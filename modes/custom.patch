diff --git a/.gitignore b/.gitignore
index ee08a605d..ecca4a344 100644
--- a/.gitignore
+++ b/.gitignore
@@ -94,3 +94,4 @@ tests/data/svg/viewbox/viewbox_*.svg
 tests/regression/pdfexporttest/centered.pdf
 tests/regression/pdfexporttest/simple-pdf.pdf
 scripts/run-clang-tidy-cached
+.aider*
diff --git a/src/Cache.h b/src/Cache.h
index 3c801bd5e..5c86ab285 100644
--- a/src/Cache.h
+++ b/src/Cache.h
@@ -52,11 +52,24 @@ template <class Key, class T>
 class Cache
 {
   struct Node {
-    inline Node() : keyPtr(nullptr), t(nullptr), c(0), p(nullptr), n(nullptr) {
+    inline Node ()
+      : keyPtr (nullptr)
+      , t (nullptr)
+      , c (0)
+      , p (nullptr)
+      , n (nullptr) {
     }
-    inline Node(T * data, size_t cost) : keyPtr(nullptr), t(data), c(cost), p(nullptr), n(nullptr) {
+    inline Node (T *data, size_t cost)
+      : keyPtr (nullptr)
+      , t (data)
+      , c (cost)
+      , p (nullptr)
+      , n (nullptr) {
     }
-    const Key *keyPtr; T *t; size_t c; Node *p, *n;
+    const Key *keyPtr;
+    T *t;
+    size_t c;
+    Node *p, *n;
   };
   using map_type = typename std::unordered_map<Key, Node>;
   using iterator_type = typename map_type::iterator;
@@ -67,25 +80,33 @@ class Cache
   void *unused{nullptr};
   size_t mx, total{0};
 
-  inline void unlink(Node& n) {
-    if (n.p) n.p->n = n.n;
-    if (n.n) n.n->p = n.p;
-    if (l == &n) l = n.p;
-    if (f == &n) f = n.n;
+  inline void unlink (Node &n) {
+    if (n.p)
+      n.p->n = n.n;
+    if (n.n)
+      n.n->p = n.p;
+    if (l == &n)
+      l = n.p;
+    if (f == &n)
+      f = n.n;
     total -= n.c;
     T *obj = n.t;
-    hash.erase(*n.keyPtr);
+    hash.erase (*n.keyPtr);
     delete obj;
   }
-  inline T *relink(const Key& key) {
-    auto i = hash.find(key);
-    if (i == hash.end()) return nullptr;
+  inline T *relink (const Key &key) {
+    auto i = hash.find (key);
+    if (i == hash.end ())
+      return nullptr;
 
-    Node& n = i->second;
+    Node &n = i->second;
     if (f != &n) {
-      if (n.p) n.p->n = n.n;
-      if (n.n) n.n->p = n.p;
-      if (l == &n) l = n.p;
+      if (n.p)
+        n.p->n = n.n;
+      if (n.n)
+        n.n->p = n.p;
+      if (l == &n)
+        l = n.p;
       n.p = nullptr;
       n.n = f;
       f->p = &n;
@@ -95,95 +116,116 @@ class Cache
   }
 
 public:
-  inline explicit Cache(size_t maxCost = 100)
-    : f(nullptr), l(nullptr), mx(maxCost) { }
-  inline ~Cache() { clear(); }
+  inline explicit Cache (size_t maxCost = 100)
+    : f (nullptr)
+    , l (nullptr)
+    , mx (maxCost) {}
+  inline ~Cache () {
+    clear ();
+  }
 
-  [[nodiscard]] inline size_t maxCost() const { return mx; }
-  void setMaxCost(size_t m) { mx = m; trim(mx); }
-  [[nodiscard]] inline size_t totalCost() const { return total; }
+  [[nodiscard]] inline size_t maxCost () const {
+    return mx;
+  }
+  void setMaxCost (size_t m) {
+    mx = m;
+    trim (mx);
+  }
+  [[nodiscard]] inline size_t totalCost () const {
+    return total;
+  }
 
-  [[nodiscard]] inline size_t size() const { return hash.size(); }
-  [[nodiscard]] inline bool empty() const { return hash.empty(); }
+  [[nodiscard]] inline size_t size () const {
+    return hash.size ();
+  }
+  [[nodiscard]] inline bool empty () const {
+    return hash.empty ();
+  }
 
-  void clear() {
+  void clear () {
     while (f) {
-      delete f->t; f = f->n;
+      delete f->t;
+      f = f->n;
     }
-    hash.clear();
+    hash.clear ();
     l = nullptr;
     total = 0;
   }
 
-  bool insert(const Key& key, T *object, size_t cost);
-  T *object(const Key& key) const { return const_cast<Cache<Key, T> *>(this)->relink(key); }
-  inline bool contains(const Key& key) const { return hash.find(key) != hash.end(); }
-  T *operator[](const Key& key) const { return object(key); }
+  bool insert (const Key &key, T *object, size_t cost);
+  T *object (const Key &key) const {
+    return const_cast<Cache<Key, T> *> (this)->relink (key);
+  }
+  inline bool contains (const Key &key) const {
+    return hash.find (key) != hash.end ();
+  }
+  T *operator[] (const Key &key) const {
+    return object (key);
+  }
 
-  bool remove(const Key& key);
-  T *take(const Key& key);
+  bool remove (const Key &key);
+  T *take (const Key &key);
 
 private:
-  void trim(size_t m);
+  void trim (size_t m);
 };
 
 template <class Key, class T>
-inline bool Cache<Key, T>::remove(const Key& key)
-{
-  auto i = hash.find(key);
-  if (i == hash.end()) {
+inline bool Cache<Key, T>::remove (const Key &key) {
+  auto i = hash.find (key);
+  if (i == hash.end ()) {
     return false;
   } else {
-    unlink(i->second);
+    unlink (i->second);
     return true;
   }
 }
 
 template <class Key, class T>
-inline T *Cache<Key, T>::take(const Key& key)
-{
-  iterator_type i = hash.find(key);
-  if (i == hash.end()) return 0;
+inline T *Cache<Key, T>::take (const Key &key) {
+  iterator_type i = hash.find (key);
+  if (i == hash.end ())
+    return 0;
 
-  Node& n = *i;
+  Node &n = *i;
   T *t = n.t;
   n.t = 0;
-  unlink(n);
+  unlink (n);
   return t;
 }
 
 template <class Key, class T>
-bool Cache<Key, T>::insert(const Key& akey, T *aobject, size_t acost)
-{
-  remove(akey);
+bool Cache<Key, T>::insert (const Key &akey, T *aobject, size_t acost) {
+  remove (akey);
   if (acost > mx) {
     delete aobject;
     return false;
   }
-  trim(mx - acost);
-  Node node(aobject, acost);
+  trim (mx - acost);
+  Node node (aobject, acost);
   hash[akey] = node;
-  auto i = hash.find(akey);
+  auto i = hash.find (akey);
   total += acost;
   Node *n = &i->second;
   n->keyPtr = &i->first;
-  if (f) f->p = n;
+  if (f)
+    f->p = n;
   n->n = f;
   f = n;
-  if (!l) l = f;
+  if (!l)
+    l = f;
   return true;
 }
 
 template <class Key, class T>
-void Cache<Key, T>::trim(size_t m)
-{
+void Cache<Key, T>::trim (size_t m) {
   Node *n = l;
   while (n && total > m) {
     Node *u = n;
     n = n->p;
 #ifdef DEBUG
-    LOG("Trimming cache: %1$s (%2$d bytes)", u->keyPtr->substr(0, 40), u->c);
+    LOG ("Trimming cache: %1$s (%2$d bytes)", u->keyPtr->substr (0, 40), u->c);
 #endif
-    unlink(*u);
+    unlink (*u);
   }
 }
diff --git a/src/Feature.cc b/src/Feature.cc
index 6b0075a7a..db96de32d 100644
--- a/src/Feature.cc
+++ b/src/Feature.cc
@@ -15,8 +15,8 @@
  * NOTE: All features double-register pointers to themselves in these two
  * structures, and can be accessed from either.
  */
-Feature::map_t Feature::feature_map;  // Double-listed values. ----v
-Feature::list_t Feature::feature_list;  // Double-listed values. --^
+Feature::map_t Feature::feature_map; // Double-listed values. ----v
+Feature::list_t Feature::feature_list; // Double-listed values. --^
 
 /*
  * List of features, the names given here are used in both command line
@@ -26,37 +26,35 @@ Feature::list_t Feature::feature_list;  // Double-listed values. --^
  * (well-defined) order of object construction, matching the order of the
  * const Features listed below.
  */
-const Feature Feature::ExperimentalRoof("roof", "Enable <code>roof</code>");
-const Feature Feature::ExperimentalInputDriverDBus("input-driver-dbus", "Enable DBus input drivers (requires restart)");
-const Feature Feature::ExperimentalLazyUnion("lazy-union", "Enable lazy unions.");
-const Feature Feature::ExperimentalVxORenderersIndexing("vertex-object-renderers-indexing", "Enable indexing in vertex object renderers");
-const Feature Feature::ExperimentalTextMetricsFunctions("textmetrics", "Enable the <code>textmetrics()</code> and <code>fontmetrics()</code> functions.");
-const Feature Feature::ExperimentalImportFunction("import-function", "Enable import function returning data instead of geometry.");
-const Feature Feature::ExperimentalObjectFunction("object-function", "Enable object function to allow user creation of objects.");
-const Feature Feature::ExperimentalPredictibleOutput("predictible-output", "Attempt to produce predictible, diffable outputs (e.g. sorting the STL, or remeshing in a determined order)");
+const Feature Feature::ExperimentalRoof ("roof", "Enable <code>roof</code>");
+const Feature Feature::ExperimentalInputDriverDBus ("input-driver-dbus", "Enable DBus input drivers (requires restart)");
+const Feature Feature::ExperimentalLazyUnion ("lazy-union", "Enable lazy unions.");
+const Feature Feature::ExperimentalVxORenderersIndexing ("vertex-object-renderers-indexing", "Enable indexing in vertex object renderers");
+const Feature Feature::ExperimentalTextMetricsFunctions ("textmetrics", "Enable the <code>textmetrics()</code> and <code>fontmetrics()</code> functions.");
+const Feature Feature::ExperimentalImportFunction ("import-function", "Enable import function returning data instead of geometry.");
+const Feature Feature::ExperimentalObjectFunction ("object-function", "Enable object function to allow user creation of objects.");
+const Feature Feature::ExperimentalPredictibleOutput ("predictible-output", "Attempt to produce predictible, diffable outputs (e.g. sorting the STL, or remeshing in a determined order)");
 #ifdef ENABLE_PYTHON
-const Feature Feature::ExperimentalPythonEngine("python-engine", "Enable experimental Python Engine (implies risk of malicious scripts downloaded).");
+const Feature Feature::ExperimentalPythonEngine ("python-engine", "Enable experimental Python Engine (implies risk of malicious scripts downloaded).");
 #endif
 
-Feature::Feature(const std::string& name, std::string description, bool hidden)
-  : name(name), description(std::move(description))
-{
+Feature::Feature (const std::string &name, std::string description, bool hidden)
+  : name (name)
+  , description (std::move (description)) {
   feature_map[name] = this;
-  if (!hidden) feature_list.push_back(this);
+  if (!hidden)
+    feature_list.push_back (this);
 }
 
-const std::string& Feature::get_name() const
-{
+const std::string &Feature::get_name () const {
   return name;
 }
 
-const std::string& Feature::get_description() const
-{
+const std::string &Feature::get_description () const {
   return description;
 }
 
-bool Feature::is_enabled() const
-{
+bool Feature::is_enabled () const {
 #ifdef ENABLE_EXPERIMENTAL
   return enabled;
 #else
@@ -64,57 +62,48 @@ bool Feature::is_enabled() const
 #endif
 }
 
-void Feature::enable(bool status)
-{
+void Feature::enable (bool status) {
   enabled = status;
 }
 
 // Note, features are also accessed by iterator with begin/end.
-void Feature::enable_feature(const std::string& feature_name, bool status)
-{
-  auto it = feature_map.find(feature_name);
-  if (it != feature_map.end()) {
-    it->second->enable(status);
+void Feature::enable_feature (const std::string &feature_name, bool status) {
+  auto it = feature_map.find (feature_name);
+  if (it != feature_map.end ()) {
+    it->second->enable (status);
   } else {
-    LOG(message_group::Warning, "Ignoring request to enable unknown feature '%1$s'.", feature_name);
+    LOG (message_group::Warning, "Ignoring request to enable unknown feature '%1$s'.", feature_name);
   }
 }
 
-void Feature::enable_all(bool status)
-{
-  for (const auto& f : boost::make_iterator_range(Feature::begin(), Feature::end())) {
-    f->enable(status);
+void Feature::enable_all (bool status) {
+  for (const auto &f : boost::make_iterator_range (Feature::begin (), Feature::end ())) {
+    f->enable (status);
   }
 }
 
-Feature::iterator Feature::begin()
-{
-  return feature_list.begin();
+Feature::iterator Feature::begin () {
+  return feature_list.begin ();
 }
 
-Feature::iterator Feature::end()
-{
-  return feature_list.end();
+Feature::iterator Feature::end () {
+  return feature_list.end ();
 }
 
-std::string Feature::features()
-{
-  const auto seq = boost::make_iterator_range(Feature::begin(), Feature::end());
-  const auto str = [](const Feature *const f) {
-      return (boost::format("%s%s") % f->get_name() % (f->is_enabled() ? "*" : "")).str();
-    };
-  return boost::algorithm::join(boost::adaptors::transform(seq, str), ", ");
+std::string Feature::features () {
+  const auto seq = boost::make_iterator_range (Feature::begin (), Feature::end ());
+  const auto str = [] (const Feature *const f) {
+    return (boost::format ("%s%s") % f->get_name () % (f->is_enabled () ? "*" : "")).str ();
+  };
+  return boost::algorithm::join (boost::adaptors::transform (seq, str), ", ");
 }
 
-ExperimentalFeatureException::ExperimentalFeatureException(const std::string& what_arg)
-  : EvaluationException(what_arg)
-{
-
+ExperimentalFeatureException::ExperimentalFeatureException (const std::string &what_arg)
+  : EvaluationException (what_arg) {
 }
 
-void ExperimentalFeatureException::check(const Feature& feature)
-{
-  if (!feature.is_enabled()) {
-    throw ExperimentalFeatureException(STR("ERROR: Experimental feature not enabled: '", feature.get_name(), "'. Please check preferences."));
+void ExperimentalFeatureException::check (const Feature &feature) {
+  if (!feature.is_enabled ()) {
+    throw ExperimentalFeatureException (STR ("ERROR: Experimental feature not enabled: '", feature.get_name (), "'. Please check preferences."));
   }
 }
diff --git a/src/Feature.h b/src/Feature.h
index d475de6f9..82612c758 100644
--- a/src/Feature.h
+++ b/src/Feature.h
@@ -25,23 +25,23 @@ public:
 #endif
 
 #ifdef ENABLE_GUI_TESTS
-  static constexpr bool HasGuiTesting {true};
+  static constexpr bool HasGuiTesting{true};
 #else
-  static constexpr bool HasGuiTesting {false};
+  static constexpr bool HasGuiTesting{false};
 #endif
 
-  [[nodiscard]] const std::string& get_name() const;
-  [[nodiscard]] const std::string& get_description() const;
+  [[nodiscard]] const std::string &get_name () const;
+  [[nodiscard]] const std::string &get_description () const;
 
-  [[nodiscard]] bool is_enabled() const;
-  void enable(bool status);
+  [[nodiscard]] bool is_enabled () const;
+  void enable (bool status);
 
-  static iterator begin();
-  static iterator end();
+  static iterator begin ();
+  static iterator end ();
 
-  static std::string features();
-  static void enable_feature(const std::string& feature_name, bool status = true);
-  static void enable_all(bool status = true);
+  static std::string features ();
+  static void enable_feature (const std::string &feature_name, bool status = true);
+  static void enable_all (bool status = true);
 
 private:
   bool enabled{false};
@@ -53,15 +53,15 @@ private:
   static map_t feature_map;
   static list_t feature_list;
 
-  Feature(const std::string& name, std::string description, bool hidden = false);
-  virtual ~Feature() = default;
+  Feature (const std::string &name, std::string description, bool hidden = false);
+  virtual ~Feature () = default;
 };
 
 class ExperimentalFeatureException : public EvaluationException
 {
 public:
-  static void check(const Feature& feature);
+  static void check (const Feature &feature);
 
 private:
-  ExperimentalFeatureException(const std::string& what_arg);
+  ExperimentalFeatureException (const std::string &what_arg);
 };
diff --git a/src/FontCache.cc b/src/FontCache.cc
index 39f440729..437a39ca4 100644
--- a/src/FontCache.cc
+++ b/src/FontCache.cc
@@ -53,37 +53,35 @@ std::vector<std::string> fontpath;
 
 namespace fs = std::filesystem;
 
-std::string get_fontconfig_version()
-{
-  const unsigned int version = FcGetVersion();
+std::string get_fontconfig_version () {
+  const unsigned int version = FcGetVersion ();
 
   const OpenSCAD::library_version_number header_version{FC_MAJOR, FC_MINOR, FC_REVISION};
   const OpenSCAD::library_version_number runtime_version{version / 10000, (version / 100) % 100, version % 100};
-  return OpenSCAD::get_version_string(header_version, runtime_version);
+  return OpenSCAD::get_version_string (header_version, runtime_version);
 }
 
-std::string get_harfbuzz_version()
-{
+std::string get_harfbuzz_version () {
   unsigned int major, minor, micro;
-  hb_version(&major, &minor, &micro);
+  hb_version (&major, &minor, &micro);
 
   const OpenSCAD::library_version_number header_version{HB_VERSION_MAJOR, HB_VERSION_MINOR, HB_VERSION_MICRO};
   const OpenSCAD::library_version_number runtime_version{major, minor, micro};
-  return OpenSCAD::get_version_string(header_version, runtime_version);
+  return OpenSCAD::get_version_string (header_version, runtime_version);
 }
 
-std::string get_freetype_version()
-{
-  return FontCache::instance()->get_freetype_version();
+std::string get_freetype_version () {
+  return FontCache::instance ()->get_freetype_version ();
 }
 
-FontInfo::FontInfo(std::string family, std::string style, std::string file, uint32_t hash)
-  : family(std::move(family)), style(std::move(style)), file(std::move(file)), hash(hash)
-{
+FontInfo::FontInfo (std::string family, std::string style, std::string file, uint32_t hash)
+  : family (std::move (family))
+  , style (std::move (style))
+  , file (std::move (file))
+  , hash (hash) {
 }
 
-bool FontInfo::operator<(const FontInfo& rhs) const
-{
+bool FontInfo::operator< (const FontInfo &rhs) const {
   if (family < rhs.family) {
     return true;
   }
@@ -93,384 +91,370 @@ bool FontInfo::operator<(const FontInfo& rhs) const
   return file < rhs.file;
 }
 
-const std::string& FontInfo::get_family() const
-{
+const std::string &FontInfo::get_family () const {
   return family;
 }
 
-const std::string& FontInfo::get_style() const
-{
+const std::string &FontInfo::get_style () const {
   return style;
 }
 
-const std::string& FontInfo::get_file() const
-{
+const std::string &FontInfo::get_file () const {
   return file;
 }
 
-const uint32_t FontInfo::get_hash() const
-{
+const uint32_t FontInfo::get_hash () const {
   return hash;
 }
 
 FontCache *FontCache::self = nullptr;
 FontCache::InitHandlerFunc *FontCache::cb_handler = FontCache::defaultInitHandler;
 void *FontCache::cb_userdata = nullptr;
-const std::string FontCache::DEFAULT_FONT("Liberation Sans:style=Regular");
+const std::string FontCache::DEFAULT_FONT ("Liberation Sans:style=Regular");
 
 /**
  * Default implementation for the font cache initialization. In case no other
  * handler is registered, the cache build is just called synchronously in the
  * current thread by this handler.
  */
-void FontCache::defaultInitHandler(FontCacheInitializer *initializer, void *)
-{
-  initializer->run();
+void FontCache::defaultInitHandler (FontCacheInitializer *initializer, void *) {
+  initializer->run ();
 }
 
-FontCache::FontCache()
-{
+FontCache::FontCache () {
   this->init_ok = false;
   this->library = nullptr;
 
   // If we've got a bundled fonts.conf, initialize fontconfig with our own config
   // by overriding the built-in fontconfig path.
   // For system installs and dev environments, we leave this alone
-  const fs::path fontdir(PlatformUtils::resourcePath("fonts"));
-  if (fs::is_regular_file(fontdir / "fonts.conf")) {
-    auto abspath = fontdir.empty() ? fs::current_path() : fs::absolute(fontdir);
-    PlatformUtils::setenv("FONTCONFIG_PATH", (abspath.generic_string()).c_str(), 0);
+  const fs::path fontdir (PlatformUtils::resourcePath ("fonts"));
+  if (fs::is_regular_file (fontdir / "fonts.conf")) {
+    auto abspath = fontdir.empty () ? fs::current_path () : fs::absolute (fontdir);
+    PlatformUtils::setenv ("FONTCONFIG_PATH", (abspath.generic_string ()).c_str (), 0);
   }
 
   // Just load the configs. We'll build the fonts once all configs are loaded
-  this->config = FcInitLoadConfig();
+  this->config = FcInitLoadConfig ();
   if (!this->config) {
-    LOG(message_group::Font_Warning, "Can't initialize fontconfig library, text() objects will not be rendered");
+    LOG (message_group::Font_Warning, "Can't initialize fontconfig library, text() objects will not be rendered");
     return;
   }
 
   // Add the built-in fonts & config
-  fs::path builtinfontpath(PlatformUtils::resourcePath("fonts"));
-  if (fs::is_directory(builtinfontpath)) {
+  fs::path builtinfontpath (PlatformUtils::resourcePath ("fonts"));
+  if (fs::is_directory (builtinfontpath)) {
 #ifndef __EMSCRIPTEN__
-    builtinfontpath = fs::canonical(builtinfontpath);
+    builtinfontpath = fs::canonical (builtinfontpath);
 #endif
-    FcConfigParseAndLoad(this->config, reinterpret_cast<const FcChar8 *>(builtinfontpath.generic_string().c_str()), false);
-    add_font_dir(builtinfontpath.generic_string());
+    FcConfigParseAndLoad (this->config, reinterpret_cast<const FcChar8 *> (builtinfontpath.generic_string ().c_str ()), false);
+    add_font_dir (builtinfontpath.generic_string ());
   }
 
-  const char *home = getenv("HOME");
+  const char *home = getenv ("HOME");
 
   // Add Linux font folders, the system folders are expected to be
   // configured by the system configuration for fontconfig.
   if (home) {
-    add_font_dir(std::string(home) + "/.fonts");
+    add_font_dir (std::string (home) + "/.fonts");
   }
 
-  const char *env_font_path = getenv("OPENSCAD_FONT_PATH");
+  const char *env_font_path = getenv ("OPENSCAD_FONT_PATH");
   if (env_font_path != nullptr) {
-    std::string paths(env_font_path);
-    const std::string sep = PlatformUtils::pathSeparatorChar();
+    std::string paths (env_font_path);
+    const std::string sep = PlatformUtils::pathSeparatorChar ();
     using string_split_iterator = boost::split_iterator<std::string::iterator>;
-    for (string_split_iterator it = boost::make_split_iterator(paths, boost::first_finder(sep, boost::is_iequal())); it != string_split_iterator(); ++it) {
-      const fs::path p(boost::copy_range<std::string>(*it));
-      if (fs::exists(p) && fs::is_directory(p)) {
-        const std::string path = fs::absolute(p).string();
-        add_font_dir(path);
+    for (string_split_iterator it = boost::make_split_iterator (paths, boost::first_finder (sep, boost::is_iequal ())); it != string_split_iterator (); ++it) {
+      const fs::path p (boost::copy_range<std::string> (*it));
+      if (fs::exists (p) && fs::is_directory (p)) {
+        const std::string path = fs::absolute (p).string ();
+        add_font_dir (path);
       }
     }
   }
 
-  FontCacheInitializer initializer(this->config);
-  cb_handler(&initializer, cb_userdata);
+  FontCacheInitializer initializer (this->config);
+  cb_handler (&initializer, cb_userdata);
 
   // For use by LibraryInfo
-  FcStrList *dirs = FcConfigGetFontDirs(this->config);
-  while (FcChar8 *dir = FcStrListNext(dirs)) {
-    fontpath.emplace_back((const char *)dir);
+  FcStrList *dirs = FcConfigGetFontDirs (this->config);
+  while (FcChar8 *dir = FcStrListNext (dirs)) {
+    fontpath.emplace_back ((const char *)dir);
   }
-  FcStrListDone(dirs);
+  FcStrListDone (dirs);
 
-  const FT_Error error = FT_Init_FreeType(&this->library);
+  const FT_Error error = FT_Init_FreeType (&this->library);
   if (error) {
-    LOG(message_group::Font_Warning, "Can't initialize freetype library, text() objects will not be rendered");
+    LOG (message_group::Font_Warning, "Can't initialize freetype library, text() objects will not be rendered");
     return;
   }
 
   this->init_ok = true;
 }
 
-FontCache *FontCache::instance()
-{
+FontCache *FontCache::instance () {
   if (!self) {
-    self = new FontCache();
+    self = new FontCache ();
   }
   return self;
 }
 
-const std::string FontCache::get_freetype_version() const
-{
-  if (!this->is_init_ok()) {
+const std::string FontCache::get_freetype_version () const {
+  if (!this->is_init_ok ()) {
     return "(not initialized)";
   }
 
   FT_Int major, minor, micro;
-  FT_Library_Version(this->library, &major, &minor, &micro);
+  FT_Library_Version (this->library, &major, &minor, &micro);
 
   const OpenSCAD::library_version_number header_version{FREETYPE_MAJOR, FREETYPE_MINOR, FREETYPE_PATCH};
-  const OpenSCAD::library_version_number runtime_version{static_cast<unsigned>(major), static_cast<unsigned>(minor), static_cast<unsigned>(micro)};
-  return OpenSCAD::get_version_string(header_version, runtime_version);
+  const OpenSCAD::library_version_number runtime_version{static_cast<unsigned> (major), static_cast<unsigned> (minor), static_cast<unsigned> (micro)};
+  return OpenSCAD::get_version_string (header_version, runtime_version);
 }
 
-void FontCache::registerProgressHandler(InitHandlerFunc *handler, void *userdata)
-{
+void FontCache::registerProgressHandler (InitHandlerFunc *handler, void *userdata) {
   FontCache::cb_handler = handler;
   FontCache::cb_userdata = userdata;
 }
 
-void FontCache::register_font_file(const std::string& path)
-{
-  if (!FcConfigAppFontAddFile(this->config, reinterpret_cast<const FcChar8 *>(path.c_str()))) {
-    LOG("Can't register font '%1$s'", path);
+void FontCache::register_font_file (const std::string &path) {
+  if (!FcConfigAppFontAddFile (this->config, reinterpret_cast<const FcChar8 *> (path.c_str ()))) {
+    LOG ("Can't register font '%1$s'", path);
   }
 }
 
-void FontCache::add_font_dir(const std::string& path)
-{
-  if (!fs::is_directory(path)) {
+void FontCache::add_font_dir (const std::string &path) {
+  if (!fs::is_directory (path)) {
     return;
   }
-  if (!FcConfigAppFontAddDir(this->config, reinterpret_cast<const FcChar8 *>(path.c_str()))) {
-    LOG("Can't register font directory '%1$s'", path);
+  if (!FcConfigAppFontAddDir (this->config, reinterpret_cast<const FcChar8 *> (path.c_str ()))) {
+    LOG ("Can't register font directory '%1$s'", path);
   }
 }
 
-std::vector<uint32_t> FontCache::filter(const std::u32string& str) const
-{
-  FcObjectSet *object_set = FcObjectSetBuild(FC_FAMILY, FC_STYLE, FC_FILE, nullptr);
-  FcPattern *pattern = FcPatternCreate();
-  init_pattern(pattern);
-  FcCharSet *charSet = FcCharSetCreate();
+std::vector<uint32_t> FontCache::filter (const std::u32string &str) const {
+  FcObjectSet *object_set = FcObjectSetBuild (FC_FAMILY, FC_STYLE, FC_FILE, nullptr);
+  FcPattern *pattern = FcPatternCreate ();
+  init_pattern (pattern);
+  FcCharSet *charSet = FcCharSetCreate ();
   for (const char32_t a : str) {
-    FcCharSetAddChar(charSet, a);
+    FcCharSetAddChar (charSet, a);
   }
   FcValue charSetValue;
   charSetValue.type = FcTypeCharSet;
   charSetValue.u.c = charSet;
-  FcPatternAdd(pattern, FC_CHARSET, charSetValue, true);
+  FcPatternAdd (pattern, FC_CHARSET, charSetValue, true);
 
-  FcFontSet *font_set = FcFontList(this->config, pattern, object_set);
-  FcObjectSetDestroy(object_set);
-  FcPatternDestroy(pattern);
-  FcCharSetDestroy(charSet);
+  FcFontSet *font_set = FcFontList (this->config, pattern, object_set);
+  FcObjectSetDestroy (object_set);
+  FcPatternDestroy (pattern);
+  FcCharSetDestroy (charSet);
 
   std::vector<uint32_t> result;
-  result.reserve(font_set->nfont);
+  result.reserve (font_set->nfont);
   for (int a = 0; a < font_set->nfont; ++a) {
-    result.push_back(FcPatternHash(font_set->fonts[a]));
+    result.push_back (FcPatternHash (font_set->fonts[a]));
   }
-  FcFontSetDestroy(font_set);
+  FcFontSetDestroy (font_set);
   return result;
 }
 
-FontInfoList *FontCache::list_fonts() const
-{
-  FcObjectSet *object_set = FcObjectSetBuild(FC_FAMILY, FC_STYLE, FC_FILE, nullptr);
-  FcPattern *pattern = FcPatternCreate();
-  init_pattern(pattern);
-  FcFontSet *font_set = FcFontList(this->config, pattern, object_set);
-  FcObjectSetDestroy(object_set);
-  FcPatternDestroy(pattern);
+FontInfoList *FontCache::list_fonts () const {
+  FcObjectSet *object_set = FcObjectSetBuild (FC_FAMILY, FC_STYLE, FC_FILE, nullptr);
+  FcPattern *pattern = FcPatternCreate ();
+  init_pattern (pattern);
+  FcFontSet *font_set = FcFontList (this->config, pattern, object_set);
+  FcObjectSetDestroy (object_set);
+  FcPatternDestroy (pattern);
 
-  auto *list = new FontInfoList();
+  auto *list = new FontInfoList ();
   for (int a = 0; a < font_set->nfont; ++a) {
     FcPattern *p = font_set->fonts[a];
 
     FcChar8 *file_value;
-    if (FcPatternGetString(p, FC_FILE, 0, &file_value) != FcResultMatch) {
+    if (FcPatternGetString (p, FC_FILE, 0, &file_value) != FcResultMatch) {
       continue;
     }
 
     FcChar8 *family_value;
-    if (FcPatternGetString(p, FC_FAMILY, 0, &family_value) != FcResultMatch) {
+    if (FcPatternGetString (p, FC_FAMILY, 0, &family_value) != FcResultMatch) {
       continue;
     }
 
     FcChar8 *style_value;
-    if (FcPatternGetString(p, FC_STYLE, 0, &style_value) != FcResultMatch) {
+    if (FcPatternGetString (p, FC_STYLE, 0, &style_value) != FcResultMatch) {
       continue;
     }
 
-    const std::string family((const char *) family_value);
-    const std::string style((const char *) style_value);
-    const std::string file((const char *) file_value);
+    const std::string family ((const char *)family_value);
+    const std::string style ((const char *)style_value);
+    const std::string file ((const char *)file_value);
 
-    list->emplace_back(family, style, file, FcPatternHash(p));
+    list->emplace_back (family, style, file, FcPatternHash (p));
   }
-  FcFontSetDestroy(font_set);
+  FcFontSetDestroy (font_set);
 
   return list;
 }
 
-bool FontCache::is_init_ok() const
-{
+bool FontCache::is_init_ok () const {
   return this->init_ok;
 }
 
-void FontCache::clear()
-{
-  this->cache.clear();
+void FontCache::clear () {
+  this->cache.clear ();
 }
 
-void FontCache::dump_cache(const std::string& info)
-{
+void FontCache::dump_cache (const std::string &info) {
   std::cout << info << ":";
-  for (const auto& item : this->cache) {
+  for (const auto &item : this->cache) {
     std::cout << " " << item.first << " (" << item.second.second << ")";
   }
   std::cout << std::endl;
 }
 
-void FontCache::check_cleanup()
-{
-  if (this->cache.size() < MAX_NR_OF_CACHE_ENTRIES) {
+void FontCache::check_cleanup () {
+  if (this->cache.size () < MAX_NR_OF_CACHE_ENTRIES) {
     return;
   }
 
-  auto pos = this->cache.begin()++;
-  for (auto it = this->cache.begin(); it != this->cache.end(); ++it) {
+  auto pos = this->cache.begin ()++;
+  for (auto it = this->cache.begin (); it != this->cache.end (); ++it) {
     if ((*pos).second.second > (*it).second.second) {
       pos = it;
     }
   }
   FontFacePtr face = (*pos).second.first;
-  this->cache.erase(pos);
+  this->cache.erase (pos);
 }
 
-FontFacePtr FontCache::get_font(const std::string& font)
-{
+FontFacePtr FontCache::get_font (const std::string &font) {
   FontFacePtr face;
-  auto it = this->cache.find(font);
-  if (it == this->cache.end()) {
-    face = find_face(font);
+  auto it = this->cache.find (font);
+  if (it == this->cache.end ()) {
+    face = find_face (font);
     if (!face) {
       return nullptr;
     }
-    check_cleanup();
+    check_cleanup ();
   } else {
     face = (*it).second.first;
   }
-  this->cache[font] = cache_entry_t(face, time(nullptr));
+  this->cache[font] = cache_entry_t (face, time (nullptr));
   return face;
 }
 
-FontFacePtr FontCache::find_face(const std::string& font) const
-{
-  std::string trimmed(font);
-  boost::algorithm::trim(trimmed);
+FontFacePtr FontCache::find_face (const std::string &font) const {
+  std::string trimmed (font);
+  boost::algorithm::trim (trimmed);
 
-  const std::string lookup = trimmed.empty() ? DEFAULT_FONT : trimmed;
-  PRINTDB("font = \"%s\", lookup = \"%s\"", font % lookup);
-  FontFacePtr face = find_face_fontconfig(lookup);
+  const std::string lookup = trimmed.empty () ? DEFAULT_FONT : trimmed;
+  PRINTDB ("font = \"%s\", lookup = \"%s\"", font % lookup);
+  FontFacePtr face = find_face_fontconfig (lookup);
   if (face) {
-    PRINTDB("result = \"%s\", style = \"%s\"", face->face_->family_name % face->face_->style_name);
+    PRINTDB ("result = \"%s\", style = \"%s\"", face->face_->family_name % face->face_->style_name);
   } else {
-    PRINTD("font not found");
+    PRINTD ("font not found");
   }
   return face;
 }
 
-void FontCache::init_pattern(FcPattern *pattern) const
-{
-  assert(pattern);
+void FontCache::init_pattern (FcPattern *pattern) const {
+  assert (pattern);
   const FcValue true_value = {
     .type = FcTypeBool,
     .u = {.b = true},
   };
 
-  FcPatternAdd(pattern, FC_OUTLINE, true_value, true);
-  FcPatternAdd(pattern, FC_SCALABLE, true_value, true);
+  FcPatternAdd (pattern, FC_OUTLINE, true_value, true);
+  FcPatternAdd (pattern, FC_SCALABLE, true_value, true);
 }
 
-FontFacePtr FontCache::find_face_fontconfig(const std::string& font) const
-{
+FontFacePtr FontCache::find_face_fontconfig (const std::string &font) const {
   FcResult result;
 
-  FcPattern *pattern = FcNameParse((unsigned char *)font.c_str());
+  FcPattern *pattern = FcNameParse ((unsigned char *)font.c_str ());
   if (!pattern) {
-    LOG(message_group::Font_Warning, "Could not parse font '%1$s'", font);
+    LOG (message_group::Font_Warning, "Could not parse font '%1$s'", font);
     return nullptr;
   }
-  init_pattern(pattern);
+  init_pattern (pattern);
 
-  FcConfigSubstitute(this->config, pattern, FcMatchPattern);
-  FcDefaultSubstitute(pattern);
+  FcConfigSubstitute (this->config, pattern, FcMatchPattern);
+  FcDefaultSubstitute (pattern);
 
-  FcPattern *match = FcFontMatch(this->config, pattern, &result);
+  FcPattern *match = FcFontMatch (this->config, pattern, &result);
 
   FcChar8 *file_value;
-  if (FcPatternGetString(match, FC_FILE, 0, &file_value) != FcResultMatch) {
+  if (FcPatternGetString (match, FC_FILE, 0, &file_value) != FcResultMatch) {
     return nullptr;
   }
 
   int font_index;
-  if (FcPatternGetInteger(match, FC_INDEX, 0, &font_index) != FcResultMatch) {
+  if (FcPatternGetInteger (match, FC_INDEX, 0, &font_index) != FcResultMatch) {
     return nullptr;
   }
 
   FcChar8 *font_features;
   std::string font_features_str;
-  if (FcPatternGetString(match, FC_FONT_FEATURES, 0, &font_features) == FcResultMatch) {
+  if (FcPatternGetString (match, FC_FONT_FEATURES, 0, &font_features) == FcResultMatch) {
     font_features_str = (const char *)(font_features);
-    PRINTDB("Found font features: '%s'", font_features_str);
+    PRINTDB ("Found font features: '%s'", font_features_str);
   }
 
   FT_Face ftFace;
-  const FT_Error error = FT_New_Face(this->library, (const char *)file_value, font_index, &ftFace);
+  const FT_Error error = FT_New_Face (this->library, (const char *)file_value, font_index, &ftFace);
 
-  FcPatternDestroy(pattern);
-  FcPatternDestroy(match);
+  FcPatternDestroy (pattern);
+  FcPatternDestroy (match);
 
   if (error) {
     return nullptr;
   }
 
   std::vector<std::string> features;
-  boost::split(features, font_features_str, boost::is_any_of(";"));
-  FontFacePtr face = std::make_shared<const FontFace>(ftFace, features);
+  boost::split (features, font_features_str, boost::is_any_of (";"));
+  FontFacePtr face = std::make_shared<const FontFace> (ftFace, features);
 
   for (int a = 0; a < face->face_->num_charmaps; ++a) {
     FT_CharMap charmap = face->face_->charmaps[a];
-    PRINTDB("charmap = %d: platform = %d, encoding = %d", a % charmap->platform_id % charmap->encoding_id);
+    PRINTDB ("charmap = %d: platform = %d, encoding = %d", a % charmap->platform_id % charmap->encoding_id);
   }
 
-  if (FT_Select_Charmap(face->face_, ft_encoding_unicode) == 0) {
-    PRINTDB("Successfully selected unicode charmap: %s/%s", face->face_->family_name % face->face_->style_name);
+  if (FT_Select_Charmap (face->face_, ft_encoding_unicode) == 0) {
+    PRINTDB ("Successfully selected unicode charmap: %s/%s", face->face_->family_name % face->face_->style_name);
   } else {
     bool charmap_set = false;
-    if (!charmap_set) charmap_set = try_charmap(face, TT_PLATFORM_MICROSOFT, TT_MS_ID_UNICODE_CS);
-    if (!charmap_set) charmap_set = try_charmap(face, TT_PLATFORM_ISO, TT_ISO_ID_10646);
-    if (!charmap_set) charmap_set = try_charmap(face, TT_PLATFORM_APPLE_UNICODE, -1);
-    if (!charmap_set) charmap_set = try_charmap(face, TT_PLATFORM_MICROSOFT, TT_MS_ID_SYMBOL_CS);
-    if (!charmap_set) charmap_set = try_charmap(face, TT_PLATFORM_MACINTOSH, TT_MAC_ID_ROMAN);
-    if (!charmap_set) charmap_set = try_charmap(face, TT_PLATFORM_ISO, TT_ISO_ID_8859_1);
-    if (!charmap_set) charmap_set = try_charmap(face, TT_PLATFORM_ISO, TT_ISO_ID_7BIT_ASCII);
-    if (!charmap_set) LOG(message_group::Font_Warning, "Could not select a char map for font '%1$s/%2$s'", face->face_->family_name, face->face_->style_name);
+    if (!charmap_set)
+      charmap_set = try_charmap (face, TT_PLATFORM_MICROSOFT, TT_MS_ID_UNICODE_CS);
+    if (!charmap_set)
+      charmap_set = try_charmap (face, TT_PLATFORM_ISO, TT_ISO_ID_10646);
+    if (!charmap_set)
+      charmap_set = try_charmap (face, TT_PLATFORM_APPLE_UNICODE, -1);
+    if (!charmap_set)
+      charmap_set = try_charmap (face, TT_PLATFORM_MICROSOFT, TT_MS_ID_SYMBOL_CS);
+    if (!charmap_set)
+      charmap_set = try_charmap (face, TT_PLATFORM_MACINTOSH, TT_MAC_ID_ROMAN);
+    if (!charmap_set)
+      charmap_set = try_charmap (face, TT_PLATFORM_ISO, TT_ISO_ID_8859_1);
+    if (!charmap_set)
+      charmap_set = try_charmap (face, TT_PLATFORM_ISO, TT_ISO_ID_7BIT_ASCII);
+    if (!charmap_set)
+      LOG (message_group::Font_Warning, "Could not select a char map for font '%1$s/%2$s'", face->face_->family_name, face->face_->style_name);
   }
 
   return face;
 }
 
-bool FontCache::try_charmap(const FontFacePtr& face_ptr, int platform_id, int encoding_id) const
-{
+bool FontCache::try_charmap (const FontFacePtr &face_ptr, int platform_id, int encoding_id) const {
   FT_Face face = face_ptr->face_;
   for (int idx = 0; idx < face->num_charmaps; ++idx) {
     FT_CharMap charmap = face->charmaps[idx];
     if ((charmap->platform_id == platform_id) && ((encoding_id < 0) || (charmap->encoding_id == encoding_id))) {
-      if (FT_Set_Charmap(face, charmap) == 0) {
-        PRINTDB("Selected charmap: platform_id = %d, encoding_id = %d", charmap->platform_id % charmap->encoding_id);
-        if (is_windows_symbol_font(face)) {
-          PRINTDB("Detected windows symbol font with character codes in the Private Use Area of Unicode at 0xf000: %s/%s", face->family_name % face->style_name);
+      if (FT_Set_Charmap (face, charmap) == 0) {
+        PRINTDB ("Selected charmap: platform_id = %d, encoding_id = %d", charmap->platform_id % charmap->encoding_id);
+        if (is_windows_symbol_font (face)) {
+          PRINTDB ("Detected windows symbol font with character codes in the Private Use Area of Unicode at 0xf000: %s/%s", face->family_name % face->style_name);
         }
         return true;
       }
@@ -479,8 +463,7 @@ bool FontCache::try_charmap(const FontFacePtr& face_ptr, int platform_id, int en
   return false;
 }
 
-bool FontCache::is_windows_symbol_font(const FT_Face& face) const
-{
+bool FontCache::is_windows_symbol_font (const FT_Face &face) const {
   if (face->charmap->platform_id != TT_PLATFORM_MICROSOFT) {
     return false;
   }
@@ -490,7 +473,7 @@ bool FontCache::is_windows_symbol_font(const FT_Face& face) const
   }
 
   FT_UInt gindex;
-  const FT_ULong charcode = FT_Get_First_Char(face, &gindex);
+  const FT_ULong charcode = FT_Get_First_Char (face, &gindex);
   if ((gindex == 0) || (charcode < 0xf000)) {
     return false;
   }
diff --git a/src/FontCache.h b/src/FontCache.h
index a4b69198d..1fac6746b 100644
--- a/src/FontCache.h
+++ b/src/FontCache.h
@@ -38,21 +38,22 @@
 #include FT_FREETYPE_H
 #include <fontconfig/fontconfig.h>
 
-std::string get_fontconfig_version();
-std::string get_harfbuzz_version();
-std::string get_freetype_version();
+std::string get_fontconfig_version ();
+std::string get_harfbuzz_version ();
+std::string get_freetype_version ();
 
 class FontInfo
 {
 public:
-  FontInfo(std::string family, std::string style, std::string file, uint32_t hash);
-  virtual ~FontInfo() = default;
-
-  [[nodiscard]] const std::string& get_family() const;
-  [[nodiscard]] const std::string& get_style() const;
-  [[nodiscard]] const std::string& get_file() const;
-  [[nodiscard]] const uint32_t get_hash() const;
-  bool operator<(const FontInfo& rhs) const;
+  FontInfo (std::string family, std::string style, std::string file, uint32_t hash);
+  virtual ~FontInfo () = default;
+
+  [[nodiscard]] const std::string &get_family () const;
+  [[nodiscard]] const std::string &get_style () const;
+  [[nodiscard]] const std::string &get_file () const;
+  [[nodiscard]] const uint32_t get_hash () const;
+  bool operator< (const FontInfo &rhs) const;
+
 private:
   std::string family;
   std::string style;
@@ -70,23 +71,27 @@ using FontInfoList = std::vector<FontInfo>;
 class FontCacheInitializer
 {
 public:
-  FontCacheInitializer(FcConfig *config) : config(config) { }
-  void run() { FcConfigBuildFonts(config); }
+  FontCacheInitializer (FcConfig *config)
+    : config (config) {}
+  void run () {
+    FcConfigBuildFonts (config);
+  }
+
 private:
   FcConfig *config;
 };
 
-struct FontFace
-{
+struct FontFace {
   FT_Face face_;
   std::vector<std::string> features_;
 
-  FontFace(FT_Face face, std::vector<std::string> features)
-    : face_(face), features_(std::move(features)) {
+  FontFace (FT_Face face, std::vector<std::string> features)
+    : face_ (face)
+    , features_ (std::move (features)) {
   }
 
-  virtual ~FontFace() {
-    FT_Done_Face(face_);
+  virtual ~FontFace () {
+    FT_Done_Face (face_);
   }
 };
 
@@ -98,22 +103,22 @@ public:
   const static std::string DEFAULT_FONT;
   const static unsigned int MAX_NR_OF_CACHE_ENTRIES = 5;
 
-  FontCache();
-  virtual ~FontCache() = default;
+  FontCache ();
+  virtual ~FontCache () = default;
 
-  [[nodiscard]] bool is_init_ok() const;
-  FontFacePtr get_font(const std::string& font);
-  [[nodiscard]] bool is_windows_symbol_font(const FT_Face& face) const;
-  void register_font_file(const std::string& path);
-  void clear();
-  [[nodiscard]] FontInfoList *list_fonts() const;
-  [[nodiscard]] std::vector<uint32_t> filter(const std::u32string&) const;
-  [[nodiscard]] const std::string get_freetype_version() const;
+  [[nodiscard]] bool is_init_ok () const;
+  FontFacePtr get_font (const std::string &font);
+  [[nodiscard]] bool is_windows_symbol_font (const FT_Face &face) const;
+  void register_font_file (const std::string &path);
+  void clear ();
+  [[nodiscard]] FontInfoList *list_fonts () const;
+  [[nodiscard]] std::vector<uint32_t> filter (const std::u32string &) const;
+  [[nodiscard]] const std::string get_freetype_version () const;
 
-  static FontCache *instance();
+  static FontCache *instance ();
 
   using InitHandlerFunc = void (FontCacheInitializer *, void *);
-  static void registerProgressHandler(InitHandlerFunc *handler, void *userdata = nullptr);
+  static void registerProgressHandler (InitHandlerFunc *handler, void *userdata = nullptr);
 
 private:
   using cache_entry_t = std::pair<FontFacePtr, std::time_t>;
@@ -123,21 +128,20 @@ private:
   static InitHandlerFunc *cb_handler;
   static void *cb_userdata;
 
-  static void defaultInitHandler(FontCacheInitializer *delegate, void *userdata);
+  static void defaultInitHandler (FontCacheInitializer *delegate, void *userdata);
 
   bool init_ok;
   cache_t cache;
   FcConfig *config;
   FT_Library library;
 
-  void check_cleanup();
-  void dump_cache(const std::string& info);
+  void check_cleanup ();
+  void dump_cache (const std::string &info);
 
-  void add_font_dir(const std::string& path);
-  void init_pattern(FcPattern *pattern) const;
+  void add_font_dir (const std::string &path);
+  void init_pattern (FcPattern *pattern) const;
 
-  [[nodiscard]] FontFacePtr find_face(const std::string& font) const;
-  [[nodiscard]] FontFacePtr find_face_fontconfig(const std::string& font) const;
-  bool try_charmap(const FontFacePtr& face_ptr, int platform_id, int encoding_id) const;
+  [[nodiscard]] FontFacePtr find_face (const std::string &font) const;
+  [[nodiscard]] FontFacePtr find_face_fontconfig (const std::string &font) const;
+  bool try_charmap (const FontFacePtr &face_ptr, int platform_id, int encoding_id) const;
 };
-
diff --git a/src/LibraryInfo.cc b/src/LibraryInfo.cc
index 3b73daa22..b1b5a483a 100644
--- a/src/LibraryInfo.cc
+++ b/src/LibraryInfo.cc
@@ -49,14 +49,13 @@
 #endif
 
 #define STRINGIFY(x) #x
-#define TOSTRING(x) STRINGIFY(x)
+#define TOSTRING(x) STRINGIFY (x)
 
 #ifdef ENABLE_MANIFOLD
-#include <manifold/version.h>  // if it is new enough for us, it has version.h
-#define MANIFOLD_VERSION_STRING \
-        TOSTRING(MANIFOLD_VERSION_MAJOR) "." \
-        TOSTRING(MANIFOLD_VERSION_MINOR) "." \
-        TOSTRING(MANIFOLD_VERSION_PATCH)
+#include <manifold/version.h> // if it is new enough for us, it has version.h
+#define MANIFOLD_VERSION_STRING     \
+  TOSTRING (MANIFOLD_VERSION_MAJOR) \
+  "." TOSTRING (MANIFOLD_VERSION_MINOR) "." TOSTRING (MANIFOLD_VERSION_PATCH)
 #else
 #define MANIFOLD_VERSION_STRING "<not enabled>"
 #endif
@@ -68,82 +67,81 @@
 
 extern std::vector<std::string> librarypath;
 extern std::vector<std::string> fontpath;
-extern const std::string get_cairo_version();
+extern const std::string get_cairo_version ();
 extern const char *LODEPNG_VERSION_STRING;
 
-std::string LibraryInfo::info()
-{
+std::string LibraryInfo::info () {
   std::ostringstream s;
 
 #if defined(__x86_64__) || defined(_M_X64)
-  const std::string bits(" 64bit");
+  const std::string bits (" 64bit");
 #elif defined(__i386) || defined(_M_IX86)
-  const std::string bits(" 32bit");
+  const std::string bits (" 32bit");
 #else
-  const std::string bits("");
+  const std::string bits ("");
 #endif
 
 #if defined(__GNUG__) && !defined(__clang__)
-  const std::string compiler_info("GCC " + std::string(TOSTRING(__VERSION__)) + bits);
+  const std::string compiler_info ("GCC " + std::string (TOSTRING (__VERSION__)) + bits);
 #elif defined(_MSC_VER)
-  const std::string compiler_info("MSVC " + std::string(TOSTRING(_MSC_FULL_VER)) + bits);
+  const std::string compiler_info ("MSVC " + std::string (TOSTRING (_MSC_FULL_VER)) + bits);
 #elif defined(__clang__)
-  const std::string compiler_info("Clang " + std::string(TOSTRING(__clang_version__)) + bits);
+  const std::string compiler_info ("Clang " + std::string (TOSTRING (__clang_version__)) + bits);
 #else
-  const std::string compiler_info("unknown compiler");
+  const std::string compiler_info ("unknown compiler");
 #endif
 
 #if defined(__MINGW64__)
-  const std::string mingwstatus("MingW64");
+  const std::string mingwstatus ("MingW64");
 #elif defined(__MINGW32__)
-  const std::string mingwstatus("MingW32");
+  const std::string mingwstatus ("MingW32");
 #else
-  const std::string mingwstatus("No");
+  const std::string mingwstatus ("No");
 #endif
 
 #ifdef DEBUG
-  const std::string debugstatus("Yes");
+  const std::string debugstatus ("Yes");
 #else
-  const std::string debugstatus("No");
+  const std::string debugstatus ("No");
 #endif
 
 #ifdef QT_VERSION
-  const std::string qtVersion = qVersion();
+  const std::string qtVersion = qVersion ();
 #else
   const std::string qtVersion = "Qt disabled - Commandline Test Version";
 #endif
 
 #ifdef ENABLE_CGAL
-  std::string cgal_3d_kernel = typeid(CGAL_Kernel3).name();
-  std::string cgal_2d_kernel = typeid(CGAL_Kernel2).name();
+  std::string cgal_3d_kernel = typeid (CGAL_Kernel3).name ();
+  std::string cgal_2d_kernel = typeid (CGAL_Kernel2).name ();
 #if defined(openscad_info_demangle_)
   int status;
-  cgal_3d_kernel = std::string(abi::__cxa_demangle(cgal_3d_kernel.c_str(), nullptr, nullptr, &status) );
-  cgal_2d_kernel = std::string(abi::__cxa_demangle(cgal_2d_kernel.c_str(), nullptr, nullptr, &status) );
+  cgal_3d_kernel = std::string (abi::__cxa_demangle (cgal_3d_kernel.c_str (), nullptr, nullptr, &status));
+  cgal_2d_kernel = std::string (abi::__cxa_demangle (cgal_2d_kernel.c_str (), nullptr, nullptr, &status));
 #endif // demangle
-  boost::replace_all(cgal_3d_kernel, "CGAL::", "");
-  boost::replace_all(cgal_2d_kernel, "CGAL::", "");
+  boost::replace_all (cgal_3d_kernel, "CGAL::", "");
+  boost::replace_all (cgal_2d_kernel, "CGAL::", "");
 #else // ENABLE_CGAL
   std::string cgal_3d_kernel = "";
   std::string cgal_2d_kernel = "";
 #endif // ENABLE_CGAL
 
-  const char *env_path = getenv("OPENSCADPATH");
-  const char *env_font_path = getenv("OPENSCAD_FONT_PATH");
+  const char *env_path = getenv ("OPENSCADPATH");
+  const char *env_font_path = getenv ("OPENSCAD_FONT_PATH");
 
   s << "OpenSCAD Version: " << openscad_detailedversionnumber
-    << "\nSystem information: " << PlatformUtils::sysinfo()
-    << "\nUser Agent: " << PlatformUtils::user_agent()
+    << "\nSystem information: " << PlatformUtils::sysinfo ()
+    << "\nUser Agent: " << PlatformUtils::user_agent ()
     << "\nCompiler: " << compiler_info
     << "\nMinGW build: " << mingwstatus
     << "\nDebug build: " << debugstatus
     << "\nBoost version: " << BOOST_LIB_VERSION
     << "\nEigen version: " << EIGEN_WORLD_VERSION << "." << EIGEN_MAJOR_VERSION << "." << EIGEN_MINOR_VERSION
 #ifdef ENABLE_CGAL
-    << "\nCGAL version, kernels: " << TOSTRING(CGAL_VERSION) << ", " << cgal_3d_kernel << ", " << cgal_2d_kernel
+    << "\nCGAL version, kernels: " << TOSTRING (CGAL_VERSION) << ", " << cgal_3d_kernel << ", " << cgal_2d_kernel
 #endif
 #ifdef ENABLE_PYTHON
-    << "\nPython Version: " << python_version()
+    << "\nPython Version: " << python_version ()
 #endif
     << "\nOpenCSG version: " << OPENCSG_VERSION_STRING
     << "\nClipper2 version: " << CLIPPER2_VERSION
@@ -151,40 +149,40 @@ std::string LibraryInfo::info()
     << "\nQt version: " << qtVersion
 #ifndef OPENSCAD_NOGUI
     << "\nQScintilla version: " << QSCINTILLA_VERSION_STR
-    << "\nInputDrivers: " << InputDriverManager::instance()->listDrivers()
+    << "\nInputDrivers: " << InputDriverManager::instance ()->listDrivers ()
 #endif
     << "\nGLib version: " << GLIB_MAJOR_VERSION << "." << GLIB_MINOR_VERSION << "." << GLIB_MICRO_VERSION
     << "\nlodepng version: " << LODEPNG_VERSION_STRING
     << "\nlibzip version: " << LIBZIP_VERSION
-    << "\nfontconfig version: " << get_fontconfig_version()
-    << "\nfreetype version: " << get_freetype_version()
-    << "\nharfbuzz version: " << get_harfbuzz_version()
-    << "\ncairo version: " << get_cairo_version()
-    << "\nlib3mf version: " << get_lib3mf_version()
+    << "\nfontconfig version: " << get_fontconfig_version ()
+    << "\nfreetype version: " << get_freetype_version ()
+    << "\nharfbuzz version: " << get_harfbuzz_version ()
+    << "\ncairo version: " << get_cairo_version ()
+    << "\nlib3mf version: " << get_lib3mf_version ()
 #ifdef ENABLE_EXPERIMENTAL
-    << "\nFeatures: " << Feature::features()
+    << "\nFeatures: " << Feature::features ()
 #endif
-    << "\nApplication Path: " << PlatformUtils::applicationPath()
-    << "\nDocuments Path: " << PlatformUtils::documentsPath()
-    << "\nUser Documents Path: " << PlatformUtils::userDocumentsPath()
-    << "\nResource Path: " << PlatformUtils::resourceBasePath()
-    << "\nUser Library Path: " << PlatformUtils::userLibraryPath()
-    << "\nUser Examples Path: " << PlatformUtils::userExamplesPath()
-    << "\nUser Config Path: " << PlatformUtils::userConfigPath()
-    << "\nBackup Path: " << PlatformUtils::backupPath()
+    << "\nApplication Path: " << PlatformUtils::applicationPath ()
+    << "\nDocuments Path: " << PlatformUtils::documentsPath ()
+    << "\nUser Documents Path: " << PlatformUtils::userDocumentsPath ()
+    << "\nResource Path: " << PlatformUtils::resourceBasePath ()
+    << "\nUser Library Path: " << PlatformUtils::userLibraryPath ()
+    << "\nUser Examples Path: " << PlatformUtils::userExamplesPath ()
+    << "\nUser Config Path: " << PlatformUtils::userConfigPath ()
+    << "\nBackup Path: " << PlatformUtils::backupPath ()
     << "\nOPENSCADPATH: " << (env_path == nullptr ? "<not set>" : env_path)
     << "\nOpenSCAD library path:\n";
 
-  for (const auto& path : librarypath) {
+  for (const auto &path : librarypath) {
     s << "  " << path << "\n";
   }
 
   s << "\nOPENSCAD_FONT_PATH: " << (env_font_path == nullptr ? "<not set>" : env_font_path)
     << "\nOpenSCAD font path:\n";
 
-  for (const auto& path : fontpath) {
+  for (const auto &path : fontpath) {
     s << "  " << path << "\n";
   }
 
-  return s.str();
+  return s.str ();
 }
diff --git a/src/LibraryInfo.h b/src/LibraryInfo.h
index b798d074c..fa8565e8e 100644
--- a/src/LibraryInfo.h
+++ b/src/LibraryInfo.h
@@ -3,5 +3,5 @@
 #include <string>
 
 namespace LibraryInfo {
-std::string info();
+std::string info ();
 }
diff --git a/src/RenderStatistic.cc b/src/RenderStatistic.cc
index ce95a7bd8..29cb06b85 100644
--- a/src/RenderStatistic.cc
+++ b/src/RenderStatistic.cc
@@ -23,7 +23,6 @@
  *
  */
 
-
 #include "RenderStatistic.h"
 
 #include <algorithm>
@@ -56,81 +55,87 @@
 #include "geometry/manifold/manifoldutils.h"
 #endif // ENABLE_MANIFOLD
 
-
 class GeometryList;
 
 namespace {
 
-struct StatisticVisitor : public GeometryVisitor
-{
-  StatisticVisitor(const std::vector<std::string>& options)
-    : all(std::find(options.begin(), options.end(), "all") != options.end()),
-    options(options) { }
-  virtual void printCamera(const Camera& camera) = 0;
-  virtual void printCacheStatistic() = 0;
-  virtual void printRenderingTime(std::chrono::milliseconds) = 0;
-  virtual void finish() = 0;
+struct StatisticVisitor : public GeometryVisitor {
+  StatisticVisitor (const std::vector<std::string> &options)
+    : all (std::find (options.begin (), options.end (), "all") != options.end ())
+    , options (options) {}
+  virtual void printCamera (const Camera &camera) = 0;
+  virtual void printCacheStatistic () = 0;
+  virtual void printRenderingTime (std::chrono::milliseconds) = 0;
+  virtual void finish () = 0;
+
 protected:
-  bool is_enabled(const std::string& name) {
-    return all || std::find(options.begin(), options.end(), name) != options.end();
+  bool is_enabled (const std::string &name) {
+    return all || std::find (options.begin (), options.end (), name) != options.end ();
   }
+
 private:
   bool all;
   std::vector<std::string> options;
 };
 
-struct LogVisitor : public StatisticVisitor
-{
-  LogVisitor(const std::vector<std::string>& options) : StatisticVisitor(options) { }
-  void visit(const GeometryList& node) override;
-  void visit(const PolySet& node) override;
-  void visit(const Polygon2d& node) override;
+struct LogVisitor : public StatisticVisitor {
+  LogVisitor (const std::vector<std::string> &options)
+    : StatisticVisitor (options) {}
+  void visit (const GeometryList &node) override;
+  void visit (const PolySet &node) override;
+  void visit (const Polygon2d &node) override;
 #ifdef ENABLE_CGAL
-  void visit(const CGALNefGeometry& node) override;
+  void visit (const CGALNefGeometry &node) override;
 #endif // ENABLE_CGAL
 #ifdef ENABLE_MANIFOLD
-  void visit(const ManifoldGeometry& node) override;
+  void visit (const ManifoldGeometry &node) override;
 #endif // ENABLE_MANIFOLD
-  void printCamera(const Camera& camera) override;
-  void printCacheStatistic() override;
-  void printRenderingTime(std::chrono::milliseconds) override;
-  void finish() override;
+  void printCamera (const Camera &camera) override;
+  void printCacheStatistic () override;
+  void printRenderingTime (std::chrono::milliseconds) override;
+  void finish () override;
+
 private:
-  void printBoundingBox3(const BoundingBox& bb);
+  void printBoundingBox3 (const BoundingBox &bb);
 };
 
-struct StreamVisitor : public StatisticVisitor
-{
-  StreamVisitor(const std::vector<std::string>& options, std::ostream& stream) : StatisticVisitor(options), stream(stream) {}
-  StreamVisitor(const std::vector<std::string>& options, const std::string& filename) : StatisticVisitor(options), fstream(filename), stream(fstream) {}
-  ~StreamVisitor() override {
-    if (fstream.is_open()) fstream.close();
+struct StreamVisitor : public StatisticVisitor {
+  StreamVisitor (const std::vector<std::string> &options, std::ostream &stream)
+    : StatisticVisitor (options)
+    , stream (stream) {}
+  StreamVisitor (const std::vector<std::string> &options, const std::string &filename)
+    : StatisticVisitor (options)
+    , fstream (filename)
+    , stream (fstream) {}
+  ~StreamVisitor () override {
+    if (fstream.is_open ())
+      fstream.close ();
   }
-  void visit(const GeometryList& node) override;
-  void visit(const PolySet& node) override;
-  void visit(const Polygon2d& node) override;
+  void visit (const GeometryList &node) override;
+  void visit (const PolySet &node) override;
+  void visit (const Polygon2d &node) override;
 #ifdef ENABLE_CGAL
-  void visit(const CGALNefGeometry& node) override;
+  void visit (const CGALNefGeometry &node) override;
 #endif // ENABLE_CGAL
 #ifdef ENABLE_MANIFOLD
-  void visit(const ManifoldGeometry& node) override;
+  void visit (const ManifoldGeometry &node) override;
 #endif // ENABLE_MANIFOLD
-  void printCamera(const Camera& camera) override;
-  void printCacheStatistic() override;
-  void printRenderingTime(std::chrono::milliseconds) override;
-  void finish() override;
+  void printCamera (const Camera &camera) override;
+  void printCacheStatistic () override;
+  void printRenderingTime (std::chrono::milliseconds) override;
+  void finish () override;
+
 private:
   nlohmann::json json;
   std::ofstream fstream;
-  std::ostream& stream;
+  std::ostream &stream;
 };
 
-static nlohmann::json getBoundingBox2d(const Geometry& geometry)
-{
-  const auto& bb = geometry.getBoundingBox();
-  const std::array<double, 2> min = { bb.min().x(), bb.min().y() };
-  const std::array<double, 2> max = { bb.max().x(), bb.max().y() };
-  const std::array<double, 2> size = { bb.max().x() - bb.min().x(), bb.max().y() - bb.min().y() };
+static nlohmann::json getBoundingBox2d (const Geometry &geometry) {
+  const auto &bb = geometry.getBoundingBox ();
+  const std::array<double, 2> min = {bb.min ().x (), bb.min ().y ()};
+  const std::array<double, 2> max = {bb.max ().x (), bb.max ().y ()};
+  const std::array<double, 2> size = {bb.max ().x () - bb.min ().x (), bb.max ().y () - bb.min ().y ()};
   nlohmann::json bbJson;
   bbJson["min"] = min;
   bbJson["max"] = max;
@@ -138,12 +143,11 @@ static nlohmann::json getBoundingBox2d(const Geometry& geometry)
   return bbJson;
 }
 
-static nlohmann::json getBoundingBox3d(const Geometry& geometry)
-{
-  const auto& bb = geometry.getBoundingBox();
-  const std::array<double, 3> min = { bb.min().x(), bb.min().y(), bb.min().z() };
-  const std::array<double, 3> max = { bb.max().x(), bb.max().y(), bb.max().z() };
-  const std::array<double, 3> size = { bb.max().x() - bb.min().x(), bb.max().y() - bb.min().y(), bb.max().z() - bb.min().z() };
+static nlohmann::json getBoundingBox3d (const Geometry &geometry) {
+  const auto &bb = geometry.getBoundingBox ();
+  const std::array<double, 3> min = {bb.min ().x (), bb.min ().y (), bb.min ().z ()};
+  const std::array<double, 3> max = {bb.max ().x (), bb.max ().y (), bb.max ().z ()};
+  const std::array<double, 3> size = {bb.max ().x () - bb.min ().x (), bb.max ().y () - bb.min ().y (), bb.max ().z () - bb.min ().z ()};
   nlohmann::json bbJson;
   bbJson["min"] = min;
   bbJson["max"] = max;
@@ -152,230 +156,210 @@ static nlohmann::json getBoundingBox3d(const Geometry& geometry)
 }
 
 template <typename C>
-static nlohmann::json getCache(C cache)
-{
+static nlohmann::json getCache (C cache) {
   nlohmann::json cacheJson;
-  cacheJson["entries"] = cache->size();
-  cacheJson["bytes"] = cache->totalCost();
-  cacheJson["max_size"] = cache->maxSizeMB() * 1024 * 1024;
+  cacheJson["entries"] = cache->size ();
+  cacheJson["bytes"] = cache->totalCost ();
+  cacheJson["max_size"] = cache->maxSizeMB () * 1024 * 1024;
   return cacheJson;
 }
 
 } // namespace
 
-RenderStatistic::RenderStatistic() : begin(std::chrono::steady_clock::now())
-{
+RenderStatistic::RenderStatistic ()
+  : begin (std::chrono::steady_clock::now ()) {
 }
 
-void RenderStatistic::start()
-{
-  begin = std::chrono::steady_clock::now();
+void RenderStatistic::start () {
+  begin = std::chrono::steady_clock::now ();
 }
 
-std::chrono::milliseconds RenderStatistic::ms()
-{
-  const std::chrono::steady_clock::time_point end{std::chrono::steady_clock::now()};
-  const std::chrono::milliseconds ms{std::chrono::duration_cast<std::chrono::milliseconds>(end - begin)};
+std::chrono::milliseconds RenderStatistic::ms () {
+  const std::chrono::steady_clock::time_point end{std::chrono::steady_clock::now ()};
+  const std::chrono::milliseconds ms{std::chrono::duration_cast<std::chrono::milliseconds> (end - begin)};
   return ms;
 }
 
-void RenderStatistic::printCacheStatistic()
-{
-  LogVisitor visitor({});
-  visitor.printCacheStatistic();
+void RenderStatistic::printCacheStatistic () {
+  LogVisitor visitor ({});
+  visitor.printCacheStatistic ();
 }
 
-void RenderStatistic::printRenderingTime()
-{
-  LogVisitor visitor({});
-  visitor.printRenderingTime(ms());
+void RenderStatistic::printRenderingTime () {
+  LogVisitor visitor ({});
+  visitor.printRenderingTime (ms ());
 }
 
-void RenderStatistic::printAll(const std::shared_ptr<const Geometry>& geom, const Camera& camera, const std::vector<std::string>& options, const std::string& filename)
-{
+void RenderStatistic::printAll (const std::shared_ptr<const Geometry> &geom, const Camera &camera, const std::vector<std::string> &options, const std::string &filename) {
   //bool is_log = false;
   std::unique_ptr<StatisticVisitor> visitor;
-  if (filename.empty()) {
+  if (filename.empty ()) {
     //is_log = true;
-    visitor = std::make_unique<LogVisitor>(options);
+    visitor = std::make_unique<LogVisitor> (options);
   } else if (filename == "-") {
-    visitor = std::make_unique<StreamVisitor>(options, std::cout);
+    visitor = std::make_unique<StreamVisitor> (options, std::cout);
   } else {
-    visitor = std::make_unique<StreamVisitor>(options, filename);
+    visitor = std::make_unique<StreamVisitor> (options, filename);
   }
 
-  visitor->printCacheStatistic();
-  visitor->printRenderingTime(ms());
-  if (geom && !geom->isEmpty()) {
-    geom->accept(*visitor);
+  visitor->printCacheStatistic ();
+  visitor->printRenderingTime (ms ());
+  if (geom && !geom->isEmpty ()) {
+    geom->accept (*visitor);
   }
-  visitor->printCamera(camera);
-  visitor->finish();
+  visitor->printCamera (camera);
+  visitor->finish ();
 }
 
-void LogVisitor::visit(const GeometryList& geomlist)
-{
-  LOG("Top level object is a list of objects:");
-  LOG("   Objects:    %1$d",
-      geomlist.getChildren().size());
+void LogVisitor::visit (const GeometryList &geomlist) {
+  LOG ("Top level object is a list of objects:");
+  LOG ("   Objects:    %1$d",
+       geomlist.getChildren ().size ());
 }
 
-void LogVisitor::visit(const Polygon2d& poly)
-{
-  LOG("Top level object is a 2D object:");
-  LOG("   Contours:   %1$6d", poly.outlines().size());
-  if (is_enabled(RenderStatistic::BOUNDING_BOX)) {
-    const auto& bb = poly.getBoundingBox();
-    LOG("Bounding box:");
-    LOG("   Min:  %1$.2f, %2$.2f", bb.min().x(), bb.min().y());
-    LOG("   Max:  %1$.2f, %2$.2f", bb.max().x(), bb.max().y());
-    LOG("   Size: %1$.2f, %2$.2f", bb.max().x() - bb.min().x(), bb.max().y() - bb.min().y());
+void LogVisitor::visit (const Polygon2d &poly) {
+  LOG ("Top level object is a 2D object:");
+  LOG ("   Contours:   %1$6d", poly.outlines ().size ());
+  if (is_enabled (RenderStatistic::BOUNDING_BOX)) {
+    const auto &bb = poly.getBoundingBox ();
+    LOG ("Bounding box:");
+    LOG ("   Min:  %1$.2f, %2$.2f", bb.min ().x (), bb.min ().y ());
+    LOG ("   Max:  %1$.2f, %2$.2f", bb.max ().x (), bb.max ().y ());
+    LOG ("   Size: %1$.2f, %2$.2f", bb.max ().x () - bb.min ().x (), bb.max ().y () - bb.min ().y ());
   }
-  if (is_enabled(RenderStatistic::AREA)) {
-    LOG("Measurements:");
-    LOG("   Area: %1$.2f", poly.area());
+  if (is_enabled (RenderStatistic::AREA)) {
+    LOG ("Measurements:");
+    LOG ("   Area: %1$.2f", poly.area ());
   }
 }
 
-void LogVisitor::printBoundingBox3(const BoundingBox& bb)
-{
-  if (is_enabled(RenderStatistic::BOUNDING_BOX)) {
-    LOG("Bounding box:");
-    LOG("   Min:  %1$.2f, %2$.2f, %3$.2f", bb.min().x(), bb.min().y(), bb.min().z());
-    LOG("   Max:  %1$.2f, %2$.2f, %3$.2f", bb.max().x(), bb.max().y(), bb.max().z());
-    LOG("   Size: %1$.2f, %2$.2f, %3$.2f", bb.max().x() - bb.min().x(), bb.max().y() - bb.min().y(), bb.max().z() - bb.min().z());
+void LogVisitor::printBoundingBox3 (const BoundingBox &bb) {
+  if (is_enabled (RenderStatistic::BOUNDING_BOX)) {
+    LOG ("Bounding box:");
+    LOG ("   Min:  %1$.2f, %2$.2f, %3$.2f", bb.min ().x (), bb.min ().y (), bb.min ().z ());
+    LOG ("   Max:  %1$.2f, %2$.2f, %3$.2f", bb.max ().x (), bb.max ().y (), bb.max ().z ());
+    LOG ("   Size: %1$.2f, %2$.2f, %3$.2f", bb.max ().x () - bb.min ().x (), bb.max ().y () - bb.min ().y (), bb.max ().z () - bb.min ().z ());
   }
 }
 
-void LogVisitor::visit(const PolySet& ps)
-{
-  assert(ps.getDimension() == 3);
-  LOG("Top level object is a 3D object (PolySet):");
-  LOG("   Convex:       %1$s", (ps.isConvex() ? "yes" : "no"));
-  if (ps.isTriangular()) {
-    LOG("   Triangles: %1$6d", ps.numFacets());
+void LogVisitor::visit (const PolySet &ps) {
+  assert (ps.getDimension () == 3);
+  LOG ("Top level object is a 3D object (PolySet):");
+  LOG ("   Convex:       %1$s", (ps.isConvex () ? "yes" : "no"));
+  if (ps.isTriangular ()) {
+    LOG ("   Triangles: %1$6d", ps.numFacets ());
   } else {
-    LOG("   Facets:    %1$6d", ps.numFacets());
+    LOG ("   Facets:    %1$6d", ps.numFacets ());
   }
-  printBoundingBox3(ps.getBoundingBox());
+  printBoundingBox3 (ps.getBoundingBox ());
 }
 
 #ifdef ENABLE_CGAL
-void LogVisitor::visit(const CGALNefGeometry& nef)
-{
-  if (nef.getDimension() == 3) {
-    const bool simple = nef.p3->is_simple();
-    LOG("Top level object is a 3D object (Nef polyhedron):");
-    LOG("   Simple:     %1$s", (simple ? "yes" : "no"));
-    LOG("   Vertices:   %1$6d", nef.p3->number_of_vertices());
-    LOG("   Halfedges:  %1$6d", nef.p3->number_of_halfedges());
-    LOG("   Edges:      %1$6d", nef.p3->number_of_edges());
-    LOG("   Halffacets: %1$6d", nef.p3->number_of_halffacets());
-    LOG("   Facets:     %1$6d", nef.p3->number_of_facets());
-    LOG("   Volumes:    %1$6d", nef.p3->number_of_volumes());
+void LogVisitor::visit (const CGALNefGeometry &nef) {
+  if (nef.getDimension () == 3) {
+    const bool simple = nef.p3->is_simple ();
+    LOG ("Top level object is a 3D object (Nef polyhedron):");
+    LOG ("   Simple:     %1$s", (simple ? "yes" : "no"));
+    LOG ("   Vertices:   %1$6d", nef.p3->number_of_vertices ());
+    LOG ("   Halfedges:  %1$6d", nef.p3->number_of_halfedges ());
+    LOG ("   Edges:      %1$6d", nef.p3->number_of_edges ());
+    LOG ("   Halffacets: %1$6d", nef.p3->number_of_halffacets ());
+    LOG ("   Facets:     %1$6d", nef.p3->number_of_facets ());
+    LOG ("   Volumes:    %1$6d", nef.p3->number_of_volumes ());
     if (!simple) {
-      LOG(message_group::UI_Warning, "Object may not be a valid 2-manifold and may need repair!");
+      LOG (message_group::UI_Warning, "Object may not be a valid 2-manifold and may need repair!");
     }
-    printBoundingBox3(nef.getBoundingBox());
+    printBoundingBox3 (nef.getBoundingBox ());
   }
 }
 #endif // ENABLE_CGAL
 
 #ifdef ENABLE_MANIFOLD
-void LogVisitor::visit(const ManifoldGeometry& mani_geom)
-{
-  LOG("   Top level object is a 3D object (manifold):");
-  auto& mani = mani_geom.getManifold();
-
-  LOG("   Status:     %1$s", ManifoldUtils::statusToString(mani.Status()));
-  LOG("   Genus:      %1$d", mani.Genus());
-  LOG("   Vertices:   %1$6d", mani.NumVert());
-  LOG("   Facets:     %1$6d", mani.NumTri());
-  printBoundingBox3(mani_geom.getBoundingBox());
+void LogVisitor::visit (const ManifoldGeometry &mani_geom) {
+  LOG ("   Top level object is a 3D object (manifold):");
+  auto &mani = mani_geom.getManifold ();
+
+  LOG ("   Status:     %1$s", ManifoldUtils::statusToString (mani.Status ()));
+  LOG ("   Genus:      %1$d", mani.Genus ());
+  LOG ("   Vertices:   %1$6d", mani.NumVert ());
+  LOG ("   Facets:     %1$6d", mani.NumTri ());
+  printBoundingBox3 (mani_geom.getBoundingBox ());
 }
 #endif // ENABLE_MANIFOLD
 
-void LogVisitor::printCamera(const Camera& camera)
-{
-  if (is_enabled(RenderStatistic::CAMERA)) {
-    LOG("Camera:");
-    LOG("   Translation: %1$.2f, %2$.2f, %3$.2f", camera.getVpt().x(), camera.getVpt().y(), camera.getVpt().z());
-    LOG("   Rotation:    %1$.2f, %2$.2f, %3$.2f", camera.getVpr().x(), camera.getVpr().y(), camera.getVpr().z());
-    LOG("   Distance:    %1$.2f", camera.zoomValue());
-    LOG("   FOV:         %1$.2f", camera.fovValue());
+void LogVisitor::printCamera (const Camera &camera) {
+  if (is_enabled (RenderStatistic::CAMERA)) {
+    LOG ("Camera:");
+    LOG ("   Translation: %1$.2f, %2$.2f, %3$.2f", camera.getVpt ().x (), camera.getVpt ().y (), camera.getVpt ().z ());
+    LOG ("   Rotation:    %1$.2f, %2$.2f, %3$.2f", camera.getVpr ().x (), camera.getVpr ().y (), camera.getVpr ().z ());
+    LOG ("   Distance:    %1$.2f", camera.zoomValue ());
+    LOG ("   FOV:         %1$.2f", camera.fovValue ());
   }
 }
 
-void LogVisitor::printCacheStatistic()
-{
+void LogVisitor::printCacheStatistic () {
   // always enabled
-  GeometryCache::instance()->print();
+  GeometryCache::instance ()->print ();
 #ifdef ENABLE_CGAL
-  CGALCache::instance()->print();
+  CGALCache::instance ()->print ();
 #endif
 }
 
-void LogVisitor::printRenderingTime(const std::chrono::milliseconds ms)
-{
+void LogVisitor::printRenderingTime (const std::chrono::milliseconds ms) {
   // always enabled
-  LOG("Total rendering time: %1$d:%2$02d:%3$02d.%4$03d",
-      (ms.count() / 1000 / 60 / 60),
-      (ms.count() / 1000 / 60 % 60),
-      (ms.count() / 1000 % 60),
-      (ms.count() % 1000));
+  LOG ("Total rendering time: %1$d:%2$02d:%3$02d.%4$03d",
+       (ms.count () / 1000 / 60 / 60),
+       (ms.count () / 1000 / 60 % 60),
+       (ms.count () / 1000 % 60),
+       (ms.count () % 1000));
 }
 
-void LogVisitor::finish()
-{
+void LogVisitor::finish () {
 }
 
-void StreamVisitor::visit(const GeometryList& geomlist)
-{
+void StreamVisitor::visit (const GeometryList &geomlist) {
 }
 
-void StreamVisitor::visit(const Polygon2d& poly)
-{
-  if (is_enabled(RenderStatistic::GEOMETRY)) {
+void StreamVisitor::visit (const Polygon2d &poly) {
+  if (is_enabled (RenderStatistic::GEOMETRY)) {
     nlohmann::json geometryJson;
     geometryJson["dimensions"] = 2;
-    geometryJson["convex"] = poly.is_convex();
-    geometryJson["contours"] = poly.outlines().size();
-    if (is_enabled(RenderStatistic::BOUNDING_BOX)) {
-      geometryJson["bounding_box"] = getBoundingBox2d(poly);
+    geometryJson["convex"] = poly.is_convex ();
+    geometryJson["contours"] = poly.outlines ().size ();
+    if (is_enabled (RenderStatistic::BOUNDING_BOX)) {
+      geometryJson["bounding_box"] = getBoundingBox2d (poly);
     }
     json["geometry"] = geometryJson;
   }
 }
 
-void StreamVisitor::visit(const PolySet& ps)
-{
-  if (is_enabled(RenderStatistic::GEOMETRY)) {
-    assert(ps.getDimension() == 3);
+void StreamVisitor::visit (const PolySet &ps) {
+  if (is_enabled (RenderStatistic::GEOMETRY)) {
+    assert (ps.getDimension () == 3);
     nlohmann::json geometryJson;
     geometryJson["dimensions"] = 3;
-    geometryJson["convex"] = ps.isConvex();
-    geometryJson["triangular"] = ps.isTriangular();
-    geometryJson["facets"] = ps.numFacets();
-    if (is_enabled(RenderStatistic::BOUNDING_BOX)) {
-      geometryJson["bounding_box"] = getBoundingBox3d(ps);
+    geometryJson["convex"] = ps.isConvex ();
+    geometryJson["triangular"] = ps.isTriangular ();
+    geometryJson["facets"] = ps.numFacets ();
+    if (is_enabled (RenderStatistic::BOUNDING_BOX)) {
+      geometryJson["bounding_box"] = getBoundingBox3d (ps);
     }
     json["geometry"] = geometryJson;
   }
 }
 
 #ifdef ENABLE_CGAL
-void StreamVisitor::visit(const CGALNefGeometry& nef)
-{
-  if (is_enabled(RenderStatistic::GEOMETRY)) {
+void StreamVisitor::visit (const CGALNefGeometry &nef) {
+  if (is_enabled (RenderStatistic::GEOMETRY)) {
     nlohmann::json geometryJson;
     geometryJson["dimensions"] = 3;
-    geometryJson["simple"] = nef.p3->is_simple();
-    geometryJson["vertices"] = nef.p3->number_of_vertices();
-    geometryJson["edges"] = nef.p3->number_of_edges();
-    geometryJson["facets"] = nef.p3->number_of_facets();
-    geometryJson["volumes"] = nef.p3->number_of_volumes();
-    if (is_enabled(RenderStatistic::BOUNDING_BOX)) {
-      geometryJson["bounding_box"] = getBoundingBox3d(nef);
+    geometryJson["simple"] = nef.p3->is_simple ();
+    geometryJson["vertices"] = nef.p3->number_of_vertices ();
+    geometryJson["edges"] = nef.p3->number_of_edges ();
+    geometryJson["facets"] = nef.p3->number_of_facets ();
+    geometryJson["volumes"] = nef.p3->number_of_volumes ();
+    if (is_enabled (RenderStatistic::BOUNDING_BOX)) {
+      geometryJson["bounding_box"] = getBoundingBox3d (nef);
     }
     json["geometry"] = geometryJson;
   }
@@ -383,67 +367,58 @@ void StreamVisitor::visit(const CGALNefGeometry& nef)
 #endif // ENABLE_CGAL
 
 #ifdef ENABLE_MANIFOLD
-void StreamVisitor::visit(const ManifoldGeometry& mani)
-{
-  if (is_enabled(RenderStatistic::GEOMETRY)) {
+void StreamVisitor::visit (const ManifoldGeometry &mani) {
+  if (is_enabled (RenderStatistic::GEOMETRY)) {
     nlohmann::json geometryJson;
     geometryJson["dimensions"] = 3;
-    geometryJson["simple"] = mani.isManifold();
-    geometryJson["vertices"] = mani.numVertices();
-    geometryJson["facets"] = mani.numFacets();
-    if (is_enabled(RenderStatistic::BOUNDING_BOX)) {
-      geometryJson["bounding_box"] = getBoundingBox3d(mani);
+    geometryJson["simple"] = mani.isManifold ();
+    geometryJson["vertices"] = mani.numVertices ();
+    geometryJson["facets"] = mani.numFacets ();
+    if (is_enabled (RenderStatistic::BOUNDING_BOX)) {
+      geometryJson["bounding_box"] = getBoundingBox3d (mani);
     }
     json["geometry"] = geometryJson;
   }
 }
 #endif // ENABLE_MANIFOLD
 
-void StreamVisitor::printCamera(const Camera& camera)
-{
-  if (is_enabled(RenderStatistic::CAMERA)) {
-    const std::array<double, 3> translation = { camera.getVpt().x(), camera.getVpt().y(), camera.getVpt().z() };
-    const std::array<double, 3> rotation = { camera.getVpr().x(), camera.getVpr().y(), camera.getVpr().z() };
+void StreamVisitor::printCamera (const Camera &camera) {
+  if (is_enabled (RenderStatistic::CAMERA)) {
+    const std::array<double, 3> translation = {camera.getVpt ().x (), camera.getVpt ().y (), camera.getVpt ().z ()};
+    const std::array<double, 3> rotation = {camera.getVpr ().x (), camera.getVpr ().y (), camera.getVpr ().z ()};
     nlohmann::json cameraJson;
     cameraJson["translation"] = translation;
     cameraJson["rotation"] = rotation;
-    cameraJson["distance"] = camera.zoomValue();
-    cameraJson["fov"] = camera.fovValue();
+    cameraJson["distance"] = camera.zoomValue ();
+    cameraJson["fov"] = camera.fovValue ();
     json["camera"] = cameraJson;
   }
 }
 
-void StreamVisitor::printCacheStatistic()
-{
-  if (is_enabled(RenderStatistic::CACHE)) {
+void StreamVisitor::printCacheStatistic () {
+  if (is_enabled (RenderStatistic::CACHE)) {
     nlohmann::json cacheJson;
-    cacheJson["geometry_cache"] = getCache(GeometryCache::instance());
+    cacheJson["geometry_cache"] = getCache (GeometryCache::instance ());
 #ifdef ENABLE_CGAL
-    cacheJson["cgal_cache"] = getCache(CGALCache::instance());
+    cacheJson["cgal_cache"] = getCache (CGALCache::instance ());
 #endif // ENABLE_CGAL
     json["cache"] = cacheJson;
   }
 }
 
-void StreamVisitor::printRenderingTime(const std::chrono::milliseconds ms)
-{
-  if (is_enabled(RenderStatistic::TIME)) {
+void StreamVisitor::printRenderingTime (const std::chrono::milliseconds ms) {
+  if (is_enabled (RenderStatistic::TIME)) {
     nlohmann::json timeJson;
-    timeJson["time"] = (boost::format("%1$d:%2$02d:%3$02d.%4$03d")
-                        % (ms.count() / 1000 / 60 / 60)
-                        % (ms.count() / 1000 / 60 % 60)
-                        % (ms.count() / 1000 % 60)
-                        % (ms.count() % 1000)).str();
-    timeJson["total"] = ms.count();
-    timeJson["milliseconds"] = ms.count() % 1000;
-    timeJson["seconds"] = ms.count() / 1000 % 60;
-    timeJson["minutes"] = ms.count() / 1000 / 60 % 60;
-    timeJson["hours"] = ms.count() / 1000 / 60 / 60;
+    timeJson["time"] = (boost::format ("%1$d:%2$02d:%3$02d.%4$03d") % (ms.count () / 1000 / 60 / 60) % (ms.count () / 1000 / 60 % 60) % (ms.count () / 1000 % 60) % (ms.count () % 1000)).str ();
+    timeJson["total"] = ms.count ();
+    timeJson["milliseconds"] = ms.count () % 1000;
+    timeJson["seconds"] = ms.count () / 1000 % 60;
+    timeJson["minutes"] = ms.count () / 1000 / 60 % 60;
+    timeJson["hours"] = ms.count () / 1000 / 60 / 60;
     json["time"] = timeJson;
   }
 }
 
-void StreamVisitor::finish()
-{
+void StreamVisitor::finish () {
   stream << json;
 }
diff --git a/src/RenderStatistic.h b/src/RenderStatistic.h
index ebe2edd15..1c31cfe2b 100644
--- a/src/RenderStatistic.h
+++ b/src/RenderStatistic.h
@@ -51,33 +51,33 @@ public:
    * Construct a statistic printer for the given geometry with current
    * time as start time.
    */
-  RenderStatistic();
+  RenderStatistic ();
 
   /**
    * Set start time when reusing a RenderStatistic instance.
    */
-  void start();
+  void start ();
 
   /**
    * Return render time in milliseconds.
    */
-  std::chrono::milliseconds ms();
+  std::chrono::milliseconds ms ();
 
   /**
    * Print some statistic on cache usage. Namely, stats on the @ref GeometryCache
    * and @ref CGALCache (if enabled).
    */
-  void printCacheStatistic();
+  void printCacheStatistic ();
 
   /**
    * Format and print time elapsed by rendering.
    */
-  void printRenderingTime();
+  void printRenderingTime ();
 
   /**
    * Print all available statistic information.
    */
-  void printAll(const std::shared_ptr<const Geometry>& geom, const Camera& camera, const std::vector<std::string>& options = {}, const std::string& filename = {});
+  void printAll (const std::shared_ptr<const Geometry> &geom, const Camera &camera, const std::vector<std::string> &options = {}, const std::string &filename = {});
 
 private:
   std::chrono::steady_clock::time_point begin;
diff --git a/src/core/AST.cc b/src/core/AST.cc
index 7cc82107a..66faf4414 100644
--- a/src/core/AST.cc
+++ b/src/core/AST.cc
@@ -6,40 +6,37 @@
 #include <string>
 #include "io/fileutils.h"
 
-const Location Location::NONE(0, 0, 0, 0, std::make_shared<fs::path>(fs::path{}));
+const Location Location::NONE (0, 0, 0, 0, std::make_shared<fs::path> (fs::path{}));
 
-bool operator==(Location const& lhs, Location const& rhs){
-  return
-    lhs.firstLine() == rhs.firstLine() &&
-    lhs.firstColumn() == rhs.firstColumn() &&
-    lhs.lastLine() == rhs.lastLine() &&
-    lhs.lastColumn() == rhs.lastColumn() &&
-    lhs.filePath() == rhs.filePath();
+bool operator== (Location const &lhs, Location const &rhs) {
+  return lhs.firstLine () == rhs.firstLine () &&
+         lhs.firstColumn () == rhs.firstColumn () &&
+         lhs.lastLine () == rhs.lastLine () &&
+         lhs.lastColumn () == rhs.lastColumn () &&
+         lhs.filePath () == rhs.filePath ();
 }
 
-bool operator!=(Location const& lhs, Location const& rhs)
-{
+bool operator!= (Location const &lhs, Location const &rhs) {
   return !(lhs == rhs);
 }
 
-bool Location::isNone() const {
+bool Location::isNone () const {
   return ((*this) == Location::NONE);
 }
 
-std::string Location::toRelativeString(const std::string& docPath) const {
-  if (this->isNone()) return "location unknown";
-  return "in file " + fs_uncomplete((*path), docPath).generic_string() + ", " + "line " + std::to_string(this->firstLine());
+std::string Location::toRelativeString (const std::string &docPath) const {
+  if (this->isNone ())
+    return "location unknown";
+  return "in file " + fs_uncomplete ((*path), docPath).generic_string () + ", " + "line " + std::to_string (this->firstLine ());
 }
 
-std::ostream& operator<<(std::ostream& stream, const ASTNode& ast)
-{
-  ast.print(stream, "");
+std::ostream &operator<< (std::ostream &stream, const ASTNode &ast) {
+  ast.print (stream, "");
   return stream;
 }
 
-std::string ASTNode::dump(const std::string& indent) const
-{
+std::string ASTNode::dump (const std::string &indent) const {
   std::ostringstream stream;
-  print(stream, indent);
-  return stream.str();
+  print (stream, indent);
+  return stream.str ();
 }
diff --git a/src/core/AST.h b/src/core/AST.h
index da3d8c7a2..7f9f281a0 100644
--- a/src/core/AST.h
+++ b/src/core/AST.h
@@ -13,26 +13,42 @@ class Location
 {
 
 public:
-  Location(int firstLine, int firstCol, int lastLine, int lastCol,
-           std::shared_ptr<fs::path> path)
-    : first_line(firstLine), first_col(firstCol), last_line(lastLine),
-    last_col(lastCol), path(std::move(path)) {
+  Location (int firstLine, int firstCol, int lastLine, int lastCol,
+            std::shared_ptr<fs::path> path)
+    : first_line (firstLine)
+    , first_col (firstCol)
+    , last_line (lastLine)
+    , last_col (lastCol)
+    , path (std::move (path)) {
   }
 
-  [[nodiscard]] std::string fileName() const { return path ? path->generic_string() : ""; }
-  [[nodiscard]] const fs::path& filePath() const { return *path; }
-  [[nodiscard]] int firstLine() const { return first_line; }
-  [[nodiscard]] int firstColumn() const { return first_col; }
-  [[nodiscard]] int lastLine() const { return last_line; }
-  [[nodiscard]] int lastColumn() const { return last_col; }
-  [[nodiscard]] bool isNone() const;
+  [[nodiscard]] std::string fileName () const {
+    return path ? path->generic_string () : "";
+  }
+  [[nodiscard]] const fs::path &filePath () const {
+    return *path;
+  }
+  [[nodiscard]] int firstLine () const {
+    return first_line;
+  }
+  [[nodiscard]] int firstColumn () const {
+    return first_col;
+  }
+  [[nodiscard]] int lastLine () const {
+    return last_line;
+  }
+  [[nodiscard]] int lastColumn () const {
+    return last_col;
+  }
+  [[nodiscard]] bool isNone () const;
 
-  [[nodiscard]] std::string toRelativeString(const std::string& docPath) const;
+  [[nodiscard]] std::string toRelativeString (const std::string &docPath) const;
 
-  bool operator==(Location const& rhs);
-  bool operator!=(Location const& rhs);
+  bool operator== (Location const &rhs);
+  bool operator!= (Location const &rhs);
 
   static const Location NONE;
+
 private:
   int first_line;
   int first_col;
@@ -44,17 +60,22 @@ private:
 class ASTNode
 {
 public:
-  ASTNode(Location loc) : loc(std::move(loc)) {}
-  virtual ~ASTNode() = default;
+  ASTNode (Location loc)
+    : loc (std::move (loc)) {}
+  virtual ~ASTNode () = default;
 
-  virtual void print(std::ostream& stream, const std::string& indent) const = 0;
+  virtual void print (std::ostream &stream, const std::string &indent) const = 0;
 
-  [[nodiscard]] std::string dump(const std::string& indent) const;
-  [[nodiscard]] const Location& location() const { return loc; }
-  void setLocation(const Location& loc) { this->loc = loc; }
+  [[nodiscard]] std::string dump (const std::string &indent) const;
+  [[nodiscard]] const Location &location () const {
+    return loc;
+  }
+  void setLocation (const Location &loc) {
+    this->loc = loc;
+  }
 
 protected:
   Location loc;
 };
 
-std::ostream& operator<<(std::ostream& stream, const ASTNode& ast);
+std::ostream &operator<< (std::ostream &stream, const ASTNode &ast);
diff --git a/src/core/Arguments.cc b/src/core/Arguments.cc
index 658e89eae..8e86f0a66 100644
--- a/src/core/Arguments.cc
+++ b/src/core/Arguments.cc
@@ -30,39 +30,34 @@
 #include <memory>
 #include "core/Expression.h"
 
-Arguments::Arguments(const AssignmentList& argument_expressions, const std::shared_ptr<const Context>& context) :
-  evaluation_session(context->session())
-{
-  for (const auto& argument_expression : argument_expressions) {
-    emplace_back(
-      argument_expression->getName().empty() ? boost::none : boost::optional<std::string>(argument_expression->getName()),
-      argument_expression->getExpr()->evaluate(context)
-      );
+Arguments::Arguments (const AssignmentList &argument_expressions, const std::shared_ptr<const Context> &context)
+  : evaluation_session (context->session ()) {
+  for (const auto &argument_expression : argument_expressions) {
+    emplace_back (
+      argument_expression->getName ().empty () ? boost::none : boost::optional<std::string> (argument_expression->getName ()),
+      argument_expression->getExpr ()->evaluate (context));
   }
 }
 
-Arguments Arguments::clone() const
-{
-  Arguments output(evaluation_session);
-  for (const Argument& argument : *this) {
-    output.emplace_back(argument.name, argument.value.clone());
+Arguments Arguments::clone () const {
+  Arguments output (evaluation_session);
+  for (const Argument &argument : *this) {
+    output.emplace_back (argument.name, argument.value.clone ());
   }
   return output;
 }
 
-std::ostream& operator<<(std::ostream& stream, const Argument& argument)
-{
+std::ostream &operator<< (std::ostream &stream, const Argument &argument) {
   if (argument.name) {
     stream << *argument.name << " = ";
   }
-  stream << argument.value.toEchoString();
+  stream << argument.value.toEchoString ();
   return stream;
 }
 
-std::ostream& operator<<(std::ostream& stream, const Arguments& arguments)
-{
+std::ostream &operator<< (std::ostream &stream, const Arguments &arguments) {
   bool first = true;
-  for (const auto& argument : arguments) {
+  for (const auto &argument : arguments) {
     if (first) {
       first = false;
     } else {
diff --git a/src/core/Arguments.h b/src/core/Arguments.h
index 120e8e88c..f9e0f358a 100644
--- a/src/core/Arguments.h
+++ b/src/core/Arguments.h
@@ -14,40 +14,51 @@ struct Argument {
   boost::optional<std::string> name;
   Value value;
 
-  Argument(boost::optional<std::string> name, Value value) : name(std::move(name)), value(std::move(value)) {
+  Argument (boost::optional<std::string> name, Value value)
+    : name (std::move (name))
+    , value (std::move (value)) {
+  }
+  Argument (Argument &&other) = default;
+  Argument &operator= (Argument &&other) = default;
+  Argument (const Argument &other) = delete;
+  Argument &operator= (const Argument &other) = delete;
+  ~Argument () = default;
+
+  const Value *operator->() const {
+    return &value;
+  }
+  Value *operator->() {
+    return &value;
   }
-  Argument(Argument&& other) = default;
-  Argument& operator=(Argument&& other) = default;
-  Argument(const Argument& other) = delete;
-  Argument& operator=(const Argument& other) = delete;
-  ~Argument() = default;
-
-  const Value *operator->() const { return &value; }
-  Value *operator->() { return &value; }
 };
 
 class Arguments : public std::vector<Argument>
 {
 public:
-  Arguments(const AssignmentList& argument_expressions, const std::shared_ptr<const Context>& context);
-  Arguments(Arguments&& other) = default;
-  Arguments& operator=(Arguments&& other) = default;
-  Arguments(const Arguments& other) = delete;
-  Arguments& operator=(const Arguments& other) = delete;
-  ~Arguments() = default;
+  Arguments (const AssignmentList &argument_expressions, const std::shared_ptr<const Context> &context);
+  Arguments (Arguments &&other) = default;
+  Arguments &operator= (Arguments &&other) = default;
+  Arguments (const Arguments &other) = delete;
+  Arguments &operator= (const Arguments &other) = delete;
+  ~Arguments () = default;
 
 private:
-  Arguments(EvaluationSession *session) : evaluation_session(session) {}
+  Arguments (EvaluationSession *session)
+    : evaluation_session (session) {}
 
 public:
-  [[nodiscard]] Arguments clone() const;
+  [[nodiscard]] Arguments clone () const;
 
-  [[nodiscard]] EvaluationSession *session() const { return evaluation_session; }
-  [[nodiscard]] const std::string& documentRoot() const { return evaluation_session->documentRoot(); }
+  [[nodiscard]] EvaluationSession *session () const {
+    return evaluation_session;
+  }
+  [[nodiscard]] const std::string &documentRoot () const {
+    return evaluation_session->documentRoot ();
+  }
 
 private:
   EvaluationSession *evaluation_session;
 };
 
-std::ostream& operator<<(std::ostream& stream, const Argument& argument);
-std::ostream& operator<<(std::ostream& stream, const Arguments& arguments);
+std::ostream &operator<< (std::ostream &stream, const Argument &argument);
+std::ostream &operator<< (std::ostream &stream, const Arguments &arguments);
diff --git a/src/core/Assignment.cc b/src/core/Assignment.cc
index 10860e0de..7caa0740c 100644
--- a/src/core/Assignment.cc
+++ b/src/core/Assignment.cc
@@ -30,55 +30,52 @@
 #include <ostream>
 #include <string>
 
-void Assignment::addAnnotations(AnnotationList *annotations)
-{
-  for (auto& annotation : *annotations) {
-    this->annotations.insert({annotation.getName(), &annotation});
+void Assignment::addAnnotations (AnnotationList *annotations) {
+  for (auto &annotation : *annotations) {
+    this->annotations.insert ({annotation.getName (), &annotation});
   }
 }
 
-bool Assignment::hasAnnotations() const
-{
-  return !annotations.empty();
+bool Assignment::hasAnnotations () const {
+  return !annotations.empty ();
 }
 
-const Annotation *Assignment::annotation(const std::string& name) const
-{
-  auto found = annotations.find(name);
-  return found == annotations.end() ? nullptr : found->second;
+const Annotation *Assignment::annotation (const std::string &name) const {
+  auto found = annotations.find (name);
+  return found == annotations.end () ? nullptr : found->second;
 }
 
-
-void Assignment::print(std::ostream& stream, const std::string& indent) const
-{
-  if (this->hasAnnotations()) {
-    const Annotation *group = this->annotation("Group");
-    if (group) group->print(stream, indent);
-    const Annotation *description = this->annotation("Description");
-    if (description) description->print(stream, indent);
-    const Annotation *parameter = this->annotation("Parameter");
-    if (parameter) parameter->print(stream, indent);
+void Assignment::print (std::ostream &stream, const std::string &indent) const {
+  if (this->hasAnnotations ()) {
+    const Annotation *group = this->annotation ("Group");
+    if (group)
+      group->print (stream, indent);
+    const Annotation *description = this->annotation ("Description");
+    if (description)
+      description->print (stream, indent);
+    const Annotation *parameter = this->annotation ("Parameter");
+    if (parameter)
+      parameter->print (stream, indent);
   }
   stream << indent << this->name << " = " << *this->expr << ";\n";
 }
 
-std::ostream& operator<<(std::ostream& stream, const AssignmentList& assignments)
-{
+std::ostream &operator<< (std::ostream &stream, const AssignmentList &assignments) {
   bool first = true;
-  for (const auto& assignment : assignments) {
+  for (const auto &assignment : assignments) {
     if (first) {
       first = false;
     } else {
       stream << ", ";
     }
-    if (!assignment->getName().empty()) {
-      stream << assignment->getName();
+    if (!assignment->getName ().empty ()) {
+      stream << assignment->getName ();
     }
-    if (!assignment->getName().empty() && assignment->getExpr()) {
+    if (!assignment->getName ().empty () && assignment->getExpr ()) {
       stream << " = ";
     }
-    if (assignment->getExpr()) {
-      stream << *assignment->getExpr();
+    if (assignment->getExpr ()) {
+      stream << *assignment->getExpr ();
     }
   }
   return stream;
diff --git a/src/core/Assignment.h b/src/core/Assignment.h
index 7a360fc6c..c97afec72 100644
--- a/src/core/Assignment.h
+++ b/src/core/Assignment.h
@@ -13,26 +13,43 @@
 class Assignment : public ASTNode
 {
 public:
-  Assignment(std::string name, const Location& loc)
-    : ASTNode(loc), name(std::move(name)), locOfOverwrite(Location::NONE) { }
-  Assignment(std::string name,
-             std::shared_ptr<class Expression> expr = {},
-             const Location& loc = Location::NONE)
-    : ASTNode(loc), name(std::move(name)), expr(std::move(expr)), locOfOverwrite(Location::NONE){ }
-
-  void print(std::ostream& stream, const std::string& indent) const override;
-  const std::string& getName() const { return name; }
-  const std::shared_ptr<Expression>& getExpr() const { return expr; }
-  const AnnotationMap& getAnnotations() const { return annotations; }
+  Assignment (std::string name, const Location &loc)
+    : ASTNode (loc)
+    , name (std::move (name))
+    , locOfOverwrite (Location::NONE) {}
+  Assignment (std::string name,
+              std::shared_ptr<class Expression> expr = {},
+              const Location &loc = Location::NONE)
+    : ASTNode (loc)
+    , name (std::move (name))
+    , expr (std::move (expr))
+    , locOfOverwrite (Location::NONE) {}
+
+  void print (std::ostream &stream, const std::string &indent) const override;
+  const std::string &getName () const {
+    return name;
+  }
+  const std::shared_ptr<Expression> &getExpr () const {
+    return expr;
+  }
+  const AnnotationMap &getAnnotations () const {
+    return annotations;
+  }
   // setExpr used by customizer ParameterObject etc.
-  void setExpr(std::shared_ptr<Expression> e) { expr = std::move(e); }
+  void setExpr (std::shared_ptr<Expression> e) {
+    expr = std::move (e);
+  }
 
-  virtual void addAnnotations(AnnotationList *annotations);
-  virtual bool hasAnnotations() const;
-  virtual const Annotation *annotation(const std::string& name) const;
+  virtual void addAnnotations (AnnotationList *annotations);
+  virtual bool hasAnnotations () const;
+  virtual const Annotation *annotation (const std::string &name) const;
 
-  const Location& locationOfOverwrite() const { return locOfOverwrite; }
-  void setLocationOfOverwrite(const Location& locOfOverwrite) { this->locOfOverwrite = locOfOverwrite; }
+  const Location &locationOfOverwrite () const {
+    return locOfOverwrite;
+  }
+  void setLocationOfOverwrite (const Location &locOfOverwrite) {
+    this->locOfOverwrite = locOfOverwrite;
+  }
 
 protected:
   const std::string name;
@@ -41,11 +58,12 @@ protected:
   Location locOfOverwrite;
 };
 
-template <class ... Args> std::shared_ptr<Assignment> assignment(Args... args) {
-  return std::make_shared<Assignment>(args ...);
+template <class... Args>
+std::shared_ptr<Assignment> assignment (Args... args) {
+  return std::make_shared<Assignment> (args...);
 }
 
 using AssignmentList = std::vector<std::shared_ptr<Assignment>>;
 using AssignmentMap = std::unordered_map<std::string, const Expression *>;
 
-std::ostream& operator<<(std::ostream& stream, const AssignmentList& assignments);
+std::ostream &operator<< (std::ostream &stream, const AssignmentList &assignments);
diff --git a/src/core/BaseVisitable.h b/src/core/BaseVisitable.h
index e78901a4f..fe894db47 100644
--- a/src/core/BaseVisitable.h
+++ b/src/core/BaseVisitable.h
@@ -1,34 +1,36 @@
 #pragma once
 
-
 // FIXME: Default constructor Response()
-enum class Response {ContinueTraversal, AbortTraversal, PruneTraversal};
+enum class Response { ContinueTraversal,
+                      AbortTraversal,
+                      PruneTraversal };
 
 class State;
 
 class BaseVisitor
 {
 public:
-  virtual ~BaseVisitor() = default;
+  virtual ~BaseVisitor () = default;
 };
 
 template <class T>
 class Visitor
 {
 public:
-  virtual Response visit(State& state, const T&) = 0;
+  virtual Response visit (State &state, const T &) = 0;
 };
 
 class BaseVisitable
 {
 public:
-  virtual ~BaseVisitable() = default;
-  virtual Response accept(State&, BaseVisitor&) const = 0;
+  virtual ~BaseVisitable () = default;
+  virtual Response accept (State &, BaseVisitor &) const = 0;
+
 protected:
   template <class T>
-  static Response acceptImpl(State& state, const T& node, BaseVisitor& visitor) {
-    if (auto *p = dynamic_cast<Visitor<T> *>(&visitor)) {
-      return p->visit(state, node);
+  static Response acceptImpl (State &state, const T &node, BaseVisitor &visitor) {
+    if (auto *p = dynamic_cast<Visitor<T> *> (&visitor)) {
+      return p->visit (state, node);
     }
     // FIXME: If we want to allow for missing nodes in visitors, we need
     // to handle it here, e.g. by calling some handler.
@@ -37,7 +39,7 @@ protected:
   }
 };
 
-#define VISITABLE() \
-        Response accept(State & state, BaseVisitor & visitor) const override { \
-          return acceptImpl(state, *this, visitor); \
-        }
+#define VISITABLE()                                                     \
+  Response accept (State &state, BaseVisitor &visitor) const override { \
+    return acceptImpl (state, *this, visitor);                          \
+  }
diff --git a/src/core/BuiltinContext.cc b/src/core/BuiltinContext.cc
index 76b3c7c46..673e41342 100644
--- a/src/core/BuiltinContext.cc
+++ b/src/core/BuiltinContext.cc
@@ -8,48 +8,45 @@
 #include "core/function.h"
 #include "utils/printutils.h"
 
-BuiltinContext::BuiltinContext(EvaluationSession *session) : Context(session)
-{
+BuiltinContext::BuiltinContext (EvaluationSession *session)
+  : Context (session) {
 }
 
-void BuiltinContext::init()
-{
-  for (const auto& assignment : Builtins::instance()->getAssignments()) {
-    this->set_variable(assignment->getName(), assignment->getExpr()->evaluate(shared_from_this()));
+void BuiltinContext::init () {
+  for (const auto &assignment : Builtins::instance ()->getAssignments ()) {
+    this->set_variable (assignment->getName (), assignment->getExpr ()->evaluate (shared_from_this ()));
   }
 
-  this->set_variable("PI", M_PI);
+  this->set_variable ("PI", M_PI);
 }
 
-boost::optional<CallableFunction> BuiltinContext::lookup_local_function(const std::string& name, const Location& loc) const
-{
-  const auto& search = Builtins::instance()->getFunctions().find(name);
-  if (search != Builtins::instance()->getFunctions().end()) {
+boost::optional<CallableFunction> BuiltinContext::lookup_local_function (const std::string &name, const Location &loc) const {
+  const auto &search = Builtins::instance ()->getFunctions ().find (name);
+  if (search != Builtins::instance ()->getFunctions ().end ()) {
     BuiltinFunction *f = search->second;
-    if (f->is_enabled()) {
+    if (f->is_enabled ()) {
       return CallableFunction{f};
     }
 
-    LOG(message_group::Warning, loc, documentRoot(), "Experimental builtin function '%1$s' is not enabled", name);
+    LOG (message_group::Warning, loc, documentRoot (), "Experimental builtin function '%1$s' is not enabled", name);
   }
-  return Context::lookup_local_function(name, loc);
+  return Context::lookup_local_function (name, loc);
 }
 
-boost::optional<InstantiableModule> BuiltinContext::lookup_local_module(const std::string& name, const Location& loc) const
-{
-  const auto& search = Builtins::instance()->getModules().find(name);
-  if (search != Builtins::instance()->getModules().end()) {
+boost::optional<InstantiableModule> BuiltinContext::lookup_local_module (const std::string &name, const Location &loc) const {
+  const auto &search = Builtins::instance ()->getModules ().find (name);
+  if (search != Builtins::instance ()->getModules ().end ()) {
     AbstractModule *m = search->second;
-    if (!m->is_enabled()) {
-      LOG(message_group::Warning, loc, documentRoot(), "Experimental builtin module '%1$s' is not enabled", name);
+    if (!m->is_enabled ()) {
+      LOG (message_group::Warning, loc, documentRoot (), "Experimental builtin module '%1$s' is not enabled", name);
     }
-    std::string replacement = Builtins::instance()->instance()->isDeprecated(name);
-    if (!replacement.empty()) {
-      LOG(message_group::Deprecated, loc, documentRoot(), "The %1$s() module will be removed in future releases. Use %2$s instead.", name, replacement);
+    std::string replacement = Builtins::instance ()->instance ()->isDeprecated (name);
+    if (!replacement.empty ()) {
+      LOG (message_group::Deprecated, loc, documentRoot (), "The %1$s() module will be removed in future releases. Use %2$s instead.", name, replacement);
     }
-    if (m->is_enabled()) {
-      return InstantiableModule{get_shared_ptr(), m};
+    if (m->is_enabled ()) {
+      return InstantiableModule{get_shared_ptr (), m};
     }
   }
-  return Context::lookup_local_module(name, loc);
+  return Context::lookup_local_module (name, loc);
 }
diff --git a/src/core/BuiltinContext.h b/src/core/BuiltinContext.h
index 4efdf4f17..6f50e22cc 100644
--- a/src/core/BuiltinContext.h
+++ b/src/core/BuiltinContext.h
@@ -8,12 +8,12 @@
 class BuiltinContext : public Context
 {
 public:
-  void init() override;
-  boost::optional<CallableFunction> lookup_local_function(const std::string& name, const Location& loc) const override;
-  boost::optional<InstantiableModule> lookup_local_module(const std::string& name, const Location& loc) const override;
+  void init () override;
+  boost::optional<CallableFunction> lookup_local_function (const std::string &name, const Location &loc) const override;
+  boost::optional<InstantiableModule> lookup_local_module (const std::string &name, const Location &loc) const override;
 
 protected:
-  BuiltinContext(EvaluationSession *session);
+  BuiltinContext (EvaluationSession *session);
 
   friend class Context;
 };
diff --git a/src/core/Builtins.cc b/src/core/Builtins.cc
index 4647fc951..7e32e3887 100644
--- a/src/core/Builtins.cc
+++ b/src/core/Builtins.cc
@@ -12,8 +12,7 @@
 
 std::unordered_map<std::string, const std::vector<std::string>> Builtins::keywordList;
 
-Builtins *Builtins::instance(bool erase)
-{
+Builtins *Builtins::instance (bool erase) {
   static auto *builtins = new Builtins;
   if (erase) {
     delete builtins;
@@ -22,120 +21,116 @@ Builtins *Builtins::instance(bool erase)
   return builtins;
 }
 
-void Builtins::init(const std::string& name, class AbstractModule *module)
-{
+void Builtins::init (const std::string &name, class AbstractModule *module) {
 #ifndef ENABLE_EXPERIMENTAL
-  if (module->is_experimental()) return;
+  if (module->is_experimental ())
+    return;
 #endif
-  Builtins::instance()->modules.emplace(name, module);
+  Builtins::instance ()->modules.emplace (name, module);
 }
 
-void Builtins::init(const std::string& name, AbstractModule *module, const std::vector<std::string>& calltipList)
-{
+void Builtins::init (const std::string &name, AbstractModule *module, const std::vector<std::string> &calltipList) {
 #ifndef ENABLE_EXPERIMENTAL
-  if (module->is_experimental()) return;
+  if (module->is_experimental ())
+    return;
 #endif
-  Builtins::instance()->modules.emplace(name, module);
-  Builtins::keywordList.insert({name, calltipList});
+  Builtins::instance ()->modules.emplace (name, module);
+  Builtins::keywordList.insert ({name, calltipList});
 }
 
-void Builtins::init(const std::string& name, BuiltinFunction *function, const std::vector<std::string>& calltipList)
-{
+void Builtins::init (const std::string &name, BuiltinFunction *function, const std::vector<std::string> &calltipList) {
 #ifndef ENABLE_EXPERIMENTAL
-  if (function->is_experimental()) return;
+  if (function->is_experimental ())
+    return;
 #endif
-  Builtins::instance()->functions.emplace(name, function);
-  Builtins::keywordList.insert({name, calltipList});
+  Builtins::instance ()->functions.emplace (name, function);
+  Builtins::keywordList.insert ({name, calltipList});
 }
 
-extern void register_builtin_functions();
-extern void register_builtin_group();
-extern void register_builtin_csgops();
-extern void register_builtin_transform();
-extern void register_builtin_color();
-extern void register_builtin_primitives();
-extern void register_builtin_surface();
-extern void register_builtin_control();
-extern void register_builtin_render();
-extern void register_builtin_import();
-extern void register_builtin_projection();
-extern void register_builtin_cgaladv();
-extern void register_builtin_offset();
-extern void register_builtin_linear_extrude();
-extern void register_builtin_rotate_extrude();
+extern void register_builtin_functions ();
+extern void register_builtin_group ();
+extern void register_builtin_csgops ();
+extern void register_builtin_transform ();
+extern void register_builtin_color ();
+extern void register_builtin_primitives ();
+extern void register_builtin_surface ();
+extern void register_builtin_control ();
+extern void register_builtin_render ();
+extern void register_builtin_import ();
+extern void register_builtin_projection ();
+extern void register_builtin_cgaladv ();
+extern void register_builtin_offset ();
+extern void register_builtin_linear_extrude ();
+extern void register_builtin_rotate_extrude ();
 #if defined(ENABLE_EXPERIMENTAL) && defined(ENABLE_CGAL)
-extern void register_builtin_roof();
+extern void register_builtin_roof ();
 #endif
-extern void register_builtin_text();
-extern void initialize_builtin_dxf_dim();
+extern void register_builtin_text ();
+extern void initialize_builtin_dxf_dim ();
 
 /*!
    Registers all builtin functions.
    Call once for the whole app.
  */
-void Builtins::initialize()
-{
-  Builtins::initKeywordList();
+void Builtins::initialize () {
+  Builtins::initKeywordList ();
 
-  register_builtin_functions();
-  initialize_builtin_dxf_dim();
+  register_builtin_functions ();
+  initialize_builtin_dxf_dim ();
 
-  register_builtin_group();
-  register_builtin_csgops();
-  register_builtin_transform();
-  register_builtin_color();
-  register_builtin_primitives();
-  register_builtin_surface();
-  register_builtin_control();
-  register_builtin_render();
-  register_builtin_import();
-  register_builtin_projection();
-  register_builtin_cgaladv();
-  register_builtin_offset();
-  register_builtin_linear_extrude();
-  register_builtin_rotate_extrude();
+  register_builtin_group ();
+  register_builtin_csgops ();
+  register_builtin_transform ();
+  register_builtin_color ();
+  register_builtin_primitives ();
+  register_builtin_surface ();
+  register_builtin_control ();
+  register_builtin_render ();
+  register_builtin_import ();
+  register_builtin_projection ();
+  register_builtin_cgaladv ();
+  register_builtin_offset ();
+  register_builtin_linear_extrude ();
+  register_builtin_rotate_extrude ();
 #if defined(ENABLE_EXPERIMENTAL) && defined(ENABLE_CGAL)
-  register_builtin_roof();
+  register_builtin_roof ();
 #endif
-  register_builtin_text();
+  register_builtin_text ();
 
-  this->deprecations.emplace("assign", "a regular assignment");
+  this->deprecations.emplace ("assign", "a regular assignment");
 }
 
-std::string Builtins::isDeprecated(const std::string& name) const
-{
-  if (this->deprecations.find(name) != this->deprecations.end()) {
-    return this->deprecations.at(name);
+std::string Builtins::isDeprecated (const std::string &name) const {
+  if (this->deprecations.find (name) != this->deprecations.end ()) {
+    return this->deprecations.at (name);
   }
   return {};
 }
 
-Builtins::Builtins()
-{
-  this->assignments.emplace_back(new Assignment("$fn", std::make_shared<Literal>(0.0)) );
-  this->assignments.emplace_back(new Assignment("$fs", std::make_shared<Literal>(2.0)) );
-  this->assignments.emplace_back(new Assignment("$fa", std::make_shared<Literal>(12.0)) );
-  this->assignments.emplace_back(new Assignment("$t", std::make_shared<Literal>(0.0)) );
-  this->assignments.emplace_back(new Assignment("$preview", std::make_shared<Literal>()) ); //undef as should always be overwritten.
-  auto zeroVector = std::make_shared<Vector>(Location::NONE);
-  zeroVector->emplace_back(new Literal(0.0));
-  zeroVector->emplace_back(new Literal(0.0));
-  zeroVector->emplace_back(new Literal(0.0));
-  this->assignments.emplace_back(new Assignment("$vpt", zeroVector) );
-  this->assignments.emplace_back(new Assignment("$vpr", zeroVector) );
-  this->assignments.emplace_back(new Assignment("$vpd", std::make_shared<Literal>(500.0)) );
-  this->assignments.emplace_back(new Assignment("$vpf", std::make_shared<Literal>(22.5)) );
+Builtins::Builtins () {
+  this->assignments.emplace_back (new Assignment ("$fn", std::make_shared<Literal> (0.0)));
+  this->assignments.emplace_back (new Assignment ("$fs", std::make_shared<Literal> (2.0)));
+  this->assignments.emplace_back (new Assignment ("$fa", std::make_shared<Literal> (12.0)));
+  this->assignments.emplace_back (new Assignment ("$t", std::make_shared<Literal> (0.0)));
+  this->assignments.emplace_back (new Assignment ("$preview", std::make_shared<Literal> ())); //undef as should always be overwritten.
+  auto zeroVector = std::make_shared<Vector> (Location::NONE);
+  zeroVector->emplace_back (new Literal (0.0));
+  zeroVector->emplace_back (new Literal (0.0));
+  zeroVector->emplace_back (new Literal (0.0));
+  this->assignments.emplace_back (new Assignment ("$vpt", zeroVector));
+  this->assignments.emplace_back (new Assignment ("$vpr", zeroVector));
+  this->assignments.emplace_back (new Assignment ("$vpd", std::make_shared<Literal> (500.0)));
+  this->assignments.emplace_back (new Assignment ("$vpf", std::make_shared<Literal> (22.5)));
 }
 
-void Builtins::initKeywordList()
-{
-  Builtins::keywordList.insert({"else", {}});
-  Builtins::keywordList.insert({"each", {}});
-  Builtins::keywordList.insert({"module", {}});
-  Builtins::keywordList.insert({"function", {}});
-  Builtins::keywordList.insert({"true", {}});
-  Builtins::keywordList.insert({"false", {}});
-  Builtins::keywordList.insert({"undef", {}});
-  Builtins::keywordList.insert({"use", {}});
-  Builtins::keywordList.insert({"include", {}});
+void Builtins::initKeywordList () {
+  Builtins::keywordList.insert ({"else", {}});
+  Builtins::keywordList.insert ({"each", {}});
+  Builtins::keywordList.insert ({"module", {}});
+  Builtins::keywordList.insert ({"function", {}});
+  Builtins::keywordList.insert ({"true", {}});
+  Builtins::keywordList.insert ({"false", {}});
+  Builtins::keywordList.insert ({"undef", {}});
+  Builtins::keywordList.insert ({"use", {}});
+  Builtins::keywordList.insert ({"include", {}});
 }
diff --git a/src/core/Builtins.h b/src/core/Builtins.h
index da90c2ada..d0b818795 100644
--- a/src/core/Builtins.h
+++ b/src/core/Builtins.h
@@ -9,29 +9,35 @@
 class AbstractModule;
 class BuiltinFunction;
 
-void initialize_rng();
+void initialize_rng ();
 
 class Builtins
 {
 public:
-  static Builtins *instance(bool erase = false);
-  static void init(const std::string& name, AbstractModule *module);
-  static void init(const std::string& name, AbstractModule *module, const std::vector<std::string>& calltipList);
-  static void init(const std::string& name, BuiltinFunction *function, const std::vector<std::string>& calltipList);
-  void initialize();
-  std::string isDeprecated(const std::string& name) const;
-
-  const auto& getAssignments() const { return this->assignments; }
-  const auto& getFunctions() const { return this->functions; }
-  const auto& getModules() const { return this->modules; }
+  static Builtins *instance (bool erase = false);
+  static void init (const std::string &name, AbstractModule *module);
+  static void init (const std::string &name, AbstractModule *module, const std::vector<std::string> &calltipList);
+  static void init (const std::string &name, BuiltinFunction *function, const std::vector<std::string> &calltipList);
+  void initialize ();
+  std::string isDeprecated (const std::string &name) const;
+
+  const auto &getAssignments () const {
+    return this->assignments;
+  }
+  const auto &getFunctions () const {
+    return this->functions;
+  }
+  const auto &getModules () const {
+    return this->modules;
+  }
 
   static std::unordered_map<std::string, const std::vector<std::string>> keywordList;
 
 private:
-  Builtins();
-  virtual ~Builtins() = default;
+  Builtins ();
+  virtual ~Builtins () = default;
 
-  static void initKeywordList();
+  static void initKeywordList ();
 
   AssignmentList assignments;
   std::unordered_map<std::string, BuiltinFunction *> functions;
diff --git a/src/core/CSGNode.cc b/src/core/CSGNode.cc
index d7d6bd691..5865383e6 100644
--- a/src/core/CSGNode.cc
+++ b/src/core/CSGNode.cc
@@ -67,120 +67,121 @@
    A CSGProduct is a vector of intersections and a vector of subtractions, used for CSG rendering.
  */
 
-std::shared_ptr<CSGNode> CSGNode::createEmptySet() {
-  return std::shared_ptr<CSGNode>(new CSGLeaf(nullptr, Transform3d(), Color4f(), "empty()", 0));
+std::shared_ptr<CSGNode> CSGNode::createEmptySet () {
+  return std::shared_ptr<CSGNode> (new CSGLeaf (nullptr, Transform3d (), Color4f (), "empty()", 0));
 }
 
-std::shared_ptr<CSGNode> CSGOperation::createCSGNode(OpenSCADOperator type, std::shared_ptr<CSGNode> left, std::shared_ptr<CSGNode> right)
-{
+std::shared_ptr<CSGNode> CSGOperation::createCSGNode (OpenSCADOperator type, std::shared_ptr<CSGNode> left, std::shared_ptr<CSGNode> right) {
   // Note that std::shared_ptr<CSGNode> == nullptr is different from having a CSGNode with std::shared_ptr<Geometry> geom == nullptr
   // The former indicates lack of a geometry node (could be echo or assert node), and the latter represents the empty set of geometry.
   if (!left && !right) {
-    return CSGNode::createEmptySet();
+    return CSGNode::createEmptySet ();
   } else if (!left && right) {
     return right;
   } else if (left && !right) {
     return left;
   } else {
     // In case we're creating a CSG term from a pruned tree, left or right may be the empty set
-    if (right->isEmptySet()) {
-      if (type == OpenSCADOperator::UNION || type == OpenSCADOperator::DIFFERENCE) return left;
-      else return right;
+    if (right->isEmptySet ()) {
+      if (type == OpenSCADOperator::UNION || type == OpenSCADOperator::DIFFERENCE)
+        return left;
+      else
+        return right;
     }
-    if (left->isEmptySet()) {
-      if (type == OpenSCADOperator::UNION) return right;
-      else return left;
+    if (left->isEmptySet ()) {
+      if (type == OpenSCADOperator::UNION)
+        return right;
+      else
+        return left;
     }
   }
 
   // Pruning the tree. For details, see "Solid Modeling" by Goldfeather:
   // http://www.cc.gatech.edu/~turk/my_papers/pxpl_csg.pdf
-  const auto& leftbox = left->getBoundingBox();
-  const auto& rightbox = right->getBoundingBox();
+  const auto &leftbox = left->getBoundingBox ();
+  const auto &rightbox = right->getBoundingBox ();
   Vector3d newmin, newmax;
   if (type == OpenSCADOperator::INTERSECTION) {
-    newmin = leftbox.min().array().cwiseMax(rightbox.min().array() );
-    newmax = leftbox.max().array().cwiseMin(rightbox.max().array() );
-    BoundingBox newbox(newmin, newmax);
-    if (newbox.isNull()) {
-      return CSGNode::createEmptySet(); // Prune entire product
+    newmin = leftbox.min ().array ().cwiseMax (rightbox.min ().array ());
+    newmax = leftbox.max ().array ().cwiseMin (rightbox.max ().array ());
+    BoundingBox newbox (newmin, newmax);
+    if (newbox.isNull ()) {
+      return CSGNode::createEmptySet (); // Prune entire product
     }
   } else if (type == OpenSCADOperator::DIFFERENCE) {
-    newmin = leftbox.min().array().cwiseMax(rightbox.min().array() );
-    newmax = leftbox.max().array().cwiseMin(rightbox.max().array() );
-    BoundingBox newbox(newmin, newmax);
-    if (newbox.isNull()) {
+    newmin = leftbox.min ().array ().cwiseMax (rightbox.min ().array ());
+    newmax = leftbox.max ().array ().cwiseMin (rightbox.max ().array ());
+    BoundingBox newbox (newmin, newmax);
+    if (newbox.isNull ()) {
       return left; // Prune the negative component
     }
   }
 
-  return {new CSGOperation(type, left, right), CSGOperationDeleter()};
+  return {new CSGOperation (type, left, right), CSGOperationDeleter ()};
 }
 
-CSGLeaf::CSGLeaf(const std::shared_ptr<const PolySet>& ps, Transform3d matrix, Color4f color, std::string label, const int index)
-  : label(std::move(label)), matrix(std::move(matrix)), color(std::move(color)), index(index)
-{
-  if (ps && !ps->isEmpty()) this->polyset = ps;
-  CSGLeaf::initBoundingBox();
+CSGLeaf::CSGLeaf (const std::shared_ptr<const PolySet> &ps, Transform3d matrix, Color4f color, std::string label, const int index)
+  : label (std::move (label))
+  , matrix (std::move (matrix))
+  , color (std::move (color))
+  , index (index) {
+  if (ps && !ps->isEmpty ())
+    this->polyset = ps;
+  CSGLeaf::initBoundingBox ();
 }
 
-CSGOperation::CSGOperation(OpenSCADOperator type, const std::shared_ptr<CSGNode>& left, const std::shared_ptr<CSGNode>& right)
-  : type(type)
-{
-  this->children.push_back(left);
-  this->children.push_back(right);
-  CSGOperation::initBoundingBox();
+CSGOperation::CSGOperation (OpenSCADOperator type, const std::shared_ptr<CSGNode> &left, const std::shared_ptr<CSGNode> &right)
+  : type (type) {
+  this->children.push_back (left);
+  this->children.push_back (right);
+  CSGOperation::initBoundingBox ();
 }
 
-void CSGLeaf::initBoundingBox()
-{
-  if (!this->polyset) return;
-  this->bbox = this->matrix * this->polyset->getBoundingBox();
+void CSGLeaf::initBoundingBox () {
+  if (!this->polyset)
+    return;
+  this->bbox = this->matrix * this->polyset->getBoundingBox ();
 }
 
-void CSGOperation::initBoundingBox()
-{
-  const auto& leftbox = this->left()->getBoundingBox();
-  const auto& rightbox = this->right()->getBoundingBox();
+void CSGOperation::initBoundingBox () {
+  const auto &leftbox = this->left ()->getBoundingBox ();
+  const auto &rightbox = this->right ()->getBoundingBox ();
   Vector3d newmin, newmax;
   switch (this->type) {
   case OpenSCADOperator::UNION:
-    this->bbox = leftbox.merged(rightbox);
+    this->bbox = leftbox.merged (rightbox);
     break;
   case OpenSCADOperator::INTERSECTION:
-    this->bbox = leftbox.intersection(rightbox);
+    this->bbox = leftbox.intersection (rightbox);
     break;
   case OpenSCADOperator::DIFFERENCE:
     this->bbox = leftbox;
     break;
   default:
-    assert(false);
+    assert (false);
   }
 }
 
-bool CSGLeaf::isEmptySet() const
-{
-  return polyset == nullptr || polyset->isEmpty();
+bool CSGLeaf::isEmptySet () const {
+  return polyset == nullptr || polyset->isEmpty ();
 }
 
-std::string CSGLeaf::dump() const
-{
+std::string CSGLeaf::dump () const {
   return this->label;
 }
 
 // Recursive traversal can cause stack overflow with very large loops of child nodes,
 // so tree is traverse iteratively, managing our own stack.
-std::string CSGOperation::dump() const
-{
+std::string CSGOperation::dump () const {
   // tuple(node pointer, postfix string, ispostfix bool)
   std::stack<std::tuple<const CSGOperation *, std::string, bool>> callstack;
-  callstack.emplace(this, "", false);
+  callstack.emplace (this, "", false);
   std::ostringstream out;
   const CSGOperation *node;
   std::string postfixstr;
   bool ispostfix;
   do {
-    std::tie(node, postfixstr, ispostfix) = callstack.top();
+    std::tie (node, postfixstr, ispostfix) = callstack.top ();
     if (!ispostfix) { // handle left child. only right child uses a prefix string
       std::string lpostfix;
       switch (node->type) {
@@ -194,143 +195,135 @@ std::string CSGOperation::dump() const
         lpostfix = " - ";
         break;
       default:
-        assert(false);
+        assert (false);
       }
 
       out << '(';
 
       // mark current node as postfix before (maybe) pushing left child
-      ispostfix = std::get<2>(callstack.top()) = true;
+      ispostfix = std::get<2> (callstack.top ()) = true;
 
-      if (auto opl = std::dynamic_pointer_cast<CSGOperation>(node->left())) {
-        callstack.emplace(opl.get(), lpostfix, false);
+      if (auto opl = std::dynamic_pointer_cast<CSGOperation> (node->left ())) {
+        callstack.emplace (opl.get (), lpostfix, false);
         continue;
       } else {
-        out << node->left()->dump() << lpostfix;
+        out << node->left ()->dump () << lpostfix;
       }
     }
 
     // postfix traversal of node, handle right child
     if (ispostfix) {
-      callstack.pop();
-      if (auto opr = std::dynamic_pointer_cast<CSGOperation>(node->right())) {
-        callstack.emplace(opr.get(), ")", false);
+      callstack.pop ();
+      if (auto opr = std::dynamic_pointer_cast<CSGOperation> (node->right ())) {
+        callstack.emplace (opr.get (), ")", false);
         continue;
       } else {
-        out << node->right()->dump() << ")";
+        out << node->right ()->dump () << ")";
       }
       out << postfixstr;
     }
 
-  } while (!callstack.empty());
-  return out.str();
+  } while (!callstack.empty ());
+  return out.str ();
 }
 
-void CSGProducts::import(std::shared_ptr<CSGNode> csgnode, OpenSCADOperator type, CSGNode::Flag flags)
-{
+void CSGProducts::import (std::shared_ptr<CSGNode> csgnode, OpenSCADOperator type, CSGNode::Flag flags) {
   std::stack<std::tuple<std::shared_ptr<CSGNode>, OpenSCADOperator, CSGNode::Flag>> callstack;
-  callstack.push(std::make_tuple(csgnode, type, flags));
+  callstack.push (std::make_tuple (csgnode, type, flags));
 
   do {
-    auto args = callstack.top();
-    callstack.pop();
-    csgnode = std::get<0>(args);
-    type = std::get<1>(args);
-    flags = std::get<2>(args);
+    auto args = callstack.top ();
+    callstack.pop ();
+    csgnode = std::get<0> (args);
+    type = std::get<1> (args);
+    flags = std::get<2> (args);
 
-    auto newflags = static_cast<CSGNode::Flag>(csgnode->getFlags() | flags);
+    auto newflags = static_cast<CSGNode::Flag> (csgnode->getFlags () | flags);
 
-    if (auto leaf = std::dynamic_pointer_cast<CSGLeaf>(csgnode)) {
-      if (type == OpenSCADOperator::UNION && this->currentproduct->intersections.size() > 0) {
-        this->createProduct();
+    if (auto leaf = std::dynamic_pointer_cast<CSGLeaf> (csgnode)) {
+      if (type == OpenSCADOperator::UNION && this->currentproduct->intersections.size () > 0) {
+        this->createProduct ();
       } else if (type == OpenSCADOperator::DIFFERENCE) {
         this->currentlist = &this->currentproduct->subtractions;
       } else if (type == OpenSCADOperator::INTERSECTION) {
         this->currentlist = &this->currentproduct->intersections;
       }
-      this->currentlist->emplace_back(leaf, newflags);
-    } else if (auto op = std::dynamic_pointer_cast<CSGOperation>(csgnode)) {
-      assert(op->left() && op->right());
-      callstack.emplace(op->right(), op->getType(), newflags);
-      callstack.emplace(op->left(), type, newflags);
+      this->currentlist->emplace_back (leaf, newflags);
+    } else if (auto op = std::dynamic_pointer_cast<CSGOperation> (csgnode)) {
+      assert (op->left () && op->right ());
+      callstack.emplace (op->right (), op->getType (), newflags);
+      callstack.emplace (op->left (), type, newflags);
     }
-  } while (!callstack.empty());
+  } while (!callstack.empty ());
 }
 
-std::string CSGProduct::dump() const
-{
+std::string CSGProduct::dump () const {
   std::ostringstream dump;
-  dump << this->intersections.front().leaf->label;
-  for (const auto& csgobj :
-       boost::make_iterator_range(this->intersections.begin() + 1,
-                                  this->intersections.end())) {
+  dump << this->intersections.front ().leaf->label;
+  for (const auto &csgobj :
+       boost::make_iterator_range (this->intersections.begin () + 1,
+                                   this->intersections.end ())) {
     dump << " *" << csgobj.leaf->label;
   }
-  for (const auto& csgobj : this->subtractions) {
+  for (const auto &csgobj : this->subtractions) {
     dump << " -" << csgobj.leaf->label;
   }
-  return dump.str();
+  return dump.str ();
 }
 
-BoundingBox CSGProduct::getBoundingBox(bool throwntogether) const
-{
+BoundingBox CSGProduct::getBoundingBox (bool throwntogether) const {
   BoundingBox bbox;
-  if (this->intersections.empty()) return bbox;
+  if (this->intersections.empty ())
+    return bbox;
 
   if (throwntogether) {
-    bbox = std::accumulate(
-      this->intersections.cbegin() + 1,
-      this->intersections.cend(),
-      this->intersections.front().leaf->bbox,
-      [](const BoundingBox& a, const CSGChainObject& b) {
-      return a.merged(b.leaf->bbox);
-    }
-      );
-    bbox = std::accumulate(
-      this->subtractions.cbegin(),
-      this->subtractions.cend(),
+    bbox = std::accumulate (
+      this->intersections.cbegin () + 1,
+      this->intersections.cend (),
+      this->intersections.front ().leaf->bbox,
+      [] (const BoundingBox &a, const CSGChainObject &b) {
+        return a.merged (b.leaf->bbox);
+      });
+    bbox = std::accumulate (
+      this->subtractions.cbegin (),
+      this->subtractions.cend (),
       bbox,
-      [](const BoundingBox& a, const CSGChainObject& b) {
-      return a.merged(b.leaf->bbox);
-    }
-      );
+      [] (const BoundingBox &a, const CSGChainObject &b) {
+        return a.merged (b.leaf->bbox);
+      });
   } else {
-    bbox = std::accumulate(
-      this->intersections.cbegin() + 1,
-      this->intersections.cend(),
-      this->intersections.front().leaf->bbox,
-      [](const BoundingBox& a, const CSGChainObject& b) {
-      return a.intersection(b.leaf->bbox);
-    }
-      );
+    bbox = std::accumulate (
+      this->intersections.cbegin () + 1,
+      this->intersections.cend (),
+      this->intersections.front ().leaf->bbox,
+      [] (const BoundingBox &a, const CSGChainObject &b) {
+        return a.intersection (b.leaf->bbox);
+      });
   }
   return bbox;
 }
 
-std::string CSGProducts::dump() const
-{
+std::string CSGProducts::dump () const {
   std::ostringstream dump;
 
-  for (const auto& product : this->products) {
-    dump << "+" << product.dump() << "\n";
+  for (const auto &product : this->products) {
+    dump << "+" << product.dump () << "\n";
   }
-  return dump.str();
+  return dump.str ();
 }
 
-BoundingBox CSGProducts::getBoundingBox(bool throwntogether) const
-{
+BoundingBox CSGProducts::getBoundingBox (bool throwntogether) const {
   BoundingBox bbox;
-  for (const auto& product : this->products) {
-    bbox.extend(product.getBoundingBox(throwntogether));
+  for (const auto &product : this->products) {
+    bbox.extend (product.getBoundingBox (throwntogether));
   }
   return bbox;
 }
 
-size_t CSGProducts::size() const
-{
+size_t CSGProducts::size () const {
   size_t count = 0;
-  for (const auto& product : this->products) {
-    count += product.intersections.size() + product.subtractions.size();
+  for (const auto &product : this->products) {
+    count += product.intersections.size () + product.subtractions.size ();
   }
   return count;
 }
diff --git a/src/core/CSGNode.h b/src/core/CSGNode.h
index 6d11bd13c..d5a8b4643 100644
--- a/src/core/CSGNode.h
+++ b/src/core/CSGNode.h
@@ -19,22 +19,37 @@ public:
     FLAG_HIGHLIGHT = 0x02
   };
 
-  CSGNode(Flag flags = FLAG_NONE) : flags(flags) {}
-  virtual ~CSGNode() = default;
-  [[nodiscard]] virtual std::string dump() const = 0;
-  [[nodiscard]] virtual bool isEmptySet() const { return false; }
+  CSGNode (Flag flags = FLAG_NONE)
+    : flags (flags) {}
+  virtual ~CSGNode () = default;
+  [[nodiscard]] virtual std::string dump () const = 0;
+  [[nodiscard]] virtual bool isEmptySet () const {
+    return false;
+  }
 
-  [[nodiscard]] const BoundingBox& getBoundingBox() const { return this->bbox; }
-  [[nodiscard]] unsigned int getFlags() const { return this->flags; }
-  [[nodiscard]] bool isHighlight() const { return this->flags & FLAG_HIGHLIGHT; }
-  [[nodiscard]] bool isBackground() const { return this->flags & FLAG_BACKGROUND; }
-  void setHighlight(bool on) { on ? this->flags |= FLAG_HIGHLIGHT : this->flags &= ~FLAG_HIGHLIGHT; }
-  void setBackground(bool on) { on ? this->flags |= FLAG_BACKGROUND : this->flags &= ~FLAG_BACKGROUND; }
+  [[nodiscard]] const BoundingBox &getBoundingBox () const {
+    return this->bbox;
+  }
+  [[nodiscard]] unsigned int getFlags () const {
+    return this->flags;
+  }
+  [[nodiscard]] bool isHighlight () const {
+    return this->flags & FLAG_HIGHLIGHT;
+  }
+  [[nodiscard]] bool isBackground () const {
+    return this->flags & FLAG_BACKGROUND;
+  }
+  void setHighlight (bool on) {
+    on ? this->flags |= FLAG_HIGHLIGHT : this->flags &= ~FLAG_HIGHLIGHT;
+  }
+  void setBackground (bool on) {
+    on ? this->flags |= FLAG_BACKGROUND : this->flags &= ~FLAG_BACKGROUND;
+  }
 
-  static std::shared_ptr<CSGNode> createEmptySet();
+  static std::shared_ptr<CSGNode> createEmptySet ();
 
 protected:
-  virtual void initBoundingBox() = 0;
+  virtual void initBoundingBox () = 0;
 
   BoundingBox bbox;
   unsigned int flags;
@@ -46,21 +61,31 @@ protected:
 class CSGOperation : public CSGNode
 {
 public:
-  CSGOperation() = default;
-  void initBoundingBox() override;
-  [[nodiscard]] std::string dump() const override;
+  CSGOperation () = default;
+  void initBoundingBox () override;
+  [[nodiscard]] std::string dump () const override;
 
-  std::shared_ptr<CSGNode>& left() { return this->children[0]; }
-  std::shared_ptr<CSGNode>& right() { return this->children[1]; }
-  [[nodiscard]] const std::shared_ptr<CSGNode>& left() const { return this->children[0]; }
-  [[nodiscard]] const std::shared_ptr<CSGNode>& right() const { return this->children[1]; }
+  std::shared_ptr<CSGNode> &left () {
+    return this->children[0];
+  }
+  std::shared_ptr<CSGNode> &right () {
+    return this->children[1];
+  }
+  [[nodiscard]] const std::shared_ptr<CSGNode> &left () const {
+    return this->children[0];
+  }
+  [[nodiscard]] const std::shared_ptr<CSGNode> &right () const {
+    return this->children[1];
+  }
 
-  [[nodiscard]] OpenSCADOperator getType() const { return this->type; }
+  [[nodiscard]] OpenSCADOperator getType () const {
+    return this->type;
+  }
 
-  static std::shared_ptr<CSGNode> createCSGNode(OpenSCADOperator type, std::shared_ptr<CSGNode> left, std::shared_ptr<CSGNode> right);
+  static std::shared_ptr<CSGNode> createCSGNode (OpenSCADOperator type, std::shared_ptr<CSGNode> left, std::shared_ptr<CSGNode> right);
 
 private:
-  CSGOperation(OpenSCADOperator type, const std::shared_ptr<CSGNode>& left, const std::shared_ptr<CSGNode>& right);
+  CSGOperation (OpenSCADOperator type, const std::shared_ptr<CSGNode> &left, const std::shared_ptr<CSGNode> &right);
   OpenSCADOperator type;
   std::vector<std::shared_ptr<CSGNode>> children;
 };
@@ -68,19 +93,19 @@ private:
 // very large lists of children can overflow stack due to recursive destruction of shared_ptr,
 // so move shared_ptrs into a temporary vector
 struct CSGOperationDeleter {
-  void operator()(CSGOperation *node) {
+  void operator() (CSGOperation *node) {
     std::vector<std::shared_ptr<CSGNode>> purge;
-    purge.emplace_back(std::move(node->right()));
-    purge.emplace_back(std::move(node->left()));
+    purge.emplace_back (std::move (node->right ()));
+    purge.emplace_back (std::move (node->left ()));
     delete node;
     do {
-      auto op = std::dynamic_pointer_cast<CSGOperation>(purge.back());
-      purge.pop_back();
-      if (op && op.use_count() == 1) {
-        purge.emplace_back(std::move(op->right()));
-        purge.emplace_back(std::move(op->left()));
+      auto op = std::dynamic_pointer_cast<CSGOperation> (purge.back ());
+      purge.pop_back ();
+      if (op && op.use_count () == 1) {
+        purge.emplace_back (std::move (op->right ()));
+        purge.emplace_back (std::move (op->left ()));
       }
-    } while (!purge.empty());
+    } while (!purge.empty ());
   }
 };
 
@@ -88,10 +113,10 @@ class CSGLeaf : public CSGNode
 {
 public:
   EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-  CSGLeaf(const std::shared_ptr<const PolySet>& ps, Transform3d matrix, Color4f color, std::string label, const int index);
-  void initBoundingBox() override;
-  [[nodiscard]] bool isEmptySet() const override;
-  [[nodiscard]] std::string dump() const override;
+  CSGLeaf (const std::shared_ptr<const PolySet> &ps, Transform3d matrix, Color4f color, std::string label, const int index);
+  void initBoundingBox () override;
+  [[nodiscard]] bool isEmptySet () const override;
+  [[nodiscard]] std::string dump () const override;
   std::string label;
   std::shared_ptr<const PolySet> polyset;
   Transform3d matrix;
@@ -109,8 +134,9 @@ public:
 class CSGChainObject
 {
 public:
-  CSGChainObject(const std::shared_ptr<CSGLeaf>& leaf, CSGNode::Flag flags = CSGNode::FLAG_NONE)
-    : leaf(leaf), flags(flags) {}
+  CSGChainObject (const std::shared_ptr<CSGLeaf> &leaf, CSGNode::Flag flags = CSGNode::FLAG_NONE)
+    : leaf (leaf)
+    , flags (flags) {}
 
   std::shared_ptr<CSGLeaf> leaf;
   CSGNode::Flag flags;
@@ -119,10 +145,10 @@ public:
 class CSGProduct
 {
 public:
-  CSGProduct() = default;
+  CSGProduct () = default;
 
-  [[nodiscard]] std::string dump() const;
-  [[nodiscard]] BoundingBox getBoundingBox(bool throwntogether = false) const;
+  [[nodiscard]] std::string dump () const;
+  [[nodiscard]] BoundingBox getBoundingBox (bool throwntogether = false) const;
 
   std::vector<CSGChainObject> intersections;
   std::vector<CSGChainObject> subtractions;
@@ -131,22 +157,22 @@ public:
 class CSGProducts
 {
 public:
-  CSGProducts() {
-    this->createProduct();
+  CSGProducts () {
+    this->createProduct ();
   }
 
-  void import(std::shared_ptr<CSGNode> csgtree, OpenSCADOperator type = OpenSCADOperator::UNION, CSGNode::Flag flags = CSGNode::FLAG_NONE);
-  [[nodiscard]] std::string dump() const;
-  [[nodiscard]] BoundingBox getBoundingBox(bool throwntogether = false) const;
+  void import (std::shared_ptr<CSGNode> csgtree, OpenSCADOperator type = OpenSCADOperator::UNION, CSGNode::Flag flags = CSGNode::FLAG_NONE);
+  [[nodiscard]] std::string dump () const;
+  [[nodiscard]] BoundingBox getBoundingBox (bool throwntogether = false) const;
 
   std::vector<CSGProduct> products;
 
-  [[nodiscard]] size_t size() const;
+  [[nodiscard]] size_t size () const;
 
 private:
-  void createProduct() {
-    this->products.emplace_back();
-    this->currentproduct = &this->products.back();
+  void createProduct () {
+    this->products.emplace_back ();
+    this->currentproduct = &this->products.back ();
     this->currentlist = &this->currentproduct->intersections;
   }
 
diff --git a/src/core/CSGTreeEvaluator.cc b/src/core/CSGTreeEvaluator.cc
index 278ef0d55..a261b83f2 100644
--- a/src/core/CSGTreeEvaluator.cc
+++ b/src/core/CSGTreeEvaluator.cc
@@ -29,46 +29,46 @@
    with OpenCSG.
  */
 
-std::shared_ptr<CSGNode> CSGTreeEvaluator::buildCSGTree(const AbstractNode& node)
-{
-  this->traverse(node);
+std::shared_ptr<CSGNode> CSGTreeEvaluator::buildCSGTree (const AbstractNode &node) {
+  this->traverse (node);
 
-  std::shared_ptr<CSGNode> t(this->stored_term[node.index()]);
+  std::shared_ptr<CSGNode> t (this->stored_term[node.index ()]);
   if (t) {
-    if (t->isHighlight()) this->highlightNodes.push_back(t);
-    if (t->isBackground()) {
-      this->backgroundNodes.push_back(t);
-      t.reset();
+    if (t->isHighlight ())
+      this->highlightNodes.push_back (t);
+    if (t->isBackground ()) {
+      this->backgroundNodes.push_back (t);
+      t.reset ();
     }
   }
 
   return this->rootNode = t;
 }
 
-void CSGTreeEvaluator::applyBackgroundAndHighlight(State& /*state*/, const AbstractNode& node)
-{
-  for (const auto& chnode : this->visitedchildren[node.index()]) {
-    std::shared_ptr<CSGNode> t(this->stored_term[chnode->index()]);
-    this->stored_term.erase(chnode->index());
+void CSGTreeEvaluator::applyBackgroundAndHighlight (State & /*state*/, const AbstractNode &node) {
+  for (const auto &chnode : this->visitedchildren[node.index ()]) {
+    std::shared_ptr<CSGNode> t (this->stored_term[chnode->index ()]);
+    this->stored_term.erase (chnode->index ());
     if (t) {
-      if (t->isBackground()) this->backgroundNodes.push_back(t);
-      if (t->isHighlight()) this->highlightNodes.push_back(t);
+      if (t->isBackground ())
+        this->backgroundNodes.push_back (t);
+      if (t->isHighlight ())
+        this->highlightNodes.push_back (t);
     }
   }
 }
 
-void CSGTreeEvaluator::applyToChildren(State& state, const AbstractNode& node, OpenSCADOperator op)
-{
-  const auto& vc = this->visitedchildren[node.index()];
-  if (vc.empty()) {
-    this->stored_term[node.index()] = CSGNode::createEmptySet();
+void CSGTreeEvaluator::applyToChildren (State &state, const AbstractNode &node, OpenSCADOperator op) {
+  const auto &vc = this->visitedchildren[node.index ()];
+  if (vc.empty ()) {
+    this->stored_term[node.index ()] = CSGNode::createEmptySet ();
     return;
   }
 
   std::shared_ptr<CSGNode> t1;
-  for (const auto& chnode : vc) {
-    std::shared_ptr<CSGNode> t2(this->stored_term[chnode->index()]);
-    this->stored_term.erase(chnode->index());
+  for (const auto &chnode : vc) {
+    std::shared_ptr<CSGNode> t2 (this->stored_term[chnode->index ()]);
+    this->stored_term.erase (chnode->index ());
     if (t2 && !t1) {
       t1 = t2;
     } else if (t2 && t1) {
@@ -76,46 +76,46 @@ void CSGTreeEvaluator::applyToChildren(State& state, const AbstractNode& node, O
       std::shared_ptr<CSGNode> t;
       // Handle background
       // Background objects are simply moved to backgroundNodes
-      if (t2->isBackground()) {
+      if (t2->isBackground ()) {
         t = t1;
-        this->backgroundNodes.push_back(t2);
-      } else if (t1->isBackground()) {
+        this->backgroundNodes.push_back (t2);
+      } else if (t1->isBackground ()) {
         t = t2;
-        this->backgroundNodes.push_back(t1);
+        this->backgroundNodes.push_back (t1);
       } else {
-        t = CSGOperation::createCSGNode(op, t1, t2);
+        t = CSGOperation::createCSGNode (op, t1, t2);
       }
       // Handle highlight
       switch (op) {
       case OpenSCADOperator::DIFFERENCE:
-        if (t != t1 && t1->isHighlight()) {
-          t->setHighlight(true);
-        } else if (t != t2 && t2->isHighlight()) {
-          this->highlightNodes.push_back(t2);
+        if (t != t1 && t1->isHighlight ()) {
+          t->setHighlight (true);
+        } else if (t != t2 && t2->isHighlight ()) {
+          this->highlightNodes.push_back (t2);
         }
         break;
       case OpenSCADOperator::INTERSECTION:
-        if (t && !t->isEmptySet() && t != t1 && t != t2 &&
-            t1->isHighlight() && t2->isHighlight()) {
-          t->setHighlight(true);
+        if (t && !t->isEmptySet () && t != t1 && t != t2 &&
+            t1->isHighlight () && t2->isHighlight ()) {
+          t->setHighlight (true);
         } else {
-          if (t != t1 && t1->isHighlight()) {
-            this->highlightNodes.push_back(t1);
+          if (t != t1 && t1->isHighlight ()) {
+            this->highlightNodes.push_back (t1);
           }
-          if (t != t2 && t2->isHighlight()) {
-            this->highlightNodes.push_back(t2);
+          if (t != t2 && t2->isHighlight ()) {
+            this->highlightNodes.push_back (t2);
           }
         }
         break;
       case OpenSCADOperator::UNION:
         if (t != t1 && t != t2 &&
-            t1->isHighlight() && t2->isHighlight()) {
-          t->setHighlight(true);
-        } else if (t != t1 && t1->isHighlight()) {
-          this->highlightNodes.push_back(t1);
+            t1->isHighlight () && t2->isHighlight ()) {
+          t->setHighlight (true);
+        } else if (t != t1 && t1->isHighlight ()) {
+          this->highlightNodes.push_back (t1);
           t = t2;
-        } else if (t != t2 && t2->isHighlight()) {
-          this->highlightNodes.push_back(t2);
+        } else if (t != t2 && t2->isHighlight ()) {
+          this->highlightNodes.push_back (t2);
           t = t1;
         }
         break;
@@ -129,213 +129,208 @@ void CSGTreeEvaluator::applyToChildren(State& state, const AbstractNode& node, O
     }
   }
   if (t1) {
-    if (node.modinst->isBackground() || state.isBackground()) t1->setBackground(true);
-    if (node.modinst->isHighlight() || state.isHighlight()) t1->setHighlight(true);
+    if (node.modinst->isBackground () || state.isBackground ())
+      t1->setBackground (true);
+    if (node.modinst->isHighlight () || state.isHighlight ())
+      t1->setHighlight (true);
   }
-  this->stored_term[node.index()] = t1;
+  this->stored_term[node.index ()] = t1;
 }
 
-Response CSGTreeEvaluator::visit(State& state, const AbstractNode& node)
-{
-  if (state.isPostfix()) {
-    applyToChildren(state, node, OpenSCADOperator::UNION);
-    addToParent(state, node);
+Response CSGTreeEvaluator::visit (State &state, const AbstractNode &node) {
+  if (state.isPostfix ()) {
+    applyToChildren (state, node, OpenSCADOperator::UNION);
+    addToParent (state, node);
   }
   return Response::ContinueTraversal;
 }
 
-Response CSGTreeEvaluator::visit(State& state, const AbstractIntersectionNode& node)
-{
-  if (state.isPostfix()) {
-    applyToChildren(state, node, OpenSCADOperator::INTERSECTION);
-    addToParent(state, node);
+Response CSGTreeEvaluator::visit (State &state, const AbstractIntersectionNode &node) {
+  if (state.isPostfix ()) {
+    applyToChildren (state, node, OpenSCADOperator::INTERSECTION);
+    addToParent (state, node);
   }
   return Response::ContinueTraversal;
 }
 
-Response CSGTreeEvaluator::visit(State& state, const class ListNode &node)
-{
-  if (state.parent()) {
-    if (state.isPrefix()) {
-      if (node.modinst->isHighlight()) state.setHighlight(true);
-      if (node.modinst->isBackground()) state.setBackground(true);
+Response CSGTreeEvaluator::visit (State &state, const class ListNode &node) {
+  if (state.parent ()) {
+    if (state.isPrefix ()) {
+      if (node.modinst->isHighlight ())
+        state.setHighlight (true);
+      if (node.modinst->isBackground ())
+        state.setBackground (true);
     }
-    if (state.isPostfix()) {
-      for (auto& chnode : this->visitedchildren[node.index()]) {
-        addToParent(state, *chnode);
+    if (state.isPostfix ()) {
+      for (auto &chnode : this->visitedchildren[node.index ()]) {
+        addToParent (state, *chnode);
       }
     }
     return Response::ContinueTraversal;
   } else {
     // Handle root modifier on ListNode just like a group
-    return visit(state, (const AbstractNode&)node);
+    return visit (state, (const AbstractNode &)node);
   }
-
 }
 
 // Creates a 1-unit-thick PolySet with dim==2 from a Polygon2d.
-std::shared_ptr<const PolySet> polygon2dToPolySet(const Polygon2d& p2d) {
-  const auto ps = p2d.tessellate();
+std::shared_ptr<const PolySet> polygon2dToPolySet (const Polygon2d &p2d) {
+  const auto ps = p2d.tessellate ();
   constexpr int dim = 2;
   // Estimating num vertices and polygons: top + bottom + sides
-  PolySetBuilder builder(ps->vertices.size() * 2,
-                         ps->indices.size() * 2 + ps->vertices.size(),
-                         dim, p2d.is_convex());
-  builder.setConvexity(p2d.getConvexity());
+  PolySetBuilder builder (ps->vertices.size () * 2,
+                          ps->indices.size () * 2 + ps->vertices.size (),
+                          dim, p2d.is_convex ());
+  builder.setConvexity (p2d.getConvexity ());
 
   // Create bottom face.
-  for (const auto& poly : ps->indices) {
-    builder.beginPolygon(poly.size());
+  for (const auto &poly : ps->indices) {
+    builder.beginPolygon (poly.size ());
     // Flip vertex ordering for bottom polygon
-    for (const auto& ind: boost::adaptors::reverse(poly)) {
-      builder.addVertex(ps->vertices[ind] - Vector3d(0, 0, 0.5));
+    for (const auto &ind : boost::adaptors::reverse (poly)) {
+      builder.addVertex (ps->vertices[ind] - Vector3d (0, 0, 0.5));
     }
   }
 
   // Create top face.
-  for (const auto& poly : ps->indices) {
-    builder.beginPolygon(poly.size());
-    for (const auto& ind: poly) {
-      builder.addVertex(ps->vertices[ind] + Vector3d(0, 0, 0.5));
+  for (const auto &poly : ps->indices) {
+    builder.beginPolygon (poly.size ());
+    for (const auto &ind : poly) {
+      builder.addVertex (ps->vertices[ind] + Vector3d (0, 0, 0.5));
     }
   }
 
   // Create sides
-  for (const auto& o : p2d.outlines()) {
-    for (size_t i = 0; i < o.vertices.size(); ++i) {
-      const Vector2d& prev = o.vertices[i];
-      const Vector2d& curr = o.vertices[(i + 1) % o.vertices.size()];
-      builder.appendPolygon({
-        Vector3d(prev[0], prev[1], -0.5),
-        Vector3d(curr[0], curr[1], -0.5),
-        Vector3d(curr[0], curr[1], 0.5),
-        Vector3d(prev[0], prev[1], 0.5),
+  for (const auto &o : p2d.outlines ()) {
+    for (size_t i = 0; i < o.vertices.size (); ++i) {
+      const Vector2d &prev = o.vertices[i];
+      const Vector2d &curr = o.vertices[(i + 1) % o.vertices.size ()];
+      builder.appendPolygon ({
+        Vector3d (prev[0], prev[1], -0.5),
+        Vector3d (curr[0], curr[1], -0.5),
+        Vector3d (curr[0], curr[1], 0.5),
+        Vector3d (prev[0], prev[1], 0.5),
       });
     }
   }
 
-  return builder.build();
+  return builder.build ();
 }
 
-
-std::shared_ptr<CSGNode> CSGTreeEvaluator::evaluateCSGNodeFromGeometry(
-  State& state, const std::shared_ptr<const Geometry>& geom,
-  const ModuleInstantiation *modinst, const AbstractNode& node)
-{
-  assert(geom);
+std::shared_ptr<CSGNode> CSGTreeEvaluator::evaluateCSGNodeFromGeometry (
+  State &state, const std::shared_ptr<const Geometry> &geom,
+  const ModuleInstantiation *modinst, const AbstractNode &node) {
+  assert (geom);
   // We cannot render Polygon2d directly, so we convert it to a PolySet here
   std::shared_ptr<const PolySet> ps;
-  if (!geom->isEmpty()) {
-    if (auto p2d = std::dynamic_pointer_cast<const Polygon2d>(geom)) {
-      ps = polygon2dToPolySet(*p2d);
+  if (!geom->isEmpty ()) {
+    if (auto p2d = std::dynamic_pointer_cast<const Polygon2d> (geom)) {
+      ps = polygon2dToPolySet (*p2d);
     }
     // 3D PolySets are tessellated before inserting into Geometry cache, inside GeometryEvaluator::evaluateGeometry
     else {
-      ps = std::dynamic_pointer_cast<const PolySet>(geom);
+      ps = std::dynamic_pointer_cast<const PolySet> (geom);
     }
   }
 
-  std::shared_ptr<CSGNode> t(new CSGLeaf(ps, state.matrix(), state.color(), STR(node.name(), node.index()), node.index()));
-  if (modinst->isHighlight() || state.isHighlight()) t->setHighlight(true);
-  if (modinst->isBackground() || state.isBackground()) t->setBackground(true);
+  std::shared_ptr<CSGNode> t (new CSGLeaf (ps, state.matrix (), state.color (), STR (node.name (), node.index ()), node.index ()));
+  if (modinst->isHighlight () || state.isHighlight ())
+    t->setHighlight (true);
+  if (modinst->isBackground () || state.isBackground ())
+    t->setBackground (true);
   return t;
 }
 
-Response CSGTreeEvaluator::visit(State& state, const AbstractPolyNode& node)
-{
-  if (state.isPostfix()) {
+Response CSGTreeEvaluator::visit (State &state, const AbstractPolyNode &node) {
+  if (state.isPostfix ()) {
     std::shared_ptr<CSGNode> t1;
     if (this->geomevaluator) {
-      auto geom = this->geomevaluator->evaluateGeometry(node, false);
+      auto geom = this->geomevaluator->evaluateGeometry (node, false);
       if (geom) {
-        t1 = evaluateCSGNodeFromGeometry(state, geom, node.modinst, node);
+        t1 = evaluateCSGNodeFromGeometry (state, geom, node.modinst, node);
       } else {
-        t1 = CSGNode::createEmptySet();
+        t1 = CSGNode::createEmptySet ();
       }
-      node.progress_report();
+      node.progress_report ();
     }
-    this->stored_term[node.index()] = t1;
-    addToParent(state, node);
+    this->stored_term[node.index ()] = t1;
+    addToParent (state, node);
   }
   return Response::ContinueTraversal;
 }
 
-Response CSGTreeEvaluator::visit(State& state, const CsgOpNode& node)
-{
-  if (state.isPostfix()) {
-    applyToChildren(state, node, node.type);
-    addToParent(state, node);
+Response CSGTreeEvaluator::visit (State &state, const CsgOpNode &node) {
+  if (state.isPostfix ()) {
+    applyToChildren (state, node, node.type);
+    addToParent (state, node);
   }
   return Response::ContinueTraversal;
 }
 
-Response CSGTreeEvaluator::visit(State& state, const TransformNode& node)
-{
-  if (state.isPrefix()) {
-    if (matrix_contains_infinity(node.matrix) || matrix_contains_nan(node.matrix)) {
-      LOG(message_group::Warning, "Transformation matrix contains Not-a-Number and/or Infinity - removing object.");
+Response CSGTreeEvaluator::visit (State &state, const TransformNode &node) {
+  if (state.isPrefix ()) {
+    if (matrix_contains_infinity (node.matrix) || matrix_contains_nan (node.matrix)) {
+      LOG (message_group::Warning, "Transformation matrix contains Not-a-Number and/or Infinity - removing object.");
       return Response::PruneTraversal;
     }
-    state.setMatrix(state.matrix() * node.matrix);
+    state.setMatrix (state.matrix () * node.matrix);
   }
-  if (state.isPostfix()) {
-    applyToChildren(state, node, OpenSCADOperator::UNION);
-    addToParent(state, node);
+  if (state.isPostfix ()) {
+    applyToChildren (state, node, OpenSCADOperator::UNION);
+    addToParent (state, node);
   }
   return Response::ContinueTraversal;
 }
 
-Response CSGTreeEvaluator::visit(State& state, const ColorNode& node)
-{
-  if (state.isPrefix()) {
-    if (!state.color().isValid()) state.setColor(node.color);
+Response CSGTreeEvaluator::visit (State &state, const ColorNode &node) {
+  if (state.isPrefix ()) {
+    if (!state.color ().isValid ())
+      state.setColor (node.color);
   }
-  if (state.isPostfix()) {
-    applyToChildren(state, node, OpenSCADOperator::UNION);
-    addToParent(state, node);
+  if (state.isPostfix ()) {
+    applyToChildren (state, node, OpenSCADOperator::UNION);
+    addToParent (state, node);
   }
   return Response::ContinueTraversal;
 }
 
 // FIXME: If we've got CGAL support, render this node as a CGAL union into a PolySet
-Response CSGTreeEvaluator::visit(State& state, const RenderNode& node)
-{
-  if (state.isPostfix()) {
+Response CSGTreeEvaluator::visit (State &state, const RenderNode &node) {
+  if (state.isPostfix ()) {
     std::shared_ptr<CSGNode> t1;
     std::shared_ptr<const Geometry> geom;
     if (this->geomevaluator) {
-      geom = this->geomevaluator->evaluateGeometry(node, false);
+      geom = this->geomevaluator->evaluateGeometry (node, false);
       if (geom) {
-        t1 = evaluateCSGNodeFromGeometry(state, geom, node.modinst, node);
+        t1 = evaluateCSGNodeFromGeometry (state, geom, node.modinst, node);
       } else {
-        t1 = CSGNode::createEmptySet();
+        t1 = CSGNode::createEmptySet ();
       }
-      node.progress_report();
+      node.progress_report ();
     }
-    this->stored_term[node.index()] = t1;
-    addToParent(state, node);
+    this->stored_term[node.index ()] = t1;
+    addToParent (state, node);
   }
   return Response::ContinueTraversal;
 }
 
-Response CSGTreeEvaluator::visit(State& state, const CgalAdvNode& node)
-{
-  if (state.isPostfix()) {
+Response CSGTreeEvaluator::visit (State &state, const CgalAdvNode &node) {
+  if (state.isPostfix ()) {
     std::shared_ptr<CSGNode> t1;
     // FIXME: Calling evaluator directly since we're not a PolyNode. Generalize this.
     std::shared_ptr<const Geometry> geom;
     if (this->geomevaluator) {
-      geom = this->geomevaluator->evaluateGeometry(node, false);
+      geom = this->geomevaluator->evaluateGeometry (node, false);
       if (geom) {
-        t1 = evaluateCSGNodeFromGeometry(state, geom, node.modinst, node);
+        t1 = evaluateCSGNodeFromGeometry (state, geom, node.modinst, node);
       } else {
-        t1 = CSGNode::createEmptySet();
+        t1 = CSGNode::createEmptySet ();
       }
-      node.progress_report();
+      node.progress_report ();
     }
-    this->stored_term[node.index()] = t1;
-    applyBackgroundAndHighlight(state, node);
-    addToParent(state, node);
+    this->stored_term[node.index ()] = t1;
+    applyBackgroundAndHighlight (state, node);
+    addToParent (state, node);
   }
   return Response::ContinueTraversal;
 }
@@ -345,10 +340,9 @@ Response CSGTreeEvaluator::visit(State& state, const CgalAdvNode& node)
    Call this for _every_ node which affects output during traversal.
     Usually, this should be called from the postfix stage, but for some nodes, we defer traversal letting other components (e.g. CGAL) render the subgraph, and we'll then call this from prefix and prune further traversal.
  */
-void CSGTreeEvaluator::addToParent(const State& state, const AbstractNode& node)
-{
-  this->visitedchildren.erase(node.index());
-  if (state.parent()) {
-    this->visitedchildren[state.parent()->index()].push_back(node.shared_from_this());
+void CSGTreeEvaluator::addToParent (const State &state, const AbstractNode &node) {
+  this->visitedchildren.erase (node.index ());
+  if (state.parent ()) {
+    this->visitedchildren[state.parent ()->index ()].push_back (node.shared_from_this ());
   }
 }
diff --git a/src/core/CSGTreeEvaluator.h b/src/core/CSGTreeEvaluator.h
index 2edd0d2f7..7d24118aa 100644
--- a/src/core/CSGTreeEvaluator.h
+++ b/src/core/CSGTreeEvaluator.h
@@ -17,46 +17,47 @@ class Tree;
 class CSGTreeEvaluator : public NodeVisitor
 {
 public:
-  CSGTreeEvaluator(const Tree& tree, GeometryEvaluator *geomevaluator = nullptr)
-    : tree(tree), geomevaluator(geomevaluator) {
+  CSGTreeEvaluator (const Tree &tree, GeometryEvaluator *geomevaluator = nullptr)
+    : tree (tree)
+    , geomevaluator (geomevaluator) {
   }
 
-  Response visit(State& state, const AbstractNode& node) override;
-  Response visit(State& state, const AbstractIntersectionNode& node) override;
-  Response visit(State& state, const AbstractPolyNode& node) override;
-  Response visit(State& state, const ListNode& node) override;
-  Response visit(State& state, const CsgOpNode& node) override;
-  Response visit(State& state, const TransformNode& node) override;
-  Response visit(State& state, const ColorNode& node) override;
-  Response visit(State& state, const RenderNode& node) override;
-  Response visit(State& state, const CgalAdvNode& node) override;
+  Response visit (State &state, const AbstractNode &node) override;
+  Response visit (State &state, const AbstractIntersectionNode &node) override;
+  Response visit (State &state, const AbstractPolyNode &node) override;
+  Response visit (State &state, const ListNode &node) override;
+  Response visit (State &state, const CsgOpNode &node) override;
+  Response visit (State &state, const TransformNode &node) override;
+  Response visit (State &state, const ColorNode &node) override;
+  Response visit (State &state, const RenderNode &node) override;
+  Response visit (State &state, const CgalAdvNode &node) override;
 
-  std::shared_ptr<CSGNode> buildCSGTree(const AbstractNode& node);
+  std::shared_ptr<CSGNode> buildCSGTree (const AbstractNode &node);
 
-  [[nodiscard]] const std::shared_ptr<CSGNode>& getRootNode() const {
+  [[nodiscard]] const std::shared_ptr<CSGNode> &getRootNode () const {
     return this->rootNode;
   }
-  [[nodiscard]] const std::vector<std::shared_ptr<CSGNode>>& getHighlightNodes() const {
+  [[nodiscard]] const std::vector<std::shared_ptr<CSGNode>> &getHighlightNodes () const {
     return this->highlightNodes;
   }
-  [[nodiscard]] const std::vector<std::shared_ptr<CSGNode>>& getBackgroundNodes() const {
+  [[nodiscard]] const std::vector<std::shared_ptr<CSGNode>> &getBackgroundNodes () const {
     return this->backgroundNodes;
   }
 
 private:
-  void addToParent(const State& state, const AbstractNode& node);
-  void applyToChildren(State& state, const AbstractNode& node, OpenSCADOperator op);
-  std::shared_ptr<CSGNode> evaluateCSGNodeFromGeometry(State& state,
-                                                       const std::shared_ptr<const Geometry>& geom,
-                                                       const ModuleInstantiation *modinst,
-                                                       const AbstractNode& node);
-  void applyBackgroundAndHighlight(State& state, const AbstractNode& node);
+  void addToParent (const State &state, const AbstractNode &node);
+  void applyToChildren (State &state, const AbstractNode &node, OpenSCADOperator op);
+  std::shared_ptr<CSGNode> evaluateCSGNodeFromGeometry (State &state,
+                                                        const std::shared_ptr<const Geometry> &geom,
+                                                        const ModuleInstantiation *modinst,
+                                                        const AbstractNode &node);
+  void applyBackgroundAndHighlight (State &state, const AbstractNode &node);
 
   using ChildList = std::list<std::shared_ptr<const AbstractNode>>;
   std::map<int, ChildList> visitedchildren;
 
 protected:
-  const Tree& tree;
+  const Tree &tree;
   GeometryEvaluator *geomevaluator;
   std::shared_ptr<CSGNode> rootNode;
   std::vector<std::shared_ptr<CSGNode>> highlightNodes;
diff --git a/src/core/CgalAdvNode.cc b/src/core/CgalAdvNode.cc
index 9df2a48e3..96de2ba1f 100644
--- a/src/core/CgalAdvNode.cc
+++ b/src/core/CgalAdvNode.cc
@@ -37,64 +37,65 @@
 #include <boost/assign/std/vector.hpp>
 using namespace boost::assign; // bring 'operator+=()' into scope
 
-static std::shared_ptr<AbstractNode> builtin_minkowski(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  auto node = std::make_shared<CgalAdvNode>(inst, CgalAdvType::MINKOWSKI);
+static std::shared_ptr<AbstractNode> builtin_minkowski (const ModuleInstantiation *inst, Arguments arguments, const Children &children) {
+  auto node = std::make_shared<CgalAdvNode> (inst, CgalAdvType::MINKOWSKI);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"convexity"});
-  node->convexity = static_cast<int>(parameters["convexity"].toDouble());
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (), {"convexity"});
+  node->convexity = static_cast<int> (parameters["convexity"].toDouble ());
 
-  return children.instantiate(node);
+  return children.instantiate (node);
 }
 
-static std::shared_ptr<AbstractNode> builtin_hull(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  auto node = std::make_shared<CgalAdvNode>(inst, CgalAdvType::HULL);
+static std::shared_ptr<AbstractNode> builtin_hull (const ModuleInstantiation *inst, Arguments arguments, const Children &children) {
+  auto node = std::make_shared<CgalAdvNode> (inst, CgalAdvType::HULL);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {});
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (), {});
   node->convexity = 0;
 
-  return children.instantiate(node);
+  return children.instantiate (node);
 }
 
-static std::shared_ptr<AbstractNode> builtin_fill(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  auto node = std::make_shared<CgalAdvNode>(inst, CgalAdvType::FILL);
+static std::shared_ptr<AbstractNode> builtin_fill (const ModuleInstantiation *inst, Arguments arguments, const Children &children) {
+  auto node = std::make_shared<CgalAdvNode> (inst, CgalAdvType::FILL);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {});
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (), {});
 
-  return children.instantiate(node);
+  return children.instantiate (node);
 }
 
-static std::shared_ptr<AbstractNode> builtin_resize(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  auto node = std::make_shared<CgalAdvNode>(inst, CgalAdvType::RESIZE);
+static std::shared_ptr<AbstractNode> builtin_resize (const ModuleInstantiation *inst, Arguments arguments, const Children &children) {
+  auto node = std::make_shared<CgalAdvNode> (inst, CgalAdvType::RESIZE);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"newsize", "auto", "convexity"});
-  node->convexity = static_cast<int>(parameters["convexity"].toDouble());
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (), {"newsize", "auto", "convexity"});
+  node->convexity = static_cast<int> (parameters["convexity"].toDouble ());
   node->newsize << 0, 0, 0;
-  if (parameters["newsize"].type() == Value::Type::VECTOR) {
-    const auto& vs = parameters["newsize"].toVector();
-    if (vs.size() >= 1) node->newsize[0] = vs[0].toDouble();
-    if (vs.size() >= 2) node->newsize[1] = vs[1].toDouble();
-    if (vs.size() >= 3) node->newsize[2] = vs[2].toDouble();
+  if (parameters["newsize"].type () == Value::Type::VECTOR) {
+    const auto &vs = parameters["newsize"].toVector ();
+    if (vs.size () >= 1)
+      node->newsize[0] = vs[0].toDouble ();
+    if (vs.size () >= 2)
+      node->newsize[1] = vs[1].toDouble ();
+    if (vs.size () >= 3)
+      node->newsize[2] = vs[2].toDouble ();
   }
-  const auto& autosize = parameters["auto"];
+  const auto &autosize = parameters["auto"];
   node->autosize << false, false, false;
-  if (autosize.type() == Value::Type::VECTOR) {
-    const auto& va = autosize.toVector();
-    if (va.size() >= 1) node->autosize[0] = va[0].toBool();
-    if (va.size() >= 2) node->autosize[1] = va[1].toBool();
-    if (va.size() >= 3) node->autosize[2] = va[2].toBool();
-  } else if (autosize.type() == Value::Type::BOOL) {
-    node->autosize << autosize.toBool(), autosize.toBool(), autosize.toBool();
+  if (autosize.type () == Value::Type::VECTOR) {
+    const auto &va = autosize.toVector ();
+    if (va.size () >= 1)
+      node->autosize[0] = va[0].toBool ();
+    if (va.size () >= 2)
+      node->autosize[1] = va[1].toBool ();
+    if (va.size () >= 3)
+      node->autosize[2] = va[2].toBool ();
+  } else if (autosize.type () == Value::Type::BOOL) {
+    node->autosize << autosize.toBool (), autosize.toBool (), autosize.toBool ();
   }
 
-  return children.instantiate(node);
+  return children.instantiate (node);
 }
 
-std::string CgalAdvNode::name() const
-{
+std::string CgalAdvNode::name () const {
   switch (this->type) {
   case CgalAdvType::MINKOWSKI:
     return "minkowski";
@@ -109,16 +110,15 @@ std::string CgalAdvNode::name() const
     return "resize";
     break;
   default:
-    assert(false);
+    assert (false);
   }
   return "internal_error";
 }
 
-std::string CgalAdvNode::toString() const
-{
+std::string CgalAdvNode::toString () const {
   std::ostringstream stream;
 
-  stream << this->name();
+  stream << this->name ();
   switch (type) {
   case CgalAdvType::MINKOWSKI:
     stream << "(convexity = " << this->convexity << ")";
@@ -136,34 +136,33 @@ std::string CgalAdvNode::toString() const
            << ")";
     break;
   default:
-    assert(false);
+    assert (false);
   }
 
-  return stream.str();
+  return stream.str ();
 }
 
-void register_builtin_cgaladv()
-{
-  Builtins::init("minkowski", new BuiltinModule(builtin_minkowski),
-  {
-    "minkowski(convexity = number)",
-  });
-
-  Builtins::init("hull", new BuiltinModule(builtin_hull),
-  {
-    "hull()",
-  });
-
-  Builtins::init("fill", new BuiltinModule(builtin_fill),
-  {
-    "fill()",
-  });
-
-  Builtins::init("resize", new BuiltinModule(builtin_resize),
-  {
-    "resize([x, y, z])",
-    "resize([x, y, z], boolean)",
-    "resize([x, y, z], [boolean, boolean, boolean])",
-    "resize([x, y, z], [boolean, boolean, boolean], convexity = number)",
-  });
+void register_builtin_cgaladv () {
+  Builtins::init ("minkowski", new BuiltinModule (builtin_minkowski),
+                  {
+                    "minkowski(convexity = number)",
+                  });
+
+  Builtins::init ("hull", new BuiltinModule (builtin_hull),
+                  {
+                    "hull()",
+                  });
+
+  Builtins::init ("fill", new BuiltinModule (builtin_fill),
+                  {
+                    "fill()",
+                  });
+
+  Builtins::init ("resize", new BuiltinModule (builtin_resize),
+                  {
+                    "resize([x, y, z])",
+                    "resize([x, y, z], boolean)",
+                    "resize([x, y, z], [boolean, boolean, boolean])",
+                    "resize([x, y, z], [boolean, boolean, boolean], convexity = number)",
+                  });
 }
diff --git a/src/core/CgalAdvNode.h b/src/core/CgalAdvNode.h
index 32cd0f57e..64e42746f 100644
--- a/src/core/CgalAdvNode.h
+++ b/src/core/CgalAdvNode.h
@@ -16,11 +16,13 @@ enum class CgalAdvType {
 class CgalAdvNode : public AbstractNode
 {
 public:
-  VISITABLE();
-  CgalAdvNode(const ModuleInstantiation *mi, CgalAdvType type) : AbstractNode(mi), type(type) {
+  VISITABLE ();
+  CgalAdvNode (const ModuleInstantiation *mi, CgalAdvType type)
+    : AbstractNode (mi)
+    , type (type) {
   }
-  std::string toString() const override;
-  std::string name() const override;
+  std::string toString () const override;
+  std::string name () const override;
 
   unsigned int convexity{1};
   Vector3d newsize;
diff --git a/src/core/Children.cc b/src/core/Children.cc
index b620dffc5..3fe96cd14 100644
--- a/src/core/Children.cc
+++ b/src/core/Children.cc
@@ -32,17 +32,14 @@
 
 #include "core/ScopeContext.h"
 
-std::shared_ptr<AbstractNode> Children::instantiate(const std::shared_ptr<AbstractNode>& target) const
-{
-  return children_scope->instantiateModules(*scopeContext(), target);
+std::shared_ptr<AbstractNode> Children::instantiate (const std::shared_ptr<AbstractNode> &target) const {
+  return children_scope->instantiateModules (*scopeContext (), target);
 }
 
-std::shared_ptr<AbstractNode> Children::instantiate(const std::shared_ptr<AbstractNode>& target, const std::vector<size_t>& indices) const
-{
-  return children_scope->instantiateModules(*scopeContext(), target, indices);
+std::shared_ptr<AbstractNode> Children::instantiate (const std::shared_ptr<AbstractNode> &target, const std::vector<size_t> &indices) const {
+  return children_scope->instantiateModules (*scopeContext (), target, indices);
 }
 
-ContextHandle<ScopeContext> Children::scopeContext() const
-{
-  return Context::create<ScopeContext>(context, children_scope);
+ContextHandle<ScopeContext> Children::scopeContext () const {
+  return Context::create<ScopeContext> (context, children_scope);
 }
diff --git a/src/core/Children.h b/src/core/Children.h
index 99cb5d2ab..0f4e35fa8 100644
--- a/src/core/Children.h
+++ b/src/core/Children.h
@@ -14,30 +14,35 @@ class ScopeContext;
 class Children
 {
 public:
-  Children(const LocalScope *children_scope, std::shared_ptr<const Context> context) :
-    children_scope(children_scope),
-    context(std::move(context))
-  {}
+  Children (const LocalScope *children_scope, std::shared_ptr<const Context> context)
+    : children_scope (children_scope)
+    , context (std::move (context)) {}
 
-  Children(Children&& other) = default;
-  Children& operator=(Children&& other) = default;
-  Children(const Children& other) = default;
-  Children& operator=(const Children& other) = default;
-  ~Children() = default;
+  Children (Children &&other) = default;
+  Children &operator= (Children &&other) = default;
+  Children (const Children &other) = default;
+  Children &operator= (const Children &other) = default;
+  ~Children () = default;
 
   // NOLINTBEGIN(modernize-use-nodiscard)
   // instantiate just returns a copy of target shared_ptr as a convenience, not crucial to use this value
-  std::shared_ptr<AbstractNode> instantiate(const std::shared_ptr<AbstractNode>& target) const;
-  std::shared_ptr<AbstractNode> instantiate(const std::shared_ptr<AbstractNode>& target, const std::vector<size_t>& indices) const;
+  std::shared_ptr<AbstractNode> instantiate (const std::shared_ptr<AbstractNode> &target) const;
+  std::shared_ptr<AbstractNode> instantiate (const std::shared_ptr<AbstractNode> &target, const std::vector<size_t> &indices) const;
   // NOLINTEND(modernize-use-nodiscard)
 
-  [[nodiscard]] bool empty() const { return !children_scope->hasChildren(); }
-  [[nodiscard]] size_t size() const { return children_scope->moduleInstantiations.size(); }
-  [[nodiscard]] const std::shared_ptr<const Context>& getContext() const { return context; }
+  [[nodiscard]] bool empty () const {
+    return !children_scope->hasChildren ();
+  }
+  [[nodiscard]] size_t size () const {
+    return children_scope->moduleInstantiations.size ();
+  }
+  [[nodiscard]] const std::shared_ptr<const Context> &getContext () const {
+    return context;
+  }
 
 private:
   const LocalScope *children_scope;
   std::shared_ptr<const Context> context;
 
-  [[nodiscard]] ContextHandle<ScopeContext> scopeContext() const;
+  [[nodiscard]] ContextHandle<ScopeContext> scopeContext () const;
 };
diff --git a/src/core/ColorNode.cc b/src/core/ColorNode.cc
index 37b6c3ee1..7d327fbd0 100644
--- a/src/core/ColorNode.cc
+++ b/src/core/ColorNode.cc
@@ -46,58 +46,54 @@
 
 using namespace boost::assign; // bring 'operator+=()' into scope
 
-static std::shared_ptr<AbstractNode> builtin_color(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  auto node = std::make_shared<ColorNode>(inst);
+static std::shared_ptr<AbstractNode> builtin_color (const ModuleInstantiation *inst, Arguments arguments, const Children &children) {
+  auto node = std::make_shared<ColorNode> (inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"c", "alpha"});
-  if (parameters["c"].type() == Value::Type::VECTOR) {
-    const auto& vec = parameters["c"].toVector();
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (), {"c", "alpha"});
+  if (parameters["c"].type () == Value::Type::VECTOR) {
+    const auto &vec = parameters["c"].toVector ();
     Vector4f color;
     for (size_t i = 0; i < 4; ++i) {
-      color[i] = i < vec.size() ? (float)vec[i].toDouble() : 1.0f;
+      color[i] = i < vec.size () ? (float)vec[i].toDouble () : 1.0f;
       if (color[i] > 1 || color[i] < 0) {
-        LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "color() expects numbers between 0.0 and 1.0. Value of %1$.1f is out of range", color[i]);
+        LOG (message_group::Warning, inst->location (), parameters.documentRoot (), "color() expects numbers between 0.0 and 1.0. Value of %1$.1f is out of range", color[i]);
       }
     }
     node->color = color;
-  } else if (parameters["c"].type() == Value::Type::STRING) {
-    auto colorname = parameters["c"].toString();
-    const auto parsed_color = OpenSCAD::parse_color(colorname);
+  } else if (parameters["c"].type () == Value::Type::STRING) {
+    auto colorname = parameters["c"].toString ();
+    const auto parsed_color = OpenSCAD::parse_color (colorname);
     if (parsed_color) {
       node->color = *parsed_color;
     } else {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Unable to parse color \"%1$s\"", colorname);
-      LOG("Please see https://en.wikipedia.org/wiki/Web_colors");
+      LOG (message_group::Warning, inst->location (), parameters.documentRoot (), "Unable to parse color \"%1$s\"", colorname);
+      LOG ("Please see https://en.wikipedia.org/wiki/Web_colors");
     }
   }
-  if (parameters["alpha"].type() == Value::Type::NUMBER) {
-    node->color.setAlpha(parameters["alpha"].toDouble());
-    if (node->color.a() < 0.0f || node->color.a() > 1.0f) {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "color() expects alpha between 0.0 and 1.0. Value of %1$.1f is out of range", node->color.a());
+  if (parameters["alpha"].type () == Value::Type::NUMBER) {
+    node->color.setAlpha (parameters["alpha"].toDouble ());
+    if (node->color.a () < 0.0f || node->color.a () > 1.0f) {
+      LOG (message_group::Warning, inst->location (), parameters.documentRoot (), "color() expects alpha between 0.0 and 1.0. Value of %1$.1f is out of range", node->color.a ());
     }
   }
 
-  return children.instantiate(node);
+  return children.instantiate (node);
 }
 
-std::string ColorNode::toString() const
-{
-  return STR("color([", this->color.r(), ", ", this->color.g(), ", ", this->color.b(), ", ", this->color.a(), "])");
+std::string ColorNode::toString () const {
+  return STR ("color([", this->color.r (), ", ", this->color.g (), ", ", this->color.b (), ", ", this->color.a (), "])");
 }
 
-std::string ColorNode::name() const
-{
+std::string ColorNode::name () const {
   return "color";
 }
 
-void register_builtin_color()
-{
-  Builtins::init("color", new BuiltinModule(builtin_color),
-  {
-    "color(c = [r, g, b, a])",
-    "color(c = [r, g, b], alpha = 1.0)",
-    "color(\"#hexvalue\")",
-    "color(\"colorname\", 1.0)",
-  });
+void register_builtin_color () {
+  Builtins::init ("color", new BuiltinModule (builtin_color),
+                  {
+                    "color(c = [r, g, b, a])",
+                    "color(c = [r, g, b], alpha = 1.0)",
+                    "color(\"#hexvalue\")",
+                    "color(\"colorname\", 1.0)",
+                  });
 }
diff --git a/src/core/ColorNode.h b/src/core/ColorNode.h
index 002767312..f9a332511 100644
--- a/src/core/ColorNode.h
+++ b/src/core/ColorNode.h
@@ -10,10 +10,11 @@
 class ColorNode : public AbstractNode
 {
 public:
-  VISITABLE();
-  ColorNode(const ModuleInstantiation *mi) : AbstractNode(mi) { }
-  std::string toString() const override;
-  std::string name() const override;
+  VISITABLE ();
+  ColorNode (const ModuleInstantiation *mi)
+    : AbstractNode (mi) {}
+  std::string toString () const override;
+  std::string name () const override;
 
   Color4f color;
 };
diff --git a/src/core/ColorUtil.cc b/src/core/ColorUtil.cc
index 6bfd8fa42..1af30ead9 100644
--- a/src/core/ColorUtil.cc
+++ b/src/core/ColorUtil.cc
@@ -161,27 +161,24 @@ std::unordered_map<std::string, Color4f> webcolors{
   {"yellowgreen", {154, 205, 50}},
 
   // additional OpenSCAD specific entry
-  {"transparent", {0, 0, 0, 0}}
-};
-
+  {"transparent", {0, 0, 0, 0}}};
 
 // See http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv
-void rgbtohsv(float r, float g, float b, float& h, float& s, float& v)
-{
+void rgbtohsv (float r, float g, float b, float &h, float &s, float &v) {
   float K = 0.f;
 
   if (g < b) {
-    std::swap(g, b);
+    std::swap (g, b);
     K = -1.f;
   }
 
   if (r < g) {
-    std::swap(r, g);
+    std::swap (r, g);
     K = -2.f / 6.f - K;
   }
 
-  float chroma = r - std::min(g, b);
-  h = std::fabs(K + (g - b) / (6.f * chroma + 1e-20f));
+  float chroma = r - std::min (g, b);
+  h = std::fabs (K + (g - b) / (6.f * chroma + 1e-20f));
   s = chroma / (r + 1e-20f);
   v = r;
 }
@@ -193,18 +190,20 @@ void rgbtohsv(float r, float g, float b, float& h, float& s, float& v)
 // * "#rrggbbaa"
 // * "#rgb"
 // * "#rgba"
-std::optional<Color4f> parse_hex_color(const std::string& hex) {
+std::optional<Color4f> parse_hex_color (const std::string &hex) {
   // validate size. short syntax uses one hex digit per color channel instead of 2.
-  const bool short_syntax = hex.size() == 4 || hex.size() == 5;
-  const bool long_syntax = hex.size() == 7 || hex.size() == 9;
-  if (!short_syntax && !long_syntax) return {};
+  const bool short_syntax = hex.size () == 4 || hex.size () == 5;
+  const bool long_syntax = hex.size () == 7 || hex.size () == 9;
+  if (!short_syntax && !long_syntax)
+    return {};
 
   // validate
-  if (hex[0] != '#') return {};
-  if (!std::all_of(std::begin(hex) + 1, std::end(hex),
-                   [](char c) {
-      return std::isxdigit(static_cast<unsigned char>(c));
-    })) {
+  if (hex[0] != '#')
+    return {};
+  if (!std::all_of (std::begin (hex) + 1, std::end (hex),
+                    [] (char c) {
+                      return std::isxdigit (static_cast<unsigned char> (c));
+                    })) {
     return {};
   }
 
@@ -215,20 +214,20 @@ std::optional<Color4f> parse_hex_color(const std::string& hex) {
   Vector4f rgba;
   rgba[3] = 1.0; // default alpha to 100%
 
-  for (unsigned i = 0; i < (hex.size() - 1) / stride; ++i) {
-    const std::string chunk = hex.substr(1 + i * stride, stride);
+  for (unsigned i = 0; i < (hex.size () - 1) / stride; ++i) {
+    const std::string chunk = hex.substr (1 + i * stride, stride);
 
     // convert the hex character(s) to a fraction between 0 and 1, inclusive
-    rgba[i] = stoi(chunk, nullptr, 16) / channel_max;
+    rgba[i] = stoi (chunk, nullptr, 16) / channel_max;
   }
 
   return rgba;
 }
 
-std::optional<Color4f> parse_web_color(const std::string& col) {
-  std::string colorname = boost::algorithm::to_lower_copy(col);
-  if (webcolors.find(colorname) != webcolors.end()) {
-    return webcolors.at(colorname);
+std::optional<Color4f> parse_web_color (const std::string &col) {
+  std::string colorname = boost::algorithm::to_lower_copy (col);
+  if (webcolors.find (colorname) != webcolors.end ()) {
+    return webcolors.at (colorname);
   }
   return {};
 }
@@ -237,13 +236,13 @@ std::optional<Color4f> parse_web_color(const std::string& col) {
 
 namespace OpenSCAD {
 
-std::optional<Color4f> parse_color(const std::string& col) {
-  auto webcolor = ::parse_web_color(col);
+std::optional<Color4f> parse_color (const std::string &col) {
+  auto webcolor = ::parse_web_color (col);
   if (webcolor) {
     return webcolor;
   }
 
-  auto hexcolor = ::parse_hex_color(col);
+  auto hexcolor = ::parse_hex_color (col);
   if (hexcolor) {
     return hexcolor;
   }
@@ -251,23 +250,21 @@ std::optional<Color4f> parse_color(const std::string& col) {
   return {};
 }
 
-Color4f getColor(const std::string& col, const Color4f& defaultcolor)
-{
-  const auto parsed = parse_color(col);
+Color4f getColor (const std::string &col, const Color4f &defaultcolor) {
+  const auto parsed = parse_color (col);
 
   if (!parsed) {
-    LOG(message_group::Warning, "Unable to parse color \"%1$s\", reverting to default color.", col);
-    LOG("Please see https://en.wikipedia.org/wiki/Web_colors");
+    LOG (message_group::Warning, "Unable to parse color \"%1$s\", reverting to default color.", col);
+    LOG ("Please see https://en.wikipedia.org/wiki/Web_colors");
   }
 
-  return parsed.value_or(defaultcolor);
+  return parsed.value_or (defaultcolor);
 }
 
-Vector4f getColorHSV(const Color4f& col)
-{
+Vector4f getColorHSV (const Color4f &col) {
   float h, s, v;
-  ::rgbtohsv(col.r(), col.g(), col.b(), h, s, v);
-  return {h, s, v, col.a()};
+  ::rgbtohsv (col.r (), col.g (), col.b (), h, s, v);
+  return {h, s, v, col.a ()};
 }
 
 /**
@@ -277,10 +274,9 @@ Vector4f getColorHSV(const Color4f& col)
  * @param col the input color
  * @return a color with high contrast to the input color
  */
-Color4f getContrastColor(const Color4f& col)
-{
-  const auto hsv = getColorHSV(col);
-  float Y = 0.2126f * col.r() + 0.7152f * col.g() + 0.0722f * col.b();
+Color4f getContrastColor (const Color4f &col) {
+  const auto hsv = getColorHSV (col);
+  float Y = 0.2126f * col.r () + 0.7152f * col.g () + 0.0722f * col.b ();
   float S = hsv[1];
 
   if (S < 0.5) {
diff --git a/src/core/ColorUtil.h b/src/core/ColorUtil.h
index f2402bfff..3215c2550 100644
--- a/src/core/ColorUtil.h
+++ b/src/core/ColorUtil.h
@@ -7,14 +7,14 @@
 
 namespace OpenSCAD {
 
-inline Color4f CORNFIELD_FACE_COLOR{ 0xf9, 0xd7, 0x2c, 0xff };
+inline Color4f CORNFIELD_FACE_COLOR{0xf9, 0xd7, 0x2c, 0xff};
 
-std::optional<Color4f> parse_color(const std::string& col);
+std::optional<Color4f> parse_color (const std::string &col);
 
-Color4f getColor(const std::string& col, const Color4f& defaultcolor);
+Color4f getColor (const std::string &col, const Color4f &defaultcolor);
 
-Color4f getContrastColor(const Color4f& col);
+Color4f getContrastColor (const Color4f &col);
 
-Vector4f getColorHSV(const Color4f& col);
+Vector4f getColorHSV (const Color4f &col);
 
 } // namespace OpenSCAD
diff --git a/src/core/Context.cc b/src/core/Context.cc
index 8b039ea01..c1a1bb5a2 100644
--- a/src/core/Context.cc
+++ b/src/core/Context.cc
@@ -36,48 +36,42 @@
 #include "core/function.h"
 #include "utils/printutils.h"
 
-Context::Context(EvaluationSession *session) :
-  ContextFrame(session),
-  parent(nullptr)
-{}
+Context::Context (EvaluationSession *session)
+  : ContextFrame (session)
+  , parent (nullptr) {}
 
-Context::Context(const std::shared_ptr<const Context>& parent) :
-  ContextFrame(parent->evaluation_session),
-  parent(parent)
-{}
+Context::Context (const std::shared_ptr<const Context> &parent)
+  : ContextFrame (parent->evaluation_session)
+  , parent (parent) {}
 
-Context::~Context()
-{
-  Context::clear();
-  if (accountingAdded)   // avoiding bad accounting where exception threw in constructor issue #3871
-    session()->contextMemoryManager().releaseContext();
+Context::~Context () {
+  Context::clear ();
+  if (accountingAdded) // avoiding bad accounting where exception threw in constructor issue #3871
+    session ()->contextMemoryManager ().releaseContext ();
 }
 
-const Children *Context::user_module_children() const
-{
+const Children *Context::user_module_children () const {
   if (parent) {
-    return parent->user_module_children();
+    return parent->user_module_children ();
   } else {
     return nullptr;
   }
 }
 
-std::vector<const std::shared_ptr<const Context> *> Context::list_referenced_contexts() const
-{
+std::vector<const std::shared_ptr<const Context> *> Context::list_referenced_contexts () const {
   std::vector<const std::shared_ptr<const Context> *> output;
   if (parent) {
-    output.push_back(&parent);
+    output.push_back (&parent);
   }
   return output;
 }
 
-boost::optional<const Value&> Context::try_lookup_variable(const std::string& name) const
-{
-  if (is_config_variable(name)) {
-    return session()->try_lookup_special_variable(name);
+boost::optional<const Value &> Context::try_lookup_variable (const std::string &name) const {
+  if (is_config_variable (name)) {
+    return session ()->try_lookup_special_variable (name);
   }
-  for (const Context *context = this; context != nullptr; context = context->getParent().get()) {
-    boost::optional<const Value&> result = context->lookup_local_variable(name);
+  for (const Context *context = this; context != nullptr; context = context->getParent ().get ()) {
+    boost::optional<const Value &> result = context->lookup_local_variable (name);
     if (result) {
       return result;
     }
@@ -85,72 +79,66 @@ boost::optional<const Value&> Context::try_lookup_variable(const std::string& na
   return boost::none;
 }
 
-const Value& Context::lookup_variable(const std::string& name, const Location& loc) const
-{
-  boost::optional<const Value&> result = try_lookup_variable(name);
+const Value &Context::lookup_variable (const std::string &name, const Location &loc) const {
+  boost::optional<const Value &> result = try_lookup_variable (name);
   if (!result) {
-    LOG(message_group::Warning, loc, documentRoot(), "Ignoring unknown variable %1$s", quoteVar(name));
+    LOG (message_group::Warning, loc, documentRoot (), "Ignoring unknown variable %1$s", quoteVar (name));
     return Value::undefined;
   }
   return *result;
 }
 
-boost::optional<CallableFunction> Context::lookup_function(const std::string& name, const Location& loc) const
-{
-  if (is_config_variable(name)) {
-    return session()->lookup_special_function(name, loc);
+boost::optional<CallableFunction> Context::lookup_function (const std::string &name, const Location &loc) const {
+  if (is_config_variable (name)) {
+    return session ()->lookup_special_function (name, loc);
   }
-  for (const Context *context = this; context != nullptr; context = context->getParent().get()) {
-    boost::optional<CallableFunction> result = context->lookup_local_function(name, loc);
+  for (const Context *context = this; context != nullptr; context = context->getParent ().get ()) {
+    boost::optional<CallableFunction> result = context->lookup_local_function (name, loc);
     if (result) {
       return result;
     }
   }
-  LOG(message_group::Warning, loc, documentRoot(), "Ignoring unknown function '%1$s'", name);
+  LOG (message_group::Warning, loc, documentRoot (), "Ignoring unknown function '%1$s'", name);
   return boost::none;
 }
 
-boost::optional<InstantiableModule> Context::lookup_module(const std::string& name, const Location& loc) const
-{
-  if (is_config_variable(name)) {
-    return session()->lookup_special_module(name, loc);
+boost::optional<InstantiableModule> Context::lookup_module (const std::string &name, const Location &loc) const {
+  if (is_config_variable (name)) {
+    return session ()->lookup_special_module (name, loc);
   }
-  for (const Context *context = this; context != nullptr; context = context->getParent().get()) {
-    boost::optional<InstantiableModule> result = context->lookup_local_module(name, loc);
+  for (const Context *context = this; context != nullptr; context = context->getParent ().get ()) {
+    boost::optional<InstantiableModule> result = context->lookup_local_module (name, loc);
     if (result) {
       return result;
     }
   }
-  LOG(message_group::Warning, loc, this->documentRoot(), "Ignoring unknown module '%1$s'", name);
+  LOG (message_group::Warning, loc, this->documentRoot (), "Ignoring unknown module '%1$s'", name);
   return boost::none;
 }
 
-bool Context::set_variable(const std::string& name, Value&& value)
-{
-  bool new_variable = ContextFrame::set_variable(name, std::move(value));
+bool Context::set_variable (const std::string &name, Value &&value) {
+  bool new_variable = ContextFrame::set_variable (name, std::move (value));
   if (new_variable) {
-    session()->accounting().addContextVariable();
+    session ()->accounting ().addContextVariable ();
   }
   return new_variable;
 }
 
-size_t Context::clear()
-{
-  size_t removed = ContextFrame::clear();
-  session()->accounting().removeContextVariable(removed);
+size_t Context::clear () {
+  size_t removed = ContextFrame::clear ();
+  session ()->accounting ().removeContextVariable (removed);
   return removed;
 }
 
 #ifdef DEBUG
-std::string Context::dump() const
-{
+std::string Context::dump () const {
   std::ostringstream s;
-  s << boost::format("Context %p:\n") % this;
+  s << boost::format ("Context %p:\n") % this;
   Context const *context = this;
   while (context) {
-    s << "  " << context->dumpFrame();
-    context = context->getParent().get();
+    s << "  " << context->dumpFrame ();
+    context = context->getParent ().get ();
   }
-  return s.str();
+  return s.str ();
 }
 #endif // ifdef DEBUG
diff --git a/src/core/Context.h b/src/core/Context.h
index e09bf768f..038d80ce0 100644
--- a/src/core/Context.h
+++ b/src/core/Context.h
@@ -19,48 +19,52 @@ template <typename T>
 class ContextHandle : ContextFrameHandle
 {
 public:
-  ContextHandle(std::shared_ptr<T>&& context) :
-    ContextFrameHandle(context.get()),
-    context(std::move(context))
-  {
+  ContextHandle (std::shared_ptr<T> &&context)
+    : ContextFrameHandle (context.get ())
+    , context (std::move (context)) {
     try {
-      this->context->init();
+      this->context->init ();
     } catch (...) {
-      session->contextMemoryManager().addContext(std::move(this->context));
+      session->contextMemoryManager ().addContext (std::move (this->context));
       throw;
     }
   }
 
-  ~ContextHandle()
-  {
-    assert(!!session == !!context);
+  ~ContextHandle () {
+    assert (!!session == !!context);
     if (session) {
-      session->contextMemoryManager().addContext(std::move(this->context));
+      session->contextMemoryManager ().addContext (std::move (this->context));
     }
   }
 
-  ContextHandle(const ContextHandle&) = delete;
-  ContextHandle& operator=(const ContextHandle&) = delete;
-  ContextHandle(ContextHandle&& other) noexcept = default;
+  ContextHandle (const ContextHandle &) = delete;
+  ContextHandle &operator= (const ContextHandle &) = delete;
+  ContextHandle (ContextHandle &&other) noexcept = default;
 
   // Valid only if $other is on the top of the stack.
-  ContextHandle& operator=(ContextHandle&& other) noexcept {
-    assert(session);
-    assert(context);
-    assert(other.context);
-    assert(other.session);
+  ContextHandle &operator= (ContextHandle &&other) noexcept {
+    assert (session);
+    assert (context);
+    assert (other.context);
+    assert (other.session);
 
     //session->contextMemoryManager().releaseContext();
-    session->contextMemoryManager().addContext(std::move(this->context));
-    other.release();
-    context = std::move(other.context);
-    ContextFrameHandle::operator=(context.get());
+    session->contextMemoryManager ().addContext (std::move (this->context));
+    other.release ();
+    context = std::move (other.context);
+    ContextFrameHandle::operator= (context.get ());
     return *this;
   }
 
-  const T *operator->() const { return context.get(); }
-  T *operator->() { return context.get(); }
-  std::shared_ptr<const T> operator*() const { return context; }
+  const T *operator->() const {
+    return context.get ();
+  }
+  T *operator->() {
+    return context.get ();
+  }
+  std::shared_ptr<const T> operator* () const {
+    return context;
+  }
 
 private:
   std::shared_ptr<T> context;
@@ -69,43 +73,51 @@ private:
 class Context : public ContextFrame, public std::enable_shared_from_this<Context>
 {
 protected:
-  Context(EvaluationSession *session);
-  Context(const std::shared_ptr<const Context>& parent);
+  Context (EvaluationSession *session);
+  Context (const std::shared_ptr<const Context> &parent);
 
 public:
-  ~Context() override;
+  ~Context () override;
 
-  template <typename C, typename ... T>
-  static ContextHandle<C> create(T&& ... t) {
-    return ContextHandle<C>{std::shared_ptr<C>(new C(std::forward<T>(t)...))};
+  template <typename C, typename... T>
+  static ContextHandle<C> create (T &&...t) {
+    return ContextHandle<C>{std::shared_ptr<C> (new C (std::forward<T> (t)...))};
   }
 
-  virtual void init() { }
-
-  std::shared_ptr<const Context> get_shared_ptr() const { return shared_from_this(); }
-  virtual const class Children *user_module_children() const;
-  virtual std::vector<const std::shared_ptr<const Context> *> list_referenced_contexts() const;
-
-  boost::optional<const Value&> try_lookup_variable(const std::string& name) const;
-  const Value& lookup_variable(const std::string& name, const Location& loc) const;
-  boost::optional<CallableFunction> lookup_function(const std::string& name, const Location& loc) const;
-  boost::optional<InstantiableModule> lookup_module(const std::string& name, const Location& loc) const;
-  bool set_variable(const std::string& name, Value&& value) override;
-  size_t clear() override;
+  virtual void init () {}
 
-  const std::shared_ptr<const Context>& getParent() const { return this->parent; }
+  std::shared_ptr<const Context> get_shared_ptr () const {
+    return shared_from_this ();
+  }
+  virtual const class Children *user_module_children () const;
+  virtual std::vector<const std::shared_ptr<const Context> *> list_referenced_contexts () const;
+
+  boost::optional<const Value &> try_lookup_variable (const std::string &name) const;
+  const Value &lookup_variable (const std::string &name, const Location &loc) const;
+  boost::optional<CallableFunction> lookup_function (const std::string &name, const Location &loc) const;
+  boost::optional<InstantiableModule> lookup_module (const std::string &name, const Location &loc) const;
+  bool set_variable (const std::string &name, Value &&value) override;
+  size_t clear () override;
+
+  const std::shared_ptr<const Context> &getParent () const {
+    return this->parent;
+  }
   // This modifies the semantics of the context in an error-prone way. Use with caution.
-  void setParent(const std::shared_ptr<const Context>& parent) { this->parent = parent; }
+  void setParent (const std::shared_ptr<const Context> &parent) {
+    this->parent = parent;
+  }
 
-  void setAccountingAdded() { accountingAdded = true; }
+  void setAccountingAdded () {
+    accountingAdded = true;
+  }
 
 protected:
   std::shared_ptr<const Context> parent;
 
-  bool accountingAdded = false;   // avoiding bad accounting when exception threw in constructor issue #3871
+  bool accountingAdded = false; // avoiding bad accounting when exception threw in constructor issue #3871
 
 public:
 #ifdef DEBUG
-  std::string dump() const;
+  std::string dump () const;
 #endif
 };
diff --git a/src/core/ContextFrame.cc b/src/core/ContextFrame.cc
index 238c40b01..c692a9c10 100644
--- a/src/core/ContextFrame.cc
+++ b/src/core/ContextFrame.cc
@@ -32,127 +32,110 @@
 #include <string>
 #include <vector>
 
+ContextFrame::ContextFrame (EvaluationSession *session)
+  : evaluation_session (session) {}
 
-ContextFrame::ContextFrame(EvaluationSession *session) :
-  evaluation_session(session)
-{}
-
-boost::optional<const Value&> ContextFrame::lookup_local_variable(const std::string& name) const
-{
-  if (is_config_variable(name)) {
-    auto result = config_variables.find(name);
-    if (result != config_variables.end()) {
+boost::optional<const Value &> ContextFrame::lookup_local_variable (const std::string &name) const {
+  if (is_config_variable (name)) {
+    auto result = config_variables.find (name);
+    if (result != config_variables.end ()) {
       return result->second;
     }
   } else {
-    auto result = lexical_variables.find(name);
-    if (result != lexical_variables.end()) {
+    auto result = lexical_variables.find (name);
+    if (result != lexical_variables.end ()) {
       return result->second;
     }
   }
   return boost::none;
 }
 
-boost::optional<CallableFunction> ContextFrame::lookup_local_function(const std::string& name, const Location& /*loc*/) const
-{
-  boost::optional<const Value&> value = lookup_local_variable(name);
-  if (value && value->type() == Value::Type::FUNCTION) {
+boost::optional<CallableFunction> ContextFrame::lookup_local_function (const std::string &name, const Location & /*loc*/) const {
+  boost::optional<const Value &> value = lookup_local_variable (name);
+  if (value && value->type () == Value::Type::FUNCTION) {
     return CallableFunction{&*value};
   }
   return boost::none;
 }
 
-boost::optional<InstantiableModule> ContextFrame::lookup_local_module(const std::string& /*name*/, const Location& /*loc*/) const
-{
+boost::optional<InstantiableModule> ContextFrame::lookup_local_module (const std::string & /*name*/, const Location & /*loc*/) const {
   return boost::none;
 }
 
-std::vector<const Value *> ContextFrame::list_embedded_values() const
-{
+std::vector<const Value *> ContextFrame::list_embedded_values () const {
   std::vector<const Value *> output;
-  for (const auto& variable : lexical_variables) {
-    output.push_back(&variable.second);
+  for (const auto &variable : lexical_variables) {
+    output.push_back (&variable.second);
   }
-  for (const auto& variable : config_variables) {
-    output.push_back(&variable.second);
+  for (const auto &variable : config_variables) {
+    output.push_back (&variable.second);
   }
   return output;
 }
 
-size_t ContextFrame::clear()
-{
-  size_t removed = lexical_variables.size() + config_variables.size();
-  lexical_variables.clear();
-  config_variables.clear();
+size_t ContextFrame::clear () {
+  size_t removed = lexical_variables.size () + config_variables.size ();
+  lexical_variables.clear ();
+  config_variables.clear ();
   return removed;
 }
 
-bool ContextFrame::set_variable(const std::string& name, Value&& value)
-{
-  if (is_config_variable(name)) {
-    return config_variables.insert_or_assign(name, std::move(value)).second;
+bool ContextFrame::set_variable (const std::string &name, Value &&value) {
+  if (is_config_variable (name)) {
+    return config_variables.insert_or_assign (name, std::move (value)).second;
   } else {
-    return lexical_variables.insert_or_assign(name, std::move(value)).second;
+    return lexical_variables.insert_or_assign (name, std::move (value)).second;
   }
 }
 
-void ContextFrame::apply_variables(const ValueMap& variables)
-{
-  for (const auto& variable : variables) {
-    set_variable(variable.first, variable.second.clone());
+void ContextFrame::apply_variables (const ValueMap &variables) {
+  for (const auto &variable : variables) {
+    set_variable (variable.first, variable.second.clone ());
   }
 }
 
-void ContextFrame::apply_lexical_variables(const ContextFrame& other)
-{
-  apply_variables(other.lexical_variables);
+void ContextFrame::apply_lexical_variables (const ContextFrame &other) {
+  apply_variables (other.lexical_variables);
 }
 
-void ContextFrame::apply_config_variables(const ContextFrame& other)
-{
-  apply_variables(other.config_variables);
+void ContextFrame::apply_config_variables (const ContextFrame &other) {
+  apply_variables (other.config_variables);
 }
 
-void ContextFrame::apply_variables(ValueMap&& variables)
-{
-  for (auto& variable : variables) {
-    set_variable(variable.first, std::move(variable.second));
+void ContextFrame::apply_variables (ValueMap &&variables) {
+  for (auto &variable : variables) {
+    set_variable (variable.first, std::move (variable.second));
   }
-  variables.clear();
+  variables.clear ();
 }
 
-void ContextFrame::apply_lexical_variables(ContextFrame&& other)
-{
-  apply_variables(std::move(other.lexical_variables));
+void ContextFrame::apply_lexical_variables (ContextFrame &&other) {
+  apply_variables (std::move (other.lexical_variables));
 }
 
-void ContextFrame::apply_config_variables(ContextFrame&& other)
-{
-  apply_variables(std::move(other.config_variables));
+void ContextFrame::apply_config_variables (ContextFrame &&other) {
+  apply_variables (std::move (other.config_variables));
 }
 
-void ContextFrame::apply_variables(ContextFrame&& other)
-{
-  apply_variables(std::move(other.lexical_variables));
-  apply_variables(std::move(other.config_variables));
+void ContextFrame::apply_variables (ContextFrame &&other) {
+  apply_variables (std::move (other.lexical_variables));
+  apply_variables (std::move (other.config_variables));
 }
 
-bool ContextFrame::is_config_variable(const std::string& name)
-{
+bool ContextFrame::is_config_variable (const std::string &name) {
   return name[0] == '$' && name != "$children";
 }
 
 #ifdef DEBUG
-std::string ContextFrame::dumpFrame() const
-{
+std::string ContextFrame::dumpFrame () const {
   std::ostringstream s;
-  s << boost::format("ContextFrame %p:\n") % this;
-  for (const auto& v : lexical_variables) {
-    s << boost::format("    %s = %s\n") % v.first % v.second.toEchoString();
+  s << boost::format ("ContextFrame %p:\n") % this;
+  for (const auto &v : lexical_variables) {
+    s << boost::format ("    %s = %s\n") % v.first % v.second.toEchoString ();
   }
-  for (const auto& v : config_variables) {
-    s << boost::format("    %s = %s\n") % v.first % v.second.toEchoString();
+  for (const auto &v : config_variables) {
+    s << boost::format ("    %s = %s\n") % v.first % v.second.toEchoString ();
   }
-  return s.str();
+  return s.str ();
 }
 #endif // ifdef DEBUG
diff --git a/src/core/ContextFrame.h b/src/core/ContextFrame.h
index ffae22b31..32f9849e0 100644
--- a/src/core/ContextFrame.h
+++ b/src/core/ContextFrame.h
@@ -12,37 +12,41 @@
 class ContextFrame
 {
 public:
-  ContextFrame(EvaluationSession *session);
-  virtual ~ContextFrame() = default;
+  ContextFrame (EvaluationSession *session);
+  virtual ~ContextFrame () = default;
 
-  ContextFrame(ContextFrame&& other) = default;
+  ContextFrame (ContextFrame &&other) = default;
 
-  virtual boost::optional<const Value&> lookup_local_variable(const std::string& name) const;
-  virtual boost::optional<CallableFunction> lookup_local_function(const std::string& name, const Location& loc) const;
-  virtual boost::optional<InstantiableModule> lookup_local_module(const std::string& name, const Location& loc) const;
+  virtual boost::optional<const Value &> lookup_local_variable (const std::string &name) const;
+  virtual boost::optional<CallableFunction> lookup_local_function (const std::string &name, const Location &loc) const;
+  virtual boost::optional<InstantiableModule> lookup_local_module (const std::string &name, const Location &loc) const;
 
-  virtual std::vector<const Value *> list_embedded_values() const;
-  virtual size_t clear();
+  virtual std::vector<const Value *> list_embedded_values () const;
+  virtual size_t clear ();
 
-  virtual bool set_variable(const std::string& name, Value&& value);
+  virtual bool set_variable (const std::string &name, Value &&value);
 
-  void apply_variables(const ValueMap& variables);
-  void apply_lexical_variables(const ContextFrame& other);
-  void apply_config_variables(const ContextFrame& other);
-  void apply_variables(const ContextFrame& other) {
-    apply_lexical_variables(other);
-    apply_config_variables(other);
+  void apply_variables (const ValueMap &variables);
+  void apply_lexical_variables (const ContextFrame &other);
+  void apply_config_variables (const ContextFrame &other);
+  void apply_variables (const ContextFrame &other) {
+    apply_lexical_variables (other);
+    apply_config_variables (other);
   }
 
-  void apply_variables(ValueMap&& variables);
-  void apply_lexical_variables(ContextFrame&& other);
-  void apply_config_variables(ContextFrame&& other);
-  void apply_variables(ContextFrame&& other);
+  void apply_variables (ValueMap &&variables);
+  void apply_lexical_variables (ContextFrame &&other);
+  void apply_config_variables (ContextFrame &&other);
+  void apply_variables (ContextFrame &&other);
 
-  static bool is_config_variable(const std::string& name);
+  static bool is_config_variable (const std::string &name);
 
-  EvaluationSession *session() const { return evaluation_session; }
-  const std::string& documentRoot() const { return evaluation_session->documentRoot(); }
+  EvaluationSession *session () const {
+    return evaluation_session;
+  }
+  const std::string &documentRoot () const {
+    return evaluation_session->documentRoot ();
+  }
 
 protected:
   ValueMap lexical_variables;
@@ -51,7 +55,7 @@ protected:
 
 public:
 #ifdef DEBUG
-  virtual std::string dumpFrame() const;
+  virtual std::string dumpFrame () const;
 #endif
 };
 
@@ -62,39 +66,34 @@ public:
 class ContextFrameHandle
 {
 public:
-  ContextFrameHandle(ContextFrame *frame) :
-    session(frame->session())
-  {
-    frame_index = session->push_frame(frame);
+  ContextFrameHandle (ContextFrame *frame)
+    : session (frame->session ()) {
+    frame_index = session->push_frame (frame);
   }
-  ~ContextFrameHandle()
-  {
-    release();
+  ~ContextFrameHandle () {
+    release ();
   }
 
-  ContextFrameHandle(const ContextFrameHandle&) = delete;
-  ContextFrameHandle& operator=(const ContextFrameHandle&) = delete;
-  ContextFrameHandle& operator=(ContextFrameHandle&&) = delete;
+  ContextFrameHandle (const ContextFrameHandle &) = delete;
+  ContextFrameHandle &operator= (const ContextFrameHandle &) = delete;
+  ContextFrameHandle &operator= (ContextFrameHandle &&) = delete;
 
-  ContextFrameHandle(ContextFrameHandle&& other) noexcept :
-    session(other.session),
-    frame_index(other.frame_index)
-  {
+  ContextFrameHandle (ContextFrameHandle &&other) noexcept
+    : session (other.session)
+    , frame_index (other.frame_index) {
     other.session = nullptr;
   }
 
-  ContextFrameHandle& operator=(ContextFrame *frame)
-  {
-    assert(session == frame->session());
-    session->replace_frame(frame_index, frame);
+  ContextFrameHandle &operator= (ContextFrame *frame) {
+    assert (session == frame->session ());
+    session->replace_frame (frame_index, frame);
     return *this;
   }
 
   // Valid only if handle is on the top of the stack.
-  void release()
-  {
+  void release () {
     if (session) {
-      session->pop_frame(frame_index);
+      session->pop_frame (frame_index);
       session = nullptr;
     }
   }
diff --git a/src/core/ContextMemoryManager.cc b/src/core/ContextMemoryManager.cc
index 070ee8e6d..bf8e6eab1 100644
--- a/src/core/ContextMemoryManager.cc
+++ b/src/core/ContextMemoryManager.cc
@@ -54,64 +54,88 @@
  */
 using ValueIdentifier = void *;
 
-struct IdentifierVisitor
-{
-  ValueIdentifier operator()(const VectorType& value) const { return value.ptr.get(); }
-  ValueIdentifier operator()(const EmbeddedVectorType& value) const { return value.ptr.get(); }
-  ValueIdentifier operator()(const ObjectType& value) const { return value.ptr.get(); }
-  ValueIdentifier operator()(const FunctionPtr& value) const { return value.get().get(); }
+struct IdentifierVisitor {
+  ValueIdentifier operator() (const VectorType &value) const {
+    return value.ptr.get ();
+  }
+  ValueIdentifier operator() (const EmbeddedVectorType &value) const {
+    return value.ptr.get ();
+  }
+  ValueIdentifier operator() (const ObjectType &value) const {
+    return value.ptr.get ();
+  }
+  ValueIdentifier operator() (const FunctionPtr &value) const {
+    return value.get ().get ();
+  }
 
   // all types without identity
-  template <typename T> ValueIdentifier operator()(const T&) const {
+  template <typename T>
+  ValueIdentifier operator() (const T &) const {
     return nullptr;
   }
 };
 
-struct UseCountVisitor
-{
-  int operator()(const VectorType& value) const { return value.ptr.use_count(); }
-  int operator()(const EmbeddedVectorType& value) const { return value.ptr.use_count(); }
-  int operator()(const ObjectType& value) const { return value.ptr.use_count(); }
-  int operator()(const FunctionPtr& value) const { return value.get().use_count(); }
+struct UseCountVisitor {
+  int operator() (const VectorType &value) const {
+    return value.ptr.use_count ();
+  }
+  int operator() (const EmbeddedVectorType &value) const {
+    return value.ptr.use_count ();
+  }
+  int operator() (const ObjectType &value) const {
+    return value.ptr.use_count ();
+  }
+  int operator() (const FunctionPtr &value) const {
+    return value.get ().use_count ();
+  }
 
   // all types without use count
-  template <typename T> int operator()(const T&) const {
+  template <typename T>
+  int operator() (const T &) const {
     return 0;
   }
 };
 
 template <typename F>
 struct EmbeddedValuesVisitor {
-  const F&& func;
-  explicit EmbeddedValuesVisitor(F&& func) : func(std::forward<F>(func)) {}
+  const F &&func;
+  explicit EmbeddedValuesVisitor (F &&func)
+    : func (std::forward<F> (func)) {}
 
-  void operator()(const VectorType& value) const { call_each(value.ptr->vec); }
-  void operator()(const EmbeddedVectorType& value) const { call_each(value.ptr->vec); }
-  void operator()(const ObjectType& value) const { call_each(value.ptr->values); }
+  void operator() (const VectorType &value) const {
+    call_each (value.ptr->vec);
+  }
+  void operator() (const EmbeddedVectorType &value) const {
+    call_each (value.ptr->vec);
+  }
+  void operator() (const ObjectType &value) const {
+    call_each (value.ptr->values);
+  }
 
   // unused types
-  template <typename T> void operator()(const T&) const {}
+  template <typename T>
+  void operator() (const T &) const {}
 
 private:
-  void call_each(const std::vector<Value>& vector) const {
-    for (const Value& member : vector) {
-      func(member);
+  void call_each (const std::vector<Value> &vector) const {
+    for (const Value &member : vector) {
+      func (member);
     }
   }
 };
 
-struct ReferencedContextVisitor
-{
-  const std::shared_ptr<const Context> *operator()(const FunctionPtr& value) const { return &value->getContext(); }
+struct ReferencedContextVisitor {
+  const std::shared_ptr<const Context> *operator() (const FunctionPtr &value) const {
+    return &value->getContext ();
+  }
 
   // unused types
-  template <typename T> const std::shared_ptr<const Context> *operator()(const T&) const {
+  template <typename T>
+  const std::shared_ptr<const Context> *operator() (const T &) const {
     return nullptr;
   }
 };
 
-
-
 /*
  * Finds all contexts that have an inbound reference from something that is not
  * another context.
@@ -125,8 +149,7 @@ struct ReferencedContextVisitor
  *
  * Implemented as a breadth first search to save on stack space.
  */
-static std::vector<Context *> findRootContexts(const std::vector<std::shared_ptr<Context>>& managedContexts)
-{
+static std::vector<Context *> findRootContexts (const std::vector<std::shared_ptr<Context>> &managedContexts) {
   std::map<ValueIdentifier, int> accountedValueReferences;
   std::map<const Context *, int> accountedContextReferences;
   std::unordered_set<const Context *> fullyAccountedContexts;
@@ -134,135 +157,134 @@ static std::vector<Context *> findRootContexts(const std::vector<std::shared_ptr
   std::deque<const Value *> valueQueue;
   std::deque<const std::shared_ptr<const Context> *> contextQueue;
 
-  auto visitValue = [&](const Value& value) {
-      ValueIdentifier identifier = std::visit(IdentifierVisitor(), value.getVariant());
-      if (!identifier) {
-        return;
-      }
+  auto visitValue = [&] (const Value &value) {
+    ValueIdentifier identifier = std::visit (IdentifierVisitor (), value.getVariant ());
+    if (!identifier) {
+      return;
+    }
 
-      if (!accountedValueReferences.count(identifier)) {
-        accountedValueReferences[identifier] = 0;
-      }
-      const int accountedReferences = ++accountedValueReferences[identifier];
-      const int requiredReferences = std::visit(UseCountVisitor(), value.getVariant());
-      assert(accountedReferences <= requiredReferences);
-
-      if (accountedReferences == requiredReferences) {
-        std::visit(EmbeddedValuesVisitor{[&](const Value& v) {
-                                           valueQueue.push_back(&v);
-                                         }}, value.getVariant());
-
-        const std::shared_ptr<const Context> *referencedContext = std::visit(ReferencedContextVisitor(), value.getVariant());
-        if (referencedContext) {
-          contextQueue.push_back(referencedContext);
-        }
-      }
-    };
+    if (!accountedValueReferences.count (identifier)) {
+      accountedValueReferences[identifier] = 0;
+    }
+    const int accountedReferences = ++accountedValueReferences[identifier];
+    const int requiredReferences = std::visit (UseCountVisitor (), value.getVariant ());
+    assert (accountedReferences <= requiredReferences);
 
-  auto visitContext = [&](const std::shared_ptr<const Context>& context) {
-      if (!accountedContextReferences.count(context.get())) {
-        accountedContextReferences[context.get()] = 0;
-      }
-      const int accountedReferences = ++accountedContextReferences[context.get()];
-      const int requiredReferences = context.use_count();
-      assert(accountedReferences <= requiredReferences);
-      if (accountedReferences == requiredReferences) {
-        fullyAccountedContexts.insert(context.get());
+    if (accountedReferences == requiredReferences) {
+      std::visit (EmbeddedValuesVisitor{[&] (const Value &v) {
+                    valueQueue.push_back (&v);
+                  }},
+                  value.getVariant ());
+
+      const std::shared_ptr<const Context> *referencedContext = std::visit (ReferencedContextVisitor (), value.getVariant ());
+      if (referencedContext) {
+        contextQueue.push_back (referencedContext);
       }
-    };
+    }
+  };
+
+  auto visitContext = [&] (const std::shared_ptr<const Context> &context) {
+    if (!accountedContextReferences.count (context.get ())) {
+      accountedContextReferences[context.get ()] = 0;
+    }
+    const int accountedReferences = ++accountedContextReferences[context.get ()];
+    const int requiredReferences = context.use_count ();
+    assert (accountedReferences <= requiredReferences);
+    if (accountedReferences == requiredReferences) {
+      fullyAccountedContexts.insert (context.get ());
+    }
+  };
 
-  for (const std::shared_ptr<Context>& context : managedContexts) {
-    std::vector<const Value *> values = context->list_embedded_values();
-    valueQueue.insert(valueQueue.end(), values.begin(), values.end());
+  for (const std::shared_ptr<Context> &context : managedContexts) {
+    std::vector<const Value *> values = context->list_embedded_values ();
+    valueQueue.insert (valueQueue.end (), values.begin (), values.end ());
 
-    std::vector<const std::shared_ptr<const Context> *> referencedContexts = context->list_referenced_contexts();
-    contextQueue.insert(contextQueue.end(), referencedContexts.begin(), referencedContexts.end());
+    std::vector<const std::shared_ptr<const Context> *> referencedContexts = context->list_referenced_contexts ();
+    contextQueue.insert (contextQueue.end (), referencedContexts.begin (), referencedContexts.end ());
 
-    accountedContextReferences[context.get()] = 1;
+    accountedContextReferences[context.get ()] = 1;
   }
 
-  while (!valueQueue.empty() || !contextQueue.empty()) {
-    if (!valueQueue.empty()) {
-      const Value *value = valueQueue.front();
-      valueQueue.pop_front();
-      visitValue(*value);
+  while (!valueQueue.empty () || !contextQueue.empty ()) {
+    if (!valueQueue.empty ()) {
+      const Value *value = valueQueue.front ();
+      valueQueue.pop_front ();
+      visitValue (*value);
     } else {
-      assert(!contextQueue.empty());
-      const std::shared_ptr<const Context> *context = contextQueue.front();
-      contextQueue.pop_front();
-      visitContext(*context);
+      assert (!contextQueue.empty ());
+      const std::shared_ptr<const Context> *context = contextQueue.front ();
+      contextQueue.pop_front ();
+      visitContext (*context);
     }
   }
 
   std::vector<Context *> rootContexts;
-  for (const std::shared_ptr<Context>& context : managedContexts) {
-    if (!fullyAccountedContexts.count(context.get())) {
-      rootContexts.push_back(context.get());
+  for (const std::shared_ptr<Context> &context : managedContexts) {
+    if (!fullyAccountedContexts.count (context.get ())) {
+      rootContexts.push_back (context.get ());
     }
   }
   return rootContexts;
 }
 
-
-
 /*
  * Finds all contexts reachable from a set of root contexts.
  *
  * Implemented as a breadth first search to save on stack space.
  */
-static std::unordered_set<const Context *> findReachableContexts(const std::vector<Context *>& rootContexts)
-{
+static std::unordered_set<const Context *> findReachableContexts (const std::vector<Context *> &rootContexts) {
   std::unordered_set<ValueIdentifier> valuesSeen;
   std::unordered_set<const Context *> contextsSeen;
 
   std::deque<const Value *> valueQueue;
   std::deque<const Context *> contextQueue;
 
-  auto visitValue = [&](const Value& value) {
-      ValueIdentifier identifier = std::visit(IdentifierVisitor(), value.getVariant());
-      if (!identifier) {
-        return;
-      }
-      if (!valuesSeen.count(identifier)) {
-        valuesSeen.insert(identifier);
-        valueQueue.push_back(&value);
-      }
-    };
-  auto visitContext = [&](const Context *context) {
-      if (!contextsSeen.count(context)) {
-        contextsSeen.insert(context);
-        contextQueue.push_back(context);
-      }
-    };
+  auto visitValue = [&] (const Value &value) {
+    ValueIdentifier identifier = std::visit (IdentifierVisitor (), value.getVariant ());
+    if (!identifier) {
+      return;
+    }
+    if (!valuesSeen.count (identifier)) {
+      valuesSeen.insert (identifier);
+      valueQueue.push_back (&value);
+    }
+  };
+  auto visitContext = [&] (const Context *context) {
+    if (!contextsSeen.count (context)) {
+      contextsSeen.insert (context);
+      contextQueue.push_back (context);
+    }
+  };
 
-  contextsSeen.insert(rootContexts.begin(), rootContexts.end());
-  contextQueue.insert(contextQueue.end(), rootContexts.begin(), rootContexts.end());
-  while (!valueQueue.empty() || !contextQueue.empty()) {
-    if (!valueQueue.empty()) {
-      const Value *value = valueQueue.front();
-      valueQueue.pop_front();
+  contextsSeen.insert (rootContexts.begin (), rootContexts.end ());
+  contextQueue.insert (contextQueue.end (), rootContexts.begin (), rootContexts.end ());
+  while (!valueQueue.empty () || !contextQueue.empty ()) {
+    if (!valueQueue.empty ()) {
+      const Value *value = valueQueue.front ();
+      valueQueue.pop_front ();
 
-      std::visit(EmbeddedValuesVisitor{[&](const Value& v) {
-                                         visitValue(v);
-                                       }}, value->getVariant());
+      std::visit (EmbeddedValuesVisitor{[&] (const Value &v) {
+                    visitValue (v);
+                  }},
+                  value->getVariant ());
 
-      const std::shared_ptr<const Context> *referencedContext = std::visit(ReferencedContextVisitor(), value->getVariant());
+      const std::shared_ptr<const Context> *referencedContext = std::visit (ReferencedContextVisitor (), value->getVariant ());
       if (referencedContext) {
-        visitContext(referencedContext->get());
+        visitContext (referencedContext->get ());
       }
     } else {
-      assert(!contextQueue.empty());
-      const Context *context = contextQueue.front();
-      contextQueue.pop_front();
+      assert (!contextQueue.empty ());
+      const Context *context = contextQueue.front ();
+      contextQueue.pop_front ();
 
-      const std::vector<const Value *> values = context->list_embedded_values();
+      const std::vector<const Value *> values = context->list_embedded_values ();
       for (const Value *value : values) {
-        visitValue(*value);
+        visitValue (*value);
       }
 
-      const std::vector<const std::shared_ptr<const Context> *> referencedContexts = context->list_referenced_contexts();
+      const std::vector<const std::shared_ptr<const Context> *> referencedContexts = context->list_referenced_contexts ();
       for (const std::shared_ptr<const Context> *referencedContext : referencedContexts) {
-        visitContext(referencedContext->get());
+        visitContext (referencedContext->get ());
       }
     }
   }
@@ -270,13 +292,10 @@ static std::unordered_set<const Context *> findReachableContexts(const std::vect
   return contextsSeen;
 }
 
-
-
 /*
  * Clean up all unreachable contexts.
  */
-static void collectGarbage(std::vector<std::weak_ptr<Context>>& managedContexts)
-{
+static void collectGarbage (std::vector<std::weak_ptr<Context>> &managedContexts) {
   /*
    * Garbage collection consists of three phases.
    *
@@ -299,29 +318,29 @@ static void collectGarbage(std::vector<std::weak_ptr<Context>>& managedContexts)
    * Lock all contexts to prevent deletion during reachability analysis.
    */
   std::vector<std::shared_ptr<Context>> allContexts;
-  for (const std::weak_ptr<Context>& managedContext : managedContexts) {
-    std::shared_ptr<Context> context = managedContext.lock();
+  for (const std::weak_ptr<Context> &managedContext : managedContexts) {
+    std::shared_ptr<Context> context = managedContext.lock ();
     if (context) {
-      allContexts.push_back(std::move(context));
+      allContexts.push_back (std::move (context));
     }
   }
 
-  const std::vector<Context *> rootContexts = findRootContexts(allContexts);
+  const std::vector<Context *> rootContexts = findRootContexts (allContexts);
 
-  const std::unordered_set<const Context *> reachableContexts = findReachableContexts(rootContexts);
+  const std::unordered_set<const Context *> reachableContexts = findReachableContexts (rootContexts);
 
 #ifdef DEBUG
   std::vector<std::weak_ptr<Context>> removedContexts;
 #endif
 
-  managedContexts.clear();
-  for (const std::shared_ptr<Context>& context : allContexts) {
-    if (reachableContexts.count(context.get())) {
-      managedContexts.emplace_back(context);
+  managedContexts.clear ();
+  for (const std::shared_ptr<Context> &context : allContexts) {
+    if (reachableContexts.count (context.get ())) {
+      managedContexts.emplace_back (context);
     } else {
-      context->clear();
+      context->clear ();
 #ifdef DEBUG
-      removedContexts.emplace_back(context);
+      removedContexts.emplace_back (context);
 #endif
     }
   }
@@ -336,41 +355,37 @@ static void collectGarbage(std::vector<std::weak_ptr<Context>>& managedContexts)
    * stack, clear out allContexts back-to-front, which is reverse creation
    * order.
    */
-  while (!allContexts.empty()) {
-    allContexts.pop_back();
+  while (!allContexts.empty ()) {
+    allContexts.pop_back ();
   }
 
 #ifdef DEBUG
-  for (const auto& context : removedContexts) {
-    assert(context.expired());
+  for (const auto &context : removedContexts) {
+    assert (context.expired ());
   }
 #endif
 }
 
-
-
-ContextMemoryManager::~ContextMemoryManager()
-{
-  collectGarbage(managedContexts);
-  assert(managedContexts.empty());
-  assert(heapSizeAccounting.size() == 0);
+ContextMemoryManager::~ContextMemoryManager () {
+  collectGarbage (managedContexts);
+  assert (managedContexts.empty ());
+  assert (heapSizeAccounting.size () == 0);
 }
 
-void ContextMemoryManager::addContext(const std::shared_ptr<Context>& context)
-{
-  heapSizeAccounting.addContext();
-  context->setAccountingAdded();   // avoiding bad accounting when an exception threw in constructor issue #3871
+void ContextMemoryManager::addContext (const std::shared_ptr<Context> &context) {
+  heapSizeAccounting.addContext ();
+  context->setAccountingAdded (); // avoiding bad accounting when an exception threw in constructor issue #3871
 
   /*
    * If we are holding the last copy to this context, no point in invoking
    * the garbage collection machinery, we can just let context get destroyed
    * right away.
    */
-  if (context.use_count() > 1) {
-    managedContexts.emplace_back(context);
+  if (context.use_count () > 1) {
+    managedContexts.emplace_back (context);
 
-    if (heapSizeAccounting.size() >= nextGarbageCollectSize) {
-      collectGarbage(managedContexts);
+    if (heapSizeAccounting.size () >= nextGarbageCollectSize) {
+      collectGarbage (managedContexts);
       /*
        * The cost of a garbage collection run is proportional to the heap
        * size. By scheduling the next run at twice the *remaining* heap size,
@@ -380,7 +395,7 @@ void ContextMemoryManager::addContext(const std::shared_ptr<Context>& context)
        * used at any point at most twice the amount of necessary memory usage
        * (i.e. waste is at most a factor 2 overhead).
        */
-      nextGarbageCollectSize = heapSizeAccounting.size() * 2;
+      nextGarbageCollectSize = heapSizeAccounting.size () * 2;
     }
   }
 }
diff --git a/src/core/ContextMemoryManager.h b/src/core/ContextMemoryManager.h
index 9884acef4..889658da5 100644
--- a/src/core/ContextMemoryManager.h
+++ b/src/core/ContextMemoryManager.h
@@ -18,14 +18,28 @@ class Context;
 class HeapSizeAccounting
 {
 public:
-  void addContext(size_t number = 1) { count += number; }
-  void removeContext(size_t number = 1) { count -= number; }
-  void addContextVariable(size_t number = 1) { count += number; }
-  void removeContextVariable(size_t number = 1) { count -= number; }
-  void addVectorElement(size_t number = 1) { count += number; }
-  void removeVectorElement(size_t number = 1) { count -= number; }
+  void addContext (size_t number = 1) {
+    count += number;
+  }
+  void removeContext (size_t number = 1) {
+    count -= number;
+  }
+  void addContextVariable (size_t number = 1) {
+    count += number;
+  }
+  void removeContextVariable (size_t number = 1) {
+    count -= number;
+  }
+  void addVectorElement (size_t number = 1) {
+    count += number;
+  }
+  void removeVectorElement (size_t number = 1) {
+    count -= number;
+  }
 
-  [[nodiscard]] size_t size() const { return count; }
+  [[nodiscard]] size_t size () const {
+    return count;
+  }
 
 private:
   size_t count = 0;
@@ -34,12 +48,16 @@ private:
 class ContextMemoryManager
 {
 public:
-  ~ContextMemoryManager();
+  ~ContextMemoryManager ();
 
-  void addContext(const std::shared_ptr<Context>& context);
-  void releaseContext() { heapSizeAccounting.removeContext(); }
+  void addContext (const std::shared_ptr<Context> &context);
+  void releaseContext () {
+    heapSizeAccounting.removeContext ();
+  }
 
-  HeapSizeAccounting& accounting() { return heapSizeAccounting; }
+  HeapSizeAccounting &accounting () {
+    return heapSizeAccounting;
+  }
 
 private:
   std::vector<std::weak_ptr<Context>> managedContexts;
diff --git a/src/core/CsgOpNode.cc b/src/core/CsgOpNode.cc
index 78118dab5..323969ce3 100644
--- a/src/core/CsgOpNode.cc
+++ b/src/core/CsgOpNode.cc
@@ -37,31 +37,26 @@
 #include <string>
 #include <cassert>
 
-static std::shared_ptr<AbstractNode> builtin_union(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {});
-  return children.instantiate(std::make_shared<CsgOpNode>(inst, OpenSCADOperator::UNION));
+static std::shared_ptr<AbstractNode> builtin_union (const ModuleInstantiation *inst, Arguments arguments, const Children &children) {
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (), {});
+  return children.instantiate (std::make_shared<CsgOpNode> (inst, OpenSCADOperator::UNION));
 }
 
-static std::shared_ptr<AbstractNode> builtin_difference(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {});
-  return children.instantiate(std::make_shared<CsgOpNode>(inst, OpenSCADOperator::DIFFERENCE));
+static std::shared_ptr<AbstractNode> builtin_difference (const ModuleInstantiation *inst, Arguments arguments, const Children &children) {
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (), {});
+  return children.instantiate (std::make_shared<CsgOpNode> (inst, OpenSCADOperator::DIFFERENCE));
 }
 
-static std::shared_ptr<AbstractNode> builtin_intersection(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {});
-  return children.instantiate(std::make_shared<CsgOpNode>(inst, OpenSCADOperator::INTERSECTION));
+static std::shared_ptr<AbstractNode> builtin_intersection (const ModuleInstantiation *inst, Arguments arguments, const Children &children) {
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (), {});
+  return children.instantiate (std::make_shared<CsgOpNode> (inst, OpenSCADOperator::INTERSECTION));
 }
 
-std::string CsgOpNode::toString() const
-{
-  return this->name() + "()";
+std::string CsgOpNode::toString () const {
+  return this->name () + "()";
 }
 
-std::string CsgOpNode::name() const
-{
+std::string CsgOpNode::name () const {
   switch (this->type) {
   case OpenSCADOperator::UNION:
     return "union";
@@ -73,25 +68,24 @@ std::string CsgOpNode::name() const
     return "intersection";
     break;
   default:
-    assert(false);
+    assert (false);
   }
   return "internal_error";
 }
 
-void register_builtin_csgops()
-{
-  Builtins::init("union", new BuiltinModule(builtin_union),
-  {
-    "union()",
-  });
+void register_builtin_csgops () {
+  Builtins::init ("union", new BuiltinModule (builtin_union),
+                  {
+                    "union()",
+                  });
 
-  Builtins::init("difference", new BuiltinModule(builtin_difference),
-  {
-    "difference()",
-  });
+  Builtins::init ("difference", new BuiltinModule (builtin_difference),
+                  {
+                    "difference()",
+                  });
 
-  Builtins::init("intersection", new BuiltinModule(builtin_intersection),
-  {
-    "intersection()",
-  });
+  Builtins::init ("intersection", new BuiltinModule (builtin_intersection),
+                  {
+                    "intersection()",
+                  });
 }
diff --git a/src/core/CsgOpNode.h b/src/core/CsgOpNode.h
index 236f9e976..f094635ee 100644
--- a/src/core/CsgOpNode.h
+++ b/src/core/CsgOpNode.h
@@ -9,9 +9,11 @@
 class CsgOpNode : public AbstractNode
 {
 public:
-  VISITABLE();
+  VISITABLE ();
   OpenSCADOperator type;
-  CsgOpNode(const ModuleInstantiation *mi, OpenSCADOperator type) : AbstractNode(mi), type(type) { }
-  std::string toString() const override;
-  std::string name() const override;
+  CsgOpNode (const ModuleInstantiation *mi, OpenSCADOperator type)
+    : AbstractNode (mi)
+    , type (type) {}
+  std::string toString () const override;
+  std::string name () const override;
 };
diff --git a/src/core/DrawingCallback.cc b/src/core/DrawingCallback.cc
index 48e2be283..17a9b8e8c 100644
--- a/src/core/DrawingCallback.cc
+++ b/src/core/DrawingCallback.cc
@@ -31,97 +31,89 @@
 
 #include "geometry/Polygon2d.h"
 
-DrawingCallback::DrawingCallback(unsigned long fn, double size) :
-  pen(Vector2d(0, 0)), offset(Vector2d(0, 0)), advance(Vector2d(0, 0)), fn(fn), size(size)
-{
+DrawingCallback::DrawingCallback (unsigned long fn, double size)
+  : pen (Vector2d (0, 0))
+  , offset (Vector2d (0, 0))
+  , advance (Vector2d (0, 0))
+  , fn (fn)
+  , size (size) {
 }
 
-DrawingCallback::~DrawingCallback()
-{
+DrawingCallback::~DrawingCallback () {
 }
 
-void DrawingCallback::start_glyph()
-{
-  this->polygon = std::make_shared<Polygon2d>();
+void DrawingCallback::start_glyph () {
+  this->polygon = std::make_shared<Polygon2d> ();
   // FIXME: Why do we think that a glyph is sanitized?
   // This is technically not true, since we don't maintain correct values for the 'positive' flag.
-  this->polygon->setSanitized(true);
+  this->polygon->setSanitized (true);
 }
 
-void DrawingCallback::finish_glyph()
-{
-  if (this->outline.vertices.size() > 0) {
-    this->polygon->addOutline(this->outline);
-    this->outline.vertices.clear();
+void DrawingCallback::finish_glyph () {
+  if (this->outline.vertices.size () > 0) {
+    this->polygon->addOutline (this->outline);
+    this->outline.vertices.clear ();
   }
-  if (this->polygon->outlines().size() == 0) {
+  if (this->polygon->outlines ().size () == 0) {
     this->polygon = nullptr;
   }
   if (this->polygon) {
-    this->polygons.push_back(this->polygon);
+    this->polygons.push_back (this->polygon);
     this->polygon = nullptr;
   }
 }
 
-std::vector<std::shared_ptr<const Polygon2d>> DrawingCallback::get_result()
-{
+std::vector<std::shared_ptr<const Polygon2d>> DrawingCallback::get_result () {
   return this->polygons;
 }
 
-void DrawingCallback::set_glyph_offset(double offset_x, double offset_y)
-{
-  offset = Vector2d(offset_x, offset_y);
+void DrawingCallback::set_glyph_offset (double offset_x, double offset_y) {
+  offset = Vector2d (offset_x, offset_y);
 }
 
-void DrawingCallback::add_glyph_advance(double advance_x, double advance_y)
-{
-  advance += Vector2d(advance_x, advance_y);
+void DrawingCallback::add_glyph_advance (double advance_x, double advance_y) {
+  advance += Vector2d (advance_x, advance_y);
 }
 
-void DrawingCallback::add_vertex(const Vector2d& v)
-{
-  this->outline.vertices.push_back(size * (v + offset + advance));
+void DrawingCallback::add_vertex (const Vector2d &v) {
+  this->outline.vertices.push_back (size * (v + offset + advance));
 }
 
-void DrawingCallback::move_to(const Vector2d& to)
-{
-  if (this->outline.vertices.size() > 0) {
-    this->polygon->addOutline(this->outline);
-    this->outline.vertices.clear();
+void DrawingCallback::move_to (const Vector2d &to) {
+  if (this->outline.vertices.size () > 0) {
+    this->polygon->addOutline (this->outline);
+    this->outline.vertices.clear ();
   }
-  add_vertex(to);
+  add_vertex (to);
   pen = to;
 }
 
-void DrawingCallback::line_to(const Vector2d& to)
-{
-  add_vertex(to);
+void DrawingCallback::line_to (const Vector2d &to) {
+  add_vertex (to);
   pen = to;
 }
 
 // Quadric Bezier curve
-void DrawingCallback::curve_to(const Vector2d& c1, const Vector2d& to)
-{
+void DrawingCallback::curve_to (const Vector2d &c1, const Vector2d &to) {
   // NOTE - this could be done better using a chord length iteration (uniform in space) to implement $fa (lot of work, little gain)
   for (unsigned long idx = 1; idx <= fn; ++idx) {
     const double a = idx * (1.0 / (double)fn);
-    add_vertex(pen * pow(1 - a, 2) +
-               c1 * 2 * pow(1 - a, 1) * a +
-               to * pow(a, 2));
+    add_vertex (pen * pow (1 - a, 2) +
+                c1 * 2 * pow (1 - a, 1) * a +
+                to * pow (a, 2));
   }
   pen = to;
 }
 
 // Cubic Bezier curve
-void DrawingCallback::curve_to(const Vector2d& c1, const Vector2d& c2, const Vector2d& to)
-{
+void DrawingCallback::curve_to (const Vector2d &c1, const Vector2d &c2, const Vector2d &to) {
   // NOTE - this could be done better using a chord length iteration (uniform in space) to implement $fa (lot of work, little gain)
   for (unsigned long idx = 1; idx <= fn; ++idx) {
     const double a = idx * (1.0 / (double)fn);
-    add_vertex(pen * pow(1 - a, 3) +
-               c1 * 3 * pow(1 - a, 2) * a +
-               c2 * 3 * pow(1 - a, 1) * pow(a, 2) +
-               to * pow(a, 3));
+    add_vertex (pen * pow (1 - a, 3) +
+                c1 * 3 * pow (1 - a, 2) * a +
+                c2 * 3 * pow (1 - a, 1) * pow (a, 2) +
+                to * pow (a, 3));
   }
   pen = to;
 }
diff --git a/src/core/DrawingCallback.h b/src/core/DrawingCallback.h
index 79fdd8289..689775321 100644
--- a/src/core/DrawingCallback.h
+++ b/src/core/DrawingCallback.h
@@ -38,19 +38,20 @@ class Geometry;
 class DrawingCallback
 {
 public:
-  DrawingCallback(unsigned long fn, double size);
-  virtual ~DrawingCallback();
+  DrawingCallback (unsigned long fn, double size);
+  virtual ~DrawingCallback ();
 
-  void start_glyph();
-  void finish_glyph();
-  void set_glyph_offset(double offset_x, double offset_y);
-  void add_glyph_advance(double advance_x, double advance_y);
-  std::vector<std::shared_ptr<const Polygon2d>> get_result();
+  void start_glyph ();
+  void finish_glyph ();
+  void set_glyph_offset (double offset_x, double offset_y);
+  void add_glyph_advance (double advance_x, double advance_y);
+  std::vector<std::shared_ptr<const Polygon2d>> get_result ();
+
+  void move_to (const Vector2d &to);
+  void line_to (const Vector2d &to);
+  void curve_to (const Vector2d &c1, const Vector2d &to);
+  void curve_to (const Vector2d &c1, const Vector2d &c2, const Vector2d &to);
 
-  void move_to(const Vector2d& to);
-  void line_to(const Vector2d& to);
-  void curve_to(const Vector2d& c1, const Vector2d& to);
-  void curve_to(const Vector2d& c1, const Vector2d& c2, const Vector2d& to);
 private:
   Vector2d pen;
   Vector2d offset;
@@ -62,5 +63,5 @@ private:
   std::shared_ptr<Polygon2d> polygon;
   std::vector<std::shared_ptr<const Polygon2d>> polygons;
 
-  void add_vertex(const Vector2d& v);
+  void add_vertex (const Vector2d &v);
 };
diff --git a/src/core/EvaluationSession.cc b/src/core/EvaluationSession.cc
index aa5c96fc7..3aef12209 100644
--- a/src/core/EvaluationSession.cc
+++ b/src/core/EvaluationSession.cc
@@ -34,29 +34,25 @@
 #include "core/ContextFrame.h"
 #include "utils/printutils.h"
 
-size_t EvaluationSession::push_frame(ContextFrame *frame)
-{
-  size_t index = stack.size();
-  stack.push_back(frame);
+size_t EvaluationSession::push_frame (ContextFrame *frame) {
+  size_t index = stack.size ();
+  stack.push_back (frame);
   return index;
 }
 
-void EvaluationSession::replace_frame(size_t index, ContextFrame *frame)
-{
-  assert(index < stack.size());
+void EvaluationSession::replace_frame (size_t index, ContextFrame *frame) {
+  assert (index < stack.size ());
   stack[index] = frame;
 }
 
-void EvaluationSession::pop_frame(size_t index)
-{
-  stack.pop_back();
-  assert(stack.size() == index);
+void EvaluationSession::pop_frame (size_t index) {
+  stack.pop_back ();
+  assert (stack.size () == index);
 }
 
-boost::optional<const Value&> EvaluationSession::try_lookup_special_variable(const std::string& name) const
-{
-  for (auto it = stack.crbegin(); it != stack.crend(); ++it) {
-    boost::optional<const Value&> result = (*it)->lookup_local_variable(name);
+boost::optional<const Value &> EvaluationSession::try_lookup_special_variable (const std::string &name) const {
+  for (auto it = stack.crbegin (); it != stack.crend (); ++it) {
+    boost::optional<const Value &> result = (*it)->lookup_local_variable (name);
     if (result) {
       return result;
     }
@@ -64,36 +60,33 @@ boost::optional<const Value&> EvaluationSession::try_lookup_special_variable(con
   return boost::none;
 }
 
-const Value& EvaluationSession::lookup_special_variable(const std::string& name, const Location& loc) const
-{
-  boost::optional<const Value&> result = try_lookup_special_variable(name);
+const Value &EvaluationSession::lookup_special_variable (const std::string &name, const Location &loc) const {
+  boost::optional<const Value &> result = try_lookup_special_variable (name);
   if (!result) {
-    LOG(message_group::Warning, loc, documentRoot(), "Ignoring unknown variable %1$s", quoteVar(name));
+    LOG (message_group::Warning, loc, documentRoot (), "Ignoring unknown variable %1$s", quoteVar (name));
     return Value::undefined;
   }
   return *result;
 }
 
-boost::optional<CallableFunction> EvaluationSession::lookup_special_function(const std::string& name, const Location& loc) const
-{
-  for (auto it = stack.crbegin(); it != stack.crend(); ++it) {
-    boost::optional<CallableFunction> result = (*it)->lookup_local_function(name, loc);
+boost::optional<CallableFunction> EvaluationSession::lookup_special_function (const std::string &name, const Location &loc) const {
+  for (auto it = stack.crbegin (); it != stack.crend (); ++it) {
+    boost::optional<CallableFunction> result = (*it)->lookup_local_function (name, loc);
     if (result) {
       return result;
     }
   }
-  LOG(message_group::Warning, loc, documentRoot(), "Ignoring unknown function '%1$s'", name);
+  LOG (message_group::Warning, loc, documentRoot (), "Ignoring unknown function '%1$s'", name);
   return boost::none;
 }
 
-boost::optional<InstantiableModule> EvaluationSession::lookup_special_module(const std::string& name, const Location& loc) const
-{
-  for (auto it = stack.crbegin(); it != stack.crend(); ++it) {
-    boost::optional<InstantiableModule> result = (*it)->lookup_local_module(name, loc);
+boost::optional<InstantiableModule> EvaluationSession::lookup_special_module (const std::string &name, const Location &loc) const {
+  for (auto it = stack.crbegin (); it != stack.crend (); ++it) {
+    boost::optional<InstantiableModule> result = (*it)->lookup_local_module (name, loc);
     if (result) {
       return result;
     }
   }
-  LOG(message_group::Warning, loc, documentRoot(), "Ignoring unknown module '%1$s'", name);
+  LOG (message_group::Warning, loc, documentRoot (), "Ignoring unknown module '%1$s'", name);
   return boost::none;
 }
diff --git a/src/core/EvaluationSession.h b/src/core/EvaluationSession.h
index b83b4a7b1..868c89681 100644
--- a/src/core/EvaluationSession.h
+++ b/src/core/EvaluationSession.h
@@ -17,22 +17,27 @@ class ContextFrame;
 class EvaluationSession
 {
 public:
-  EvaluationSession(std::string documentRoot) :
-    document_root(std::move(documentRoot))
-  {}
-
-  size_t push_frame(ContextFrame *frame);
-  void replace_frame(size_t index, ContextFrame *frame);
-  void pop_frame(size_t index);
-
-  [[nodiscard]] boost::optional<const Value&> try_lookup_special_variable(const std::string& name) const;
-  [[nodiscard]] const Value& lookup_special_variable(const std::string& name, const Location& loc) const;
-  [[nodiscard]] boost::optional<CallableFunction> lookup_special_function(const std::string& name, const Location& loc) const;
-  [[nodiscard]] boost::optional<InstantiableModule> lookup_special_module(const std::string& name, const Location& loc) const;
-
-  [[nodiscard]] const std::string& documentRoot() const { return document_root; }
-  ContextMemoryManager& contextMemoryManager() { return context_memory_manager; }
-  HeapSizeAccounting& accounting() { return context_memory_manager.accounting(); }
+  EvaluationSession (std::string documentRoot)
+    : document_root (std::move (documentRoot)) {}
+
+  size_t push_frame (ContextFrame *frame);
+  void replace_frame (size_t index, ContextFrame *frame);
+  void pop_frame (size_t index);
+
+  [[nodiscard]] boost::optional<const Value &> try_lookup_special_variable (const std::string &name) const;
+  [[nodiscard]] const Value &lookup_special_variable (const std::string &name, const Location &loc) const;
+  [[nodiscard]] boost::optional<CallableFunction> lookup_special_function (const std::string &name, const Location &loc) const;
+  [[nodiscard]] boost::optional<InstantiableModule> lookup_special_module (const std::string &name, const Location &loc) const;
+
+  [[nodiscard]] const std::string &documentRoot () const {
+    return document_root;
+  }
+  ContextMemoryManager &contextMemoryManager () {
+    return context_memory_manager;
+  }
+  HeapSizeAccounting &accounting () {
+    return context_memory_manager.accounting ();
+  }
 
 private:
   std::string document_root;
diff --git a/src/core/Expression.cc b/src/core/Expression.cc
index 67f97dc6d..b301ced57 100644
--- a/src/core/Expression.cc
+++ b/src/core/Expression.cc
@@ -51,187 +51,209 @@
 #include <boost/assign/std/vector.hpp>
 using namespace boost::assign; // bring 'operator+=()' into scope
 
-Value Expression::checkUndef(Value&& val, const std::shared_ptr<const Context>& context) const {
-  if (val.isUncheckedUndef()) LOG(message_group::Warning, loc, context->documentRoot(), "%1$s", val.toUndefString());
-  return std::move(val);
+Value Expression::checkUndef (Value &&val, const std::shared_ptr<const Context> &context) const {
+  if (val.isUncheckedUndef ())
+    LOG (message_group::Warning, loc, context->documentRoot (), "%1$s", val.toUndefString ());
+  return std::move (val);
 }
 
-bool Expression::isLiteral() const
-{
+bool Expression::isLiteral () const {
   return false;
 }
 
-UnaryOp::UnaryOp(UnaryOp::Op op, Expression *expr, const Location& loc) : Expression(loc), op(op), expr(expr)
-{
+UnaryOp::UnaryOp (UnaryOp::Op op, Expression *expr, const Location &loc)
+  : Expression (loc)
+  , op (op)
+  , expr (expr) {
 }
 
-Value UnaryOp::evaluate(const std::shared_ptr<const Context>& context) const
-{
+Value UnaryOp::evaluate (const std::shared_ptr<const Context> &context) const {
   switch (this->op) {
-  case (Op::Not):    return !this->expr->evaluate(context).toBool();
-  case (Op::Negate): return checkUndef(-this->expr->evaluate(context), context);
-  case (Op::BinaryNot): return checkUndef(~this->expr->evaluate(context), context);
+  case (Op::Not):
+    return !this->expr->evaluate (context).toBool ();
+  case (Op::Negate):
+    return checkUndef (-this->expr->evaluate (context), context);
+  case (Op::BinaryNot):
+    return checkUndef (~this->expr->evaluate (context), context);
   default:
-    assert(false && "Non-existent unary operator!");
-    throw EvaluationException("Non-existent unary operator!");
+    assert (false && "Non-existent unary operator!");
+    throw EvaluationException ("Non-existent unary operator!");
   }
 }
 
-const char *UnaryOp::opString() const
-{
+const char *UnaryOp::opString () const {
   switch (this->op) {
-  case Op::Not:    return "!";
-  case Op::Negate: return "-";
-  case Op::BinaryNot: return "~";
+  case Op::Not:
+    return "!";
+  case Op::Negate:
+    return "-";
+  case Op::BinaryNot:
+    return "~";
   default:
-    assert(false && "Non-existent unary operator!");
-    throw EvaluationException("Non-existent unary operator!");
+    assert (false && "Non-existent unary operator!");
+    throw EvaluationException ("Non-existent unary operator!");
   }
 }
 
-bool UnaryOp::isLiteral() const {
-  return this->expr->isLiteral();
+bool UnaryOp::isLiteral () const {
+  return this->expr->isLiteral ();
 }
 
-void UnaryOp::print(std::ostream& stream, const std::string&) const
-{
-  stream << opString() << *this->expr;
+void UnaryOp::print (std::ostream &stream, const std::string &) const {
+  stream << opString () << *this->expr;
 }
 
-BinaryOp::BinaryOp(Expression *left, BinaryOp::Op op, Expression *right, const Location& loc) :
-  Expression(loc), op(op), left(left), right(right)
-{
+BinaryOp::BinaryOp (Expression *left, BinaryOp::Op op, Expression *right, const Location &loc)
+  : Expression (loc)
+  , op (op)
+  , left (left)
+  , right (right) {
 }
 
-Value BinaryOp::evaluate(const std::shared_ptr<const Context>& context) const
-{
+Value BinaryOp::evaluate (const std::shared_ptr<const Context> &context) const {
   switch (this->op) {
   case Op::LogicalAnd:
-    return this->left->evaluate(context).toBool() && this->right->evaluate(context).toBool();
+    return this->left->evaluate (context).toBool () && this->right->evaluate (context).toBool ();
   case Op::LogicalOr:
-    return this->left->evaluate(context).toBool() || this->right->evaluate(context).toBool();
+    return this->left->evaluate (context).toBool () || this->right->evaluate (context).toBool ();
   case Op::Exponent:
-    return checkUndef(this->left->evaluate(context) ^ this->right->evaluate(context), context);
+    return checkUndef (this->left->evaluate (context) ^ this->right->evaluate (context), context);
   case Op::Multiply:
-    return checkUndef(this->left->evaluate(context) * this->right->evaluate(context), context);
+    return checkUndef (this->left->evaluate (context) * this->right->evaluate (context), context);
   case Op::Divide:
-    return checkUndef(this->left->evaluate(context) / this->right->evaluate(context), context);
+    return checkUndef (this->left->evaluate (context) / this->right->evaluate (context), context);
   case Op::Modulo:
-    return checkUndef(this->left->evaluate(context) % this->right->evaluate(context), context);
+    return checkUndef (this->left->evaluate (context) % this->right->evaluate (context), context);
   case Op::Plus:
-    return checkUndef(this->left->evaluate(context) + this->right->evaluate(context), context);
+    return checkUndef (this->left->evaluate (context) + this->right->evaluate (context), context);
   case Op::Minus:
-    return checkUndef(this->left->evaluate(context) - this->right->evaluate(context), context);
+    return checkUndef (this->left->evaluate (context) - this->right->evaluate (context), context);
   case Op::ShiftLeft:
-    return checkUndef(this->left->evaluate(context) << this->right->evaluate(context), context);
+    return checkUndef (this->left->evaluate (context) << this->right->evaluate (context), context);
   case Op::ShiftRight:
-    return checkUndef(this->left->evaluate(context) >> this->right->evaluate(context), context);
+    return checkUndef (this->left->evaluate (context) >> this->right->evaluate (context), context);
   case Op::BinaryAnd:
-    return checkUndef(this->left->evaluate(context) & this->right->evaluate(context), context);
+    return checkUndef (this->left->evaluate (context) & this->right->evaluate (context), context);
   case Op::BinaryOr:
-    return checkUndef(this->left->evaluate(context) | this->right->evaluate(context), context);
+    return checkUndef (this->left->evaluate (context) | this->right->evaluate (context), context);
   case Op::Less:
-    return checkUndef(this->left->evaluate(context) < this->right->evaluate(context), context);
+    return checkUndef (this->left->evaluate (context) < this->right->evaluate (context), context);
   case Op::LessEqual:
-    return checkUndef(this->left->evaluate(context) <= this->right->evaluate(context), context);
+    return checkUndef (this->left->evaluate (context) <= this->right->evaluate (context), context);
   case Op::Greater:
-    return checkUndef(this->left->evaluate(context) > this->right->evaluate(context), context);
+    return checkUndef (this->left->evaluate (context) > this->right->evaluate (context), context);
   case Op::GreaterEqual:
-    return checkUndef(this->left->evaluate(context) >= this->right->evaluate(context), context);
+    return checkUndef (this->left->evaluate (context) >= this->right->evaluate (context), context);
   case Op::Equal:
-    return checkUndef(this->left->evaluate(context) == this->right->evaluate(context), context);
+    return checkUndef (this->left->evaluate (context) == this->right->evaluate (context), context);
   case Op::NotEqual:
-    return checkUndef(this->left->evaluate(context) != this->right->evaluate(context), context);
+    return checkUndef (this->left->evaluate (context) != this->right->evaluate (context), context);
   default:
-    assert(false && "Non-existent binary operator!");
-    throw EvaluationException("Non-existent binary operator!");
+    assert (false && "Non-existent binary operator!");
+    throw EvaluationException ("Non-existent binary operator!");
   }
 }
 
-const char *BinaryOp::opString() const
-{
+const char *BinaryOp::opString () const {
   switch (this->op) {
-  case Op::LogicalAnd:   return "&&";
-  case Op::LogicalOr:    return "||";
-  case Op::Exponent:     return "^";
-  case Op::Multiply:     return "*";
-  case Op::Divide:       return "/";
-  case Op::Modulo:       return "%";
-  case Op::Plus:         return "+";
-  case Op::Minus:        return "-";
-  case Op::Less:         return "<";
-  case Op::LessEqual:    return "<=";
-  case Op::Greater:      return ">";
-  case Op::GreaterEqual: return ">=";
-  case Op::Equal:        return "==";
-  case Op::NotEqual:     return "!=";
-  case Op::BinaryOr:     return "|";
-  case Op::BinaryAnd:     return "&";
-  case Op::ShiftLeft:     return "<<";
-  case Op::ShiftRight:     return ">>";
+  case Op::LogicalAnd:
+    return "&&";
+  case Op::LogicalOr:
+    return "||";
+  case Op::Exponent:
+    return "^";
+  case Op::Multiply:
+    return "*";
+  case Op::Divide:
+    return "/";
+  case Op::Modulo:
+    return "%";
+  case Op::Plus:
+    return "+";
+  case Op::Minus:
+    return "-";
+  case Op::Less:
+    return "<";
+  case Op::LessEqual:
+    return "<=";
+  case Op::Greater:
+    return ">";
+  case Op::GreaterEqual:
+    return ">=";
+  case Op::Equal:
+    return "==";
+  case Op::NotEqual:
+    return "!=";
+  case Op::BinaryOr:
+    return "|";
+  case Op::BinaryAnd:
+    return "&";
+  case Op::ShiftLeft:
+    return "<<";
+  case Op::ShiftRight:
+    return ">>";
   default:
-    assert(false && "Non-existent binary operator!");
-    throw EvaluationException("Non-existent binary operator!");
+    assert (false && "Non-existent binary operator!");
+    throw EvaluationException ("Non-existent binary operator!");
   }
 }
 
-void BinaryOp::print(std::ostream& stream, const std::string&) const
-{
-  stream << "(" << *this->left << " " << opString() << " " << *this->right << ")";
+void BinaryOp::print (std::ostream &stream, const std::string &) const {
+  stream << "(" << *this->left << " " << opString () << " " << *this->right << ")";
 }
 
-TernaryOp::TernaryOp(Expression *cond, Expression *ifexpr, Expression *elseexpr, const Location& loc)
-  : Expression(loc), cond(cond), ifexpr(ifexpr), elseexpr(elseexpr)
-{
+TernaryOp::TernaryOp (Expression *cond, Expression *ifexpr, Expression *elseexpr, const Location &loc)
+  : Expression (loc)
+  , cond (cond)
+  , ifexpr (ifexpr)
+  , elseexpr (elseexpr) {
 }
 
-const Expression *TernaryOp::evaluateStep(const std::shared_ptr<const Context>& context) const
-{
-  return this->cond->evaluate(context).toBool() ? this->ifexpr.get() : this->elseexpr.get();
+const Expression *TernaryOp::evaluateStep (const std::shared_ptr<const Context> &context) const {
+  return this->cond->evaluate (context).toBool () ? this->ifexpr.get () : this->elseexpr.get ();
 }
 
-Value TernaryOp::evaluate(const std::shared_ptr<const Context>& context) const
-{
-  return evaluateStep(context)->evaluate(context);
+Value TernaryOp::evaluate (const std::shared_ptr<const Context> &context) const {
+  return evaluateStep (context)->evaluate (context);
 }
 
-void TernaryOp::print(std::ostream& stream, const std::string&) const
-{
+void TernaryOp::print (std::ostream &stream, const std::string &) const {
   stream << "(" << *this->cond << " ? " << *this->ifexpr << " : " << *this->elseexpr << ")";
 }
 
-ArrayLookup::ArrayLookup(Expression *array, Expression *index, const Location& loc)
-  : Expression(loc), array(array), index(index)
-{
+ArrayLookup::ArrayLookup (Expression *array, Expression *index, const Location &loc)
+  : Expression (loc)
+  , array (array)
+  , index (index) {
 }
 
-Value ArrayLookup::evaluate(const std::shared_ptr<const Context>& context) const {
-  return this->array->evaluate(context)[this->index->evaluate(context)];
+Value ArrayLookup::evaluate (const std::shared_ptr<const Context> &context) const {
+  return this->array->evaluate (context)[this->index->evaluate (context)];
 }
 
-void ArrayLookup::print(std::ostream& stream, const std::string&) const
-{
+void ArrayLookup::print (std::ostream &stream, const std::string &) const {
   stream << *array << "[" << *index << "]";
 }
 
-Value Literal::evaluate(const std::shared_ptr<const Context>&) const
-{
-  return value.clone();
+Value Literal::evaluate (const std::shared_ptr<const Context> &) const {
+  return value.clone ();
 }
 
-void Literal::print(std::ostream& stream, const std::string&) const
-{
+void Literal::print (std::ostream &stream, const std::string &) const {
   stream << value;
 }
 
-Range::Range(Expression *begin, Expression *end, const Location& loc)
-  : Expression(loc), begin(begin), end(end)
-{
+Range::Range (Expression *begin, Expression *end, const Location &loc)
+  : Expression (loc)
+  , begin (begin)
+  , end (end) {
 }
 
-Range::Range(Expression *begin, Expression *step, Expression *end, const Location& loc)
-  : Expression(loc), begin(begin), step(step), end(end)
-{
+Range::Range (Expression *begin, Expression *step, Expression *end, const Location &loc)
+  : Expression (loc)
+  , begin (begin)
+  , step (step)
+  , end (end) {
 }
 
 /**
@@ -241,57 +263,54 @@ Range::Range(Expression *begin, Expression *step, Expression *end, const Locatio
  * noinline is required, as we here specifically optimize for stack usage
  * during normal operating, not runtime during error handling.
  */
-static void NOINLINE print_range_err(const std::string& begin, const std::string& step, const Location& loc, const std::shared_ptr<const Context>& context){
-  LOG(message_group::Warning, loc, context->documentRoot(), "begin %1$s than the end, but step %2$s", begin, step);
+static void NOINLINE print_range_err (const std::string &begin, const std::string &step, const Location &loc, const std::shared_ptr<const Context> &context) {
+  LOG (message_group::Warning, loc, context->documentRoot (), "begin %1$s than the end, but step %2$s", begin, step);
 }
 
-Value Range::evaluate(const std::shared_ptr<const Context>& context) const
-{
+Value Range::evaluate (const std::shared_ptr<const Context> &context) const {
   double begin_val;
   double end_val;
-  if (!this->begin->evaluate(context).getDouble(begin_val)
-      || !this->end->evaluate(context).getDouble(end_val)) {
-    return Value::undefined.clone();
+  if (!this->begin->evaluate (context).getDouble (begin_val) || !this->end->evaluate (context).getDouble (end_val)) {
+    return Value::undefined.clone ();
   }
 
   double step_val = 1.0;
   if (this->step) {
-    if (!this->step->evaluate(context).getDouble(step_val)) {
-      return Value::undefined.clone();
+    if (!this->step->evaluate (context).getDouble (step_val)) {
+      return Value::undefined.clone ();
     }
   }
-  if (this->isLiteral()) {
+  if (this->isLiteral ()) {
     if ((step_val > 0) && (end_val < begin_val)) {
-      print_range_err("is greater", "is positive", loc, context);
+      print_range_err ("is greater", "is positive", loc, context);
     } else if ((step_val < 0) && (end_val > begin_val)) {
-      print_range_err("is smaller", "is negative", loc, context);
+      print_range_err ("is smaller", "is negative", loc, context);
     }
   }
-  return RangeType(begin_val, step_val, end_val);
+  return RangeType (begin_val, step_val, end_val);
 }
 
-void Range::print(std::ostream& stream, const std::string&) const
-{
+void Range::print (std::ostream &stream, const std::string &) const {
   stream << "[" << *this->begin;
-  if (this->step) stream << " : " << *this->step;
+  if (this->step)
+    stream << " : " << *this->step;
   stream << " : " << *this->end;
   stream << "]";
 }
 
-bool Range::isLiteral() const {
-  return this->step ?
-         begin->isLiteral() && end->isLiteral() && step->isLiteral() :
-         begin->isLiteral() && end->isLiteral();
+bool Range::isLiteral () const {
+  return this->step ? begin->isLiteral () && end->isLiteral () && step->isLiteral () : begin->isLiteral () && end->isLiteral ();
 }
 
-Vector::Vector(const Location& loc) : Expression(loc), literal_flag(unknown)
-{
+Vector::Vector (const Location &loc)
+  : Expression (loc)
+  , literal_flag (unknown) {
 }
 
-bool Vector::isLiteral() const {
-  if (unknown(literal_flag)) {
-    for (const auto& e : this->children) {
-      if (!e->isLiteral()) {
+bool Vector::isLiteral () const {
+  if (unknown (literal_flag)) {
+    for (const auto &e : this->children) {
+      if (!e->isLiteral ()) {
         literal_flag = false;
         return false;
       }
@@ -299,128 +318,148 @@ bool Vector::isLiteral() const {
     literal_flag = true;
     return true;
   } else {
-    return bool(literal_flag);
+    return bool (literal_flag);
   }
 }
 
-void Vector::emplace_back(Expression *expr)
-{
-  this->children.emplace_back(expr);
+void Vector::emplace_back (Expression *expr) {
+  this->children.emplace_back (expr);
 }
 
-Value Vector::evaluate(const std::shared_ptr<const Context>& context) const
-{
-  if (children.size() == 1) {
-    Value val = children.front()->evaluate(context);
+Value Vector::evaluate (const std::shared_ptr<const Context> &context) const {
+  if (children.size () == 1) {
+    Value val = children.front ()->evaluate (context);
     // If only 1 EmbeddedVectorType, convert to plain VectorType
-    if (val.type() == Value::Type::EMBEDDED_VECTOR) {
-      return VectorType(std::move(val.toEmbeddedVectorNonConst()));
+    if (val.type () == Value::Type::EMBEDDED_VECTOR) {
+      return VectorType (std::move (val.toEmbeddedVectorNonConst ()));
     } else {
-      VectorType vec(context->session());
-      vec.emplace_back(std::move(val));
-      return std::move(vec);
+      VectorType vec (context->session ());
+      vec.emplace_back (std::move (val));
+      return std::move (vec);
     }
   } else {
-    VectorType vec(context->session());
-    vec.reserve(this->children.size());
-    for (const auto& e : this->children) vec.emplace_back(e->evaluate(context));
-    return std::move(vec);
+    VectorType vec (context->session ());
+    vec.reserve (this->children.size ());
+    for (const auto &e : this->children)
+      vec.emplace_back (e->evaluate (context));
+    return std::move (vec);
   }
 }
 
-void Vector::print(std::ostream& stream, const std::string&) const
-{
+void Vector::print (std::ostream &stream, const std::string &) const {
   stream << "[";
-  for (size_t i = 0; i < this->children.size(); ++i) {
-    if (i > 0) stream << ", ";
+  for (size_t i = 0; i < this->children.size (); ++i) {
+    if (i > 0)
+      stream << ", ";
     stream << *this->children[i];
   }
   stream << "]";
 }
 
-Lookup::Lookup(std::string name, const Location& loc) : Expression(loc), name(std::move(name))
-{
+Lookup::Lookup (std::string name, const Location &loc)
+  : Expression (loc)
+  , name (std::move (name)) {
 }
 
-Value Lookup::evaluate(const std::shared_ptr<const Context>& context) const
-{
-  return context->lookup_variable(this->name, loc).clone();
+Value Lookup::evaluate (const std::shared_ptr<const Context> &context) const {
+  return context->lookup_variable (this->name, loc).clone ();
 }
 
-void Lookup::print(std::ostream& stream, const std::string&) const
-{
+void Lookup::print (std::ostream &stream, const std::string &) const {
   stream << this->name;
 }
 
-MemberLookup::MemberLookup(Expression *expr, std::string member, const Location& loc)
-  : Expression(loc), expr(expr), member(std::move(member))
-{
+MemberLookup::MemberLookup (Expression *expr, std::string member, const Location &loc)
+  : Expression (loc)
+  , expr (expr)
+  , member (std::move (member)) {
 }
 
-Value MemberLookup::evaluate(const std::shared_ptr<const Context>& context) const
-{
-  const Value& v = this->expr->evaluate(context);
-  static const boost::regex re_swizzle_validation("^([xyzw]{1,4}|[rgba]{1,4})$");
+Value MemberLookup::evaluate (const std::shared_ptr<const Context> &context) const {
+  const Value &v = this->expr->evaluate (context);
+  static const boost::regex re_swizzle_validation ("^([xyzw]{1,4}|[rgba]{1,4})$");
 
-  switch (v.type()) {
+  switch (v.type ()) {
   case Value::Type::VECTOR:
-    if (this->member.length() > 1 && boost::regex_match(this->member, re_swizzle_validation)) {
-      VectorType ret(context->session());
-      ret.reserve(this->member.length());
-      for (const char& ch : this->member)
+    if (this->member.length () > 1 && boost::regex_match (this->member, re_swizzle_validation)) {
+      VectorType ret (context->session ());
+      ret.reserve (this->member.length ());
+      for (const char &ch : this->member)
         switch (ch) {
-        case 'r': case 'x': ret.emplace_back(v[0]); break;
-        case 'g': case 'y': ret.emplace_back(v[1]); break;
-        case 'b': case 'z': ret.emplace_back(v[2]); break;
-        case 'a': case 'w': ret.emplace_back(v[3]); break;
+        case 'r':
+        case 'x':
+          ret.emplace_back (v[0]);
+          break;
+        case 'g':
+        case 'y':
+          ret.emplace_back (v[1]);
+          break;
+        case 'b':
+        case 'z':
+          ret.emplace_back (v[2]);
+          break;
+        case 'a':
+        case 'w':
+          ret.emplace_back (v[3]);
+          break;
         }
-      return {std::move(ret)};
+      return {std::move (ret)};
     }
-    if (this->member == "x") return v[0];
-    if (this->member == "y") return v[1];
-    if (this->member == "z") return v[2];
-    if (this->member == "w") return v[3];
-    if (this->member == "r") return v[0];
-    if (this->member == "g") return v[1];
-    if (this->member == "b") return v[2];
-    if (this->member == "a") return v[3];
+    if (this->member == "x")
+      return v[0];
+    if (this->member == "y")
+      return v[1];
+    if (this->member == "z")
+      return v[2];
+    if (this->member == "w")
+      return v[3];
+    if (this->member == "r")
+      return v[0];
+    if (this->member == "g")
+      return v[1];
+    if (this->member == "b")
+      return v[2];
+    if (this->member == "a")
+      return v[3];
     break;
   case Value::Type::RANGE:
-    if (this->member == "begin") return v[0];
-    if (this->member == "step") return v[1];
-    if (this->member == "end") return v[2];
+    if (this->member == "begin")
+      return v[0];
+    if (this->member == "step")
+      return v[1];
+    if (this->member == "end")
+      return v[2];
     break;
   case Value::Type::OBJECT:
     return v[this->member];
   default:
     break;
   }
-  return Value::undefined.clone();
+  return Value::undefined.clone ();
 }
 
-void MemberLookup::print(std::ostream& stream, const std::string&) const
-{
+void MemberLookup::print (std::ostream &stream, const std::string &) const {
   stream << *this->expr << "." << this->member;
 }
 
-FunctionDefinition::FunctionDefinition(Expression *expr, AssignmentList parameters, const Location& loc)
-  : Expression(loc), context(nullptr), parameters(std::move(parameters)), expr(expr)
-{
+FunctionDefinition::FunctionDefinition (Expression *expr, AssignmentList parameters, const Location &loc)
+  : Expression (loc)
+  , context (nullptr)
+  , parameters (std::move (parameters))
+  , expr (expr) {
 }
 
-Value FunctionDefinition::evaluate(const std::shared_ptr<const Context>& context) const
-{
-  return FunctionPtr{FunctionType{context, expr, std::make_unique<AssignmentList>(parameters)}};
+Value FunctionDefinition::evaluate (const std::shared_ptr<const Context> &context) const {
+  return FunctionPtr{FunctionType{context, expr, std::make_unique<AssignmentList> (parameters)}};
 }
 
-void FunctionDefinition::print(std::ostream& stream, const std::string& indent) const
-{
+void FunctionDefinition::print (std::ostream &stream, const std::string &indent) const {
   stream << indent << "function(";
   bool first = true;
-  for (const auto& parameter : parameters) {
-    stream << (first ? "" : ", ") << parameter->getName();
-    if (parameter->getExpr()) {
-      stream << " = " << *parameter->getExpr();
+  for (const auto &parameter : parameters) {
+    stream << (first ? "" : ", ") << parameter->getName ();
+    if (parameter->getExpr ()) {
+      stream << " = " << *parameter->getExpr ();
     }
     first = false;
   }
@@ -434,8 +473,8 @@ void FunctionDefinition::print(std::ostream& stream, const std::string& indent)
  * noinline is required, as we here specifically optimize for stack usage
  * during normal operating, not runtime during error handling.
  */
-static void NOINLINE print_err(const char *name, const Location& loc, const std::shared_ptr<const Context>& context){
-  LOG(message_group::Error, loc, context->documentRoot(), "Recursion detected calling function '%1$s'", name);
+static void NOINLINE print_err (const char *name, const Location &loc, const std::shared_ptr<const Context> &context) {
+  LOG (message_group::Error, loc, context->documentRoot (), "Recursion detected calling function '%1$s'", name);
 }
 
 /**
@@ -445,37 +484,37 @@ static void NOINLINE print_err(const char *name, const Location& loc, const std:
  * noinline is required, as we here specifically optimize for stack usage
  * during normal operating, not runtime during error handling.
  */
-static void NOINLINE print_trace(const FunctionCall *val, const std::shared_ptr<const Context>& context){
-  LOG(message_group::Trace, val->location(), context->documentRoot(), "called by '%1$s'", val->get_name());
+static void NOINLINE print_trace (const FunctionCall *val, const std::shared_ptr<const Context> &context) {
+  LOG (message_group::Trace, val->location (), context->documentRoot (), "called by '%1$s'", val->get_name ());
 }
 
-FunctionCall::FunctionCall(Expression *expr, AssignmentList args, const Location& loc)
-  : Expression(loc), expr(expr), arguments(std::move(args))
-{
-  if (typeid(*expr) == typeid(Lookup)) {
+FunctionCall::FunctionCall (Expression *expr, AssignmentList args, const Location &loc)
+  : Expression (loc)
+  , expr (expr)
+  , arguments (std::move (args)) {
+  if (typeid (*expr) == typeid (Lookup)) {
     isLookup = true;
-    const Lookup *lookup = static_cast<Lookup *>(expr);
-    name = lookup->get_name();
+    const Lookup *lookup = static_cast<Lookup *> (expr);
+    name = lookup->get_name ();
   } else {
     isLookup = false;
     std::ostringstream s;
     s << "(";
-    expr->print(s, "");
+    expr->print (s, "");
     s << ")";
-    name = s.str();
+    name = s.str ();
   }
 }
 
-boost::optional<CallableFunction> FunctionCall::evaluate_function_expression(const std::shared_ptr<const Context>& context) const
-{
+boost::optional<CallableFunction> FunctionCall::evaluate_function_expression (const std::shared_ptr<const Context> &context) const {
   if (isLookup) {
-    return context->lookup_function(name, location());
+    return context->lookup_function (name, location ());
   } else {
-    auto v = expr->evaluate(context);
-    if (v.type() == Value::Type::FUNCTION) {
-      return CallableFunction{std::move(v)};
+    auto v = expr->evaluate (context);
+    if (v.type () == Value::Type::FUNCTION) {
+      return CallableFunction{std::move (v)};
     } else {
-      LOG(message_group::Warning, loc, context->documentRoot(), "Can't call function on %1$s", v.typeName());
+      LOG (message_group::Warning, loc, context->documentRoot (), "Can't call function on %1$s", v.typeName ());
       return boost::none;
     }
   }
@@ -488,78 +527,76 @@ struct SimplifiedExpression {
 };
 using SimplificationResult = std::variant<SimplifiedExpression, Value>;
 
-static SimplificationResult simplify_function_body(const Expression *expression, const std::shared_ptr<const Context>& context)
-{
+static SimplificationResult simplify_function_body (const Expression *expression, const std::shared_ptr<const Context> &context) {
   if (!expression) {
-    return Value::undefined.clone();
+    return Value::undefined.clone ();
   } else {
-    const auto& type = typeid(*expression);
-    if (type == typeid(TernaryOp)) {
-      const auto *ternary = static_cast<const TernaryOp *>(expression);
-      return SimplifiedExpression{ternary->evaluateStep(context)};
-    } else if (type == typeid(Assert)) {
-      const auto *assertion = static_cast<const Assert *>(expression);
-      return SimplifiedExpression{assertion->evaluateStep(context)};
-    } else if (type == typeid(Echo)) {
-      const Echo *echo = static_cast<const Echo *>(expression);
-      return SimplifiedExpression{echo->evaluateStep(context)};
-    } else if (type == typeid(Let)) {
-      const Let *let = static_cast<const Let *>(expression);
-      ContextHandle<Context> let_context{Context::create<Context>(context)};
-      let_context->apply_config_variables(*context);
-      return SimplifiedExpression{let->evaluateStep(let_context), std::move(let_context)};
-    } else if (type == typeid(FunctionCall)) {
-      const auto *call = static_cast<const FunctionCall *>(expression);
+    const auto &type = typeid (*expression);
+    if (type == typeid (TernaryOp)) {
+      const auto *ternary = static_cast<const TernaryOp *> (expression);
+      return SimplifiedExpression{ternary->evaluateStep (context)};
+    } else if (type == typeid (Assert)) {
+      const auto *assertion = static_cast<const Assert *> (expression);
+      return SimplifiedExpression{assertion->evaluateStep (context)};
+    } else if (type == typeid (Echo)) {
+      const Echo *echo = static_cast<const Echo *> (expression);
+      return SimplifiedExpression{echo->evaluateStep (context)};
+    } else if (type == typeid (Let)) {
+      const Let *let = static_cast<const Let *> (expression);
+      ContextHandle<Context> let_context{Context::create<Context> (context)};
+      let_context->apply_config_variables (*context);
+      return SimplifiedExpression{let->evaluateStep (let_context), std::move (let_context)};
+    } else if (type == typeid (FunctionCall)) {
+      const auto *call = static_cast<const FunctionCall *> (expression);
 
       const Expression *function_body;
       const AssignmentList *required_parameters;
       std::shared_ptr<const Context> defining_context;
 
-      auto f = call->evaluate_function_expression(context);
+      auto f = call->evaluate_function_expression (context);
       if (!f) {
-        return Value::undefined.clone();
+        return Value::undefined.clone ();
       } else {
-        auto index = f->index();
+        auto index = f->index ();
         if (index == 0) {
-          return std::get<const BuiltinFunction *>(*f)->evaluate(context, call);
+          return std::get<const BuiltinFunction *> (*f)->evaluate (context, call);
         } else if (index == 1) {
-          CallableUserFunction callable = std::get<CallableUserFunction>(*f);
-          function_body = callable.function->expr.get();
+          CallableUserFunction callable = std::get<CallableUserFunction> (*f);
+          function_body = callable.function->expr.get ();
           required_parameters = &callable.function->parameters;
           defining_context = callable.defining_context;
         } else {
           const FunctionType *function;
           if (index == 2) {
-            function = &std::get<Value>(*f).toFunction();
+            function = &std::get<Value> (*f).toFunction ();
           } else if (index == 3) {
-            function = &std::get<const Value *>(*f)->toFunction();
+            function = &std::get<const Value *> (*f)->toFunction ();
           } else {
-            assert(false);
+            assert (false);
           }
-          function_body = function->getExpr().get();
-          required_parameters = function->getParameters().get();
-          defining_context = function->getContext();
+          function_body = function->getExpr ().get ();
+          required_parameters = function->getParameters ().get ();
+          defining_context = function->getContext ();
         }
       }
-      ContextHandle<Context> body_context{Context::create<Context>(defining_context)};
-      body_context->apply_config_variables(*context);
+      ContextHandle<Context> body_context{Context::create<Context> (defining_context)};
+      body_context->apply_config_variables (*context);
       Arguments arguments{call->arguments, context};
-      Parameters parameters = Parameters::parse(std::move(arguments), call->location(), *required_parameters, defining_context);
-      body_context->apply_variables(std::move(parameters).to_context_frame());
+      Parameters parameters = Parameters::parse (std::move (arguments), call->location (), *required_parameters, defining_context);
+      body_context->apply_variables (std::move (parameters).to_context_frame ());
 
-      return SimplifiedExpression{function_body, std::move(body_context), call};
+      return SimplifiedExpression{function_body, std::move (body_context), call};
     } else {
-      return expression->evaluate(context);
+      return expression->evaluate (context);
     }
   }
 }
 
-Value FunctionCall::evaluate(const std::shared_ptr<const Context>& context) const
-{
-  const auto& name = get_name();
-  if (StackCheck::inst().check()) {
-    print_err(name.c_str(), loc, context);
-    throw RecursionException::create("function", name, this->loc);
+Value FunctionCall::evaluate (const std::shared_ptr<const Context> &context) const {
+  const auto &name = get_name ();
+  if (StackCheck::inst ().check ()) {
+    print_err (name.c_str (), loc, context);
+    throw RecursionException::create ("function", name, this->loc);
   }
 
   // Repeatedly simplify expr until it reduces to either a tail call,
@@ -569,32 +606,32 @@ Value FunctionCall::evaluate(const std::shared_ptr<const Context>& context) cons
   unsigned int recursion_depth = 0;
   const FunctionCall *current_call = this;
 
-  ContextHandle<Context> expression_context{Context::create<Context>(context)};
+  ContextHandle<Context> expression_context{Context::create<Context> (context)};
   const Expression *expression = this;
   while (true) {
     try {
-      auto result = simplify_function_body(expression, *expression_context);
-      if (Value *value = std::get_if<Value>(&result)) {
-        return std::move(*value);
+      auto result = simplify_function_body (expression, *expression_context);
+      if (Value *value = std::get_if<Value> (&result)) {
+        return std::move (*value);
       }
 
-      SimplifiedExpression *simplified_expression = std::get_if<SimplifiedExpression>(&result);
-      assert(simplified_expression);
+      SimplifiedExpression *simplified_expression = std::get_if<SimplifiedExpression> (&result);
+      assert (simplified_expression);
 
       expression = simplified_expression->expression;
       if (simplified_expression->new_context) {
-        expression_context = std::move(*simplified_expression->new_context);
+        expression_context = std::move (*simplified_expression->new_context);
       }
       if (simplified_expression->new_active_function_call) {
         current_call = *simplified_expression->new_active_function_call;
         if (recursion_depth++ == 1000000) {
-          LOG(message_group::Error, expression->location(), expression_context->documentRoot(), "Recursion detected calling function '%1$s'", current_call->name);
-          throw RecursionException::create("function", current_call->name, current_call->location());
+          LOG (message_group::Error, expression->location (), expression_context->documentRoot (), "Recursion detected calling function '%1$s'", current_call->name);
+          throw RecursionException::create ("function", current_call->name, current_call->location ());
         }
       }
-    } catch (EvaluationException& e) {
+    } catch (EvaluationException &e) {
       if (e.traceDepth > 0) {
-        print_trace(current_call, *expression_context);
+        print_trace (current_call, *expression_context);
         e.traceDepth--;
       }
       throw;
@@ -602,341 +639,321 @@ Value FunctionCall::evaluate(const std::shared_ptr<const Context>& context) cons
   }
 }
 
-void FunctionCall::print(std::ostream& stream, const std::string&) const
-{
-  stream << this->get_name() << "(" << this->arguments << ")";
+void FunctionCall::print (std::ostream &stream, const std::string &) const {
+  stream << this->get_name () << "(" << this->arguments << ")";
 }
 
-Expression *FunctionCall::create(const std::string& funcname, const AssignmentList& arglist, Expression *expr, const Location& loc)
-{
+Expression *FunctionCall::create (const std::string &funcname, const AssignmentList &arglist, Expression *expr, const Location &loc) {
   if (funcname == "assert") {
-    return new Assert(arglist, expr, loc);
+    return new Assert (arglist, expr, loc);
   } else if (funcname == "echo") {
-    return new Echo(arglist, expr, loc);
+    return new Echo (arglist, expr, loc);
   } else if (funcname == "let") {
-    return new Let(arglist, expr, loc);
+    return new Let (arglist, expr, loc);
   }
   return nullptr;
   // TODO: Generate error/warning if expr != 0?
   //return new FunctionCall(funcname, arglist, loc);
 }
 
-Assert::Assert(AssignmentList args, Expression *expr, const Location& loc)
-  : Expression(loc), arguments(std::move(args)), expr(expr)
-{
-
+Assert::Assert (AssignmentList args, Expression *expr, const Location &loc)
+  : Expression (loc)
+  , arguments (std::move (args))
+  , expr (expr) {
 }
 
-void Assert::performAssert(const AssignmentList& arguments, const Location& location, const std::shared_ptr<const Context>& context)
-{
-  Parameters parameters = Parameters::parse(Arguments(arguments, context), location, {"condition"}, {"message"});
+void Assert::performAssert (const AssignmentList &arguments, const Location &location, const std::shared_ptr<const Context> &context) {
+  Parameters parameters = Parameters::parse (Arguments (arguments, context), location, {"condition"}, {"message"});
   const Expression *conditionExpression = nullptr;
-  for (const auto& argument : arguments) {
-    if (argument->getName() == "" || argument->getName() == "condition") {
-      conditionExpression = argument->getExpr().get();
+  for (const auto &argument : arguments) {
+    if (argument->getName () == "" || argument->getName () == "condition") {
+      conditionExpression = argument->getExpr ().get ();
       break;
     }
   }
 
-  if (!parameters["condition"].toBool()) {
-    std::string conditionString = conditionExpression ? STR(" '", *conditionExpression, "'") : "";
-    std::string messageString = parameters.contains("message") ? (": " + parameters["message"].toEchoStringNoThrow()) : "";
-    LOG(message_group::Error, location, context->documentRoot(), "Assertion%1$s failed%2$s", conditionString, messageString);
-    throw AssertionFailedException("Assertion Failed", location);
+  if (!parameters["condition"].toBool ()) {
+    std::string conditionString = conditionExpression ? STR (" '", *conditionExpression, "'") : "";
+    std::string messageString = parameters.contains ("message") ? (": " + parameters["message"].toEchoStringNoThrow ()) : "";
+    LOG (message_group::Error, location, context->documentRoot (), "Assertion%1$s failed%2$s", conditionString, messageString);
+    throw AssertionFailedException ("Assertion Failed", location);
   }
 }
 
-const Expression *Assert::evaluateStep(const std::shared_ptr<const Context>& context) const
-{
-  performAssert(this->arguments, this->loc, context);
-  return expr.get();
+const Expression *Assert::evaluateStep (const std::shared_ptr<const Context> &context) const {
+  performAssert (this->arguments, this->loc, context);
+  return expr.get ();
 }
 
-Value Assert::evaluate(const std::shared_ptr<const Context>& context) const
-{
-  const Expression *nextexpr = evaluateStep(context);
-  return nextexpr ? nextexpr->evaluate(context) : Value::undefined.clone();
+Value Assert::evaluate (const std::shared_ptr<const Context> &context) const {
+  const Expression *nextexpr = evaluateStep (context);
+  return nextexpr ? nextexpr->evaluate (context) : Value::undefined.clone ();
 }
 
-void Assert::print(std::ostream& stream, const std::string&) const
-{
+void Assert::print (std::ostream &stream, const std::string &) const {
   stream << "assert(" << this->arguments << ")";
-  if (this->expr) stream << " " << *this->expr;
+  if (this->expr)
+    stream << " " << *this->expr;
 }
 
-Echo::Echo(AssignmentList args, Expression *expr, const Location& loc)
-  : Expression(loc), arguments(std::move(args)), expr(expr)
-{
-
+Echo::Echo (AssignmentList args, Expression *expr, const Location &loc)
+  : Expression (loc)
+  , arguments (std::move (args))
+  , expr (expr) {
 }
 
-const Expression *Echo::evaluateStep(const std::shared_ptr<const Context>& context) const
-{
+const Expression *Echo::evaluateStep (const std::shared_ptr<const Context> &context) const {
   Arguments arguments{this->arguments, context};
-  LOG(message_group::Echo, "%1$s", STR(arguments));
-  return expr.get();
+  LOG (message_group::Echo, "%1$s", STR (arguments));
+  return expr.get ();
 }
 
-Value Echo::evaluate(const std::shared_ptr<const Context>& context) const
-{
-  const Expression *nextexpr = evaluateStep(context);
-  return nextexpr ? nextexpr->evaluate(context) : Value::undefined.clone();
+Value Echo::evaluate (const std::shared_ptr<const Context> &context) const {
+  const Expression *nextexpr = evaluateStep (context);
+  return nextexpr ? nextexpr->evaluate (context) : Value::undefined.clone ();
 }
 
-void Echo::print(std::ostream& stream, const std::string&) const
-{
+void Echo::print (std::ostream &stream, const std::string &) const {
   stream << "echo(" << this->arguments << ")";
-  if (this->expr) stream << " " << *this->expr;
+  if (this->expr)
+    stream << " " << *this->expr;
 }
 
-Let::Let(AssignmentList args, Expression *expr, const Location& loc)
-  : Expression(loc), arguments(std::move(args)), expr(expr)
-{
+Let::Let (AssignmentList args, Expression *expr, const Location &loc)
+  : Expression (loc)
+  , arguments (std::move (args))
+  , expr (expr) {
 }
 
-void Let::doSequentialAssignment(const AssignmentList& assignments, const Location& location, ContextHandle<Context>& targetContext)
-{
+void Let::doSequentialAssignment (const AssignmentList &assignments, const Location &location, ContextHandle<Context> &targetContext) {
   std::set<std::string> seen;
-  for (const auto& assignment : assignments) {
-    Value value = assignment->getExpr()->evaluate(*targetContext);
-    if (assignment->getName().empty()) {
-      LOG(message_group::Warning, location, targetContext->documentRoot(), "Assignment without variable name %1$s", value.toEchoStringNoThrow());
-    } else if (seen.find(assignment->getName()) != seen.end()) {
+  for (const auto &assignment : assignments) {
+    Value value = assignment->getExpr ()->evaluate (*targetContext);
+    if (assignment->getName ().empty ()) {
+      LOG (message_group::Warning, location, targetContext->documentRoot (), "Assignment without variable name %1$s", value.toEchoStringNoThrow ());
+    } else if (seen.find (assignment->getName ()) != seen.end ()) {
       // TODO Should maybe quote the entire assignment with a new quoteExpr() or quoteStmt().
-      LOG(message_group::Warning, location, targetContext->documentRoot(), "Ignoring duplicate variable assignment %1$s = %2$s", quoteVar(assignment->getName()), value.toEchoStringNoThrow());
+      LOG (message_group::Warning, location, targetContext->documentRoot (), "Ignoring duplicate variable assignment %1$s = %2$s", quoteVar (assignment->getName ()), value.toEchoStringNoThrow ());
     } else {
-      targetContext->set_variable(assignment->getName(), std::move(value));
-      seen.insert(assignment->getName());
+      targetContext->set_variable (assignment->getName (), std::move (value));
+      seen.insert (assignment->getName ());
     }
   }
 }
 
-ContextHandle<Context> Let::sequentialAssignmentContext(const AssignmentList& assignments, const Location& location, const std::shared_ptr<const Context>& context)
-{
-  ContextHandle<Context> letContext{Context::create<Context>(context)};
-  doSequentialAssignment(assignments, location, letContext);
+ContextHandle<Context> Let::sequentialAssignmentContext (const AssignmentList &assignments, const Location &location, const std::shared_ptr<const Context> &context) {
+  ContextHandle<Context> letContext{Context::create<Context> (context)};
+  doSequentialAssignment (assignments, location, letContext);
   return letContext;
 }
 
-const Expression *Let::evaluateStep(ContextHandle<Context>& targetContext) const
-{
-  doSequentialAssignment(this->arguments, this->location(), targetContext);
-  return this->expr.get();
+const Expression *Let::evaluateStep (ContextHandle<Context> &targetContext) const {
+  doSequentialAssignment (this->arguments, this->location (), targetContext);
+  return this->expr.get ();
 }
 
-Value Let::evaluate(const std::shared_ptr<const Context>& context) const
-{
-  ContextHandle<Context> letContext{Context::create<Context>(context)};
-  return evaluateStep(letContext)->evaluate(*letContext);
+Value Let::evaluate (const std::shared_ptr<const Context> &context) const {
+  ContextHandle<Context> letContext{Context::create<Context> (context)};
+  return evaluateStep (letContext)->evaluate (*letContext);
 }
 
-void Let::print(std::ostream& stream, const std::string&) const
-{
+void Let::print (std::ostream &stream, const std::string &) const {
   stream << "let(" << this->arguments << ") " << *expr;
 }
 
-ListComprehension::ListComprehension(const Location& loc) : Expression(loc)
-{
+ListComprehension::ListComprehension (const Location &loc)
+  : Expression (loc) {
 }
 
-LcIf::LcIf(Expression *cond, Expression *ifexpr, Expression *elseexpr, const Location& loc)
-  : ListComprehension(loc), cond(cond), ifexpr(ifexpr), elseexpr(elseexpr)
-{
+LcIf::LcIf (Expression *cond, Expression *ifexpr, Expression *elseexpr, const Location &loc)
+  : ListComprehension (loc)
+  , cond (cond)
+  , ifexpr (ifexpr)
+  , elseexpr (elseexpr) {
 }
 
-Value LcIf::evaluate(const std::shared_ptr<const Context>& context) const
-{
-  const std::shared_ptr<Expression>& expr = this->cond->evaluate(context).toBool() ? this->ifexpr : this->elseexpr;
+Value LcIf::evaluate (const std::shared_ptr<const Context> &context) const {
+  const std::shared_ptr<Expression> &expr = this->cond->evaluate (context).toBool () ? this->ifexpr : this->elseexpr;
   if (expr) {
-    return expr->evaluate(context);
+    return expr->evaluate (context);
   } else {
-    return EmbeddedVectorType::Empty();
+    return EmbeddedVectorType::Empty ();
   }
 }
 
-void LcIf::print(std::ostream& stream, const std::string&) const
-{
+void LcIf::print (std::ostream &stream, const std::string &) const {
   stream << "if(" << *this->cond << ") (" << *this->ifexpr << ")";
   if (this->elseexpr) {
     stream << " else (" << *this->elseexpr << ")";
   }
 }
 
-LcEach::LcEach(Expression *expr, const Location& loc) : ListComprehension(loc), expr(expr)
-{
+LcEach::LcEach (Expression *expr, const Location &loc)
+  : ListComprehension (loc)
+  , expr (expr) {
 }
 
 // Need this for recurring into already embedded vectors, and performing "each" on their elements
 //    Context is only passed along for the possible use in Range warning.
-Value LcEach::evalRecur(Value&& v, const std::shared_ptr<const Context>& context) const
-{
-  if (v.type() == Value::Type::RANGE) {
-    const RangeType& range = v.toRange();
-    uint32_t steps = range.numValues();
+Value LcEach::evalRecur (Value &&v, const std::shared_ptr<const Context> &context) const {
+  if (v.type () == Value::Type::RANGE) {
+    const RangeType &range = v.toRange ();
+    uint32_t steps = range.numValues ();
     if (steps >= 1000000) {
-      LOG(message_group::Warning, loc, context->documentRoot(), "Bad range parameter in for statement: too many elements (%1$lu)", steps);
+      LOG (message_group::Warning, loc, context->documentRoot (), "Bad range parameter in for statement: too many elements (%1$lu)", steps);
     } else {
-      EmbeddedVectorType vec(context->session());
-      vec.reserve(range.numValues());
-      for (double d : range) vec.emplace_back(d);
-      return {std::move(vec)};
+      EmbeddedVectorType vec (context->session ());
+      vec.reserve (range.numValues ());
+      for (double d : range)
+        vec.emplace_back (d);
+      return {std::move (vec)};
     }
-  } else if (v.type() == Value::Type::VECTOR) {
+  } else if (v.type () == Value::Type::VECTOR) {
     // Safe to move the overall vector ptr since we have a temporary value (could be a copy, or constructed just for us, doesn't matter)
-    auto vec = EmbeddedVectorType(std::move(v.toVectorNonConst()));
-    return {std::move(vec)};
-  } else if (v.type() == Value::Type::EMBEDDED_VECTOR) {
-    EmbeddedVectorType vec(context->session());
-    vec.reserve(v.toEmbeddedVector().size());
+    auto vec = EmbeddedVectorType (std::move (v.toVectorNonConst ()));
+    return {std::move (vec)};
+  } else if (v.type () == Value::Type::EMBEDDED_VECTOR) {
+    EmbeddedVectorType vec (context->session ());
+    vec.reserve (v.toEmbeddedVector ().size ());
     // Not safe to move values out of a vector, since it's shared_ptr maye be shared with another Value,
     // which should remain constant
-    for (const auto& val : v.toEmbeddedVector()) vec.emplace_back(evalRecur(val.clone(), context) );
-    return {std::move(vec)};
-  } else if (v.type() == Value::Type::STRING) {
-    EmbeddedVectorType vec(context->session());
-    auto& wrapper = v.toStrUtf8Wrapper();
-    vec.reserve(wrapper.size());
-    for (auto ch : wrapper) vec.emplace_back(std::move(ch));
-    return {std::move(vec)};
-  } else if (v.type() != Value::Type::UNDEFINED) {
-    return std::move(v);
+    for (const auto &val : v.toEmbeddedVector ())
+      vec.emplace_back (evalRecur (val.clone (), context));
+    return {std::move (vec)};
+  } else if (v.type () == Value::Type::STRING) {
+    EmbeddedVectorType vec (context->session ());
+    auto &wrapper = v.toStrUtf8Wrapper ();
+    vec.reserve (wrapper.size ());
+    for (auto ch : wrapper)
+      vec.emplace_back (std::move (ch));
+    return {std::move (vec)};
+  } else if (v.type () != Value::Type::UNDEFINED) {
+    return std::move (v);
   }
-  return EmbeddedVectorType::Empty();
+  return EmbeddedVectorType::Empty ();
 }
 
-Value LcEach::evaluate(const std::shared_ptr<const Context>& context) const
-{
-  return evalRecur(this->expr->evaluate(context), context);
+Value LcEach::evaluate (const std::shared_ptr<const Context> &context) const {
+  return evalRecur (this->expr->evaluate (context), context);
 }
 
-void LcEach::print(std::ostream& stream, const std::string&) const
-{
+void LcEach::print (std::ostream &stream, const std::string &) const {
   stream << "each (" << *this->expr << ")";
 }
 
-LcFor::LcFor(AssignmentList args, Expression *expr, const Location& loc)
-  : ListComprehension(loc), arguments(std::move(args)), expr(expr)
-{
+LcFor::LcFor (AssignmentList args, Expression *expr, const Location &loc)
+  : ListComprehension (loc)
+  , arguments (std::move (args))
+  , expr (expr) {
 }
 
-static inline ContextHandle<Context> forContext(const std::shared_ptr<const Context>& context, const std::string& name, Value value)
-{
-  ContextHandle<Context> innerContext{Context::create<Context>(context)};
-  innerContext->set_variable(name, std::move(value));
+static inline ContextHandle<Context> forContext (const std::shared_ptr<const Context> &context, const std::string &name, Value value) {
+  ContextHandle<Context> innerContext{Context::create<Context> (context)};
+  innerContext->set_variable (name, std::move (value));
   return innerContext;
 }
 
-static void doForEach(
-  const AssignmentList& assignments,
-  const Location& location,
-  const std::function<void(const std::shared_ptr<const Context>&)>& operation,
+static void doForEach (
+  const AssignmentList &assignments,
+  const Location &location,
+  const std::function<void (const std::shared_ptr<const Context> &)> &operation,
   size_t assignment_index,
-  const std::shared_ptr<const Context>& context,
-  const std::function<void(size_t)> *pReserve = nullptr
-  ) {
-  if (assignment_index >= assignments.size()) {
-    operation(context);
+  const std::shared_ptr<const Context> &context,
+  const std::function<void (size_t)> *pReserve = nullptr) {
+  if (assignment_index >= assignments.size ()) {
+    operation (context);
     return;
   }
 
-  const std::string& variable_name = assignments[assignment_index]->getName();
-  Value variable_values = assignments[assignment_index]->getExpr()->evaluate(context);
+  const std::string &variable_name = assignments[assignment_index]->getName ();
+  Value variable_values = assignments[assignment_index]->getExpr ()->evaluate (context);
 
-  if (variable_values.type() == Value::Type::RANGE) {
-    const RangeType& range = variable_values.toRange();
-    uint32_t steps = range.numValues();
+  if (variable_values.type () == Value::Type::RANGE) {
+    const RangeType &range = variable_values.toRange ();
+    uint32_t steps = range.numValues ();
     if (steps >= 1000000) {
-      LOG(message_group::Warning, location, context->documentRoot(),
-          "Bad range parameter in for statement: too many elements (%1$lu)", steps);
+      LOG (message_group::Warning, location, context->documentRoot (),
+           "Bad range parameter in for statement: too many elements (%1$lu)", steps);
     } else {
       if (pReserve) {
-        (*pReserve)(steps);
+        (*pReserve) (steps);
       }
       for (double value : range) {
-        doForEach(assignments, location, operation, assignment_index + 1,
-                  *forContext(context, variable_name, value)
-                  );
+        doForEach (assignments, location, operation, assignment_index + 1,
+                   *forContext (context, variable_name, value));
       }
     }
-  } else if (variable_values.type() == Value::Type::VECTOR) {
-    auto& vec = variable_values.toVector();
+  } else if (variable_values.type () == Value::Type::VECTOR) {
+    auto &vec = variable_values.toVector ();
     if (pReserve) {
-      (*pReserve)(vec.size());
+      (*pReserve) (vec.size ());
     }
-    for (const auto& value : vec) {
-      doForEach(assignments, location, operation, assignment_index + 1,
-                *forContext(context, variable_name, value.clone())
-                );
+    for (const auto &value : vec) {
+      doForEach (assignments, location, operation, assignment_index + 1,
+                 *forContext (context, variable_name, value.clone ()));
     }
-  } else if (variable_values.type() == Value::Type::OBJECT) {
-    auto& keys = variable_values.toObject().keys();
+  } else if (variable_values.type () == Value::Type::OBJECT) {
+    auto &keys = variable_values.toObject ().keys ();
     if (pReserve) {
-      (*pReserve)(keys.size());
+      (*pReserve) (keys.size ());
     }
     for (auto key : keys) {
-      doForEach(assignments, location, operation, assignment_index + 1,
-                *forContext(context, variable_name, key)
-                );
+      doForEach (assignments, location, operation, assignment_index + 1,
+                 *forContext (context, variable_name, key));
     }
-  } else if (variable_values.type() == Value::Type::STRING) {
-    auto& wrapper = variable_values.toStrUtf8Wrapper();
+  } else if (variable_values.type () == Value::Type::STRING) {
+    auto &wrapper = variable_values.toStrUtf8Wrapper ();
     if (pReserve) {
-      (*pReserve)(wrapper.size());
+      (*pReserve) (wrapper.size ());
     }
     for (auto value : wrapper) {
-      doForEach(assignments, location, operation, assignment_index + 1,
-                *forContext(context, variable_name, Value(std::move(value)))
-                );
+      doForEach (assignments, location, operation, assignment_index + 1,
+                 *forContext (context, variable_name, Value (std::move (value))));
     }
-  } else if (variable_values.type() != Value::Type::UNDEFINED) {
-    doForEach(assignments, location, operation, assignment_index + 1,
-              *forContext(context, variable_name, std::move(variable_values))
-              );
+  } else if (variable_values.type () != Value::Type::UNDEFINED) {
+    doForEach (assignments, location, operation, assignment_index + 1,
+               *forContext (context, variable_name, std::move (variable_values)));
   }
 }
 
-void LcFor::forEach(const AssignmentList& assignments, const Location& loc, const std::shared_ptr<const Context>& context, const std::function<void(const std::shared_ptr<const Context>&)>& operation, const std::function<void(size_t)> *pReserve)
-{
-  doForEach(assignments, loc, operation, 0, context, pReserve);
+void LcFor::forEach (const AssignmentList &assignments, const Location &loc, const std::shared_ptr<const Context> &context, const std::function<void (const std::shared_ptr<const Context> &)> &operation, const std::function<void (size_t)> *pReserve) {
+  doForEach (assignments, loc, operation, 0, context, pReserve);
 }
 
-Value LcFor::evaluate(const std::shared_ptr<const Context>& context) const
-{
-  EmbeddedVectorType vec(context->session());
-  std::function<void(size_t)> reserve = [&vec](size_t capacity) {
-      vec.reserve(capacity);
-    };
-  forEach(this->arguments, this->loc, context,
-          [&vec, expression = expr.get()] (const std::shared_ptr<const Context>& iterationContext) {
-    vec.emplace_back(expression->evaluate(iterationContext));
-  }, &reserve);
-  return {std::move(vec)};
+Value LcFor::evaluate (const std::shared_ptr<const Context> &context) const {
+  EmbeddedVectorType vec (context->session ());
+  std::function<void (size_t)> reserve = [&vec] (size_t capacity) {
+    vec.reserve (capacity);
+  };
+  forEach (this->arguments, this->loc, context, [&vec, expression = expr.get ()] (const std::shared_ptr<const Context> &iterationContext) { vec.emplace_back (expression->evaluate (iterationContext)); }, &reserve);
+  return {std::move (vec)};
 }
 
-void LcFor::print(std::ostream& stream, const std::string&) const
-{
+void LcFor::print (std::ostream &stream, const std::string &) const {
   stream << "for(" << this->arguments << ") (" << *this->expr << ")";
 }
 
-LcForC::LcForC(AssignmentList args, AssignmentList incrargs, Expression *cond, Expression *expr, const Location& loc)
-  : ListComprehension(loc), arguments(std::move(args)), incr_arguments(std::move(incrargs)), cond(cond), expr(expr)
-{
+LcForC::LcForC (AssignmentList args, AssignmentList incrargs, Expression *cond, Expression *expr, const Location &loc)
+  : ListComprehension (loc)
+  , arguments (std::move (args))
+  , incr_arguments (std::move (incrargs))
+  , cond (cond)
+  , expr (expr) {
 }
 
-Value LcForC::evaluate(const std::shared_ptr<const Context>& context) const
-{
-  EmbeddedVectorType output(context->session());
+Value LcForC::evaluate (const std::shared_ptr<const Context> &context) const {
+  EmbeddedVectorType output (context->session ());
 
-  ContextHandle<Context> initialContext{Let::sequentialAssignmentContext(this->arguments, this->location(), context)};
-  ContextHandle<Context> currentContext{Context::create<Context>(*initialContext)};
+  ContextHandle<Context> initialContext{Let::sequentialAssignmentContext (this->arguments, this->location (), context)};
+  ContextHandle<Context> currentContext{Context::create<Context> (*initialContext)};
 
   unsigned int counter = 0;
-  while (this->cond->evaluate(*currentContext).toBool()) {
-    output.emplace_back(this->expr->evaluate(*currentContext));
+  while (this->cond->evaluate (*currentContext).toBool ()) {
+    output.emplace_back (this->expr->evaluate (*currentContext));
 
     if (counter++ == 1000000) {
-      LOG(message_group::Error, loc, context->documentRoot(), "For loop counter exceeded limit");
-      throw LoopCntException::create("for", loc);
+      LOG (message_group::Error, loc, context->documentRoot (), "For loop counter exceeded limit");
+      throw LoopCntException::create ("for", loc);
     }
 
     /*
@@ -950,15 +967,14 @@ Value LcForC::evaluate(const std::shared_ptr<const Context>& context) const
      * captured context references in lambda functions.
      * So, we reparent the next context to the initial context.
      */
-    ContextHandle<Context> nextContext{Let::sequentialAssignmentContext(this->incr_arguments, this->location(), *currentContext)};
-    currentContext = std::move(nextContext);
-    currentContext->setParent(*initialContext);
+    ContextHandle<Context> nextContext{Let::sequentialAssignmentContext (this->incr_arguments, this->location (), *currentContext)};
+    currentContext = std::move (nextContext);
+    currentContext->setParent (*initialContext);
   }
-  return {std::move(output)};
+  return {std::move (output)};
 }
 
-void LcForC::print(std::ostream& stream, const std::string&) const
-{
+void LcForC::print (std::ostream &stream, const std::string &) const {
   stream
     << "for(" << this->arguments
     << ";" << *this->cond
@@ -966,17 +982,16 @@ void LcForC::print(std::ostream& stream, const std::string&) const
     << ") " << *this->expr;
 }
 
-LcLet::LcLet(AssignmentList args, Expression *expr, const Location& loc)
-  : ListComprehension(loc), arguments(std::move(args)), expr(expr)
-{
+LcLet::LcLet (AssignmentList args, Expression *expr, const Location &loc)
+  : ListComprehension (loc)
+  , arguments (std::move (args))
+  , expr (expr) {
 }
 
-Value LcLet::evaluate(const std::shared_ptr<const Context>& context) const
-{
-  return this->expr->evaluate(*Let::sequentialAssignmentContext(this->arguments, this->location(), context));
+Value LcLet::evaluate (const std::shared_ptr<const Context> &context) const {
+  return this->expr->evaluate (*Let::sequentialAssignmentContext (this->arguments, this->location (), context));
 }
 
-void LcLet::print(std::ostream& stream, const std::string&) const
-{
+void LcLet::print (std::ostream &stream, const std::string &) const {
   stream << "let(" << this->arguments << ") (" << *this->expr << ")";
 }
diff --git a/src/core/Expression.h b/src/core/Expression.h
index b0800c2a4..2cc2d9378 100644
--- a/src/core/Expression.h
+++ b/src/core/Expression.h
@@ -13,15 +13,17 @@
 #include "core/function.h"
 #include "core/Value.h"
 
-template <class T> class ContextHandle;
+template <class T>
+class ContextHandle;
 
 class Expression : public ASTNode
 {
 public:
-  Expression(const Location& loc) : ASTNode(loc) {}
-  [[nodiscard]] virtual bool isLiteral() const;
-  [[nodiscard]] virtual Value evaluate(const std::shared_ptr<const Context>& context) const = 0;
-  Value checkUndef(Value&& val, const std::shared_ptr<const Context>& context) const;
+  Expression (const Location &loc)
+    : ASTNode (loc) {}
+  [[nodiscard]] virtual bool isLiteral () const;
+  [[nodiscard]] virtual Value evaluate (const std::shared_ptr<const Context> &context) const = 0;
+  Value checkUndef (Value &&val, const std::shared_ptr<const Context> &context) const;
 };
 
 class UnaryOp : public Expression
@@ -32,13 +34,13 @@ public:
     BinaryNot,
     Negate
   };
-  [[nodiscard]] bool isLiteral() const override;
-  UnaryOp(Op op, Expression *expr, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  [[nodiscard]] bool isLiteral () const override;
+  UnaryOp (Op op, Expression *expr, const Location &loc);
+  [[nodiscard]] Value evaluate (const std::shared_ptr<const Context> &context) const override;
+  void print (std::ostream &stream, const std::string &indent) const override;
 
 private:
-  [[nodiscard]] const char *opString() const;
+  [[nodiscard]] const char *opString () const;
 
   Op op;
   std::shared_ptr<Expression> expr;
@@ -68,12 +70,12 @@ public:
     NotEqual
   };
 
-  BinaryOp(Expression *left, Op op, Expression *right, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  BinaryOp (Expression *left, Op op, Expression *right, const Location &loc);
+  [[nodiscard]] Value evaluate (const std::shared_ptr<const Context> &context) const override;
+  void print (std::ostream &stream, const std::string &indent) const override;
 
 private:
-  [[nodiscard]] const char *opString() const;
+  [[nodiscard]] const char *opString () const;
 
   Op op;
   std::shared_ptr<Expression> left;
@@ -83,10 +85,11 @@ private:
 class TernaryOp : public Expression
 {
 public:
-  TernaryOp(Expression *cond, Expression *ifexpr, Expression *elseexpr, const Location& loc);
-  [[nodiscard]] const Expression *evaluateStep(const std::shared_ptr<const Context>& context) const;
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  TernaryOp (Expression *cond, Expression *ifexpr, Expression *elseexpr, const Location &loc);
+  [[nodiscard]] const Expression *evaluateStep (const std::shared_ptr<const Context> &context) const;
+  [[nodiscard]] Value evaluate (const std::shared_ptr<const Context> &context) const override;
+  void print (std::ostream &stream, const std::string &indent) const override;
+
 private:
   std::shared_ptr<Expression> cond;
   std::shared_ptr<Expression> ifexpr;
@@ -96,9 +99,10 @@ private:
 class ArrayLookup : public Expression
 {
 public:
-  ArrayLookup(Expression *array, Expression *index, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  ArrayLookup (Expression *array, Expression *index, const Location &loc);
+  [[nodiscard]] Value evaluate (const std::shared_ptr<const Context> &context) const override;
+  void print (std::ostream &stream, const std::string &indent) const override;
+
 private:
   std::shared_ptr<Expression> array;
   std::shared_ptr<Expression> index;
@@ -107,19 +111,40 @@ private:
 class Literal : public Expression
 {
 public:
-  Literal(const Location& loc = Location::NONE) : Expression(loc), value(Value::undefined.clone()) { }
-  Literal(Value val, const Location& loc = Location::NONE) : Expression(loc), value(std::move(val)) { }
-  [[nodiscard]] bool isBool() const { return value.type() == Value::Type::BOOL; }
-  [[nodiscard]] bool toBool() const { return value.toBool(); }
-  [[nodiscard]] bool isDouble() const { return value.type() == Value::Type::NUMBER; }
-  [[nodiscard]] double toDouble() const { return value.toDouble(); }
-  [[nodiscard]] bool isString() const { return value.type() == Value::Type::STRING; }
-  [[nodiscard]] const std::string& toString() const { return value.toStrUtf8Wrapper().toString(); }
-  [[nodiscard]] bool isUndefined() const { return value.type() == Value::Type::UNDEFINED; }
-
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
-  [[nodiscard]] bool isLiteral() const override { return true; }
+  Literal (const Location &loc = Location::NONE)
+    : Expression (loc)
+    , value (Value::undefined.clone ()) {}
+  Literal (Value val, const Location &loc = Location::NONE)
+    : Expression (loc)
+    , value (std::move (val)) {}
+  [[nodiscard]] bool isBool () const {
+    return value.type () == Value::Type::BOOL;
+  }
+  [[nodiscard]] bool toBool () const {
+    return value.toBool ();
+  }
+  [[nodiscard]] bool isDouble () const {
+    return value.type () == Value::Type::NUMBER;
+  }
+  [[nodiscard]] double toDouble () const {
+    return value.toDouble ();
+  }
+  [[nodiscard]] bool isString () const {
+    return value.type () == Value::Type::STRING;
+  }
+  [[nodiscard]] const std::string &toString () const {
+    return value.toStrUtf8Wrapper ().toString ();
+  }
+  [[nodiscard]] bool isUndefined () const {
+    return value.type () == Value::Type::UNDEFINED;
+  }
+
+  [[nodiscard]] Value evaluate (const std::shared_ptr<const Context> &context) const override;
+  void print (std::ostream &stream, const std::string &indent) const override;
+  [[nodiscard]] bool isLiteral () const override {
+    return true;
+  }
+
 private:
   const Value value;
 };
@@ -127,14 +152,21 @@ private:
 class Range : public Expression
 {
 public:
-  Range(Expression *begin, Expression *end, const Location& loc);
-  Range(Expression *begin, Expression *step, Expression *end, const Location& loc);
-  [[nodiscard]] const Expression *getBegin() const { return begin.get(); }
-  [[nodiscard]] const Expression *getStep() const { return step.get(); }
-  [[nodiscard]] const Expression *getEnd() const { return end.get(); }
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
-  [[nodiscard]] bool isLiteral() const override;
+  Range (Expression *begin, Expression *end, const Location &loc);
+  Range (Expression *begin, Expression *step, Expression *end, const Location &loc);
+  [[nodiscard]] const Expression *getBegin () const {
+    return begin.get ();
+  }
+  [[nodiscard]] const Expression *getStep () const {
+    return step.get ();
+  }
+  [[nodiscard]] const Expression *getEnd () const {
+    return end.get ();
+  }
+  [[nodiscard]] Value evaluate (const std::shared_ptr<const Context> &context) const override;
+  void print (std::ostream &stream, const std::string &indent) const override;
+  [[nodiscard]] bool isLiteral () const override;
+
 private:
   std::shared_ptr<Expression> begin;
   std::shared_ptr<Expression> step;
@@ -144,12 +176,15 @@ private:
 class Vector : public Expression
 {
 public:
-  Vector(const Location& loc);
-  const std::vector<std::shared_ptr<Expression>>& getChildren() const { return children; }
-  Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
-  void emplace_back(Expression *expr);
-  bool isLiteral() const override;
+  Vector (const Location &loc);
+  const std::vector<std::shared_ptr<Expression>> &getChildren () const {
+    return children;
+  }
+  Value evaluate (const std::shared_ptr<const Context> &context) const override;
+  void print (std::ostream &stream, const std::string &indent) const override;
+  void emplace_back (Expression *expr);
+  bool isLiteral () const override;
+
 private:
   std::vector<std::shared_ptr<Expression>> children;
   mutable boost::tribool literal_flag; // cache if already computed
@@ -158,10 +193,13 @@ private:
 class Lookup : public Expression
 {
 public:
-  Lookup(std::string name, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
-  [[nodiscard]] const std::string& get_name() const { return name; }
+  Lookup (std::string name, const Location &loc);
+  [[nodiscard]] Value evaluate (const std::shared_ptr<const Context> &context) const override;
+  void print (std::ostream &stream, const std::string &indent) const override;
+  [[nodiscard]] const std::string &get_name () const {
+    return name;
+  }
+
 private:
   std::string name;
 };
@@ -169,9 +207,10 @@ private:
 class MemberLookup : public Expression
 {
 public:
-  MemberLookup(Expression *expr, std::string member, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  MemberLookup (Expression *expr, std::string member, const Location &loc);
+  [[nodiscard]] Value evaluate (const std::shared_ptr<const Context> &context) const override;
+  void print (std::ostream &stream, const std::string &indent) const override;
+
 private:
   std::shared_ptr<Expression> expr;
   std::string member;
@@ -180,12 +219,15 @@ private:
 class FunctionCall : public Expression
 {
 public:
-  FunctionCall(Expression *expr, AssignmentList arglist, const Location& loc);
-  [[nodiscard]] boost::optional<CallableFunction> evaluate_function_expression(const std::shared_ptr<const Context>& context) const;
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
-  [[nodiscard]] const std::string& get_name() const { return name; }
-  static Expression *create(const std::string& funcname, const AssignmentList& arglist, Expression *expr, const Location& loc);
+  FunctionCall (Expression *expr, AssignmentList arglist, const Location &loc);
+  [[nodiscard]] boost::optional<CallableFunction> evaluate_function_expression (const std::shared_ptr<const Context> &context) const;
+  [[nodiscard]] Value evaluate (const std::shared_ptr<const Context> &context) const override;
+  void print (std::ostream &stream, const std::string &indent) const override;
+  [[nodiscard]] const std::string &get_name () const {
+    return name;
+  }
+  static Expression *create (const std::string &funcname, const AssignmentList &arglist, Expression *expr, const Location &loc);
+
 public:
   bool isLookup;
   std::string name;
@@ -196,9 +238,10 @@ public:
 class FunctionDefinition : public Expression
 {
 public:
-  FunctionDefinition(Expression *expr, AssignmentList parameters, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  FunctionDefinition (Expression *expr, AssignmentList parameters, const Location &loc);
+  [[nodiscard]] Value evaluate (const std::shared_ptr<const Context> &context) const override;
+  void print (std::ostream &stream, const std::string &indent) const override;
+
 public:
   std::shared_ptr<const Context> context;
   AssignmentList parameters;
@@ -208,11 +251,12 @@ public:
 class Assert : public Expression
 {
 public:
-  Assert(AssignmentList args, Expression *expr, const Location& loc);
-  static void performAssert(const AssignmentList& arguments, const Location& location, const std::shared_ptr<const Context>& context);
-  [[nodiscard]] const Expression *evaluateStep(const std::shared_ptr<const Context>& context) const;
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  Assert (AssignmentList args, Expression *expr, const Location &loc);
+  static void performAssert (const AssignmentList &arguments, const Location &location, const std::shared_ptr<const Context> &context);
+  [[nodiscard]] const Expression *evaluateStep (const std::shared_ptr<const Context> &context) const;
+  [[nodiscard]] Value evaluate (const std::shared_ptr<const Context> &context) const override;
+  void print (std::ostream &stream, const std::string &indent) const override;
+
 private:
   AssignmentList arguments;
   std::shared_ptr<Expression> expr;
@@ -221,10 +265,11 @@ private:
 class Echo : public Expression
 {
 public:
-  Echo(AssignmentList args, Expression *expr, const Location& loc);
-  [[nodiscard]] const Expression *evaluateStep(const std::shared_ptr<const Context>& context) const;
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  Echo (AssignmentList args, Expression *expr, const Location &loc);
+  [[nodiscard]] const Expression *evaluateStep (const std::shared_ptr<const Context> &context) const;
+  [[nodiscard]] Value evaluate (const std::shared_ptr<const Context> &context) const override;
+  void print (std::ostream &stream, const std::string &indent) const override;
+
 private:
   AssignmentList arguments;
   std::shared_ptr<Expression> expr;
@@ -233,12 +278,13 @@ private:
 class Let : public Expression
 {
 public:
-  Let(AssignmentList args, Expression *expr, const Location& loc);
-  static void doSequentialAssignment(const AssignmentList& assignments, const Location& location, ContextHandle<Context>& targetContext);
-  static ContextHandle<Context> sequentialAssignmentContext(const AssignmentList& assignments, const Location& location, const std::shared_ptr<const Context>& context);
-  const Expression *evaluateStep(ContextHandle<Context>& targetContext) const;
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  Let (AssignmentList args, Expression *expr, const Location &loc);
+  static void doSequentialAssignment (const AssignmentList &assignments, const Location &location, ContextHandle<Context> &targetContext);
+  static ContextHandle<Context> sequentialAssignmentContext (const AssignmentList &assignments, const Location &location, const std::shared_ptr<const Context> &context);
+  const Expression *evaluateStep (ContextHandle<Context> &targetContext) const;
+  [[nodiscard]] Value evaluate (const std::shared_ptr<const Context> &context) const override;
+  void print (std::ostream &stream, const std::string &indent) const override;
+
 private:
   AssignmentList arguments;
   std::shared_ptr<Expression> expr;
@@ -247,15 +293,16 @@ private:
 class ListComprehension : public Expression
 {
 public:
-  ListComprehension(const Location& loc);
+  ListComprehension (const Location &loc);
 };
 
 class LcIf : public ListComprehension
 {
 public:
-  LcIf(Expression *cond, Expression *ifexpr, Expression *elseexpr, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  LcIf (Expression *cond, Expression *ifexpr, Expression *elseexpr, const Location &loc);
+  [[nodiscard]] Value evaluate (const std::shared_ptr<const Context> &context) const override;
+  void print (std::ostream &stream, const std::string &indent) const override;
+
 private:
   std::shared_ptr<Expression> cond;
   std::shared_ptr<Expression> ifexpr;
@@ -265,10 +312,11 @@ private:
 class LcFor : public ListComprehension
 {
 public:
-  LcFor(AssignmentList args, Expression *expr, const Location& loc);
-  static void forEach(const AssignmentList& assignments, const Location& loc, const std::shared_ptr<const Context>& context, const std::function<void(const std::shared_ptr<const Context>&)>& operation, const std::function<void(size_t)> *pReserve = nullptr);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  LcFor (AssignmentList args, Expression *expr, const Location &loc);
+  static void forEach (const AssignmentList &assignments, const Location &loc, const std::shared_ptr<const Context> &context, const std::function<void (const std::shared_ptr<const Context> &)> &operation, const std::function<void (size_t)> *pReserve = nullptr);
+  [[nodiscard]] Value evaluate (const std::shared_ptr<const Context> &context) const override;
+  void print (std::ostream &stream, const std::string &indent) const override;
+
 private:
   AssignmentList arguments;
   std::shared_ptr<Expression> expr;
@@ -277,9 +325,10 @@ private:
 class LcForC : public ListComprehension
 {
 public:
-  LcForC(AssignmentList args, AssignmentList incrargs, Expression *cond, Expression *expr, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  LcForC (AssignmentList args, AssignmentList incrargs, Expression *cond, Expression *expr, const Location &loc);
+  [[nodiscard]] Value evaluate (const std::shared_ptr<const Context> &context) const override;
+  void print (std::ostream &stream, const std::string &indent) const override;
+
 private:
   AssignmentList arguments;
   AssignmentList incr_arguments;
@@ -290,20 +339,22 @@ private:
 class LcEach : public ListComprehension
 {
 public:
-  LcEach(Expression *expr, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  LcEach (Expression *expr, const Location &loc);
+  [[nodiscard]] Value evaluate (const std::shared_ptr<const Context> &context) const override;
+  void print (std::ostream &stream, const std::string &indent) const override;
+
 private:
-  Value evalRecur(Value&& v, const std::shared_ptr<const Context>& context) const;
+  Value evalRecur (Value &&v, const std::shared_ptr<const Context> &context) const;
   std::shared_ptr<Expression> expr;
 };
 
 class LcLet : public ListComprehension
 {
 public:
-  LcLet(AssignmentList args, Expression *expr, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  LcLet (AssignmentList args, Expression *expr, const Location &loc);
+  [[nodiscard]] Value evaluate (const std::shared_ptr<const Context> &context) const override;
+  void print (std::ostream &stream, const std::string &indent) const override;
+
 private:
   AssignmentList arguments;
   std::shared_ptr<Expression> expr;
diff --git a/src/core/FreetypeRenderer.cc b/src/core/FreetypeRenderer.cc
index 892ddb859..72a3a50fb 100644
--- a/src/core/FreetypeRenderer.cc
+++ b/src/core/FreetypeRenderer.cc
@@ -33,7 +33,6 @@
 #include <cstdio>
 #include <vector>
 
-
 #include <fontconfig/fontconfig.h>
 #include <hb-ft.h>
 
@@ -46,16 +45,15 @@
 
 #include FT_OUTLINE_H
 // NOLINTNEXTLINE(bugprone-macro-parentheses)
-#define SCRIPT_UNTAG(tag)   ((uint8_t)((tag) >> 24)) % ((uint8_t)((tag) >> 16)) % ((uint8_t)((tag) >> 8)) % ((uint8_t)(tag))
+#define SCRIPT_UNTAG(tag) ((uint8_t)((tag) >> 24)) % ((uint8_t)((tag) >> 16)) % ((uint8_t)((tag) >> 8)) % ((uint8_t)(tag))
 
-static inline Vector2d get_scaled_vector(const FT_Vector *ft_vector, double scale) {
+static inline Vector2d get_scaled_vector (const FT_Vector *ft_vector, double scale) {
   return {ft_vector->x / scale, ft_vector->y / scale};
 }
 
 const double FreetypeRenderer::scale = 1e5;
 
-FreetypeRenderer::FreetypeRenderer()
-{
+FreetypeRenderer::FreetypeRenderer () {
   funcs.move_to = outline_move_to_func;
   funcs.line_to = outline_line_to_func;
   funcs.conic_to = outline_conic_to_func;
@@ -64,42 +62,37 @@ FreetypeRenderer::FreetypeRenderer()
   funcs.shift = 0;
 }
 
-int FreetypeRenderer::outline_move_to_func(const FT_Vector *to, void *user)
-{
-  auto *cb = reinterpret_cast<DrawingCallback *>(user);
+int FreetypeRenderer::outline_move_to_func (const FT_Vector *to, void *user) {
+  auto *cb = reinterpret_cast<DrawingCallback *> (user);
 
-  cb->move_to(get_scaled_vector(to, scale));
+  cb->move_to (get_scaled_vector (to, scale));
   return 0;
 }
 
-int FreetypeRenderer::outline_line_to_func(const FT_Vector *to, void *user)
-{
-  auto *cb = reinterpret_cast<DrawingCallback *>(user);
+int FreetypeRenderer::outline_line_to_func (const FT_Vector *to, void *user) {
+  auto *cb = reinterpret_cast<DrawingCallback *> (user);
 
-  cb->line_to(get_scaled_vector(to, scale));
+  cb->line_to (get_scaled_vector (to, scale));
   return 0;
 }
 
-int FreetypeRenderer::outline_conic_to_func(const FT_Vector *c1, const FT_Vector *to, void *user)
-{
-  auto *cb = reinterpret_cast<DrawingCallback *>(user);
+int FreetypeRenderer::outline_conic_to_func (const FT_Vector *c1, const FT_Vector *to, void *user) {
+  auto *cb = reinterpret_cast<DrawingCallback *> (user);
 
-  cb->curve_to(get_scaled_vector(c1, scale), get_scaled_vector(to, scale));
+  cb->curve_to (get_scaled_vector (c1, scale), get_scaled_vector (to, scale));
   return 0;
 }
 
-int FreetypeRenderer::outline_cubic_to_func(const FT_Vector *c1, const FT_Vector *c2, const FT_Vector *to, void *user)
-{
-  auto *cb = reinterpret_cast<DrawingCallback *>(user);
+int FreetypeRenderer::outline_cubic_to_func (const FT_Vector *c1, const FT_Vector *c2, const FT_Vector *to, void *user) {
+  auto *cb = reinterpret_cast<DrawingCallback *> (user);
 
-  cb->curve_to(get_scaled_vector(c1, scale), get_scaled_vector(c2, scale), get_scaled_vector(to, scale));
+  cb->curve_to (get_scaled_vector (c1, scale), get_scaled_vector (c2, scale), get_scaled_vector (to, scale));
   return 0;
 }
 
 // Calculate offsets for horizontal text.
-void FreetypeRenderer::ShapeResults::calc_offsets_horiz(
-  const FreetypeRenderer::Params& params)
-{
+void FreetypeRenderer::ShapeResults::calc_offsets_horiz (
+  const FreetypeRenderer::Params &params) {
   if (params.halign == "right") {
     x_offset = -advance_x;
   } else if (params.halign == "center") {
@@ -107,10 +100,10 @@ void FreetypeRenderer::ShapeResults::calc_offsets_horiz(
   } else if (params.halign == "left" || params.halign == "default") {
     x_offset = 0;
   } else {
-    LOG(message_group::Warning, params.loc, params.documentPath,
-        "Unknown value for the halign parameter"
-        " (use \"left\", \"right\" or \"center\"): '%1$s'",
-        params.halign);
+    LOG (message_group::Warning, params.loc, params.documentPath,
+         "Unknown value for the halign parameter"
+         " (use \"left\", \"right\" or \"center\"): '%1$s'",
+         params.halign);
     x_offset = 0;
   }
 
@@ -124,18 +117,17 @@ void FreetypeRenderer::ShapeResults::calc_offsets_horiz(
   } else if (params.valign == "baseline" || params.valign == "default") {
     y_offset = 0;
   } else {
-    LOG(message_group::Warning, params.loc, params.documentPath,
-        "Unknown value for the valign parameter"
-        " (use \"baseline\", \"bottom\", \"top\" or \"center\"): '%1$s'",
-        params.valign);
+    LOG (message_group::Warning, params.loc, params.documentPath,
+         "Unknown value for the valign parameter"
+         " (use \"baseline\", \"bottom\", \"top\" or \"center\"): '%1$s'",
+         params.valign);
     y_offset = 0;
   }
 }
 
 // Calculate offsets for vertical text.
-void FreetypeRenderer::ShapeResults::calc_offsets_vert(
-  const FreetypeRenderer::Params& params)
-{
+void FreetypeRenderer::ShapeResults::calc_offsets_vert (
+  const FreetypeRenderer::Params &params) {
   if (params.halign == "right") {
     x_offset = -right;
   } else if (params.halign == "left") {
@@ -143,17 +135,17 @@ void FreetypeRenderer::ShapeResults::calc_offsets_vert(
   } else if (params.halign == "center" || params.halign == "default") {
     x_offset = 0;
   } else {
-    LOG(message_group::Warning, params.loc, params.documentPath,
-        "Unknown value for the halign parameter"
-        " (use \"left\", \"right\" or \"center\"): '%1$s'",
-        params.halign);
+    LOG (message_group::Warning, params.loc, params.documentPath,
+         "Unknown value for the halign parameter"
+         " (use \"left\", \"right\" or \"center\"): '%1$s'",
+         params.halign);
     x_offset = 0;
   }
 
   if (params.valign == "baseline") {
-    LOG(message_group::Warning, params.loc, params.documentPath,
-        "Don't use valign=\"baseline\" with vertical layouts",
-        params.valign);
+    LOG (message_group::Warning, params.loc, params.documentPath,
+         "Don't use valign=\"baseline\" with vertical layouts",
+         params.valign);
     y_offset = 0;
   } else if (params.valign == "center") {
     y_offset = -advance_y / 2.0;
@@ -165,37 +157,35 @@ void FreetypeRenderer::ShapeResults::calc_offsets_vert(
     // being placed below the origin.
     y_offset = 0;
   } else {
-    LOG(message_group::Warning, params.loc, params.documentPath,
-        "Unknown value for the valign parameter"
-        " (use \"baseline\", \"bottom\", \"top\" or \"center\"): '%1$s'",
-        params.valign);
+    LOG (message_group::Warning, params.loc, params.documentPath,
+         "Unknown value for the valign parameter"
+         " (use \"baseline\", \"bottom\", \"top\" or \"center\"): '%1$s'",
+         params.valign);
   }
 }
 
-hb_direction_t FreetypeRenderer::Params::detect_direction(const hb_script_t script) const
-{
+hb_direction_t FreetypeRenderer::Params::detect_direction (const hb_script_t script) const {
   hb_direction_t hbdirection;
 
-  hbdirection = hb_direction_from_string(direction.c_str(), -1);
+  hbdirection = hb_direction_from_string (direction.c_str (), -1);
   if (hbdirection != HB_DIRECTION_INVALID) {
-    PRINTDB("Explicit direction '%s' for %s",
-            hb_direction_to_string(hbdirection) % text.c_str());
+    PRINTDB ("Explicit direction '%s' for %s",
+             hb_direction_to_string (hbdirection) % text.c_str ());
     return hbdirection;
   }
 
-  hbdirection = hb_script_get_horizontal_direction(script);
+  hbdirection = hb_script_get_horizontal_direction (script);
   if (hbdirection != HB_DIRECTION_INVALID) {
-    PRINTDB("Detected direction '%s' for %s",
-            hb_direction_to_string(hbdirection) % text.c_str());
+    PRINTDB ("Detected direction '%s' for %s",
+             hb_direction_to_string (hbdirection) % text.c_str ());
     return hbdirection;
   }
 
-  PRINTDB("Unknown direction for %s; defaulting to LTR", text.c_str());
+  PRINTDB ("Unknown direction for %s; defaulting to LTR", text.c_str ());
   return HB_DIRECTION_LTR;
 }
 
-bool FreetypeRenderer::Params::is_ignored_script(const hb_script_t script)
-{
+bool FreetypeRenderer::Params::is_ignored_script (const hb_script_t script) {
   switch (script) {
   case HB_SCRIPT_COMMON:
   case HB_SCRIPT_INHERITED:
@@ -207,11 +197,10 @@ bool FreetypeRenderer::Params::is_ignored_script(const hb_script_t script)
   }
 }
 
-hb_script_t FreetypeRenderer::Params::detect_script(hb_glyph_info_t *glyph_info, unsigned int glyph_count) const
-{
+hb_script_t FreetypeRenderer::Params::detect_script (hb_glyph_info_t *glyph_info, unsigned int glyph_count) const {
   hb_script_t hbscript;
 
-  hbscript = hb_script_from_string(script.c_str(), -1);
+  hbscript = hb_script_from_string (script.c_str (), -1);
   if (hbscript != HB_SCRIPT_INVALID) {
     return hbscript;
   }
@@ -219,8 +208,8 @@ hb_script_t FreetypeRenderer::Params::detect_script(hb_glyph_info_t *glyph_info,
   hbscript = HB_SCRIPT_INVALID;
   for (unsigned int idx = 0; idx < glyph_count; ++idx) {
     hb_codepoint_t cp = glyph_info[idx].codepoint;
-    hb_script_t s = hb_unicode_script(hb_unicode_funcs_get_default(), cp);
-    if (!is_ignored_script(s)) {
+    hb_script_t s = hb_unicode_script (hb_unicode_funcs_get_default (), cp);
+    if (!is_ignored_script (s)) {
       if (hbscript == HB_SCRIPT_INVALID) {
         hbscript = s;
       } else if ((hbscript != s) && (hbscript != HB_SCRIPT_UNKNOWN)) {
@@ -228,112 +217,109 @@ hb_script_t FreetypeRenderer::Params::detect_script(hb_glyph_info_t *glyph_info,
       }
     }
   }
-  PRINTDB("Detected script '%c%c%c%c' for %s", SCRIPT_UNTAG(hbscript) % text.c_str());
+  PRINTDB ("Detected script '%c%c%c%c' for %s", SCRIPT_UNTAG (hbscript) % text.c_str ());
   return hbscript;
 }
 
-void FreetypeRenderer::Params::detect_properties()
-{
-  hb_buffer_t *hb_buf = hb_buffer_create();
-  hb_buffer_add_utf8(hb_buf, text.c_str(), strlen(text.c_str()), 0, strlen(text.c_str()));
+void FreetypeRenderer::Params::detect_properties () {
+  hb_buffer_t *hb_buf = hb_buffer_create ();
+  hb_buffer_add_utf8 (hb_buf, text.c_str (), strlen (text.c_str ()), 0, strlen (text.c_str ()));
 
   unsigned int glyph_count;
-  hb_glyph_info_t *glyph_info = hb_buffer_get_glyph_infos(hb_buf, &glyph_count);
+  hb_glyph_info_t *glyph_info = hb_buffer_get_glyph_infos (hb_buf, &glyph_count);
 
-  hb_script_t hbscript = detect_script(glyph_info, glyph_count);
-  hb_buffer_destroy(hb_buf);
+  hb_script_t hbscript = detect_script (glyph_info, glyph_count);
+  hb_buffer_destroy (hb_buf);
 
-  if (!is_ignored_script(hbscript)) {
-    char script_buf[5] = { 0, };
-    hb_tag_to_string(hb_script_to_iso15924_tag(hbscript), script_buf);
-    set_script(script_buf);
+  if (!is_ignored_script (hbscript)) {
+    char script_buf[5] = {
+      0,
+    };
+    hb_tag_to_string (hb_script_to_iso15924_tag (hbscript), script_buf);
+    set_script (script_buf);
   }
 
-  hb_direction_t hbdirection = detect_direction(hbscript);
-  set_direction(hb_direction_to_string(hbdirection));
+  hb_direction_t hbdirection = detect_direction (hbscript);
+  set_direction (hb_direction_to_string (hbdirection));
 
-  auto segments = Calc::get_fragments_from_r(size, fn, fs, fa);
+  auto segments = Calc::get_fragments_from_r (size, fn, fs, fa);
   // The curved segments of most fonts are relatively short, so
   // by using a fraction of the number of full circle segments
   // the resolution will be better matching the detail level of
   // other objects.
-  auto text_segments = std::max(segments / 8 + 1, 2);
-  set_segments(text_segments);
+  auto text_segments = std::max (segments / 8 + 1, 2);
+  set_segments (text_segments);
 }
 
-const FontFacePtr FreetypeRenderer::Params::get_font_face() const
-{
-  FontCache *cache = FontCache::instance();
-  if (!cache->is_init_ok()) {
-    LOG(message_group::Warning, loc, documentPath,
-        "Font cache initialization failed");
+const FontFacePtr FreetypeRenderer::Params::get_font_face () const {
+  FontCache *cache = FontCache::instance ();
+  if (!cache->is_init_ok ()) {
+    LOG (message_group::Warning, loc, documentPath,
+         "Font cache initialization failed");
     return nullptr;
   }
 
-  const FontFacePtr face = cache->get_font(font);
+  const FontFacePtr face = cache->get_font (font);
   if (!face) {
-    LOG(message_group::Warning, loc, documentPath, "Can't get font %1$s", font);
+    LOG (message_group::Warning, loc, documentPath, "Can't get font %1$s", font);
     return nullptr;
   }
 
-  FT_Error error = FT_Set_Char_Size(face->face_, 0, scale, 100, 100);
+  FT_Error error = FT_Set_Char_Size (face->face_, 0, scale, 100, 100);
   if (error) {
-    LOG(message_group::Warning, loc, documentPath,
-        "Can't set font size for font %1$s", font);
+    LOG (message_group::Warning, loc, documentPath,
+         "Can't set font size for font %1$s", font);
     return nullptr;
   }
   return face;
 }
 
-void FreetypeRenderer::Params::set(Parameters& parameters)
-{
+void FreetypeRenderer::Params::set (Parameters &parameters) {
   // Note:
   // This populates all of the Params entries that text() populates.
   // Probably some of them are not needed by some callers.
   // However, we populate them here rather than "knowing" which
   // ones are and are not needed.
 
-  (void) parameters.valid("size", Value::Type::NUMBER);
-  (void) parameters.valid("text", Value::Type::STRING);
-  (void) parameters.valid("spacing", Value::Type::NUMBER);
-  (void) parameters.valid("font", Value::Type::STRING);
-  (void) parameters.valid("direction", Value::Type::STRING);
-  (void) parameters.valid("language", Value::Type::STRING);
-  (void) parameters.valid("script", Value::Type::STRING);
-  (void) parameters.valid("halign", Value::Type::STRING);
-  (void) parameters.valid("valign", Value::Type::STRING);
-
-  set_fn(parameters["$fn"].toDouble());
-  set_fa(parameters["$fa"].toDouble());
-  set_fs(parameters["$fs"].toDouble());
-
-  set_size(parameters.get("size", 10.0));
-  set_text(parameters.get("text", ""));
-  set_spacing(parameters.get("spacing", 1.0));
-  set_font(parameters.get("font", ""));
-  set_direction(parameters.get("direction", ""));
-  set_language(parameters.get("language", "en"));
-  set_script(parameters.get("script", ""));
-  set_halign(parameters.get("halign", "default"));
-  set_valign(parameters.get("valign", "default"));
+  (void)parameters.valid ("size", Value::Type::NUMBER);
+  (void)parameters.valid ("text", Value::Type::STRING);
+  (void)parameters.valid ("spacing", Value::Type::NUMBER);
+  (void)parameters.valid ("font", Value::Type::STRING);
+  (void)parameters.valid ("direction", Value::Type::STRING);
+  (void)parameters.valid ("language", Value::Type::STRING);
+  (void)parameters.valid ("script", Value::Type::STRING);
+  (void)parameters.valid ("halign", Value::Type::STRING);
+  (void)parameters.valid ("valign", Value::Type::STRING);
+
+  set_fn (parameters["$fn"].toDouble ());
+  set_fa (parameters["$fa"].toDouble ());
+  set_fs (parameters["$fs"].toDouble ());
+
+  set_size (parameters.get ("size", 10.0));
+  set_text (parameters.get ("text", ""));
+  set_spacing (parameters.get ("spacing", 1.0));
+  set_font (parameters.get ("font", ""));
+  set_direction (parameters.get ("direction", ""));
+  set_language (parameters.get ("language", "en"));
+  set_script (parameters.get ("script", ""));
+  set_halign (parameters.get ("halign", "default"));
+  set_valign (parameters.get ("valign", "default"));
 }
 
-
-FreetypeRenderer::ShapeResults::ShapeResults(
-  const FreetypeRenderer::Params& params)
-{
-  const FontFacePtr face = params.get_font_face();
+FreetypeRenderer::ShapeResults::ShapeResults (
+  const FreetypeRenderer::Params &params) {
+  const FontFacePtr face = params.get_font_face ();
   if (!face) {
     return;
   }
 
-  hb_ft_font = hb_ft_font_create(face->face_, nullptr);
+  hb_ft_font = hb_ft_font_create (face->face_, nullptr);
 
-  hb_buf = hb_buffer_create();
-  hb_buffer_set_direction(hb_buf, hb_direction_from_string(params.direction.c_str(), -1));
-  hb_buffer_set_script(hb_buf, hb_script_from_string(params.script.c_str(), -1));
-  hb_buffer_set_language(hb_buf, hb_language_from_string(params.language.c_str(), -1));
-  if (FontCache::instance()->is_windows_symbol_font(face->face_)) {
+  hb_buf = hb_buffer_create ();
+  hb_buffer_set_direction (hb_buf, hb_direction_from_string (params.direction.c_str (), -1));
+  hb_buffer_set_script (hb_buf, hb_script_from_string (params.script.c_str (), -1));
+  hb_buffer_set_language (hb_buf, hb_language_from_string (params.language.c_str (), -1));
+  if (FontCache::instance ()->is_windows_symbol_font (face->face_)) {
     // Special handling for symbol fonts like Webdings.
     // see http://www.microsoft.com/typography/otspec/recom.htm
     //
@@ -343,78 +329,78 @@ FreetypeRenderer::ShapeResults::ShapeResults(
     // values are untouched, so using the correct codepoint directly
     // (e.g. \uf021 for the spider in Webdings) still works.
     str_utf8_wrapper utf8_str{params.text};
-    if (utf8_str.utf8_validate()) {
+    if (utf8_str.utf8_validate ()) {
       for (auto ch : utf8_str) {
-        gunichar c = ch.get_utf8_char();
+        gunichar c = ch.get_utf8_char ();
         c = (c < 0x0100) ? 0xf000 + c : c;
-        hb_buffer_add_utf32(hb_buf, &c, 1, 0, 1);
+        hb_buffer_add_utf32 (hb_buf, &c, 1, 0, 1);
       }
     } else {
-      LOG(message_group::Warning, params.loc, params.documentPath,
-          "Ignoring text with invalid UTF-8 encoding: \"%1$s\"",
-          params.text.c_str());
+      LOG (message_group::Warning, params.loc, params.documentPath,
+           "Ignoring text with invalid UTF-8 encoding: \"%1$s\"",
+           params.text.c_str ());
     }
   } else {
-    hb_buffer_add_utf8(hb_buf, params.text.c_str(), strlen(params.text.c_str()), 0, strlen(params.text.c_str()));
+    hb_buffer_add_utf8 (hb_buf, params.text.c_str (), strlen (params.text.c_str ()), 0, strlen (params.text.c_str ()));
   }
 
   std::vector<hb_feature_t> features;
-  features.reserve(face->features_.size());
-  std::transform(begin(face->features_), end(face->features_), std::back_inserter(features), [](const std::string& s) {
+  features.reserve (face->features_.size ());
+  std::transform (begin (face->features_), end (face->features_), std::back_inserter (features), [] (const std::string &s) {
     hb_feature_t f;
-    hb_feature_from_string(s.c_str(), s.size(), &f);
+    hb_feature_from_string (s.c_str (), s.size (), &f);
     return f;
   });
   std::vector<hb_feature_t *> features_ptr;
-  features.reserve(features.size());
-  std::transform(begin(features), end(features), std::back_inserter(features_ptr), [](hb_feature_t& f) {
+  features.reserve (features.size ());
+  std::transform (begin (features), end (features), std::back_inserter (features_ptr), [] (hb_feature_t &f) {
     return &f;
   });
 
-  hb_shape(hb_ft_font, hb_buf, features_ptr.data()[0], features_ptr.size());
+  hb_shape (hb_ft_font, hb_buf, features_ptr.data ()[0], features_ptr.size ());
 
   unsigned int glyph_count;
-  hb_glyph_info_t *glyph_info = hb_buffer_get_glyph_infos(hb_buf, &glyph_count);
-  hb_glyph_position_t *glyph_pos = hb_buffer_get_glyph_positions(hb_buf, &glyph_count);
+  hb_glyph_info_t *glyph_info = hb_buffer_get_glyph_infos (hb_buf, &glyph_count);
+  hb_glyph_position_t *glyph_pos = hb_buffer_get_glyph_positions (hb_buf, &glyph_count);
 
-  glyph_array.reserve(glyph_count);
+  glyph_array.reserve (glyph_count);
   for (unsigned int idx = 0; idx < glyph_count; ++idx) {
     FT_Error error;
     FT_UInt glyph_index = glyph_info[idx].codepoint;
-    error = FT_Load_Glyph(face->face_, glyph_index, FT_LOAD_DEFAULT);
+    error = FT_Load_Glyph (face->face_, glyph_index, FT_LOAD_DEFAULT);
     if (error) {
-      LOG(message_group::Warning, params.loc, params.documentPath,
-          "Could not load glyph %1$u"
-          " for char at index %2$u in text '%3$s'",
-          glyph_index, idx, params.text);
+      LOG (message_group::Warning, params.loc, params.documentPath,
+           "Could not load glyph %1$u"
+           " for char at index %2$u in text '%3$s'",
+           glyph_index, idx, params.text);
       continue;
     }
 
     FT_Glyph glyph;
-    error = FT_Get_Glyph(face->face_->glyph, &glyph);
+    error = FT_Get_Glyph (face->face_->glyph, &glyph);
     if (error) {
-      LOG(message_group::Warning, params.loc, params.documentPath,
-          "Could not get glyph %1$u"
-          " for char at index %2$u in text '%3$s'",
-          glyph_index, idx, params.text);
+      LOG (message_group::Warning, params.loc, params.documentPath,
+           "Could not get glyph %1$u"
+           " for char at index %2$u in text '%3$s'",
+           glyph_index, idx, params.text);
       continue;
     }
 
-    glyph_array.emplace_back(glyph, idx, &glyph_pos[idx]);
+    glyph_array.emplace_back (glyph, idx, &glyph_pos[idx]);
   }
 
-  ascent = std::numeric_limits<double>::lowest();
-  descent = std::numeric_limits<double>::max();
+  ascent = std::numeric_limits<double>::lowest ();
+  descent = std::numeric_limits<double>::max ();
   advance_x = 0;
   advance_y = 0;
-  left = std::numeric_limits<double>::max();
-  right = std::numeric_limits<double>::lowest();
-  bottom = std::numeric_limits<double>::max();
-  top = std::numeric_limits<double>::lowest();
+  left = std::numeric_limits<double>::max ();
+  right = std::numeric_limits<double>::lowest ();
+  bottom = std::numeric_limits<double>::max ();
+  top = std::numeric_limits<double>::lowest ();
 
-  for (const auto& glyph : glyph_array) {
+  for (const auto &glyph : glyph_array) {
     FT_BBox bbox;
-    FT_Glyph_Get_CBox(glyph.get_glyph(), FT_GLYPH_BBOX_GRIDFIT, &bbox);
+    FT_Glyph_Get_CBox (glyph.get_glyph (), FT_GLYPH_BBOX_GRIDFIT, &bbox);
 
     // Note that glyphs can extend left of their origin
     // and right of their advance-width, into the next
@@ -426,36 +412,36 @@ FreetypeRenderer::ShapeResults::ShapeResults(
     // ink and so do not contribute to the bounding box or
     // ascent and descent.
     if (bbox.xMax > bbox.xMin && bbox.yMax > bbox.yMin) {
-      ascent = std::max(ascent, bbox.yMax / scale);
-      descent = std::min(descent, bbox.yMin / scale);
+      ascent = std::max (ascent, bbox.yMax / scale);
+      descent = std::min (descent, bbox.yMin / scale);
 
-      const double gxoff = glyph.get_x_offset();
-      const double gyoff = glyph.get_y_offset();
+      const double gxoff = glyph.get_x_offset ();
+      const double gyoff = glyph.get_y_offset ();
 
-      left = std::min(left,
-                      advance_x + gxoff + bbox.xMin / scale);
-      right = std::max(right,
-                       advance_x + gxoff + bbox.xMax / scale);
+      left = std::min (left,
+                       advance_x + gxoff + bbox.xMin / scale);
+      right = std::max (right,
+                        advance_x + gxoff + bbox.xMax / scale);
 
-      top = std::max(top,
-                     advance_y + gyoff + bbox.yMax / scale);
-      bottom = std::min(bottom,
-                        advance_y + gyoff + bbox.yMin / scale);
+      top = std::max (top,
+                      advance_y + gyoff + bbox.yMax / scale);
+      bottom = std::min (bottom,
+                         advance_y + gyoff + bbox.yMin / scale);
     }
 
-    advance_x += glyph.get_x_advance() * params.spacing;
-    advance_y += glyph.get_y_advance() * params.spacing;
+    advance_x += glyph.get_x_advance () * params.spacing;
+    advance_y += glyph.get_y_advance () * params.spacing;
   }
 
   // Right and left start out reversed.  If any ink is ever
   // contributed they will flip.  If they're still reversed,
   // there was no ink.
   if (right >= left) {
-    if (HB_DIRECTION_IS_HORIZONTAL(
-          hb_buffer_get_direction(hb_buf))) {
-      calc_offsets_horiz(params);
+    if (HB_DIRECTION_IS_HORIZONTAL (
+          hb_buffer_get_direction (hb_buf))) {
+      calc_offsets_horiz (params);
     } else {
-      calc_offsets_vert(params);
+      calc_offsets_vert (params);
     }
   } else {
     left = 0;
@@ -471,24 +457,22 @@ FreetypeRenderer::ShapeResults::ShapeResults(
   ok = true;
 }
 
-FreetypeRenderer::ShapeResults::~ShapeResults()
-{
+FreetypeRenderer::ShapeResults::~ShapeResults () {
   if (hb_buf != nullptr) {
-    hb_buffer_destroy(hb_buf);
+    hb_buffer_destroy (hb_buf);
     hb_buf = nullptr;
   }
   if (hb_ft_font != nullptr) {
-    hb_font_destroy(hb_ft_font);
+    hb_font_destroy (hb_ft_font);
     hb_ft_font = nullptr;
   }
 }
 
-FreetypeRenderer::FontMetrics::FontMetrics(
-  const FreetypeRenderer::Params& params)
-{
+FreetypeRenderer::FontMetrics::FontMetrics (
+  const FreetypeRenderer::Params &params) {
   ok = false;
 
-  const FontFacePtr face = params.get_font_face();
+  const FontFacePtr face = params.get_font_face ();
   if (!face) {
     return;
   }
@@ -497,32 +481,26 @@ FreetypeRenderer::FontMetrics::FontMetrics(
   // @ 100dpi = 100/72 pixels per point
   const FT_Size_Metrics *size_metrics = &face->face_->size->metrics;
   nominal_ascent =
-    FT_MulFix(face->face_->ascender, size_metrics->y_scale) / scale
-    * params.size;
+    FT_MulFix (face->face_->ascender, size_metrics->y_scale) / scale * params.size;
   nominal_descent =
-    FT_MulFix(face->face_->descender, size_metrics->y_scale) / scale
-    * params.size;
+    FT_MulFix (face->face_->descender, size_metrics->y_scale) / scale * params.size;
   max_ascent =
-    FT_MulFix(face->face_->bbox.yMax, size_metrics->y_scale) / scale
-    * params.size;
+    FT_MulFix (face->face_->bbox.yMax, size_metrics->y_scale) / scale * params.size;
   max_descent =
-    FT_MulFix(face->face_->bbox.yMin, size_metrics->y_scale) / scale
-    * params.size;
+    FT_MulFix (face->face_->bbox.yMin, size_metrics->y_scale) / scale * params.size;
   interline =
-    FT_MulFix(face->face_->height, size_metrics->y_scale) / scale
-    * params.size;
+    FT_MulFix (face->face_->height, size_metrics->y_scale) / scale * params.size;
   family_name = face->face_->family_name;
   style_name = face->face_->style_name;
 
   ok = true;
 }
 
-FreetypeRenderer::TextMetrics::TextMetrics(
-  const FreetypeRenderer::Params& params)
-{
+FreetypeRenderer::TextMetrics::TextMetrics (
+  const FreetypeRenderer::Params &params) {
   ok = false;
 
-  ShapeResults sr(params);
+  ShapeResults sr (params);
 
   if (!sr.ok) {
     return;
@@ -561,31 +539,30 @@ FreetypeRenderer::TextMetrics::TextMetrics(
   ok = true;
 }
 
-std::vector<std::shared_ptr<const Polygon2d>> FreetypeRenderer::render(const FreetypeRenderer::Params& params) const
-{
-  ShapeResults sr(params);
+std::vector<std::shared_ptr<const Polygon2d>> FreetypeRenderer::render (const FreetypeRenderer::Params &params) const {
+  ShapeResults sr (params);
 
   if (!sr.ok) {
     return {};
   }
 
-  DrawingCallback callback(params.segments, params.size);
-  for (const auto& glyph : sr.glyph_array) {
-    callback.start_glyph();
-    callback.set_glyph_offset(
-      sr.x_offset + glyph.get_x_offset(),
-      sr.y_offset + glyph.get_y_offset());
-    FT_Outline outline = reinterpret_cast<FT_OutlineGlyph>(glyph.get_glyph())->outline;
-    FT_Outline_Decompose(&outline, &funcs, &callback);
-
-    double adv_x = glyph.get_x_advance() * params.spacing;
-    double adv_y = glyph.get_y_advance() * params.spacing;
-    callback.add_glyph_advance(adv_x, adv_y);
-    callback.finish_glyph();
+  DrawingCallback callback (params.segments, params.size);
+  for (const auto &glyph : sr.glyph_array) {
+    callback.start_glyph ();
+    callback.set_glyph_offset (
+      sr.x_offset + glyph.get_x_offset (),
+      sr.y_offset + glyph.get_y_offset ());
+    FT_Outline outline = reinterpret_cast<FT_OutlineGlyph> (glyph.get_glyph ())->outline;
+    FT_Outline_Decompose (&outline, &funcs, &callback);
+
+    double adv_x = glyph.get_x_advance () * params.spacing;
+    double adv_y = glyph.get_y_advance () * params.spacing;
+    callback.add_glyph_advance (adv_x, adv_y);
+    callback.finish_glyph ();
   }
 
   // FIXME: The returned Polygon2d currently contains only outlines with the 'positive' flag set to true,
   // and where the winding order determines if the outlines should be interpreted as polygons or holes.
   // We have to rely on any downstream processing to be aware of the winding order, and ignore the 'positive' flag.
-  return callback.get_result();
+  return callback.get_result ();
 }
diff --git a/src/core/FreetypeRenderer.h b/src/core/FreetypeRenderer.h
index dc6a60af4..148ecb7bd 100644
--- a/src/core/FreetypeRenderer.h
+++ b/src/core/FreetypeRenderer.h
@@ -43,56 +43,56 @@ class FreetypeRenderer
 public:
   class Params
   {
-public:
-    void set_size(double size) {
+  public:
+    void set_size (double size) {
       this->size = size;
     }
-    void set_spacing(double spacing) {
+    void set_spacing (double spacing) {
       this->spacing = spacing;
     }
-    void set_fn(double fn) {
+    void set_fn (double fn) {
       this->fn = fn;
     }
-    void set_fa(double fa) {
+    void set_fa (double fa) {
       this->fa = fa;
     }
-    void set_fs(double fs) {
+    void set_fs (double fs) {
       this->fs = fs;
     }
-    void set_segments(unsigned int segments) {
+    void set_segments (unsigned int segments) {
       this->segments = segments;
     }
-    void set_text(const std::string& text) {
+    void set_text (const std::string &text) {
       this->text = text;
     }
-    void set_font(const std::string& font) {
+    void set_font (const std::string &font) {
       this->font = font;
     }
-    void set_direction(const std::string& direction) {
+    void set_direction (const std::string &direction) {
       this->direction = direction;
     }
-    void set_language(const std::string& language) {
+    void set_language (const std::string &language) {
       this->language = language;
     }
-    void set_script(const std::string& script) {
+    void set_script (const std::string &script) {
       this->script = script;
     }
-    void set_halign(const std::string& halign) {
+    void set_halign (const std::string &halign) {
       this->halign = halign;
     }
-    void set_valign(const std::string& valign) {
+    void set_valign (const std::string &valign) {
       this->valign = valign;
     }
-    void set_loc(const Location& loc) {
+    void set_loc (const Location &loc) {
       this->loc = loc;
     }
-    void set_documentPath(const std::string& path) {
+    void set_documentPath (const std::string &path) {
       this->documentPath = path;
     }
-    void set(Parameters& parameters);
-    [[nodiscard]] const FontFacePtr get_font_face() const;
-    void detect_properties();
-    friend std::ostream& operator<<(std::ostream& stream, const FreetypeRenderer::Params& params) {
+    void set (Parameters &parameters);
+    [[nodiscard]] const FontFacePtr get_font_face () const;
+    void detect_properties ();
+    friend std::ostream &operator<< (std::ostream &stream, const FreetypeRenderer::Params &params) {
       return stream
              << "text = \"" << params.text
              << "\", size = " << params.size
@@ -100,30 +100,31 @@ public:
              << ", font = \"" << params.font
              << "\", direction = \"" << params.direction
              << "\", language = \"" << params.language
-             << (params.script.empty() ? "" : "\", script = \"") << params.script
+             << (params.script.empty () ? "" : "\", script = \"") << params.script
              << "\", halign = \"" << params.halign
              << "\", valign = \"" << params.valign
              << "\", $fn = " << params.fn
              << ", $fa = " << params.fa
              << ", $fs = " << params.fs;
     }
-private:
+
+  private:
     double size, spacing, fn, fa, fs;
     unsigned int segments;
     std::string text, font, direction, language, script, halign, valign;
     Location loc = Location::NONE;
     std::string documentPath = "";
-    static bool is_ignored_script(const hb_script_t script);
-    hb_script_t detect_script(hb_glyph_info_t *glyph_info,
-                              unsigned int glyph_count) const;
-    [[nodiscard]] hb_direction_t detect_direction(const hb_script_t script) const;
+    static bool is_ignored_script (const hb_script_t script);
+    hb_script_t detect_script (hb_glyph_info_t *glyph_info,
+                               unsigned int glyph_count) const;
+    [[nodiscard]] hb_direction_t detect_direction (const hb_script_t script) const;
 
     friend class FreetypeRenderer;
   };
 
   class TextMetrics
   {
-public:
+  public:
     bool ok; // true if object is valid
     // The values here are all at their final size; they have been
     // descaled down from the 1e5 size used for Freetype, and rescaled
@@ -138,11 +139,11 @@ public:
     double descent;
     double x_offset;
     double y_offset;
-    TextMetrics(const FreetypeRenderer::Params& params);
+    TextMetrics (const FreetypeRenderer::Params &params);
   };
   class FontMetrics
   {
-public:
+  public:
     bool ok; // true if object is valid
     // The values here are all at their final size; they have been
     // descaled down from the 1e5 size used for Freetype, and rescaled
@@ -154,12 +155,13 @@ public:
     double interline;
     std::string family_name;
     std::string style_name;
-    FontMetrics(const FreetypeRenderer::Params& params);
+    FontMetrics (const FreetypeRenderer::Params &params);
   };
-  FreetypeRenderer();
-  virtual ~FreetypeRenderer() = default;
+  FreetypeRenderer ();
+  virtual ~FreetypeRenderer () = default;
+
+  [[nodiscard]] std::vector<std::shared_ptr<const class Polygon2d>> render (const FreetypeRenderer::Params &params) const;
 
-  [[nodiscard]] std::vector<std::shared_ptr<const class Polygon2d>> render(const FreetypeRenderer::Params& params) const;
 private:
   const static double scale;
   FT_Outline_Funcs funcs;
@@ -170,16 +172,34 @@ private:
   // remains valid until the GlyphData is destroyed.
   class GlyphData
   {
-public:
-    GlyphData(FT_Glyph glyph, unsigned int idx, hb_glyph_position_t *glyph_pos) : glyph(glyph), idx(idx), glyph_pos(glyph_pos) {}
-    [[nodiscard]] unsigned int get_idx() const { return idx; }
-    [[nodiscard]] FT_Glyph get_glyph() const { return glyph; }
-    [[nodiscard]] double get_x_offset() const { return glyph_pos->x_offset / scale; }
-    [[nodiscard]] double get_y_offset() const { return glyph_pos->y_offset / scale; }
-    [[nodiscard]] double get_x_advance() const { return glyph_pos->x_advance / scale; }
-    [[nodiscard]] double get_y_advance() const { return glyph_pos->y_advance / scale; }
-    ~GlyphData() { FT_Done_Glyph(glyph); }
-private:
+  public:
+    GlyphData (FT_Glyph glyph, unsigned int idx, hb_glyph_position_t *glyph_pos)
+      : glyph (glyph)
+      , idx (idx)
+      , glyph_pos (glyph_pos) {}
+    [[nodiscard]] unsigned int get_idx () const {
+      return idx;
+    }
+    [[nodiscard]] FT_Glyph get_glyph () const {
+      return glyph;
+    }
+    [[nodiscard]] double get_x_offset () const {
+      return glyph_pos->x_offset / scale;
+    }
+    [[nodiscard]] double get_y_offset () const {
+      return glyph_pos->y_offset / scale;
+    }
+    [[nodiscard]] double get_x_advance () const {
+      return glyph_pos->x_advance / scale;
+    }
+    [[nodiscard]] double get_y_advance () const {
+      return glyph_pos->y_advance / scale;
+    }
+    ~GlyphData () {
+      FT_Done_Glyph (glyph);
+    }
+
+  private:
     FT_Glyph glyph;
     unsigned int idx;
     hb_glyph_position_t *glyph_pos;
@@ -187,7 +207,7 @@ private:
 
   class ShapeResults
   {
-public:
+  public:
     bool ok{false}; // true if object is valid
     // The values here are all in fractions of the specified size.
     // They have been downscaled from the 1e+5 unit size used for
@@ -204,17 +224,18 @@ public:
     double advance_y{0.0};
     double ascent{0.0};
     double descent{0.0};
-    ShapeResults(const FreetypeRenderer::Params& params);
-    virtual ~ShapeResults();
-private:
-    void calc_offsets_horiz(const FreetypeRenderer::Params& params);
-    void calc_offsets_vert(const FreetypeRenderer::Params& params);
+    ShapeResults (const FreetypeRenderer::Params &params);
+    virtual ~ShapeResults ();
+
+  private:
+    void calc_offsets_horiz (const FreetypeRenderer::Params &params);
+    void calc_offsets_vert (const FreetypeRenderer::Params &params);
     hb_font_t *hb_ft_font{nullptr};
     hb_buffer_t *hb_buf{nullptr};
   };
 
-  static int outline_move_to_func(const FT_Vector *to, void *user);
-  static int outline_line_to_func(const FT_Vector *to, void *user);
-  static int outline_conic_to_func(const FT_Vector *c1, const FT_Vector *to, void *user);
-  static int outline_cubic_to_func(const FT_Vector *c1, const FT_Vector *c2, const FT_Vector *to, void *user);
+  static int outline_move_to_func (const FT_Vector *to, void *user);
+  static int outline_line_to_func (const FT_Vector *to, void *user);
+  static int outline_conic_to_func (const FT_Vector *c1, const FT_Vector *to, void *user);
+  static int outline_cubic_to_func (const FT_Vector *c1, const FT_Vector *c2, const FT_Vector *to, void *user);
 };
diff --git a/src/core/FunctionType.cc b/src/core/FunctionType.cc
index 71724e652..d1140ed00 100644
--- a/src/core/FunctionType.cc
+++ b/src/core/FunctionType.cc
@@ -4,36 +4,35 @@
 #include "core/Value.h"
 #include "core/Expression.h"
 
-Value FunctionType::operator==(const FunctionType& other) const {
+Value FunctionType::operator== (const FunctionType &other) const {
   return this == &other;
 }
-Value FunctionType::operator!=(const FunctionType& other) const {
+Value FunctionType::operator!= (const FunctionType &other) const {
   return this != &other;
 }
-Value FunctionType::operator<(const FunctionType& /*other*/) const {
-  return Value::undef("operation undefined (function < function)");
+Value FunctionType::operator< (const FunctionType & /*other*/) const {
+  return Value::undef ("operation undefined (function < function)");
 }
-Value FunctionType::operator>(const FunctionType& /*other*/) const {
-  return Value::undef("operation undefined (function > function)");
+Value FunctionType::operator> (const FunctionType & /*other*/) const {
+  return Value::undef ("operation undefined (function > function)");
 }
-Value FunctionType::operator<=(const FunctionType& /*other*/) const {
-  return Value::undef("operation undefined (function <= function)");
+Value FunctionType::operator<= (const FunctionType & /*other*/) const {
+  return Value::undef ("operation undefined (function <= function)");
 }
-Value FunctionType::operator>=(const FunctionType& /*other*/) const {
-  return Value::undef("operation undefined (function >= function)");
+Value FunctionType::operator>= (const FunctionType & /*other*/) const {
+  return Value::undef ("operation undefined (function >= function)");
 }
 
-std::ostream& operator<<(std::ostream& stream, const FunctionType& f)
-{
+std::ostream &operator<< (std::ostream &stream, const FunctionType &f) {
   stream << "function(";
   bool first = true;
-  for (const auto& parameter : *(f.getParameters())) {
-    stream << (first ? "" : ", ") << parameter->getName();
-    if (parameter->getExpr()) {
-      stream << " = " << *parameter->getExpr();
+  for (const auto &parameter : *(f.getParameters ())) {
+    stream << (first ? "" : ", ") << parameter->getName ();
+    if (parameter->getExpr ()) {
+      stream << " = " << *parameter->getExpr ();
     }
     first = false;
   }
-  stream << ") " << *f.getExpr();
+  stream << ") " << *f.getExpr ();
   return stream;
 }
diff --git a/src/core/FunctionType.h b/src/core/FunctionType.h
index bed08fa94..56c30ed94 100644
--- a/src/core/FunctionType.h
+++ b/src/core/FunctionType.h
@@ -13,22 +13,31 @@ class Value;
 class FunctionType
 {
 public:
-  FunctionType(std::shared_ptr<const Context> context, std::shared_ptr<Expression> expr, std::shared_ptr<AssignmentList> parameters)
-    : context(std::move(context)), expr(std::move(expr)), parameters(std::move(parameters)) { }
-  Value operator==(const FunctionType& other) const;
-  Value operator!=(const FunctionType& other) const;
-  Value operator<(const FunctionType& other) const;
-  Value operator>(const FunctionType& other) const;
-  Value operator<=(const FunctionType& other) const;
-  Value operator>=(const FunctionType& other) const;
+  FunctionType (std::shared_ptr<const Context> context, std::shared_ptr<Expression> expr, std::shared_ptr<AssignmentList> parameters)
+    : context (std::move (context))
+    , expr (std::move (expr))
+    , parameters (std::move (parameters)) {}
+  Value operator== (const FunctionType &other) const;
+  Value operator!= (const FunctionType &other) const;
+  Value operator< (const FunctionType &other) const;
+  Value operator> (const FunctionType &other) const;
+  Value operator<= (const FunctionType &other) const;
+  Value operator>= (const FunctionType &other) const;
+
+  [[nodiscard]] const std::shared_ptr<const Context> &getContext () const {
+    return context;
+  }
+  [[nodiscard]] const std::shared_ptr<Expression> &getExpr () const {
+    return expr;
+  }
+  [[nodiscard]] const std::shared_ptr<AssignmentList> &getParameters () const {
+    return parameters;
+  }
 
-  [[nodiscard]] const std::shared_ptr<const Context>& getContext() const { return context; }
-  [[nodiscard]] const std::shared_ptr<Expression>& getExpr() const { return expr; }
-  [[nodiscard]] const std::shared_ptr<AssignmentList>& getParameters() const { return parameters; }
 private:
   std::shared_ptr<const Context> context;
   std::shared_ptr<Expression> expr;
   std::shared_ptr<AssignmentList> parameters;
 };
 
-std::ostream& operator<<(std::ostream& stream, const FunctionType& f);
+std::ostream &operator<< (std::ostream &stream, const FunctionType &f);
diff --git a/src/core/GroupModule.cc b/src/core/GroupModule.cc
index 91f261abe..37ef0e6f4 100644
--- a/src/core/GroupModule.cc
+++ b/src/core/GroupModule.cc
@@ -32,16 +32,14 @@
 #include "core/Children.h"
 #include "core/Parameters.h"
 
-std::shared_ptr<AbstractNode> builtin_group(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {});
-  return children.instantiate(std::make_shared<GroupNode>(inst));
+std::shared_ptr<AbstractNode> builtin_group (const ModuleInstantiation *inst, Arguments arguments, const Children &children) {
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (), {});
+  return children.instantiate (std::make_shared<GroupNode> (inst));
 }
 
-void register_builtin_group()
-{
-  Builtins::init("group", new BuiltinModule(builtin_group),
-  {
-    "group",
-  });
+void register_builtin_group () {
+  Builtins::init ("group", new BuiltinModule (builtin_group),
+                  {
+                    "group",
+                  });
 }
diff --git a/src/core/ImportNode.cc b/src/core/ImportNode.cc
index 7ea933038..f1778f8ad 100644
--- a/src/core/ImportNode.cc
+++ b/src/core/ImportNode.cc
@@ -56,126 +56,134 @@ namespace fs = std::filesystem;
 #include <boost/assign/std/vector.hpp>
 using namespace boost::assign; // bring 'operator+=()' into scope
 
+static std::shared_ptr<AbstractNode> do_import (const ModuleInstantiation *inst, Arguments arguments, ImportType type) {
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (),
+                                             {"file", "layer", "convexity", "origin", "scale"},
+                                             {"width", "height", "filename", "layername", "center", "dpi", "id"});
 
-static std::shared_ptr<AbstractNode> do_import(const ModuleInstantiation *inst, Arguments arguments, ImportType type)
-{
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(),
-                                            {"file", "layer", "convexity", "origin", "scale"},
-                                            {"width", "height", "filename", "layername", "center", "dpi", "id"}
-                                            );
-
-  const auto& v = parameters["file"];
+  const auto &v = parameters["file"];
   std::string filename;
-  if (v.isDefined()) {
-    filename = lookup_file(v.isUndefined() ? "" : v.toString(), inst->location().filePath().parent_path().string(), parameters.documentRoot());
+  if (v.isDefined ()) {
+    filename = lookup_file (v.isUndefined () ? "" : v.toString (), inst->location ().filePath ().parent_path ().string (), parameters.documentRoot ());
   } else {
-    const auto& filename_val = parameters["filename"];
-    if (!filename_val.isUndefined()) {
-      LOG(message_group::Deprecated, "filename= is deprecated. Please use file=");
+    const auto &filename_val = parameters["filename"];
+    if (!filename_val.isUndefined ()) {
+      LOG (message_group::Deprecated, "filename= is deprecated. Please use file=");
     }
-    filename = lookup_file(filename_val.isUndefined() ? "" : filename_val.toString(), inst->location().filePath().parent_path().string(), parameters.documentRoot());
+    filename = lookup_file (filename_val.isUndefined () ? "" : filename_val.toString (), inst->location ().filePath ().parent_path ().string (), parameters.documentRoot ());
   }
-  if (!filename.empty()) handle_dep(filename);
+  if (!filename.empty ())
+    handle_dep (filename);
   ImportType actualtype = type;
   if (actualtype == ImportType::UNKNOWN) {
-    std::string extraw = fs::path(filename).extension().generic_string();
-    std::string ext = boost::algorithm::to_lower_copy(extraw);
-    if (ext == ".stl") actualtype = ImportType::STL;
-    else if (ext == ".off") actualtype = ImportType::OFF;
-    else if (ext == ".dxf") actualtype = ImportType::DXF;
-    else if (ext == ".nef3") actualtype = ImportType::NEF3;
-    else if (ext == ".3mf") actualtype = ImportType::_3MF;
-    else if (ext == ".amf") actualtype = ImportType::AMF;
-    else if (ext == ".svg") actualtype = ImportType::SVG;
-    else if (ext == ".obj") actualtype = ImportType::OBJ;
+    std::string extraw = fs::path (filename).extension ().generic_string ();
+    std::string ext = boost::algorithm::to_lower_copy (extraw);
+    if (ext == ".stl")
+      actualtype = ImportType::STL;
+    else if (ext == ".off")
+      actualtype = ImportType::OFF;
+    else if (ext == ".dxf")
+      actualtype = ImportType::DXF;
+    else if (ext == ".nef3")
+      actualtype = ImportType::NEF3;
+    else if (ext == ".3mf")
+      actualtype = ImportType::_3MF;
+    else if (ext == ".amf")
+      actualtype = ImportType::AMF;
+    else if (ext == ".svg")
+      actualtype = ImportType::SVG;
+    else if (ext == ".obj")
+      actualtype = ImportType::OBJ;
   }
 
-  auto node = std::make_shared<ImportNode>(inst, actualtype);
+  auto node = std::make_shared<ImportNode> (inst, actualtype);
 
-  node->fn = parameters["$fn"].toDouble();
-  node->fs = parameters["$fs"].toDouble();
-  node->fa = parameters["$fa"].toDouble();
+  node->fn = parameters["$fn"].toDouble ();
+  node->fs = parameters["$fs"].toDouble ();
+  node->fa = parameters["$fa"].toDouble ();
 
   node->filename = filename;
-  const auto& layerval = parameters["layer"];
-  if (layerval.isDefined()) {
-    node->layer = layerval.toString();
+  const auto &layerval = parameters["layer"];
+  if (layerval.isDefined ()) {
+    node->layer = layerval.toString ();
   } else {
-    const auto& layername = parameters["layername"];
-    if (layername.isDefined()) {
-      LOG(message_group::Deprecated, "layername= is deprecated. Please use layer=");
-      node->layer = layername.toString();
+    const auto &layername = parameters["layername"];
+    if (layername.isDefined ()) {
+      LOG (message_group::Deprecated, "layername= is deprecated. Please use layer=");
+      node->layer = layername.toString ();
     }
   }
-  const auto& idval = parameters["id"];
-  if (idval.isDefined()) {
-    node->id = idval.toString();
+  const auto &idval = parameters["id"];
+  if (idval.isDefined ()) {
+    node->id = idval.toString ();
   }
-  node->convexity = (int)parameters["convexity"].toDouble();
+  node->convexity = (int)parameters["convexity"].toDouble ();
 
-  if (node->convexity <= 0) node->convexity = 1;
+  if (node->convexity <= 0)
+    node->convexity = 1;
 
-  const auto& origin = parameters["origin"];
+  const auto &origin = parameters["origin"];
   node->origin_x = node->origin_y = 0;
-  bool originOk = origin.getVec2(node->origin_x, node->origin_y);
-  originOk &= std::isfinite(node->origin_x) && std::isfinite(node->origin_y);
-  if (origin.isDefined() && !originOk) {
-    LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Unable to convert import(..., origin=%1$s) parameter to vec2", origin.toEchoStringNoThrow());
+  bool originOk = origin.getVec2 (node->origin_x, node->origin_y);
+  originOk &= std::isfinite (node->origin_x) && std::isfinite (node->origin_y);
+  if (origin.isDefined () && !originOk) {
+    LOG (message_group::Warning, inst->location (), parameters.documentRoot (), "Unable to convert import(..., origin=%1$s) parameter to vec2", origin.toEchoStringNoThrow ());
   }
 
-  const auto& center = parameters["center"];
-  node->center = center.type() == Value::Type::BOOL ? center.toBool() : false;
+  const auto &center = parameters["center"];
+  node->center = center.type () == Value::Type::BOOL ? center.toBool () : false;
 
-  node->scale = parameters["scale"].toDouble();
-  if (node->scale <= 0) node->scale = 1;
+  node->scale = parameters["scale"].toDouble ();
+  if (node->scale <= 0)
+    node->scale = 1;
 
   node->dpi = ImportNode::SVG_DEFAULT_DPI;
-  const auto& dpi = parameters["dpi"];
-  if (dpi.type() == Value::Type::NUMBER) {
-    double val = dpi.toDouble();
+  const auto &dpi = parameters["dpi"];
+  if (dpi.type () == Value::Type::NUMBER) {
+    double val = dpi.toDouble ();
     if (val < 0.001) {
-      std::string filePath = fs_uncomplete(inst->location().filePath(), parameters.documentRoot()).generic_string();
-      LOG(message_group::Warning,
-          "Invalid dpi value giving, using default of %1$f dpi. Value must be positive and >= 0.001, file %2$s, import() at line %3$d",
-          origin.toEchoStringNoThrow(), filePath, filePath, inst->location().firstLine()
-          );
+      std::string filePath = fs_uncomplete (inst->location ().filePath (), parameters.documentRoot ()).generic_string ();
+      LOG (message_group::Warning,
+           "Invalid dpi value giving, using default of %1$f dpi. Value must be positive and >= 0.001, file %2$s, import() at line %3$d",
+           origin.toEchoStringNoThrow (), filePath, filePath, inst->location ().firstLine ());
     } else {
       node->dpi = val;
     }
   }
 
-  node->width = parameters.get("width", -1);
-  node->height = parameters.get("height", -1);
+  node->width = parameters.get ("width", -1);
+  node->height = parameters.get ("height", -1);
 
   return node;
 }
 
-static std::shared_ptr<AbstractNode> builtin_import(const ModuleInstantiation *inst, Arguments arguments)
-{ return do_import(inst, std::move(arguments), ImportType::UNKNOWN); }
+static std::shared_ptr<AbstractNode> builtin_import (const ModuleInstantiation *inst, Arguments arguments) {
+  return do_import (inst, std::move (arguments), ImportType::UNKNOWN);
+}
 
 template <typename T>
-static std::unique_ptr<T> optionally_center(std::unique_ptr<T> g, bool center) {
+static std::unique_ptr<T> optionally_center (std::unique_ptr<T> g, bool center) {
   if (center) {
-    auto bbox = g->getBoundingBox();
-    auto center = bbox.center();
+    auto bbox = g->getBoundingBox ();
+    auto center = bbox.center ();
 
-    if constexpr (std::is_same_v<T, Polygon2d> ) {
-      auto mat = Transform2d::Identity();
-      auto translate = mat.translation();
+    if constexpr (std::is_same_v<T, Polygon2d>) {
+      auto mat = Transform2d::Identity ();
+      auto translate = mat.translation ();
 
-      translate.x() = -center.x();
-      translate.y() = -center.y();
+      translate.x () = -center.x ();
+      translate.y () = -center.y ();
 
-      g->transform(mat);
+      g->transform (mat);
     } else {
-      auto mat = Transform3d::Identity();
-      auto translate = mat.translation();
+      auto mat = Transform3d::Identity ();
+      auto translate = mat.translation ();
 
-      translate.x() = -center.x();
-      translate.y() = -center.y();
-      translate.z() = -center.z();
+      translate.x () = -center.x ();
+      translate.y () = -center.y ();
+      translate.z () = -center.z ();
 
-      g->transform(mat);
+      g->transform (mat);
     }
   }
 
@@ -185,68 +193,66 @@ static std::unique_ptr<T> optionally_center(std::unique_ptr<T> g, bool center) {
 /*!
    Will return an empty geometry if the import failed, but not nullptr
  */
-std::unique_ptr<const Geometry> ImportNode::createGeometry() const
-{
+std::unique_ptr<const Geometry> ImportNode::createGeometry () const {
   std::unique_ptr<Geometry> g;
-  auto loc = this->modinst->location();
+  auto loc = this->modinst->location ();
 
   switch (this->type) {
   case ImportType::STL: {
-    g = optionally_center(import_stl(this->filename, loc), this->center);
+    g = optionally_center (import_stl (this->filename, loc), this->center);
     break;
   }
   case ImportType::AMF: {
-    g = optionally_center(import_amf(this->filename, loc), this->center);
+    g = optionally_center (import_amf (this->filename, loc), this->center);
     break;
   }
   case ImportType::_3MF: {
-    g = optionally_center(import_3mf(this->filename, loc), this->center);
+    g = optionally_center (import_3mf (this->filename, loc), this->center);
     break;
   }
   case ImportType::OFF: {
-    g = optionally_center(import_off(this->filename, loc), this->center);
+    g = optionally_center (import_off (this->filename, loc), this->center);
     break;
   }
   case ImportType::OBJ: {
-    g = optionally_center(import_obj(this->filename, loc), this->center);
+    g = optionally_center (import_obj (this->filename, loc), this->center);
     break;
   }
   case ImportType::SVG: {
-    g = import_svg(this->fn, this->fs, this->fa, this->filename, this->id, this->layer, this->dpi, this->center, loc);
+    g = import_svg (this->fn, this->fs, this->fa, this->filename, this->id, this->layer, this->dpi, this->center, loc);
     break;
   }
   case ImportType::DXF: {
-    DxfData dd(this->fn, this->fs, this->fa, this->filename, this->layer.value_or(""), this->origin_x, this->origin_y, this->scale);
-    g = optionally_center(dd.toPolygon2d(), this->center);
+    DxfData dd (this->fn, this->fs, this->fa, this->filename, this->layer.value_or (""), this->origin_x, this->origin_y, this->scale);
+    g = optionally_center (dd.toPolygon2d (), this->center);
     break;
   }
 #ifdef ENABLE_CGAL
   case ImportType::NEF3: {
-    g = import_nef3(this->filename, loc);
+    g = import_nef3 (this->filename, loc);
     break;
   }
 #endif
   default:
-    LOG(message_group::Error, "Unsupported file format while trying to import file '%1$s', import() at line %2$d", this->filename, loc.firstLine());
-    g = PolySet::createEmpty();
+    LOG (message_group::Error, "Unsupported file format while trying to import file '%1$s', import() at line %2$d", this->filename, loc.firstLine ());
+    g = PolySet::createEmpty ();
   }
 
-  g->setConvexity(this->convexity);
+  g->setConvexity (this->convexity);
   return g;
 }
 
-std::string ImportNode::toString() const
-{
+std::string ImportNode::toString () const {
   std::ostringstream stream;
-  fs::path path((std::string)this->filename);
+  fs::path path ((std::string)this->filename);
 
-  stream << this->name();
+  stream << this->name ();
   stream << "(file = " << this->filename;
   if (this->id) {
-    stream << ", id = " << QuotedString(this->id.get());
+    stream << ", id = " << QuotedString (this->id.get ());
   }
   if (this->layer) {
-    stream << ", layer = " << QuotedString(this->layer.get());
+    stream << ", layer = " << QuotedString (this->layer.get ());
   }
   stream << ", origin = [" << std::dec << this->origin_x << ", " << this->origin_y << "]";
   if (this->type == ImportType::SVG) {
@@ -256,21 +262,19 @@ std::string ImportNode::toString() const
          << ", center = " << (this->center ? "true" : "false")
          << ", convexity = " << this->convexity
          << ", $fn = " << this->fn << ", $fa = " << this->fa << ", $fs = " << this->fs
-         << ", timestamp = " << fs_timestamp(path)
+         << ", timestamp = " << fs_timestamp (path)
          << ")";
 
-  return stream.str();
+  return stream.str ();
 }
 
-std::string ImportNode::name() const
-{
+std::string ImportNode::name () const {
   return "import";
 }
 
-void register_builtin_import()
-{
-  Builtins::init("import", new BuiltinModule(builtin_import),
-  {
-    "import(string, [number, [number]])",
-  });
+void register_builtin_import () {
+  Builtins::init ("import", new BuiltinModule (builtin_import),
+                  {
+                    "import(string, [number, [number]])",
+                  });
 }
diff --git a/src/core/ImportNode.h b/src/core/ImportNode.h
index 1e2caf0f3..9b6f96541 100644
--- a/src/core/ImportNode.h
+++ b/src/core/ImportNode.h
@@ -25,10 +25,12 @@ class ImportNode : public LeafNode
 public:
   constexpr static double SVG_DEFAULT_DPI = 72.0;
 
-  VISITABLE();
-  ImportNode(const ModuleInstantiation *mi, ImportType type) : LeafNode(mi), type(type) { }
-  std::string toString() const override;
-  std::string name() const override;
+  VISITABLE ();
+  ImportNode (const ModuleInstantiation *mi, ImportType type)
+    : LeafNode (mi)
+    , type (type) {}
+  std::string toString () const override;
+  std::string name () const override;
 
   ImportType type;
   Filename filename;
@@ -40,5 +42,5 @@ public:
   double fn, fs, fa;
   double origin_x, origin_y, scale;
   double width, height;
-  std::unique_ptr<const class Geometry> createGeometry() const override;
+  std::unique_ptr<const class Geometry> createGeometry () const override;
 };
diff --git a/src/core/IndicatorData.h b/src/core/IndicatorData.h
index d8926892a..b47107d5b 100644
--- a/src/core/IndicatorData.h
+++ b/src/core/IndicatorData.h
@@ -4,12 +4,14 @@
 #include <utility>
 #include <utility>
 
-struct IndicatorData
-{
-  IndicatorData(int firstLine, int firstCol, int lastLine, int lastCol,
-                std::string path)
-    : first_line(firstLine), first_col(firstCol), last_line(lastLine),
-    last_col(lastCol), path(std::move(path)) {
+struct IndicatorData {
+  IndicatorData (int firstLine, int firstCol, int lastLine, int lastCol,
+                 std::string path)
+    : first_line (firstLine)
+    , first_col (firstCol)
+    , last_line (lastLine)
+    , last_col (lastCol)
+    , path (std::move (path)) {
   }
 
   int first_line;
diff --git a/src/core/LinearExtrudeNode.cc b/src/core/LinearExtrudeNode.cc
index 2a58b7710..b7333cac0 100644
--- a/src/core/LinearExtrudeNode.cc
+++ b/src/core/LinearExtrudeNode.cc
@@ -45,76 +45,78 @@ using namespace boost::assign; // bring 'operator+=()' into scope
 #include <filesystem>
 
 namespace {
-std::shared_ptr<AbstractNode> builtin_linear_extrude(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  auto node = std::make_shared<LinearExtrudeNode>(inst);
+std::shared_ptr<AbstractNode> builtin_linear_extrude (const ModuleInstantiation *inst, Arguments arguments, const Children &children) {
+  auto node = std::make_shared<LinearExtrudeNode> (inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(),
-                                            {"height", "v", "scale", "center", "twist", "slices", "segments"},
-                                            {"convexity", "h"});
-  parameters.set_caller("linear_extrude");
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (),
+                                             {"height", "v", "scale", "center", "twist", "slices", "segments"},
+                                             {"convexity", "h"});
+  parameters.set_caller ("linear_extrude");
 
-  node->fn = parameters["$fn"].toDouble();
-  node->fs = parameters["$fs"].toDouble();
-  node->fa = parameters["$fa"].toDouble();
+  node->fn = parameters["$fn"].toDouble ();
+  node->fs = parameters["$fs"].toDouble ();
+  node->fa = parameters["$fa"].toDouble ();
 
   double height = 100.0;
 
-  if (parameters["v"].isDefined()) {
-    if (!parameters["v"].getVec3(node->height[0], node->height[1], node->height[2])) {
-      LOG(message_group::Error, "v when specified should be a 3d vector.");
+  if (parameters["v"].isDefined ()) {
+    if (!parameters["v"].getVec3 (node->height[0], node->height[1], node->height[2])) {
+      LOG (message_group::Error, "v when specified should be a 3d vector.");
     }
     height = 1.0;
   }
-  const Value& heightValue = parameters[{"height", "h"}];
-  if (heightValue.isDefined()) {
-    if (!heightValue.getFiniteDouble(height)) {
-      LOG(message_group::Error, "height when specified should be a number.");
+  const Value &heightValue = parameters[{"height", "h"}];
+  if (heightValue.isDefined ()) {
+    if (!heightValue.getFiniteDouble (height)) {
+      LOG (message_group::Error, "height when specified should be a number.");
       height = 100.0;
     }
-    node->height.normalize();
+    node->height.normalize ();
   }
   node->height *= height;
 
-  parameters["convexity"].getPositiveInt(node->convexity);
+  parameters["convexity"].getPositiveInt (node->convexity);
 
   node->scale_x = node->scale_y = 1;
-  bool scaleOK = parameters["scale"].getFiniteDouble(node->scale_x);
-  scaleOK &= parameters["scale"].getFiniteDouble(node->scale_y);
-  scaleOK |= parameters["scale"].getVec2(node->scale_x, node->scale_y, true);
-  if ((parameters["scale"].isDefined()) && (!scaleOK || !std::isfinite(node->scale_x) || !std::isfinite(node->scale_y))) {
-    LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "linear_extrude(..., scale=%1$s) could not be converted", parameters["scale"].toEchoStringNoThrow());
+  bool scaleOK = parameters["scale"].getFiniteDouble (node->scale_x);
+  scaleOK &= parameters["scale"].getFiniteDouble (node->scale_y);
+  scaleOK |= parameters["scale"].getVec2 (node->scale_x, node->scale_y, true);
+  if ((parameters["scale"].isDefined ()) && (!scaleOK || !std::isfinite (node->scale_x) || !std::isfinite (node->scale_y))) {
+    LOG (message_group::Warning, inst->location (), parameters.documentRoot (), "linear_extrude(..., scale=%1$s) could not be converted", parameters["scale"].toEchoStringNoThrow ());
   }
 
-  if (parameters["center"].type() == Value::Type::BOOL) node->center = parameters["center"].toBool();
+  if (parameters["center"].type () == Value::Type::BOOL)
+    node->center = parameters["center"].toBool ();
 
-  if (node->height[2] <= 0) node->height[2] = 0;
+  if (node->height[2] <= 0)
+    node->height[2] = 0;
 
-  if (node->scale_x < 0) node->scale_x = 0;
-  if (node->scale_y < 0) node->scale_y = 0;
+  if (node->scale_x < 0)
+    node->scale_x = 0;
+  if (node->scale_y < 0)
+    node->scale_y = 0;
 
-  node->has_slices = parameters.validate_integral("slices", node->slices, 1u);
-  node->has_segments = parameters.validate_integral("segments", node->segments, 0u);
+  node->has_slices = parameters.validate_integral ("slices", node->slices, 1u);
+  node->has_segments = parameters.validate_integral ("segments", node->segments, 0u);
 
   node->twist = 0.0;
-  parameters["twist"].getFiniteDouble(node->twist);
+  parameters["twist"].getFiniteDouble (node->twist);
   if (node->twist != 0.0) {
     node->has_twist = true;
   }
 
-  children.instantiate(node);
+  children.instantiate (node);
 
   return node;
 }
 
 } // namespace
 
-std::string LinearExtrudeNode::toString() const
-{
+std::string LinearExtrudeNode::toString () const {
   std::ostringstream stream;
 
-  stream << this->name() << "(";
-  double height = this->height.norm();
+  stream << this->name () << "(";
+  double height = this->height.norm ();
   stream << "height = " << height;
   if (height > 0) {
     Vector3d v = this->height / height;
@@ -148,13 +150,12 @@ std::string LinearExtrudeNode::toString() const
     stream << ", convexity = " << this->convexity;
   }
   stream << ")";
-  return stream.str();
+  return stream.str ();
 }
 
-void register_builtin_linear_extrude()
-{
-  Builtins::init("linear_extrude", new BuiltinModule(builtin_linear_extrude),
-  {
-    "linear_extrude(height = 100, center = false, convexity = 1, twist = 0, scale = 1.0, [slices, segments, v, $fn, $fs, $fa])",
-  });
+void register_builtin_linear_extrude () {
+  Builtins::init ("linear_extrude", new BuiltinModule (builtin_linear_extrude),
+                  {
+                    "linear_extrude(height = 100, center = false, convexity = 1, twist = 0, scale = 1.0, [slices, segments, v, $fn, $fs, $fa])",
+                  });
 }
diff --git a/src/core/LinearExtrudeNode.h b/src/core/LinearExtrudeNode.h
index 1caf2a9a7..b2eca2c9d 100644
--- a/src/core/LinearExtrudeNode.h
+++ b/src/core/LinearExtrudeNode.h
@@ -10,13 +10,16 @@
 class LinearExtrudeNode : public AbstractPolyNode
 {
 public:
-  VISITABLE();
-  LinearExtrudeNode(const ModuleInstantiation *mi) : AbstractPolyNode(mi) {
+  VISITABLE ();
+  LinearExtrudeNode (const ModuleInstantiation *mi)
+    : AbstractPolyNode (mi) {
+  }
+  std::string toString () const override;
+  std::string name () const override {
+    return "linear_extrude";
   }
-  std::string toString() const override;
-  std::string name() const override { return "linear_extrude"; }
 
-  Vector3d height = Vector3d(0, 0, 1);
+  Vector3d height = Vector3d (0, 0, 1);
   double fn = 0.0, fs = 0.0, fa = 0.0;
   double scale_x = 1.0, scale_y = 1.0;
   double twist = 0.0;
diff --git a/src/core/LocalScope.cc b/src/core/LocalScope.cc
index bf5cdf8d3..9bb7328b5 100644
--- a/src/core/LocalScope.cc
+++ b/src/core/LocalScope.cc
@@ -13,69 +13,66 @@
 #include "core/function.h"
 #include "core/node.h"
 
-void LocalScope::addModuleInst(const std::shared_ptr<ModuleInstantiation>& modinst)
-{
-  assert(modinst);
-  this->moduleInstantiations.push_back(modinst);
+void LocalScope::addModuleInst (const std::shared_ptr<ModuleInstantiation> &modinst) {
+  assert (modinst);
+  this->moduleInstantiations.push_back (modinst);
 }
 
-void LocalScope::addModule(const std::shared_ptr<class UserModule>& module)
-{
-  assert(module);
-  auto it = this->modules.find(module->name);
-  if (it != this->modules.end()) it->second = module;
-  else this->modules.emplace(module->name, module);
-  this->astModules.emplace_back(module->name, module);
+void LocalScope::addModule (const std::shared_ptr<class UserModule> &module) {
+  assert (module);
+  auto it = this->modules.find (module->name);
+  if (it != this->modules.end ())
+    it->second = module;
+  else
+    this->modules.emplace (module->name, module);
+  this->astModules.emplace_back (module->name, module);
 }
 
-void LocalScope::addFunction(const std::shared_ptr<class UserFunction>& func)
-{
-  assert(func);
-  auto it = this->functions.find(func->name);
-  if (it != this->functions.end()) it->second = func;
-  else this->functions.emplace(func->name, func);
-  this->astFunctions.emplace_back(func->name, func);
+void LocalScope::addFunction (const std::shared_ptr<class UserFunction> &func) {
+  assert (func);
+  auto it = this->functions.find (func->name);
+  if (it != this->functions.end ())
+    it->second = func;
+  else
+    this->functions.emplace (func->name, func);
+  this->astFunctions.emplace_back (func->name, func);
 }
 
-void LocalScope::addAssignment(const std::shared_ptr<Assignment>& assignment)
-{
-  this->assignments.push_back(assignment);
+void LocalScope::addAssignment (const std::shared_ptr<Assignment> &assignment) {
+  this->assignments.push_back (assignment);
 }
 
-void LocalScope::print(std::ostream& stream, const std::string& indent, const bool inlined) const
-{
-  for (const auto& f : this->astFunctions) {
-    f.second->print(stream, indent);
+void LocalScope::print (std::ostream &stream, const std::string &indent, const bool inlined) const {
+  for (const auto &f : this->astFunctions) {
+    f.second->print (stream, indent);
   }
-  for (const auto& m : this->astModules) {
-    m.second->print(stream, indent);
+  for (const auto &m : this->astModules) {
+    m.second->print (stream, indent);
   }
-  for (const auto& assignment : this->assignments) {
-    assignment->print(stream, indent);
+  for (const auto &assignment : this->assignments) {
+    assignment->print (stream, indent);
   }
-  for (const auto& inst : this->moduleInstantiations) {
-    inst->print(stream, indent, inlined);
+  for (const auto &inst : this->moduleInstantiations) {
+    inst->print (stream, indent, inlined);
   }
 }
 
-std::shared_ptr<AbstractNode> LocalScope::instantiateModules(const std::shared_ptr<const Context>& context, const std::shared_ptr<AbstractNode>& target) const
-{
-  for (const auto& modinst : this->moduleInstantiations) {
-    auto node = modinst->evaluate(context);
+std::shared_ptr<AbstractNode> LocalScope::instantiateModules (const std::shared_ptr<const Context> &context, const std::shared_ptr<AbstractNode> &target) const {
+  for (const auto &modinst : this->moduleInstantiations) {
+    auto node = modinst->evaluate (context);
     if (node) {
-      target->children.push_back(node);
+      target->children.push_back (node);
     }
   }
   return target;
 }
 
-std::shared_ptr<AbstractNode> LocalScope::instantiateModules(const std::shared_ptr<const Context>& context, const std::shared_ptr<AbstractNode>& target, const std::vector<size_t>& indices) const
-{
+std::shared_ptr<AbstractNode> LocalScope::instantiateModules (const std::shared_ptr<const Context> &context, const std::shared_ptr<AbstractNode> &target, const std::vector<size_t> &indices) const {
   for (size_t index : indices) {
-    assert(index < this->moduleInstantiations.size());
-    auto node = moduleInstantiations[index]->evaluate(context);
+    assert (index < this->moduleInstantiations.size ());
+    auto node = moduleInstantiations[index]->evaluate (context);
     if (node) {
-      target->children.push_back(node);
+      target->children.push_back (node);
     }
   }
   return target;
diff --git a/src/core/LocalScope.h b/src/core/LocalScope.h
index bd7c66aae..f329f3504 100644
--- a/src/core/LocalScope.h
+++ b/src/core/LocalScope.h
@@ -15,15 +15,19 @@ class Context;
 class LocalScope
 {
 public:
-  size_t numElements() const { return assignments.size() + moduleInstantiations.size(); }
-  void print(std::ostream& stream, const std::string& indent, const bool inlined = false) const;
-  std::shared_ptr<AbstractNode> instantiateModules(const std::shared_ptr<const Context>& context, const std::shared_ptr<AbstractNode>& target) const;
-  std::shared_ptr<AbstractNode> instantiateModules(const std::shared_ptr<const Context>& context, const std::shared_ptr<AbstractNode>& target, const std::vector<size_t>& indices) const;
-  void addModuleInst(const std::shared_ptr<class ModuleInstantiation>& modinst);
-  void addModule(const std::shared_ptr<class UserModule>& module);
-  void addFunction(const std::shared_ptr<class UserFunction>& function);
-  void addAssignment(const std::shared_ptr<class Assignment>& assignment);
-  bool hasChildren() const {return !(moduleInstantiations.empty());}
+  size_t numElements () const {
+    return assignments.size () + moduleInstantiations.size ();
+  }
+  void print (std::ostream &stream, const std::string &indent, const bool inlined = false) const;
+  std::shared_ptr<AbstractNode> instantiateModules (const std::shared_ptr<const Context> &context, const std::shared_ptr<AbstractNode> &target) const;
+  std::shared_ptr<AbstractNode> instantiateModules (const std::shared_ptr<const Context> &context, const std::shared_ptr<AbstractNode> &target, const std::vector<size_t> &indices) const;
+  void addModuleInst (const std::shared_ptr<class ModuleInstantiation> &modinst);
+  void addModule (const std::shared_ptr<class UserModule> &module);
+  void addFunction (const std::shared_ptr<class UserFunction> &function);
+  void addAssignment (const std::shared_ptr<class Assignment> &assignment);
+  bool hasChildren () const {
+    return !(moduleInstantiations.empty ());
+  }
 
   AssignmentList assignments;
   std::vector<std::shared_ptr<ModuleInstantiation>> moduleInstantiations;
diff --git a/src/core/ModuleInstantiation.cc b/src/core/ModuleInstantiation.cc
index 3715cef0a..0cbd72d8e 100644
--- a/src/core/ModuleInstantiation.cc
+++ b/src/core/ModuleInstantiation.cc
@@ -11,42 +11,43 @@
 #include "utils/exceptions.h"
 #include "utils/printutils.h"
 
-void ModuleInstantiation::print(std::ostream& stream, const std::string& indent, const bool inlined) const
-{
-  if (!inlined) stream << indent;
+void ModuleInstantiation::print (std::ostream &stream, const std::string &indent, const bool inlined) const {
+  if (!inlined)
+    stream << indent;
   stream << modname + "(";
-  for (size_t i = 0; i < this->arguments.size(); ++i) {
-    const auto& arg = this->arguments[i];
-    if (i > 0) stream << ", ";
-    if (!arg->getName().empty()) stream << arg->getName() << " = ";
-    stream << *arg->getExpr();
+  for (size_t i = 0; i < this->arguments.size (); ++i) {
+    const auto &arg = this->arguments[i];
+    if (i > 0)
+      stream << ", ";
+    if (!arg->getName ().empty ())
+      stream << arg->getName () << " = ";
+    stream << *arg->getExpr ();
   }
-  if (scope.numElements() == 0) {
+  if (scope.numElements () == 0) {
     stream << ");\n";
-  } else if (scope.numElements() == 1) {
+  } else if (scope.numElements () == 1) {
     stream << ") ";
-    scope.print(stream, indent, true);
+    scope.print (stream, indent, true);
   } else {
     stream << ") {\n";
-    scope.print(stream, indent + "\t", false);
+    scope.print (stream, indent + "\t", false);
     stream << indent << "}\n";
   }
 }
 
-void IfElseModuleInstantiation::print(std::ostream& stream, const std::string& indent, const bool inlined) const
-{
-  ModuleInstantiation::print(stream, indent, inlined);
+void IfElseModuleInstantiation::print (std::ostream &stream, const std::string &indent, const bool inlined) const {
+  ModuleInstantiation::print (stream, indent, inlined);
   if (else_scope) {
-    auto num_elements = else_scope->numElements();
+    auto num_elements = else_scope->numElements ();
     if (num_elements == 0) {
       stream << indent << "else;";
     } else {
       stream << indent << "else ";
       if (num_elements == 1) {
-        else_scope->print(stream, indent, true);
+        else_scope->print (stream, indent, true);
       } else {
         stream << "{\n";
-        else_scope->print(stream, indent + "\t", false);
+        else_scope->print (stream, indent + "\t", false);
         stream << indent << "}\n";
       }
     }
@@ -60,31 +61,29 @@ void IfElseModuleInstantiation::print(std::ostream& stream, const std::string& i
  * noinline is required, as we here specifically optimize for stack usage
  * during normal operating, not runtime during error handling.
  */
-static void NOINLINE print_trace(const ModuleInstantiation *mod, const std::shared_ptr<const Context>& context){
-  LOG(message_group::Trace, mod->location(), context->documentRoot(), "called by '%1$s'", mod->name());
+static void NOINLINE print_trace (const ModuleInstantiation *mod, const std::shared_ptr<const Context> &context) {
+  LOG (message_group::Trace, mod->location (), context->documentRoot (), "called by '%1$s'", mod->name ());
 }
 
-std::shared_ptr<AbstractNode> ModuleInstantiation::evaluate(const std::shared_ptr<const Context>& context) const
-{
-  boost::optional<InstantiableModule> module = context->lookup_module(this->name(), this->loc);
+std::shared_ptr<AbstractNode> ModuleInstantiation::evaluate (const std::shared_ptr<const Context> &context) const {
+  boost::optional<InstantiableModule> module = context->lookup_module (this->name (), this->loc);
   if (!module) {
     return nullptr;
   }
 
-  try{
-    auto node = module->module->instantiate(module->defining_context, this, context);
+  try {
+    auto node = module->module->instantiate (module->defining_context, this, context);
     return node;
-  } catch (EvaluationException& e) {
+  } catch (EvaluationException &e) {
     if (e.traceDepth > 0) {
-      print_trace(this, context);
+      print_trace (this, context);
       e.traceDepth--;
     }
     throw;
   }
 }
 
-LocalScope *IfElseModuleInstantiation::makeElseScope()
-{
-  this->else_scope = std::make_unique<LocalScope>();
-  return this->else_scope.get();
+LocalScope *IfElseModuleInstantiation::makeElseScope () {
+  this->else_scope = std::make_unique<LocalScope> ();
+  return this->else_scope.get ();
 }
diff --git a/src/core/ModuleInstantiation.h b/src/core/ModuleInstantiation.h
index 509672b40..0045d8c5b 100644
--- a/src/core/ModuleInstantiation.h
+++ b/src/core/ModuleInstantiation.h
@@ -13,17 +13,29 @@ using ModuleInstantiationList = std::vector<class ModuleInstantiation *>;
 class ModuleInstantiation : public ASTNode
 {
 public:
-  ModuleInstantiation(std::string name, AssignmentList args = AssignmentList(), const Location& loc = Location::NONE)
-    : ASTNode(loc), arguments(std::move(args)), modname(std::move(name)) { }
+  ModuleInstantiation (std::string name, AssignmentList args = AssignmentList (), const Location &loc = Location::NONE)
+    : ASTNode (loc)
+    , arguments (std::move (args))
+    , modname (std::move (name)) {}
 
-  virtual void print(std::ostream& stream, const std::string& indent, const bool inlined) const;
-  void print(std::ostream& stream, const std::string& indent) const override { print(stream, indent, false); }
-  std::shared_ptr<AbstractNode> evaluate(const std::shared_ptr<const Context>& context) const;
+  virtual void print (std::ostream &stream, const std::string &indent, const bool inlined) const;
+  void print (std::ostream &stream, const std::string &indent) const override {
+    print (stream, indent, false);
+  }
+  std::shared_ptr<AbstractNode> evaluate (const std::shared_ptr<const Context> &context) const;
 
-  const std::string& name() const { return this->modname; }
-  bool isBackground() const { return this->tag_background; }
-  bool isHighlight() const { return this->tag_highlight; }
-  bool isRoot() const { return this->tag_root; }
+  const std::string &name () const {
+    return this->modname;
+  }
+  bool isBackground () const {
+    return this->tag_background;
+  }
+  bool isHighlight () const {
+    return this->tag_highlight;
+  }
+  bool isRoot () const {
+    return this->tag_root;
+  }
 
   AssignmentList arguments;
   LocalScope scope;
@@ -31,6 +43,7 @@ public:
   bool tag_root{false};
   bool tag_highlight{false};
   bool tag_background{false};
+
 protected:
   std::string modname;
 };
@@ -38,12 +51,15 @@ protected:
 class IfElseModuleInstantiation : public ModuleInstantiation
 {
 public:
-  IfElseModuleInstantiation(std::shared_ptr<class Expression> expr, const Location& loc) :
-    ModuleInstantiation("if", AssignmentList{assignment("", std::move(expr))}, loc) { }
+  IfElseModuleInstantiation (std::shared_ptr<class Expression> expr, const Location &loc)
+    : ModuleInstantiation ("if", AssignmentList{assignment ("", std::move (expr))}, loc) {}
+
+  LocalScope *makeElseScope ();
+  LocalScope *getElseScope () const {
+    return this->else_scope.get ();
+  }
+  void print (std::ostream &stream, const std::string &indent, const bool inlined) const final;
 
-  LocalScope *makeElseScope();
-  LocalScope *getElseScope() const { return this->else_scope.get(); }
-  void print(std::ostream& stream, const std::string& indent, const bool inlined) const final;
 private:
   std::unique_ptr<LocalScope> else_scope;
 };
diff --git a/src/core/NodeCache.h b/src/core/NodeCache.h
index 0550160fd..f639478fd 100644
--- a/src/core/NodeCache.h
+++ b/src/core/NodeCache.h
@@ -18,42 +18,42 @@
 class NodeCache
 {
 public:
-  NodeCache() = default;
+  NodeCache () = default;
 
-  bool contains(const AbstractNode& node) const {
-    auto result = this->cache.find(node.index());
-    return result != this->cache.end() &&
+  bool contains (const AbstractNode &node) const {
+    auto result = this->cache.find (node.index ());
+    return result != this->cache.end () &&
            result->second.second >= 0L &&
-           (long)this->rootString.size() >= result->second.second;
+           (long)this->rootString.size () >= result->second.second;
   }
 
-  std::string operator[](const AbstractNode& node) const {
+  std::string operator[] (const AbstractNode &node) const {
     // throws std::out_of_range on miss
-    auto indexpair = this->cache.at(node.index());
-    return rootString.substr(indexpair.first, indexpair.second - indexpair.first);
+    auto indexpair = this->cache.at (node.index ());
+    return rootString.substr (indexpair.first, indexpair.second - indexpair.first);
   }
 
-  void insertStart(const size_t nodeidx, const long startindex) {
-    assert(this->cache.count(nodeidx) == 0 && "start index inserted twice");
-    this->cache.emplace(nodeidx, std::make_pair(startindex, -1L));
+  void insertStart (const size_t nodeidx, const long startindex) {
+    assert (this->cache.count (nodeidx) == 0 && "start index inserted twice");
+    this->cache.emplace (nodeidx, std::make_pair (startindex, -1L));
   }
 
-  void insertEnd(const size_t nodeidx, const long endindex) {
+  void insertEnd (const size_t nodeidx, const long endindex) {
     // throws std::out_of_range on miss
-    auto indexpair = this->cache.at(nodeidx);
-    assert(indexpair.second == -1L && "end index inserted twice");
-    this->cache[nodeidx] = std::make_pair(indexpair.first, endindex);
+    auto indexpair = this->cache.at (nodeidx);
+    assert (indexpair.second == -1L && "end index inserted twice");
+    this->cache[nodeidx] = std::make_pair (indexpair.first, endindex);
 #ifdef DEBUG
-    PRINTDB("NodeCache insert {%i,[%d:%d]}", nodeidx % indexpair.first % endindex);
+    PRINTDB ("NodeCache insert {%i,[%d:%d]}", nodeidx % indexpair.first % endindex);
 #endif
   }
 
-  void setRootString(const std::string& rootString) {
+  void setRootString (const std::string &rootString) {
     this->rootString = rootString;
   }
 
-  void clear() {
-    this->cache.clear();
+  void clear () {
+    this->cache.clear ();
     this->rootString = "";
   }
 
diff --git a/src/core/NodeDumper.cc b/src/core/NodeDumper.cc
index 3724a87df..f0e2163be 100644
--- a/src/core/NodeDumper.cc
+++ b/src/core/NodeDumper.cc
@@ -8,46 +8,42 @@
 #include <sstream>
 #include <boost/regex.hpp>
 
-
-void GroupNodeChecker::incChildCount(int groupNodeIndex) {
-  auto search = this->groupChildCounts.find(groupNodeIndex);
+void GroupNodeChecker::incChildCount (int groupNodeIndex) {
+  auto search = this->groupChildCounts.find (groupNodeIndex);
   // if no entry then given node wasn't a group node
-  if (search != this->groupChildCounts.end()) {
+  if (search != this->groupChildCounts.end ()) {
     ++(search->second);
   }
 }
 
-int GroupNodeChecker::getChildCount(int groupNodeIndex) const {
-  auto search = this->groupChildCounts.find(groupNodeIndex);
-  if (search != this->groupChildCounts.end()) {
+int GroupNodeChecker::getChildCount (int groupNodeIndex) const {
+  auto search = this->groupChildCounts.find (groupNodeIndex);
+  if (search != this->groupChildCounts.end ()) {
     return search->second;
   } else {
     return -1;
   }
 }
 
-Response GroupNodeChecker::visit(State& state, const GroupNode& node)
-{
-  if (state.isPrefix()) {
+Response GroupNodeChecker::visit (State &state, const GroupNode &node) {
+  if (state.isPrefix ()) {
     // create entry for group node, which children may increment
-    this->groupChildCounts.emplace(node.index(), 0);
-  } else if (state.isPostfix()) {
-    if ((this->getChildCount(node.index()) > 0) && state.parent()) {
-      this->incChildCount(state.parent()->index());
+    this->groupChildCounts.emplace (node.index (), 0);
+  } else if (state.isPostfix ()) {
+    if ((this->getChildCount (node.index ()) > 0) && state.parent ()) {
+      this->incChildCount (state.parent ()->index ());
     }
   }
   return Response::ContinueTraversal;
 }
 
-Response GroupNodeChecker::visit(State& state, const AbstractNode&)
-{
-  if (state.isPostfix() && state.parent()) {
-    this->incChildCount(state.parent()->index());
+Response GroupNodeChecker::visit (State &state, const AbstractNode &) {
+  if (state.isPostfix () && state.parent ()) {
+    this->incChildCount (state.parent ()->index ());
   }
   return Response::ContinueTraversal;
 }
 
-
 /*!
    \class NodeDumper
 
@@ -56,107 +52,107 @@ Response GroupNodeChecker::visit(State& state, const AbstractNode&)
    any node or subtree.
  */
 
-void NodeDumper::initCache()
-{
-  this->dumpstream.str("");
-  this->dumpstream.clear();
-  this->cache.clear();
+void NodeDumper::initCache () {
+  this->dumpstream.str ("");
+  this->dumpstream.clear ();
+  this->cache.clear ();
 }
 
-void NodeDumper::finalizeCache()
-{
-  this->cache.setRootString(this->dumpstream.str());
+void NodeDumper::finalizeCache () {
+  this->cache.setRootString (this->dumpstream.str ());
 }
 
-bool NodeDumper::isCached(const AbstractNode& node) const
-{
-  return this->cache.contains(node);
+bool NodeDumper::isCached (const AbstractNode &node) const {
+  return this->cache.contains (node);
 }
 
-Response NodeDumper::visit(State& state, const GroupNode& node)
-{
+Response NodeDumper::visit (State &state, const GroupNode &node) {
   if (!this->idString) {
-    return NodeDumper::visit(state, (const AbstractNode&)node);
+    return NodeDumper::visit (state, (const AbstractNode &)node);
   }
-  if (state.isPrefix()) {
+  if (state.isPrefix ()) {
     // For handling root modifier '!'
     // Check if we are processing the root of the current Tree and init cache
-    if (this->root.get() == &node) {
-      this->initCache();
+    if (this->root.get () == &node) {
+      this->initCache ();
     }
 
     // ListNodes can pass down modifiers to children via state, so check both modinst and state
-    if (node.modinst->isBackground() || state.isBackground()) this->dumpstream << "%";
-    if (node.modinst->isHighlight() || state.isHighlight()) this->dumpstream << "#";
+    if (node.modinst->isBackground () || state.isBackground ())
+      this->dumpstream << "%";
+    if (node.modinst->isHighlight () || state.isHighlight ())
+      this->dumpstream << "#";
 
 // If IDPREFIX is set, we will output "/*id*/" in front of each node
 // which is useful for debugging.
 #ifdef IDPREFIX
-    if (this->idString) this->dumpstream << "\n";
-    this->dumpstream << "/*" << node.index() << "*/";
+    if (this->idString)
+      this->dumpstream << "\n";
+    this->dumpstream << "/*" << node.index () << "*/";
 #endif
 
     // insert start index
-    this->cache.insertStart(node.index(), this->dumpstream.tellp());
+    this->cache.insertStart (node.index (), this->dumpstream.tellp ());
 
-    if (this->groupChecker.getChildCount(node.index()) > 1) {
+    if (this->groupChecker.getChildCount (node.index ()) > 1) {
       this->dumpstream << node << "{";
     }
     this->currindent++;
-  } else if (state.isPostfix()) {
+  } else if (state.isPostfix ()) {
     this->currindent--;
-    if (this->groupChecker.getChildCount(node.index()) > 1) {
+    if (this->groupChecker.getChildCount (node.index ()) > 1) {
       this->dumpstream << "}";
     }
     // insert end index
-    this->cache.insertEnd(node.index(), this->dumpstream.tellp());
+    this->cache.insertEnd (node.index (), this->dumpstream.tellp ());
 
     // For handling root modifier '!'
     // Check if we are processing the root of the current Tree and finalize cache
-    if (this->root.get() == &node) {
-      this->finalizeCache();
+    if (this->root.get () == &node) {
+      this->finalizeCache ();
     }
   }
 
   return Response::ContinueTraversal;
 }
 
-
 /*!
    Called for each node in the tree.
  */
-Response NodeDumper::visit(State& state, const AbstractNode& node)
-{
-  if (state.isPrefix()) {
+Response NodeDumper::visit (State &state, const AbstractNode &node) {
+  if (state.isPrefix ()) {
 
     // For handling root modifier '!'
     // Check if we are processing the root of the current Tree and init cache
-    if (this->root.get() == &node) {
-      this->initCache();
+    if (this->root.get () == &node) {
+      this->initCache ();
     }
 
     // ListNodes can pass down modifiers to children via state, so check both modinst and state
-    if (node.modinst->isBackground() || state.isBackground()) this->dumpstream << "%";
-    if (node.modinst->isHighlight() || state.isHighlight()) this->dumpstream << "#";
+    if (node.modinst->isBackground () || state.isBackground ())
+      this->dumpstream << "%";
+    if (node.modinst->isHighlight () || state.isHighlight ())
+      this->dumpstream << "#";
 
 // If IDPREFIX is set, we will output "/*id*/" in front of each node
 // which is useful for debugging.
 #ifdef IDPREFIX
-    if (this->idString) this->dumpstream << "\n";
-    this->dumpstream << "/*" << node.index() << "*/";
+    if (this->idString)
+      this->dumpstream << "\n";
+    this->dumpstream << "/*" << node.index () << "*/";
 #endif
 
     // insert start index
-    this->cache.insertStart(node.index(), this->dumpstream.tellp());
+    this->cache.insertStart (node.index (), this->dumpstream.tellp ());
 
     if (this->idString) {
 
-      static const boost::regex re(R"([^\s\"]+|\"(?:[^\"\\]|\\.)*\")");
-      const auto name = STR(node);
-      boost::sregex_token_iterator it(name.begin(), name.end(), re, 0);
-      std::copy(it, boost::sregex_token_iterator(), std::ostream_iterator<std::string>(this->dumpstream));
+      static const boost::regex re (R"([^\s\"]+|\"(?:[^\"\\]|\\.)*\")");
+      const auto name = STR (node);
+      boost::sregex_token_iterator it (name.begin (), name.end (), re, 0);
+      std::copy (it, boost::sregex_token_iterator (), std::ostream_iterator<std::string> (this->dumpstream));
 
-      if (node.getChildren().size() > 0) {
+      if (node.getChildren ().size () > 0) {
         this->dumpstream << "{";
       }
 
@@ -166,25 +162,25 @@ Response NodeDumper::visit(State& state, const AbstractNode& node)
         this->dumpstream << this->indent;
       }
       this->dumpstream << node;
-      if (node.getChildren().size() > 0) {
+      if (node.getChildren ().size () > 0) {
         this->dumpstream << " {\n";
       }
     }
 
     this->currindent++;
 
-  } else if (state.isPostfix()) {
+  } else if (state.isPostfix ()) {
 
     this->currindent--;
 
     if (this->idString) {
-      if (node.getChildren().size() > 0) {
+      if (node.getChildren ().size () > 0) {
         this->dumpstream << "}";
       } else {
         this->dumpstream << ";";
       }
     } else {
-      if (node.getChildren().size() > 0) {
+      if (node.getChildren ().size () > 0) {
         for (int i = 0; i < this->currindent; ++i) {
           this->dumpstream << this->indent;
         }
@@ -195,12 +191,12 @@ Response NodeDumper::visit(State& state, const AbstractNode& node)
     }
 
     // insert end index
-    this->cache.insertEnd(node.index(), this->dumpstream.tellp());
+    this->cache.insertEnd (node.index (), this->dumpstream.tellp ());
 
     // For handling root modifier '!'
     // Check if we are processing the root of the current Tree and finalize cache
-    if (this->root.get() == &node) {
-      this->finalizeCache();
+    if (this->root.get () == &node) {
+      this->finalizeCache ();
     }
   }
 
@@ -210,22 +206,23 @@ Response NodeDumper::visit(State& state, const AbstractNode& node)
 /*!
    Handle list nodes specially: Only list children
  */
-Response NodeDumper::visit(State& state, const ListNode& node)
-{
-  if (state.isPrefix()) {
+Response NodeDumper::visit (State &state, const ListNode &node) {
+  if (state.isPrefix ()) {
     // For handling root modifier '!'
-    if (this->root.get() == &node) {
-      this->initCache();
+    if (this->root.get () == &node) {
+      this->initCache ();
     }
     // pass modifiers down to children via state
-    if (node.modinst->isHighlight()) state.setHighlight(true);
-    if (node.modinst->isBackground()) state.setBackground(true);
-    this->cache.insertStart(node.index(), this->dumpstream.tellp());
-  } else if (state.isPostfix()) {
-    this->cache.insertEnd(node.index(), this->dumpstream.tellp());
+    if (node.modinst->isHighlight ())
+      state.setHighlight (true);
+    if (node.modinst->isBackground ())
+      state.setBackground (true);
+    this->cache.insertStart (node.index (), this->dumpstream.tellp ());
+  } else if (state.isPostfix ()) {
+    this->cache.insertEnd (node.index (), this->dumpstream.tellp ());
     // For handling root modifier '!'
-    if (this->root.get() == &node) {
-      this->finalizeCache();
+    if (this->root.get () == &node) {
+      this->finalizeCache ();
     }
   }
 
@@ -235,16 +232,16 @@ Response NodeDumper::visit(State& state, const ListNode& node)
 /*!
    Handle root nodes specially: Only list children
  */
-Response NodeDumper::visit(State& state, const RootNode& node)
-{
-  if (isCached(node)) return Response::PruneTraversal;
-
-  if (state.isPrefix()) {
-    this->initCache();
-    this->cache.insertStart(node.index(), this->dumpstream.tellp());
-  } else if (state.isPostfix()) {
-    this->cache.insertEnd(node.index(), this->dumpstream.tellp());
-    this->finalizeCache();
+Response NodeDumper::visit (State &state, const RootNode &node) {
+  if (isCached (node))
+    return Response::PruneTraversal;
+
+  if (state.isPrefix ()) {
+    this->initCache ();
+    this->cache.insertStart (node.index (), this->dumpstream.tellp ());
+  } else if (state.isPostfix ()) {
+    this->cache.insertEnd (node.index (), this->dumpstream.tellp ());
+    this->finalizeCache ();
   }
 
   return Response::ContinueTraversal;
diff --git a/src/core/NodeDumper.h b/src/core/NodeDumper.h
index b1f4d0248..6593b623c 100644
--- a/src/core/NodeDumper.h
+++ b/src/core/NodeDumper.h
@@ -17,13 +17,15 @@
 class GroupNodeChecker : public NodeVisitor
 {
 public:
-  GroupNodeChecker() = default;
+  GroupNodeChecker () = default;
 
-  Response visit(State& state, const AbstractNode& node) override;
-  Response visit(State& state, const GroupNode& node) override;
-  void incChildCount(int groupNodeIndex);
-  int getChildCount(int groupNodeIndex) const;
-  void reset() { groupChildCounts.clear(); }
+  Response visit (State &state, const AbstractNode &node) override;
+  Response visit (State &state, const GroupNode &node) override;
+  void incChildCount (int groupNodeIndex);
+  int getChildCount (int groupNodeIndex) const;
+  void reset () {
+    groupChildCounts.clear ();
+  }
 
 private:
   // stores <node_idx,nonEmptyChildCount> for each group node
@@ -33,24 +35,27 @@ private:
 class NodeDumper : public NodeVisitor
 {
 public:
-  NodeDumper(NodeCache& cache, std::shared_ptr<const AbstractNode> root_node, std::string indent, bool idString) :
-    cache(cache), indent(std::move(indent)), idString(idString), root(std::move(root_node)) {
+  NodeDumper (NodeCache &cache, std::shared_ptr<const AbstractNode> root_node, std::string indent, bool idString)
+    : cache (cache)
+    , indent (std::move (indent))
+    , idString (idString)
+    , root (std::move (root_node)) {
     if (idString) {
-      groupChecker.traverse(*root);
+      groupChecker.traverse (*root);
     }
   }
 
-  Response visit(State& state, const AbstractNode& node) override;
-  Response visit(State& state, const GroupNode& node) override;
-  Response visit(State& state, const ListNode& node) override;
-  Response visit(State& state, const RootNode& node) override;
+  Response visit (State &state, const AbstractNode &node) override;
+  Response visit (State &state, const GroupNode &node) override;
+  Response visit (State &state, const ListNode &node) override;
+  Response visit (State &state, const RootNode &node) override;
 
 private:
-  void initCache();
-  void finalizeCache();
-  bool isCached(const AbstractNode& node) const;
+  void initCache ();
+  void finalizeCache ();
+  bool isCached (const AbstractNode &node) const;
 
-  NodeCache& cache;
+  NodeCache &cache;
   // Output Formatting options
   std::string indent;
   bool idString;
@@ -59,7 +64,4 @@ private:
   std::shared_ptr<const AbstractNode> root;
   GroupNodeChecker groupChecker;
   std::ostringstream dumpstream;
-
 };
-
-
diff --git a/src/core/NodeVisitor.cc b/src/core/NodeVisitor.cc
index 1cce775b2..9d7a5cf60 100644
--- a/src/core/NodeVisitor.cc
+++ b/src/core/NodeVisitor.cc
@@ -1,35 +1,36 @@
 #include "core/NodeVisitor.h"
 #include "core/State.h"
 
-State NodeVisitor::nullstate(nullptr);
+State NodeVisitor::nullstate (nullptr);
 
-Response NodeVisitor::traverse(const AbstractNode& node, const State& state)
-{
+Response NodeVisitor::traverse (const AbstractNode &node, const State &state) {
   State newstate = state;
-  newstate.setNumChildren(node.getChildren().size());
+  newstate.setNumChildren (node.getChildren ().size ());
 
   Response response = Response::ContinueTraversal;
-  newstate.setPrefix(true);
-  newstate.setParent(state.parent());
-  response = node.accept(newstate, *this);
+  newstate.setPrefix (true);
+  newstate.setParent (state.parent ());
+  response = node.accept (newstate, *this);
 
   // Pruned traversals mean don't traverse children
   if (response == Response::ContinueTraversal) {
-    newstate.setParent(node.shared_from_this());
-    for (const auto& chnode : node.getChildren()) {
-      response = this->traverse(*chnode, newstate);
-      if (response == Response::AbortTraversal) return response; // Abort immediately
+    newstate.setParent (node.shared_from_this ());
+    for (const auto &chnode : node.getChildren ()) {
+      response = this->traverse (*chnode, newstate);
+      if (response == Response::AbortTraversal)
+        return response; // Abort immediately
     }
   }
 
   // Postfix is executed for all non-aborted traversals
   if (response != Response::AbortTraversal) {
-    newstate.setParent(state.parent());
-    newstate.setPrefix(false);
-    newstate.setPostfix(true);
-    response = node.accept(newstate, *this);
+    newstate.setParent (state.parent ());
+    newstate.setPrefix (false);
+    newstate.setPostfix (true);
+    response = node.accept (newstate, *this);
   }
 
-  if (response != Response::AbortTraversal) response = Response::ContinueTraversal;
+  if (response != Response::AbortTraversal)
+    response = Response::ContinueTraversal;
   return response;
 }
diff --git a/src/core/NodeVisitor.h b/src/core/NodeVisitor.h
index 3252fc108..0de7ee1dd 100644
--- a/src/core/NodeVisitor.h
+++ b/src/core/NodeVisitor.h
@@ -6,92 +6,91 @@
 
 class State;
 
-class NodeVisitor :
-  public BaseVisitor,
-  public Visitor<class AbstractNode>,
-  public Visitor<class AbstractIntersectionNode>,
-  public Visitor<class AbstractPolyNode>,
-  public Visitor<class ListNode>,
-  public Visitor<class GroupNode>,
-  public Visitor<class RootNode>,
-  public Visitor<class LeafNode>,
-  public Visitor<class CgalAdvNode>,
-  public Visitor<class CsgOpNode>,
-  public Visitor<class LinearExtrudeNode>,
-  public Visitor<class RotateExtrudeNode>,
-  public Visitor<class RoofNode>,
-  public Visitor<class ImportNode>,
-  public Visitor<class TextNode>,
-  public Visitor<class ProjectionNode>,
-  public Visitor<class RenderNode>,
-  public Visitor<class SurfaceNode>,
-  public Visitor<class TransformNode>,
-  public Visitor<class ColorNode>,
-  public Visitor<class OffsetNode>
+class NodeVisitor : public BaseVisitor,
+                    public Visitor<class AbstractNode>,
+                    public Visitor<class AbstractIntersectionNode>,
+                    public Visitor<class AbstractPolyNode>,
+                    public Visitor<class ListNode>,
+                    public Visitor<class GroupNode>,
+                    public Visitor<class RootNode>,
+                    public Visitor<class LeafNode>,
+                    public Visitor<class CgalAdvNode>,
+                    public Visitor<class CsgOpNode>,
+                    public Visitor<class LinearExtrudeNode>,
+                    public Visitor<class RotateExtrudeNode>,
+                    public Visitor<class RoofNode>,
+                    public Visitor<class ImportNode>,
+                    public Visitor<class TextNode>,
+                    public Visitor<class ProjectionNode>,
+                    public Visitor<class RenderNode>,
+                    public Visitor<class SurfaceNode>,
+                    public Visitor<class TransformNode>,
+                    public Visitor<class ColorNode>,
+                    public Visitor<class OffsetNode>
 {
 public:
-  NodeVisitor() = default;
+  NodeVisitor () = default;
 
-  Response traverse(const AbstractNode& node, const State& state = NodeVisitor::nullstate);
+  Response traverse (const AbstractNode &node, const State &state = NodeVisitor::nullstate);
 
-  Response visit(State& state, const AbstractNode& node) override = 0;
-  Response visit(State& state, const AbstractIntersectionNode& node) override {
-    return visit(state, (const AbstractNode&) node);
+  Response visit (State &state, const AbstractNode &node) override = 0;
+  Response visit (State &state, const AbstractIntersectionNode &node) override {
+    return visit (state, (const AbstractNode &)node);
   }
-  Response visit(State& state, const AbstractPolyNode& node) override {
-    return visit(state, (const AbstractNode&) node);
+  Response visit (State &state, const AbstractPolyNode &node) override {
+    return visit (state, (const AbstractNode &)node);
   }
-  Response visit(State& state, const ListNode& node) override {
-    return visit(state, (const AbstractNode&) node);
+  Response visit (State &state, const ListNode &node) override {
+    return visit (state, (const AbstractNode &)node);
   }
 
-  Response visit(State& state, const GroupNode& node) override {
-    return visit(state, (const AbstractNode&) node);
+  Response visit (State &state, const GroupNode &node) override {
+    return visit (state, (const AbstractNode &)node);
   }
-  Response visit(State& state, const RootNode& node) override {
-    return visit(state, (const GroupNode&) node);
+  Response visit (State &state, const RootNode &node) override {
+    return visit (state, (const GroupNode &)node);
   }
-  Response visit(State& state, const LeafNode& node) override {
-    return visit(state, (const AbstractPolyNode&) node);
+  Response visit (State &state, const LeafNode &node) override {
+    return visit (state, (const AbstractPolyNode &)node);
   }
-  Response visit(State& state, const CgalAdvNode& node) override {
-    return visit(state, (const AbstractNode&) node);
+  Response visit (State &state, const CgalAdvNode &node) override {
+    return visit (state, (const AbstractNode &)node);
   }
-  Response visit(State& state, const CsgOpNode& node) override {
-    return visit(state, (const AbstractNode&) node);
+  Response visit (State &state, const CsgOpNode &node) override {
+    return visit (state, (const AbstractNode &)node);
   }
-  Response visit(State& state, const LinearExtrudeNode& node) override {
-    return visit(state, (const AbstractPolyNode&) node);
+  Response visit (State &state, const LinearExtrudeNode &node) override {
+    return visit (state, (const AbstractPolyNode &)node);
   }
-  Response visit(State& state, const RotateExtrudeNode& node) override {
-    return visit(state, (const AbstractPolyNode&) node);
+  Response visit (State &state, const RotateExtrudeNode &node) override {
+    return visit (state, (const AbstractPolyNode &)node);
   }
-  Response visit(State& state, const RoofNode& node) override {
-    return visit(state, (const AbstractPolyNode&) node);
+  Response visit (State &state, const RoofNode &node) override {
+    return visit (state, (const AbstractPolyNode &)node);
   }
-  Response visit(State& state, const ImportNode& node) override {
-    return visit(state, (const LeafNode&) node);
+  Response visit (State &state, const ImportNode &node) override {
+    return visit (state, (const LeafNode &)node);
   }
-  Response visit(State& state, const TextNode& node) override {
-    return visit(state, (const AbstractPolyNode&) node);
+  Response visit (State &state, const TextNode &node) override {
+    return visit (state, (const AbstractPolyNode &)node);
   }
-  Response visit(State& state, const ProjectionNode& node) override {
-    return visit(state, (const AbstractPolyNode&) node);
+  Response visit (State &state, const ProjectionNode &node) override {
+    return visit (state, (const AbstractPolyNode &)node);
   }
-  Response visit(State& state, const RenderNode& node) override {
-    return visit(state, (const AbstractNode&) node);
+  Response visit (State &state, const RenderNode &node) override {
+    return visit (state, (const AbstractNode &)node);
   }
-  Response visit(State& state, const SurfaceNode& node) override {
-    return visit(state, (const LeafNode&) node);
+  Response visit (State &state, const SurfaceNode &node) override {
+    return visit (state, (const LeafNode &)node);
   }
-  Response visit(State& state, const TransformNode& node) override {
-    return visit(state, (const AbstractNode&) node);
+  Response visit (State &state, const TransformNode &node) override {
+    return visit (state, (const AbstractNode &)node);
   }
-  Response visit(State& state, const ColorNode& node) override {
-    return visit(state, (const AbstractNode&) node);
+  Response visit (State &state, const ColorNode &node) override {
+    return visit (state, (const AbstractNode &)node);
   }
-  Response visit(State& state, const OffsetNode& node) override {
-    return visit(state, (const AbstractPolyNode&) node);
+  Response visit (State &state, const OffsetNode &node) override {
+    return visit (state, (const AbstractPolyNode &)node);
   }
   // Add visit() methods for new visitable subtypes of AbstractNode here
 
diff --git a/src/core/OffsetNode.cc b/src/core/OffsetNode.cc
index ba4b485e5..4a342b53a 100644
--- a/src/core/OffsetNode.cc
+++ b/src/core/OffsetNode.cc
@@ -40,43 +40,41 @@
 #include <boost/assign/std/vector.hpp>
 using namespace boost::assign; // bring 'operator+=()' into scope
 
-static std::shared_ptr<AbstractNode> builtin_offset(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  auto node = std::make_shared<OffsetNode>(inst);
+static std::shared_ptr<AbstractNode> builtin_offset (const ModuleInstantiation *inst, Arguments arguments, const Children &children) {
+  auto node = std::make_shared<OffsetNode> (inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"r"}, {"delta", "chamfer"});
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (), {"r"}, {"delta", "chamfer"});
 
-  node->fn = parameters["$fn"].toDouble();
-  node->fs = parameters["$fs"].toDouble();
-  node->fa = parameters["$fa"].toDouble();
+  node->fn = parameters["$fn"].toDouble ();
+  node->fs = parameters["$fs"].toDouble ();
+  node->fa = parameters["$fa"].toDouble ();
 
   // default with no argument at all is (r = 1, chamfer = false)
   // radius takes precedence if both r and delta are given.
   node->delta = 1;
   node->chamfer = false;
   node->join_type = Clipper2Lib::JoinType::Round;
-  if (parameters["r"].isDefinedAs(Value::Type::NUMBER)) {
-    node->delta = parameters["r"].toDouble();
-  } else if (parameters["delta"].isDefinedAs(Value::Type::NUMBER)) {
-    node->delta = parameters["delta"].toDouble();
+  if (parameters["r"].isDefinedAs (Value::Type::NUMBER)) {
+    node->delta = parameters["r"].toDouble ();
+  } else if (parameters["delta"].isDefinedAs (Value::Type::NUMBER)) {
+    node->delta = parameters["delta"].toDouble ();
     node->join_type = Clipper2Lib::JoinType::Miter;
-    if (parameters["chamfer"].isDefinedAs(Value::Type::BOOL) && parameters["chamfer"].toBool()) {
+    if (parameters["chamfer"].isDefinedAs (Value::Type::BOOL) && parameters["chamfer"].toBool ()) {
       node->chamfer = true;
       node->join_type = Clipper2Lib::JoinType::Square;
     }
   }
 
-  return children.instantiate(node);
+  return children.instantiate (node);
 }
 
-std::string OffsetNode::toString() const
-{
+std::string OffsetNode::toString () const {
   std::ostringstream stream;
 
   bool isRadius = this->join_type == Clipper2Lib::JoinType::Round;
   auto var = isRadius ? "(r = " : "(delta = ";
 
-  stream << this->name() << var << std::dec << this->delta;
+  stream << this->name () << var << std::dec << this->delta;
   if (!isRadius) {
     stream << ", chamfer = " << (this->chamfer ? "true" : "false");
   }
@@ -84,15 +82,14 @@ std::string OffsetNode::toString() const
          << ", $fa = " << this->fa
          << ", $fs = " << this->fs << ")";
 
-  return stream.str();
+  return stream.str ();
 }
 
-void register_builtin_offset()
-{
-  Builtins::init("offset", new BuiltinModule(builtin_offset),
-  {
-    "offset(r = number)",
-    "offset(delta = number)",
-    "offset(delta = number, chamfer = false)",
-  });
+void register_builtin_offset () {
+  Builtins::init ("offset", new BuiltinModule (builtin_offset),
+                  {
+                    "offset(r = number)",
+                    "offset(delta = number)",
+                    "offset(delta = number, chamfer = false)",
+                  });
 }
diff --git a/src/core/OffsetNode.h b/src/core/OffsetNode.h
index c68805cd4..e2e28dfff 100644
--- a/src/core/OffsetNode.h
+++ b/src/core/OffsetNode.h
@@ -9,10 +9,13 @@
 class OffsetNode : public AbstractPolyNode
 {
 public:
-  VISITABLE();
-  OffsetNode(const ModuleInstantiation *mi) : AbstractPolyNode(mi) { }
-  std::string toString() const override;
-  std::string name() const override { return "offset"; }
+  VISITABLE ();
+  OffsetNode (const ModuleInstantiation *mi)
+    : AbstractPolyNode (mi) {}
+  std::string toString () const override;
+  std::string name () const override {
+    return "offset";
+  }
 
   bool chamfer{false};
   double fn{0}, fs{0}, fa{0}, delta{1};
diff --git a/src/core/Parameters.cc b/src/core/Parameters.cc
index 10e616ecd..9ec3586c5 100644
--- a/src/core/Parameters.cc
+++ b/src/core/Parameters.cc
@@ -39,50 +39,45 @@
 #include "core/AST.h"
 #include "core/Expression.h"
 
-Parameters::Parameters(ContextFrame&& frame, Location loc) :
-  loc(std::move(loc)),
-  frame(std::move(frame)),
-  handle(&this->frame)
-{}
-
-Parameters::Parameters(Parameters&& other) noexcept :
-  loc(std::move(other.loc)),
-  frame(std::move(other).to_context_frame()),
-  handle(&this->frame)
-{}
-
-boost::optional<const Value&> Parameters::lookup(const std::string& name) const
-{
-  if (ContextFrame::is_config_variable(name)) {
-    return frame.session()->try_lookup_special_variable(name);
+Parameters::Parameters (ContextFrame &&frame, Location loc)
+  : loc (std::move (loc))
+  , frame (std::move (frame))
+  , handle (&this->frame) {}
+
+Parameters::Parameters (Parameters &&other) noexcept
+  : loc (std::move (other.loc))
+  , frame (std::move (other).to_context_frame ())
+  , handle (&this->frame) {}
+
+boost::optional<const Value &> Parameters::lookup (const std::string &name) const {
+  if (ContextFrame::is_config_variable (name)) {
+    return frame.session ()->try_lookup_special_variable (name);
   } else {
-    return frame.lookup_local_variable(name);
+    return frame.lookup_local_variable (name);
   }
 }
 
-const Value& Parameters::get(const std::string& name) const
-{
-  boost::optional<const Value&> value = lookup(name);
+const Value &Parameters::get (const std::string &name) const {
+  boost::optional<const Value &> value = lookup (name);
   if (!value) {
     return Value::undefined;
   }
   return *value;
 }
 
-const Value& Parameters::get(const std::initializer_list<std::string> names) const
-{
+const Value &Parameters::get (const std::initializer_list<std::string> names) const {
   std::string matchName;
-  boost::optional<const Value&> matchValue;
+  boost::optional<const Value &> matchValue;
 
-  for (const std::string& name: names) {
-    boost::optional<const Value&> value = lookup(name);
-    if (value && value->isDefined()) {
+  for (const std::string &name : names) {
+    boost::optional<const Value &> value = lookup (name);
+    if (value && value->isDefined ()) {
       if (!matchValue) {
         matchName = name;
         matchValue = value;
       } else {
-        LOG(message_group::Warning, loc, documentRoot(),
-            "Specified both %1$s and %2$s", quoteVar(matchName), quoteVar(name));
+        LOG (message_group::Warning, loc, documentRoot (),
+             "Specified both %1$s and %2$s", quoteVar (matchName), quoteVar (name));
       }
     }
   }
@@ -90,248 +85,231 @@ const Value& Parameters::get(const std::initializer_list<std::string> names) con
   return matchValue ? *matchValue : Value::undefined;
 }
 
-double Parameters::get(const std::string& name, double default_value) const
-{
-  boost::optional<const Value&> value = lookup(name);
-  return (value && value->type() == Value::Type::NUMBER) ? value->toDouble() : default_value;
+double Parameters::get (const std::string &name, double default_value) const {
+  boost::optional<const Value &> value = lookup (name);
+  return (value && value->type () == Value::Type::NUMBER) ? value->toDouble () : default_value;
 }
 
-const std::string& Parameters::get(const std::string& name, const std::string& default_value) const
-{
-  boost::optional<const Value&> value = lookup(name);
-  return (value && value->type() == Value::Type::STRING) ? value->toStrUtf8Wrapper().toString() : default_value;
+const std::string &Parameters::get (const std::string &name, const std::string &default_value) const {
+  boost::optional<const Value &> value = lookup (name);
+  return (value && value->type () == Value::Type::STRING) ? value->toStrUtf8Wrapper ().toString () : default_value;
 }
 
-bool Parameters::valid(const std::string& name, const Value& value,
-                       Value::Type type)
-{
-  if (value.type() == type) {
+bool Parameters::valid (const std::string &name, const Value &value,
+                        Value::Type type) {
+  if (value.type () == type) {
     return true;
   }
-  print_argConvert_warning(caller, name, value, {type}, loc,
-                           documentRoot());
+  print_argConvert_warning (caller, name, value, {type}, loc,
+                            documentRoot ());
   return false;
 }
 
 // Note:  unused, doesn't really work right because in some cases where the parameter
 // is not supplied, lookup() returns an existing Value with a value of undef.
-bool Parameters::valid_required(const std::string& name, Value::Type type)
-{
-  boost::optional<const Value&> value = lookup(name);
+bool Parameters::valid_required (const std::string &name, Value::Type type) {
+  boost::optional<const Value &> value = lookup (name);
   if (!value) {
-    LOG(message_group::Warning, loc, documentRoot(),
-        "%1$s: missing argument %2$s", caller, quoteVar(name));
+    LOG (message_group::Warning, loc, documentRoot (),
+         "%1$s: missing argument %2$s", caller, quoteVar (name));
     return false;
   }
-  return valid(name, *value, type);
+  return valid (name, *value, type);
 }
 
-bool Parameters::valid(const std::string& name, Value::Type type)
-{
-  boost::optional<const Value&> value = lookup(name);
-  if (!value || value->isUndefined()) {
+bool Parameters::valid (const std::string &name, Value::Type type) {
+  boost::optional<const Value &> value = lookup (name);
+  if (!value || value->isUndefined ()) {
     return true;
   }
-  return valid(name, *value, type);
+  return valid (name, *value, type);
 }
 
 // Handle all general warnings and return true if a valid number is found.
-bool Parameters::validate_number(const std::string& name, double& out)
-{
-  boost::optional<const Value&> value = lookup(name);
-  if (!value || value->isUndefined()) {
+bool Parameters::validate_number (const std::string &name, double &out) {
+  boost::optional<const Value &> value = lookup (name);
+  if (!value || value->isUndefined ()) {
     return false;
-  } else if (valid(name, *value, Value::Type::NUMBER)) {
-    if (value->getFiniteDouble(out)) {
+  } else if (valid (name, *value, Value::Type::NUMBER)) {
+    if (value->getFiniteDouble (out)) {
       return true;
     } else {
-      LOG(message_group::Warning, loc, documentRoot(), "%1$s(..., %2$s=%3$s) argument cannot be infinite or nan", caller, name, value->toString());
+      LOG (message_group::Warning, loc, documentRoot (), "%1$s(..., %2$s=%3$s) argument cannot be infinite or nan", caller, name, value->toString ());
       return false;
     }
   }
   return false;
 }
 
-ContextFrame Parameters::to_context_frame() &&
-{
-  handle.release();
-  return std::move(frame);
+ContextFrame Parameters::to_context_frame () && {
+  handle.release ();
+  return std::move (frame);
 }
 
 template <class T, class F>
-static ContextFrame parse_without_defaults(
+static ContextFrame parse_without_defaults (
   Arguments arguments,
-  const Location& loc,
-  const std::vector<T>& required_parameters,
-  const std::vector<T>& optional_parameters,
+  const Location &loc,
+  const std::vector<T> &required_parameters,
+  const std::vector<T> &optional_parameters,
   bool warn_for_unexpected_arguments,
-  F parameter_name
-  ) {
-  ContextFrame output{arguments.session()};
+  F parameter_name) {
+  ContextFrame output{arguments.session ()};
 
   std::set<std::string> named_arguments;
 
   size_t parameter_position = 0;
   bool warned_for_extra_arguments = false;
 
-  for (auto& argument : arguments) {
+  for (auto &argument : arguments) {
     std::string name;
     if (argument.name) {
       name = *argument.name;
-      if (named_arguments.count(name)) {
-        LOG(message_group::Warning, loc, arguments.documentRoot(), "argument %1$s supplied more than once", quoteVar(name));
-      } else if (output.lookup_local_variable(name)) {
-        LOG(message_group::Warning, loc, arguments.documentRoot(), "argument %1$s overrides positional argument", quoteVar(name));
-      } else if (warn_for_unexpected_arguments && !ContextFrame::is_config_variable(name)) {
+      if (named_arguments.count (name)) {
+        LOG (message_group::Warning, loc, arguments.documentRoot (), "argument %1$s supplied more than once", quoteVar (name));
+      } else if (output.lookup_local_variable (name)) {
+        LOG (message_group::Warning, loc, arguments.documentRoot (), "argument %1$s overrides positional argument", quoteVar (name));
+      } else if (warn_for_unexpected_arguments && !ContextFrame::is_config_variable (name)) {
         bool found = false;
-        for (const auto& parameter : required_parameters) {
-          if (parameter_name(parameter) == name) {
+        for (const auto &parameter : required_parameters) {
+          if (parameter_name (parameter) == name) {
             found = true;
             break;
           }
         }
-        for (const auto& parameter : optional_parameters) {
-          if (parameter_name(parameter) == name) {
+        for (const auto &parameter : optional_parameters) {
+          if (parameter_name (parameter) == name) {
             found = true;
             break;
           }
         }
         if (!found) {
-          LOG(message_group::Warning, loc, arguments.documentRoot(), "variable %1$s not specified as parameter", quoteVar(name));
+          LOG (message_group::Warning, loc, arguments.documentRoot (), "variable %1$s not specified as parameter", quoteVar (name));
         }
       }
-      named_arguments.insert(name);
+      named_arguments.insert (name);
     } else {
-      while (parameter_position < required_parameters.size() + optional_parameters.size()) {
-        std::string candidate_name = (parameter_position < required_parameters.size())
-    ? parameter_name(required_parameters[parameter_position])
-    : parameter_name(optional_parameters[parameter_position - required_parameters.size()])
-        ;
+      while (parameter_position < required_parameters.size () + optional_parameters.size ()) {
+        std::string candidate_name = (parameter_position < required_parameters.size ())
+                                       ? parameter_name (required_parameters[parameter_position])
+                                       : parameter_name (optional_parameters[parameter_position - required_parameters.size ()]);
         parameter_position++;
-        if (!named_arguments.count(candidate_name)) {
+        if (!named_arguments.count (candidate_name)) {
           name = candidate_name;
           break;
         }
       }
-      if (name.empty()) {
+      if (name.empty ()) {
         if (warn_for_unexpected_arguments && !warned_for_extra_arguments) {
-          LOG(message_group::Warning, loc, arguments.documentRoot(), "Too many unnamed arguments supplied");
+          LOG (message_group::Warning, loc, arguments.documentRoot (), "Too many unnamed arguments supplied");
           warned_for_extra_arguments = true;
         }
         continue;
       }
     }
 
-    output.set_variable(name, std::move(argument.value));
+    output.set_variable (name, std::move (argument.value));
   }
   return output;
 }
 
-Parameters Parameters::parse(
+Parameters Parameters::parse (
   Arguments arguments,
-  const Location& loc,
-  const std::vector<std::string>& required_parameters,
-  const std::vector<std::string>& optional_parameters
-  ) {
-  ContextFrame frame{parse_without_defaults(std::move(arguments), loc, required_parameters, optional_parameters, true,
-                                            [](const std::string& s) -> std::string {
-      return s;
-    }
-                                            )};
-
-  for (const auto& parameter : required_parameters) {
-    if (!frame.lookup_local_variable(parameter)) {
-      frame.set_variable(parameter, Value::undefined.clone());
+  const Location &loc,
+  const std::vector<std::string> &required_parameters,
+  const std::vector<std::string> &optional_parameters) {
+  ContextFrame frame{parse_without_defaults (std::move (arguments), loc, required_parameters, optional_parameters, true,
+                                             [] (const std::string &s) -> std::string {
+                                               return s;
+                                             })};
+
+  for (const auto &parameter : required_parameters) {
+    if (!frame.lookup_local_variable (parameter)) {
+      frame.set_variable (parameter, Value::undefined.clone ());
     }
   }
 
-  return Parameters{std::move(frame), loc};
+  return Parameters{std::move (frame), loc};
 }
 
-Parameters Parameters::parse(
+Parameters Parameters::parse (
   Arguments arguments,
-  const Location& loc,
-  const AssignmentList& required_parameters,
-  const std::shared_ptr<const Context>& defining_context
-  ) {
-  ContextFrame frame{parse_without_defaults(std::move(arguments), loc, required_parameters, {}, OpenSCAD::parameterCheck,
-                                            [](const std::shared_ptr<Assignment>& assignment) {
-      return assignment->getName();
-    }
-                                            )};
-
-  for (const auto& parameter : required_parameters) {
-    if (!frame.lookup_local_variable(parameter->getName())) {
-      if (parameter->getExpr()) {
-        frame.set_variable(parameter->getName(), parameter->getExpr()->evaluate(defining_context));
+  const Location &loc,
+  const AssignmentList &required_parameters,
+  const std::shared_ptr<const Context> &defining_context) {
+  ContextFrame frame{parse_without_defaults (std::move (arguments), loc, required_parameters, {}, OpenSCAD::parameterCheck,
+                                             [] (const std::shared_ptr<Assignment> &assignment) {
+                                               return assignment->getName ();
+                                             })};
+
+  for (const auto &parameter : required_parameters) {
+    if (!frame.lookup_local_variable (parameter->getName ())) {
+      if (parameter->getExpr ()) {
+        frame.set_variable (parameter->getName (), parameter->getExpr ()->evaluate (defining_context));
       } else {
-        frame.set_variable(parameter->getName(), Value::undefined.clone());
+        frame.set_variable (parameter->getName (), Value::undefined.clone ());
       }
     }
   }
 
-  return Parameters{std::move(frame), loc};
+  return Parameters{std::move (frame), loc};
 }
 
-void Parameters::set_caller(const std::string& caller)
-{
+void Parameters::set_caller (const std::string &caller) {
   this->caller = caller;
 }
 
-void print_argCnt_warning(
-  const std::string& name,
+void print_argCnt_warning (
+  const std::string &name,
   int found,
-  const std::string& expected,
-  const Location& loc,
-  const std::string& documentRoot
-  ) {
-  LOG(message_group::Warning, loc, documentRoot, "%1$s() number of parameters does not match: expected %2$s, found %3$i", name, expected, found);
+  const std::string &expected,
+  const Location &loc,
+  const std::string &documentRoot) {
+  LOG (message_group::Warning, loc, documentRoot, "%1$s() number of parameters does not match: expected %2$s, found %3$i", name, expected, found);
 }
 
-void print_argConvert_positioned_warning(
-  const std::string& calledName,
-  const std::string& where,
-  const Value& found,
+void print_argConvert_positioned_warning (
+  const std::string &calledName,
+  const std::string &where,
+  const Value &found,
   std::vector<Value::Type> expected,
-  const Location& loc,
-  const std::string& documentRoot
-  ){
+  const Location &loc,
+  const std::string &documentRoot) {
   std::stringstream message;
   message << calledName << "() parameter could not be converted: " << where << ": expected ";
-  if (expected.size() == 1) {
-    message << Value::typeName(expected[0]);
+  if (expected.size () == 1) {
+    message << Value::typeName (expected[0]);
   } else {
-    assert(expected.size() > 0);
-    message << "one of (" << Value::typeName(expected[0]);
-    for (size_t i = 1; i < expected.size(); i++) {
-      message << ", " << Value::typeName(expected[i]);
+    assert (expected.size () > 0);
+    message << "one of (" << Value::typeName (expected[0]);
+    for (size_t i = 1; i < expected.size (); i++) {
+      message << ", " << Value::typeName (expected[i]);
     }
     message << ")";
   }
-  message << ", found " << found.typeName() << " " << "(" << found.toEchoStringNoThrow() << ")";
-  LOG(message_group::Warning, loc, documentRoot, "%1$s", message.str());
+  message << ", found " << found.typeName () << " " << "(" << found.toEchoStringNoThrow () << ")";
+  LOG (message_group::Warning, loc, documentRoot, "%1$s", message.str ());
 }
 
-void print_argConvert_warning(
-  const std::string& calledName,
-  const std::string& argName,
-  const Value& found,
+void print_argConvert_warning (
+  const std::string &calledName,
+  const std::string &argName,
+  const Value &found,
   std::vector<Value::Type> expected,
-  const Location& loc,
-  const std::string& documentRoot
-  ) {
+  const Location &loc,
+  const std::string &documentRoot) {
   std::stringstream message;
-  message << calledName << "(..., " << argName << "=" << found.toEchoStringNoThrow() << ") Invalid type: expected ";
-  if (expected.size() == 1) {
-    message << Value::typeName(expected[0]);
+  message << calledName << "(..., " << argName << "=" << found.toEchoStringNoThrow () << ") Invalid type: expected ";
+  if (expected.size () == 1) {
+    message << Value::typeName (expected[0]);
   } else {
-    assert(expected.size() > 0);
-    message << "one of (" << Value::typeName(expected[0]);
-    for (size_t i = 1; i < expected.size(); i++) {
-      message << ", " << Value::typeName(expected[i]);
+    assert (expected.size () > 0);
+    message << "one of (" << Value::typeName (expected[0]);
+    for (size_t i = 1; i < expected.size (); i++) {
+      message << ", " << Value::typeName (expected[i]);
     }
     message << ")";
   }
-  message << ", found " << found.typeName();
-  LOG(message_group::Warning, loc, documentRoot, "%1$s", message.str());
+  message << ", found " << found.typeName ();
+  LOG (message_group::Warning, loc, documentRoot, "%1$s", message.str ());
 }
diff --git a/src/core/Parameters.h b/src/core/Parameters.h
index 749bfee8d..4be04d7d1 100644
--- a/src/core/Parameters.h
+++ b/src/core/Parameters.h
@@ -20,10 +20,10 @@
 class Parameters
 {
 private:
-  Parameters(ContextFrame&& frame, Location loc);
+  Parameters (ContextFrame &&frame, Location loc);
 
 public:
-  Parameters(Parameters&& other) noexcept;
+  Parameters (Parameters &&other) noexcept;
 
   /*
    * Matches arguments with parameters.
@@ -31,80 +31,88 @@ public:
    * Required parameters are set to undefined if absent;
    * Optional parameters are not set at all.
    */
-  static Parameters parse(
+  static Parameters parse (
     Arguments arguments,
-    const Location& loc,
-    const std::vector<std::string>& required_parameters,
-    const std::vector<std::string>& optional_parameters = {}
-    );
+    const Location &loc,
+    const std::vector<std::string> &required_parameters,
+    const std::vector<std::string> &optional_parameters = {});
   /*
    * Matches arguments with parameters.
    * Supports default arguments, and requires a context in which to interpret them.
    * Absent parameters without defaults are set to undefined.
    */
-  static Parameters parse(
+  static Parameters parse (
     Arguments arguments,
-    const Location& loc,
-    const AssignmentList& required_parameters,
-    const std::shared_ptr<const Context>& defining_context
-    );
+    const Location &loc,
+    const AssignmentList &required_parameters,
+    const std::shared_ptr<const Context> &defining_context);
 
-  boost::optional<const Value&> lookup(const std::string& name) const;
+  boost::optional<const Value &> lookup (const std::string &name) const;
 
-  void set_caller(const std::string& caller);
-  const Value& get(const std::string& name) const;
-  const Value& get(const std::initializer_list<std::string> names) const;
-  double get(const std::string& name, double default_value) const;
-  const std::string& get(const std::string& name, const std::string& default_value) const;
+  void set_caller (const std::string &caller);
+  const Value &get (const std::string &name) const;
+  const Value &get (const std::initializer_list<std::string> names) const;
+  double get (const std::string &name, double default_value) const;
+  const std::string &get (const std::string &name, const std::string &default_value) const;
 
-  bool contains(const std::string& name) const { return bool(lookup(name)); }
-  const Value& operator[](const std::string& name) const { return get(name); }
-  const Value& operator[](const std::initializer_list<std::string> names) const { return get(names); }
-  bool valid(const std::string& name, Value::Type type);
-  bool valid_required(const std::string& name, Value::Type type);
-  bool validate_number(const std::string& name, double& out);
-  template <typename T> bool validate_integral(const std::string& name, T& out,
-                                               T lo = std::numeric_limits<T>::min(),
-                                               T hi = std::numeric_limits<T>::max());
+  bool contains (const std::string &name) const {
+    return bool (lookup (name));
+  }
+  const Value &operator[] (const std::string &name) const {
+    return get (name);
+  }
+  const Value &operator[] (const std::initializer_list<std::string> names) const {
+    return get (names);
+  }
+  bool valid (const std::string &name, Value::Type type);
+  bool valid_required (const std::string &name, Value::Type type);
+  bool validate_number (const std::string &name, double &out);
+  template <typename T>
+  bool validate_integral (const std::string &name, T &out,
+                          T lo = std::numeric_limits<T>::min (),
+                          T hi = std::numeric_limits<T>::max ());
 
-  ContextFrame to_context_frame() &&;
+  ContextFrame to_context_frame () &&;
 
-  const std::string& documentRoot() const { return frame.documentRoot(); }
-  const Location& location() const { return loc; }
+  const std::string &documentRoot () const {
+    return frame.documentRoot ();
+  }
+  const Location &location () const {
+    return loc;
+  }
 
 private:
   Location loc;
   ContextFrame frame;
   ContextFrameHandle handle;
-  bool valid(const std::string& name, const Value& value, Value::Type type);
+  bool valid (const std::string &name, const Value &value, Value::Type type);
   std::string caller = "";
 };
 
 // Silently clamp to the given range(defaults to numeric_limits)
 // as long as param is a finite number.
 template <typename T>
-bool Parameters::validate_integral(const std::string& name, T& out, T lo, T hi)
-{
+bool Parameters::validate_integral (const std::string &name, T &out, T lo, T hi) {
   double temp;
-  if (validate_number(name, temp)) {
+  if (validate_number (name, temp)) {
     if (temp < lo) {
       out = lo;
     } else if (temp > hi) {
       out = hi;
     } else {
-      out = static_cast<T>(temp);
+      out = static_cast<T> (temp);
     }
     return true;
   }
   return false;
 }
 
-void print_argCnt_warning(const std::string& name, int found,
-                          const std::string& expected, const Location& loc,
-                          const std::string& documentRoot);
-void print_argConvert_positioned_warning(const std::string& calledName, const std::string& where,
-                                         const Value& found, std::vector<Value::Type> expected,
-                                         const Location& loc, const std::string& documentRoot);
-void print_argConvert_warning(const std::string& calledName, const std::string& argName,
-                              const Value& found, std::vector<Value::Type> expected,
-                              const Location& loc, const std::string& documentRoot);
+void print_argCnt_warning (const std::string &name, int found,
+                           const std::string &expected, const Location &loc,
+                           const std::string &documentRoot);
+void print_argConvert_positioned_warning (const std::string &calledName, const std::string &where,
+                                          const Value &found, std::vector<Value::Type> expected,
+                                          const Location &loc, const std::string &documentRoot);
+void print_argConvert_warning (const std::string &calledName, const std::string &argName,
+                               const Value &found, std::vector<Value::Type> expected,
+                               const Location &loc, const std::string &documentRoot);
diff --git a/src/core/ProjectionNode.cc b/src/core/ProjectionNode.cc
index 07ea7c033..4eb1352d9 100644
--- a/src/core/ProjectionNode.cc
+++ b/src/core/ProjectionNode.cc
@@ -37,29 +37,26 @@
 #include <boost/assign/std/vector.hpp>
 using namespace boost::assign; // bring 'operator+=()' into scope
 
-static std::shared_ptr<AbstractNode> builtin_projection(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  auto node = std::make_shared<ProjectionNode>(inst);
+static std::shared_ptr<AbstractNode> builtin_projection (const ModuleInstantiation *inst, Arguments arguments, const Children &children) {
+  auto node = std::make_shared<ProjectionNode> (inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"cut"}, {"convexity"});
-  node->convexity = static_cast<int>(parameters["convexity"].toDouble());
-  if (parameters["cut"].type() == Value::Type::BOOL) {
-    node->cut_mode = parameters["cut"].toBool();
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (), {"cut"}, {"convexity"});
+  node->convexity = static_cast<int> (parameters["convexity"].toDouble ());
+  if (parameters["cut"].type () == Value::Type::BOOL) {
+    node->cut_mode = parameters["cut"].toBool ();
   }
 
-  return children.instantiate(node);
+  return children.instantiate (node);
 }
 
-std::string ProjectionNode::toString() const
-{
-  return STR("projection(cut = ", (this->cut_mode ? "true" : "false"),
-             ", convexity = ", this->convexity, ")");
+std::string ProjectionNode::toString () const {
+  return STR ("projection(cut = ", (this->cut_mode ? "true" : "false"),
+              ", convexity = ", this->convexity, ")");
 }
 
-void register_builtin_projection()
-{
-  Builtins::init("projection", new BuiltinModule(builtin_projection),
-  {
-    "projection(cut = false)",
-  });
+void register_builtin_projection () {
+  Builtins::init ("projection", new BuiltinModule (builtin_projection),
+                  {
+                    "projection(cut = false)",
+                  });
 }
diff --git a/src/core/ProjectionNode.h b/src/core/ProjectionNode.h
index c9b6da64e..6ebdbfa7c 100644
--- a/src/core/ProjectionNode.h
+++ b/src/core/ProjectionNode.h
@@ -7,10 +7,13 @@
 class ProjectionNode : public AbstractPolyNode
 {
 public:
-  VISITABLE();
-  ProjectionNode(const ModuleInstantiation *mi) : AbstractPolyNode(mi) { }
-  std::string toString() const override;
-  std::string name() const override { return "projection"; }
+  VISITABLE ();
+  ProjectionNode (const ModuleInstantiation *mi)
+    : AbstractPolyNode (mi) {}
+  std::string toString () const override;
+  std::string name () const override {
+    return "projection";
+  }
 
   int convexity{1};
   bool cut_mode{false};
diff --git a/src/core/RangeType.h b/src/core/RangeType.h
index 2bbbeaa4b..9d0f9f8f0 100644
--- a/src/core/RangeType.h
+++ b/src/core/RangeType.h
@@ -12,7 +12,9 @@ private:
   double begin_val;
   double step_val;
   double end_val;
-  enum class iter_state { RANGE_BEGIN, RANGE_RUNNING, RANGE_END };
+  enum class iter_state { RANGE_BEGIN,
+                          RANGE_RUNNING,
+                          RANGE_END };
 
 public:
   static constexpr uint32_t MAX_RANGE_STEPS = 10000;
@@ -20,148 +22,173 @@ public:
 
   class iterator
   {
-public:
+  public:
     // iterator_traits required types:
     using iterator_category = std::forward_iterator_tag;
     using value_type = double;
     using difference_type = void; // type used by operator-(iterator), not implemented for forward iterator
     using reference = value_type; // type used by operator*(), not actually a reference
-    using pointer = void;     // type used by operator->(), not implemented
-    iterator(const RangeType& range, iter_state state) :
-      range(range), val(range.begin_val), state(state),
-      num_values(range.numValues()), i_step(state == iter_state::RANGE_END ? num_values : 0)
-    {
-      if (std::isnan(range.begin_val) || std::isnan(range.end_val) ||
-          std::isnan(range.step_val) || range.step_val == 0) {
+    using pointer = void; // type used by operator->(), not implemented
+    iterator (const RangeType &range, iter_state state)
+      : range (range)
+      , val (range.begin_val)
+      , state (state)
+      , num_values (range.numValues ())
+      , i_step (state == iter_state::RANGE_END ? num_values : 0) {
+      if (std::isnan (range.begin_val) || std::isnan (range.end_val) ||
+          std::isnan (range.step_val) || range.step_val == 0) {
         i_step = num_values;
       }
-      update_state();
+      update_state ();
     }
 
-    iterator& operator++() {
+    iterator &operator++ () {
       val = range.begin_val + range.step_val * ++i_step;
-      update_state();
+      update_state ();
       return *this;
     }
 
-    reference operator*() { return val; }
+    reference operator* () {
+      return val;
+    }
 
-    bool operator==(const iterator& other) const {
+    bool operator== (const iterator &other) const {
       return (val == other.val || state != iter_state::RANGE_RUNNING) &&
              state == other.state && range == other.range;
     }
-    bool operator!=(const iterator& other) const { return !(*this == other); }
-private:
-    const RangeType& range;
+    bool operator!= (const iterator &other) const {
+      return !(*this == other);
+    }
+
+  private:
+    const RangeType &range;
     double val;
     iter_state state;
     const uint32_t num_values;
     uint32_t i_step;
-    void update_state() {
+    void update_state () {
       if (i_step >= num_values) {
         state = iter_state::RANGE_END;
       }
     }
-
   };
 
-  RangeType(const RangeType&) = delete;       // never copy, move instead
-  RangeType& operator=(const RangeType&) = delete; // never copy, move instead
-  RangeType(RangeType&&) = default;
-  RangeType& operator=(RangeType&&) = default;
-  ~RangeType() = default;
-
-  explicit RangeType(double begin, double step, double end)
-    : begin_val(begin), step_val(step), end_val(end) {}
-
-  bool operator==(const RangeType& other) const {
-    auto n1 = this->numValues();
-    auto n2 = other.numValues();
-    if (n1 == 0) return n2 == 0;
-    if (n2 == 0) return false;
+  RangeType (const RangeType &) = delete; // never copy, move instead
+  RangeType &operator= (const RangeType &) = delete; // never copy, move instead
+  RangeType (RangeType &&) = default;
+  RangeType &operator= (RangeType &&) = default;
+  ~RangeType () = default;
+
+  explicit RangeType (double begin, double step, double end)
+    : begin_val (begin)
+    , step_val (step)
+    , end_val (end) {}
+
+  bool operator== (const RangeType &other) const {
+    auto n1 = this->numValues ();
+    auto n2 = other.numValues ();
+    if (n1 == 0)
+      return n2 == 0;
+    if (n2 == 0)
+      return false;
     return this == &other ||
            (this->begin_val == other.begin_val &&
             this->step_val == other.step_val &&
             n1 == n2);
   }
 
-  bool operator!=(const RangeType& other) const {
+  bool operator!= (const RangeType &other) const {
     return !(*this == other);
   }
 
-  bool operator<(const RangeType& other) const {
-    auto n1 = this->numValues();
-    auto n2 = other.numValues();
-    if (n1 == 0) return 0 < n2;
-    if (n2 == 0) return false;
+  bool operator< (const RangeType &other) const {
+    auto n1 = this->numValues ();
+    auto n2 = other.numValues ();
+    if (n1 == 0)
+      return 0 < n2;
+    if (n2 == 0)
+      return false;
     return this->begin_val < other.begin_val ||
            (this->begin_val == other.begin_val &&
-            (this->step_val < other.step_val || (this->step_val == other.step_val && n1 < n2))
-           );
+            (this->step_val < other.step_val || (this->step_val == other.step_val && n1 < n2)));
   }
 
-  bool operator<=(const RangeType& other) const {
-    auto n1 = this->numValues();
-    auto n2 = other.numValues();
-    if (n1 == 0) return true; // (0 <= n2) is always true
-    if (n2 == 0) return false;
+  bool operator<= (const RangeType &other) const {
+    auto n1 = this->numValues ();
+    auto n2 = other.numValues ();
+    if (n1 == 0)
+      return true; // (0 <= n2) is always true
+    if (n2 == 0)
+      return false;
     return this->begin_val < other.begin_val ||
            (this->begin_val == other.begin_val &&
-            (this->step_val < other.step_val || (this->step_val == other.step_val && n1 <= n2))
-           );
+            (this->step_val < other.step_val || (this->step_val == other.step_val && n1 <= n2)));
   }
 
-  bool operator>(const RangeType& other) const {
-    auto n1 = this->numValues();
-    auto n2 = other.numValues();
-    if (n2 == 0) return n1 > 0;
-    if (n1 == 0) return false;
+  bool operator> (const RangeType &other) const {
+    auto n1 = this->numValues ();
+    auto n2 = other.numValues ();
+    if (n2 == 0)
+      return n1 > 0;
+    if (n1 == 0)
+      return false;
     return this->begin_val > other.begin_val ||
            (this->begin_val == other.begin_val &&
-            (this->step_val > other.step_val || (this->step_val == other.step_val && n1 > n2))
-           );
+            (this->step_val > other.step_val || (this->step_val == other.step_val && n1 > n2)));
   }
 
-  bool operator>=(const RangeType& other) const {
-    auto n1 = this->numValues();
-    auto n2 = other.numValues();
-    if (n2 == 0) return true; // (n1 >= 0) is always true
-    if (n1 == 0) return false;
+  bool operator>= (const RangeType &other) const {
+    auto n1 = this->numValues ();
+    auto n2 = other.numValues ();
+    if (n2 == 0)
+      return true; // (n1 >= 0) is always true
+    if (n1 == 0)
+      return false;
     return this->begin_val > other.begin_val ||
            (this->begin_val == other.begin_val &&
-            (this->step_val > other.step_val || (this->step_val == other.step_val && n1 >= n2))
-           );
+            (this->step_val > other.step_val || (this->step_val == other.step_val && n1 >= n2)));
   }
 
-  [[nodiscard]] double begin_value() const { return begin_val; }
-  [[nodiscard]] double step_value() const { return step_val; }
-  [[nodiscard]] double end_value() const { return end_val; }
+  [[nodiscard]] double begin_value () const {
+    return begin_val;
+  }
+  [[nodiscard]] double step_value () const {
+    return step_val;
+  }
+  [[nodiscard]] double end_value () const {
+    return end_val;
+  }
 
-  [[nodiscard]] iterator begin() const { return {*this, iter_state::RANGE_BEGIN}; }
-  [[nodiscard]] iterator end() const { return {*this, iter_state::RANGE_END}; }
+  [[nodiscard]] iterator begin () const {
+    return {*this, iter_state::RANGE_BEGIN};
+  }
+  [[nodiscard]] iterator end () const {
+    return {*this, iter_state::RANGE_END};
+  }
 
   /// return number of values, max uint32_t value if step is 0 or range is infinite
-  [[nodiscard]] uint32_t numValues() const {
-    if (std::isnan(begin_val) || std::isnan(end_val) || std::isnan(step_val)) {
+  [[nodiscard]] uint32_t numValues () const {
+    if (std::isnan (begin_val) || std::isnan (end_val) || std::isnan (step_val)) {
       return 0;
     }
     if (step_val < 0) {
-      if (begin_val < end_val) return 0;
+      if (begin_val < end_val)
+        return 0;
     } else {
-      if (begin_val > end_val) return 0;
+      if (begin_val > end_val)
+        return 0;
     }
-    if ((begin_val == end_val) || std::isinf(step_val)) {
+    if ((begin_val == end_val) || std::isinf (step_val)) {
       return 1;
     }
-    if (std::isinf(begin_val) || std::isinf(end_val) || step_val == 0) {
-      return std::numeric_limits<uint32_t>::max();
+    if (std::isinf (begin_val) || std::isinf (end_val) || step_val == 0) {
+      return std::numeric_limits<uint32_t>::max ();
     }
     // Use nextafter to compensate for possible floating point inaccurary where result is just below a whole number.
-    const uint32_t max = std::numeric_limits<uint32_t>::max();
-    uint32_t num_steps = std::nextafter((end_val - begin_val) / step_val, max);
+    const uint32_t max = std::numeric_limits<uint32_t>::max ();
+    uint32_t num_steps = std::nextafter ((end_val - begin_val) / step_val, max);
     return (num_steps == max) ? max : num_steps + 1;
   }
-
 };
 
-std::ostream& operator<<(std::ostream& stream, const RangeType& r);
+std::ostream &operator<< (std::ostream &stream, const RangeType &r);
diff --git a/src/core/RenderNode.cc b/src/core/RenderNode.cc
index 320e67f27..fd3e0c039 100644
--- a/src/core/RenderNode.cc
+++ b/src/core/RenderNode.cc
@@ -36,27 +36,24 @@
 #include <boost/assign/std/vector.hpp>
 using namespace boost::assign; // bring 'operator+=()' into scope
 
-static std::shared_ptr<AbstractNode> builtin_render(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  auto node = std::make_shared<RenderNode>(inst);
+static std::shared_ptr<AbstractNode> builtin_render (const ModuleInstantiation *inst, Arguments arguments, const Children &children) {
+  auto node = std::make_shared<RenderNode> (inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"convexity"});
-  if (parameters["convexity"].type() == Value::Type::NUMBER) {
-    node->convexity = static_cast<int>(parameters["convexity"].toDouble());
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (), {"convexity"});
+  if (parameters["convexity"].type () == Value::Type::NUMBER) {
+    node->convexity = static_cast<int> (parameters["convexity"].toDouble ());
   }
 
-  return children.instantiate(node);
+  return children.instantiate (node);
 }
 
-std::string RenderNode::toString() const
-{
-  return STR(this->name(), "(convexity = ", convexity, ")");
+std::string RenderNode::toString () const {
+  return STR (this->name (), "(convexity = ", convexity, ")");
 }
 
-void register_builtin_render()
-{
-  Builtins::init("render", new BuiltinModule(builtin_render),
-  {
-    "render(convexity = 1)",
-  });
+void register_builtin_render () {
+  Builtins::init ("render", new BuiltinModule (builtin_render),
+                  {
+                    "render(convexity = 1)",
+                  });
 }
diff --git a/src/core/RenderNode.h b/src/core/RenderNode.h
index 02f1e94b6..65580fb06 100644
--- a/src/core/RenderNode.h
+++ b/src/core/RenderNode.h
@@ -7,10 +7,13 @@
 class RenderNode : public AbstractNode
 {
 public:
-  VISITABLE();
-  RenderNode(const ModuleInstantiation *mi) : AbstractNode(mi) { }
-  std::string toString() const override;
-  std::string name() const override { return "render"; }
+  VISITABLE ();
+  RenderNode (const ModuleInstantiation *mi)
+    : AbstractNode (mi) {}
+  std::string toString () const override;
+  std::string name () const override {
+    return "render";
+  }
 
   int convexity{1};
 };
diff --git a/src/core/RenderVariables.cc b/src/core/RenderVariables.cc
index 719e6649c..07b693bd3 100644
--- a/src/core/RenderVariables.cc
+++ b/src/core/RenderVariables.cc
@@ -2,20 +2,18 @@
 #include "core/Context.h"
 #include "core/BuiltinContext.h"
 
-void
-RenderVariables::applyToContext(ContextHandle<BuiltinContext>& context) const
-{
-  context->set_variable("$preview", preview);
-  context->set_variable("$t", time);
+void RenderVariables::applyToContext (ContextHandle<BuiltinContext> &context) const {
+  context->set_variable ("$preview", preview);
+  context->set_variable ("$t", time);
 
-  const auto vpr = camera.getVpr();
-  context->set_variable("$vpr",
-                        VectorType(context->session(), vpr.x(), vpr.y(), vpr.z()));
-  const auto vpt = camera.getVpt();
-  context->set_variable("$vpt",
-                        VectorType(context->session(), vpt.x(), vpt.y(), vpt.z()));
-  const auto vpd = camera.zoomValue();
-  context->set_variable("$vpd", vpd);
-  const auto vpf = camera.fovValue();
-  context->set_variable("$vpf", vpf);
+  const auto vpr = camera.getVpr ();
+  context->set_variable ("$vpr",
+                         VectorType (context->session (), vpr.x (), vpr.y (), vpr.z ()));
+  const auto vpt = camera.getVpt ();
+  context->set_variable ("$vpt",
+                         VectorType (context->session (), vpt.x (), vpt.y (), vpt.z ()));
+  const auto vpd = camera.zoomValue ();
+  context->set_variable ("$vpd", vpd);
+  const auto vpf = camera.fovValue ();
+  context->set_variable ("$vpf", vpf);
 }
diff --git a/src/core/RenderVariables.h b/src/core/RenderVariables.h
index 7e3b117ec..8851a63d2 100644
--- a/src/core/RenderVariables.h
+++ b/src/core/RenderVariables.h
@@ -8,5 +8,5 @@ public:
   bool preview;
   double time;
   Camera camera;
-  void applyToContext(ContextHandle<BuiltinContext>& context) const;
+  void applyToContext (ContextHandle<BuiltinContext> &context) const;
 };
diff --git a/src/core/RoofNode.cc b/src/core/RoofNode.cc
index 979be260e..c3f697478 100644
--- a/src/core/RoofNode.cc
+++ b/src/core/RoofNode.cc
@@ -14,50 +14,48 @@
 #include "core/Parameters.h"
 #include "core/Children.h"
 
-static std::shared_ptr<AbstractNode> builtin_roof(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  auto node = std::make_shared<RoofNode>(inst);
+static std::shared_ptr<AbstractNode> builtin_roof (const ModuleInstantiation *inst, Arguments arguments, const Children &children) {
+  auto node = std::make_shared<RoofNode> (inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(),
-                                            {"method"},
-                                            {"convexity"}
-                                            );
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (),
+                                             {"method"},
+                                             {"convexity"});
 
-  node->fn = parameters["$fn"].toDouble();
-  node->fs = parameters["$fs"].toDouble();
-  node->fa = parameters["$fa"].toDouble();
+  node->fn = parameters["$fn"].toDouble ();
+  node->fs = parameters["$fs"].toDouble ();
+  node->fa = parameters["$fa"].toDouble ();
 
-  node->fa = std::max(node->fa, 0.01);
-  node->fs = std::max(node->fs, 0.01);
+  node->fa = std::max (node->fa, 0.01);
+  node->fs = std::max (node->fs, 0.01);
   if (node->fn > 0) {
     node->fa = 360.0 / node->fn;
     node->fs = 0.0;
   }
 
-  if (parameters["method"].isUndefined()) {
+  if (parameters["method"].isUndefined ()) {
     node->method = "voronoi";
   } else {
-    node->method = parameters["method"].toString();
+    node->method = parameters["method"].toString ();
     // method can only be one of...
     if (node->method != "voronoi" && node->method != "straight") {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
-          "Unknown roof method '" + node->method + "'. Using 'voronoi'.");
+      LOG (message_group::Warning, inst->location (), parameters.documentRoot (),
+           "Unknown roof method '" + node->method + "'. Using 'voronoi'.");
       node->method = "voronoi";
     }
   }
 
   double tmp_convexity = 0.0;
-  parameters["convexity"].getFiniteDouble(tmp_convexity);
-  node->convexity = static_cast<int>(tmp_convexity);
-  if (node->convexity <= 0) node->convexity = 1;
+  parameters["convexity"].getFiniteDouble (tmp_convexity);
+  node->convexity = static_cast<int> (tmp_convexity);
+  if (node->convexity <= 0)
+    node->convexity = 1;
 
-  children.instantiate(node);
+  children.instantiate (node);
 
   return node;
 }
 
-std::string RoofNode::toString() const
-{
+std::string RoofNode::toString () const {
   std::stringstream stream;
 
   stream << "roof(method = \"" << this->method << "\""
@@ -67,12 +65,9 @@ std::string RoofNode::toString() const
          << ", convexity = " << this->convexity
          << ")";
 
-  return stream.str();
+  return stream.str ();
 }
 
-void register_builtin_roof()
-{
-  Builtins::init("roof", new BuiltinModule(builtin_roof, &Feature::ExperimentalRoof), {
-    "roof(method = \"voronoi\")"
-  });
+void register_builtin_roof () {
+  Builtins::init ("roof", new BuiltinModule (builtin_roof, &Feature::ExperimentalRoof), {"roof(method = \"voronoi\")"});
 }
diff --git a/src/core/RoofNode.h b/src/core/RoofNode.h
index 127ea855f..bf6094f09 100644
--- a/src/core/RoofNode.h
+++ b/src/core/RoofNode.h
@@ -13,10 +13,13 @@
 class RoofNode : public AbstractPolyNode
 {
 public:
-  VISITABLE();
-  RoofNode(const ModuleInstantiation *mi) : AbstractPolyNode(mi) {}
-  std::string toString() const override;
-  std::string name() const override { return "roof"; }
+  VISITABLE ();
+  RoofNode (const ModuleInstantiation *mi)
+    : AbstractPolyNode (mi) {}
+  std::string toString () const override;
+  std::string name () const override {
+    return "roof";
+  }
 
   double fa, fs, fn;
   int convexity = 1;
@@ -24,10 +27,14 @@ public:
 
   class roof_exception : public std::exception
   {
-public:
-    roof_exception(std::string message) : m(std::move(message)) {}
-    std::string message() {return m;}
-private:
+  public:
+    roof_exception (std::string message)
+      : m (std::move (message)) {}
+    std::string message () {
+      return m;
+    }
+
+  private:
     std::string m;
   };
 };
diff --git a/src/core/RotateExtrudeNode.cc b/src/core/RotateExtrudeNode.cc
index 38ab24ef9..b7c7f9481 100644
--- a/src/core/RotateExtrudeNode.cc
+++ b/src/core/RotateExtrudeNode.cc
@@ -43,62 +43,67 @@ using namespace boost::assign; // bring 'operator+=()' into scope
 
 namespace {
 
-std::shared_ptr<AbstractNode> builtin_rotate_extrude(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  auto node = std::make_shared<RotateExtrudeNode>(inst);
+std::shared_ptr<AbstractNode> builtin_rotate_extrude (const ModuleInstantiation *inst, Arguments arguments, const Children &children) {
+  auto node = std::make_shared<RotateExtrudeNode> (inst);
 
-  const Parameters parameters = Parameters::parse(std::move(arguments), inst->location(),
-                                                  {"angle", "start"}, {"convexity", "a"});
+  const Parameters parameters = Parameters::parse (std::move (arguments), inst->location (),
+                                                   {"angle", "start"}, {"convexity", "a"});
 
-  node->fn = parameters["$fn"].toDouble();
-  node->fs = parameters["$fs"].toDouble();
-  node->fa = parameters["$fa"].toDouble();
+  node->fn = parameters["$fn"].toDouble ();
+  node->fs = parameters["$fs"].toDouble ();
+  node->fa = parameters["$fa"].toDouble ();
 
-  node->convexity = static_cast<int>(parameters["convexity"].toDouble());
+  node->convexity = static_cast<int> (parameters["convexity"].toDouble ());
   // If an angle is specified, use it, defaulting to starting at zero.
   // If no angle is specified, use 360 and default to starting at 180.
   // Regardless, if a start angle is specified, use it.
-  bool hasAngle = parameters[{"angle", "a"}].getFiniteDouble(node->angle);
+  bool hasAngle = parameters[{"angle", "a"}].getFiniteDouble (node->angle);
   if (hasAngle) {
     node->start = 0;
-    if ((node->angle <= -360) || (node->angle > 360)) node->angle = 360;
+    if ((node->angle <= -360) || (node->angle > 360))
+      node->angle = 360;
   } else {
     node->angle = 360;
     node->start = 180;
   }
-  bool hasStart = parameters["start"].getFiniteDouble(node->start);
+  bool hasStart = parameters["start"].getFiniteDouble (node->start);
   if (!hasAngle && !hasStart && (int)node->fn % 2 != 0) {
-    LOG(message_group::Deprecated, "In future releases, rotational extrusion without \"angle\" will start at zero, the +X axis.  Set start=180 to explicitly start on the -X axis.");
+    LOG (message_group::Deprecated, "In future releases, rotational extrusion without \"angle\" will start at zero, the +X axis.  Set start=180 to explicitly start on the -X axis.");
   }
 
-  if (node->convexity <= 0) node->convexity = 2;
+  if (node->convexity <= 0)
+    node->convexity = 2;
 
-  children.instantiate(node);
+  children.instantiate (node);
 
   return node;
 }
 
-}  // namespace
+} // namespace
 
-std::string RotateExtrudeNode::toString() const
-{
+std::string RotateExtrudeNode::toString () const {
   std::ostringstream stream;
 
-  stream << this->name() << "("
-    "angle = " << this->angle << ", "
-    "start = " << this->start << ", "
-    "convexity = " << this->convexity << ", "
-    "$fn = " << this->fn << ", "
-    "$fa = " << this->fa << ", "
-    "$fs = " << this->fs << ")";
+  stream << this->name () << "("
+                             "angle = "
+         << this->angle << ", "
+                           "start = "
+         << this->start << ", "
+                           "convexity = "
+         << this->convexity << ", "
+                               "$fn = "
+         << this->fn << ", "
+                        "$fa = "
+         << this->fa << ", "
+                        "$fs = "
+         << this->fs << ")";
 
-  return stream.str();
+  return stream.str ();
 }
 
-void register_builtin_rotate_extrude()
-{
-  Builtins::init("rotate_extrude", new BuiltinModule(builtin_rotate_extrude),
-  {
-    "rotate_extrude(angle = 360, convexity = 2)",
-  });
+void register_builtin_rotate_extrude () {
+  Builtins::init ("rotate_extrude", new BuiltinModule (builtin_rotate_extrude),
+                  {
+                    "rotate_extrude(angle = 360, convexity = 2)",
+                  });
 }
diff --git a/src/core/RotateExtrudeNode.h b/src/core/RotateExtrudeNode.h
index 0827326c7..44f1b8769 100644
--- a/src/core/RotateExtrudeNode.h
+++ b/src/core/RotateExtrudeNode.h
@@ -9,15 +9,18 @@
 class RotateExtrudeNode : public AbstractPolyNode
 {
 public:
-  VISITABLE();
-  RotateExtrudeNode(const ModuleInstantiation *mi) : AbstractPolyNode(mi) {
+  VISITABLE ();
+  RotateExtrudeNode (const ModuleInstantiation *mi)
+    : AbstractPolyNode (mi) {
     convexity = 0;
     fn = fs = fa = 0;
     angle = 360;
     start = 0;
   }
-  std::string toString() const override;
-  std::string name() const override { return "rotate_extrude"; }
+  std::string toString () const override;
+  std::string name () const override {
+    return "rotate_extrude";
+  }
 
   int convexity;
   double fn, fs, fa;
diff --git a/src/core/ScopeContext.cc b/src/core/ScopeContext.cc
index 9ce02825c..52247b66e 100644
--- a/src/core/ScopeContext.cc
+++ b/src/core/ScopeContext.cc
@@ -55,21 +55,20 @@ void ScopeContext::evaluateAssignments(const AssignmentList& assignments)
 }
 #endif // if 0
 
-void ScopeContext::init()
-{
-  for (const auto& assignment : scope->assignments) {
-    if (assignment->getExpr()->isLiteral() && lookup_local_variable(assignment->getName())) {
-      LOG(message_group::Warning, assignment->location(), this->documentRoot(), "Parameter %1$s is overwritten with a literal", quoteVar(assignment->getName()));
+void ScopeContext::init () {
+  for (const auto &assignment : scope->assignments) {
+    if (assignment->getExpr ()->isLiteral () && lookup_local_variable (assignment->getName ())) {
+      LOG (message_group::Warning, assignment->location (), this->documentRoot (), "Parameter %1$s is overwritten with a literal", quoteVar (assignment->getName ()));
     }
-    try{
-      set_variable(assignment->getName(), assignment->getExpr()->evaluate(get_shared_ptr()));
-    } catch (EvaluationException& e) {
+    try {
+      set_variable (assignment->getName (), assignment->getExpr ()->evaluate (get_shared_ptr ()));
+    } catch (EvaluationException &e) {
       if (e.traceDepth > 0) {
-        if (assignment->locationOfOverwrite().isNone()){
-          LOG(message_group::Trace, assignment->location(), this->documentRoot(), "assignment to %1$s", quoteVar(assignment->getName()));
+        if (assignment->locationOfOverwrite ().isNone ()) {
+          LOG (message_group::Trace, assignment->location (), this->documentRoot (), "assignment to %1$s", quoteVar (assignment->getName ()));
         } else {
-          LOG(message_group::Trace, assignment->location(), this->documentRoot(), "overwritten assignment to %1$s (this is where the assignment is evaluated)", quoteVar(assignment->getName()));
-          LOG(message_group::Trace, assignment->locationOfOverwrite(), this->documentRoot(), "overwriting assignment to %1$s", quoteVar(assignment->getName()));
+          LOG (message_group::Trace, assignment->location (), this->documentRoot (), "overwritten assignment to %1$s (this is where the assignment is evaluated)", quoteVar (assignment->getName ()));
+          LOG (message_group::Trace, assignment->locationOfOverwrite (), this->documentRoot (), "overwriting assignment to %1$s", quoteVar (assignment->getName ()));
         }
         e.traceDepth--;
       }
@@ -77,83 +76,77 @@ void ScopeContext::init()
     }
   }
 
-// Experimental code. See issue #399
-//	evaluateAssignments(module.scope.assignments);
+  // Experimental code. See issue #399
+  //	evaluateAssignments(module.scope.assignments);
 }
 
-boost::optional<CallableFunction> ScopeContext::lookup_local_function(const std::string& name, const Location& loc) const
-{
-  const auto& search = scope->functions.find(name);
-  if (search != scope->functions.end()) {
-    return CallableFunction{CallableUserFunction{get_shared_ptr(), search->second.get()}};
+boost::optional<CallableFunction> ScopeContext::lookup_local_function (const std::string &name, const Location &loc) const {
+  const auto &search = scope->functions.find (name);
+  if (search != scope->functions.end ()) {
+    return CallableFunction{CallableUserFunction{get_shared_ptr (), search->second.get ()}};
   }
-  return Context::lookup_local_function(name, loc);
+  return Context::lookup_local_function (name, loc);
 }
 
-boost::optional<InstantiableModule> ScopeContext::lookup_local_module(const std::string& name, const Location& loc) const
-{
-  const auto& search = scope->modules.find(name);
-  if (search != scope->modules.end()) {
-    return InstantiableModule{get_shared_ptr(), search->second.get()};
+boost::optional<InstantiableModule> ScopeContext::lookup_local_module (const std::string &name, const Location &loc) const {
+  const auto &search = scope->modules.find (name);
+  if (search != scope->modules.end ()) {
+    return InstantiableModule{get_shared_ptr (), search->second.get ()};
   }
-  return Context::lookup_local_module(name, loc);
+  return Context::lookup_local_module (name, loc);
 }
 
-UserModuleContext::UserModuleContext(const std::shared_ptr<const Context>& parent, const UserModule *module, const Location& loc, Arguments arguments, Children children) :
-  ScopeContext(parent, &module->body),
-  children(std::move(children))
-{
-  set_variable("$children", Value(double(this->children.size())));
-  set_variable("$parent_modules", Value(double(StaticModuleNameStack::size())));
-  apply_variables(Parameters::parse(std::move(arguments), loc, module->parameters, parent).to_context_frame());
+UserModuleContext::UserModuleContext (const std::shared_ptr<const Context> &parent, const UserModule *module, const Location &loc, Arguments arguments, Children children)
+  : ScopeContext (parent, &module->body)
+  , children (std::move (children)) {
+  set_variable ("$children", Value (double (this->children.size ())));
+  set_variable ("$parent_modules", Value (double (StaticModuleNameStack::size ())));
+  apply_variables (Parameters::parse (std::move (arguments), loc, module->parameters, parent).to_context_frame ());
 }
 
-std::vector<const std::shared_ptr<const Context> *> UserModuleContext::list_referenced_contexts() const
-{
-  std::vector<const std::shared_ptr<const Context> *> output = Context::list_referenced_contexts();
-  output.push_back(&children.getContext());
+std::vector<const std::shared_ptr<const Context> *> UserModuleContext::list_referenced_contexts () const {
+  std::vector<const std::shared_ptr<const Context> *> output = Context::list_referenced_contexts ();
+  output.push_back (&children.getContext ());
   return output;
 }
 
-boost::optional<CallableFunction> FileContext::lookup_local_function(const std::string& name, const Location& loc) const
-{
-  auto result = ScopeContext::lookup_local_function(name, loc);
+boost::optional<CallableFunction> FileContext::lookup_local_function (const std::string &name, const Location &loc) const {
+  auto result = ScopeContext::lookup_local_function (name, loc);
   if (result) {
     return result;
   }
 
-  for (const auto& m : source_file->usedlibs) {
+  for (const auto &m : source_file->usedlibs) {
     // usedmod is nullptr if the library wasn't be compiled (error or file-not-found)
-    auto usedmod = SourceFileCache::instance()->lookup(m);
-    if (usedmod && usedmod->scope.functions.find(name) != usedmod->scope.functions.end()) {
-      ContextHandle<FileContext> context{Context::create<FileContext>(this->parent, usedmod)};
+    auto usedmod = SourceFileCache::instance ()->lookup (m);
+    if (usedmod && usedmod->scope.functions.find (name) != usedmod->scope.functions.end ()) {
+      ContextHandle<FileContext> context{Context::create<FileContext> (this->parent, usedmod)};
 #ifdef DEBUG
-      PRINTDB("FileContext for function %s::%s:", m % name);
-      PRINTDB("%s", context->dump());
+      PRINTDB ("FileContext for function %s::%s:", m % name);
+      PRINTDB ("%s", context->dump ());
 #endif
-      return CallableFunction{CallableUserFunction{*context, usedmod->scope.functions[name].get()}};
+      return CallableFunction{CallableUserFunction{*context, usedmod->scope.functions[name].get ()}};
     }
   }
   return boost::none;
 }
 
-boost::optional<InstantiableModule> FileContext::lookup_local_module(const std::string& name, const Location& loc) const
-{
-  auto result = ScopeContext::lookup_local_module(name, loc);
+boost::optional<InstantiableModule> FileContext::lookup_local_module (const std::string &name, const Location &loc) const {
+  auto result = ScopeContext::lookup_local_module (name, loc);
   if (result) {
     return result;
   }
 
-  for (const auto& m : source_file->usedlibs) {
+  for (const auto &m : source_file->usedlibs) {
     // usedmod is nullptr if the library wasn't be compiled (error or file-not-found)
-    auto usedmod = SourceFileCache::instance()->lookup(m);
-    if (usedmod && usedmod->scope.modules.find(name) != usedmod->scope.modules.end()) {
-      ContextHandle<FileContext> context{Context::create<FileContext>(this->parent, usedmod)};
+    auto usedmod = SourceFileCache::instance ()->lookup (m);
+    if (usedmod && usedmod->scope.modules.find (name) != usedmod->scope.modules.end ()) {
+      ContextHandle<FileContext> context{Context::create<FileContext> (this->parent, usedmod)};
 #ifdef DEBUG
-      PRINTDB("FileContext for module %s::%s:", m % name);
-      PRINTDB("%s", context->dump());
+      PRINTDB ("FileContext for module %s::%s:", m % name);
+      PRINTDB ("%s", context->dump ());
 #endif
-      return InstantiableModule{*context, usedmod->scope.modules[name].get()};
+      return InstantiableModule{*context, usedmod->scope.modules[name].get ()};
     }
   }
   return boost::none;
diff --git a/src/core/ScopeContext.h b/src/core/ScopeContext.h
index a52281741..1361b5cb9 100644
--- a/src/core/ScopeContext.h
+++ b/src/core/ScopeContext.h
@@ -15,19 +15,18 @@ class UserModule;
 class ScopeContext : public Context
 {
 public:
-  void init() override;
-  boost::optional<CallableFunction> lookup_local_function(const std::string& name, const Location& loc) const override;
-  boost::optional<InstantiableModule> lookup_local_module(const std::string& name, const Location& loc) const override;
+  void init () override;
+  boost::optional<CallableFunction> lookup_local_function (const std::string &name, const Location &loc) const override;
+  boost::optional<InstantiableModule> lookup_local_module (const std::string &name, const Location &loc) const override;
 
 protected:
-  ScopeContext(const std::shared_ptr<const Context>& parent, const LocalScope *scope) :
-    Context(parent),
-    scope(scope)
-  {}
+  ScopeContext (const std::shared_ptr<const Context> &parent, const LocalScope *scope)
+    : Context (parent)
+    , scope (scope) {}
 
 private:
-// Experimental code. See issue #399
-//	void evaluateAssignments(const AssignmentList &assignments);
+  // Experimental code. See issue #399
+  //	void evaluateAssignments(const AssignmentList &assignments);
 
   const LocalScope *scope;
 
@@ -37,11 +36,13 @@ private:
 class UserModuleContext : public ScopeContext
 {
 public:
-  const Children *user_module_children() const override { return &children; }
-  std::vector<const std::shared_ptr<const Context> *> list_referenced_contexts() const override;
+  const Children *user_module_children () const override {
+    return &children;
+  }
+  std::vector<const std::shared_ptr<const Context> *> list_referenced_contexts () const override;
 
 protected:
-  UserModuleContext(const std::shared_ptr<const Context>& parent, const UserModule *module, const Location& loc, Arguments arguments, Children children);
+  UserModuleContext (const std::shared_ptr<const Context> &parent, const UserModule *module, const Location &loc, Arguments arguments, Children children);
 
 private:
   Children children;
@@ -52,14 +53,13 @@ private:
 class FileContext : public ScopeContext
 {
 public:
-  boost::optional<CallableFunction> lookup_local_function(const std::string& name, const Location& loc) const override;
-  boost::optional<InstantiableModule> lookup_local_module(const std::string& name, const Location& loc) const override;
+  boost::optional<CallableFunction> lookup_local_function (const std::string &name, const Location &loc) const override;
+  boost::optional<InstantiableModule> lookup_local_module (const std::string &name, const Location &loc) const override;
 
 protected:
-  FileContext(const std::shared_ptr<const Context>& parent, const SourceFile *source_file) :
-    ScopeContext(parent, &source_file->scope),
-    source_file(source_file)
-  {}
+  FileContext (const std::shared_ptr<const Context> &parent, const SourceFile *source_file)
+    : ScopeContext (parent, &source_file->scope)
+    , source_file (source_file) {}
 
 private:
   const SourceFile *source_file;
diff --git a/src/core/Selection.h b/src/core/Selection.h
index 543cdf0e3..9bd8d7b8a 100644
--- a/src/core/Selection.h
+++ b/src/core/Selection.h
@@ -37,4 +37,3 @@ struct SelectedObject {
   Vector3d p1;
   Vector3d p2;
 };
-
diff --git a/src/core/Settings.cc b/src/core/Settings.cc
index 3fb113863..29b324a06 100644
--- a/src/core/Settings.cc
+++ b/src/core/Settings.cc
@@ -26,361 +26,303 @@ namespace {
 
 std::vector<SettingsEntryBase *> entries;
 
-std::vector<SettingsEntryEnum<std::string>::Item> createFileFormatItems(std::vector<FileFormat> formats) {
+std::vector<SettingsEntryEnum<std::string>::Item> createFileFormatItems (std::vector<FileFormat> formats) {
   std::vector<SettingsEntryEnum<std::string>::Item> items;
-  std::transform(formats.begin(), formats.end(), std::back_inserter(items),
-                 [](const FileFormat& format){
-        const FileFormatInfo& info = fileformat::info(format);
-        return SettingsEntryEnum<std::string>::Item{info.identifier, info.identifier, info.description};
-      });
+  std::transform (formats.begin (), formats.end (), std::back_inserter (items),
+                  [] (const FileFormat &format) {
+                    const FileFormatInfo &info = fileformat::info (format);
+                    return SettingsEntryEnum<std::string>::Item{info.identifier, info.identifier, info.description};
+                  });
   return items;
 }
 
-std::vector<SettingsEntryEnum<std::string>::Item> axisValues() {
+std::vector<SettingsEntryEnum<std::string>::Item> axisValues () {
   std::vector<SettingsEntryEnum<std::string>::Item> output;
-  output.push_back({"None", "none", _("None")});
+  output.push_back ({"None", "none", _ ("None")});
   for (size_t i = 0; i < max_axis; ++i) {
-    const auto userData = (boost::format("+%d") % (i + 1)).str();
-    const auto name = (boost::format(_("axis-%d")) % i).str();
-    const auto text = (boost::format(_("Axis %d")) % i).str();
-    output.push_back({userData, name, text});
-    const auto userDataInv = (boost::format("-%d") % (i + 1)).str();
-    const auto nameInv = (boost::format(_("axis-inverted-%d")) % i).str();
-    const auto textInv = (boost::format(_("Axis %d (inverted)")) % i).str();
-    output.push_back({userDataInv, nameInv, textInv});
+    const auto userData = (boost::format ("+%d") % (i + 1)).str ();
+    const auto name = (boost::format (_ ("axis-%d")) % i).str ();
+    const auto text = (boost::format (_ ("Axis %d")) % i).str ();
+    output.push_back ({userData, name, text});
+    const auto userDataInv = (boost::format ("-%d") % (i + 1)).str ();
+    const auto nameInv = (boost::format (_ ("axis-inverted-%d")) % i).str ();
+    const auto textInv = (boost::format (_ ("Axis %d (inverted)")) % i).str ();
+    output.push_back ({userDataInv, nameInv, textInv});
   }
   return output;
 }
 
 } // namespace
 
-void Settings::visit(const SettingsVisitor& visitor)
-{
+void Settings::visit (const SettingsVisitor &visitor) {
   for (SettingsEntryBase *entry : entries) {
-    visitor.handle(*entry);
+    visitor.handle (*entry);
   }
 }
 
-SettingsEntryBase::SettingsEntryBase(std::string category, std::string name) :
-  _category(std::move(category)), _name(std::move(name))
-{
-  entries.push_back(this);
+SettingsEntryBase::SettingsEntryBase (std::string category, std::string name)
+  : _category (std::move (category))
+  , _name (std::move (name)) {
+  entries.push_back (this);
 }
 
-std::string SettingsEntryBool::encode() const
-{
+std::string SettingsEntryBool::encode () const {
   return _value ? "true" : "false";
 }
 
-const bool SettingsEntryBool::decode(const std::string& encoded) const
-{
-  std::string trimmed = boost::algorithm::trim_copy(encoded);
+const bool SettingsEntryBool::decode (const std::string &encoded) const {
+  std::string trimmed = boost::algorithm::trim_copy (encoded);
   if (trimmed == "true") {
     return true;
   } else if (trimmed == "false") {
     return false;
   } else {
     try {
-      return boost::lexical_cast<bool>(trimmed);
-    } catch (const boost::bad_lexical_cast&) {
-      return defaultValue();
+      return boost::lexical_cast<bool> (trimmed);
+    } catch (const boost::bad_lexical_cast &) {
+      return defaultValue ();
     }
   }
 }
 
-std::string SettingsEntryInt::encode() const
-{
-  return STR(_value);
+std::string SettingsEntryInt::encode () const {
+  return STR (_value);
 }
 
-const int SettingsEntryInt::decode(const std::string& encoded) const
-{
+const int SettingsEntryInt::decode (const std::string &encoded) const {
   try {
-    return boost::lexical_cast<int>(boost::algorithm::trim_copy(encoded));
-  } catch (const boost::bad_lexical_cast&) {
-    return defaultValue();
+    return boost::lexical_cast<int> (boost::algorithm::trim_copy (encoded));
+  } catch (const boost::bad_lexical_cast &) {
+    return defaultValue ();
   }
 }
 
-std::string SettingsEntryDouble::encode() const
-{
-  return STR(_value);
+std::string SettingsEntryDouble::encode () const {
+  return STR (_value);
 }
 
-const double SettingsEntryDouble::decode(const std::string& encoded) const
-{
+const double SettingsEntryDouble::decode (const std::string &encoded) const {
   try {
-    return boost::lexical_cast<double>(boost::algorithm::trim_copy(encoded));
-  } catch (const boost::bad_lexical_cast&) {
-    return defaultValue();
+    return boost::lexical_cast<double> (boost::algorithm::trim_copy (encoded));
+  } catch (const boost::bad_lexical_cast &) {
+    return defaultValue ();
   }
 }
 
-std::ostream& operator<<(std::ostream& stream, const LocalAppParameter& param)
-{
+std::ostream &operator<< (std::ostream &stream, const LocalAppParameter &param) {
   json data;
-  data["type"] = static_cast<int>(param.type);
-  if (!param.value.empty()) {
+  data["type"] = static_cast<int> (param.type);
+  if (!param.value.empty ()) {
     data["value"] = param.value;
   }
-  stream << data.dump();
+  stream << data.dump ();
   return stream;
 }
 
-std::istream& operator>>(std::istream& stream, LocalAppParameter& param)
-{
+std::istream &operator>> (std::istream &stream, LocalAppParameter &param) {
   try {
     json data;
     stream >> data;
-    param.type = static_cast<LocalAppParameterType>(data["type"]);
-    if (data.contains("value")) {
+    param.type = static_cast<LocalAppParameterType> (data["type"]);
+    if (data.contains ("value")) {
       param.value = data["value"];
     }
-  } catch (const json::exception& e) {
+  } catch (const json::exception &e) {
     param.type = LocalAppParameterType::invalid;
     param.value = "";
   }
   return stream;
 }
 
-SettingsEntryBool Settings::showWarningsIn3dView("3dview", "showWarningsIn3dView", true);
-SettingsEntryBool Settings::mouseCentricZoom("3dview", "mouseCentricZoom", true);
-SettingsEntryBool Settings::mouseSwapButtons("3dview", "mouseSwapButtons", false);
-SettingsEntryInt Settings::indentationWidth("editor", "indentationWidth", 1, 16, 4);
-SettingsEntryInt Settings::tabWidth("editor", "tabWidth", 1, 16, 4);
-SettingsEntryEnum<std::string> Settings::lineWrap("editor", "lineWrap", {
-    {"None", "none", _("None")},
-    {"Char", "char", _("Wrap at character boundaries")},
-    {"Word", "word", _("Wrap at word boundaries")}
-  }, "Word");
-SettingsEntryEnum<std::string> Settings::lineWrapIndentationStyle("editor", "lineWrapIndentationStyle", {
-    {"Fixed",    "fixed",    _("Fixed")},
-    {"Same",     "same",     _("Same")},
-    {"Indented", "indented", _("Indented")}
-  }, "Fixed");
-SettingsEntryInt Settings::lineWrapIndentation("editor", "lineWrapIndentation", 0, 999, 4);
-SettingsEntryEnum<std::string> Settings::lineWrapVisualizationBegin("editor", "lineWrapVisualizationBegin", {
-    {"None",   "none",   _("None")},
-    {"Text",   "text", _("Text")},
-    {"Border", "border", _("Border")},
-    {"Margin", "margin", _("Margin")}
-  }, "None");
-SettingsEntryEnum<std::string> Settings::lineWrapVisualizationEnd("editor", "lineWrapVisualizationEnd", {
-    {"None",   "none",   _("None")},
-    {"Text",   "text",   _("Text")},
-    {"Border", "border", _("Border")},
-    {"Margin", "margin", _("Margin")}
-  }, "Border");
-SettingsEntryEnum<std::string> Settings::showWhitespace("editor", "showWhitespaces", {
-    {"Never",            "never",        _("Never")},
-    {"Always",           "always",       _("Always")},
-    {"AfterIndentation", "after-indent", _("After indentation")}
-  }, "Never");
-SettingsEntryInt Settings::showWhitespaceSize("editor", "showWhitespacesSize", 1, 16, 2);
-SettingsEntryBool Settings::autoIndent("editor", "autoIndent", true);
-SettingsEntryBool Settings::backspaceUnindents("editor", "backspaceUnindents", false);
-SettingsEntryEnum<std::string> Settings::indentStyle("editor", "indentStyle", {
-    {"Spaces", "spaces", _("Spaces")},
-    {"Tabs",   "tabs",   _("Tabs")}
-  }, "spaces");
-SettingsEntryEnum<std::string> Settings::tabKeyFunction("editor", "tabKeyFunction", {
-    {"Indent",    "indent", _("Indent")},
-    {"InsertTab", "tab",    _("Insert Tab")}
-  }, "Indent");
-SettingsEntryBool Settings::highlightCurrentLine("editor", "highlightCurrentLine", true);
-SettingsEntryBool Settings::enableBraceMatching("editor", "enableBraceMatching", true);
-SettingsEntryBool Settings::enableLineNumbers("editor", "enableLineNumbers", true);
-SettingsEntryBool Settings::enableNumberScrollWheel("editor", "enableNumberScrollWheel", true);
-SettingsEntryEnum<std::string> Settings::modifierNumberScrollWheel("editor", "modifierNumberScrollWheel", {
-    {"Alt",               "alt",               _("Alt")},
-    {"Left Mouse Button", "left-mouse-button", _("Left Mouse Button")},
-    {"Either",            "either",            _("Either")}
-  }, "Alt");
-
-SettingsEntryString Settings::defaultPrintService("printing", "printService", "NONE");
-SettingsEntryBool Settings::enableRemotePrintServices("printing", "enableRemotePrintServices", false);
-SettingsEntryBool Settings::printServiceAlwaysShowDialog("printing", "always-show-dialog", false);
-SettingsEntryString Settings::printServiceName("printing", "printServiceName", "");
-SettingsEntryEnum<std::string> Settings::printServiceFileFormat(
-  "printing", "printServiceFileFormat", createFileFormatItems(fileformat::all3D()),
-  fileformat::info(FileFormat::ASCII_STL).description);
-
-SettingsEntryString Settings::octoPrintUrl("printing", "octoPrintUrl", "");
-SettingsEntryString Settings::octoPrintApiKey("printing", "octoPrintApiKey", "");
-SettingsEntryEnum<std::string> Settings::octoPrintAction("printing", "octoPrintAction", {
-    {"upload", "upload", _("Upload only")},
-    {"slice",  "slice",  _("Upload & Slice")},
-    {"select", "select", _("Upload, Slice & Select for printing")},
-    {"print",  "print",  _("Upload, Slice & Start printing")}
-  }, "upload");
-SettingsEntryString Settings::octoPrintSlicerEngine("printing", "octoPrintSlicerEngine", "");
-SettingsEntryString Settings::octoPrintSlicerEngineDesc("printing", "octoPrintSlicerEngineDesc", "");
-SettingsEntryString Settings::octoPrintSlicerProfile("printing", "octoPrintSlicerProfile", "");
-SettingsEntryString Settings::octoPrintSlicerProfileDesc("printing", "octoPrintSlicerProfileDesc", "");
-SettingsEntryEnum<std::string> Settings::octoPrintFileFormat(
+SettingsEntryBool Settings::showWarningsIn3dView ("3dview", "showWarningsIn3dView", true);
+SettingsEntryBool Settings::mouseCentricZoom ("3dview", "mouseCentricZoom", true);
+SettingsEntryBool Settings::mouseSwapButtons ("3dview", "mouseSwapButtons", false);
+SettingsEntryInt Settings::indentationWidth ("editor", "indentationWidth", 1, 16, 4);
+SettingsEntryInt Settings::tabWidth ("editor", "tabWidth", 1, 16, 4);
+SettingsEntryEnum<std::string> Settings::lineWrap ("editor", "lineWrap", {{"None", "none", _ ("None")}, {"Char", "char", _ ("Wrap at character boundaries")}, {"Word", "word", _ ("Wrap at word boundaries")}}, "Word");
+SettingsEntryEnum<std::string> Settings::lineWrapIndentationStyle ("editor", "lineWrapIndentationStyle", {{"Fixed", "fixed", _ ("Fixed")}, {"Same", "same", _ ("Same")}, {"Indented", "indented", _ ("Indented")}}, "Fixed");
+SettingsEntryInt Settings::lineWrapIndentation ("editor", "lineWrapIndentation", 0, 999, 4);
+SettingsEntryEnum<std::string> Settings::lineWrapVisualizationBegin ("editor", "lineWrapVisualizationBegin", {{"None", "none", _ ("None")}, {"Text", "text", _ ("Text")}, {"Border", "border", _ ("Border")}, {"Margin", "margin", _ ("Margin")}}, "None");
+SettingsEntryEnum<std::string> Settings::lineWrapVisualizationEnd ("editor", "lineWrapVisualizationEnd", {{"None", "none", _ ("None")}, {"Text", "text", _ ("Text")}, {"Border", "border", _ ("Border")}, {"Margin", "margin", _ ("Margin")}}, "Border");
+SettingsEntryEnum<std::string> Settings::showWhitespace ("editor", "showWhitespaces", {{"Never", "never", _ ("Never")}, {"Always", "always", _ ("Always")}, {"AfterIndentation", "after-indent", _ ("After indentation")}}, "Never");
+SettingsEntryInt Settings::showWhitespaceSize ("editor", "showWhitespacesSize", 1, 16, 2);
+SettingsEntryBool Settings::autoIndent ("editor", "autoIndent", true);
+SettingsEntryBool Settings::backspaceUnindents ("editor", "backspaceUnindents", false);
+SettingsEntryEnum<std::string> Settings::indentStyle ("editor", "indentStyle", {{"Spaces", "spaces", _ ("Spaces")}, {"Tabs", "tabs", _ ("Tabs")}}, "spaces");
+SettingsEntryEnum<std::string> Settings::tabKeyFunction ("editor", "tabKeyFunction", {{"Indent", "indent", _ ("Indent")}, {"InsertTab", "tab", _ ("Insert Tab")}}, "Indent");
+SettingsEntryBool Settings::highlightCurrentLine ("editor", "highlightCurrentLine", true);
+SettingsEntryBool Settings::enableBraceMatching ("editor", "enableBraceMatching", true);
+SettingsEntryBool Settings::enableLineNumbers ("editor", "enableLineNumbers", true);
+SettingsEntryBool Settings::enableNumberScrollWheel ("editor", "enableNumberScrollWheel", true);
+SettingsEntryEnum<std::string> Settings::modifierNumberScrollWheel ("editor", "modifierNumberScrollWheel", {{"Alt", "alt", _ ("Alt")}, {"Left Mouse Button", "left-mouse-button", _ ("Left Mouse Button")}, {"Either", "either", _ ("Either")}}, "Alt");
+
+SettingsEntryString Settings::defaultPrintService ("printing", "printService", "NONE");
+SettingsEntryBool Settings::enableRemotePrintServices ("printing", "enableRemotePrintServices", false);
+SettingsEntryBool Settings::printServiceAlwaysShowDialog ("printing", "always-show-dialog", false);
+SettingsEntryString Settings::printServiceName ("printing", "printServiceName", "");
+SettingsEntryEnum<std::string> Settings::printServiceFileFormat (
+  "printing", "printServiceFileFormat", createFileFormatItems (fileformat::all3D ()),
+  fileformat::info (FileFormat::ASCII_STL).description);
+
+SettingsEntryString Settings::octoPrintUrl ("printing", "octoPrintUrl", "");
+SettingsEntryString Settings::octoPrintApiKey ("printing", "octoPrintApiKey", "");
+SettingsEntryEnum<std::string> Settings::octoPrintAction ("printing", "octoPrintAction", {{"upload", "upload", _ ("Upload only")}, {"slice", "slice", _ ("Upload & Slice")}, {"select", "select", _ ("Upload, Slice & Select for printing")}, {"print", "print", _ ("Upload, Slice & Start printing")}}, "upload");
+SettingsEntryString Settings::octoPrintSlicerEngine ("printing", "octoPrintSlicerEngine", "");
+SettingsEntryString Settings::octoPrintSlicerEngineDesc ("printing", "octoPrintSlicerEngineDesc", "");
+SettingsEntryString Settings::octoPrintSlicerProfile ("printing", "octoPrintSlicerProfile", "");
+SettingsEntryString Settings::octoPrintSlicerProfileDesc ("printing", "octoPrintSlicerProfileDesc", "");
+SettingsEntryEnum<std::string> Settings::octoPrintFileFormat (
   "printing", "octoPrintFileFormat",
-  createFileFormatItems({FileFormat::ASCII_STL, FileFormat::BINARY_STL, FileFormat::_3MF, FileFormat::OFF}),
-  fileformat::info(FileFormat::ASCII_STL).description);
-
-SettingsEntryString Settings::localAppExecutable("printing", "localAppExecutable", "");
-SettingsEntryString Settings::localAppTempDir("printing", "localAppTempDir", "");
-SettingsEntryEnum<std::string> Settings::localAppFileFormat(
-  "printing", "localAppFileFormat", createFileFormatItems(fileformat::all3D()),
-  fileformat::info(FileFormat::ASCII_STL).description);
-SettingsEntryList<LocalAppParameter> Settings::localAppParameterList("printing", "localAppParameterList");
-
-SettingsEntryEnum<std::string> Settings::renderBackend3D("advanced", "renderBackend3D", {
-    {"CGAL",     "cgal",     "CGAL (old/slow)"},
-    {"Manifold", "manifold", "Manifold (new/fast)"}
-  }, "CGAL");
-SettingsEntryEnum<std::string> Settings::toolbarExport3D("advanced", "toolbarExport3D", createFileFormatItems(fileformat::all3D()), fileformat::info(FileFormat::ASCII_STL).description);
-SettingsEntryEnum<std::string> Settings::toolbarExport2D("advanced", "toolbarExport2D", createFileFormatItems(fileformat::all2D()), fileformat::info(FileFormat::DXF).description);
-
-SettingsEntryBool Settings::summaryCamera("summary", "camera", false);
-SettingsEntryBool Settings::summaryArea("summary", "measurementArea", false);
-SettingsEntryBool Settings::summaryBoundingBox("summary", "boundingBox", false);
-
-SettingsEntryBool Settings::inputEnableDriverHIDAPI("input", "enableDriverHIDAPI", false);
-SettingsEntryBool Settings::inputEnableDriverHIDAPILog("input", "enableDriverHIDAPILog", false);
-SettingsEntryBool Settings::inputEnableDriverSPNAV("input", "enableDriverSPNAV", false);
-SettingsEntryBool Settings::inputEnableDriverJOYSTICK("input", "enableDriverJOYSTICK", false);
-SettingsEntryBool Settings::inputEnableDriverQGAMEPAD("input", "enableDriverQGAMEPAD", false);
-SettingsEntryBool Settings::inputEnableDriverDBUS("input", "enableDriverDBUS", false);
-
-SettingsEntryEnum<std::string> Settings::inputTranslationX("input", "translationX", axisValues(), "+1");
-SettingsEntryEnum<std::string> Settings::inputTranslationY("input", "translationY", axisValues(), "-2");
-SettingsEntryEnum<std::string> Settings::inputTranslationZ("input", "translationZ", axisValues(), "-3");
-SettingsEntryEnum<std::string> Settings::inputTranslationXVPRel("input", "translationXVPRel", axisValues(), "None");
-SettingsEntryEnum<std::string> Settings::inputTranslationYVPRel("input", "translationYVPRel", axisValues(), "None");
-SettingsEntryEnum<std::string> Settings::inputTranslationZVPRel("input", "translationZVPRel", axisValues(), "None");
-SettingsEntryEnum<std::string> Settings::inputRotateX("input", "rotateX", axisValues(), "+4");
-SettingsEntryEnum<std::string> Settings::inputRotateY("input", "rotateY", axisValues(), "-5");
-SettingsEntryEnum<std::string> Settings::inputRotateZ("input", "rotateZ", axisValues(), "-6");
-SettingsEntryEnum<std::string> Settings::inputRotateXVPRel("input", "rotateXVPRel", axisValues(), "None");
-SettingsEntryEnum<std::string> Settings::inputRotateYVPRel("input", "rotateYVPRel", axisValues(), "None");
-SettingsEntryEnum<std::string> Settings::inputRotateZVPRel("input", "rotateZVPRel", axisValues(), "None");
-SettingsEntryEnum<std::string> Settings::inputZoom("input", "zoom", axisValues(), "None");
-SettingsEntryEnum<std::string> Settings::inputZoom2("input", "zoom2", axisValues(), "None");
-
-SettingsEntryDouble Settings::inputTranslationGain("input", "translationGain", 0.01, 0.01, 9.99, 1.00);
-SettingsEntryDouble Settings::inputTranslationVPRelGain("input", "translationVPRelGain", 0.01, 0.01, 9.99, 1.00);
-SettingsEntryDouble Settings::inputRotateGain("input", "rotateGain", 0.01, 0.01, 9.99, 1.00);
-SettingsEntryDouble Settings::inputRotateVPRelGain("input", "rotateVPRelGain", 0.01, 0.01, 9.99, 1.00);
-SettingsEntryDouble Settings::inputZoomGain("input", "zoomGain", 0.1, 0.1, 99.9, 1.0);
-
-SettingsEntryString Settings::inputButton0("input", "button0", "");
-SettingsEntryString Settings::inputButton1("input", "button1", "");
-SettingsEntryString Settings::inputButton2("input", "button2", "");
-SettingsEntryString Settings::inputButton3("input", "button3", "");
-SettingsEntryString Settings::inputButton4("input", "button4", "");
-SettingsEntryString Settings::inputButton5("input", "button5", "");
-SettingsEntryString Settings::inputButton6("input", "button6", "");
-SettingsEntryString Settings::inputButton7("input", "button7", "");
-SettingsEntryString Settings::inputButton8("input", "button8", "");
-SettingsEntryString Settings::inputButton9("input", "button9", "");
-SettingsEntryString Settings::inputButton10("input", "button10", "");
-SettingsEntryString Settings::inputButton11("input", "button11", "");
-SettingsEntryString Settings::inputButton12("input", "button12", "");
-SettingsEntryString Settings::inputButton13("input", "button13", "");
-SettingsEntryString Settings::inputButton14("input", "button14", "");
-SettingsEntryString Settings::inputButton15("input", "button15", "");
-SettingsEntryString Settings::inputButton16("input", "button16", "");
-SettingsEntryString Settings::inputButton17("input", "button17", "");
-SettingsEntryString Settings::inputButton18("input", "button18", "");
-SettingsEntryString Settings::inputButton19("input", "button19", "");
-SettingsEntryString Settings::inputButton20("input", "button20", "");
-SettingsEntryString Settings::inputButton21("input", "button21", "");
-SettingsEntryString Settings::inputButton22("input", "button22", "");
-SettingsEntryString Settings::inputButton23("input", "button23", "");
-SettingsEntryDouble Settings::axisTrim0("input", "axisTrim0", -1.0, 0.01, 1.0, 0.0);
-SettingsEntryDouble Settings::axisTrim1("input", "axisTrim1", -1.0, 0.01, 1.0, 0.0);
-SettingsEntryDouble Settings::axisTrim2("input", "axisTrim2", -1.0, 0.01, 1.0, 0.0);
-SettingsEntryDouble Settings::axisTrim3("input", "axisTrim3", -1.0, 0.01, 1.0, 0.0);
-SettingsEntryDouble Settings::axisTrim4("input", "axisTrim4", -1.0, 0.01, 1.0, 0.0);
-SettingsEntryDouble Settings::axisTrim5("input", "axisTrim5", -1.0, 0.01, 1.0, 0.0);
-SettingsEntryDouble Settings::axisTrim6("input", "axisTrim6", -1.0, 0.01, 1.0, 0.0);
-SettingsEntryDouble Settings::axisTrim7("input", "axisTrim7", -1.0, 0.01, 1.0, 0.0);
-SettingsEntryDouble Settings::axisTrim8("input", "axisTrim8", -1.0, 0.01, 1.0, 0.0);
-SettingsEntryDouble Settings::axisDeadzone0("input", "axisDeadzone0", 0.0, 0.01, 1.0, 0.10);
-SettingsEntryDouble Settings::axisDeadzone1("input", "axisDeadzone1", 0.0, 0.01, 1.0, 0.10);
-SettingsEntryDouble Settings::axisDeadzone2("input", "axisDeadzone2", 0.0, 0.01, 1.0, 0.10);
-SettingsEntryDouble Settings::axisDeadzone3("input", "axisDeadzone3", 0.0, 0.01, 1.0, 0.10);
-SettingsEntryDouble Settings::axisDeadzone4("input", "axisDeadzone4", 0.0, 0.01, 1.0, 0.10);
-SettingsEntryDouble Settings::axisDeadzone5("input", "axisDeadzone5", 0.0, 0.01, 1.0, 0.10);
-SettingsEntryDouble Settings::axisDeadzone6("input", "axisDeadzone6", 0.0, 0.01, 1.0, 0.10);
-SettingsEntryDouble Settings::axisDeadzone7("input", "axisDeadzone7", 0.0, 0.01, 1.0, 0.10);
-SettingsEntryDouble Settings::axisDeadzone8("input", "axisDeadzone8", 0.0, 0.01, 1.0, 0.10);
-
-SettingsEntryInt Settings::joystickNr("input", "joystickNr", 0, 9, 0);
-
-SettingsEntryString SettingsPython::pythonTrustedFiles(SECTION_PYTHON, "trusted-files", "");
-SettingsEntryString SettingsPython::pythonVirtualEnv(SECTION_PYTHON, "virtual-env", "");
-
-SettingsEntryBool SettingsExportPdf::exportPdfAlwaysShowDialog(SECTION_EXPORT_PDF, "always-show-dialog", true);
-SettingsEntryEnum<ExportPdfPaperSize> SettingsExportPdf::exportPdfPaperSize(SECTION_EXPORT_PDF, "paper-size", {
-    {ExportPdfPaperSize::A6,      "a6",      _("A6 (105 x 148 mm)")},
-    {ExportPdfPaperSize::A5,      "a5",      _("A5 (148 x 210 mm)")},
-    {ExportPdfPaperSize::A4,      "a4",      _("A4 (210x297 mm)")},
-    {ExportPdfPaperSize::A3,      "a3",      _("A3 (297x420 mm)")},
-    {ExportPdfPaperSize::LETTER,  "letter",  _("Letter (8.5x11 in)")},
-    {ExportPdfPaperSize::LEGAL,   "legal",   _("Legal (8.5x14 in)")},
-    {ExportPdfPaperSize::TABLOID, "tabloid", _("Tabloid (11x17 in)")}
-  }, ExportPdfPaperSize::A4);
-SettingsEntryEnum<ExportPdfPaperOrientation> SettingsExportPdf::exportPdfOrientation(SECTION_EXPORT_PDF, "orientation", {
-    {ExportPdfPaperOrientation::PORTRAIT,  "portrait",  _("Portrait (Vertical)")},
-    {ExportPdfPaperOrientation::LANDSCAPE, "landscape", _("Landscape (Horizontal)")},
-    {ExportPdfPaperOrientation::AUTO,      "auto",      _("Auto")}
-  }, ExportPdfPaperOrientation::PORTRAIT);
-SettingsEntryBool SettingsExportPdf::exportPdfShowFilename(SECTION_EXPORT_PDF, "show-filename", false);
-SettingsEntryBool SettingsExportPdf::exportPdfShowScale(SECTION_EXPORT_PDF, "show-scale", true);
-SettingsEntryBool SettingsExportPdf::exportPdfShowScaleMessage(SECTION_EXPORT_PDF, "show-scale-message", true);
-SettingsEntryBool SettingsExportPdf::exportPdfShowGrid(SECTION_EXPORT_PDF, "show-grid", false);
-SettingsEntryDouble SettingsExportPdf::exportPdfGridSize(SECTION_EXPORT_PDF, "grid-size", 1.0, 1.0, 100.0, 10.0);
-SettingsEntryBool SettingsExportPdf::exportPdfAddMetaData(SECTION_EXPORT_PDF, "add-meta-data", true);
-SettingsEntryBool SettingsExportPdf::exportPdfAddMetaDataAuthor(SECTION_EXPORT_PDF, "add-meta-data-author", false);
-SettingsEntryBool SettingsExportPdf::exportPdfAddMetaDataSubject(SECTION_EXPORT_PDF, "add-meta-data-subject", false);
-SettingsEntryBool SettingsExportPdf::exportPdfAddMetaDataKeywords(SECTION_EXPORT_PDF, "add-meta-data-keywords", false);
-SettingsEntryString SettingsExportPdf::exportPdfMetaDataTitle(SECTION_EXPORT_PDF, "meta-data-title", "");
-SettingsEntryString SettingsExportPdf::exportPdfMetaDataAuthor(SECTION_EXPORT_PDF, "meta-data-author", "");
-SettingsEntryString SettingsExportPdf::exportPdfMetaDataSubject(SECTION_EXPORT_PDF, "meta-data-subject", "");
-SettingsEntryString SettingsExportPdf::exportPdfMetaDataKeywords(SECTION_EXPORT_PDF, "meta-data-keywords", "");
-SettingsEntryBool SettingsExportPdf::exportPdfFill(SECTION_EXPORT_PDF, "fill", false);
-SettingsEntryString SettingsExportPdf::exportPdfFillColor(SECTION_EXPORT_PDF, "fill-color", "black");
-SettingsEntryBool SettingsExportPdf::exportPdfStroke(SECTION_EXPORT_PDF, "stroke", true);
-SettingsEntryString SettingsExportPdf::exportPdfStrokeColor(SECTION_EXPORT_PDF, "stroke-color", "black");
-SettingsEntryDouble SettingsExportPdf::exportPdfStrokeWidth(SECTION_EXPORT_PDF, "stroke-width", 0, 0.01, 999, 0.35);
-
-SettingsEntryBool SettingsExport3mf::export3mfAlwaysShowDialog(SECTION_EXPORT_3MF, "always-show-dialog", true);
-SettingsEntryEnum<Export3mfColorMode> SettingsExport3mf::export3mfColorMode(SECTION_EXPORT_3MF, "color-mode", {
-    {Export3mfColorMode::model,               "model",               _("Use colors from model")},
-    {Export3mfColorMode::none,                "none",                _("No colors")},
-    {Export3mfColorMode::selected_only,       "selected-only",       _("Use selected color only")},
-  }, Export3mfColorMode::model);
-SettingsEntryEnum<Export3mfUnit> SettingsExport3mf::export3mfUnit(SECTION_EXPORT_3MF, "unit", {
-    {Export3mfUnit::micron,     "micron",     _("Micron")},
-    {Export3mfUnit::millimeter, "millimeter", _("Millimeter")},
-    {Export3mfUnit::centimeter, "centimeter", _("Centimeter")},
-    {Export3mfUnit::meter,      "meter",      _("Meter")},
-    {Export3mfUnit::inch,       "inch",       _("Inch")},
-    {Export3mfUnit::foot,       "foot",       _("Feet")},
-  }, Export3mfUnit::millimeter);
-SettingsEntryString SettingsExport3mf::export3mfColor(SECTION_EXPORT_3MF, "color", "#f9d72c"); // Cornfield: CGAL_FACE_FRONT_COLOR
-SettingsEntryEnum<Export3mfMaterialType> SettingsExport3mf::export3mfMaterialType(SECTION_EXPORT_3MF, "material-type", {
-    {Export3mfMaterialType::color,        "color",        _("Color")},
-    {Export3mfMaterialType::basematerial, "basematerial", _("Base Material")},
-  }, Export3mfMaterialType::basematerial);
-SettingsEntryInt SettingsExport3mf::export3mfDecimalPrecision(SECTION_EXPORT_3MF, "decimal-precision", 1, 16, 6);
-SettingsEntryBool SettingsExport3mf::export3mfAddMetaData(SECTION_EXPORT_3MF, "add-meta-data", true);
-SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataDesigner(SECTION_EXPORT_3MF, "add-meta-data-designer", false);
-SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataDescription(SECTION_EXPORT_3MF, "add-meta-data-description", false);
-SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataCopyright(SECTION_EXPORT_3MF, "add-meta-data-copyright", false);
-SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataLicenseTerms(SECTION_EXPORT_3MF, "add-meta-data-license-terms", false);
-SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataRating(SECTION_EXPORT_3MF, "add-meta-data-rating", false);
-SettingsEntryString SettingsExport3mf::export3mfMetaDataTitle(SECTION_EXPORT_3MF, "meta-data-title", "");
-SettingsEntryString SettingsExport3mf::export3mfMetaDataDesigner(SECTION_EXPORT_3MF, "meta-data-designer", "");
-SettingsEntryString SettingsExport3mf::export3mfMetaDataDescription(SECTION_EXPORT_3MF, "meta-data-description", "");
-SettingsEntryString SettingsExport3mf::export3mfMetaDataCopyright(SECTION_EXPORT_3MF, "meta-data-copyright", "");
-SettingsEntryString SettingsExport3mf::export3mfMetaDataLicenseTerms(SECTION_EXPORT_3MF, "meta-data-license-terms", "");
-SettingsEntryString SettingsExport3mf::export3mfMetaDataRating(SECTION_EXPORT_3MF, "meta-data-rating", "");
+  createFileFormatItems ({FileFormat::ASCII_STL, FileFormat::BINARY_STL, FileFormat::_3MF, FileFormat::OFF}),
+  fileformat::info (FileFormat::ASCII_STL).description);
+
+SettingsEntryString Settings::localAppExecutable ("printing", "localAppExecutable", "");
+SettingsEntryString Settings::localAppTempDir ("printing", "localAppTempDir", "");
+SettingsEntryEnum<std::string> Settings::localAppFileFormat (
+  "printing", "localAppFileFormat", createFileFormatItems (fileformat::all3D ()),
+  fileformat::info (FileFormat::ASCII_STL).description);
+SettingsEntryList<LocalAppParameter> Settings::localAppParameterList ("printing", "localAppParameterList");
+
+SettingsEntryEnum<std::string> Settings::renderBackend3D ("advanced", "renderBackend3D", {{"CGAL", "cgal", "CGAL (old/slow)"}, {"Manifold", "manifold", "Manifold (new/fast)"}}, "CGAL");
+SettingsEntryEnum<std::string> Settings::toolbarExport3D ("advanced", "toolbarExport3D", createFileFormatItems (fileformat::all3D ()), fileformat::info (FileFormat::ASCII_STL).description);
+SettingsEntryEnum<std::string> Settings::toolbarExport2D ("advanced", "toolbarExport2D", createFileFormatItems (fileformat::all2D ()), fileformat::info (FileFormat::DXF).description);
+
+SettingsEntryBool Settings::summaryCamera ("summary", "camera", false);
+SettingsEntryBool Settings::summaryArea ("summary", "measurementArea", false);
+SettingsEntryBool Settings::summaryBoundingBox ("summary", "boundingBox", false);
+
+SettingsEntryBool Settings::inputEnableDriverHIDAPI ("input", "enableDriverHIDAPI", false);
+SettingsEntryBool Settings::inputEnableDriverHIDAPILog ("input", "enableDriverHIDAPILog", false);
+SettingsEntryBool Settings::inputEnableDriverSPNAV ("input", "enableDriverSPNAV", false);
+SettingsEntryBool Settings::inputEnableDriverJOYSTICK ("input", "enableDriverJOYSTICK", false);
+SettingsEntryBool Settings::inputEnableDriverQGAMEPAD ("input", "enableDriverQGAMEPAD", false);
+SettingsEntryBool Settings::inputEnableDriverDBUS ("input", "enableDriverDBUS", false);
+
+SettingsEntryEnum<std::string> Settings::inputTranslationX ("input", "translationX", axisValues (), "+1");
+SettingsEntryEnum<std::string> Settings::inputTranslationY ("input", "translationY", axisValues (), "-2");
+SettingsEntryEnum<std::string> Settings::inputTranslationZ ("input", "translationZ", axisValues (), "-3");
+SettingsEntryEnum<std::string> Settings::inputTranslationXVPRel ("input", "translationXVPRel", axisValues (), "None");
+SettingsEntryEnum<std::string> Settings::inputTranslationYVPRel ("input", "translationYVPRel", axisValues (), "None");
+SettingsEntryEnum<std::string> Settings::inputTranslationZVPRel ("input", "translationZVPRel", axisValues (), "None");
+SettingsEntryEnum<std::string> Settings::inputRotateX ("input", "rotateX", axisValues (), "+4");
+SettingsEntryEnum<std::string> Settings::inputRotateY ("input", "rotateY", axisValues (), "-5");
+SettingsEntryEnum<std::string> Settings::inputRotateZ ("input", "rotateZ", axisValues (), "-6");
+SettingsEntryEnum<std::string> Settings::inputRotateXVPRel ("input", "rotateXVPRel", axisValues (), "None");
+SettingsEntryEnum<std::string> Settings::inputRotateYVPRel ("input", "rotateYVPRel", axisValues (), "None");
+SettingsEntryEnum<std::string> Settings::inputRotateZVPRel ("input", "rotateZVPRel", axisValues (), "None");
+SettingsEntryEnum<std::string> Settings::inputZoom ("input", "zoom", axisValues (), "None");
+SettingsEntryEnum<std::string> Settings::inputZoom2 ("input", "zoom2", axisValues (), "None");
+
+SettingsEntryDouble Settings::inputTranslationGain ("input", "translationGain", 0.01, 0.01, 9.99, 1.00);
+SettingsEntryDouble Settings::inputTranslationVPRelGain ("input", "translationVPRelGain", 0.01, 0.01, 9.99, 1.00);
+SettingsEntryDouble Settings::inputRotateGain ("input", "rotateGain", 0.01, 0.01, 9.99, 1.00);
+SettingsEntryDouble Settings::inputRotateVPRelGain ("input", "rotateVPRelGain", 0.01, 0.01, 9.99, 1.00);
+SettingsEntryDouble Settings::inputZoomGain ("input", "zoomGain", 0.1, 0.1, 99.9, 1.0);
+
+SettingsEntryString Settings::inputButton0 ("input", "button0", "");
+SettingsEntryString Settings::inputButton1 ("input", "button1", "");
+SettingsEntryString Settings::inputButton2 ("input", "button2", "");
+SettingsEntryString Settings::inputButton3 ("input", "button3", "");
+SettingsEntryString Settings::inputButton4 ("input", "button4", "");
+SettingsEntryString Settings::inputButton5 ("input", "button5", "");
+SettingsEntryString Settings::inputButton6 ("input", "button6", "");
+SettingsEntryString Settings::inputButton7 ("input", "button7", "");
+SettingsEntryString Settings::inputButton8 ("input", "button8", "");
+SettingsEntryString Settings::inputButton9 ("input", "button9", "");
+SettingsEntryString Settings::inputButton10 ("input", "button10", "");
+SettingsEntryString Settings::inputButton11 ("input", "button11", "");
+SettingsEntryString Settings::inputButton12 ("input", "button12", "");
+SettingsEntryString Settings::inputButton13 ("input", "button13", "");
+SettingsEntryString Settings::inputButton14 ("input", "button14", "");
+SettingsEntryString Settings::inputButton15 ("input", "button15", "");
+SettingsEntryString Settings::inputButton16 ("input", "button16", "");
+SettingsEntryString Settings::inputButton17 ("input", "button17", "");
+SettingsEntryString Settings::inputButton18 ("input", "button18", "");
+SettingsEntryString Settings::inputButton19 ("input", "button19", "");
+SettingsEntryString Settings::inputButton20 ("input", "button20", "");
+SettingsEntryString Settings::inputButton21 ("input", "button21", "");
+SettingsEntryString Settings::inputButton22 ("input", "button22", "");
+SettingsEntryString Settings::inputButton23 ("input", "button23", "");
+SettingsEntryDouble Settings::axisTrim0 ("input", "axisTrim0", -1.0, 0.01, 1.0, 0.0);
+SettingsEntryDouble Settings::axisTrim1 ("input", "axisTrim1", -1.0, 0.01, 1.0, 0.0);
+SettingsEntryDouble Settings::axisTrim2 ("input", "axisTrim2", -1.0, 0.01, 1.0, 0.0);
+SettingsEntryDouble Settings::axisTrim3 ("input", "axisTrim3", -1.0, 0.01, 1.0, 0.0);
+SettingsEntryDouble Settings::axisTrim4 ("input", "axisTrim4", -1.0, 0.01, 1.0, 0.0);
+SettingsEntryDouble Settings::axisTrim5 ("input", "axisTrim5", -1.0, 0.01, 1.0, 0.0);
+SettingsEntryDouble Settings::axisTrim6 ("input", "axisTrim6", -1.0, 0.01, 1.0, 0.0);
+SettingsEntryDouble Settings::axisTrim7 ("input", "axisTrim7", -1.0, 0.01, 1.0, 0.0);
+SettingsEntryDouble Settings::axisTrim8 ("input", "axisTrim8", -1.0, 0.01, 1.0, 0.0);
+SettingsEntryDouble Settings::axisDeadzone0 ("input", "axisDeadzone0", 0.0, 0.01, 1.0, 0.10);
+SettingsEntryDouble Settings::axisDeadzone1 ("input", "axisDeadzone1", 0.0, 0.01, 1.0, 0.10);
+SettingsEntryDouble Settings::axisDeadzone2 ("input", "axisDeadzone2", 0.0, 0.01, 1.0, 0.10);
+SettingsEntryDouble Settings::axisDeadzone3 ("input", "axisDeadzone3", 0.0, 0.01, 1.0, 0.10);
+SettingsEntryDouble Settings::axisDeadzone4 ("input", "axisDeadzone4", 0.0, 0.01, 1.0, 0.10);
+SettingsEntryDouble Settings::axisDeadzone5 ("input", "axisDeadzone5", 0.0, 0.01, 1.0, 0.10);
+SettingsEntryDouble Settings::axisDeadzone6 ("input", "axisDeadzone6", 0.0, 0.01, 1.0, 0.10);
+SettingsEntryDouble Settings::axisDeadzone7 ("input", "axisDeadzone7", 0.0, 0.01, 1.0, 0.10);
+SettingsEntryDouble Settings::axisDeadzone8 ("input", "axisDeadzone8", 0.0, 0.01, 1.0, 0.10);
+
+SettingsEntryInt Settings::joystickNr ("input", "joystickNr", 0, 9, 0);
+
+SettingsEntryString SettingsPython::pythonTrustedFiles (SECTION_PYTHON, "trusted-files", "");
+SettingsEntryString SettingsPython::pythonVirtualEnv (SECTION_PYTHON, "virtual-env", "");
+
+SettingsEntryBool SettingsExportPdf::exportPdfAlwaysShowDialog (SECTION_EXPORT_PDF, "always-show-dialog", true);
+SettingsEntryEnum<ExportPdfPaperSize> SettingsExportPdf::exportPdfPaperSize (SECTION_EXPORT_PDF, "paper-size", {{ExportPdfPaperSize::A6, "a6", _ ("A6 (105 x 148 mm)")}, {ExportPdfPaperSize::A5, "a5", _ ("A5 (148 x 210 mm)")}, {ExportPdfPaperSize::A4, "a4", _ ("A4 (210x297 mm)")}, {ExportPdfPaperSize::A3, "a3", _ ("A3 (297x420 mm)")}, {ExportPdfPaperSize::LETTER, "letter", _ ("Letter (8.5x11 in)")}, {ExportPdfPaperSize::LEGAL, "legal", _ ("Legal (8.5x14 in)")}, {ExportPdfPaperSize::TABLOID, "tabloid", _ ("Tabloid (11x17 in)")}}, ExportPdfPaperSize::A4);
+SettingsEntryEnum<ExportPdfPaperOrientation> SettingsExportPdf::exportPdfOrientation (SECTION_EXPORT_PDF, "orientation", {{ExportPdfPaperOrientation::PORTRAIT, "portrait", _ ("Portrait (Vertical)")}, {ExportPdfPaperOrientation::LANDSCAPE, "landscape", _ ("Landscape (Horizontal)")}, {ExportPdfPaperOrientation::AUTO, "auto", _ ("Auto")}}, ExportPdfPaperOrientation::PORTRAIT);
+SettingsEntryBool SettingsExportPdf::exportPdfShowFilename (SECTION_EXPORT_PDF, "show-filename", false);
+SettingsEntryBool SettingsExportPdf::exportPdfShowScale (SECTION_EXPORT_PDF, "show-scale", true);
+SettingsEntryBool SettingsExportPdf::exportPdfShowScaleMessage (SECTION_EXPORT_PDF, "show-scale-message", true);
+SettingsEntryBool SettingsExportPdf::exportPdfShowGrid (SECTION_EXPORT_PDF, "show-grid", false);
+SettingsEntryDouble SettingsExportPdf::exportPdfGridSize (SECTION_EXPORT_PDF, "grid-size", 1.0, 1.0, 100.0, 10.0);
+SettingsEntryBool SettingsExportPdf::exportPdfAddMetaData (SECTION_EXPORT_PDF, "add-meta-data", true);
+SettingsEntryBool SettingsExportPdf::exportPdfAddMetaDataAuthor (SECTION_EXPORT_PDF, "add-meta-data-author", false);
+SettingsEntryBool SettingsExportPdf::exportPdfAddMetaDataSubject (SECTION_EXPORT_PDF, "add-meta-data-subject", false);
+SettingsEntryBool SettingsExportPdf::exportPdfAddMetaDataKeywords (SECTION_EXPORT_PDF, "add-meta-data-keywords", false);
+SettingsEntryString SettingsExportPdf::exportPdfMetaDataTitle (SECTION_EXPORT_PDF, "meta-data-title", "");
+SettingsEntryString SettingsExportPdf::exportPdfMetaDataAuthor (SECTION_EXPORT_PDF, "meta-data-author", "");
+SettingsEntryString SettingsExportPdf::exportPdfMetaDataSubject (SECTION_EXPORT_PDF, "meta-data-subject", "");
+SettingsEntryString SettingsExportPdf::exportPdfMetaDataKeywords (SECTION_EXPORT_PDF, "meta-data-keywords", "");
+SettingsEntryBool SettingsExportPdf::exportPdfFill (SECTION_EXPORT_PDF, "fill", false);
+SettingsEntryString SettingsExportPdf::exportPdfFillColor (SECTION_EXPORT_PDF, "fill-color", "black");
+SettingsEntryBool SettingsExportPdf::exportPdfStroke (SECTION_EXPORT_PDF, "stroke", true);
+SettingsEntryString SettingsExportPdf::exportPdfStrokeColor (SECTION_EXPORT_PDF, "stroke-color", "black");
+SettingsEntryDouble SettingsExportPdf::exportPdfStrokeWidth (SECTION_EXPORT_PDF, "stroke-width", 0, 0.01, 999, 0.35);
+
+SettingsEntryBool SettingsExport3mf::export3mfAlwaysShowDialog (SECTION_EXPORT_3MF, "always-show-dialog", true);
+SettingsEntryEnum<Export3mfColorMode> SettingsExport3mf::export3mfColorMode (SECTION_EXPORT_3MF, "color-mode", {
+                                                                                                                 {Export3mfColorMode::model, "model", _ ("Use colors from model")},
+                                                                                                                 {Export3mfColorMode::none, "none", _ ("No colors")},
+                                                                                                                 {Export3mfColorMode::selected_only, "selected-only", _ ("Use selected color only")},
+                                                                                                               },
+                                                                             Export3mfColorMode::model);
+SettingsEntryEnum<Export3mfUnit> SettingsExport3mf::export3mfUnit (SECTION_EXPORT_3MF, "unit", {
+                                                                                                 {Export3mfUnit::micron, "micron", _ ("Micron")},
+                                                                                                 {Export3mfUnit::millimeter, "millimeter", _ ("Millimeter")},
+                                                                                                 {Export3mfUnit::centimeter, "centimeter", _ ("Centimeter")},
+                                                                                                 {Export3mfUnit::meter, "meter", _ ("Meter")},
+                                                                                                 {Export3mfUnit::inch, "inch", _ ("Inch")},
+                                                                                                 {Export3mfUnit::foot, "foot", _ ("Feet")},
+                                                                                               },
+                                                                   Export3mfUnit::millimeter);
+SettingsEntryString SettingsExport3mf::export3mfColor (SECTION_EXPORT_3MF, "color", "#f9d72c"); // Cornfield: CGAL_FACE_FRONT_COLOR
+SettingsEntryEnum<Export3mfMaterialType> SettingsExport3mf::export3mfMaterialType (SECTION_EXPORT_3MF, "material-type", {
+                                                                                                                          {Export3mfMaterialType::color, "color", _ ("Color")},
+                                                                                                                          {Export3mfMaterialType::basematerial, "basematerial", _ ("Base Material")},
+                                                                                                                        },
+                                                                                   Export3mfMaterialType::basematerial);
+SettingsEntryInt SettingsExport3mf::export3mfDecimalPrecision (SECTION_EXPORT_3MF, "decimal-precision", 1, 16, 6);
+SettingsEntryBool SettingsExport3mf::export3mfAddMetaData (SECTION_EXPORT_3MF, "add-meta-data", true);
+SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataDesigner (SECTION_EXPORT_3MF, "add-meta-data-designer", false);
+SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataDescription (SECTION_EXPORT_3MF, "add-meta-data-description", false);
+SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataCopyright (SECTION_EXPORT_3MF, "add-meta-data-copyright", false);
+SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataLicenseTerms (SECTION_EXPORT_3MF, "add-meta-data-license-terms", false);
+SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataRating (SECTION_EXPORT_3MF, "add-meta-data-rating", false);
+SettingsEntryString SettingsExport3mf::export3mfMetaDataTitle (SECTION_EXPORT_3MF, "meta-data-title", "");
+SettingsEntryString SettingsExport3mf::export3mfMetaDataDesigner (SECTION_EXPORT_3MF, "meta-data-designer", "");
+SettingsEntryString SettingsExport3mf::export3mfMetaDataDescription (SECTION_EXPORT_3MF, "meta-data-description", "");
+SettingsEntryString SettingsExport3mf::export3mfMetaDataCopyright (SECTION_EXPORT_3MF, "meta-data-copyright", "");
+SettingsEntryString SettingsExport3mf::export3mfMetaDataLicenseTerms (SECTION_EXPORT_3MF, "meta-data-license-terms", "");
+SettingsEntryString SettingsExport3mf::export3mfMetaDataRating (SECTION_EXPORT_3MF, "meta-data-rating", "");
 
 } // namespace Settings
diff --git a/src/core/Settings.h b/src/core/Settings.h
index 6755bcf33..7ad1fc2e8 100644
--- a/src/core/Settings.h
+++ b/src/core/Settings.h
@@ -31,18 +31,24 @@ constexpr inline auto SECTION_EXPORT_3MF = "export-3mf";
 class SettingsEntryBase
 {
 public:
-  const std::string& category() const { return _category; }
-  const std::string& name() const { return _name; }
-  const std::string key() const { return category() + "/" + name(); }
+  const std::string &category () const {
+    return _category;
+  }
+  const std::string &name () const {
+    return _name;
+  }
+  const std::string key () const {
+    return category () + "/" + name ();
+  }
 
-  virtual bool isDefault() const = 0;
-  virtual std::string encode() const = 0;
-  virtual void set(const std::string& encoded) = 0;
-  virtual const std::tuple<std::string, std::string> help() const = 0;
+  virtual bool isDefault () const = 0;
+  virtual std::string encode () const = 0;
+  virtual void set (const std::string &encoded) = 0;
+  virtual const std::tuple<std::string, std::string> help () const = 0;
 
 protected:
-  SettingsEntryBase(std::string category, std::string name);
-  virtual ~SettingsEntryBase() = default;
+  SettingsEntryBase (std::string category, std::string name);
+  virtual ~SettingsEntryBase () = default;
 
 private:
   std::string _category;
@@ -55,31 +61,41 @@ class SettingsEntry : public SettingsEntryBase
 public:
   using entry_type_t = entry_type;
 
-  virtual const entry_type decode(const std::string& encoded) const = 0;
+  virtual const entry_type decode (const std::string &encoded) const = 0;
 
 protected:
-  SettingsEntry(const std::string& category, const std::string& name) : SettingsEntryBase(category, name) {}
-  virtual ~SettingsEntry() = default;
+  SettingsEntry (const std::string &category, const std::string &name)
+    : SettingsEntryBase (category, name) {}
+  virtual ~SettingsEntry () = default;
 };
 
 class SettingsEntryBool : public SettingsEntry<bool>
 {
 public:
-  SettingsEntryBool(const std::string& category, const std::string& name, bool defaultValue) :
-    SettingsEntry(category, name),
-    _value(defaultValue),
-    _defaultValue(defaultValue)
-  {}
-
-  bool value() const { return _value; }
-  void setValue(bool value) { _value = value; }
-  bool defaultValue() const { return _defaultValue; }
-  bool isDefault() const override { return _value == _defaultValue; }
-  std::string encode() const override;
-  const bool decode(const std::string& encoded) const override;
-  void set(const std::string& encoded) override { setValue(decode(encoded)); }
-  const std::tuple<std::string, std::string> help() const override {
-    return {"bool", defaultValue() ? "<true>/false" : "true/<false>"};
+  SettingsEntryBool (const std::string &category, const std::string &name, bool defaultValue)
+    : SettingsEntry (category, name)
+    , _value (defaultValue)
+    , _defaultValue (defaultValue) {}
+
+  bool value () const {
+    return _value;
+  }
+  void setValue (bool value) {
+    _value = value;
+  }
+  bool defaultValue () const {
+    return _defaultValue;
+  }
+  bool isDefault () const override {
+    return _value == _defaultValue;
+  }
+  std::string encode () const override;
+  const bool decode (const std::string &encoded) const override;
+  void set (const std::string &encoded) override {
+    setValue (decode (encoded));
+  }
+  const std::tuple<std::string, std::string> help () const override {
+    return {"bool", defaultValue () ? "<true>/false" : "true/<false>"};
   }
 
 private:
@@ -90,25 +106,38 @@ private:
 class SettingsEntryInt : public SettingsEntry<int>
 {
 public:
-  SettingsEntryInt(const std::string& category, const std::string& name, int minimum, int maximum, int defaultValue) :
-    SettingsEntry(category, name),
-    _value(defaultValue),
-    _defaultValue(defaultValue),
-    _minimum(minimum),
-    _maximum(maximum)
-  {}
-
-  int value() const { return _value; }
-  void setValue(int value) { _value = value; }
-  int minimum() const { return _minimum; }
-  int maximum() const { return _maximum; }
-  int defaultValue() const { return _defaultValue; }
-  bool isDefault() const override { return _value == _defaultValue; }
-  std::string encode() const override;
-  const int decode(const std::string& encoded) const override;
-  void set(const std::string& encoded) override { setValue(decode(encoded)); }
-  const std::tuple<std::string, std::string> help() const override {
-    return {"int", std::to_string(_minimum) + " : <" + std::to_string(defaultValue()) + "> : " + std::to_string(maximum())};
+  SettingsEntryInt (const std::string &category, const std::string &name, int minimum, int maximum, int defaultValue)
+    : SettingsEntry (category, name)
+    , _value (defaultValue)
+    , _defaultValue (defaultValue)
+    , _minimum (minimum)
+    , _maximum (maximum) {}
+
+  int value () const {
+    return _value;
+  }
+  void setValue (int value) {
+    _value = value;
+  }
+  int minimum () const {
+    return _minimum;
+  }
+  int maximum () const {
+    return _maximum;
+  }
+  int defaultValue () const {
+    return _defaultValue;
+  }
+  bool isDefault () const override {
+    return _value == _defaultValue;
+  }
+  std::string encode () const override;
+  const int decode (const std::string &encoded) const override;
+  void set (const std::string &encoded) override {
+    setValue (decode (encoded));
+  }
+  const std::tuple<std::string, std::string> help () const override {
+    return {"int", std::to_string (_minimum) + " : <" + std::to_string (defaultValue ()) + "> : " + std::to_string (maximum ())};
   }
 
 private:
@@ -121,27 +150,42 @@ private:
 class SettingsEntryDouble : public SettingsEntry<double>
 {
 public:
-  SettingsEntryDouble(const std::string& category, const std::string& name, double minimum, double step, double maximum, double defaultValue) :
-    SettingsEntry(category, name),
-    _value(defaultValue),
-    _defaultValue(defaultValue),
-    _minimum(minimum),
-    _step(step),
-    _maximum(maximum)
-  {}
-
-  double value() const { return _value; }
-  void setValue(double value) { _value = value; }
-  double minimum() const { return _minimum; }
-  double step() const { return _step; }
-  double maximum() const { return _maximum; }
-  double defaultValue() const { return _defaultValue; }
-  bool isDefault() const override { return _value == _defaultValue; }
-  std::string encode() const override;
-  const double decode(const std::string& encoded) const override;
-  void set(const std::string& encoded) override { setValue(decode(encoded)); }
-  const std::tuple<std::string, std::string> help() const override {
-    return {"double", std::to_string(_minimum) + " : <" + std::to_string(defaultValue()) + "> : " + std::to_string(maximum())};
+  SettingsEntryDouble (const std::string &category, const std::string &name, double minimum, double step, double maximum, double defaultValue)
+    : SettingsEntry (category, name)
+    , _value (defaultValue)
+    , _defaultValue (defaultValue)
+    , _minimum (minimum)
+    , _step (step)
+    , _maximum (maximum) {}
+
+  double value () const {
+    return _value;
+  }
+  void setValue (double value) {
+    _value = value;
+  }
+  double minimum () const {
+    return _minimum;
+  }
+  double step () const {
+    return _step;
+  }
+  double maximum () const {
+    return _maximum;
+  }
+  double defaultValue () const {
+    return _defaultValue;
+  }
+  bool isDefault () const override {
+    return _value == _defaultValue;
+  }
+  std::string encode () const override;
+  const double decode (const std::string &encoded) const override;
+  void set (const std::string &encoded) override {
+    setValue (decode (encoded));
+  }
+  const std::tuple<std::string, std::string> help () const override {
+    return {"double", std::to_string (_minimum) + " : <" + std::to_string (defaultValue ()) + "> : " + std::to_string (maximum ())};
   }
 
 private:
@@ -155,20 +199,35 @@ private:
 class SettingsEntryString : public SettingsEntry<std::string>
 {
 public:
-  SettingsEntryString(const std::string& category, const std::string& name, const std::string& defaultValue) :
-    SettingsEntry(category, name),
-    _value(defaultValue),
-    _defaultValue(defaultValue)
-  {}
-
-  const std::string& value() const { return _value; }
-  void setValue(const std::string& value) { _value = value; }
-  const std::string& defaultValue() const { return _defaultValue; }
-  bool isDefault() const override { return _value == _defaultValue; }
-  std::string encode() const override { return value(); }
-  const std::string decode(const std::string& encoded) const override { return encoded; }
-  void set(const std::string& encoded) override { setValue(decode(encoded)); }
-  const std::tuple<std::string, std::string> help() const override { return {"string", "\"" + encode() + "\""}; }
+  SettingsEntryString (const std::string &category, const std::string &name, const std::string &defaultValue)
+    : SettingsEntry (category, name)
+    , _value (defaultValue)
+    , _defaultValue (defaultValue) {}
+
+  const std::string &value () const {
+    return _value;
+  }
+  void setValue (const std::string &value) {
+    _value = value;
+  }
+  const std::string &defaultValue () const {
+    return _defaultValue;
+  }
+  bool isDefault () const override {
+    return _value == _defaultValue;
+  }
+  std::string encode () const override {
+    return value ();
+  }
+  const std::string decode (const std::string &encoded) const override {
+    return encoded;
+  }
+  void set (const std::string &encoded) override {
+    setValue (decode (encoded));
+  }
+  const std::tuple<std::string, std::string> help () const override {
+    return {"string", "\"" + encode () + "\""};
+  }
 
 private:
   std::string _value;
@@ -180,36 +239,55 @@ class SettingsEntryEnum : public SettingsEntry<enum_type>
 {
 public:
   struct Item {
-    Item(enum_type value, std::string name, std::string description) : value(value), name(std::move(name)), description(std::move(description)) {
+    Item (enum_type value, std::string name, std::string description)
+      : value (value)
+      , name (std::move (name))
+      , description (std::move (description)) {
     }
     enum_type value;
     std::string name;
     std::string description;
   };
-  SettingsEntryEnum(const std::string& category, const std::string& name, std::vector<Item> items, enum_type defaultValue) :
-    SettingsEntry<enum_type>(category, name),
-    _items(std::move(items)),
-    _defaultValue(std::move(defaultValue))
-  {
-    setValue(_defaultValue);
-  }
-
-  const Item& item() const { return _items[_index]; }
-  const enum_type& value() const { return item().value; }
-  size_t index() const { return _index; }
-  void setValue(const enum_type& value);
-  void setIndex(size_t index) { if (index < _items.size()) _index = index; }
-  const std::vector<Item>& items() const { return _items; }
-  const enum_type& defaultValue() const { return _defaultValue; }
-  bool isDefault() const override { return value() == _defaultValue; }
-  std::string encode() const override;
-  const enum_type decode(const std::string& encoded) const override;
-  void set(const std::string& encoded) override { setValue(decode(encoded)); }
-  const std::tuple<std::string, std::string> help() const override {
+  SettingsEntryEnum (const std::string &category, const std::string &name, std::vector<Item> items, enum_type defaultValue)
+    : SettingsEntry<enum_type> (category, name)
+    , _items (std::move (items))
+    , _defaultValue (std::move (defaultValue)) {
+    setValue (_defaultValue);
+  }
+
+  const Item &item () const {
+    return _items[_index];
+  }
+  const enum_type &value () const {
+    return item ().value;
+  }
+  size_t index () const {
+    return _index;
+  }
+  void setValue (const enum_type &value);
+  void setIndex (size_t index) {
+    if (index < _items.size ())
+      _index = index;
+  }
+  const std::vector<Item> &items () const {
+    return _items;
+  }
+  const enum_type &defaultValue () const {
+    return _defaultValue;
+  }
+  bool isDefault () const override {
+    return value () == _defaultValue;
+  }
+  std::string encode () const override;
+  const enum_type decode (const std::string &encoded) const override;
+  void set (const std::string &encoded) override {
+    setValue (decode (encoded));
+  }
+  const std::tuple<std::string, std::string> help () const override {
     std::string sep = "[";
     std::string list = "";
-    for (const auto& item : items()) {
-      const auto def = item.value == defaultValue();
+    for (const auto &item : items ()) {
+      const auto def = item.value == defaultValue ();
       const auto p = def ? "<" : "";
       const auto s = def ? ">" : "";
       list += sep + p + item.name + s;
@@ -226,9 +304,8 @@ private:
 };
 
 template <typename enum_type>
-void SettingsEntryEnum<enum_type>::setValue(const enum_type& value)
-{
-  for (size_t i = 0; i < _items.size(); ++i) {
+void SettingsEntryEnum<enum_type>::setValue (const enum_type &value) {
+  for (size_t i = 0; i < _items.size (); ++i) {
     if (_items[i].value == value) {
       _index = i;
       return;
@@ -237,29 +314,34 @@ void SettingsEntryEnum<enum_type>::setValue(const enum_type& value)
 }
 
 template <typename enum_type>
-std::string SettingsEntryEnum<enum_type>::encode() const { return item().name; }
+std::string SettingsEntryEnum<enum_type>::encode () const {
+  return item ().name;
+}
 
 template <typename enum_type>
-const enum_type SettingsEntryEnum<enum_type>::decode(const std::string& encoded) const {
-  for (const Item& item : items()) {
+const enum_type SettingsEntryEnum<enum_type>::decode (const std::string &encoded) const {
+  for (const Item &item : items ()) {
     if (item.name == encoded) {
       return item.value;
     }
   }
-  return defaultValue();
+  return defaultValue ();
 }
 
 template <>
-inline std::string SettingsEntryEnum<std::string>::encode() const { return value(); }
+inline std::string SettingsEntryEnum<std::string>::encode () const {
+  return value ();
+}
 
 template <>
-inline const std::string SettingsEntryEnum<std::string>::decode(const std::string& encoded) const { return encoded; }
+inline const std::string SettingsEntryEnum<std::string>::decode (const std::string &encoded) const {
+  return encoded;
+}
 
 class LocalAppParameterType
 {
 public:
-  enum Value : uint8_t
-  {
+  enum Value : uint8_t {
     invalid,
     string,
     file,
@@ -269,34 +351,49 @@ public:
     sourcedir
   };
 
-  LocalAppParameterType() = default;
-  constexpr LocalAppParameterType(Value v) : value(v) { }
-  constexpr operator Value() const {
+  LocalAppParameterType () = default;
+  constexpr LocalAppParameterType (Value v)
+    : value (v) {}
+  constexpr operator Value () const {
     return value;
   }
-  explicit operator bool() const = delete;
+  explicit operator bool () const = delete;
 
-  std::string icon() const {
+  std::string icon () const {
     switch (value) {
-    case string: return "chokusen-parameter";
-    case file: return "chokusen-orthogonal";
-    case dir: return "chokusen-folder";
-    case extension: return "chokusen-parameter";
-    case source: return "chokusen-file";
-    case sourcedir: return "chokusen-folder";
-    default: return "*invalid*";
+    case string:
+      return "chokusen-parameter";
+    case file:
+      return "chokusen-orthogonal";
+    case dir:
+      return "chokusen-folder";
+    case extension:
+      return "chokusen-parameter";
+    case source:
+      return "chokusen-file";
+    case sourcedir:
+      return "chokusen-folder";
+    default:
+      return "*invalid*";
     }
   }
 
-  std::string description() const {
+  std::string description () const {
     switch (value) {
-    case string: return "";
-    case file: return "<full path to the output file>";
-    case dir: return "<directory of the output file>";
-    case extension: return "<extension of the output file without leading dot>";
-    case source: return "<full path to the main source file>";
-    case sourcedir: return "<directory of the main source file>";
-    default: return "*invalid*";
+    case string:
+      return "";
+    case file:
+      return "<full path to the output file>";
+    case dir:
+      return "<directory of the output file>";
+    case extension:
+      return "<extension of the output file without leading dot>";
+    case source:
+      return "<full path to the main source file>";
+    case sourcedir:
+      return "<directory of the main source file>";
+    default:
+      return "*invalid*";
     }
   }
 
@@ -308,11 +405,15 @@ struct LocalAppParameter {
   LocalAppParameterType type;
   std::string value;
 
-  LocalAppParameter() : type(LocalAppParameterType::string), value("") {
+  LocalAppParameter ()
+    : type (LocalAppParameterType::string)
+    , value ("") {
   }
-  LocalAppParameter(const LocalAppParameterType t, std::string v) : type(t), value(std::move(v)) {
+  LocalAppParameter (const LocalAppParameterType t, std::string v)
+    : type (t)
+    , value (std::move (v)) {
   }
-  operator bool() const {
+  operator bool () const {
     return type != LocalAppParameterType::invalid;
   }
 };
@@ -322,35 +423,42 @@ class SettingsEntryList : public SettingsEntry<std::vector<item_type>>
 {
 public:
   using list_type_t = std::vector<item_type>;
-  SettingsEntryList(const std::string& category, const std::string& name) :
-    SettingsEntry<std::vector<item_type>>(category, name)
-  {
-  }
-  const list_type_t& value() const { return _items; }
-  void setValue(const list_type_t& items) { _items = items; }
-  bool isDefault() const override { return _items.empty(); }
-  std::string encode() const override {
+  SettingsEntryList (const std::string &category, const std::string &name)
+    : SettingsEntry<std::vector<item_type>> (category, name) {
+  }
+  const list_type_t &value () const {
+    return _items;
+  }
+  void setValue (const list_type_t &items) {
+    _items = items;
+  }
+  bool isDefault () const override {
+    return _items.empty ();
+  }
+  std::string encode () const override {
     std::ostringstream oss;
-    for (const auto& item : _items) {
+    for (const auto &item : _items) {
       oss << item;
     }
-    return oss.str();
+    return oss.str ();
   }
-  const std::vector<item_type> decode(const std::string& encoded) const override {
+  const std::vector<item_type> decode (const std::string &encoded) const override {
     std::vector<item_type> items;
     std::stringstream ss;
     ss << encoded;
-    while (ss.good()) {
+    while (ss.good ()) {
       item_type item;
       ss >> item;
       if (item) {
-        items.push_back(item);
+        items.push_back (item);
       }
     }
     return items;
   }
-  void set(const std::string& encoded) override { setValue(decode(encoded)); }
-  const std::tuple<std::string, std::string> help() const override {
+  void set (const std::string &encoded) override {
+    setValue (decode (encoded));
+  }
+  const std::tuple<std::string, std::string> help () const override {
     return {"list", ""};
   }
 
@@ -484,7 +592,7 @@ public:
   static SettingsEntryDouble axisDeadzone8;
   static SettingsEntryInt joystickNr;
 
-  static void visit(const SettingsVisitor& visitor);
+  static void visit (const SettingsVisitor &visitor);
 };
 
 class SettingsPython
@@ -581,10 +689,10 @@ public:
 class SettingsVisitor
 {
 public:
-  SettingsVisitor() = default;
-  virtual ~SettingsVisitor() = default;
+  SettingsVisitor () = default;
+  virtual ~SettingsVisitor () = default;
 
-  virtual void handle(SettingsEntryBase& entry) const = 0;
+  virtual void handle (SettingsEntryBase &entry) const = 0;
 };
 
 } // namespace Settings
diff --git a/src/core/SourceFile.cc b/src/core/SourceFile.cc
index 3b87eb69a..66d3f762d 100644
--- a/src/core/SourceFile.cc
+++ b/src/core/SourceFile.cc
@@ -46,71 +46,69 @@ namespace fs = std::filesystem;
 #include "FontCache.h"
 #include <sys/stat.h>
 
-SourceFile::SourceFile(std::string path, std::string filename)
-  : ASTNode(Location::NONE), path(std::move(path)), filename(std::move(filename))
-{
+SourceFile::SourceFile (std::string path, std::string filename)
+  : ASTNode (Location::NONE)
+  , path (std::move (path))
+  , filename (std::move (filename)) {
 }
 
-void SourceFile::print(std::ostream& stream, const std::string& indent) const
-{
-  scope.print(stream, indent);
+void SourceFile::print (std::ostream &stream, const std::string &indent) const {
+  scope.print (stream, indent);
 }
 
-void SourceFile::registerUse(const std::string& path, const Location& loc)
-{
-  PRINTDB("registerUse(): (%p) %d, %d - %d, %d (%s) -> %s", this %
-          loc.firstLine() % loc.firstColumn() %
-          loc.lastLine() % loc.lastColumn() %
-          loc.fileName() %
-          path);
+void SourceFile::registerUse (const std::string &path, const Location &loc) {
+  PRINTDB ("registerUse(): (%p) %d, %d - %d, %d (%s) -> %s", this %
+                                                               loc.firstLine () % loc.firstColumn () %
+                                                               loc.lastLine () % loc.lastColumn () %
+                                                               loc.fileName () %
+                                                               path);
 
-  auto ext = fs::path(path).extension().generic_string();
+  auto ext = fs::path (path).extension ().generic_string ();
 
-  if (boost::iequals(ext, ".otf") || boost::iequals(ext, ".ttf")) {
-    if (fs::is_regular_file(path)) {
-      FontCache::instance()->register_font_file(path);
+  if (boost::iequals (ext, ".otf") || boost::iequals (ext, ".ttf")) {
+    if (fs::is_regular_file (path)) {
+      FontCache::instance ()->register_font_file (path);
     } else {
-      LOG(message_group::Error, "Can't read font with path '%1$s'", path);
+      LOG (message_group::Error, "Can't read font with path '%1$s'", path);
     }
   } else {
-    auto pos = std::find(usedlibs.begin(), usedlibs.end(), path);
-    if (pos != usedlibs.end()) usedlibs.erase(pos);
-    usedlibs.insert(usedlibs.begin(), path);
-    if (!loc.isNone()) {
-      indicatorData.emplace_back(loc.firstLine(), loc.firstColumn(), loc.lastLine(), loc.lastColumn(), path);
+    auto pos = std::find (usedlibs.begin (), usedlibs.end (), path);
+    if (pos != usedlibs.end ())
+      usedlibs.erase (pos);
+    usedlibs.insert (usedlibs.begin (), path);
+    if (!loc.isNone ()) {
+      indicatorData.emplace_back (loc.firstLine (), loc.firstColumn (), loc.lastLine (), loc.lastColumn (), path);
     }
   }
 }
 
-void SourceFile::registerInclude(const std::string& localpath, const std::string& fullpath, const Location& loc)
-{
-  PRINTDB("registerInclude(): (%p) %d, %d - %d, %d (%s) -> %s", this %
-          loc.firstLine() % loc.firstColumn() %
-          loc.lastLine() % loc.lastColumn() %
-          localpath %
-          fullpath);
+void SourceFile::registerInclude (const std::string &localpath, const std::string &fullpath, const Location &loc) {
+  PRINTDB ("registerInclude(): (%p) %d, %d - %d, %d (%s) -> %s", this %
+                                                                   loc.firstLine () % loc.firstColumn () %
+                                                                   loc.lastLine () % loc.lastColumn () %
+                                                                   localpath %
+                                                                   fullpath);
 
   this->includes[localpath] = fullpath;
-  if (!loc.isNone()) {
-    indicatorData.emplace_back(loc.firstLine(), loc.firstColumn(), loc.lastLine(), loc.lastColumn(), fullpath);
+  if (!loc.isNone ()) {
+    indicatorData.emplace_back (loc.firstLine (), loc.firstColumn (), loc.lastLine (), loc.lastColumn (), fullpath);
   }
 }
 
-time_t SourceFile::includesChanged() const
-{
+time_t SourceFile::includesChanged () const {
   time_t latest = 0;
-  for (const auto& item : this->includes) {
-    auto mtime = include_modified(item.second);
-    if (mtime > latest) latest = mtime;
+  for (const auto &item : this->includes) {
+    auto mtime = include_modified (item.second);
+    if (mtime > latest)
+      latest = mtime;
   }
   return latest;
 }
 
-time_t SourceFile::include_modified(const std::string& filename) const
-{
+time_t SourceFile::include_modified (const std::string &filename) const {
   struct stat st;
 
-  if (StatCache::stat(filename, st) == 0) {
+  if (StatCache::stat (filename, st) == 0) {
     return st.st_mtime;
   }
 
@@ -121,10 +119,11 @@ time_t SourceFile::include_modified(const std::string& filename) const
    Check if any dependencies have been modified and recompile them.
    Returns true if anything was recompiled.
  */
-time_t SourceFile::handleDependencies(bool is_root)
-{
-  if (is_root) SourceFileCache::clear_markers();
-  else if (this->is_handling_dependencies) return 0;
+time_t SourceFile::handleDependencies (bool is_root) {
+  if (is_root)
+    SourceFileCache::clear_markers ();
+  else if (this->is_handling_dependencies)
+    return 0;
   this->is_handling_dependencies = true;
 
   std::vector<std::pair<std::string, std::string>> updates;
@@ -138,11 +137,11 @@ time_t SourceFile::handleDependencies(bool is_root)
     auto found = true;
 
     // Get an absolute filename for the module
-    if (!fs::path(filename).is_absolute()) {
-      auto fullpath = find_valid_path(this->path, filename);
-      if (!fullpath.empty()) {
-        auto newfilename = fullpath.generic_string();
-        updates.emplace_back(filename, newfilename);
+    if (!fs::path (filename).is_absolute ()) {
+      auto fullpath = find_valid_path (this->path, filename);
+      if (!fullpath.empty ()) {
+        auto newfilename = fullpath.generic_string ();
+        updates.emplace_back (filename, newfilename);
         filename = newfilename;
       } else {
         found = false;
@@ -150,39 +149,40 @@ time_t SourceFile::handleDependencies(bool is_root)
     }
 
     if (found) {
-      auto oldmodule = SourceFileCache::instance()->lookup(filename);
+      auto oldmodule = SourceFileCache::instance ()->lookup (filename);
       SourceFile *newmodule;
-      auto mtime = SourceFileCache::instance()->evaluate(this->getFullpath(), filename, newmodule);
-      if (mtime > latest) latest = mtime;
+      auto mtime = SourceFileCache::instance ()->evaluate (this->getFullpath (), filename, newmodule);
+      if (mtime > latest)
+        latest = mtime;
       auto changed = newmodule && newmodule != oldmodule;
       // Detect appearance but not removal of files, and keep old module
       // on compile errors (FIXME: Is this correct behavior?)
       if (changed) {
-        PRINTDB("  %s: %p -> %p", filename % oldmodule % newmodule);
+        PRINTDB ("  %s: %p -> %p", filename % oldmodule % newmodule);
       } else {
-        PRINTDB("  %s: %p", filename % oldmodule);
+        PRINTDB ("  %s: %p", filename % oldmodule);
       }
     }
   }
 
   // Relative filenames which were located are reinserted as absolute filenames
-  for (const auto& files : updates) {
-    auto pos = std::find(usedlibs.begin(), usedlibs.end(), files.first);
-    if (pos != usedlibs.end()) *pos = files.second;
+  for (const auto &files : updates) {
+    auto pos = std::find (usedlibs.begin (), usedlibs.end (), files.first);
+    if (pos != usedlibs.end ())
+      *pos = files.second;
   }
   return latest;
 }
 
-std::shared_ptr<AbstractNode> SourceFile::instantiate(const std::shared_ptr<const Context>& context, std::shared_ptr<const FileContext> *resulting_file_context) const
-{
-  auto node = std::make_shared<RootNode>();
+std::shared_ptr<AbstractNode> SourceFile::instantiate (const std::shared_ptr<const Context> &context, std::shared_ptr<const FileContext> *resulting_file_context) const {
+  auto node = std::make_shared<RootNode> ();
   try {
-    ContextHandle<FileContext> file_context{Context::create<FileContext>(context, this)};
+    ContextHandle<FileContext> file_context{Context::create<FileContext> (context, this)};
     *resulting_file_context = *file_context;
-    this->scope.instantiateModules(*file_context, node);
-  } catch (HardWarningException& e) {
+    this->scope.instantiateModules (*file_context, node);
+  } catch (HardWarningException &e) {
     throw;
-  } catch (EvaluationException& e) {
+  } catch (EvaluationException &e) {
     // LOG(message_group::NONE,,e.what()); //please output the message before throwing the exception
     *resulting_file_context = nullptr;
   }
@@ -192,11 +192,11 @@ std::shared_ptr<AbstractNode> SourceFile::instantiate(const std::shared_ptr<cons
 //please preferably use getFilename
 //if you compare filenames (which is the origin of this method),
 //please call getFilename first and use this method only as a fallback
-const std::string SourceFile::getFullpath() const {
-  if (fs::path(this->filename).is_absolute()) {
+const std::string SourceFile::getFullpath () const {
+  if (fs::path (this->filename).is_absolute ()) {
     return this->filename;
-  } else if (!this->path.empty()) {
-    return (fs::path(this->path) / fs::path(this->filename)).generic_string();
+  } else if (!this->path.empty ()) {
+    return (fs::path (this->path) / fs::path (this->filename)).generic_string ();
   } else {
     return "";
   }
diff --git a/src/core/SourceFile.h b/src/core/SourceFile.h
index 903b69c43..b4ccb6fca 100644
--- a/src/core/SourceFile.h
+++ b/src/core/SourceFile.h
@@ -15,24 +15,40 @@
 class SourceFile : public ASTNode
 {
 public:
-  SourceFile(std::string path, std::string filename);
-
-  std::shared_ptr<AbstractNode> instantiate(const std::shared_ptr<const Context>& context, std::shared_ptr<const class FileContext> *resulting_file_context) const;
-  void print(std::ostream& stream, const std::string& indent) const override;
-
-  void setModulePath(const std::string& path) { this->path = path; }
-  const std::string& modulePath() const { return this->path; }
-  void registerUse(const std::string& path, const Location& loc);
-  void registerInclude(const std::string& localpath, const std::string& fullpath, const Location& loc);
-  std::time_t includesChanged() const;
-  std::time_t handleDependencies(bool is_root = true);
-  bool hasIncludes() const { return !this->includes.empty(); }
-  bool usesLibraries() const { return !this->usedlibs.empty(); }
-  bool isHandlingDependencies() const { return this->is_handling_dependencies; }
-  void clearHandlingDependencies() { this->is_handling_dependencies = false; }
-  void setFilename(const std::string& filename) { this->filename = filename; }
-  const std::string& getFilename() const { return this->filename; }
-  const std::string getFullpath() const;
+  SourceFile (std::string path, std::string filename);
+
+  std::shared_ptr<AbstractNode> instantiate (const std::shared_ptr<const Context> &context, std::shared_ptr<const class FileContext> *resulting_file_context) const;
+  void print (std::ostream &stream, const std::string &indent) const override;
+
+  void setModulePath (const std::string &path) {
+    this->path = path;
+  }
+  const std::string &modulePath () const {
+    return this->path;
+  }
+  void registerUse (const std::string &path, const Location &loc);
+  void registerInclude (const std::string &localpath, const std::string &fullpath, const Location &loc);
+  std::time_t includesChanged () const;
+  std::time_t handleDependencies (bool is_root = true);
+  bool hasIncludes () const {
+    return !this->includes.empty ();
+  }
+  bool usesLibraries () const {
+    return !this->usedlibs.empty ();
+  }
+  bool isHandlingDependencies () const {
+    return this->is_handling_dependencies;
+  }
+  void clearHandlingDependencies () {
+    this->is_handling_dependencies = false;
+  }
+  void setFilename (const std::string &filename) {
+    this->filename = filename;
+  }
+  const std::string &getFilename () const {
+    return this->filename;
+  }
+  const std::string getFullpath () const;
 
   LocalScope scope;
   std::vector<std::string> usedlibs;
@@ -40,7 +56,7 @@ public:
   std::vector<IndicatorData> indicatorData;
 
 private:
-  std::time_t include_modified(const std::string& filename) const;
+  std::time_t include_modified (const std::string &filename) const;
 
   std::unordered_map<std::string, std::string> includes;
   bool is_handling_dependencies{false};
diff --git a/src/core/SourceFileCache.cc b/src/core/SourceFileCache.cc
index 72523479c..5f549db6f 100644
--- a/src/core/SourceFileCache.cc
+++ b/src/core/SourceFileCache.cc
@@ -28,28 +28,29 @@ SourceFileCache *SourceFileCache::inst = nullptr;
 
    Returns the latest modification time of the file, its dependencies or includes.
  */
-std::time_t SourceFileCache::evaluate(const std::string& mainFile, const std::string& filename, SourceFile *& sourceFile)
-{
+std::time_t SourceFileCache::evaluate (const std::string &mainFile, const std::string &filename, SourceFile *&sourceFile) {
   sourceFile = nullptr;
-  auto entry = this->entries.find(filename);
-  bool found{entry != this->entries.end()};
+  auto entry = this->entries.find (filename);
+  bool found{entry != this->entries.end ()};
   SourceFile *file{found ? entry->second.file : nullptr};
 
   // Don't try to recursively evaluate - if the file changes
   // during evaluation, that would be really bad.
-  if (file && file->isHandlingDependencies()) return 0;
+  if (file && file->isHandlingDependencies ())
+    return 0;
 
   // Create cache ID
   struct stat st;
-  bool valid = (StatCache::stat(filename, st) == 0);
+  bool valid = (StatCache::stat (filename, st) == 0);
 
   // If file isn't there, just return and let the cache retain the old file
-  if (!valid) return 0;
+  if (!valid)
+    return 0;
 
   // If the file is present, we'll always cache some result
-  std::string cache_id = str(boost::format("%x.%x") % st.st_mtime % st.st_size);
+  std::string cache_id = str (boost::format ("%x.%x") % st.st_mtime % st.st_size);
 
-  cache_entry& cacheEntry = this->entries[filename];
+  cache_entry &cacheEntry = this->entries[filename];
   // Initialize entry, if new
   if (!found) {
     cacheEntry.file = nullptr;
@@ -66,7 +67,7 @@ std::time_t SourceFileCache::evaluate(const std::string& mainFile, const std::st
       shouldCompile = false;
       // Recompile if includes changed
       if (cacheEntry.parsed_file) {
-        std::time_t mtime = cacheEntry.parsed_file->includesChanged();
+        std::time_t mtime = cacheEntry.parsed_file->includesChanged ();
         if (mtime > cacheEntry.includes_mtime) {
           cacheEntry.includes_mtime = mtime;
           shouldCompile = true;
@@ -84,53 +85,53 @@ std::time_t SourceFileCache::evaluate(const std::string& mainFile, const std::st
   if (shouldCompile) {
 #ifdef DEBUG
     if (found) {
-      PRINTDB("Recompiling cached library: %s (%s)", filename % cache_id);
+      PRINTDB ("Recompiling cached library: %s (%s)", filename % cache_id);
     } else {
-      PRINTDB("Compiling library '%s'.", filename);
+      PRINTDB ("Compiling library '%s'.", filename);
     }
 #endif
 
     std::string text;
     {
-      std::ifstream ifs(filename.c_str());
-      if (!ifs.is_open()) {
-        LOG(message_group::Warning, "Can't open library file '%1$s'\n", filename);
+      std::ifstream ifs (filename.c_str ());
+      if (!ifs.is_open ()) {
+        LOG (message_group::Warning, "Can't open library file '%1$s'\n", filename);
         return 0;
       }
-      text = STR(ifs.rdbuf(), "\n\x03\n", commandline_commands);
+      text = STR (ifs.rdbuf (), "\n\x03\n", commandline_commands);
     }
 
-    print_messages_push();
+    print_messages_push ();
 
     delete cacheEntry.parsed_file;
-    file = parse(cacheEntry.parsed_file, text, filename, mainFile, false) ? cacheEntry.parsed_file : nullptr;
-    PRINTDB("compiled file: %s", filename);
+    file = parse (cacheEntry.parsed_file, text, filename, mainFile, false) ? cacheEntry.parsed_file : nullptr;
+    PRINTDB ("compiled file: %s", filename);
     cacheEntry.file = file;
     cacheEntry.cache_id = cache_id;
     auto mod = file ? file : cacheEntry.parsed_file;
-    if (!found && mod) cacheEntry.includes_mtime = mod->includesChanged();
-    print_messages_pop();
+    if (!found && mod)
+      cacheEntry.includes_mtime = mod->includesChanged ();
+    print_messages_pop ();
   }
 
   sourceFile = file;
   // FIXME: Do we need to handle include-only cases?
-  std::time_t deps_mtime = file ? file->handleDependencies(false) : 0;
+  std::time_t deps_mtime = file ? file->handleDependencies (false) : 0;
 
-  return std::max({deps_mtime, cacheEntry.mtime, cacheEntry.includes_mtime});
+  return std::max ({deps_mtime, cacheEntry.mtime, cacheEntry.includes_mtime});
 }
 
-void SourceFileCache::clear()
-{
-  this->entries.clear();
+void SourceFileCache::clear () {
+  this->entries.clear ();
 }
 
-SourceFile *SourceFileCache::lookup(const std::string& filename)
-{
-  auto it = this->entries.find(filename);
-  return it != this->entries.end() ? it->second.file : nullptr;
+SourceFile *SourceFileCache::lookup (const std::string &filename) {
+  auto it = this->entries.find (filename);
+  return it != this->entries.end () ? it->second.file : nullptr;
 }
 
-void SourceFileCache::clear_markers() {
-  for (const auto& entry : instance()->entries)
-    if (auto lib = entry.second.file) lib->clearHandlingDependencies();
+void SourceFileCache::clear_markers () {
+  for (const auto &entry : instance ()->entries)
+    if (auto lib = entry.second.file)
+      lib->clearHandlingDependencies ();
 }
diff --git a/src/core/SourceFileCache.h b/src/core/SourceFileCache.h
index eb736a530..85d527879 100644
--- a/src/core/SourceFileCache.h
+++ b/src/core/SourceFileCache.h
@@ -12,22 +12,28 @@ class SourceFile;
 class SourceFileCache
 {
 public:
-  static SourceFileCache *instance() { if (!inst) inst = new SourceFileCache; return inst; }
+  static SourceFileCache *instance () {
+    if (!inst)
+      inst = new SourceFileCache;
+    return inst;
+  }
 
-  std::time_t evaluate(const std::string& mainFile, const std::string& filename, SourceFile *& sourceFile);
-  SourceFile *lookup(const std::string& filename);
-  size_t size() const { return this->entries.size(); }
-  void clear();
-  static void clear_markers();
+  std::time_t evaluate (const std::string &mainFile, const std::string &filename, SourceFile *&sourceFile);
+  SourceFile *lookup (const std::string &filename);
+  size_t size () const {
+    return this->entries.size ();
+  }
+  void clear ();
+  static void clear_markers ();
 
 private:
-  SourceFileCache() = default;
+  SourceFileCache () = default;
 
   static SourceFileCache *inst;
 
   struct cache_entry {
     SourceFile *file{};
-    SourceFile *parsed_file{};                   // the last version parsed for the include list
+    SourceFile *parsed_file{}; // the last version parsed for the include list
     std::string cache_id;
     std::time_t mtime{}; // time file last modified
     std::time_t includes_mtime{}; // time the includes last changed
diff --git a/src/core/StatCache.cc b/src/core/StatCache.cc
index cf7cf0737..4e3bd3c7f 100644
--- a/src/core/StatCache.cc
+++ b/src/core/StatCache.cc
@@ -32,16 +32,14 @@
 
 namespace {
 
-const float stale = 190;  // 190ms, maximum lifetime of a cache entry chosen to be shorter than the automatic reload poll time
+const float stale = 190; // 190ms, maximum lifetime of a cache entry chosen to be shorter than the automatic reload poll time
 
-double millis_clock()
-{
-  return std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
+double millis_clock () {
+  return std::chrono::duration_cast<std::chrono::milliseconds> (std::chrono::system_clock::now ().time_since_epoch ()).count ();
 }
 
-struct CacheEntry
-{
-  struct stat st;  // result from stat
+struct CacheEntry {
+  struct stat st; // result from stat
   double timestamp; // the time stat was called
 };
 
@@ -51,18 +49,18 @@ std::unordered_map<std::string, CacheEntry> statMap;
 
 namespace StatCache {
 
-int stat(const std::string& path, struct ::stat &st)
-{
-  auto iter = statMap.find(path);
-  if (iter != statMap.end()) {                // Have we got an entry for this file?
-    if (millis_clock() - iter->second.timestamp < stale) {
-      st = iter->second.st;      // Not stale yet so return it
+int stat (const std::string &path, struct ::stat &st) {
+  auto iter = statMap.find (path);
+  if (iter != statMap.end ()) { // Have we got an entry for this file?
+    if (millis_clock () - iter->second.timestamp < stale) {
+      st = iter->second.st; // Not stale yet so return it
       return 0;
     }
-    statMap.erase(iter);                // Remove stale entry
+    statMap.erase (iter); // Remove stale entry
   }
-  if (auto rv = ::stat(path.c_str(), &st)) return rv; // stat failed
-  statMap[path] = {st, millis_clock()};
+  if (auto rv = ::stat (path.c_str (), &st))
+    return rv; // stat failed
+  statMap[path] = {st, millis_clock ()};
   return 0;
 }
 
diff --git a/src/core/StatCache.h b/src/core/StatCache.h
index bc46f5f2b..cbf72fef7 100644
--- a/src/core/StatCache.h
+++ b/src/core/StatCache.h
@@ -31,6 +31,6 @@
 
 namespace StatCache {
 
-int stat(const std::string& path, struct ::stat &st);
+int stat (const std::string &path, struct ::stat &st);
 
 }
diff --git a/src/core/State.h b/src/core/State.h
index c327fe66e..64536ed00 100644
--- a/src/core/State.h
+++ b/src/core/State.h
@@ -10,42 +10,78 @@ class State
 {
 
 public:
-  State(std::shared_ptr<const AbstractNode> parent)
-    : parentnode(std::move(parent)) {
-    this->matrix_ = Transform3d::Identity();
-  }
-
-  void setPrefix(bool on) { FLAG(this->flags, PREFIX, on); }
-  void setPostfix(bool on) { FLAG(this->flags, POSTFIX, on); }
-  void setHighlight(bool on) { FLAG(this->flags, HIGHLIGHT, on); }
-  void setBackground(bool on) { FLAG(this->flags, BACKGROUND, on); }
-  void setNumChildren(unsigned int numc) { this->numchildren = numc; }
-  void setParent(const std::shared_ptr<const AbstractNode>& parent) { this->parentnode = parent; }
-  void setMatrix(const Transform3d& m) { this->matrix_ = m; }
-  void setColor(const Color4f& c) { this->color_ = c; }
-  void setPreferNef(bool on) { FLAG(this->flags, PREFERNEF, on); }
-  [[nodiscard]] bool preferNef() const { return this->flags & PREFERNEF; }
-
-  [[nodiscard]] bool isPrefix() const { return this->flags & PREFIX; }
-  [[nodiscard]] bool isPostfix() const { return this->flags & POSTFIX; }
-  [[nodiscard]] bool isHighlight() const { return this->flags & HIGHLIGHT; }
-  [[nodiscard]] bool isBackground() const { return this->flags & BACKGROUND; }
-  [[nodiscard]] unsigned int numChildren() const { return this->numchildren; }
-  [[nodiscard]] std::shared_ptr<const AbstractNode> parent() const { return this->parentnode; }
-  [[nodiscard]] const Transform3d& matrix() const { return this->matrix_; }
-  [[nodiscard]] const Color4f& color() const { return this->color_; }
+  State (std::shared_ptr<const AbstractNode> parent)
+    : parentnode (std::move (parent)) {
+    this->matrix_ = Transform3d::Identity ();
+  }
+
+  void setPrefix (bool on) {
+    FLAG (this->flags, PREFIX, on);
+  }
+  void setPostfix (bool on) {
+    FLAG (this->flags, POSTFIX, on);
+  }
+  void setHighlight (bool on) {
+    FLAG (this->flags, HIGHLIGHT, on);
+  }
+  void setBackground (bool on) {
+    FLAG (this->flags, BACKGROUND, on);
+  }
+  void setNumChildren (unsigned int numc) {
+    this->numchildren = numc;
+  }
+  void setParent (const std::shared_ptr<const AbstractNode> &parent) {
+    this->parentnode = parent;
+  }
+  void setMatrix (const Transform3d &m) {
+    this->matrix_ = m;
+  }
+  void setColor (const Color4f &c) {
+    this->color_ = c;
+  }
+  void setPreferNef (bool on) {
+    FLAG (this->flags, PREFERNEF, on);
+  }
+  [[nodiscard]] bool preferNef () const {
+    return this->flags & PREFERNEF;
+  }
+
+  [[nodiscard]] bool isPrefix () const {
+    return this->flags & PREFIX;
+  }
+  [[nodiscard]] bool isPostfix () const {
+    return this->flags & POSTFIX;
+  }
+  [[nodiscard]] bool isHighlight () const {
+    return this->flags & HIGHLIGHT;
+  }
+  [[nodiscard]] bool isBackground () const {
+    return this->flags & BACKGROUND;
+  }
+  [[nodiscard]] unsigned int numChildren () const {
+    return this->numchildren;
+  }
+  [[nodiscard]] std::shared_ptr<const AbstractNode> parent () const {
+    return this->parentnode;
+  }
+  [[nodiscard]] const Transform3d &matrix () const {
+    return this->matrix_;
+  }
+  [[nodiscard]] const Color4f &color () const {
+    return this->color_;
+  }
 
 private:
   enum StateFlags : unsigned int {
-    NONE       = 0x00u,
-    PREFIX     = 0x01u,
-    POSTFIX    = 0x02u,
-    PREFERNEF  = 0x04u,
-    HIGHLIGHT  = 0x08u,
+    NONE = 0x00u,
+    PREFIX = 0x01u,
+    POSTFIX = 0x02u,
+    PREFERNEF = 0x04u,
+    HIGHLIGHT = 0x08u,
     BACKGROUND = 0x10u
   };
 
-  constexpr void FLAG(unsigned int& var, StateFlags flag, bool on) {
+  constexpr void FLAG (unsigned int &var, StateFlags flag, bool on) {
     if (on) {
       var |= flag;
     } else {
diff --git a/src/core/SurfaceNode.cc b/src/core/SurfaceNode.cc
index 2e5134bbe..ed7c59eb9 100644
--- a/src/core/SurfaceNode.cc
+++ b/src/core/SurfaceNode.cc
@@ -62,102 +62,96 @@ using namespace boost::assign; // bring 'operator+=()' into scope
 #include <filesystem>
 namespace fs = std::filesystem;
 
+static std::shared_ptr<AbstractNode> builtin_surface (const ModuleInstantiation *inst, Arguments arguments) {
+  auto node = std::make_shared<SurfaceNode> (inst);
 
-static std::shared_ptr<AbstractNode> builtin_surface(const ModuleInstantiation *inst, Arguments arguments)
-{
-  auto node = std::make_shared<SurfaceNode>(inst);
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (), {"file", "center", "convexity"}, {"invert"});
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"file", "center", "convexity"}, {"invert"});
-
-  std::string fileval = parameters["file"].isUndefined() ? "" : parameters["file"].toString();
-  auto filename = lookup_file(fileval, inst->location().filePath().parent_path().string(), parameters.documentRoot());
+  std::string fileval = parameters["file"].isUndefined () ? "" : parameters["file"].toString ();
+  auto filename = lookup_file (fileval, inst->location ().filePath ().parent_path ().string (), parameters.documentRoot ());
   node->filename = filename;
-  handle_dep(fs::path(filename).generic_string());
+  handle_dep (fs::path (filename).generic_string ());
 
-  if (parameters["center"].type() == Value::Type::BOOL) {
-    node->center = parameters["center"].toBool();
+  if (parameters["center"].type () == Value::Type::BOOL) {
+    node->center = parameters["center"].toBool ();
   }
 
-  if (parameters["convexity"].type() == Value::Type::NUMBER) {
-    node->convexity = static_cast<int>(parameters["convexity"].toDouble());
+  if (parameters["convexity"].type () == Value::Type::NUMBER) {
+    node->convexity = static_cast<int> (parameters["convexity"].toDouble ());
   }
 
-  if (parameters["invert"].type() == Value::Type::BOOL) {
-    node->invert = parameters["invert"].toBool();
+  if (parameters["invert"].type () == Value::Type::BOOL) {
+    node->invert = parameters["invert"].toBool ();
   }
 
   return node;
 }
 
-void SurfaceNode::convert_image(img_data_t& data, std::vector<uint8_t>& img, unsigned int width, unsigned int height) const
-{
+void SurfaceNode::convert_image (img_data_t &data, std::vector<uint8_t> &img, unsigned int width, unsigned int height) const {
   data.width = width;
   data.height = height;
-  data.resize( (size_t)width * height);
+  data.resize ((size_t)width * height);
   double min_val = 200;
   for (unsigned int y = 0; y < height; ++y) {
     for (unsigned int x = 0; x < width; ++x) {
       long idx = 4l * (y * width + x);
       double pixel = 0.2126 * img[idx] + 0.7152 * img[idx + 1] + 0.0722 * img[idx + 2];
       double z = 100.0 / 255 * (invert ? 1 - pixel : pixel);
-      data[ x + (width * (height - 1 - y)) ] = z;
-      min_val = std::min(z, min_val);
+      data[x + (width * (height - 1 - y))] = z;
+      min_val = std::min (z, min_val);
     }
   }
   data.min_val = min_val;
 }
 
-bool SurfaceNode::is_png(std::vector<uint8_t>& png) const
-{
+bool SurfaceNode::is_png (std::vector<uint8_t> &png) const {
   const size_t pngHeaderLength = 8;
   const uint8_t pngHeader[pngHeaderLength] = {0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a};
-  return (png.size() >= pngHeaderLength &&
-          std::memcmp(png.data(), pngHeader, pngHeaderLength) == 0);
+  return (png.size () >= pngHeaderLength &&
+          std::memcmp (png.data (), pngHeader, pngHeaderLength) == 0);
 }
 
-img_data_t SurfaceNode::read_png_or_dat(std::string filename) const
-{
+img_data_t SurfaceNode::read_png_or_dat (std::string filename) const {
   img_data_t data;
   std::vector<uint8_t> png;
   int ret_val = 0;
-  try{
-    ret_val = lodepng::load_file(png, filename);
-  } catch (std::bad_alloc& ba) {
-    LOG(message_group::Warning, "bad_alloc caught for '%1$s'.", ba.what());
+  try {
+    ret_val = lodepng::load_file (png, filename);
+  } catch (std::bad_alloc &ba) {
+    LOG (message_group::Warning, "bad_alloc caught for '%1$s'.", ba.what ());
     return data;
   }
 
   if (ret_val == 78) {
-    LOG(message_group::Warning, "The file '%1$s' couldn't be opened.", filename);
+    LOG (message_group::Warning, "The file '%1$s' couldn't be opened.", filename);
     return data;
   }
 
-  if (!is_png(png)) {
-    png.clear();
-    return read_dat(filename);
+  if (!is_png (png)) {
+    png.clear ();
+    return read_dat (filename);
   }
 
   unsigned int width, height;
   std::vector<uint8_t> img;
-  auto error = lodepng::decode(img, width, height, png);
+  auto error = lodepng::decode (img, width, height, png);
   if (error) {
-    LOG(message_group::Warning, "Can't read PNG image '%1$s'", filename);
-    data.clear();
+    LOG (message_group::Warning, "Can't read PNG image '%1$s'", filename);
+    data.clear ();
     return data;
   }
 
-  convert_image(data, img, width, height);
+  convert_image (data, img, width, height);
 
   return data;
 }
 
-img_data_t SurfaceNode::read_dat(std::string filename) const
-{
+img_data_t SurfaceNode::read_dat (std::string filename) const {
   img_data_t data;
-  std::ifstream stream(filename.c_str());
+  std::ifstream stream (filename.c_str ());
 
-  if (!stream.good()) {
-    LOG(message_group::Warning, "Can't open DAT file '%1$s'.", filename);
+  if (!stream.good ()) {
+    LOG (message_group::Warning, "Can't open DAT file '%1$s'.", filename);
     return data;
   }
 
@@ -165,33 +159,35 @@ img_data_t SurfaceNode::read_dat(std::string filename) const
   double min_val = 1; // this balances out with the (min_val-1) inside createGeometry, to match old behavior
 
   using tokenizer = boost::tokenizer<boost::char_separator<char>>;
-  boost::char_separator<char> sep(" \t");
+  boost::char_separator<char> sep (" \t");
 
   // We use an unordered map because the data file may not be rectangular,
   // and we may need to fill in some bits.
   using unordered_image_data_t = std::unordered_map<std::pair<int, int>, double, boost::hash<std::pair<int, int>>>;
   unordered_image_data_t unordered_data;
 
-  while (!stream.eof()) {
+  while (!stream.eof ()) {
     std::string line;
-    while (!stream.eof() && (line.size() == 0 || line[0] == '#')) {
-      std::getline(stream, line);
-      boost::trim(line);
+    while (!stream.eof () && (line.size () == 0 || line[0] == '#')) {
+      std::getline (stream, line);
+      boost::trim (line);
     }
-    if (line.size() == 0 && stream.eof()) break;
+    if (line.size () == 0 && stream.eof ())
+      break;
 
     int col = 0;
-    tokenizer tokens(line, sep);
+    tokenizer tokens (line, sep);
     try {
-      for (const auto& token : tokens) {
-        auto v = boost::lexical_cast<double>(token);
-        unordered_data[ std::make_pair(lines, col++) ] = v;
-        if (col > columns) columns = col;
-        min_val = std::min(v, min_val);
+      for (const auto &token : tokens) {
+        auto v = boost::lexical_cast<double> (token);
+        unordered_data[std::make_pair (lines, col++)] = v;
+        if (col > columns)
+          columns = col;
+        min_val = std::min (v, min_val);
       }
-    } catch (const boost::bad_lexical_cast& blc) {
-      if (!stream.eof()) {
-        LOG(message_group::Warning, "Illegal value in '%1$s': %2$s", filename, blc.what());
+    } catch (const boost::bad_lexical_cast &blc) {
+      if (!stream.eof ()) {
+        LOG (message_group::Warning, "Illegal value in '%1$s': %2$s", filename, blc.what ());
       }
       return data;
     }
@@ -205,22 +201,21 @@ img_data_t SurfaceNode::read_dat(std::string filename) const
 
   // Now convert the unordered, possibly non-rectangular data into a well ordered vector
   // for faster access and reduced memory usage.
-  data.resize( (size_t)lines * columns);
+  data.resize ((size_t)lines * columns);
   for (int i = 0; i < lines; ++i)
     for (int j = 0; j < columns; ++j)
-      data[ i * columns + j ] = unordered_data[std::make_pair(i, j)];
+      data[i * columns + j] = unordered_data[std::make_pair (i, j)];
 
   return data;
 }
 
 // FIXME: Look for faster way to generate PolySet directly
-std::unique_ptr<const Geometry> SurfaceNode::createGeometry() const
-{
-  auto data = read_png_or_dat(filename);
+std::unique_ptr<const Geometry> SurfaceNode::createGeometry () const {
+  auto data = read_png_or_dat (filename);
 
   int lines = data.height;
   int columns = data.width;
-  double min_val = data.min_value() - 1; // make the bottom solid, and match old code
+  double min_val = data.min_value () - 1; // make the bottom solid, and match old code
 
   // reserve the polygon vector size so we don't have to reallocate as often
 
@@ -228,122 +223,105 @@ std::unique_ptr<const Geometry> SurfaceNode::createGeometry() const
   double oy = center ? -(lines - 1) / 2.0 : 0;
 
   int num_indices = (lines - 1) * (columns - 1) * 4 + (lines - 1) * 2 + (columns - 1) * 2 + 1;
-  PolySetBuilder builder(0, num_indices);
-  builder.setConvexity(convexity);
+  PolySetBuilder builder (0, num_indices);
+  builder.setConvexity (convexity);
   // the bulk of the heightmap
   for (int i = 1; i < lines; ++i)
     for (int j = 1; j < columns; ++j) {
-      double v1 = data[ (j - 1) + (i - 1) * columns ];
-      double v2 = data[ (j) + (i - 1) * columns ];
-      double v3 = data[ (j - 1) + (i) * columns ];
-      double v4 = data[ (j) + (i) * columns ];
+      double v1 = data[(j - 1) + (i - 1) * columns];
+      double v2 = data[(j) + (i - 1) * columns];
+      double v3 = data[(j - 1) + (i)*columns];
+      double v4 = data[(j) + (i)*columns];
 
       double vx = (v1 + v2 + v3 + v4) / 4;
 
-      builder.appendPolygon({
-        Vector3d(ox + j - 1, oy + i - 1, v1),
-        Vector3d(ox + j, oy + i - 1, v2),
-        Vector3d(ox + j - 0.5, oy + i - 0.5, vx)
-      });
-
-      builder.appendPolygon({
-        Vector3d(ox + j, oy + i - 1, v2),
-        Vector3d(ox + j, oy + i, v4),
-        Vector3d(ox + j - 0.5, oy + i - 0.5, vx)
-      });
-
-      builder.appendPolygon({
-        Vector3d(ox + j, oy + i, v4),
-        Vector3d(ox + j - 1, oy + i, v3),
-        Vector3d(ox + j - 0.5, oy + i - 0.5, vx)
-      });
-
-      builder.appendPolygon({
-        Vector3d(ox + j - 1, oy + i, v3),
-        Vector3d(ox + j - 1, oy + i - 1, v1),
-        Vector3d(ox + j - 0.5, oy + i - 0.5, vx)
-      });
+      builder.appendPolygon ({Vector3d (ox + j - 1, oy + i - 1, v1),
+                              Vector3d (ox + j, oy + i - 1, v2),
+                              Vector3d (ox + j - 0.5, oy + i - 0.5, vx)});
+
+      builder.appendPolygon ({Vector3d (ox + j, oy + i - 1, v2),
+                              Vector3d (ox + j, oy + i, v4),
+                              Vector3d (ox + j - 0.5, oy + i - 0.5, vx)});
+
+      builder.appendPolygon ({Vector3d (ox + j, oy + i, v4),
+                              Vector3d (ox + j - 1, oy + i, v3),
+                              Vector3d (ox + j - 0.5, oy + i - 0.5, vx)});
+
+      builder.appendPolygon ({Vector3d (ox + j - 1, oy + i, v3),
+                              Vector3d (ox + j - 1, oy + i - 1, v1),
+                              Vector3d (ox + j - 0.5, oy + i - 0.5, vx)});
     }
 
   // edges along Y
   for (int i = 1; i < lines; ++i) {
-    double v1 = data[ (0) + (i - 1) * columns ];
-    double v2 = data[ (0) + (i) * columns ];
-    double v3 = data[ (columns - 1) + (i - 1) * columns ];
-    double v4 = data[ (columns - 1) + (i) * columns ];
-
-
-    builder.appendPolygon({
-      Vector3d(ox + 0, oy + i - 1, min_val),
-      Vector3d(ox + 0, oy + i - 1, v1),
-      Vector3d(ox + 0, oy + i, v2),
-      Vector3d(ox + 0, oy + i, min_val)
-    });
-
-    builder.appendPolygon({
-      Vector3d(ox + columns - 1, oy + i, min_val),
-      Vector3d(ox + columns - 1, oy + i, v4),
-      Vector3d(ox + columns - 1, oy + i - 1, v3),
-      Vector3d(ox + columns - 1, oy + i - 1, min_val)
-    });
+    double v1 = data[(0) + (i - 1) * columns];
+    double v2 = data[(0) + (i)*columns];
+    double v3 = data[(columns - 1) + (i - 1) * columns];
+    double v4 = data[(columns - 1) + (i)*columns];
+
+    builder.appendPolygon ({Vector3d (ox + 0, oy + i - 1, min_val),
+                            Vector3d (ox + 0, oy + i - 1, v1),
+                            Vector3d (ox + 0, oy + i, v2),
+                            Vector3d (ox + 0, oy + i, min_val)});
+
+    builder.appendPolygon ({Vector3d (ox + columns - 1, oy + i, min_val),
+                            Vector3d (ox + columns - 1, oy + i, v4),
+                            Vector3d (ox + columns - 1, oy + i - 1, v3),
+                            Vector3d (ox + columns - 1, oy + i - 1, min_val)});
   }
 
   // edges along X
   for (int i = 1; i < columns; ++i) {
-    double v1 = data[ (i - 1) + (0) * columns ];
-    double v2 = data[ (i) + (0) * columns ];
-    double v3 = data[ (i - 1) + (lines - 1) * columns ];
-    double v4 = data[ (i) + (lines - 1) * columns ];
-
-    builder.appendPolygon({
-      Vector3d(ox + i, oy + 0, min_val),
-      Vector3d(ox + i, oy + 0, v2),
-      Vector3d(ox + i - 1, oy + 0, v1),
-      Vector3d(ox + i - 1, oy + 0, min_val)
-    });
-
-    builder.appendPolygon({
-      Vector3d(ox + i - 1, oy + lines - 1, min_val),
-      Vector3d(ox + i - 1, oy + lines - 1, v3),
-      Vector3d(ox + i, oy + lines - 1, v4),
-      Vector3d(ox + i, oy + lines - 1, min_val)
-    });
+    double v1 = data[(i - 1) + (0) * columns];
+    double v2 = data[(i) + (0) * columns];
+    double v3 = data[(i - 1) + (lines - 1) * columns];
+    double v4 = data[(i) + (lines - 1) * columns];
+
+    builder.appendPolygon ({Vector3d (ox + i, oy + 0, min_val),
+                            Vector3d (ox + i, oy + 0, v2),
+                            Vector3d (ox + i - 1, oy + 0, v1),
+                            Vector3d (ox + i - 1, oy + 0, min_val)});
+
+    builder.appendPolygon ({Vector3d (ox + i - 1, oy + lines - 1, min_val),
+                            Vector3d (ox + i - 1, oy + lines - 1, v3),
+                            Vector3d (ox + i, oy + lines - 1, v4),
+                            Vector3d (ox + i, oy + lines - 1, min_val)});
   }
 
   // the bottom of the shape (one less than the real minimum value), making it a solid volume
   if (columns > 1 && lines > 1) {
-    builder.beginPolygon(2 * (columns - 1) + 2 * (lines - 1) );
+    builder.beginPolygon (2 * (columns - 1) + 2 * (lines - 1));
     for (int i = 0; i < lines - 1; ++i)
-      builder.addVertex(Vector3d(ox + 0, oy + i, min_val));
+      builder.addVertex (Vector3d (ox + 0, oy + i, min_val));
     for (int i = 0; i < columns - 1; ++i)
-      builder.addVertex(Vector3d(ox + i, oy + lines - 1, min_val));
+      builder.addVertex (Vector3d (ox + i, oy + lines - 1, min_val));
     for (int i = lines - 1; i > 0; i--)
-      builder.addVertex(Vector3d(ox + columns - 1, oy + i, min_val));
+      builder.addVertex (Vector3d (ox + columns - 1, oy + i, min_val));
     for (int i = columns - 1; i > 0; i--)
-      builder.addVertex(Vector3d(ox + i, oy + 0, min_val));
+      builder.addVertex (Vector3d (ox + i, oy + 0, min_val));
   }
 
-  return builder.build();
+  return builder.build ();
 }
 
-std::string SurfaceNode::toString() const
-{
+std::string SurfaceNode::toString () const {
   std::ostringstream stream;
-  fs::path path{static_cast<std::string>(this->filename)}; // gcc-4.6
+  fs::path path{static_cast<std::string> (this->filename)}; // gcc-4.6
 
-  stream << this->name() << "(file = " << this->filename
+  stream << this->name () << "(file = " << this->filename
          << ", center = " << (this->center ? "true" : "false")
          << ", invert = " << (this->invert ? "true" : "false")
-         << ", " "timestamp = " << fs_timestamp(path)
+         << ", "
+            "timestamp = "
+         << fs_timestamp (path)
          << ")";
 
-  return stream.str();
+  return stream.str ();
 }
 
-void register_builtin_surface()
-{
-  Builtins::init("surface", new BuiltinModule(builtin_surface),
-  {
-    "surface(string, center = false, invert = false, number)",
-  });
+void register_builtin_surface () {
+  Builtins::init ("surface", new BuiltinModule (builtin_surface),
+                  {
+                    "surface(string, center = false, invert = false, number)",
+                  });
 }
diff --git a/src/core/SurfaceNode.h b/src/core/SurfaceNode.h
index df58f84a9..8f46af25e 100644
--- a/src/core/SurfaceNode.h
+++ b/src/core/SurfaceNode.h
@@ -34,51 +34,65 @@
 #include "core/ModuleInstantiation.h"
 #include "core/Value.h"
 
-struct img_data_t
-{
+struct img_data_t {
 public:
   using storage_type = double; // float could be enough here
 
-  img_data_t() {
-    min_val = 0; height = width = 0;
+  img_data_t () {
+    min_val = 0;
+    height = width = 0;
   }
 
-  void clear() { min_val = 0; height = width = 0; storage.clear(); }
+  void clear () {
+    min_val = 0;
+    height = width = 0;
+    storage.clear ();
+  }
 
-  void reserve(size_t x) { storage.reserve(x); }
+  void reserve (size_t x) {
+    storage.reserve (x);
+  }
 
-  void resize(size_t x) { storage.resize(x); }
+  void resize (size_t x) {
+    storage.resize (x);
+  }
 
-  storage_type& operator[](int x) { return storage[x]; }
+  storage_type &operator[] (int x) {
+    return storage[x];
+  }
 
-  storage_type min_value() { return min_val; } // *std::min_element(storage.begin(), storage.end());
+  storage_type min_value () {
+    return min_val;
+  } // *std::min_element(storage.begin(), storage.end());
 
 public:
   unsigned int height; // rows
   unsigned int width; // columns
   storage_type min_val;
   std::vector<storage_type> storage;
-
 };
 
-
 class SurfaceNode : public LeafNode
 {
 public:
-  VISITABLE();
-  SurfaceNode(const ModuleInstantiation *mi) : LeafNode(mi) { }
-  std::string toString() const override;
-  std::string name() const override { return "surface"; }
+  VISITABLE ();
+  SurfaceNode (const ModuleInstantiation *mi)
+    : LeafNode (mi) {}
+  std::string toString () const override;
+  std::string name () const override {
+    return "surface";
+  }
 
   Filename filename;
   bool center{false};
   bool invert{false};
   int convexity{1};
 
-  std::unique_ptr<const Geometry> createGeometry() const override;
+  std::unique_ptr<const Geometry> createGeometry () const override;
+
 private:
-  void convert_image(img_data_t& data, std::vector<uint8_t>& img, unsigned int width, unsigned int height) const;
-  bool is_png(std::vector<uint8_t>& img) const;
-  img_data_t read_dat(std::string filename) const;
-  img_data_t read_png_or_dat(std::string filename) const;
+  void convert_image (img_data_t &data, std::vector<uint8_t> &img, unsigned int width, unsigned int height) const;
+  bool is_png (std::vector<uint8_t> &img) const;
+  img_data_t read_dat (std::string filename) const;
+  img_data_t read_png_or_dat (std::string filename) const;
 };
diff --git a/src/core/TextNode.cc b/src/core/TextNode.cc
index 274971622..7b79b8c9d 100644
--- a/src/core/TextNode.cc
+++ b/src/core/TextNode.cc
@@ -42,45 +42,39 @@
 #include <boost/assign/std/vector.hpp>
 using namespace boost::assign; // bring 'operator+=()' into scope
 
-static std::shared_ptr<AbstractNode> builtin_text(const ModuleInstantiation *inst, Arguments arguments)
-{
-  auto node = std::make_shared<TextNode>(inst);
+static std::shared_ptr<AbstractNode> builtin_text (const ModuleInstantiation *inst, Arguments arguments) {
+  auto node = std::make_shared<TextNode> (inst);
 
-  auto *session = arguments.session();
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(),
-                                            {"text", "size", "font"},
-                                            {"direction", "language", "script", "halign", "valign", "spacing"}
-                                            );
-  parameters.set_caller("text");
+  auto *session = arguments.session ();
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (),
+                                             {"text", "size", "font"},
+                                             {"direction", "language", "script", "halign", "valign", "spacing"});
+  parameters.set_caller ("text");
 
-  node->params.set_loc(inst->location());
-  node->params.set_documentPath(session->documentRoot());
-  node->params.set(parameters);
-  node->params.detect_properties();
+  node->params.set_loc (inst->location ());
+  node->params.set_documentPath (session->documentRoot ());
+  node->params.set (parameters);
+  node->params.detect_properties ();
 
   return node;
 }
 
-std::vector<std::shared_ptr<const Polygon2d>> TextNode::createPolygonList() const
-{
+std::vector<std::shared_ptr<const Polygon2d>> TextNode::createPolygonList () const {
   FreetypeRenderer renderer;
-  return renderer.render(this->get_params());
+  return renderer.render (this->get_params ());
 }
 
-FreetypeRenderer::Params TextNode::get_params() const
-{
+FreetypeRenderer::Params TextNode::get_params () const {
   return params;
 }
 
-std::string TextNode::toString() const
-{
-  return STR(name(), "(", this->params, ")");
+std::string TextNode::toString () const {
+  return STR (name (), "(", this->params, ")");
 }
 
-void register_builtin_text()
-{
-  Builtins::init("text", new BuiltinModule(builtin_text),
-  {
-    R"(text(text = "", size = 10, font = "", halign = "left", valign = "baseline", spacing = 1, direction = "ltr", language = "en", script = "latin"[, $fn]))",
-  });
+void register_builtin_text () {
+  Builtins::init ("text", new BuiltinModule (builtin_text),
+                  {
+                    R"(text(text = "", size = 10, font = "", halign = "left", valign = "baseline", spacing = 1, direction = "ltr", language = "en", script = "latin"[, $fn]))",
+                  });
 }
diff --git a/src/core/TextNode.h b/src/core/TextNode.h
index 0bf4e4783..daa2bdad9 100644
--- a/src/core/TextNode.h
+++ b/src/core/TextNode.h
@@ -14,15 +14,18 @@ class TextModule;
 class TextNode : public AbstractPolyNode
 {
 public:
-  VISITABLE();
-  TextNode(const ModuleInstantiation *mi) : AbstractPolyNode(mi) {}
+  VISITABLE ();
+  TextNode (const ModuleInstantiation *mi)
+    : AbstractPolyNode (mi) {}
 
-  std::string toString() const override;
-  std::string name() const override { return "text"; }
+  std::string toString () const override;
+  std::string name () const override {
+    return "text";
+  }
 
-  std::vector<std::shared_ptr<const Polygon2d>> createPolygonList() const;
+  std::vector<std::shared_ptr<const Polygon2d>> createPolygonList () const;
 
-  virtual FreetypeRenderer::Params get_params() const;
+  virtual FreetypeRenderer::Params get_params () const;
 
   FreetypeRenderer::Params params;
 };
diff --git a/src/core/TransformNode.cc b/src/core/TransformNode.cc
index e767b741d..479e86c74 100644
--- a/src/core/TransformNode.cc
+++ b/src/core/TransformNode.cc
@@ -52,119 +52,116 @@ enum class transform_type_e {
   MULTMATRIX
 };
 
-std::shared_ptr<AbstractNode> builtin_scale(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  auto node = std::make_shared<TransformNode>(inst, "scale");
+std::shared_ptr<AbstractNode> builtin_scale (const ModuleInstantiation *inst, Arguments arguments, const Children &children) {
+  auto node = std::make_shared<TransformNode> (inst, "scale");
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"v"});
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (), {"v"});
 
-  Vector3d scalevec(1, 1, 1);
-  if (!parameters["v"].getVec3(scalevec[0], scalevec[1], scalevec[2], 1.0)) {
+  Vector3d scalevec (1, 1, 1);
+  if (!parameters["v"].getVec3 (scalevec[0], scalevec[1], scalevec[2], 1.0)) {
     double num;
-    if (parameters["v"].getDouble(num)) {
-      scalevec.setConstant(num);
+    if (parameters["v"].getDouble (num)) {
+      scalevec.setConstant (num);
     } else {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Unable to convert scale(%1$s) parameter to a number, a vec3 or vec2 of numbers or a number", parameters["v"].toEchoStringNoThrow());
+      LOG (message_group::Warning, inst->location (), parameters.documentRoot (), "Unable to convert scale(%1$s) parameter to a number, a vec3 or vec2 of numbers or a number", parameters["v"].toEchoStringNoThrow ());
     }
   }
   if (OpenSCAD::rangeCheck) {
-    if (scalevec[0] == 0 || scalevec[1] == 0 || scalevec[2] == 0 || !std::isfinite(scalevec[0])|| !std::isfinite(scalevec[1])|| !std::isfinite(scalevec[2])) {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "scale(%1$s)", parameters["v"].toEchoStringNoThrow());
+    if (scalevec[0] == 0 || scalevec[1] == 0 || scalevec[2] == 0 || !std::isfinite (scalevec[0]) || !std::isfinite (scalevec[1]) || !std::isfinite (scalevec[2])) {
+      LOG (message_group::Warning, inst->location (), parameters.documentRoot (), "scale(%1$s)", parameters["v"].toEchoStringNoThrow ());
     }
   }
-  node->matrix.scale(scalevec);
+  node->matrix.scale (scalevec);
 
-  return children.instantiate(node);
+  return children.instantiate (node);
 }
 
-std::shared_ptr<AbstractNode> builtin_rotate(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  auto node = std::make_shared<TransformNode>(inst, "rotate");
+std::shared_ptr<AbstractNode> builtin_rotate (const ModuleInstantiation *inst, Arguments arguments, const Children &children) {
+  auto node = std::make_shared<TransformNode> (inst, "rotate");
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"a", "v"});
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (), {"a", "v"});
 
-  const auto& val_a = parameters["a"];
-  const auto& val_v = parameters["v"];
-  if (val_a.type() == Value::Type::VECTOR) {
+  const auto &val_a = parameters["a"];
+  const auto &val_v = parameters["v"];
+  if (val_a.type () == Value::Type::VECTOR) {
     double sx = 0, sy = 0, sz = 0;
     double cx = 1, cy = 1, cz = 1;
     double a = 0.0;
     bool ok = true;
-    const auto& vec_a = val_a.toVector();
-    switch (vec_a.size()) {
+    const auto &vec_a = val_a.toVector ();
+    switch (vec_a.size ()) {
     default:
       ok &= false;
       [[fallthrough]];
     case 3:
-      ok &= vec_a[2].getDouble(a);
-      ok &= !std::isinf(a) && !std::isnan(a);
-      sz = sin_degrees(a);
-      cz = cos_degrees(a);
+      ok &= vec_a[2].getDouble (a);
+      ok &= !std::isinf (a) && !std::isnan (a);
+      sz = sin_degrees (a);
+      cz = cos_degrees (a);
       [[fallthrough]];
     case 2:
-      ok &= vec_a[1].getDouble(a);
-      ok &= !std::isinf(a) && !std::isnan(a);
-      sy = sin_degrees(a);
-      cy = cos_degrees(a);
+      ok &= vec_a[1].getDouble (a);
+      ok &= !std::isinf (a) && !std::isnan (a);
+      sy = sin_degrees (a);
+      cy = cos_degrees (a);
       [[fallthrough]];
     case 1:
-      ok &= vec_a[0].getDouble(a);
-      ok &= !std::isinf(a) && !std::isnan(a);
-      sx = sin_degrees(a);
-      cx = cos_degrees(a);
+      ok &= vec_a[0].getDouble (a);
+      ok &= !std::isinf (a) && !std::isnan (a);
+      sx = sin_degrees (a);
+      cx = cos_degrees (a);
       break;
     case 0:
       break;
     }
 
-    bool v_supplied = val_v.isDefined();
+    bool v_supplied = val_v.isDefined ();
     if (ok) {
       if (v_supplied) {
-        LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "When parameter a is supplied as vector, v is ignored rotate(a=%1$s, v=%2$s)", val_a.toEchoStringNoThrow(), val_v.toEchoStringNoThrow());
+        LOG (message_group::Warning, inst->location (), parameters.documentRoot (), "When parameter a is supplied as vector, v is ignored rotate(a=%1$s, v=%2$s)", val_a.toEchoStringNoThrow (), val_v.toEchoStringNoThrow ());
       }
     } else {
       if (v_supplied) {
-        LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Problem converting rotate(a=%1$s, v=%2$s) parameter", val_a.toEchoStringNoThrow(), val_v.toEchoStringNoThrow());
+        LOG (message_group::Warning, inst->location (), parameters.documentRoot (), "Problem converting rotate(a=%1$s, v=%2$s) parameter", val_a.toEchoStringNoThrow (), val_v.toEchoStringNoThrow ());
       } else {
-        LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Problem converting rotate(a=%1$s) parameter", val_a.toEchoStringNoThrow());
+        LOG (message_group::Warning, inst->location (), parameters.documentRoot (), "Problem converting rotate(a=%1$s) parameter", val_a.toEchoStringNoThrow ());
       }
     }
     Matrix3d M;
-    M << cy * cz,  cz * sx * sy - cx * sz,   cx * cz * sy + sx * sz,
-      cy *sz,  cx *cz + sx * sy * sz,  -cz * sx + cx * sy * sz,
-      -sy,       cy *sx,                  cx *cy;
-    node->matrix.rotate(M);
+    M << cy * cz, cz * sx * sy - cx * sz, cx * cz * sy + sx * sz,
+      cy * sz, cx * cz + sx * sy * sz, -cz * sx + cx * sy * sz,
+      -sy, cy * sx, cx * cy;
+    node->matrix.rotate (M);
   } else {
     double a = 0.0;
-    bool aConverted = val_a.getDouble(a);
-    aConverted &= !std::isinf(a) && !std::isnan(a);
+    bool aConverted = val_a.getDouble (a);
+    aConverted &= !std::isinf (a) && !std::isnan (a);
 
-    Vector3d v(0, 0, 1);
-    bool vConverted = val_v.getVec3(v[0], v[1], v[2], 0.0);
-    node->matrix.rotate(angle_axis_degrees(aConverted ? a : 0, v));
-    if (val_v.isDefined() && !vConverted) {
+    Vector3d v (0, 0, 1);
+    bool vConverted = val_v.getVec3 (v[0], v[1], v[2], 0.0);
+    node->matrix.rotate (angle_axis_degrees (aConverted ? a : 0, v));
+    if (val_v.isDefined () && !vConverted) {
       if (aConverted) {
-        LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Problem converting rotate(..., v=%1$s) parameter", val_v.toEchoStringNoThrow());
+        LOG (message_group::Warning, inst->location (), parameters.documentRoot (), "Problem converting rotate(..., v=%1$s) parameter", val_v.toEchoStringNoThrow ());
       } else {
-        LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Problem converting rotate(a=%1$s, v=%2$s) parameter", val_a.toEchoStringNoThrow(), val_v.toEchoStringNoThrow());
+        LOG (message_group::Warning, inst->location (), parameters.documentRoot (), "Problem converting rotate(a=%1$s, v=%2$s) parameter", val_a.toEchoStringNoThrow (), val_v.toEchoStringNoThrow ());
       }
     } else if (!aConverted) {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Problem converting rotate(a=%1$s) parameter", val_a.toEchoStringNoThrow());
+      LOG (message_group::Warning, inst->location (), parameters.documentRoot (), "Problem converting rotate(a=%1$s) parameter", val_a.toEchoStringNoThrow ());
     }
   }
 
-  return children.instantiate(node);
+  return children.instantiate (node);
 }
 
-std::shared_ptr<AbstractNode> builtin_mirror(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  auto node = std::make_shared<TransformNode>(inst, "mirror");
+std::shared_ptr<AbstractNode> builtin_mirror (const ModuleInstantiation *inst, Arguments arguments, const Children &children) {
+  auto node = std::make_shared<TransformNode> (inst, "mirror");
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"v"});
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (), {"v"});
 
   double x = 1.0, y = 0.0, z = 0.0;
-  if (!parameters["v"].getVec3(x, y, z, 0.0)) {
-    LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Unable to convert mirror(%1$s) parameter to a vec3 or vec2 of numbers", parameters["v"].toEchoStringNoThrow());
+  if (!parameters["v"].getVec3 (x, y, z, 0.0)) {
+    LOG (message_group::Warning, inst->location (), parameters.documentRoot (), "Unable to convert mirror(%1$s) parameter to a vec3 or vec2 of numbers", parameters["v"].toEchoStringNoThrow ());
   }
 
   // x /= sqrt(x*x + y*y + z*z)
@@ -184,110 +181,107 @@ std::shared_ptr<AbstractNode> builtin_mirror(const ModuleInstantiation *inst, Ar
     node->matrix = m;
   }
 
-  return children.instantiate(node);
+  return children.instantiate (node);
 }
 
-std::shared_ptr<AbstractNode> builtin_translate(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  auto node = std::make_shared<TransformNode>(inst, "translate");
+std::shared_ptr<AbstractNode> builtin_translate (const ModuleInstantiation *inst, Arguments arguments, const Children &children) {
+  auto node = std::make_shared<TransformNode> (inst, "translate");
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"v"});
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (), {"v"});
 
-  Vector3d translatevec(0, 0, 0);
-  bool ok = parameters["v"].getVec3(translatevec[0], translatevec[1], translatevec[2], 0.0);
-  ok &= std::isfinite(translatevec[0]) && std::isfinite(translatevec[1]) && std::isfinite(translatevec[2]);
+  Vector3d translatevec (0, 0, 0);
+  bool ok = parameters["v"].getVec3 (translatevec[0], translatevec[1], translatevec[2], 0.0);
+  ok &= std::isfinite (translatevec[0]) && std::isfinite (translatevec[1]) && std::isfinite (translatevec[2]);
   if (ok) {
-    node->matrix.translate(translatevec);
+    node->matrix.translate (translatevec);
   } else {
-    LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Unable to convert translate(%1$s) parameter to a vec3 or vec2 of numbers", parameters["v"].toEchoStringNoThrow());
+    LOG (message_group::Warning, inst->location (), parameters.documentRoot (), "Unable to convert translate(%1$s) parameter to a vec3 or vec2 of numbers", parameters["v"].toEchoStringNoThrow ());
   }
 
-  return children.instantiate(node);
+  return children.instantiate (node);
 }
 
-std::shared_ptr<AbstractNode> builtin_multmatrix(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  auto node = std::make_shared<TransformNode>(inst, "multmatrix");
+std::shared_ptr<AbstractNode> builtin_multmatrix (const ModuleInstantiation *inst, Arguments arguments, const Children &children) {
+  auto node = std::make_shared<TransformNode> (inst, "multmatrix");
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"m"});
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (), {"m"});
 
-  if (parameters["m"].type() == Value::Type::VECTOR) {
-    Matrix4d rawmatrix{Matrix4d::Identity()};
-    const auto& mat = parameters["m"].toVector();
-    for (size_t row_i = 0; row_i < std::min(mat.size(), size_t(4)); ++row_i) {
-      const auto& row = mat[row_i].toVector();
-      for (size_t col_i = 0; col_i < std::min(row.size(), size_t(4)); ++col_i) {
-        row[col_i].getDouble(rawmatrix(row_i, col_i));
+  if (parameters["m"].type () == Value::Type::VECTOR) {
+    Matrix4d rawmatrix{Matrix4d::Identity ()};
+    const auto &mat = parameters["m"].toVector ();
+    for (size_t row_i = 0; row_i < std::min (mat.size (), size_t (4)); ++row_i) {
+      const auto &row = mat[row_i].toVector ();
+      for (size_t col_i = 0; col_i < std::min (row.size (), size_t (4)); ++col_i) {
+        row[col_i].getDouble (rawmatrix (row_i, col_i));
       }
     }
-    double w = rawmatrix(3, 3);
-    if (w != 1.0) node->matrix = rawmatrix / w;
-    else node->matrix = rawmatrix;
+    double w = rawmatrix (3, 3);
+    if (w != 1.0)
+      node->matrix = rawmatrix / w;
+    else
+      node->matrix = rawmatrix;
   }
 
-  return children.instantiate(node);
+  return children.instantiate (node);
 }
 
-std::string TransformNode::toString() const
-{
+std::string TransformNode::toString () const {
   std::ostringstream stream;
 
   stream << "multmatrix([";
   for (int j = 0; j < 4; ++j) {
     stream << "[";
     for (int i = 0; i < 4; ++i) {
-      stream << this->matrix(j, i);
-      if (i != 3) stream << ", ";
+      stream << this->matrix (j, i);
+      if (i != 3)
+        stream << ", ";
     }
     stream << "]";
-    if (j != 3) stream << ", ";
+    if (j != 3)
+      stream << ", ";
   }
   stream << "])";
 
-  return stream.str();
+  return stream.str ();
 }
 
-TransformNode::TransformNode(const ModuleInstantiation *mi, std::string verbose_name) :
-  AbstractNode(mi),
-  matrix(Transform3d::Identity()),
-  _name(std::move(verbose_name))
-{
+TransformNode::TransformNode (const ModuleInstantiation *mi, std::string verbose_name)
+  : AbstractNode (mi)
+  , matrix (Transform3d::Identity ())
+  , _name (std::move (verbose_name)) {
 }
 
-std::string TransformNode::name() const
-{
+std::string TransformNode::name () const {
   return "transform";
 }
 
-std::string TransformNode::verbose_name() const
-{
+std::string TransformNode::verbose_name () const {
   return _name;
 }
 
-void register_builtin_transform()
-{
-  Builtins::init("scale", new BuiltinModule(builtin_scale),
-  {
-    "scale([x, y, z])",
-  });
-
-  Builtins::init("rotate", new BuiltinModule(builtin_rotate),
-  {
-    "rotate([x, y, z])",
-  });
-
-  Builtins::init("mirror", new BuiltinModule(builtin_mirror),
-  {
-    "mirror([x, y, z])",
-  });
-
-  Builtins::init("translate", new BuiltinModule(builtin_translate),
-  {
-    "translate([x, y, z])",
-  });
-
-  Builtins::init("multmatrix", new BuiltinModule(builtin_multmatrix),
-  {
-    "multmatrix(matrix_4_by_4)",
-  });
+void register_builtin_transform () {
+  Builtins::init ("scale", new BuiltinModule (builtin_scale),
+                  {
+                    "scale([x, y, z])",
+                  });
+
+  Builtins::init ("rotate", new BuiltinModule (builtin_rotate),
+                  {
+                    "rotate([x, y, z])",
+                  });
+
+  Builtins::init ("mirror", new BuiltinModule (builtin_mirror),
+                  {
+                    "mirror([x, y, z])",
+                  });
+
+  Builtins::init ("translate", new BuiltinModule (builtin_translate),
+                  {
+                    "translate([x, y, z])",
+                  });
+
+  Builtins::init ("multmatrix", new BuiltinModule (builtin_multmatrix),
+                  {
+                    "multmatrix(matrix_4_by_4)",
+                  });
 }
diff --git a/src/core/TransformNode.h b/src/core/TransformNode.h
index 3aaadb9a0..869cba662 100644
--- a/src/core/TransformNode.h
+++ b/src/core/TransformNode.h
@@ -9,12 +9,12 @@
 class TransformNode : public AbstractNode
 {
 public:
-  VISITABLE();
+  VISITABLE ();
   EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-  TransformNode(const ModuleInstantiation *mi, std::string verbose_name);
-  std::string toString() const override;
-  std::string name() const override;
-  std::string verbose_name() const override;
+  TransformNode (const ModuleInstantiation *mi, std::string verbose_name);
+  std::string toString () const override;
+  std::string name () const override;
+  std::string verbose_name () const override;
   Transform3d matrix;
 
 private:
diff --git a/src/core/Tree.cc b/src/core/Tree.cc
index 9c54d3e37..2bc48514e 100644
--- a/src/core/Tree.cc
+++ b/src/core/Tree.cc
@@ -6,28 +6,26 @@
 #include <string>
 #include <tuple>
 
-Tree::~Tree()
-{
-  this->nodecachemap.clear();
+Tree::~Tree () {
+  this->nodecachemap.clear ();
 }
 
 /*!
    Returns the cached string representation of the subtree rooted by \a node.
    If node is not cached, the cache will be rebuilt.
  */
-const std::string Tree::getString(const AbstractNode& node, const std::string& indent) const
-{
-  assert(this->root_node);
+const std::string Tree::getString (const AbstractNode &node, const std::string &indent) const {
+  assert (this->root_node);
   bool idString = false;
 
   // Retrieve a nodecache given a tuple of NodeDumper constructor options
-  NodeCache& nodecache = this->nodecachemap[std::make_tuple(indent, idString)];
+  NodeCache &nodecache = this->nodecachemap[std::make_tuple (indent, idString)];
 
-  if (!nodecache.contains(node)) {
-    NodeDumper dumper(nodecache, this->root_node, indent, idString);
-    dumper.traverse(*this->root_node);
-    assert(nodecache.contains(*this->root_node) &&
-           "NodeDumper failed to create a cache");
+  if (!nodecache.contains (node)) {
+    NodeDumper dumper (nodecache, this->root_node, indent, idString);
+    dumper.traverse (*this->root_node);
+    assert (nodecache.contains (*this->root_node) &&
+            "NodeDumper failed to create a cache");
   }
   return nodecache[node];
 }
@@ -40,21 +38,20 @@ const std::string Tree::getString(const AbstractNode& node, const std::string& i
    is stripped for whitespace. Especially indentation whitespace is important to
    strip to enable cache hits for equivalent nodes from different scopes.
  */
-const std::string Tree::getIdString(const AbstractNode& node) const
-{
-  assert(this->root_node);
+const std::string Tree::getIdString (const AbstractNode &node) const {
+  assert (this->root_node);
   const std::string indent = "";
   const bool idString = true;
 
   // Retrieve a nodecache given a tuple of NodeDumper constructor options
-  NodeCache& nodecache = this->nodecachemap[make_tuple(indent, idString)];
+  NodeCache &nodecache = this->nodecachemap[make_tuple (indent, idString)];
 
-  if (!nodecache.contains(node)) {
-    nodecache.clear();
-    NodeDumper dumper(nodecache, this->root_node, indent, idString);
-    dumper.traverse(*this->root_node);
-    assert(nodecache.contains(*this->root_node) &&
-           "NodeDumper failed to create id cache");
+  if (!nodecache.contains (node)) {
+    nodecache.clear ();
+    NodeDumper dumper (nodecache, this->root_node, indent, idString);
+    dumper.traverse (*this->root_node);
+    assert (nodecache.contains (*this->root_node) &&
+            "NodeDumper failed to create id cache");
   }
   return nodecache[node];
 }
@@ -62,17 +59,15 @@ const std::string Tree::getIdString(const AbstractNode& node) const
 /*!
    Sets a new root. Will clear the existing cache.
  */
-void Tree::setRoot(const std::shared_ptr<const AbstractNode>& root)
-{
+void Tree::setRoot (const std::shared_ptr<const AbstractNode> &root) {
   this->root_node = root;
-  this->nodecachemap.clear();
+  this->nodecachemap.clear ();
 }
 
-void Tree::setDocumentPath(const std::string& path){
+void Tree::setDocumentPath (const std::string &path) {
   this->document_path = path;
 }
 
-const std::string Tree::getDocumentPath() const
-{
+const std::string Tree::getDocumentPath () const {
   return this->document_path;
 }
diff --git a/src/core/Tree.h b/src/core/Tree.h
index efe74daab..9175ae277 100644
--- a/src/core/Tree.h
+++ b/src/core/Tree.h
@@ -16,16 +16,20 @@
 class Tree
 {
 public:
-  Tree(std::shared_ptr<const AbstractNode> root = nullptr, std::string path = {}) : root_node(std::move(root)), document_path(std::move(path)) {}
-  ~Tree();
+  Tree (std::shared_ptr<const AbstractNode> root = nullptr, std::string path = {})
+    : root_node (std::move (root))
+    , document_path (std::move (path)) {}
+  ~Tree ();
 
-  void setRoot(const std::shared_ptr<const AbstractNode>& root);
-  void setDocumentPath(const std::string& path);
-  const std::shared_ptr<const AbstractNode>& root() const { return this->root_node; }
+  void setRoot (const std::shared_ptr<const AbstractNode> &root);
+  void setDocumentPath (const std::string &path);
+  const std::shared_ptr<const AbstractNode> &root () const {
+    return this->root_node;
+  }
 
-  const std::string getString(const AbstractNode& node, const std::string& indent) const;
-  const std::string getIdString(const AbstractNode& node) const;
-  const std::string getDocumentPath() const;
+  const std::string getString (const AbstractNode &node, const std::string &indent) const;
+  const std::string getIdString (const AbstractNode &node) const;
+  const std::string getDocumentPath () const;
 
 private:
   std::shared_ptr<const AbstractNode> root_node;
diff --git a/src/core/UndefType.cc b/src/core/UndefType.cc
index 3b0463ad1..807ad489f 100644
--- a/src/core/UndefType.cc
+++ b/src/core/UndefType.cc
@@ -1,14 +1,14 @@
 #include "core/Value.h"
 
-Value UndefType::operator<(const UndefType& /*other*/) const {
-  return Value::undef("operation undefined (undefined < undefined)");
+Value UndefType::operator< (const UndefType & /*other*/) const {
+  return Value::undef ("operation undefined (undefined < undefined)");
 }
-Value UndefType::operator>(const UndefType& /*other*/) const {
-  return Value::undef("operation undefined (undefined > undefined)");
+Value UndefType::operator> (const UndefType & /*other*/) const {
+  return Value::undef ("operation undefined (undefined > undefined)");
 }
-Value UndefType::operator<=(const UndefType& /*other*/) const {
-  return Value::undef("operation undefined (undefined <= undefined)");
+Value UndefType::operator<= (const UndefType & /*other*/) const {
+  return Value::undef ("operation undefined (undefined <= undefined)");
 }
-Value UndefType::operator>=(const UndefType& /*other*/) const {
-  return Value::undef("operation undefined (undefined >= undefined)");
+Value UndefType::operator>= (const UndefType & /*other*/) const {
+  return Value::undef ("operation undefined (undefined >= undefined)");
 }
diff --git a/src/core/UndefType.h b/src/core/UndefType.h
index 1bee3c348..28990c778 100644
--- a/src/core/UndefType.h
+++ b/src/core/UndefType.h
@@ -19,31 +19,39 @@ class UndefType
 {
 public:
   // TODO: eventually deprecate undef creation without a reason.
-  UndefType() : reasons{std::make_unique<std::vector<std::string>>()} { }
-  explicit UndefType(const std::string& why) : reasons{std::make_unique<std::vector<std::string>>(std::initializer_list<std::string>({why}))} { }
+  UndefType ()
+    : reasons{std::make_unique<std::vector<std::string>> ()} {}
+  explicit UndefType (const std::string &why)
+    : reasons{std::make_unique<std::vector<std::string>> (std::initializer_list<std::string> ({why}))} {}
 
   // Append another reason in case a chain of undefined operations are made before handling
-  const UndefType& append(const std::string& why) const { reasons->push_back(why); return *this; }
+  const UndefType &append (const std::string &why) const {
+    reasons->push_back (why);
+    return *this;
+  }
 
-  Value operator<(const UndefType& other) const;
-  Value operator>(const UndefType& other) const;
-  Value operator<=(const UndefType& other) const;
-  Value operator>=(const UndefType& other) const;
+  Value operator< (const UndefType &other) const;
+  Value operator> (const UndefType &other) const;
+  Value operator<= (const UndefType &other) const;
+  Value operator>= (const UndefType &other) const;
 
-  std::string toString() const {
+  std::string toString () const {
     std::ostringstream stream;
-    if (!reasons->empty()) {
-      auto it = reasons->begin();
+    if (!reasons->empty ()) {
+      auto it = reasons->begin ();
       stream << *it;
-      for (++it; it != reasons->end(); ++it) {
+      for (++it; it != reasons->end (); ++it) {
         stream << "\n\t" << *it;
       }
     }
     // clear reasons so multiple same warnings are not given on the same value
-    reasons->clear();
-    return stream.str();
+    reasons->clear ();
+    return stream.str ();
+  }
+  bool empty () const {
+    return reasons->empty ();
   }
-  bool empty() const { return reasons->empty(); }
+
 private:
   // using unique_ptr to keep the size small enough that the variant of
   // all value types does not exceed the 24 bytes.
@@ -51,9 +59,7 @@ private:
   mutable std::unique_ptr<std::vector<std::string>> reasons;
 };
 
-
-inline std::ostream& operator<<(std::ostream& stream, const UndefType& /*u*/)
-{
+inline std::ostream &operator<< (std::ostream &stream, const UndefType & /*u*/) {
   stream << "undef";
   return stream;
 }
diff --git a/src/core/UserModule.cc b/src/core/UserModule.cc
index d36dc29cb..1f3dd4d27 100644
--- a/src/core/UserModule.cc
+++ b/src/core/UserModule.cc
@@ -45,67 +45,64 @@
 
 std::vector<std::string> StaticModuleNameStack::stack;
 
-static void NOINLINE print_err(std::string name, const Location& loc, const std::shared_ptr<const Context>& context){
-  LOG(message_group::Error, loc, context->documentRoot(), "Recursion detected calling module '%1$s'", name);
+static void NOINLINE print_err (std::string name, const Location &loc, const std::shared_ptr<const Context> &context) {
+  LOG (message_group::Error, loc, context->documentRoot (), "Recursion detected calling module '%1$s'", name);
 }
 
-static void NOINLINE print_trace(const UserModule *mod, const std::shared_ptr<const UserModuleContext>& context, const AssignmentList& parameters){
+static void NOINLINE print_trace (const UserModule *mod, const std::shared_ptr<const UserModuleContext> &context, const AssignmentList &parameters) {
   std::stringstream stream;
-  if (parameters.size() == 0) {
+  if (parameters.size () == 0) {
     //nothing to do
-  } else if (StackCheck::inst().check()) {
+  } else if (StackCheck::inst ().check ()) {
     stream << "...";
   } else {
     bool first = true;
-    for (const auto& assignment : parameters) {
+    for (const auto &assignment : parameters) {
       if (first) {
         first = false;
       } else {
         stream << ", ";
       }
-      if (!assignment->getName().empty()) {
-        stream << assignment->getName();
+      if (!assignment->getName ().empty ()) {
+        stream << assignment->getName ();
         stream << " = ";
       }
       try {
-        stream << context->lookup_variable(assignment->getName(), Location::NONE);
-      } catch (EvaluationException& e) {
+        stream << context->lookup_variable (assignment->getName (), Location::NONE);
+      } catch (EvaluationException &e) {
         stream << "...";
       }
     }
   }
-  LOG(message_group::Trace, mod->location(), context->documentRoot(), "call of '%1$s(%2$s)'",
-      mod->name, stream.str()
-      );
+  LOG (message_group::Trace, mod->location (), context->documentRoot (), "call of '%1$s(%2$s)'",
+       mod->name, stream.str ());
 }
 
-std::shared_ptr<AbstractNode> UserModule::instantiate(const std::shared_ptr<const Context>& defining_context, const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context) const
-{
-  if (StackCheck::inst().check()) {
-    print_err(inst->name(), loc, context);
-    throw RecursionException::create("module", inst->name(), loc);
+std::shared_ptr<AbstractNode> UserModule::instantiate (const std::shared_ptr<const Context> &defining_context, const ModuleInstantiation *inst, const std::shared_ptr<const Context> &context) const {
+  if (StackCheck::inst ().check ()) {
+    print_err (inst->name (), loc, context);
+    throw RecursionException::create ("module", inst->name (), loc);
     return nullptr;
   }
 
-  StaticModuleNameStack name{inst->name()}; // push on static stack, pop at end of method!
-  ContextHandle<UserModuleContext> module_context{Context::create<UserModuleContext>(
-                                                    defining_context,
-                                                    this,
-                                                    inst->location(),
-                                                    Arguments(inst->arguments, context),
-                                                    Children(&inst->scope, context)
-                                                    )};
+  StaticModuleNameStack name{inst->name ()}; // push on static stack, pop at end of method!
+  ContextHandle<UserModuleContext> module_context{Context::create<UserModuleContext> (
+    defining_context,
+    this,
+    inst->location (),
+    Arguments (inst->arguments, context),
+    Children (&inst->scope, context))};
 #if 0 && DEBUG
   PRINTDB("UserModuleContext for module %s(%s):\n", this->name % STR(this->parameters));
   PRINTDB("%s", module_context->dump());
 #endif
 
   std::shared_ptr<AbstractNode> ret;
-  try{
-    ret = this->body.instantiateModules(*module_context, std::make_shared<GroupNode>(inst, std::string("module ") + this->name));
-  } catch (EvaluationException& e) {
+  try {
+    ret = this->body.instantiateModules (*module_context, std::make_shared<GroupNode> (inst, std::string ("module ") + this->name));
+  } catch (EvaluationException &e) {
     if (OpenSCAD::traceUsermoduleParameters && e.traceDepth > 0) {
-      print_trace(this, *module_context, this->parameters);
+      print_trace (this, *module_context, this->parameters);
       e.traceDepth--;
     }
     throw;
@@ -113,22 +110,23 @@ std::shared_ptr<AbstractNode> UserModule::instantiate(const std::shared_ptr<cons
   return ret;
 }
 
-void UserModule::print(std::ostream& stream, const std::string& indent) const
-{
+void UserModule::print (std::ostream &stream, const std::string &indent) const {
   std::string tab;
-  if (!this->name.empty()) {
+  if (!this->name.empty ()) {
     stream << indent << "module " << this->name << "(";
-    for (size_t i = 0; i < this->parameters.size(); ++i) {
-      const auto& parameter = this->parameters[i];
-      if (i > 0) stream << ", ";
-      stream << parameter->getName();
-      if (parameter->getExpr()) stream << " = " << *parameter->getExpr();
+    for (size_t i = 0; i < this->parameters.size (); ++i) {
+      const auto &parameter = this->parameters[i];
+      if (i > 0)
+        stream << ", ";
+      stream << parameter->getName ();
+      if (parameter->getExpr ())
+        stream << " = " << *parameter->getExpr ();
     }
     stream << ") {\n";
     tab = "\t";
   }
-  body.print(stream, indent + tab);
-  if (!this->name.empty()) {
+  body.print (stream, indent + tab);
+  if (!this->name.empty ()) {
     stream << indent << "}\n";
   }
 }
diff --git a/src/core/UserModule.h b/src/core/UserModule.h
index 39cc4df34..99ffa39ad 100644
--- a/src/core/UserModule.h
+++ b/src/core/UserModule.h
@@ -14,15 +14,19 @@ class Feature;
 class StaticModuleNameStack
 {
 public:
-  StaticModuleNameStack(const std::string& name) {
-    stack.push_back(name);
+  StaticModuleNameStack (const std::string &name) {
+    stack.push_back (name);
   }
-  ~StaticModuleNameStack() {
-    stack.pop_back();
+  ~StaticModuleNameStack () {
+    stack.pop_back ();
   }
 
-  static int size() { return stack.size(); }
-  static const std::string& at(int idx) { return stack[idx]; }
+  static int size () {
+    return stack.size ();
+  }
+  static const std::string &at (int idx) {
+    return stack[idx];
+  }
 
 private:
   static std::vector<std::string> stack;
@@ -31,13 +35,22 @@ private:
 class UserModule : public AbstractModule, public ASTNode
 {
 public:
-  UserModule(const char *name, const Location& loc) : ASTNode(loc), name(name) { }
-  UserModule(const char *name, const Feature& feature, const Location& loc) : AbstractModule(feature), ASTNode(loc), name(name) { }
-
-  std::shared_ptr<AbstractNode> instantiate(const std::shared_ptr<const Context>& defining_context, const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
-  static const std::string& stack_element(int n) { return StaticModuleNameStack::at(n); }
-  static int stack_size() { return StaticModuleNameStack::size(); }
+  UserModule (const char *name, const Location &loc)
+    : ASTNode (loc)
+    , name (name) {}
+  UserModule (const char *name, const Feature &feature, const Location &loc)
+    : AbstractModule (feature)
+    , ASTNode (loc)
+    , name (name) {}
+
+  std::shared_ptr<AbstractNode> instantiate (const std::shared_ptr<const Context> &defining_context, const ModuleInstantiation *inst, const std::shared_ptr<const Context> &context) const override;
+  void print (std::ostream &stream, const std::string &indent) const override;
+  static const std::string &stack_element (int n) {
+    return StaticModuleNameStack::at (n);
+  }
+  static int stack_size () {
+    return StaticModuleNameStack::size ();
+  }
 
   std::string name;
   AssignmentList parameters;
diff --git a/src/core/Value.cc b/src/core/Value.cc
index 976204a98..aeab3a750 100644
--- a/src/core/Value.cc
+++ b/src/core/Value.cc
@@ -53,10 +53,9 @@
 namespace fs = std::filesystem;
 
 const Value Value::undefined;
-const VectorType VectorType::EMPTY(nullptr);
+const VectorType VectorType::EMPTY (nullptr);
 const RangeType RangeType::EMPTY{0, 0, 0};
 
-
 /* Define values for double-conversion library. */
 #define DC_BUFFER_SIZE (128)
 #define DC_FLAGS (double_conversion::DoubleToStringConverter::UNIQUE_ZERO | double_conversion::DoubleToStringConverter::EMIT_POSITIVE_EXPONENT_SIGN)
@@ -81,37 +80,38 @@ const RangeType RangeType::EMPTY{0, 0, 0};
 //parameter currentpos shall be set to end of buffer (where '\0' is located).
 //set parameters exppos and decimalpos when needed.
 //leave parameter zeropos as is.
-inline int trimTrailingZeroesHelper(char *buffer, const int pos, char *currentpos = nullptr, char *exppos = nullptr, char *decimalpos = nullptr, char *zeropos = nullptr) {
+inline int trimTrailingZeroesHelper (char *buffer, const int pos, char *currentpos = nullptr, char *exppos = nullptr, char *decimalpos = nullptr, char *zeropos = nullptr) {
 
   int cont = TRIM_TRAILINGZEROES_CONTINUE;
 
   //we have exhausted all positions from end to start
-  if (currentpos <= buffer) return TRIM_TRAILINGZEROES_DONE;
+  if (currentpos <= buffer)
+    return TRIM_TRAILINGZEROES_DONE;
 
   //we do no need to process the terminator of string
   if (*currentpos == '\0') {
     currentpos--;
-    cont = trimTrailingZeroesHelper(buffer, pos, currentpos, exppos, decimalpos, zeropos);
+    cont = trimTrailingZeroesHelper (buffer, pos, currentpos, exppos, decimalpos, zeropos);
   }
 
   //we have an exponent and jumps to the position before the exponent - no need to process the characters belonging to the exponent
   if (cont && exppos && currentpos >= exppos) {
     currentpos = exppos;
     currentpos--;
-    cont = trimTrailingZeroesHelper(buffer, pos, currentpos, exppos, decimalpos, zeropos);
+    cont = trimTrailingZeroesHelper (buffer, pos, currentpos, exppos, decimalpos, zeropos);
   }
 
   //we are still on the right side of the decimal and still counting zeroes (keep track of) from the back to start
   if (cont && currentpos && decimalpos < currentpos && *currentpos == '0') {
     zeropos = currentpos;
     currentpos--;
-    cont = trimTrailingZeroesHelper(buffer, pos, currentpos, exppos, decimalpos, zeropos);
+    cont = trimTrailingZeroesHelper (buffer, pos, currentpos, exppos, decimalpos, zeropos);
   }
 
   //we have found the first occurrence of not a zero and have zeroes and exponent to take care of (move exponent to either the position of the zero or the decimal)
   if (cont && zeropos && exppos) {
     int count = &buffer[pos] - exppos + 1;
-    memmove(zeropos - 1 == decimalpos ? decimalpos : zeropos, exppos, count);
+    memmove (zeropos - 1 == decimalpos ? decimalpos : zeropos, exppos, count);
     return TRIM_TRAILINGZEROES_DONE;
   }
 
@@ -122,150 +122,201 @@ inline int trimTrailingZeroesHelper(char *buffer, const int pos, char *currentpo
   }
 
   //we have just another character (other than a zero) and are done
-  if (cont && !zeropos) return TRIM_TRAILINGZEROES_DONE;
+  if (cont && !zeropos)
+    return TRIM_TRAILINGZEROES_DONE;
 
   return TRIM_TRAILINGZEROES_DONE;
 }
 
-inline void trimTrailingZeroes(char *buffer, const int pos) {
-  char *decimal = strchr(buffer, '.');
+inline void trimTrailingZeroes (char *buffer, const int pos) {
+  char *decimal = strchr (buffer, '.');
   if (decimal) {
-    char *exppos = strchr(buffer, DC_EXP);
-    trimTrailingZeroesHelper(buffer, pos, &buffer[pos], exppos, decimal, nullptr);
+    char *exppos = strchr (buffer, DC_EXP);
+    trimTrailingZeroesHelper (buffer, pos, &buffer[pos], exppos, decimal, nullptr);
   }
 }
 
-inline bool HandleSpecialValues(const double& value, double_conversion::StringBuilder& builder) {
-  double_conversion::Double double_inspect(value);
-  if (double_inspect.IsInfinite()) {
+inline bool HandleSpecialValues (const double &value, double_conversion::StringBuilder &builder) {
+  double_conversion::Double double_inspect (value);
+  if (double_inspect.IsInfinite ()) {
     if (value < 0) {
-      builder.AddCharacter('-');
+      builder.AddCharacter ('-');
     }
-    builder.AddString(DC_INF);
+    builder.AddString (DC_INF);
     return true;
   }
-  if (double_inspect.IsNan()) {
-    builder.AddString(DC_NAN);
+  if (double_inspect.IsNan ()) {
+    builder.AddString (DC_NAN);
     return true;
   }
   return false;
 }
 
-inline std::string DoubleConvert(const double& value, char *buffer,
-                                 double_conversion::StringBuilder& builder, const double_conversion::DoubleToStringConverter& dc) {
-  builder.Reset();
-  if (double_conversion::Double(value).IsSpecial()) {
-    HandleSpecialValues(value, builder);
-    builder.Finalize();
+inline std::string DoubleConvert (const double &value, char *buffer,
+                                  double_conversion::StringBuilder &builder, const double_conversion::DoubleToStringConverter &dc) {
+  builder.Reset ();
+  if (double_conversion::Double (value).IsSpecial ()) {
+    HandleSpecialValues (value, builder);
+    builder.Finalize ();
     return buffer;
   }
-  dc.ToPrecision(value, DC_PRECISION_REQUESTED, &builder);
-  int pos = builder.position(); // get position before Finalize destroys it
-  builder.Finalize();
-  trimTrailingZeroes(buffer, pos);
+  dc.ToPrecision (value, DC_PRECISION_REQUESTED, &builder);
+  int pos = builder.position (); // get position before Finalize destroys it
+  builder.Finalize ();
+  trimTrailingZeroes (buffer, pos);
   return buffer;
 }
 
-static uint32_t convert_to_uint32(const double d)
-{
-  auto ret = std::numeric_limits<uint32_t>::max();
-  if (std::isfinite(d)) {
+static uint32_t convert_to_uint32 (const double d) {
+  auto ret = std::numeric_limits<uint32_t>::max ();
+  if (std::isfinite (d)) {
     try {
-      ret = boost::numeric_cast<uint32_t>(d);
-    } catch (boost::bad_numeric_cast&) {
+      ret = boost::numeric_cast<uint32_t> (d);
+    } catch (boost::bad_numeric_cast &) {
       // ignore, leaving the default max() value
     }
   }
   return ret;
 }
 
-std::ostream& operator<<(std::ostream& stream, const Filename& filename)
-{
-  fs::path fnpath{static_cast<std::string>(filename)}; // gcc-4.6
-  auto fpath = fs_uncomplete(fnpath, fs::current_path());
-  stream << QuotedString(fpath.generic_string());
+std::ostream &operator<< (std::ostream &stream, const Filename &filename) {
+  fs::path fnpath{static_cast<std::string> (filename)}; // gcc-4.6
+  auto fpath = fs_uncomplete (fnpath, fs::current_path ());
+  stream << QuotedString (fpath.generic_string ());
   return stream;
 }
 
 // FIXME: This could probably be done more elegantly using boost::regex
-std::ostream& operator<<(std::ostream& stream, const QuotedString& s)
-{
+std::ostream &operator<< (std::ostream &stream, const QuotedString &s) {
   stream << '"';
   for (char c : s) {
     switch (c) {
-    case '\t': stream << "\\t"; break;
-    case '\n': stream << "\\n"; break;
-    case '\r': stream << "\\r"; break;
-    case '"':  stream << "\\\""; break;
-    case '\\': stream << "\\\\"; break;
-    default:   stream << c;
+    case '\t':
+      stream << "\\t";
+      break;
+    case '\n':
+      stream << "\\n";
+      break;
+    case '\r':
+      stream << "\\r";
+      break;
+    case '"':
+      stream << "\\\"";
+      break;
+    case '\\':
+      stream << "\\\\";
+      break;
+    default:
+      stream << c;
     }
   }
   return stream << '"';
 }
 
-Value Value::clone() const {
-  switch (this->type()) {
-  case Type::UNDEFINED: return {};
-  case Type::BOOL:      return std::get<bool>(this->value);
-  case Type::NUMBER:    return std::get<double>(this->value);
-  case Type::STRING:    return std::get<str_utf8_wrapper>(this->value).clone();
-  case Type::RANGE:     return std::get<RangePtr>(this->value).clone();
-  case Type::VECTOR:    return std::get<VectorType>(this->value).clone();
-  case Type::OBJECT:    return std::get<ObjectType>(this->value).clone();
-  case Type::FUNCTION:  return std::get<FunctionPtr>(this->value).clone();
-  default: assert(false && "unknown Value variant type"); return {};
-  }
-}
-
-Value Value::undef(const std::string& why)
-{
+Value Value::clone () const {
+  switch (this->type ()) {
+  case Type::UNDEFINED:
+    return {};
+  case Type::BOOL:
+    return std::get<bool> (this->value);
+  case Type::NUMBER:
+    return std::get<double> (this->value);
+  case Type::STRING:
+    return std::get<str_utf8_wrapper> (this->value).clone ();
+  case Type::RANGE:
+    return std::get<RangePtr> (this->value).clone ();
+  case Type::VECTOR:
+    return std::get<VectorType> (this->value).clone ();
+  case Type::OBJECT:
+    return std::get<ObjectType> (this->value).clone ();
+  case Type::FUNCTION:
+    return std::get<FunctionPtr> (this->value).clone ();
+  default:
+    assert (false && "unknown Value variant type");
+    return {};
+  }
+}
+
+Value Value::undef (const std::string &why) {
   return Value{UndefType{why}};
 }
 
-std::string Value::typeName(Type type)
-{
+std::string Value::typeName (Type type) {
   switch (type) {
-  case Type::UNDEFINED: return "undefined";
-  case Type::BOOL:      return "bool";
-  case Type::NUMBER:    return "number";
-  case Type::STRING:    return "string";
-  case Type::VECTOR:    return "vector";
-  case Type::RANGE:     return "range";
-  case Type::OBJECT:    return "object";
-  case Type::FUNCTION:  return "function";
-  default: assert(false && "unknown Value variant type"); return "<unknown>";
-  }
+  case Type::UNDEFINED:
+    return "undefined";
+  case Type::BOOL:
+    return "bool";
+  case Type::NUMBER:
+    return "number";
+  case Type::STRING:
+    return "string";
+  case Type::VECTOR:
+    return "vector";
+  case Type::RANGE:
+    return "range";
+  case Type::OBJECT:
+    return "object";
+  case Type::FUNCTION:
+    return "function";
+  default:
+    assert (false && "unknown Value variant type");
+    return "<unknown>";
+  }
+}
+
+const std::string Value::typeName () const {
+  return typeName (this->type ());
 }
 
-const std::string Value::typeName() const
-{
-  return typeName(this->type());
+// free functions for use by static_visitor templated functions in creating undef messages.
+std::string getTypeName (const UndefType &) {
+  return "undefined";
+}
+std::string getTypeName (bool) {
+  return "bool";
+}
+std::string getTypeName (double) {
+  return "number";
+}
+std::string getTypeName (const str_utf8_wrapper &) {
+  return "string";
+}
+std::string getTypeName (const VectorType &) {
+  return "vector";
+}
+std::string getTypeName (const ObjectType &) {
+  return "object";
+}
+std::string getTypeName (const RangePtr &) {
+  return "range";
+}
+std::string getTypeName (const FunctionPtr &) {
+  return "function";
 }
 
-// free functions for use by static_visitor templated functions in creating undef messages.
-std::string getTypeName(const UndefType&) { return "undefined"; }
-std::string getTypeName(bool) { return "bool"; }
-std::string getTypeName(double) { return "number"; }
-std::string getTypeName(const str_utf8_wrapper&) { return "string"; }
-std::string getTypeName(const VectorType&) { return "vector"; }
-std::string getTypeName(const ObjectType&) { return "object"; }
-std::string getTypeName(const RangePtr&) { return "range"; }
-std::string getTypeName(const FunctionPtr&) { return "function"; }
-
-bool Value::toBool() const
-{
+bool Value::toBool () const {
   // NOLINTBEGIN(bugprone-branch-clone)
-  switch (this->type()) {
-  case Type::UNDEFINED: return false;
-  case Type::BOOL:      return std::get<bool>(this->value);
-  case Type::NUMBER:    return std::get<double>(this->value) != 0;
-  case Type::STRING:    return !std::get<str_utf8_wrapper>(this->value).empty();
-  case Type::VECTOR:    return !std::get<VectorType>(this->value).empty();
-  case Type::RANGE:     return true;
-  case Type::OBJECT:    return !std::get<ObjectType>(this->value).empty();
-  case Type::FUNCTION:  return true;
-  default: assert(false && "unknown Value variant type"); return false;
+  switch (this->type ()) {
+  case Type::UNDEFINED:
+    return false;
+  case Type::BOOL:
+    return std::get<bool> (this->value);
+  case Type::NUMBER:
+    return std::get<double> (this->value) != 0;
+  case Type::STRING:
+    return !std::get<str_utf8_wrapper> (this->value).empty ();
+  case Type::VECTOR:
+    return !std::get<VectorType> (this->value).empty ();
+  case Type::RANGE:
+    return true;
+  case Type::OBJECT:
+    return !std::get<ObjectType> (this->value).empty ();
+  case Type::FUNCTION:
+    return true;
+  default:
+    assert (false && "unknown Value variant type");
+    return false;
   }
   // NOLINTEND(bugprone-branch-clone)
 }
@@ -273,25 +324,21 @@ bool Value::toBool() const
 // Convert the value to a double with an integer value, for use in bitwise operations.
 // Since there are several possible ways to do this (floor, ceil, round, trunc) this function
 // centralizes the choice for consistency.
-double Value::toInteger() const
-{
-  return trunc(this->toDouble());
+double Value::toInteger () const {
+  return trunc (this->toDouble ());
 }
 
-int64_t Value::toInt64() const
-{
-  return this->toInteger();
+int64_t Value::toInt64 () const {
+  return this->toInteger ();
 }
 
-double Value::toDouble() const
-{
-  const double *d = std::get_if<double>(&this->value);
+double Value::toDouble () const {
+  const double *d = std::get_if<double> (&this->value);
   return d ? *d : 0.0;
 }
 
-bool Value::getDouble(double& v) const
-{
-  const double *d = std::get_if<double>(&this->value);
+bool Value::getDouble (double &v) const {
+  const double *d = std::get_if<double> (&this->value);
   if (d) {
     v = *d;
     return true;
@@ -299,40 +346,37 @@ bool Value::getDouble(double& v) const
   return false;
 }
 
-bool Value::getFiniteDouble(double& v) const
-{
+bool Value::getFiniteDouble (double &v) const {
   double result;
-  if (getDouble(result) && std::isfinite(result)) {
+  if (getDouble (result) && std::isfinite (result)) {
     v = result;
     return true;
   }
   return false;
 }
 
-bool Value::getUnsignedInt(unsigned int& v) const
-{
+bool Value::getUnsignedInt (unsigned int &v) const {
   double result;
-  if (getFiniteDouble(result) &&
-      result >= 0.0 && result <= std::numeric_limits<unsigned int>::max()) {
+  if (getFiniteDouble (result) &&
+      result >= 0.0 && result <= std::numeric_limits<unsigned int>::max ()) {
     v = result;
     return true;
   }
   return false;
 }
 
-bool Value::getPositiveInt(unsigned int& v) const
-{
+bool Value::getPositiveInt (unsigned int &v) const {
   double result;
-  if (getFiniteDouble(result) &&
-      result >= 1 && result <= std::numeric_limits<unsigned int>::max()) {
+  if (getFiniteDouble (result) &&
+      result >= 1 && result <= std::numeric_limits<unsigned int>::max ()) {
     v = result;
     return true;
   }
   return false;
 }
 
-const str_utf8_wrapper& Value::toStrUtf8Wrapper() const {
-  return std::get<str_utf8_wrapper>(this->value);
+const str_utf8_wrapper &Value::toStrUtf8Wrapper () const {
+  return std::get<str_utf8_wrapper> (this->value);
 }
 
 // Optimization to avoid multiple stream instantiations and copies to str for long vectors.
@@ -340,62 +384,63 @@ const str_utf8_wrapper& Value::toStrUtf8Wrapper() const {
 class tostream_visitor
 {
 public:
-  std::ostringstream& stream;
+  std::ostringstream &stream;
   mutable char buffer[DC_BUFFER_SIZE];
   mutable double_conversion::StringBuilder builder;
   double_conversion::DoubleToStringConverter dc;
 
-  tostream_visitor(std::ostringstream& stream)
-    : stream(stream), builder(buffer, DC_BUFFER_SIZE),
-    dc(DC_FLAGS, DC_INF, DC_NAN, DC_EXP, DC_DECIMAL_LOW_EXP, DC_DECIMAL_HIGH_EXP, DC_MAX_LEADING_ZEROES, DC_MAX_TRAILING_ZEROES)
-  {}
+  tostream_visitor (std::ostringstream &stream)
+    : stream (stream)
+    , builder (buffer, DC_BUFFER_SIZE)
+    , dc (DC_FLAGS, DC_INF, DC_NAN, DC_EXP, DC_DECIMAL_LOW_EXP, DC_DECIMAL_HIGH_EXP, DC_MAX_LEADING_ZEROES, DC_MAX_TRAILING_ZEROES) {}
 
-  template <typename T> void operator()(const T& op1) const {
+  template <typename T>
+  void operator() (const T &op1) const {
     //std::cout << "[generic tostream_visitor]\n";
-    stream << boost::lexical_cast<std::string>(op1);
+    stream << boost::lexical_cast<std::string> (op1);
   }
 
-  void operator()(const double& op1) const {
-    stream << DoubleConvert(op1, buffer, builder, dc);
+  void operator() (const double &op1) const {
+    stream << DoubleConvert (op1, buffer, builder, dc);
   }
 
-  void operator()(const UndefType&) const {
+  void operator() (const UndefType &) const {
     stream << "undef";
   }
 
-  void operator()(const bool& v) const {
+  void operator() (const bool &v) const {
     stream << (v ? "true" : "false");
   }
 
-  void operator()(const EmbeddedVectorType&) const {
-    assert(false && "Error: unexpected visit to EmbeddedVectorType!");
+  void operator() (const EmbeddedVectorType &) const {
+    assert (false && "Error: unexpected visit to EmbeddedVectorType!");
   }
 
-  void operator()(const VectorType& v) const {
-    if (StackCheck::inst().check()) {
-      throw VectorEchoStringException::create();
+  void operator() (const VectorType &v) const {
+    if (StackCheck::inst ().check ()) {
+      throw VectorEchoStringException::create ();
     }
     stream << '[';
-    if (!v.empty()) {
-      auto it = v.begin();
-      std::visit(*this, it->getVariant());
-      for (++it; it != v.end(); ++it) {
+    if (!v.empty ()) {
+      auto it = v.begin ();
+      std::visit (*this, it->getVariant ());
+      for (++it; it != v.end (); ++it) {
         stream << ", ";
-        std::visit(*this, it->getVariant());
+        std::visit (*this, it->getVariant ());
       }
     }
     stream << ']';
   }
 
-  void operator()(const str_utf8_wrapper& v) const {
-    stream << '"' << v.toString() << '"';
+  void operator() (const str_utf8_wrapper &v) const {
+    stream << '"' << v.toString () << '"';
   }
 
-  void operator()(const RangePtr& v) const {
+  void operator() (const RangePtr &v) const {
     stream << *v;
   }
 
-  void operator()(const FunctionPtr& v) const {
+  void operator() (const FunctionPtr &v) const {
     stream << *v;
   }
 };
@@ -403,212 +448,200 @@ public:
 class tostring_visitor
 {
 public:
-  template <typename T> std::string operator()(const T& op1) const {
-    assert(false && "unhandled tostring_visitor type");
-    return STR(op1);
+  template <typename T>
+  std::string operator() (const T &op1) const {
+    assert (false && "unhandled tostring_visitor type");
+    return STR (op1);
   }
 
-  std::string operator()(const str_utf8_wrapper& op1) const {
-    return op1.toString();
+  std::string operator() (const str_utf8_wrapper &op1) const {
+    return op1.toString ();
   }
 
-  std::string operator()(const double& op1) const {
+  std::string operator() (const double &op1) const {
     char buffer[DC_BUFFER_SIZE];
-    double_conversion::StringBuilder builder(buffer, DC_BUFFER_SIZE);
-    double_conversion::DoubleToStringConverter dc(DC_FLAGS, DC_INF, DC_NAN, DC_EXP,
-                                                  DC_DECIMAL_LOW_EXP, DC_DECIMAL_HIGH_EXP, DC_MAX_LEADING_ZEROES, DC_MAX_TRAILING_ZEROES);
-    return DoubleConvert(op1, buffer, builder, dc);
+    double_conversion::StringBuilder builder (buffer, DC_BUFFER_SIZE);
+    double_conversion::DoubleToStringConverter dc (DC_FLAGS, DC_INF, DC_NAN, DC_EXP,
+                                                   DC_DECIMAL_LOW_EXP, DC_DECIMAL_HIGH_EXP, DC_MAX_LEADING_ZEROES, DC_MAX_TRAILING_ZEROES);
+    return DoubleConvert (op1, buffer, builder, dc);
   }
 
-  std::string operator()(const UndefType&) const {
+  std::string operator() (const UndefType &) const {
     return "undef";
   }
 
-  std::string operator()(const bool& v) const {
+  std::string operator() (const bool &v) const {
     return v ? "true" : "false";
   }
 
-  std::string operator()(const EmbeddedVectorType&) const {
-    assert(false && "Error: unexpected visit to EmbeddedVectorType!");
+  std::string operator() (const EmbeddedVectorType &) const {
+    assert (false && "Error: unexpected visit to EmbeddedVectorType!");
     return "";
   }
 
-  std::string operator()(const VectorType& v) const {
+  std::string operator() (const VectorType &v) const {
     // Create a single stream and pass reference to it for list elements for optimization.
     std::ostringstream stream;
     try {
-      (tostream_visitor(stream))(v);
-    } catch (EvaluationException& e) {
-      LOG(message_group::Error, e.what());
+      (tostream_visitor (stream)) (v);
+    } catch (EvaluationException &e) {
+      LOG (message_group::Error, e.what ());
       throw;
     }
-    return stream.str();
+    return stream.str ();
   }
 
-  std::string operator()(const ObjectType& v) const {
-    return STR(v);
+  std::string operator() (const ObjectType &v) const {
+    return STR (v);
   }
 
-  std::string operator()(const RangePtr& v) const {
-    return STR(*v);
+  std::string operator() (const RangePtr &v) const {
+    return STR (*v);
   }
 
-  std::string operator()(const FunctionPtr& v) const {
-    return STR(*v);
+  std::string operator() (const FunctionPtr &v) const {
+    return STR (*v);
   }
 };
 
-std::string Value::toString() const
-{
-  return std::visit(tostring_visitor(), this->value);
+std::string Value::toString () const {
+  return std::visit (tostring_visitor (), this->value);
 }
 
-std::string Value::toEchoString() const
-{
-  if (type() == Value::Type::STRING) {
-    return std::string("\"") + toString() + '"';
+std::string Value::toEchoString () const {
+  if (type () == Value::Type::STRING) {
+    return std::string ("\"") + toString () + '"';
   } else {
-    return toString();
+    return toString ();
   }
 }
 
-std::string Value::toEchoStringNoThrow() const
-{
+std::string Value::toEchoStringNoThrow () const {
   std::string ret;
-  try{
-    ret = toEchoString();
-  } catch (EvaluationException& e) {
+  try {
+    ret = toEchoString ();
+  } catch (EvaluationException &e) {
     ret = "...";
   }
   return ret;
 }
 
-const UndefType& Value::toUndef() const
-{
-  return std::get<UndefType>(this->value);
+const UndefType &Value::toUndef () const {
+  return std::get<UndefType> (this->value);
 }
 
-std::string Value::toUndefString() const
-{
-  return std::get<UndefType>(this->value).toString();
+std::string Value::toUndefString () const {
+  return std::get<UndefType> (this->value).toString ();
 }
 
 class chr_visitor
 {
 public:
-  template <typename S> std::string operator()(const S&) const
-  {
+  template <typename S>
+  std::string operator() (const S &) const {
     return "";
   }
 
-  std::string operator()(const double& v) const
-  {
+  std::string operator() (const double &v) const {
     char buf[8];
-    memset(buf, 0, 8);
+    memset (buf, 0, 8);
     if (v > 0) {
       const gunichar c = v;
-      if (g_unichar_validate(c) && (c != 0)) {
-        g_unichar_to_utf8(c, buf);
+      if (g_unichar_validate (c) && (c != 0)) {
+        g_unichar_to_utf8 (c, buf);
       }
     }
     return {buf};
   }
 
-  std::string operator()(const VectorType& v) const
-  {
+  std::string operator() (const VectorType &v) const {
     std::ostringstream stream;
-    for (auto& val : v) {
-      stream << val.chrString();
+    for (auto &val : v) {
+      stream << val.chrString ();
     }
-    return stream.str();
+    return stream.str ();
   }
 
-  std::string operator()(const RangePtr& v) const
-  {
-    const uint32_t steps = v->numValues();
+  std::string operator() (const RangePtr &v) const {
+    const uint32_t steps = v->numValues ();
     if (steps >= RangeType::MAX_RANGE_STEPS) {
-      LOG(message_group::Warning, "Bad range parameter in for statement: too many elements (%1$lu).", steps);
+      LOG (message_group::Warning, "Bad range parameter in for statement: too many elements (%1$lu).", steps);
       return "";
     }
 
     std::ostringstream stream;
-    for (double d : *v) stream << Value(d).chrString();
-    return stream.str();
+    for (double d : *v)
+      stream << Value (d).chrString ();
+    return stream.str ();
   }
 };
 
-std::string Value::chrString() const
-{
-  return std::visit(chr_visitor(), this->value);
+std::string Value::chrString () const {
+  return std::visit (chr_visitor (), this->value);
 }
 
-VectorType::VectorType(EvaluationSession *session) :
-  ptr(std::shared_ptr<VectorObject>(new VectorObject(), VectorObjectDeleter() ))
-{
+VectorType::VectorType (EvaluationSession *session)
+  : ptr (std::shared_ptr<VectorObject> (new VectorObject (), VectorObjectDeleter ())) {
   ptr->evaluation_session = session;
 }
 
-VectorType::VectorType(class EvaluationSession *session, double x, double y, double z) :
-  ptr(std::shared_ptr<VectorObject>(new VectorObject(), VectorObjectDeleter() ))
-{
+VectorType::VectorType (class EvaluationSession *session, double x, double y, double z)
+  : ptr (std::shared_ptr<VectorObject> (new VectorObject (), VectorObjectDeleter ())) {
   ptr->evaluation_session = session;
-  emplace_back(x);
-  emplace_back(y);
-  emplace_back(z);
+  emplace_back (x);
+  emplace_back (y);
+  emplace_back (z);
 }
 
-void VectorType::emplace_back(Value&& val)
-{
-  if (val.type() == Value::Type::EMBEDDED_VECTOR) {
-    emplace_back(std::move(val.toEmbeddedVectorNonConst()));
+void VectorType::emplace_back (Value &&val) {
+  if (val.type () == Value::Type::EMBEDDED_VECTOR) {
+    emplace_back (std::move (val.toEmbeddedVectorNonConst ()));
   } else {
-    ptr->vec.push_back(std::move(val));
+    ptr->vec.push_back (std::move (val));
     if (ptr->evaluation_session) {
-      ptr->evaluation_session->accounting().addVectorElement(1);
+      ptr->evaluation_session->accounting ().addVectorElement (1);
     }
   }
 }
 
 // Specialized handler for EmbeddedVectorTypes
-void VectorType::emplace_back(EmbeddedVectorType&& mbed)
-{
-  if (mbed.size() > 1) {
+void VectorType::emplace_back (EmbeddedVectorType &&mbed) {
+  if (mbed.size () > 1) {
     // embed_excess represents how many to add to vec.size() to get the total elements after flattening,
     // the embedded vector itself already counts towards an element in the parent's size, so subtract 1 from its size.
-    ptr->embed_excess += mbed.size() - 1;
-    ptr->vec.emplace_back(std::move(mbed));
+    ptr->embed_excess += mbed.size () - 1;
+    ptr->vec.emplace_back (std::move (mbed));
     if (ptr->evaluation_session) {
-      ptr->evaluation_session->accounting().addVectorElement(1);
+      ptr->evaluation_session->accounting ().addVectorElement (1);
     }
-  } else if (mbed.size() == 1) {
+  } else if (mbed.size () == 1) {
     // If embedded vector contains only one value, then insert a copy of that element
     // Due to the above mentioned "-1" count, putting it in directaly as an EmbeddedVector
     // would not change embed_excess, which is needed to check if flatten is required.
-    emplace_back(mbed.ptr->vec[0].clone());
+    emplace_back (mbed.ptr->vec[0].clone ());
   }
   // else mbed.size() == 0, do nothing
 }
 
-void VectorType::flatten() const
-{
+void VectorType::flatten () const {
   vec_t ret;
-  ret.reserve(this->size());
+  ret.reserve (this->size ());
   // VectorType::iterator already handles the tricky recursive navigation of embedded vectors,
   // so just build up our new vector from that.
-  for (const auto& el : *this) ret.emplace_back(el.clone());
-  assert(ret.size() == this->size());
+  for (const auto &el : *this)
+    ret.emplace_back (el.clone ());
+  assert (ret.size () == this->size ());
   ptr->embed_excess = 0;
   if (ptr->evaluation_session) {
-    ptr->evaluation_session->accounting().addVectorElement(ret.size());
-    ptr->evaluation_session->accounting().removeVectorElement(ptr->vec.size());
+    ptr->evaluation_session->accounting ().addVectorElement (ret.size ());
+    ptr->evaluation_session->accounting ().removeVectorElement (ptr->vec.size ());
   }
-  ptr->vec = std::move(ret);
+  ptr->vec = std::move (ret);
 }
 
-void VectorType::VectorObjectDeleter::operator()(VectorObject *v)
-{
+void VectorType::VectorObjectDeleter::operator() (VectorObject *v) {
   if (v->evaluation_session) {
-    v->evaluation_session->accounting().removeVectorElement(v->vec.size());
+    v->evaluation_session->accounting ().removeVectorElement (v->vec.size ());
   }
 
   VectorObject *orig = v;
@@ -616,63 +649,62 @@ void VectorType::VectorObjectDeleter::operator()(VectorObject *v)
   std::vector<std::shared_ptr<VectorObject>> purge;
   while (true) {
     if (v && v->embed_excess) {
-      for (Value& val : v->vec) {
-        auto type = val.type();
+      for (Value &val : v->vec) {
+        auto type = val.type ();
         if (type == Value::Type::EMBEDDED_VECTOR) {
-          std::shared_ptr<VectorObject>& temp = std::get<EmbeddedVectorType>(val.value).ptr;
-          if (temp.use_count() <= 1) purge.emplace_back(std::move(temp));
+          std::shared_ptr<VectorObject> &temp = std::get<EmbeddedVectorType> (val.value).ptr;
+          if (temp.use_count () <= 1)
+            purge.emplace_back (std::move (temp));
         } else if (type == Value::Type::VECTOR) {
-          std::shared_ptr<VectorObject>& temp = std::get<VectorType>(val.value).ptr;
-          if (temp.use_count() <= 1) purge.emplace_back(std::move(temp));
+          std::shared_ptr<VectorObject> &temp = std::get<VectorType> (val.value).ptr;
+          if (temp.use_count () <= 1)
+            purge.emplace_back (std::move (temp));
         }
       }
     }
-    if (purge.empty()) break;
-    curr = std::move(purge.back()); // this should cause destruction of the *previous value* for curr
-    v = curr.get();
-    purge.pop_back();
+    if (purge.empty ())
+      break;
+    curr = std::move (purge.back ()); // this should cause destruction of the *previous value* for curr
+    v = curr.get ();
+    purge.pop_back ();
   }
   delete orig;
 }
 
-const VectorType& Value::toVector() const
-{
-  static const VectorType empty(nullptr);
-  const VectorType *v = std::get_if<VectorType>(&this->value);
+const VectorType &Value::toVector () const {
+  static const VectorType empty (nullptr);
+  const VectorType *v = std::get_if<VectorType> (&this->value);
   return v ? *v : empty;
 }
 
-VectorType& Value::toVectorNonConst()
-{
-  return std::get<VectorType>(this->value);
+VectorType &Value::toVectorNonConst () {
+  return std::get<VectorType> (this->value);
 }
 
-const ObjectType& Value::toObject() const
-{
-  static const ObjectType empty(nullptr);
-  const ObjectType *v = std::get_if<ObjectType>(&this->value);
+const ObjectType &Value::toObject () const {
+  static const ObjectType empty (nullptr);
+  const ObjectType *v = std::get_if<ObjectType> (&this->value);
   return v ? *v : empty;
 }
 
-EmbeddedVectorType& Value::toEmbeddedVectorNonConst()
-{
-  return std::get<EmbeddedVectorType>(this->value);
+EmbeddedVectorType &Value::toEmbeddedVectorNonConst () {
+  return std::get<EmbeddedVectorType> (this->value);
 }
 
-const EmbeddedVectorType& Value::toEmbeddedVector() const
-{
-  return std::get<EmbeddedVectorType>(this->value);
+const EmbeddedVectorType &Value::toEmbeddedVector () const {
+  return std::get<EmbeddedVectorType> (this->value);
 }
 
-bool Value::getVec2(double& x, double& y, bool ignoreInfinite) const
-{
-  if (this->type() != Type::VECTOR) return false;
-  const auto& v = this->toVector();
-  if (v.size() != 2) return false;
+bool Value::getVec2 (double &x, double &y, bool ignoreInfinite) const {
+  if (this->type () != Type::VECTOR)
+    return false;
+  const auto &v = this->toVector ();
+  if (v.size () != 2)
+    return false;
   double rx, ry;
   bool valid = ignoreInfinite
-    ? v[0].getFiniteDouble(rx) && v[1].getFiniteDouble(ry)
-    : v[0].getDouble(rx) && v[1].getDouble(ry);
+                 ? v[0].getFiniteDouble (rx) && v[1].getFiniteDouble (ry)
+                 : v[0].getDouble (rx) && v[1].getDouble (ry);
   if (valid) {
     x = rx;
     y = ry;
@@ -680,360 +712,407 @@ bool Value::getVec2(double& x, double& y, bool ignoreInfinite) const
   return valid;
 }
 
-bool Value::getVec3(double& x, double& y, double& z) const
-{
-  if (this->type() != Type::VECTOR) return false;
-  const VectorType& v = this->toVector();
-  if (v.size() != 3) return false;
-  return (v[0].getDouble(x) && v[1].getDouble(y) && v[2].getDouble(z));
+bool Value::getVec3 (double &x, double &y, double &z) const {
+  if (this->type () != Type::VECTOR)
+    return false;
+  const VectorType &v = this->toVector ();
+  if (v.size () != 3)
+    return false;
+  return (v[0].getDouble (x) && v[1].getDouble (y) && v[2].getDouble (z));
 }
 
-bool Value::getVec3(double& x, double& y, double& z, double defaultval) const
-{
-  if (this->type() != Type::VECTOR) return false;
-  const VectorType& v = toVector();
-  if (v.size() == 2) {
-    getVec2(x, y);
+bool Value::getVec3 (double &x, double &y, double &z, double defaultval) const {
+  if (this->type () != Type::VECTOR)
+    return false;
+  const VectorType &v = toVector ();
+  if (v.size () == 2) {
+    getVec2 (x, y);
     z = defaultval;
     return true;
   } else {
-    if (v.size() != 3) return false;
+    if (v.size () != 3)
+      return false;
   }
-  return (v[0].getDouble(x) && v[1].getDouble(y) && v[2].getDouble(z));
+  return (v[0].getDouble (x) && v[1].getDouble (y) && v[2].getDouble (z));
 }
 
-const RangeType& Value::toRange() const
-{
-  const RangePtr *val = std::get_if<RangePtr>(&this->value);
+const RangeType &Value::toRange () const {
+  const RangePtr *val = std::get_if<RangePtr> (&this->value);
   if (val) {
     return **val;
-  } else return RangeType::EMPTY;
+  } else
+    return RangeType::EMPTY;
 }
 
-const FunctionType& Value::toFunction() const
-{
-  return *std::get<FunctionPtr>(this->value);
+const FunctionType &Value::toFunction () const {
+  return *std::get<FunctionPtr> (this->value);
 }
 
-bool Value::isUncheckedUndef() const
-{
-  return this->type() == Type::UNDEFINED && !std::get<UndefType>(this->value).empty();
+bool Value::isUncheckedUndef () const {
+  return this->type () == Type::UNDEFINED && !std::get<UndefType> (this->value).empty ();
 }
 
-Value ObjectType::operator==(const ObjectType& other) const {
+Value ObjectType::operator== (const ObjectType &other) const {
   if (other.ptr == this->ptr) {
     return true;
   }
-  if (other.ptr->values.size() != this->ptr->values.size()) {
+  if (other.ptr->values.size () != this->ptr->values.size ()) {
     return false;
   }
 
-  for ( size_t i = 0; i < this->ptr->values.size(); i++){
+  for (size_t i = 0; i < this->ptr->values.size (); i++) {
     auto key_the_same = this->ptr->keys[i] != other.ptr->keys[i];
     if (key_the_same) {
       return false;
     }
 
     auto value_the_same = this->ptr->values[i] != other.ptr->values[i];
-    if (value_the_same.toBool() ) {
+    if (value_the_same.toBool ()) {
       return false;
     }
   }
   return true;
 }
-Value ObjectType::operator!=(const ObjectType& other) const {
+Value ObjectType::operator!= (const ObjectType &other) const {
   Value a = *this == other;
-  return !a.toBool();
+  return !a.toBool ();
 }
 
-Value ObjectType::operator<(const ObjectType& /*other*/) const {
-  return Value::undef("operation undefined (object < object)");
+Value ObjectType::operator< (const ObjectType & /*other*/) const {
+  return Value::undef ("operation undefined (object < object)");
 }
-Value ObjectType::operator>(const ObjectType& /*other*/) const {
-  return Value::undef("operation undefined (object > object)");
+Value ObjectType::operator> (const ObjectType & /*other*/) const {
+  return Value::undef ("operation undefined (object > object)");
 }
-Value ObjectType::operator<=(const ObjectType& /*other*/) const {
-  return Value::undef("operation undefined (object <= object)");
+Value ObjectType::operator<= (const ObjectType & /*other*/) const {
+  return Value::undef ("operation undefined (object <= object)");
 }
-Value ObjectType::operator>=(const ObjectType& /*other*/) const {
-  return Value::undef("operation undefined (object >= object)");
+Value ObjectType::operator>= (const ObjectType & /*other*/) const {
+  return Value::undef ("operation undefined (object >= object)");
 }
 
-Value VectorType::operator==(const VectorType& v) const {
+Value VectorType::operator== (const VectorType &v) const {
   size_t i = 0;
-  auto first1 = this->begin(), last1 = this->end(), first2 = v.begin(), last2 = v.end();
-  for ( ; (first1 != last1) && (first2 != last2); ++first1, ++first2, ++i) {
+  auto first1 = this->begin (), last1 = this->end (), first2 = v.begin (), last2 = v.end ();
+  for (; (first1 != last1) && (first2 != last2); ++first1, ++first2, ++i) {
     Value temp = *first1 == *first2;
-    if (temp.isUndefined()) {
-      temp.toUndef().append(STR("in vector comparison at index ", i));
+    if (temp.isUndefined ()) {
+      temp.toUndef ().append (STR ("in vector comparison at index ", i));
       return temp;
     }
-    if (!temp.toBool()) return false;
+    if (!temp.toBool ())
+      return false;
   }
   return (first1 == last1) && (first2 == last2);
 }
 
-Value VectorType::operator!=(const VectorType& v) const {
-  Value temp = this->VectorType::operator==(v);
-  if (temp.isUndefined()) return temp;
-  return !temp.toBool();
+Value VectorType::operator!= (const VectorType &v) const {
+  Value temp = this->VectorType::operator== (v);
+  if (temp.isUndefined ())
+    return temp;
+  return !temp.toBool ();
 }
 
 // lexicographical compare with possible undef result
-Value VectorType::operator<(const VectorType& v) const {
-  auto first1 = this->begin(), last1 = this->end(), first2 = v.begin(), last2 = v.end();
+Value VectorType::operator< (const VectorType &v) const {
+  auto first1 = this->begin (), last1 = this->end (), first2 = v.begin (), last2 = v.end ();
   size_t i = 0;
-  for ( ; (first1 != last1) && (first2 != last2); ++first1, ++first2, ++i) {
+  for (; (first1 != last1) && (first2 != last2); ++first1, ++first2, ++i) {
     Value temp = *first1 < *first2;
-    if (temp.isUndefined()) {
-      temp.toUndef().append(STR("in vector comparison at index ", i));
+    if (temp.isUndefined ()) {
+      temp.toUndef ().append (STR ("in vector comparison at index ", i));
       return temp;
     }
-    if (temp.toBool()) return true;
-    if ((*first2 < *first1).toBool()) return false;
+    if (temp.toBool ())
+      return true;
+    if ((*first2 < *first1).toBool ())
+      return false;
   }
   return (first1 == last1) && (first2 != last2);
 }
 
-Value VectorType::operator>(const VectorType& v) const {
-  return v.VectorType::operator<(*this);
+Value VectorType::operator> (const VectorType &v) const {
+  return v.VectorType::operator< (*this);
 }
 
-Value VectorType::operator<=(const VectorType& v) const {
-  Value temp = this->VectorType::operator>(v);
-  if (temp.isUndefined()) return temp;
-  return !temp.toBool();
+Value VectorType::operator<= (const VectorType &v) const {
+  Value temp = this->VectorType::operator> (v);
+  if (temp.isUndefined ())
+    return temp;
+  return !temp.toBool ();
 }
 
-Value VectorType::operator>=(const VectorType& v) const {
-  Value temp = this->VectorType::operator<(v);
-  if (temp.isUndefined()) return temp;
-  return !temp.toBool();
+Value VectorType::operator>= (const VectorType &v) const {
+  Value temp = this->VectorType::operator< (v);
+  if (temp.isUndefined ())
+    return temp;
+  return !temp.toBool ();
 }
 
 class notequal_visitor
 {
 public:
-  template <typename T, typename U> Value operator()(const T& /*op1*/, const U& /*op2*/) const { return true; }
-  template <typename T> Value operator()(const T& op1, const T& op2) const { return op1 != op2; }
-  Value operator()(const UndefType&, const UndefType&) const { return false; }
-  template <typename T> Value operator()(const ValuePtr<T>& op1, const ValuePtr<T>& op2) const { return *op1 != *op2; }
+  template <typename T, typename U>
+  Value operator() (const T & /*op1*/, const U & /*op2*/) const {
+    return true;
+  }
+  template <typename T>
+  Value operator() (const T &op1, const T &op2) const {
+    return op1 != op2;
+  }
+  Value operator() (const UndefType &, const UndefType &) const {
+    return false;
+  }
+  template <typename T>
+  Value operator() (const ValuePtr<T> &op1, const ValuePtr<T> &op2) const {
+    return *op1 != *op2;
+  }
 };
 
 class equals_visitor
 {
 public:
-  template <typename T, typename U> Value operator()(const T& /*op1*/, const U& /*op2*/) const { return false; }
-  template <typename T> Value operator()(const T& op1, const T& op2) const { return op1 == op2; }
-  Value operator()(const UndefType&, const UndefType&) const { return true; }
-  template <typename T> Value operator()(const ValuePtr<T>& op1, const ValuePtr<T>& op2) const { return *op1 == *op2; }
+  template <typename T, typename U>
+  Value operator() (const T & /*op1*/, const U & /*op2*/) const {
+    return false;
+  }
+  template <typename T>
+  Value operator() (const T &op1, const T &op2) const {
+    return op1 == op2;
+  }
+  Value operator() (const UndefType &, const UndefType &) const {
+    return true;
+  }
+  template <typename T>
+  Value operator() (const ValuePtr<T> &op1, const ValuePtr<T> &op2) const {
+    return *op1 == *op2;
+  }
 };
 
 class less_visitor
 {
 public:
-  template <typename T, typename U> Value operator()(const T& op1, const U& op2) const {
-    return Value::undef(STR("undefined operation (", getTypeName(op1), " < ", getTypeName(op2), ")"));
+  template <typename T, typename U>
+  Value operator() (const T &op1, const U &op2) const {
+    return Value::undef (STR ("undefined operation (", getTypeName (op1), " < ", getTypeName (op2), ")"));
+  }
+  template <typename T>
+  Value operator() (const T &op1, const T &op2) const {
+    return op1 < op2;
+  }
+  template <typename T>
+  Value operator() (const ValuePtr<T> &op1, const ValuePtr<T> &op2) const {
+    return *op1 < *op2;
   }
-  template <typename T> Value operator()(const T& op1, const T& op2) const { return op1 < op2; }
-  template <typename T> Value operator()(const ValuePtr<T>& op1, const ValuePtr<T>& op2) const { return *op1 < *op2; }
 };
 
 class greater_visitor
 {
 public:
-  template <typename T, typename U> Value operator()(const T& op1, const U& op2) const {
-    return Value::undef(STR("undefined operation (", getTypeName(op1), " > ", getTypeName(op2), ")"));
+  template <typename T, typename U>
+  Value operator() (const T &op1, const U &op2) const {
+    return Value::undef (STR ("undefined operation (", getTypeName (op1), " > ", getTypeName (op2), ")"));
+  }
+  template <typename T>
+  Value operator() (const T &op1, const T &op2) const {
+    return op1 > op2;
+  }
+  template <typename T>
+  Value operator() (const ValuePtr<T> &op1, const ValuePtr<T> &op2) const {
+    return *op1 > *op2;
   }
-  template <typename T> Value operator()(const T& op1, const T& op2) const { return op1 > op2; }
-  template <typename T> Value operator()(const ValuePtr<T>& op1, const ValuePtr<T>& op2) const { return *op1 > *op2; }
 };
 
 class lessequal_visitor
 {
 public:
-  template <typename T, typename U> Value operator()(const T& op1, const U& op2) const {
-    return Value::undef(STR("undefined operation (", getTypeName(op1), " <= ", getTypeName(op2), ")"));
+  template <typename T, typename U>
+  Value operator() (const T &op1, const U &op2) const {
+    return Value::undef (STR ("undefined operation (", getTypeName (op1), " <= ", getTypeName (op2), ")"));
+  }
+  template <typename T>
+  Value operator() (const T &op1, const T &op2) const {
+    return op1 <= op2;
+  }
+  template <typename T>
+  Value operator() (const ValuePtr<T> &op1, const ValuePtr<T> &op2) const {
+    return *op1 <= *op2;
   }
-  template <typename T> Value operator()(const T& op1, const T& op2) const { return op1 <= op2; }
-  template <typename T> Value operator()(const ValuePtr<T>& op1, const ValuePtr<T>& op2) const { return *op1 <= *op2; }
 };
 
 class greaterequal_visitor
 {
 public:
-  template <typename T, typename U> Value operator()(const T& op1, const U& op2) const {
-    return Value::undef(STR("undefined operation (", getTypeName(op1), " >= ", getTypeName(op2), ")"));
+  template <typename T, typename U>
+  Value operator() (const T &op1, const U &op2) const {
+    return Value::undef (STR ("undefined operation (", getTypeName (op1), " >= ", getTypeName (op2), ")"));
+  }
+  template <typename T>
+  Value operator() (const T &op1, const T &op2) const {
+    return op1 >= op2;
+  }
+  template <typename T>
+  Value operator() (const ValuePtr<T> &op1, const ValuePtr<T> &op2) const {
+    return *op1 >= *op2;
   }
-  template <typename T> Value operator()(const T& op1, const T& op2) const { return op1 >= op2; }
-  template <typename T> Value operator()(const ValuePtr<T>& op1, const ValuePtr<T>& op2) const { return *op1 >= *op2; }
 };
 
-Value Value::operator==(const Value& v) const
-{
-  return std::visit(equals_visitor(), this->value, v.value);
+Value Value::operator== (const Value &v) const {
+  return std::visit (equals_visitor (), this->value, v.value);
 }
 
-Value Value::operator!=(const Value& v) const
-{
-  return std::visit(notequal_visitor(), this->value, v.value);
+Value Value::operator!= (const Value &v) const {
+  return std::visit (notequal_visitor (), this->value, v.value);
 }
 
-Value Value::operator<(const Value& v) const
-{
-  return std::visit(less_visitor(), this->value, v.value);
+Value Value::operator< (const Value &v) const {
+  return std::visit (less_visitor (), this->value, v.value);
 }
 
-Value Value::operator>=(const Value& v) const
-{
-  return std::visit(greaterequal_visitor(), this->value, v.value);
+Value Value::operator>= (const Value &v) const {
+  return std::visit (greaterequal_visitor (), this->value, v.value);
 }
 
-Value Value::operator>(const Value& v) const
-{
-  return std::visit(greater_visitor(), this->value, v.value);
+Value Value::operator> (const Value &v) const {
+  return std::visit (greater_visitor (), this->value, v.value);
 }
 
-Value Value::operator<=(const Value& v) const
-{
-  return std::visit(lessequal_visitor(), this->value, v.value);
+Value Value::operator<= (const Value &v) const {
+  return std::visit (lessequal_visitor (), this->value, v.value);
 }
 
-bool Value::cmp_less(const Value& v1, const Value& v2) {
-  return v1.operator<(v2).toBool();
+bool Value::cmp_less (const Value &v1, const Value &v2) {
+  return v1.operator< (v2).toBool ();
 }
 
 class plus_visitor
 {
 public:
-  template <typename T, typename U> Value operator()(const T& op1, const U& op2) const {
-    return Value::undef(STR("undefined operation (", getTypeName(op1), " + ", getTypeName(op2), ")"));
+  template <typename T, typename U>
+  Value operator() (const T &op1, const U &op2) const {
+    return Value::undef (STR ("undefined operation (", getTypeName (op1), " + ", getTypeName (op2), ")"));
   }
 
-  Value operator()(const double& op1, const double& op2) const {
+  Value operator() (const double &op1, const double &op2) const {
     return op1 + op2;
   }
 
-  Value operator()(const VectorType& op1, const VectorType& op2) const {
-    VectorType sum(op1.evaluation_session());
-    sum.reserve(op1.size());
+  Value operator() (const VectorType &op1, const VectorType &op2) const {
+    VectorType sum (op1.evaluation_session ());
+    sum.reserve (op1.size ());
     // FIXME: should we really truncate to shortest vector here?
     //   Maybe better to either "add zeroes" and return longest
     //   and/or issue an warning/error about length mismatch.
-    for (auto it1 = op1.begin(), end1 = op1.end(), it2 = op2.begin(), end2 = op2.end();
+    for (auto it1 = op1.begin (), end1 = op1.end (), it2 = op2.begin (), end2 = op2.end ();
          it1 != end1 && it2 != end2;
          ++it1, ++it2) {
-      sum.emplace_back(*it1 + *it2);
+      sum.emplace_back (*it1 + *it2);
     }
-    return std::move(sum);
+    return std::move (sum);
   }
 };
 
-Value Value::operator+(const Value& v) const
-{
-  return std::visit(plus_visitor(), this->value, v.value);
+Value Value::operator+ (const Value &v) const {
+  return std::visit (plus_visitor (), this->value, v.value);
 }
 
 class minus_visitor
 {
 public:
-  template <typename T, typename U> Value operator()(const T& op1, const U& op2) const {
-    return Value::undef(STR("undefined operation (", getTypeName(op1), " - ", getTypeName(op2), ")"));
+  template <typename T, typename U>
+  Value operator() (const T &op1, const U &op2) const {
+    return Value::undef (STR ("undefined operation (", getTypeName (op1), " - ", getTypeName (op2), ")"));
   }
 
-  Value operator()(const double& op1, const double& op2) const {
+  Value operator() (const double &op1, const double &op2) const {
     return op1 - op2;
   }
 
-  Value operator()(const VectorType& op1, const VectorType& op2) const {
-    VectorType sum(op1.evaluation_session());
-    sum.reserve(op1.size());
-    for (size_t i = 0; i < op1.size() && i < op2.size(); ++i) {
-      sum.emplace_back(op1[i] - op2[i]);
+  Value operator() (const VectorType &op1, const VectorType &op2) const {
+    VectorType sum (op1.evaluation_session ());
+    sum.reserve (op1.size ());
+    for (size_t i = 0; i < op1.size () && i < op2.size (); ++i) {
+      sum.emplace_back (op1[i] - op2[i]);
     }
-    return std::move(sum);
+    return std::move (sum);
   }
 };
 
-Value Value::operator-(const Value& v) const
-{
-  return std::visit(minus_visitor(), this->value, v.value);
+Value Value::operator- (const Value &v) const {
+  return std::visit (minus_visitor (), this->value, v.value);
 }
 
-Value multvecnum(const VectorType& vecval, const Value& numval)
-{
+Value multvecnum (const VectorType &vecval, const Value &numval) {
   // Vector * Number
-  VectorType dstv(vecval.evaluation_session());
-  dstv.reserve(vecval.size());
-  for (const auto& val : vecval) {
-    dstv.emplace_back(val * numval);
+  VectorType dstv (vecval.evaluation_session ());
+  dstv.reserve (vecval.size ());
+  for (const auto &val : vecval) {
+    dstv.emplace_back (val * numval);
   }
-  return std::move(dstv);
+  return std::move (dstv);
 }
 
-Value multmatvec(const VectorType& matrixvec, const VectorType& vectorvec)
-{
+Value multmatvec (const VectorType &matrixvec, const VectorType &vectorvec) {
   // Matrix * Vector
-  VectorType dstv(matrixvec.evaluation_session());
-  dstv.reserve(matrixvec.size());
-  for (size_t i = 0; i < matrixvec.size(); ++i) {
-    if (matrixvec[i].type() != Value::Type::VECTOR ||
-        matrixvec[i].toVector().size() != vectorvec.size()) {
-      return Value::undef(STR("Matrix must be rectangular. Problem at row ", i));
+  VectorType dstv (matrixvec.evaluation_session ());
+  dstv.reserve (matrixvec.size ());
+  for (size_t i = 0; i < matrixvec.size (); ++i) {
+    if (matrixvec[i].type () != Value::Type::VECTOR ||
+        matrixvec[i].toVector ().size () != vectorvec.size ()) {
+      return Value::undef (STR ("Matrix must be rectangular. Problem at row ", i));
     }
     double r_e = 0.0;
-    for (size_t j = 0; j < matrixvec[i].toVector().size(); ++j) {
-      if (matrixvec[i].toVector()[j].type() != Value::Type::NUMBER) {
-        return Value::undef(STR("Matrix must contain only numbers. Problem at row ", i, ", col ", j));
+    for (size_t j = 0; j < matrixvec[i].toVector ().size (); ++j) {
+      if (matrixvec[i].toVector ()[j].type () != Value::Type::NUMBER) {
+        return Value::undef (STR ("Matrix must contain only numbers. Problem at row ", i, ", col ", j));
       }
-      if (vectorvec[j].type() != Value::Type::NUMBER) {
-        return Value::undef(STR("Vector must contain only numbers. Problem at index ", j));
+      if (vectorvec[j].type () != Value::Type::NUMBER) {
+        return Value::undef (STR ("Vector must contain only numbers. Problem at index ", j));
       }
-      r_e += matrixvec[i].toVector()[j].toDouble() * vectorvec[j].toDouble();
+      r_e += matrixvec[i].toVector ()[j].toDouble () * vectorvec[j].toDouble ();
     }
-    dstv.emplace_back(Value(r_e));
+    dstv.emplace_back (Value (r_e));
   }
-  return std::move(dstv);
+  return std::move (dstv);
 }
 
-Value multvecmat(const VectorType& vectorvec, const VectorType& matrixvec)
-{
-  assert(vectorvec.size() == matrixvec.size());
+Value multvecmat (const VectorType &vectorvec, const VectorType &matrixvec) {
+  assert (vectorvec.size () == matrixvec.size ());
   // Vector * Matrix
-  VectorType dstv(matrixvec[0].toVector().evaluation_session());
-  size_t firstRowSize = matrixvec[0].toVector().size();
-  dstv.reserve(firstRowSize);
+  VectorType dstv (matrixvec[0].toVector ().evaluation_session ());
+  size_t firstRowSize = matrixvec[0].toVector ().size ();
+  dstv.reserve (firstRowSize);
   for (size_t i = 0; i < firstRowSize; ++i) {
     double r_e = 0.0;
-    for (size_t j = 0; j < vectorvec.size(); ++j) {
-      if (matrixvec[j].type() != Value::Type::VECTOR ||
-          matrixvec[j].toVector().size() != firstRowSize) {
-        LOG(message_group::Warning, "Matrix must be rectangular. Problem at row %1$lu", j);
-        return Value::undef(STR("Matrix must be rectangular. Problem at row ", j));
+    for (size_t j = 0; j < vectorvec.size (); ++j) {
+      if (matrixvec[j].type () != Value::Type::VECTOR ||
+          matrixvec[j].toVector ().size () != firstRowSize) {
+        LOG (message_group::Warning, "Matrix must be rectangular. Problem at row %1$lu", j);
+        return Value::undef (STR ("Matrix must be rectangular. Problem at row ", j));
       }
-      if (vectorvec[j].type() != Value::Type::NUMBER) {
-        LOG(message_group::Warning, "Vector must contain only numbers. Problem at index %1$lu", j);
-        return Value::undef(STR("Vector must contain only numbers. Problem at index ", j));
+      if (vectorvec[j].type () != Value::Type::NUMBER) {
+        LOG (message_group::Warning, "Vector must contain only numbers. Problem at index %1$lu", j);
+        return Value::undef (STR ("Vector must contain only numbers. Problem at index ", j));
       }
-      if (matrixvec[j].toVector()[i].type() != Value::Type::NUMBER) {
-        LOG(message_group::Warning, "Matrix must contain only numbers. Problem at row %1$lu, col %2$lu", j, i);
-        return Value::undef(STR("Matrix must contain only numbers. Problem at row ", j, ", col ", i));
+      if (matrixvec[j].toVector ()[i].type () != Value::Type::NUMBER) {
+        LOG (message_group::Warning, "Matrix must contain only numbers. Problem at row %1$lu, col %2$lu", j, i);
+        return Value::undef (STR ("Matrix must contain only numbers. Problem at row ", j, ", col ", i));
       }
-      r_e += vectorvec[j].toDouble() * matrixvec[j].toVector()[i].toDouble();
+      r_e += vectorvec[j].toDouble () * matrixvec[j].toVector ()[i].toDouble ();
     }
-    dstv.emplace_back(r_e);
+    dstv.emplace_back (r_e);
   }
-  return {std::move(dstv)};
+  return {std::move (dstv)};
 }
 
-Value multvecvec(const VectorType& vec1, const VectorType& vec2) {
+Value multvecvec (const VectorType &vec1, const VectorType &vec2) {
   // Vector dot product.
   auto r = 0.0;
-  for (size_t i = 0; i < vec1.size(); i++) {
-    if (vec1[i].type() != Value::Type::NUMBER || vec2[i].type() != Value::Type::NUMBER) {
-      return Value::undef(STR("undefined operation (", vec1[i].typeName(), " * ", vec2[i].typeName(), ")"));
+  for (size_t i = 0; i < vec1.size (); i++) {
+    if (vec1[i].type () != Value::Type::NUMBER || vec2[i].type () != Value::Type::NUMBER) {
+      return Value::undef (STR ("undefined operation (", vec1[i].typeName (), " * ", vec2[i].typeName (), ")"));
     }
-    r += vec1[i].toDouble() * vec2[i].toDouble();
+    r += vec1[i].toDouble () * vec2[i].toDouble ();
   }
   return {r};
 }
@@ -1041,170 +1120,174 @@ Value multvecvec(const VectorType& vec1, const VectorType& vec2) {
 class multiply_visitor
 {
 public:
-  template <typename T, typename U> Value operator()(const T& op1, const U& op2) const {
-    return Value::undef(STR("undefined operation (", getTypeName(op1), " * ", getTypeName(op2), ")"));
+  template <typename T, typename U>
+  Value operator() (const T &op1, const U &op2) const {
+    return Value::undef (STR ("undefined operation (", getTypeName (op1), " * ", getTypeName (op2), ")"));
+  }
+  Value operator() (const double &op1, const double &op2) const {
+    return op1 * op2;
+  }
+  Value operator() (const double &op1, const VectorType &op2) const {
+    return multvecnum (op2, op1);
+  }
+  Value operator() (const VectorType &op1, const double &op2) const {
+    return multvecnum (op1, op2);
   }
-  Value operator()(const double& op1, const double& op2) const { return op1 * op2; }
-  Value operator()(const double& op1, const VectorType& op2) const { return multvecnum(op2, op1); }
-  Value operator()(const VectorType& op1, const double& op2) const { return multvecnum(op1, op2); }
 
-  Value operator()(const VectorType& op1, const VectorType& op2) const {
-    if (op1.empty() || op2.empty()) return Value::undef("Multiplication is undefined on empty vectors");
-    auto first1 = op1.begin(), first2 = op2.begin();
-    auto eltype1 = (*first1).type(), eltype2 = (*first2).type();
+  Value operator() (const VectorType &op1, const VectorType &op2) const {
+    if (op1.empty () || op2.empty ())
+      return Value::undef ("Multiplication is undefined on empty vectors");
+    auto first1 = op1.begin (), first2 = op2.begin ();
+    auto eltype1 = (*first1).type (), eltype2 = (*first2).type ();
     if (eltype1 == Value::Type::NUMBER) {
       if (eltype2 == Value::Type::NUMBER) {
-        if (op1.size() == op2.size()) return multvecvec(op1, op2);
-        else return Value::undef(STR("vector*vector requires matching lengths (", op1.size(), " != ", op2.size(), ')'));
+        if (op1.size () == op2.size ())
+          return multvecvec (op1, op2);
+        else
+          return Value::undef (STR ("vector*vector requires matching lengths (", op1.size (), " != ", op2.size (), ')'));
       } else if (eltype2 == Value::Type::VECTOR) {
-        if (op1.size() == op2.size()) return multvecmat(op1, op2);
-        else return Value::undef(STR("vector*matrix requires vector length to match matrix row count (", op1.size(), " != ", op2.size(), ')'));
+        if (op1.size () == op2.size ())
+          return multvecmat (op1, op2);
+        else
+          return Value::undef (STR ("vector*matrix requires vector length to match matrix row count (", op1.size (), " != ", op2.size (), ')'));
       }
     } else if (eltype1 == Value::Type::VECTOR) {
       if (eltype2 == Value::Type::NUMBER) {
-        if ((*first1).toVector().size() == op2.size()) return multmatvec(op1, op2);
-        else return Value::undef(STR("matrix*vector requires matrix column count to match vector length (", (*first1).toVector().size(), " != ", op2.size(), ')'));
+        if ((*first1).toVector ().size () == op2.size ())
+          return multmatvec (op1, op2);
+        else
+          return Value::undef (STR ("matrix*vector requires matrix column count to match vector length (", (*first1).toVector ().size (), " != ", op2.size (), ')'));
       } else if (eltype2 == Value::Type::VECTOR) {
-        if ((*first1).toVector().size() == op2.size()) {
+        if ((*first1).toVector ().size () == op2.size ()) {
           // Matrix * Matrix
-          VectorType dstv(op1.evaluation_session());
-          dstv.reserve(op1.size());
+          VectorType dstv (op1.evaluation_session ());
+          dstv.reserve (op1.size ());
           size_t i = 0;
-          for (const auto& srcrow : op1) {
-            const auto& srcrowvec = srcrow.toVector();
-            if (srcrowvec.size() != op2.size()) return Value::undef(STR("matrix*matrix left operand row length does not match right operand row count (", srcrowvec.size(), " != ", op2.size(), ") at row ", i));
-            auto temp = multvecmat(srcrowvec, op2);
-            if (temp.isUndefined()) {
-              temp.toUndef().append(STR("while processing left operand at row ", i));
+          for (const auto &srcrow : op1) {
+            const auto &srcrowvec = srcrow.toVector ();
+            if (srcrowvec.size () != op2.size ())
+              return Value::undef (STR ("matrix*matrix left operand row length does not match right operand row count (", srcrowvec.size (), " != ", op2.size (), ") at row ", i));
+            auto temp = multvecmat (srcrowvec, op2);
+            if (temp.isUndefined ()) {
+              temp.toUndef ().append (STR ("while processing left operand at row ", i));
               return temp;
             } else {
-              dstv.emplace_back(std::move(temp));
+              dstv.emplace_back (std::move (temp));
             }
             ++i;
           }
-          return {std::move(dstv)};
+          return {std::move (dstv)};
         } else {
-          return Value::undef(STR("matrix*matrix requires left operand column count to match right operand row count (", (*first1).toVector().size(), " != ", op2.size(), ')'));
+          return Value::undef (STR ("matrix*matrix requires left operand column count to match right operand row count (", (*first1).toVector ().size (), " != ", op2.size (), ')'));
         }
       }
     }
-    return Value::undef(STR("undefined vector*vector multiplication where first elements are types ", (*first1).typeName(), " and ", (*first2).typeName() ));
+    return Value::undef (STR ("undefined vector*vector multiplication where first elements are types ", (*first1).typeName (), " and ", (*first2).typeName ()));
   }
 };
 
-Value Value::operator*(const Value& v) const
-{
-  return std::visit(multiply_visitor(), this->value, v.value);
+Value Value::operator* (const Value &v) const {
+  return std::visit (multiply_visitor (), this->value, v.value);
 }
 
-Value Value::operator/(const Value& v) const
-{
-  if (this->type() == Type::NUMBER && v.type() == Type::NUMBER) {
-    return this->toDouble() / v.toDouble();
-  } else if (this->type() == Type::VECTOR && v.type() == Type::NUMBER) {
-    VectorType dstv(this->toVector().evaluation_session());
-    dstv.reserve(this->toVector().size());
-    for (const auto& vecval : this->toVector()) {
-      dstv.emplace_back(vecval / v);
+Value Value::operator/ (const Value &v) const {
+  if (this->type () == Type::NUMBER && v.type () == Type::NUMBER) {
+    return this->toDouble () / v.toDouble ();
+  } else if (this->type () == Type::VECTOR && v.type () == Type::NUMBER) {
+    VectorType dstv (this->toVector ().evaluation_session ());
+    dstv.reserve (this->toVector ().size ());
+    for (const auto &vecval : this->toVector ()) {
+      dstv.emplace_back (vecval / v);
     }
-    return std::move(dstv);
-  } else if (this->type() == Type::NUMBER && v.type() == Type::VECTOR) {
-    VectorType dstv(v.toVector().evaluation_session());
-    dstv.reserve(v.toVector().size());
-    for (const auto& vecval : v.toVector()) {
-      dstv.emplace_back(*this / vecval);
+    return std::move (dstv);
+  } else if (this->type () == Type::NUMBER && v.type () == Type::VECTOR) {
+    VectorType dstv (v.toVector ().evaluation_session ());
+    dstv.reserve (v.toVector ().size ());
+    for (const auto &vecval : v.toVector ()) {
+      dstv.emplace_back (*this / vecval);
     }
-    return std::move(dstv);
+    return std::move (dstv);
   }
-  return Value::undef(STR("undefined operation (", this->typeName(), " / ", v.typeName(), ")"));
+  return Value::undef (STR ("undefined operation (", this->typeName (), " / ", v.typeName (), ")"));
 }
 
-Value Value::operator%(const Value& v) const
-{
-  if (this->type() == Type::NUMBER && v.type() == Type::NUMBER) {
-    return fmod(std::get<double>(this->value), std::get<double>(v.value));
+Value Value::operator% (const Value &v) const {
+  if (this->type () == Type::NUMBER && v.type () == Type::NUMBER) {
+    return fmod (std::get<double> (this->value), std::get<double> (v.value));
   }
-  return Value::undef(STR("undefined operation (", this->typeName(), " % ", v.typeName(), ")"));
+  return Value::undef (STR ("undefined operation (", this->typeName (), " % ", v.typeName (), ")"));
 }
 
-Value Value::operator<<(const Value& v) const
-{
-  if (this->type() == Type::NUMBER && v.type() == Type::NUMBER) {
-    int64_t lhs = this->toInt64();
-    int64_t rhs = v.toInt64();
+Value Value::operator<< (const Value &v) const {
+  if (this->type () == Type::NUMBER && v.type () == Type::NUMBER) {
+    int64_t lhs = this->toInt64 ();
+    int64_t rhs = v.toInt64 ();
     if (rhs < 0) {
-      return Value::undef(STR("negative shift"));
+      return Value::undef (STR ("negative shift"));
     }
     if (rhs >= 64) {
-      return Value::undef(STR("shift too large"));
+      return Value::undef (STR ("shift too large"));
     }
     return (double)(lhs << rhs);
   }
-  return Value::undef(STR("undefined operation (", this->typeName(), " << ", v.typeName(), ")"));
+  return Value::undef (STR ("undefined operation (", this->typeName (), " << ", v.typeName (), ")"));
 }
 
-Value Value::operator>>(const Value& v) const
-{
-  if (this->type() == Type::NUMBER && v.type() == Type::NUMBER) {
-    int64_t lhs = this->toInt64();
-    int64_t rhs = v.toInt64();
+Value Value::operator>> (const Value &v) const {
+  if (this->type () == Type::NUMBER && v.type () == Type::NUMBER) {
+    int64_t lhs = this->toInt64 ();
+    int64_t rhs = v.toInt64 ();
     if (rhs < 0) {
-      return Value::undef(STR("negative shift"));
+      return Value::undef (STR ("negative shift"));
     }
     if (rhs >= 64) {
-      return Value::undef(STR("shift too large"));
+      return Value::undef (STR ("shift too large"));
     }
     return (double)(lhs >> rhs);
   }
-  return Value::undef(STR("undefined operation (", this->typeName(), " >> ", v.typeName(), ")"));
+  return Value::undef (STR ("undefined operation (", this->typeName (), " >> ", v.typeName (), ")"));
 }
 
-Value Value::operator&(const Value& v) const
-{
-  if (this->type() == Type::NUMBER && v.type() == Type::NUMBER) {
-    return (double)(this->toInt64() & v.toInt64());
+Value Value::operator& (const Value &v) const {
+  if (this->type () == Type::NUMBER && v.type () == Type::NUMBER) {
+    return (double)(this->toInt64 () & v.toInt64 ());
   }
-  return Value::undef(STR("undefined operation (", this->typeName(), " & ", v.typeName(), ")"));
+  return Value::undef (STR ("undefined operation (", this->typeName (), " & ", v.typeName (), ")"));
 }
 
-Value Value::operator|(const Value& v) const
-{
-  if (this->type() == Type::NUMBER && v.type() == Type::NUMBER) {
-    return (double)(this->toInt64() | v.toInt64());
+Value Value::operator| (const Value &v) const {
+  if (this->type () == Type::NUMBER && v.type () == Type::NUMBER) {
+    return (double)(this->toInt64 () | v.toInt64 ());
   }
-  return Value::undef(STR("undefined operation (", this->typeName(), " | ", v.typeName(), ")"));
+  return Value::undef (STR ("undefined operation (", this->typeName (), " | ", v.typeName (), ")"));
 }
 
-
-Value Value::operator-() const
-{
-  if (this->type() == Type::NUMBER) {
-    return {-this->toDouble()};
-  } else if (this->type() == Type::VECTOR) {
-    VectorType dstv(this->toVector().evaluation_session());
-    dstv.reserve(this->toVector().size());
-    for (const auto& vecval : this->toVector()) {
-      dstv.emplace_back(-vecval);
+Value Value::operator- () const {
+  if (this->type () == Type::NUMBER) {
+    return {-this->toDouble ()};
+  } else if (this->type () == Type::VECTOR) {
+    VectorType dstv (this->toVector ().evaluation_session ());
+    dstv.reserve (this->toVector ().size ());
+    for (const auto &vecval : this->toVector ()) {
+      dstv.emplace_back (-vecval);
     }
-    return std::move(dstv);
+    return std::move (dstv);
   }
-  return Value::undef(STR("undefined operation (-", this->typeName(), ")"));
+  return Value::undef (STR ("undefined operation (-", this->typeName (), ")"));
 }
 
-Value Value::operator~() const
-{
-  if (this->type() == Type::NUMBER) {
-    return (double)~this->toInt64();
+Value Value::operator~() const {
+  if (this->type () == Type::NUMBER) {
+    return (double)~this->toInt64 ();
   }
-  return Value::undef(STR("undefined operation (~", this->typeName(), ")"));
+  return Value::undef (STR ("undefined operation (~", this->typeName (), ")"));
 }
 
-Value Value::operator^(const Value& v) const
-{
-  if (this->type() == Type::NUMBER && v.type() == Type::NUMBER) {
-    return {pow(std::get<double>(this->value), std::get<double>(v.value))};
+Value Value::operator^ (const Value &v) const {
+  if (this->type () == Type::NUMBER && v.type () == Type::NUMBER) {
+    return {pow (std::get<double> (this->value), std::get<double> (v.value))};
   }
-  return Value::undef(STR("undefined operation (", this->typeName(), " ^ ", v.typeName(), ")"));
+  return Value::undef (STR ("undefined operation (", this->typeName (), " ^ ", v.typeName (), ")"));
 }
 
 /*
@@ -1215,106 +1298,116 @@ Value Value::operator^(const Value& v) const
 class bracket_visitor
 {
 public:
-  Value operator()(const str_utf8_wrapper& str, const double& idx) const {
-    const auto i = convert_to_uint32(idx);
+  Value operator() (const str_utf8_wrapper &str, const double &idx) const {
+    const auto i = convert_to_uint32 (idx);
     auto unichar = str[i];
-    if (unichar.empty()) {
-      return Value::undefined.clone();
+    if (unichar.empty ()) {
+      return Value::undefined.clone ();
     }
     return unichar;
   }
 
-  Value operator()(const VectorType& vec, const double& idx) const {
-    const auto i = convert_to_uint32(idx);
-    if (i < vec.size()) return vec[i].clone();
-    return Value::undef(STR("index ", i, " out of bounds for vector of size ", vec.size()));
+  Value operator() (const VectorType &vec, const double &idx) const {
+    const auto i = convert_to_uint32 (idx);
+    if (i < vec.size ())
+      return vec[i].clone ();
+    return Value::undef (STR ("index ", i, " out of bounds for vector of size ", vec.size ()));
   }
 
-  Value operator()(const ObjectType& obj, const str_utf8_wrapper& key) const {
-    return obj[key].clone();
+  Value operator() (const ObjectType &obj, const str_utf8_wrapper &key) const {
+    return obj[key].clone ();
   }
 
-  Value operator()(const RangePtr& range, const double& idx) const {
-    const auto i = convert_to_uint32(idx);
+  Value operator() (const RangePtr &range, const double &idx) const {
+    const auto i = convert_to_uint32 (idx);
     switch (i) {
-    case 0: return range->begin_value();
-    case 1: return range->step_value();
-    case 2: return range->end_value();
+    case 0:
+      return range->begin_value ();
+    case 1:
+      return range->step_value ();
+    case 2:
+      return range->end_value ();
     }
-    return Value::undef("subscript operator only defined for indices 0-2 on range (begin,step,end)");
+    return Value::undef ("subscript operator only defined for indices 0-2 on range (begin,step,end)");
   }
 
-  template <typename T, typename U> Value operator()(const T& op1, const U& op2) const {
+  template <typename T, typename U>
+  Value operator() (const T &op1, const U &op2) const {
     //std::cout << "generic bracket_visitor " << getTypeName(op1) << " " << getTypeName(op2) << "\n";
-    return Value::undef(STR("undefined operation ", getTypeName(op1), "[", getTypeName(op2), "]"));
+    return Value::undef (STR ("undefined operation ", getTypeName (op1), "[", getTypeName (op2), "]"));
   }
 };
 
-Value Value::operator[](const Value& v) const
-{
-  return std::visit(bracket_visitor(), this->value, v.value);
+Value Value::operator[] (const Value &v) const {
+  return std::visit (bracket_visitor (), this->value, v.value);
 }
 
-Value Value::operator[](size_t idx) const
-{
+Value Value::operator[] (size_t idx) const {
   Value v{(double)idx};
-  return std::visit(bracket_visitor(), this->value, v.value);
+  return std::visit (bracket_visitor (), this->value, v.value);
 }
 
-std::ostream& operator<<(std::ostream& stream, const RangeType& r)
-{
+std::ostream &operator<< (std::ostream &stream, const RangeType &r) {
   char buffer[DC_BUFFER_SIZE];
-  double_conversion::StringBuilder builder(buffer, DC_BUFFER_SIZE);
-  double_conversion::DoubleToStringConverter dc(DC_FLAGS, DC_INF,
-                                                DC_NAN, DC_EXP, DC_DECIMAL_LOW_EXP, DC_DECIMAL_HIGH_EXP,
-                                                DC_MAX_LEADING_ZEROES, DC_MAX_TRAILING_ZEROES);
+  double_conversion::StringBuilder builder (buffer, DC_BUFFER_SIZE);
+  double_conversion::DoubleToStringConverter dc (DC_FLAGS, DC_INF,
+                                                 DC_NAN, DC_EXP, DC_DECIMAL_LOW_EXP, DC_DECIMAL_HIGH_EXP,
+                                                 DC_MAX_LEADING_ZEROES, DC_MAX_TRAILING_ZEROES);
   return stream << "["
-                << DoubleConvert(r.begin_value(), buffer, builder, dc) << " : "
-                << DoubleConvert(r.step_value(), buffer, builder, dc) << " : "
-                << DoubleConvert(r.end_value(),   buffer, builder, dc) << "]";
+                << DoubleConvert (r.begin_value (), buffer, builder, dc) << " : "
+                << DoubleConvert (r.step_value (), buffer, builder, dc) << " : "
+                << DoubleConvert (r.end_value (), buffer, builder, dc) << "]";
 }
 
 // called by clone()
-ObjectType::ObjectType(const std::shared_ptr<ObjectObject>& copy)
-  : ptr(copy)
-{
+ObjectType::ObjectType (const std::shared_ptr<ObjectObject> &copy)
+  : ptr (copy) {
 }
 
-ObjectType::ObjectType(EvaluationSession *session) :
-  ptr(std::make_shared<ObjectObject>())
-{
+ObjectType::ObjectType (EvaluationSession *session)
+  : ptr (std::make_shared<ObjectObject> ()) {
   ptr->evaluation_session = session;
 }
 
-const Value& ObjectType::get(const std::string& key) const { return ptr->get(key); }
-bool ObjectType::set(const std::string& key, Value value)               { return ptr->set(key, std::move(value)); }
-bool ObjectType::del(const std::string& key)                            { return ptr->del(key) != NOINDEX; }
-bool ObjectType::contains(const std::string& key) const { return ptr->find(key) != NOINDEX; }
-bool ObjectType::empty() const { return ptr->values.empty(); }
-const std::vector<std::string>& ObjectType::keys() const { return ptr->keys; }
-const std::vector<Value>& ObjectType::values() const { return ptr->values; }
-
-const Value& ObjectType::operator[](const str_utf8_wrapper& v) const
-{
-  return this->get(v.toString());
+const Value &ObjectType::get (const std::string &key) const {
+  return ptr->get (key);
+}
+bool ObjectType::set (const std::string &key, Value value) {
+  return ptr->set (key, std::move (value));
+}
+bool ObjectType::del (const std::string &key) {
+  return ptr->del (key) != NOINDEX;
+}
+bool ObjectType::contains (const std::string &key) const {
+  return ptr->find (key) != NOINDEX;
+}
+bool ObjectType::empty () const {
+  return ptr->values.empty ();
+}
+const std::vector<std::string> &ObjectType::keys () const {
+  return ptr->keys;
+}
+const std::vector<Value> &ObjectType::values () const {
+  return ptr->values;
 }
 
+const Value &ObjectType::operator[] (const str_utf8_wrapper &v) const {
+  return this->get (v.toString ());
+}
 
 // Copy explicitly only when necessary
-ObjectType ObjectType::clone() const
-{
-  return ObjectType(this->ptr);
+ObjectType ObjectType::clone () const {
+  return ObjectType (this->ptr);
 }
 
-std::ostream& operator<<(std::ostream& stream, const ObjectType& v)
-{
+std::ostream &operator<< (std::ostream &stream, const ObjectType &v) {
   stream << "{ ";
-  auto iter = v.ptr->keys.begin();
-  if (iter != v.ptr->keys.end()) {
-    str_utf8_wrapper k(*iter);
-    for (; iter != v.ptr->keys.end(); ++iter) {
-      str_utf8_wrapper k2(*iter);
-      stream << k2.toString() << " = " << v[k2] << "; ";
+  auto iter = v.ptr->keys.begin ();
+  if (iter != v.ptr->keys.end ()) {
+    str_utf8_wrapper k (*iter);
+    for (; iter != v.ptr->keys.end (); ++iter) {
+      str_utf8_wrapper k2 (*iter);
+      stream << k2.toString () << " = " << v[k2] << "; ";
     }
   }
   stream << "}";
diff --git a/src/core/Value.h b/src/core/Value.h
index 8260ac6fb..2e2f6f7dd 100644
--- a/src/core/Value.h
+++ b/src/core/Value.h
@@ -25,31 +25,46 @@ class Value;
 class QuotedString : public std::string
 {
 public:
-  QuotedString() : std::string() {}
-  QuotedString(const std::string& s) : std::string(s) {}
+  QuotedString ()
+    : std::string () {}
+  QuotedString (const std::string &s)
+    : std::string (s) {}
 };
-std::ostream& operator<<(std::ostream& stream, const QuotedString& s);
+std::ostream &operator<< (std::ostream &stream, const QuotedString &s);
 
 class Filename : public QuotedString
 {
 public:
-  Filename() : QuotedString() {}
-  Filename(const std::string& f) : QuotedString(f) {}
+  Filename ()
+    : QuotedString () {}
+  Filename (const std::string &f)
+    : QuotedString (f) {}
 };
-std::ostream& operator<<(std::ostream& stream, const Filename& filename);
+std::ostream &operator<< (std::ostream &stream, const Filename &filename);
 
 template <typename T>
 class ValuePtr
 {
 private:
-  explicit ValuePtr(std::shared_ptr<T> val_in) : value(std::move(val_in)) { }
+  explicit ValuePtr (std::shared_ptr<T> val_in)
+    : value (std::move (val_in)) {}
+
 public:
-  ValuePtr(T&& value) : value(std::make_shared<T>(std::move(value))) { }
-  [[nodiscard]] ValuePtr clone() const { return ValuePtr(value); }
+  ValuePtr (T &&value)
+    : value (std::make_shared<T> (std::move (value))) {}
+  [[nodiscard]] ValuePtr clone () const {
+    return ValuePtr (value);
+  }
 
-  const T& operator*() const { return *value; }
-  const T *operator->() const { return value.get(); }
-  [[nodiscard]] const std::shared_ptr<T>& get() const { return value; }
+  const T &operator* () const {
+    return *value;
+  }
+  const T *operator->() const {
+    return value.get ();
+  }
+  [[nodiscard]] const std::shared_ptr<T> &get () const {
+    return value;
+  }
 
 private:
   std::shared_ptr<T> value;
@@ -116,7 +131,7 @@ public:
   class VectorType
   {
 
-protected:
+  protected:
     // The object type which VectorType's shared_ptr points to.
     struct VectorObject {
       using vec_t = std::vector<Value>;
@@ -124,26 +139,32 @@ protected:
       vec_t vec;
       size_type embed_excess = 0; // Keep count of the number of embedded elements *excess of* vec.size()
       class EvaluationSession *evaluation_session = nullptr; // Used for heap size bookkeeping. May be null for vectors of known small maximum size.
-      [[nodiscard]] size_type size() const { return vec.size() + embed_excess;  }
-      [[nodiscard]] bool empty() const { return vec.empty() && embed_excess == 0;  }
+      [[nodiscard]] size_type size () const {
+        return vec.size () + embed_excess;
+      }
+      [[nodiscard]] bool empty () const {
+        return vec.empty () && embed_excess == 0;
+      }
     };
     using vec_t = VectorObject::vec_t;
-public:
+
+  public:
     std::shared_ptr<VectorObject> ptr;
-protected:
 
+  protected:
     // A Deleter is used on the shared_ptrs to avoid stack overflow in cases
     // of destructing a very large list of nested embedded vectors, such as from a
     // recursive function which concats one element at a time.
     // (A similar solution can also be seen with CSGNode.h:CSGOperationDeleter).
     struct VectorObjectDeleter {
-      void operator()(VectorObject *vec);
+      void operator() (VectorObject *vec);
     };
-    void flatten() const; // flatten replaces VectorObject::vec with a new vector
-                          // where any embedded elements are copied directly into the top level vec,
-                          // leaving only true elements for straightforward indexing by operator[].
-    explicit VectorType(const std::shared_ptr<VectorObject>& copy) : ptr(copy) { } // called by clone()
-public:
+    void flatten () const; // flatten replaces VectorObject::vec with a new vector
+      // where any embedded elements are copied directly into the top level vec,
+      // leaving only true elements for straightforward indexing by operator[].
+    explicit VectorType (const std::shared_ptr<VectorObject> &copy)
+      : ptr (copy) {} // called by clone()
+  public:
     using size_type = VectorObject::size_type;
     static const VectorType EMPTY;
     // EmbeddedVectorType-aware iterator, manages its own stack of begin/end vec_t::const_iterators
@@ -151,7 +172,7 @@ public:
     // Also tracks the overall element index. In case flattening occurs during iteration, it can continue based on that index. (Issue #3541)
     class iterator
     {
-private:
+    private:
       const VectorObject *vo;
       std::vector<std::pair<vec_t::const_iterator, vec_t::const_iterator>> it_stack;
       vec_t::const_iterator it, end;
@@ -161,230 +182,292 @@ private:
       //  - Depends on the fact that VectorType::emplace_back(EmbeddedVectorType&& mbed)
       //    will not embed an empty vector, which ensures iterator will arrive at an actual element,
       //    unless already at end of parent VectorType.
-      void check_and_push()
-      {
+      void check_and_push () {
         if (it != end) {
-          while (it->type() == Type::EMBEDDED_VECTOR) {
-            const vec_t& cur = it->toEmbeddedVector().ptr->vec;
-            it_stack.emplace_back(it, end);
-            it = cur.begin();
-            end = cur.end();
+          while (it->type () == Type::EMBEDDED_VECTOR) {
+            const vec_t &cur = it->toEmbeddedVector ().ptr->vec;
+            it_stack.emplace_back (it, end);
+            it = cur.begin ();
+            end = cur.end ();
           }
         }
       }
-public:
+
+    public:
       using iterator_category = std::forward_iterator_tag;
       using value_type = Value;
       using difference_type = void;
-      using reference = const value_type&;
+      using reference = const value_type &;
       using pointer = const value_type *;
 
-      iterator() : vo(EMPTY.ptr.get()), it_stack(), it(EMPTY.ptr->vec.begin()), end(EMPTY.ptr->vec.end()), index(0) {}
-      iterator(const VectorObject *v) : vo(v), it(v->vec.begin()), end(v->vec.end()), index(0) {
-        if (vo->embed_excess) check_and_push();
+      iterator ()
+        : vo (EMPTY.ptr.get ())
+        , it_stack ()
+        , it (EMPTY.ptr->vec.begin ())
+        , end (EMPTY.ptr->vec.end ())
+        , index (0) {}
+      iterator (const VectorObject *v)
+        : vo (v)
+        , it (v->vec.begin ())
+        , end (v->vec.end ())
+        , index (0) {
+        if (vo->embed_excess)
+          check_and_push ();
       }
-      iterator(const VectorObject *v, bool /*end*/) : vo(v), index(v->size()) { }
-      iterator& operator++() {
+      iterator (const VectorObject *v, bool /*end*/)
+        : vo (v)
+        , index (v->size ()) {}
+      iterator &operator++ () {
         ++index;
         if (vo->embed_excess) {
           // recursively increment and pop stack while at the end of EmbeddedVector(s)
-          while (++it == end && !it_stack.empty()) {
-            const auto& up = it_stack.back();
+          while (++it == end && !it_stack.empty ()) {
+            const auto &up = it_stack.back ();
             it = up.first;
             end = up.second;
-            it_stack.pop_back();
+            it_stack.pop_back ();
           }
-          check_and_push();
+          check_and_push ();
         } else { // vo->vec is flat
-          it = vo->vec.begin() + static_cast<vec_t::iterator::difference_type>(index);
+          it = vo->vec.begin () + static_cast<vec_t::iterator::difference_type> (index);
         }
         return *this;
       }
-      reference operator*() const { return *it; }
-      pointer operator->() const { return &*it; }
-      bool operator==(const iterator& other) const { return this->vo == other.vo && this->index == other.index; }
-      bool operator!=(const iterator& other) const { return this->vo != other.vo || this->index != other.index; }
+      reference operator* () const {
+        return *it;
+      }
+      pointer operator->() const {
+        return &*it;
+      }
+      bool operator== (const iterator &other) const {
+        return this->vo == other.vo && this->index == other.index;
+      }
+      bool operator!= (const iterator &other) const {
+        return this->vo != other.vo || this->index != other.index;
+      }
     };
     using const_iterator = const iterator;
-    VectorType(class EvaluationSession *session);
-    VectorType(class EvaluationSession *session, double x, double y, double z);
-    VectorType(const VectorType&) = delete; // never copy, move instead
-    VectorType& operator=(const VectorType&) = delete; // never copy, move instead
-    VectorType(VectorType&&) = default;
-    VectorType& operator=(VectorType&&) = default;
-    ~VectorType() = default;
-    [[nodiscard]] VectorType clone() const { return VectorType(this->ptr); } // Copy explicitly only when necessary
-    static Value Empty() { return VectorType(nullptr); }
-
-    void reserve(size_t size) {
-      ptr->vec.reserve(size);
+    VectorType (class EvaluationSession *session);
+    VectorType (class EvaluationSession *session, double x, double y, double z);
+    VectorType (const VectorType &) = delete; // never copy, move instead
+    VectorType &operator= (const VectorType &) = delete; // never copy, move instead
+    VectorType (VectorType &&) = default;
+    VectorType &operator= (VectorType &&) = default;
+    ~VectorType () = default;
+    [[nodiscard]] VectorType clone () const {
+      return VectorType (this->ptr);
+    } // Copy explicitly only when necessary
+    static Value Empty () {
+      return VectorType (nullptr);
+    }
+
+    void reserve (size_t size) {
+      ptr->vec.reserve (size);
     }
 
-    [[nodiscard]] const_iterator begin() const { return iterator(ptr.get()); }
-    [[nodiscard]] const_iterator   end() const { return iterator(ptr.get(), true); }
-    [[nodiscard]] size_type size() const { return ptr->size(); }
-    [[nodiscard]] bool empty() const { return ptr->empty(); }
+    [[nodiscard]] const_iterator begin () const {
+      return iterator (ptr.get ());
+    }
+    [[nodiscard]] const_iterator end () const {
+      return iterator (ptr.get (), true);
+    }
+    [[nodiscard]] size_type size () const {
+      return ptr->size ();
+    }
+    [[nodiscard]] bool empty () const {
+      return ptr->empty ();
+    }
     // const accesses to VectorObject require .clone to be move-able
-    const Value& operator[](size_t idx) const {
-      if (idx < this->size()) {
-        if (ptr->embed_excess) flatten();
+    const Value &operator[] (size_t idx) const {
+      if (idx < this->size ()) {
+        if (ptr->embed_excess)
+          flatten ();
         return ptr->vec[idx];
       } else {
         return Value::undefined;
       }
     }
-    Value operator==(const VectorType& v) const;
-    Value operator<(const VectorType& v) const;
-    Value operator>(const VectorType& v) const;
-    Value operator!=(const VectorType& v) const;
-    Value operator<=(const VectorType& v) const;
-    Value operator>=(const VectorType& v) const;
-    [[nodiscard]] class EvaluationSession *evaluation_session() const { return ptr->evaluation_session; }
-
-    void emplace_back(Value&& val);
-    void emplace_back(EmbeddedVectorType&& mbed);
-    template <typename ... Args> void emplace_back(Args&&... args) { emplace_back(Value(std::forward<Args>(args)...)); }
+    Value operator== (const VectorType &v) const;
+    Value operator< (const VectorType &v) const;
+    Value operator> (const VectorType &v) const;
+    Value operator!= (const VectorType &v) const;
+    Value operator<= (const VectorType &v) const;
+    Value operator>= (const VectorType &v) const;
+    [[nodiscard]] class EvaluationSession *evaluation_session () const {
+      return ptr->evaluation_session;
+    }
+
+    void emplace_back (Value &&val);
+    void emplace_back (EmbeddedVectorType &&mbed);
+    template <typename... Args>
+    void emplace_back (Args &&...args) {
+      emplace_back (Value (std::forward<Args> (args)...));
+    }
   };
 
   class EmbeddedVectorType : public VectorType
   {
-private:
-    explicit EmbeddedVectorType(const std::shared_ptr<VectorObject>& copy) : VectorType(copy) { } // called by clone()
-public:
-    EmbeddedVectorType(class EvaluationSession *session) : VectorType(session) {}
-    EmbeddedVectorType(const EmbeddedVectorType&) = delete;
-    EmbeddedVectorType& operator=(const EmbeddedVectorType&) = delete;
-    EmbeddedVectorType(EmbeddedVectorType&&) = default;
-    EmbeddedVectorType& operator=(EmbeddedVectorType&&) = default;
-    ~EmbeddedVectorType() = default;
-    EmbeddedVectorType(VectorType&& v) : VectorType(std::move(v)) {} // converting constructor
-    [[nodiscard]] EmbeddedVectorType clone() const { return EmbeddedVectorType(this->ptr); }
-    static Value Empty() { return EmbeddedVectorType(nullptr); }
+  private:
+    explicit EmbeddedVectorType (const std::shared_ptr<VectorObject> &copy)
+      : VectorType (copy) {} // called by clone()
+  public:
+    EmbeddedVectorType (class EvaluationSession *session)
+      : VectorType (session) {}
+    EmbeddedVectorType (const EmbeddedVectorType &) = delete;
+    EmbeddedVectorType &operator= (const EmbeddedVectorType &) = delete;
+    EmbeddedVectorType (EmbeddedVectorType &&) = default;
+    EmbeddedVectorType &operator= (EmbeddedVectorType &&) = default;
+    ~EmbeddedVectorType () = default;
+    EmbeddedVectorType (VectorType &&v)
+      : VectorType (std::move (v)) {} // converting constructor
+    [[nodiscard]] EmbeddedVectorType clone () const {
+      return EmbeddedVectorType (this->ptr);
+    }
+    static Value Empty () {
+      return EmbeddedVectorType (nullptr);
+    }
   };
 
   class ObjectType
   {
-protected:
+  protected:
     struct ObjectObject;
     struct ObjectObjectDeleter {
-      void operator()(ObjectObject *obj);
+      void operator() (ObjectObject *obj);
     };
 
-private:
-    explicit ObjectType(const std::shared_ptr<ObjectObject>& copy);
+  private:
+    explicit ObjectType (const std::shared_ptr<ObjectObject> &copy);
 
-public:
+  public:
     std::shared_ptr<ObjectObject> ptr;
-    ObjectType(class EvaluationSession *session);
-    [[nodiscard]] ObjectType clone() const;
-    [[nodiscard]] const Value& get(const std::string& key) const;
-    bool set(const std::string& key, Value value);
-    bool del(const std::string& key); // true if was present
-    bool contains(const std::string& key) const;
-    bool empty() const;
-    Value operator==(const ObjectType& v) const;
-    Value operator<(const ObjectType& v) const;
-    Value operator>(const ObjectType& v) const;
-    Value operator!=(const ObjectType& v) const;
-    Value operator<=(const ObjectType& v) const;
-    Value operator>=(const ObjectType& v) const;
-    const Value& operator[](const str_utf8_wrapper& v) const;
-    [[nodiscard]] const std::vector<std::string>& keys() const;
-    [[nodiscard]] const std::vector<Value>& values() const;
+    ObjectType (class EvaluationSession *session);
+    [[nodiscard]] ObjectType clone () const;
+    [[nodiscard]] const Value &get (const std::string &key) const;
+    bool set (const std::string &key, Value value);
+    bool del (const std::string &key); // true if was present
+    bool contains (const std::string &key) const;
+    bool empty () const;
+    Value operator== (const ObjectType &v) const;
+    Value operator< (const ObjectType &v) const;
+    Value operator> (const ObjectType &v) const;
+    Value operator!= (const ObjectType &v) const;
+    Value operator<= (const ObjectType &v) const;
+    Value operator>= (const ObjectType &v) const;
+    const Value &operator[] (const str_utf8_wrapper &v) const;
+    [[nodiscard]] const std::vector<std::string> &keys () const;
+    [[nodiscard]] const std::vector<Value> &values () const;
   };
 
 private:
-  Value() : value(UndefType()) { } // Don't default construct empty Values.  If "undefined" needed, use reference to Value::undefined, or call Value::undef() for return by value
+  Value ()
+    : value (UndefType ()) {} // Don't default construct empty Values.  If "undefined" needed, use reference to Value::undefined, or call Value::undef() for return by value
 public:
-  Value(const Value&) = delete; // never copy, move instead
-  Value& operator=(const Value& v) = delete; // never copy, move instead
-  Value(Value&&) = default;
-  Value& operator=(Value&&) = default;
-  [[nodiscard]] Value clone() const; // Use sparingly to explicitly copy a Value
-  ~Value() = default;
-
-  Value(int v) : value(double(v)) { }
-  Value(const char *v) : value(str_utf8_wrapper(v)) { } // prevent insane implicit conversion to bool!
-  Value(char *v) : value(str_utf8_wrapper(v)) { } // prevent insane implicit conversion to bool!
-                                                  // http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0608r3.html
+  Value (const Value &) = delete; // never copy, move instead
+  Value &operator= (const Value &v) = delete; // never copy, move instead
+  Value (Value &&) = default;
+  Value &operator= (Value &&) = default;
+  [[nodiscard]] Value clone () const; // Use sparingly to explicitly copy a Value
+  ~Value () = default;
+
+  Value (int v)
+    : value (double (v)) {}
+  Value (const char *v)
+    : value (str_utf8_wrapper (v)) {} // prevent insane implicit conversion to bool!
+  Value (char *v)
+    : value (str_utf8_wrapper (v)) {} // prevent insane implicit conversion to bool!
+    // http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0608r3.html
   // Don't shadow move constructor
   template <class T, class = std::enable_if_t<!std::is_same_v<std::decay_t<T>, Value>>>
-  Value(T&& val) : value(std::forward<T>(val)) { }
+  Value (T &&val)
+    : value (std::forward<T> (val)) {}
 
-  static Value undef(const std::string& why); // creation of undef requires a reason!
+  static Value undef (const std::string &why); // creation of undef requires a reason!
 
-  [[nodiscard]] const std::string typeName() const;
-  [[nodiscard]] static std::string typeName(Type type);
-  [[nodiscard]] Type type() const { return static_cast<Type>(this->value.index()); }
-  [[nodiscard]] bool isDefinedAs(const Type type) const { return this->type() == type; }
-  [[nodiscard]] bool isDefined()   const { return this->type() != Type::UNDEFINED; }
-  [[nodiscard]] bool isUndefined() const { return this->type() == Type::UNDEFINED; }
-  [[nodiscard]] bool isUncheckedUndef() const;
+  [[nodiscard]] const std::string typeName () const;
+  [[nodiscard]] static std::string typeName (Type type);
+  [[nodiscard]] Type type () const {
+    return static_cast<Type> (this->value.index ());
+  }
+  [[nodiscard]] bool isDefinedAs (const Type type) const {
+    return this->type () == type;
+  }
+  [[nodiscard]] bool isDefined () const {
+    return this->type () != Type::UNDEFINED;
+  }
+  [[nodiscard]] bool isUndefined () const {
+    return this->type () == Type::UNDEFINED;
+  }
+  [[nodiscard]] bool isUncheckedUndef () const;
 
   // Conversion to std::variant "BoundedType"s. const ref where appropriate.
-  [[nodiscard]] bool toBool() const;
-  [[nodiscard]] double toDouble() const;
-  [[nodiscard]] double toInteger() const;
-  [[nodiscard]] int64_t toInt64() const;
-  [[nodiscard]] const str_utf8_wrapper& toStrUtf8Wrapper() const;
-  [[nodiscard]] const VectorType& toVector() const;
-  [[nodiscard]] const EmbeddedVectorType& toEmbeddedVector() const;
-  [[nodiscard]] VectorType& toVectorNonConst();
-  [[nodiscard]] EmbeddedVectorType& toEmbeddedVectorNonConst();
-  [[nodiscard]] const RangeType& toRange() const;
-  [[nodiscard]] const FunctionType& toFunction() const;
-  [[nodiscard]] const ObjectType& toObject() const;
+  [[nodiscard]] bool toBool () const;
+  [[nodiscard]] double toDouble () const;
+  [[nodiscard]] double toInteger () const;
+  [[nodiscard]] int64_t toInt64 () const;
+  [[nodiscard]] const str_utf8_wrapper &toStrUtf8Wrapper () const;
+  [[nodiscard]] const VectorType &toVector () const;
+  [[nodiscard]] const EmbeddedVectorType &toEmbeddedVector () const;
+  [[nodiscard]] VectorType &toVectorNonConst ();
+  [[nodiscard]] EmbeddedVectorType &toEmbeddedVectorNonConst ();
+  [[nodiscard]] const RangeType &toRange () const;
+  [[nodiscard]] const FunctionType &toFunction () const;
+  [[nodiscard]] const ObjectType &toObject () const;
 
   // Other conversion utility functions
-  bool getDouble(double& v) const;
-  bool getFiniteDouble(double& v) const;
-  bool getUnsignedInt(unsigned int& v) const;
-  bool getPositiveInt(unsigned int& v) const;
-  [[nodiscard]] std::string toString() const;
-  [[nodiscard]] std::string toEchoString() const;
-  [[nodiscard]] std::string toEchoStringNoThrow() const; //use this for warnings
-  [[nodiscard]] const UndefType& toUndef() const;
-  [[nodiscard]] std::string toUndefString() const;
-  [[nodiscard]] std::string chrString() const;
-  bool getVec2(double& x, double& y, bool ignoreInfinite = false) const;
-  bool getVec3(double& x, double& y, double& z) const;
-  bool getVec3(double& x, double& y, double& z, double defaultval) const;
+  bool getDouble (double &v) const;
+  bool getFiniteDouble (double &v) const;
+  bool getUnsignedInt (unsigned int &v) const;
+  bool getPositiveInt (unsigned int &v) const;
+  [[nodiscard]] std::string toString () const;
+  [[nodiscard]] std::string toEchoString () const;
+  [[nodiscard]] std::string toEchoStringNoThrow () const; //use this for warnings
+  [[nodiscard]] const UndefType &toUndef () const;
+  [[nodiscard]] std::string toUndefString () const;
+  [[nodiscard]] std::string chrString () const;
+  bool getVec2 (double &x, double &y, bool ignoreInfinite = false) const;
+  bool getVec3 (double &x, double &y, double &z) const;
+  bool getVec3 (double &x, double &y, double &z, double defaultval) const;
 
   // Common Operators
-  operator bool() const = delete;
-  Value operator==(const Value& v) const;
-  Value operator!=(const Value& v) const;
-  Value operator<(const Value& v) const;
-  Value operator<=(const Value& v) const;
-  Value operator>=(const Value& v) const;
-  Value operator>(const Value& v) const;
-  Value operator-() const;
+  operator bool () const = delete;
+  Value operator== (const Value &v) const;
+  Value operator!= (const Value &v) const;
+  Value operator< (const Value &v) const;
+  Value operator<= (const Value &v) const;
+  Value operator>= (const Value &v) const;
+  Value operator> (const Value &v) const;
+  Value operator- () const;
   Value operator~() const;
-  Value operator[](size_t idx) const;
-  Value operator[](const Value& v) const;
-  Value operator+(const Value& v) const;
-  Value operator-(const Value& v) const;
-  Value operator<<(const Value& v) const;
-  Value operator>>(const Value& v) const;
-  Value operator&(const Value& v) const;
-  Value operator|(const Value& v) const;
-  Value operator*(const Value& v) const;
-  Value operator/(const Value& v) const;
-  Value operator%(const Value& v) const;
-  Value operator^(const Value& v) const;
-
-  static bool cmp_less(const Value& v1, const Value& v2);
-
-  friend std::ostream& operator<<(std::ostream& stream, const Value& value) {
-    if (value.type() == Value::Type::STRING) stream << QuotedString(value.toString());
-    else stream << value.toString();
+  Value operator[] (size_t idx) const;
+  Value operator[] (const Value &v) const;
+  Value operator+ (const Value &v) const;
+  Value operator- (const Value &v) const;
+  Value operator<< (const Value &v) const;
+  Value operator>> (const Value &v) const;
+  Value operator& (const Value &v) const;
+  Value operator| (const Value &v) const;
+  Value operator* (const Value &v) const;
+  Value operator/ (const Value &v) const;
+  Value operator% (const Value &v) const;
+  Value operator^ (const Value &v) const;
+
+  static bool cmp_less (const Value &v1, const Value &v2);
+
+  friend std::ostream &operator<< (std::ostream &stream, const Value &value) {
+    if (value.type () == Value::Type::STRING)
+      stream << QuotedString (value.toString ());
+    else
+      stream << value.toString ();
     return stream;
   }
 
   using Variant = std::variant<UndefType, bool, double, str_utf8_wrapper, VectorType, EmbeddedVectorType, RangePtr, FunctionPtr, ObjectType>;
 
-  static_assert(sizeof(Value::Variant) <= 24, "Memory size of Value too big");
-  [[nodiscard]] const Variant& getVariant() const { return value; }
+  static_assert (sizeof (Value::Variant) <= 24, "Memory size of Value too big");
+  [[nodiscard]] const Variant &getVariant () const {
+    return value;
+  }
 
 private:
   Variant value;
@@ -409,51 +492,54 @@ struct Value::ObjectType::ObjectObject {
   std::vector<std::string> keys;
   std::vector<Value> values;
 
-  const size_t find(const std::string& key) {
-    if (!keys.empty() && map.empty()){
-      for ( size_t i = 0; i < keys.size(); i++) {
-        map.emplace(keys[i], i);
+  const size_t find (const std::string &key) {
+    if (!keys.empty () && map.empty ()) {
+      for (size_t i = 0; i < keys.size (); i++) {
+        map.emplace (keys[i], i);
       }
     }
-    auto it = map.find(key);
-    if (it != map.end()) {
+    auto it = map.find (key);
+    if (it != map.end ()) {
       return it->second;
-    } else return NOINDEX;
+    } else
+      return NOINDEX;
   }
 
-  bool set(const std::string& key, Value value) {
-    size_t index = find(key);
+  bool set (const std::string &key, Value value) {
+    size_t index = find (key);
     if (index != NOINDEX) {
       // if contains key, keep at same position
-      values[index] = std::move(value);
+      values[index] = std::move (value);
     } else {
-      if (!map.empty()) {
-        map[key] = keys.size();       // incremental update
+      if (!map.empty ()) {
+        map[key] = keys.size (); // incremental update
       }
-      keys.emplace_back(key);
-      values.emplace_back(std::move(value));
+      keys.emplace_back (key);
+      values.emplace_back (std::move (value));
     }
     return index == NOINDEX;
   }
 
-  size_t del(const std::string& key) {
-    size_t index = find(key);
+  size_t del (const std::string &key) {
+    size_t index = find (key);
     if (index != NOINDEX) {
-      keys.erase(keys.begin() + index);
-      values.erase(values.begin() + index);
-      map.clear();
+      keys.erase (keys.begin () + index);
+      values.erase (values.begin () + index);
+      map.clear ();
     }
     return index;
   }
 
-  const Value& get(const std::string& key) {
-    size_t index = find(key);
-    if (index != NOINDEX)return values[index];
-    else return Value::undefined;
+  const Value &get (const std::string &key) {
+    size_t index = find (key);
+    if (index != NOINDEX)
+      return values[index];
+    else
+      return Value::undefined;
   }
 };
 
-std::ostream& operator<<(std::ostream& stream, const Value::ObjectType& u);
+std::ostream &operator<< (std::ostream &stream, const Value::ObjectType &u);
 
 using VectorType = Value::VectorType;
 using EmbeddedVectorType = Value::EmbeddedVectorType;
diff --git a/src/core/ValueMap.h b/src/core/ValueMap.h
index 226658499..971e0e633 100644
--- a/src/core/ValueMap.h
+++ b/src/core/ValueMap.h
@@ -17,28 +17,45 @@ public:
   using iterator = map_t::iterator;
   using const_iterator = map_t::const_iterator;
 
-// Gotta have C++20 for this beast
-  bool contains(const std::string& name) const { return map.count(name); }
+  // Gotta have C++20 for this beast
+  bool contains (const std::string &name) const {
+    return map.count (name);
+  }
 
-// Directly wrapped calls
-  const_iterator find(const std::string& name) const {  return map.find(name); }
-  const_iterator begin() const {  return map.cbegin(); }
-  const_iterator end() const {  return map.cend(); }
-  iterator begin() {  return map.begin(); }
-  iterator end() {  return map.end(); }
-  void clear() { map.clear(); }
-  size_t size() const { return map.size(); }
-  template <typename ... Args> std::pair<iterator, bool> emplace(Args&&... args) {
-    return map.emplace(std::forward<Args>(args)...);
-  }
-  std::pair<iterator, bool> insert_or_assign(const std::string& name, Value&& value) {
-    return map.insert_or_assign(name, std::move(value));
+  // Directly wrapped calls
+  const_iterator find (const std::string &name) const {
+    return map.find (name);
+  }
+  const_iterator begin () const {
+    return map.cbegin ();
+  }
+  const_iterator end () const {
+    return map.cend ();
+  }
+  iterator begin () {
+    return map.begin ();
+  }
+  iterator end () {
+    return map.end ();
+  }
+  void clear () {
+    map.clear ();
+  }
+  size_t size () const {
+    return map.size ();
+  }
+  template <typename... Args>
+  std::pair<iterator, bool> emplace (Args &&...args) {
+    return map.emplace (std::forward<Args> (args)...);
+  }
+  std::pair<iterator, bool> insert_or_assign (const std::string &name, Value &&value) {
+    return map.insert_or_assign (name, std::move (value));
   }
 
   // Get value by name, without possibility of default-constructing a missing name
   //   return Value::undefined if key missing
-  const Value& get(const std::string& name) const {
-    auto result = map.find(name);
-    return result == map.end() ? Value::undefined : result->second;
+  const Value &get (const std::string &name) const {
+    auto result = map.find (name);
+    return result == map.end () ? Value::undefined : result->second;
   }
 };
diff --git a/src/core/builtin_functions.cc b/src/core/builtin_functions.cc
index 630e46104..af3a82295 100644
--- a/src/core/builtin_functions.cc
+++ b/src/core/builtin_functions.cc
@@ -55,28 +55,26 @@
 
 #if defined __WIN32__ || defined _MSC_VER
 #include <process.h>
-int process_id = _getpid();
+int process_id = _getpid ();
 #else
 #include <sys/types.h>
 #include <unistd.h>
-int process_id = getpid();
+int process_id = getpid ();
 #endif
 
-std::mt19937 deterministic_rng(std::time(nullptr) + process_id);
-void initialize_rng() {
+std::mt19937 deterministic_rng (std::time (nullptr) + process_id);
+void initialize_rng () {
   static uint64_t seed_val = 0;
-  seed_val ^= uint64_t(std::time(nullptr) + process_id);
-  deterministic_rng.seed(seed_val);
-  std::uniform_int_distribution<uint64_t> distributor(0);
-  seed_val ^= distributor(deterministic_rng);
+  seed_val ^= uint64_t (std::time (nullptr) + process_id);
+  deterministic_rng.seed (seed_val);
+  std::uniform_int_distribution<uint64_t> distributor (0);
+  seed_val ^= distributor (deterministic_rng);
 }
 
-
-static inline bool check_arguments(const char *function_name, const Arguments& arguments, const Location& loc, unsigned int expected_count, bool warn = true)
-{
-  if (arguments.size() != expected_count) {
+static inline bool check_arguments (const char *function_name, const Arguments &arguments, const Location &loc, unsigned int expected_count, bool warn = true) {
+  if (arguments.size () != expected_count) {
     if (warn) {
-      print_argCnt_warning(function_name, arguments.size(), STR(expected_count), loc, arguments.documentRoot());
+      print_argCnt_warning (function_name, arguments.size (), STR (expected_count), loc, arguments.documentRoot ());
     }
     return false;
   }
@@ -89,15 +87,14 @@ static inline bool check_arguments(const char *function_name, const Arguments& a
    }
  */
 template <size_t N>
-static inline bool check_arguments(const char *function_name, const Arguments& arguments, const Location& loc, const Value::Type (& expected_types) [N], bool warn = true)
-{
-  if (!check_arguments(function_name, arguments, loc, N, warn)) {
+static inline bool check_arguments (const char *function_name, const Arguments &arguments, const Location &loc, const Value::Type (&expected_types)[N], bool warn = true) {
+  if (!check_arguments (function_name, arguments, loc, N, warn)) {
     return false;
   }
   for (size_t i = 0; i < N; i++) {
-    if (arguments[i]->type() != expected_types[i]) {
+    if (arguments[i]->type () != expected_types[i]) {
       if (warn) {
-        print_argConvert_positioned_warning(function_name, "argument " + STR(i), arguments[i]->clone(), {expected_types[i]}, loc, arguments.documentRoot());
+        print_argConvert_positioned_warning (function_name, "argument " + STR (i), arguments[i]->clone (), {expected_types[i]}, loc, arguments.documentRoot ());
       }
       return false;
     }
@@ -106,406 +103,367 @@ static inline bool check_arguments(const char *function_name, const Arguments& a
 }
 
 template <size_t N>
-static inline bool try_check_arguments(const Arguments& arguments, const Value::Type (& expected_types) [N])
-{
-  return check_arguments(nullptr, arguments, Location::NONE, expected_types, false);
+static inline bool try_check_arguments (const Arguments &arguments, const Value::Type (&expected_types)[N]) {
+  return check_arguments (nullptr, arguments, Location::NONE, expected_types, false);
 }
 
-Value builtin_abs(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("abs", arguments, loc, { Value::Type::NUMBER })) {
-    return Value::undefined.clone();
+Value builtin_abs (Arguments arguments, const Location &loc) {
+  if (!check_arguments ("abs", arguments, loc, {Value::Type::NUMBER})) {
+    return Value::undefined.clone ();
   }
-  return {std::fabs(arguments[0]->toDouble())};
+  return {std::fabs (arguments[0]->toDouble ())};
 }
 
-Value builtin_sign(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("sign", arguments, loc, { Value::Type::NUMBER })) {
-    return Value::undefined.clone();
+Value builtin_sign (Arguments arguments, const Location &loc) {
+  if (!check_arguments ("sign", arguments, loc, {Value::Type::NUMBER})) {
+    return Value::undefined.clone ();
   }
-  double x = arguments[0]->toDouble();
+  double x = arguments[0]->toDouble ();
   return {(x < 0) ? -1.0 : ((x > 0) ? 1.0 : 0.0)};
 }
 
-Value builtin_rands(Arguments arguments, const Location& loc)
-{
-  if (arguments.size() < 3 || arguments.size() > 4) {
-    print_argCnt_warning("rands", arguments.size(), "3 or 4", loc, arguments.documentRoot());
-    return Value::undefined.clone();
-  } else if (arguments.size() == 3) {
-    if (!check_arguments("rands", arguments, loc, { Value::Type::NUMBER, Value::Type::NUMBER, Value::Type::NUMBER })) {
-      return Value::undefined.clone();
+Value builtin_rands (Arguments arguments, const Location &loc) {
+  if (arguments.size () < 3 || arguments.size () > 4) {
+    print_argCnt_warning ("rands", arguments.size (), "3 or 4", loc, arguments.documentRoot ());
+    return Value::undefined.clone ();
+  } else if (arguments.size () == 3) {
+    if (!check_arguments ("rands", arguments, loc, {Value::Type::NUMBER, Value::Type::NUMBER, Value::Type::NUMBER})) {
+      return Value::undefined.clone ();
     }
   } else {
-    if (!check_arguments("rands", arguments, loc, { Value::Type::NUMBER, Value::Type::NUMBER, Value::Type::NUMBER, Value::Type::NUMBER })) {
-      return Value::undefined.clone();
+    if (!check_arguments ("rands", arguments, loc, {Value::Type::NUMBER, Value::Type::NUMBER, Value::Type::NUMBER, Value::Type::NUMBER})) {
+      return Value::undefined.clone ();
     }
   }
 
-  double min = arguments[0]->toDouble();
-  if (std::isinf(min) || std::isnan(min)) {
-    LOG(message_group::Warning, loc, arguments.documentRoot(), "rands() range min cannot be infinite");
-    min = -std::numeric_limits<double>::max() / 2;
-    LOG(message_group::Warning, "resetting to %1f", min);
+  double min = arguments[0]->toDouble ();
+  if (std::isinf (min) || std::isnan (min)) {
+    LOG (message_group::Warning, loc, arguments.documentRoot (), "rands() range min cannot be infinite");
+    min = -std::numeric_limits<double>::max () / 2;
+    LOG (message_group::Warning, "resetting to %1f", min);
   }
 
-  double max = arguments[1]->toDouble();
-  if (std::isinf(max)  || std::isnan(max)) {
-    LOG(message_group::Warning, loc, arguments.documentRoot(), "rands() range max cannot be infinite");
-    max = std::numeric_limits<double>::max() / 2;
-    LOG(message_group::Warning, "resetting to %1f", max);
+  double max = arguments[1]->toDouble ();
+  if (std::isinf (max) || std::isnan (max)) {
+    LOG (message_group::Warning, loc, arguments.documentRoot (), "rands() range max cannot be infinite");
+    max = std::numeric_limits<double>::max () / 2;
+    LOG (message_group::Warning, "resetting to %1f", max);
   }
   if (max < min) {
-    double tmp = min; min = max; max = tmp;
+    double tmp = min;
+    min = max;
+    max = tmp;
   }
 
-  double numresultsd = std::abs(arguments[2]->toDouble() );
-  if (std::isinf(numresultsd) || std::isnan(numresultsd)) {
-    LOG(message_group::Warning, loc, arguments.documentRoot(), "rands() cannot create an infinite number of results");
-    LOG(message_group::Warning, "resetting number of results to 1");
+  double numresultsd = std::abs (arguments[2]->toDouble ());
+  if (std::isinf (numresultsd) || std::isnan (numresultsd)) {
+    LOG (message_group::Warning, loc, arguments.documentRoot (), "rands() cannot create an infinite number of results");
+    LOG (message_group::Warning, "resetting number of results to 1");
     numresultsd = 1;
   }
-  auto numresults = boost_numeric_cast<size_t, double>(numresultsd);
+  auto numresults = boost_numeric_cast<size_t, double> (numresultsd);
 
-  if (arguments.size() > 3) {
-    auto seed = static_cast<uint32_t>(hash_floating_point(arguments[3]->toDouble() ));
-    deterministic_rng.seed(seed);
+  if (arguments.size () > 3) {
+    auto seed = static_cast<uint32_t> (hash_floating_point (arguments[3]->toDouble ()));
+    deterministic_rng.seed (seed);
   }
 
-  VectorType vec(arguments.session());
-  vec.reserve(numresults);
+  VectorType vec (arguments.session ());
+  vec.reserve (numresults);
   if (min >= max) { // uniform_real_distribution doesn't allow min == max
     for (size_t i = 0; i < numresults; ++i)
-      vec.emplace_back(min);
+      vec.emplace_back (min);
   } else {
-    std::uniform_real_distribution<> distributor(min, max);
+    std::uniform_real_distribution<> distributor (min, max);
     for (size_t i = 0; i < numresults; ++i) {
-      vec.emplace_back(distributor(deterministic_rng));
+      vec.emplace_back (distributor (deterministic_rng));
     }
   }
-  return std::move(vec);
+  return std::move (vec);
 }
 
-static std::vector<double> min_max_arguments(const Arguments& arguments, const Location& loc, const char *function_name)
-{
+static std::vector<double> min_max_arguments (const Arguments &arguments, const Location &loc, const char *function_name) {
   std::vector<double> output;
   // preserve special handling of the first argument
   // as a template for vector processing
-  if (arguments.size() == 0) {
-    print_argCnt_warning(function_name, arguments.size(), "at least 1", loc, arguments.documentRoot());
+  if (arguments.size () == 0) {
+    print_argCnt_warning (function_name, arguments.size (), "at least 1", loc, arguments.documentRoot ());
     return {};
-  } else if (arguments.size() == 1 && arguments[0]->type() == Value::Type::VECTOR) {
-    const auto& elements = arguments[0]->toVector();
-    if (elements.size() == 0) {
-      print_argCnt_warning(function_name, elements.size(), "at least 1 vector element", loc, arguments.documentRoot());
+  } else if (arguments.size () == 1 && arguments[0]->type () == Value::Type::VECTOR) {
+    const auto &elements = arguments[0]->toVector ();
+    if (elements.size () == 0) {
+      print_argCnt_warning (function_name, elements.size (), "at least 1 vector element", loc, arguments.documentRoot ());
       return {};
     }
-    for (size_t i = 0; i < elements.size(); i++) {
-      const auto& element = elements[i];
+    for (size_t i = 0; i < elements.size (); i++) {
+      const auto &element = elements[i];
       // 4/20/14 semantic change per discussion:
       // break on any non-number
-      if (element.type() != Value::Type::NUMBER) {
-        print_argConvert_positioned_warning(function_name, "vector element " + STR(i), element, {Value::Type::NUMBER}, loc, arguments.documentRoot());
+      if (element.type () != Value::Type::NUMBER) {
+        print_argConvert_positioned_warning (function_name, "vector element " + STR (i), element, {Value::Type::NUMBER}, loc, arguments.documentRoot ());
         return {};
       }
-      output.push_back(element.toDouble());
+      output.push_back (element.toDouble ());
     }
   } else {
-    for (size_t i = 0; i < arguments.size(); i++) {
-      const auto& argument = arguments[i];
+    for (size_t i = 0; i < arguments.size (); i++) {
+      const auto &argument = arguments[i];
       // 4/20/14 semantic change per discussion:
       // break on any non-number
-      if (argument->type() != Value::Type::NUMBER) {
-        print_argConvert_positioned_warning(function_name, "argument " + STR(i), argument->clone(), {Value::Type::NUMBER}, loc, arguments.documentRoot());
+      if (argument->type () != Value::Type::NUMBER) {
+        print_argConvert_positioned_warning (function_name, "argument " + STR (i), argument->clone (), {Value::Type::NUMBER}, loc, arguments.documentRoot ());
         return {};
       }
-      output.push_back(argument->toDouble());
+      output.push_back (argument->toDouble ());
     }
   }
   return output;
 }
 
-Value builtin_min(Arguments arguments, const Location& loc)
-{
-  std::vector<double> values = min_max_arguments(arguments, loc, "min");
-  if (values.empty()) {
-    return Value::undefined.clone();
+Value builtin_min (Arguments arguments, const Location &loc) {
+  std::vector<double> values = min_max_arguments (arguments, loc, "min");
+  if (values.empty ()) {
+    return Value::undefined.clone ();
   }
-  return {*std::min_element(values.begin(), values.end())};
+  return {*std::min_element (values.begin (), values.end ())};
 }
 
-Value builtin_max(Arguments arguments, const Location& loc)
-{
-  std::vector<double> values = min_max_arguments(arguments, loc, "max");
-  if (values.empty()) {
-    return Value::undefined.clone();
+Value builtin_max (Arguments arguments, const Location &loc) {
+  std::vector<double> values = min_max_arguments (arguments, loc, "max");
+  if (values.empty ()) {
+    return Value::undefined.clone ();
   }
-  return {*std::max_element(values.begin(), values.end())};
+  return {*std::max_element (values.begin (), values.end ())};
 }
 
-Value builtin_sin(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("sin", arguments, loc, { Value::Type::NUMBER })) {
-    return Value::undefined.clone();
+Value builtin_sin (Arguments arguments, const Location &loc) {
+  if (!check_arguments ("sin", arguments, loc, {Value::Type::NUMBER})) {
+    return Value::undefined.clone ();
   }
-  return {sin_degrees(arguments[0]->toDouble())};
+  return {sin_degrees (arguments[0]->toDouble ())};
 }
 
-Value builtin_cos(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("cos", arguments, loc, { Value::Type::NUMBER })) {
-    return Value::undefined.clone();
+Value builtin_cos (Arguments arguments, const Location &loc) {
+  if (!check_arguments ("cos", arguments, loc, {Value::Type::NUMBER})) {
+    return Value::undefined.clone ();
   }
-  return {cos_degrees(arguments[0]->toDouble())};
+  return {cos_degrees (arguments[0]->toDouble ())};
 }
 
-Value builtin_asin(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("asin", arguments, loc, { Value::Type::NUMBER })) {
-    return Value::undefined.clone();
+Value builtin_asin (Arguments arguments, const Location &loc) {
+  if (!check_arguments ("asin", arguments, loc, {Value::Type::NUMBER})) {
+    return Value::undefined.clone ();
   }
-  return {asin_degrees(arguments[0]->toDouble())};
+  return {asin_degrees (arguments[0]->toDouble ())};
 }
 
-Value builtin_acos(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("acos", arguments, loc, { Value::Type::NUMBER })) {
-    return Value::undefined.clone();
+Value builtin_acos (Arguments arguments, const Location &loc) {
+  if (!check_arguments ("acos", arguments, loc, {Value::Type::NUMBER})) {
+    return Value::undefined.clone ();
   }
-  return {acos_degrees(arguments[0]->toDouble())};
+  return {acos_degrees (arguments[0]->toDouble ())};
 }
 
-Value builtin_tan(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("tan", arguments, loc, { Value::Type::NUMBER })) {
-    return Value::undefined.clone();
+Value builtin_tan (Arguments arguments, const Location &loc) {
+  if (!check_arguments ("tan", arguments, loc, {Value::Type::NUMBER})) {
+    return Value::undefined.clone ();
   }
-  return {tan_degrees(arguments[0]->toDouble())};
+  return {tan_degrees (arguments[0]->toDouble ())};
 }
 
-Value builtin_atan(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("atan", arguments, loc, { Value::Type::NUMBER })) {
-    return Value::undefined.clone();
+Value builtin_atan (Arguments arguments, const Location &loc) {
+  if (!check_arguments ("atan", arguments, loc, {Value::Type::NUMBER})) {
+    return Value::undefined.clone ();
   }
-  return {atan_degrees(arguments[0]->toDouble())};
+  return {atan_degrees (arguments[0]->toDouble ())};
 }
 
-Value builtin_atan2(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("atan2", arguments, loc, { Value::Type::NUMBER, Value::Type::NUMBER })) {
-    return Value::undefined.clone();
+Value builtin_atan2 (Arguments arguments, const Location &loc) {
+  if (!check_arguments ("atan2", arguments, loc, {Value::Type::NUMBER, Value::Type::NUMBER})) {
+    return Value::undefined.clone ();
   }
-  return {atan2_degrees(arguments[0]->toDouble(), arguments[1]->toDouble())};
+  return {atan2_degrees (arguments[0]->toDouble (), arguments[1]->toDouble ())};
 }
 
-Value builtin_pow(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("pow", arguments, loc, { Value::Type::NUMBER, Value::Type::NUMBER })) {
-    return Value::undefined.clone();
+Value builtin_pow (Arguments arguments, const Location &loc) {
+  if (!check_arguments ("pow", arguments, loc, {Value::Type::NUMBER, Value::Type::NUMBER})) {
+    return Value::undefined.clone ();
   }
-  return {pow(arguments[0]->toDouble(), arguments[1]->toDouble())};
+  return {pow (arguments[0]->toDouble (), arguments[1]->toDouble ())};
 }
 
-Value builtin_round(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("round", arguments, loc, { Value::Type::NUMBER })) {
-    return Value::undefined.clone();
+Value builtin_round (Arguments arguments, const Location &loc) {
+  if (!check_arguments ("round", arguments, loc, {Value::Type::NUMBER})) {
+    return Value::undefined.clone ();
   }
-  return {round(arguments[0]->toDouble())};
+  return {round (arguments[0]->toDouble ())};
 }
 
-Value builtin_ceil(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("ceil", arguments, loc, { Value::Type::NUMBER })) {
-    return Value::undefined.clone();
+Value builtin_ceil (Arguments arguments, const Location &loc) {
+  if (!check_arguments ("ceil", arguments, loc, {Value::Type::NUMBER})) {
+    return Value::undefined.clone ();
   }
-  return {ceil(arguments[0]->toDouble())};
+  return {ceil (arguments[0]->toDouble ())};
 }
 
-Value builtin_floor(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("floor", arguments, loc, { Value::Type::NUMBER })) {
-    return Value::undefined.clone();
+Value builtin_floor (Arguments arguments, const Location &loc) {
+  if (!check_arguments ("floor", arguments, loc, {Value::Type::NUMBER})) {
+    return Value::undefined.clone ();
   }
-  return {floor(arguments[0]->toDouble())};
+  return {floor (arguments[0]->toDouble ())};
 }
 
-Value builtin_sqrt(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("sqrt", arguments, loc, { Value::Type::NUMBER })) {
-    return Value::undefined.clone();
+Value builtin_sqrt (Arguments arguments, const Location &loc) {
+  if (!check_arguments ("sqrt", arguments, loc, {Value::Type::NUMBER})) {
+    return Value::undefined.clone ();
   }
-  return {sqrt(arguments[0]->toDouble())};
+  return {sqrt (arguments[0]->toDouble ())};
 }
 
-Value builtin_exp(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("exp", arguments, loc, { Value::Type::NUMBER })) {
-    return Value::undefined.clone();
+Value builtin_exp (Arguments arguments, const Location &loc) {
+  if (!check_arguments ("exp", arguments, loc, {Value::Type::NUMBER})) {
+    return Value::undefined.clone ();
   }
-  return {exp(arguments[0]->toDouble())};
+  return {exp (arguments[0]->toDouble ())};
 }
 
-Value builtin_length(Arguments arguments, const Location& loc)
-{
-  if (try_check_arguments(arguments, { Value::Type::VECTOR })) {
-    return {double(arguments[0]->toVector().size())};
+Value builtin_length (Arguments arguments, const Location &loc) {
+  if (try_check_arguments (arguments, {Value::Type::VECTOR})) {
+    return {double (arguments[0]->toVector ().size ())};
   }
-  if (!check_arguments("len", arguments, loc, { Value::Type::STRING })) {
-    return Value::undefined.clone();
+  if (!check_arguments ("len", arguments, loc, {Value::Type::STRING})) {
+    return Value::undefined.clone ();
   }
   //Unicode glyph count for the length -- rather than the string (num. of bytes) length.
-  return {double( arguments[0]->toStrUtf8Wrapper().get_utf8_strlen() )};
+  return {double (arguments[0]->toStrUtf8Wrapper ().get_utf8_strlen ())};
 }
 
-Value builtin_log(Arguments arguments, const Location& loc)
-{
+Value builtin_log (Arguments arguments, const Location &loc) {
   double x, y;
-  if (arguments.size() == 1) {
-    if (!check_arguments("log", arguments, loc, { Value::Type::NUMBER })) {
-      return Value::undefined.clone();
+  if (arguments.size () == 1) {
+    if (!check_arguments ("log", arguments, loc, {Value::Type::NUMBER})) {
+      return Value::undefined.clone ();
     }
     x = 10.0;
-    y = arguments[0]->toDouble();
+    y = arguments[0]->toDouble ();
   } else {
-    if (!check_arguments("log", arguments, loc, { Value::Type::NUMBER, Value::Type::NUMBER })) {
-      return Value::undefined.clone();
+    if (!check_arguments ("log", arguments, loc, {Value::Type::NUMBER, Value::Type::NUMBER})) {
+      return Value::undefined.clone ();
     }
-    x = arguments[0]->toDouble();
-    y = arguments[1]->toDouble();
+    x = arguments[0]->toDouble ();
+    y = arguments[1]->toDouble ();
   }
-  return {log(y) / log(x)};
+  return {log (y) / log (x)};
 }
 
-Value builtin_ln(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("ln", arguments, loc, { Value::Type::NUMBER })) {
-    return Value::undefined.clone();
+Value builtin_ln (Arguments arguments, const Location &loc) {
+  if (!check_arguments ("ln", arguments, loc, {Value::Type::NUMBER})) {
+    return Value::undefined.clone ();
   }
-  return {log(arguments[0]->toDouble())};
+  return {log (arguments[0]->toDouble ())};
 }
 
-Value builtin_str(Arguments arguments, const Location& /*loc*/)
-{
+Value builtin_str (Arguments arguments, const Location & /*loc*/) {
   std::ostringstream stream;
-  for (const auto& argument : arguments) {
-    stream << argument->toString();
+  for (const auto &argument : arguments) {
+    stream << argument->toString ();
   }
-  return {stream.str()};
+  return {stream.str ()};
 }
 
-Value builtin_chr(Arguments arguments, const Location& /*loc*/)
-{
+Value builtin_chr (Arguments arguments, const Location & /*loc*/) {
   std::ostringstream stream;
-  for (const auto& argument : arguments) {
-    stream << argument->chrString();
+  for (const auto &argument : arguments) {
+    stream << argument->chrString ();
   }
-  return {stream.str()};
+  return {stream.str ()};
 }
 
-Value builtin_ord(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("ord", arguments, loc, { Value::Type::STRING })) {
-    return Value::undefined.clone();
+Value builtin_ord (Arguments arguments, const Location &loc) {
+  if (!check_arguments ("ord", arguments, loc, {Value::Type::STRING})) {
+    return Value::undefined.clone ();
   }
-  const str_utf8_wrapper& arg_str = arguments[0]->toStrUtf8Wrapper();
-  if (!arg_str.utf8_validate()) {
-    LOG(message_group::Warning, loc, arguments.documentRoot(), "ord() argument '%1$s' is not a valid utf8 string", arg_str.toString());
-    return Value::undefined.clone();
+  const str_utf8_wrapper &arg_str = arguments[0]->toStrUtf8Wrapper ();
+  if (!arg_str.utf8_validate ()) {
+    LOG (message_group::Warning, loc, arguments.documentRoot (), "ord() argument '%1$s' is not a valid utf8 string", arg_str.toString ());
+    return Value::undefined.clone ();
   }
 
-  if (arg_str.get_utf8_strlen() == 0) {
-    return Value::undefined.clone();
+  if (arg_str.get_utf8_strlen () == 0) {
+    return Value::undefined.clone ();
   }
 
-  return {(double)arg_str.get_utf8_char()};
+  return {(double)arg_str.get_utf8_char ()};
 }
 
-Value builtin_concat(Arguments arguments, const Location& /*loc*/)
-{
-  VectorType result(arguments.session());
-  result.reserve(arguments.size());
-  for (auto& argument : arguments) {
-    if (argument->type() == Value::Type::VECTOR) {
-      result.emplace_back(EmbeddedVectorType(std::move(argument->toVectorNonConst())));
+Value builtin_concat (Arguments arguments, const Location & /*loc*/) {
+  VectorType result (arguments.session ());
+  result.reserve (arguments.size ());
+  for (auto &argument : arguments) {
+    if (argument->type () == Value::Type::VECTOR) {
+      result.emplace_back (EmbeddedVectorType (std::move (argument->toVectorNonConst ())));
     } else {
-      result.emplace_back(std::move(argument.value));
+      result.emplace_back (std::move (argument.value));
     }
   }
-  return std::move(result);
+  return std::move (result);
 }
 
 #define OBJECT_HELP "In an unnamed list, entries must be [key,value] to set or [key] to delete. The key must be <string>."
 
-static std::string builtin_object_unnamed(ObjectType& result, const Value& value, int arg_index) {
+static std::string builtin_object_unnamed (ObjectType &result, const Value &value, int arg_index) {
 
-  std::string prior_args = "Argument " + std::to_string(arg_index) + " ";
+  std::string prior_args = "Argument " + std::to_string (arg_index) + " ";
 
-  switch (value.type()){
+  switch (value.type ()) {
   case Value::Type::OBJECT: {
-    const auto& obj = value.toObject();
-    for (const auto& key : obj.keys()) {
-      result.set(key, obj.get(key).clone());
+    const auto &obj = value.toObject ();
+    for (const auto &key : obj.keys ()) {
+      result.set (key, obj.get (key).clone ());
     }
     return "";
   }
   case Value::Type::VECTOR: {
 
-    const VectorType& vector = value.toVector();
+    const VectorType &vector = value.toVector ();
     int element = 0;
-    for (const auto& member : vector) {
-      std::string prior_entries = "Element " + std::to_string(element++) + " ";
-
-      if (member.type() != Value::Type::VECTOR) {
-        return str(boost::format(
-                     "object( %s[%s<%s>] ) Entry type is not a list, it is <%s>. " OBJECT_HELP)
-                   % prior_args.c_str()
-                   % prior_entries.c_str()
-                   % Value::typeName(member.type())
-                   % Value::typeName(member.type()));
+    for (const auto &member : vector) {
+      std::string prior_entries = "Element " + std::to_string (element++) + " ";
+
+      if (member.type () != Value::Type::VECTOR) {
+        return str (boost::format (
+                      "object( %s[%s<%s>] ) Entry type is not a list, it is <%s>. " OBJECT_HELP) %
+                    prior_args.c_str () % prior_entries.c_str () % Value::typeName (member.type ()) % Value::typeName (member.type ()));
       }
 
-      const auto& entry = member.toVector();
-      switch (entry.size()){
+      const auto &entry = member.toVector ();
+      switch (entry.size ()) {
       case 2:
       case 1: {
-        if (entry[0].type() != Value::Type::STRING) {
-          const char *es = entry.size() == 1 ? "" : ",value";
-          return str(boost::format("object(%s[%s[<%s>%s]]) The key of the entry is not <string> but <%s>. " OBJECT_HELP)
-                     % prior_args
-                     % prior_entries
-                     % Value::typeName(entry[0].type())
-                     % es
-                     % Value::typeName(entry[0].type()));
+        if (entry[0].type () != Value::Type::STRING) {
+          const char *es = entry.size () == 1 ? "" : ",value";
+          return str (boost::format ("object(%s[%s[<%s>%s]]) The key of the entry is not <string> but <%s>. " OBJECT_HELP) % prior_args % prior_entries % Value::typeName (entry[0].type ()) % es % Value::typeName (entry[0].type ()));
         }
-        const auto& key = entry[0].toString();
-        if (entry.size() == 1) {
-          result.del(key);
+        const auto &key = entry[0].toString ();
+        if (entry.size () == 1) {
+          result.del (key);
         } else {
-          result.set(key, entry[1].clone());
+          result.set (key, entry[1].clone ());
         }
         break;
       };
 
-      case 0: return str(boost::format("object(%s[%s[]]) Entry is empty. " OBJECT_HELP)
-                         % prior_args.c_str()
-                         % prior_entries.c_str());
+      case 0:
+        return str (boost::format ("object(%s[%s[]]) Entry is empty. " OBJECT_HELP) % prior_args.c_str () % prior_entries.c_str ());
 
-      default: return str(boost::format("object(%s[%s[...]]) Entry length is %d, must be 1 [key] or 2 [key,value]. " OBJECT_HELP)
-                          % prior_args
-                          % prior_entries
-                          % entry.size());
+      default:
+        return str (boost::format ("object(%s[%s[...]]) Entry length is %d, must be 1 [key] or 2 [key,value]. " OBJECT_HELP) % prior_args % prior_entries % entry.size ());
       }
     }
     return "";
   }
   default:
-    return str(boost::format("object(%s<%s>) An unnamed argument must be either <object> or <list>, it is <%s>. ")
-               % prior_args
-               % Value::typeName(value.type())
-               % Value::typeName(value.type()));
+    return str (boost::format ("object(%s<%s>) An unnamed argument must be either <object> or <list>, it is <%s>. ") % prior_args % Value::typeName (value.type ()) % Value::typeName (value.type ()));
   }
 }
 /**
@@ -520,61 +478,58 @@ static std::string builtin_object_unnamed(ObjectType& result, const Value& value
 
     Any other values are incorrect and will return undef and be logged as warning.
  */
-Value builtin_object(const std::shared_ptr<const Context>& context, const FunctionCall *call)
-{
-  ObjectType result(context->session());
+Value builtin_object (const std::shared_ptr<const Context> &context, const FunctionCall *call) {
+  ObjectType result (context->session ());
   int n = 0;
-  for (const auto& argument : call->arguments) {
-    Value value = argument->getExpr()->evaluate(context);
-    if (argument->getName().empty()) {
-      const auto error = builtin_object_unnamed(result, value, n);
-      if (!error.empty()) {
-        LOG(message_group::Warning, call->location(), context->documentRoot(), error.c_str());
-        return Value::undef(error);
+  for (const auto &argument : call->arguments) {
+    Value value = argument->getExpr ()->evaluate (context);
+    if (argument->getName ().empty ()) {
+      const auto error = builtin_object_unnamed (result, value, n);
+      if (!error.empty ()) {
+        LOG (message_group::Warning, call->location (), context->documentRoot (), error.c_str ());
+        return Value::undef (error);
       }
     } else {
-      result.set(argument->getName(), std::move(value));
+      result.set (argument->getName (), std::move (value));
     }
     n++;
   }
   return result;
 }
 
-Value builtin_has_key(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("has_key", arguments, loc, { Value::Type::OBJECT, Value::Type::STRING })) {
-    return Value::undefined.clone();
+Value builtin_has_key (Arguments arguments, const Location &loc) {
+  if (!check_arguments ("has_key", arguments, loc, {Value::Type::OBJECT, Value::Type::STRING})) {
+    return Value::undefined.clone ();
   }
-  const auto& obj = arguments[0]->toObject();
-  const auto& key = arguments[1]->toString();
-  return obj.contains(key);
+  const auto &obj = arguments[0]->toObject ();
+  const auto &key = arguments[1]->toString ();
+  return obj.contains (key);
 }
 
-Value builtin_lookup(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("lookup", arguments, loc, { Value::Type::NUMBER, Value::Type::VECTOR })) {
-    return Value::undefined.clone();
+Value builtin_lookup (Arguments arguments, const Location &loc) {
+  if (!check_arguments ("lookup", arguments, loc, {Value::Type::NUMBER, Value::Type::VECTOR})) {
+    return Value::undefined.clone ();
   }
-  double p = arguments[0]->toDouble();
-  if (!std::isfinite(p)) {
-    LOG(message_group::Warning, loc, arguments.documentRoot(), "lookup(%1$s, ...) first argument is not a number", arguments[0]->toEchoStringNoThrow());
-    return Value::undefined.clone();
+  double p = arguments[0]->toDouble ();
+  if (!std::isfinite (p)) {
+    LOG (message_group::Warning, loc, arguments.documentRoot (), "lookup(%1$s, ...) first argument is not a number", arguments[0]->toEchoStringNoThrow ());
+    return Value::undefined.clone ();
   }
 
   double low_p, low_v, high_p, high_v;
-  const auto& vec = arguments[1]->toVector();
+  const auto &vec = arguments[1]->toVector ();
 
   // Second must be a vector of vec2, with valid numbers inside
-  auto it = vec.begin();
-  if (vec.empty() || it->toVector().size() < 2 || !it->getVec2(low_p, low_v)) {
-    return Value::undefined.clone();
+  auto it = vec.begin ();
+  if (vec.empty () || it->toVector ().size () < 2 || !it->getVec2 (low_p, low_v)) {
+    return Value::undefined.clone ();
   }
   high_p = low_p;
   high_v = low_v;
 
-  for (++it; it != vec.end(); ++it) {
+  for (++it; it != vec.end (); ++it) {
     double this_p, this_v;
-    if (it->getVec2(this_p, this_v)) {
+    if (it->getVec2 (this_p, this_v)) {
       if (this_p <= p && (this_p > low_p || low_p > p)) {
         low_p = this_p;
         low_v = this_v;
@@ -585,10 +540,12 @@ Value builtin_lookup(Arguments arguments, const Location& loc)
       }
     }
   }
-  if (p <= low_p) return {high_v};
-  if (p >= high_p) return {low_v};
+  if (p <= low_p)
+    return {high_v};
+  if (p >= high_p)
+    return {low_v};
   double f = (p - low_p) / (high_p - low_p);
-  return {high_v *f + low_v * (1 - f)};
+  return {high_v * f + low_v * (1 - f)};
 }
 
 /*
@@ -641,29 +598,28 @@ Value builtin_lookup(Arguments arguments, const Location& loc)
 
  */
 
-static VectorType search(
-  const str_utf8_wrapper& find,
-  const str_utf8_wrapper& table,
+static VectorType search (
+  const str_utf8_wrapper &find,
+  const str_utf8_wrapper &table,
   unsigned int num_returns_per_match,
-  EvaluationSession *session
-  ) {
-  VectorType returnvec(session);
+  EvaluationSession *session) {
+  VectorType returnvec (session);
   //Unicode glyph count for the length
-  size_t findThisSize = find.get_utf8_strlen();
-  size_t searchTableSize = table.get_utf8_strlen();
+  size_t findThisSize = find.get_utf8_strlen ();
+  size_t searchTableSize = table.get_utf8_strlen ();
   for (size_t i = 0; i < findThisSize; ++i) {
     unsigned int matchCount = 0;
-    VectorType resultvec(session);
+    VectorType resultvec (session);
     const auto ft = find[i];
     for (size_t j = 0; j < searchTableSize; ++j) {
       const auto st = table[j];
-      if (!ft.empty() && !st.empty() && ft.get_utf8_char() == st.get_utf8_char()) {
+      if (!ft.empty () && !st.empty () && ft.get_utf8_char () == st.get_utf8_char ()) {
         matchCount++;
         if (num_returns_per_match == 1) {
-          returnvec.emplace_back(double(j));
+          returnvec.emplace_back (double (j));
           break;
         } else {
-          resultvec.emplace_back(double(j));
+          resultvec.emplace_back (double (j));
         }
         if (num_returns_per_match > 1 && matchCount >= num_returns_per_match) {
           break;
@@ -671,41 +627,40 @@ static VectorType search(
       }
     }
     if (num_returns_per_match == 0 || num_returns_per_match > 1) {
-      returnvec.emplace_back(std::move(resultvec));
+      returnvec.emplace_back (std::move (resultvec));
     }
   }
   return returnvec;
 }
 
-static VectorType search(
-  const str_utf8_wrapper& find,
-  const VectorType& table,
+static VectorType search (
+  const str_utf8_wrapper &find,
+  const VectorType &table,
   unsigned int num_returns_per_match,
   unsigned int index_col_num,
-  const Location& loc,
-  EvaluationSession *session
-  ) {
-  VectorType returnvec(session);
+  const Location &loc,
+  EvaluationSession *session) {
+  VectorType returnvec (session);
   //Unicode glyph count for the length
-  unsigned int findThisSize = find.get_utf8_strlen();
-  unsigned int searchTableSize = table.size();
+  unsigned int findThisSize = find.get_utf8_strlen ();
+  unsigned int searchTableSize = table.size ();
   for (size_t i = 0; i < findThisSize; ++i) {
     unsigned int matchCount = 0;
-    VectorType resultvec(session);
+    VectorType resultvec (session);
     const auto ft = find[i];
     for (size_t j = 0; j < searchTableSize; ++j) {
-      const auto& entryVec = table[j].toVector();
-      if (entryVec.size() <= index_col_num) {
-        LOG(message_group::Warning, loc, session->documentRoot(), "Invalid entry in search vector at index %1$d, required number of values in the entry: %2$d. Invalid entry: %3$s", j, (index_col_num + 1), table[j].toEchoStringNoThrow());
+      const auto &entryVec = table[j].toVector ();
+      if (entryVec.size () <= index_col_num) {
+        LOG (message_group::Warning, loc, session->documentRoot (), "Invalid entry in search vector at index %1$d, required number of values in the entry: %2$d. Invalid entry: %3$s", j, (index_col_num + 1), table[j].toEchoStringNoThrow ());
         return {session};
       }
-      if (!ft.empty() && ft.get_utf8_char() == entryVec[index_col_num].toStrUtf8Wrapper().get_utf8_char()) {
+      if (!ft.empty () && ft.get_utf8_char () == entryVec[index_col_num].toStrUtf8Wrapper ().get_utf8_char ()) {
         matchCount++;
         if (num_returns_per_match == 1) {
-          returnvec.emplace_back(double(j));
+          returnvec.emplace_back (double (j));
           break;
         } else {
-          resultvec.emplace_back(double(j));
+          resultvec.emplace_back (double (j));
         }
         if (num_returns_per_match > 1 && matchCount >= num_returns_per_match) {
           break;
@@ -713,580 +668,562 @@ static VectorType search(
       }
     }
     if (num_returns_per_match == 0 || num_returns_per_match > 1) {
-      returnvec.emplace_back(std::move(resultvec));
+      returnvec.emplace_back (std::move (resultvec));
     }
   }
   return returnvec;
 }
 
-Value builtin_search(Arguments arguments, const Location& loc)
-{
-  if (arguments.size() < 2 || arguments.size() > 4) {
-    print_argCnt_warning("search", arguments.size(), "between 2 and 4", loc, arguments.documentRoot());
-    return Value::undefined.clone();
+Value builtin_search (Arguments arguments, const Location &loc) {
+  if (arguments.size () < 2 || arguments.size () > 4) {
+    print_argCnt_warning ("search", arguments.size (), "between 2 and 4", loc, arguments.documentRoot ());
+    return Value::undefined.clone ();
   }
 
-  const Value& findThis = arguments[0].value;
-  const Value& searchTable = arguments[1].value;
-  unsigned int num_returns_per_match = (arguments.size() > 2) ? (unsigned int)arguments[2]->toDouble() : 1;
-  unsigned int index_col_num = (arguments.size() > 3) ? (unsigned int)arguments[3]->toDouble() : 0;
+  const Value &findThis = arguments[0].value;
+  const Value &searchTable = arguments[1].value;
+  unsigned int num_returns_per_match = (arguments.size () > 2) ? (unsigned int)arguments[2]->toDouble () : 1;
+  unsigned int index_col_num = (arguments.size () > 3) ? (unsigned int)arguments[3]->toDouble () : 0;
 
-  VectorType returnvec(arguments.session());
+  VectorType returnvec (arguments.session ());
 
-  if (findThis.type() == Value::Type::NUMBER) {
+  if (findThis.type () == Value::Type::NUMBER) {
     unsigned int matchCount = 0;
     size_t j = 0;
-    for (const auto& search_element : searchTable.toVector()) {
-      if ((index_col_num == 0 && (findThis == search_element).toBool()) ||
-          (index_col_num < search_element.toVector().size() &&
-           (findThis == search_element.toVector()[index_col_num]).toBool())) {
-        returnvec.emplace_back(double(j));
+    for (const auto &search_element : searchTable.toVector ()) {
+      if ((index_col_num == 0 && (findThis == search_element).toBool ()) ||
+          (index_col_num < search_element.toVector ().size () &&
+           (findThis == search_element.toVector ()[index_col_num]).toBool ())) {
+        returnvec.emplace_back (double (j));
         matchCount++;
-        if (num_returns_per_match != 0 && matchCount >= num_returns_per_match) break;
+        if (num_returns_per_match != 0 && matchCount >= num_returns_per_match)
+          break;
       }
       ++j;
     }
-  } else if (findThis.type() == Value::Type::STRING) {
-    if (searchTable.type() == Value::Type::STRING) {
-      returnvec = search(findThis.toStrUtf8Wrapper(), searchTable.toStrUtf8Wrapper(), num_returns_per_match, arguments.session());
+  } else if (findThis.type () == Value::Type::STRING) {
+    if (searchTable.type () == Value::Type::STRING) {
+      returnvec = search (findThis.toStrUtf8Wrapper (), searchTable.toStrUtf8Wrapper (), num_returns_per_match, arguments.session ());
     } else {
-      returnvec = search(findThis.toStrUtf8Wrapper(), searchTable.toVector(), num_returns_per_match, index_col_num, loc, arguments.session());
+      returnvec = search (findThis.toStrUtf8Wrapper (), searchTable.toVector (), num_returns_per_match, index_col_num, loc, arguments.session ());
     }
-  } else if (findThis.type() == Value::Type::VECTOR) {
-    const auto& findVec = findThis.toVector();
-    for (const auto& find_value : findVec) {
+  } else if (findThis.type () == Value::Type::VECTOR) {
+    const auto &findVec = findThis.toVector ();
+    for (const auto &find_value : findVec) {
       unsigned int matchCount = 0;
-      VectorType resultvec(arguments.session());
+      VectorType resultvec (arguments.session ());
 
       size_t j = 0;
-      for (const auto& search_element : searchTable.toVector()) {
-        if ((index_col_num == 0 && (find_value == search_element).toBool()) ||
-            (index_col_num < search_element.toVector().size() &&
-             (find_value == search_element.toVector()[index_col_num]).toBool())) {
+      for (const auto &search_element : searchTable.toVector ()) {
+        if ((index_col_num == 0 && (find_value == search_element).toBool ()) ||
+            (index_col_num < search_element.toVector ().size () &&
+             (find_value == search_element.toVector ()[index_col_num]).toBool ())) {
           matchCount++;
           if (num_returns_per_match == 1) {
-            returnvec.emplace_back(double(j));
+            returnvec.emplace_back (double (j));
             break;
           } else {
-            resultvec.emplace_back(double(j));
+            resultvec.emplace_back (double (j));
           }
-          if (num_returns_per_match > 1 && matchCount >= num_returns_per_match) break;
+          if (num_returns_per_match > 1 && matchCount >= num_returns_per_match)
+            break;
         }
         ++j;
       }
       if ((num_returns_per_match == 1 && matchCount == 0) ||
           num_returns_per_match == 0 ||
           num_returns_per_match > 1) {
-        returnvec.emplace_back(std::move(resultvec));
+        returnvec.emplace_back (std::move (resultvec));
       }
     }
   } else {
-    return Value::undefined.clone();
+    return Value::undefined.clone ();
   }
-  return std::move(returnvec);
+  return std::move (returnvec);
 }
 
-#define QUOTE(x__) # x__
-#define QUOTED(x__) QUOTE(x__)
+#define QUOTE(x__) #x__
+#define QUOTED(x__) QUOTE (x__)
 
-Value builtin_version(Arguments arguments, const Location& /*loc*/)
-{
-  VectorType vec(arguments.session());
-  vec.emplace_back(double(OPENSCAD_YEAR));
-  vec.emplace_back(double(OPENSCAD_MONTH));
+Value builtin_version (Arguments arguments, const Location & /*loc*/) {
+  VectorType vec (arguments.session ());
+  vec.emplace_back (double (OPENSCAD_YEAR));
+  vec.emplace_back (double (OPENSCAD_MONTH));
 #ifdef OPENSCAD_DAY
-  vec.emplace_back(double(OPENSCAD_DAY));
+  vec.emplace_back (double (OPENSCAD_DAY));
 #endif
-  return std::move(vec);
+  return std::move (vec);
 }
 
-Value builtin_version_num(Arguments arguments, const Location& loc)
-{
-  Value val = (arguments.size() == 0) ? builtin_version(std::move(arguments), loc) : std::move(arguments[0].value);
+Value builtin_version_num (Arguments arguments, const Location &loc) {
+  Value val = (arguments.size () == 0) ? builtin_version (std::move (arguments), loc) : std::move (arguments[0].value);
   double y, m, d;
-  if (!val.getVec3(y, m, d, 0)) {
-    return Value::undefined.clone();
+  if (!val.getVec3 (y, m, d, 0)) {
+    return Value::undefined.clone ();
   }
   return {y * 10000 + m * 100 + d};
 }
 
-Value builtin_parent_module(Arguments arguments, const Location& loc)
-{
+Value builtin_parent_module (Arguments arguments, const Location &loc) {
   double d;
-  if (arguments.size() == 0) {
+  if (arguments.size () == 0) {
     d = 1;
-  } else if (!check_arguments("parent_module", arguments, loc, { Value::Type::NUMBER })) {
-    return Value::undefined.clone();
+  } else if (!check_arguments ("parent_module", arguments, loc, {Value::Type::NUMBER})) {
+    return Value::undefined.clone ();
   } else {
-    d = arguments[0]->toDouble();
+    d = arguments[0]->toDouble ();
   }
 
-  int n = trunc(d);
-  int s = UserModule::stack_size();
+  int n = trunc (d);
+  int s = UserModule::stack_size ();
   if (n < 0) {
-    LOG(message_group::Warning, loc, arguments.documentRoot(), "Negative parent module index (%1$d) not allowed", n);
-    return Value::undefined.clone();
+    LOG (message_group::Warning, loc, arguments.documentRoot (), "Negative parent module index (%1$d) not allowed", n);
+    return Value::undefined.clone ();
   }
   if (n >= s) {
-    LOG(message_group::Warning, loc, arguments.documentRoot(), "Parent module index (%1$d) greater than the number of modules on the stack", n);
-    return Value::undefined.clone();
+    LOG (message_group::Warning, loc, arguments.documentRoot (), "Parent module index (%1$d) greater than the number of modules on the stack", n);
+    return Value::undefined.clone ();
   }
-  return {UserModule::stack_element(s - 1 - n)};
+  return {UserModule::stack_element (s - 1 - n)};
 }
 
-Value builtin_norm(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("norm", arguments, loc, { Value::Type::VECTOR })) {
-    return Value::undefined.clone();
+Value builtin_norm (Arguments arguments, const Location &loc) {
+  if (!check_arguments ("norm", arguments, loc, {Value::Type::VECTOR})) {
+    return Value::undefined.clone ();
   }
   double sum = 0;
-  for (const auto& v : arguments[0]->toVector()) {
-    if (v.type() == Value::Type::NUMBER) {
-      double x = v.toDouble();
+  for (const auto &v : arguments[0]->toVector ()) {
+    if (v.type () == Value::Type::NUMBER) {
+      double x = v.toDouble ();
       sum += x * x;
     } else {
-      LOG(message_group::Warning, loc, arguments.documentRoot(), "Incorrect arguments to norm()");
-      return Value::undefined.clone();
+      LOG (message_group::Warning, loc, arguments.documentRoot (), "Incorrect arguments to norm()");
+      return Value::undefined.clone ();
     }
   }
-  return {sqrt(sum)};
+  return {sqrt (sum)};
 }
 
-Value builtin_cross(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("cross", arguments, loc, { Value::Type::VECTOR, Value::Type::VECTOR })) {
-    return Value::undefined.clone();
+Value builtin_cross (Arguments arguments, const Location &loc) {
+  if (!check_arguments ("cross", arguments, loc, {Value::Type::VECTOR, Value::Type::VECTOR})) {
+    return Value::undefined.clone ();
   }
 
-  const auto& v0 = arguments[0]->toVector();
-  const auto& v1 = arguments[1]->toVector();
-  if ((v0.size() == 2) && (v1.size() == 2)) {
-    return {v0[0].toDouble() * v1[1].toDouble() - v0[1].toDouble() * v1[0].toDouble()};
+  const auto &v0 = arguments[0]->toVector ();
+  const auto &v1 = arguments[1]->toVector ();
+  if ((v0.size () == 2) && (v1.size () == 2)) {
+    return {v0[0].toDouble () * v1[1].toDouble () - v0[1].toDouble () * v1[0].toDouble ()};
   }
 
-  if ((v0.size() != 3) || (v1.size() != 3)) {
-    LOG(message_group::Warning, loc, arguments.documentRoot(), "Invalid vector size of parameter for cross()");
-    return Value::undefined.clone();
+  if ((v0.size () != 3) || (v1.size () != 3)) {
+    LOG (message_group::Warning, loc, arguments.documentRoot (), "Invalid vector size of parameter for cross()");
+    return Value::undefined.clone ();
   }
   for (unsigned int a = 0; a < 3; ++a) {
-    if ((v0[a].type() != Value::Type::NUMBER) || (v1[a].type() != Value::Type::NUMBER)) {
-      LOG(message_group::Warning, loc, arguments.documentRoot(), "Invalid value in parameter vector for cross()");
-      return Value::undefined.clone();
+    if ((v0[a].type () != Value::Type::NUMBER) || (v1[a].type () != Value::Type::NUMBER)) {
+      LOG (message_group::Warning, loc, arguments.documentRoot (), "Invalid value in parameter vector for cross()");
+      return Value::undefined.clone ();
     }
-    double d0 = v0[a].toDouble();
-    double d1 = v1[a].toDouble();
-    if (std::isnan(d0) || std::isnan(d1)) {
-      LOG(message_group::Warning, loc, arguments.documentRoot(), "Invalid value (NaN) in parameter vector for cross()");
-      return Value::undefined.clone();
+    double d0 = v0[a].toDouble ();
+    double d1 = v1[a].toDouble ();
+    if (std::isnan (d0) || std::isnan (d1)) {
+      LOG (message_group::Warning, loc, arguments.documentRoot (), "Invalid value (NaN) in parameter vector for cross()");
+      return Value::undefined.clone ();
     }
-    if (std::isinf(d0) || std::isinf(d1)) {
-      LOG(message_group::Warning, loc, arguments.documentRoot(), "Invalid value (INF) in parameter vector for cross()");
-      return Value::undefined.clone();
+    if (std::isinf (d0) || std::isinf (d1)) {
+      LOG (message_group::Warning, loc, arguments.documentRoot (), "Invalid value (INF) in parameter vector for cross()");
+      return Value::undefined.clone ();
     }
   }
 
-  double x = v0[1].toDouble() * v1[2].toDouble() - v0[2].toDouble() * v1[1].toDouble();
-  double y = v0[2].toDouble() * v1[0].toDouble() - v0[0].toDouble() * v1[2].toDouble();
-  double z = v0[0].toDouble() * v1[1].toDouble() - v0[1].toDouble() * v1[0].toDouble();
+  double x = v0[1].toDouble () * v1[2].toDouble () - v0[2].toDouble () * v1[1].toDouble ();
+  double y = v0[2].toDouble () * v1[0].toDouble () - v0[0].toDouble () * v1[2].toDouble ();
+  double z = v0[0].toDouble () * v1[1].toDouble () - v0[1].toDouble () * v1[0].toDouble ();
 
-  return VectorType(arguments.session(), x, y, z);
+  return VectorType (arguments.session (), x, y, z);
 }
 
-Value builtin_textmetrics(Arguments arguments, const Location& loc)
-{
-  auto *session = arguments.session();
-  Parameters parameters = Parameters::parse(std::move(arguments), loc,
-                                            { "text", "size", "font" },
-                                            { "direction", "language", "script", "halign", "valign", "spacing" }
-                                            );
-  parameters.set_caller("textmetrics");
+Value builtin_textmetrics (Arguments arguments, const Location &loc) {
+  auto *session = arguments.session ();
+  Parameters parameters = Parameters::parse (std::move (arguments), loc,
+                                             {"text", "size", "font"},
+                                             {"direction", "language", "script", "halign", "valign", "spacing"});
+  parameters.set_caller ("textmetrics");
 
   FreetypeRenderer::Params ftparams;
-  ftparams.set_loc(loc);
-  ftparams.set_documentPath(session->documentRoot());
-  ftparams.set(parameters);
-  ftparams.detect_properties();
+  ftparams.set_loc (loc);
+  ftparams.set_documentPath (session->documentRoot ());
+  ftparams.set (parameters);
+  ftparams.detect_properties ();
 
-  FreetypeRenderer::TextMetrics metrics(ftparams);
+  FreetypeRenderer::TextMetrics metrics (ftparams);
   if (!metrics.ok) {
-    return Value::undefined.clone();
+    return Value::undefined.clone ();
   }
 
   // The bounding box, ascent/descent, and offset values will be zero
   // if the text consists of nothing but whitespace.
-  VectorType bbox_pos(session);
-  bbox_pos.reserve(2);
-  bbox_pos.emplace_back(metrics.bbox_x);
-  bbox_pos.emplace_back(metrics.bbox_y);
+  VectorType bbox_pos (session);
+  bbox_pos.reserve (2);
+  bbox_pos.emplace_back (metrics.bbox_x);
+  bbox_pos.emplace_back (metrics.bbox_y);
 
-  VectorType bbox_dims(session);
-  bbox_dims.reserve(2);
-  bbox_dims.emplace_back(metrics.bbox_w);
-  bbox_dims.emplace_back(metrics.bbox_h);
+  VectorType bbox_dims (session);
+  bbox_dims.reserve (2);
+  bbox_dims.emplace_back (metrics.bbox_w);
+  bbox_dims.emplace_back (metrics.bbox_h);
 
-  VectorType offset(session);
-  offset.reserve(2);
-  offset.emplace_back(metrics.x_offset);
-  offset.emplace_back(metrics.y_offset);
+  VectorType offset (session);
+  offset.reserve (2);
+  offset.emplace_back (metrics.x_offset);
+  offset.emplace_back (metrics.y_offset);
 
   // The advance values are valid whether or not the text
   // is whitespace.
-  VectorType advance(session);
-  advance.reserve(2);
-  advance.emplace_back(metrics.advance_x);
-  advance.emplace_back(metrics.advance_y);
-
-  ObjectType text_metrics(session);
-  text_metrics.set("position", std::move(bbox_pos));
-  text_metrics.set("size", std::move(bbox_dims));
-  text_metrics.set("ascent", metrics.ascent);
-  text_metrics.set("descent", metrics.descent);
-  text_metrics.set("offset", std::move(offset));
-  text_metrics.set("advance", std::move(advance));
-  return std::move(text_metrics);
+  VectorType advance (session);
+  advance.reserve (2);
+  advance.emplace_back (metrics.advance_x);
+  advance.emplace_back (metrics.advance_y);
+
+  ObjectType text_metrics (session);
+  text_metrics.set ("position", std::move (bbox_pos));
+  text_metrics.set ("size", std::move (bbox_dims));
+  text_metrics.set ("ascent", metrics.ascent);
+  text_metrics.set ("descent", metrics.descent);
+  text_metrics.set ("offset", std::move (offset));
+  text_metrics.set ("advance", std::move (advance));
+  return std::move (text_metrics);
 }
 
-Value builtin_fontmetrics(Arguments arguments, const Location& loc)
-{
-  auto *session = arguments.session();
-  Parameters parameters = Parameters::parse(std::move(arguments), loc,
-                                            { "size", "font" }
-                                            );
-  parameters.set_caller("fontmetrics");
+Value builtin_fontmetrics (Arguments arguments, const Location &loc) {
+  auto *session = arguments.session ();
+  Parameters parameters = Parameters::parse (std::move (arguments), loc,
+                                             {"size", "font"});
+  parameters.set_caller ("fontmetrics");
 
   FreetypeRenderer::Params ftparams;
-  ftparams.set_loc(loc);
-  ftparams.set_documentPath(session->documentRoot());
-  ftparams.set(parameters);
-  ftparams.detect_properties();
+  ftparams.set_loc (loc);
+  ftparams.set_documentPath (session->documentRoot ());
+  ftparams.set (parameters);
+  ftparams.detect_properties ();
 
-  FreetypeRenderer::FontMetrics metrics(ftparams);
+  FreetypeRenderer::FontMetrics metrics (ftparams);
   if (!metrics.ok) {
-    return Value::undefined.clone();
+    return Value::undefined.clone ();
   }
 
-  ObjectType nominal(session);
-  nominal.set("ascent", metrics.nominal_ascent);
-  nominal.set("descent", metrics.nominal_descent);
+  ObjectType nominal (session);
+  nominal.set ("ascent", metrics.nominal_ascent);
+  nominal.set ("descent", metrics.nominal_descent);
 
-  ObjectType max(session);
-  max.set("ascent", metrics.max_ascent);
-  max.set("descent", metrics.max_descent);
+  ObjectType max (session);
+  max.set ("ascent", metrics.max_ascent);
+  max.set ("descent", metrics.max_descent);
 
-  ObjectType font(session);
-  font.set("family", metrics.family_name);
-  font.set("style", metrics.style_name);
+  ObjectType font (session);
+  font.set ("family", metrics.family_name);
+  font.set ("style", metrics.style_name);
 
-  ObjectType font_metrics(session);
-  font_metrics.set("nominal", nominal);
-  font_metrics.set("max", max);
-  font_metrics.set("interline", metrics.interline);
-  font_metrics.set("font", font);
+  ObjectType font_metrics (session);
+  font_metrics.set ("nominal", nominal);
+  font_metrics.set ("max", max);
+  font_metrics.set ("interline", metrics.interline);
+  font_metrics.set ("font", font);
 
-  return std::move(font_metrics);
+  return std::move (font_metrics);
 }
 
-Value builtin_is_undef(const std::shared_ptr<const Context>& context, const FunctionCall *call)
-{
-  if (call->arguments.size() != 1) {
-    print_argCnt_warning("is_undef", call->arguments.size(), "1", call->location(), context->documentRoot());
-    return Value::undefined.clone();
+Value builtin_is_undef (const std::shared_ptr<const Context> &context, const FunctionCall *call) {
+  if (call->arguments.size () != 1) {
+    print_argCnt_warning ("is_undef", call->arguments.size (), "1", call->location (), context->documentRoot ());
+    return Value::undefined.clone ();
   }
-  if (auto lookup = std::dynamic_pointer_cast<Lookup>(call->arguments[0]->getExpr())) {
-    auto result = context->try_lookup_variable(lookup->get_name());
-    return !result || result->isUndefined();
+  if (auto lookup = std::dynamic_pointer_cast<Lookup> (call->arguments[0]->getExpr ())) {
+    auto result = context->try_lookup_variable (lookup->get_name ());
+    return !result || result->isUndefined ();
   } else {
-    return call->arguments[0]->getExpr()->evaluate(context).isUndefined();
+    return call->arguments[0]->getExpr ()->evaluate (context).isUndefined ();
   }
 }
 
-Value builtin_is_list(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("is_list", arguments, loc, 1)) {
-    return Value::undefined.clone();
+Value builtin_is_list (Arguments arguments, const Location &loc) {
+  if (!check_arguments ("is_list", arguments, loc, 1)) {
+    return Value::undefined.clone ();
   }
-  return {arguments[0]->isDefinedAs(Value::Type::VECTOR)};
+  return {arguments[0]->isDefinedAs (Value::Type::VECTOR)};
 }
 
-Value builtin_is_num(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("is_num", arguments, loc, 1)) {
-    return Value::undefined.clone();
+Value builtin_is_num (Arguments arguments, const Location &loc) {
+  if (!check_arguments ("is_num", arguments, loc, 1)) {
+    return Value::undefined.clone ();
   }
-  return {arguments[0]->isDefinedAs(Value::Type::NUMBER) && !std::isnan(arguments[0]->toDouble())};
+  return {arguments[0]->isDefinedAs (Value::Type::NUMBER) && !std::isnan (arguments[0]->toDouble ())};
 }
 
-Value builtin_is_bool(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("is_bool", arguments, loc, 1)) {
-    return Value::undefined.clone();
+Value builtin_is_bool (Arguments arguments, const Location &loc) {
+  if (!check_arguments ("is_bool", arguments, loc, 1)) {
+    return Value::undefined.clone ();
   }
-  return {arguments[0]->isDefinedAs(Value::Type::BOOL)};
+  return {arguments[0]->isDefinedAs (Value::Type::BOOL)};
 }
 
-Value builtin_is_string(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("is_string", arguments, loc, 1)) {
-    return Value::undefined.clone();
+Value builtin_is_string (Arguments arguments, const Location &loc) {
+  if (!check_arguments ("is_string", arguments, loc, 1)) {
+    return Value::undefined.clone ();
   }
-  return {arguments[0]->isDefinedAs(Value::Type::STRING)};
+  return {arguments[0]->isDefinedAs (Value::Type::STRING)};
 }
 
-Value builtin_is_function(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("is_function", arguments, loc, 1)) {
-    return Value::undefined.clone();
+Value builtin_is_function (Arguments arguments, const Location &loc) {
+  if (!check_arguments ("is_function", arguments, loc, 1)) {
+    return Value::undefined.clone ();
   }
-  return {arguments[0]->isDefinedAs(Value::Type::FUNCTION)};
+  return {arguments[0]->isDefinedAs (Value::Type::FUNCTION)};
 }
 
-Value builtin_is_object(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("is_object", arguments, loc, 1)) {
-    return Value::undefined.clone();
+Value builtin_is_object (Arguments arguments, const Location &loc) {
+  if (!check_arguments ("is_object", arguments, loc, 1)) {
+    return Value::undefined.clone ();
   }
-  return {arguments[0]->isDefinedAs(Value::Type::OBJECT)};
+  return {arguments[0]->isDefinedAs (Value::Type::OBJECT)};
 }
 
-Value builtin_import(Arguments arguments, const Location& loc)
-{
-  auto session = arguments.session();
-  const Parameters parameters = Parameters::parse(std::move(arguments), loc, {}, {"file"});
-  std::string raw_filename = parameters.get("file", "");
-  std::string file = lookup_file(raw_filename, loc.filePath().parent_path().string(), parameters.documentRoot());
-  return import_json(file, session, loc);
+Value builtin_import (Arguments arguments, const Location &loc) {
+  auto session = arguments.session ();
+  const Parameters parameters = Parameters::parse (std::move (arguments), loc, {}, {"file"});
+  std::string raw_filename = parameters.get ("file", "");
+  std::string file = lookup_file (raw_filename, loc.filePath ().parent_path ().string (), parameters.documentRoot ());
+  return import_json (file, session, loc);
 }
 
-void register_builtin_functions()
-{
-  Builtins::init("abs", new BuiltinFunction(&builtin_abs),
-  {
-    "abs(number) -> number",
-  });
-
-  Builtins::init("sign", new BuiltinFunction(&builtin_sign),
-  {
-    "sign(number) -> -1, 0 or 1",
-  });
-
-  Builtins::init("rands", new BuiltinFunction(&builtin_rands),
-  {
-    "rands(min, max, num_results) -> vector",
-    "rands(min, max, num_results, seed) -> vector",
-  });
-
-  Builtins::init("min", new BuiltinFunction(&builtin_min),
-  {
-    "min(number, number, ...) -> number",
-    "min(vector) -> number",
-  });
-
-  Builtins::init("max", new BuiltinFunction(&builtin_max),
-  {
-    "max(number, number, ...) -> number",
-    "max(vector) -> number",
-  });
-
-  Builtins::init("sin", new BuiltinFunction(&builtin_sin),
-  {
-    "sin(degrees) -> number",
-  });
-
-  Builtins::init("cos", new BuiltinFunction(&builtin_cos),
-  {
-    "cos(degrees) -> number",
-  });
-
-  Builtins::init("asin", new BuiltinFunction(&builtin_asin),
-  {
-    "asin(number) -> degrees",
-  });
-
-  Builtins::init("acos", new BuiltinFunction(&builtin_acos),
-  {
-    "acos(number) -> degrees",
-  });
-
-  Builtins::init("tan", new BuiltinFunction(&builtin_tan),
-  {
-    "tan(degrees) -> number",
-  });
-
-  Builtins::init("atan", new BuiltinFunction(&builtin_atan),
-  {
-    "atan(number) -> degrees",
-  });
-
-  Builtins::init("atan2", new BuiltinFunction(&builtin_atan2),
-  {
-    "atan2(number, number) -> degrees",
-  });
-
-  Builtins::init("round", new BuiltinFunction(&builtin_round),
-  {
-    "round(number) -> number",
-  });
-
-  Builtins::init("ceil", new BuiltinFunction(&builtin_ceil),
-  {
-    "ceil(number) -> number",
-  });
-
-  Builtins::init("floor", new BuiltinFunction(&builtin_floor),
-  {
-    "floor(number) -> number",
-  });
-
-  Builtins::init("pow", new BuiltinFunction(&builtin_pow),
-  {
-    "pow(base, exponent) -> number",
-  });
-
-  Builtins::init("sqrt", new BuiltinFunction(&builtin_sqrt),
-  {
-    "sqrt(number) -> number",
-  });
-
-  Builtins::init("exp", new BuiltinFunction(&builtin_exp),
-  {
-    "exp(number) -> number",
-  });
-
-  Builtins::init("len", new BuiltinFunction(&builtin_length),
-  {
-    "len(string) -> number",
-    "len(vector) -> number",
-  });
-
-  Builtins::init("log", new BuiltinFunction(&builtin_log),
-  {
-    "log(number) -> number",
-  });
-
-  Builtins::init("ln", new BuiltinFunction(&builtin_ln),
-  {
-    "ln(number) -> number",
-  });
-
-  Builtins::init("str", new BuiltinFunction(&builtin_str),
-  {
-    "str(number or string, ...) -> string",
-  });
-
-  Builtins::init("chr", new BuiltinFunction(&builtin_chr),
-  {
-    "chr(number) -> string",
-    "chr(vector) -> string",
-    "chr(range) -> string",
-  });
-
-  Builtins::init("textmetrics",
-                 new BuiltinFunction(&builtin_textmetrics,
-                                     &Feature::ExperimentalTextMetricsFunctions),
-  {
-    "textmetrics(text, size, font, direction, language, script, halign, valign, spacing) -> object",
-  });
-
-  Builtins::init("fontmetrics",
-                 new BuiltinFunction(&builtin_fontmetrics,
-                                     &Feature::ExperimentalTextMetricsFunctions),
-  {
-    "fontmetrics(size, font) -> object",
-  });
-
-  Builtins::init("ord", new BuiltinFunction(&builtin_ord),
-  {
-    "ord(string) -> number",
-  });
-
-  Builtins::init("concat", new BuiltinFunction(&builtin_concat),
-  {
-    "concat(number or string or vector, ...) -> vector",
-  });
-
-  Builtins::init("lookup", new BuiltinFunction(&builtin_lookup),
-  {
-    "lookup(key, <key,value> vector) -> value",
-  });
-
-  Builtins::init("search", new BuiltinFunction(&builtin_search),
-  {
-    "search(string , string or vector [, num_returns_per_match [, index_col_num ] ] ) -> vector",
-  });
-
-  Builtins::init("version", new BuiltinFunction(&builtin_version),
-  {
-    "version() -> vector",
-  });
-
-  Builtins::init("version_num", new BuiltinFunction(&builtin_version_num),
-  {
-    "version_num() -> number",
-  });
-
-  Builtins::init("norm", new BuiltinFunction(&builtin_norm),
-  {
-    "norm(vector) -> number",
-  });
-
-  Builtins::init("cross", new BuiltinFunction(&builtin_cross),
-  {
-    "cross(vector, vector) -> vector",
-  });
-
-  Builtins::init("parent_module", new BuiltinFunction(&builtin_parent_module),
-  {
-    "parent_module(number) -> string",
-  });
-
-  Builtins::init("is_undef", new BuiltinFunction(&builtin_is_undef),
-  {
-    "is_undef(arg) -> boolean",
-  });
-
-  Builtins::init("is_list", new BuiltinFunction(&builtin_is_list),
-  {
-    "is_list(arg) -> boolean",
-  });
-
-  Builtins::init("is_num", new BuiltinFunction(&builtin_is_num),
-  {
-    "is_num(arg) -> boolean",
-  });
-
-  Builtins::init("is_bool", new BuiltinFunction(&builtin_is_bool),
-  {
-    "is_bool(arg) -> boolean",
-  });
-
-  Builtins::init("is_string", new BuiltinFunction(&builtin_is_string),
-  {
-    "is_string(arg) -> boolean",
-  });
-
-  Builtins::init("is_function", new BuiltinFunction(&builtin_is_function),
-  {
-    "is_function(arg) -> boolean",
-  });
-
-  Builtins::init("is_object", new BuiltinFunction(&builtin_is_object,
-                                                  &Feature::ExperimentalTextMetricsFunctions),
-  {
-    "is_object(arg) -> boolean",
-  });
-
-  Builtins::init("object", new BuiltinFunction(&builtin_object, &Feature::ExperimentalObjectFunction),
-  {
-    "object([ object, ] [ key-val list, ] key=value, ...) -> object",
-  });
-
-  Builtins::init("has_key", new BuiltinFunction(&builtin_has_key, &Feature::ExperimentalObjectFunction),
-  {
-    "has_key(object, key) -> boolean",
-  });
-
-  Builtins::init("import", new BuiltinFunction(&builtin_import, &Feature::ExperimentalImportFunction),
-  {
-    "import(file) -> object",
-  });
+void register_builtin_functions () {
+  Builtins::init ("abs", new BuiltinFunction (&builtin_abs),
+                  {
+                    "abs(number) -> number",
+                  });
+
+  Builtins::init ("sign", new BuiltinFunction (&builtin_sign),
+                  {
+                    "sign(number) -> -1, 0 or 1",
+                  });
+
+  Builtins::init ("rands", new BuiltinFunction (&builtin_rands),
+                  {
+                    "rands(min, max, num_results) -> vector",
+                    "rands(min, max, num_results, seed) -> vector",
+                  });
+
+  Builtins::init ("min", new BuiltinFunction (&builtin_min),
+                  {
+                    "min(number, number, ...) -> number",
+                    "min(vector) -> number",
+                  });
+
+  Builtins::init ("max", new BuiltinFunction (&builtin_max),
+                  {
+                    "max(number, number, ...) -> number",
+                    "max(vector) -> number",
+                  });
+
+  Builtins::init ("sin", new BuiltinFunction (&builtin_sin),
+                  {
+                    "sin(degrees) -> number",
+                  });
+
+  Builtins::init ("cos", new BuiltinFunction (&builtin_cos),
+                  {
+                    "cos(degrees) -> number",
+                  });
+
+  Builtins::init ("asin", new BuiltinFunction (&builtin_asin),
+                  {
+                    "asin(number) -> degrees",
+                  });
+
+  Builtins::init ("acos", new BuiltinFunction (&builtin_acos),
+                  {
+                    "acos(number) -> degrees",
+                  });
+
+  Builtins::init ("tan", new BuiltinFunction (&builtin_tan),
+                  {
+                    "tan(degrees) -> number",
+                  });
+
+  Builtins::init ("atan", new BuiltinFunction (&builtin_atan),
+                  {
+                    "atan(number) -> degrees",
+                  });
+
+  Builtins::init ("atan2", new BuiltinFunction (&builtin_atan2),
+                  {
+                    "atan2(number, number) -> degrees",
+                  });
+
+  Builtins::init ("round", new BuiltinFunction (&builtin_round),
+                  {
+                    "round(number) -> number",
+                  });
+
+  Builtins::init ("ceil", new BuiltinFunction (&builtin_ceil),
+                  {
+                    "ceil(number) -> number",
+                  });
+
+  Builtins::init ("floor", new BuiltinFunction (&builtin_floor),
+                  {
+                    "floor(number) -> number",
+                  });
+
+  Builtins::init ("pow", new BuiltinFunction (&builtin_pow),
+                  {
+                    "pow(base, exponent) -> number",
+                  });
+
+  Builtins::init ("sqrt", new BuiltinFunction (&builtin_sqrt),
+                  {
+                    "sqrt(number) -> number",
+                  });
+
+  Builtins::init ("exp", new BuiltinFunction (&builtin_exp),
+                  {
+                    "exp(number) -> number",
+                  });
+
+  Builtins::init ("len", new BuiltinFunction (&builtin_length),
+                  {
+                    "len(string) -> number",
+                    "len(vector) -> number",
+                  });
+
+  Builtins::init ("log", new BuiltinFunction (&builtin_log),
+                  {
+                    "log(number) -> number",
+                  });
+
+  Builtins::init ("ln", new BuiltinFunction (&builtin_ln),
+                  {
+                    "ln(number) -> number",
+                  });
+
+  Builtins::init ("str", new BuiltinFunction (&builtin_str),
+                  {
+                    "str(number or string, ...) -> string",
+                  });
+
+  Builtins::init ("chr", new BuiltinFunction (&builtin_chr),
+                  {
+                    "chr(number) -> string",
+                    "chr(vector) -> string",
+                    "chr(range) -> string",
+                  });
+
+  Builtins::init ("textmetrics",
+                  new BuiltinFunction (&builtin_textmetrics,
+                                       &Feature::ExperimentalTextMetricsFunctions),
+                  {
+                    "textmetrics(text, size, font, direction, language, script, halign, valign, spacing) -> object",
+                  });
+
+  Builtins::init ("fontmetrics",
+                  new BuiltinFunction (&builtin_fontmetrics,
+                                       &Feature::ExperimentalTextMetricsFunctions),
+                  {
+                    "fontmetrics(size, font) -> object",
+                  });
+
+  Builtins::init ("ord", new BuiltinFunction (&builtin_ord),
+                  {
+                    "ord(string) -> number",
+                  });
+
+  Builtins::init ("concat", new BuiltinFunction (&builtin_concat),
+                  {
+                    "concat(number or string or vector, ...) -> vector",
+                  });
+
+  Builtins::init ("lookup", new BuiltinFunction (&builtin_lookup),
+                  {
+                    "lookup(key, <key,value> vector) -> value",
+                  });
+
+  Builtins::init ("search", new BuiltinFunction (&builtin_search),
+                  {
+                    "search(string , string or vector [, num_returns_per_match [, index_col_num ] ] ) -> vector",
+                  });
+
+  Builtins::init ("version", new BuiltinFunction (&builtin_version),
+                  {
+                    "version() -> vector",
+                  });
+
+  Builtins::init ("version_num", new BuiltinFunction (&builtin_version_num),
+                  {
+                    "version_num() -> number",
+                  });
+
+  Builtins::init ("norm", new BuiltinFunction (&builtin_norm),
+                  {
+                    "norm(vector) -> number",
+                  });
+
+  Builtins::init ("cross", new BuiltinFunction (&builtin_cross),
+                  {
+                    "cross(vector, vector) -> vector",
+                  });
+
+  Builtins::init ("parent_module", new BuiltinFunction (&builtin_parent_module),
+                  {
+                    "parent_module(number) -> string",
+                  });
+
+  Builtins::init ("is_undef", new BuiltinFunction (&builtin_is_undef),
+                  {
+                    "is_undef(arg) -> boolean",
+                  });
+
+  Builtins::init ("is_list", new BuiltinFunction (&builtin_is_list),
+                  {
+                    "is_list(arg) -> boolean",
+                  });
+
+  Builtins::init ("is_num", new BuiltinFunction (&builtin_is_num),
+                  {
+                    "is_num(arg) -> boolean",
+                  });
+
+  Builtins::init ("is_bool", new BuiltinFunction (&builtin_is_bool),
+                  {
+                    "is_bool(arg) -> boolean",
+                  });
+
+  Builtins::init ("is_string", new BuiltinFunction (&builtin_is_string),
+                  {
+                    "is_string(arg) -> boolean",
+                  });
+
+  Builtins::init ("is_function", new BuiltinFunction (&builtin_is_function),
+                  {
+                    "is_function(arg) -> boolean",
+                  });
+
+  Builtins::init ("is_object", new BuiltinFunction (&builtin_is_object, &Feature::ExperimentalTextMetricsFunctions),
+                  {
+                    "is_object(arg) -> boolean",
+                  });
+
+  Builtins::init ("object", new BuiltinFunction (&builtin_object, &Feature::ExperimentalObjectFunction),
+                  {
+                    "object([ object, ] [ key-val list, ] key=value, ...) -> object",
+                  });
+
+  Builtins::init ("has_key", new BuiltinFunction (&builtin_has_key, &Feature::ExperimentalObjectFunction),
+                  {
+                    "has_key(object, key) -> boolean",
+                  });
+
+  Builtins::init ("import", new BuiltinFunction (&builtin_import, &Feature::ExperimentalImportFunction),
+                  {
+                    "import(file) -> object",
+                  });
 }
diff --git a/src/core/control.cc b/src/core/control.cc
index 2598f886f..a2c9d7623 100644
--- a/src/core/control.cc
+++ b/src/core/control.cc
@@ -40,253 +40,238 @@
 #include "utils/printutils.h"
 #include <cstdint>
 
-static std::shared_ptr<AbstractNode> lazyUnionNode(const ModuleInstantiation *inst)
-{
-  if (Feature::ExperimentalLazyUnion.is_enabled()) {
-    return std::make_shared<ListNode>(inst);
+static std::shared_ptr<AbstractNode> lazyUnionNode (const ModuleInstantiation *inst) {
+  if (Feature::ExperimentalLazyUnion.is_enabled ()) {
+    return std::make_shared<ListNode> (inst);
   } else {
-    return std::make_shared<GroupNode>(inst);
+    return std::make_shared<GroupNode> (inst);
   }
 }
 
-static boost::optional<size_t> validChildIndex(int n, const Children *children, const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
-  if (n < 0 || n >= static_cast<int>(children->size())) {
-    LOG(message_group::Warning, inst->location(), context->documentRoot(), "Children index (%1$d) out of bounds (%2$d children)", n, children->size());
+static boost::optional<size_t> validChildIndex (int n, const Children *children, const ModuleInstantiation *inst, const std::shared_ptr<const Context> &context) {
+  if (n < 0 || n >= static_cast<int> (children->size ())) {
+    LOG (message_group::Warning, inst->location (), context->documentRoot (), "Children index (%1$d) out of bounds (%2$d children)", n, children->size ());
     return boost::none;
   }
-  return size_t(n);
+  return size_t (n);
 }
 
-static boost::optional<size_t> validChildIndex(const Value& value, const Children *children, const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
-  if (value.type() != Value::Type::NUMBER) {
-    LOG(message_group::Warning, inst->location(), context->documentRoot(), "Bad parameter type (%1$s) for children, only accept: empty, number, vector, range.", value.toString());
+static boost::optional<size_t> validChildIndex (const Value &value, const Children *children, const ModuleInstantiation *inst, const std::shared_ptr<const Context> &context) {
+  if (value.type () != Value::Type::NUMBER) {
+    LOG (message_group::Warning, inst->location (), context->documentRoot (), "Bad parameter type (%1$s) for children, only accept: empty, number, vector, range.", value.toString ());
     return boost::none;
   }
-  return validChildIndex(static_cast<int>(value.toDouble()), children, inst, context);
+  return validChildIndex (static_cast<int> (value.toDouble ()), children, inst, context);
 }
 
-static std::shared_ptr<AbstractNode> builtin_child(const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
-  LOG(message_group::Deprecated, "child() will be removed in future releases. Use children() instead.");
+static std::shared_ptr<AbstractNode> builtin_child (const ModuleInstantiation *inst, const std::shared_ptr<const Context> &context) {
+  LOG (message_group::Deprecated, "child() will be removed in future releases. Use children() instead.");
 
   Arguments arguments{inst->arguments, context};
 
-  BuiltinModule::noChildren(inst, arguments);
+  BuiltinModule::noChildren (inst, arguments);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {}, std::vector<std::string>{"index"});
-  const Children *children = context->user_module_children();
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (), {}, std::vector<std::string>{"index"});
+  const Children *children = context->user_module_children ();
   if (!children) {
     // child() called outside any user module
     return nullptr;
   }
 
   boost::optional<size_t> index;
-  if (!parameters.contains("index")) {
-    index = validChildIndex(0, children, inst, context);
+  if (!parameters.contains ("index")) {
+    index = validChildIndex (0, children, inst, context);
   } else {
-    index = validChildIndex(parameters["index"], children, inst, context);
+    index = validChildIndex (parameters["index"], children, inst, context);
   }
   if (!index) {
     return nullptr;
   }
-  return children->instantiate(lazyUnionNode(inst), {*index});
+  return children->instantiate (lazyUnionNode (inst), {*index});
 }
 
-static std::shared_ptr<AbstractNode> builtin_children(const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
+static std::shared_ptr<AbstractNode> builtin_children (const ModuleInstantiation *inst, const std::shared_ptr<const Context> &context) {
   Arguments arguments{inst->arguments, context};
 
-  BuiltinModule::noChildren(inst, arguments);
+  BuiltinModule::noChildren (inst, arguments);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {}, std::vector<std::string>{"index"});
-  const Children *children = context->user_module_children();
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (), {}, std::vector<std::string>{"index"});
+  const Children *children = context->user_module_children ();
   if (!children) {
     // children() called outside any user module
     return nullptr;
   }
 
-  if (!parameters.contains("index")) {
+  if (!parameters.contains ("index")) {
     // no arguments => all children
-    return children->instantiate(lazyUnionNode(inst));
+    return children->instantiate (lazyUnionNode (inst));
   }
 
   // one (or more ignored) argument
-  if (parameters["index"].type() == Value::Type::NUMBER) {
-    auto index = validChildIndex(parameters["index"], children, inst, context);
+  if (parameters["index"].type () == Value::Type::NUMBER) {
+    auto index = validChildIndex (parameters["index"], children, inst, context);
     if (!index) {
       return nullptr;
     }
-    return children->instantiate(lazyUnionNode(inst), {*index});
-  } else if (parameters["index"].type() == Value::Type::VECTOR) {
+    return children->instantiate (lazyUnionNode (inst), {*index});
+  } else if (parameters["index"].type () == Value::Type::VECTOR) {
     std::vector<size_t> indices;
-    for (const auto& val : parameters["index"].toVector()) {
-      auto index = validChildIndex(val, children, inst, context);
+    for (const auto &val : parameters["index"].toVector ()) {
+      auto index = validChildIndex (val, children, inst, context);
       if (index) {
-        indices.push_back(*index);
+        indices.push_back (*index);
       }
     }
-    return children->instantiate(lazyUnionNode(inst), indices);
-  } else if (parameters["index"].type() == Value::Type::RANGE) {
-    const RangeType& range = parameters["index"].toRange();
-    uint32_t steps = range.numValues();
+    return children->instantiate (lazyUnionNode (inst), indices);
+  } else if (parameters["index"].type () == Value::Type::RANGE) {
+    const RangeType &range = parameters["index"].toRange ();
+    uint32_t steps = range.numValues ();
     if (steps >= RangeType::MAX_RANGE_STEPS) {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
-          "Bad range parameter for children: too many elements (%1$lu)", steps);
+      LOG (message_group::Warning, inst->location (), parameters.documentRoot (),
+           "Bad range parameter for children: too many elements (%1$lu)", steps);
       return nullptr;
     }
     std::vector<size_t> indices;
     for (double d : range) {
-      auto index = validChildIndex(static_cast<int>(d), children, inst, context);
+      auto index = validChildIndex (static_cast<int> (d), children, inst, context);
       if (index) {
-        indices.push_back(*index);
+        indices.push_back (*index);
       }
     }
-    return children->instantiate(lazyUnionNode(inst), indices);
+    return children->instantiate (lazyUnionNode (inst), indices);
   } else {
     // Invalid argument
-    LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Bad parameter type (%1$s) for children, only accept: empty, number, vector, range", parameters["index"].toEchoStringNoThrow());
+    LOG (message_group::Warning, inst->location (), parameters.documentRoot (), "Bad parameter type (%1$s) for children, only accept: empty, number, vector, range", parameters["index"].toEchoStringNoThrow ());
     return {};
   }
 }
 
-static std::shared_ptr<AbstractNode> builtin_echo(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  LOG(message_group::Echo, "%1$s", STR(arguments));
+static std::shared_ptr<AbstractNode> builtin_echo (const ModuleInstantiation *inst, Arguments arguments, const Children &children) {
+  LOG (message_group::Echo, "%1$s", STR (arguments));
 
-  auto node = children.instantiate(lazyUnionNode(inst));
+  auto node = children.instantiate (lazyUnionNode (inst));
   // echo without child geometries should not count as valid CSGNode
-  if (node->children.empty()) {
+  if (node->children.empty ()) {
     return {};
   }
   return node;
 }
 
-static std::shared_ptr<AbstractNode> builtin_assert(const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
-  Assert::performAssert(inst->arguments, inst->location(), context);
+static std::shared_ptr<AbstractNode> builtin_assert (const ModuleInstantiation *inst, const std::shared_ptr<const Context> &context) {
+  Assert::performAssert (inst->arguments, inst->location (), context);
 
-  auto node = Children(&inst->scope, context).instantiate(lazyUnionNode(inst));
+  auto node = Children (&inst->scope, context).instantiate (lazyUnionNode (inst));
   // assert without child geometries should not count as valid CSGNode
-  if (node->children.empty()) {
+  if (node->children.empty ()) {
     return {};
   }
   return node;
 }
 
-static std::shared_ptr<AbstractNode> builtin_let(const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
-  return Children(&inst->scope, *Let::sequentialAssignmentContext(inst->arguments, inst->location(), context)).instantiate(lazyUnionNode(inst));
+static std::shared_ptr<AbstractNode> builtin_let (const ModuleInstantiation *inst, const std::shared_ptr<const Context> &context) {
+  return Children (&inst->scope, *Let::sequentialAssignmentContext (inst->arguments, inst->location (), context)).instantiate (lazyUnionNode (inst));
 }
 
-static std::shared_ptr<AbstractNode> builtin_assign(const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
+static std::shared_ptr<AbstractNode> builtin_assign (const ModuleInstantiation *inst, const std::shared_ptr<const Context> &context) {
   // We create a new context to avoid arguments from influencing each other
   // -> parallel evaluation. This is to be backwards compatible.
   Arguments arguments{inst->arguments, context};
-  ContextHandle<Context> assignContext{Context::create<Context>(context)};
-  for (auto& argument : arguments) {
+  ContextHandle<Context> assignContext{Context::create<Context> (context)};
+  for (auto &argument : arguments) {
     if (!argument.name) {
-      LOG(message_group::Warning, inst->location(), context->documentRoot(), "Assignment without variable name %1$s", argument->toEchoStringNoThrow());
+      LOG (message_group::Warning, inst->location (), context->documentRoot (), "Assignment without variable name %1$s", argument->toEchoStringNoThrow ());
     } else {
-      if (assignContext->lookup_local_variable(*argument.name)) {
+      if (assignContext->lookup_local_variable (*argument.name)) {
         // TODO Should maybe quote the entire assignment with a new quoteExpr() or quoteStmt().
-        LOG(message_group::Warning, inst->location(), context->documentRoot(), "Duplicate variable assignment %1$s = %2$s", quoteVar(*argument.name), argument->toEchoStringNoThrow());
+        LOG (message_group::Warning, inst->location (), context->documentRoot (), "Duplicate variable assignment %1$s = %2$s", quoteVar (*argument.name), argument->toEchoStringNoThrow ());
       }
-      assignContext->set_variable(*argument.name, std::move(argument.value));
+      assignContext->set_variable (*argument.name, std::move (argument.value));
     }
   }
 
-  return Children(&inst->scope, *assignContext).instantiate(lazyUnionNode(inst));
+  return Children (&inst->scope, *assignContext).instantiate (lazyUnionNode (inst));
 }
 
-static std::shared_ptr<AbstractNode> builtin_for(const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
-  auto node = lazyUnionNode(inst);
-  if (!inst->arguments.empty()) {
-    LcFor::forEach(inst->arguments, inst->location(), context,
-                   [inst, node] (const std::shared_ptr<const Context>& iterationContext) {
-      Children(&inst->scope, iterationContext).instantiate(node);
-    }
-                   );
+static std::shared_ptr<AbstractNode> builtin_for (const ModuleInstantiation *inst, const std::shared_ptr<const Context> &context) {
+  auto node = lazyUnionNode (inst);
+  if (!inst->arguments.empty ()) {
+    LcFor::forEach (inst->arguments, inst->location (), context,
+                    [inst, node] (const std::shared_ptr<const Context> &iterationContext) {
+                      Children (&inst->scope, iterationContext).instantiate (node);
+                    });
   }
   return node;
 }
 
-static std::shared_ptr<AbstractNode> builtin_intersection_for(const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
-  auto node = std::make_shared<AbstractIntersectionNode>(inst);
-  if (!inst->arguments.empty()) {
-    LcFor::forEach(inst->arguments, inst->location(), context,
-                   [inst, node] (const std::shared_ptr<const Context>& iterationContext) {
-      Children(&inst->scope, iterationContext).instantiate(node);
-    }
-                   );
+static std::shared_ptr<AbstractNode> builtin_intersection_for (const ModuleInstantiation *inst, const std::shared_ptr<const Context> &context) {
+  auto node = std::make_shared<AbstractIntersectionNode> (inst);
+  if (!inst->arguments.empty ()) {
+    LcFor::forEach (inst->arguments, inst->location (), context,
+                    [inst, node] (const std::shared_ptr<const Context> &iterationContext) {
+                      Children (&inst->scope, iterationContext).instantiate (node);
+                    });
   }
   return node;
 }
 
-static std::shared_ptr<AbstractNode> builtin_if(const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
+static std::shared_ptr<AbstractNode> builtin_if (const ModuleInstantiation *inst, const std::shared_ptr<const Context> &context) {
   Arguments arguments{inst->arguments, context};
-  const auto *ifelse = dynamic_cast<const IfElseModuleInstantiation *>(inst);
-  if (arguments.size() > 0 && arguments[0]->toBool()) {
-    return Children(&inst->scope, context).instantiate(lazyUnionNode(inst));
-  } else if (ifelse->getElseScope()) {
-    return Children(ifelse->getElseScope(), context).instantiate(lazyUnionNode(inst));
+  const auto *ifelse = dynamic_cast<const IfElseModuleInstantiation *> (inst);
+  if (arguments.size () > 0 && arguments[0]->toBool ()) {
+    return Children (&inst->scope, context).instantiate (lazyUnionNode (inst));
+  } else if (ifelse->getElseScope ()) {
+    return Children (ifelse->getElseScope (), context).instantiate (lazyUnionNode (inst));
   } else {
     // "if" with failed condition, and no "else" should not count as valid CSGNode
     return nullptr;
   }
 }
 
-void register_builtin_control()
-{
-  Builtins::init("assign", new BuiltinModule(builtin_assign));
-  Builtins::init("child", new BuiltinModule(builtin_child));
-
-  Builtins::init("children", new BuiltinModule(builtin_children),
-  {
-    "children()",
-    "children(number)",
-    "children([start : step : end])",
-    "children([start : end])",
-    "children([vector])",
-  });
-
-  Builtins::init("echo", new BuiltinModule(builtin_echo),
-  {
-    "echo(arg, ...)",
-  });
-
-  Builtins::init("assert", new BuiltinModule(builtin_assert),
-  {
-    "assert(boolean)",
-    "assert(boolean, string)",
-  });
-
-  Builtins::init("for", new BuiltinModule(builtin_for),
-  {
-    "for([start : increment : end])",
-    "for([start : end])",
-    "for([vector])",
-  });
-
-  Builtins::init("let", new BuiltinModule(builtin_let),
-  {
-    "let(arg, ...) expression",
-  });
-
-  Builtins::init("intersection_for", new BuiltinModule(builtin_intersection_for),
-  {
-    "intersection_for([start : increment : end])",
-    "intersection_for([start : end])",
-    "intersection_for([vector])",
-  });
-
-  Builtins::init("if", new BuiltinModule(builtin_if),
-  {
-    "if(boolean)",
-  });
+void register_builtin_control () {
+  Builtins::init ("assign", new BuiltinModule (builtin_assign));
+  Builtins::init ("child", new BuiltinModule (builtin_child));
+
+  Builtins::init ("children", new BuiltinModule (builtin_children),
+                  {
+                    "children()",
+                    "children(number)",
+                    "children([start : step : end])",
+                    "children([start : end])",
+                    "children([vector])",
+                  });
+
+  Builtins::init ("echo", new BuiltinModule (builtin_echo),
+                  {
+                    "echo(arg, ...)",
+                  });
+
+  Builtins::init ("assert", new BuiltinModule (builtin_assert),
+                  {
+                    "assert(boolean)",
+                    "assert(boolean, string)",
+                  });
+
+  Builtins::init ("for", new BuiltinModule (builtin_for),
+                  {
+                    "for([start : increment : end])",
+                    "for([start : end])",
+                    "for([vector])",
+                  });
+
+  Builtins::init ("let", new BuiltinModule (builtin_let),
+                  {
+                    "let(arg, ...) expression",
+                  });
+
+  Builtins::init ("intersection_for", new BuiltinModule (builtin_intersection_for),
+                  {
+                    "intersection_for([start : increment : end])",
+                    "intersection_for([start : end])",
+                    "intersection_for([vector])",
+                  });
+
+  Builtins::init ("if", new BuiltinModule (builtin_if),
+                  {
+                    "if(boolean)",
+                  });
 }
diff --git a/src/core/customizer/Annotation.cc b/src/core/customizer/Annotation.cc
index d8b953414..203fbadbd 100644
--- a/src/core/customizer/Annotation.cc
+++ b/src/core/customizer/Annotation.cc
@@ -24,7 +24,6 @@
  *
  */
 
-
 #include "core/customizer/Annotation.h"
 
 #include <ostream>
@@ -34,12 +33,11 @@
 
 #include "core/Expression.h"
 
-Annotation::Annotation(std::string name, std::shared_ptr<Expression> expr)
-  : name(std::move(name)), expr(std::move(expr))
-{
+Annotation::Annotation (std::string name, std::shared_ptr<Expression> expr)
+  : name (std::move (name))
+  , expr (std::move (expr)) {
 }
 
-void Annotation::print(std::ostream& stream, const std::string& indent) const
-{
+void Annotation::print (std::ostream &stream, const std::string &indent) const {
   stream << indent << "//" << name << "(" << *this->expr << ")" << std::endl;
 }
diff --git a/src/core/customizer/Annotation.h b/src/core/customizer/Annotation.h
index 290c5626b..71dca655a 100644
--- a/src/core/customizer/Annotation.h
+++ b/src/core/customizer/Annotation.h
@@ -9,11 +9,15 @@
 class Annotation
 {
 public:
-  Annotation(std::string name, std::shared_ptr<class Expression> expr);
+  Annotation (std::string name, std::shared_ptr<class Expression> expr);
 
-  void print(std::ostream& stream, const std::string& indent) const;
-  [[nodiscard]] const std::string& getName() const { return name; }
-  [[nodiscard]] const std::shared_ptr<Expression>& getExpr() const { return expr; }
+  void print (std::ostream &stream, const std::string &indent) const;
+  [[nodiscard]] const std::string &getName () const {
+    return name;
+  }
+  [[nodiscard]] const std::shared_ptr<Expression> &getExpr () const {
+    return expr;
+  }
 
 private:
   std::string name;
diff --git a/src/core/customizer/CommentParser.cc b/src/core/customizer/CommentParser.cc
index d06545f5c..16c7b2200 100644
--- a/src/core/customizer/CommentParser.cc
+++ b/src/core/customizer/CommentParser.cc
@@ -25,10 +25,10 @@ using GroupList = std::vector<GroupInfo>;
 
  */
 
-static int getLineToStop(const std::string& fulltext){
+static int getLineToStop (const std::string &fulltext) {
   int lineNo = 1;
   bool inString = false;
-  for (unsigned int i = 0; i < fulltext.length(); ++i) {
+  for (unsigned int i = 0; i < fulltext.length (); ++i) {
     // increase line number
     if (fulltext[i] == '\n') {
       lineNo++;
@@ -36,7 +36,7 @@ static int getLineToStop(const std::string& fulltext){
     }
 
     // skip escaped quotes inside strings
-    if (inString && fulltext.compare(i, 2, "\\\"") == 0) {
+    if (inString && fulltext.compare (i, 2, "\\\"") == 0) {
       i++;
       continue;
     }
@@ -47,23 +47,24 @@ static int getLineToStop(const std::string& fulltext){
       continue;
     }
 
-    if (!inString && fulltext.compare(i, 2, "//") == 0) {
+    if (!inString && fulltext.compare (i, 2, "//") == 0) {
       i++;
-      while (i < fulltext.length() && fulltext[i] != '\n') i++;
+      while (i < fulltext.length () && fulltext[i] != '\n')
+        i++;
       lineNo++;
       continue;
     }
 
     //start of multi line comment if check is true
-    if (!inString && fulltext.compare(i, 2, "/*") == 0) {
+    if (!inString && fulltext.compare (i, 2, "/*") == 0) {
       i++;
-      if (i < fulltext.length()) {
+      if (i < fulltext.length ()) {
         i++;
       } else {
         continue;
       }
       // till */ every character is comment
-      while (fulltext.compare(i, 2, "*/") != 0 && i < fulltext.length()) {
+      while (fulltext.compare (i, 2, "*/") != 0 && i < fulltext.length ()) {
         if (fulltext[i] == '\n') {
           lineNo++;
         }
@@ -71,54 +72,61 @@ static int getLineToStop(const std::string& fulltext){
       }
     }
 
-    if (i < fulltext.length() && fulltext[i] == '{') {
+    if (i < fulltext.length () && fulltext[i] == '{') {
       return lineNo;
     }
   }
   return lineNo;
 }
 
-
 /*
    Finds the given line in the given source code text, and
    extracts the comment (excluding the "//" prefix)
  */
-static std::string getComment(const std::string& fulltext, int line)
-{
-  if (line < 1) return "";
+static std::string getComment (const std::string &fulltext, int line) {
+  if (line < 1)
+    return "";
 
   // Locate line
   std::size_t start = 0;
-  for (; start < fulltext.length(); ++start) {
-    if (line <= 1) break;
-    if (fulltext[start] == '\n') line--;
+  for (; start < fulltext.length (); ++start) {
+    if (line <= 1)
+      break;
+    if (fulltext[start] == '\n')
+      line--;
   }
 
   std::size_t end = start + 1;
-  while (end < fulltext.size() && fulltext[end] != '\n') end++;
+  while (end < fulltext.size () && fulltext[end] != '\n')
+    end++;
 
-  std::string comment = fulltext.substr(start, end - start);
+  std::string comment = fulltext.substr (start, end - start);
 
   // Locate comment
   unsigned int startText = 0;
   int noOfSemicolon = 0;
   bool inString = false;
-  for (; startText < comment.length() - 1; ++startText) {
-    if (inString && comment.compare(startText, 2, "\\\"") == 0) {
+  for (; startText < comment.length () - 1; ++startText) {
+    if (inString && comment.compare (startText, 2, "\\\"") == 0) {
       startText++;
       continue;
     }
-    if (comment[startText] == '"') inString = !inString;
+    if (comment[startText] == '"')
+      inString = !inString;
     if (!inString) {
-      if (comment.compare(startText, 2, "//") == 0) break;
-      if (comment[startText] == ';' && noOfSemicolon > 0) return "";
-      if (comment[startText] == ';') noOfSemicolon++;
+      if (comment.compare (startText, 2, "//") == 0)
+        break;
+      if (comment[startText] == ';' && noOfSemicolon > 0)
+        return "";
+      if (comment[startText] == ';')
+        noOfSemicolon++;
     }
   }
 
-  if (startText + 2 > comment.length()) return "";
+  if (startText + 2 > comment.length ())
+    return "";
 
-  std::string result = comment.substr(startText + 2);
+  std::string result = comment.substr (startText + 2);
   return result;
 }
 
@@ -126,30 +134,34 @@ static std::string getComment(const std::string& fulltext, int line)
    Extracts a parameter description from comment on the given line.
    Returns description, without any "//"
  */
-static std::string getDescription(const std::string& fulltext, int line)
-{
-  if (line < 1) return "";
+static std::string getDescription (const std::string &fulltext, int line) {
+  if (line < 1)
+    return "";
 
   unsigned int start = 0;
-  for (; start < fulltext.length(); ++start) {
-    if (line <= 1) break;
-    if (fulltext[start] == '\n') line--;
+  for (; start < fulltext.length (); ++start) {
+    if (line <= 1)
+      break;
+    if (fulltext[start] == '\n')
+      line--;
   }
 
   // not a valid description
-  if (fulltext.compare(start, 2, "//") != 0) return "";
+  if (fulltext.compare (start, 2, "//") != 0)
+    return "";
 
   // Jump over the two forward slashes
   start = start + 2;
 
   //Jump over all the spaces
-  while (fulltext[start] == ' ' || fulltext[start] == '\t') start++;
+  while (fulltext[start] == ' ' || fulltext[start] == '\t')
+    start++;
   std::string retString = "";
 
   // go till the end of the line
   while (fulltext[start] != '\n') {
     // replace // with space
-    if (fulltext.compare(start, 2, "//") == 0) {
+    if (fulltext.compare (start, 2, "//") == 0) {
       retString += " ";
       start++;
     } else {
@@ -163,24 +175,23 @@ static std::string getDescription(const std::string& fulltext, int line)
 /*
    Create groups by parsing the multi line comment provided
  */
-static GroupInfo createGroup(std::string comment, int lineNo)
-{
+static GroupInfo createGroup (std::string comment, int lineNo) {
   //store info related to group
   GroupInfo groupInfo;
   std::string finalGroupName;
 
-  boost::regex regex("\\[(.*?)\\]");
+  boost::regex regex ("\\[(.*?)\\]");
   boost::match_results<std::string::const_iterator> match;
-  while (boost::regex_search(comment, match, regex)) {
-    std::string groupName = match[1].str();
-    if (finalGroupName.empty()) {
+  while (boost::regex_search (comment, match, regex)) {
+    std::string groupName = match[1].str ();
+    if (finalGroupName.empty ()) {
       finalGroupName = groupName;
     } else {
-      finalGroupName.push_back('-');
-      finalGroupName.append(groupName);
+      finalGroupName.push_back ('-');
+      finalGroupName.append (groupName);
     }
-    groupName.clear();
-    comment = match.suffix();
+    groupName.clear ();
+    comment = match.suffix ();
   }
 
   groupInfo.commentString = finalGroupName;
@@ -188,19 +199,17 @@ static GroupInfo createGroup(std::string comment, int lineNo)
   return groupInfo;
 }
 
-
 /*
    This function collect all groups of parameters described in the
    scad file.
  */
-static GroupList collectGroups(const std::string& fulltext)
-{
+static GroupList collectGroups (const std::string &fulltext) {
   GroupList groupList; // container of all group names
   int lineNo = 1; // tracks line number
   bool inString = false; // check if its string or (line-) comment
 
   // iterate through whole scad file
-  for (unsigned int i = 0; i < fulltext.length(); ++i) {
+  for (unsigned int i = 0; i < fulltext.length (); ++i) {
     // increase line number
     if (fulltext[i] == '\n') {
       lineNo++;
@@ -208,7 +217,7 @@ static GroupList collectGroups(const std::string& fulltext)
     }
 
     // skip escaped quotes inside strings
-    if (inString && fulltext.compare(i, 2, "\\\"") == 0) {
+    if (inString && fulltext.compare (i, 2, "\\\"") == 0) {
       i++;
       continue;
     }
@@ -219,26 +228,27 @@ static GroupList collectGroups(const std::string& fulltext)
       continue;
     }
 
-    if (!inString && fulltext.compare(i, 2, "//") == 0) {
+    if (!inString && fulltext.compare (i, 2, "//") == 0) {
       i++;
-      while (i < fulltext.length() && fulltext[i] != '\n') i++;
+      while (i < fulltext.length () && fulltext[i] != '\n')
+        i++;
       lineNo++;
       continue;
     }
 
     //start of multi line comment if check is true
-    if (!inString && fulltext.compare(i, 2, "/*") == 0) {
+    if (!inString && fulltext.compare (i, 2, "/*") == 0) {
       //store comment
       std::string comment;
       i++;
-      if (i < fulltext.length()) {
+      if (i < fulltext.length ()) {
         i++;
       } else {
         continue;
       }
       bool isGroup = true;
       // till */ every character is comment
-      while (fulltext.compare(i, 2, "*/") != 0 && i < fulltext.length()) {
+      while (fulltext.compare (i, 2, "*/") != 0 && i < fulltext.length ()) {
         if (fulltext[i] == '\n') {
           lineNo++;
           isGroup = false;
@@ -247,74 +257,72 @@ static GroupList collectGroups(const std::string& fulltext)
         i++;
       }
 
-      if (isGroup) groupList.push_back(createGroup(comment, lineNo));
+      if (isGroup)
+        groupList.push_back (createGroup (comment, lineNo));
     }
   }
   return groupList;
 }
 
-
-
 /*!
    Insert Parameters in AST of given scad file
    form of annotations
  */
-void CommentParser::collectParameters(const std::string& fulltext, SourceFile *root_file)
-{
-  static auto EmptyStringLiteral(std::make_shared<Literal>(""));
+void CommentParser::collectParameters (const std::string &fulltext, SourceFile *root_file) {
+  static auto EmptyStringLiteral (std::make_shared<Literal> (""));
 
   // Get all groups of parameters
-  GroupList groupList = collectGroups(fulltext);
-  int parseTill = getLineToStop(fulltext);
+  GroupList groupList = collectGroups (fulltext);
+  int parseTill = getLineToStop (fulltext);
   // Extract parameters for all literal assignments
-  for (auto& assignment : root_file->scope.assignments) {
-    if (!assignment->getExpr()->isLiteral()) continue; // Only consider literals
+  for (auto &assignment : root_file->scope.assignments) {
+    if (!assignment->getExpr ()->isLiteral ())
+      continue; // Only consider literals
 
     // get location of assignment node
-    auto firstLocation = assignment->location();
-    auto overwriteLocation = assignment->locationOfOverwrite();
-    auto location = overwriteLocation.isNone() ? firstLocation : overwriteLocation;
-
-    int firstLine = location.firstLine();
-    if (firstLine >= parseTill || (
-          location.fileName() != "" &&
-          location.fileName() != root_file->getFilename() &&
-          location.fileName() != root_file->getFullpath()
-          )) {
+    auto firstLocation = assignment->location ();
+    auto overwriteLocation = assignment->locationOfOverwrite ();
+    auto location = overwriteLocation.isNone () ? firstLocation : overwriteLocation;
+
+    int firstLine = location.firstLine ();
+    if (firstLine >= parseTill || (location.fileName () != "" &&
+                                   location.fileName () != root_file->getFilename () &&
+                                   location.fileName () != root_file->getFullpath ())) {
       continue;
     }
     // making list to add annotations
-    auto *annotationList = new AnnotationList();
+    auto *annotationList = new AnnotationList ();
 
     // Extracting the parameter comment
     std::shared_ptr<Expression> params;
-    std::string comment = getComment(fulltext, firstLine);
-    if (comment.length() > 0) { // don't parse what doesn't exist, so we don't get bogus errors from the parser
+    std::string comment = getComment (fulltext, firstLine);
+    if (comment.length () > 0) { // don't parse what doesn't exist, so we don't get bogus errors from the parser
       // getting the node for parameter annotation
-      params = CommentParser::parser(comment.c_str());
+      params = CommentParser::parser (comment.c_str ());
     }
-    if (!params) params = EmptyStringLiteral;
+    if (!params)
+      params = EmptyStringLiteral;
 
     // adding parameter to the list
-    annotationList->push_back(Annotation("Parameter", params));
+    annotationList->push_back (Annotation ("Parameter", params));
 
     //extracting the description
-    std::string descr = getDescription(fulltext, firstLine - 1);
+    std::string descr = getDescription (fulltext, firstLine - 1);
     if (descr != "") {
       //creating node for description
-      std::shared_ptr<Expression> expr(new Literal(descr));
-      annotationList->push_back(Annotation("Description", expr));
+      std::shared_ptr<Expression> expr (new Literal (descr));
+      annotationList->push_back (Annotation ("Description", expr));
     }
 
     // Look for the group to which the given assignment belong
-    for (const auto& groupInfo :boost::adaptors::reverse(groupList)) {
+    for (const auto &groupInfo : boost::adaptors::reverse (groupList)) {
       if (groupInfo.lineNo < firstLine) {
         //creating node for description
-        std::shared_ptr<Expression> expr(new Literal(groupInfo.commentString));
-        annotationList->push_back(Annotation("Group", expr));
+        std::shared_ptr<Expression> expr (new Literal (groupInfo.commentString));
+        annotationList->push_back (Annotation ("Group", expr));
         break;
       }
     }
-    assignment->addAnnotations(annotationList);
+    assignment->addAnnotations (annotationList);
   }
 }
diff --git a/src/core/customizer/CommentParser.h b/src/core/customizer/CommentParser.h
index 25cdea291..2947a483f 100644
--- a/src/core/customizer/CommentParser.h
+++ b/src/core/customizer/CommentParser.h
@@ -7,7 +7,7 @@
 
 namespace CommentParser {
 
-std::shared_ptr<Expression> parser(const char *text);
-void collectParameters(const std::string& fulltext, SourceFile *root_file);
+std::shared_ptr<Expression> parser (const char *text);
+void collectParameters (const std::string &fulltext, SourceFile *root_file);
 
-}
+} // namespace CommentParser
diff --git a/src/core/customizer/ParameterObject.cc b/src/core/customizer/ParameterObject.cc
index 44cba56f4..7199695ab 100644
--- a/src/core/customizer/ParameterObject.cc
+++ b/src/core/customizer/ParameterObject.cc
@@ -18,24 +18,22 @@
 
 namespace {
 
-bool set_enum_value(json& o, const std::string& name, const EnumParameter::EnumItem& item)
-{
+bool set_enum_value (json &o, const std::string &name, const EnumParameter::EnumItem &item) {
   EnumParameter::EnumValue itemValue = item.value;
-  double *doubleValue = std::get_if<double>(&itemValue);
+  double *doubleValue = std::get_if<double> (&itemValue);
   if (doubleValue) {
     o[name] = *doubleValue;
     return true;
   } else {
-    o[name] = std::get<std::string>(itemValue);
+    o[name] = std::get<std::string> (itemValue);
     return false;
   }
 }
 
-}
+} // namespace
 
-bool BoolParameter::importValue(boost::property_tree::ptree encodedValue, bool store)
-{
-  boost::optional<bool> decoded = encodedValue.get_value_optional<bool>();
+bool BoolParameter::importValue (boost::property_tree::ptree encodedValue, bool store) {
+  boost::optional<bool> decoded = encodedValue.get_value_optional<bool> ();
   if (!decoded) {
     return false;
   }
@@ -45,77 +43,68 @@ bool BoolParameter::importValue(boost::property_tree::ptree encodedValue, bool s
   return true;
 }
 
-boost::property_tree::ptree BoolParameter::exportValue() const
-{
+boost::property_tree::ptree BoolParameter::exportValue () const {
   boost::property_tree::ptree output;
-  output.put_value<bool>(value);
+  output.put_value<bool> (value);
   return output;
 }
 
-json BoolParameter::jsonValue() const
-{
+json BoolParameter::jsonValue () const {
   json o;
   o["type"] = "boolean";
   o["initial"] = defaultValue;
   return o;
 }
 
-void BoolParameter::apply(Assignment *assignment) const
-{
-  assignment->setExpr(std::make_shared<Literal>(value));
+void BoolParameter::apply (Assignment *assignment) const {
+  assignment->setExpr (std::make_shared<Literal> (value));
 }
 
-StringParameter::StringParameter(
-  const std::string& name, const std::string& description, const std::string& group,
-  const std::string& defaultValue,
-  boost::optional<size_t> maximumSize
-  ) :
-  ParameterObject(name, description, group, ParameterObject::ParameterType::String),
-  value(defaultValue), defaultValue(defaultValue),
-  maximumSize(maximumSize)
-{
-  if (maximumSize && defaultValue.size() > *maximumSize) {
-    maximumSize = defaultValue.size();
+StringParameter::StringParameter (
+  const std::string &name, const std::string &description, const std::string &group,
+  const std::string &defaultValue,
+  boost::optional<size_t> maximumSize)
+  : ParameterObject (name, description, group, ParameterObject::ParameterType::String)
+  , value (defaultValue)
+  , defaultValue (defaultValue)
+  , maximumSize (maximumSize) {
+  if (maximumSize && defaultValue.size () > *maximumSize) {
+    maximumSize = defaultValue.size ();
   }
 }
 
-bool StringParameter::importValue(boost::property_tree::ptree encodedValue, bool store)
-{
+bool StringParameter::importValue (boost::property_tree::ptree encodedValue, bool store) {
   if (store) {
-    value = encodedValue.data();
-    if (maximumSize && value.size() > *maximumSize) {
-      value = value.substr(0, *maximumSize);
+    value = encodedValue.data ();
+    if (maximumSize && value.size () > *maximumSize) {
+      value = value.substr (0, *maximumSize);
     }
   }
   return true;
 }
 
-boost::property_tree::ptree StringParameter::exportValue() const
-{
+boost::property_tree::ptree StringParameter::exportValue () const {
   boost::property_tree::ptree output;
-  output.data() = value;
+  output.data () = value;
   return output;
 }
 
-json StringParameter::jsonValue() const
-{
+json StringParameter::jsonValue () const {
   json o;
   o["type"] = "string";
   o["initial"] = defaultValue;
-  if (maximumSize.is_initialized()) {
-    o["maxLength"] = maximumSize.get();
+  if (maximumSize.is_initialized ()) {
+    o["maxLength"] = maximumSize.get ();
   }
   return o;
 }
 
-void StringParameter::apply(Assignment *assignment) const
-{
-  assignment->setExpr(std::make_shared<Literal>(value));
+void StringParameter::apply (Assignment *assignment) const {
+  assignment->setExpr (std::make_shared<Literal> (value));
 }
 
-bool NumberParameter::importValue(boost::property_tree::ptree encodedValue, bool store)
-{
-  boost::optional<double> decoded = encodedValue.get_value_optional<double>();
+bool NumberParameter::importValue (boost::property_tree::ptree encodedValue, bool store) {
+  boost::optional<double> decoded = encodedValue.get_value_optional<double> ();
   if (!decoded) {
     return false;
   }
@@ -131,64 +120,60 @@ bool NumberParameter::importValue(boost::property_tree::ptree encodedValue, bool
   return true;
 }
 
-boost::property_tree::ptree NumberParameter::exportValue() const
-{
+boost::property_tree::ptree NumberParameter::exportValue () const {
   boost::property_tree::ptree output;
-  output.put_value<double>(value);
+  output.put_value<double> (value);
   return output;
 }
 
-json NumberParameter::jsonValue() const
-{
+json NumberParameter::jsonValue () const {
   json o;
   o["type"] = "number";
   o["initial"] = defaultValue;
 
-  if (maximum.is_initialized()) {
-    o["max"] = maximum.get();
-    o["min"] = minimum.is_initialized() ? minimum.get() : 0.0;
-    o["step"] = step.is_initialized() ? step.get() : 1.0;
+  if (maximum.is_initialized ()) {
+    o["max"] = maximum.get ();
+    o["min"] = minimum.is_initialized () ? minimum.get () : 0.0;
+    o["step"] = step.is_initialized () ? step.get () : 1.0;
   }
   return o;
 }
 
-void NumberParameter::apply(Assignment *assignment) const
-{
-  assignment->setExpr(std::make_shared<Literal>(value));
+void NumberParameter::apply (Assignment *assignment) const {
+  assignment->setExpr (std::make_shared<Literal> (value));
 }
 
-bool VectorParameter::importValue(boost::property_tree::ptree encodedValue, bool store)
-{
+bool VectorParameter::importValue (boost::property_tree::ptree encodedValue, bool store) {
   std::vector<double> decoded;
 
   // NOLINTBEGIN(*NewDeleteLeaks) LLVM bug https://github.com/llvm/llvm-project/issues/40486
-  std::string encoded = boost::algorithm::erase_all_copy(encodedValue.data(), " ");
-  if (encoded.size() < 2 || encoded[0] != '[' || encoded[encoded.size() - 1] != ']') {
+  std::string encoded = boost::algorithm::erase_all_copy (encodedValue.data (), " ");
+  if (encoded.size () < 2 || encoded[0] != '[' || encoded[encoded.size () - 1] != ']') {
     return false;
   }
-  encoded.erase(encoded.begin());
-  encoded.erase(encoded.end() - 1);
+  encoded.erase (encoded.begin ());
+  encoded.erase (encoded.end () - 1);
 
   std::vector<std::string> items;
-  boost::algorithm::split(items, encoded, boost::algorithm::is_any_of(","));
+  boost::algorithm::split (items, encoded, boost::algorithm::is_any_of (","));
   // NOLINTEND(*NewDeleteLeaks)
 
-  for (const std::string& item : items) {
-    std::stringstream stream(item);
+  for (const std::string &item : items) {
+    std::stringstream stream (item);
     double itemValue;
     stream >> itemValue;
-    if (!stream || !stream.eof()) {
+    if (!stream || !stream.eof ()) {
       return false;
     }
-    decoded.push_back(itemValue);
+    decoded.push_back (itemValue);
   }
 
-  if (decoded.size() != value.size()) {
+  if (decoded.size () != value.size ()) {
     return false;
   }
 
   if (store) {
-    for (size_t i = 0; i < value.size(); i++) {
+    for (size_t i = 0; i < value.size (); i++) {
       value[i] = decoded[i];
       if (minimum && value[i] < *minimum) {
         value[i] = *minimum;
@@ -201,11 +186,10 @@ bool VectorParameter::importValue(boost::property_tree::ptree encodedValue, bool
   return true;
 }
 
-boost::property_tree::ptree VectorParameter::exportValue() const
-{
+boost::property_tree::ptree VectorParameter::exportValue () const {
   std::stringstream encoded;
   encoded << "[";
-  for (size_t i = 0; i < value.size(); i++) {
+  for (size_t i = 0; i < value.size (); i++) {
     if (i > 0) {
       encoded << ", ";
     }
@@ -214,40 +198,37 @@ boost::property_tree::ptree VectorParameter::exportValue() const
   encoded << "]";
 
   boost::property_tree::ptree output;
-  output.data() = encoded.str();
+  output.data () = encoded.str ();
   return output;
 }
 
-json VectorParameter::jsonValue() const
-{
+json VectorParameter::jsonValue () const {
   json o;
   o["type"] = "number";
   o["initial"] = defaultValue;
 
-  if (maximum.is_initialized()) {
-    o["max"] = maximum.get();
-    o["min"] = minimum.is_initialized() ? minimum.get() : 0.0;
-    o["step"] = step.is_initialized() ? step.get() : 1.0;
+  if (maximum.is_initialized ()) {
+    o["max"] = maximum.get ();
+    o["min"] = minimum.is_initialized () ? minimum.get () : 0.0;
+    o["step"] = step.is_initialized () ? step.get () : 1.0;
   }
   return o;
 }
 
-void VectorParameter::apply(Assignment *assignment) const
-{
-  std::shared_ptr<Vector> vector = std::make_shared<Vector>(Location::NONE);
+void VectorParameter::apply (Assignment *assignment) const {
+  std::shared_ptr<Vector> vector = std::make_shared<Vector> (Location::NONE);
   for (double item : value) {
-    vector->emplace_back(new Literal(item));
+    vector->emplace_back (new Literal (item));
   }
-  assignment->setExpr(std::move(vector));
+  assignment->setExpr (std::move (vector));
 }
 
-bool EnumParameter::importValue(boost::property_tree::ptree encodedValue, bool store)
-{
+bool EnumParameter::importValue (boost::property_tree::ptree encodedValue, bool store) {
   bool found = false;
   int index;
-  boost::optional<double> decodedDouble = encodedValue.get_value_optional<double>();
-  for (size_t i = 0; i < items.size(); i++) {
-    if ((decodedDouble && items[i].value == EnumValue(*decodedDouble)) || items[i].value == EnumValue(encodedValue.data())) {
+  boost::optional<double> decodedDouble = encodedValue.get_value_optional<double> ();
+  for (size_t i = 0; i < items.size (); i++) {
+    if ((decodedDouble && items[i].value == EnumValue (*decodedDouble)) || items[i].value == EnumValue (encodedValue.data ())) {
       index = i;
       found = true;
       break;
@@ -263,122 +244,115 @@ bool EnumParameter::importValue(boost::property_tree::ptree encodedValue, bool s
   return true;
 }
 
-boost::property_tree::ptree EnumParameter::exportValue() const
-{
-  const EnumValue& itemValue = items[valueIndex].value;
+boost::property_tree::ptree EnumParameter::exportValue () const {
+  const EnumValue &itemValue = items[valueIndex].value;
   boost::property_tree::ptree output;
-  if (std::holds_alternative<double>(itemValue)) {
-    output.put_value<double>(std::get<double>(itemValue));
+  if (std::holds_alternative<double> (itemValue)) {
+    output.put_value<double> (std::get<double> (itemValue));
   } else {
-    output.data() = std::get<std::string>(itemValue);
+    output.data () = std::get<std::string> (itemValue);
   }
   return output;
 }
 
-json EnumParameter::jsonValue() const
-{
+json EnumParameter::jsonValue () const {
   json o;
-  if (set_enum_value(o, "initial", items[defaultValueIndex])) {
+  if (set_enum_value (o, "initial", items[defaultValueIndex])) {
     o["type"] = "number";
   } else {
     o["type"] = "string";
   }
 
   json options;
-  for (const auto& item : items) {
+  for (const auto &item : items) {
     json option;
     option["name"] = item.key;
-    set_enum_value(option, "value", item);
-    options.push_back(option);
+    set_enum_value (option, "value", item);
+    options.push_back (option);
   }
   o["options"] = options;
 
   return o;
 }
 
-void EnumParameter::apply(Assignment *assignment) const
-{
-  const EnumValue& itemValue = items[valueIndex].value;
-  if (std::holds_alternative<double>(itemValue)) {
-    assignment->setExpr(std::make_shared<Literal>(std::get<double>(itemValue)));
+void EnumParameter::apply (Assignment *assignment) const {
+  const EnumValue &itemValue = items[valueIndex].value;
+  if (std::holds_alternative<double> (itemValue)) {
+    assignment->setExpr (std::make_shared<Literal> (std::get<double> (itemValue)));
   } else {
-    assignment->setExpr(std::make_shared<Literal>(std::get<std::string>(itemValue)));
+    assignment->setExpr (std::make_shared<Literal> (std::get<std::string> (itemValue)));
   }
 }
 
-
-
-struct EnumValues
-{
+struct EnumValues {
   std::vector<EnumParameter::EnumItem> items;
   int defaultValueIndex;
 };
-static EnumValues parseEnumItems(const Expression *parameter, const std::string& defaultKey, const EnumParameter::EnumValue& defaultValue)
-{
+static EnumValues parseEnumItems (const Expression *parameter, const std::string &defaultKey, const EnumParameter::EnumValue &defaultValue) {
   EnumValues output;
 
-  const auto *expression = dynamic_cast<const Vector *>(parameter);
+  const auto *expression = dynamic_cast<const Vector *> (parameter);
   if (!expression) {
     return output;
   }
 
   std::vector<EnumParameter::EnumItem> items;
-  const auto& elements = expression->getChildren();
-  for (const auto& elementPointer : elements) {
+  const auto &elements = expression->getChildren ();
+  for (const auto &elementPointer : elements) {
     EnumParameter::EnumItem item;
-    if (const auto *element = dynamic_cast<const Literal *>(elementPointer.get())) {
+    if (const auto *element = dynamic_cast<const Literal *> (elementPointer.get ())) {
       // string or number literal
-      if (element->isDouble()) {
-        if (elements.size() == 1) {
+      if (element->isDouble ()) {
+        if (elements.size () == 1) {
           // a vector with a single numeric element is not an enum specifier,
           // it's a range with a maximum and no minimum.
           return output;
         }
-        item.value = element->toDouble();
-        item.key = STR(element->toDouble());
-      } else if (element->isString()) {
-        item.value = element->toString();
-        item.key = element->toString();
+        item.value = element->toDouble ();
+        item.key = STR (element->toDouble ());
+      } else if (element->isString ()) {
+        item.value = element->toString ();
+        item.key = element->toString ();
       } else {
         return output;
       }
-    } else if (const auto *element = dynamic_cast<const Vector *>(elementPointer.get())) {
+    } else if (const auto *element = dynamic_cast<const Vector *> (elementPointer.get ())) {
       // [value, key] vector
-      if (element->getChildren().size() != 2) {
+      if (element->getChildren ().size () != 2) {
         return output;
       }
 
-      const auto *key = dynamic_cast<const Literal *>(element->getChildren()[1].get());
+      const auto *key = dynamic_cast<const Literal *> (element->getChildren ()[1].get ());
       if (!key) {
         return output;
       }
-      if (key->isDouble()) {
-        item.key = STR(key->toDouble());
-      } else if (key->isString()) {
-        item.key = key->toString();
+      if (key->isDouble ()) {
+        item.key = STR (key->toDouble ());
+      } else if (key->isString ()) {
+        item.key = key->toString ();
       } else {
         return output;
       }
 
-      const auto *value = dynamic_cast<const Literal *>(element->getChildren()[0].get());
+      const auto *value = dynamic_cast<const Literal *> (element->getChildren ()[0].get ());
       if (!value) {
         return output;
       }
-      if (value->isDouble()) {
-        item.value = value->toDouble();
-      } else if (value->isString()) {
-        item.value = value->toString();
+      if (value->isDouble ()) {
+        item.value = value->toDouble ();
+      } else if (value->isString ()) {
+        item.value = value->toString ();
       } else {
         return output;
       }
     } else {
       return output;
     }
-    items.push_back(item);
+    items.push_back (item);
   }
 
-  output.items = std::move(items);
-  for (size_t i = 0; i < output.items.size(); i++) {
+  output.items = std::move (items);
+  for (size_t i = 0; i < output.items.size (); i++) {
     if (defaultValue == output.items[i].value) {
       output.defaultValueIndex = i;
       return output;
@@ -387,45 +361,41 @@ static EnumValues parseEnumItems(const Expression *parameter, const std::string&
   EnumParameter::EnumItem defaultItem;
   defaultItem.key = defaultKey;
   defaultItem.value = defaultValue;
-  output.items.insert(output.items.begin(), defaultItem);
+  output.items.insert (output.items.begin (), defaultItem);
   output.defaultValueIndex = 0;
   return output;
 }
 
-struct NumericLimits
-{
+struct NumericLimits {
   boost::optional<double> minimum;
   boost::optional<double> maximum;
   boost::optional<double> step;
 };
-static NumericLimits parseNumericLimits(const Expression *parameter, const std::vector<double>& values)
-{
+static NumericLimits parseNumericLimits (const Expression *parameter, const std::vector<double> &values) {
   NumericLimits output;
 
-  if (const auto *step = dynamic_cast<const Literal *>(parameter)) {
-    if (step->isDouble()) {
-      output.step = step->toDouble();
+  if (const auto *step = dynamic_cast<const Literal *> (parameter)) {
+    if (step->isDouble ()) {
+      output.step = step->toDouble ();
     }
-  } else if (const auto *maximum = dynamic_cast<const Vector *>(parameter)) {
-    if (maximum->getChildren().size() == 1) {
-      const auto *maximumChild = dynamic_cast<const Literal *>(maximum->getChildren()[0].get());
-      if (maximumChild && maximumChild->isDouble()) {
-        output.maximum = maximumChild->toDouble();
+  } else if (const auto *maximum = dynamic_cast<const Vector *> (parameter)) {
+    if (maximum->getChildren ().size () == 1) {
+      const auto *maximumChild = dynamic_cast<const Literal *> (maximum->getChildren ()[0].get ());
+      if (maximumChild && maximumChild->isDouble ()) {
+        output.maximum = maximumChild->toDouble ();
       }
     }
-  } else if (const auto *range = dynamic_cast<const Range *>(parameter)) {
-    const auto *minimum = dynamic_cast<const Literal *>(range->getBegin());
-    const auto *maximum = dynamic_cast<const Literal *>(range->getEnd());
+  } else if (const auto *range = dynamic_cast<const Range *> (parameter)) {
+    const auto *minimum = dynamic_cast<const Literal *> (range->getBegin ());
+    const auto *maximum = dynamic_cast<const Literal *> (range->getEnd ());
     if (
-      minimum && minimum->isDouble()
-      && maximum && maximum->isDouble()
-      ) {
-      output.minimum = minimum->toDouble();
-      output.maximum = maximum->toDouble();
-
-      const auto *step = dynamic_cast<const Literal *>(range->getStep());
-      if (step && step->isDouble()) {
-        output.step = step->toDouble();
+      minimum && minimum->isDouble () && maximum && maximum->isDouble ()) {
+      output.minimum = minimum->toDouble ();
+      output.maximum = maximum->toDouble ();
+
+      const auto *step = dynamic_cast<const Literal *> (range->getStep ());
+      if (step && step->isDouble ()) {
+        output.step = step->toDouble ();
       }
     }
   }
@@ -441,148 +411,142 @@ static NumericLimits parseNumericLimits(const Expression *parameter, const std::
   return output;
 }
 
-std::unique_ptr<ParameterObject> ParameterObject::fromAssignment(const Assignment *assignment)
-{
-  std::string name = assignment->getName();
+std::unique_ptr<ParameterObject> ParameterObject::fromAssignment (const Assignment *assignment) {
+  std::string name = assignment->getName ();
 
   const Expression *parameter = nullptr;
-  const Annotation *parameterAnnotation = assignment->annotation("Parameter");
+  const Annotation *parameterAnnotation = assignment->annotation ("Parameter");
   if (!parameterAnnotation) {
     return nullptr;
   }
-  parameter = parameterAnnotation->getExpr().get();
+  parameter = parameterAnnotation->getExpr ().get ();
 
   std::string description;
-  const Annotation *descriptionAnnotation = assignment->annotation("Description");
+  const Annotation *descriptionAnnotation = assignment->annotation ("Description");
   if (descriptionAnnotation) {
-    const auto *expression = dynamic_cast<const Literal *>(descriptionAnnotation->getExpr().get());
-    if (expression && expression->isString()) {
-      description = expression->toString();
+    const auto *expression = dynamic_cast<const Literal *> (descriptionAnnotation->getExpr ().get ());
+    if (expression && expression->isString ()) {
+      description = expression->toString ();
     }
   }
 
   std::string group = "Parameters";
-  const Annotation *groupAnnotation = assignment->annotation("Group");
+  const Annotation *groupAnnotation = assignment->annotation ("Group");
   if (groupAnnotation) {
-    const auto *expression = dynamic_cast<const Literal *>(groupAnnotation->getExpr().get());
-    if (expression && expression->isString()) {
-      group = boost::algorithm::trim_copy(expression->toString());
-
+    const auto *expression = dynamic_cast<const Literal *> (groupAnnotation->getExpr ().get ());
+    if (expression && expression->isString ()) {
+      group = boost::algorithm::trim_copy (expression->toString ());
     }
-    if (group == "Hidden") return nullptr;
+    if (group == "Hidden")
+      return nullptr;
   }
 
-  const Expression *valueExpression = assignment->getExpr().get();
-  if (const auto *expression = dynamic_cast<const Literal *>(valueExpression)) {
-    if (expression->isBool()) {
-      return std::make_unique<BoolParameter>(name, description, group, expression->toBool());
+  const Expression *valueExpression = assignment->getExpr ().get ();
+  if (const auto *expression = dynamic_cast<const Literal *> (valueExpression)) {
+    if (expression->isBool ()) {
+      return std::make_unique<BoolParameter> (name, description, group, expression->toBool ());
     }
 
-    if (expression->isDouble() || expression->isString()) {
+    if (expression->isDouble () || expression->isString ()) {
       std::string key;
       EnumParameter::EnumValue value;
-      if (expression->isDouble()) {
-        value = expression->toDouble();
-        key = STR(expression->toDouble());
+      if (expression->isDouble ()) {
+        value = expression->toDouble ();
+        key = STR (expression->toDouble ());
       } else {
-        value = expression->toString();
-        key = expression->toString();
+        value = expression->toString ();
+        key = expression->toString ();
       }
-      EnumValues values = parseEnumItems(parameter, key, value);
-      if (!values.items.empty()) {
-        return std::make_unique<EnumParameter>(name, description, group, values.defaultValueIndex, values.items);
+      EnumValues values = parseEnumItems (parameter, key, value);
+      if (!values.items.empty ()) {
+        return std::make_unique<EnumParameter> (name, description, group, values.defaultValueIndex, values.items);
       }
     }
 
-    if (expression->isString()) {
-      std::string value = expression->toString();
+    if (expression->isString ()) {
+      std::string value = expression->toString ();
       boost::optional<size_t> maximumSize = boost::none;
-      const auto *maximumSizeExpression = dynamic_cast<const Literal *>(parameter);
-      if (maximumSizeExpression && maximumSizeExpression->isDouble()) {
-        maximumSize = (size_t)(maximumSizeExpression->toDouble());
+      const auto *maximumSizeExpression = dynamic_cast<const Literal *> (parameter);
+      if (maximumSizeExpression && maximumSizeExpression->isDouble ()) {
+        maximumSize = (size_t)(maximumSizeExpression->toDouble ());
       }
-      return std::make_unique<StringParameter>(name, description, group, value, maximumSize);
+      return std::make_unique<StringParameter> (name, description, group, value, maximumSize);
     }
 
-    if (expression->isDouble()) {
-      double value = expression->toDouble();
-      NumericLimits limits = parseNumericLimits(parameter, {value});
-      return std::make_unique<NumberParameter>(name, description, group, value, limits.minimum, limits.maximum, limits.step);
+    if (expression->isDouble ()) {
+      double value = expression->toDouble ();
+      NumericLimits limits = parseNumericLimits (parameter, {value});
+      return std::make_unique<NumberParameter> (name, description, group, value, limits.minimum, limits.maximum, limits.step);
     }
-  } else if (const auto *expression = dynamic_cast<const Vector *>(valueExpression)) {
-    if (expression->getChildren().size() < 1 || expression->getChildren().size() > 4) {
+  } else if (const auto *expression = dynamic_cast<const Vector *> (valueExpression)) {
+    if (expression->getChildren ().size () < 1 || expression->getChildren ().size () > 4) {
       return nullptr;
     }
 
     std::vector<double> value;
-    for (const auto& element : expression->getChildren()) {
-      const auto *item = dynamic_cast<const Literal *>(element.get());
+    for (const auto &element : expression->getChildren ()) {
+      const auto *item = dynamic_cast<const Literal *> (element.get ());
       if (!item) {
         return nullptr;
       }
-      if (!item->isDouble()) {
+      if (!item->isDouble ()) {
         return nullptr;
       }
-      value.push_back(item->toDouble());
+      value.push_back (item->toDouble ());
     }
 
-    NumericLimits limits = parseNumericLimits(parameter, value);
-    return std::make_unique<VectorParameter>(name, description, group, value, limits.minimum, limits.maximum, limits.step);
+    NumericLimits limits = parseNumericLimits (parameter, value);
+    return std::make_unique<VectorParameter> (name, description, group, value, limits.minimum, limits.maximum, limits.step);
   }
   return nullptr;
 }
 
-ParameterObjects ParameterObjects::fromSourceFile(const SourceFile *sourceFile)
-{
+ParameterObjects ParameterObjects::fromSourceFile (const SourceFile *sourceFile) {
   ParameterObjects output;
-  for (const auto& assignment : sourceFile->scope.assignments) {
-    std::unique_ptr<ParameterObject> parameter = ParameterObject::fromAssignment(assignment.get());
+  for (const auto &assignment : sourceFile->scope.assignments) {
+    std::unique_ptr<ParameterObject> parameter = ParameterObject::fromAssignment (assignment.get ());
     if (parameter) {
-      output.push_back(std::move(parameter));
+      output.push_back (std::move (parameter));
     }
   }
   return output;
 }
 
-void ParameterObjects::reset()
-{
-  for (const auto& parameter : *this) {
-    parameter->reset();
+void ParameterObjects::reset () {
+  for (const auto &parameter : *this) {
+    parameter->reset ();
   }
 }
 
-void ParameterObjects::importValues(const ParameterSet& values)
-{
-  for (const auto& parameter : *this) {
-    auto it = values.find(parameter->name());
-    if (it == values.end()) {
-      parameter->reset();
+void ParameterObjects::importValues (const ParameterSet &values) {
+  for (const auto &parameter : *this) {
+    auto it = values.find (parameter->name ());
+    if (it == values.end ()) {
+      parameter->reset ();
     } else {
-      parameter->importValue(it->second, true);
+      parameter->importValue (it->second, true);
     }
   }
 }
 
-ParameterSet ParameterObjects::exportValues(const std::string& setName)
-{
+ParameterSet ParameterObjects::exportValues (const std::string &setName) {
   ParameterSet output;
-  output.setName(setName);
-  for (const auto& parameter : *this) {
-    output[parameter->name()] = parameter->exportValue();
+  output.setName (setName);
+  for (const auto &parameter : *this) {
+    output[parameter->name ()] = parameter->exportValue ();
   }
   return output;
 }
 
-void ParameterObjects::apply(SourceFile *sourceFile) const
-{
+void ParameterObjects::apply (SourceFile *sourceFile) const {
   std::map<std::string, ParameterObject *> namedParameters;
-  for (const auto& parameter : *this) {
-    namedParameters[parameter->name()] = parameter.get();
+  for (const auto &parameter : *this) {
+    namedParameters[parameter->name ()] = parameter.get ();
   }
 
-  for (auto& assignment : sourceFile->scope.assignments) {
-    if (namedParameters.count(assignment->getName())) {
-      namedParameters[assignment->getName()]->apply(assignment.get());
+  for (auto &assignment : sourceFile->scope.assignments) {
+    if (namedParameters.count (assignment->getName ())) {
+      namedParameters[assignment->getName ()]->apply (assignment.get ());
     }
   }
 }
diff --git a/src/core/customizer/ParameterObject.h b/src/core/customizer/ParameterObject.h
index e4d12e0b4..15a3f20f1 100644
--- a/src/core/customizer/ParameterObject.h
+++ b/src/core/customizer/ParameterObject.h
@@ -17,25 +17,40 @@ class Assignment;
 class ParameterObject
 {
 public:
-  enum class ParameterType { Bool, String, Number, Vector, Enum };
-
-  virtual ~ParameterObject() = default;
-  static std::unique_ptr<ParameterObject> fromAssignment(const Assignment *assignment);
-
-  [[nodiscard]] ParameterType type() const { return type_; }
-  [[nodiscard]] const std::string& name() const { return name_; }
-  [[nodiscard]] const std::string& description() const { return description_; }
-  [[nodiscard]] const std::string& group() const { return group_; }
-
-  virtual void reset() = 0;
-  virtual bool importValue(boost::property_tree::ptree encodedValue, bool store) = 0;
-  [[nodiscard]] virtual boost::property_tree::ptree exportValue() const = 0;
-  [[nodiscard]] virtual json jsonValue() const = 0;
-  virtual void apply(Assignment *assignment) const = 0;
+  enum class ParameterType { Bool,
+                             String,
+                             Number,
+                             Vector,
+                             Enum };
+
+  virtual ~ParameterObject () = default;
+  static std::unique_ptr<ParameterObject> fromAssignment (const Assignment *assignment);
+
+  [[nodiscard]] ParameterType type () const {
+    return type_;
+  }
+  [[nodiscard]] const std::string &name () const {
+    return name_;
+  }
+  [[nodiscard]] const std::string &description () const {
+    return description_;
+  }
+  [[nodiscard]] const std::string &group () const {
+    return group_;
+  }
+
+  virtual void reset () = 0;
+  virtual bool importValue (boost::property_tree::ptree encodedValue, bool store) = 0;
+  [[nodiscard]] virtual boost::property_tree::ptree exportValue () const = 0;
+  [[nodiscard]] virtual json jsonValue () const = 0;
+  virtual void apply (Assignment *assignment) const = 0;
 
 protected:
-  ParameterObject(std::string name, std::string description, std::string group, ParameterType type) :
-    type_(type), name_(std::move(name)), description_(std::move(description)), group_(std::move(group)) {}
+  ParameterObject (std::string name, std::string description, std::string group, ParameterType type)
+    : type_ (type)
+    , name_ (std::move (name))
+    , description_ (std::move (description))
+    , group_ (std::move (group)) {}
 
   ParameterType type_;
   std::string name_;
@@ -46,19 +61,20 @@ protected:
 class BoolParameter : public ParameterObject
 {
 public:
-  BoolParameter(
-    const std::string& name, const std::string& description, const std::string& group,
-    bool defaultValue
-    ) :
-    ParameterObject(name, description, group, ParameterObject::ParameterType::Bool),
-    value(defaultValue), defaultValue(defaultValue)
-  {}
-
-  void reset() override { value = defaultValue; }
-  bool importValue(boost::property_tree::ptree encodedValue, bool store) override;
-  [[nodiscard]] boost::property_tree::ptree exportValue() const override;
-  [[nodiscard]] json jsonValue() const override;
-  void apply(Assignment *assignment) const override;
+  BoolParameter (
+    const std::string &name, const std::string &description, const std::string &group,
+    bool defaultValue)
+    : ParameterObject (name, description, group, ParameterObject::ParameterType::Bool)
+    , value (defaultValue)
+    , defaultValue (defaultValue) {}
+
+  void reset () override {
+    value = defaultValue;
+  }
+  bool importValue (boost::property_tree::ptree encodedValue, bool store) override;
+  [[nodiscard]] boost::property_tree::ptree exportValue () const override;
+  [[nodiscard]] json jsonValue () const override;
+  void apply (Assignment *assignment) const override;
 
   bool value;
   bool defaultValue;
@@ -67,17 +83,18 @@ public:
 class StringParameter : public ParameterObject
 {
 public:
-  StringParameter(
-    const std::string& name, const std::string& description, const std::string& group,
-    const std::string& defaultValue,
-    boost::optional<size_t> maximumSize
-    );
-
-  void reset() override { value = defaultValue; }
-  bool importValue(boost::property_tree::ptree encodedValue, bool store) override;
-  [[nodiscard]] boost::property_tree::ptree exportValue() const override;
-  [[nodiscard]] json jsonValue() const override;
-  void apply(Assignment *assignment) const override;
+  StringParameter (
+    const std::string &name, const std::string &description, const std::string &group,
+    const std::string &defaultValue,
+    boost::optional<size_t> maximumSize);
+
+  void reset () override {
+    value = defaultValue;
+  }
+  bool importValue (boost::property_tree::ptree encodedValue, bool store) override;
+  [[nodiscard]] boost::property_tree::ptree exportValue () const override;
+  [[nodiscard]] json jsonValue () const override;
+  void apply (Assignment *assignment) const override;
 
   std::string value;
   std::string defaultValue;
@@ -87,21 +104,24 @@ public:
 class NumberParameter : public ParameterObject
 {
 public:
-  NumberParameter(
-    const std::string& name, const std::string& description, const std::string& group,
+  NumberParameter (
+    const std::string &name, const std::string &description, const std::string &group,
     double defaultValue,
-    boost::optional<double> minimum, boost::optional<double> maximum, boost::optional<double> step
-    ) :
-    ParameterObject(name, description, group, ParameterObject::ParameterType::Number),
-    value(defaultValue), defaultValue(defaultValue),
-    minimum(minimum), maximum(maximum), step(step)
-  {}
-
-  void reset() override { value = defaultValue; }
-  bool importValue(boost::property_tree::ptree encodedValue, bool store) override;
-  [[nodiscard]] boost::property_tree::ptree exportValue() const override;
-  [[nodiscard]] json jsonValue() const override;
-  void apply(Assignment *assignment) const override;
+    boost::optional<double> minimum, boost::optional<double> maximum, boost::optional<double> step)
+    : ParameterObject (name, description, group, ParameterObject::ParameterType::Number)
+    , value (defaultValue)
+    , defaultValue (defaultValue)
+    , minimum (minimum)
+    , maximum (maximum)
+    , step (step) {}
+
+  void reset () override {
+    value = defaultValue;
+  }
+  bool importValue (boost::property_tree::ptree encodedValue, bool store) override;
+  [[nodiscard]] boost::property_tree::ptree exportValue () const override;
+  [[nodiscard]] json jsonValue () const override;
+  void apply (Assignment *assignment) const override;
 
   double value;
   double defaultValue;
@@ -113,21 +133,24 @@ public:
 class VectorParameter : public ParameterObject
 {
 public:
-  VectorParameter(
-    const std::string& name, const std::string& description, const std::string& group,
-    const std::vector<double>& defaultValue,
-    boost::optional<double> minimum, boost::optional<double> maximum, boost::optional<double> step
-    ) :
-    ParameterObject(name, description, group, ParameterObject::ParameterType::Vector),
-    value(defaultValue), defaultValue(defaultValue),
-    minimum(minimum), maximum(maximum), step(step)
-  {}
-
-  void reset() override { value = defaultValue; }
-  bool importValue(boost::property_tree::ptree encodedValue, bool store) override;
-  [[nodiscard]] boost::property_tree::ptree exportValue() const override;
-  [[nodiscard]] json jsonValue() const override;
-  void apply(Assignment *assignment) const override;
+  VectorParameter (
+    const std::string &name, const std::string &description, const std::string &group,
+    const std::vector<double> &defaultValue,
+    boost::optional<double> minimum, boost::optional<double> maximum, boost::optional<double> step)
+    : ParameterObject (name, description, group, ParameterObject::ParameterType::Vector)
+    , value (defaultValue)
+    , defaultValue (defaultValue)
+    , minimum (minimum)
+    , maximum (maximum)
+    , step (step) {}
+
+  void reset () override {
+    value = defaultValue;
+  }
+  bool importValue (boost::property_tree::ptree encodedValue, bool store) override;
+  [[nodiscard]] boost::property_tree::ptree exportValue () const override;
+  [[nodiscard]] json jsonValue () const override;
+  void apply (Assignment *assignment) const override;
 
   std::vector<double> value;
   std::vector<double> defaultValue;
@@ -145,21 +168,22 @@ public:
     EnumValue value;
   };
 
-  EnumParameter(
-    const std::string& name, const std::string& description, const std::string& group,
+  EnumParameter (
+    const std::string &name, const std::string &description, const std::string &group,
     int defaultValueIndex,
-    std::vector<EnumItem> items
-    ) :
-    ParameterObject(name, description, group, ParameterObject::ParameterType::Enum),
-    valueIndex(defaultValueIndex), defaultValueIndex(defaultValueIndex),
-    items(std::move(items))
-  {}
-
-  void reset() override { valueIndex = defaultValueIndex; }
-  bool importValue(boost::property_tree::ptree encodedValue, bool store) override;
-  [[nodiscard]] boost::property_tree::ptree exportValue() const override;
-  [[nodiscard]] json jsonValue() const override;
-  void apply(Assignment *assignment) const override;
+    std::vector<EnumItem> items)
+    : ParameterObject (name, description, group, ParameterObject::ParameterType::Enum)
+    , valueIndex (defaultValueIndex)
+    , defaultValueIndex (defaultValueIndex)
+    , items (std::move (items)) {}
+
+  void reset () override {
+    valueIndex = defaultValueIndex;
+  }
+  bool importValue (boost::property_tree::ptree encodedValue, bool store) override;
+  [[nodiscard]] boost::property_tree::ptree exportValue () const override;
+  [[nodiscard]] json jsonValue () const override;
+  void apply (Assignment *assignment) const override;
 
   int valueIndex;
   int defaultValueIndex;
@@ -169,9 +193,9 @@ public:
 class ParameterObjects : public std::vector<std::unique_ptr<ParameterObject>>
 {
 public:
-  static ParameterObjects fromSourceFile(const SourceFile *sourceFile);
-  void reset();
-  void importValues(const ParameterSet& values);
-  ParameterSet exportValues(const std::string& setName);
-  void apply(SourceFile *sourceFile) const;
+  static ParameterObjects fromSourceFile (const SourceFile *sourceFile);
+  void reset ();
+  void importValues (const ParameterSet &values);
+  ParameterSet exportValues (const std::string &setName);
+  void apply (SourceFile *sourceFile) const;
 };
diff --git a/src/core/customizer/ParameterSet.cc b/src/core/customizer/ParameterSet.cc
index 304daef70..8c64bcfb5 100644
--- a/src/core/customizer/ParameterSet.cc
+++ b/src/core/customizer/ParameterSet.cc
@@ -4,55 +4,53 @@
 
 #include <string>
 
-static std::string parameterSetsKey("parameterSets");
-static std::string fileFormatVersionKey("fileFormatVersion");
-static std::string fileFormatVersionValue("1");
+static std::string parameterSetsKey ("parameterSets");
+static std::string fileFormatVersionKey ("fileFormatVersion");
+static std::string fileFormatVersionValue ("1");
 
-bool ParameterSets::readFile(const std::string& filename)
-{
+bool ParameterSets::readFile (const std::string &filename) {
   boost::property_tree::ptree root;
 
   try {
-    boost::property_tree::read_json(filename, root);
-  } catch (const boost::property_tree::json_parser_error& e) {
-    LOG(message_group::Error, "Cannot open Parameter Set '%1$s': %2$s", filename, e.what());
+    boost::property_tree::read_json (filename, root);
+  } catch (const boost::property_tree::json_parser_error &e) {
+    LOG (message_group::Error, "Cannot open Parameter Set '%1$s': %2$s", filename, e.what ());
     return false;
   }
 
-  boost::optional<boost::property_tree::ptree&> sets = root.get_child_optional(parameterSetsKey);
+  boost::optional<boost::property_tree::ptree &> sets = root.get_child_optional (parameterSetsKey);
   if (!sets) {
     return false;
   }
 
-  for (const auto& entry : *sets) {
+  for (const auto &entry : *sets) {
     ParameterSet set;
-    set.setName(entry.first);
-    for (const auto& value : entry.second) {
+    set.setName (entry.first);
+    for (const auto &value : entry.second) {
       set[value.first] = value.second;
     }
-    push_back(set);
+    push_back (set);
   }
   return true;
 }
 
-void ParameterSets::writeFile(const std::string& filename) const
-{
+void ParameterSets::writeFile (const std::string &filename) const {
   boost::property_tree::ptree sets;
-  for (const auto& set : *this) {
+  for (const auto &set : *this) {
     boost::property_tree::ptree setTree;
-    for (const auto& parameter : set) {
-      setTree.push_back(boost::property_tree::ptree::value_type(parameter.first, parameter.second));
+    for (const auto &parameter : set) {
+      setTree.push_back (boost::property_tree::ptree::value_type (parameter.first, parameter.second));
     }
-    sets.push_back(boost::property_tree::ptree::value_type(set.name(), setTree));
+    sets.push_back (boost::property_tree::ptree::value_type (set.name (), setTree));
   }
 
   boost::property_tree::ptree root;
-  root.put<std::string>(fileFormatVersionKey, fileFormatVersionValue);
-  root.push_back(boost::property_tree::ptree::value_type(parameterSetsKey, sets));
+  root.put<std::string> (fileFormatVersionKey, fileFormatVersionValue);
+  root.push_back (boost::property_tree::ptree::value_type (parameterSetsKey, sets));
 
   try {
-    boost::property_tree::write_json(filename, root);
-  } catch (const boost::property_tree::json_parser_error& e) {
-    LOG(message_group::Error, "Cannot write Parameter Set '%1$s': %2$s", filename, e.what());
+    boost::property_tree::write_json (filename, root);
+  } catch (const boost::property_tree::json_parser_error &e) {
+    LOG (message_group::Error, "Cannot write Parameter Set '%1$s': %2$s", filename, e.what ());
   }
 }
diff --git a/src/core/customizer/ParameterSet.h b/src/core/customizer/ParameterSet.h
index b842c146d..e748a0736 100644
--- a/src/core/customizer/ParameterSet.h
+++ b/src/core/customizer/ParameterSet.h
@@ -8,8 +8,12 @@
 class ParameterSet : public std::map<std::string, boost::property_tree::ptree>
 {
 public:
-  [[nodiscard]] const std::string& name() const { return _name; }
-  void setName(const std::string& name) { _name = name; }
+  [[nodiscard]] const std::string &name () const {
+    return _name;
+  }
+  void setName (const std::string &name) {
+    _name = name;
+  }
 
 private:
   std::string _name;
@@ -18,6 +22,6 @@ private:
 class ParameterSets : public std::vector<ParameterSet>
 {
 public:
-  bool readFile(const std::string& filename);
-  void writeFile(const std::string& filename) const;
+  bool readFile (const std::string &filename);
+  void writeFile (const std::string &filename) const;
 };
diff --git a/src/core/function.cc b/src/core/function.cc
index af785370a..608dc514a 100644
--- a/src/core/function.cc
+++ b/src/core/function.cc
@@ -35,32 +35,33 @@
 #include <cstddef>
 #include <utility>
 
-BuiltinFunction::BuiltinFunction(Value(*f)(const std::shared_ptr<const Context>&, const FunctionCall *), const Feature *feature) :
-  evaluate(f),
-  feature(feature)
-{}
+BuiltinFunction::BuiltinFunction (Value (*f) (const std::shared_ptr<const Context> &, const FunctionCall *), const Feature *feature)
+  : evaluate (f)
+  , feature (feature) {}
 
-BuiltinFunction::BuiltinFunction(Value(*f)(Arguments, const Location&), const Feature *feature) :
-  feature(feature)
-{
-  evaluate = [f] (const std::shared_ptr<const Context>& context, const FunctionCall *call) {
-      return f(Arguments(call->arguments, context), call->location());
-    };
+BuiltinFunction::BuiltinFunction (Value (*f) (Arguments, const Location &), const Feature *feature)
+  : feature (feature) {
+  evaluate = [f] (const std::shared_ptr<const Context> &context, const FunctionCall *call) {
+    return f (Arguments (call->arguments, context), call->location ());
+  };
 }
 
-UserFunction::UserFunction(const char *name, AssignmentList& parameters, std::shared_ptr<Expression> expr, const Location& loc)
-  : ASTNode(loc), name(name), parameters(parameters), expr(std::move(expr))
-{
+UserFunction::UserFunction (const char *name, AssignmentList &parameters, std::shared_ptr<Expression> expr, const Location &loc)
+  : ASTNode (loc)
+  , name (name)
+  , parameters (parameters)
+  , expr (std::move (expr)) {
 }
 
-void UserFunction::print(std::ostream& stream, const std::string& indent) const
-{
+void UserFunction::print (std::ostream &stream, const std::string &indent) const {
   stream << indent << "function " << name << "(";
-  for (size_t i = 0; i < parameters.size(); ++i) {
-    const auto& parameter = parameters[i];
-    if (i > 0) stream << ", ";
-    stream << parameter->getName();
-    if (parameter->getExpr()) stream << " = " << *parameter->getExpr();
+  for (size_t i = 0; i < parameters.size (); ++i) {
+    const auto &parameter = parameters[i];
+    if (i > 0)
+      stream << ", ";
+    stream << parameter->getName ();
+    if (parameter->getExpr ())
+      stream << " = " << *parameter->getExpr ();
   }
   stream << ") = " << *expr << ";\n";
 }
diff --git a/src/core/function.h b/src/core/function.h
index 6cb6fb016..4962d43d7 100644
--- a/src/core/function.h
+++ b/src/core/function.h
@@ -17,17 +17,21 @@ class FunctionCall;
 class BuiltinFunction
 {
 public:
-  std::function<Value(const std::shared_ptr<const Context>&, const FunctionCall *)> evaluate;
+  std::function<Value (const std::shared_ptr<const Context> &, const FunctionCall *)> evaluate;
 
 private:
   const Feature *feature;
 
 public:
-  BuiltinFunction(Value(*f)(const std::shared_ptr<const Context>&, const FunctionCall *), const Feature *feature = nullptr);
-  BuiltinFunction(Value(*f)(Arguments, const Location&), const Feature *feature = nullptr);
-
-  [[nodiscard]] bool is_experimental() const { return feature != nullptr; }
-  [[nodiscard]] bool is_enabled() const { return (feature == nullptr) || feature->is_enabled(); }
+  BuiltinFunction (Value (*f) (const std::shared_ptr<const Context> &, const FunctionCall *), const Feature *feature = nullptr);
+  BuiltinFunction (Value (*f) (Arguments, const Location &), const Feature *feature = nullptr);
+
+  [[nodiscard]] bool is_experimental () const {
+    return feature != nullptr;
+  }
+  [[nodiscard]] bool is_enabled () const {
+    return (feature == nullptr) || feature->is_enabled ();
+  }
 };
 
 class UserFunction : public ASTNode
@@ -37,14 +41,12 @@ public:
   AssignmentList parameters;
   std::shared_ptr<Expression> expr;
 
-  UserFunction(const char *name, AssignmentList& parameters, std::shared_ptr<Expression> expr, const Location& loc);
+  UserFunction (const char *name, AssignmentList &parameters, std::shared_ptr<Expression> expr, const Location &loc);
 
-  void print(std::ostream& stream, const std::string& indent) const override;
+  void print (std::ostream &stream, const std::string &indent) const override;
 };
 
-
-struct CallableUserFunction
-{
+struct CallableUserFunction {
   std::shared_ptr<const Context> defining_context;
   const UserFunction *function;
 };
diff --git a/src/core/module.cc b/src/core/module.cc
index d5d57dd50..38b64be88 100644
--- a/src/core/module.cc
+++ b/src/core/module.cc
@@ -34,39 +34,34 @@
 #include "core/Context.h"
 #include "core/ModuleInstantiation.h"
 
-BuiltinModule::BuiltinModule(std::shared_ptr<AbstractNode>(*instantiate)(const ModuleInstantiation *, const std::shared_ptr<const Context>&), const Feature *feature) :
-  AbstractModule(feature),
-  do_instantiate(instantiate)
-{}
+BuiltinModule::BuiltinModule (std::shared_ptr<AbstractNode> (*instantiate) (const ModuleInstantiation *, const std::shared_ptr<const Context> &), const Feature *feature)
+  : AbstractModule (feature)
+  , do_instantiate (instantiate) {}
 
-BuiltinModule::BuiltinModule(std::shared_ptr<AbstractNode>(*instantiate)(const ModuleInstantiation *, Arguments, const Children&), const Feature *feature) :
-  AbstractModule(feature)
-{
-  do_instantiate = [instantiate](const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context) {
-      return instantiate(inst, Arguments(inst->arguments, context), Children(&inst->scope, context));
-    };
+BuiltinModule::BuiltinModule (std::shared_ptr<AbstractNode> (*instantiate) (const ModuleInstantiation *, Arguments, const Children &), const Feature *feature)
+  : AbstractModule (feature) {
+  do_instantiate = [instantiate] (const ModuleInstantiation *inst, const std::shared_ptr<const Context> &context) {
+    return instantiate (inst, Arguments (inst->arguments, context), Children (&inst->scope, context));
+  };
 }
 
-BuiltinModule::BuiltinModule(std::shared_ptr<AbstractNode>(*instantiate)(const ModuleInstantiation *, Arguments), const Feature *feature) :
-  AbstractModule(feature)
-{
-  do_instantiate = [instantiate](const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context) {
-      Arguments arguments(inst->arguments, context);
-      noChildren(inst, arguments);
-      return instantiate(inst, std::move(arguments));
-    };
+BuiltinModule::BuiltinModule (std::shared_ptr<AbstractNode> (*instantiate) (const ModuleInstantiation *, Arguments), const Feature *feature)
+  : AbstractModule (feature) {
+  do_instantiate = [instantiate] (const ModuleInstantiation *inst, const std::shared_ptr<const Context> &context) {
+    Arguments arguments (inst->arguments, context);
+    noChildren (inst, arguments);
+    return instantiate (inst, std::move (arguments));
+  };
 }
 
-
-std::shared_ptr<AbstractNode> BuiltinModule::instantiate(const std::shared_ptr<const Context>& /*defining_context*/, const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context) const
-{
-  return do_instantiate(inst, context);
+std::shared_ptr<AbstractNode> BuiltinModule::instantiate (const std::shared_ptr<const Context> & /*defining_context*/, const ModuleInstantiation *inst, const std::shared_ptr<const Context> &context) const {
+  return do_instantiate (inst, context);
 }
 
-void BuiltinModule::noChildren(const ModuleInstantiation *inst, Arguments& arguments, std::string auxmsg) {
-  if (inst->scope.hasChildren()) {
-    LOG(message_group::Warning, inst->location(), arguments.documentRoot(),
-        "module %1$s() does not support child modules%2$s%3$s", inst->name(),
-        auxmsg.size() != 0  ? " " : "", auxmsg);
+void BuiltinModule::noChildren (const ModuleInstantiation *inst, Arguments &arguments, std::string auxmsg) {
+  if (inst->scope.hasChildren ()) {
+    LOG (message_group::Warning, inst->location (), arguments.documentRoot (),
+         "module %1$s() does not support child modules%2$s%3$s", inst->name (),
+         auxmsg.size () != 0 ? " " : "", auxmsg);
   }
 }
diff --git a/src/core/module.h b/src/core/module.h
index 49d60236a..c2f10c16f 100644
--- a/src/core/module.h
+++ b/src/core/module.h
@@ -15,31 +15,38 @@ class AbstractModule
 {
 private:
   const Feature *feature;
+
 public:
-  AbstractModule() : feature(nullptr) {}
-  AbstractModule(const Feature& feature) : feature(&feature) {}
-  AbstractModule(const Feature *feature) : feature(feature) {}
-  virtual ~AbstractModule() = default;
-  [[nodiscard]] virtual bool is_experimental() const { return feature != nullptr; }
-  [[nodiscard]] virtual bool is_enabled() const { return (feature == nullptr) || feature->is_enabled(); }
-  virtual std::shared_ptr<AbstractNode> instantiate(const std::shared_ptr<const Context>& defining_context, const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context) const = 0;
+  AbstractModule ()
+    : feature (nullptr) {}
+  AbstractModule (const Feature &feature)
+    : feature (&feature) {}
+  AbstractModule (const Feature *feature)
+    : feature (feature) {}
+  virtual ~AbstractModule () = default;
+  [[nodiscard]] virtual bool is_experimental () const {
+    return feature != nullptr;
+  }
+  [[nodiscard]] virtual bool is_enabled () const {
+    return (feature == nullptr) || feature->is_enabled ();
+  }
+  virtual std::shared_ptr<AbstractNode> instantiate (const std::shared_ptr<const Context> &defining_context, const ModuleInstantiation *inst, const std::shared_ptr<const Context> &context) const = 0;
 };
 
 class BuiltinModule : public AbstractModule
 {
 public:
-  BuiltinModule(std::shared_ptr<AbstractNode>(*instantiate)(const ModuleInstantiation *, const std::shared_ptr<const Context>&), const Feature *feature = nullptr);
-  BuiltinModule(std::shared_ptr<AbstractNode>(*instantiate)(const ModuleInstantiation *, Arguments, const Children&), const Feature *feature = nullptr);
-  BuiltinModule(std::shared_ptr<AbstractNode>(*instantiate)(const ModuleInstantiation *, Arguments), const Feature *feature = nullptr);
-  std::shared_ptr<AbstractNode> instantiate(const std::shared_ptr<const Context>& defining_context, const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context) const override;
-  static void noChildren(const ModuleInstantiation *, Arguments&, std::string auxmsg = {});
+  BuiltinModule (std::shared_ptr<AbstractNode> (*instantiate) (const ModuleInstantiation *, const std::shared_ptr<const Context> &), const Feature *feature = nullptr);
+  BuiltinModule (std::shared_ptr<AbstractNode> (*instantiate) (const ModuleInstantiation *, Arguments, const Children &), const Feature *feature = nullptr);
+  BuiltinModule (std::shared_ptr<AbstractNode> (*instantiate) (const ModuleInstantiation *, Arguments), const Feature *feature = nullptr);
+  std::shared_ptr<AbstractNode> instantiate (const std::shared_ptr<const Context> &defining_context, const ModuleInstantiation *inst, const std::shared_ptr<const Context> &context) const override;
+  static void noChildren (const ModuleInstantiation *, Arguments &, std::string auxmsg = {});
 
 private:
-  std::function<std::shared_ptr<AbstractNode>(const ModuleInstantiation *, const std::shared_ptr<const Context>&)> do_instantiate;
+  std::function<std::shared_ptr<AbstractNode> (const ModuleInstantiation *, const std::shared_ptr<const Context> &)> do_instantiate;
 };
 
-struct InstantiableModule
-{
+struct InstantiableModule {
   std::shared_ptr<const Context> defining_context;
   const AbstractModule *module;
 };
diff --git a/src/core/node.cc b/src/core/node.cc
index 87ba927be..e7d666f6f 100644
--- a/src/core/node.cc
+++ b/src/core/node.cc
@@ -39,137 +39,124 @@
 
 size_t AbstractNode::idx_counter;
 
-AbstractNode::AbstractNode(const ModuleInstantiation *mi) :
-  modinst(mi),
-  idx(idx_counter++)
-{
+AbstractNode::AbstractNode (const ModuleInstantiation *mi)
+  : modinst (mi)
+  , idx (idx_counter++) {
 }
 
-std::string AbstractNode::toString() const
-{
-  return this->name() + "()";
+std::string AbstractNode::toString () const {
+  return this->name () + "()";
 }
 
-std::shared_ptr<const AbstractNode> AbstractNode::getNodeByID(int idx, std::deque<std::shared_ptr<const AbstractNode>>& path) const
-{
-  auto self = shared_from_this();
+std::shared_ptr<const AbstractNode> AbstractNode::getNodeByID (int idx, std::deque<std::shared_ptr<const AbstractNode>> &path) const {
+  auto self = shared_from_this ();
   if (this->idx == idx) {
-    path.push_back(self);
+    path.push_back (self);
     return self;
   }
-  for (const auto& node : this->children) {
-    auto res = node->getNodeByID(idx, path);
+  for (const auto &node : this->children) {
+    auto res = node->getNodeByID (idx, path);
     if (res) {
-      path.push_back(self);
+      path.push_back (self);
       return res;
     }
   }
   return nullptr;
 }
 
-void AbstractNode::getCodeLocation(int currentLevel,  int includeLevel,
-                                   int *firstLine, int *firstColumn, int *lastLine, int *lastColumn,
-                                   int nestedModuleDepth) const
-{
-  auto location = modinst->location();
+void AbstractNode::getCodeLocation (int currentLevel, int includeLevel,
+                                    int *firstLine, int *firstColumn, int *lastLine, int *lastColumn,
+                                    int nestedModuleDepth) const {
+  auto location = modinst->location ();
   if (currentLevel >= includeLevel && nestedModuleDepth == 0) {
-    if (*firstLine < 0 || *firstLine > location.firstLine()) {
-      *firstLine = location.firstLine();
-      *firstColumn = location.firstColumn();
-    } else if (*firstLine == location.firstLine() && *firstColumn > location.firstColumn()) {
-      *firstColumn = location.firstColumn();
+    if (*firstLine < 0 || *firstLine > location.firstLine ()) {
+      *firstLine = location.firstLine ();
+      *firstColumn = location.firstColumn ();
+    } else if (*firstLine == location.firstLine () && *firstColumn > location.firstColumn ()) {
+      *firstColumn = location.firstColumn ();
     }
 
-    if (*lastLine < 0 || *lastLine < location.lastLine()) {
-      *lastLine = location.lastLine();
-      *lastColumn = location.lastColumn();
+    if (*lastLine < 0 || *lastLine < location.lastLine ()) {
+      *lastLine = location.lastLine ();
+      *lastColumn = location.lastColumn ();
     } else {
-      if (*firstLine < 0 || *firstLine > location.firstLine()) {
-        *firstLine = location.firstLine();
-        *firstColumn = location.firstColumn();
-      } else if (*firstLine == location.firstLine() && *firstColumn > location.firstColumn()) {
-        *firstColumn = location.firstColumn();
+      if (*firstLine < 0 || *firstLine > location.firstLine ()) {
+        *firstLine = location.firstLine ();
+        *firstColumn = location.firstColumn ();
+      } else if (*firstLine == location.firstLine () && *firstColumn > location.firstColumn ()) {
+        *firstColumn = location.firstColumn ();
       }
-      if (*lastLine < 0 || *lastLine < location.lastLine()) {
-        *lastLine = location.lastLine();
-        *lastColumn = location.lastColumn();
-      } else if (*lastLine == location.lastLine() && *lastColumn < location.lastColumn()) {
-        *lastColumn = location.lastColumn();
+      if (*lastLine < 0 || *lastLine < location.lastLine ()) {
+        *lastLine = location.lastLine ();
+        *lastColumn = location.lastColumn ();
+      } else if (*lastLine == location.lastLine () && *lastColumn < location.lastColumn ()) {
+        *lastColumn = location.lastColumn ();
       }
     }
   }
 
-  if (verbose_name().rfind("module", 0) == 0) {
+  if (verbose_name ().rfind ("module", 0) == 0) {
     nestedModuleDepth++;
   }
-  if (modinst->name() == "children") {
+  if (modinst->name () == "children") {
     nestedModuleDepth--;
   }
 
   if (nestedModuleDepth >= 0) {
-    for (const auto& node : children) {
-      node->getCodeLocation(currentLevel + 1, includeLevel, firstLine,  firstColumn, lastLine,
-                            lastColumn, nestedModuleDepth);
+    for (const auto &node : children) {
+      node->getCodeLocation (currentLevel + 1, includeLevel, firstLine, firstColumn, lastLine,
+                             lastColumn, nestedModuleDepth);
     }
   }
 }
 
-void AbstractNode::findNodesWithSameMod(const std::shared_ptr<const AbstractNode>& node_mod,
-                                        std::vector<std::shared_ptr<const AbstractNode>>& nodes) const {
+void AbstractNode::findNodesWithSameMod (const std::shared_ptr<const AbstractNode> &node_mod,
+                                         std::vector<std::shared_ptr<const AbstractNode>> &nodes) const {
   if (node_mod->modinst == modinst) {
-    nodes.push_back(shared_from_this());
+    nodes.push_back (shared_from_this ());
   }
-  for (const auto& step : children) {
-    step->findNodesWithSameMod(node_mod, nodes);
+  for (const auto &step : children) {
+    step->findNodesWithSameMod (node_mod, nodes);
   }
 }
 
-std::string GroupNode::name() const
-{
+std::string GroupNode::name () const {
   return "group";
 }
 
-std::string GroupNode::verbose_name() const
-{
+std::string GroupNode::verbose_name () const {
   return this->_name;
 }
 
-std::string ListNode::name() const
-{
+std::string ListNode::name () const {
   return "list";
 }
 
-std::string RootNode::name() const
-{
+std::string RootNode::name () const {
   return "root";
 }
 
-std::string AbstractIntersectionNode::toString() const
-{
-  return this->name() + "()";
+std::string AbstractIntersectionNode::toString () const {
+  return this->name () + "()";
 }
 
-std::string AbstractIntersectionNode::name() const
-{
+std::string AbstractIntersectionNode::name () const {
   // We write intersection here since the module will have to be evaluated
   // before we get here and it will not longer retain the intersection_for parameters
   return "intersection";
 }
 
-void AbstractNode::progress_prepare()
-{
-  std::for_each(this->children.begin(), this->children.end(), std::mem_fn(&AbstractNode::progress_prepare));
+void AbstractNode::progress_prepare () {
+  std::for_each (this->children.begin (), this->children.end (), std::mem_fn (&AbstractNode::progress_prepare));
   this->progress_mark = ++progress_report_count;
 }
 
-void AbstractNode::progress_report() const
-{
-  progress_update(shared_from_this(), this->progress_mark);
+void AbstractNode::progress_report () const {
+  progress_update (shared_from_this (), this->progress_mark);
 }
 
-std::ostream& operator<<(std::ostream& stream, const AbstractNode& node)
-{
-  stream << node.toString();
+std::ostream &operator<< (std::ostream &stream, const AbstractNode &node) {
+  stream << node.toString ();
   return stream;
 }
 
@@ -179,28 +166,28 @@ std::ostream& operator<<(std::ostream& stream, const AbstractNode& node)
    If a second root modifier was found, nextLocation (if non-zero) will be set to point to
    the location of that second modifier.
  */
-std::shared_ptr<AbstractNode> find_root_tag(const std::shared_ptr<AbstractNode>& node, const Location **nextLocation)
-{
+std::shared_ptr<AbstractNode> find_root_tag (const std::shared_ptr<AbstractNode> &node, const Location **nextLocation) {
   std::shared_ptr<AbstractNode> rootTag;
 
-  std::function<void (const std::shared_ptr<const AbstractNode>&)> recursive_find_tag = [&](const std::shared_ptr<const AbstractNode>& node) {
-      for (const auto& child : node->children) {
-        if (child->modinst->tag_root) {
-          if (!rootTag) {
-            rootTag = child;
-            // shortcut if we're not interested in further root modifiers
-            if (!nextLocation) return;
-          } else if (nextLocation && rootTag->modinst != child->modinst) {
-            // Throw if we have more than one root modifier in the source
-            *nextLocation = &child->modinst->location();
+  std::function<void (const std::shared_ptr<const AbstractNode> &)> recursive_find_tag = [&] (const std::shared_ptr<const AbstractNode> &node) {
+    for (const auto &child : node->children) {
+      if (child->modinst->tag_root) {
+        if (!rootTag) {
+          rootTag = child;
+          // shortcut if we're not interested in further root modifiers
+          if (!nextLocation)
             return;
-          }
+        } else if (nextLocation && rootTag->modinst != child->modinst) {
+          // Throw if we have more than one root modifier in the source
+          *nextLocation = &child->modinst->location ();
+          return;
         }
-        recursive_find_tag(child);
       }
-    };
+      recursive_find_tag (child);
+    }
+  };
 
-  recursive_find_tag(node);
+  recursive_find_tag (node);
 
   return rootTag;
 }
diff --git a/src/core/node.h b/src/core/node.h
index 070abb0e2..6e5766baa 100644
--- a/src/core/node.h
+++ b/src/core/node.h
@@ -13,11 +13,11 @@
 #include "core/ModuleInstantiation.h"
 
 extern int progress_report_count;
-extern void (*progress_report_f)(const std::shared_ptr<const AbstractNode>&, void *, int);
+extern void (*progress_report_f) (const std::shared_ptr<const AbstractNode> &, void *, int);
 extern void *progress_report_vp;
 
-void progress_report_prep(const std::shared_ptr<AbstractNode>& root, void (*f)(const std::shared_ptr<const AbstractNode>& node, void *vp, int mark), void *vp);
-void progress_report_fin();
+void progress_report_prep (const std::shared_ptr<AbstractNode> &root, void (*f) (const std::shared_ptr<const AbstractNode> &node, void *vp, int mark), void *vp);
+void progress_report_fin ();
 
 /*!
 
@@ -34,24 +34,30 @@ class AbstractNode : public BaseVisitable, public std::enable_shared_from_this<A
   // use smth. else to display node identifier in CSG tree output?
   static size_t idx_counter; // Node instantiation index
 public:
-  VISITABLE();
-  AbstractNode(const ModuleInstantiation *mi);
-  virtual std::string toString() const;
+  VISITABLE ();
+  AbstractNode (const ModuleInstantiation *mi);
+  virtual std::string toString () const;
   /*! The 'OpenSCAD name' of this node, defaults to classname, but can be
       overloaded to provide specialization for e.g. CSG nodes, primitive nodes etc.
       Used for human-readable output. */
-  virtual std::string name() const = 0;
+  virtual std::string name () const = 0;
 
   /*| When a more specific name for user interaction shall be used, such as module names,
       the verbose name shall be overloaded. */
-  virtual std::string verbose_name() const { return this->name(); }
+  virtual std::string verbose_name () const {
+    return this->name ();
+  }
 
-  const std::vector<std::shared_ptr<AbstractNode>>& getChildren() const {
+  const std::vector<std::shared_ptr<AbstractNode>> &getChildren () const {
     return this->children;
   }
-  size_t index() const { return this->idx; }
+  size_t index () const {
+    return this->idx;
+  }
 
-  static void resetIndexCounter() { idx_counter = 1; }
+  static void resetIndexCounter () {
+    idx_counter = 1;
+  }
 
   // FIXME: Make protected
   std::vector<std::shared_ptr<AbstractNode>> children;
@@ -60,37 +66,39 @@ public:
   // progress_mark is a running number used for progress indication
   // FIXME: Make all progress handling external, put it in the traverser class?
   int progress_mark{0};
-  void progress_prepare();
-  void progress_report() const;
+  void progress_prepare ();
+  void progress_report () const;
 
   int idx; // Node index (unique per tree)
 
-  std::shared_ptr<const AbstractNode> getNodeByID(int idx, std::deque<std::shared_ptr<const AbstractNode>>& path) const;
+  std::shared_ptr<const AbstractNode> getNodeByID (int idx, std::deque<std::shared_ptr<const AbstractNode>> &path) const;
 
   // returns the precise source code location associated with the node
-  void getCodeLocation(int currentLevel,  int includeLevel, int *firstLine,
-                       int *firstColumn, int *lastLine, int *lastColumn, int nestedModuleDepth) const;
+  void getCodeLocation (int currentLevel, int includeLevel, int *firstLine,
+                        int *firstColumn, int *lastLine, int *lastColumn, int nestedModuleDepth) const;
 
-  void findNodesWithSameMod(const std::shared_ptr<const AbstractNode>& node_mod,
-                            std::vector<std::shared_ptr<const AbstractNode>>& nodes) const;
+  void findNodesWithSameMod (const std::shared_ptr<const AbstractNode> &node_mod,
+                             std::vector<std::shared_ptr<const AbstractNode>> &nodes) const;
 
-  std::shared_ptr<AbstractNode> clone(void);
+  std::shared_ptr<AbstractNode> clone (void);
 };
 
 class AbstractIntersectionNode : public AbstractNode
 {
 public:
-  VISITABLE();
-  AbstractIntersectionNode(const ModuleInstantiation *mi) : AbstractNode(mi) { }
-  std::string toString() const override;
-  std::string name() const override;
+  VISITABLE ();
+  AbstractIntersectionNode (const ModuleInstantiation *mi)
+    : AbstractNode (mi) {}
+  std::string toString () const override;
+  std::string name () const override;
 };
 
 class AbstractPolyNode : public AbstractNode
 {
 public:
-  VISITABLE();
-  AbstractPolyNode(const ModuleInstantiation *mi) : AbstractNode(mi) { }
+  VISITABLE ();
+  AbstractPolyNode (const ModuleInstantiation *mi)
+    : AbstractNode (mi) {}
 
   enum class render_mode_e {
     RENDER_CGAL,
@@ -105,9 +113,10 @@ public:
 class ListNode : public AbstractNode
 {
 public:
-  VISITABLE();
-  ListNode(const ModuleInstantiation *mi) : AbstractNode(mi) { }
-  std::string name() const override;
+  VISITABLE ();
+  ListNode (const ModuleInstantiation *mi)
+    : AbstractNode (mi) {}
+  std::string name () const override;
 };
 
 /*!
@@ -117,10 +126,13 @@ public:
 class GroupNode : public AbstractNode
 {
 public:
-  VISITABLE();
-  GroupNode(const ModuleInstantiation *mi, std::string name = "") : AbstractNode(mi), _name(std::move(name)) { }
-  std::string name() const override;
-  std::string verbose_name() const override;
+  VISITABLE ();
+  GroupNode (const ModuleInstantiation *mi, std::string name = "")
+    : AbstractNode (mi)
+    , _name (std::move (name)) {}
+  std::string name () const override;
+  std::string verbose_name () const override;
+
 private:
   const std::string _name;
 };
@@ -131,9 +143,12 @@ private:
 class RootNode : public GroupNode
 {
 public:
-  VISITABLE();
-  RootNode() : GroupNode(&mi), mi("group") { }
-  std::string name() const override;
+  VISITABLE ();
+  RootNode ()
+    : GroupNode (&mi)
+    , mi ("group") {}
+  std::string name () const override;
+
 private:
   ModuleInstantiation mi;
 };
@@ -141,10 +156,11 @@ private:
 class LeafNode : public AbstractPolyNode
 {
 public:
-  VISITABLE();
-  LeafNode(const ModuleInstantiation *mi) : AbstractPolyNode(mi) { }
-  virtual std::unique_ptr<const class Geometry> createGeometry() const = 0;
+  VISITABLE ();
+  LeafNode (const ModuleInstantiation *mi)
+    : AbstractPolyNode (mi) {}
+  virtual std::unique_ptr<const class Geometry> createGeometry () const = 0;
 };
 
-std::ostream& operator<<(std::ostream& stream, const AbstractNode& node);
-std::shared_ptr<AbstractNode> find_root_tag(const std::shared_ptr<AbstractNode>& node, const Location **nextLocation = nullptr);
+std::ostream &operator<< (std::ostream &stream, const AbstractNode &node);
+std::shared_ptr<AbstractNode> find_root_tag (const std::shared_ptr<AbstractNode> &node, const Location **nextLocation = nullptr);
diff --git a/src/core/node_clone.cc b/src/core/node_clone.cc
index b383f13a3..c3c9b2ea2 100644
--- a/src/core/node_clone.cc
+++ b/src/core/node_clone.cc
@@ -43,74 +43,79 @@
 
 std::vector<ModuleInstantiation *> modinsts_list;
 
-#define NodeCloneFunc(T) std::shared_ptr<T> clone_what(const T * node) { \
-          ModuleInstantiation *inst = new ModuleInstantiation(node->modinst->name(), \
-                                                              node->modinst->arguments, node->modinst->location()); \
-          modinsts_list.push_back(inst); \
-          auto clone = std::make_shared<T>(*node); \
-          clone->modinst = inst; \
-          return clone; \
-}
+#define NodeCloneFunc(T)                                                                                        \
+  std::shared_ptr<T> clone_what (const T *node) {                                                               \
+    ModuleInstantiation *inst = new ModuleInstantiation (node->modinst->name (),                                \
+                                                         node->modinst->arguments, node->modinst->location ()); \
+    modinsts_list.push_back (inst);                                                                             \
+    auto clone = std::make_shared<T> (*node);                                                                   \
+    clone->modinst = inst;                                                                                      \
+    return clone;                                                                                               \
+  }
 
-#define NodeCloneUse(T) { const T *node = dynamic_cast<const T *>(this); if ((node) != nullptr) clone = clone_what(node); }
-NodeCloneFunc(CubeNode)
-NodeCloneFunc(SphereNode)
-NodeCloneFunc(CylinderNode)
-NodeCloneFunc(PolyhedronNode)
-NodeCloneFunc(SquareNode)
-NodeCloneFunc(CircleNode)
-NodeCloneFunc(PolygonNode)
-NodeCloneFunc(TransformNode)
-NodeCloneFunc(ColorNode)
-NodeCloneFunc(RotateExtrudeNode)
-NodeCloneFunc(LinearExtrudeNode)
-NodeCloneFunc(CsgOpNode)
-NodeCloneFunc(CgalAdvNode)
-NodeCloneFunc(RenderNode)
-NodeCloneFunc(SurfaceNode)
-NodeCloneFunc(TextNode)
-NodeCloneFunc(OffsetNode)
-NodeCloneFunc(ProjectionNode)
-NodeCloneFunc(GroupNode)
-NodeCloneFunc(ImportNode)
+#define NodeCloneUse(T)                             \
+  {                                                 \
+    const T *node = dynamic_cast<const T *> (this); \
+    if ((node) != nullptr)                          \
+      clone = clone_what (node);                    \
+  }
+NodeCloneFunc (CubeNode)
+  NodeCloneFunc (SphereNode)
+    NodeCloneFunc (CylinderNode)
+      NodeCloneFunc (PolyhedronNode)
+        NodeCloneFunc (SquareNode)
+          NodeCloneFunc (CircleNode)
+            NodeCloneFunc (PolygonNode)
+              NodeCloneFunc (TransformNode)
+                NodeCloneFunc (ColorNode)
+                  NodeCloneFunc (RotateExtrudeNode)
+                    NodeCloneFunc (LinearExtrudeNode)
+                      NodeCloneFunc (CsgOpNode)
+                        NodeCloneFunc (CgalAdvNode)
+                          NodeCloneFunc (RenderNode)
+                            NodeCloneFunc (SurfaceNode)
+                              NodeCloneFunc (TextNode)
+                                NodeCloneFunc (OffsetNode)
+                                  NodeCloneFunc (ProjectionNode)
+                                    NodeCloneFunc (GroupNode)
+                                      NodeCloneFunc (ImportNode)
 #if defined(ENABLE_EXPERIMENTAL) && defined(ENABLE_CGAL)
-NodeCloneFunc(RoofNode)
+                                        NodeCloneFunc (RoofNode)
 #endif
 
-std::shared_ptr<AbstractNode> AbstractNode::clone(void)
-{
+                                          std::shared_ptr<AbstractNode> AbstractNode::clone (void) {
   std::shared_ptr<AbstractNode> clone = nullptr;
-  NodeCloneUse(CubeNode)
-  NodeCloneUse(SphereNode)
-  NodeCloneUse(CylinderNode)
-  NodeCloneUse(PolyhedronNode)
-  NodeCloneUse(SquareNode)
-  NodeCloneUse(CircleNode)
-  NodeCloneUse(PolygonNode)
-  NodeCloneUse(TransformNode)
-  NodeCloneUse(ColorNode)
-  NodeCloneUse(RotateExtrudeNode)
-  NodeCloneUse(LinearExtrudeNode)
-  NodeCloneUse(CsgOpNode)
-  NodeCloneUse(CgalAdvNode)
-  NodeCloneUse(RenderNode)
-  NodeCloneUse(SurfaceNode)
-  NodeCloneUse(TextNode)
-  NodeCloneUse(OffsetNode)
-  NodeCloneUse(ProjectionNode)
-  NodeCloneUse(GroupNode)
-  NodeCloneUse(ImportNode)
+  NodeCloneUse (CubeNode)
+    NodeCloneUse (SphereNode)
+      NodeCloneUse (CylinderNode)
+        NodeCloneUse (PolyhedronNode)
+          NodeCloneUse (SquareNode)
+            NodeCloneUse (CircleNode)
+              NodeCloneUse (PolygonNode)
+                NodeCloneUse (TransformNode)
+                  NodeCloneUse (ColorNode)
+                    NodeCloneUse (RotateExtrudeNode)
+                      NodeCloneUse (LinearExtrudeNode)
+                        NodeCloneUse (CsgOpNode)
+                          NodeCloneUse (CgalAdvNode)
+                            NodeCloneUse (RenderNode)
+                              NodeCloneUse (SurfaceNode)
+                                NodeCloneUse (TextNode)
+                                  NodeCloneUse (OffsetNode)
+                                    NodeCloneUse (ProjectionNode)
+                                      NodeCloneUse (GroupNode)
+                                        NodeCloneUse (ImportNode)
 #if defined(ENABLE_EXPERIMENTAL) && defined(ENABLE_CGAL)
-  NodeCloneUse(RoofNode)
+                                          NodeCloneUse (RoofNode)
 #endif
-  if (clone != nullptr) {
+                                            if (clone != nullptr) {
     clone->idx = idx_counter++;
-    clone->children.clear();
-    for (const auto& child: this->children) {
-      clone->children.push_back(child->clone());
+    clone->children.clear ();
+    for (const auto &child : this->children) {
+      clone->children.push_back (child->clone ());
     }
     return clone;
   }
-  std::cout << "Type not defined for clone :" << typeid(this).name() << "\n\r";
-  return std::shared_ptr<AbstractNode>(this);
+  std::cout << "Type not defined for clone :" << typeid (this).name () << "\n\r";
+  return std::shared_ptr<AbstractNode> (this);
 }
diff --git a/src/core/parsersettings.cc b/src/core/parsersettings.cc
index 2a867fdb6..145c6ac1a 100644
--- a/src/core/parsersettings.cc
+++ b/src/core/parsersettings.cc
@@ -14,13 +14,11 @@ namespace fs = std::filesystem;
 
 std::vector<std::string> librarypath;
 
-static void add_librarydir(const std::string& libdir)
-{
-  librarypath.push_back(libdir);
+static void add_librarydir (const std::string &libdir) {
+  librarypath.push_back (libdir);
 }
 
-const std::vector<std::string>& get_library_path()
-{
+const std::vector<std::string> &get_library_path () {
   return librarypath;
 }
 
@@ -28,12 +26,11 @@ const std::vector<std::string>& get_library_path()
    Searces for the given file in library paths and returns the full path if found.
    Returns an empty path if file cannot be found or filename is a directory.
  */
-fs::path search_libs(const fs::path& localpath)
-{
-  for (const auto& dir : librarypath) {
-    fs::path usepath = fs::path(dir) / localpath;
-    if (fs::exists(usepath) && !fs::is_directory(usepath)) {
-      return usepath.string();
+fs::path search_libs (const fs::path &localpath) {
+  for (const auto &dir : librarypath) {
+    fs::path usepath = fs::path (dir) / localpath;
+    if (fs::exists (usepath) && !fs::is_directory (usepath)) {
+      return usepath.string ();
     }
   }
   return {};
@@ -42,28 +39,27 @@ fs::path search_libs(const fs::path& localpath)
 // files must be 'ordinary' - they must exist and be non-directories
 // FIXME: We cannot print any output here since these function is called periodically
 // from "Automatic reload and compile"
-static bool check_valid(const fs::path& p, const std::vector<std::string> *openfilenames)
-{
-  if (p.empty()) {
+static bool check_valid (const fs::path &p, const std::vector<std::string> *openfilenames) {
+  if (p.empty ()) {
     // LOG(message_group::Warning,,"File path is blank: %1$s",p);
     return false;
   }
-  if (!p.has_parent_path()) {
+  if (!p.has_parent_path ()) {
     // LOG(message_group::Warning,,"No parent path: %1$s",p);
     return false;
   }
-  if (!fs::exists(p)) {
+  if (!fs::exists (p)) {
     // LOG(message_group::Warning,,"File not found: %1$s",p);
     return false;
   }
-  if (fs::is_directory(p)) {
+  if (fs::is_directory (p)) {
     // LOG(message_group::Warning,,"%1$s invalid - points to a directory",p);
     return false;
   }
-  const std::string& fullname = p.generic_string();
+  const std::string &fullname = p.generic_string ();
   // Detect circular includes
   if (openfilenames) {
-    for (const auto& s : *openfilenames) {
+    for (const auto &s : *openfilenames) {
       if (s == fullname) {
         // LOG(message_group::Warning,,"circular include file %1$s",fullname);
         return false;
@@ -82,14 +78,13 @@ static bool check_valid(const fs::path& p, const std::vector<std::string> *openf
    Returns the absolute path to a valid file, or an empty path if no
    valid files could be found.
  */
-inline fs::path find_valid_path_(const fs::path& sourcepath,
-                                 const fs::path& localpath,
-                                 const std::vector<std::string> *openfilenames)
-{
-  if (localpath.is_absolute()) {
-    if (check_valid(localpath, openfilenames)) {
+inline fs::path find_valid_path_ (const fs::path &sourcepath,
+                                  const fs::path &localpath,
+                                  const std::vector<std::string> *openfilenames) {
+  if (localpath.is_absolute ()) {
+    if (check_valid (localpath, openfilenames)) {
 #ifndef __EMSCRIPTEN__
-      return fs::canonical(localpath);
+      return fs::canonical (localpath);
 #else
       return localpath;
 #endif
@@ -97,77 +92,76 @@ inline fs::path find_valid_path_(const fs::path& sourcepath,
   } else {
     fs::path fpath = sourcepath / localpath;
 #ifndef __EMSCRIPTEN__
-    if (fs::exists(fpath)) fpath = fs::canonical(fpath);
+    if (fs::exists (fpath))
+      fpath = fs::canonical (fpath);
 #endif
-    if (check_valid(fpath, openfilenames)) return fpath;
-    fpath = search_libs(localpath);
-    if (!fpath.empty() && check_valid(fpath, openfilenames)) return fpath;
+    if (check_valid (fpath, openfilenames))
+      return fpath;
+    fpath = search_libs (localpath);
+    if (!fpath.empty () && check_valid (fpath, openfilenames))
+      return fpath;
   }
   return {};
 }
 
-fs::path find_valid_path(const fs::path& sourcepath,
-                         const fs::path& localpath,
-                         const std::vector<std::string> *openfilenames)
-{
-  return {find_valid_path_(sourcepath, localpath, openfilenames).generic_string()};
+fs::path find_valid_path (const fs::path &sourcepath,
+                          const fs::path &localpath,
+                          const std::vector<std::string> *openfilenames) {
+  return {find_valid_path_ (sourcepath, localpath, openfilenames).generic_string ()};
 }
 
-
-static bool path_contains_file(fs::path dir, fs::path file)
-{
+static bool path_contains_file (fs::path dir, fs::path file) {
   // from https://stackoverflow.com/a/15549954/1080604
   // If dir ends with "/" and isn't the root directory, then the final
   // component returned by iterators will include "." and will interfere
   // with the std::equal check below, so we strip it before proceeding.
-  if (dir.filename() == ".") dir.remove_filename();
+  if (dir.filename () == ".")
+    dir.remove_filename ();
   // We're also not interested in the file's name.
-  assert(file.has_filename());
-  file.remove_filename();
+  assert (file.has_filename ());
+  file.remove_filename ();
 
   // If dir has more components than file, then file can't possibly
   // reside in dir.
-  auto dir_len = std::distance(dir.begin(), dir.end());
-  auto file_len = std::distance(file.begin(), file.end());
-  if (dir_len > file_len) return false;
+  auto dir_len = std::distance (dir.begin (), dir.end ());
+  auto file_len = std::distance (file.begin (), file.end ());
+  if (dir_len > file_len)
+    return false;
 
   // This stops checking when it reaches dir.end(), so it's OK if file
   // has more directory components afterward. They won't be checked.
-  return std::equal(dir.begin(), dir.end(), file.begin());
+  return std::equal (dir.begin (), dir.end (), file.begin ());
 }
 
-fs::path get_library_for_path(const fs::path& localpath)
-{
-  for (const auto& libpath : librarypath) {
-    if (path_contains_file(fs::path(libpath), localpath)) {
+fs::path get_library_for_path (const fs::path &localpath) {
+  for (const auto &libpath : librarypath) {
+    if (path_contains_file (fs::path (libpath), localpath)) {
       return libpath;
     }
   }
   return {};
 }
 
-
-void parser_init()
-{
+void parser_init () {
   // Add paths from OPENSCADPATH before adding built-in paths
-  const char *openscadpaths = getenv("OPENSCADPATH");
+  const char *openscadpaths = getenv ("OPENSCADPATH");
   if (openscadpaths) {
-    std::string paths(openscadpaths);
-    std::string sep = PlatformUtils::pathSeparatorChar();
+    std::string paths (openscadpaths);
+    std::string sep = PlatformUtils::pathSeparatorChar ();
     using string_split_iterator = boost::split_iterator<std::string::iterator>;
-    for (string_split_iterator it = boost::make_split_iterator(paths, boost::first_finder(sep, boost::is_iequal())); it != string_split_iterator(); ++it) {
-      auto str{boost::copy_range<std::string>(*it)};
-      fs::path abspath = str.empty() ? fs::current_path() : fs::absolute(fs::path(str));
-      add_librarydir(abspath.generic_string());
+    for (string_split_iterator it = boost::make_split_iterator (paths, boost::first_finder (sep, boost::is_iequal ())); it != string_split_iterator (); ++it) {
+      auto str{boost::copy_range<std::string> (*it)};
+      fs::path abspath = str.empty () ? fs::current_path () : fs::absolute (fs::path (str));
+      add_librarydir (abspath.generic_string ());
     }
   }
 
-  add_librarydir(PlatformUtils::userLibraryPath());
+  add_librarydir (PlatformUtils::userLibraryPath ());
 
-  fs::path libpath = PlatformUtils::resourcePath("libraries");
+  fs::path libpath = PlatformUtils::resourcePath ("libraries");
   // std::filesystem::absolute() will throw if passed empty path
-  if (libpath.empty()) {
-    libpath = fs::current_path();
+  if (libpath.empty ()) {
+    libpath = fs::current_path ();
   }
-  add_librarydir(fs::absolute(libpath).string());
+  add_librarydir (fs::absolute (libpath).string ());
 }
diff --git a/src/core/parsersettings.h b/src/core/parsersettings.h
index 7ae3a9a5e..d2a97c629 100644
--- a/src/core/parsersettings.h
+++ b/src/core/parsersettings.h
@@ -11,12 +11,12 @@ extern int parser_error_pos;
 /**
  * Initialize library path.
  */
-void parser_init();
+void parser_init ();
 
-fs::path search_libs(const fs::path& localpath);
-fs::path find_valid_path(const fs::path& sourcepath,
-                         const fs::path& localpath,
-                         const std::vector<std::string> *openfilenames = nullptr);
-fs::path get_library_for_path(const fs::path& localpath);
+fs::path search_libs (const fs::path &localpath);
+fs::path find_valid_path (const fs::path &sourcepath,
+                          const fs::path &localpath,
+                          const std::vector<std::string> *openfilenames = nullptr);
+fs::path get_library_for_path (const fs::path &localpath);
 
-const std::vector<std::string>& get_library_path();
\ No newline at end of file
+const std::vector<std::string> &get_library_path ();
\ No newline at end of file
diff --git a/src/core/primitives.cc b/src/core/primitives.cc
index 3db0f7aba..aeced70e9 100644
--- a/src/core/primitives.cc
+++ b/src/core/primitives.cc
@@ -55,10 +55,10 @@ using namespace boost::assign; // bring 'operator+=()' into scope
 #define F_MINIMUM 0.01
 
 template <class InsertIterator>
-static void generate_circle(InsertIterator iter, double r, double z, int fragments) {
+static void generate_circle (InsertIterator iter, double r, double z, int fragments) {
   for (int i = 0; i < fragments; ++i) {
     double phi = (360.0 * i) / fragments;
-    *(iter++) = {r *cos_degrees(phi), r *sin_degrees(phi), z};
+    *(iter++) = {r * cos_degrees (phi), r * sin_degrees (phi), z};
   }
 }
 
@@ -74,53 +74,45 @@ static void generate_circle(InsertIterator iter, double r, double z, int fragmen
  * @return radius value of type Value::Type::NUMBER or Value::Type::UNDEFINED if both
  *         variables are invalid or not set.
  */
-static Value lookup_radius(const Parameters& parameters, const ModuleInstantiation *inst, const std::string& diameter_var, const std::string& radius_var)
-{
-  const auto& d = parameters[diameter_var];
-  const auto& r = parameters[radius_var];
-  const auto r_defined = (r.type() == Value::Type::NUMBER);
+static Value lookup_radius (const Parameters &parameters, const ModuleInstantiation *inst, const std::string &diameter_var, const std::string &radius_var) {
+  const auto &d = parameters[diameter_var];
+  const auto &r = parameters[radius_var];
+  const auto r_defined = (r.type () == Value::Type::NUMBER);
 
-  if (d.type() == Value::Type::NUMBER) {
+  if (d.type () == Value::Type::NUMBER) {
     if (r_defined) {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
-          "Ignoring radius variable %1$s as diameter %2$s is defined too.",
-          quoteVar(radius_var), quoteVar(diameter_var));
+      LOG (message_group::Warning, inst->location (), parameters.documentRoot (),
+           "Ignoring radius variable %1$s as diameter %2$s is defined too.",
+           quoteVar (radius_var), quoteVar (diameter_var));
     }
-    return d.toDouble() / 2.0;
+    return d.toDouble () / 2.0;
   } else if (r_defined) {
-    return r.clone();
+    return r.clone ();
   } else {
-    return Value::undefined.clone();
+    return Value::undefined.clone ();
   }
 }
 
-static void set_fragments(const Parameters& parameters, const ModuleInstantiation *inst, double& fn, double& fs, double& fa)
-{
-  fn = parameters["$fn"].toDouble();
-  fs = parameters["$fs"].toDouble();
-  fa = parameters["$fa"].toDouble();
+static void set_fragments (const Parameters &parameters, const ModuleInstantiation *inst, double &fn, double &fs, double &fa) {
+  fn = parameters["$fn"].toDouble ();
+  fs = parameters["$fs"].toDouble ();
+  fa = parameters["$fa"].toDouble ();
 
   if (fs < F_MINIMUM) {
-    LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
-        "$fs too small - clamping to %1$f", F_MINIMUM);
+    LOG (message_group::Warning, inst->location (), parameters.documentRoot (),
+         "$fs too small - clamping to %1$f", F_MINIMUM);
     fs = F_MINIMUM;
   }
   if (fa < F_MINIMUM) {
-    LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
-        "$fa too small - clamping to %1$f", F_MINIMUM);
+    LOG (message_group::Warning, inst->location (), parameters.documentRoot (),
+         "$fa too small - clamping to %1$f", F_MINIMUM);
     fa = F_MINIMUM;
   }
 }
 
-
-
-std::unique_ptr<const Geometry> CubeNode::createGeometry() const
-{
-  if (this->x <= 0 || !std::isfinite(this->x)
-      || this->y <= 0 || !std::isfinite(this->y)
-      || this->z <= 0 || !std::isfinite(this->z)
-      ) {
-    return PolySet::createEmpty();
+std::unique_ptr<const Geometry> CubeNode::createGeometry () const {
+  if (this->x <= 0 || !std::isfinite (this->x) || this->y <= 0 || !std::isfinite (this->y) || this->z <= 0 || !std::isfinite (this->z)) {
+    return PolySet::createEmpty ();
   }
 
   double x1, x2, y1, y2, z1, z2;
@@ -137,86 +129,84 @@ std::unique_ptr<const Geometry> CubeNode::createGeometry() const
     y2 = this->y;
     z2 = this->z;
   }
-  auto ps = std::make_unique<PolySet>(3, /*convex*/ true);
+  auto ps = std::make_unique<PolySet> (3, /*convex*/ true);
   for (int i = 0; i < 8; i++) {
-    ps->vertices.emplace_back(i & 1 ? x2 : x1, i & 2 ? y2 : y1,
-                              i & 4 ? z2 : z1);
+    ps->vertices.emplace_back (i & 1 ? x2 : x1, i & 2 ? y2 : y1,
+                               i & 4 ? z2 : z1);
   }
   ps->indices = {
-    {4, 5, 7, 6},   // top
-    {2, 3, 1, 0},   // bottom
-    {0, 1, 5, 4},   // front
-    {1, 3, 7, 5},   // right
-    {3, 2, 6, 7},   // back
-    {2, 0, 4, 6},   // left
+    {4, 5, 7, 6}, // top
+    {2, 3, 1, 0}, // bottom
+    {0, 1, 5, 4}, // front
+    {1, 3, 7, 5}, // right
+    {3, 2, 6, 7}, // back
+    {2, 0, 4, 6}, // left
   };
 
   return ps;
 }
 
-static std::shared_ptr<AbstractNode> builtin_cube(const ModuleInstantiation *inst, Arguments arguments)
-{
-  auto node = std::make_shared<CubeNode>(inst);
+static std::shared_ptr<AbstractNode> builtin_cube (const ModuleInstantiation *inst, Arguments arguments) {
+  auto node = std::make_shared<CubeNode> (inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"size", "center"});
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (), {"size", "center"});
 
-  const auto& size = parameters["size"];
-  if (size.isDefined()) {
+  const auto &size = parameters["size"];
+  if (size.isDefined ()) {
     bool converted = false;
-    converted |= size.getDouble(node->x);
-    converted |= size.getDouble(node->y);
-    converted |= size.getDouble(node->z);
-    converted |= size.getVec3(node->x, node->y, node->z);
+    converted |= size.getDouble (node->x);
+    converted |= size.getDouble (node->y);
+    converted |= size.getDouble (node->z);
+    converted |= size.getVec3 (node->x, node->y, node->z);
     if (!converted) {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Unable to convert cube(size=%1$s, ...) parameter to a number or a vec3 of numbers", size.toEchoStringNoThrow());
+      LOG (message_group::Warning, inst->location (), parameters.documentRoot (), "Unable to convert cube(size=%1$s, ...) parameter to a number or a vec3 of numbers", size.toEchoStringNoThrow ());
     } else if (OpenSCAD::rangeCheck) {
       bool ok = (node->x > 0) && (node->y > 0) && (node->z > 0);
-      ok &= std::isfinite(node->x) && std::isfinite(node->y) && std::isfinite(node->z);
+      ok &= std::isfinite (node->x) && std::isfinite (node->y) && std::isfinite (node->z);
       if (!ok) {
-        LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "cube(size=%1$s, ...)", size.toEchoStringNoThrow());
+        LOG (message_group::Warning, inst->location (), parameters.documentRoot (), "cube(size=%1$s, ...)", size.toEchoStringNoThrow ());
       }
     }
   }
-  if (parameters["center"].type() == Value::Type::BOOL) {
-    node->center = parameters["center"].toBool();
+  if (parameters["center"].type () == Value::Type::BOOL) {
+    node->center = parameters["center"].toBool ();
   }
 
   return node;
 }
 
-std::unique_ptr<const Geometry> SphereNode::createGeometry() const
-{
-  if (this->r <= 0 || !std::isfinite(this->r)) {
-    return PolySet::createEmpty();
+std::unique_ptr<const Geometry> SphereNode::createGeometry () const {
+  if (this->r <= 0 || !std::isfinite (this->r)) {
+    return PolySet::createEmpty ();
   }
 
-  auto num_fragments = Calc::get_fragments_from_r(r, fn, fs, fa);
+  auto num_fragments = Calc::get_fragments_from_r (r, fn, fs, fa);
   size_t num_rings = (num_fragments + 1) / 2;
   // Uncomment the following three lines to enable experimental sphere
   // tessellation
   //  if (num_rings % 2 == 0) num_rings++; // To ensure that the middle ring is at
   //  phi == 0 degrees
 
-  auto polyset = std::make_unique<PolySet>(3, /*convex*/ true);
-  polyset->vertices.reserve(num_rings * num_fragments);
+  auto polyset = std::make_unique<PolySet> (3, /*convex*/ true);
+  polyset->vertices.reserve (num_rings * num_fragments);
 
   // double offset = 0.5 * ((fragments / 2) % 2);
   for (int i = 0; i < num_rings; ++i) {
     //                double phi = (180.0 * (i + offset)) / (fragments/2);
     const double phi = (180.0 * (i + 0.5)) / num_rings;
-    const double radius = r * sin_degrees(phi);
-    generate_circle(std::back_inserter(polyset->vertices), radius, r * cos_degrees(phi), num_fragments);
+    const double radius = r * sin_degrees (phi);
+    generate_circle (std::back_inserter (polyset->vertices), radius, r * cos_degrees (phi), num_fragments);
   }
 
-  polyset->indices.push_back({});
+  polyset->indices.push_back ({});
   for (int i = 0; i < num_fragments; ++i) {
-    polyset->indices.back().push_back(i);
+    polyset->indices.back ().push_back (i);
   }
 
   for (int i = 0; i < num_rings - 1; ++i) {
     for (int r = 0; r < num_fragments; ++r) {
-      polyset->indices.push_back({
-        i *num_fragments + (r + 1) % num_fragments,
+      polyset->indices.push_back ({
+        i * num_fragments + (r + 1) % num_fragments,
         i * num_fragments + r,
         (i + 1) * num_fragments + r,
         (i + 1) * num_fragments + (r + 1) % num_fragments,
@@ -224,47 +214,39 @@ std::unique_ptr<const Geometry> SphereNode::createGeometry() const
     }
   }
 
-  polyset->indices.push_back({});
+  polyset->indices.push_back ({});
   for (int i = 0; i < num_fragments; ++i) {
-    polyset->indices.back().push_back(num_rings * num_fragments - i - 1);
+    polyset->indices.back ().push_back (num_rings * num_fragments - i - 1);
   }
 
   return polyset;
 }
 
-static std::shared_ptr<AbstractNode> builtin_sphere(const ModuleInstantiation *inst, Arguments arguments)
-{
-  auto node = std::make_shared<SphereNode>(inst);
+static std::shared_ptr<AbstractNode> builtin_sphere (const ModuleInstantiation *inst, Arguments arguments) {
+  auto node = std::make_shared<SphereNode> (inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"r"}, {"d"});
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (), {"r"}, {"d"});
 
-  set_fragments(parameters, inst, node->fn, node->fs, node->fa);
-  const auto r = lookup_radius(parameters, inst, "d", "r");
-  if (r.type() == Value::Type::NUMBER) {
-    node->r = r.toDouble();
-    if (OpenSCAD::rangeCheck && (node->r <= 0 || !std::isfinite(node->r))) {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
-          "sphere(r=%1$s)", r.toEchoStringNoThrow());
+  set_fragments (parameters, inst, node->fn, node->fs, node->fa);
+  const auto r = lookup_radius (parameters, inst, "d", "r");
+  if (r.type () == Value::Type::NUMBER) {
+    node->r = r.toDouble ();
+    if (OpenSCAD::rangeCheck && (node->r <= 0 || !std::isfinite (node->r))) {
+      LOG (message_group::Warning, inst->location (), parameters.documentRoot (),
+           "sphere(r=%1$s)", r.toEchoStringNoThrow ());
     }
   }
 
   return node;
 }
 
-
-
-std::unique_ptr<const Geometry> CylinderNode::createGeometry() const
-{
+std::unique_ptr<const Geometry> CylinderNode::createGeometry () const {
   if (
-    this->h <= 0 || !std::isfinite(this->h)
-    || this->r1 < 0 || !std::isfinite(this->r1)
-    || this->r2 < 0 || !std::isfinite(this->r2)
-    || (this->r1 <= 0 && this->r2 <= 0)
-    ) {
-    return PolySet::createEmpty();
+    this->h <= 0 || !std::isfinite (this->h) || this->r1 < 0 || !std::isfinite (this->r1) || this->r2 < 0 || !std::isfinite (this->r2) || (this->r1 <= 0 && this->r2 <= 0)) {
+    return PolySet::createEmpty ();
   }
 
-  auto num_fragments = Calc::get_fragments_from_r(std::fmax(this->r1, this->r2), this->fn, this->fs, this->fa);
+  auto num_fragments = Calc::get_fragments_from_r (std::fmax (this->r1, this->r2), this->fn, this->fs, this->fa);
 
   double z1, z2;
   if (this->center) {
@@ -278,101 +260,100 @@ std::unique_ptr<const Geometry> CylinderNode::createGeometry() const
   bool cone = (r2 == 0.0);
   bool inverted_cone = (r1 == 0.0);
 
-  auto polyset = std::make_unique<PolySet>(3, /*convex*/ true);
-  polyset->vertices.reserve((cone || inverted_cone) ? num_fragments + 1 : 2 * num_fragments);
+  auto polyset = std::make_unique<PolySet> (3, /*convex*/ true);
+  polyset->vertices.reserve ((cone || inverted_cone) ? num_fragments + 1 : 2 * num_fragments);
 
   if (inverted_cone) {
-    polyset->vertices.emplace_back(0.0, 0.0, z1);
+    polyset->vertices.emplace_back (0.0, 0.0, z1);
   } else {
-    generate_circle(std::back_inserter(polyset->vertices), r1, z1, num_fragments);
+    generate_circle (std::back_inserter (polyset->vertices), r1, z1, num_fragments);
   }
   if (cone) {
-    polyset->vertices.emplace_back(0.0, 0.0, z2);
+    polyset->vertices.emplace_back (0.0, 0.0, z2);
   } else {
-    generate_circle(std::back_inserter(polyset->vertices), r2, z2, num_fragments);
+    generate_circle (std::back_inserter (polyset->vertices), r2, z2, num_fragments);
   }
 
   for (int i = 0; i < num_fragments; ++i) {
     int j = (i + 1) % num_fragments;
-    if (cone) polyset->indices.push_back({i, j, num_fragments});
-    else if (inverted_cone) polyset->indices.push_back({0, j + 1, i + 1});
-    else polyset->indices.push_back({i, j, j + num_fragments, i + num_fragments});
+    if (cone)
+      polyset->indices.push_back ({i, j, num_fragments});
+    else if (inverted_cone)
+      polyset->indices.push_back ({0, j + 1, i + 1});
+    else
+      polyset->indices.push_back ({i, j, j + num_fragments, i + num_fragments});
   }
 
   if (!inverted_cone) {
-    polyset->indices.push_back({});
+    polyset->indices.push_back ({});
     for (int i = 0; i < num_fragments; ++i) {
-      polyset->indices.back().push_back(num_fragments - i - 1);
+      polyset->indices.back ().push_back (num_fragments - i - 1);
     }
   }
   if (!cone) {
-    polyset->indices.push_back({});
+    polyset->indices.push_back ({});
     int offset = inverted_cone ? 1 : num_fragments;
     for (int i = 0; i < num_fragments; ++i) {
-      polyset->indices.back().push_back(offset + i);
+      polyset->indices.back ().push_back (offset + i);
     }
   }
 
   return polyset;
 }
 
-static std::shared_ptr<AbstractNode> builtin_cylinder(const ModuleInstantiation *inst, Arguments arguments)
-{
-  auto node = std::make_shared<CylinderNode>(inst);
+static std::shared_ptr<AbstractNode> builtin_cylinder (const ModuleInstantiation *inst, Arguments arguments) {
+  auto node = std::make_shared<CylinderNode> (inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"h", "r1", "r2", "center"}, {"r", "d", "d1", "d2"});
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (), {"h", "r1", "r2", "center"}, {"r", "d", "d1", "d2"});
 
-  set_fragments(parameters, inst, node->fn, node->fs, node->fa);
-  if (parameters["h"].type() == Value::Type::NUMBER) {
-    node->h = parameters["h"].toDouble();
+  set_fragments (parameters, inst, node->fn, node->fs, node->fa);
+  if (parameters["h"].type () == Value::Type::NUMBER) {
+    node->h = parameters["h"].toDouble ();
   }
 
-  auto r = lookup_radius(parameters, inst, "d", "r");
-  auto r1 = lookup_radius(parameters, inst, "d1", "r1");
-  auto r2 = lookup_radius(parameters, inst, "d2", "r2");
-  if (r.type() == Value::Type::NUMBER &&
-      (r1.type() == Value::Type::NUMBER || r2.type() == Value::Type::NUMBER)
-      ) {
-    LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Cylinder parameters ambiguous");
+  auto r = lookup_radius (parameters, inst, "d", "r");
+  auto r1 = lookup_radius (parameters, inst, "d1", "r1");
+  auto r2 = lookup_radius (parameters, inst, "d2", "r2");
+  if (r.type () == Value::Type::NUMBER &&
+      (r1.type () == Value::Type::NUMBER || r2.type () == Value::Type::NUMBER)) {
+    LOG (message_group::Warning, inst->location (), parameters.documentRoot (), "Cylinder parameters ambiguous");
   }
 
-  if (r.type() == Value::Type::NUMBER) {
-    node->r1 = r.toDouble();
-    node->r2 = r.toDouble();
+  if (r.type () == Value::Type::NUMBER) {
+    node->r1 = r.toDouble ();
+    node->r2 = r.toDouble ();
   }
-  if (r1.type() == Value::Type::NUMBER) {
-    node->r1 = r1.toDouble();
+  if (r1.type () == Value::Type::NUMBER) {
+    node->r1 = r1.toDouble ();
   }
-  if (r2.type() == Value::Type::NUMBER) {
-    node->r2 = r2.toDouble();
+  if (r2.type () == Value::Type::NUMBER) {
+    node->r2 = r2.toDouble ();
   }
 
   if (OpenSCAD::rangeCheck) {
-    if (node->h <= 0 || !std::isfinite(node->h)) {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "cylinder(h=%1$s, ...)", parameters["h"].toEchoStringNoThrow());
+    if (node->h <= 0 || !std::isfinite (node->h)) {
+      LOG (message_group::Warning, inst->location (), parameters.documentRoot (), "cylinder(h=%1$s, ...)", parameters["h"].toEchoStringNoThrow ());
     }
-    if (node->r1 < 0 || node->r2 < 0 || (node->r1 == 0 && node->r2 == 0) || !std::isfinite(node->r1) || !std::isfinite(node->r2)) {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
-          "cylinder(r1=%1$s, r2=%2$s, ...)",
-          (r1.type() == Value::Type::NUMBER ? r1.toEchoStringNoThrow() : r.toEchoStringNoThrow()),
-          (r2.type() == Value::Type::NUMBER ? r2.toEchoStringNoThrow() : r.toEchoStringNoThrow()));
+    if (node->r1 < 0 || node->r2 < 0 || (node->r1 == 0 && node->r2 == 0) || !std::isfinite (node->r1) || !std::isfinite (node->r2)) {
+      LOG (message_group::Warning, inst->location (), parameters.documentRoot (),
+           "cylinder(r1=%1$s, r2=%2$s, ...)",
+           (r1.type () == Value::Type::NUMBER ? r1.toEchoStringNoThrow () : r.toEchoStringNoThrow ()),
+           (r2.type () == Value::Type::NUMBER ? r2.toEchoStringNoThrow () : r.toEchoStringNoThrow ()));
     }
   }
 
-  if (parameters["center"].type() == Value::Type::BOOL) {
-    node->center = parameters["center"].toBool();
+  if (parameters["center"].type () == Value::Type::BOOL) {
+    node->center = parameters["center"].toBool ();
   }
 
   return node;
 }
 
-
-std::string PolyhedronNode::toString() const
-{
+std::string PolyhedronNode::toString () const {
   std::ostringstream stream;
   stream << "polyhedron(points = [";
   bool firstPoint = true;
-  for (const auto& point : this->points) {
+  for (const auto &point : this->points) {
     if (firstPoint) {
       firstPoint = false;
     } else {
@@ -382,7 +363,7 @@ std::string PolyhedronNode::toString() const
   }
   stream << "], faces = [";
   bool firstFace = true;
-  for (const auto& face : this->faces) {
+  for (const auto &face : this->faces) {
     if (firstFace) {
       firstFace = false;
     } else {
@@ -390,7 +371,7 @@ std::string PolyhedronNode::toString() const
     }
     stream << "[";
     bool firstIndex = true;
-    for (const auto& index : face) {
+    for (const auto &index : face) {
       if (firstIndex) {
         firstIndex = false;
       } else {
@@ -401,189 +382,179 @@ std::string PolyhedronNode::toString() const
     stream << "]";
   }
   stream << "], convexity = " << this->convexity << ")";
-  return stream.str();
+  return stream.str ();
 }
 
-std::unique_ptr<const Geometry> PolyhedronNode::createGeometry() const
-{
-  auto p = PolySet::createEmpty();
-  p->setConvexity(this->convexity);
+std::unique_ptr<const Geometry> PolyhedronNode::createGeometry () const {
+  auto p = PolySet::createEmpty ();
+  p->setConvexity (this->convexity);
   p->vertices = this->points;
   p->indices = this->faces;
   bool is_triangular = true;
-  for (auto& poly : p->indices) {
-    std::reverse(poly.begin(), poly.end());
-    if (is_triangular && poly.size() > 3) {
+  for (auto &poly : p->indices) {
+    std::reverse (poly.begin (), poly.end ());
+    if (is_triangular && poly.size () > 3) {
       is_triangular = false;
     }
   }
-  p->setTriangular(is_triangular);
+  p->setTriangular (is_triangular);
   return p;
 }
 
-static std::shared_ptr<AbstractNode> builtin_polyhedron(const ModuleInstantiation *inst, Arguments arguments)
-{
-  auto node = std::make_shared<PolyhedronNode>(inst);
+static std::shared_ptr<AbstractNode> builtin_polyhedron (const ModuleInstantiation *inst, Arguments arguments) {
+  auto node = std::make_shared<PolyhedronNode> (inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"points", "faces", "convexity"}, {"triangles"});
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (), {"points", "faces", "convexity"}, {"triangles"});
 
-  if (parameters["points"].type() != Value::Type::VECTOR) {
-    LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert points = %1$s to a vector of coordinates", parameters["points"].toEchoStringNoThrow());
+  if (parameters["points"].type () != Value::Type::VECTOR) {
+    LOG (message_group::Error, inst->location (), parameters.documentRoot (), "Unable to convert points = %1$s to a vector of coordinates", parameters["points"].toEchoStringNoThrow ());
     return node;
   }
-  node->points.reserve(parameters["points"].toVector().size());
-  for (const Value& pointValue : parameters["points"].toVector()) {
+  node->points.reserve (parameters["points"].toVector ().size ());
+  for (const Value &pointValue : parameters["points"].toVector ()) {
     Vector3d point;
-    if (!pointValue.getVec3(point[0], point[1], point[2], 0.0) ||
-        !std::isfinite(point[0]) || !std::isfinite(point[1]) || !std::isfinite(point[2])
-        ) {
-      LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert points[%1$d] = %2$s to a vec3 of numbers", node->points.size(), pointValue.toEchoStringNoThrow());
-      node->points.push_back({0, 0, 0});
+    if (!pointValue.getVec3 (point[0], point[1], point[2], 0.0) ||
+        !std::isfinite (point[0]) || !std::isfinite (point[1]) || !std::isfinite (point[2])) {
+      LOG (message_group::Error, inst->location (), parameters.documentRoot (), "Unable to convert points[%1$d] = %2$s to a vec3 of numbers", node->points.size (), pointValue.toEchoStringNoThrow ());
+      node->points.push_back ({0, 0, 0});
     } else {
-      node->points.push_back(point);
+      node->points.push_back (point);
     }
   }
 
   const Value *faces = nullptr;
-  if (parameters["faces"].type() == Value::Type::UNDEFINED && parameters["triangles"].type() != Value::Type::UNDEFINED) {
+  if (parameters["faces"].type () == Value::Type::UNDEFINED && parameters["triangles"].type () != Value::Type::UNDEFINED) {
     // backwards compatible
-    LOG(message_group::Deprecated, inst->location(), parameters.documentRoot(), "polyhedron(triangles=[]) will be removed in future releases. Use polyhedron(faces=[]) instead.");
+    LOG (message_group::Deprecated, inst->location (), parameters.documentRoot (), "polyhedron(triangles=[]) will be removed in future releases. Use polyhedron(faces=[]) instead.");
     faces = &parameters["triangles"];
   } else {
     faces = &parameters["faces"];
   }
-  if (faces->type() != Value::Type::VECTOR) {
-    LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert faces = %1$s to a vector of vector of point indices", faces->toEchoStringNoThrow());
+  if (faces->type () != Value::Type::VECTOR) {
+    LOG (message_group::Error, inst->location (), parameters.documentRoot (), "Unable to convert faces = %1$s to a vector of vector of point indices", faces->toEchoStringNoThrow ());
     return node;
   }
   size_t faceIndex = 0;
-  node->faces.reserve(faces->toVector().size());
-  for (const Value& faceValue : faces->toVector()) {
-    if (faceValue.type() != Value::Type::VECTOR) {
-      LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert faces[%1$d] = %2$s to a vector of numbers", faceIndex, faceValue.toEchoStringNoThrow());
+  node->faces.reserve (faces->toVector ().size ());
+  for (const Value &faceValue : faces->toVector ()) {
+    if (faceValue.type () != Value::Type::VECTOR) {
+      LOG (message_group::Error, inst->location (), parameters.documentRoot (), "Unable to convert faces[%1$d] = %2$s to a vector of numbers", faceIndex, faceValue.toEchoStringNoThrow ());
     } else {
       size_t pointIndexIndex = 0;
       IndexedFace face;
-      for (const Value& pointIndexValue : faceValue.toVector()) {
-        if (pointIndexValue.type() != Value::Type::NUMBER) {
-          LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert faces[%1$d][%2$d] = %3$s to a number", faceIndex, pointIndexIndex, pointIndexValue.toEchoStringNoThrow());
+      for (const Value &pointIndexValue : faceValue.toVector ()) {
+        if (pointIndexValue.type () != Value::Type::NUMBER) {
+          LOG (message_group::Error, inst->location (), parameters.documentRoot (), "Unable to convert faces[%1$d][%2$d] = %3$s to a number", faceIndex, pointIndexIndex, pointIndexValue.toEchoStringNoThrow ());
         } else {
-          auto pointIndex = (size_t)pointIndexValue.toDouble();
-          if (pointIndex < node->points.size()) {
-            face.push_back(pointIndex);
+          auto pointIndex = (size_t)pointIndexValue.toDouble ();
+          if (pointIndex < node->points.size ()) {
+            face.push_back (pointIndex);
           } else {
-            LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Point index %1$d is out of bounds (from faces[%2$d][%3$d])", pointIndex, faceIndex, pointIndexIndex);
+            LOG (message_group::Warning, inst->location (), parameters.documentRoot (), "Point index %1$d is out of bounds (from faces[%2$d][%3$d])", pointIndex, faceIndex, pointIndexIndex);
           }
         }
         pointIndexIndex++;
       }
       // FIXME: Print an error message if < 3 vertices are specified
-      if (face.size() >= 3) {
-        node->faces.push_back(std::move(face));
+      if (face.size () >= 3) {
+        node->faces.push_back (std::move (face));
       }
     }
     faceIndex++;
   }
 
-  node->convexity = (int)parameters["convexity"].toDouble();
-  if (node->convexity < 1) node->convexity = 1;
+  node->convexity = (int)parameters["convexity"].toDouble ();
+  if (node->convexity < 1)
+    node->convexity = 1;
 
   return node;
 }
 
-
-std::unique_ptr<const Geometry> SquareNode::createGeometry() const
-{
-  if (this->x <= 0 || !std::isfinite(this->x) ||
-      this->y <= 0 || !std::isfinite(this->y)) {
-    return std::make_unique<Polygon2d>();
+std::unique_ptr<const Geometry> SquareNode::createGeometry () const {
+  if (this->x <= 0 || !std::isfinite (this->x) ||
+      this->y <= 0 || !std::isfinite (this->y)) {
+    return std::make_unique<Polygon2d> ();
   }
 
-  Vector2d v1(0, 0);
-  Vector2d v2(this->x, this->y);
+  Vector2d v1 (0, 0);
+  Vector2d v2 (this->x, this->y);
   if (this->center) {
-    v1 -= Vector2d(this->x / 2, this->y / 2);
-    v2 -= Vector2d(this->x / 2, this->y / 2);
+    v1 -= Vector2d (this->x / 2, this->y / 2);
+    v2 -= Vector2d (this->x / 2, this->y / 2);
   }
 
   Outline2d o;
   o.vertices = {v1, {v2[0], v1[1]}, v2, {v1[0], v2[1]}};
-  return std::make_unique<Polygon2d>(o);
+  return std::make_unique<Polygon2d> (o);
 }
 
-static std::shared_ptr<AbstractNode> builtin_square(const ModuleInstantiation *inst, Arguments arguments)
-{
-  auto node = std::make_shared<SquareNode>(inst);
+static std::shared_ptr<AbstractNode> builtin_square (const ModuleInstantiation *inst, Arguments arguments) {
+  auto node = std::make_shared<SquareNode> (inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"size", "center"});
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (), {"size", "center"});
 
-  const auto& size = parameters["size"];
-  if (size.isDefined()) {
+  const auto &size = parameters["size"];
+  if (size.isDefined ()) {
     bool converted = false;
-    converted |= size.getDouble(node->x);
-    converted |= size.getDouble(node->y);
-    converted |= size.getVec2(node->x, node->y);
+    converted |= size.getDouble (node->x);
+    converted |= size.getDouble (node->y);
+    converted |= size.getVec2 (node->x, node->y);
     if (!converted) {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Unable to convert square(size=%1$s, ...) parameter to a number or a vec2 of numbers", size.toEchoStringNoThrow());
+      LOG (message_group::Warning, inst->location (), parameters.documentRoot (), "Unable to convert square(size=%1$s, ...) parameter to a number or a vec2 of numbers", size.toEchoStringNoThrow ());
     } else if (OpenSCAD::rangeCheck) {
       bool ok = true;
       ok &= (node->x > 0) && (node->y > 0);
-      ok &= std::isfinite(node->x) && std::isfinite(node->y);
+      ok &= std::isfinite (node->x) && std::isfinite (node->y);
       if (!ok) {
-        LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "square(size=%1$s, ...)", size.toEchoStringNoThrow());
+        LOG (message_group::Warning, inst->location (), parameters.documentRoot (), "square(size=%1$s, ...)", size.toEchoStringNoThrow ());
       }
     }
   }
-  if (parameters["center"].type() == Value::Type::BOOL) {
-    node->center = parameters["center"].toBool();
+  if (parameters["center"].type () == Value::Type::BOOL) {
+    node->center = parameters["center"].toBool ();
   }
 
   return node;
 }
 
-std::unique_ptr<const Geometry> CircleNode::createGeometry() const
-{
-  if (this->r <= 0 || !std::isfinite(this->r)) {
-    return std::make_unique<Polygon2d>();
+std::unique_ptr<const Geometry> CircleNode::createGeometry () const {
+  if (this->r <= 0 || !std::isfinite (this->r)) {
+    return std::make_unique<Polygon2d> ();
   }
 
-  auto fragments = Calc::get_fragments_from_r(this->r, this->fn, this->fs, this->fa);
+  auto fragments = Calc::get_fragments_from_r (this->r, this->fn, this->fs, this->fa);
   Outline2d o;
-  o.vertices.resize(fragments);
+  o.vertices.resize (fragments);
   for (int i = 0; i < fragments; ++i) {
     double phi = (360.0 * i) / fragments;
-    o.vertices[i] = {this->r * cos_degrees(phi), this->r * sin_degrees(phi)};
+    o.vertices[i] = {this->r * cos_degrees (phi), this->r * sin_degrees (phi)};
   }
-  return std::make_unique<Polygon2d>(o);
+  return std::make_unique<Polygon2d> (o);
 }
 
-static std::shared_ptr<AbstractNode> builtin_circle(const ModuleInstantiation *inst, Arguments arguments)
-{
-  auto node = std::make_shared<CircleNode>(inst);
+static std::shared_ptr<AbstractNode> builtin_circle (const ModuleInstantiation *inst, Arguments arguments) {
+  auto node = std::make_shared<CircleNode> (inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"r"}, {"d"});
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (), {"r"}, {"d"});
 
-  set_fragments(parameters, inst, node->fn, node->fs, node->fa);
-  const auto r = lookup_radius(parameters, inst, "d", "r");
-  if (r.type() == Value::Type::NUMBER) {
-    node->r = r.toDouble();
-    if (OpenSCAD::rangeCheck && ((node->r <= 0) || !std::isfinite(node->r))) {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
-          "circle(r=%1$s)", r.toEchoStringNoThrow());
+  set_fragments (parameters, inst, node->fn, node->fs, node->fa);
+  const auto r = lookup_radius (parameters, inst, "d", "r");
+  if (r.type () == Value::Type::NUMBER) {
+    node->r = r.toDouble ();
+    if (OpenSCAD::rangeCheck && ((node->r <= 0) || !std::isfinite (node->r))) {
+      LOG (message_group::Warning, inst->location (), parameters.documentRoot (),
+           "circle(r=%1$s)", r.toEchoStringNoThrow ());
     }
   }
 
   return node;
 }
 
-
-
-std::string PolygonNode::toString() const
-{
+std::string PolygonNode::toString () const {
   std::ostringstream stream;
   stream << "polygon(points = [";
   bool firstPoint = true;
-  for (const auto& point : this->points) {
+  for (const auto &point : this->points) {
     if (firstPoint) {
       firstPoint = false;
     } else {
@@ -592,12 +563,12 @@ std::string PolygonNode::toString() const
     stream << "[" << point[0] << ", " << point[1] << "]";
   }
   stream << "], paths = ";
-  if (this->paths.empty()) {
+  if (this->paths.empty ()) {
     stream << "undef";
   } else {
     stream << "[";
     bool firstPath = true;
-    for (const auto& path : this->paths) {
+    for (const auto &path : this->paths) {
       if (firstPath) {
         firstPath = false;
       } else {
@@ -605,7 +576,7 @@ std::string PolygonNode::toString() const
       }
       stream << "[";
       bool firstIndex = true;
-      for (const auto& index : path) {
+      for (const auto &index : path) {
         if (firstIndex) {
           firstIndex = false;
         } else {
@@ -618,144 +589,139 @@ std::string PolygonNode::toString() const
     stream << "]";
   }
   stream << ", convexity = " << this->convexity << ")";
-  return stream.str();
+  return stream.str ();
 }
 
-std::unique_ptr<const Geometry> PolygonNode::createGeometry() const
-{
-  auto p = std::make_unique<Polygon2d>();
-  if (this->paths.empty() && this->points.size() > 2) {
+std::unique_ptr<const Geometry> PolygonNode::createGeometry () const {
+  auto p = std::make_unique<Polygon2d> ();
+  if (this->paths.empty () && this->points.size () > 2) {
     Outline2d outline;
-    for (const auto& point : this->points) {
-      outline.vertices.push_back(point);
+    for (const auto &point : this->points) {
+      outline.vertices.push_back (point);
     }
-    p->addOutline(outline);
+    p->addOutline (outline);
   } else {
     bool positive = true; // First outline is positive
-    for (const auto& path : this->paths) {
+    for (const auto &path : this->paths) {
       Outline2d outline;
-      for (const auto& index : path) {
-        assert(index < this->points.size());
-        const auto& point = points[index];
-        outline.vertices.push_back(point);
+      for (const auto &index : path) {
+        assert (index < this->points.size ());
+        const auto &point = points[index];
+        outline.vertices.push_back (point);
       }
       outline.positive = positive;
-      p->addOutline(outline);
+      p->addOutline (outline);
       positive = false; // Subsequent outlines are holes
     }
   }
-  if (p->outlines().size() > 0) {
-    p->setConvexity(convexity);
+  if (p->outlines ().size () > 0) {
+    p->setConvexity (convexity);
   }
   return p;
 }
 
-static std::shared_ptr<AbstractNode> builtin_polygon(const ModuleInstantiation *inst, Arguments arguments)
-{
-  auto node = std::make_shared<PolygonNode>(inst);
+static std::shared_ptr<AbstractNode> builtin_polygon (const ModuleInstantiation *inst, Arguments arguments) {
+  auto node = std::make_shared<PolygonNode> (inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"points", "paths", "convexity"});
+  Parameters parameters = Parameters::parse (std::move (arguments), inst->location (), {"points", "paths", "convexity"});
 
-  if (parameters["points"].type() != Value::Type::VECTOR) {
-    LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert points = %1$s to a vector of coordinates", parameters["points"].toEchoStringNoThrow());
+  if (parameters["points"].type () != Value::Type::VECTOR) {
+    LOG (message_group::Error, inst->location (), parameters.documentRoot (), "Unable to convert points = %1$s to a vector of coordinates", parameters["points"].toEchoStringNoThrow ());
     return node;
   }
-  for (const Value& pointValue : parameters["points"].toVector()) {
+  for (const Value &pointValue : parameters["points"].toVector ()) {
     Vector2d point;
-    if (!pointValue.getVec2(point[0], point[1]) ||
-        !std::isfinite(point[0]) || !std::isfinite(point[1])
-        ) {
-      LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert points[%1$d] = %2$s to a vec2 of numbers", node->points.size(), pointValue.toEchoStringNoThrow());
-      node->points.push_back({0, 0});
+    if (!pointValue.getVec2 (point[0], point[1]) ||
+        !std::isfinite (point[0]) || !std::isfinite (point[1])) {
+      LOG (message_group::Error, inst->location (), parameters.documentRoot (), "Unable to convert points[%1$d] = %2$s to a vec2 of numbers", node->points.size (), pointValue.toEchoStringNoThrow ());
+      node->points.push_back ({0, 0});
     } else {
-      node->points.push_back(point);
+      node->points.push_back (point);
     }
   }
 
-  if (parameters["paths"].type() == Value::Type::VECTOR) {
+  if (parameters["paths"].type () == Value::Type::VECTOR) {
     size_t pathIndex = 0;
-    for (const Value& pathValue : parameters["paths"].toVector()) {
-      if (pathValue.type() != Value::Type::VECTOR) {
-        LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert paths[%1$d] = %2$s to a vector of numbers", pathIndex, pathValue.toEchoStringNoThrow());
+    for (const Value &pathValue : parameters["paths"].toVector ()) {
+      if (pathValue.type () != Value::Type::VECTOR) {
+        LOG (message_group::Error, inst->location (), parameters.documentRoot (), "Unable to convert paths[%1$d] = %2$s to a vector of numbers", pathIndex, pathValue.toEchoStringNoThrow ());
       } else {
         size_t pointIndexIndex = 0;
         std::vector<size_t> path;
-        for (const Value& pointIndexValue : pathValue.toVector()) {
-          if (pointIndexValue.type() != Value::Type::NUMBER) {
-            LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert paths[%1$d][%2$d] = %3$s to a number", pathIndex, pointIndexIndex, pointIndexValue.toEchoStringNoThrow());
+        for (const Value &pointIndexValue : pathValue.toVector ()) {
+          if (pointIndexValue.type () != Value::Type::NUMBER) {
+            LOG (message_group::Error, inst->location (), parameters.documentRoot (), "Unable to convert paths[%1$d][%2$d] = %3$s to a number", pathIndex, pointIndexIndex, pointIndexValue.toEchoStringNoThrow ());
           } else {
-            auto pointIndex = (size_t)pointIndexValue.toDouble();
-            if (pointIndex < node->points.size()) {
-              path.push_back(pointIndex);
+            auto pointIndex = (size_t)pointIndexValue.toDouble ();
+            if (pointIndex < node->points.size ()) {
+              path.push_back (pointIndex);
             } else {
-              LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Point index %1$d is out of bounds (from paths[%2$d][%3$d])", pointIndex, pathIndex, pointIndexIndex);
+              LOG (message_group::Warning, inst->location (), parameters.documentRoot (), "Point index %1$d is out of bounds (from paths[%2$d][%3$d])", pointIndex, pathIndex, pointIndexIndex);
             }
           }
           pointIndexIndex++;
         }
-        node->paths.push_back(std::move(path));
+        node->paths.push_back (std::move (path));
       }
       pathIndex++;
     }
-  } else if (parameters["paths"].type() != Value::Type::UNDEFINED) {
-    LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert paths = %1$s to a vector of vector of point indices", parameters["paths"].toEchoStringNoThrow());
+  } else if (parameters["paths"].type () != Value::Type::UNDEFINED) {
+    LOG (message_group::Error, inst->location (), parameters.documentRoot (), "Unable to convert paths = %1$s to a vector of vector of point indices", parameters["paths"].toEchoStringNoThrow ());
     return node;
   }
 
-  node->convexity = (int)parameters["convexity"].toDouble();
-  if (node->convexity < 1) node->convexity = 1;
+  node->convexity = (int)parameters["convexity"].toDouble ();
+  if (node->convexity < 1)
+    node->convexity = 1;
 
   return node;
 }
 
-
-
-void register_builtin_primitives()
-{
-  Builtins::init("cube", new BuiltinModule(builtin_cube),
-  {
-    "cube(size)",
-    "cube([width, depth, height])",
-    "cube([width, depth, height], center = true)",
-  });
-
-  Builtins::init("sphere", new BuiltinModule(builtin_sphere),
-  {
-    "sphere(radius)",
-    "sphere(r = radius)",
-    "sphere(d = diameter)",
-  });
-
-  Builtins::init("cylinder", new BuiltinModule(builtin_cylinder),
-  {
-    "cylinder(h, r1, r2)",
-    "cylinder(h = height, r = radius, center = true)",
-    "cylinder(h = height, r1 = bottom, r2 = top, center = true)",
-    "cylinder(h = height, d = diameter, center = true)",
-    "cylinder(h = height, d1 = bottom, d2 = top, center = true)",
-  });
-
-  Builtins::init("polyhedron", new BuiltinModule(builtin_polyhedron),
-  {
-    "polyhedron(points, faces, convexity)",
-  });
-
-  Builtins::init("square", new BuiltinModule(builtin_square),
-  {
-    "square(size, center = true)",
-    "square([width,height], center = true)",
-  });
-
-  Builtins::init("circle", new BuiltinModule(builtin_circle),
-  {
-    "circle(radius)",
-    "circle(r = radius)",
-    "circle(d = diameter)",
-  });
-
-  Builtins::init("polygon", new BuiltinModule(builtin_polygon),
-  {
-    "polygon([points])",
-    "polygon([points], [paths])",
-  });
+void register_builtin_primitives () {
+  Builtins::init ("cube", new BuiltinModule (builtin_cube),
+                  {
+                    "cube(size)",
+                    "cube([width, depth, height])",
+                    "cube([width, depth, height], center = true)",
+                  });
+
+  Builtins::init ("sphere", new BuiltinModule (builtin_sphere),
+                  {
+                    "sphere(radius)",
+                    "sphere(r = radius)",
+                    "sphere(d = diameter)",
+                  });
+
+  Builtins::init ("cylinder", new BuiltinModule (builtin_cylinder),
+                  {
+                    "cylinder(h, r1, r2)",
+                    "cylinder(h = height, r = radius, center = true)",
+                    "cylinder(h = height, r1 = bottom, r2 = top, center = true)",
+                    "cylinder(h = height, d = diameter, center = true)",
+                    "cylinder(h = height, d1 = bottom, d2 = top, center = true)",
+                  });
+
+  Builtins::init ("polyhedron", new BuiltinModule (builtin_polyhedron),
+                  {
+                    "polyhedron(points, faces, convexity)",
+                  });
+
+  Builtins::init ("square", new BuiltinModule (builtin_square),
+                  {
+                    "square(size, center = true)",
+                    "square([width,height], center = true)",
+                  });
+
+  Builtins::init ("circle", new BuiltinModule (builtin_circle),
+                  {
+                    "circle(radius)",
+                    "circle(r = radius)",
+                    "circle(d = diameter)",
+                  });
+
+  Builtins::init ("polygon", new BuiltinModule (builtin_polygon),
+                  {
+                    "polygon([points])",
+                    "polygon([points], [paths])",
+                  });
 }
diff --git a/src/core/primitives.h b/src/core/primitives.h
index 19c005e6c..08f26e3ae 100644
--- a/src/core/primitives.h
+++ b/src/core/primitives.h
@@ -39,31 +39,32 @@
 class CubeNode : public LeafNode
 {
 public:
-  CubeNode(const ModuleInstantiation *mi) : LeafNode(mi) {}
-  std::string toString() const override
-  {
+  CubeNode (const ModuleInstantiation *mi)
+    : LeafNode (mi) {}
+  std::string toString () const override {
     std::ostringstream stream;
     stream << "cube(size = ["
            << x << ", "
            << y << ", "
            << z << "], center = "
            << (center ? "true" : "false") << ")";
-    return stream.str();
+    return stream.str ();
   }
-  std::string name() const override { return "cube"; }
-  std::unique_ptr<const Geometry> createGeometry() const override;
+  std::string name () const override {
+    return "cube";
+  }
+  std::unique_ptr<const Geometry> createGeometry () const override;
 
   double x = 1, y = 1, z = 1;
   bool center = false;
 };
 
-
 class SphereNode : public LeafNode
 {
 public:
-  SphereNode(const ModuleInstantiation *mi) : LeafNode(mi) {}
-  std::string toString() const override
-  {
+  SphereNode (const ModuleInstantiation *mi)
+    : LeafNode (mi) {}
+  std::string toString () const override {
     std::ostringstream stream;
     stream << "sphere"
            << "($fn = " << fn
@@ -71,22 +72,23 @@ public:
            << ", $fs = " << fs
            << ", r = " << r
            << ")";
-    return stream.str();
+    return stream.str ();
   }
-  std::string name() const override { return "sphere"; }
-  std::unique_ptr<const Geometry> createGeometry() const override;
+  std::string name () const override {
+    return "sphere";
+  }
+  std::unique_ptr<const Geometry> createGeometry () const override;
 
   double fn, fs, fa;
   double r = 1;
 };
 
-
 class CylinderNode : public LeafNode
 {
 public:
-  CylinderNode(const ModuleInstantiation *mi) : LeafNode(mi) {}
-  std::string toString() const override
-  {
+  CylinderNode (const ModuleInstantiation *mi)
+    : LeafNode (mi) {}
+  std::string toString () const override {
     std::ostringstream stream;
     stream << "cylinder"
            << "($fn = " << fn
@@ -97,58 +99,62 @@ public:
            << ", r2 = " << r2
            << ", center = " << (center ? "true" : "false")
            << ")";
-    return stream.str();
+    return stream.str ();
   }
-  std::string name() const override { return "cylinder"; }
-  std::unique_ptr<const Geometry> createGeometry() const override;
+  std::string name () const override {
+    return "cylinder";
+  }
+  std::unique_ptr<const Geometry> createGeometry () const override;
 
   double fn, fs, fa;
   double r1 = 1, r2 = 1, h = 1;
   bool center = false;
 };
 
-
 class PolyhedronNode : public LeafNode
 {
 public:
-  PolyhedronNode (const ModuleInstantiation *mi) : LeafNode(mi) {}
-  std::string toString() const override;
-  std::string name() const override { return "polyhedron"; }
-  std::unique_ptr<const Geometry> createGeometry() const override;
+  PolyhedronNode (const ModuleInstantiation *mi)
+    : LeafNode (mi) {}
+  std::string toString () const override;
+  std::string name () const override {
+    return "polyhedron";
+  }
+  std::unique_ptr<const Geometry> createGeometry () const override;
 
   std::vector<Vector3d> points;
   std::vector<IndexedFace> faces;
   int convexity = 1;
 };
 
-
 class SquareNode : public LeafNode
 {
 public:
-  SquareNode(const ModuleInstantiation *mi) : LeafNode(mi) {}
-  std::string toString() const override
-  {
+  SquareNode (const ModuleInstantiation *mi)
+    : LeafNode (mi) {}
+  std::string toString () const override {
     std::ostringstream stream;
     stream << "square(size = ["
            << x << ", "
            << y << "], center = "
            << (center ? "true" : "false") << ")";
-    return stream.str();
+    return stream.str ();
+  }
+  std::string name () const override {
+    return "square";
   }
-  std::string name() const override { return "square"; }
-  std::unique_ptr<const Geometry> createGeometry() const override;
+  std::unique_ptr<const Geometry> createGeometry () const override;
 
   double x = 1, y = 1;
   bool center = false;
 };
 
-
 class CircleNode : public LeafNode
 {
 public:
-  CircleNode(const ModuleInstantiation *mi) : LeafNode(mi) {}
-  std::string toString() const override
-  {
+  CircleNode (const ModuleInstantiation *mi)
+    : LeafNode (mi) {}
+  std::string toString () const override {
     std::ostringstream stream;
     stream << "circle"
            << "($fn = " << fn
@@ -156,23 +162,27 @@ public:
            << ", $fs = " << fs
            << ", r = " << r
            << ")";
-    return stream.str();
+    return stream.str ();
   }
-  std::string name() const override { return "circle"; }
-  std::unique_ptr<const Geometry> createGeometry() const override;
+  std::string name () const override {
+    return "circle";
+  }
+  std::unique_ptr<const Geometry> createGeometry () const override;
 
   double fn, fs, fa;
   double r = 1;
 };
 
-
 class PolygonNode : public LeafNode
 {
 public:
-  PolygonNode (const ModuleInstantiation *mi) : LeafNode(mi) {}
-  std::string toString() const override;
-  std::string name() const override { return "polygon"; }
-  std::unique_ptr<const Geometry> createGeometry() const override;
+  PolygonNode (const ModuleInstantiation *mi)
+    : LeafNode (mi) {}
+  std::string toString () const override;
+  std::string name () const override {
+    return "polygon";
+  }
+  std::unique_ptr<const Geometry> createGeometry () const override;
 
   std::vector<Vector2d> points;
   std::vector<std::vector<size_t>> paths;
diff --git a/src/core/progress.cc b/src/core/progress.cc
index c011714f6..59fe49aae 100644
--- a/src/core/progress.cc
+++ b/src/core/progress.cc
@@ -5,33 +5,30 @@
 
 int progress_report_count;
 int progress_mark_;
-void (*progress_report_f)(const std::shared_ptr<const AbstractNode>&, void *, int);
+void (*progress_report_f) (const std::shared_ptr<const AbstractNode> &, void *, int);
 void *progress_report_userdata;
 
-void progress_report_prep(const std::shared_ptr<AbstractNode>& root, void (*f)(const std::shared_ptr<const AbstractNode>& node, void *userdata, int mark), void *userdata)
-{
+void progress_report_prep (const std::shared_ptr<AbstractNode> &root, void (*f) (const std::shared_ptr<const AbstractNode> &node, void *userdata, int mark), void *userdata) {
   progress_report_count = 0;
   progress_report_f = f;
   progress_report_userdata = userdata;
-  root->progress_prepare();
+  root->progress_prepare ();
 }
 
-void progress_report_fin()
-{
+void progress_report_fin () {
   progress_report_count = 0;
   progress_report_f = nullptr;
   progress_report_userdata = nullptr;
 }
 
-void progress_update(const std::shared_ptr<const AbstractNode>& node, int mark)
-{
+void progress_update (const std::shared_ptr<const AbstractNode> &node, int mark) {
   if (progress_report_f) {
     progress_mark_ = mark;
-    progress_report_f(node, progress_report_userdata, progress_mark_);
+    progress_report_f (node, progress_report_userdata, progress_mark_);
   }
 }
 
-void progress_tick()
-{
-  if (progress_report_f) progress_report_f(std::shared_ptr<const AbstractNode>(), progress_report_userdata, ++progress_mark_);
+void progress_tick () {
+  if (progress_report_f)
+    progress_report_f (std::shared_ptr<const AbstractNode> (), progress_report_userdata, ++progress_mark_);
 }
diff --git a/src/core/progress.h b/src/core/progress.h
index b7c5ad176..6ad718c7d 100644
--- a/src/core/progress.h
+++ b/src/core/progress.h
@@ -7,14 +7,14 @@ class AbstractNode;
 // Reset to 0 in _prep() and increased for each Node instance in progress_prepare()
 extern int progress_report_count;
 
-extern void (*progress_report_f)(const std::shared_ptr<const AbstractNode>&, void *, int);
+extern void (*progress_report_f) (const std::shared_ptr<const AbstractNode> &, void *, int);
 extern void *progress_report_userdata;
 
-void progress_report_prep(const std::shared_ptr<AbstractNode>& root, void (*f)(const std::shared_ptr<const AbstractNode>& node, void *userdata, int mark), void *userdata);
-void progress_report_fin();
-void progress_update(const std::shared_ptr<const AbstractNode>& node, int mark);
+void progress_report_prep (const std::shared_ptr<AbstractNode> &root, void (*f) (const std::shared_ptr<const AbstractNode> &node, void *userdata, int mark), void *userdata);
+void progress_report_fin ();
+void progress_update (const std::shared_ptr<const AbstractNode> &node, int mark);
 // CGALUtils::applyUnion3D may process nodes out of order, so allow for an increment instead of tracking exact node
-void progress_tick();
+void progress_tick ();
 
 class ProgressCancelException
 {
diff --git a/src/core/str_utf8_wrapper.h b/src/core/str_utf8_wrapper.h
index 67ed584ab..5df8a3a56 100644
--- a/src/core/str_utf8_wrapper.h
+++ b/src/core/str_utf8_wrapper.h
@@ -15,104 +15,158 @@ private:
   // store the cached length in glong, paired with its string
   struct str_utf8_t {
     static constexpr size_t LENGTH_UNKNOWN = -1;
-    str_utf8_t() : u8str(), u8len(0) {
+    str_utf8_t ()
+      : u8str ()
+      , u8len (0) {
     }
-    str_utf8_t(std::string s) : u8str(std::move(s)) {
+    str_utf8_t (std::string s)
+      : u8str (std::move (s)) {
     }
-    str_utf8_t(const char *cstr) : u8str(cstr) {
+    str_utf8_t (const char *cstr)
+      : u8str (cstr) {
     }
-    str_utf8_t(const char *cstr, size_t size, size_t u8len) : u8str(cstr, size), u8len(u8len) {
+    str_utf8_t (const char *cstr, size_t size, size_t u8len)
+      : u8str (cstr, size)
+      , u8len (u8len) {
     }
     const std::string u8str;
     size_t u8len = LENGTH_UNKNOWN;
   };
   // private constructor for copying members
-  explicit str_utf8_wrapper(const std::shared_ptr<str_utf8_t>& str_in) : str_ptr(str_in) { }
+  explicit str_utf8_wrapper (const std::shared_ptr<str_utf8_t> &str_in)
+    : str_ptr (str_in) {}
 
 public:
   class iterator
   {
-public:
+  public:
     // iterator_traits required types:
     using iterator_category = std::forward_iterator_tag;
     using value_type = str_utf8_wrapper;
     using difference_type = void;
     using reference = value_type; // type used by operator*(), not actually a reference
     using pointer = void;
-    iterator() : ptr(&nullterm) {} // DefaultConstructible
-    iterator(const str_utf8_wrapper& str) : ptr(str.c_str()), len(char_len()) { }
-    iterator(const str_utf8_wrapper& str, bool /*end*/) : ptr(str.c_str() + str.size()) { }
+    iterator ()
+      : ptr (&nullterm) {} // DefaultConstructible
+    iterator (const str_utf8_wrapper &str)
+      : ptr (str.c_str ())
+      , len (char_len ()) {}
+    iterator (const str_utf8_wrapper &str, bool /*end*/)
+      : ptr (str.c_str () + str.size ()) {}
 
-    iterator& operator++() { ptr += len; len = char_len(); return *this; }
-    reference operator*() { return {ptr, len}; } // Note: returns a new str_utf8_wrapper **by value**, representing a single UTF8 character.
-    bool operator==(const iterator& other) const { return ptr == other.ptr; }
-    bool operator!=(const iterator& other) const { return ptr != other.ptr; }
-private:
-    size_t char_len() { return g_utf8_next_char(ptr) - ptr; }
+    iterator &operator++ () {
+      ptr += len;
+      len = char_len ();
+      return *this;
+    }
+    reference operator* () {
+      return {ptr, len};
+    } // Note: returns a new str_utf8_wrapper **by value**, representing a single UTF8 character.
+    bool operator== (const iterator &other) const {
+      return ptr == other.ptr;
+    }
+    bool operator!= (const iterator &other) const {
+      return ptr != other.ptr;
+    }
+
+  private:
+    size_t char_len () {
+      return g_utf8_next_char (ptr) - ptr;
+    }
     static const char nullterm = '\0';
     const char *ptr;
     size_t len = 0;
   };
 
-  [[nodiscard]] iterator begin() const { return {*this}; }
-  [[nodiscard]] iterator end() const { return {*this, true}; }
-  str_utf8_wrapper() : str_ptr(std::make_shared<str_utf8_t>()) { }
-  str_utf8_wrapper(const std::string& s) : str_ptr(std::make_shared<str_utf8_t>(s)) { }
-  str_utf8_wrapper(const char *cstr) : str_ptr(std::make_shared<str_utf8_t>(cstr)) { }
+  [[nodiscard]] iterator begin () const {
+    return {*this};
+  }
+  [[nodiscard]] iterator end () const {
+    return {*this, true};
+  }
+  str_utf8_wrapper ()
+    : str_ptr (std::make_shared<str_utf8_t> ()) {}
+  str_utf8_wrapper (const std::string &s)
+    : str_ptr (std::make_shared<str_utf8_t> (s)) {}
+  str_utf8_wrapper (const char *cstr)
+    : str_ptr (std::make_shared<str_utf8_t> (cstr)) {}
   // for enumerating single utf8 chars from iterator
-  str_utf8_wrapper(const char *cstr, size_t clen) : str_ptr(std::make_shared<str_utf8_t>(cstr, clen, 1)) { }
-  str_utf8_wrapper(uint32_t unicode) {
+  str_utf8_wrapper (const char *cstr, size_t clen)
+    : str_ptr (std::make_shared<str_utf8_t> (cstr, clen, 1)) {}
+  str_utf8_wrapper (uint32_t unicode) {
     char out[6] = " ";
-    if (unicode != 0 && g_unichar_validate(unicode)) {
-      g_unichar_to_utf8(unicode, out);
+    if (unicode != 0 && g_unichar_validate (unicode)) {
+      g_unichar_to_utf8 (unicode, out);
     }
-    str_ptr = std::make_shared<str_utf8_t>(out);
-  }
-  str_utf8_wrapper(const str_utf8_wrapper&) = delete; // never copy, move instead
-  str_utf8_wrapper& operator=(const str_utf8_wrapper&) = delete; // never copy, move instead
-  str_utf8_wrapper(str_utf8_wrapper&&) = default;
-  str_utf8_wrapper& operator=(str_utf8_wrapper&&) = default;
-  ~str_utf8_wrapper() = default;
-  [[nodiscard]] str_utf8_wrapper clone() const { return str_utf8_wrapper(this->str_ptr); } // makes a copy of shared_ptr
+    str_ptr = std::make_shared<str_utf8_t> (out);
+  }
+  str_utf8_wrapper (const str_utf8_wrapper &) = delete; // never copy, move instead
+  str_utf8_wrapper &operator= (const str_utf8_wrapper &) = delete; // never copy, move instead
+  str_utf8_wrapper (str_utf8_wrapper &&) = default;
+  str_utf8_wrapper &operator= (str_utf8_wrapper &&) = default;
+  ~str_utf8_wrapper () = default;
+  [[nodiscard]] str_utf8_wrapper clone () const {
+    return str_utf8_wrapper (this->str_ptr);
+  } // makes a copy of shared_ptr
 
-  bool operator==(const str_utf8_wrapper& rhs) const { return this->str_ptr->u8str == rhs.str_ptr->u8str; }
-  bool operator!=(const str_utf8_wrapper& rhs) const { return this->str_ptr->u8str != rhs.str_ptr->u8str; }
-  bool operator<(const str_utf8_wrapper& rhs) const { return this->str_ptr->u8str < rhs.str_ptr->u8str; }
-  bool operator>(const str_utf8_wrapper& rhs) const { return this->str_ptr->u8str > rhs.str_ptr->u8str; }
-  bool operator<=(const str_utf8_wrapper& rhs) const { return this->str_ptr->u8str <= rhs.str_ptr->u8str; }
-  bool operator>=(const str_utf8_wrapper& rhs) const { return this->str_ptr->u8str >= rhs.str_ptr->u8str; }
-  [[nodiscard]] bool empty() const { return this->str_ptr->u8str.empty(); }
-  [[nodiscard]] const char *c_str() const { return this->str_ptr->u8str.c_str(); }
-  [[nodiscard]] const std::string& toString() const { return this->str_ptr->u8str; }
-  [[nodiscard]] size_t size() const { return this->str_ptr->u8str.size(); }
-  str_utf8_wrapper operator[](const size_t idx) const {
-    if (idx < this->size()) {
+  bool operator== (const str_utf8_wrapper &rhs) const {
+    return this->str_ptr->u8str == rhs.str_ptr->u8str;
+  }
+  bool operator!= (const str_utf8_wrapper &rhs) const {
+    return this->str_ptr->u8str != rhs.str_ptr->u8str;
+  }
+  bool operator< (const str_utf8_wrapper &rhs) const {
+    return this->str_ptr->u8str < rhs.str_ptr->u8str;
+  }
+  bool operator> (const str_utf8_wrapper &rhs) const {
+    return this->str_ptr->u8str > rhs.str_ptr->u8str;
+  }
+  bool operator<= (const str_utf8_wrapper &rhs) const {
+    return this->str_ptr->u8str <= rhs.str_ptr->u8str;
+  }
+  bool operator>= (const str_utf8_wrapper &rhs) const {
+    return this->str_ptr->u8str >= rhs.str_ptr->u8str;
+  }
+  [[nodiscard]] bool empty () const {
+    return this->str_ptr->u8str.empty ();
+  }
+  [[nodiscard]] const char *c_str () const {
+    return this->str_ptr->u8str.c_str ();
+  }
+  [[nodiscard]] const std::string &toString () const {
+    return this->str_ptr->u8str;
+  }
+  [[nodiscard]] size_t size () const {
+    return this->str_ptr->u8str.size ();
+  }
+  str_utf8_wrapper operator[] (const size_t idx) const {
+    if (idx < this->size ()) {
       // Ensure character (not byte) index is inside the character/glyph array
-      if (idx < this->get_utf8_strlen()) {
+      if (idx < this->get_utf8_strlen ()) {
         gchar utf8_of_cp[6] = ""; //A buffer for a single unicode character to be copied into
-        auto ptr = g_utf8_offset_to_pointer(str_ptr->u8str.c_str(), idx);
+        auto ptr = g_utf8_offset_to_pointer (str_ptr->u8str.c_str (), idx);
         if (ptr) {
-          g_utf8_strncpy(utf8_of_cp, ptr, 1);
+          g_utf8_strncpy (utf8_of_cp, ptr, 1);
         }
-        return std::string(utf8_of_cp);
+        return std::string (utf8_of_cp);
       }
     }
     return {};
   }
 
-  [[nodiscard]] size_t get_utf8_strlen() const {
+  [[nodiscard]] size_t get_utf8_strlen () const {
     if (str_ptr->u8len == str_utf8_t::LENGTH_UNKNOWN) {
-      str_ptr->u8len = g_utf8_strlen(str_ptr->u8str.c_str(), static_cast<gssize>(str_ptr->u8str.size()));
+      str_ptr->u8len = g_utf8_strlen (str_ptr->u8str.c_str (), static_cast<gssize> (str_ptr->u8str.size ()));
     }
     return str_ptr->u8len;
   }
 
-  [[nodiscard]] uint32_t get_utf8_char() const {
-    return g_utf8_get_char(str_ptr->u8str.c_str());
+  [[nodiscard]] uint32_t get_utf8_char () const {
+    return g_utf8_get_char (str_ptr->u8str.c_str ());
   }
 
-  [[nodiscard]] bool utf8_validate() const {
-    return g_utf8_validate(str_ptr->u8str.c_str(), -1, nullptr);
+  [[nodiscard]] bool utf8_validate () const {
+    return g_utf8_validate (str_ptr->u8str.c_str (), -1, nullptr);
   }
 
 private:
diff --git a/src/geometry/ClipperUtils.cc b/src/geometry/ClipperUtils.cc
index b221c9254..b75b5d01c 100644
--- a/src/geometry/ClipperUtils.cc
+++ b/src/geometry/ClipperUtils.cc
@@ -17,15 +17,14 @@ namespace ClipperUtils {
 
 namespace {
 
-Clipper2Lib::Paths64 process(const Clipper2Lib::Paths64& polygons,
-                             Clipper2Lib::ClipType cliptype,
-                             Clipper2Lib::FillRule polytype)
-{
+Clipper2Lib::Paths64 process (const Clipper2Lib::Paths64 &polygons,
+                              Clipper2Lib::ClipType cliptype,
+                              Clipper2Lib::FillRule polytype) {
   Clipper2Lib::Paths64 result;
   Clipper2Lib::Clipper64 clipper;
-  clipper.PreserveCollinear(false);
-  clipper.AddSubject(polygons);
-  clipper.Execute(cliptype, polytype, result);
+  clipper.PreserveCollinear (false);
+  clipper.AddSubject (polygons);
+  clipper.Execute (cliptype, polytype, result);
   return result;
 }
 
@@ -33,44 +32,44 @@ Clipper2Lib::Paths64 process(const Clipper2Lib::Paths64& polygons,
 // The reason is numeric robustness. With the insides missing, the intersection points created by the union operation may
 // (due to rounding) be located at slightly different locations than the original geometry and this
 // can give rise to cracks
-void minkowski_outline(const Clipper2Lib::Path64& poly, const Clipper2Lib::Path64& path,
-                       Clipper2Lib::Paths64& quads, bool isSum, bool isClosed)
-{
+void minkowski_outline (const Clipper2Lib::Path64 &poly, const Clipper2Lib::Path64 &path,
+                        Clipper2Lib::Paths64 &quads, bool isSum, bool isClosed) {
   int delta = (isClosed ? 1 : 0);
-  size_t polyCnt = poly.size();
-  size_t pathCnt = path.size();
+  size_t polyCnt = poly.size ();
+  size_t pathCnt = path.size ();
   Clipper2Lib::Paths64 pp;
-  pp.reserve(pathCnt);
+  pp.reserve (pathCnt);
   if (isSum)
     for (size_t i = 0; i < pathCnt; ++i) {
       Clipper2Lib::Path64 p;
-      p.reserve(polyCnt);
+      p.reserve (polyCnt);
       for (auto point : poly) {
-        p.push_back(Clipper2Lib::Point64(path[i].x + point.x, path[i].y + point.y));
+        p.push_back (Clipper2Lib::Point64 (path[i].x + point.x, path[i].y + point.y));
       }
-      pp.push_back(p);
+      pp.push_back (p);
     }
   else
     for (size_t i = 0; i < pathCnt; ++i) {
       Clipper2Lib::Path64 p;
-      p.reserve(polyCnt);
+      p.reserve (polyCnt);
       for (auto point : poly) {
-        p.push_back(Clipper2Lib::Point64(path[i].x - point.x, path[i].y - point.y));
+        p.push_back (Clipper2Lib::Point64 (path[i].x - point.x, path[i].y - point.y));
       }
-      pp.push_back(p);
+      pp.push_back (p);
     }
 
-  quads.reserve((pathCnt + delta) * (polyCnt + 1));
+  quads.reserve ((pathCnt + delta) * (polyCnt + 1));
   for (size_t i = 0; i < pathCnt - 1 + delta; ++i)
     for (size_t j = 0; j < polyCnt; ++j) {
       Clipper2Lib::Path64 quad;
-      quad.reserve(4);
-      quad.push_back(pp[i % pathCnt][j % polyCnt]);
-      quad.push_back(pp[(i + 1) % pathCnt][j % polyCnt]);
-      quad.push_back(pp[(i + 1) % pathCnt][(j + 1) % polyCnt]);
-      quad.push_back(pp[i % pathCnt][(j + 1) % polyCnt]);
-      if (!IsPositive(quad)) std::reverse(quad.begin(), quad.end());
-      quads.push_back(quad);
+      quad.reserve (4);
+      quad.push_back (pp[i % pathCnt][j % polyCnt]);
+      quad.push_back (pp[(i + 1) % pathCnt][j % polyCnt]);
+      quad.push_back (pp[(i + 1) % pathCnt][(j + 1) % polyCnt]);
+      quad.push_back (pp[i % pathCnt][(j + 1) % polyCnt]);
+      if (!IsPositive (quad))
+        std::reverse (quad.begin (), quad.end ());
+      quads.push_back (quad);
     }
 }
 
@@ -78,17 +77,16 @@ void minkowski_outline(const Clipper2Lib::Path64& poly, const Clipper2Lib::Path6
 // Ideally, we would translate to the midpoint of component b, but the point can
 // be chosen arbitrarily since the translated object would always stay inside
 // the minkowski sum.
-void fill_minkowski_insides(const Clipper2Lib::Paths64& a,
-                            const Clipper2Lib::Paths64& b,
-                            Clipper2Lib::Paths64& target)
-{
-  for (const auto& b_path : b) {
+void fill_minkowski_insides (const Clipper2Lib::Paths64 &a,
+                             const Clipper2Lib::Paths64 &b,
+                             Clipper2Lib::Paths64 &target) {
+  for (const auto &b_path : b) {
     // We only need to add for positive components of b
-    if (!b_path.empty() && Clipper2Lib::IsPositive(b_path) == 1) {
-      const auto& delta = b_path[0]; // arbitrary point
-      for (const auto& path : a) {
-        target.push_back(path);
-        for (auto& point : target.back()) {
+    if (!b_path.empty () && Clipper2Lib::IsPositive (b_path) == 1) {
+      const auto &delta = b_path[0]; // arbitrary point
+      for (const auto &path : a) {
+        target.push_back (path);
+        for (auto &point : target.back ()) {
           point.x += delta.x;
           point.y += delta.y;
         }
@@ -97,83 +95,76 @@ void fill_minkowski_insides(const Clipper2Lib::Paths64& a,
   }
 }
 
-void SimplifyPolyTree(const Clipper2Lib::PolyPath64& polytree, double epsilon, Clipper2Lib::PolyPath64& result) {
-  for (const auto& child : polytree) {
-    Clipper2Lib::PolyPath64 *newchild = result.AddChild(Clipper2Lib::SimplifyPath(child->Polygon(), epsilon));
-    SimplifyPolyTree(*child, epsilon, *newchild);
+void SimplifyPolyTree (const Clipper2Lib::PolyPath64 &polytree, double epsilon, Clipper2Lib::PolyPath64 &result) {
+  for (const auto &child : polytree) {
+    Clipper2Lib::PolyPath64 *newchild = result.AddChild (Clipper2Lib::SimplifyPath (child->Polygon (), epsilon));
+    SimplifyPolyTree (*child, epsilon, *newchild);
   }
 }
 
-}  // namespace
+} // namespace
 
 // Using 1 bit less precision than the maximum possible, to limit the chance
 // of data loss when converting back to double (see https://github.com/openscad/openscad/issues/5253).
-const int CLIPPER_BITS{ std::ilogb(0x3FFFFFFFFFFFFFFFLL) };
-
-int scaleBitsFromBounds(const BoundingBox& bounds, int total_bits)
-{
-  const double maxCoeff = std::max({
-      bounds.min().cwiseAbs().maxCoeff(),
-      bounds.max().cwiseAbs().maxCoeff(),
-      bounds.sizes().maxCoeff()
-    });
-  const int exp = std::ilogb(maxCoeff) + 1;
+const int CLIPPER_BITS{std::ilogb (0x3FFFFFFFFFFFFFFFLL)};
+
+int scaleBitsFromBounds (const BoundingBox &bounds, int total_bits) {
+  const double maxCoeff = std::max ({bounds.min ().cwiseAbs ().maxCoeff (),
+                                     bounds.max ().cwiseAbs ().maxCoeff (),
+                                     bounds.sizes ().maxCoeff ()});
+  const int exp = std::ilogb (maxCoeff) + 1;
   const int actual_bits = (total_bits == 0) ? CLIPPER_BITS : total_bits;
   return (actual_bits - 1) - exp;
 }
 
-int scaleBitsFromPrecision(int precision)
-{
-  return std::ilogb(std::pow(10, precision)) + 1;
+int scaleBitsFromPrecision (int precision) {
+  return std::ilogb (std::pow (10, precision)) + 1;
 }
 
-Clipper2Lib::Paths64 fromPolygon2d(const Polygon2d& poly, int scale_bits)
-{
-  const bool keep_orientation = poly.isSanitized();
-  const double scale = std::ldexp(1.0, scale_bits);
+Clipper2Lib::Paths64 fromPolygon2d (const Polygon2d &poly, int scale_bits) {
+  const bool keep_orientation = poly.isSanitized ();
+  const double scale = std::ldexp (1.0, scale_bits);
   Clipper2Lib::Paths64 result;
-  for (const auto& outline : poly.outlines()) {
+  for (const auto &outline : poly.outlines ()) {
     Clipper2Lib::Path64 p;
-    for (const auto& v : outline.vertices) {
-      p.emplace_back(v[0] * scale, v[1] * scale);
+    for (const auto &v : outline.vertices) {
+      p.emplace_back (v[0] * scale, v[1] * scale);
     }
     // Make sure all polygons point up, since we project also
     // back-facing polygon in PolySetUtils::project()
-    if (!keep_orientation && !Clipper2Lib::IsPositive(p)) std::reverse(p.begin(), p.end());
-    result.push_back(std::move(p));
+    if (!keep_orientation && !Clipper2Lib::IsPositive (p))
+      std::reverse (p.begin (), p.end ());
+    result.push_back (std::move (p));
   }
   return result;
 }
 
-Clipper2Lib::Paths64 fromPolygon2d(const Polygon2d& poly)
-{
-  return fromPolygon2d(poly, scaleBitsFromPrecision());
+Clipper2Lib::Paths64 fromPolygon2d (const Polygon2d &poly) {
+  return fromPolygon2d (poly, scaleBitsFromPrecision ());
 }
 
-std::unique_ptr<Clipper2Lib::PolyTree64> sanitize(const Clipper2Lib::Paths64& paths)
-{
-  auto result = std::make_unique<Clipper2Lib::PolyTree64>();
+std::unique_ptr<Clipper2Lib::PolyTree64> sanitize (const Clipper2Lib::Paths64 &paths) {
+  auto result = std::make_unique<Clipper2Lib::PolyTree64> ();
   Clipper2Lib::Clipper64 clipper;
-  clipper.PreserveCollinear(false);
+  clipper.PreserveCollinear (false);
   try {
-    clipper.AddSubject(paths);
+    clipper.AddSubject (paths);
   } catch (...) {
     // Most likely caught a RangeTest exception from clipper
     // Note that Clipper up to v6.2.1 incorrectly throws
     // an exception of type char* rather than a clipperException()
     // TODO: Is this needed for Clipper2?
-    LOG(message_group::Warning, "Range check failed for polygon. skipping");
+    LOG (message_group::Warning, "Range check failed for polygon. skipping");
   }
-  clipper.Execute(Clipper2Lib::ClipType::Union, Clipper2Lib::FillRule::EvenOdd, *result);
+  clipper.Execute (Clipper2Lib::ClipType::Union, Clipper2Lib::FillRule::EvenOdd, *result);
   return result;
 }
 
-std::unique_ptr<Polygon2d> sanitize(const Polygon2d& poly)
-{
-  auto scale_bits = scaleBitsFromPrecision();
+std::unique_ptr<Polygon2d> sanitize (const Polygon2d &poly) {
+  auto scale_bits = scaleBitsFromPrecision ();
 
-  auto paths = ClipperUtils::fromPolygon2d(poly, scale_bits);
-  return toPolygon2d(*sanitize(paths), scale_bits);
+  auto paths = ClipperUtils::fromPolygon2d (poly, scale_bits);
+  return toPolygon2d (*sanitize (paths), scale_bits);
 }
 
 /*!
@@ -182,34 +173,33 @@ std::unique_ptr<Polygon2d> sanitize(const Polygon2d& poly)
    We could use a Paths structure, but we'd have to check the orientation of each
    path before adding it to the Polygon2d.
  */
-std::unique_ptr<Polygon2d> toPolygon2d(const Clipper2Lib::PolyTree64& polytree, int scale_bits)
-{
-  auto result = std::make_unique<Polygon2d>();
-  const double scale = std::ldexp(1.0, -scale_bits);
-  auto processChildren = [scale, &result](auto&& processChildren, const Clipper2Lib::PolyPath64& node) -> void {
-      Outline2d outline;
-      // When using offset, clipper can get the hole status wrong.
-      // IsPositive() calculates the area of the polygon, and if it's negative, it's a hole.
-      outline.positive = IsPositive(node.Polygon());
-
-      constexpr double epsilon = 1.1415; // Epsilon taken from Clipper1's default epsilon.
-      const auto cleaned_path = Clipper2Lib::SimplifyPath(node.Polygon(), epsilon);
-
-      // SimplifyPath can potentially reduce the polygon down to no vertices
-      if (cleaned_path.size() >= 3) {
-        for (const auto& ip : cleaned_path) {
-          outline.vertices.emplace_back(scale * ip.x, scale * ip.y);
-        }
-        result->addOutline(outline);
-      }
-      for (const auto& child : node) {
-        processChildren(processChildren, *child);
+std::unique_ptr<Polygon2d> toPolygon2d (const Clipper2Lib::PolyTree64 &polytree, int scale_bits) {
+  auto result = std::make_unique<Polygon2d> ();
+  const double scale = std::ldexp (1.0, -scale_bits);
+  auto processChildren = [scale, &result] (auto &&processChildren, const Clipper2Lib::PolyPath64 &node) -> void {
+    Outline2d outline;
+    // When using offset, clipper can get the hole status wrong.
+    // IsPositive() calculates the area of the polygon, and if it's negative, it's a hole.
+    outline.positive = IsPositive (node.Polygon ());
+
+    constexpr double epsilon = 1.1415; // Epsilon taken from Clipper1's default epsilon.
+    const auto cleaned_path = Clipper2Lib::SimplifyPath (node.Polygon (), epsilon);
+
+    // SimplifyPath can potentially reduce the polygon down to no vertices
+    if (cleaned_path.size () >= 3) {
+      for (const auto &ip : cleaned_path) {
+        outline.vertices.emplace_back (scale * ip.x, scale * ip.y);
       }
-    };
-  for (const auto& node : polytree) {
-    processChildren(processChildren, *node);
+      result->addOutline (outline);
+    }
+    for (const auto &child : node) {
+      processChildren (processChildren, *child);
+    }
+  };
+  for (const auto &node : polytree) {
+    processChildren (processChildren, *node);
   }
-  result->setSanitized(true);
+  result->setSanitized (true);
   return result;
 }
 
@@ -218,43 +208,42 @@ std::unique_ptr<Polygon2d> toPolygon2d(const Clipper2Lib::PolyTree64& polytree,
 
    May return an empty Polygon2d, but will not return nullptr.
  */
-std::unique_ptr<Polygon2d> apply(const std::vector<Clipper2Lib::Paths64>& pathsvector,
-                                 Clipper2Lib::ClipType clipType, int scale_bits)
-{
+std::unique_ptr<Polygon2d> apply (const std::vector<Clipper2Lib::Paths64> &pathsvector,
+                                  Clipper2Lib::ClipType clipType, int scale_bits) {
   Clipper2Lib::Clipper64 clipper;
-  clipper.PreserveCollinear(false);
+  clipper.PreserveCollinear (false);
 
-  if (clipType == Clipper2Lib::ClipType::Intersection && pathsvector.size() >= 2) {
+  if (clipType == Clipper2Lib::ClipType::Intersection && pathsvector.size () >= 2) {
     // intersection operations must be split into a sequence of binary operations
     auto source = pathsvector[0];
     Clipper2Lib::PolyTree64 result;
-    for (unsigned int i = 1; i < pathsvector.size(); ++i) {
-      clipper.AddSubject(source);
-      clipper.AddClip(pathsvector[i]);
-      clipper.Execute(clipType, Clipper2Lib::FillRule::NonZero, result);
-      if (i != pathsvector.size() - 1) {
-        source = Clipper2Lib::PolyTreeToPaths64(result);
-        clipper.Clear();
+    for (unsigned int i = 1; i < pathsvector.size (); ++i) {
+      clipper.AddSubject (source);
+      clipper.AddClip (pathsvector[i]);
+      clipper.Execute (clipType, Clipper2Lib::FillRule::NonZero, result);
+      if (i != pathsvector.size () - 1) {
+        source = Clipper2Lib::PolyTreeToPaths64 (result);
+        clipper.Clear ();
       }
     }
-    return ClipperUtils::toPolygon2d(result, scale_bits);
+    return ClipperUtils::toPolygon2d (result, scale_bits);
   }
 
   bool first = true;
-  for (const auto& paths : pathsvector) {
+  for (const auto &paths : pathsvector) {
     if (first) {
-      clipper.AddSubject(paths);
+      clipper.AddSubject (paths);
       first = false;
     } else {
-      clipper.AddClip(paths);
+      clipper.AddClip (paths);
     }
   }
   Clipper2Lib::PolyTree64 sumresult;
-  clipper.Execute(clipType, Clipper2Lib::FillRule::NonZero, sumresult);
+  clipper.Execute (clipType, Clipper2Lib::FillRule::NonZero, sumresult);
   // The returned result will have outlines ordered according to whether
   // they're positive or negative: Positive outlines counter-clockwise and
   // negative outlines clockwise.
-  return ClipperUtils::toPolygon2d(sumresult, scale_bits);
+  return ClipperUtils::toPolygon2d (sumresult, scale_bits);
 }
 
 /*!
@@ -262,116 +251,114 @@ std::unique_ptr<Polygon2d> apply(const std::vector<Clipper2Lib::Paths64>& pathsv
 
    May return an empty Polygon2d, but will not return nullptr.
  */
-std::unique_ptr<Polygon2d> apply(const std::vector<std::shared_ptr<const Polygon2d>>& polygons,
-                                 Clipper2Lib::ClipType clipType)
-{
-  const int scale_bits = scaleBitsFromPrecision();
+std::unique_ptr<Polygon2d> apply (const std::vector<std::shared_ptr<const Polygon2d>> &polygons,
+                                  Clipper2Lib::ClipType clipType) {
+  const int scale_bits = scaleBitsFromPrecision ();
 
   std::vector<Clipper2Lib::Paths64> pathsvector;
-  for (const auto& polygon : polygons) {
+  for (const auto &polygon : polygons) {
     if (polygon) {
-      auto polypaths = fromPolygon2d(*polygon, scale_bits);
-      if (!polygon->isSanitized()) {
-        polypaths = Clipper2Lib::PolyTreeToPaths64(*sanitize(polypaths));
+      auto polypaths = fromPolygon2d (*polygon, scale_bits);
+      if (!polygon->isSanitized ()) {
+        polypaths = Clipper2Lib::PolyTreeToPaths64 (*sanitize (polypaths));
       }
-      pathsvector.push_back(std::move(polypaths));
+      pathsvector.push_back (std::move (polypaths));
     } else {
       // Insert empty object as this could be the positive object in a difference
-      pathsvector.emplace_back();
+      pathsvector.emplace_back ();
     }
   }
-  auto res = apply(pathsvector, clipType, scale_bits);
-  assert(res);
+  auto res = apply (pathsvector, clipType, scale_bits);
+  assert (res);
   return res;
 }
 
-std::unique_ptr<Polygon2d> applyMinkowski(const std::vector<std::shared_ptr<const Polygon2d>>& polygons)
-{
-  if (polygons.size() == 1) {
-    return polygons[0] ? std::make_unique<Polygon2d>(*polygons[0]) : nullptr; // Just copy
+std::unique_ptr<Polygon2d> applyMinkowski (const std::vector<std::shared_ptr<const Polygon2d>> &polygons) {
+  if (polygons.size () == 1) {
+    return polygons[0] ? std::make_unique<Polygon2d> (*polygons[0]) : nullptr; // Just copy
   }
 
-  auto it = polygons.begin();
-  while (it != polygons.end() && !(*it)) ++it;
-  if (it == polygons.end()) return nullptr;
-  const int scale_bits = scaleBitsFromPrecision();
+  auto it = polygons.begin ();
+  while (it != polygons.end () && !(*it))
+    ++it;
+  if (it == polygons.end ())
+    return nullptr;
+  const int scale_bits = scaleBitsFromPrecision ();
 
   Clipper2Lib::Clipper64 clipper;
-  clipper.PreserveCollinear(false);
-  auto lhs = fromPolygon2d(polygons[0] ? *polygons[0] : Polygon2d(), scale_bits);
+  clipper.PreserveCollinear (false);
+  auto lhs = fromPolygon2d (polygons[0] ? *polygons[0] : Polygon2d (), scale_bits);
 
-  for (size_t i = 1; i < polygons.size(); ++i) {
-    if (!polygons[i]) continue;
+  for (size_t i = 1; i < polygons.size (); ++i) {
+    if (!polygons[i])
+      continue;
     Clipper2Lib::Paths64 minkowski_terms;
-    auto rhs = fromPolygon2d(*polygons[i], scale_bits);
+    auto rhs = fromPolygon2d (*polygons[i], scale_bits);
 
     // First, convolve each outline of lhs with the outlines of rhs
-    for (auto const& rhs_path : rhs) {
-      for (auto const& lhs_path : lhs) {
+    for (auto const &rhs_path : rhs) {
+      for (auto const &lhs_path : lhs) {
         Clipper2Lib::Paths64 result;
-        minkowski_outline(lhs_path, rhs_path, result, true, true);
-        minkowski_terms.insert(minkowski_terms.end(), result.begin(), result.end());
+        minkowski_outline (lhs_path, rhs_path, result, true, true);
+        minkowski_terms.insert (minkowski_terms.end (), result.begin (), result.end ());
       }
     }
 
     // Then, fill the central parts
-    fill_minkowski_insides(lhs, rhs, minkowski_terms);
-    fill_minkowski_insides(rhs, lhs, minkowski_terms);
+    fill_minkowski_insides (lhs, rhs, minkowski_terms);
+    fill_minkowski_insides (rhs, lhs, minkowski_terms);
 
     // This union operation must be performed at each iteration since the minkowski_terms
     // now contain lots of small quads
-    clipper.Clear();
-    clipper.AddSubject(minkowski_terms);
+    clipper.Clear ();
+    clipper.AddSubject (minkowski_terms);
 
-    if (i != polygons.size() - 1) {
-      clipper.Execute(Clipper2Lib::ClipType::Union, Clipper2Lib::FillRule::NonZero, lhs);
+    if (i != polygons.size () - 1) {
+      clipper.Execute (Clipper2Lib::ClipType::Union, Clipper2Lib::FillRule::NonZero, lhs);
     }
   }
 
   Clipper2Lib::PolyTree64 polytree;
-  clipper.Execute(Clipper2Lib::ClipType::Union, Clipper2Lib::FillRule::NonZero, polytree);
-  return toPolygon2d(polytree, scale_bits);
+  clipper.Execute (Clipper2Lib::ClipType::Union, Clipper2Lib::FillRule::NonZero, polytree);
+  return toPolygon2d (polytree, scale_bits);
 }
 
-std::unique_ptr<Polygon2d> applyOffset(const Polygon2d& poly, double offset, Clipper2Lib::JoinType joinType,
-                                       double miter_limit, double arc_tolerance)
-{
+std::unique_ptr<Polygon2d> applyOffset (const Polygon2d &poly, double offset, Clipper2Lib::JoinType joinType,
+                                        double miter_limit, double arc_tolerance) {
   const bool isMiter = joinType == Clipper2Lib::JoinType::Miter;
   const bool isRound = joinType == Clipper2Lib::JoinType::Round;
-  const int scale_bits = scaleBitsFromPrecision();
-  Clipper2Lib::ClipperOffset co(
+  const int scale_bits = scaleBitsFromPrecision ();
+  Clipper2Lib::ClipperOffset co (
     isMiter ? miter_limit : 2.0,
-    isRound ? std::ldexp(arc_tolerance, scale_bits) : 1.0
-    );
-  auto p = ClipperUtils::fromPolygon2d(poly, scale_bits);
-  co.AddPaths(p, joinType, Clipper2Lib::EndType::Polygon);
+    isRound ? std::ldexp (arc_tolerance, scale_bits) : 1.0);
+  auto p = ClipperUtils::fromPolygon2d (poly, scale_bits);
+  co.AddPaths (p, joinType, Clipper2Lib::EndType::Polygon);
   Clipper2Lib::PolyTree64 result;
-  co.Execute(std::ldexp(offset, scale_bits), result);
-  return toPolygon2d(result, scale_bits);
+  co.Execute (std::ldexp (offset, scale_bits), result);
+  return toPolygon2d (result, scale_bits);
 }
 
-std::unique_ptr<Polygon2d> applyProjection(const std::vector<std::shared_ptr<const Polygon2d>>& polygons)
-{
-  const int scale_bits = scaleBitsFromPrecision();
+std::unique_ptr<Polygon2d> applyProjection (const std::vector<std::shared_ptr<const Polygon2d>> &polygons) {
+  const int scale_bits = scaleBitsFromPrecision ();
 
   Clipper2Lib::Clipper64 sumclipper;
-  sumclipper.PreserveCollinear(false);
-  for (const auto& poly : polygons) {
-    Clipper2Lib::Paths64 result = ClipperUtils::fromPolygon2d(*poly, scale_bits);
+  sumclipper.PreserveCollinear (false);
+  for (const auto &poly : polygons) {
+    Clipper2Lib::Paths64 result = ClipperUtils::fromPolygon2d (*poly, scale_bits);
     // Using NonZero ensures that we don't create holes from polygons sharing
     // edges since we're unioning a mesh
-    result = ClipperUtils::process(result, Clipper2Lib::ClipType::Union, Clipper2Lib::FillRule::NonZero);
+    result = ClipperUtils::process (result, Clipper2Lib::ClipType::Union, Clipper2Lib::FillRule::NonZero);
     // Add correctly winded polygons to the main clipper
-    sumclipper.AddSubject(result);
+    sumclipper.AddSubject (result);
   }
 
   Clipper2Lib::PolyTree64 sumresult;
   // This is key - without StrictlySimple, we tend to get self-intersecting results
   // FIXME: StrictlySimple doesn't exist in Clipper2. Check if it still exposes problems without
   //  sumclipper.StrictlySimple(true);
-  sumclipper.Execute(Clipper2Lib::ClipType::Union, Clipper2Lib::FillRule::NonZero, sumresult);
-  if (sumresult.Count() > 0) {
-    return ClipperUtils::toPolygon2d(sumresult, scale_bits);
+  sumclipper.Execute (Clipper2Lib::ClipType::Union, Clipper2Lib::FillRule::NonZero, sumresult);
+  if (sumresult.Count () > 0) {
+    return ClipperUtils::toPolygon2d (sumresult, scale_bits);
   }
   return {};
 }
diff --git a/src/geometry/ClipperUtils.h b/src/geometry/ClipperUtils.h
index daf9657b5..da916cbc1 100644
--- a/src/geometry/ClipperUtils.h
+++ b/src/geometry/ClipperUtils.h
@@ -11,17 +11,17 @@ namespace ClipperUtils {
 
 constexpr int DEFAULT_PRECISION = 8;
 
-int scaleBitsFromBounds(const BoundingBox& bounds, int bits = 0);
-int scaleBitsFromPrecision(int precision = DEFAULT_PRECISION);
+int scaleBitsFromBounds (const BoundingBox &bounds, int bits = 0);
+int scaleBitsFromPrecision (int precision = DEFAULT_PRECISION);
 
-std::unique_ptr<Clipper2Lib::PolyTree64> sanitize(const Clipper2Lib::Paths64& paths);
-std::unique_ptr<Polygon2d> sanitize(const Polygon2d& poly);
+std::unique_ptr<Clipper2Lib::PolyTree64> sanitize (const Clipper2Lib::Paths64 &paths);
+std::unique_ptr<Polygon2d> sanitize (const Polygon2d &poly);
 
-Clipper2Lib::Paths64 fromPolygon2d(const Polygon2d& poly, int scale_bits);
-std::unique_ptr<Polygon2d> toPolygon2d(const Clipper2Lib::PolyTree64& poly, int scale_bits);
+Clipper2Lib::Paths64 fromPolygon2d (const Polygon2d &poly, int scale_bits);
+std::unique_ptr<Polygon2d> toPolygon2d (const Clipper2Lib::PolyTree64 &poly, int scale_bits);
 
-std::unique_ptr<Polygon2d> applyOffset(const Polygon2d& poly, double offset, Clipper2Lib::JoinType joinType, double miter_limit, double arc_tolerance);
-std::unique_ptr<Polygon2d> applyMinkowski(const std::vector<std::shared_ptr<const Polygon2d>>& polygons);
-std::unique_ptr<Polygon2d> applyProjection(const std::vector<std::shared_ptr<const Polygon2d>>& polygons);
-std::unique_ptr<Polygon2d> apply(const std::vector<std::shared_ptr<const Polygon2d>>& polygons, Clipper2Lib::ClipType);
-}
+std::unique_ptr<Polygon2d> applyOffset (const Polygon2d &poly, double offset, Clipper2Lib::JoinType joinType, double miter_limit, double arc_tolerance);
+std::unique_ptr<Polygon2d> applyMinkowski (const std::vector<std::shared_ptr<const Polygon2d>> &polygons);
+std::unique_ptr<Polygon2d> applyProjection (const std::vector<std::shared_ptr<const Polygon2d>> &polygons);
+std::unique_ptr<Polygon2d> apply (const std::vector<std::shared_ptr<const Polygon2d>> &polygons, Clipper2Lib::ClipType);
+} // namespace ClipperUtils
diff --git a/src/geometry/Geometry.cc b/src/geometry/Geometry.cc
index d9a46927e..570f2f592 100644
--- a/src/geometry/Geometry.cc
+++ b/src/geometry/Geometry.cc
@@ -8,70 +8,65 @@
 #include <string>
 #include <utility>
 
-GeometryList::GeometryList(Geometry::Geometries geometries) : children(std::move(geometries))
-{
+GeometryList::GeometryList (Geometry::Geometries geometries)
+  : children (std::move (geometries)) {
 }
 
-std::unique_ptr<Geometry> GeometryList::copy() const
-{
-  return std::make_unique<GeometryList>(*this);
+std::unique_ptr<Geometry> GeometryList::copy () const {
+  return std::make_unique<GeometryList> (*this);
 }
 
-size_t GeometryList::memsize() const
-{
+size_t GeometryList::memsize () const {
   size_t sum = 0;
-  for (const auto& item : this->children) {
-    sum += item.second->memsize();
+  for (const auto &item : this->children) {
+    sum += item.second->memsize ();
   }
   return sum;
 }
 
-BoundingBox GeometryList::getBoundingBox() const
-{
+BoundingBox GeometryList::getBoundingBox () const {
   BoundingBox bbox;
-  for (const auto& item : this->children) {
-    bbox.extend(item.second->getBoundingBox());
+  for (const auto &item : this->children) {
+    bbox.extend (item.second->getBoundingBox ());
   }
   return bbox;
 }
 
-std::string GeometryList::dump() const
-{
+std::string GeometryList::dump () const {
   std::stringstream out;
-  for (const auto& item : this->children) {
-    out << item.second->dump();
+  for (const auto &item : this->children) {
+    out << item.second->dump ();
   }
-  return out.str();
+  return out.str ();
 }
 
-unsigned int GeometryList::getDimension() const
-{
+unsigned int GeometryList::getDimension () const {
   unsigned int dim = 0;
-  for (const auto& item : this->children) {
-    if (!dim) dim = item.second->getDimension();
-    else if (dim != item.second->getDimension()) {
-      LOG(message_group::Warning, "Mixing 2D and 3D objects is not supported.");
+  for (const auto &item : this->children) {
+    if (!dim)
+      dim = item.second->getDimension ();
+    else if (dim != item.second->getDimension ()) {
+      LOG (message_group::Warning, "Mixing 2D and 3D objects is not supported.");
       break;
     }
   }
   return dim;
 }
 
-bool GeometryList::isEmpty() const
-{
-  for (const auto& item : this->children) {
-    if (!item.second->isEmpty()) return false;
+bool GeometryList::isEmpty () const {
+  for (const auto &item : this->children) {
+    if (!item.second->isEmpty ())
+      return false;
   }
   return true;
 }
 
-void flatten(const GeometryList& geomlist, GeometryList::Geometries& childlist)
-{
-  for (const auto& item : geomlist.getChildren()) {
-    if (const auto chlist = std::dynamic_pointer_cast<const GeometryList>(item.second)) {
-      flatten(*chlist, childlist);
+void flatten (const GeometryList &geomlist, GeometryList::Geometries &childlist) {
+  for (const auto &item : geomlist.getChildren ()) {
+    if (const auto chlist = std::dynamic_pointer_cast<const GeometryList> (item.second)) {
+      flatten (*chlist, childlist);
     } else {
-      childlist.push_back(item);
+      childlist.push_back (item);
     }
   }
 }
@@ -81,9 +76,8 @@ void flatten(const GeometryList& geomlist, GeometryList::Geometries& childlist)
    children directly reachable GeometryLists are collected in a flat
    list)
  */
-Geometry::Geometries GeometryList::flatten() const
-{
+Geometry::Geometries GeometryList::flatten () const {
   Geometries newchildren;
-  ::flatten(*this, newchildren);
+  ::flatten (*this, newchildren);
   return newchildren;
 }
diff --git a/src/geometry/Geometry.h b/src/geometry/Geometry.h
index 6ae983c06..cb10971cc 100644
--- a/src/geometry/Geometry.h
+++ b/src/geometry/Geometry.h
@@ -25,30 +25,37 @@ public:
   using GeometryItem = std::pair<std::shared_ptr<const AbstractNode>, std::shared_ptr<const Geometry>>;
   using Geometries = std::list<GeometryItem>;
 
-  Geometry() = default;
-  Geometry(const Geometry&) = default;
-  Geometry& operator=(const Geometry&) = default;
-  Geometry(Geometry&&) = default;
-  Geometry& operator=(Geometry&&) = default;
-  virtual ~Geometry() = default;
-
-  [[nodiscard]] virtual size_t memsize() const = 0;
-  [[nodiscard]] virtual BoundingBox getBoundingBox() const = 0;
-  [[nodiscard]] virtual std::string dump() const = 0;
-  [[nodiscard]] virtual unsigned int getDimension() const = 0;
-  [[nodiscard]] virtual bool isEmpty() const = 0;
-  [[nodiscard]] virtual std::unique_ptr<Geometry> copy() const = 0;
-  [[nodiscard]] virtual size_t numFacets() const = 0;
-  [[nodiscard]] unsigned int getConvexity() const { return convexity; }
-  void setConvexity(int c) { this->convexity = c; }
-  virtual void setColor(const Color4f& c) {}
-
-  virtual void transform(const Transform3d& /*mat*/) { assert(!"transform not implemented!"); }
-  virtual void resize(const Vector3d& /*newsize*/, const Eigen::Matrix<bool, 3, 1>& /*autosize*/) {
-    assert(!"resize not implemented!");
+  Geometry () = default;
+  Geometry (const Geometry &) = default;
+  Geometry &operator= (const Geometry &) = default;
+  Geometry (Geometry &&) = default;
+  Geometry &operator= (Geometry &&) = default;
+  virtual ~Geometry () = default;
+
+  [[nodiscard]] virtual size_t memsize () const = 0;
+  [[nodiscard]] virtual BoundingBox getBoundingBox () const = 0;
+  [[nodiscard]] virtual std::string dump () const = 0;
+  [[nodiscard]] virtual unsigned int getDimension () const = 0;
+  [[nodiscard]] virtual bool isEmpty () const = 0;
+  [[nodiscard]] virtual std::unique_ptr<Geometry> copy () const = 0;
+  [[nodiscard]] virtual size_t numFacets () const = 0;
+  [[nodiscard]] unsigned int getConvexity () const {
+    return convexity;
   }
+  void setConvexity (int c) {
+    this->convexity = c;
+  }
+  virtual void setColor (const Color4f &c) {}
+
+  virtual void transform (const Transform3d & /*mat*/) {
+    assert (!"transform not implemented!");
+  }
+  virtual void resize (const Vector3d & /*newsize*/, const Eigen::Matrix<bool, 3, 1> & /*autosize*/) {
+    assert (!"resize not implemented!");
+  }
+
+  virtual void accept (GeometryVisitor &visitor) const = 0;
 
-  virtual void accept(GeometryVisitor& visitor) const = 0;
 protected:
   int convexity{1};
 };
@@ -59,44 +66,46 @@ protected:
 class GeometryVisitor
 {
 public:
-  virtual void visit(const GeometryList& node) = 0;
-  virtual void visit(const PolySet& node) = 0;
-  virtual void visit(const Polygon2d& node) = 0;
+  virtual void visit (const GeometryList &node) = 0;
+  virtual void visit (const PolySet &node) = 0;
+  virtual void visit (const Polygon2d &node) = 0;
 #ifdef ENABLE_CGAL
-  virtual void visit(const CGALNefGeometry& node) = 0;
+  virtual void visit (const CGALNefGeometry &node) = 0;
 #endif
 #ifdef ENABLE_MANIFOLD
-  virtual void visit(const ManifoldGeometry& node) = 0;
+  virtual void visit (const ManifoldGeometry &node) = 0;
 #endif
-  virtual ~GeometryVisitor() = default;
+  virtual ~GeometryVisitor () = default;
 };
 
-#define VISITABLE_GEOMETRY() \
-        void accept(GeometryVisitor & visitor) const override { \
-          visitor.visit(*this); \
-        }
+#define VISITABLE_GEOMETRY()                              \
+  void accept (GeometryVisitor &visitor) const override { \
+    visitor.visit (*this);                                \
+  }
 
 class GeometryList : public Geometry
 {
 public:
-  VISITABLE_GEOMETRY();
+  VISITABLE_GEOMETRY ();
   Geometries children;
 
-  GeometryList();
-  GeometryList(Geometry::Geometries geometries);
-
-  [[nodiscard]] size_t memsize() const override;
-  [[nodiscard]] BoundingBox getBoundingBox() const override;
-  [[nodiscard]] std::string dump() const override;
-  [[nodiscard]] unsigned int getDimension() const override;
-  [[nodiscard]] bool isEmpty() const override;
-  [[nodiscard]] std::unique_ptr<Geometry> copy() const override;
-  [[nodiscard]] size_t numFacets() const override { assert(false && "not implemented"); return 0; }
+  GeometryList ();
+  GeometryList (Geometry::Geometries geometries);
+
+  [[nodiscard]] size_t memsize () const override;
+  [[nodiscard]] BoundingBox getBoundingBox () const override;
+  [[nodiscard]] std::string dump () const override;
+  [[nodiscard]] unsigned int getDimension () const override;
+  [[nodiscard]] bool isEmpty () const override;
+  [[nodiscard]] std::unique_ptr<Geometry> copy () const override;
+  [[nodiscard]] size_t numFacets () const override {
+    assert (false && "not implemented");
+    return 0;
+  }
 
-  [[nodiscard]] const Geometries& getChildren() const {
+  [[nodiscard]] const Geometries &getChildren () const {
     return this->children;
   }
 
-  [[nodiscard]] Geometries flatten() const;
-
+  [[nodiscard]] Geometries flatten () const;
 };
diff --git a/src/geometry/GeometryCache.cc b/src/geometry/GeometryCache.cc
index a1877f17e..84de1d5e4 100644
--- a/src/geometry/GeometryCache.cc
+++ b/src/geometry/GeometryCache.cc
@@ -12,56 +12,51 @@
 
 GeometryCache *GeometryCache::inst = nullptr;
 
-std::shared_ptr<const Geometry> GeometryCache::get(const std::string& id) const
-{
-  const auto& geom = this->cache[id]->geom;
+std::shared_ptr<const Geometry> GeometryCache::get (const std::string &id) const {
+  const auto &geom = this->cache[id]->geom;
 #ifdef DEBUG
-  PRINTDB("Geometry Cache hit: %s (%d bytes)", id.substr(0, 40) % (geom ? geom->memsize() : 0));
+  PRINTDB ("Geometry Cache hit: %s (%d bytes)", id.substr (0, 40) % (geom ? geom->memsize () : 0));
 #endif
   return geom;
 }
 
-bool GeometryCache::insert(const std::string& id, const std::shared_ptr<const Geometry>& geom)
-{
-  auto inserted = this->cache.insert(id, new cache_entry(geom), geom ? geom->memsize() : 0);
+bool GeometryCache::insert (const std::string &id, const std::shared_ptr<const Geometry> &geom) {
+  auto inserted = this->cache.insert (id, new cache_entry (geom), geom ? geom->memsize () : 0);
 #if defined(ENABLE_CGAL) && defined(DEBUG)
-  assert(!dynamic_cast<const CGALNefGeometry *>(geom.get()));
-  if (inserted) PRINTDB("Geometry Cache insert: %s (%d bytes)",
-                        id.substr(0, 40) % (geom ? geom->memsize() : 0));
-  else PRINTDB("Geometry Cache insert failed: %s (%d bytes)",
-               id.substr(0, 40) % (geom ? geom->memsize() : 0));
+  assert (!dynamic_cast<const CGALNefGeometry *> (geom.get ()));
+  if (inserted)
+    PRINTDB ("Geometry Cache insert: %s (%d bytes)",
+             id.substr (0, 40) % (geom ? geom->memsize () : 0));
+  else
+    PRINTDB ("Geometry Cache insert failed: %s (%d bytes)",
+             id.substr (0, 40) % (geom ? geom->memsize () : 0));
 #endif
   return inserted;
 }
 
-size_t GeometryCache::size() const
-{
-  return cache.size();
+size_t GeometryCache::size () const {
+  return cache.size ();
 }
 
-size_t GeometryCache::totalCost() const
-{
-  return cache.totalCost();
+size_t GeometryCache::totalCost () const {
+  return cache.totalCost ();
 }
 
-size_t GeometryCache::maxSizeMB() const
-{
-  return this->cache.maxCost() / (1024ul * 1024ul);
+size_t GeometryCache::maxSizeMB () const {
+  return this->cache.maxCost () / (1024ul * 1024ul);
 }
 
-void GeometryCache::setMaxSizeMB(size_t limit)
-{
-  this->cache.setMaxCost(limit * 1024ul * 1024ul);
+void GeometryCache::setMaxSizeMB (size_t limit) {
+  this->cache.setMaxCost (limit * 1024ul * 1024ul);
 }
 
-void GeometryCache::print()
-{
-  LOG("Geometries in cache: %1$d", this->cache.size());
-  LOG("Geometry cache size in bytes: %1$d", this->cache.totalCost());
+void GeometryCache::print () {
+  LOG ("Geometries in cache: %1$d", this->cache.size ());
+  LOG ("Geometry cache size in bytes: %1$d", this->cache.totalCost ());
 }
 
-GeometryCache::cache_entry::cache_entry(const std::shared_ptr<const Geometry>& geom)
-  : geom(geom)
-{
-  if (print_messages_stack.size() > 0) this->msg = print_messages_stack.back();
+GeometryCache::cache_entry::cache_entry (const std::shared_ptr<const Geometry> &geom)
+  : geom (geom) {
+  if (print_messages_stack.size () > 0)
+    this->msg = print_messages_stack.back ();
 }
diff --git a/src/geometry/GeometryCache.h b/src/geometry/GeometryCache.h
index 7bbcd3e55..4acf82f36 100644
--- a/src/geometry/GeometryCache.h
+++ b/src/geometry/GeometryCache.h
@@ -10,19 +10,28 @@
 class GeometryCache
 {
 public:
-  GeometryCache(size_t memorylimit = 100ul * 1024ul * 1024ul) : cache(memorylimit) {}
-
-  static GeometryCache *instance() { if (!inst) inst = new GeometryCache; return inst; }
-
-  bool contains(const std::string& id) const { return this->cache.contains(id); }
-  std::shared_ptr<const class Geometry> get(const std::string& id) const;
-  bool insert(const std::string& id, const std::shared_ptr<const Geometry>& geom);
-  size_t size() const;
-  size_t totalCost() const;
-  size_t maxSizeMB() const;
-  void setMaxSizeMB(size_t limit);
-  void clear() { cache.clear(); }
-  void print();
+  GeometryCache (size_t memorylimit = 100ul * 1024ul * 1024ul)
+    : cache (memorylimit) {}
+
+  static GeometryCache *instance () {
+    if (!inst)
+      inst = new GeometryCache;
+    return inst;
+  }
+
+  bool contains (const std::string &id) const {
+    return this->cache.contains (id);
+  }
+  std::shared_ptr<const class Geometry> get (const std::string &id) const;
+  bool insert (const std::string &id, const std::shared_ptr<const Geometry> &geom);
+  size_t size () const;
+  size_t totalCost () const;
+  size_t maxSizeMB () const;
+  void setMaxSizeMB (size_t limit);
+  void clear () {
+    cache.clear ();
+  }
+  void print ();
 
 private:
   static GeometryCache *inst;
@@ -30,7 +39,7 @@ private:
   struct cache_entry {
     std::shared_ptr<const class Geometry> geom;
     std::string msg;
-    cache_entry(const std::shared_ptr<const Geometry>& geom);
+    cache_entry (const std::shared_ptr<const Geometry> &geom);
   };
 
   Cache<std::string, cache_entry> cache;
diff --git a/src/geometry/GeometryEvaluator.cc b/src/geometry/GeometryEvaluator.cc
index d65ae2270..4e960ce05 100644
--- a/src/geometry/GeometryEvaluator.cc
+++ b/src/geometry/GeometryEvaluator.cc
@@ -53,7 +53,8 @@ class Geometry;
 class Polygon2d;
 class Tree;
 
-GeometryEvaluator::GeometryEvaluator(const Tree& tree) : tree(tree) { }
+GeometryEvaluator::GeometryEvaluator (const Tree &tree)
+  : tree (tree) {}
 
 /*!
    Set allownef to false to force the result to _not_ be a Nef polyhedron
@@ -63,33 +64,32 @@ GeometryEvaluator::GeometryEvaluator(const Tree& tree) : tree(tree) { }
  * PolySet geometries are always 3D. 2D Polysets are only created for special-purpose rendering operations downstream from here.
  * Needs validation: Implementation-specific geometries shouldn't be mixed (Nef polyhedron, Manifold)
  */
-std::shared_ptr<const Geometry> GeometryEvaluator::evaluateGeometry(const AbstractNode& node,
-                                                                    bool allownef)
-{
-  auto result = smartCacheGet(node, allownef);
+std::shared_ptr<const Geometry> GeometryEvaluator::evaluateGeometry (const AbstractNode &node,
+                                                                     bool allownef) {
+  auto result = smartCacheGet (node, allownef);
   if (!result) {
     // If not found in any caches, we need to evaluate the geometry
     // traverse() will set this->root to a geometry, which can be any geometry
     // (including GeometryList if the lazyunions feature is enabled)
-    this->traverse(node);
+    this->traverse (node);
     result = this->root;
 
     // Insert the raw result into the cache.
-    smartCacheInsert(node, result);
+    smartCacheInsert (node, result);
   }
 
   // Convert engine-specific 3D geometry to PolySet if needed
   // Note: we don't store the converted into the cache as it would conflict with subsequent calls where allownef is true.
   if (!allownef) {
-    if (auto ps = PolySetUtils::getGeometryAsPolySet(result)) {
-      assert(ps->getDimension() == 3);
+    if (auto ps = PolySetUtils::getGeometryAsPolySet (result)) {
+      assert (ps->getDimension () == 3);
       // We cannot render concave polygons, so tessellate any PolySets
-      if (!ps->isEmpty() && !ps->isTriangular()) {
+      if (!ps->isEmpty () && !ps->isTriangular ()) {
         // Since is_convex() doesn't handle non-planar faces, we need to tessellate
         // also in the indeterminate state so we cannot just use a boolean comparison. See #1061
-        bool convex = bool(ps->convexValue()); // bool is true only if tribool is true, (not indeterminate and not false)
+        bool convex = bool (ps->convexValue ()); // bool is true only if tribool is true, (not indeterminate and not false)
         if (!convex) {
-          ps = PolySetUtils::tessellate_faces(*ps);
+          ps = PolySetUtils::tessellate_faces (*ps);
         }
       }
       return ps;
@@ -98,25 +98,28 @@ std::shared_ptr<const Geometry> GeometryEvaluator::evaluateGeometry(const Abstra
   return result;
 }
 
-bool GeometryEvaluator::isValidDim(const Geometry::GeometryItem& item, unsigned int& dim) const {
-  if (!item.first->modinst->isBackground() && item.second) {
-    if (!dim) dim = item.second->getDimension();
-    else if (dim != item.second->getDimension() && !item.second->isEmpty()) {
-      LOG(message_group::Warning, item.first->modinst->location(), this->tree.getDocumentPath(), "Mixing 2D and 3D objects is not supported");
+bool GeometryEvaluator::isValidDim (const Geometry::GeometryItem &item, unsigned int &dim) const {
+  if (!item.first->modinst->isBackground () && item.second) {
+    if (!dim)
+      dim = item.second->getDimension ();
+    else if (dim != item.second->getDimension () && !item.second->isEmpty ()) {
+      LOG (message_group::Warning, item.first->modinst->location (), this->tree.getDocumentPath (), "Mixing 2D and 3D objects is not supported");
       return false;
     }
   }
   return true;
 }
 
-GeometryEvaluator::ResultObject GeometryEvaluator::applyToChildren(const AbstractNode& node, OpenSCADOperator op)
-{
+GeometryEvaluator::ResultObject GeometryEvaluator::applyToChildren (const AbstractNode &node, OpenSCADOperator op) {
   unsigned int dim = 0;
-  for (const auto& item : this->visitedchildren[node.index()]) {
-    if (!isValidDim(item, dim)) break;
+  for (const auto &item : this->visitedchildren[node.index ()]) {
+    if (!isValidDim (item, dim))
+      break;
   }
-  if (dim == 2) return ResultObject::mutableResult(std::shared_ptr<Geometry>(applyToChildren2D(node, op)));
-  else if (dim == 3) return applyToChildren3D(node, op);
+  if (dim == 2)
+    return ResultObject::mutableResult (std::shared_ptr<Geometry> (applyToChildren2D (node, op)));
+  else if (dim == 3)
+    return applyToChildren3D (node, op);
   return {};
 }
 
@@ -125,148 +128,146 @@ GeometryEvaluator::ResultObject GeometryEvaluator::applyToChildren(const Abstrac
 
    May return nullptr or any 3D Geometry object
  */
-GeometryEvaluator::ResultObject GeometryEvaluator::applyToChildren3D(const AbstractNode& node, OpenSCADOperator op)
-{
-  Geometry::Geometries children = collectChildren3D(node);
-  if (children.empty()) return {};
+GeometryEvaluator::ResultObject GeometryEvaluator::applyToChildren3D (const AbstractNode &node, OpenSCADOperator op) {
+  Geometry::Geometries children = collectChildren3D (node);
+  if (children.empty ())
+    return {};
 
   if (op == OpenSCADOperator::HULL) {
-    return ResultObject::mutableResult(std::shared_ptr<Geometry>(applyHull(children)));
+    return ResultObject::mutableResult (std::shared_ptr<Geometry> (applyHull (children)));
   } else if (op == OpenSCADOperator::FILL) {
-    for (const auto& item : children) {
-      LOG(message_group::Warning, item.first->modinst->location(), this->tree.getDocumentPath(), "fill() not yet implemented for 3D");
+    for (const auto &item : children) {
+      LOG (message_group::Warning, item.first->modinst->location (), this->tree.getDocumentPath (), "fill() not yet implemented for 3D");
     }
   }
 
   // Only one child -> this is a noop
-  if (children.size() == 1) return ResultObject::constResult(children.front().second);
+  if (children.size () == 1)
+    return ResultObject::constResult (children.front ().second);
 
   switch (op) {
-  case OpenSCADOperator::MINKOWSKI:
-  {
+  case OpenSCADOperator::MINKOWSKI: {
     Geometry::Geometries actualchildren;
-    for (const auto& item : children) {
-      if (item.second && !item.second->isEmpty()) actualchildren.push_back(item);
+    for (const auto &item : children) {
+      if (item.second && !item.second->isEmpty ())
+        actualchildren.push_back (item);
     }
-    if (actualchildren.empty()) return {};
-    if (actualchildren.size() == 1) return ResultObject::constResult(actualchildren.front().second);
-    return ResultObject::constResult(applyMinkowski(actualchildren));
+    if (actualchildren.empty ())
+      return {};
+    if (actualchildren.size () == 1)
+      return ResultObject::constResult (actualchildren.front ().second);
+    return ResultObject::constResult (applyMinkowski (actualchildren));
     break;
   }
-  case OpenSCADOperator::UNION:
-  {
+  case OpenSCADOperator::UNION: {
     Geometry::Geometries actualchildren;
-    for (const auto& item : children) {
-      if (item.second && !item.second->isEmpty()) actualchildren.push_back(item);
+    for (const auto &item : children) {
+      if (item.second && !item.second->isEmpty ())
+        actualchildren.push_back (item);
     }
-    if (actualchildren.empty()) return {};
-    if (actualchildren.size() == 1) return ResultObject::constResult(actualchildren.front().second);
+    if (actualchildren.empty ())
+      return {};
+    if (actualchildren.size () == 1)
+      return ResultObject::constResult (actualchildren.front ().second);
 #ifdef ENABLE_MANIFOLD
-    if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
-      return ResultObject::mutableResult(ManifoldUtils::applyOperator3DManifold(actualchildren, op));
+    if (RenderSettings::inst ()->backend3D == RenderBackend3D::ManifoldBackend) {
+      return ResultObject::mutableResult (ManifoldUtils::applyOperator3DManifold (actualchildren, op));
     }
 #endif
 #ifdef ENABLE_CGAL
-    return ResultObject::constResult(std::shared_ptr<const Geometry>(CGALUtils::applyUnion3D(actualchildren.begin(), actualchildren.end())));
+    return ResultObject::constResult (std::shared_ptr<const Geometry> (CGALUtils::applyUnion3D (actualchildren.begin (), actualchildren.end ())));
 #else
-    assert(false && "No boolean backend available");
+    assert (false && "No boolean backend available");
 #endif
     break;
   }
-  default:
-  {
+  default: {
 #ifdef ENABLE_MANIFOLD
-    if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
-      return ResultObject::mutableResult(ManifoldUtils::applyOperator3DManifold(children, op));
+    if (RenderSettings::inst ()->backend3D == RenderBackend3D::ManifoldBackend) {
+      return ResultObject::mutableResult (ManifoldUtils::applyOperator3DManifold (children, op));
     }
 #endif
 #ifdef ENABLE_CGAL
-    return ResultObject::constResult(CGALUtils::applyOperator3D(children, op));
+    return ResultObject::constResult (CGALUtils::applyOperator3D (children, op));
 #else
-    assert(false && "No boolean backend available");
-    #endif
+    assert (false && "No boolean backend available");
+#endif
     break;
   }
   }
 }
 
-
-
 /*!
    Apply 2D hull.
 
    May return an empty geometry but will not return nullptr.
  */
 
-std::unique_ptr<Polygon2d> GeometryEvaluator::applyHull2D(const AbstractNode& node)
-{
-  auto children = collectChildren2D(node);
-  auto geometry = std::make_unique<Polygon2d>();
+std::unique_ptr<Polygon2d> GeometryEvaluator::applyHull2D (const AbstractNode &node) {
+  auto children = collectChildren2D (node);
+  auto geometry = std::make_unique<Polygon2d> ();
 
 #ifdef ENABLE_CGAL
   using CGALPoint2 = CGAL::Point_2<CGAL_DoubleKernel>;
   // Collect point cloud
   std::list<CGALPoint2> points;
-  for (const auto& p : children) {
+  for (const auto &p : children) {
     if (p) {
-      for (const auto& o : p->outlines()) {
-        for (const auto& v : o.vertices) {
-          points.emplace_back(v[0], v[1]);
+      for (const auto &o : p->outlines ()) {
+        for (const auto &v : o.vertices) {
+          points.emplace_back (v[0], v[1]);
         }
       }
     }
   }
-  if (points.size() > 0) {
+  if (points.size () > 0) {
     // Apply hull
     std::list<CGALPoint2> result;
     try {
-      CGAL::convex_hull_2(points.begin(), points.end(), std::back_inserter(result));
+      CGAL::convex_hull_2 (points.begin (), points.end (), std::back_inserter (result));
       // Construct Polygon2d
       Outline2d outline;
-      for (const auto& p : result) {
-        outline.vertices.emplace_back(p[0], p[1]);
+      for (const auto &p : result) {
+        outline.vertices.emplace_back (p[0], p[1]);
       }
-      geometry->addOutline(outline);
-      geometry->setSanitized(true);
-    } catch (const CGAL::Failure_exception& e) {
-      LOG(message_group::Warning, "GeometryEvaluator::applyHull2D() during CGAL::convex_hull_2(): %1$s", e.what());
+      geometry->addOutline (outline);
+      geometry->setSanitized (true);
+    } catch (const CGAL::Failure_exception &e) {
+      LOG (message_group::Warning, "GeometryEvaluator::applyHull2D() during CGAL::convex_hull_2(): %1$s", e.what ());
     }
   }
 #endif // ifdef ENABLE_CGAL
   return geometry;
 }
 
-std::unique_ptr<Polygon2d> GeometryEvaluator::applyFill2D(const AbstractNode& node)
-{
+std::unique_ptr<Polygon2d> GeometryEvaluator::applyFill2D (const AbstractNode &node) {
   // Merge and sanitize input geometry
-  auto geometry_in = ClipperUtils::apply(collectChildren2D(node), Clipper2Lib::ClipType::Union);
-  assert(geometry_in->isSanitized());
+  auto geometry_in = ClipperUtils::apply (collectChildren2D (node), Clipper2Lib::ClipType::Union);
+  assert (geometry_in->isSanitized ());
 
   std::vector<std::shared_ptr<const Polygon2d>> newchildren;
   // Keep only the 'positive' outlines, eg: the outside edges
-  for (const auto& outline : geometry_in->outlines()) {
+  for (const auto &outline : geometry_in->outlines ()) {
     if (outline.positive) {
-      newchildren.push_back(std::make_shared<Polygon2d>(outline));
+      newchildren.push_back (std::make_shared<Polygon2d> (outline));
     }
   }
 
   // Re-merge geometry in case of nested outlines
-  return ClipperUtils::apply(newchildren, Clipper2Lib::ClipType::Union);
+  return ClipperUtils::apply (newchildren, Clipper2Lib::ClipType::Union);
 }
 
-std::unique_ptr<Geometry> GeometryEvaluator::applyHull3D(const AbstractNode& node)
-{
-  Geometry::Geometries children = collectChildren3D(node);
+std::unique_ptr<Geometry> GeometryEvaluator::applyHull3D (const AbstractNode &node) {
+  Geometry::Geometries children = collectChildren3D (node);
 
-  auto P = PolySet::createEmpty();
-  return applyHull(children);
+  auto P = PolySet::createEmpty ();
+  return applyHull (children);
 }
 
-std::unique_ptr<Polygon2d> GeometryEvaluator::applyMinkowski2D(const AbstractNode& node)
-{
-  auto children = collectChildren2D(node);
-  if (!children.empty()) {
-    return ClipperUtils::applyMinkowski(children);
+std::unique_ptr<Polygon2d> GeometryEvaluator::applyMinkowski2D (const AbstractNode &node) {
+  auto children = collectChildren2D (node);
+  if (!children.empty ()) {
+    return ClipperUtils::applyMinkowski (children);
   }
   return nullptr;
 }
@@ -275,35 +276,35 @@ std::unique_ptr<Polygon2d> GeometryEvaluator::applyMinkowski2D(const AbstractNod
    Returns a list of Polygon2d children of the given node.
    May return empty Polygon2d object, but not nullptr objects
  */
-std::vector<std::shared_ptr<const Polygon2d>> GeometryEvaluator::collectChildren2D(const AbstractNode& node)
-{
+std::vector<std::shared_ptr<const Polygon2d>> GeometryEvaluator::collectChildren2D (const AbstractNode &node) {
   std::vector<std::shared_ptr<const Polygon2d>> children;
-  for (const auto& item : this->visitedchildren[node.index()]) {
-    auto& chnode = item.first;
-    auto& chgeom = item.second;
-    if (chnode->modinst->isBackground()) continue;
+  for (const auto &item : this->visitedchildren[node.index ()]) {
+    auto &chnode = item.first;
+    auto &chgeom = item.second;
+    if (chnode->modinst->isBackground ())
+      continue;
 
     // NB! We insert into the cache here to ensure that all children of
     // a node is a valid object. If we inserted as we created them, the
     // cache could have been modified before we reach this point due to a large
     // sibling object.
-    smartCacheInsert(*chnode, chgeom);
+    smartCacheInsert (*chnode, chgeom);
 
     if (chgeom) {
-      if (chgeom->getDimension() == 3) {
-        LOG(message_group::Warning, item.first->modinst->location(), this->tree.getDocumentPath(), "Ignoring 3D child object for 2D operation");
-        children.push_back(nullptr); // replace 3D geometry with empty geometry
+      if (chgeom->getDimension () == 3) {
+        LOG (message_group::Warning, item.first->modinst->location (), this->tree.getDocumentPath (), "Ignoring 3D child object for 2D operation");
+        children.push_back (nullptr); // replace 3D geometry with empty geometry
       } else {
-        if (chgeom->isEmpty()) {
-          children.push_back(nullptr);
+        if (chgeom->isEmpty ()) {
+          children.push_back (nullptr);
         } else {
-          const auto polygon2d = std::dynamic_pointer_cast<const Polygon2d>(chgeom);
-          assert(polygon2d);
-          children.push_back(polygon2d);
+          const auto polygon2d = std::dynamic_pointer_cast<const Polygon2d> (chgeom);
+          assert (polygon2d);
+          children.push_back (polygon2d);
         }
       }
     } else {
-      children.push_back(nullptr);
+      children.push_back (nullptr);
     }
   }
   return children;
@@ -314,41 +315,40 @@ std::vector<std::shared_ptr<const Polygon2d>> GeometryEvaluator::collectChildren
    the appropriate cache.
    This method inserts the geometry into the appropriate cache if it's not already cached.
  */
-void GeometryEvaluator::smartCacheInsert(const AbstractNode& node,
-                                         const std::shared_ptr<const Geometry>& geom)
-{
-  const std::string& key = this->tree.getIdString(node);
-
-  if (CGALCache::acceptsGeometry(geom)) {
-    if (!CGALCache::instance()->contains(key)) {
-      CGALCache::instance()->insert(key, geom);
+void GeometryEvaluator::smartCacheInsert (const AbstractNode &node,
+                                          const std::shared_ptr<const Geometry> &geom) {
+  const std::string &key = this->tree.getIdString (node);
+
+  if (CGALCache::acceptsGeometry (geom)) {
+    if (!CGALCache::instance ()->contains (key)) {
+      CGALCache::instance ()->insert (key, geom);
     }
-  } else if (!GeometryCache::instance()->contains(key)) {
+  } else if (!GeometryCache::instance ()->contains (key)) {
     // FIXME: Sanity-check Polygon2d as well?
     // if (const auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
     //   assert(!ps->hasDegeneratePolygons());
     // }
 
     // Perhaps add acceptsGeometry() to GeometryCache as well?
-    if (!GeometryCache::instance()->insert(key, geom)) {
-      LOG(message_group::Warning, "GeometryEvaluator: Node didn't fit into cache.");
+    if (!GeometryCache::instance ()->insert (key, geom)) {
+      LOG (message_group::Warning, "GeometryEvaluator: Node didn't fit into cache.");
     }
   }
 }
 
-bool GeometryEvaluator::isSmartCached(const AbstractNode& node)
-{
-  const std::string& key = this->tree.getIdString(node);
-  return GeometryCache::instance()->contains(key) || CGALCache::instance()->contains(key);
+bool GeometryEvaluator::isSmartCached (const AbstractNode &node) {
+  const std::string &key = this->tree.getIdString (node);
+  return GeometryCache::instance ()->contains (key) || CGALCache::instance ()->contains (key);
 }
 
-std::shared_ptr<const Geometry> GeometryEvaluator::smartCacheGet(const AbstractNode& node, bool preferNef)
-{
-  const std::string& key = this->tree.getIdString(node);
-  const bool hasgeom = GeometryCache::instance()->contains(key);
-  const bool hascgal = CGALCache::instance()->contains(key);
-  if (hascgal && (preferNef || !hasgeom)) return CGALCache::instance()->get(key);
-  if (hasgeom) return GeometryCache::instance()->get(key);
+std::shared_ptr<const Geometry> GeometryEvaluator::smartCacheGet (const AbstractNode &node, bool preferNef) {
+  const std::string &key = this->tree.getIdString (node);
+  const bool hasgeom = GeometryCache::instance ()->contains (key);
+  const bool hascgal = CGALCache::instance ()->contains (key);
+  if (hascgal && (preferNef || !hasgeom))
+    return CGALCache::instance ()->get (key);
+  if (hasgeom)
+    return GeometryCache::instance ()->get (key);
   return {};
 }
 
@@ -356,26 +356,26 @@ std::shared_ptr<const Geometry> GeometryEvaluator::smartCacheGet(const AbstractN
    Returns a list of 3D Geometry children of the given node.
    May return empty geometries, but not nullptr objects
  */
-Geometry::Geometries GeometryEvaluator::collectChildren3D(const AbstractNode& node)
-{
+Geometry::Geometries GeometryEvaluator::collectChildren3D (const AbstractNode &node) {
   Geometry::Geometries children;
-  for (const auto& item : this->visitedchildren[node.index()]) {
-    auto& chnode = item.first;
-    const std::shared_ptr<const Geometry>& chgeom = item.second;
-    if (chnode->modinst->isBackground()) continue;
+  for (const auto &item : this->visitedchildren[node.index ()]) {
+    auto &chnode = item.first;
+    const std::shared_ptr<const Geometry> &chgeom = item.second;
+    if (chnode->modinst->isBackground ())
+      continue;
 
     // NB! We insert into the cache here to ensure that all children of
     // a node is a valid object. If we inserted as we created them, the
     // cache could have been modified before we reach this point due to a large
     // sibling object.
-    smartCacheInsert(*chnode, chgeom);
+    smartCacheInsert (*chnode, chgeom);
 
-    if (chgeom && chgeom->getDimension() == 2) {
-      LOG(message_group::Warning, item.first->modinst->location(), this->tree.getDocumentPath(), "Ignoring 2D child object for 3D operation");
-      children.push_back(std::make_pair(item.first, nullptr)); // replace 2D geometry with empty geometry
+    if (chgeom && chgeom->getDimension () == 2) {
+      LOG (message_group::Warning, item.first->modinst->location (), this->tree.getDocumentPath (), "Ignoring 2D child object for 3D operation");
+      children.push_back (std::make_pair (item.first, nullptr)); // replace 2D geometry with empty geometry
     } else {
       // Add children if geometry is 3D OR null/empty
-      children.push_back(item);
+      children.push_back (item);
     }
   }
   return children;
@@ -384,26 +384,25 @@ Geometry::Geometries GeometryEvaluator::collectChildren3D(const AbstractNode& no
 /*!
 
  */
-std::unique_ptr<Polygon2d> GeometryEvaluator::applyToChildren2D(const AbstractNode& node, OpenSCADOperator op)
-{
-  node.progress_report();
+std::unique_ptr<Polygon2d> GeometryEvaluator::applyToChildren2D (const AbstractNode &node, OpenSCADOperator op) {
+  node.progress_report ();
   if (op == OpenSCADOperator::MINKOWSKI) {
-    return applyMinkowski2D(node);
+    return applyMinkowski2D (node);
   } else if (op == OpenSCADOperator::HULL) {
-    return applyHull2D(node);
+    return applyHull2D (node);
   } else if (op == OpenSCADOperator::FILL) {
-    return applyFill2D(node);
+    return applyFill2D (node);
   }
 
-  auto children = collectChildren2D(node);
+  auto children = collectChildren2D (node);
 
-  if (children.empty()) {
+  if (children.empty ()) {
     return nullptr;
   }
 
-  if (children.size() == 1) {
+  if (children.size () == 1) {
     if (children[0]) {
-      return std::make_unique<Polygon2d>(*children[0]); // Copy
+      return std::make_unique<Polygon2d> (*children[0]); // Copy
     } else {
       return nullptr;
     }
@@ -421,12 +420,12 @@ std::unique_ptr<Polygon2d> GeometryEvaluator::applyToChildren2D(const AbstractNo
     clipType = Clipper2Lib::ClipType::Difference;
     break;
   default:
-    LOG(message_group::Error, "Unknown boolean operation %1$d", int(op));
+    LOG (message_group::Error, "Unknown boolean operation %1$d", int (op));
     return nullptr;
     break;
   }
 
-  return ClipperUtils::apply(children, clipType);
+  return ClipperUtils::apply (children, clipType);
 }
 
 /*!
@@ -438,38 +437,38 @@ std::unique_ptr<Polygon2d> GeometryEvaluator::applyToChildren2D(const AbstractNo
 
    The added geometry can be nullptr if it wasn't possible to evaluate it.
  */
-void GeometryEvaluator::addToParent(const State& state,
-                                    const AbstractNode& node,
-                                    const std::shared_ptr<const Geometry>& geom)
-{
-  this->visitedchildren.erase(node.index());
-  if (state.parent()) {
-    this->visitedchildren[state.parent()->index()].push_back(std::make_pair(node.shared_from_this(), geom));
+void GeometryEvaluator::addToParent (const State &state,
+                                     const AbstractNode &node,
+                                     const std::shared_ptr<const Geometry> &geom) {
+  this->visitedchildren.erase (node.index ());
+  if (state.parent ()) {
+    this->visitedchildren[state.parent ()->index ()].push_back (std::make_pair (node.shared_from_this (), geom));
   } else {
     // Root node
     this->root = geom;
-    assert(this->visitedchildren.empty());
+    assert (this->visitedchildren.empty ());
   }
 }
 
-Response GeometryEvaluator::visit(State& state, const ColorNode& node)
-{
-  if (state.isPrefix() && isSmartCached(node)) return Response::PruneTraversal;
-  if (state.isPostfix()) {
+Response GeometryEvaluator::visit (State &state, const ColorNode &node) {
+  if (state.isPrefix () && isSmartCached (node))
+    return Response::PruneTraversal;
+  if (state.isPostfix ()) {
     std::shared_ptr<const Geometry> geom;
-    if (!isSmartCached(node)) {
+    if (!isSmartCached (node)) {
       // First union all children
-      ResultObject res = applyToChildren(node, OpenSCADOperator::UNION);
-      if ((geom = res.constptr())) {
-        auto mutableGeom = res.asMutableGeometry();
-        if (mutableGeom) mutableGeom->setColor(node.color);
+      ResultObject res = applyToChildren (node, OpenSCADOperator::UNION);
+      if ((geom = res.constptr ())) {
+        auto mutableGeom = res.asMutableGeometry ();
+        if (mutableGeom)
+          mutableGeom->setColor (node.color);
         geom = mutableGeom;
       }
     } else {
-      geom = smartCacheGet(node, state.preferNef());
+      geom = smartCacheGet (node, state.preferNef ());
     }
-    addToParent(state, node, geom);
-    node.progress_report();
+    addToParent (state, node, geom);
+    node.progress_report ();
   }
   return Response::ContinueTraversal;
 }
@@ -477,21 +476,21 @@ Response GeometryEvaluator::visit(State& state, const ColorNode& node)
 /*!
    Custom nodes are handled here => implicit union
  */
-Response GeometryEvaluator::visit(State& state, const AbstractNode& node)
-{
-  if (state.isPrefix()) {
-    if (isSmartCached(node)) return Response::PruneTraversal;
-    state.setPreferNef(true); // Improve quality of CSG by avoiding conversion loss
+Response GeometryEvaluator::visit (State &state, const AbstractNode &node) {
+  if (state.isPrefix ()) {
+    if (isSmartCached (node))
+      return Response::PruneTraversal;
+    state.setPreferNef (true); // Improve quality of CSG by avoiding conversion loss
   }
-  if (state.isPostfix()) {
+  if (state.isPostfix ()) {
     std::shared_ptr<const Geometry> geom;
-    if (!isSmartCached(node)) {
-      geom = applyToChildren(node, OpenSCADOperator::UNION).constptr();
+    if (!isSmartCached (node)) {
+      geom = applyToChildren (node, OpenSCADOperator::UNION).constptr ();
     } else {
-      geom = smartCacheGet(node, state.preferNef());
+      geom = smartCacheGet (node, state.preferNef ());
     }
-    addToParent(state, node, geom);
-    node.progress_report();
+    addToParent (state, node, geom);
+    node.progress_report ();
   }
   return Response::ContinueTraversal;
 }
@@ -499,67 +498,72 @@ Response GeometryEvaluator::visit(State& state, const AbstractNode& node)
 /*!
    Pass children to parent without touching them. Used by e.g. for loops
  */
-Response GeometryEvaluator::visit(State& state, const ListNode& node)
-{
-  if (state.parent()) {
-    if (state.isPrefix() && node.modinst->isBackground()) {
-      if (node.modinst->isBackground()) state.setBackground(true);
+Response GeometryEvaluator::visit (State &state, const ListNode &node) {
+  if (state.parent ()) {
+    if (state.isPrefix () && node.modinst->isBackground ()) {
+      if (node.modinst->isBackground ())
+        state.setBackground (true);
       return Response::PruneTraversal;
     }
-    if (state.isPostfix()) {
+    if (state.isPostfix ()) {
       unsigned int dim = 0;
-      for (const auto& item : this->visitedchildren[node.index()]) {
-        if (!isValidDim(item, dim)) break;
-        auto& chnode = item.first;
-        const std::shared_ptr<const Geometry>& chgeom = item.second;
-        addToParent(state, *chnode, chgeom);
+      for (const auto &item : this->visitedchildren[node.index ()]) {
+        if (!isValidDim (item, dim))
+          break;
+        auto &chnode = item.first;
+        const std::shared_ptr<const Geometry> &chgeom = item.second;
+        addToParent (state, *chnode, chgeom);
       }
-      this->visitedchildren.erase(node.index());
+      this->visitedchildren.erase (node.index ());
     }
     return Response::ContinueTraversal;
   } else {
     // Handle when a ListNode is given root modifier
-    return lazyEvaluateRootNode(state, node);
+    return lazyEvaluateRootNode (state, node);
   }
 }
 
 /*!
  */
-Response GeometryEvaluator::visit(State& state, const GroupNode& node)
-{
-  return visit(state, (const AbstractNode&)node);
+Response GeometryEvaluator::visit (State &state, const GroupNode &node) {
+  return visit (state, (const AbstractNode &)node);
 }
 
-Response GeometryEvaluator::lazyEvaluateRootNode(State& state, const AbstractNode& node) {
-  if (state.isPrefix()) {
-    if (node.modinst->isBackground()) {
-      state.setBackground(true);
+Response GeometryEvaluator::lazyEvaluateRootNode (State &state, const AbstractNode &node) {
+  if (state.isPrefix ()) {
+    if (node.modinst->isBackground ()) {
+      state.setBackground (true);
       return Response::PruneTraversal;
     }
-    if (isSmartCached(node)) {
+    if (isSmartCached (node)) {
       return Response::PruneTraversal;
     }
   }
-  if (state.isPostfix()) {
+  if (state.isPostfix ()) {
     std::shared_ptr<const Geometry> geom;
 
     unsigned int dim = 0;
     GeometryList::Geometries geometries;
-    for (const auto& item : this->visitedchildren[node.index()]) {
-      if (!isValidDim(item, dim)) break;
-      auto& chnode = item.first;
-      const std::shared_ptr<const Geometry>& chgeom = item.second;
-      if (chnode->modinst->isBackground()) continue;
+    for (const auto &item : this->visitedchildren[node.index ()]) {
+      if (!isValidDim (item, dim))
+        break;
+      auto &chnode = item.first;
+      const std::shared_ptr<const Geometry> &chgeom = item.second;
+      if (chnode->modinst->isBackground ())
+        continue;
       // NB! We insert into the cache here to ensure that all children of
       // a node is a valid object. If we inserted as we created them, the
       // cache could have been modified before we reach this point due to a large
       // sibling object.
-      smartCacheInsert(*chnode, chgeom);
+      smartCacheInsert (*chnode, chgeom);
       // Only use valid geometries
-      if (chgeom && !chgeom->isEmpty()) geometries.push_back(item);
+      if (chgeom && !chgeom->isEmpty ())
+        geometries.push_back (item);
     }
-    if (geometries.size() == 1) geom = geometries.front().second;
-    else if (geometries.size() > 1) geom = std::make_shared<GeometryList>(geometries);
+    if (geometries.size () == 1)
+      geom = geometries.front ().second;
+    else if (geometries.size () > 1)
+      geom = std::make_shared<GeometryList> (geometries);
 
     this->root = geom;
   }
@@ -573,34 +577,33 @@ Response GeometryEvaluator::lazyEvaluateRootNode(State& state, const AbstractNod
    NB! This is likely a temporary measure until a better implementation of
    group nodes is in place.
  */
-Response GeometryEvaluator::visit(State& state, const RootNode& node)
-{
+Response GeometryEvaluator::visit (State &state, const RootNode &node) {
   // If we didn't enable lazy unions, just union the top-level objects
-  if (!Feature::ExperimentalLazyUnion.is_enabled()) {
-    return visit(state, (const GroupNode&)node);
+  if (!Feature::ExperimentalLazyUnion.is_enabled ()) {
+    return visit (state, (const GroupNode &)node);
   }
-  return lazyEvaluateRootNode(state, node);
+  return lazyEvaluateRootNode (state, node);
 }
 
-Response GeometryEvaluator::visit(State& state, const OffsetNode& node)
-{
-  if (state.isPrefix() && isSmartCached(node)) return Response::PruneTraversal;
-  if (state.isPostfix()) {
+Response GeometryEvaluator::visit (State &state, const OffsetNode &node) {
+  if (state.isPrefix () && isSmartCached (node))
+    return Response::PruneTraversal;
+  if (state.isPostfix ()) {
     std::shared_ptr<const Geometry> geom;
-    if (!isSmartCached(node)) {
-      if (const auto polygon = applyToChildren2D(node, OpenSCADOperator::UNION)) {
+    if (!isSmartCached (node)) {
+      if (const auto polygon = applyToChildren2D (node, OpenSCADOperator::UNION)) {
         // ClipperLib documentation: The formula for the number of steps in a full
         // circular arc is ... Pi / acos(1 - arc_tolerance / abs(delta))
-        double n = Calc::get_fragments_from_r(std::abs(node.delta), node.fn, node.fs, node.fa);
-        double arc_tolerance = std::abs(node.delta) * (1 - cos_degrees(180 / n));
-        geom = ClipperUtils::applyOffset(*polygon, node.delta, node.join_type, node.miter_limit, arc_tolerance);
-        assert(geom);
+        double n = Calc::get_fragments_from_r (std::abs (node.delta), node.fn, node.fs, node.fa);
+        double arc_tolerance = std::abs (node.delta) * (1 - cos_degrees (180 / n));
+        geom = ClipperUtils::applyOffset (*polygon, node.delta, node.join_type, node.miter_limit, arc_tolerance);
+        assert (geom);
       }
     } else {
-      geom = smartCacheGet(node, false);
+      geom = smartCacheGet (node, false);
     }
-    addToParent(state, node, geom);
-    node.progress_report();
+    addToParent (state, node, geom);
+    node.progress_report ();
   }
   return Response::ContinueTraversal;
 }
@@ -608,24 +611,25 @@ Response GeometryEvaluator::visit(State& state, const OffsetNode& node)
 /*!
    RenderNodes just pass on convexity
  */
-Response GeometryEvaluator::visit(State& state, const RenderNode& node)
-{
-  if (state.isPrefix()) {
-    if (isSmartCached(node)) return Response::PruneTraversal;
-    state.setPreferNef(true); // Improve quality of CSG by avoiding conversion loss
+Response GeometryEvaluator::visit (State &state, const RenderNode &node) {
+  if (state.isPrefix ()) {
+    if (isSmartCached (node))
+      return Response::PruneTraversal;
+    state.setPreferNef (true); // Improve quality of CSG by avoiding conversion loss
   }
-  if (state.isPostfix()) {
+  if (state.isPostfix ()) {
     std::shared_ptr<const Geometry> geom;
-    if (!isSmartCached(node)) {
-      ResultObject res = applyToChildren(node, OpenSCADOperator::UNION);
-      auto mutableGeom = res.asMutableGeometry();
-      if (mutableGeom) mutableGeom->setConvexity(node.convexity);
+    if (!isSmartCached (node)) {
+      ResultObject res = applyToChildren (node, OpenSCADOperator::UNION);
+      auto mutableGeom = res.asMutableGeometry ();
+      if (mutableGeom)
+        mutableGeom->setConvexity (node.convexity);
       geom = mutableGeom;
     } else {
-      geom = smartCacheGet(node, state.preferNef());
+      geom = smartCacheGet (node, state.preferNef ());
     }
-    node.progress_report();
-    addToParent(state, node, geom);
+    node.progress_report ();
+    addToParent (state, node, geom);
   }
   return Response::ContinueTraversal;
 }
@@ -636,67 +640,64 @@ Response GeometryEvaluator::visit(State& state, const RenderNode& node)
    input: None
    output: PolySet or Polygon2d
  */
-Response GeometryEvaluator::visit(State& state, const LeafNode& node)
-{
-  if (state.isPrefix()) {
+Response GeometryEvaluator::visit (State &state, const LeafNode &node) {
+  if (state.isPrefix ()) {
     std::shared_ptr<const Geometry> geom;
-    if (!isSmartCached(node)) {
-      geom = node.createGeometry();
-      assert(geom);
-      if (const auto polygon = std::dynamic_pointer_cast<const Polygon2d>(geom)) {
-        if (!polygon->isSanitized()) {
-          geom = ClipperUtils::sanitize(*polygon);
+    if (!isSmartCached (node)) {
+      geom = node.createGeometry ();
+      assert (geom);
+      if (const auto polygon = std::dynamic_pointer_cast<const Polygon2d> (geom)) {
+        if (!polygon->isSanitized ()) {
+          geom = ClipperUtils::sanitize (*polygon);
         }
-      } else if (const auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
-//        assert(!ps->hasDegeneratePolygons());
+      } else if (const auto ps = std::dynamic_pointer_cast<const PolySet> (geom)) {
+        //        assert(!ps->hasDegeneratePolygons());
       }
     } else {
-      geom = smartCacheGet(node, state.preferNef());
+      geom = smartCacheGet (node, state.preferNef ());
     }
-    addToParent(state, node, geom);
-    node.progress_report();
+    addToParent (state, node, geom);
+    node.progress_report ();
   }
   return Response::PruneTraversal;
 }
 
-Response GeometryEvaluator::visit(State& state, const TextNode& node)
-{
-  if (state.isPrefix()) {
+Response GeometryEvaluator::visit (State &state, const TextNode &node) {
+  if (state.isPrefix ()) {
     std::shared_ptr<const Geometry> geom;
-    if (!isSmartCached(node)) {
-      auto polygonlist = node.createPolygonList();
-      geom = ClipperUtils::apply(polygonlist, Clipper2Lib::ClipType::Union);
+    if (!isSmartCached (node)) {
+      auto polygonlist = node.createPolygonList ();
+      geom = ClipperUtils::apply (polygonlist, Clipper2Lib::ClipType::Union);
     } else {
-      geom = GeometryCache::instance()->get(this->tree.getIdString(node));
+      geom = GeometryCache::instance ()->get (this->tree.getIdString (node));
     }
-    addToParent(state, node, geom);
-    node.progress_report();
+    addToParent (state, node, geom);
+    node.progress_report ();
   }
   return Response::PruneTraversal;
 }
 
-
 /*!
    input: List of 2D or 3D objects (not mixed)
    output: Polygon2d or 3D PolySet
    operation:
     o Perform csg op on children
  */
-Response GeometryEvaluator::visit(State& state, const CsgOpNode& node)
-{
-  if (state.isPrefix()) {
-    if (isSmartCached(node)) return Response::PruneTraversal;
-    state.setPreferNef(true); // Improve quality of CSG by avoiding conversion loss
+Response GeometryEvaluator::visit (State &state, const CsgOpNode &node) {
+  if (state.isPrefix ()) {
+    if (isSmartCached (node))
+      return Response::PruneTraversal;
+    state.setPreferNef (true); // Improve quality of CSG by avoiding conversion loss
   }
-  if (state.isPostfix()) {
+  if (state.isPostfix ()) {
     std::shared_ptr<const Geometry> geom;
-    if (!isSmartCached(node)) {
-      geom = applyToChildren(node, node.type).constptr();
+    if (!isSmartCached (node)) {
+      geom = applyToChildren (node, node.type).constptr ();
     } else {
-      geom = smartCacheGet(node, state.preferNef());
+      geom = smartCacheGet (node, state.preferNef ());
     }
-    addToParent(state, node, geom);
-    node.progress_report();
+    addToParent (state, node, geom);
+    node.progress_report ();
   }
   return Response::ContinueTraversal;
 }
@@ -708,48 +709,48 @@ Response GeometryEvaluator::visit(State& state, const CsgOpNode& node)
     o Union all children
     o Perform transform
  */
-Response GeometryEvaluator::visit(State& state, const TransformNode& node)
-{
-  if (state.isPrefix() && isSmartCached(node)) return Response::PruneTraversal;
-  if (state.isPostfix()) {
+Response GeometryEvaluator::visit (State &state, const TransformNode &node) {
+  if (state.isPrefix () && isSmartCached (node))
+    return Response::PruneTraversal;
+  if (state.isPostfix ()) {
     std::shared_ptr<const Geometry> geom;
-    if (!isSmartCached(node)) {
-      if (matrix_contains_infinity(node.matrix) || matrix_contains_nan(node.matrix)) {
+    if (!isSmartCached (node)) {
+      if (matrix_contains_infinity (node.matrix) || matrix_contains_nan (node.matrix)) {
         // due to the way parse/eval works we can't currently distinguish between NaN and Inf
-        LOG(message_group::Warning, node.modinst->location(), this->tree.getDocumentPath(), "Transformation matrix contains Not-a-Number and/or Infinity - removing object.");
+        LOG (message_group::Warning, node.modinst->location (), this->tree.getDocumentPath (), "Transformation matrix contains Not-a-Number and/or Infinity - removing object.");
       } else {
         // First union all children
-        ResultObject res = applyToChildren(node, OpenSCADOperator::UNION);
-        if ((geom = res.constptr())) {
-          if (geom->getDimension() == 2) {
-            auto polygons = std::dynamic_pointer_cast<Polygon2d>(res.asMutableGeometry());
-            assert(polygons);
+        ResultObject res = applyToChildren (node, OpenSCADOperator::UNION);
+        if ((geom = res.constptr ())) {
+          if (geom->getDimension () == 2) {
+            auto polygons = std::dynamic_pointer_cast<Polygon2d> (res.asMutableGeometry ());
+            assert (polygons);
 
             Transform2d mat2;
-            mat2.matrix() <<
-              node.matrix(0, 0), node.matrix(0, 1), node.matrix(0, 3),
-              node.matrix(1, 0), node.matrix(1, 1), node.matrix(1, 3),
-              node.matrix(3, 0), node.matrix(3, 1), node.matrix(3, 3);
-            polygons->transform(mat2);
+            mat2.matrix () << node.matrix (0, 0), node.matrix (0, 1), node.matrix (0, 3),
+              node.matrix (1, 0), node.matrix (1, 1), node.matrix (1, 3),
+              node.matrix (3, 0), node.matrix (3, 1), node.matrix (3, 3);
+            polygons->transform (mat2);
             // FIXME: We lose the transform if we copied a const geometry above. Probably similar issue in multiple places
             // A 2D transformation may flip the winding order of a polygon.
             // If that happens with a sanitized polygon, we need to reverse
             // the winding order for it to be correct.
-            if (polygons->isSanitized() && mat2.matrix().determinant() <= 0) {
-              geom = ClipperUtils::sanitize(*polygons);
+            if (polygons->isSanitized () && mat2.matrix ().determinant () <= 0) {
+              geom = ClipperUtils::sanitize (*polygons);
             }
-          } else if (geom->getDimension() == 3) {
-            auto mutableGeom = res.asMutableGeometry();
-            if (mutableGeom) mutableGeom->transform(node.matrix);
+          } else if (geom->getDimension () == 3) {
+            auto mutableGeom = res.asMutableGeometry ();
+            if (mutableGeom)
+              mutableGeom->transform (node.matrix);
             geom = mutableGeom;
           }
         }
       }
     } else {
-      geom = smartCacheGet(node, state.preferNef());
+      geom = smartCacheGet (node, state.preferNef ());
     }
-    addToParent(state, node, geom);
-    node.progress_report();
+    addToParent (state, node, geom);
+    node.progress_report ();
   }
   return Response::ContinueTraversal;
 }
@@ -761,23 +762,23 @@ Response GeometryEvaluator::visit(State& state, const TransformNode& node)
     o Union all children
     o Perform extrude
  */
-Response GeometryEvaluator::visit(State& state, const LinearExtrudeNode& node)
-{
-  if (state.isPrefix() && isSmartCached(node)) return Response::PruneTraversal;
-  if (state.isPostfix()) {
+Response GeometryEvaluator::visit (State &state, const LinearExtrudeNode &node) {
+  if (state.isPrefix () && isSmartCached (node))
+    return Response::PruneTraversal;
+  if (state.isPostfix ()) {
     std::shared_ptr<const Geometry> geom;
-    if (!isSmartCached(node)) {
-      const std::shared_ptr<const Geometry> geometry = applyToChildren2D(node, OpenSCADOperator::UNION);
+    if (!isSmartCached (node)) {
+      const std::shared_ptr<const Geometry> geometry = applyToChildren2D (node, OpenSCADOperator::UNION);
       if (geometry) {
-        const auto polygons = std::dynamic_pointer_cast<const Polygon2d>(geometry);
-        geom = extrudePolygon(node, *polygons);
-        assert(geom);
+        const auto polygons = std::dynamic_pointer_cast<const Polygon2d> (geometry);
+        geom = extrudePolygon (node, *polygons);
+        assert (geom);
       }
     } else {
-      geom = smartCacheGet(node, false);
+      geom = smartCacheGet (node, false);
     }
-    addToParent(state, node, geom);
-    node.progress_report();
+    addToParent (state, node, geom);
+    node.progress_report ();
   }
   return Response::ContinueTraversal;
 }
@@ -789,21 +790,21 @@ Response GeometryEvaluator::visit(State& state, const LinearExtrudeNode& node)
     o Union all children
     o Perform extrude
  */
-Response GeometryEvaluator::visit(State& state, const RotateExtrudeNode& node)
-{
-  if (state.isPrefix() && isSmartCached(node)) return Response::PruneTraversal;
-  if (state.isPostfix()) {
+Response GeometryEvaluator::visit (State &state, const RotateExtrudeNode &node) {
+  if (state.isPrefix () && isSmartCached (node))
+    return Response::PruneTraversal;
+  if (state.isPostfix ()) {
     std::shared_ptr<const Geometry> geom;
-    if (!isSmartCached(node)) {
-      const std::shared_ptr<const Polygon2d> geometry = applyToChildren2D(node, OpenSCADOperator::UNION);
+    if (!isSmartCached (node)) {
+      const std::shared_ptr<const Polygon2d> geometry = applyToChildren2D (node, OpenSCADOperator::UNION);
       if (geometry) {
-        geom = rotatePolygon(node, *geometry);
+        geom = rotatePolygon (node, *geometry);
       }
     } else {
-      geom = smartCacheGet(node, false);
+      geom = smartCacheGet (node, false);
     }
-    addToParent(state, node, geom);
-    node.progress_report();
+    addToParent (state, node, geom);
+    node.progress_report ();
   }
   return Response::ContinueTraversal;
 }
@@ -811,33 +812,31 @@ Response GeometryEvaluator::visit(State& state, const RotateExtrudeNode& node)
 /*!
    FIXME: Not in use
  */
-Response GeometryEvaluator::visit(State& /*state*/, const AbstractPolyNode& /*node*/)
-{
-  assert(false);
+Response GeometryEvaluator::visit (State & /*state*/, const AbstractPolyNode & /*node*/) {
+  assert (false);
   return Response::AbortTraversal;
 }
 
-std::shared_ptr<const Geometry> GeometryEvaluator::projectionCut(const ProjectionNode& node)
-{
+std::shared_ptr<const Geometry> GeometryEvaluator::projectionCut (const ProjectionNode &node) {
   std::shared_ptr<const Geometry> geom;
-  std::shared_ptr<const Geometry> newgeom = applyToChildren3D(node, OpenSCADOperator::UNION).constptr();
+  std::shared_ptr<const Geometry> newgeom = applyToChildren3D (node, OpenSCADOperator::UNION).constptr ();
   if (newgeom) {
 #ifdef ENABLE_MANIFOLD
-    if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
-      auto manifold = ManifoldUtils::createManifoldFromGeometry(newgeom);
+    if (RenderSettings::inst ()->backend3D == RenderBackend3D::ManifoldBackend) {
+      auto manifold = ManifoldUtils::createManifoldFromGeometry (newgeom);
       if (manifold != nullptr) {
-        auto poly2d = manifold->slice();
-        return std::shared_ptr<const Polygon2d>(ClipperUtils::sanitize(poly2d));
+        auto poly2d = manifold->slice ();
+        return std::shared_ptr<const Polygon2d> (ClipperUtils::sanitize (poly2d));
       }
     }
 #endif
 #ifdef ENABLE_CGAL
-    auto Nptr = CGALUtils::getNefPolyhedronFromGeometry(newgeom);
-    if (Nptr && !Nptr->isEmpty()) {
-      auto poly = CGALUtils::project(*Nptr, node.cut_mode);
+    auto Nptr = CGALUtils::getNefPolyhedronFromGeometry (newgeom);
+    if (Nptr && !Nptr->isEmpty ()) {
+      auto poly = CGALUtils::project (*Nptr, node.cut_mode);
       if (poly) {
-        poly->setConvexity(node.convexity);
-        geom = std::move(poly);
+        poly->setConvexity (node.convexity);
+        geom = std::move (poly);
       }
     }
 #endif
@@ -845,42 +844,41 @@ std::shared_ptr<const Geometry> GeometryEvaluator::projectionCut(const Projectio
   return geom;
 }
 
-std::shared_ptr<const Geometry> GeometryEvaluator::projectionNoCut(const ProjectionNode& node)
-{
+std::shared_ptr<const Geometry> GeometryEvaluator::projectionNoCut (const ProjectionNode &node) {
 #ifdef ENABLE_MANIFOLD
-  if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
-    const std::shared_ptr<const Geometry> newgeom = applyToChildren3D(node, OpenSCADOperator::UNION).constptr();
+  if (RenderSettings::inst ()->backend3D == RenderBackend3D::ManifoldBackend) {
+    const std::shared_ptr<const Geometry> newgeom = applyToChildren3D (node, OpenSCADOperator::UNION).constptr ();
     if (newgeom) {
-      auto manifold = ManifoldUtils::createManifoldFromGeometry(newgeom);
+      auto manifold = ManifoldUtils::createManifoldFromGeometry (newgeom);
       if (manifold != nullptr) {
-        auto poly2d = manifold->project();
-        return std::shared_ptr<const Polygon2d>(ClipperUtils::sanitize(poly2d));
+        auto poly2d = manifold->project ();
+        return std::shared_ptr<const Polygon2d> (ClipperUtils::sanitize (poly2d));
       }
     } else {
-      return std::make_shared<Polygon2d>();
+      return std::make_shared<Polygon2d> ();
     }
   }
 #endif // ifdef ENABLE_MANIFOLD
 
   std::vector<std::shared_ptr<const Polygon2d>> tmp_geom;
-  for (const auto& [chnode, chgeom] : this->visitedchildren[node.index()]) {
-    if (chnode->modinst->isBackground()) continue;
+  for (const auto &[chnode, chgeom] : this->visitedchildren[node.index ()]) {
+    if (chnode->modinst->isBackground ())
+      continue;
 
     // Clipper version of Geometry projection
     // Clipper doesn't handle meshes very well.
     // It's better in V6 but not quite there. FIXME: stand-alone example.
     // project chgeom -> polygon2d
-    if (auto chPS = PolySetUtils::getGeometryAsPolySet(chgeom)) {
-      if (auto poly = PolySetUtils::project(*chPS)) {
-        tmp_geom.push_back(std::shared_ptr(std::move(poly)));
+    if (auto chPS = PolySetUtils::getGeometryAsPolySet (chgeom)) {
+      if (auto poly = PolySetUtils::project (*chPS)) {
+        tmp_geom.push_back (std::shared_ptr (std::move (poly)));
       }
     }
   }
-  auto projected = ClipperUtils::applyProjection(tmp_geom);
-  return std::shared_ptr(std::move(projected));
+  auto projected = ClipperUtils::applyProjection (tmp_geom);
+  return std::shared_ptr (std::move (projected));
 }
 
-
 /*!
    input: List of 3D objects
    output: Polygon2d
@@ -888,22 +886,22 @@ std::shared_ptr<const Geometry> GeometryEvaluator::projectionNoCut(const Project
     o Union all children
     o Perform projection
  */
-Response GeometryEvaluator::visit(State& state, const ProjectionNode& node)
-{
-  if (state.isPrefix() && isSmartCached(node)) return Response::PruneTraversal;
-  if (state.isPostfix()) {
+Response GeometryEvaluator::visit (State &state, const ProjectionNode &node) {
+  if (state.isPrefix () && isSmartCached (node))
+    return Response::PruneTraversal;
+  if (state.isPostfix ()) {
     std::shared_ptr<const Geometry> geom;
-    if (isSmartCached(node)) {
-      geom = smartCacheGet(node, false);
+    if (isSmartCached (node)) {
+      geom = smartCacheGet (node, false);
     } else {
       if (node.cut_mode) {
-        geom = projectionCut(node);
+        geom = projectionCut (node);
       } else {
-        geom = projectionNoCut(node);
+        geom = projectionNoCut (node);
       }
     }
-    addToParent(state, node, geom);
-    node.progress_report();
+    addToParent (state, node, geom);
+    node.progress_report ();
   }
   return Response::ContinueTraversal;
 }
@@ -914,114 +912,113 @@ Response GeometryEvaluator::visit(State& state, const ProjectionNode& node)
    operation:
     o Perform cgal operation
  */
-Response GeometryEvaluator::visit(State& state, const CgalAdvNode& node)
-{
-  if (state.isPrefix() && isSmartCached(node)) return Response::PruneTraversal;
-  if (state.isPostfix()) {
+Response GeometryEvaluator::visit (State &state, const CgalAdvNode &node) {
+  if (state.isPrefix () && isSmartCached (node))
+    return Response::PruneTraversal;
+  if (state.isPostfix ()) {
     std::shared_ptr<const Geometry> geom;
-    if (!isSmartCached(node)) {
+    if (!isSmartCached (node)) {
       switch (node.type) {
       case CgalAdvType::MINKOWSKI: {
-        ResultObject res = applyToChildren(node, OpenSCADOperator::MINKOWSKI);
-        geom = res.constptr();
+        ResultObject res = applyToChildren (node, OpenSCADOperator::MINKOWSKI);
+        geom = res.constptr ();
         // If we added convexity, we need to pass it on
-        if (geom && geom->getConvexity() != node.convexity) {
-          auto editablegeom = res.asMutableGeometry();
-          editablegeom->setConvexity(node.convexity);
+        if (geom && geom->getConvexity () != node.convexity) {
+          auto editablegeom = res.asMutableGeometry ();
+          editablegeom->setConvexity (node.convexity);
           geom = editablegeom;
         }
         break;
       }
       case CgalAdvType::HULL: {
-        geom = applyToChildren(node, OpenSCADOperator::HULL).constptr();
+        geom = applyToChildren (node, OpenSCADOperator::HULL).constptr ();
         break;
       }
       case CgalAdvType::FILL: {
-        geom = applyToChildren(node, OpenSCADOperator::FILL).constptr();
+        geom = applyToChildren (node, OpenSCADOperator::FILL).constptr ();
         break;
       }
       case CgalAdvType::RESIZE: {
-        ResultObject res = applyToChildren(node, OpenSCADOperator::UNION);
-        auto editablegeom = res.asMutableGeometry();
+        ResultObject res = applyToChildren (node, OpenSCADOperator::UNION);
+        auto editablegeom = res.asMutableGeometry ();
         geom = editablegeom;
         if (editablegeom) {
-          editablegeom->setConvexity(node.convexity);
-          editablegeom->resize(node.newsize, node.autosize);
+          editablegeom->setConvexity (node.convexity);
+          editablegeom->resize (node.newsize, node.autosize);
         }
         break;
       }
       default:
-        assert(false && "not implemented");
+        assert (false && "not implemented");
       }
     } else {
-      geom = smartCacheGet(node, state.preferNef());
+      geom = smartCacheGet (node, state.preferNef ());
     }
-    addToParent(state, node, geom);
-    node.progress_report();
+    addToParent (state, node, geom);
+    node.progress_report ();
   }
   return Response::ContinueTraversal;
 }
 
-Response GeometryEvaluator::visit(State& state, const AbstractIntersectionNode& node)
-{
-  if (state.isPrefix()) {
-    if (isSmartCached(node)) return Response::PruneTraversal;
-    state.setPreferNef(true); // Improve quality of CSG by avoiding conversion loss
+Response GeometryEvaluator::visit (State &state, const AbstractIntersectionNode &node) {
+  if (state.isPrefix ()) {
+    if (isSmartCached (node))
+      return Response::PruneTraversal;
+    state.setPreferNef (true); // Improve quality of CSG by avoiding conversion loss
   }
-  if (state.isPostfix()) {
+  if (state.isPostfix ()) {
     std::shared_ptr<const Geometry> geom;
-    if (!isSmartCached(node)) {
-      geom = applyToChildren(node, OpenSCADOperator::INTERSECTION).constptr();
+    if (!isSmartCached (node)) {
+      geom = applyToChildren (node, OpenSCADOperator::INTERSECTION).constptr ();
     } else {
-      geom = smartCacheGet(node, state.preferNef());
+      geom = smartCacheGet (node, state.preferNef ());
     }
-    addToParent(state, node, geom);
-    node.progress_report();
+    addToParent (state, node, geom);
+    node.progress_report ();
   }
   return Response::ContinueTraversal;
 }
 
 #if defined(ENABLE_EXPERIMENTAL) && defined(ENABLE_CGAL)
 // FIXME: What is the convex/manifold situation of the resulting PolySet?
-static std::unique_ptr<Geometry> roofOverPolygon(const RoofNode& node, const Polygon2d& poly)
-{
+static std::unique_ptr<Geometry> roofOverPolygon (const RoofNode &node, const Polygon2d &poly) {
   std::unique_ptr<PolySet> roof;
   if (node.method == "voronoi") {
-    roof = roof_vd::voronoi_diagram_roof(poly, node.fa, node.fs);
-    roof->setConvexity(node.convexity);
+    roof = roof_vd::voronoi_diagram_roof (poly, node.fa, node.fs);
+    roof->setConvexity (node.convexity);
   } else if (node.method == "straight") {
-    roof = roof_ss::straight_skeleton_roof(poly);
-    roof->setConvexity(node.convexity);
+    roof = roof_ss::straight_skeleton_roof (poly);
+    roof->setConvexity (node.convexity);
   } else {
-    assert(false && "Invalid roof method");
+    assert (false && "Invalid roof method");
   }
 
   return roof;
 }
 
-Response GeometryEvaluator::visit(State& state, const RoofNode& node)
-{
-  if (state.isPrefix() && isSmartCached(node)) return Response::PruneTraversal;
-  if (state.isPostfix()) {
+Response GeometryEvaluator::visit (State &state, const RoofNode &node) {
+  if (state.isPrefix () && isSmartCached (node))
+    return Response::PruneTraversal;
+  if (state.isPostfix ()) {
     std::shared_ptr<const Geometry> geom;
-    if (!isSmartCached(node)) {
-      const auto polygon2d = applyToChildren2D(node, OpenSCADOperator::UNION);
+    if (!isSmartCached (node)) {
+      const auto polygon2d = applyToChildren2D (node, OpenSCADOperator::UNION);
       if (polygon2d) {
         std::unique_ptr<Geometry> roof;
         try {
-          roof = roofOverPolygon(node, *polygon2d);
-        } catch (RoofNode::roof_exception& e) {
-          LOG(message_group::Error, node.modinst->location(), this->tree.getDocumentPath(),
-              "Skeleton computation error. " + e.message());
-          roof = PolySet::createEmpty();
+          roof = roofOverPolygon (node, *polygon2d);
+        } catch (RoofNode::roof_exception &e) {
+          LOG (message_group::Error, node.modinst->location (), this->tree.getDocumentPath (),
+               "Skeleton computation error. " + e.message ());
+          roof = PolySet::createEmpty ();
         }
-        assert(roof);
-        geom = std::move(roof);
+        assert (roof);
+        geom = std::move (roof);
       }
     } else {
-      geom = smartCacheGet(node, false);
+      geom = smartCacheGet (node, false);
     }
-    addToParent(state, node, geom);
+    addToParent (state, node, geom);
   }
   return Response::ContinueTraversal;
 }
diff --git a/src/geometry/GeometryEvaluator.h b/src/geometry/GeometryEvaluator.h
index 1b72de0d1..b0621455b 100644
--- a/src/geometry/GeometryEvaluator.h
+++ b/src/geometry/GeometryEvaluator.h
@@ -21,88 +21,109 @@ class Tree;
 class GeometryEvaluator : public NodeVisitor
 {
 public:
-  GeometryEvaluator(const Tree& tree);
+  GeometryEvaluator (const Tree &tree);
 
-  std::shared_ptr<const Geometry> evaluateGeometry(const AbstractNode& node, bool allownef);
+  std::shared_ptr<const Geometry> evaluateGeometry (const AbstractNode &node, bool allownef);
 
-  Response visit(State& state, const AbstractNode& node) override;
-  Response visit(State& state, const ColorNode& node) override;
-  Response visit(State& state, const AbstractIntersectionNode& node) override;
-  Response visit(State& state, const AbstractPolyNode& node) override;
-  Response visit(State& state, const LinearExtrudeNode& node) override;
-  Response visit(State& state, const RotateExtrudeNode& node) override;
+  Response visit (State &state, const AbstractNode &node) override;
+  Response visit (State &state, const ColorNode &node) override;
+  Response visit (State &state, const AbstractIntersectionNode &node) override;
+  Response visit (State &state, const AbstractPolyNode &node) override;
+  Response visit (State &state, const LinearExtrudeNode &node) override;
+  Response visit (State &state, const RotateExtrudeNode &node) override;
 #if defined(ENABLE_EXPERIMENTAL) && defined(ENABLE_CGAL)
-  Response visit(State& state, const RoofNode& node) override;
+  Response visit (State &state, const RoofNode &node) override;
 #endif
-  Response visit(State& state, const ListNode& node) override;
-  Response visit(State& state, const GroupNode& node) override;
-  Response visit(State& state, const RootNode& node) override;
-  Response visit(State& state, const LeafNode& node) override;
-  Response visit(State& state, const TransformNode& node) override;
-  Response visit(State& state, const CsgOpNode& node) override;
-  Response visit(State& state, const CgalAdvNode& node) override;
-  Response visit(State& state, const ProjectionNode& node) override;
-  Response visit(State& state, const RenderNode& node) override;
-  Response visit(State& state, const TextNode& node) override;
-  Response visit(State& state, const OffsetNode& node) override;
+  Response visit (State &state, const ListNode &node) override;
+  Response visit (State &state, const GroupNode &node) override;
+  Response visit (State &state, const RootNode &node) override;
+  Response visit (State &state, const LeafNode &node) override;
+  Response visit (State &state, const TransformNode &node) override;
+  Response visit (State &state, const CsgOpNode &node) override;
+  Response visit (State &state, const CgalAdvNode &node) override;
+  Response visit (State &state, const ProjectionNode &node) override;
+  Response visit (State &state, const RenderNode &node) override;
+  Response visit (State &state, const TextNode &node) override;
+  Response visit (State &state, const OffsetNode &node) override;
 
-  [[nodiscard]] const Tree& getTree() const { return this->tree; }
+  [[nodiscard]] const Tree &getTree () const {
+    return this->tree;
+  }
 
 private:
   class ResultObject
   {
-public:
+  public:
     // This makes it explicit if we want a const vs. non-const result.
     // This is important to avoid inadvertently tagging a geometry as const when
     // the underlying geometry is actually mutable.
     // The template trick, combined with private constructors, makes it possible
     // to create a ResultObject containing a const, _only_ from const objects
     // (i.e. no implicit conversion from non-const to const).
-    template <class T> static ResultObject constResult(std::shared_ptr<const T> geom) {return {geom};}
-    template <class T> static ResultObject mutableResult(std::shared_ptr<T> geom) {return {geom};}
+    template <class T>
+    static ResultObject constResult (std::shared_ptr<const T> geom) {
+      return {geom};
+    }
+    template <class T>
+    static ResultObject mutableResult (std::shared_ptr<T> geom) {
+      return {geom};
+    }
 
     // Default constructor with nullptr can be used to represent empty geometry,
     // for example union() with no children, etc.
-    ResultObject() : is_const(true) {}
-    std::shared_ptr<Geometry> ptr() { assert(!is_const); return pointer; }
-    [[nodiscard]] std::shared_ptr<const Geometry> constptr() const {
-      return is_const ? const_pointer : std::static_pointer_cast<const Geometry>(pointer);
+    ResultObject ()
+      : is_const (true) {}
+    std::shared_ptr<Geometry> ptr () {
+      assert (!is_const);
+      return pointer;
     }
-    std::shared_ptr<Geometry> asMutableGeometry() {
-      if (is_const) return {constptr() ? constptr()->copy() : nullptr};
-      else return ptr();
+    [[nodiscard]] std::shared_ptr<const Geometry> constptr () const {
+      return is_const ? const_pointer : std::static_pointer_cast<const Geometry> (pointer);
     }
-private:
-    template <class T> ResultObject(std::shared_ptr<const T> g) : is_const(true), const_pointer(std::move(g)) {}
-    template <class T> ResultObject(std::shared_ptr<T> g) : is_const(false), pointer(std::move(g)) {}
+    std::shared_ptr<Geometry> asMutableGeometry () {
+      if (is_const)
+        return {constptr () ? constptr ()->copy () : nullptr};
+      else
+        return ptr ();
+    }
+
+  private:
+    template <class T>
+    ResultObject (std::shared_ptr<const T> g)
+      : is_const (true)
+      , const_pointer (std::move (g)) {}
+    template <class T>
+    ResultObject (std::shared_ptr<T> g)
+      : is_const (false)
+      , pointer (std::move (g)) {}
 
     bool is_const;
     std::shared_ptr<Geometry> pointer;
     std::shared_ptr<const Geometry> const_pointer;
   };
 
-  void smartCacheInsert(const AbstractNode& node, const std::shared_ptr<const Geometry>& geom);
-  std::shared_ptr<const Geometry> smartCacheGet(const AbstractNode& node, bool preferNef);
-  bool isSmartCached(const AbstractNode& node);
-  bool isValidDim(const Geometry::GeometryItem& item, unsigned int& dim) const;
-  std::vector<std::shared_ptr<const Polygon2d>> collectChildren2D(const AbstractNode& node);
-  Geometry::Geometries collectChildren3D(const AbstractNode& node);
-  std::unique_ptr<Polygon2d> applyMinkowski2D(const AbstractNode& node);
-  std::unique_ptr<Polygon2d> applyHull2D(const AbstractNode& node);
-  std::unique_ptr<Polygon2d> applyFill2D(const AbstractNode& node);
-  std::unique_ptr<Geometry> applyHull3D(const AbstractNode& node);
-  void applyResize3D(CGALNefGeometry& N, const Vector3d& newsize, const Eigen::Matrix<bool, 3, 1>& autosize);
-  std::unique_ptr<Polygon2d> applyToChildren2D(const AbstractNode& node, OpenSCADOperator op);
-  ResultObject applyToChildren3D(const AbstractNode& node, OpenSCADOperator op);
-  ResultObject applyToChildren(const AbstractNode& node, OpenSCADOperator op);
-  std::shared_ptr<const Geometry> projectionCut(const ProjectionNode& node);
-  std::shared_ptr<const Geometry> projectionNoCut(const ProjectionNode& node);
+  void smartCacheInsert (const AbstractNode &node, const std::shared_ptr<const Geometry> &geom);
+  std::shared_ptr<const Geometry> smartCacheGet (const AbstractNode &node, bool preferNef);
+  bool isSmartCached (const AbstractNode &node);
+  bool isValidDim (const Geometry::GeometryItem &item, unsigned int &dim) const;
+  std::vector<std::shared_ptr<const Polygon2d>> collectChildren2D (const AbstractNode &node);
+  Geometry::Geometries collectChildren3D (const AbstractNode &node);
+  std::unique_ptr<Polygon2d> applyMinkowski2D (const AbstractNode &node);
+  std::unique_ptr<Polygon2d> applyHull2D (const AbstractNode &node);
+  std::unique_ptr<Polygon2d> applyFill2D (const AbstractNode &node);
+  std::unique_ptr<Geometry> applyHull3D (const AbstractNode &node);
+  void applyResize3D (CGALNefGeometry &N, const Vector3d &newsize, const Eigen::Matrix<bool, 3, 1> &autosize);
+  std::unique_ptr<Polygon2d> applyToChildren2D (const AbstractNode &node, OpenSCADOperator op);
+  ResultObject applyToChildren3D (const AbstractNode &node, OpenSCADOperator op);
+  ResultObject applyToChildren (const AbstractNode &node, OpenSCADOperator op);
+  std::shared_ptr<const Geometry> projectionCut (const ProjectionNode &node);
+  std::shared_ptr<const Geometry> projectionNoCut (const ProjectionNode &node);
 
-  void addToParent(const State& state, const AbstractNode& node, const std::shared_ptr<const Geometry>& geom);
-  Response lazyEvaluateRootNode(State& state, const AbstractNode& node);
+  void addToParent (const State &state, const AbstractNode &node, const std::shared_ptr<const Geometry> &geom);
+  Response lazyEvaluateRootNode (State &state, const AbstractNode &node);
 
   std::map<int, Geometry::Geometries> visitedchildren;
-  const Tree& tree;
+  const Tree &tree;
   std::shared_ptr<const Geometry> root;
 
 public:
diff --git a/src/geometry/GeometryUtils.cc b/src/geometry/GeometryUtils.cc
index 09d09425d..537052fa6 100644
--- a/src/geometry/GeometryUtils.cc
+++ b/src/geometry/GeometryUtils.cc
@@ -29,14 +29,14 @@
 #include "geometry/manifold/ManifoldGeometry.h"
 #endif
 
-static void *stdAlloc(void *userData, unsigned int size) {
-  TESS_NOTUSED(userData);
-  return malloc(size);
+static void *stdAlloc (void *userData, unsigned int size) {
+  TESS_NOTUSED (userData);
+  return malloc (size);
 }
 
-static void stdFree(void *userData, void *ptr) {
-  TESS_NOTUSED(userData);
-  free(ptr);
+static void stdFree (void *userData, void *ptr) {
+  TESS_NOTUSED (userData);
+  free (ptr);
 }
 
 using IndexedEdge = std::pair<int, int>;
@@ -48,140 +48,156 @@ using IndexedEdge = std::pair<int, int>;
 class EdgeDict
 {
 public:
-// Counts occurrences of edges
+  // Counts occurrences of edges
   using IndexedEdgeDict = std::unordered_map<IndexedEdge, int, boost::hash<IndexedEdge>>;
 
-  EdgeDict() = default;
+  EdgeDict () = default;
 
-  void add(const IndexedFace& face) {
-    for (size_t i = 0; i < face.size(); ++i) {
-      IndexedEdge e(face[(i + 1) % face.size()], face[i]);
-      if (this->count(e) > 0) this->remove(e);
-      else this->add(e.second, e.first);
+  void add (const IndexedFace &face) {
+    for (size_t i = 0; i < face.size (); ++i) {
+      IndexedEdge e (face[(i + 1) % face.size ()], face[i]);
+      if (this->count (e) > 0)
+        this->remove (e);
+      else
+        this->add (e.second, e.first);
     }
   }
 
-  void remove(const IndexedTriangle& t) {
+  void remove (const IndexedTriangle &t) {
     for (int i = 0; i < 3; ++i) {
-      IndexedEdge e(t[i], t[(i + 1) % 3]);
+      IndexedEdge e (t[i], t[(i + 1) % 3]);
       // If the edge exist, remove it
-      if (this->count(e) > 0) this->remove(e);
-      else this->add(e.second, e.first);
+      if (this->count (e) > 0)
+        this->remove (e);
+      else
+        this->add (e.second, e.first);
     }
   }
 
-  void add(const IndexedTriangle& t) {
+  void add (const IndexedTriangle &t) {
     for (int i = 0; i < 3; ++i) {
-      IndexedEdge e(t[(i + 1) % 3], t[i]);
+      IndexedEdge e (t[(i + 1) % 3], t[i]);
       // If an opposite edge exists, they cancel out
-      if (this->count(e) > 0) this->remove(e);
-      else this->add(e.second, e.first);
+      if (this->count (e) > 0)
+        this->remove (e);
+      else
+        this->add (e.second, e.first);
     }
   }
 
-  void add(int start, int end) {
-    this->add(IndexedEdge(start, end));
+  void add (int start, int end) {
+    this->add (IndexedEdge (start, end));
   }
 
-  void add(const IndexedEdge& e) {
+  void add (const IndexedEdge &e) {
     this->edges[e]++;
-//    PRINTDB("add: (%d,%d)", e.first % e.second);
+    //    PRINTDB("add: (%d,%d)", e.first % e.second);
   }
 
-  void remove(int start, int end) {
-    this->remove(IndexedEdge(start, end));
+  void remove (int start, int end) {
+    this->remove (IndexedEdge (start, end));
   }
 
-  void remove(const IndexedEdge& e) {
+  void remove (const IndexedEdge &e) {
     this->edges[e]--;
-    if (this->edges[e] == 0) this->edges.erase(e);
-//    PRINTDB("remove: (%d,%d)", e.first % e.second);
+    if (this->edges[e] == 0)
+      this->edges.erase (e);
+    //    PRINTDB("remove: (%d,%d)", e.first % e.second);
   }
 
-  int count(int start, int end) {
-    return this->count(IndexedEdge(start, end));
+  int count (int start, int end) {
+    return this->count (IndexedEdge (start, end));
   }
 
-  int count(const IndexedEdge& e) {
-    auto it = this->edges.find(e);
-    if (it != edges.end()) return it->second;
+  int count (const IndexedEdge &e) {
+    auto it = this->edges.find (e);
+    if (it != edges.end ())
+      return it->second;
     return 0;
   }
 
-  bool empty() const { return this->edges.empty(); }
-
-  size_t size() const { return this->edges.size(); }
+  bool empty () const {
+    return this->edges.empty ();
+  }
 
-  void print() const {
-//    for (const auto& v : this->edges) {
-//      const auto& e = v.first;
-//      PRINTDB("     (%d,%d)%s", e.first % e.second % ((v.second > 1) ? std::to_string(v.second).c_str() : ""));
-//    }
+  size_t size () const {
+    return this->edges.size ();
   }
 
-  void remove_from_v2e(int vidx, int next, int prev) {
-    auto& l = v2e[vidx];
-    auto it = std::find(l.begin(), l.end(), next);
-    if (it != l.end()) l.erase(it);
-    if (l.empty()) v2e.erase(vidx);
+  void print () const {
+    //    for (const auto& v : this->edges) {
+    //      const auto& e = v.first;
+    //      PRINTDB("     (%d,%d)%s", e.first % e.second % ((v.second > 1) ? std::to_string(v.second).c_str() : ""));
+    //    }
+  }
 
-    auto& l2 = v2e_reverse[vidx];
-    it = std::find(l2.begin(), l2.end(), prev);
-    if (it != l2.end()) l2.erase(it);
-    if (l2.empty()) v2e_reverse.erase(vidx);
+  void remove_from_v2e (int vidx, int next, int prev) {
+    auto &l = v2e[vidx];
+    auto it = std::find (l.begin (), l.end (), next);
+    if (it != l.end ())
+      l.erase (it);
+    if (l.empty ())
+      v2e.erase (vidx);
+
+    auto &l2 = v2e_reverse[vidx];
+    it = std::find (l2.begin (), l2.end (), prev);
+    if (it != l2.end ())
+      l2.erase (it);
+    if (l2.empty ())
+      v2e_reverse.erase (vidx);
   }
 
-  void extractTriangle(int vidx, int next, std::vector<IndexedTriangle>& triangles) {
-    assert(v2e_reverse.find(vidx) != v2e_reverse.end());
-    assert(!v2e_reverse[vidx].empty());
-    auto prev = v2e_reverse[vidx].front();
+  void extractTriangle (int vidx, int next, std::vector<IndexedTriangle> &triangles) {
+    assert (v2e_reverse.find (vidx) != v2e_reverse.end ());
+    assert (!v2e_reverse[vidx].empty ());
+    auto prev = v2e_reverse[vidx].front ();
 
-    IndexedTriangle t(prev, vidx, next);
-//    PRINTDB("Clipping ear: %d %d %d", t[0] % t[1] % t[2]);
-    triangles.push_back(t);
+    IndexedTriangle t (prev, vidx, next);
+    //    PRINTDB("Clipping ear: %d %d %d", t[0] % t[1] % t[2]);
+    triangles.push_back (t);
     // Remove the generated triangle from the original.
     // Add new boundary edges to the edge dict
-    this->remove(t);
+    this->remove (t);
 
     // If next->prev doesn't exists, add prev->next
-    auto v2eit = std::find(v2e[next].begin(), v2e[next].end(), prev);
-    if (v2eit == v2e[next].end()) {
-      v2e[prev].push_back(next);
-      v2e_reverse[next].push_back(prev);
+    auto v2eit = std::find (v2e[next].begin (), v2e[next].end (), prev);
+    if (v2eit == v2e[next].end ()) {
+      v2e[prev].push_back (next);
+      v2e_reverse[next].push_back (prev);
     }
-    remove_from_v2e(vidx, next, prev);
-    remove_from_v2e(prev, vidx, next);
-    remove_from_v2e(next, prev, vidx);
+    remove_from_v2e (vidx, next, prev);
+    remove_from_v2e (prev, vidx, next);
+    remove_from_v2e (next, prev, vidx);
   }
 
   // Triangulate remaining loops and add to triangles
-  void triangulateLoops(std::vector<IndexedTriangle>& triangles) {
+  void triangulateLoops (std::vector<IndexedTriangle> &triangles) {
     // First, look for self-intersections in edges
-    v2e.clear();
-    v2e_reverse.clear();
-    for (const auto& v : this->edges) {
-      const auto& e = v.first;
+    v2e.clear ();
+    v2e_reverse.clear ();
+    for (const auto &v : this->edges) {
+      const auto &e = v.first;
       for (int i = 0; i < v.second; ++i) {
-        v2e[e.first].push_back(e.second);
-        v2e_reverse[e.second].push_back(e.first);
+        v2e[e.first].push_back (e.second);
+        v2e_reverse[e.second].push_back (e.first);
       }
     }
 
-    while (!v2e.empty()) {
+    while (!v2e.empty ()) {
       std::unordered_map<int, std::list<int>>::iterator it;
-      for (it = v2e.begin(); it != v2e.end(); ++it) {
-        if (it->second.size() == 1) { // First single vertex
+      for (it = v2e.begin (); it != v2e.end (); ++it) {
+        if (it->second.size () == 1) { // First single vertex
           auto vidx = it->first;
-          auto next = it->second.front();
-          extractTriangle(vidx, next, triangles);
+          auto next = it->second.front ();
+          extractTriangle (vidx, next, triangles);
           break;
         }
       }
       // Only duplicate vertices left
-      if (it == v2e.end() && !v2e.empty()) {
-        auto vidx = v2e.begin()->first;
-        auto next = v2e.begin()->second.front();
-        extractTriangle(vidx, next, triangles);
+      if (it == v2e.end () && !v2e.empty ()) {
+        auto vidx = v2e.begin ()->first;
+        auto next = v2e.begin ()->second.front ();
+        extractTriangle (vidx, next, triangles);
       }
     }
   }
@@ -191,7 +207,6 @@ public:
   std::unordered_map<int, std::list<int>> v2e_reverse;
 };
 
-
 /*!
    Tessellates input contours into a triangle mesh.
 
@@ -210,11 +225,10 @@ public:
 
    Returns true on error, false on success.
  */
-bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vertices,
-                                               const std::vector<IndexedFace>& faces,
-                                               std::vector<IndexedTriangle>& triangles,
-                                               const Vector3f *normal)
-{
+bool GeometryUtils::tessellatePolygonWithHoles (const std::vector<Vector3f> &vertices,
+                                                const std::vector<IndexedFace> &faces,
+                                                std::vector<IndexedTriangle> &triangles,
+                                                const Vector3f *normal) {
   // Algorithm outline:
   // o Remove consecutive equal vertices and null ears (i.e. 23,24,23)
   // o Ignore polygons with < 3 vertices
@@ -223,47 +237,52 @@ bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vert
   // o Postprocess to clean up misbehaviors in libtess2
 
   // No polygon. FIXME: Will this ever happen or can we assert here?
-  if (faces.empty()) return false;
+  if (faces.empty ())
+    return false;
 
   // Remove consecutive equal vertices, as well as null ears
   auto cleanfaces = faces;
-  for (auto& face : cleanfaces) {
+  for (auto &face : cleanfaces) {
     size_t i = 0;
-    while (face.size() >= 3 && i < face.size()) {
-      if (face[i] == face[(i + 1) % face.size()]) { // Two consecutively equal indices
-        face.erase(face.begin() + i);
-      } else if (face[(i + face.size() - 1) % face.size()] == face[(i + 1) % face.size()]) { // Null ear
-        if (i == 0) face.erase(face.begin() + i, face.begin() + i + 2);
-        else face.erase(face.begin() + i - 1, face.begin() + i + 1);
+    while (face.size () >= 3 && i < face.size ()) {
+      if (face[i] == face[(i + 1) % face.size ()]) { // Two consecutively equal indices
+        face.erase (face.begin () + i);
+      } else if (face[(i + face.size () - 1) % face.size ()] == face[(i + 1) % face.size ()]) { // Null ear
+        if (i == 0)
+          face.erase (face.begin () + i, face.begin () + i + 2);
+        else
+          face.erase (face.begin () + i - 1, face.begin () + i + 1);
         i--;
       } else {
         // Filter away inf and nan vertices as they cause libtess2 to crash
-        const auto& v = vertices[face[i]];
+        const auto &v = vertices[face[i]];
         int k;
         for (k = 0; k < 3; ++k) {
-          if (std::isnan(v[k]) || std::isinf(v[k])) {
-            face.erase(face.begin() + i);
+          if (std::isnan (v[k]) || std::isinf (v[k])) {
+            face.erase (face.begin () + i);
             break;
           }
         }
-        if (k == 3) i++;
+        if (k == 3)
+          i++;
       }
     }
   }
   // First polygon has < 3 points - no output
-  if (cleanfaces[0].size() < 3) return false;
+  if (cleanfaces[0].size () < 3)
+    return false;
   // Remove collapsed holes
-  for (size_t i = 1; i < cleanfaces.size(); ++i) {
-    if (cleanfaces[i].size() < 3) {
-      cleanfaces.erase(cleanfaces.begin() + i);
+  for (size_t i = 1; i < cleanfaces.size (); ++i) {
+    if (cleanfaces[i].size () < 3) {
+      cleanfaces.erase (cleanfaces.begin () + i);
       i--;
     }
   }
 
-  if (cleanfaces.size() == 1 && cleanfaces[0].size() == 3) {
+  if (cleanfaces.size () == 1 && cleanfaces[0].size () == 3) {
     // Input polygon has 3 points. shortcut tessellation.
     //PRINTDB("  tri: %d %d %d", cleanfaces[0][0] % cleanfaces[0][1] % cleanfaces[0][2]);
-    triangles.emplace_back(cleanfaces[0][0], cleanfaces[0][1], cleanfaces[0][2]);
+    triangles.emplace_back (cleanfaces[0][0], cleanfaces[0][1], cleanfaces[0][2]);
     return false;
   }
 
@@ -271,8 +290,8 @@ bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vert
   // This contains all edges in the original polygon.
   // To maintain connectivity, all these edges must exist in the output.
   EdgeDict edges;
-  for (const auto& face : cleanfaces) {
-    edges.add(face);
+  for (const auto &face : cleanfaces) {
+    edges.add (face);
   }
 
   TESSreal *normalvec = nullptr;
@@ -287,35 +306,37 @@ bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vert
   TESSalloc ma;
   TESStesselator *tess = nullptr;
 
-  memset(&ma, 0, sizeof(ma));
+  memset (&ma, 0, sizeof (ma));
   ma.memalloc = stdAlloc;
   ma.memfree = stdFree;
   ma.extraVertices = 256; // realloc not provided, allow 256 extra vertices.
 
-  if (!(tess = tessNewTess(&ma))) return true;
+  if (!(tess = tessNewTess (&ma)))
+    return true;
 
   std::vector<TESSreal> contour;
   // Since libtess2's indices is based on the running number of points added, we need to map back
   // to our indices. allindices does the mapping.
   std::vector<int> allindices;
-  for (const auto& face : cleanfaces) {
-    contour.clear();
+  for (const auto &face : cleanfaces) {
+    contour.clear ();
     for (auto idx : face) {
-      const auto& v = vertices[idx];
-      contour.push_back(v[0]);
-      contour.push_back(v[1]);
-      contour.push_back(v[2]);
-      allindices.push_back(idx);
+      const auto &v = vertices[idx];
+      contour.push_back (v[0]);
+      contour.push_back (v[1]);
+      contour.push_back (v[2]);
+      allindices.push_back (idx);
     }
-    assert(face.size() >= 3);
-    tessAddContour(tess, 3, &contour.front(), sizeof(TESSreal) * 3, face.size());
+    assert (face.size () >= 3);
+    tessAddContour (tess, 3, &contour.front (), sizeof (TESSreal) * 3, face.size ());
   }
 
-  if (!tessTesselate(tess, TESS_WINDING_ODD, TESS_CONSTRAINED_DELAUNAY_TRIANGLES, 3, 3, normalvec)) return false;
+  if (!tessTesselate (tess, TESS_WINDING_ODD, TESS_CONSTRAINED_DELAUNAY_TRIANGLES, 3, 3, normalvec))
+    return false;
 
-  const auto vindices = tessGetVertexIndices(tess);
-  const auto elements = tessGetElements(tess);
-  auto numelems = tessGetElementCount(tess);
+  const auto vindices = tessGetVertexIndices (tess);
+  const auto elements = tessGetElements (tess);
+  auto numelems = tessGetElementCount (tess);
 
   /*
      At this point, we have a delaunay triangle mesh.
@@ -334,14 +355,14 @@ bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vert
      B) Locate all unused vertices
      C) For each unused vertex, create a triangle connecting it to the existing mesh
    */
-  auto inputSize = allindices.size(); // inputSize is number of points added to libtess2
-  std::vector<int> vflags(inputSize); // Inits with 0's
+  auto inputSize = allindices.size (); // inputSize is number of points added to libtess2
+  std::vector<int> vflags (inputSize); // Inits with 0's
 
   IndexedTriangle tri;
   IndexedTriangle mappedtri;
   for (int t = 0; t < numelems; ++t) {
     auto err = false;
-    mappedtri.fill(-1);
+    mappedtri.fill (-1);
     for (int i = 0; i < 3; ++i) {
       auto vidx = vindices[elements[t * 3 + i]];
       if (vidx == TESS_UNDEF) {
@@ -369,36 +390,36 @@ bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vert
       // In this case, don't reverse, but attempt to carry on
       auto reverse = false;
       for (int i = 0; i < 3; ++i) {
-        const IndexedEdge e(mappedtri[i], mappedtri[(i + 1) % 3]);
-        if (edges.count(e) > 0) {
+        const IndexedEdge e (mappedtri[i], mappedtri[(i + 1) % 3]);
+        if (edges.count (e) > 0) {
           reverse = false;
           break;
-        } else if (edges.count(e.second, e.first) > 0) {
+        } else if (edges.count (e.second, e.first) > 0) {
           reverse = true;
         }
       }
       if (reverse) {
-        mappedtri.reverseInPlace();
-//        PRINTDB("  reversed: %d %d %d", mappedtri[0] % mappedtri[1] % mappedtri[2]);
+        mappedtri.reverseInPlace ();
+        //        PRINTDB("  reversed: %d %d %d", mappedtri[0] % mappedtri[1] % mappedtri[2]);
       }
 
       // Remove the generated triangle from the original.
       // Add new boundary edges to the edge dict
-      edges.remove(mappedtri);
-      triangles.push_back(mappedtri);
+      edges.remove (mappedtri);
+      triangles.push_back (mappedtri);
     }
   }
 
-  if (!edges.empty()) {
-    PRINTDB("   %d edges remaining after main triangulation", edges.size());
-    edges.print();
+  if (!edges.empty ()) {
+    PRINTDB ("   %d edges remaining after main triangulation", edges.size ());
+    edges.print ();
 
     // Collect loops from remaining edges and triangulate loops manually
-    edges.triangulateLoops(triangles);
+    edges.triangulateLoops (triangles);
 
-    if (!edges.empty()) {
-      PRINTDB("   %d edges remaining after loop triangulation", edges.size());
-      edges.print();
+    if (!edges.empty ()) {
+      PRINTDB ("   %d edges remaining after loop triangulation", edges.size ());
+      edges.print ();
     }
   }
 #if 0
@@ -423,7 +444,7 @@ bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vert
   }
 #endif // if 0
 
-  tessDeleteTess(tess);
+  tessDeleteTess (tess);
 
   return false;
 }
@@ -432,84 +453,86 @@ bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vert
    Tessellates a single contour. Non-indexed version.
    Appends resulting triangles to triangles.
  */
-bool GeometryUtils::tessellatePolygon(const Polygon& polygon, Polygons& triangles,
-                                      const Vector3f *normal)
-{
+bool GeometryUtils::tessellatePolygon (const Polygon &polygon, Polygons &triangles,
+                                       const Vector3f *normal) {
   auto err = false;
   Reindexer<Vector3f> uniqueVertices;
   std::vector<IndexedFace> indexedfaces{{}};
-  auto& currface = indexedfaces.back();
-  for (const auto& v : polygon) {
-    auto idx = uniqueVertices.lookup(v.cast<float>());
-    if (currface.empty() || idx != currface.back()) currface.push_back(idx);
-  }
-  if (currface.front() == currface.back()) currface.pop_back();
-  if (currface.size() >= 3) { // Cull empty triangles
-    const auto& verts = uniqueVertices.getArray();
+  auto &currface = indexedfaces.back ();
+  for (const auto &v : polygon) {
+    auto idx = uniqueVertices.lookup (v.cast<float> ());
+    if (currface.empty () || idx != currface.back ())
+      currface.push_back (idx);
+  }
+  if (currface.front () == currface.back ())
+    currface.pop_back ();
+  if (currface.size () >= 3) { // Cull empty triangles
+    const auto &verts = uniqueVertices.getArray ();
     std::vector<IndexedTriangle> indexedtriangles;
-    err = tessellatePolygonWithHoles(verts, indexedfaces, indexedtriangles, normal);
-    for (const auto& t : indexedtriangles) {
-      triangles.push_back(Polygon());
-      Polygon& p = triangles.back();
-      p.push_back(verts[t[0]].cast<double>());
-      p.push_back(verts[t[1]].cast<double>());
-      p.push_back(verts[t[2]].cast<double>());
+    err = tessellatePolygonWithHoles (verts, indexedfaces, indexedtriangles, normal);
+    for (const auto &t : indexedtriangles) {
+      triangles.push_back (Polygon ());
+      Polygon &p = triangles.back ();
+      p.push_back (verts[t[0]].cast<double> ());
+      p.push_back (verts[t[1]].cast<double> ());
+      p.push_back (verts[t[2]].cast<double> ());
     }
   }
   return err;
 }
 
-int GeometryUtils::findUnconnectedEdges(const std::vector<std::vector<IndexedFace>>& polygons)
-{
+int GeometryUtils::findUnconnectedEdges (const std::vector<std::vector<IndexedFace>> &polygons) {
   EdgeDict edges;
-  for (const auto& faces : polygons) {
-    for (const auto& face : faces) {
-      edges.add(face);
+  for (const auto &faces : polygons) {
+    for (const auto &face : faces) {
+      edges.add (face);
     }
   }
 #if 1 // for debugging
-  if (!edges.empty()) {
-    PRINTD("Unconnected:");
-    edges.print();
+  if (!edges.empty ()) {
+    PRINTD ("Unconnected:");
+    edges.print ();
   }
 #endif
-  return edges.size();
+  return edges.size ();
 }
 
-int GeometryUtils::findUnconnectedEdges(const std::vector<IndexedTriangle>& triangles)
-{
+int GeometryUtils::findUnconnectedEdges (const std::vector<IndexedTriangle> &triangles) {
   EdgeDict edges;
-  for (const auto& t : triangles) {
-    edges.add(t);
+  for (const auto &t : triangles) {
+    edges.add (t);
   }
 #if 1 // for debugging
-  if (!edges.empty()) {
-    PRINTD("Unconnected:");
-    edges.print();
+  if (!edges.empty ()) {
+    PRINTD ("Unconnected:");
+    edges.print ();
   }
 #endif
 
-  return edges.size();
+  return edges.size ();
 }
 
-Transform3d GeometryUtils::getResizeTransform(const BoundingBox& bbox, const Vector3d& newsize, const Eigen::Matrix<bool, 3, 1>& autosize)
-{
+Transform3d GeometryUtils::getResizeTransform (const BoundingBox &bbox, const Vector3d &newsize, const Eigen::Matrix<bool, 3, 1> &autosize) {
   // Find largest dimension
   int maxdim = 0;
-  for (int i = 1; i < 3; ++i) if (newsize[i] > newsize[maxdim]) maxdim = i;
+  for (int i = 1; i < 3; ++i)
+    if (newsize[i] > newsize[maxdim])
+      maxdim = i;
 
   // Default scale (scale with 1 if the new size is 0)
-  Vector3d scale(1, 1, 1);
-  for (int i = 0; i < 3; ++i) if (newsize[i] > 0) scale[i] = newsize[i] / bbox.sizes()[i];
+  Vector3d scale (1, 1, 1);
+  for (int i = 0; i < 3; ++i)
+    if (newsize[i] > 0)
+      scale[i] = newsize[i] / bbox.sizes ()[i];
 
   // Autoscale where applicable
   double autoscale = scale[maxdim];
   Vector3d newscale;
-  for (int i = 0; i < 3; ++i) newscale[i] = !autosize[i] || (newsize[i] > 0) ? scale[i] : autoscale;
+  for (int i = 0; i < 3; ++i)
+    newscale[i] = !autosize[i] || (newsize[i] > 0) ? scale[i] : autoscale;
 
   Transform3d t;
-  t.matrix() <<
-    newscale[0], 0, 0, 0,
+  t.matrix () << newscale[0], 0, 0, 0,
     0, newscale[1], 0, 0,
     0, 0, newscale[2], 0,
     0, 0, 0, 1;
@@ -520,30 +543,29 @@ Transform3d GeometryUtils::getResizeTransform(const BoundingBox& bbox, const Vec
 // Return or force creation of backend-specific geometry.
 // Will prefer Manifold if multiple backends are enabled.
 // geom must be a 3D PolySet or the correct backend-specific geometry.
-std::shared_ptr<const Geometry> GeometryUtils::getBackendSpecificGeometry(const std::shared_ptr<const Geometry>& geom)
-{
+std::shared_ptr<const Geometry> GeometryUtils::getBackendSpecificGeometry (const std::shared_ptr<const Geometry> &geom) {
 #if ENABLE_MANIFOLD
-  if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
-    if (const auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
-      std::shared_ptr<ManifoldGeometry> mani = ManifoldUtils::createManifoldFromPolySet(*ps);
+  if (RenderSettings::inst ()->backend3D == RenderBackend3D::ManifoldBackend) {
+    if (const auto ps = std::dynamic_pointer_cast<const PolySet> (geom)) {
+      std::shared_ptr<ManifoldGeometry> mani = ManifoldUtils::createManifoldFromPolySet (*ps);
       if (mani == nullptr) {
-        mani = std::make_shared<ManifoldGeometry>();
+        mani = std::make_shared<ManifoldGeometry> ();
       }
       return mani;
-    } else if (auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
+    } else if (auto mani = std::dynamic_pointer_cast<const ManifoldGeometry> (geom)) {
       return geom;
     } else {
-      assert(false && "Unexpected geometry");
+      assert (false && "Unexpected geometry");
     }
   }
 #endif // if ENABLE_MANIFOLD
 #if ENABLE_CGAL
-  if (auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
-    return CGALUtils::createNefPolyhedronFromPolySet(*ps);
-  } else if (auto poly = std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
+  if (auto ps = std::dynamic_pointer_cast<const PolySet> (geom)) {
+    return CGALUtils::createNefPolyhedronFromPolySet (*ps);
+  } else if (auto poly = std::dynamic_pointer_cast<const CGALNefGeometry> (geom)) {
     return geom;
   } else {
-    assert(false && "Unexpected geometry");
+    assert (false && "Unexpected geometry");
   }
 #endif
   return nullptr;
diff --git a/src/geometry/GeometryUtils.h b/src/geometry/GeometryUtils.h
index 7ea5d5ee6..6a6149b1e 100644
--- a/src/geometry/GeometryUtils.h
+++ b/src/geometry/GeometryUtils.h
@@ -32,18 +32,18 @@ struct IndexedPolyMesh {
 
 namespace GeometryUtils {
 
-bool tessellatePolygon(const Polygon& polygon,
-                       Polygons& triangles,
-                       const Vector3f *normal = nullptr);
-bool tessellatePolygonWithHoles(const std::vector<Vector3f>& vertices,
-                                const std::vector<IndexedFace>& faces,
-                                std::vector<IndexedTriangle>& triangles,
-                                const Vector3f *normal = nullptr);
+bool tessellatePolygon (const Polygon &polygon,
+                        Polygons &triangles,
+                        const Vector3f *normal = nullptr);
+bool tessellatePolygonWithHoles (const std::vector<Vector3f> &vertices,
+                                 const std::vector<IndexedFace> &faces,
+                                 std::vector<IndexedTriangle> &triangles,
+                                 const Vector3f *normal = nullptr);
 
-int findUnconnectedEdges(const std::vector<std::vector<IndexedFace>>& polygons);
-int findUnconnectedEdges(const std::vector<IndexedTriangle>& triangles);
+int findUnconnectedEdges (const std::vector<std::vector<IndexedFace>> &polygons);
+int findUnconnectedEdges (const std::vector<IndexedTriangle> &triangles);
 
-Transform3d getResizeTransform(const BoundingBox& bbox, const Vector3d& newsize, const Eigen::Matrix<bool, 3, 1>& autosize);
-std::shared_ptr<const Geometry> getBackendSpecificGeometry(const std::shared_ptr<const Geometry>& geom);
+Transform3d getResizeTransform (const BoundingBox &bbox, const Vector3d &newsize, const Eigen::Matrix<bool, 3, 1> &autosize);
+std::shared_ptr<const Geometry> getBackendSpecificGeometry (const std::shared_ptr<const Geometry> &geom);
 
-}
+} // namespace GeometryUtils
diff --git a/src/geometry/Grid.h b/src/geometry/Grid.h
index ea26ed9df..7179d66ec 100644
--- a/src/geometry/Grid.h
+++ b/src/geometry/Grid.h
@@ -26,7 +26,7 @@ public:
   double res;
   std::unordered_map<std::pair<int64_t, int64_t>, T, boost::hash<std::pair<int64_t, int64_t>>> db;
 
-  Grid2d(double resolution) {
+  Grid2d (double resolution) {
     res = resolution;
   }
   /*!
@@ -34,15 +34,16 @@ public:
      Returns the value stored if a point already existing or an uninitialized new value
      if not.
    */
-  T& align(double& x, double& y) {
-    auto ix = (int64_t)std::round(x / res);
-    auto iy = (int64_t)std::round(y / res);
-    if (db.find(std::make_pair(ix, iy)) == db.end()) {
+  T &align (double &x, double &y) {
+    auto ix = (int64_t)std::round (x / res);
+    auto iy = (int64_t)std::round (y / res);
+    if (db.find (std::make_pair (ix, iy)) == db.end ()) {
       int dist = 10;
       for (int64_t jx = ix - 1; jx <= ix + 1; ++jx) {
         for (int64_t jy = iy - 1; jy <= iy + 1; ++jy) {
-          if (db.find(std::make_pair(jx, jy)) == db.end()) continue;
-          int d = abs(int(ix - jx)) + abs(int(iy - jy));
+          if (db.find (std::make_pair (jx, jy)) == db.end ())
+            continue;
+          int d = abs (int (ix - jx)) + abs (int (iy - jy));
           if (d < dist) {
             dist = d;
             ix = jx;
@@ -52,31 +53,34 @@ public:
       }
     }
     x = ix * res, y = iy * res;
-    return db[std::make_pair(ix, iy)];
+    return db[std::make_pair (ix, iy)];
   }
 
-  [[nodiscard]] bool has(double x, double y) const {
-    auto ix = (int64_t)std::round(x / res);
-    auto iy = (int64_t)std::round(y / res);
-    if (db.find(std::make_pair(ix, iy)) != db.end()) return true;
+  [[nodiscard]] bool has (double x, double y) const {
+    auto ix = (int64_t)std::round (x / res);
+    auto iy = (int64_t)std::round (y / res);
+    if (db.find (std::make_pair (ix, iy)) != db.end ())
+      return true;
     for (int64_t jx = ix - 1; jx <= ix + 1; ++jx)
       for (int64_t jy = iy - 1; jy <= iy + 1; ++jy) {
-        if (db.find(std::make_pair(jx, jy)) != db.end()) return true;
+        if (db.find (std::make_pair (jx, jy)) != db.end ())
+          return true;
       }
     return false;
   }
 
-  bool eq(double x1, double y1, double x2, double y2) {
-    align(x1, y1);
-    align(x2, y2);
-    if (fabs(x1 - x2) < res && fabs(y1 - y2) < res) return true;
+  bool eq (double x1, double y1, double x2, double y2) {
+    align (x1, y1);
+    align (x2, y2);
+    if (fabs (x1 - x2) < res && fabs (y1 - y2) < res)
+      return true;
     return false;
   }
-  T& data(double x, double y) {
-    return align(x, y);
+  T &data (double x, double y) {
+    return align (x, y);
   }
-  T& operator()(double x, double y) {
-    return align(x, y);
+  T &operator() (double x, double y) {
+    return align (x, y);
   }
 };
 
@@ -89,31 +93,32 @@ public:
   using GridContainer = std::unordered_map<Key, T>;
   GridContainer db;
 
-  Grid3d(double resolution) {
+  Grid3d (double resolution) {
     res = resolution;
   }
 
-  inline void createGridVertex(const Vector3d& v, Vector3l& i) {
-    i[0] = int64_t(v[0] / this->res);
-    i[1] = int64_t(v[1] / this->res);
-    i[2] = int64_t(v[2] / this->res);
+  inline void createGridVertex (const Vector3d &v, Vector3l &i) {
+    i[0] = int64_t (v[0] / this->res);
+    i[1] = int64_t (v[1] / this->res);
+    i[2] = int64_t (v[2] / this->res);
   }
 
   // Aligns vertex to the grid. Returns index of the vertex.
   // Will automatically increase the index as new unique vertices are added.
-  T align(Vector3d& v) {
+  T align (Vector3d &v) {
     Vector3l key;
-    createGridVertex(v, key);
-    auto iter = db.find(key);
-    if (iter == db.end()) {
+    createGridVertex (v, key);
+    auto iter = db.find (key);
+    if (iter == db.end ()) {
       float dist = 10.0f; // > max possible distance
       for (int64_t jx = key[0] - 1; jx <= key[0] + 1; ++jx) {
         for (int64_t jy = key[1] - 1; jy <= key[1] + 1; ++jy) {
           for (int64_t jz = key[2] - 1; jz <= key[2] + 1; ++jz) {
-            Vector3l k(jx, jy, jz);
-            auto tmpiter = db.find(k);
-            if (tmpiter == db.end()) continue;
-            float d = sqrt((key - k).squaredNorm());
+            Vector3l k (jx, jy, jz);
+            auto tmpiter = db.find (k);
+            if (tmpiter == db.end ())
+              continue;
+            float d = sqrt ((key - k).squaredNorm ());
             if (d < dist) {
               dist = d;
               iter = tmpiter;
@@ -124,8 +129,8 @@ public:
     }
 
     T data;
-    if (iter == db.end()) { // Not found: insert using key
-      data = db.size();
+    if (iter == db.end ()) { // Not found: insert using key
+      data = db.size ();
       db[key] = data;
     } else {
       // If found return existing data
@@ -141,27 +146,28 @@ public:
     return data;
   }
 
-  bool has(const Vector3d& v, T *data = nullptr) {
-    Vector3l key = createGridVertex(v);
-    typename GridContainer::iterator pos = db.find(key);
-    if (pos != db.end()) {
-      if (data) *data = pos->second;
+  bool has (const Vector3d &v, T *data = nullptr) {
+    Vector3l key = createGridVertex (v);
+    typename GridContainer::iterator pos = db.find (key);
+    if (pos != db.end ()) {
+      if (data)
+        *data = pos->second;
       return true;
     }
     for (int64_t jx = key[0] - 1; jx <= key[0] + 1; ++jx)
       for (int64_t jy = key[1] - 1; jy <= key[1] + 1; ++jy)
         for (int64_t jz = key[2] - 1; jz <= key[2] + 1; ++jz) {
-          pos = db.find(Vector3l(jx, jy, jz));
-          if (pos != db.end()) {
-            if (data) *data = pos->second;
+          pos = db.find (Vector3l (jx, jy, jz));
+          if (pos != db.end ()) {
+            if (data)
+              *data = pos->second;
             return true;
           }
         }
     return false;
   }
 
-  T data(Vector3d v) {
-    return align(v);
+  T data (Vector3d v) {
+    return align (v);
   }
-
 };
diff --git a/src/geometry/PolySet.cc b/src/geometry/PolySet.cc
index a7e81d446..1f3985d0c 100644
--- a/src/geometry/PolySet.cc
+++ b/src/geometry/PolySet.cc
@@ -52,82 +52,81 @@
 
  */
 
-PolySet::PolySet(unsigned int dim, boost::tribool convex)
-  : dim_(dim), convex_(convex)
-{
+PolySet::PolySet (unsigned int dim, boost::tribool convex)
+  : dim_ (dim)
+  , convex_ (convex) {
 }
 
-std::unique_ptr<Geometry> PolySet::copy() const {
-  return std::make_unique<PolySet>(*this);
+std::unique_ptr<Geometry> PolySet::copy () const {
+  return std::make_unique<PolySet> (*this);
 }
 
-std::string PolySet::dump() const
-{
+std::string PolySet::dump () const {
   std::ostringstream out;
   out << "PolySet:"
       << "\n dimensions:" << dim_
       << "\n convexity:" << this->convexity
-      << "\n num polygons: " << indices.size()
+      << "\n num polygons: " << indices.size ()
       << "\n polygons data:";
-  for (const auto& polygon : indices) {
+  for (const auto &polygon : indices) {
     out << "\n  polygon begin:";
     for (auto v : polygon) {
-      out << "\n   vertex:" << this->vertices[v].transpose();
+      out << "\n   vertex:" << this->vertices[v].transpose ();
     }
   }
   out << "\nPolySet end";
-  return out.str();
+  return out.str ();
 }
 
-BoundingBox PolySet::getBoundingBox() const
-{
-  if (bbox_.isNull()) {
-    for (const auto& v : vertices) {
-      bbox_.extend(v);
+BoundingBox PolySet::getBoundingBox () const {
+  if (bbox_.isNull ()) {
+    for (const auto &v : vertices) {
+      bbox_.extend (v);
     }
   }
   return bbox_;
 }
 
-size_t PolySet::memsize() const
-{
+size_t PolySet::memsize () const {
   size_t mem = 0;
-  for (const auto& p : this->indices) mem += p.size() * sizeof(int);
-  for (const auto& p : this->vertices) mem += p.size() * sizeof(Vector3d);
-  mem += sizeof(PolySet);
+  for (const auto &p : this->indices)
+    mem += p.size () * sizeof (int);
+  for (const auto &p : this->vertices)
+    mem += p.size () * sizeof (Vector3d);
+  mem += sizeof (PolySet);
   return mem;
 }
-void PolySet::transform(const Transform3d& mat)
-{
+void PolySet::transform (const Transform3d &mat) {
   // If mirroring transform, flip faces to avoid the object to end up being inside-out
-  bool mirrored = mat.matrix().determinant() < 0;
+  bool mirrored = mat.matrix ().determinant () < 0;
 
-  for (auto& v : this->vertices)
+  for (auto &v : this->vertices)
     v = mat * v;
 
   if (mirrored)
-    for (auto& p : this->indices) {
-      std::reverse(p.begin(), p.end());
+    for (auto &p : this->indices) {
+      std::reverse (p.begin (), p.end ());
     }
-  bbox_.setNull();
+  bbox_.setNull ();
 }
 
-void PolySet::setColor(const Color4f& c) {
+void PolySet::setColor (const Color4f &c) {
   colors = {c};
-  color_indices.assign(indices.size(), 0);
+  color_indices.assign (indices.size (), 0);
 }
 
-bool PolySet::isConvex() const {
-  if (convex_ || this->isEmpty()) return true;
-  if (!convex_) return false;
-  bool is_convex = PolySetUtils::is_approximately_convex(*this);
+bool PolySet::isConvex () const {
+  if (convex_ || this->isEmpty ())
+    return true;
+  if (!convex_)
+    return false;
+  bool is_convex = PolySetUtils::is_approximately_convex (*this);
   convex_ = is_convex;
   return is_convex;
 }
 
-void PolySet::resize(const Vector3d& newsize, const Eigen::Matrix<bool, 3, 1>& autosize)
-{
-  this->transform(GeometryUtils::getResizeTransform(this->getBoundingBox(), newsize, autosize));
+void PolySet::resize (const Vector3d &newsize, const Eigen::Matrix<bool, 3, 1> &autosize) {
+  this->transform (GeometryUtils::getResizeTransform (this->getBoundingBox (), newsize, autosize));
 }
 
 /*!
@@ -135,33 +134,33 @@ void PolySet::resize(const Vector3d& newsize, const Eigen::Matrix<bool, 3, 1>& a
    neighboring grids.
    May reduce the number of polygons if polygons collapse into < 3 vertices.
  */
-void PolySet::quantizeVertices(std::vector<Vector3d> *pPointsOut)
-{
-  const bool has_colors = !this->color_indices.empty();
-  Grid3d<unsigned int> grid(GRID_FINE);
+void PolySet::quantizeVertices (std::vector<Vector3d> *pPointsOut) {
+  const bool has_colors = !this->color_indices.empty ();
+  Grid3d<unsigned int> grid (GRID_FINE);
   std::vector<unsigned int> polygon_indices; // Vertex indices in one polygon
-  for (size_t i = 0; i < this->indices.size();) {
-    IndexedFace& ind_f = this->indices[i];
-    polygon_indices.resize(ind_f.size());
+  for (size_t i = 0; i < this->indices.size ();) {
+    IndexedFace &ind_f = this->indices[i];
+    polygon_indices.resize (ind_f.size ());
     // Quantize all vertices. Build index list
-    for (unsigned int i = 0; i < ind_f.size(); ++i) {
-      polygon_indices[i] = grid.align(this->vertices[ind_f[i]]);
-      if (pPointsOut && pPointsOut->size() < grid.db.size()) {
-        pPointsOut->push_back(this->vertices[ind_f[i]]);
+    for (unsigned int i = 0; i < ind_f.size (); ++i) {
+      polygon_indices[i] = grid.align (this->vertices[ind_f[i]]);
+      if (pPointsOut && pPointsOut->size () < grid.db.size ()) {
+        pPointsOut->push_back (this->vertices[ind_f[i]]);
       }
     }
     // Remove consecutive duplicate vertices
-    auto currp = ind_f.begin();
-    for (unsigned int i = 0; i < polygon_indices.size(); ++i) {
-      if (polygon_indices[i] != polygon_indices[(i + 1) % polygon_indices.size()]) {
+    auto currp = ind_f.begin ();
+    for (unsigned int i = 0; i < polygon_indices.size (); ++i) {
+      if (polygon_indices[i] != polygon_indices[(i + 1) % polygon_indices.size ()]) {
         (*currp++) = ind_f[i];
       }
     }
-    ind_f.erase(currp, ind_f.end());
-    if (ind_f.size() < 3) {
-      PRINTD("Removing collapsed polygon due to quantizing");
-      this->indices.erase(this->indices.begin() + i);
-      if (has_colors) this->color_indices.erase(this->color_indices.begin() + i);
+    ind_f.erase (currp, ind_f.end ());
+    if (ind_f.size () < 3) {
+      PRINTD ("Removing collapsed polygon due to quantizing");
+      this->indices.erase (this->indices.begin () + i);
+      if (has_colors)
+        this->color_indices.erase (this->color_indices.begin () + i);
     } else {
       i++;
     }
diff --git a/src/geometry/PolySet.h b/src/geometry/PolySet.h
index 9c8e5dd58..47f9d18ac 100644
--- a/src/geometry/PolySet.h
+++ b/src/geometry/PolySet.h
@@ -17,36 +17,51 @@ class PolySetBuilder;
 class PolySet : public Geometry
 {
   friend class PolySetBuilder;
+
 public:
-  VISITABLE_GEOMETRY();
+  VISITABLE_GEOMETRY ();
   PolygonIndices indices;
   std::vector<Vector3d> vertices;
   // Per polygon color, indexing the colors vector below. Can be empty, and -1 means no specific color.
   std::vector<int32_t> color_indices;
   std::vector<Color4f> colors;
 
-  PolySet(unsigned int dim, boost::tribool convex = unknown);
+  PolySet (unsigned int dim, boost::tribool convex = unknown);
 
-  size_t memsize() const override;
-  BoundingBox getBoundingBox() const override;
-  std::string dump() const override;
-  unsigned int getDimension() const override { return dim_; }
-  bool isEmpty() const override { return indices.empty(); }
-  std::unique_ptr<Geometry> copy() const override;
+  size_t memsize () const override;
+  BoundingBox getBoundingBox () const override;
+  std::string dump () const override;
+  unsigned int getDimension () const override {
+    return dim_;
+  }
+  bool isEmpty () const override {
+    return indices.empty ();
+  }
+  std::unique_ptr<Geometry> copy () const override;
 
-  void quantizeVertices(std::vector<Vector3d> *pPointsOut = nullptr);
-  size_t numFacets() const override { return indices.size(); }
-  void transform(const Transform3d& mat) override;
-  void resize(const Vector3d& newsize, const Eigen::Matrix<bool, 3, 1>& autosize) override;
-  void setColor(const Color4f& c) override;
+  void quantizeVertices (std::vector<Vector3d> *pPointsOut = nullptr);
+  size_t numFacets () const override {
+    return indices.size ();
+  }
+  void transform (const Transform3d &mat) override;
+  void resize (const Vector3d &newsize, const Eigen::Matrix<bool, 3, 1> &autosize) override;
+  void setColor (const Color4f &c) override;
 
-  bool isConvex() const;
-  boost::tribool convexValue() const { return convex_; }
+  bool isConvex () const;
+  boost::tribool convexValue () const {
+    return convex_;
+  }
 
-  bool isTriangular() const { return is_triangular_; }
-  void setTriangular(bool triangular) { is_triangular_ = triangular; }
+  bool isTriangular () const {
+    return is_triangular_;
+  }
+  void setTriangular (bool triangular) {
+    is_triangular_ = triangular;
+  }
 
-  static std::unique_ptr<PolySet> createEmpty() { return std::make_unique<PolySet>(3); }
+  static std::unique_ptr<PolySet> createEmpty () {
+    return std::make_unique<PolySet> (3);
+  }
 
 private:
   bool is_triangular_ = false;
diff --git a/src/geometry/PolySetBuilder.cc b/src/geometry/PolySetBuilder.cc
index 1cd05f100..0ba011472 100644
--- a/src/geometry/PolySetBuilder.cc
+++ b/src/geometry/PolySetBuilder.cc
@@ -45,189 +45,182 @@
 #include <memory>
 #include <vector>
 
-PolySetBuilder::PolySetBuilder(int vertices_count, int indices_count, int dim, boost::tribool convex)
-  : dim_(dim), convex_(convex)
-{
-  reserve(vertices_count, indices_count);
+PolySetBuilder::PolySetBuilder (int vertices_count, int indices_count, int dim, boost::tribool convex)
+  : dim_ (dim)
+  , convex_ (convex) {
+  reserve (vertices_count, indices_count);
 }
 
-void PolySetBuilder::reserve(int vertices_count, int indices_count) {
-  if (vertices_count != 0) vertices_.reserve(vertices_count);
-  if (indices_count != 0) indices_.reserve(indices_count);
+void PolySetBuilder::reserve (int vertices_count, int indices_count) {
+  if (vertices_count != 0)
+    vertices_.reserve (vertices_count);
+  if (indices_count != 0)
+    indices_.reserve (indices_count);
 }
 
-void PolySetBuilder::setConvexity(int convexity){
+void PolySetBuilder::setConvexity (int convexity) {
   convexity_ = convexity;
 }
 
-void PolySetBuilder::addColor(const Color4f& color)
-{
-  colors_.push_back(color);
+void PolySetBuilder::addColor (const Color4f &color) {
+  colors_.push_back (color);
 }
 
-void PolySetBuilder::addColorIndex(const int32_t idx)
-{
-  color_indices_.push_back(idx);
+void PolySetBuilder::addColorIndex (const int32_t idx) {
+  color_indices_.push_back (idx);
 }
 
-int PolySetBuilder::numVertices() const {
-  return vertices_.size();
+int PolySetBuilder::numVertices () const {
+  return vertices_.size ();
 }
 
-int PolySetBuilder::numPolygons() const {
-  return indices_.size();
+int PolySetBuilder::numPolygons () const {
+  return indices_.size ();
 }
 
-bool PolySetBuilder::isEmpty() const {
-  return vertices_.size() == 0 && indices_.size() == 0;
+bool PolySetBuilder::isEmpty () const {
+  return vertices_.size () == 0 && indices_.size () == 0;
 }
 
-int PolySetBuilder::vertexIndex(const Vector3d& pt)
-{
-  return vertices_.lookup(pt);
+int PolySetBuilder::vertexIndex (const Vector3d &pt) {
+  return vertices_.lookup (pt);
 }
 
-void PolySetBuilder::appendGeometry(const std::shared_ptr<const Geometry>& geom)
-{
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
-    for (const Geometry::GeometryItem& item : geomlist->getChildren()) {
-      appendGeometry(item.second);
+void PolySetBuilder::appendGeometry (const std::shared_ptr<const Geometry> &geom) {
+  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList> (geom)) {
+    for (const Geometry::GeometryItem &item : geomlist->getChildren ()) {
+      appendGeometry (item.second);
     }
-  } else if (const auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
-    appendPolySet(*ps);
+  } else if (const auto ps = std::dynamic_pointer_cast<const PolySet> (geom)) {
+    appendPolySet (*ps);
 #ifdef ENABLE_CGAL
-  } else if (const auto N = std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
-    if (const auto ps = CGALUtils::createPolySetFromNefPolyhedron3(*(N->p3))) {
-      appendPolySet(*ps);
+  } else if (const auto N = std::dynamic_pointer_cast<const CGALNefGeometry> (geom)) {
+    if (const auto ps = CGALUtils::createPolySetFromNefPolyhedron3 (*(N->p3))) {
+      appendPolySet (*ps);
     } else {
-      LOG(message_group::Error, "Nef->PolySet failed");
+      LOG (message_group::Error, "Nef->PolySet failed");
     }
 #endif // ifdef ENABLE_CGAL
 #ifdef ENABLE_MANIFOLD
-  } else if (const auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
-    appendPolySet(*mani->toPolySet());
+  } else if (const auto mani = std::dynamic_pointer_cast<const ManifoldGeometry> (geom)) {
+    appendPolySet (*mani->toPolySet ());
 #endif
-  } else if (std::dynamic_pointer_cast<const Polygon2d>(geom)) { // NOLINT(bugprone-branch-clone)
-    assert(false && "Unsupported geometry");
+  } else if (std::dynamic_pointer_cast<const Polygon2d> (geom)) { // NOLINT(bugprone-branch-clone)
+    assert (false && "Unsupported geometry");
   } else { // NOLINT(bugprone-branch-clone)
-    assert(false && "Not implemented");
+    assert (false && "Not implemented");
   }
-
 }
 
-void PolySetBuilder::appendPolygon(const std::vector<int>& inds)
-{
-  beginPolygon(inds.size());
-  for (int idx : inds) addVertex(idx);
-  endPolygon();
+void PolySetBuilder::appendPolygon (const std::vector<int> &inds) {
+  beginPolygon (inds.size ());
+  for (int idx : inds)
+    addVertex (idx);
+  endPolygon ();
 }
 
-void PolySetBuilder::appendPolygon(const std::vector<Vector3d>& polygon)
-{
-  beginPolygon(polygon.size());
-  for (const auto& v: polygon) addVertex(v);
-  endPolygon();
+void PolySetBuilder::appendPolygon (const std::vector<Vector3d> &polygon) {
+  beginPolygon (polygon.size ());
+  for (const auto &v : polygon)
+    addVertex (v);
+  endPolygon ();
 }
 
-void PolySetBuilder::beginPolygon(int nvertices) {
-  endPolygon();
-  current_polygon_.reserve(nvertices);
+void PolySetBuilder::beginPolygon (int nvertices) {
+  endPolygon ();
+  current_polygon_.reserve (nvertices);
 }
 
-void PolySetBuilder::addVertex(int ind)
-{
+void PolySetBuilder::addVertex (int ind) {
   // Ignore consecutive duplicate indices
-  if (current_polygon_.empty() || (ind != current_polygon_.back() && ind != current_polygon_.front())) {
-    current_polygon_.push_back(ind);
+  if (current_polygon_.empty () || (ind != current_polygon_.back () && ind != current_polygon_.front ())) {
+    current_polygon_.push_back (ind);
   }
 }
 
-void PolySetBuilder::addVertex(const Vector3d& v)
-{
-  addVertex(vertexIndex(v));
+void PolySetBuilder::addVertex (const Vector3d &v) {
+  addVertex (vertexIndex (v));
 }
 
-void PolySetBuilder::endPolygon(const Color4f& color) {
+void PolySetBuilder::endPolygon (const Color4f &color) {
   // FIXME: Should we check for self-touching polygons (non-consecutive duplicate indices)?
 
   // FIXME: Can we move? What would the state of current_polygon_ be after move?
-  if (current_polygon_.size() >= 3) {
-    indices_.push_back(current_polygon_);
+  if (current_polygon_.size () >= 3) {
+    indices_.push_back (current_polygon_);
 
-    if (color.isValid()) {
-      if (color_indices_.empty() && indices_.size() > 1) {
-        color_indices_.resize(indices_.size() - 1, -1);
+    if (color.isValid ()) {
+      if (color_indices_.empty () && indices_.size () > 1) {
+        color_indices_.resize (indices_.size () - 1, -1);
       }
-      auto it = std::find(colors_.begin(), colors_.end(), color);
-      if (it == colors_.end()) {
-        color_indices_.push_back(colors_.size());
-        colors_.push_back(color);
+      auto it = std::find (colors_.begin (), colors_.end (), color);
+      if (it == colors_.end ()) {
+        color_indices_.push_back (colors_.size ());
+        colors_.push_back (color);
       } else {
-        color_indices_.push_back(it - colors_.begin());
+        color_indices_.push_back (it - colors_.begin ());
       }
     }
   }
-  current_polygon_.clear();
+  current_polygon_.clear ();
 }
 
-void PolySetBuilder::appendPolySet(const PolySet& ps)
-{
+void PolySetBuilder::appendPolySet (const PolySet &ps) {
   // Copy color indices lazily.
-  if (!ps.color_indices.empty()) {
+  if (!ps.color_indices.empty ()) {
     // If we hadn't built color_indices_ yet, catch up / fill w/ -1.
-    if (color_indices_.empty() && !indices_.empty()) {
-      color_indices_.resize(indices_.size(), -1);
+    if (color_indices_.empty () && !indices_.empty ()) {
+      color_indices_.resize (indices_.size (), -1);
     }
-    color_indices_.reserve(color_indices_.size() + ps.color_indices.size());
+    color_indices_.reserve (color_indices_.size () + ps.color_indices.size ());
 
-    auto nColors = ps.colors.size();
-    std::vector<uint32_t> color_map(nColors);
+    auto nColors = ps.colors.size ();
+    std::vector<uint32_t> color_map (nColors);
     for (size_t i = 0; i < nColors; i++) {
-      const auto& color = ps.colors[i];
+      const auto &color = ps.colors[i];
       // Find index of color in colors_, or add it if it doesn't exist
-      auto it = std::find(colors_.begin(), colors_.end(), color);
-      if (it == colors_.end()) {
-        color_map[i] = colors_.size();
-        colors_.push_back(color);
+      auto it = std::find (colors_.begin (), colors_.end (), color);
+      if (it == colors_.end ()) {
+        color_map[i] = colors_.size ();
+        colors_.push_back (color);
       } else {
-        color_map[i] = it - colors_.begin();
+        color_map[i] = it - colors_.begin ();
       }
     }
     for (auto color_index : ps.color_indices) {
-      color_indices_.push_back(color_index < 0 ? -1 : color_map[color_index]);
+      color_indices_.push_back (color_index < 0 ? -1 : color_map[color_index]);
     }
-  } else if (!color_indices_.empty()) {
+  } else if (!color_indices_.empty ()) {
     // If we already built color_indices_ but don't have colors with this ps, fill with -1.
-    color_indices_.resize(color_indices_.size() + ps.indices.size(), -1);
+    color_indices_.resize (color_indices_.size () + ps.indices.size (), -1);
   }
 
-  reserve(numVertices() + ps.vertices.size(), numPolygons() + ps.indices.size());
-  for (const auto& poly : ps.indices) {
-    beginPolygon(poly.size());
-    for (const auto& ind: poly) {
-      addVertex(ps.vertices[ind]);
+  reserve (numVertices () + ps.vertices.size (), numPolygons () + ps.indices.size ());
+  for (const auto &poly : ps.indices) {
+    beginPolygon (poly.size ());
+    for (const auto &ind : poly) {
+      addVertex (ps.vertices[ind]);
     }
-    endPolygon();
+    endPolygon ();
   }
 }
 
-std::unique_ptr<PolySet> PolySetBuilder::build()
-{
-  endPolygon();
+std::unique_ptr<PolySet> PolySetBuilder::build () {
+  endPolygon ();
   std::unique_ptr<PolySet> polyset;
-  polyset = std::make_unique<PolySet>(dim_, convex_);
-  vertices_.copy(std::back_inserter(polyset->vertices));
-  polyset->indices = std::move(indices_);
-  polyset->color_indices = std::move(color_indices_);
-  polyset->colors = std::move(colors_);
-  polyset->setConvexity(convexity_);
+  polyset = std::make_unique<PolySet> (dim_, convex_);
+  vertices_.copy (std::back_inserter (polyset->vertices));
+  polyset->indices = std::move (indices_);
+  polyset->color_indices = std::move (color_indices_);
+  polyset->colors = std::move (colors_);
+  polyset->setConvexity (convexity_);
   bool is_triangular = true;
-  for (const auto& face : polyset->indices) {
-    if (face.size() > 3) {
+  for (const auto &face : polyset->indices) {
+    if (face.size () > 3) {
       is_triangular = false;
       break;
     }
   }
-  polyset->setTriangular(is_triangular);
+  polyset->setTriangular (is_triangular);
   return polyset;
 }
diff --git a/src/geometry/PolySetBuilder.h b/src/geometry/PolySetBuilder.h
index 04363f933..b4d15b667 100644
--- a/src/geometry/PolySetBuilder.h
+++ b/src/geometry/PolySetBuilder.h
@@ -16,29 +16,30 @@ class PolySet;
 class PolySetBuilder
 {
 public:
-  PolySetBuilder(int vertices_count = 0, int indices_count = 0, int dim = 3, boost::tribool convex = unknown);
-  void reserve(int vertices_count = 0, int indices_count = 0);
-  void setConvexity(int n);
-  int vertexIndex(const Vector3d& coord);
-  int numVertices() const;
-  int numPolygons() const;
-  bool isEmpty() const;
-
-  void appendPolySet(const PolySet& ps);
-  void appendGeometry(const std::shared_ptr<const Geometry>& geom);
-  void appendPolygon(const std::vector<int>& inds);
-  void appendPolygon(const std::vector<Vector3d>& v);
-
-  void beginPolygon(int nvertices);
-  void addVertex(int ind);
-  void addVertex(const Vector3d& v);
+  PolySetBuilder (int vertices_count = 0, int indices_count = 0, int dim = 3, boost::tribool convex = unknown);
+  void reserve (int vertices_count = 0, int indices_count = 0);
+  void setConvexity (int n);
+  int vertexIndex (const Vector3d &coord);
+  int numVertices () const;
+  int numPolygons () const;
+  bool isEmpty () const;
+
+  void appendPolySet (const PolySet &ps);
+  void appendGeometry (const std::shared_ptr<const Geometry> &geom);
+  void appendPolygon (const std::vector<int> &inds);
+  void appendPolygon (const std::vector<Vector3d> &v);
+
+  void beginPolygon (int nvertices);
+  void addVertex (int ind);
+  void addVertex (const Vector3d &v);
   // Calling this is optional; will be called automatically when adding a new polygon or building the PolySet
-  void endPolygon(const Color4f& color = {});
+  void endPolygon (const Color4f &color = {});
 
-  void addColor(const Color4f& color);
-  void addColorIndex(int idx); // should be paired with begin/endPolygon()
+  void addColor (const Color4f &color);
+  void addColorIndex (int idx); // should be paired with begin/endPolygon()
+
+  std::unique_ptr<PolySet> build ();
 
-  std::unique_ptr<PolySet> build();
 private:
   Reindexer<Vector3d> vertices_;
   PolygonIndices indices_;
diff --git a/src/geometry/PolySetUtils.cc b/src/geometry/PolySetUtils.cc
index d58ace789..d57844435 100644
--- a/src/geometry/PolySetUtils.cc
+++ b/src/geometry/PolySetUtils.cc
@@ -28,17 +28,17 @@ namespace PolySetUtils {
 // Project all polygons (also back-facing) into a Polygon2d instance.
 // It is important to select all faces, since filtering by normal vector here
 // will trigger floating point incertainties and cause problems later.
-std::unique_ptr<Polygon2d> project(const PolySet& ps) {
-  auto poly = std::make_unique<Polygon2d>();
+std::unique_ptr<Polygon2d> project (const PolySet &ps) {
+  auto poly = std::make_unique<Polygon2d> ();
 
   Vector3d pt;
-  for (const auto& p : ps.indices) {
+  for (const auto &p : ps.indices) {
     Outline2d outline;
-    for (const auto& v : p) {
+    for (const auto &v : p) {
       pt = ps.vertices[v];
-      outline.vertices.emplace_back(pt[0], pt[1]);
+      outline.vertices.emplace_back (pt[0], pt[1]);
     }
-    poly->addOutline(outline);
+    poly->addOutline (outline);
   }
   return poly;
 }
@@ -62,166 +62,165 @@ std::unique_ptr<Polygon2d> project(const PolySet& ps) {
    polyset has simple polygon faces with no holes.
    The tessellation will be robust wrt. degenerate and self-intersecting
  */
-std::unique_ptr<PolySet> tessellate_faces(const PolySet& polyset)
-{
+std::unique_ptr<PolySet> tessellate_faces (const PolySet &polyset) {
   int degeneratePolygons = 0;
-  auto result = std::make_unique<PolySet>(3, polyset.convexValue());
-  result->setConvexity(polyset.getConvexity());
-  result->setTriangular(true);
+  auto result = std::make_unique<PolySet> (3, polyset.convexValue ());
+  result->setConvexity (polyset.getConvexity ());
+  result->setTriangular (true);
   // ideally this should not require a copy...
-  if (polyset.isTriangular()) {
+  if (polyset.isTriangular ()) {
     result->vertices = polyset.vertices;
     result->indices = polyset.indices;
     result->color_indices = polyset.color_indices;
     result->colors = polyset.colors;
     return result;
   }
-  result->vertices.reserve(polyset.vertices.size());
-  result->indices.reserve(polyset.indices.size());
+  result->vertices.reserve (polyset.vertices.size ());
+  result->indices.reserve (polyset.indices.size ());
 
-  std::vector<bool> used(polyset.vertices.size(), false);
+  std::vector<bool> used (polyset.vertices.size (), false);
   // best estimate without iterating all polygons, to reduce reallocations
   std::vector<IndexedFace> polygons;
-  polygons.reserve(polyset.indices.size());
+  polygons.reserve (polyset.indices.size ());
   std::vector<int32_t> polygon_color_indices;
-  auto has_colors = !polyset.color_indices.empty();
+  auto has_colors = !polyset.color_indices.empty ();
   if (has_colors) {
-    assert(polyset.color_indices.size() == polyset.indices.size());
-    polygon_color_indices.reserve(polyset.color_indices.size());
+    assert (polyset.color_indices.size () == polyset.indices.size ());
+    polygon_color_indices.reserve (polyset.color_indices.size ());
     result->colors = polyset.colors;
   }
-  for (size_t i = 0, n = polyset.indices.size(); i < n; i++) {
-    const auto& pgon = polyset.indices[i];
-    if (pgon.size() < 3) {
+  for (size_t i = 0, n = polyset.indices.size (); i < n; i++) {
+    const auto &pgon = polyset.indices[i];
+    if (pgon.size () < 3) {
       degeneratePolygons++;
       continue;
     }
-    auto& currface = polygons.emplace_back();
-    for (const auto& ind : pgon) {
-      const Vector3f v = polyset.vertices[ind].cast<float>();
-      if (currface.empty() || v != polyset.vertices[currface.back()].cast<float>())currface.push_back(ind);
+    auto &currface = polygons.emplace_back ();
+    for (const auto &ind : pgon) {
+      const Vector3f v = polyset.vertices[ind].cast<float> ();
+      if (currface.empty () || v != polyset.vertices[currface.back ()].cast<float> ())
+        currface.push_back (ind);
     }
-    const Vector3f head = polyset.vertices[currface.front()].cast<float>();
-    while (!currface.empty() && head == polyset.vertices[currface.back()].cast<float>())
-      currface.pop_back();
-    if (currface.size() < 3) {
-      polygons.pop_back();
+    const Vector3f head = polyset.vertices[currface.front ()].cast<float> ();
+    while (!currface.empty () && head == polyset.vertices[currface.back ()].cast<float> ())
+      currface.pop_back ();
+    if (currface.size () < 3) {
+      polygons.pop_back ();
       continue;
     }
     if (has_colors) {
-      polygon_color_indices.push_back(polyset.color_indices[i]);
+      polygon_color_indices.push_back (polyset.color_indices[i]);
     }
-    for (const auto& ind : currface)
+    for (const auto &ind : currface)
       used[ind] = true;
   }
   // remove unreferenced vertices
   std::vector<Vector3f> verts;
-  std::vector<int> indexMap(polyset.vertices.size());
-  verts.reserve(polyset.vertices.size());
-  for (size_t i = 0; i < polyset.vertices.size(); ++i) {
+  std::vector<int> indexMap (polyset.vertices.size ());
+  verts.reserve (polyset.vertices.size ());
+  for (size_t i = 0; i < polyset.vertices.size (); ++i) {
     if (used[i]) {
-      indexMap[i] = verts.size();
-      verts.emplace_back(polyset.vertices[i].cast<float>());
-      result->vertices.push_back(polyset.vertices[i]);
+      indexMap[i] = verts.size ();
+      verts.emplace_back (polyset.vertices[i].cast<float> ());
+      result->vertices.push_back (polyset.vertices[i]);
     }
   }
-  if (verts.size() != polyset.vertices.size()) {
+  if (verts.size () != polyset.vertices.size ()) {
     // only remap indices when some vertices are really removed
-    for (auto& face : polygons) {
-      for (auto& ind : face)
+    for (auto &face : polygons) {
+      for (auto &ind : face)
         ind = indexMap[ind];
     }
   }
 
   // we will reuse this memory instead of reallocating for each polygon
   std::vector<IndexedTriangle> triangles;
-  std::vector<IndexedFace> facesBuffer(1);
-  for (size_t i = 0, n = polygons.size(); i < n; i++) {
-    const auto& face = polygons[i];
-    if (face.size() == 3) {
+  std::vector<IndexedFace> facesBuffer (1);
+  for (size_t i = 0, n = polygons.size (); i < n; i++) {
+    const auto &face = polygons[i];
+    if (face.size () == 3) {
       // trivial case - triangles cannot be concave or have holes
-      result->indices.push_back({face[0], face[1], face[2]});
-      if (has_colors)result->color_indices.push_back(polygon_color_indices[i]);
+      result->indices.push_back ({face[0], face[1], face[2]});
+      if (has_colors)
+        result->color_indices.push_back (polygon_color_indices[i]);
     }
     // Quads seem trivial, but can be concave, and can have degenerate cases.
     // So everything more complex than triangles goes into the general case.
     else {
-      triangles.clear();
+      triangles.clear ();
       facesBuffer[0] = face;
-      auto err = GeometryUtils::tessellatePolygonWithHoles(verts, facesBuffer, triangles, nullptr);
+      auto err = GeometryUtils::tessellatePolygonWithHoles (verts, facesBuffer, triangles, nullptr);
       if (!err) {
-        for (const auto& t : triangles) {
-          result->indices.push_back({t[0], t[1], t[2]});
-          if (has_colors)result->color_indices.push_back(polygon_color_indices[i]);
+        for (const auto &t : triangles) {
+          result->indices.push_back ({t[0], t[1], t[2]});
+          if (has_colors)
+            result->color_indices.push_back (polygon_color_indices[i]);
         }
       }
     }
   }
   if (degeneratePolygons > 0) {
-    LOG(message_group::Warning, "PolySet has degenerate polygons");
+    LOG (message_group::Warning, "PolySet has degenerate polygons");
   }
   return result;
 }
 
-bool is_approximately_convex(const PolySet& ps) {
+bool is_approximately_convex (const PolySet &ps) {
 #ifdef ENABLE_CGAL
-  return CGALUtils::is_approximately_convex(ps);
+  return CGALUtils::is_approximately_convex (ps);
 #else
   return false;
 #endif
 }
 
 // Get as or convert the geometry to a PolySet.
-std::shared_ptr<const PolySet> getGeometryAsPolySet(const std::shared_ptr<const Geometry>& geom)
-{
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
+std::shared_ptr<const PolySet> getGeometryAsPolySet (const std::shared_ptr<const Geometry> &geom) {
+  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList> (geom)) {
     PolySetBuilder builder;
-    builder.appendGeometry(geom);
-    return builder.build();
-  } else if (auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
+    builder.appendGeometry (geom);
+    return builder.build ();
+  } else if (auto ps = std::dynamic_pointer_cast<const PolySet> (geom)) {
     return ps;
   }
 #ifdef ENABLE_CGAL
-  if (auto N = std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
-    if (!N->isEmpty()) {
-      if (auto ps = CGALUtils::createPolySetFromNefPolyhedron3(*N->p3)) {
-        ps->setConvexity(N->getConvexity());
+  if (auto N = std::dynamic_pointer_cast<const CGALNefGeometry> (geom)) {
+    if (!N->isEmpty ()) {
+      if (auto ps = CGALUtils::createPolySetFromNefPolyhedron3 (*N->p3)) {
+        ps->setConvexity (N->getConvexity ());
         return ps;
       }
-      LOG(message_group::Error, "Nef->PolySet failed.");
+      LOG (message_group::Error, "Nef->PolySet failed.");
     }
-    return PolySet::createEmpty();
+    return PolySet::createEmpty ();
   }
 #endif // ifdef ENABLE_CGAL
 #ifdef ENABLE_MANIFOLD
-  if (auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
-    return mani->toPolySet();
+  if (auto mani = std::dynamic_pointer_cast<const ManifoldGeometry> (geom)) {
+    return mani->toPolySet ();
   }
 #endif
   return nullptr;
 }
 
-
-std::string polySetToPolyhedronSource(const PolySet& ps)
-{
+std::string polySetToPolyhedronSource (const PolySet &ps) {
   std::stringstream sstr;
   sstr << "polyhedron(\n";
   sstr << "  points=[\n";
-  for (const auto& v : ps.vertices) {
+  for (const auto &v : ps.vertices) {
     sstr << "[" << v[0] << ", " << v[1] << ", " << v[2] << "],\n";
   }
   sstr << "  ],\n";
   sstr << "  faces=[\n";
-  for (const auto& polygon : ps.indices) {
+  for (const auto &polygon : ps.indices) {
     sstr << "[";
-    for (const auto idx : boost::adaptors::reverse(polygon)) {
+    for (const auto idx : boost::adaptors::reverse (polygon)) {
       sstr << idx << ",";
     }
     sstr << "],\n";
   }
   sstr << "  ],\n";
   sstr << ");\n";
-  return sstr.str();
+  return sstr.str ();
 }
 
 } // namespace PolySetUtils
diff --git a/src/geometry/PolySetUtils.h b/src/geometry/PolySetUtils.h
index 086417aa7..fa6878aa2 100644
--- a/src/geometry/PolySetUtils.h
+++ b/src/geometry/PolySetUtils.h
@@ -10,12 +10,12 @@ class PolySet;
 
 namespace PolySetUtils {
 
-std::unique_ptr<Polygon2d> project(const PolySet& ps);
-std::unique_ptr<PolySet> tessellate_faces(const PolySet& inps);
-bool is_approximately_convex(const PolySet& ps);
+std::unique_ptr<Polygon2d> project (const PolySet &ps);
+std::unique_ptr<PolySet> tessellate_faces (const PolySet &inps);
+bool is_approximately_convex (const PolySet &ps);
 
-std::shared_ptr<const PolySet> getGeometryAsPolySet(const std::shared_ptr<const class Geometry>&);
+std::shared_ptr<const PolySet> getGeometryAsPolySet (const std::shared_ptr<const class Geometry> &);
 
-std::string polySetToPolyhedronSource(const PolySet& ps);
+std::string polySetToPolyhedronSource (const PolySet &ps);
 
-}
+} // namespace PolySetUtils
diff --git a/src/geometry/Polygon2d.cc b/src/geometry/Polygon2d.cc
index 409d306de..ac4f2f19a 100644
--- a/src/geometry/Polygon2d.cc
+++ b/src/geometry/Polygon2d.cc
@@ -17,20 +17,19 @@
 #include "geometry/PolySet.h"
 #include "glview/RenderSettings.h"
 
-
-Polygon2d::Polygon2d(Outline2d outline) : sanitized(true) {
-  addOutline(std::move(outline));
+Polygon2d::Polygon2d (Outline2d outline)
+  : sanitized (true) {
+  addOutline (std::move (outline));
 }
 
-std::unique_ptr<Geometry> Polygon2d::copy() const
-{
-  return std::make_unique<Polygon2d>(*this);
+std::unique_ptr<Geometry> Polygon2d::copy () const {
+  return std::make_unique<Polygon2d> (*this);
 }
 
-BoundingBox Outline2d::getBoundingBox() const {
+BoundingBox Outline2d::getBoundingBox () const {
   BoundingBox bbox;
-  for (const auto& v : this->vertices) {
-    bbox.extend(Vector3d(v[0], v[1], 0));
+  for (const auto &v : this->vertices) {
+    bbox.extend (Vector3d (v[0], v[1], 0));
   }
   return bbox;
 }
@@ -50,116 +49,107 @@ BoundingBox Outline2d::getBoundingBox() const {
    the flag can be set manually.
  */
 
-size_t Polygon2d::memsize() const
-{
+size_t Polygon2d::memsize () const {
   size_t mem = 0;
-  for (const auto& o : this->outlines()) {
-    mem += o.vertices.size() * sizeof(Vector2d) + sizeof(Outline2d);
+  for (const auto &o : this->outlines ()) {
+    mem += o.vertices.size () * sizeof (Vector2d) + sizeof (Outline2d);
   }
-  mem += sizeof(Polygon2d);
+  mem += sizeof (Polygon2d);
   return mem;
 }
 
-BoundingBox Polygon2d::getBoundingBox() const
-{
+BoundingBox Polygon2d::getBoundingBox () const {
   BoundingBox bbox;
-  for (const auto& o : this->outlines()) {
-    bbox.extend(o.getBoundingBox());
+  for (const auto &o : this->outlines ()) {
+    bbox.extend (o.getBoundingBox ());
   }
   return bbox;
 }
 
-std::string Polygon2d::dump() const
-{
+std::string Polygon2d::dump () const {
   std::ostringstream out;
-  for (const auto& o : this->theoutlines) {
+  for (const auto &o : this->theoutlines) {
     out << "contour:\n";
-    for (const auto& v : o.vertices) {
-      out << "  " << v.transpose();
+    for (const auto &v : o.vertices) {
+      out << "  " << v.transpose ();
     }
     out << "\n";
   }
-  return out.str();
+  return out.str ();
 }
 
-bool Polygon2d::isEmpty() const
-{
-  return this->theoutlines.empty();
+bool Polygon2d::isEmpty () const {
+  return this->theoutlines.empty ();
 }
 
-void Polygon2d::transform(const Transform2d& mat)
-{
-  if (mat.matrix().determinant() == 0) {
-    LOG(message_group::Warning, "Scaling a 2D object with 0 - removing object");
-    this->theoutlines.clear();
+void Polygon2d::transform (const Transform2d &mat) {
+  if (mat.matrix ().determinant () == 0) {
+    LOG (message_group::Warning, "Scaling a 2D object with 0 - removing object");
+    this->theoutlines.clear ();
     return;
   }
-  for (auto& o : this->theoutlines) {
-    for (auto& v : o.vertices) {
+  for (auto &o : this->theoutlines) {
+    for (auto &v : o.vertices) {
       v = mat * v;
     }
   }
 }
 
-void Polygon2d::resize(const Vector2d& newsize, const Eigen::Matrix<bool, 2, 1>& autosize)
-{
-  auto bbox = this->getBoundingBox();
+void Polygon2d::resize (const Vector2d &newsize, const Eigen::Matrix<bool, 2, 1> &autosize) {
+  auto bbox = this->getBoundingBox ();
 
   // Find largest dimension
   int maxdim = (newsize[1] && newsize[1] > newsize[0]) ? 1 : 0;
 
   // Default scale (scale with 1 if the new size is 0)
-  Vector2d scale(newsize[0] > 0 ? newsize[0] / bbox.sizes()[0] : 1,
-                 newsize[1] > 0 ? newsize[1] / bbox.sizes()[1] : 1);
+  Vector2d scale (newsize[0] > 0 ? newsize[0] / bbox.sizes ()[0] : 1,
+                  newsize[1] > 0 ? newsize[1] / bbox.sizes ()[1] : 1);
 
   // Autoscale where applicable
-  double autoscale = newsize[maxdim] > 0 ? newsize[maxdim] / bbox.sizes()[maxdim] : 1;
-  Vector2d newscale(!autosize[0] || (newsize[0] > 0) ? scale[0] : autoscale,
-                    !autosize[1] || (newsize[1] > 0) ? scale[1] : autoscale);
+  double autoscale = newsize[maxdim] > 0 ? newsize[maxdim] / bbox.sizes ()[maxdim] : 1;
+  Vector2d newscale (!autosize[0] || (newsize[0] > 0) ? scale[0] : autoscale,
+                     !autosize[1] || (newsize[1] > 0) ? scale[1] : autoscale);
 
   Transform2d t;
-  t.matrix() <<
-    newscale[0], 0, 0,
+  t.matrix () << newscale[0], 0, 0,
     0, newscale[1], 0,
     0, 0, 1;
 
-  this->transform(t);
+  this->transform (t);
 }
 
-bool Polygon2d::is_convex() const
-{
-  if (theoutlines.size() > 1) return false;
-  if (theoutlines.empty()) return true;
+bool Polygon2d::is_convex () const {
+  if (theoutlines.size () > 1)
+    return false;
+  if (theoutlines.empty ())
+    return true;
 
-  auto const& pts = theoutlines[0].vertices;
-  int N = pts.size();
+  auto const &pts = theoutlines[0].vertices;
+  int N = pts.size ();
 
   // Check for a right turn. This assumes the polygon is simple.
   for (int i = 0; i < N; ++i) {
-    const auto& d1 = pts[(i + 1) % N] - pts[i];
-    const auto& d2 = pts[(i + 2) % N] - pts[(i + 1) % N];
+    const auto &d1 = pts[(i + 1) % N] - pts[i];
+    const auto &d2 = pts[(i + 2) % N] - pts[(i + 1) % N];
     double zcross = d1[0] * d2[1] - d1[1] * d2[0];
-    if (zcross < 0) return false;
+    if (zcross < 0)
+      return false;
   }
   return true;
 }
 
-double Polygon2d::area() const
-{
-  auto ps = tessellate();
+double Polygon2d::area () const {
+  auto ps = tessellate ();
   if (ps == nullptr) {
     return 0;
   }
 
   double area = 0.0;
-  for (const auto& poly : ps->indices) {
-    const auto& v1 = ps->vertices[poly[0]];
-    const auto& v2 = ps->vertices[poly[1]];
-    const auto& v3 = ps->vertices[poly[2]];
-    area += 0.5 * (
-      v1.x() * (v2.y() - v3.y())
-      + v2.x() * (v3.y() - v1.y())
-      + v3.x() * (v1.y() - v2.y()));
+  for (const auto &poly : ps->indices) {
+    const auto &v1 = ps->vertices[poly[0]];
+    const auto &v2 = ps->vertices[poly[1]];
+    const auto &v3 = ps->vertices[poly[2]];
+    area += 0.5 * (v1.x () * (v2.y () - v3.y ()) + v2.x () * (v3.y () - v1.y ()) + v3.x () * (v1.y () - v2.y ()));
   }
   return area;
 }
@@ -176,13 +166,12 @@ double Polygon2d::area() const
  * guarantee that vertices and their order are untouched (apart from adding a zero 3rd dimension)
  *
  */
-std::unique_ptr<PolySet> Polygon2d::tessellate() const
-{
-  PRINTDB("Polygon2d::tessellate(): %d outlines", this->outlines().size());
+std::unique_ptr<PolySet> Polygon2d::tessellate () const {
+  PRINTDB ("Polygon2d::tessellate(): %d outlines", this->outlines ().size ());
 #if defined(ENABLE_MANIFOLD) && defined(USE_MANIFOLD_TRIANGULATOR)
-  if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
-    return ManifoldUtils::createTriangulatedPolySetFromPolygon2d(*this);
+  if (RenderSettings::inst ()->backend3D == RenderBackend3D::ManifoldBackend) {
+    return ManifoldUtils::createTriangulatedPolySetFromPolygon2d (*this);
   } else
 #endif
-  return CGALUtils::createTriangulatedPolySetFromPolygon2d(*this);
+    return CGALUtils::createTriangulatedPolySetFromPolygon2d (*this);
 }
diff --git a/src/geometry/Polygon2d.h b/src/geometry/Polygon2d.h
index 948dda826..1dfddd1e2 100644
--- a/src/geometry/Polygon2d.h
+++ b/src/geometry/Polygon2d.h
@@ -14,52 +14,62 @@
    positive is (optionally) used to distinguish between polygon contours and hole contours.
  */
 struct Outline2d {
-  Outline2d() = default;
+  Outline2d () = default;
   VectorOfVector2d vertices;
   bool positive{true};
-  [[nodiscard]] BoundingBox getBoundingBox() const;
+  [[nodiscard]] BoundingBox getBoundingBox () const;
 };
 
 class Polygon2d : public Geometry
 {
 public:
-  VISITABLE_GEOMETRY();
-  Polygon2d() = default;
-  Polygon2d(Outline2d outline);
-  [[nodiscard]] size_t memsize() const override;
-  [[nodiscard]] BoundingBox getBoundingBox() const override;
-  [[nodiscard]] std::string dump() const override;
-  [[nodiscard]] unsigned int getDimension() const override { return 2; }
-  [[nodiscard]] bool isEmpty() const override;
-  [[nodiscard]] std::unique_ptr<Geometry> copy() const override;
-  [[nodiscard]] size_t numFacets() const override {
-    return std::accumulate(theoutlines.begin(), theoutlines.end(), 0,
-                           [](size_t a, const Outline2d& b) {
-      return a + b.vertices.size();
-    }
-                           );
+  VISITABLE_GEOMETRY ();
+  Polygon2d () = default;
+  Polygon2d (Outline2d outline);
+  [[nodiscard]] size_t memsize () const override;
+  [[nodiscard]] BoundingBox getBoundingBox () const override;
+  [[nodiscard]] std::string dump () const override;
+  [[nodiscard]] unsigned int getDimension () const override {
+    return 2;
   }
-  void addOutline(Outline2d outline) { this->theoutlines.push_back(std::move(outline)); }
-  [[nodiscard]] std::unique_ptr<PolySet> tessellate() const;
-  [[nodiscard]] double area() const;
+  [[nodiscard]] bool isEmpty () const override;
+  [[nodiscard]] std::unique_ptr<Geometry> copy () const override;
+  [[nodiscard]] size_t numFacets () const override {
+    return std::accumulate (theoutlines.begin (), theoutlines.end (), 0,
+                            [] (size_t a, const Outline2d &b) {
+                              return a + b.vertices.size ();
+                            });
+  }
+  void addOutline (Outline2d outline) {
+    this->theoutlines.push_back (std::move (outline));
+  }
+  [[nodiscard]] std::unique_ptr<PolySet> tessellate () const;
+  [[nodiscard]] double area () const;
 
   using Outlines2d = std::vector<Outline2d>;
-  [[nodiscard]] const Outlines2d& outlines() const { return theoutlines; }
+  [[nodiscard]] const Outlines2d &outlines () const {
+    return theoutlines;
+  }
   // Note: The "using" here is a kludge to avoid a compiler warning.
   // It would be better to fix the class relationships, so that Polygon2d does
   // not inherit an unused 3d transform function.
   // But that will likely require significant refactoring.
   using Geometry::transform;
 
-  void transform(const Transform2d& mat);
-  void resize(const Vector2d& newsize, const Eigen::Matrix<bool, 2, 1>& autosize);
-  void resize(const Vector3d& newsize, const Eigen::Matrix<bool, 3, 1>& autosize) override {
-    resize(Vector2d(newsize[0], newsize[1]), Eigen::Matrix<bool, 2, 1>(autosize[0], autosize[1]));
+  void transform (const Transform2d &mat);
+  void resize (const Vector2d &newsize, const Eigen::Matrix<bool, 2, 1> &autosize);
+  void resize (const Vector3d &newsize, const Eigen::Matrix<bool, 3, 1> &autosize) override {
+    resize (Vector2d (newsize[0], newsize[1]), Eigen::Matrix<bool, 2, 1> (autosize[0], autosize[1]));
+  }
+
+  [[nodiscard]] bool isSanitized () const {
+    return this->sanitized;
+  }
+  void setSanitized (bool s) {
+    this->sanitized = s;
   }
+  [[nodiscard]] bool is_convex () const;
 
-  [[nodiscard]] bool isSanitized() const { return this->sanitized; }
-  void setSanitized(bool s) { this->sanitized = s; }
-  [[nodiscard]] bool is_convex() const;
 private:
   Outlines2d theoutlines;
   bool sanitized{false};
diff --git a/src/geometry/Reindexer.h b/src/geometry/Reindexer.h
index c43a58920..aca2174ec 100644
--- a/src/geometry/Reindexer.h
+++ b/src/geometry/Reindexer.h
@@ -20,35 +20,36 @@ public:
   /*!
      Looks up a value. Will insert the value if it doesn't already exist.
      Returns the new index. */
-  int lookup(const T& val) {
-    auto iter = this->map.find(val);
-    if (iter != this->map.end()) return iter->second;
+  int lookup (const T &val) {
+    auto iter = this->map.find (val);
+    if (iter != this->map.end ())
+      return iter->second;
     else {
-      this->map.insert(std::make_pair(val, this->map.size()));
-      return this->map.size() - 1;
+      this->map.insert (std::make_pair (val, this->map.size ()));
+      return this->map.size () - 1;
     }
   }
 
   /*!
      Returns the current size of the new element array
    */
-  [[nodiscard]] std::size_t size() const {
-    return this->map.size();
+  [[nodiscard]] std::size_t size () const {
+    return this->map.size ();
   }
 
   /*!
      Reserve the requested size for the new element map
    */
-  void reserve(std::size_t n) {
-    return this->map.reserve(n);
+  void reserve (std::size_t n) {
+    return this->map.reserve (n);
   }
 
   /*!
      Return a copy of the new element array
    */
-  const std::vector<T>& getArray() {
-    this->vec.resize(this->map.size());
-    for (const auto& entry : map) {
+  const std::vector<T> &getArray () {
+    this->vec.resize (this->map.size ());
+    for (const auto &entry : map) {
       this->vec[entry.second] = entry.first;
     }
     return this->vec;
@@ -57,9 +58,10 @@ public:
   /*!
      Copies the internal vector to the given destination
    */
-  template <class OutputIterator> void copy(OutputIterator dest) {
-    this->getArray();
-    std::copy(this->vec.begin(), this->vec.end(), dest);
+  template <class OutputIterator>
+  void copy (OutputIterator dest) {
+    this->getArray ();
+    std::copy (this->vec.begin (), this->vec.end (), dest);
   }
 
 private:
diff --git a/src/geometry/boolean_utils.cc b/src/geometry/boolean_utils.cc
index 0b34760f9..352a5f480 100644
--- a/src/geometry/boolean_utils.cc
+++ b/src/geometry/boolean_utils.cc
@@ -9,11 +9,11 @@
 #include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
 #include <CGAL/convex_hull_3.h>
 #include "geometry/cgal/cgalutils.h"
-#endif  // ENABLE_CGAL
+#endif // ENABLE_CGAL
 #ifdef ENABLE_MANIFOLD
 #include "geometry/manifold/ManifoldGeometry.h"
 #include "geometry/manifold/manifoldutils.h"
-#endif  // ENABLE_MANIFOLD
+#endif // ENABLE_MANIFOLD
 
 #include "glview/RenderSettings.h"
 #include "geometry/PolySet.h"
@@ -23,92 +23,89 @@
 #include "geometry/GeometryUtils.h"
 
 #ifdef ENABLE_CGAL
-std::unique_ptr<PolySet> applyHull(const Geometry::Geometries& children)
-{
+std::unique_ptr<PolySet> applyHull (const Geometry::Geometries &children) {
   using Hull_kernel = CGAL::Epick;
   // Collect point cloud
   Reindexer<Hull_kernel::Point_3> reindexer;
 
-  auto addCapacity = [&](const auto n) {
-      reindexer.reserve(reindexer.size() + n);
-    };
+  auto addCapacity = [&] (const auto n) {
+    reindexer.reserve (reindexer.size () + n);
+  };
 
-  auto addPoint = [&](const auto& v) {
-      reindexer.lookup(v);
-    };
+  auto addPoint = [&] (const auto &v) {
+    reindexer.lookup (v);
+  };
 
-  for (const auto& item : children) {
-    auto& chgeom = item.second;
+  for (const auto &item : children) {
+    auto &chgeom = item.second;
 #ifdef ENABLE_CGAL
-    if (const auto *N = dynamic_cast<const CGALNefGeometry *>(chgeom.get())) {
-      if (!N->isEmpty()) {
-        addCapacity(N->p3->number_of_vertices());
-        for (auto it = N->p3->vertices_begin(); it != N->p3->vertices_end(); ++it) {
-          addPoint(CGALUtils::vector_convert<Hull_kernel::Point_3>(it->point()));
+    if (const auto *N = dynamic_cast<const CGALNefGeometry *> (chgeom.get ())) {
+      if (!N->isEmpty ()) {
+        addCapacity (N->p3->number_of_vertices ());
+        for (auto it = N->p3->vertices_begin (); it != N->p3->vertices_end (); ++it) {
+          addPoint (CGALUtils::vector_convert<Hull_kernel::Point_3> (it->point ()));
         }
       }
-#endif  // ENABLE_CGAL
+#endif // ENABLE_CGAL
 #ifdef ENABLE_MANIFOLD
-  } else if (const auto *mani = dynamic_cast<const ManifoldGeometry *>(chgeom.get())) {
-    addCapacity(mani->numVertices());
-    mani->foreachVertexUntilTrue([&](auto& p) {
-      addPoint(CGALUtils::vector_convert<Hull_kernel::Point_3>(p));
-      return false;
-    });
-#endif  // ENABLE_MANIFOLD
-  } else if (const auto *ps = dynamic_cast<const PolySet *>(chgeom.get())) {
-    addCapacity(ps->indices.size() * 3);
-    for (const auto& p : ps->indices) {
-      for (const auto& ind : p) {
-        addPoint(CGALUtils::vector_convert<Hull_kernel::Point_3>(ps->vertices[ind]));
+    } else if (const auto *mani = dynamic_cast<const ManifoldGeometry *> (chgeom.get ())) {
+      addCapacity (mani->numVertices ());
+      mani->foreachVertexUntilTrue ([&] (auto &p) {
+        addPoint (CGALUtils::vector_convert<Hull_kernel::Point_3> (p));
+        return false;
+      });
+#endif // ENABLE_MANIFOLD
+    } else if (const auto *ps = dynamic_cast<const PolySet *> (chgeom.get ())) {
+      addCapacity (ps->indices.size () * 3);
+      for (const auto &p : ps->indices) {
+        for (const auto &ind : p) {
+          addPoint (CGALUtils::vector_convert<Hull_kernel::Point_3> (ps->vertices[ind]));
+        }
       }
     }
   }
-}
 
-const auto& points = reindexer.getArray();
-if (points.size() <= 3) return nullptr;
+  const auto &points = reindexer.getArray ();
+  if (points.size () <= 3)
+    return nullptr;
 
-// Apply hull
-if (points.size() >= 4) {
-  try {
-    CGAL::Polyhedron_3<Hull_kernel> r;
-    CGAL::convex_hull_3(points.begin(), points.end(), r);
-    PRINTDB("After hull vertices: %d", r.size_of_vertices());
-    PRINTDB("After hull facets: %d", r.size_of_facets());
-    PRINTDB("After hull closed: %d", r.is_closed());
-    PRINTDB("After hull valid: %d", r.is_valid());
-    // FIXME: Make sure PolySet is set to convex.
-    // FIXME: Can we guarantee a manifold PolySet here?
-    return CGALUtils::createPolySetFromPolyhedron(r);
-  } catch (const CGAL::Failure_exception& e) {
-    LOG(message_group::Error, "CGAL error in applyHull(): %1$s", e.what());
+  // Apply hull
+  if (points.size () >= 4) {
+    try {
+      CGAL::Polyhedron_3<Hull_kernel> r;
+      CGAL::convex_hull_3 (points.begin (), points.end (), r);
+      PRINTDB ("After hull vertices: %d", r.size_of_vertices ());
+      PRINTDB ("After hull facets: %d", r.size_of_facets ());
+      PRINTDB ("After hull closed: %d", r.is_closed ());
+      PRINTDB ("After hull valid: %d", r.is_valid ());
+      // FIXME: Make sure PolySet is set to convex.
+      // FIXME: Can we guarantee a manifold PolySet here?
+      return CGALUtils::createPolySetFromPolyhedron (r);
+    } catch (const CGAL::Failure_exception &e) {
+      LOG (message_group::Error, "CGAL error in applyHull(): %1$s", e.what ());
+    }
   }
-}
-return nullptr;
+  return nullptr;
 
-/*!
+  /*!
    children cannot contain nullptr objects
 
    FIXME: This shouldn't return const, but it does due to internal implementation details
  */
-std::shared_ptr<const Geometry> applyMinkowski(const Geometry::Geometries& children)
-{
+  std::shared_ptr<const Geometry> applyMinkowski (const Geometry::Geometries &children) {
 #if ENABLE_MANIFOLD
-  if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
-    return ManifoldUtils::applyMinkowski(children);
+    if (RenderSettings::inst ()->backend3D == RenderBackend3D::ManifoldBackend) {
+      return ManifoldUtils::applyMinkowski (children);
+    }
+#endif // ENABLE_MANIFOLD
+    return CGALUtils::applyMinkowski3D (children);
   }
-#endif  // ENABLE_MANIFOLD
-  return CGALUtils::applyMinkowski3D(children);
-}
-#else  // ENABLE_CGAL
-std::unique_ptr<PolySet> applyHull(const Geometry::Geometries& children)
-{
-  return std::make_unique<PolySet>(3, true);
+#else // ENABLE_CGAL
+std::unique_ptr<PolySet> applyHull (const Geometry::Geometries &children) {
+  return std::make_unique<PolySet> (3, true);
 }
 
-std::shared_ptr<const Geometry> applyMinkowski(const Geometry::Geometries& children)
-{
-  return std::make_shared<PolySet>(3);
+std::shared_ptr<const Geometry> applyMinkowski (const Geometry::Geometries &children) {
+  return std::make_shared<PolySet> (3);
 }
-#endif  // !ENABLE_CGAL
+#endif // !ENABLE_CGAL
diff --git a/src/geometry/boolean_utils.h b/src/geometry/boolean_utils.h
index 082a23e87..479271400 100644
--- a/src/geometry/boolean_utils.h
+++ b/src/geometry/boolean_utils.h
@@ -4,5 +4,5 @@
 #include "geometry/PolySet.h"
 #include "geometry/Geometry.h"
 
-std::unique_ptr<PolySet> applyHull(const Geometry::Geometries& children);
-std::shared_ptr<const Geometry> applyMinkowski(const Geometry::Geometries& children);
+std::unique_ptr<PolySet> applyHull (const Geometry::Geometries &children);
+std::shared_ptr<const Geometry> applyMinkowski (const Geometry::Geometries &children);
diff --git a/src/geometry/cgal/CGALCache.cc b/src/geometry/cgal/CGALCache.cc
index a5e895a18..c2f6d44b6 100644
--- a/src/geometry/cgal/CGALCache.cc
+++ b/src/geometry/cgal/CGALCache.cc
@@ -16,74 +16,68 @@
 
 CGALCache *CGALCache::inst = nullptr;
 
-CGALCache::CGALCache(size_t limit) : cache(limit)
-{
+CGALCache::CGALCache (size_t limit)
+  : cache (limit) {
 }
 
-std::shared_ptr<const Geometry> CGALCache::get(const std::string& id) const
-{
-  const auto& N = this->cache[id]->N;
+std::shared_ptr<const Geometry> CGALCache::get (const std::string &id) const {
+  const auto &N = this->cache[id]->N;
 #ifdef DEBUG
-  LOG("CGAL Cache hit: %1$s (%2$d bytes)", id.substr(0, 40), N ? N->memsize() : 0);
+  LOG ("CGAL Cache hit: %1$s (%2$d bytes)", id.substr (0, 40), N ? N->memsize () : 0);
 #endif
   return N;
 }
 
-bool CGALCache::acceptsGeometry(const std::shared_ptr<const Geometry>& geom) {
+bool CGALCache::acceptsGeometry (const std::shared_ptr<const Geometry> &geom) {
   return 0
 #ifdef ENABLE_CGAL
-         || std::dynamic_pointer_cast<const CGALNefGeometry>(geom) != nullptr
+         || std::dynamic_pointer_cast<const CGALNefGeometry> (geom) != nullptr
 #endif
 #ifdef ENABLE_MANIFOLD
-         || std::dynamic_pointer_cast<const ManifoldGeometry>(geom) != nullptr
+         || std::dynamic_pointer_cast<const ManifoldGeometry> (geom) != nullptr
 #endif
-  ;
+    ;
 }
 
-bool CGALCache::insert(const std::string& id, const std::shared_ptr<const Geometry>& N)
-{
-  assert(acceptsGeometry(N));
-  auto inserted = this->cache.insert(id, new cache_entry(N), N ? N->memsize() : 0);
+bool CGALCache::insert (const std::string &id, const std::shared_ptr<const Geometry> &N) {
+  assert (acceptsGeometry (N));
+  auto inserted = this->cache.insert (id, new cache_entry (N), N ? N->memsize () : 0);
 #ifdef DEBUG
-  if (inserted) LOG("CGAL Cache insert: %1$s (%2$d bytes)", id.substr(0, 40), (N ? N->memsize() : 0));
-  else LOG("CGAL Cache insert failed: %1$s (%2$d bytes)", id.substr(0, 40), (N ? N->memsize() : 0));
+  if (inserted)
+    LOG ("CGAL Cache insert: %1$s (%2$d bytes)", id.substr (0, 40), (N ? N->memsize () : 0));
+  else
+    LOG ("CGAL Cache insert failed: %1$s (%2$d bytes)", id.substr (0, 40), (N ? N->memsize () : 0));
 #endif
   return inserted;
 }
 
-size_t CGALCache::size() const
-{
-  return cache.size();
+size_t CGALCache::size () const {
+  return cache.size ();
 }
 
-size_t CGALCache::totalCost() const
-{
-  return cache.totalCost();
+size_t CGALCache::totalCost () const {
+  return cache.totalCost ();
 }
 
-size_t CGALCache::maxSizeMB() const
-{
-  return this->cache.maxCost() / (1024ul * 1024ul);
+size_t CGALCache::maxSizeMB () const {
+  return this->cache.maxCost () / (1024ul * 1024ul);
 }
 
-void CGALCache::setMaxSizeMB(size_t limit)
-{
-  this->cache.setMaxCost(limit * 1024ul * 1024ul);
+void CGALCache::setMaxSizeMB (size_t limit) {
+  this->cache.setMaxCost (limit * 1024ul * 1024ul);
 }
 
-void CGALCache::clear()
-{
-  cache.clear();
+void CGALCache::clear () {
+  cache.clear ();
 }
 
-void CGALCache::print()
-{
-  LOG("CGAL Polyhedrons in cache: %1$d", this->cache.size());
-  LOG("CGAL cache size in bytes: %1$d", this->cache.totalCost());
+void CGALCache::print () {
+  LOG ("CGAL Polyhedrons in cache: %1$d", this->cache.size ());
+  LOG ("CGAL cache size in bytes: %1$d", this->cache.totalCost ());
 }
 
-CGALCache::cache_entry::cache_entry(const std::shared_ptr<const Geometry>& N)
-  : N(N)
-{
-  if (print_messages_stack.size() > 0) this->msg = print_messages_stack.back();
+CGALCache::cache_entry::cache_entry (const std::shared_ptr<const Geometry> &N)
+  : N (N) {
+  if (print_messages_stack.size () > 0)
+    this->msg = print_messages_stack.back ();
 }
diff --git a/src/geometry/cgal/CGALCache.h b/src/geometry/cgal/CGALCache.h
index 4653b6663..6ac16a44c 100644
--- a/src/geometry/cgal/CGALCache.h
+++ b/src/geometry/cgal/CGALCache.h
@@ -9,20 +9,26 @@
 class CGALCache
 {
 public:
-  CGALCache(size_t limit = 100ul *1024ul *1024ul);
+  CGALCache (size_t limit = 100ul * 1024ul * 1024ul);
 
-  static CGALCache *instance() { if (!inst) inst = new CGALCache; return inst; }
-  static bool acceptsGeometry(const std::shared_ptr<const Geometry>& geom);
+  static CGALCache *instance () {
+    if (!inst)
+      inst = new CGALCache;
+    return inst;
+  }
+  static bool acceptsGeometry (const std::shared_ptr<const Geometry> &geom);
 
-  bool contains(const std::string& id) const { return this->cache.contains(id); }
-  std::shared_ptr<const Geometry> get(const std::string& id) const;
-  bool insert(const std::string& id, const std::shared_ptr<const Geometry>& N);
-  size_t size() const;
-  size_t totalCost() const;
-  size_t maxSizeMB() const;
-  void setMaxSizeMB(size_t limit);
-  void clear();
-  void print();
+  bool contains (const std::string &id) const {
+    return this->cache.contains (id);
+  }
+  std::shared_ptr<const Geometry> get (const std::string &id) const;
+  bool insert (const std::string &id, const std::shared_ptr<const Geometry> &N);
+  size_t size () const;
+  size_t totalCost () const;
+  size_t maxSizeMB () const;
+  void setMaxSizeMB (size_t limit);
+  void clear ();
+  void print ();
 
 private:
   static CGALCache *inst;
@@ -30,7 +36,7 @@ private:
   struct cache_entry {
     std::shared_ptr<const Geometry> N;
     std::string msg;
-    cache_entry(const std::shared_ptr<const Geometry>& N);
+    cache_entry (const std::shared_ptr<const Geometry> &N);
   };
 
   Cache<std::string, cache_entry> cache;
diff --git a/src/geometry/cgal/CGALNefGeometry.cc b/src/geometry/cgal/CGALNefGeometry.cc
index bc0b17c8f..95c82527a 100644
--- a/src/geometry/cgal/CGALNefGeometry.cc
+++ b/src/geometry/cgal/CGALNefGeometry.cc
@@ -14,105 +14,96 @@
 // Copy constructor only performs shallow copies, so all modifying functions
 // must reset p3 with a new CGAL_Nef_polyhedron3 object, to prevent cache corruption.
 // This is also partly enforced by p3 pointing to a const object.
-CGALNefGeometry::CGALNefGeometry(const CGALNefGeometry& src) : Geometry(src)
-{
-  if (src.p3) this->p3 = src.p3;
+CGALNefGeometry::CGALNefGeometry (const CGALNefGeometry &src)
+  : Geometry (src) {
+  if (src.p3)
+    this->p3 = src.p3;
 }
 
-std::unique_ptr<Geometry> CGALNefGeometry::copy() const
-{
-  return std::make_unique<CGALNefGeometry>(*this);
+std::unique_ptr<Geometry> CGALNefGeometry::copy () const {
+  return std::make_unique<CGALNefGeometry> (*this);
 }
 
-CGALNefGeometry CGALNefGeometry::operator+(const CGALNefGeometry& other) const
-{
-  return {std::make_shared<CGAL_Nef_polyhedron3>((*this->p3) + (*other.p3))};
+CGALNefGeometry CGALNefGeometry::operator+ (const CGALNefGeometry &other) const {
+  return {std::make_shared<CGAL_Nef_polyhedron3> ((*this->p3) + (*other.p3))};
 }
 
-CGALNefGeometry& CGALNefGeometry::operator+=(const CGALNefGeometry& other)
-{
-  this->p3 = std::make_shared<CGAL_Nef_polyhedron3>((*this->p3) + (*other.p3));
+CGALNefGeometry &CGALNefGeometry::operator+= (const CGALNefGeometry &other) {
+  this->p3 = std::make_shared<CGAL_Nef_polyhedron3> ((*this->p3) + (*other.p3));
   return *this;
 }
 
-CGALNefGeometry& CGALNefGeometry::operator*=(const CGALNefGeometry& other)
-{
-  this->p3 = std::make_shared<CGAL_Nef_polyhedron3>((*this->p3) * (*other.p3));
+CGALNefGeometry &CGALNefGeometry::operator*= (const CGALNefGeometry &other) {
+  this->p3 = std::make_shared<CGAL_Nef_polyhedron3> ((*this->p3) * (*other.p3));
   return *this;
 }
 
-CGALNefGeometry& CGALNefGeometry::operator-=(const CGALNefGeometry& other)
-{
-  this->p3 = std::make_shared<CGAL_Nef_polyhedron3>((*this->p3) - (*other.p3));
+CGALNefGeometry &CGALNefGeometry::operator-= (const CGALNefGeometry &other) {
+  this->p3 = std::make_shared<CGAL_Nef_polyhedron3> ((*this->p3) - (*other.p3));
   return *this;
 }
 
 // Note: this is only the fallback method in case of failure in CGALUtils::applyMinkowski (see: cgalutils-applyops.cc)
-CGALNefGeometry& CGALNefGeometry::minkowski(const CGALNefGeometry& other)
-{
+CGALNefGeometry &CGALNefGeometry::minkowski (const CGALNefGeometry &other) {
   // It is required to construct copies of our const input operands here.
   // "Postcondition: If either of the input polyhedra is non-convex, it is modified during the computation,
   //  i.e., it is decomposed into convex pieces."
   // from https://doc.cgal.org/latest/Minkowski_sum_3/group__PkgMinkowskiSum3Ref.html
-  CGAL_Nef_polyhedron3 op1(*this->p3);
-  CGAL_Nef_polyhedron3 op2(*other.p3);
-  this->p3 = std::make_shared<CGAL_Nef_polyhedron3>(CGAL::minkowski_sum_3(op1, op2));
+  CGAL_Nef_polyhedron3 op1 (*this->p3);
+  CGAL_Nef_polyhedron3 op2 (*other.p3);
+  this->p3 = std::make_shared<CGAL_Nef_polyhedron3> (CGAL::minkowski_sum_3 (op1, op2));
   return *this;
 }
 
-size_t CGALNefGeometry::memsize() const
-{
-  if (this->isEmpty()) return 0;
+size_t CGALNefGeometry::memsize () const {
+  if (this->isEmpty ())
+    return 0;
 
-  auto memsize = sizeof(CGALNefGeometry);
-  memsize += const_cast<CGAL_Nef_polyhedron3&>(*this->p3).bytes();
+  auto memsize = sizeof (CGALNefGeometry);
+  memsize += const_cast<CGAL_Nef_polyhedron3 &> (*this->p3).bytes ();
   return memsize;
 }
 
-bool CGALNefGeometry::isEmpty() const
-{
-  return !this->p3 || this->p3->is_empty();
+bool CGALNefGeometry::isEmpty () const {
+  return !this->p3 || this->p3->is_empty ();
 }
 
-BoundingBox CGALNefGeometry::getBoundingBox() const
-{
-  if (isEmpty()) {
+BoundingBox CGALNefGeometry::getBoundingBox () const {
+  if (isEmpty ()) {
     return {};
   }
-  auto bb = CGALUtils::boundingBox(*this->p3).bbox();
+  auto bb = CGALUtils::boundingBox (*this->p3).bbox ();
 
   BoundingBox result;
-  result.extend(Vector3d(bb.xmin(), bb.ymin(), bb.zmin()));
-  result.extend(Vector3d(bb.xmax(), bb.ymax(), bb.zmax()));
+  result.extend (Vector3d (bb.xmin (), bb.ymin (), bb.zmin ()));
+  result.extend (Vector3d (bb.xmax (), bb.ymax (), bb.zmax ()));
   return result;
 }
 
-void CGALNefGeometry::resize(const Vector3d& newsize,
-                             const Eigen::Matrix<bool, 3, 1>& autosize)
-{
+void CGALNefGeometry::resize (const Vector3d &newsize,
+                              const Eigen::Matrix<bool, 3, 1> &autosize) {
   // Based on resize() in Giles Bathgate's RapCAD (but not exactly)
-  if (this->isEmpty()) return;
+  if (this->isEmpty ())
+    return;
 
-  transform(
-    CGALUtils::computeResizeTransform(
-      CGALUtils::boundingBox(*this->p3),
-      getDimension(), newsize, autosize));
+  transform (
+    CGALUtils::computeResizeTransform (
+      CGALUtils::boundingBox (*this->p3),
+      getDimension (), newsize, autosize));
 }
 
-std::string CGALNefGeometry::dump() const
-{
-  return OpenSCAD::dump_svg(*this->p3);
+std::string CGALNefGeometry::dump () const {
+  return OpenSCAD::dump_svg (*this->p3);
 }
 
-void CGALNefGeometry::transform(const Transform3d& matrix)
-{
-  if (!this->isEmpty()) {
-    if (matrix.matrix().determinant() == 0) {
-      LOG(message_group::Warning, "Scaling a 3D object with 0 - removing object");
-      this->reset();
+void CGALNefGeometry::transform (const Transform3d &matrix) {
+  if (!this->isEmpty ()) {
+    if (matrix.matrix ().determinant () == 0) {
+      LOG (message_group::Warning, "Scaling a 3D object with 0 - removing object");
+      this->reset ();
     } else {
-      auto N = std::make_shared<CGAL_Nef_polyhedron3>(*this->p3);
-      CGALUtils::transform(*N, matrix);
+      auto N = std::make_shared<CGAL_Nef_polyhedron3> (*this->p3);
+      CGALUtils::transform (*N, matrix);
       this->p3 = N;
     }
   }
diff --git a/src/geometry/cgal/CGALNefGeometry.h b/src/geometry/cgal/CGALNefGeometry.h
index cdef9c4b8..0ad0fd439 100644
--- a/src/geometry/cgal/CGALNefGeometry.h
+++ b/src/geometry/cgal/CGALNefGeometry.h
@@ -11,33 +11,40 @@
 class CGALNefGeometry : public Geometry
 {
 public:
-  VISITABLE_GEOMETRY();
-  CGALNefGeometry() = default;
-  CGALNefGeometry(std::shared_ptr<const CGAL_Nef_polyhedron3> p) : p3(std::move(p)) {}
-  CGALNefGeometry(const CGALNefGeometry& src);
-  CGALNefGeometry& operator=(const CGALNefGeometry&) = default;
-  CGALNefGeometry(CGALNefGeometry&&) = default;
-  CGALNefGeometry& operator=(CGALNefGeometry&&) = default;
-  ~CGALNefGeometry() override = default;
+  VISITABLE_GEOMETRY ();
+  CGALNefGeometry () = default;
+  CGALNefGeometry (std::shared_ptr<const CGAL_Nef_polyhedron3> p)
+    : p3 (std::move (p)) {}
+  CGALNefGeometry (const CGALNefGeometry &src);
+  CGALNefGeometry &operator= (const CGALNefGeometry &) = default;
+  CGALNefGeometry (CGALNefGeometry &&) = default;
+  CGALNefGeometry &operator= (CGALNefGeometry &&) = default;
+  ~CGALNefGeometry () override = default;
 
-  [[nodiscard]] size_t memsize() const override;
+  [[nodiscard]] size_t memsize () const override;
   // FIXME: Implement, but we probably want a high-resolution BBox..
-  [[nodiscard]] BoundingBox getBoundingBox() const override;
-  [[nodiscard]] std::string dump() const override;
-  [[nodiscard]] unsigned int getDimension() const override { return 3; }
+  [[nodiscard]] BoundingBox getBoundingBox () const override;
+  [[nodiscard]] std::string dump () const override;
+  [[nodiscard]] unsigned int getDimension () const override {
+    return 3;
+  }
   // Empty means it is a geometric node which has zero area/volume
-  [[nodiscard]] bool isEmpty() const override;
-  [[nodiscard]] std::unique_ptr<Geometry> copy() const override;
-  [[nodiscard]] size_t numFacets() const override { return p3->number_of_facets(); }
+  [[nodiscard]] bool isEmpty () const override;
+  [[nodiscard]] std::unique_ptr<Geometry> copy () const override;
+  [[nodiscard]] size_t numFacets () const override {
+    return p3->number_of_facets ();
+  }
 
-  void reset() { p3.reset(); }
-  CGALNefGeometry operator+(const CGALNefGeometry& other) const;
-  CGALNefGeometry& operator+=(const CGALNefGeometry& other);
-  CGALNefGeometry& operator*=(const CGALNefGeometry& other);
-  CGALNefGeometry& operator-=(const CGALNefGeometry& other);
-  CGALNefGeometry& minkowski(const CGALNefGeometry& other);
-  void transform(const Transform3d& matrix) override;
-  void resize(const Vector3d& newsize, const Eigen::Matrix<bool, 3, 1>& autosize) override;
+  void reset () {
+    p3.reset ();
+  }
+  CGALNefGeometry operator+ (const CGALNefGeometry &other) const;
+  CGALNefGeometry &operator+= (const CGALNefGeometry &other);
+  CGALNefGeometry &operator*= (const CGALNefGeometry &other);
+  CGALNefGeometry &operator-= (const CGALNefGeometry &other);
+  CGALNefGeometry &minkowski (const CGALNefGeometry &other);
+  void transform (const Transform3d &matrix) override;
+  void resize (const Vector3d &newsize, const Eigen::Matrix<bool, 3, 1> &autosize) override;
 
   std::shared_ptr<const CGAL_Nef_polyhedron3> p3;
 };
diff --git a/src/geometry/cgal/Polygon2d-CGAL.h b/src/geometry/cgal/Polygon2d-CGAL.h
index 42edd83fc..11fcc3555 100644
--- a/src/geometry/cgal/Polygon2d-CGAL.h
+++ b/src/geometry/cgal/Polygon2d-CGAL.h
@@ -3,5 +3,5 @@
 #include "geometry/cgal/CGALNefGeometry.h"
 
 namespace Polygon2DCGAL {
-CGALNefGeometry toNefPolyhedron();
+CGALNefGeometry toNefPolyhedron ();
 }
diff --git a/src/geometry/cgal/cgalutils-applyops-minkowski.cc b/src/geometry/cgal/cgalutils-applyops-minkowski.cc
index 6d73a14d2..47f5f4606 100644
--- a/src/geometry/cgal/cgalutils-applyops-minkowski.cc
+++ b/src/geometry/cgal/cgalutils-applyops-minkowski.cc
@@ -9,18 +9,17 @@
 
 namespace CGALUtils {
 
-std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& children)
-{
-  assert(children.size() >= 2);
+std::shared_ptr<const Geometry> applyMinkowski3D (const Geometry::Geometries &children) {
+  assert (children.size () >= 2);
 
   CGAL::Timer t;
   CGAL::Timer t_tot;
-  t_tot.start();
+  t_tot.start ();
 
-  auto it = children.begin();
-  std::shared_ptr<const Geometry> operands[2] = {it->second, std::shared_ptr<const Geometry>()};
+  auto it = children.begin ();
+  std::shared_ptr<const Geometry> operands[2] = {it->second, std::shared_ptr<const Geometry> ()};
   try {
-    while (++it != children.end()) {
+    while (++it != children.end ()) {
       operands[1] = it->second;
 
       using Hull_kernel = CGAL::Epick;
@@ -31,49 +30,52 @@ std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& chi
       for (size_t i = 0; i < 2; ++i) {
         CGAL_Polyhedron poly;
 
-        auto ps = std::dynamic_pointer_cast<const PolySet>(operands[i]);
-        auto nef = std::dynamic_pointer_cast<const CGALNefGeometry>(operands[i]);
+        auto ps = std::dynamic_pointer_cast<const PolySet> (operands[i]);
+        auto nef = std::dynamic_pointer_cast<const CGALNefGeometry> (operands[i]);
 
         if (!nef) {
-          nef = CGALUtils::getNefPolyhedronFromGeometry(operands[i]);
+          nef = CGALUtils::getNefPolyhedronFromGeometry (operands[i]);
         }
 
-        if (ps) CGALUtils::createPolyhedronFromPolySet(*ps, poly);
-        else if (nef && nef->p3->is_simple()) CGALUtils::convertNefToPolyhedron(*nef->p3, poly);
-        else throw 0;
-
-        if ((ps && ps->isConvex()) ||
-            (!ps && CGALUtils::is_weakly_convex(poly))) {
-          PRINTDB("Minkowski: child %d is convex and %s", i % (ps?"PolySet":"Nef"));
-          P[i].push_back(poly);
+        if (ps)
+          CGALUtils::createPolyhedronFromPolySet (*ps, poly);
+        else if (nef && nef->p3->is_simple ())
+          CGALUtils::convertNefToPolyhedron (*nef->p3, poly);
+        else
+          throw 0;
+
+        if ((ps && ps->isConvex ()) ||
+            (!ps && CGALUtils::is_weakly_convex (poly))) {
+          PRINTDB ("Minkowski: child %d is convex and %s", i % (ps ? "PolySet" : "Nef"));
+          P[i].push_back (poly);
         } else {
           CGAL_Nef_polyhedron3 decomposed_nef;
 
           if (ps) {
-            PRINTDB("Minkowski: child %d is nonconvex PolySet, transforming to Nef and decomposing...", i);
-            auto p = CGALUtils::getNefPolyhedronFromGeometry(ps);
-            if (p && !p->isEmpty()) decomposed_nef = *p->p3;
+            PRINTDB ("Minkowski: child %d is nonconvex PolySet, transforming to Nef and decomposing...", i);
+            auto p = CGALUtils::getNefPolyhedronFromGeometry (ps);
+            if (p && !p->isEmpty ())
+              decomposed_nef = *p->p3;
           } else {
-            PRINTDB("Minkowski: child %d is nonconvex Nef, decomposing...", i);
+            PRINTDB ("Minkowski: child %d is nonconvex Nef, decomposing...", i);
             decomposed_nef = *nef->p3;
           }
 
-          t.start();
-          CGAL::convex_decomposition_3(decomposed_nef);
+          t.start ();
+          CGAL::convex_decomposition_3 (decomposed_nef);
 
           // the first volume is the outer volume, which ignored in the decomposition
-          for (auto ci = ++decomposed_nef.volumes_begin(); ci != decomposed_nef.volumes_end(); ++ci) {
-            if (ci->mark()) {
+          for (auto ci = ++decomposed_nef.volumes_begin (); ci != decomposed_nef.volumes_end (); ++ci) {
+            if (ci->mark ()) {
               CGAL_Polyhedron poly;
-              decomposed_nef.convert_inner_shell_to_polyhedron(ci->shells_begin(), poly);
-              P[i].push_back(poly);
+              decomposed_nef.convert_inner_shell_to_polyhedron (ci->shells_begin (), poly);
+              P[i].push_back (poly);
             }
           }
 
-
-          PRINTDB("Minkowski: decomposed into %d convex parts", P[i].size());
-          t.stop();
-          PRINTDB("Minkowski: decomposition took %f s", t.time());
+          PRINTDB ("Minkowski: decomposed into %d convex parts", P[i].size ());
+          t.stop ();
+          PRINTDB ("Minkowski: decomposition took %f s", t.time ());
         }
       }
 
@@ -82,135 +84,136 @@ std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& chi
 
       CGAL::Cartesian_converter<CGAL_Kernel3, Hull_kernel> conv;
 
-      for (size_t i = 0; i < P[0].size(); ++i) {
-        for (size_t j = 0; j < P[1].size(); ++j) {
-          t.start();
-          points[0].clear();
-          points[1].clear();
+      for (size_t i = 0; i < P[0].size (); ++i) {
+        for (size_t j = 0; j < P[1].size (); ++j) {
+          t.start ();
+          points[0].clear ();
+          points[1].clear ();
 
           for (int k = 0; k < 2; ++k) {
-            auto it = P[k].begin();
-            std::advance(it, k == 0?i:j);
+            auto it = P[k].begin ();
+            std::advance (it, k == 0 ? i : j);
 
-            CGAL_Polyhedron const& poly = *it;
-            points[k].reserve(poly.size_of_vertices());
+            CGAL_Polyhedron const &poly = *it;
+            points[k].reserve (poly.size_of_vertices ());
 
-            for (CGAL_Polyhedron::Vertex_const_iterator pi = poly.vertices_begin(); pi != poly.vertices_end(); ++pi) {
-              CGAL_Polyhedron::Point_3 const& p = pi->point();
-              points[k].push_back(conv(p));
+            for (CGAL_Polyhedron::Vertex_const_iterator pi = poly.vertices_begin (); pi != poly.vertices_end (); ++pi) {
+              CGAL_Polyhedron::Point_3 const &p = pi->point ();
+              points[k].push_back (conv (p));
             }
           }
 
-          minkowski_points.clear();
-          minkowski_points.reserve(points[0].size() * points[1].size());
-          for (size_t i = 0; i < points[0].size(); ++i) {
-            for (size_t j = 0; j < points[1].size(); ++j) {
-              minkowski_points.push_back(points[0][i] + (points[1][j] - CGAL::ORIGIN));
+          minkowski_points.clear ();
+          minkowski_points.reserve (points[0].size () * points[1].size ());
+          for (size_t i = 0; i < points[0].size (); ++i) {
+            for (size_t j = 0; j < points[1].size (); ++j) {
+              minkowski_points.push_back (points[0][i] + (points[1][j] - CGAL::ORIGIN));
             }
           }
 
-          if (minkowski_points.size() <= 3) {
-            t.stop();
+          if (minkowski_points.size () <= 3) {
+            t.stop ();
             continue;
           }
 
           CGAL::Polyhedron_3<Hull_kernel> result;
-          t.stop();
-          PRINTDB("Minkowski: Point cloud creation (%d  %d -> %d) took %f ms", points[0].size() % points[1].size() % minkowski_points.size() % (t.time() * 1000));
-          t.reset();
+          t.stop ();
+          PRINTDB ("Minkowski: Point cloud creation (%d  %d -> %d) took %f ms", points[0].size () % points[1].size () % minkowski_points.size () % (t.time () * 1000));
+          t.reset ();
 
-          t.start();
+          t.start ();
 
-          CGAL::convex_hull_3(minkowski_points.begin(), minkowski_points.end(), result);
+          CGAL::convex_hull_3 (minkowski_points.begin (), minkowski_points.end (), result);
 
           std::vector<Hull_kernel::Point_3> strict_points;
-          strict_points.reserve(minkowski_points.size());
+          strict_points.reserve (minkowski_points.size ());
 
-          for (CGAL::Polyhedron_3<Hull_kernel>::Vertex_iterator i = result.vertices_begin(); i != result.vertices_end(); ++i) {
-            Hull_kernel::Point_3 const& p = i->point();
+          for (CGAL::Polyhedron_3<Hull_kernel>::Vertex_iterator i = result.vertices_begin (); i != result.vertices_end (); ++i) {
+            Hull_kernel::Point_3 const &p = i->point ();
 
             CGAL::Polyhedron_3<Hull_kernel>::Vertex::Halfedge_handle h, e;
-            h = i->halfedge();
+            h = i->halfedge ();
             e = h;
             bool collinear = false;
             bool coplanar = true;
 
             do {
-              Hull_kernel::Point_3 const& q = h->opposite()->vertex()->point();
-              if (coplanar && !CGAL::coplanar(p, q,
-                                              h->next_on_vertex()->opposite()->vertex()->point(),
-                                              h->next_on_vertex()->next_on_vertex()->opposite()->vertex()->point())) {
+              Hull_kernel::Point_3 const &q = h->opposite ()->vertex ()->point ();
+              if (coplanar && !CGAL::coplanar (p, q,
+                                               h->next_on_vertex ()->opposite ()->vertex ()->point (),
+                                               h->next_on_vertex ()->next_on_vertex ()->opposite ()->vertex ()->point ())) {
                 coplanar = false;
               }
 
-
-              for (CGAL::Polyhedron_3<Hull_kernel>::Vertex::Halfedge_handle j = h->next_on_vertex();
+              for (CGAL::Polyhedron_3<Hull_kernel>::Vertex::Halfedge_handle j = h->next_on_vertex ();
                    j != h && !collinear && !coplanar;
-                   j = j->next_on_vertex()) {
+                   j = j->next_on_vertex ()) {
 
-                Hull_kernel::Point_3 const& r = j->opposite()->vertex()->point();
-                if (CGAL::collinear(p, q, r)) {
+                Hull_kernel::Point_3 const &r = j->opposite ()->vertex ()->point ();
+                if (CGAL::collinear (p, q, r)) {
                   collinear = true;
                 }
               }
 
-              h = h->next_on_vertex();
+              h = h->next_on_vertex ();
             } while (h != e && !collinear);
 
-            if (!collinear && !coplanar) strict_points.push_back(p);
+            if (!collinear && !coplanar)
+              strict_points.push_back (p);
           }
 
-          result.clear();
-          CGAL::convex_hull_3(strict_points.begin(), strict_points.end(), result);
-
+          result.clear ();
+          CGAL::convex_hull_3 (strict_points.begin (), strict_points.end (), result);
 
-          t.stop();
-          PRINTDB("Minkowski: Computing convex hull took %f s", t.time());
-          t.reset();
+          t.stop ();
+          PRINTDB ("Minkowski: Computing convex hull took %f s", t.time ());
+          t.reset ();
 
-          result_parts.push_back(result);
+          result_parts.push_back (result);
         }
       }
 
-      if (it != std::next(children.begin())) operands[0].reset();
+      if (it != std::next (children.begin ()))
+        operands[0].reset ();
 
-      auto partToGeom = [&](auto& poly) -> std::shared_ptr<const Geometry> {
-          return CGALUtils::createPolySetFromPolyhedron(poly);
-        };
+      auto partToGeom = [&] (auto &poly) -> std::shared_ptr<const Geometry> {
+        return CGALUtils::createPolySetFromPolyhedron (poly);
+      };
 
-      if (result_parts.size() == 1) {
-        operands[0] = partToGeom(*result_parts.begin());
-      } else if (!result_parts.empty()) {
-        t.start();
-        PRINTDB("Minkowski: Computing union of %d parts", result_parts.size());
+      if (result_parts.size () == 1) {
+        operands[0] = partToGeom (*result_parts.begin ());
+      } else if (!result_parts.empty ()) {
+        t.start ();
+        PRINTDB ("Minkowski: Computing union of %d parts", result_parts.size ());
         Geometry::Geometries fake_children;
-        for (const auto& part : result_parts) {
-          fake_children.emplace_back(std::shared_ptr<const AbstractNode>(), partToGeom(part));
+        for (const auto &part : result_parts) {
+          fake_children.emplace_back (std::shared_ptr<const AbstractNode> (), partToGeom (part));
         }
-        auto N = CGALUtils::applyUnion3D(fake_children.begin(), fake_children.end());
+        auto N = CGALUtils::applyUnion3D (fake_children.begin (), fake_children.end ());
         // FIXME: This should really never throw.
         // Assert once we figured out what went wrong with issue #1069?
-        if (!N) throw 0;
-        t.stop();
-        PRINTDB("Minkowski: Union done: %f s", t.time());
-        t.reset();
-        operands[0] = std::move(N);
+        if (!N)
+          throw 0;
+        t.stop ();
+        PRINTDB ("Minkowski: Union done: %f s", t.time ());
+        t.reset ();
+        operands[0] = std::move (N);
       } else {
-        operands[0] = std::make_shared<CGALNefGeometry>();
+        operands[0] = std::make_shared<CGALNefGeometry> ();
       }
     }
 
-    t_tot.stop();
-    PRINTDB("Minkowski: Total execution time %f s", t_tot.time());
-    t_tot.reset();
+    t_tot.stop ();
+    PRINTDB ("Minkowski: Total execution time %f s", t_tot.time ());
+    t_tot.reset ();
     return operands[0];
   } catch (...) {
     // If anything throws we simply fall back to Nef Minkowski
-    PRINTD("Minkowski: Falling back to Nef Minkowski");
+    PRINTD ("Minkowski: Falling back to Nef Minkowski");
 
-    auto N = std::shared_ptr<const Geometry>(CGALUtils::applyOperator3D(children, OpenSCADOperator::MINKOWSKI));
+    auto N = std::shared_ptr<const Geometry> (CGALUtils::applyOperator3D (children, OpenSCADOperator::MINKOWSKI));
     return N;
   }
 }
 
-}  // namespace CGALUtils
\ No newline at end of file
+} // namespace CGALUtils
\ No newline at end of file
diff --git a/src/geometry/cgal/cgalutils-applyops.cc b/src/geometry/cgal/cgalutils-applyops.cc
index 67c3aefdd..52ebb63cf 100644
--- a/src/geometry/cgal/cgalutils-applyops.cc
+++ b/src/geometry/cgal/cgalutils-applyops.cc
@@ -35,16 +35,14 @@
 
 namespace CGALUtils {
 
-std::unique_ptr<const Geometry> applyUnion3D(
-  Geometry::Geometries::iterator chbegin, Geometry::Geometries::iterator chend)
-{
+std::unique_ptr<const Geometry> applyUnion3D (
+  Geometry::Geometries::iterator chbegin, Geometry::Geometries::iterator chend) {
   using QueueConstItem = std::pair<std::shared_ptr<const CGALNefGeometry>, int>;
   struct QueueItemGreater {
     // stable sort for priority_queue by facets, then progress mark
-    bool operator()(const QueueConstItem& lhs, const QueueConstItem& rhs) const
-    {
-      size_t l = lhs.first->p3->number_of_facets();
-      size_t r = rhs.first->p3->number_of_facets();
+    bool operator() (const QueueConstItem &lhs, const QueueConstItem &rhs) const {
+      size_t l = lhs.first->p3->number_of_facets ();
+      size_t r = rhs.first->p3->number_of_facets ();
       return (l > r) || (l == r && lhs.second > rhs.second);
     }
   };
@@ -53,33 +51,33 @@ std::unique_ptr<const Geometry> applyUnion3D(
   try {
     // sort children by fewest faces
     for (auto it = chbegin; it != chend; ++it) {
-      auto curChild = getNefPolyhedronFromGeometry(it->second);
-      if (curChild && !curChild->isEmpty()) {
+      auto curChild = getNefPolyhedronFromGeometry (it->second);
+      if (curChild && !curChild->isEmpty ()) {
         int node_mark = -1;
         if (it->first) {
           node_mark = it->first->progress_mark;
         }
-        q.emplace(curChild, node_mark);
+        q.emplace (curChild, node_mark);
       }
     }
 
-    progress_tick();
-    while (q.size() > 1) {
-      auto p1 = q.top();
-      q.pop();
-      auto p2 = q.top();
-      q.pop();
-      q.emplace(std::make_unique<const CGALNefGeometry>(*p1.first + *p2.first), -1);
-      progress_tick();
+    progress_tick ();
+    while (q.size () > 1) {
+      auto p1 = q.top ();
+      q.pop ();
+      auto p2 = q.top ();
+      q.pop ();
+      q.emplace (std::make_unique<const CGALNefGeometry> (*p1.first + *p2.first), -1);
+      progress_tick ();
     }
 
-    if (q.size() == 1) {
-      return std::make_unique<CGALNefGeometry>(q.top().first->p3);
+    if (q.size () == 1) {
+      return std::make_unique<CGALNefGeometry> (q.top ().first->p3);
     } else {
       return nullptr;
     }
-  } catch (const CGAL::Failure_exception& e) {
-    LOG(message_group::Error, "CGAL error in CGALUtils::applyUnion3D: %1$s", e.what());
+  } catch (const CGAL::Failure_exception &e) {
+    LOG (message_group::Error, "CGAL error in CGALUtils::applyUnion3D: %1$s", e.what ());
   }
   return nullptr;
 }
@@ -88,23 +86,22 @@ std::unique_ptr<const Geometry> applyUnion3D(
    Applies op to all children and returns the result.
    The child list should be guaranteed to contain non-NULL 3D or empty Geometry objects
  */
-std::shared_ptr<const Geometry> applyOperator3D(const Geometry::Geometries& children, OpenSCADOperator op)
-{
+std::shared_ptr<const Geometry> applyOperator3D (const Geometry::Geometries &children, OpenSCADOperator op) {
   std::shared_ptr<CGALNefGeometry> N;
 
-  assert(op != OpenSCADOperator::UNION && "use applyUnion3D() instead of applyOperator3D()");
+  assert (op != OpenSCADOperator::UNION && "use applyUnion3D() instead of applyOperator3D()");
   bool foundFirst = false;
 
   try {
-    for (const auto& item : children) {
-      const std::shared_ptr<const Geometry>& chgeom = item.second;
-      auto chN = getNefPolyhedronFromGeometry(chgeom);
+    for (const auto &item : children) {
+      const std::shared_ptr<const Geometry> &chgeom = item.second;
+      auto chN = getNefPolyhedronFromGeometry (chgeom);
 
       // Initialize N with first expected geometric object
       if (!foundFirst) {
         if (chN) {
           // FIXME: Do we need to make a copy here?
-          N = std::make_shared<CGALNefGeometry>(*chN);
+          N = std::make_shared<CGALNefGeometry> (*chN);
         } else { // first child geometry might be empty/null
           N = nullptr;
         }
@@ -113,7 +110,7 @@ std::shared_ptr<const Geometry> applyOperator3D(const Geometry::Geometries& chil
       }
 
       // Intersecting something with nothing results in nothing
-      if (!chN || chN->isEmpty()) {
+      if (!chN || chN->isEmpty ()) {
         if (op == OpenSCADOperator::INTERSECTION) {
           N = nullptr;
         }
@@ -121,7 +118,8 @@ std::shared_ptr<const Geometry> applyOperator3D(const Geometry::Geometries& chil
       }
 
       // empty op <something> => empty
-      if (!N || N->isEmpty()) continue;
+      if (!N || N->isEmpty ())
+        continue;
 
       switch (op) {
       case OpenSCADOperator::INTERSECTION:
@@ -131,25 +129,30 @@ std::shared_ptr<const Geometry> applyOperator3D(const Geometry::Geometries& chil
         *N -= *chN;
         break;
       case OpenSCADOperator::MINKOWSKI:
-        N->minkowski(*chN);
+        N->minkowski (*chN);
         break;
       default:
-        LOG(message_group::Error, "Unsupported CGAL operator: %1$d", static_cast<int>(op));
+        LOG (message_group::Error, "Unsupported CGAL operator: %1$d", static_cast<int> (op));
       }
-      if (item.first) item.first->progress_report();
+      if (item.first)
+        item.first->progress_report ();
     }
   }
   // union && difference assert triggered by tests/data/scad/bugs/rotate-diff-nonmanifold-crash.scad and tests/data/scad/bugs/issue204.scad
-  catch (const CGAL::Failure_exception& e) {
-    std::string opstr = op == OpenSCADOperator::INTERSECTION ? "intersection" : op == OpenSCADOperator::DIFFERENCE ? "difference" : op == OpenSCADOperator::UNION ? "union" : "UNKNOWN";
-    LOG(message_group::Error, "CGAL error in CGALUtils::applyOperator3D %1$s: %2$s", opstr, e.what());
+  catch (const CGAL::Failure_exception &e) {
+    std::string opstr = op == OpenSCADOperator::INTERSECTION ? "intersection" : op == OpenSCADOperator::DIFFERENCE ? "difference"
+                                                                              : op == OpenSCADOperator::UNION      ? "union"
+                                                                                                                   : "UNKNOWN";
+    LOG (message_group::Error, "CGAL error in CGALUtils::applyOperator3D %1$s: %2$s", opstr, e.what ());
   }
   // boost any_cast throws exceptions inside CGAL code, ending here https://github.com/openscad/openscad/issues/3756
-  catch (const std::exception& e) {
-    std::string opstr = op == OpenSCADOperator::INTERSECTION ? "intersection" : op == OpenSCADOperator::DIFFERENCE ? "difference" : op == OpenSCADOperator::UNION ? "union" : "UNKNOWN";
-    LOG(message_group::Error, "exception in CGALUtils::applyOperator3D %1$s: %2$s", opstr, e.what());
+  catch (const std::exception &e) {
+    std::string opstr = op == OpenSCADOperator::INTERSECTION ? "intersection" : op == OpenSCADOperator::DIFFERENCE ? "difference"
+                                                                              : op == OpenSCADOperator::UNION      ? "union"
+                                                                                                                   : "UNKNOWN";
+    LOG (message_group::Error, "exception in CGALUtils::applyOperator3D %1$s: %2$s", opstr, e.what ());
   }
   return N;
 }
 
-}  // namespace CGALUtils
+} // namespace CGALUtils
diff --git a/src/geometry/cgal/cgalutils-closed.cc b/src/geometry/cgal/cgalutils-closed.cc
index 71a5815c2..8f59795f9 100644
--- a/src/geometry/cgal/cgalutils-closed.cc
+++ b/src/geometry/cgal/cgalutils-closed.cc
@@ -7,12 +7,10 @@
 namespace CGALUtils {
 
 template <typename Polyhedron>
-bool isClosed(const Polyhedron& p)
-{
-  return CGAL::is_closed(p);
+bool isClosed (const Polyhedron &p) {
+  return CGAL::is_closed (p);
 }
 
-template bool isClosed(const CGAL_DoubleMesh& p);
+template bool isClosed (const CGAL_DoubleMesh &p);
 
 } // namespace CGALUtils
-
diff --git a/src/geometry/cgal/cgalutils-convex.cc b/src/geometry/cgal/cgalutils-convex.cc
index 01329daf0..b7435473a 100644
--- a/src/geometry/cgal/cgalutils-convex.cc
+++ b/src/geometry/cgal/cgalutils-convex.cc
@@ -10,88 +10,88 @@
 namespace CGALUtils {
 
 template <typename K>
-bool is_weakly_convex(const CGAL::Polyhedron_3<K>& p) {
+bool is_weakly_convex (const CGAL::Polyhedron_3<K> &p) {
   using Polyhedron = typename CGAL::Polyhedron_3<K>;
 
-  for (typename Polyhedron::Edge_const_iterator i = p.edges_begin(); i != p.edges_end(); ++i) {
-    typename Polyhedron::Plane_3 p(i->opposite()->vertex()->point(), i->vertex()->point(), i->next()->vertex()->point());
-    if (p.has_on_positive_side(i->opposite()->next()->vertex()->point()) &&
-        CGAL::squared_distance(p, i->opposite()->next()->vertex()->point()) > 1e-8) {
+  for (typename Polyhedron::Edge_const_iterator i = p.edges_begin (); i != p.edges_end (); ++i) {
+    typename Polyhedron::Plane_3 p (i->opposite ()->vertex ()->point (), i->vertex ()->point (), i->next ()->vertex ()->point ());
+    if (p.has_on_positive_side (i->opposite ()->next ()->vertex ()->point ()) &&
+        CGAL::squared_distance (p, i->opposite ()->next ()->vertex ()->point ()) > 1e-8) {
       return false;
     }
   }
   // Also make sure that there is only one shell:
   std::unordered_set<typename Polyhedron::Facet_const_handle, typename CGAL::Handle_hash_function> visited;
   // c++11
-  visited.reserve(p.size_of_facets());
+  visited.reserve (p.size_of_facets ());
 
   std::queue<typename Polyhedron::Facet_const_handle> to_explore;
-  to_explore.push(p.facets_begin()); // One arbitrary facet
-  visited.insert(to_explore.front());
+  to_explore.push (p.facets_begin ()); // One arbitrary facet
+  visited.insert (to_explore.front ());
 
-  while (!to_explore.empty()) {
-    typename Polyhedron::Facet_const_handle f = to_explore.front();
-    to_explore.pop();
+  while (!to_explore.empty ()) {
+    typename Polyhedron::Facet_const_handle f = to_explore.front ();
+    to_explore.pop ();
     typename Polyhedron::Facet::Halfedge_around_facet_const_circulator he, end;
-    end = he = f->facet_begin();
-    CGAL_For_all(he, end) {
-      typename Polyhedron::Facet_const_handle o = he->opposite()->facet();
+    end = he = f->facet_begin ();
+    CGAL_For_all (he, end) {
+      typename Polyhedron::Facet_const_handle o = he->opposite ()->facet ();
 
-      if (!visited.count(o)) {
-        visited.insert(o);
-        to_explore.push(o);
+      if (!visited.count (o)) {
+        visited.insert (o);
+        to_explore.push (o);
       }
     }
   }
 
-  return visited.size() == p.size_of_facets();
+  return visited.size () == p.size_of_facets ();
 }
 
-template bool is_weakly_convex(const CGAL::Polyhedron_3<CGAL_Kernel3>& p);
+template bool is_weakly_convex (const CGAL::Polyhedron_3<CGAL_Kernel3> &p);
 
 template <typename K>
-bool is_weakly_convex(const CGAL::Surface_mesh<CGAL::Point_3<K>>& m) {
+bool is_weakly_convex (const CGAL::Surface_mesh<CGAL::Point_3<K>> &m) {
   using Mesh = typename CGAL::Surface_mesh<CGAL::Point_3<K>>;
 
-  for (auto i : m.halfedges()) {
-    CGAL::Plane_3<K> p(
-      m.point(m.target(m.opposite(i))),
-      m.point(m.target(i)),
-      m.point(m.target(m.next(i))));
-    const auto& pt = m.point(m.target(m.next(m.opposite(i))));
-    if (p.has_on_positive_side(pt) && CGAL::squared_distance(p, pt) > 1e-8) {
+  for (auto i : m.halfedges ()) {
+    CGAL::Plane_3<K> p (
+      m.point (m.target (m.opposite (i))),
+      m.point (m.target (i)),
+      m.point (m.target (m.next (i))));
+    const auto &pt = m.point (m.target (m.next (m.opposite (i))));
+    if (p.has_on_positive_side (pt) && CGAL::squared_distance (p, pt) > 1e-8) {
       return false;
     }
   }
 
   // Also make sure that there is only one shell:
   std::unordered_set<typename Mesh::Face_index, typename CGAL::Handle_hash_function> visited;
-  visited.reserve(m.number_of_faces());
+  visited.reserve (m.number_of_faces ());
 
   std::queue<typename Mesh::Face_index> to_explore;
-  to_explore.push(*m.faces().begin()); // One arbitrary facet
-  visited.insert(to_explore.front());
+  to_explore.push (*m.faces ().begin ()); // One arbitrary facet
+  visited.insert (to_explore.front ());
 
-  while (!to_explore.empty()) {
-    typename Mesh::Face_index f = to_explore.front();
-    to_explore.pop();
+  while (!to_explore.empty ()) {
+    typename Mesh::Face_index f = to_explore.front ();
+    to_explore.pop ();
 
     CGAL::Halfedge_around_face_iterator<Mesh> he, end;
-    for (boost::tie(he, end) = CGAL::halfedges_around_face(m.halfedge(f), m); he != end; ++he) {
-      typename Mesh::Face_index o = m.face(m.opposite(*he));
+    for (boost::tie (he, end) = CGAL::halfedges_around_face (m.halfedge (f), m); he != end; ++he) {
+      typename Mesh::Face_index o = m.face (m.opposite (*he));
 
-      if (!visited.count(o)) {
-        visited.insert(o);
-        to_explore.push(o);
+      if (!visited.count (o)) {
+        visited.insert (o);
+        to_explore.push (o);
       }
     }
   }
 
-  return visited.size() == m.number_of_faces();
+  return visited.size () == m.number_of_faces ();
 }
 
-template bool is_weakly_convex(const CGAL::Surface_mesh<CGAL_Point_3>& m);
+template bool is_weakly_convex (const CGAL::Surface_mesh<CGAL_Point_3> &m);
 
-}  // namespace CGALUtils
+} // namespace CGALUtils
 
 #endif // ENABLE_CGAL
diff --git a/src/geometry/cgal/cgalutils-kernel.cc b/src/geometry/cgal/cgalutils-kernel.cc
index cbb46c8c8..2e37953e4 100644
--- a/src/geometry/cgal/cgalutils-kernel.cc
+++ b/src/geometry/cgal/cgalutils-kernel.cc
@@ -6,23 +6,20 @@
 namespace CGALUtils {
 
 template <>
-double KernelConverter<CGAL::Cartesian<CGAL::Gmpq>, CGAL::Epick>::operator()(
-  const CGAL::Gmpq& n) const
-{
-  return CGAL::to_double(n);
+double KernelConverter<CGAL::Cartesian<CGAL::Gmpq>, CGAL::Epick>::operator() (
+  const CGAL::Gmpq &n) const {
+  return CGAL::to_double (n);
 }
 
 template <>
-CGAL::Gmpq KernelConverter<CGAL::Epick, CGAL::Cartesian<CGAL::Gmpq>>::operator()(
-  const double& n) const
-{
+CGAL::Gmpq KernelConverter<CGAL::Epick, CGAL::Cartesian<CGAL::Gmpq>>::operator() (
+  const double &n) const {
   return n;
 }
 
 template <>
-double KernelConverter<CGAL::Epick, CGAL_DoubleKernel>::operator()(
-  const double& n) const
-{
+double KernelConverter<CGAL::Epick, CGAL_DoubleKernel>::operator() (
+  const double &n) const {
   return n;
 }
 
diff --git a/src/geometry/cgal/cgalutils-mesh-edits.h b/src/geometry/cgal/cgalutils-mesh-edits.h
index f873597db..1025ad8e1 100644
--- a/src/geometry/cgal/cgalutils-mesh-edits.h
+++ b/src/geometry/cgal/cgalutils-mesh-edits.h
@@ -33,51 +33,50 @@ private:
   std::unordered_map<vertex_descriptor, vertex_descriptor> vertexReplacements;
 
 public:
-
-  bool isEmpty() {
-    return facesToRemove.empty() &&
-           verticesToRemove.empty() &&
-           facesToAdd.empty() &&
-           vertexReplacements.empty();
+  bool isEmpty () {
+    return facesToRemove.empty () &&
+           verticesToRemove.empty () &&
+           facesToAdd.empty () &&
+           vertexReplacements.empty ();
   }
 
-  void removeFace(const face_descriptor& f) {
-    facesToRemove.insert(f);
+  void removeFace (const face_descriptor &f) {
+    facesToRemove.insert (f);
   }
 
-  void removeVertex(const vertex_descriptor& v) {
-    verticesToRemove.insert(v);
+  void removeVertex (const vertex_descriptor &v) {
+    verticesToRemove.insert (v);
   }
 
-  void addFace(const std::vector<vertex_descriptor>& vertices) {
-    facesToAdd.push_back(vertices);
+  void addFace (const std::vector<vertex_descriptor> &vertices) {
+    facesToAdd.push_back (vertices);
   }
 
-  void replaceVertex(const vertex_descriptor& original, const vertex_descriptor& replacement) {
+  void replaceVertex (const vertex_descriptor &original, const vertex_descriptor &replacement) {
     vertexReplacements[original] = replacement;
   }
 
-  static bool findCollapsibleVertices(
-    const std::vector<vertex_descriptor>& path,
-    const TriangleMesh& tm,
-    const std::function<void(size_t, vertex_descriptor)>& sinkFn) {
-    if (path.size() <= 3) {
+  static bool findCollapsibleVertices (
+    const std::vector<vertex_descriptor> &path,
+    const TriangleMesh &tm,
+    const std::function<void (size_t, vertex_descriptor)> &sinkFn) {
+    if (path.size () <= 3) {
       return false;
     }
 
-    const auto *p1 = &tm.point(path[0]);
-    const auto *p2 = &tm.point(path[1]);
-    const auto *p3 = &tm.point(path[2]);
+    const auto *p1 = &tm.point (path[0]);
+    const auto *p2 = &tm.point (path[1]);
+    const auto *p3 = &tm.point (path[2]);
 
-    for (size_t i = 0, n = path.size(); i < n; i++) {
-      if (CGAL::are_ordered_along_line(*p1, *p2, *p3)) {
+    for (size_t i = 0, n = path.size (); i < n; i++) {
+      if (CGAL::are_ordered_along_line (*p1, *p2, *p3)) {
         // p2 (at index i + 1) can be removed.
         auto ii = (i + 1) % n;
-        sinkFn(ii, path[ii]);
+        sinkFn (ii, path[ii]);
       }
       p1 = p2;
       p2 = p3;
-      p3 = &tm.point(path[(i + 3) % n]);
+      p3 = &tm.point (path[(i + 3) % n]);
     }
 
     return true;
@@ -85,109 +84,109 @@ public:
 
   /*! Mutating in place is tricky, to say the least, so this creates a new mesh
    * and overwrites the original to it at the end for now. */
-  bool apply(TriangleMesh& src) const
-  {
+  bool apply (TriangleMesh &src) const {
     TriangleMesh copy;
-    auto wasValid = CGAL::is_valid_polygon_mesh(src);
-    auto wasClosed = CGAL::is_closed(src);
+    auto wasValid = CGAL::is_valid_polygon_mesh (src);
+    auto wasClosed = CGAL::is_closed (src);
 
     auto edgesAdded = 0;
-    for (auto& vs : facesToAdd) edgesAdded += vs.size();
+    for (auto &vs : facesToAdd)
+      edgesAdded += vs.size ();
 
-    auto projectedVertexCount = src.number_of_vertices() - verticesToRemove.size();
-    auto projectedHalfedgeCount = src.number_of_halfedges() + edgesAdded * 2; // This is crude
-    auto projectedFaceCount = src.number_of_faces() - facesToRemove.size() + facesToAdd.size();
-    copy.reserve(copy.number_of_vertices() + projectedVertexCount,
-                 copy.number_of_halfedges() + projectedHalfedgeCount,
-                 copy.number_of_faces() + projectedFaceCount);
+    auto projectedVertexCount = src.number_of_vertices () - verticesToRemove.size ();
+    auto projectedHalfedgeCount = src.number_of_halfedges () + edgesAdded * 2; // This is crude
+    auto projectedFaceCount = src.number_of_faces () - facesToRemove.size () + facesToAdd.size ();
+    copy.reserve (copy.number_of_vertices () + projectedVertexCount,
+                  copy.number_of_halfedges () + projectedHalfedgeCount,
+                  copy.number_of_faces () + projectedFaceCount);
 
     // TODO(ochafik): Speed up with a lookup vector : std::vector<vertex_descriptor> vertexMap(src.number_of_vertices());
     std::unordered_map<vertex_descriptor, vertex_descriptor> vertexMap;
-    vertexMap.reserve(projectedVertexCount);
+    vertexMap.reserve (projectedVertexCount);
 
-    auto getDestinationVertex = [&](auto srcVertex) {
-        auto repIt = vertexReplacements.find(srcVertex);
-        if (repIt != vertexReplacements.end()) {
-          srcVertex = repIt->second;
-        }
-        auto it = vertexMap.find(srcVertex);
-        if (it == vertexMap.end()) {
-          auto v = copy.add_vertex(src.point(srcVertex));
-          vertexMap[srcVertex] = v;
-          return v;
-        }
-        return it->second;
-      };
+    auto getDestinationVertex = [&] (auto srcVertex) {
+      auto repIt = vertexReplacements.find (srcVertex);
+      if (repIt != vertexReplacements.end ()) {
+        srcVertex = repIt->second;
+      }
+      auto it = vertexMap.find (srcVertex);
+      if (it == vertexMap.end ()) {
+        auto v = copy.add_vertex (src.point (srcVertex));
+        vertexMap[srcVertex] = v;
+        return v;
+      }
+      return it->second;
+    };
 
     std::vector<vertex_descriptor> polygon;
 
-    auto addFace = [&](auto& polygon) {
-        auto face = copy.add_face(polygon);
-        if (face.is_valid()) {
-          if (polygon.size() > 3) {
-            PMP::triangulate_face(face, copy);
-          }
-          return true;
-        } else {
-          LOG(message_group::Warning, "Failed to add face with %1$lu vertices!", polygon.size());
-          return false;
-        }
-      };
-    auto copyFace = [&](auto& f) {
-        polygon.clear();
-
-        CGAL::Vertex_around_face_iterator<TriangleMesh> vit, vend;
-        for (boost::tie(vit, vend) = vertices_around_face(src.halfedge(f), src); vit != vend; ++vit) {
-          auto v = *vit;
-          if (verticesToRemove.find(v) != verticesToRemove.end()) {
-            continue;
-          }
-          polygon.push_back(getDestinationVertex(v));
+    auto addFace = [&] (auto &polygon) {
+      auto face = copy.add_face (polygon);
+      if (face.is_valid ()) {
+        if (polygon.size () > 3) {
+          PMP::triangulate_face (face, copy);
         }
-        if (polygon.size() < 3) {
-          LOG(message_group::Warning, "Attempted to remove too many vertices around this copied face, remesh aborted!");
-          return false;
+        return true;
+      } else {
+        LOG (message_group::Warning, "Failed to add face with %1$lu vertices!", polygon.size ());
+        return false;
+      }
+    };
+    auto copyFace = [&] (auto &f) {
+      polygon.clear ();
+
+      CGAL::Vertex_around_face_iterator<TriangleMesh> vit, vend;
+      for (boost::tie (vit, vend) = vertices_around_face (src.halfedge (f), src); vit != vend; ++vit) {
+        auto v = *vit;
+        if (verticesToRemove.find (v) != verticesToRemove.end ()) {
+          continue;
         }
+        polygon.push_back (getDestinationVertex (v));
+      }
+      if (polygon.size () < 3) {
+        LOG (message_group::Warning, "Attempted to remove too many vertices around this copied face, remesh aborted!");
+        return false;
+      }
 
-        return addFace(polygon);
-      };
+      return addFace (polygon);
+    };
 
-    for (auto f : src.faces()) {
-      if (src.is_removed(f)) {
+    for (auto f : src.faces ()) {
+      if (src.is_removed (f)) {
         continue;
       }
-      if (facesToRemove.find(f) != facesToRemove.end()) {
+      if (facesToRemove.find (f) != facesToRemove.end ()) {
         continue;
       }
-      if (!copyFace(f)) {
+      if (!copyFace (f)) {
         return false;
       }
     }
 
-    for (auto& originalPolygon : facesToAdd) {
-      polygon.clear();
+    for (auto &originalPolygon : facesToAdd) {
+      polygon.clear ();
 
       for (auto v : originalPolygon) {
-        if (verticesToRemove.find(v) != verticesToRemove.end()) {
+        if (verticesToRemove.find (v) != verticesToRemove.end ()) {
           continue;
         }
-        polygon.push_back(getDestinationVertex(v));
+        polygon.push_back (getDestinationVertex (v));
       }
-      if (polygon.size() < 3) {
-        LOG(message_group::Warning, "Attempted to remove too many vertices around this added face, remesh aborted!");
+      if (polygon.size () < 3) {
+        LOG (message_group::Warning, "Attempted to remove too many vertices around this added face, remesh aborted!");
         return false;
       }
-      if (!addFace(polygon)) {
+      if (!addFace (polygon)) {
         return false;
       }
     }
 
-    if (wasValid && !CGAL::is_valid_polygon_mesh(copy)) {
-      LOG(message_group::Warning, "Remeshing output isn't valid");
+    if (wasValid && !CGAL::is_valid_polygon_mesh (copy)) {
+      LOG (message_group::Warning, "Remeshing output isn't valid");
       return false;
     }
-    if (wasClosed && !CGAL::is_closed(copy)) {
-      LOG(message_group::Warning, "Remeshing output isn't closed");
+    if (wasClosed && !CGAL::is_closed (copy)) {
+      LOG (message_group::Warning, "Remeshing output isn't closed");
       return false;
     }
 
diff --git a/src/geometry/cgal/cgalutils-mesh.cc b/src/geometry/cgal/cgalutils-mesh.cc
index 4a5b208f5..4f68208e3 100644
--- a/src/geometry/cgal/cgalutils-mesh.cc
+++ b/src/geometry/cgal/cgalutils-mesh.cc
@@ -21,108 +21,102 @@ namespace CGALUtils {
 
 namespace PMP = CGAL::Polygon_mesh_processing;
 
-CGAL_DoubleMesh repairPolySet(const PolySet& ps)
-{
+CGAL_DoubleMesh repairPolySet (const PolySet &ps) {
   std::vector<CGAL_DoubleMesh::Point> points;
   std::vector<std::vector<size_t>> polygons;
 
   // at least 3*numFacets
-  points.reserve(ps.indices.size() * 3);
-  polygons.reserve(ps.indices.size());
-  for (const auto& inds : ps.indices) {
-    std::vector<size_t>& polygon = polygons.emplace_back();
-    polygon.reserve(inds.size());
-    for (const auto& ind : inds) {
-      polygon.push_back(points.size());
-      auto& pt = ps.vertices[ind];
-      points.emplace_back(pt[0], pt[1], pt[2]);
+  points.reserve (ps.indices.size () * 3);
+  polygons.reserve (ps.indices.size ());
+  for (const auto &inds : ps.indices) {
+    std::vector<size_t> &polygon = polygons.emplace_back ();
+    polygon.reserve (inds.size ());
+    for (const auto &ind : inds) {
+      polygon.push_back (points.size ());
+      auto &pt = ps.vertices[ind];
+      points.emplace_back (pt[0], pt[1], pt[2]);
     }
   }
 
-  PMP::repair_polygon_soup(points, polygons);
-  PMP::orient_polygon_soup(points, polygons);
+  PMP::repair_polygon_soup (points, polygons);
+  PMP::orient_polygon_soup (points, polygons);
   CGAL_DoubleMesh mesh;
-  PMP::polygon_soup_to_polygon_mesh(points, polygons, mesh);
+  PMP::polygon_soup_to_polygon_mesh (points, polygons, mesh);
   return mesh;
 }
 
 template <class SurfaceMesh>
-std::shared_ptr<SurfaceMesh> createSurfaceMeshFromPolySet(const PolySet& ps)
-{
-  auto mesh = std::make_shared<SurfaceMesh>();
-  mesh->reserve(ps.vertices.size(), ps.indices.size() * 3, ps.indices.size());
-  for (const auto& v : ps.vertices) {
-    mesh->add_vertex(typename SurfaceMesh::Point(v[0], v[1], v[2]));
+std::shared_ptr<SurfaceMesh> createSurfaceMeshFromPolySet (const PolySet &ps) {
+  auto mesh = std::make_shared<SurfaceMesh> ();
+  mesh->reserve (ps.vertices.size (), ps.indices.size () * 3, ps.indices.size ());
+  for (const auto &v : ps.vertices) {
+    mesh->add_vertex (typename SurfaceMesh::Point (v[0], v[1], v[2]));
   }
-  for (const auto& face : ps.indices) {
-    mesh->add_face(face | boost::adaptors::transformed([](uint32_t i){
-        return typename SurfaceMesh::Vertex_index(i);
-      }));
+  for (const auto &face : ps.indices) {
+    mesh->add_face (face | boost::adaptors::transformed ([] (uint32_t i) {
+                      return typename SurfaceMesh::Vertex_index (i);
+                    }));
   }
   return mesh;
 }
 
-template std::shared_ptr<CGAL_DoubleMesh> createSurfaceMeshFromPolySet<CGAL_DoubleMesh>(const PolySet& ps);
-template std::shared_ptr<CGAL_Kernel3Mesh> createSurfaceMeshFromPolySet(const PolySet& ps);
-
+template std::shared_ptr<CGAL_DoubleMesh> createSurfaceMeshFromPolySet<CGAL_DoubleMesh> (const PolySet &ps);
+template std::shared_ptr<CGAL_Kernel3Mesh> createSurfaceMeshFromPolySet (const PolySet &ps);
 
 template <class SurfaceMesh>
-std::unique_ptr<PolySet> createPolySetFromSurfaceMesh(const SurfaceMesh& mesh)
-{
+std::unique_ptr<PolySet> createPolySetFromSurfaceMesh (const SurfaceMesh &mesh) {
   //  FIXME: We may want to convert directly, without PolySetBuilder here, to maintain manifoldness, if possible.
-  PolySetBuilder builder(0, mesh.number_of_faces() + mesh.number_of_faces());
-  for (const auto& f : mesh.faces()) {
-    builder.beginPolygon(mesh.degree(f));
+  PolySetBuilder builder (0, mesh.number_of_faces () + mesh.number_of_faces ());
+  for (const auto &f : mesh.faces ()) {
+    builder.beginPolygon (mesh.degree (f));
 
     CGAL::Vertex_around_face_iterator<SurfaceMesh> vbegin, vend;
-    for (boost::tie(vbegin, vend) = vertices_around_face(mesh.halfedge(f), mesh); vbegin != vend;
+    for (boost::tie (vbegin, vend) = vertices_around_face (mesh.halfedge (f), mesh); vbegin != vend;
          ++vbegin) {
-      auto& v = mesh.point(*vbegin);
+      auto &v = mesh.point (*vbegin);
       // for (auto &v : f) {
-      double x = CGAL::to_double(v.x());
-      double y = CGAL::to_double(v.y());
-      double z = CGAL::to_double(v.z());
-      builder.addVertex(Vector3d(x, y, z));
+      double x = CGAL::to_double (v.x ());
+      double y = CGAL::to_double (v.y ());
+      double z = CGAL::to_double (v.z ());
+      builder.addVertex (Vector3d (x, y, z));
     }
   }
-  return builder.build();
+  return builder.build ();
 }
 
 template <class InputKernel, class OutputKernel>
-void copyMesh(
-  const CGAL::Surface_mesh<CGAL::Point_3<InputKernel>>& input,
-  CGAL::Surface_mesh<CGAL::Point_3<OutputKernel>>& output)
-{
+void copyMesh (
+  const CGAL::Surface_mesh<CGAL::Point_3<InputKernel>> &input,
+  CGAL::Surface_mesh<CGAL::Point_3<OutputKernel>> &output) {
   using InputMesh = CGAL::Surface_mesh<CGAL::Point_3<InputKernel>>;
   using OutputMesh = CGAL::Surface_mesh<CGAL::Point_3<OutputKernel>>;
 
-  auto converter = getCartesianConverter<InputKernel, OutputKernel>();
-  output.reserve(output.number_of_vertices() + input.number_of_vertices(),
-                 output.number_of_halfedges() + input.number_of_halfedges(),
-                 output.number_of_faces() + input.number_of_faces());
+  auto converter = getCartesianConverter<InputKernel, OutputKernel> ();
+  output.reserve (output.number_of_vertices () + input.number_of_vertices (),
+                  output.number_of_halfedges () + input.number_of_halfedges (),
+                  output.number_of_faces () + input.number_of_faces ());
 
   std::vector<typename CGAL::Surface_mesh<CGAL::Point_3<OutputKernel>>::Vertex_index> polygon;
   std::unordered_map<typename InputMesh::Vertex_index, typename OutputMesh::Vertex_index> reindexer;
-  for (auto face : input.faces()) {
-    polygon.clear();
+  for (auto face : input.faces ()) {
+    polygon.clear ();
 
     CGAL::Vertex_around_face_iterator<typename CGAL::Surface_mesh<CGAL::Point_3<InputKernel>>>
-    vbegin, vend;
-    for (boost::tie(vbegin, vend) = vertices_around_face(input.halfedge(face), input);
+      vbegin, vend;
+    for (boost::tie (vbegin, vend) = vertices_around_face (input.halfedge (face), input);
          vbegin != vend; ++vbegin) {
       auto input_vertex = *vbegin;
-      auto size_before = reindexer.size();
-      auto& output_vertex = reindexer[input_vertex];
-      if (size_before != reindexer.size()) {
-        output_vertex = output.add_vertex(converter(input.point(input_vertex)));
+      auto size_before = reindexer.size ();
+      auto &output_vertex = reindexer[input_vertex];
+      if (size_before != reindexer.size ()) {
+        output_vertex = output.add_vertex (converter (input.point (input_vertex)));
       }
-      polygon.push_back(output_vertex);
+      polygon.push_back (output_vertex);
     }
-    output.add_face(polygon);
+    output.add_face (polygon);
   }
 }
 
-template void copyMesh(const CGAL::Surface_mesh<CGAL::Point_3<CGAL::Epick>>& input, CGAL_DoubleMesh& output);
-
+template void copyMesh (const CGAL::Surface_mesh<CGAL::Point_3<CGAL::Epick>> &input, CGAL_DoubleMesh &output);
 
 } // namespace CGALUtils
diff --git a/src/geometry/cgal/cgalutils-orient.cc b/src/geometry/cgal/cgalutils-orient.cc
index 92f67421a..793d1424f 100644
--- a/src/geometry/cgal/cgalutils-orient.cc
+++ b/src/geometry/cgal/cgalutils-orient.cc
@@ -7,12 +7,10 @@
 namespace CGALUtils {
 
 template <typename SurfaceMesh>
-void orientToBoundAVolume(SurfaceMesh& mesh)
-{
-  CGAL::Polygon_mesh_processing::orient_to_bound_a_volume(mesh);
+void orientToBoundAVolume (SurfaceMesh &mesh) {
+  CGAL::Polygon_mesh_processing::orient_to_bound_a_volume (mesh);
 }
 
-template void orientToBoundAVolume(CGAL_DoubleMesh& polyhedron);
+template void orientToBoundAVolume (CGAL_DoubleMesh &polyhedron);
 
 } // namespace CGALUtils
-
diff --git a/src/geometry/cgal/cgalutils-polyhedron.cc b/src/geometry/cgal/cgalutils-polyhedron.cc
index 08d1b2704..949d3a7fd 100644
--- a/src/geometry/cgal/cgalutils-polyhedron.cc
+++ b/src/geometry/cgal/cgalutils-polyhedron.cc
@@ -26,11 +26,13 @@ class CGAL_Build_PolySet : public CGAL::Modifier_base<typename Polyhedron::Halfe
 {
   using HDS = typename Polyhedron::HalfedgeDS;
   using CGAL_Polybuilder = CGAL::Polyhedron_incremental_builder_3<typename Polyhedron::HalfedgeDS>;
+
 public:
   using CGALPoint = typename CGAL_Polybuilder::Point_3;
 
-  const PolySet& ps;
-  CGAL_Build_PolySet(const PolySet& ps) : ps(ps) { }
+  const PolySet &ps;
+  CGAL_Build_PolySet (const PolySet &ps)
+    : ps (ps) {}
 
 /*
    Using Grid here is important for performance reasons. See following model.
@@ -47,105 +49,110 @@ public:
    }
  */
 #if 1 // Use Grid
-  void operator()(HDS& hds) override {
-    CGAL_Polybuilder B(hds, true);
+  void operator() (HDS &hds) override {
+    CGAL_Polybuilder B (hds, true);
 
-    Grid3d<int> grid(GRID_FINE);
+    Grid3d<int> grid (GRID_FINE);
     std::vector<CGALPoint> vertices;
     std::vector<std::vector<size_t>> indices;
 
     // Align all vertices to grid and build vertex array in vertices
-    for (const auto& p : ps.indices) {
-      indices.emplace_back();
-      indices.back().reserve(p.size());
-      for (auto ind : boost::adaptors::reverse(p)) {
+    for (const auto &p : ps.indices) {
+      indices.emplace_back ();
+      indices.back ().reserve (p.size ());
+      for (auto ind : boost::adaptors::reverse (p)) {
         // align v to the grid; the CGALPoint will receive the aligned vertex
         Vector3d v = ps.vertices[ind];
-        size_t idx = grid.align(v);
-        if (idx == vertices.size()) {
-          CGALPoint p(v[0], v[1], v[2]);
-          vertices.push_back(p);
+        size_t idx = grid.align (v);
+        if (idx == vertices.size ()) {
+          CGALPoint p (v[0], v[1], v[2]);
+          vertices.push_back (p);
         }
-        indices.back().push_back(idx);
+        indices.back ().push_back (idx);
       }
     }
 
 #ifdef GEN_SURFACE_DEBUG
-    printf("polyhedron(faces=[");
+    printf ("polyhedron(faces=[");
     int pidx = 0;
 #endif
-    B.begin_surface(vertices.size(), ps.indices.size());
-    for (const auto& p : vertices) {
-      B.add_vertex(p);
+    B.begin_surface (vertices.size (), ps.indices.size ());
+    for (const auto &p : vertices) {
+      B.add_vertex (p);
     }
-    for (auto& pindices : indices) {
+    for (auto &pindices : indices) {
 #ifdef GEN_SURFACE_DEBUG
-      if (pidx++ > 0) printf(",");
+      if (pidx++ > 0)
+        printf (",");
 #endif
 
       // We remove duplicate indices since there is a bug in CGAL's
       // Polyhedron_incremental_builder_3::test_facet() which fails to detect this
-      auto last = std::unique(pindices.begin(), pindices.end());
-      std::advance(last, -1);
-      if (*last != pindices.front()) last++; // In case the first & last are equal
-      pindices.erase(last, pindices.end());
-      if (pindices.size() >= 3 && B.test_facet(pindices.begin(), pindices.end())) {
-        B.add_facet(pindices.begin(), pindices.end());
+      auto last = std::unique (pindices.begin (), pindices.end ());
+      std::advance (last, -1);
+      if (*last != pindices.front ())
+        last++; // In case the first & last are equal
+      pindices.erase (last, pindices.end ());
+      if (pindices.size () >= 3 && B.test_facet (pindices.begin (), pindices.end ())) {
+        B.add_facet (pindices.begin (), pindices.end ());
       }
 #ifdef GEN_SURFACE_DEBUG
-      printf("[");
+      printf ("[");
       int fidx = 0;
-      for (auto i : boost::adaptors::reverse(pindices)) {
-        if (fidx++ > 0) printf(",");
-        printf("%ld", i);
+      for (auto i : boost::adaptors::reverse (pindices)) {
+        if (fidx++ > 0)
+          printf (",");
+        printf ("%ld", i);
       }
-      printf("]");
+      printf ("]");
 #endif
     }
-    B.end_surface();
+    B.end_surface ();
 #ifdef GEN_SURFACE_DEBUG
-    printf("],\n");
+    printf ("],\n");
 #endif
 #ifdef GEN_SURFACE_DEBUG
-    printf("points=[");
-    for (std::size_t i = 0; i < vertices.size(); ++i) {
-      if (i > 0) printf(",");
-      const CGALPoint& p = vertices[i];
-      printf("[%g,%g,%g]", CGAL::to_double(p.x()), CGAL::to_double(p.y()), CGAL::to_double(p.z()));
+    printf ("points=[");
+    for (std::size_t i = 0; i < vertices.size (); ++i) {
+      if (i > 0)
+        printf (",");
+      const CGALPoint &p = vertices[i];
+      printf ("[%g,%g,%g]", CGAL::to_double (p.x ()), CGAL::to_double (p.y ()), CGAL::to_double (p.z ()));
     }
-    printf("]);\n");
+    printf ("]);\n");
 #endif
   }
 #else // Don't use Grid
-  void operator()(HDS& hds)
-  {
-    CGAL_Polybuilder B(hds, true);
+  void operator() (HDS &hds) {
+    CGAL_Polybuilder B (hds, true);
     Reindexer<Vector3d> vertices;
-    std::vector<size_t> indices(3);
+    std::vector<size_t> indices (3);
 
     // Estimating same # of vertices as polygons (very rough)
-    B.begin_surface(ps.indices.size(), ps.indices.size());
+    B.begin_surface (ps.indices.size (), ps.indices.size ());
     int pidx = 0;
 #ifdef GEN_SURFACE_DEBUG
-    printf("polyhedron(faces=[");
+    printf ("polyhedron(faces=[");
 #endif
-    for (const auto& p : ps.indices) {
+    for (const auto &p : ps.indices) {
 #ifdef GEN_SURFACE_DEBUG
-      if (pidx++ > 0) printf(",");
+      if (pidx++ > 0)
+        printf (",");
 #endif
-      indices.clear();
-      for (const auto& v: boost::adaptors::reverse(p)) {
-        size_t s = vertices.size();
-        size_t idx = vertices.lookup(v);
+      indices.clear ();
+      for (const auto &v : boost::adaptors::reverse (p)) {
+        size_t s = vertices.size ();
+        size_t idx = vertices.lookup (v);
         // If we added a vertex, also add it to the CGAL builder
-        if (idx == s) B.add_vertex(CGALPoint(v[0], v[1], v[2]));
-        indices.push_back(idx);
+        if (idx == s)
+          B.add_vertex (CGALPoint (v[0], v[1], v[2]));
+        indices.push_back (idx);
       }
       // We perform this test since there is a bug in CGAL's
       // Polyhedron_incremental_builder_3::test_facet() which
       // fails to detect duplicate indices
       bool err = false;
-      for (std::size_t i = 0; i < indices.size(); ++i) {
+      for (std::size_t i = 0; i < indices.size (); ++i) {
         // check if vertex indices[i] is already in the sequence [0..i-1]
         for (std::size_t k = 0; k < i && !err; ++k) {
           if (indices[k] == indices[i]) {
@@ -154,214 +161,211 @@ public:
           }
         }
       }
-      if (!err && B.test_facet(indices.begin(), indices.end())) {
-        B.add_facet(indices.begin(), indices.end());
+      if (!err && B.test_facet (indices.begin (), indices.end ())) {
+        B.add_facet (indices.begin (), indices.end ());
 #ifdef GEN_SURFACE_DEBUG
-        printf("[");
+        printf ("[");
         int fidx = 0;
         for (auto i : indices) {
-          if (fidx++ > 0) printf(",");
-          printf("%ld", i);
+          if (fidx++ > 0)
+            printf (",");
+          printf ("%ld", i);
         }
-        printf("]");
+        printf ("]");
 #endif
       }
     }
-    B.end_surface();
+    B.end_surface ();
 #ifdef GEN_SURFACE_DEBUG
-    printf("],\n");
-
-    printf("points=[");
-    for (std::size_t vidx = 0; vidx < vertices.size(); ++vidx) {
-      if (vidx > 0) printf(",");
-      const Vector3d& v = vertices.getArray()[vidx];
-      printf("[%g,%g,%g]", v[0], v[1], v[2]);
+    printf ("],\n");
+
+    printf ("points=[");
+    for (std::size_t vidx = 0; vidx < vertices.size (); ++vidx) {
+      if (vidx > 0)
+        printf (",");
+      const Vector3d &v = vertices.getArray ()[vidx];
+      printf ("[%g,%g,%g]", v[0], v[1], v[2]);
     }
-    printf("]);\n");
+    printf ("]);\n");
 #endif
   }
 #endif // if 1
 };
 
 template <class InputKernel, class OutputKernel>
-struct Copy_polyhedron_to : public CGAL::Modifier_base<typename CGAL::Polyhedron_3<OutputKernel>::HalfedgeDS>
-{
+struct Copy_polyhedron_to : public CGAL::Modifier_base<typename CGAL::Polyhedron_3<OutputKernel>::HalfedgeDS> {
   using Polyhedron_output = CGAL::Polyhedron_3<OutputKernel>;
   using Polyhedron_input = CGAL::Polyhedron_3<InputKernel>;
 
-  Copy_polyhedron_to(const Polyhedron_input& in_poly) : in_poly(in_poly) {}
+  Copy_polyhedron_to (const Polyhedron_input &in_poly)
+    : in_poly (in_poly) {}
 
-  void operator()(typename Polyhedron_output::HalfedgeDS& out_hds) override
-  {
+  void operator() (typename Polyhedron_output::HalfedgeDS &out_hds) override {
     using Output_HDS = typename Polyhedron_output::HalfedgeDS;
 
-    CGAL::Polyhedron_incremental_builder_3<Output_HDS> builder(out_hds);
+    CGAL::Polyhedron_incremental_builder_3<Output_HDS> builder (out_hds);
 
     using Vertex_const_iterator = typename Polyhedron_input::Vertex_const_iterator;
     using Facet_const_iterator = typename Polyhedron_input::Facet_const_iterator;
     using HFCC = typename Polyhedron_input::Halfedge_around_facet_const_circulator;
 
-    builder.begin_surface(in_poly.size_of_vertices(),
-                          in_poly.size_of_facets(),
-                          in_poly.size_of_halfedges());
+    builder.begin_surface (in_poly.size_of_vertices (),
+                           in_poly.size_of_facets (),
+                           in_poly.size_of_halfedges ());
 
-    auto converter = CGALUtils::getCartesianConverter<InputKernel, OutputKernel>();
+    auto converter = CGALUtils::getCartesianConverter<InputKernel, OutputKernel> ();
     for (Vertex_const_iterator
-         vi = in_poly.vertices_begin(), end = in_poly.vertices_end();
+           vi = in_poly.vertices_begin (),
+           end = in_poly.vertices_end ();
          vi != end; ++vi) {
-      typename Polyhedron_output::Point_3 p(converter(vi->point().x()),
-                                            converter(vi->point().y()),
-                                            converter(vi->point().z()));
-      builder.add_vertex(p);
+      typename Polyhedron_output::Point_3 p (converter (vi->point ().x ()),
+                                             converter (vi->point ().y ()),
+                                             converter (vi->point ().z ()));
+      builder.add_vertex (p);
     }
 
     using Index = CGAL::Inverse_index<Vertex_const_iterator>;
-    Index index(in_poly.vertices_begin(), in_poly.vertices_end());
+    Index index (in_poly.vertices_begin (), in_poly.vertices_end ());
 
     for (Facet_const_iterator
-         fi = in_poly.facets_begin(), end = in_poly.facets_end();
+           fi = in_poly.facets_begin (),
+           end = in_poly.facets_end ();
          fi != end; ++fi) {
-      HFCC hc = fi->facet_begin();
+      HFCC hc = fi->facet_begin ();
       HFCC hc_end = hc;
       //     std::size_t n = circulator_size(hc);
       //     CGAL_assertion(n >= 3);
-      builder.begin_facet();
+      builder.begin_facet ();
       do {
-        builder.add_vertex_to_facet(index[hc->vertex()]);
+        builder.add_vertex_to_facet (index[hc->vertex ()]);
         ++hc;
       } while (hc != hc_end);
-      builder.end_facet();
+      builder.end_facet ();
     }
-    builder.end_surface();
+    builder.end_surface ();
   } // end operator()(..)
 private:
-  const Polyhedron_input& in_poly;
-};   // end Copy_polyhedron_to<>
+  const Polyhedron_input &in_poly;
+}; // end Copy_polyhedron_to<>
 
 } // namespace
 
 namespace CGALUtils {
 
 template <class InputKernel, class OutputKernel>
-void copyPolyhedron(const CGAL::Polyhedron_3<InputKernel>& poly_a, CGAL::Polyhedron_3<OutputKernel>& poly_b)
-{
+void copyPolyhedron (const CGAL::Polyhedron_3<InputKernel> &poly_a, CGAL::Polyhedron_3<OutputKernel> &poly_b) {
   // Copy is also used in "append" cases.
-  poly_b.reserve(
-    poly_b.size_of_vertices() + poly_a.size_of_vertices(),
-    poly_b.size_of_halfedges() + poly_a.size_of_halfedges(),
-    poly_b.size_of_facets() + poly_a.size_of_facets());
+  poly_b.reserve (
+    poly_b.size_of_vertices () + poly_a.size_of_vertices (),
+    poly_b.size_of_halfedges () + poly_a.size_of_halfedges (),
+    poly_b.size_of_facets () + poly_a.size_of_facets ());
 
-  Copy_polyhedron_to<InputKernel, OutputKernel> modifier(poly_a);
-  poly_b.delegate(modifier);
+  Copy_polyhedron_to<InputKernel, OutputKernel> modifier (poly_a);
+  poly_b.delegate (modifier);
 }
 
-template void copyPolyhedron<CGAL::Epick, CGAL_Kernel3>(const CGAL::Polyhedron_3<CGAL::Epick>&, CGAL_Polyhedron&);
-template void copyPolyhedron<CGAL_Kernel3, CGAL::Epick>(const CGAL_Polyhedron&, CGAL::Polyhedron_3<CGAL::Epick>&);
+template void copyPolyhedron<CGAL::Epick, CGAL_Kernel3> (const CGAL::Polyhedron_3<CGAL::Epick> &, CGAL_Polyhedron &);
+template void copyPolyhedron<CGAL_Kernel3, CGAL::Epick> (const CGAL_Polyhedron &, CGAL::Polyhedron_3<CGAL::Epick> &);
 
 template <typename K>
-void convertNefToPolyhedron(
-  const CGAL::Nef_polyhedron_3<K>& nef, CGAL::Polyhedron_3<K>& polyhedron)
-{
-  nef.convert_to_polyhedron(polyhedron);
+void convertNefToPolyhedron (
+  const CGAL::Nef_polyhedron_3<K> &nef, CGAL::Polyhedron_3<K> &polyhedron) {
+  nef.convert_to_polyhedron (polyhedron);
 }
 
-template void convertNefToPolyhedron(const CGAL_Nef_polyhedron3& nef, CGAL_Polyhedron& polyhedron);
+template void convertNefToPolyhedron (const CGAL_Nef_polyhedron3 &nef, CGAL_Polyhedron &polyhedron);
 
 template <typename SurfaceMesh>
-void convertNefToSurfaceMesh(const CGAL_Nef_polyhedron3& nef, SurfaceMesh& mesh)
-{
+void convertNefToSurfaceMesh (const CGAL_Nef_polyhedron3 &nef, SurfaceMesh &mesh) {
   constexpr bool triangulate = false;
-  CGAL::convert_nef_polyhedron_to_polygon_mesh(nef, mesh, triangulate);
+  CGAL::convert_nef_polyhedron_to_polygon_mesh (nef, mesh, triangulate);
 }
 
-void convertSurfaceMeshToNef(const CGAL_Kernel3Mesh& mesh, CGAL_Nef_polyhedron3& nef)
-{
-  nef = CGAL_Nef_polyhedron3(mesh);
+void convertSurfaceMeshToNef (const CGAL_Kernel3Mesh &mesh, CGAL_Nef_polyhedron3 &nef) {
+  nef = CGAL_Nef_polyhedron3 (mesh);
 }
 
-
 template <typename Polyhedron>
-bool createPolyhedronFromPolySet(const PolySet& ps, Polyhedron& p)
-{
+bool createPolyhedronFromPolySet (const PolySet &ps, Polyhedron &p) {
   bool err = false;
   try {
-    CGAL_Build_PolySet<Polyhedron> builder(ps);
-    p.delegate(builder);
-  } catch (const CGAL::Assertion_exception& e) {
-    LOG(message_group::Error, "CGAL error in CGALUtils::createPolyhedronFromPolySet: %1$s", e.what());
+    CGAL_Build_PolySet<Polyhedron> builder (ps);
+    p.delegate (builder);
+  } catch (const CGAL::Assertion_exception &e) {
+    LOG (message_group::Error, "CGAL error in CGALUtils::createPolyhedronFromPolySet: %1$s", e.what ());
     err = true;
   }
   return err;
 }
 
-template bool createPolyhedronFromPolySet(const PolySet& ps, CGAL_Polyhedron& p);
-template bool createPolyhedronFromPolySet(const PolySet& ps, CGAL::Polyhedron_3<CGAL::Epick>& p);
+template bool createPolyhedronFromPolySet (const PolySet &ps, CGAL_Polyhedron &p);
+template bool createPolyhedronFromPolySet (const PolySet &ps, CGAL::Polyhedron_3<CGAL::Epick> &p);
 
 template <typename Polyhedron>
-std::unique_ptr<PolySet> createPolySetFromPolyhedron(const Polyhedron& p)
-{
+std::unique_ptr<PolySet> createPolySetFromPolyhedron (const Polyhedron &p) {
   using Vertex = typename Polyhedron::Vertex;
   using FCI = typename Polyhedron::Facet_const_iterator;
   using HFCC = typename Polyhedron::Halfedge_around_facet_const_circulator;
 
-  PolySetBuilder builder(0, p.size_of_facets());
+  PolySetBuilder builder (0, p.size_of_facets ());
 
-  for (FCI fi = p.facets_begin(); fi != p.facets_end(); ++fi) {
-    HFCC hc = fi->facet_begin();
+  for (FCI fi = p.facets_begin (); fi != p.facets_end (); ++fi) {
+    HFCC hc = fi->facet_begin ();
     HFCC hc_end = hc;
-    builder.beginPolygon(fi->facet_degree());
+    builder.beginPolygon (fi->facet_degree ());
     do {
-      Vertex const& v = *((hc++)->vertex());
-      double x = CGAL::to_double(v.point().x());
-      double y = CGAL::to_double(v.point().y());
-      double z = CGAL::to_double(v.point().z());
-      builder.addVertex(Vector3d(x, y, z));
+      Vertex const &v = *((hc++)->vertex ());
+      double x = CGAL::to_double (v.point ().x ());
+      double y = CGAL::to_double (v.point ().y ());
+      double z = CGAL::to_double (v.point ().z ());
+      builder.addVertex (Vector3d (x, y, z));
     } while (hc != hc_end);
   }
-  return builder.build();
+  return builder.build ();
 }
 
-template std::unique_ptr<PolySet> createPolySetFromPolyhedron(const CGAL_Polyhedron& p);
-template std::unique_ptr<PolySet> createPolySetFromPolyhedron(const CGAL::Polyhedron_3<CGAL::Epick>& p);
+template std::unique_ptr<PolySet> createPolySetFromPolyhedron (const CGAL_Polyhedron &p);
+template std::unique_ptr<PolySet> createPolySetFromPolyhedron (const CGAL::Polyhedron_3<CGAL::Epick> &p);
 
 class Polyhedron_writer
 {
   std::ostream *out{nullptr};
   bool firstv{true};
   std::vector<int> indices;
+
 public:
-  Polyhedron_writer() = default;
-  void write_header(std::ostream& stream,
-                    std::size_t /*vertices*/,
-                    std::size_t /*halfedges*/,
-                    std::size_t /*facets*/
-                    /*bool normals = false*/) {
+  Polyhedron_writer () = default;
+  void write_header (std::ostream &stream,
+                     std::size_t /*vertices*/,
+                     std::size_t /*halfedges*/,
+                     std::size_t /*facets*/
+                     /*bool normals = false*/) {
     this->out = &stream;
     *out << "polyhedron(points=[";
     firstv = true;
   }
-  void write_footer() {
+  void write_footer () {
     *out << "]);" << std::endl;
   }
-  void write_vertex(const double& x, const double& y, const double& z) {
+  void write_vertex (const double &x, const double &y, const double &z) {
     *out << (firstv ? "" : ",") << '[' << x << ',' << y << ',' << z << ']';
     firstv = false;
   }
-  void write_facet_header() {
+  void write_facet_header () {
     *out << "], faces=[";
     firstv = true;
   }
-  void write_facet_begin(std::size_t /*no*/) {
+  void write_facet_begin (std::size_t /*no*/) {
     *out << (firstv ? "" : ",") << '[';
-    indices.clear();
+    indices.clear ();
     firstv = false;
   }
-  void write_facet_vertex_index(std::size_t index) {
-    indices.push_back(index);
+  void write_facet_vertex_index (std::size_t index) {
+    indices.push_back (index);
   }
-  void write_facet_end() {
+  void write_facet_end () {
     bool firsti = true;
-    for (auto i : boost::adaptors::reverse(indices)) {
+    for (auto i : boost::adaptors::reverse (indices)) {
       *out << (firsti ? "" : ",") << i;
       firsti = false;
     }
@@ -369,4 +373,4 @@ public:
   }
 };
 
-}  // namespace CGALUtils
+} // namespace CGALUtils
diff --git a/src/geometry/cgal/cgalutils-project.cc b/src/geometry/cgal/cgalutils-project.cc
index ab31eb4a2..bef4aec2f 100644
--- a/src/geometry/cgal/cgalutils-project.cc
+++ b/src/geometry/cgal/cgalutils-project.cc
@@ -24,45 +24,45 @@
 
 #include <vector>
 
-static void add_outline_to_poly(CGAL_Nef_polyhedron2::Explorer& explorer,
-                                CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator circ,
-                                CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator end,
-                                bool positive,
-                                Polygon2d& poly) {
+static void add_outline_to_poly (CGAL_Nef_polyhedron2::Explorer &explorer,
+                                 CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator circ,
+                                 CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator end,
+                                 bool positive,
+                                 Polygon2d &poly) {
   Outline2d outline;
 
-  CGAL_For_all(circ, end) {
-    if (explorer.is_standard(explorer.target(circ))) {
-      CGAL_Nef_polyhedron2::Explorer::Point ep = explorer.point(explorer.target(circ));
-      outline.vertices.push_back(Vector2d(to_double(ep.x()),
-                                          to_double(ep.y())));
+  CGAL_For_all (circ, end) {
+    if (explorer.is_standard (explorer.target (circ))) {
+      CGAL_Nef_polyhedron2::Explorer::Point ep = explorer.point (explorer.target (circ));
+      outline.vertices.push_back (Vector2d (to_double (ep.x ()),
+                                            to_double (ep.y ())));
     }
   }
 
-  if (!outline.vertices.empty()) {
+  if (!outline.vertices.empty ()) {
     outline.positive = positive;
-    poly.addOutline(outline);
+    poly.addOutline (outline);
   }
 }
 
-static std::unique_ptr<Polygon2d> convertToPolygon2d(const CGAL_Nef_polyhedron2& p2)
-{
-  auto poly = std::make_unique<Polygon2d>();
+static std::unique_ptr<Polygon2d> convertToPolygon2d (const CGAL_Nef_polyhedron2 &p2) {
+  auto poly = std::make_unique<Polygon2d> ();
 
   using Explorer = CGAL_Nef_polyhedron2::Explorer;
   using fci_t = Explorer::Face_const_iterator;
   using heafcc_t = Explorer::Halfedge_around_face_const_circulator;
-  Explorer E = p2.explorer();
-  for (fci_t fit = E.faces_begin(), facesend = E.faces_end(); fit != facesend; ++fit) {
-    if (!fit->mark()) continue;
-    heafcc_t fcirc(E.face_cycle(fit)), fend(fcirc);
-    add_outline_to_poly(E, fcirc, fend, true, *poly);
-    for (CGAL_Nef_polyhedron2::Explorer::Hole_const_iterator j = E.holes_begin(fit); j != E.holes_end(fit); ++j) {
-      CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator hcirc(j), hend(hcirc);
-      add_outline_to_poly(E, hcirc, hend, false, *poly);
+  Explorer E = p2.explorer ();
+  for (fci_t fit = E.faces_begin (), facesend = E.faces_end (); fit != facesend; ++fit) {
+    if (!fit->mark ())
+      continue;
+    heafcc_t fcirc (E.face_cycle (fit)), fend (fcirc);
+    add_outline_to_poly (E, fcirc, fend, true, *poly);
+    for (CGAL_Nef_polyhedron2::Explorer::Hole_const_iterator j = E.holes_begin (fit); j != E.holes_end (fit); ++j) {
+      CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator hcirc (j), hend (hcirc);
+      add_outline_to_poly (E, hcirc, hend, false, *poly);
     }
   }
-  poly->setSanitized(true);
+  poly->setSanitized (true);
   return poly;
 }
 
@@ -101,27 +101,24 @@ public:
   std::shared_ptr<CGAL_Nef_polyhedron2> tmpnef2d;
   std::shared_ptr<CGAL_Nef_polyhedron2> output_nefpoly2d;
   CGAL::Direction_3<CGAL_Kernel3> up;
-  ZRemover()
-  {
-    output_nefpoly2d = std::make_shared<CGAL_Nef_polyhedron2>();
+  ZRemover () {
+    output_nefpoly2d = std::make_shared<CGAL_Nef_polyhedron2> ();
     boundary = CGAL_Nef_polyhedron2::INCLUDED;
-    up = CGAL::Direction_3<CGAL_Kernel3>(0, 0, 1);
+    up = CGAL::Direction_3<CGAL_Kernel3> (0, 0, 1);
   }
-  void visit(CGAL_Nef_polyhedron3::Vertex_const_handle) {}
-  void visit(CGAL_Nef_polyhedron3::Halfedge_const_handle) {}
-  void visit(CGAL_Nef_polyhedron3::SHalfedge_const_handle) {}
-  void visit(CGAL_Nef_polyhedron3::SHalfloop_const_handle) {}
-  void visit(CGAL_Nef_polyhedron3::SFace_const_handle) {}
-  void visit(CGAL_Nef_polyhedron3::Halffacet_const_handle hfacet);
+  void visit (CGAL_Nef_polyhedron3::Vertex_const_handle) {}
+  void visit (CGAL_Nef_polyhedron3::Halfedge_const_handle) {}
+  void visit (CGAL_Nef_polyhedron3::SHalfedge_const_handle) {}
+  void visit (CGAL_Nef_polyhedron3::SHalfloop_const_handle) {}
+  void visit (CGAL_Nef_polyhedron3::SFace_const_handle) {}
+  void visit (CGAL_Nef_polyhedron3::Halffacet_const_handle hfacet);
 };
 
-
-void ZRemover::visit(CGAL_Nef_polyhedron3::Halffacet_const_handle hfacet)
-{
-  PRINTDB(" <!-- ZRemover Halffacet visit. Mark: %i --> ", hfacet->mark());
-  if (hfacet->plane().orthogonal_direction() != this->up) {
-    PRINTD("  <!-- ZRemover down-facing half-facet. skipping -->");
-    PRINTD(" <!-- ZRemover Halffacet visit end-->");
+void ZRemover::visit (CGAL_Nef_polyhedron3::Halffacet_const_handle hfacet) {
+  PRINTDB (" <!-- ZRemover Halffacet visit. Mark: %i --> ", hfacet->mark ());
+  if (hfacet->plane ().orthogonal_direction () != this->up) {
+    PRINTD ("  <!-- ZRemover down-facing half-facet. skipping -->");
+    PRINTD (" <!-- ZRemover Halffacet visit end-->");
     return;
   }
 
@@ -129,28 +126,30 @@ void ZRemover::visit(CGAL_Nef_polyhedron3::Halffacet_const_handle hfacet)
 
   CGAL_Nef_polyhedron3::Halffacet_cycle_const_iterator fci;
   int contour_counter = 0;
-  CGAL_forall_facet_cycles_of(fci, hfacet) {
-    if (fci.is_shalfedge()) {
-      PRINTD(" <!-- ZRemover Halffacet cycle begin -->");
-      CGAL_Nef_polyhedron3::SHalfedge_around_facet_const_circulator c1(fci), cend(c1);
+  CGAL_forall_facet_cycles_of (fci, hfacet) {
+    if (fci.is_shalfedge ()) {
+      PRINTD (" <!-- ZRemover Halffacet cycle begin -->");
+      CGAL_Nef_polyhedron3::SHalfedge_around_facet_const_circulator c1 (fci), cend (c1);
       std::vector<CGAL_Nef_polyhedron2::Explorer::Point> contour;
-      CGAL_For_all(c1, cend) {
-        CGAL_Nef_polyhedron3::Point_3 point3d = c1->source()->target()->point();
-        CGAL_Nef_polyhedron2::Explorer::Point point2d(CGAL::to_double(point3d.x()),
-                                                      CGAL::to_double(point3d.y()));
-        contour.push_back(point2d);
+      CGAL_For_all (c1, cend) {
+        CGAL_Nef_polyhedron3::Point_3 point3d = c1->source ()->target ()->point ();
+        CGAL_Nef_polyhedron2::Explorer::Point point2d (CGAL::to_double (point3d.x ()),
+                                                       CGAL::to_double (point3d.y ()));
+        contour.push_back (point2d);
       }
-      if (contour.size() == 0) continue;
+      if (contour.size () == 0)
+        continue;
 
-      if (OpenSCAD::debug != "") PRINTDB(" <!-- is_simple_2: %i -->", CGAL::is_simple_2(contour.begin(), contour.end()));
+      if (OpenSCAD::debug != "")
+        PRINTDB (" <!-- is_simple_2: %i -->", CGAL::is_simple_2 (contour.begin (), contour.end ()));
 
-      tmpnef2d = std::make_shared<CGAL_Nef_polyhedron2>(contour.begin(), contour.end(), boundary);
+      tmpnef2d = std::make_shared<CGAL_Nef_polyhedron2> (contour.begin (), contour.end (), boundary);
 
       if (contour_counter == 0) {
-        PRINTDB(" <!-- contour is a body. make union(). %i points -->", contour.size());
+        PRINTDB (" <!-- contour is a body. make union(). %i points -->", contour.size ());
         *(output_nefpoly2d) += *(tmpnef2d);
       } else {
-        PRINTDB(" <!-- contour is a hole. make intersection(). %i points -->", contour.size());
+        PRINTDB (" <!-- contour is a hole. make intersection(). %i points -->", contour.size ());
         *(output_nefpoly2d) *= *(tmpnef2d);
       }
 
@@ -161,90 +160,88 @@ void ZRemover::visit(CGAL_Nef_polyhedron3::Halffacet_const_handle hfacet)
 
       contour_counter++;
     } else {
-      PRINTD(" <!-- ZRemover trivial facet cycle skipped -->");
+      PRINTD (" <!-- ZRemover trivial facet cycle skipped -->");
     }
-    PRINTD(" <!-- ZRemover Halffacet cycle end -->");
+    PRINTD (" <!-- ZRemover Halffacet cycle end -->");
   }
-  PRINTD(" <!-- ZRemover Halffacet visit end -->");
+  PRINTD (" <!-- ZRemover Halffacet visit end -->");
 }
 
-
-
 namespace CGALUtils {
 
-std::unique_ptr<Polygon2d> project(const CGALNefGeometry& N, bool cut)
-{
+std::unique_ptr<Polygon2d> project (const CGALNefGeometry &N, bool cut) {
   std::unique_ptr<Polygon2d> poly;
-  if (N.getDimension() != 3) return poly;
+  if (N.getDimension () != 3)
+    return poly;
 
   CGALNefGeometry newN;
   if (cut) {
     try {
-      CGAL_Nef_polyhedron3::Plane_3 xy_plane = CGAL_Nef_polyhedron3::Plane_3(0, 0, 1, 0);
-      newN.p3 = std::make_shared<CGAL_Nef_polyhedron3>(N.p3->intersection(xy_plane, CGAL_Nef_polyhedron3::PLANE_ONLY));
-    } catch (const CGAL::Failure_exception& e) {
-      PRINTDB("CGALUtils::project during plane intersection: %s", e.what());
+      CGAL_Nef_polyhedron3::Plane_3 xy_plane = CGAL_Nef_polyhedron3::Plane_3 (0, 0, 1, 0);
+      newN.p3 = std::make_shared<CGAL_Nef_polyhedron3> (N.p3->intersection (xy_plane, CGAL_Nef_polyhedron3::PLANE_ONLY));
+    } catch (const CGAL::Failure_exception &e) {
+      PRINTDB ("CGALUtils::project during plane intersection: %s", e.what ());
       try {
-        PRINTD("Trying alternative intersection using very large thin box: ");
+        PRINTD ("Trying alternative intersection using very large thin box: ");
         std::vector<CGAL_Point_3> pts;
         // don't use z of 0. there are bugs in CGAL.
         double inf = 1e8;
         double eps = 0.001;
-        CGAL_Point_3 minpt(-inf, -inf, -eps);
-        CGAL_Point_3 maxpt(inf,  inf,  eps);
-        CGAL_Iso_cuboid_3 bigcuboid(minpt, maxpt);
-        pts.reserve(8);
-        for (int i = 0; i < 8; ++i) pts.push_back(bigcuboid.vertex(i));
+        CGAL_Point_3 minpt (-inf, -inf, -eps);
+        CGAL_Point_3 maxpt (inf, inf, eps);
+        CGAL_Iso_cuboid_3 bigcuboid (minpt, maxpt);
+        pts.reserve (8);
+        for (int i = 0; i < 8; ++i)
+          pts.push_back (bigcuboid.vertex (i));
         CGAL_Polyhedron bigbox;
-        CGAL::convex_hull_3(pts.begin(), pts.end(), bigbox);
-        CGAL_Nef_polyhedron3 nef_bigbox(bigbox);
-        newN.p3 = std::make_shared<CGAL_Nef_polyhedron3>(nef_bigbox.intersection(*N.p3));
-      } catch (const CGAL::Failure_exception& e) {
-        LOG(message_group::Error, " CGAL error in CGALUtils::project during bigbox intersection: %1$s", e.what());
-
+        CGAL::convex_hull_3 (pts.begin (), pts.end (), bigbox);
+        CGAL_Nef_polyhedron3 nef_bigbox (bigbox);
+        newN.p3 = std::make_shared<CGAL_Nef_polyhedron3> (nef_bigbox.intersection (*N.p3));
+      } catch (const CGAL::Failure_exception &e) {
+        LOG (message_group::Error, " CGAL error in CGALUtils::project during bigbox intersection: %1$s", e.what ());
       }
     }
 
-    if (!newN.p3 || newN.p3->is_empty()) {
-      LOG(message_group::Warning, "Projection() failed.");
+    if (!newN.p3 || newN.p3->is_empty ()) {
+      LOG (message_group::Warning, "Projection() failed.");
       return poly;
     }
 
-    PRINTDB("%s", OpenSCAD::svg_header(480, 100000));
+    PRINTDB ("%s", OpenSCAD::svg_header (480, 100000));
     try {
       ZRemover zremover;
       CGAL_Nef_polyhedron3::Volume_const_iterator i;
       CGAL_Nef_polyhedron3::Shell_entry_const_iterator j;
       CGAL_Nef_polyhedron3::SFace_const_handle sface_handle;
-      for (i = newN.p3->volumes_begin(); i != newN.p3->volumes_end(); ++i) {
-        PRINTDB("<!-- volume. mark: %s -->", i->mark());
-        for (j = i->shells_begin(); j != i->shells_end(); ++j) {
-          PRINTDB("<!-- shell. (vol mark was: %i)", i->mark());
-          sface_handle = CGAL_Nef_polyhedron3::SFace_const_handle(j);
-          newN.p3->visit_shell_objects(sface_handle, zremover);
-          PRINTD("<!-- shell. end. -->");
+      for (i = newN.p3->volumes_begin (); i != newN.p3->volumes_end (); ++i) {
+        PRINTDB ("<!-- volume. mark: %s -->", i->mark ());
+        for (j = i->shells_begin (); j != i->shells_end (); ++j) {
+          PRINTDB ("<!-- shell. (vol mark was: %i)", i->mark ());
+          sface_handle = CGAL_Nef_polyhedron3::SFace_const_handle (j);
+          newN.p3->visit_shell_objects (sface_handle, zremover);
+          PRINTD ("<!-- shell. end. -->");
         }
-        PRINTD("<!-- volume end. -->");
+        PRINTD ("<!-- volume end. -->");
       }
-      poly = convertToPolygon2d(*zremover.output_nefpoly2d);
-    } catch (const CGAL::Failure_exception& e) {
-      LOG(message_group::Error, "CGAL error in CGALUtils::project while flattening: %1$s", e.what());
+      poly = convertToPolygon2d (*zremover.output_nefpoly2d);
+    } catch (const CGAL::Failure_exception &e) {
+      LOG (message_group::Error, "CGAL error in CGALUtils::project while flattening: %1$s", e.what ());
     }
-    PRINTD("</svg>");
+    PRINTD ("</svg>");
 
   }
   // In projection mode all the triangles are projected manually into the XY plane
   else {
-    if (auto ps = CGALUtils::createPolySetFromNefPolyhedron3(*N.p3)) {
-      poly = PolySetUtils::project(*ps);
+    if (auto ps = CGALUtils::createPolySetFromNefPolyhedron3 (*N.p3)) {
+      poly = PolySetUtils::project (*ps);
     } else {
-      LOG(message_group::Error, "Nef->PolySet failed");
+      LOG (message_group::Error, "Nef->PolySet failed");
       return poly;
     }
   }
   return poly;
 }
 
-} // namespace
+} // namespace CGALUtils
 
 #endif // ENABLE_CGAL
diff --git a/src/geometry/cgal/cgalutils-tess.cc b/src/geometry/cgal/cgalutils-tess.cc
index 7761a433c..6e850cec1 100644
--- a/src/geometry/cgal/cgalutils-tess.cc
+++ b/src/geometry/cgal/cgalutils-tess.cc
@@ -19,59 +19,60 @@ using Projection = CGAL::Filtered_projection_traits_3<Tess_kernel>;
 
 struct FaceInfo {
   int nesting_level;
-  bool in_domain() { return nesting_level % 2 == 1; }
+  bool in_domain () {
+    return nesting_level % 2 == 1;
+  }
 };
 
 using Fbb = CGAL::Triangulation_face_base_with_info_2<FaceInfo, Tess_kernel>;
 using Tds = CGAL::Triangulation_data_structure_2<CGAL::Triangulation_vertex_base_2<Projection>, CGAL::Constrained_triangulation_face_base_2<Projection, Fbb>>;
 using CDT = CGAL::Constrained_Delaunay_triangulation_2<Projection, Tds, CGAL::Exact_predicates_tag>;
 
-
-static void mark_domains(CDT& ct,
-                         CDT::Face_handle start,
-                         int index,
-                         std::list<CDT::Edge>& border)
-{
-  if (start->info().nesting_level != -1) return;
+static void mark_domains (CDT &ct,
+                          CDT::Face_handle start,
+                          int index,
+                          std::list<CDT::Edge> &border) {
+  if (start->info ().nesting_level != -1)
+    return;
   std::list<CDT::Face_handle> queue;
-  queue.push_back(start);
-  while (!queue.empty()) {
-    CDT::Face_handle fh = queue.front();
-    queue.pop_front();
-    if (fh->info().nesting_level == -1) {
-      fh->info().nesting_level = index;
+  queue.push_back (start);
+  while (!queue.empty ()) {
+    CDT::Face_handle fh = queue.front ();
+    queue.pop_front ();
+    if (fh->info ().nesting_level == -1) {
+      fh->info ().nesting_level = index;
       for (int i = 0; i < 3; ++i) {
-        CDT::Edge e(fh, i);
-        CDT::Face_handle n = fh->neighbor(i);
-        if (n->info().nesting_level == -1) {
-          if (ct.is_constrained(e)) border.push_back(e);
-          else queue.push_back(n);
+        CDT::Edge e (fh, i);
+        CDT::Face_handle n = fh->neighbor (i);
+        if (n->info ().nesting_level == -1) {
+          if (ct.is_constrained (e))
+            border.push_back (e);
+          else
+            queue.push_back (n);
         }
       }
     }
   }
 }
 
-
 //explore set of facets connected with non constrained edges,
 //and attribute to each such set a nesting level.
 //We start from facets incident to the infinite vertex, with a nesting
 //level of 0. Then we recursively consider the non-explored facets incident
 //to constrained edges bounding the former set and increase the nesting level by 1.
 //Facets in the domain are those with an odd nesting level.
-static void mark_domains(CDT& cdt)
-{
-  for (CDT::All_faces_iterator it = cdt.all_faces_begin(); it != cdt.all_faces_end(); ++it) {
-    it->info().nesting_level = -1;
+static void mark_domains (CDT &cdt) {
+  for (CDT::All_faces_iterator it = cdt.all_faces_begin (); it != cdt.all_faces_end (); ++it) {
+    it->info ().nesting_level = -1;
   }
   std::list<CDT::Edge> border;
-  mark_domains(cdt, cdt.infinite_face(), 0, border);
-  while (!border.empty()) {
-    CDT::Edge e = border.front();
-    border.pop_front();
-    CDT::Face_handle n = e.first->neighbor(e.second);
-    if (n->info().nesting_level == -1) {
-      mark_domains(cdt, n, e.first->info().nesting_level + 1, border);
+  mark_domains (cdt, cdt.infinite_face (), 0, border);
+  while (!border.empty ()) {
+    CDT::Edge e = border.front ();
+    border.pop_front ();
+    CDT::Face_handle n = e.first->neighbor (e.second);
+    if (n->info ().nesting_level == -1) {
+      mark_domains (cdt, n, e.first->info ().nesting_level + 1, border);
     }
   }
 }
@@ -87,69 +88,70 @@ namespace CGALUtils {
 
    The resulting triangles is added to the given triangles vector.
  */
-bool tessellatePolygonWithHoles(const std::vector<std::vector<CGAL::Point_3<CGAL::Epick>>>& polygons,
-                                Polygons& triangles,
-                                const CGAL::Vector_3<CGAL::Epick> *normal)
-{
+bool tessellatePolygonWithHoles (const std::vector<std::vector<CGAL::Point_3<CGAL::Epick>>> &polygons,
+                                 Polygons &triangles,
+                                 const CGAL::Vector_3<CGAL::Epick> *normal) {
   // No polygon. FIXME: Will this ever happen or can we assert here?
-  if (polygons.empty()) return false;
+  if (polygons.empty ())
+    return false;
 
   // No hole
-  if (polygons.size() == 1) return tessellatePolygon(polygons.front(), triangles, normal);
+  if (polygons.size () == 1)
+    return tessellatePolygon (polygons.front (), triangles, normal);
 
   CGAL::Vector_3<CGAL::Epick> normalvec;
   if (normal) {
     normalvec = *normal;
   } else {
     // Calculate best guess at face normal using Newell's method
-    CGAL::normal_vector_newell_3(polygons.front().begin(), polygons.front().end(), normalvec);
+    CGAL::normal_vector_newell_3 (polygons.front ().begin (), polygons.front ().end (), normalvec);
   }
-  double sqrl = normalvec.squared_length();
-  if (sqrl > 0.0) normalvec = normalvec / sqrt(sqrl);
+  double sqrl = normalvec.squared_length ();
+  if (sqrl > 0.0)
+    normalvec = normalvec / sqrt (sqrl);
 
   // Pass the normal vector to the (undocumented)
   // CGAL::Triangulation_2_filtered_projection_traits_3. This
   // trait deals with projection from 3D to 2D using the normal
   // vector as a hint, and allows for near-planar polygons to be passed to
   // the Constrained Delaunay Triangulator.
-  Projection actualProjection(normalvec);
-  CDT cdt(actualProjection);
-  for (const auto& poly : polygons) {
-    for (size_t i = 0; i < poly.size(); ++i) {
-      cdt.insert_constraint(poly[i], poly[(i + 1) % poly.size()]);
+  Projection actualProjection (normalvec);
+  CDT cdt (actualProjection);
+  for (const auto &poly : polygons) {
+    for (size_t i = 0; i < poly.size (); ++i) {
+      cdt.insert_constraint (poly[i], poly[(i + 1) % poly.size ()]);
     }
   }
 
   //Mark facets that are inside the domain bounded by the polygon
-  mark_domains(cdt);
+  mark_domains (cdt);
 
   // Iterate over the resulting faces
-  for (CDT::Finite_faces_iterator fit = cdt.finite_faces_begin();
-       fit != cdt.finite_faces_end(); fit++) {
-    if (fit->info().in_domain()) {
+  for (CDT::Finite_faces_iterator fit = cdt.finite_faces_begin ();
+       fit != cdt.finite_faces_end (); fit++) {
+    if (fit->info ().in_domain ()) {
       Polygon tri;
       for (int i = 0; i < 3; ++i) {
-        CGAL::Point_3<CGAL::Epick> v = cdt.triangle(fit)[i];
-        tri.push_back(Vector3d(v.x(), v.y(), v.z()));
+        CGAL::Point_3<CGAL::Epick> v = cdt.triangle (fit)[i];
+        tri.push_back (Vector3d (v.x (), v.y (), v.z ()));
       }
-      triangles.push_back(tri);
+      triangles.push_back (tri);
     }
   }
 
   return false;
 }
 
-bool tessellatePolygon(const std::vector<CGAL::Point_3<CGAL::Epick>>& polygon,
-                       Polygons& triangles,
-                       const CGAL::Vector_3<CGAL::Epick> *normal)
-{
-  if (polygon.size() == 3) {
-    PRINTD("input polygon has 3 points. shortcut tessellation.");
+bool tessellatePolygon (const std::vector<CGAL::Point_3<CGAL::Epick>> &polygon,
+                        Polygons &triangles,
+                        const CGAL::Vector_3<CGAL::Epick> *normal) {
+  if (polygon.size () == 3) {
+    PRINTD ("input polygon has 3 points. shortcut tessellation.");
     Polygon t;
-    t.push_back(Vector3d(polygon[0].x(), polygon[0].y(), polygon[0].z()));
-    t.push_back(Vector3d(polygon[1].x(), polygon[1].y(), polygon[1].z()));
-    t.push_back(Vector3d(polygon[2].x(), polygon[2].y(), polygon[2].z()));
-    triangles.push_back(t);
+    t.push_back (Vector3d (polygon[0].x (), polygon[0].y (), polygon[0].z ()));
+    t.push_back (Vector3d (polygon[1].x (), polygon[1].y (), polygon[1].z ()));
+    t.push_back (Vector3d (polygon[2].x (), polygon[2].y (), polygon[2].z ()));
+    triangles.push_back (t);
     return false;
   }
 
@@ -158,39 +160,40 @@ bool tessellatePolygon(const std::vector<CGAL::Point_3<CGAL::Epick>>& polygon,
     normalvec = *normal;
   } else {
     // Calculate best guess at face normal using Newell's method
-    CGAL::normal_vector_newell_3(polygon.begin(), polygon.end(), normalvec);
+    CGAL::normal_vector_newell_3 (polygon.begin (), polygon.end (), normalvec);
   }
-  double sqrl = normalvec.squared_length();
-  if (sqrl > 0.0) normalvec = normalvec / sqrt(sqrl);
+  double sqrl = normalvec.squared_length ();
+  if (sqrl > 0.0)
+    normalvec = normalvec / sqrt (sqrl);
 
   // Pass the normal vector to the (undocumented)
   // CGAL::Triangulation_2_filtered_projection_traits_3. This
   // trait deals with projection from 3D to 2D using the normal
   // vector as a hint, and allows for near-planar polygons to be passed to
   // the Constrained Delaunay Triangulator.
-  Projection actualProjection(normalvec);
-  CDT cdt(actualProjection);
-  for (size_t i = 0; i < polygon.size(); ++i) {
-    cdt.insert_constraint(polygon[i], polygon[(i + 1) % polygon.size()]);
+  Projection actualProjection (normalvec);
+  CDT cdt (actualProjection);
+  for (size_t i = 0; i < polygon.size (); ++i) {
+    cdt.insert_constraint (polygon[i], polygon[(i + 1) % polygon.size ()]);
   }
 
   //Mark facets that are inside the domain bounded by the polygon
-  mark_domains(cdt);
+  mark_domains (cdt);
 
   // Iterate over the resulting faces
   CDT::Finite_faces_iterator fit;
-  for (fit = cdt.finite_faces_begin(); fit != cdt.finite_faces_end(); ++fit) {
-    if (fit->info().in_domain()) {
+  for (fit = cdt.finite_faces_begin (); fit != cdt.finite_faces_end (); ++fit) {
+    if (fit->info ().in_domain ()) {
       Polygon tri;
       for (int i = 0; i < 3; ++i) {
-        Tess_kernel::Point_3 v = cdt.triangle(fit)[i];
-        tri.push_back(Vector3d(v.x(), v.y(), v.z()));
+        Tess_kernel::Point_3 v = cdt.triangle (fit)[i];
+        tri.push_back (Vector3d (v.x (), v.y (), v.z ()));
       }
-      triangles.push_back(tri);
+      triangles.push_back (tri);
     }
   }
 
   return false;
 }
 
-}  // namespace CGALUtils
+} // namespace CGALUtils
diff --git a/src/geometry/cgal/cgalutils-triangulate.cc b/src/geometry/cgal/cgalutils-triangulate.cc
index b8ce0bbfe..a1afb84bb 100644
--- a/src/geometry/cgal/cgalutils-triangulate.cc
+++ b/src/geometry/cgal/cgalutils-triangulate.cc
@@ -20,11 +20,12 @@ namespace CGALUtils {
 
 namespace Polygon2DCGAL {
 
-struct FaceInfo
-{
-  FaceInfo() = default;
+struct FaceInfo {
+  FaceInfo () = default;
   int nesting_level{42};
-  [[nodiscard]] bool in_domain() const { return nesting_level % 2 == 1; }
+  [[nodiscard]] bool in_domain () const {
+    return nesting_level % 2 == 1;
+  }
 };
 
 struct IdInfo {
@@ -41,28 +42,29 @@ using CDT = CGAL::Constrained_Delaunay_triangulation_2<K, TDS, Itag>;
 using Point = CDT::Point;
 using Polygon_2 = CGAL::Polygon_2<K>;
 
-void
-mark_domains(CDT& ct,
-             CDT::Face_handle start,
-             int index,
-             std::list<CDT::Edge>& border)
-{
-  if (start->info().nesting_level != -1) return;
+void mark_domains (CDT &ct,
+                   CDT::Face_handle start,
+                   int index,
+                   std::list<CDT::Edge> &border) {
+  if (start->info ().nesting_level != -1)
+    return;
 
   std::list<CDT::Face_handle> queue;
-  queue.push_back(start);
+  queue.push_back (start);
 
-  while (!queue.empty()) {
-    auto fh = queue.front();
-    queue.pop_front();
-    if (fh->info().nesting_level == -1) {
-      fh->info().nesting_level = index;
+  while (!queue.empty ()) {
+    auto fh = queue.front ();
+    queue.pop_front ();
+    if (fh->info ().nesting_level == -1) {
+      fh->info ().nesting_level = index;
       for (int i = 0; i < 3; ++i) {
-        CDT::Edge e(fh, i);
-        auto n = fh->neighbor(i);
-        if (n->info().nesting_level == -1) {
-          if (ct.is_constrained(e)) border.push_back(e);
-          else queue.push_back(n);
+        CDT::Edge e (fh, i);
+        auto n = fh->neighbor (i);
+        if (n->info ().nesting_level == -1) {
+          if (ct.is_constrained (e))
+            border.push_back (e);
+          else
+            queue.push_back (n);
         }
       }
     }
@@ -75,22 +77,20 @@ mark_domains(CDT& ct,
 // level of 0. Then we recursively consider the non-explored facets incident
 // to constrained edges bounding the former set and increase the nesting level by 1.
 // Facets in the domain are those with an odd nesting level.
-void
-mark_domains(CDT& cdt)
-{
-  for (CDT::All_faces_iterator it = cdt.all_faces_begin(); it != cdt.all_faces_end(); ++it) {
-    it->info().nesting_level = -1;
+void mark_domains (CDT &cdt) {
+  for (CDT::All_faces_iterator it = cdt.all_faces_begin (); it != cdt.all_faces_end (); ++it) {
+    it->info ().nesting_level = -1;
   }
 
   int index = 0;
   std::list<CDT::Edge> border;
-  mark_domains(cdt, cdt.infinite_face(), index++, border);
-  while (!border.empty()) {
-    CDT::Edge e = border.front();
-    border.pop_front();
-    CDT::Face_handle n = e.first->neighbor(e.second);
-    if (n->info().nesting_level == -1) {
-      mark_domains(cdt, n, e.first->info().nesting_level + 1, border);
+  mark_domains (cdt, cdt.infinite_face (), index++, border);
+  while (!border.empty ()) {
+    CDT::Edge e = border.front ();
+    border.pop_front ();
+    CDT::Face_handle n = e.first->neighbor (e.second);
+    if (n->info ().nesting_level == -1) {
+      mark_domains (cdt, n, e.first->info ().nesting_level + 1, border);
     }
   }
 }
@@ -98,69 +98,66 @@ mark_domains(CDT& cdt)
 } // namespace Polygon2DCGAL
 
 template <typename SurfaceMesh>
-void triangulateFaces(SurfaceMesh& mesh)
-{
-  CGAL::Polygon_mesh_processing::triangulate_faces(mesh);
+void triangulateFaces (SurfaceMesh &mesh) {
+  CGAL::Polygon_mesh_processing::triangulate_faces (mesh);
 }
 
-template void triangulateFaces(CGAL::Surface_mesh<CGAL::Point_3<CGAL::Epick>>& polyhedron);
+template void triangulateFaces (CGAL::Surface_mesh<CGAL::Point_3<CGAL::Epick>> &polyhedron);
 
-std::unique_ptr<PolySet> createTriangulatedPolySetFromPolygon2d(const Polygon2d& polygon2d)
-{
-  auto polyset = std::make_unique<PolySet>(2);
-  polyset->setTriangular(true);
+std::unique_ptr<PolySet> createTriangulatedPolySetFromPolygon2d (const Polygon2d &polygon2d) {
+  auto polyset = std::make_unique<PolySet> (2);
+  polyset->setTriangular (true);
 
   Polygon2DCGAL::CDT cdt; // Uses a constrained Delaunay triangulator.
 
   try {
     // Adds all vertices, and add all contours as constraints.
-    for (const auto& outline : polygon2d.outlines()) {
+    for (const auto &outline : polygon2d.outlines ()) {
       Polygon2DCGAL::CDT::Vertex_handle prev;
-      for (int i = 0; i <= outline.vertices.size(); i++) {
-        const int idx = i % outline.vertices.size();
-        const auto& v = outline.vertices[idx];
-        auto curr = cdt.insert({v[0], v[1]});
+      for (int i = 0; i <= outline.vertices.size (); i++) {
+        const int idx = i % outline.vertices.size ();
+        const auto &v = outline.vertices[idx];
+        auto curr = cdt.insert ({v[0], v[1]});
         // FIXME: We need be make sure that client relying on vertex indices being
         // maintained also skips coincident vertices the same way.
         if (curr != prev) {
           // Don't add the first vertex twice
-          if (i < outline.vertices.size()) {
-            polyset->vertices.emplace_back(v[0], v[1], 0.0);
-            curr->info().id = polyset->vertices.size() - 1;
+          if (i < outline.vertices.size ()) {
+            polyset->vertices.emplace_back (v[0], v[1], 0.0);
+            curr->info ().id = polyset->vertices.size () - 1;
           }
-          if (prev != nullptr) cdt.insert_constraint(prev, curr);
+          if (prev != nullptr)
+            cdt.insert_constraint (prev, curr);
           prev = curr;
         }
       }
     }
 
-  } catch (const CGAL::Precondition_exception& e) {
-    LOG("CGAL error in Polygon2d::tesselate(): %1$s", e.what());
+  } catch (const CGAL::Precondition_exception &e) {
+    LOG ("CGAL error in Polygon2d::tesselate(): %1$s", e.what ());
     return nullptr;
   }
 
   // To extract triangles which is part of our polygon, we need to filter away
   // triangles inside holes.
-  mark_domains(cdt);
-  for (auto fit = cdt.finite_faces_begin(); fit != cdt.finite_faces_end(); ++fit) {
-    if (fit->info().in_domain()) {
+  mark_domains (cdt);
+  for (auto fit = cdt.finite_faces_begin (); fit != cdt.finite_faces_end (); ++fit) {
+    if (fit->info ().in_domain ()) {
       // If this assert hits, it means that the polygon2d somehow contains
       // self-intersecting or intersecting constraints. This shouldn't happen
       // since Clipper guarantees no overlaps, but could happen if we lose
       // precision from converting from Clipper's coordinate space (int64) to Polygon2's (double).
       // One possible workaround is to reduce Clipper's precision further,
       // see https://github.com/openscad/openscad/issues/5253.
-      assert(fit->vertex(0)->info().id != -1);
-      assert(fit->vertex(1)->info().id != -1);
-      assert(fit->vertex(2)->info().id != -1);
-      polyset->indices.push_back({
-          fit->vertex(0)->info().id,
-          fit->vertex(1)->info().id,
-          fit->vertex(2)->info().id});
+      assert (fit->vertex (0)->info ().id != -1);
+      assert (fit->vertex (1)->info ().id != -1);
+      assert (fit->vertex (2)->info ().id != -1);
+      polyset->indices.push_back ({fit->vertex (0)->info ().id,
+                                   fit->vertex (1)->info ().id,
+                                   fit->vertex (2)->info ().id});
     }
   }
   return polyset;
 }
 
 } // namespace CGALUtils
-
diff --git a/src/geometry/cgal/cgalutils.cc b/src/geometry/cgal/cgalutils.cc
index 4d91fb033..066b54dab 100644
--- a/src/geometry/cgal/cgalutils.cc
+++ b/src/geometry/cgal/cgalutils.cc
@@ -42,115 +42,118 @@ namespace CGALUtils {
 // TODO: We could rewrite this to use PolygonMeshProcessing concepts, similar to how
 // we create Manifold geometries from PolySet; convert via Surface_mesh, check if it's closed,
 // use repair|orient_polygon_soup, etc.
-std::unique_ptr<CGALNefGeometry> createNefPolyhedronFromPolySet(const PolySet& ps)
-{
-  if (ps.isEmpty()) return std::make_unique<CGALNefGeometry>();
-  assert(ps.getDimension() == 3);
+std::unique_ptr<CGALNefGeometry> createNefPolyhedronFromPolySet (const PolySet &ps) {
+  if (ps.isEmpty ())
+    return std::make_unique<CGALNefGeometry> ();
+  assert (ps.getDimension () == 3);
 
   // Since is_convex doesn't work well with non-planar faces,
   // we tessellate the polyset before checking.
-  PolySet psq(ps);
+  PolySet psq (ps);
   std::vector<Vector3d> points3d;
-  psq.quantizeVertices(&points3d);
-  auto ps_tri = PolySetUtils::tessellate_faces(psq);
-  if (ps_tri->isConvex()) {
+  psq.quantizeVertices (&points3d);
+  auto ps_tri = PolySetUtils::tessellate_faces (psq);
+  if (ps_tri->isConvex ()) {
     using Hull_kernel = CGAL::Epick;
     // Collect point cloud
-    std::vector<Hull_kernel::Point_3> points(points3d.size());
-    for (size_t i = 0, n = points3d.size(); i < n; i++) {
-      points[i] = vector_convert<Hull_kernel::Point_3>(points3d[i]);
+    std::vector<Hull_kernel::Point_3> points (points3d.size ());
+    for (size_t i = 0, n = points3d.size (); i < n; i++) {
+      points[i] = vector_convert<Hull_kernel::Point_3> (points3d[i]);
     }
 
-    if (points.size() <= 3) return std::make_unique<CGALNefGeometry>();
+    if (points.size () <= 3)
+      return std::make_unique<CGALNefGeometry> ();
 
     // Apply hull
     CGAL::Polyhedron_3<Hull_kernel> r;
-    CGAL::convex_hull_3(points.begin(), points.end(), r);
+    CGAL::convex_hull_3 (points.begin (), points.end (), r);
     CGAL_Polyhedron r_exact;
-    CGALUtils::copyPolyhedron(r, r_exact);
-    return std::make_unique<CGALNefGeometry>(std::make_shared<CGAL_Nef_polyhedron3>(r_exact));
+    CGALUtils::copyPolyhedron (r, r_exact);
+    return std::make_unique<CGALNefGeometry> (std::make_shared<CGAL_Nef_polyhedron3> (r_exact));
   }
 
   std::shared_ptr<CGAL_Nef_polyhedron3> N;
   auto plane_error = false;
   try {
     CGAL_Polyhedron P;
-    auto err = CGALUtils::createPolyhedronFromPolySet(psq, P);
+    auto err = CGALUtils::createPolyhedronFromPolySet (psq, P);
     if (!err) {
-      if (!P.is_closed()) {
-        LOG(message_group::Error, "The given mesh is not closed! Unable to convert to CGALNefGeometry.");
-      } else if (!P.is_valid(false, 0)) {
-        LOG(message_group::Error, "The given mesh is invalid! Unable to convert to CGALNefGeometry.");
+      if (!P.is_closed ()) {
+        LOG (message_group::Error, "The given mesh is not closed! Unable to convert to CGALNefGeometry.");
+      } else if (!P.is_valid (false, 0)) {
+        LOG (message_group::Error, "The given mesh is invalid! Unable to convert to CGALNefGeometry.");
       } else {
-        N = std::make_shared<CGAL_Nef_polyhedron3>(P);
+        N = std::make_shared<CGAL_Nef_polyhedron3> (P);
       }
     }
-  } catch (const CGAL::Assertion_exception& e) {
+  } catch (const CGAL::Assertion_exception &e) {
     // First two tests matches against CGAL < 4.10, the last two tests matches against CGAL >= 4.10
-    if ((std::string(e.what()).find("Plane_constructor") != std::string::npos &&
-         std::string(e.what()).find("has_on") != std::string::npos) ||
-        std::string(e.what()).find("ss_plane.has_on(sv_prev->point())") != std::string::npos ||
-        std::string(e.what()).find("ss_circle.has_on(sp)") != std::string::npos) {
-      LOG("PolySet has nonplanar faces. Attempting alternate construction");
+    if ((std::string (e.what ()).find ("Plane_constructor") != std::string::npos &&
+         std::string (e.what ()).find ("has_on") != std::string::npos) ||
+        std::string (e.what ()).find ("ss_plane.has_on(sv_prev->point())") != std::string::npos ||
+        std::string (e.what ()).find ("ss_circle.has_on(sp)") != std::string::npos) {
+      LOG ("PolySet has nonplanar faces. Attempting alternate construction");
       plane_error = true;
     } else {
-      LOG(message_group::Error, "CGAL error in CGAL_Nef_polyhedron3(): %1$s", e.what());
+      LOG (message_group::Error, "CGAL error in CGAL_Nef_polyhedron3(): %1$s", e.what ());
     }
   }
-  if (plane_error) try {
+  if (plane_error)
+    try {
       CGAL_Polyhedron P;
-      auto err = CGALUtils::createPolyhedronFromPolySet(*ps_tri, P);
+      auto err = CGALUtils::createPolyhedronFromPolySet (*ps_tri, P);
       if (!err) {
-        PRINTDB("Polyhedron is closed: %d", P.is_closed());
-        PRINTDB("Polyhedron is valid: %d", P.is_valid(false, 0));
+        PRINTDB ("Polyhedron is closed: %d", P.is_closed ());
+        PRINTDB ("Polyhedron is valid: %d", P.is_valid (false, 0));
       }
-      if (!err) N = std::make_shared<CGAL_Nef_polyhedron3>(P);
-    } catch (const CGAL::Assertion_exception& e) {
-      LOG(message_group::Error, "Alternate construction failed. CGAL error in CGAL_Nef_polyhedron3(): %1$s", e.what());
+      if (!err)
+        N = std::make_shared<CGAL_Nef_polyhedron3> (P);
+    } catch (const CGAL::Assertion_exception &e) {
+      LOG (message_group::Error, "Alternate construction failed. CGAL error in CGAL_Nef_polyhedron3(): %1$s", e.what ());
     }
-  return std::make_unique<CGALNefGeometry>(N);
+  return std::make_unique<CGALNefGeometry> (N);
 }
 
 template <typename K>
-CGAL::Iso_cuboid_3<K> boundingBox(const CGAL::Nef_polyhedron_3<K>& N)
-{
-  CGAL::Iso_cuboid_3<K> result(0, 0, 0, 0, 0, 0);
+CGAL::Iso_cuboid_3<K> boundingBox (const CGAL::Nef_polyhedron_3<K> &N) {
+  CGAL::Iso_cuboid_3<K> result (0, 0, 0, 0, 0, 0);
   typename CGAL::Nef_polyhedron_3<K>::Vertex_const_iterator vi;
   std::vector<typename CGAL::Point_3<K>> points;
   // can be optimized by rewriting bounding_box to accept vertices
-  CGAL_forall_vertices(vi, N) points.push_back(vi->point());
-  if (points.size()) result = CGAL::bounding_box(points.begin(), points.end());
+  CGAL_forall_vertices (vi, N) points.push_back (vi->point ());
+  if (points.size ())
+    result = CGAL::bounding_box (points.begin (), points.end ());
   return result;
 }
-template CGAL_Iso_cuboid_3 boundingBox(const CGAL_Nef_polyhedron3& N);
+template CGAL_Iso_cuboid_3 boundingBox (const CGAL_Nef_polyhedron3 &N);
 
-CGAL_Iso_cuboid_3 createIsoCuboidFromBoundingBox(const BoundingBox& bbox)
-{
-  return {vector_convert<CGAL_Point_3>(bbox.min()),
-          vector_convert<CGAL_Point_3>(bbox.max())};
+CGAL_Iso_cuboid_3 createIsoCuboidFromBoundingBox (const BoundingBox &bbox) {
+  return {vector_convert<CGAL_Point_3> (bbox.min ()),
+          vector_convert<CGAL_Point_3> (bbox.max ())};
 }
 
 namespace {
 
 // lexicographic comparison
-bool operator<(Vector3d const& a, Vector3d const& b) {
+bool operator< (Vector3d const &a, Vector3d const &b) {
   for (int i = 0; i < 3; ++i) {
-    if (a[i] < b[i]) return true;
-    else if (a[i] == b[i]) continue;
+    if (a[i] < b[i])
+      return true;
+    else if (a[i] == b[i])
+      continue;
     return false;
   }
   return false;
 }
-}
+} // namespace
 
 struct VecPairCompare {
-  bool operator()(std::pair<Vector3d, Vector3d> const& a,
-                  std::pair<Vector3d, Vector3d> const& b) const {
+  bool operator() (std::pair<Vector3d, Vector3d> const &a,
+                   std::pair<Vector3d, Vector3d> const &b) const {
     return a.first < b.first || (!(b.first < a.first) && a.second < b.second);
   }
 };
 
-
 /*!
    Check if all faces of a polyset is within 0.1 degree of being convex.
 
@@ -158,9 +161,9 @@ struct VecPairCompare {
    non-planar faces. To be on the safe side, consider passing a tessellated polyset.
    See issue #1061.
  */
-bool is_approximately_convex(const PolySet& ps) {
+bool is_approximately_convex (const PolySet &ps) {
 
-  const double angle_threshold = cos_degrees(.1); // .1
+  const double angle_threshold = cos_degrees (.1); // .1
 
   using K = CGAL_DoubleKernel;
   using Vector = K::Vector_3;
@@ -172,45 +175,48 @@ bool is_approximately_convex(const PolySet& ps) {
   using Edge_to_facet_map = std::map<Edge, int, VecPairCompare>;
   Edge_to_facet_map edge_to_facet_map;
   std::vector<Plane> facet_planes;
-  facet_planes.reserve(ps.indices.size());
+  facet_planes.reserve (ps.indices.size ());
 
-  for (size_t i = 0; i < ps.indices.size(); ++i) {
+  for (size_t i = 0; i < ps.indices.size (); ++i) {
     Plane plane;
-    auto N = ps.indices[i].size();
+    auto N = ps.indices[i].size ();
     if (N >= 3) {
-      std::vector<Point> v(N);
+      std::vector<Point> v (N);
       for (size_t j = 0; j < N; ++j) {
-        v[j] = vector_convert<Point>(ps.vertices[ps.indices[i][j]]);
-        Edge edge(ps.vertices[ps.indices[i][j]], ps.vertices[ps.indices[i][(j + 1) % N]]);
-        if (edge_to_facet_map.count(edge)) return false; // edge already exists: nonmanifold
+        v[j] = vector_convert<Point> (ps.vertices[ps.indices[i][j]]);
+        Edge edge (ps.vertices[ps.indices[i][j]], ps.vertices[ps.indices[i][(j + 1) % N]]);
+        if (edge_to_facet_map.count (edge))
+          return false; // edge already exists: nonmanifold
         edge_to_facet_map[edge] = i;
       }
       Vector normal;
-      CGAL::normal_vector_newell_3(v.begin(), v.end(), normal);
-      plane = Plane(v[0], normal);
+      CGAL::normal_vector_newell_3 (v.begin (), v.end (), normal);
+      plane = Plane (v[0], normal);
     }
-    facet_planes.push_back(plane);
+    facet_planes.push_back (plane);
   }
 
-  for (size_t i = 0; i < ps.indices.size(); ++i) {
-    auto N = ps.indices[i].size();
-    if (N < 3) continue;
+  for (size_t i = 0; i < ps.indices.size (); ++i) {
+    auto N = ps.indices[i].size ();
+    if (N < 3)
+      continue;
     for (size_t j = 0; j < N; ++j) {
-      Edge other_edge(ps.vertices[ps.indices[i][(j + 1) % N]], ps.vertices[ps.indices[i][j]]);
-      if (edge_to_facet_map.count(other_edge) == 0) return false; //
+      Edge other_edge (ps.vertices[ps.indices[i][(j + 1) % N]], ps.vertices[ps.indices[i][j]]);
+      if (edge_to_facet_map.count (other_edge) == 0)
+        return false; //
       //Edge_to_facet_map::const_iterator it = edge_to_facet_map.find(other_edge);
       //if (it == edge_to_facet_map.end()) return false; // not a closed manifold
       //int other_facet = it->second;
       int other_facet = edge_to_facet_map[other_edge];
 
-      auto p = vector_convert<Point>(ps.vertices[ps.indices[i][(j + 2) % N]]);
+      auto p = vector_convert<Point> (ps.vertices[ps.indices[i][(j + 2) % N]]);
 
-      if (facet_planes[other_facet].has_on_positive_side(p)) {
+      if (facet_planes[other_facet].has_on_positive_side (p)) {
         // Check angle
-        const auto& u = facet_planes[other_facet].orthogonal_vector();
-        const auto& v = facet_planes[i].orthogonal_vector();
+        const auto &u = facet_planes[other_facet].orthogonal_vector ();
+        const auto &v = facet_planes[i].orthogonal_vector ();
 
-        double cos_angle = u / sqrt(u * u) * v / sqrt(v * v);
+        double cos_angle = u / sqrt (u * u) * v / sqrt (v * v);
         if (cos_angle < angle_threshold) {
           return false;
         }
@@ -220,39 +226,40 @@ bool is_approximately_convex(const PolySet& ps) {
 
   std::set<int> explored_facets;
   std::queue<int> facets_to_visit;
-  facets_to_visit.push(0);
-  explored_facets.insert(0);
-
-  while (!facets_to_visit.empty()) {
-    int f = facets_to_visit.front(); facets_to_visit.pop();
-
-    for (size_t i = 0; i < ps.indices[f].size(); ++i) {
-      int j = (i + 1) % ps.indices[f].size();
-      auto it = edge_to_facet_map.find(Edge(ps.vertices[ps.indices[f][j]], ps.vertices[ps.indices[f][i]]));
-      if (it == edge_to_facet_map.end()) return false; // Nonmanifold
-      if (!explored_facets.count(it->second)) {
-        explored_facets.insert(it->second);
-        facets_to_visit.push(it->second);
+  facets_to_visit.push (0);
+  explored_facets.insert (0);
+
+  while (!facets_to_visit.empty ()) {
+    int f = facets_to_visit.front ();
+    facets_to_visit.pop ();
+
+    for (size_t i = 0; i < ps.indices[f].size (); ++i) {
+      int j = (i + 1) % ps.indices[f].size ();
+      auto it = edge_to_facet_map.find (Edge (ps.vertices[ps.indices[f][j]], ps.vertices[ps.indices[f][i]]));
+      if (it == edge_to_facet_map.end ())
+        return false; // Nonmanifold
+      if (!explored_facets.count (it->second)) {
+        explored_facets.insert (it->second);
+        facets_to_visit.push (it->second);
       }
     }
   }
 
   // Make sure that we were able to reach all polygons during our visit
-  return explored_facets.size() == ps.indices.size();
+  return explored_facets.size () == ps.indices.size ();
 }
 
-std::shared_ptr<const CGALNefGeometry> getNefPolyhedronFromGeometry(const std::shared_ptr<const Geometry>& geom)
-{
-  if (auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
-    return std::shared_ptr<CGALNefGeometry>(createNefPolyhedronFromPolySet(*ps));
-  } else if (auto poly2d = std::dynamic_pointer_cast<const Polygon2d>(geom)) {
-    std::shared_ptr<PolySet> ps(poly2d->tessellate());
-    return std::shared_ptr<CGALNefGeometry>(createNefPolyhedronFromPolySet(*ps));
-  } else if (auto nef = std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
+std::shared_ptr<const CGALNefGeometry> getNefPolyhedronFromGeometry (const std::shared_ptr<const Geometry> &geom) {
+  if (auto ps = std::dynamic_pointer_cast<const PolySet> (geom)) {
+    return std::shared_ptr<CGALNefGeometry> (createNefPolyhedronFromPolySet (*ps));
+  } else if (auto poly2d = std::dynamic_pointer_cast<const Polygon2d> (geom)) {
+    std::shared_ptr<PolySet> ps (poly2d->tessellate ());
+    return std::shared_ptr<CGALNefGeometry> (createNefPolyhedronFromPolySet (*ps));
+  } else if (auto nef = std::dynamic_pointer_cast<const CGALNefGeometry> (geom)) {
     return nef;
 #if ENABLE_MANIFOLD
-  } else if (auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
-    return std::shared_ptr<CGALNefGeometry>(createNefPolyhedronFromPolySet(*mani->toPolySet()));
+  } else if (auto mani = std::dynamic_pointer_cast<const ManifoldGeometry> (geom)) {
+    return std::shared_ptr<CGALNefGeometry> (createNefPolyhedronFromPolySet (*mani->toPolySet ()));
 #endif
   }
   return nullptr;
@@ -265,8 +272,7 @@ std::shared_ptr<const CGALNefGeometry> getNefPolyhedronFromGeometry(const std::s
    formats) do not allow for holes in their faces. The function documents
    the method used to deal with this
  */
-std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3(const CGAL_Nef_polyhedron3& N)
-{
+std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3 (const CGAL_Nef_polyhedron3 &N) {
   // 1. Build Indexed PolyMesh
   // 2. Validate mesh (manifoldness)
   // 3. Triangulate each face
@@ -281,43 +287,47 @@ std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3(const CGAL_Nef_polyhedr
   std::vector<std::vector<IndexedFace>> polygons;
 
   typename Nef::Halffacet_const_iterator hfaceti;
-  CGAL_forall_halffacets(hfaceti, N) {
-    Nef::Plane_3 plane(hfaceti->plane());
+  CGAL_forall_halffacets (hfaceti, N) {
+    Nef::Plane_3 plane (hfaceti->plane ());
     // Since we're downscaling to float, vertices might merge during this conversion.
     // To avoid passing equal vertices to the tessellator, we remove consecutively identical
     // vertices.
-    polygons.emplace_back();
-    auto& faces = polygons.back();
+    polygons.emplace_back ();
+    auto &faces = polygons.back ();
     // the 0-mark-volume is the 'empty' volume of space. skip it.
-    if (!hfaceti->incident_volume()->mark()) {
+    if (!hfaceti->incident_volume ()->mark ()) {
       typename Nef::Halffacet_cycle_const_iterator cyclei;
-      CGAL_forall_facet_cycles_of(cyclei, hfaceti) {
-        typename Nef::SHalfedge_around_facet_const_circulator c1(cyclei);
-        typename Nef::SHalfedge_around_facet_const_circulator c2(c1);
-        faces.push_back(IndexedFace());
-        auto& currface = faces.back();
-        CGAL_For_all(c1, c2) {
-          auto p = c1->source()->center_vertex()->point();
+      CGAL_forall_facet_cycles_of (cyclei, hfaceti) {
+        typename Nef::SHalfedge_around_facet_const_circulator c1 (cyclei);
+        typename Nef::SHalfedge_around_facet_const_circulator c2 (c1);
+        faces.push_back (IndexedFace ());
+        auto &currface = faces.back ();
+        CGAL_For_all (c1, c2) {
+          auto p = c1->source ()->center_vertex ()->point ();
           // Create vertex indices and remove consecutive duplicate vertices
-          auto idx = allVertices.lookup(vector_convert<Vector3f>(p));
-          if (currface.empty() || idx != currface.back()) currface.push_back(idx);
+          auto idx = allVertices.lookup (vector_convert<Vector3f> (p));
+          if (currface.empty () || idx != currface.back ())
+            currface.push_back (idx);
         }
-        if (!currface.empty() && currface.front() == currface.back()) currface.pop_back();
-        if (currface.size() < 3) faces.pop_back(); // Cull empty triangles
+        if (!currface.empty () && currface.front () == currface.back ())
+          currface.pop_back ();
+        if (currface.size () < 3)
+          faces.pop_back (); // Cull empty triangles
       }
     }
-    if (faces.empty()) polygons.pop_back(); // Cull empty faces
+    if (faces.empty ())
+      polygons.pop_back (); // Cull empty faces
   }
 
   // 2. Validate mesh (manifoldness)
-  auto unconnected = GeometryUtils::findUnconnectedEdges(polygons);
+  auto unconnected = GeometryUtils::findUnconnectedEdges (polygons);
   if (unconnected > 0) {
-    LOG(message_group::Error, "Non-manifold mesh encountered: %1$d unconnected edges", unconnected);
+    LOG (message_group::Error, "Non-manifold mesh encountered: %1$d unconnected edges", unconnected);
   }
   // 3. Triangulate each face
-  const auto& verts = allVertices.getArray();
+  const auto &verts = allVertices.getArray ();
   std::vector<IndexedTriangle> allTriangles;
-  for (const auto& faces : polygons) {
+  for (const auto &faces : polygons) {
 #if 0 // For debugging
     std::cerr << "---\n";
     for (const auto& poly : faces) {
@@ -357,13 +367,13 @@ std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3(const CGAL_Nef_polyhedr
     // CGAL::Vector_3<CGAL_Kernel3> nvec = plane.orthogonal_vector();
     // K::Vector_3 normal(CGAL::to_double(nvec.x()), CGAL::to_double(nvec.y()), CGAL::to_double(nvec.z()));
     std::vector<IndexedTriangle> triangles;
-    auto err = GeometryUtils::tessellatePolygonWithHoles(verts, faces, triangles, nullptr);
+    auto err = GeometryUtils::tessellatePolygonWithHoles (verts, faces, triangles, nullptr);
     if (!err) {
-      for (const auto& t : triangles) {
-        assert(t[0] >= 0 && t[0] < static_cast<int>(allVertices.size()));
-        assert(t[1] >= 0 && t[1] < static_cast<int>(allVertices.size()));
-        assert(t[2] >= 0 && t[2] < static_cast<int>(allVertices.size()));
-        allTriangles.push_back(t);
+      for (const auto &t : triangles) {
+        assert (t[0] >= 0 && t[0] < static_cast<int> (allVertices.size ()));
+        assert (t[1] >= 0 && t[1] < static_cast<int> (allVertices.size ()));
+        assert (t[2] >= 0 && t[2] < static_cast<int> (allVertices.size ()));
+        allTriangles.push_back (t);
       }
     }
   }
@@ -374,21 +384,21 @@ std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3(const CGAL_Nef_polyhedr
   }
 #endif // debug
   // 4. Validate mesh (manifoldness)
-  auto unconnected2 = GeometryUtils::findUnconnectedEdges(allTriangles);
+  auto unconnected2 = GeometryUtils::findUnconnectedEdges (allTriangles);
   if (unconnected2 > 0) {
-    LOG(message_group::Error, "Non-manifold mesh created: %1$d unconnected edges", unconnected2);
+    LOG (message_group::Error, "Non-manifold mesh created: %1$d unconnected edges", unconnected2);
   }
 
-  auto polyset = PolySet::createEmpty();
-  polyset->vertices.reserve(verts.size());
-  for (const auto& v : verts) {
-    polyset->vertices.emplace_back(v.cast<double>());
+  auto polyset = PolySet::createEmpty ();
+  polyset->vertices.reserve (verts.size ());
+  for (const auto &v : verts) {
+    polyset->vertices.emplace_back (v.cast<double> ());
   }
-  polyset->indices.reserve(allTriangles.size());
-  for (const auto& tri : allTriangles) {
-    polyset->indices.push_back({tri[0], tri[1], tri[2]});
+  polyset->indices.reserve (allTriangles.size ());
+  for (const auto &tri : allTriangles) {
+    polyset->indices.push_back ({tri[0], tri[1], tri[2]});
   }
-  polyset->setTriangular(true);
+  polyset->setTriangular (true);
 
 #if 0 // For debugging
   std::cerr.precision(20);
@@ -401,39 +411,36 @@ std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3(const CGAL_Nef_polyhedr
 }
 
 template <typename K>
-CGAL::Aff_transformation_3<K> createAffineTransformFromMatrix(const Transform3d& matrix) {
-  return CGAL::Aff_transformation_3<K>(
-    matrix(0, 0), matrix(0, 1), matrix(0, 2), matrix(0, 3),
-    matrix(1, 0), matrix(1, 1), matrix(1, 2), matrix(1, 3),
-    matrix(2, 0), matrix(2, 1), matrix(2, 2), matrix(2, 3), matrix(3, 3));
+CGAL::Aff_transformation_3<K> createAffineTransformFromMatrix (const Transform3d &matrix) {
+  return CGAL::Aff_transformation_3<K> (
+    matrix (0, 0), matrix (0, 1), matrix (0, 2), matrix (0, 3),
+    matrix (1, 0), matrix (1, 1), matrix (1, 2), matrix (1, 3),
+    matrix (2, 0), matrix (2, 1), matrix (2, 2), matrix (2, 3), matrix (3, 3));
 }
 
 template <typename K>
-void transform(CGAL::Nef_polyhedron_3<K>& N, const Transform3d& matrix)
-{
-  assert(matrix.matrix().determinant() != 0);
-  N.transform(createAffineTransformFromMatrix<K>(matrix));
+void transform (CGAL::Nef_polyhedron_3<K> &N, const Transform3d &matrix) {
+  assert (matrix.matrix ().determinant () != 0);
+  N.transform (createAffineTransformFromMatrix<K> (matrix));
 }
 
-template void transform(CGAL_Nef_polyhedron3& N, const Transform3d& matrix);
+template void transform (CGAL_Nef_polyhedron3 &N, const Transform3d &matrix);
 
 template <typename K>
-void transform(CGAL::Surface_mesh<CGAL::Point_3<K>>& mesh, const Transform3d& matrix)
-{
-  assert(matrix.matrix().determinant() != 0);
-  auto t = createAffineTransformFromMatrix<K>(matrix);
-
-  for (auto v : mesh.vertices()) {
-    auto& pt = mesh.point(v);
-    pt = t(pt);
+void transform (CGAL::Surface_mesh<CGAL::Point_3<K>> &mesh, const Transform3d &matrix) {
+  assert (matrix.matrix ().determinant () != 0);
+  auto t = createAffineTransformFromMatrix<K> (matrix);
+
+  for (auto v : mesh.vertices ()) {
+    auto &pt = mesh.point (v);
+    pt = t (pt);
   }
 }
 
 template <typename K>
-Transform3d computeResizeTransform(
-  const CGAL::Iso_cuboid_3<K>& bb, unsigned int dimension, const Vector3d& newsize,
-  const Eigen::Matrix<bool, 3, 1>& autosize)
-{
+Transform3d computeResizeTransform (
+  const CGAL::Iso_cuboid_3<K> &bb, unsigned int dimension, const Vector3d &newsize,
+  const Eigen::Matrix<bool, 3, 1> &autosize) {
   // Based on resize() in Giles Bathgate's RapCAD (but not exactly)
 
   // The numeric type is our kernel's field type.
@@ -441,65 +448,66 @@ Transform3d computeResizeTransform(
 
   std::vector<NT> scale, bbox_size;
   for (unsigned int i = 0; i < 3; ++i) {
-    scale.push_back(NT(1));
-    bbox_size.push_back(bb.max_coord(i) - bb.min_coord(i));
+    scale.push_back (NT (1));
+    bbox_size.push_back (bb.max_coord (i) - bb.min_coord (i));
   }
   int newsizemax_index = 0;
   for (unsigned int i = 0; i < dimension; ++i) {
     if (newsize[i]) {
-      if (bbox_size[i] == NT(0)) {
-        LOG(message_group::Warning, "Resize in direction normal to flat object is not implemented");
-        return Transform3d::Identity();
+      if (bbox_size[i] == NT (0)) {
+        LOG (message_group::Warning, "Resize in direction normal to flat object is not implemented");
+        return Transform3d::Identity ();
       } else {
-        scale[i] = NT(newsize[i]) / bbox_size[i];
+        scale[i] = NT (newsize[i]) / bbox_size[i];
       }
-      if (newsize[i] > newsize[newsizemax_index]) newsizemax_index = i;
+      if (newsize[i] > newsize[newsizemax_index])
+        newsizemax_index = i;
     }
   }
 
-  auto autoscale = NT(1);
+  auto autoscale = NT (1);
   if (newsize[newsizemax_index] != 0) {
-    autoscale = NT(newsize[newsizemax_index]) / bbox_size[newsizemax_index];
+    autoscale = NT (newsize[newsizemax_index]) / bbox_size[newsizemax_index];
   }
   for (unsigned int i = 0; i < dimension; ++i) {
-    if (autosize[i] && newsize[i] == 0) scale[i] = autoscale;
+    if (autosize[i] && newsize[i] == 0)
+      scale[i] = autoscale;
   }
 
   Eigen::Matrix4d t;
-  t << CGAL::to_double(scale[0]),           0,        0,        0,
-    0,        CGAL::to_double(scale[1]),           0,        0,
-    0,        0,        CGAL::to_double(scale[2]),           0,
-    0,        0,        0,                                   1;
+  t << CGAL::to_double (scale[0]), 0, 0, 0,
+    0, CGAL::to_double (scale[1]), 0, 0,
+    0, 0, CGAL::to_double (scale[2]), 0,
+    0, 0, 0, 1;
 
-  return Transform3d(t);
+  return Transform3d (t);
 }
 
-template Transform3d computeResizeTransform(
-  const CGAL_Iso_cuboid_3& bb, unsigned int dimension, const Vector3d& newsize,
-  const Eigen::Matrix<bool, 3, 1>& autosize);
+template Transform3d computeResizeTransform (
+  const CGAL_Iso_cuboid_3 &bb, unsigned int dimension, const Vector3d &newsize,
+  const Eigen::Matrix<bool, 3, 1> &autosize);
 
-std::shared_ptr<const PolySet> getGeometryAsPolySet(const std::shared_ptr<const Geometry>& geom)
-{
-  if (auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
+std::shared_ptr<const PolySet> getGeometryAsPolySet (const std::shared_ptr<const Geometry> &geom) {
+  if (auto ps = std::dynamic_pointer_cast<const PolySet> (geom)) {
     return ps;
   }
-  if (auto N = std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
-    auto ps = std::make_shared<PolySet>(3);
-    if (!N->isEmpty()) {
-      if (auto ps = CGALUtils::createPolySetFromNefPolyhedron3(*N->p3)) {
-        ps->setConvexity(N->getConvexity());
+  if (auto N = std::dynamic_pointer_cast<const CGALNefGeometry> (geom)) {
+    auto ps = std::make_shared<PolySet> (3);
+    if (!N->isEmpty ()) {
+      if (auto ps = CGALUtils::createPolySetFromNefPolyhedron3 (*N->p3)) {
+        ps->setConvexity (N->getConvexity ());
         return ps;
       }
-      LOG(message_group::Error, "Nef->PolySet failed.");
+      LOG (message_group::Error, "Nef->PolySet failed.");
     }
-    return std::make_shared<PolySet>(3);
+    return std::make_shared<PolySet> (3);
   }
 #ifdef ENABLE_MANIFOLD
-  if (auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
-    return mani->toPolySet();
+  if (auto mani = std::dynamic_pointer_cast<const ManifoldGeometry> (geom)) {
+    return mani->toPolySet ();
   }
 #endif
   return nullptr;
 }
 
-}  // namespace CGALUtils
+} // namespace CGALUtils
diff --git a/src/geometry/cgal/cgalutils.h b/src/geometry/cgal/cgalutils.h
index 90a454a8a..030baca8b 100644
--- a/src/geometry/cgal/cgalutils.h
+++ b/src/geometry/cgal/cgalutils.h
@@ -19,103 +19,102 @@ namespace CGALUtils {
 
 #ifdef ENABLE_CGAL
 template <typename Result, typename V>
-Result vector_convert(V const& v) {
-  return Result(CGAL::to_double(v[0]), CGAL::to_double(v[1]), CGAL::to_double(v[2]));
+Result vector_convert (V const &v) {
+  return Result (CGAL::to_double (v[0]), CGAL::to_double (v[1]), CGAL::to_double (v[2]));
 }
 
-std::unique_ptr<CGALNefGeometry> createNefPolyhedronFromPolySet(const PolySet& ps);
+std::unique_ptr<CGALNefGeometry> createNefPolyhedronFromPolySet (const PolySet &ps);
 template <typename K>
-bool is_weakly_convex(const CGAL::Polyhedron_3<K>& p);
+bool is_weakly_convex (const CGAL::Polyhedron_3<K> &p);
 
 template <typename K>
-bool is_weakly_convex(const CGAL::Surface_mesh<CGAL::Point_3<K>>& m);
+bool is_weakly_convex (const CGAL::Surface_mesh<CGAL::Point_3<K>> &m);
 
-std::shared_ptr<const Geometry> applyOperator3D(const Geometry::Geometries& children, OpenSCADOperator op);
-std::unique_ptr<const Geometry> applyUnion3D(Geometry::Geometries::iterator chbegin, Geometry::Geometries::iterator chend);
-std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& children);
+std::shared_ptr<const Geometry> applyOperator3D (const Geometry::Geometries &children, OpenSCADOperator op);
+std::unique_ptr<const Geometry> applyUnion3D (Geometry::Geometries::iterator chbegin, Geometry::Geometries::iterator chend);
+std::shared_ptr<const Geometry> applyMinkowski3D (const Geometry::Geometries &children);
 
-std::unique_ptr<Polygon2d> project(const CGALNefGeometry& N, bool cut);
+std::unique_ptr<Polygon2d> project (const CGALNefGeometry &N, bool cut);
 template <typename K>
-CGAL::Iso_cuboid_3<K> boundingBox(const CGAL::Nef_polyhedron_3<K>& N);
+CGAL::Iso_cuboid_3<K> boundingBox (const CGAL::Nef_polyhedron_3<K> &N);
 
 template <typename K>
-CGAL::Iso_cuboid_3<K> boundingBox(const CGAL::Surface_mesh<CGAL::Point_3<K>>& mesh);
+CGAL::Iso_cuboid_3<K> boundingBox (const CGAL::Surface_mesh<CGAL::Point_3<K>> &mesh);
 
-CGAL_Iso_cuboid_3 createIsoCuboidFromBoundingBox(const BoundingBox& bbox);
-bool is_approximately_convex(const PolySet& ps);
+CGAL_Iso_cuboid_3 createIsoCuboidFromBoundingBox (const BoundingBox &bbox);
+bool is_approximately_convex (const PolySet &ps);
 
 template <typename Polyhedron>
-std::unique_ptr<PolySet> createPolySetFromPolyhedron(const Polyhedron& p);
+std::unique_ptr<PolySet> createPolySetFromPolyhedron (const Polyhedron &p);
 
 template <typename Polyhedron>
-bool createPolyhedronFromPolySet(const PolySet& ps, Polyhedron& p);
+bool createPolyhedronFromPolySet (const PolySet &ps, Polyhedron &p);
 
 template <class InputKernel, class OutputKernel>
-void copyPolyhedron(const CGAL::Polyhedron_3<InputKernel>& poly_a, CGAL::Polyhedron_3<OutputKernel>& poly_b);
+void copyPolyhedron (const CGAL::Polyhedron_3<InputKernel> &poly_a, CGAL::Polyhedron_3<OutputKernel> &poly_b);
 
 template <class InputKernel, class OutputKernel>
-void copyMesh(const CGAL::Surface_mesh<CGAL::Point_3<InputKernel>>& input,
-              CGAL::Surface_mesh<CGAL::Point_3<OutputKernel>>& output);
+void copyMesh (const CGAL::Surface_mesh<CGAL::Point_3<InputKernel>> &input,
+               CGAL::Surface_mesh<CGAL::Point_3<OutputKernel>> &output);
 
-CGAL_DoubleMesh repairPolySet(const PolySet& ps);
+CGAL_DoubleMesh repairPolySet (const PolySet &ps);
 
 template <class SurfaceMesh>
-std::shared_ptr<SurfaceMesh> createSurfaceMeshFromPolySet(const PolySet& ps);
+std::shared_ptr<SurfaceMesh> createSurfaceMeshFromPolySet (const PolySet &ps);
 template <class SurfaceMesh>
-std::unique_ptr<PolySet> createPolySetFromSurfaceMesh(const SurfaceMesh& mesh);
+std::unique_ptr<PolySet> createPolySetFromSurfaceMesh (const SurfaceMesh &mesh);
 
-std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3(const CGAL_Nef_polyhedron3& N);
+std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3 (const CGAL_Nef_polyhedron3 &N);
 
-std::shared_ptr<const CGALNefGeometry> getNefPolyhedronFromGeometry(const std::shared_ptr<const Geometry>& geom);
-std::shared_ptr<const CGALNefGeometry> getGeometryAsNefPolyhedron(const std::shared_ptr<const Geometry>&);
+std::shared_ptr<const CGALNefGeometry> getNefPolyhedronFromGeometry (const std::shared_ptr<const Geometry> &geom);
+std::shared_ptr<const CGALNefGeometry> getGeometryAsNefPolyhedron (const std::shared_ptr<const Geometry> &);
 
 template <typename K>
-CGAL::Aff_transformation_3<K> createAffineTransformFromMatrix(const Transform3d& matrix);
+CGAL::Aff_transformation_3<K> createAffineTransformFromMatrix (const Transform3d &matrix);
 template <typename K>
-void transform(CGAL::Nef_polyhedron_3<K>& N, const Transform3d& matrix);
+void transform (CGAL::Nef_polyhedron_3<K> &N, const Transform3d &matrix);
 template <typename K>
-void transform(CGAL::Surface_mesh<CGAL::Point_3<K>>& mesh, const Transform3d& matrix);
+void transform (CGAL::Surface_mesh<CGAL::Point_3<K>> &mesh, const Transform3d &matrix);
 template <typename K>
-Transform3d computeResizeTransform(
-  const CGAL::Iso_cuboid_3<K>& bb, unsigned int dimension, const Vector3d& newsize,
-  const Eigen::Matrix<bool, 3, 1>& autosize);
-bool tessellatePolygon(const std::vector<CGAL::Point_3<CGAL::Epick>>& polygon,
-                       Polygons& triangles,
-                       const CGAL::Vector_3<CGAL::Epick> *normal = nullptr);
-bool tessellatePolygonWithHoles(const std::vector<std::vector<CGAL::Point_3<CGAL::Epick>>>& polygons,
-                                Polygons& triangles,
-                                const CGAL::Vector_3<CGAL::Epick> *normal = nullptr);
-bool tessellate3DFaceWithHoles(std::vector<CGAL_Polygon_3>& polygons,
-                               std::vector<CGAL_Polygon_3>& triangles,
-                               CGAL::Plane_3<CGAL_Kernel3>& plane);
+Transform3d computeResizeTransform (
+  const CGAL::Iso_cuboid_3<K> &bb, unsigned int dimension, const Vector3d &newsize,
+  const Eigen::Matrix<bool, 3, 1> &autosize);
+bool tessellatePolygon (const std::vector<CGAL::Point_3<CGAL::Epick>> &polygon,
+                        Polygons &triangles,
+                        const CGAL::Vector_3<CGAL::Epick> *normal = nullptr);
+bool tessellatePolygonWithHoles (const std::vector<std::vector<CGAL::Point_3<CGAL::Epick>>> &polygons,
+                                 Polygons &triangles,
+                                 const CGAL::Vector_3<CGAL::Epick> *normal = nullptr);
+bool tessellate3DFaceWithHoles (std::vector<CGAL_Polygon_3> &polygons,
+                                std::vector<CGAL_Polygon_3> &triangles,
+                                CGAL::Plane_3<CGAL_Kernel3> &plane);
 template <typename FromKernel, typename ToKernel>
 struct KernelConverter {
   // Note: we could have this return `CGAL::to_double(n)` by default, but
   // that would mean that failure to provide a proper specialization would
   // default to lossy conversion.
-  typename ToKernel::FT operator()(const typename FromKernel::FT& n) const;
+  typename ToKernel::FT operator() (const typename FromKernel::FT &n) const;
 };
 template <typename FromKernel, typename ToKernel>
 CGAL::Cartesian_converter<FromKernel, ToKernel, KernelConverter<FromKernel, ToKernel>>
-getCartesianConverter()
-{
+getCartesianConverter () {
   return CGAL::Cartesian_converter<
-    FromKernel, ToKernel, KernelConverter<FromKernel, ToKernel>>();
+    FromKernel, ToKernel, KernelConverter<FromKernel, ToKernel>> ();
 }
 
 template <typename SurfaceMesh>
-void triangulateFaces(SurfaceMesh& mesh);
+void triangulateFaces (SurfaceMesh &mesh);
 template <typename Polyhedron>
-bool isClosed(const Polyhedron& polyhedron);
+bool isClosed (const Polyhedron &polyhedron);
 template <typename SurfaceMesh>
-void orientToBoundAVolume(SurfaceMesh& mesh);
+void orientToBoundAVolume (SurfaceMesh &mesh);
 template <typename K>
-void convertNefToPolyhedron(const CGAL::Nef_polyhedron_3<K>& nef, CGAL::Polyhedron_3<K>& polyhedron);
+void convertNefToPolyhedron (const CGAL::Nef_polyhedron_3<K> &nef, CGAL::Polyhedron_3<K> &polyhedron);
 
-void convertNefToSurfaceMesh(const CGAL_Nef_polyhedron3& nef, CGAL_Kernel3Mesh& mesh);
-void convertSurfaceMeshToNef(const CGAL_Kernel3Mesh& mesh, CGAL_Nef_polyhedron3& nef);
+void convertNefToSurfaceMesh (const CGAL_Nef_polyhedron3 &nef, CGAL_Kernel3Mesh &mesh);
+void convertSurfaceMeshToNef (const CGAL_Kernel3Mesh &mesh, CGAL_Nef_polyhedron3 &nef);
 
 #endif // ifdef ENABLE_CGAL
-std::unique_ptr<PolySet> createTriangulatedPolySetFromPolygon2d(const Polygon2d& polygon2d);
+std::unique_ptr<PolySet> createTriangulatedPolySetFromPolygon2d (const Polygon2d &polygon2d);
 
 } // namespace CGALUtils
diff --git a/src/geometry/linalg.cc b/src/geometry/linalg.cc
index a7f644ee4..5e59365d5 100644
--- a/src/geometry/linalg.cc
+++ b/src/geometry/linalg.cc
@@ -13,36 +13,36 @@
    Transforms the given bounding box by transforming each of its 8 vertices.
    Returns a new bounding box.
  */
-BoundingBox operator*(const Transform3d& m, const BoundingBox& box)
-{
-  if (box.isEmpty()) return box;
+BoundingBox operator* (const Transform3d &m, const BoundingBox &box) {
+  if (box.isEmpty ())
+    return box;
   BoundingBox newbox;
-  Vector3d boxvec[2] = { box.min(), box.max() };
-  for (auto& k : boxvec) {
-    for (auto& j : boxvec) {
-      for (auto& i : boxvec) {
-        newbox.extend(m * Vector3d(i[0], j[1], k[2]));
+  Vector3d boxvec[2] = {box.min (), box.max ()};
+  for (auto &k : boxvec) {
+    for (auto &j : boxvec) {
+      for (auto &i : boxvec) {
+        newbox.extend (m * Vector3d (i[0], j[1], k[2]));
       }
     }
   }
   return newbox;
 }
 
-bool matrix_contains_infinity(const Transform3d& m)
-{
-  for (int i = 0; i < m.matrix().rows(); ++i) {
-    for (int j = 0; j < m.matrix().cols(); ++j) {
-      if ((std::isinf)(m(i, j))) return true;
+bool matrix_contains_infinity (const Transform3d &m) {
+  for (int i = 0; i < m.matrix ().rows (); ++i) {
+    for (int j = 0; j < m.matrix ().cols (); ++j) {
+      if ((std::isinf) (m (i, j)))
+        return true;
     }
   }
   return false;
 }
 
-bool matrix_contains_nan(const Transform3d& m)
-{
-  for (int i = 0; i < m.matrix().rows(); ++i) {
-    for (int j = 0; j < m.matrix().cols(); ++j) {
-      if ((std::isnan)(m(i, j))) return true;
+bool matrix_contains_nan (const Transform3d &m) {
+  for (int i = 0; i < m.matrix ().rows (); ++i) {
+    for (int j = 0; j < m.matrix ().cols (); ++j) {
+      if ((std::isnan) (m (i, j)))
+        return true;
     }
   }
   return false;
@@ -67,8 +67,7 @@ bool matrix_contains_nan(const Transform3d& m)
 using Py_hash_t = int32_t;
 using Py_uhash_t = uint32_t;
 using Float_t = double;
-Py_hash_t hash_floating_point(Float_t v)
-{
+Py_hash_t hash_floating_point (Float_t v) {
   static constexpr int PyHASH_BITS = 31;
   //if (sizeof(Py_uhash_t)==8) PyHASH_BITS=61;
 
@@ -80,12 +79,14 @@ Py_hash_t hash_floating_point(Float_t v)
   Float_t m;
   Py_uhash_t x, y;
 
-  if (!std::isfinite(v)) {
-    if (std::isinf(v)) return v > 0 ? PyHASH_INF : -PyHASH_INF;
-    else return PyHASH_NAN;
+  if (!std::isfinite (v)) {
+    if (std::isinf (v))
+      return v > 0 ? PyHASH_INF : -PyHASH_INF;
+    else
+      return PyHASH_NAN;
   }
 
-  m = frexp(v, &e);
+  m = frexp (v, &e);
 
   sign = 1;
   if (m < 0) {
@@ -103,7 +104,8 @@ Py_hash_t hash_floating_point(Float_t v)
     y = (Py_uhash_t)m; /* pull out integer part */
     m -= y;
     x += y;
-    if (x >= PyHASH_MODULUS) x -= PyHASH_MODULUS;
+    if (x >= PyHASH_MODULUS)
+      x -= PyHASH_MODULUS;
   }
 
   /* adjust for the exponent;  first reduce it modulo PyHASH_BITS */
diff --git a/src/geometry/linalg.h b/src/geometry/linalg.h
index 3f684c282..9e0fcb1e6 100644
--- a/src/geometry/linalg.h
+++ b/src/geometry/linalg.h
@@ -14,10 +14,10 @@ using Eigen::Vector4f;
 using Eigen::Vector3i;
 
 #ifdef _MSC_VER
-  #include <Eigen/StdVector> // https://eigen.tuxfamily.org/dox/group__TopicStlContainers.html
-  #if !EIGEN_HAS_CXX11_CONTAINERS
-    #warning "Eigen has detected no support for CXX11 containers and has redefined std::vector"
-  #endif
+#include <Eigen/StdVector> // https://eigen.tuxfamily.org/dox/group__TopicStlContainers.html
+#if !EIGEN_HAS_CXX11_CONTAINERS
+#warning "Eigen has detected no support for CXX11 containers and has redefined std::vector"
+#endif
 using VectorOfVector2d = std::vector<Vector2d, Eigen::aligned_allocator<Vector2d>>;
 #else
 using VectorOfVector2d = std::vector<Vector2d>;
@@ -30,111 +30,137 @@ using Eigen::Matrix4d;
 #define Transform3d Eigen::Affine3d
 #define Transform2d Eigen::Affine2d
 
-bool matrix_contains_infinity(const Transform3d& m);
-bool matrix_contains_nan(const Transform3d& m);
-int32_t hash_floating_point(double v);
+bool matrix_contains_infinity (const Transform3d &m);
+bool matrix_contains_nan (const Transform3d &m);
+int32_t hash_floating_point (double v);
 
-template <typename Derived> bool is_finite(const Eigen::MatrixBase<Derived>& x) {
+template <typename Derived>
+bool is_finite (const Eigen::MatrixBase<Derived> &x) {
   //infinity minus infinity is NaN, which never compares equal to itself
-  return ( (x - x).array() == (x - x).array()).all(); // NOLINT(misc-redundant-expression)
+  return ((x - x).array () == (x - x).array ()).all (); // NOLINT(misc-redundant-expression)
 }
 
-template <typename Derived> bool is_nan(const Eigen::MatrixBase<Derived>& x) {
-  return !((x.array() == x.array())).all();
+template <typename Derived>
+bool is_nan (const Eigen::MatrixBase<Derived> &x) {
+  return !((x.array () == x.array ())).all ();
 }
 
-BoundingBox operator*(const Transform3d& m, const BoundingBox& box);
+BoundingBox operator* (const Transform3d &m, const BoundingBox &box);
 
 class Color4f
 {
 public:
-  Color4f(const Vector4f& v) : color_(v) { }
-  Color4f(int r, int g, int b, int a = 255) { setRgba(r, g, b, a); }
-  Color4f(float r = -1.0f, float g = -1.0f, float b = -1.0f, float a = -1.0f) : color_(r, g, b, a) { }
+  Color4f (const Vector4f &v)
+    : color_ (v) {}
+  Color4f (int r, int g, int b, int a = 255) {
+    setRgba (r, g, b, a);
+  }
+  Color4f (float r = -1.0f, float g = -1.0f, float b = -1.0f, float a = -1.0f)
+    : color_ (r, g, b, a) {}
 
-  [[nodiscard]] bool isValid() const { return color_.minCoeff() >= 0.0f; }
-  [[nodiscard]] bool hasRgb() const { return color_[0] >= 0.0f && color_[1] >= 0.0f && color_[2] >= 0.0f; }
-  [[nodiscard]] bool hasAlpha() const { return color_[3] >= 0.0f; }
+  [[nodiscard]] bool isValid () const {
+    return color_.minCoeff () >= 0.0f;
+  }
+  [[nodiscard]] bool hasRgb () const {
+    return color_[0] >= 0.0f && color_[1] >= 0.0f && color_[2] >= 0.0f;
+  }
+  [[nodiscard]] bool hasAlpha () const {
+    return color_[3] >= 0.0f;
+  }
 
-  void setRgba(int r, int g, int b, int a = 255) {
-    color_ << static_cast<float>(r) / 255.0f,
-      static_cast<float>(g) / 255.0f,
-      static_cast<float>(b) / 255.0f,
-      static_cast<float>(a) / 255.0f;
+  void setRgba (int r, int g, int b, int a = 255) {
+    color_ << static_cast<float> (r) / 255.0f,
+      static_cast<float> (g) / 255.0f,
+      static_cast<float> (b) / 255.0f,
+      static_cast<float> (a) / 255.0f;
   }
-  void setRgba(float r, float g, float b, float a = 1.0f) {
+  void setRgba (float r, float g, float b, float a = 1.0f) {
     color_ << r, g, b, a;
   }
-  void setRgb(float r, float g, float b) {
-    color_.head<3>() << r, g, b;
+  void setRgb (float r, float g, float b) {
+    color_.head<3> () << r, g, b;
   }
-  void setAlpha(float a) {
+  void setAlpha (float a) {
     color_[3] = a;
   }
 
-  bool getRgba(int& r, int& g, int& b, int& a) const {
-    if (!isValid()) return false;
-    r = std::clamp(static_cast<int>(this->r() * 255.0f), 0, 255);
-    g = std::clamp(static_cast<int>(this->g() * 255.0f), 0, 255);
-    b = std::clamp(static_cast<int>(this->b() * 255.0f), 0, 255);
-    a = std::clamp(static_cast<int>(this->a() * 255.0f), 0, 255);
+  bool getRgba (int &r, int &g, int &b, int &a) const {
+    if (!isValid ())
+      return false;
+    r = std::clamp (static_cast<int> (this->r () * 255.0f), 0, 255);
+    g = std::clamp (static_cast<int> (this->g () * 255.0f), 0, 255);
+    b = std::clamp (static_cast<int> (this->b () * 255.0f), 0, 255);
+    a = std::clamp (static_cast<int> (this->a () * 255.0f), 0, 255);
     return true;
   }
 
-  bool getRgba(uint8_t& r, uint8_t& g, uint8_t& b, uint8_t& a) const {
-    if (!isValid()) return false;
-    r = static_cast<uint8_t>(std::clamp(this->r(), 0.0f, 1.0f) * 255.0f);
-    g = static_cast<uint8_t>(std::clamp(this->g(), 0.0f, 1.0f) * 255.0f);
-    b = static_cast<uint8_t>(std::clamp(this->b(), 0.0f, 1.0f) * 255.0f);
-    a = static_cast<uint8_t>(std::clamp(this->a(), 0.0f, 1.0f) * 255.0f);
+  bool getRgba (uint8_t &r, uint8_t &g, uint8_t &b, uint8_t &a) const {
+    if (!isValid ())
+      return false;
+    r = static_cast<uint8_t> (std::clamp (this->r (), 0.0f, 1.0f) * 255.0f);
+    g = static_cast<uint8_t> (std::clamp (this->g (), 0.0f, 1.0f) * 255.0f);
+    b = static_cast<uint8_t> (std::clamp (this->b (), 0.0f, 1.0f) * 255.0f);
+    a = static_cast<uint8_t> (std::clamp (this->a (), 0.0f, 1.0f) * 255.0f);
     return true;
   }
 
-  bool getRgba(float& r, float& g, float& b, float& a) const {
-    if (!isValid()) return false;
-    r = this->r();
-    g = this->g();
-    b = this->b();
-    a = this->a();
+  bool getRgba (float &r, float &g, float &b, float &a) const {
+    if (!isValid ())
+      return false;
+    r = this->r ();
+    g = this->g ();
+    b = this->b ();
+    a = this->a ();
     return true;
   }
 
-  [[nodiscard]] Vector4f toVector4f() const {
+  [[nodiscard]] Vector4f toVector4f () const {
     return color_;
   }
 
-  [[nodiscard]] float r() const { return color_[0]; }
-  [[nodiscard]] float g() const { return color_[1]; }
-  [[nodiscard]] float b() const { return color_[2]; }
-  [[nodiscard]] float a() const { return color_[3]; }
+  [[nodiscard]] float r () const {
+    return color_[0];
+  }
+  [[nodiscard]] float g () const {
+    return color_[1];
+  }
+  [[nodiscard]] float b () const {
+    return color_[2];
+  }
+  [[nodiscard]] float a () const {
+    return color_[3];
+  }
 
-  [[nodiscard]] bool operator<(const Color4f& b) const {
+  [[nodiscard]] bool operator< (const Color4f &b) const {
     for (int i = 0; i < 4; i++) {
-      if (color_[i] < b.color_[i]) return true;
-      if (color_[i] > b.color_[i]) return false;
+      if (color_[i] < b.color_[i])
+        return true;
+      if (color_[i] > b.color_[i])
+        return false;
     }
     return false;
   }
 
-  [[nodiscard]] bool operator==(const Color4f& b) const {
+  [[nodiscard]] bool operator== (const Color4f &b) const {
     return color_ == b.color_;
   }
 
-  [[nodiscard]] bool operator!=(const Color4f& b) const {
+  [[nodiscard]] bool operator!= (const Color4f &b) const {
     return !(*this == b);
   }
 
-  [[nodiscard]] size_t hash() const {
+  [[nodiscard]] size_t hash () const {
     size_t hash = 0;
     // Gcc version 10.2.1 (Debian 11) fails to handle the
     // range-for loop, it can't find the begin() definition
     // of the Eigen::Matrix (with Eigen 3.3.9).
-    hash = std::hash<float>{}(r()) ^ (hash << 1);
-    hash = std::hash<float>{}(g()) ^ (hash << 1);
-    hash = std::hash<float>{}(b()) ^ (hash << 1);
-    hash = std::hash<float>{}(a()) ^ (hash << 1);
+    hash = std::hash<float>{}(r ()) ^ (hash << 1);
+    hash = std::hash<float>{}(g ()) ^ (hash << 1);
+    hash = std::hash<float>{}(b ()) ^ (hash << 1);
+    hash = std::hash<float>{}(a ()) ^ (hash << 1);
     return hash;
   }
+
 private:
   // Vector4f is fixed-size vectorizable
   // Use Eigen::DontAlign so we can store Color4f in STL containers
@@ -142,9 +168,9 @@ private:
   Eigen::Matrix<float, 4, 1, Eigen::DontAlign> color_;
 };
 
-template <> struct std::hash<Color4f> {
-  std::size_t operator()(Color4f const& c) const noexcept {
-    return c.hash();
+template <>
+struct std::hash<Color4f> {
+  std::size_t operator() (Color4f const &c) const noexcept {
+    return c.hash ();
   }
 };
-
diff --git a/src/geometry/linear_extrude.cc b/src/geometry/linear_extrude.cc
index 9b379b457..7c3698ab2 100644
--- a/src/geometry/linear_extrude.cc
+++ b/src/geometry/linear_extrude.cc
@@ -32,53 +32,58 @@ namespace {
     0 : if v1 ~= v2 (approximation to compoensate for floating point precision)
     1 : if v1  > v2
  */
-int sgn_vdiff(const Vector2d& v1, const Vector2d& v2) {
+int sgn_vdiff (const Vector2d &v1, const Vector2d &v2) {
   constexpr double ratio_threshold = 1e5; // 10ppm difference
-  double l1 = v1.norm();
-  double l2 = v2.norm();
+  double l1 = v1.norm ();
+  double l2 = v2.norm ();
   // Compare the average and difference, to be independent of geometry scale.
   // If the difference is within ratio_threshold of the avg, treat as equal.
   double scale = (l1 + l2);
-  double diff = 2 * std::fabs(l1 - l2) * ratio_threshold;
+  double diff = 2 * std::fabs (l1 - l2) * ratio_threshold;
   return diff > scale ? (l1 < l2 ? -1 : 1) : 0;
 }
 
 // Insert vertices for segments interpolated between v0 and v1.
 // The last vertex (t==1) is not added here to avoid duplicate vertices,
 // since it will be the first vertex of the *next* edge.
-void add_segmented_edge(Outline2d& o, const Vector2d& v0, const Vector2d& v1, unsigned int edge_segments) {
+void add_segmented_edge (Outline2d &o, const Vector2d &v0, const Vector2d &v1, unsigned int edge_segments) {
   for (unsigned int j = 0; j < edge_segments; ++j) {
-    double t = static_cast<double>(j) / edge_segments;
-    o.vertices.push_back((1 - t) * v0 + t * v1);
+    double t = static_cast<double> (j) / edge_segments;
+    o.vertices.push_back ((1 - t) * v0 + t * v1);
   }
 }
 
 // While total outline segments < fn, increment segment_count for edge with largest
 // (max_edge_length / segment_count).
-Outline2d splitOutlineByFn(
-  const Outline2d& o,
+Outline2d splitOutlineByFn (
+  const Outline2d &o,
   const double twist, const double scale_x, const double scale_y,
-  const double fn, unsigned int slices)
-{
+  const double fn, unsigned int slices) {
 
   struct segment_tracker {
     size_t edge_index;
     double max_edgelen;
     unsigned int segment_count{1u};
-    segment_tracker(size_t i, double len) : edge_index(i), max_edgelen(len) { }
+    segment_tracker (size_t i, double len)
+      : edge_index (i)
+      , max_edgelen (len) {}
     // metric for comparison: average between (max segment length, and max segment length after split)
-    [[nodiscard]] double metric() const { return max_edgelen / (segment_count + 0.5); }
-    bool operator<(const segment_tracker& rhs) const { return this->metric() < rhs.metric();  }
-    [[nodiscard]] bool close_match(const segment_tracker& other) const {
+    [[nodiscard]] double metric () const {
+      return max_edgelen / (segment_count + 0.5);
+    }
+    bool operator< (const segment_tracker &rhs) const {
+      return this->metric () < rhs.metric ();
+    }
+    [[nodiscard]] bool close_match (const segment_tracker &other) const {
       // Edges are grouped when metrics match by at least 99.9%
       constexpr double APPROX_EQ_RATIO = 0.999;
-      double l1 = this->metric(), l2 = other.metric();
-      return std::min(l1, l2) / std::max(l1, l2) >= APPROX_EQ_RATIO;
+      double l1 = this->metric (), l2 = other.metric ();
+      return std::min (l1, l2) / std::max (l1, l2) >= APPROX_EQ_RATIO;
     }
   };
 
-  const auto num_vertices = o.vertices.size();
-  std::vector<unsigned int> segment_counts(num_vertices, 1);
+  const auto num_vertices = o.vertices.size ();
+  std::vector<unsigned int> segment_counts (num_vertices, 1);
   std::priority_queue<segment_tracker, std::vector<segment_tracker>> q;
 
   Vector2d v0 = o.vertices[0];
@@ -89,22 +94,22 @@ Outline2d splitOutlineByFn(
       Vector2d v1 = o.vertices[i % num_vertices];
       double max_edgelen = 0.0; // max length for single edge over all transformed slices
       for (unsigned int j = 0; j <= slices; j++) {
-        double t = static_cast<double>(j) / slices;
-        Vector2d scale(Calc::lerp(1, scale_x, t), Calc::lerp(1, scale_y, t));
+        double t = static_cast<double> (j) / slices;
+        Vector2d scale (Calc::lerp (1, scale_x, t), Calc::lerp (1, scale_y, t));
         double rot = twist * t;
-        Eigen::Affine2d trans(Eigen::Scaling(scale) * Eigen::Affine2d(rotate_degrees(-rot)));
-        double edgelen = (trans * v1 - trans * v0).norm();
-        max_edgelen = std::max(max_edgelen, edgelen);
+        Eigen::Affine2d trans (Eigen::Scaling (scale) * Eigen::Affine2d (rotate_degrees (-rot)));
+        double edgelen = (trans * v1 - trans * v0).norm ();
+        max_edgelen = std::max (max_edgelen, edgelen);
       }
-      q.emplace(i - 1, max_edgelen);
+      q.emplace (i - 1, max_edgelen);
       v0 = v1;
     }
   } else { // uniform scaling
-    double max_scale = std::max(scale_x, 1.0);
+    double max_scale = std::max (scale_x, 1.0);
     for (size_t i = 1; i <= num_vertices; ++i) {
       Vector2d v1 = o.vertices[i % num_vertices];
-      double max_edgelen = (v1 - v0).norm() * max_scale;
-      q.emplace(i - 1, max_edgelen);
+      double max_edgelen = (v1 - v0).norm () * max_scale;
+      q.emplace (i - 1, max_edgelen);
       v0 = v1;
     }
   }
@@ -113,29 +118,29 @@ Outline2d splitOutlineByFn(
   // Process priority_queue until number of segments is reached.
   size_t seg_total = num_vertices;
   while (seg_total < fn) {
-    auto current = q.top();
+    auto current = q.top ();
 
     // Group similar length segmented edges to keep result roughly symmetrical.
-    while (!q.empty() && (tmp_q.empty() || q.top().close_match(tmp_q.front()))) {
-      tmp_q.push_back(q.top());
-      q.pop();
+    while (!q.empty () && (tmp_q.empty () || q.top ().close_match (tmp_q.front ()))) {
+      tmp_q.push_back (q.top ());
+      q.pop ();
     }
 
-    if (seg_total + tmp_q.size() <= fn) {
-      while (!tmp_q.empty()) {
-        current = tmp_q.back();
-        tmp_q.pop_back();
+    if (seg_total + tmp_q.size () <= fn) {
+      while (!tmp_q.empty ()) {
+        current = tmp_q.back ();
+        tmp_q.pop_back ();
         ++current.segment_count;
         ++segment_counts[current.edge_index];
         ++seg_total;
-        q.push(current);
+        q.push (current);
       }
     } else {
       // fn too low to segment last group, push back onto queue without change.
-      while (!tmp_q.empty()) {
-        current = tmp_q.back();
-        tmp_q.pop_back();
-        q.push(current);
+      while (!tmp_q.empty ()) {
+        current = tmp_q.back ();
+        tmp_q.pop_back ();
+        q.push (current);
       }
       break;
     }
@@ -147,22 +152,21 @@ Outline2d splitOutlineByFn(
   v0 = o.vertices[0];
   for (size_t i = 1; i <= num_vertices; ++i) {
     Vector2d v1 = o.vertices[i % num_vertices];
-    add_segmented_edge(o2, v0, v1, segment_counts[i - 1]);
+    add_segmented_edge (o2, v0, v1, segment_counts[i - 1]);
     v0 = v1;
   }
 
-  assert(o2.vertices.size() <= fn);
+  assert (o2.vertices.size () <= fn);
   return o2;
 }
 
 // For each edge in original outline, find its max length over all slice transforms,
 // and divide into segments no longer than fs.
-Outline2d splitOutlineByFs(
-  const Outline2d& o,
+Outline2d splitOutlineByFs (
+  const Outline2d &o,
   const double twist, const double scale_x, const double scale_y,
-  const double fs, unsigned int slices)
-{
-  const auto num_vertices = o.vertices.size();
+  const double fs, unsigned int slices) {
+  const auto num_vertices = o.vertices.size ();
 
   Vector2d v0 = o.vertices[0];
   Outline2d o2;
@@ -175,105 +179,105 @@ Outline2d splitOutlineByFs(
       Vector2d v1 = o.vertices[i % num_vertices];
       double max_edgelen = 0.0; // max length for single edge over all transformed slices
       for (unsigned int j = 0; j <= slices; j++) {
-        double t = static_cast<double>(j) / slices;
-        Vector2d scale(Calc::lerp(1, scale_x, t), Calc::lerp(1, scale_y, t));
+        double t = static_cast<double> (j) / slices;
+        Vector2d scale (Calc::lerp (1, scale_x, t), Calc::lerp (1, scale_y, t));
         double rot = twist * t;
-        Eigen::Affine2d trans(Eigen::Scaling(scale) * Eigen::Affine2d(rotate_degrees(-rot)));
-        double edgelen = (trans * v1 - trans * v0).norm();
-        max_edgelen = std::max(max_edgelen, edgelen);
+        Eigen::Affine2d trans (Eigen::Scaling (scale) * Eigen::Affine2d (rotate_degrees (-rot)));
+        double edgelen = (trans * v1 - trans * v0).norm ();
+        max_edgelen = std::max (max_edgelen, edgelen);
       }
-      auto edge_segments = static_cast<unsigned int>(std::ceil(max_edgelen / fs));
-      add_segmented_edge(o2, v0, v1, edge_segments);
+      auto edge_segments = static_cast<unsigned int> (std::ceil (max_edgelen / fs));
+      add_segmented_edge (o2, v0, v1, edge_segments);
       v0 = v1;
     }
   } else { // uniform scaling
-    double max_scale = std::max(scale_x, 1.0);
+    double max_scale = std::max (scale_x, 1.0);
     for (size_t i = 1; i <= num_vertices; ++i) {
       Vector2d v1 = o.vertices[i % num_vertices];
-      unsigned int edge_segments = static_cast<unsigned int>(std::ceil((v1 - v0).norm() * max_scale / fs));
-      add_segmented_edge(o2, v0, v1, edge_segments);
+      unsigned int edge_segments = static_cast<unsigned int> (std::ceil ((v1 - v0).norm () * max_scale / fs));
+      add_segmented_edge (o2, v0, v1, edge_segments);
       v0 = v1;
     }
   }
   return o2;
 }
 
-std::unique_ptr<PolySet> assemblePolySetForManifold(
-  const Polygon2d& polyref,
-  std::vector<Vector3d>& vertices, PolygonIndices& indices,
+std::unique_ptr<PolySet> assemblePolySetForManifold (
+  const Polygon2d &polyref,
+  std::vector<Vector3d> &vertices, PolygonIndices &indices,
   int convexity, boost::tribool isConvex, int index_offset) {
-  auto final_polyset = std::make_unique<PolySet>(3, isConvex);
-  final_polyset->setTriangular(true);
-  final_polyset->setConvexity(convexity);
-  final_polyset->vertices = std::move(vertices);
-  final_polyset->indices = std::move(indices);
+  auto final_polyset = std::make_unique<PolySet> (3, isConvex);
+  final_polyset->setTriangular (true);
+  final_polyset->setConvexity (convexity);
+  final_polyset->vertices = std::move (vertices);
+  final_polyset->indices = std::move (indices);
 
   // Create top and bottom face.
-  auto ps_bottom = polyref.tessellate(); // bottom
+  auto ps_bottom = polyref.tessellate (); // bottom
   // Flip vertex ordering for bottom polygon
-  for (auto& p : ps_bottom->indices) {
-    std::reverse(p.begin(), p.end());
+  for (auto &p : ps_bottom->indices) {
+    std::reverse (p.begin (), p.end ());
   }
-  std::copy(ps_bottom->indices.begin(), ps_bottom->indices.end(),
-            std::back_inserter(final_polyset->indices));
+  std::copy (ps_bottom->indices.begin (), ps_bottom->indices.end (),
+             std::back_inserter (final_polyset->indices));
 
-  for (auto& p : ps_bottom->indices) {
-    std::reverse(p.begin(), p.end());
-    for (auto& i : p) {
+  for (auto &p : ps_bottom->indices) {
+    std::reverse (p.begin (), p.end ());
+    for (auto &i : p) {
       i += index_offset;
     }
   }
-  std::copy(ps_bottom->indices.begin(), ps_bottom->indices.end(),
-            std::back_inserter(final_polyset->indices));
+  std::copy (ps_bottom->indices.begin (), ps_bottom->indices.end (),
+             std::back_inserter (final_polyset->indices));
 
   // LOG(PolySetUtils::polySetToPolyhedronSource(*final_polyset));
 
   return final_polyset;
 }
 
-std::unique_ptr<PolySet> assemblePolySetForCGAL(const Polygon2d& polyref,
-                                                std::vector<Vector3d>& vertices, PolygonIndices& indices,
-                                                int convexity, boost::tribool isConvex,
-                                                double scale_x, double scale_y,
-                                                const Vector3d& h1, const Vector3d& h2, double twist) {
+std::unique_ptr<PolySet> assemblePolySetForCGAL (const Polygon2d &polyref,
+                                                 std::vector<Vector3d> &vertices, PolygonIndices &indices,
+                                                 int convexity, boost::tribool isConvex,
+                                                 double scale_x, double scale_y,
+                                                 const Vector3d &h1, const Vector3d &h2, double twist) {
 
-  PolySetBuilder builder(0, 0, 3, isConvex);
-  builder.setConvexity(convexity);
+  PolySetBuilder builder (0, 0, 3, isConvex);
+  builder.setConvexity (convexity);
 
-  for (const auto& poly: indices) {
-    builder.beginPolygon(poly.size());
+  for (const auto &poly : indices) {
+    builder.beginPolygon (poly.size ());
     for (const auto idx : poly) {
-      builder.addVertex(vertices[idx]);
+      builder.addVertex (vertices[idx]);
     }
   }
 
-  auto translatePolySet = [](PolySet& ps, const Vector3d& translation) {
-      for (auto& v : ps.vertices) {
-        v += translation;
-      }
-    };
+  auto translatePolySet = [] (PolySet &ps, const Vector3d &translation) {
+    for (auto &v : ps.vertices) {
+      v += translation;
+    }
+  };
 
   // Create bottom face.
-  auto ps_bottom = polyref.tessellate(); // bottom
+  auto ps_bottom = polyref.tessellate (); // bottom
   // Flip vertex ordering for bottom polygon
-  for (auto& p : ps_bottom->indices) {
-    std::reverse(p.begin(), p.end());
+  for (auto &p : ps_bottom->indices) {
+    std::reverse (p.begin (), p.end ());
   }
-  translatePolySet(*ps_bottom, h1);
-  builder.appendPolySet(*ps_bottom);
+  translatePolySet (*ps_bottom, h1);
+  builder.appendPolySet (*ps_bottom);
 
   // Create top face.
   // If either scale components are 0, then top will be zero-area, so skip it.
   if (scale_x != 0 && scale_y != 0) {
-    Polygon2d top_poly(polyref);
-    Eigen::Affine2d trans(Eigen::Scaling(scale_x, scale_y) * Eigen::Affine2d(rotate_degrees(-twist)));
-    top_poly.transform(trans);
-    auto ps_top = top_poly.tessellate();
-    translatePolySet(*ps_top, h2);
-    builder.appendPolySet(*ps_top);
+    Polygon2d top_poly (polyref);
+    Eigen::Affine2d trans (Eigen::Scaling (scale_x, scale_y) * Eigen::Affine2d (rotate_degrees (-twist)));
+    top_poly.transform (trans);
+    auto ps_top = top_poly.tessellate ();
+    translatePolySet (*ps_top, h2);
+    builder.appendPolySet (*ps_top);
   }
 
-  return builder.build();
+  return builder.build ();
 }
 
 /*
@@ -283,22 +287,21 @@ std::unique_ptr<PolySet> assemblePolySetForCGAL(const Polygon2d& polyref,
    Quads are triangulated across the shorter of the two diagonals, which works well in most cases.
    However, when diagonals are equal length, decision may flip depending on other factors.
  */
-void add_slice_indices(PolygonIndices& indices, int slice_idx, int slice_stride, const Polygon2d& poly,
-                       double rot1, double rot2,
-                       const Vector2d& scale1, const Vector2d& scale2)
-{
+void add_slice_indices (PolygonIndices &indices, int slice_idx, int slice_stride, const Polygon2d &poly,
+                        double rot1, double rot2,
+                        const Vector2d &scale1, const Vector2d &scale2) {
   int prev_slice = (slice_idx - 1) * slice_stride;
   int curr_slice = slice_idx * slice_stride;
 
-  Eigen::Affine2d trans1(Eigen::Scaling(scale1) * Eigen::Affine2d(rotate_degrees(-rot1)));
-  Eigen::Affine2d trans2(Eigen::Scaling(scale2) * Eigen::Affine2d(rotate_degrees(-rot2)));
+  Eigen::Affine2d trans1 (Eigen::Scaling (scale1) * Eigen::Affine2d (rotate_degrees (-rot1)));
+  Eigen::Affine2d trans2 (Eigen::Scaling (scale2) * Eigen::Affine2d (rotate_degrees (-rot2)));
 
   bool any_zero = scale2[0] == 0 || scale2[1] == 0;
   // setting back_twist true helps keep diagonals same as previous builds.
   bool back_twist = rot2 <= rot1;
 
   int curr_outline = 0;
-  for (const auto& o : poly.outlines()) {
+  for (const auto &o : poly.outlines ()) {
     // prev1: previous slice, previous vertex
     // prev2: current slice, previous vertex
     Vector2d prev1 = trans1 * o.vertices[0];
@@ -311,88 +314,88 @@ void add_slice_indices(PolygonIndices& indices, int slice_idx, int slice_stride,
     // matched the direction of diagonal for neighboring edges (which did not exhibit "equal" diagonals).
     bool flip = ((!o.positive) xor (back_twist));
 
-    for (int i = 1; i <= o.vertices.size(); ++i) {
+    for (int i = 1; i <= o.vertices.size (); ++i) {
       // curr1: previous slice, current vertex
       // curr2: current slice, current vertex
-      Vector2d curr1 = trans1 * o.vertices[i % o.vertices.size()];
-      Vector2d curr2 = trans2 * o.vertices[i % o.vertices.size()];
-      int curr_idx = curr_outline + (i % o.vertices.size());
+      Vector2d curr1 = trans1 * o.vertices[i % o.vertices.size ()];
+      Vector2d curr2 = trans2 * o.vertices[i % o.vertices.size ()];
+      int curr_idx = curr_outline + (i % o.vertices.size ());
       int prev_idx = curr_outline + i - 1;
 
-      int diff_sign = sgn_vdiff(prev1 - curr2, curr1 - prev2);
+      int diff_sign = sgn_vdiff (prev1 - curr2, curr1 - prev2);
       bool splitfirst = diff_sign == -1 || (diff_sign == 0 && !flip);
 
       // Split along shortest diagonal,
       // unless at top for a 0-scaled axis (which can create 0 thickness "ears")
       if (splitfirst xor any_zero) {
-        indices.push_back({
-            prev_slice + curr_idx,
-            curr_slice + curr_idx,
-            prev_slice + prev_idx,
-          });
-        indices.push_back({
-            curr_slice + prev_idx,
-            prev_slice + prev_idx,
-            curr_slice + curr_idx,
-          });
+        indices.push_back ({
+          prev_slice + curr_idx,
+          curr_slice + curr_idx,
+          prev_slice + prev_idx,
+        });
+        indices.push_back ({
+          curr_slice + prev_idx,
+          prev_slice + prev_idx,
+          curr_slice + curr_idx,
+        });
       } else {
-        indices.push_back({
-            prev_slice + curr_idx,
-            curr_slice + prev_idx,
-            prev_slice + prev_idx,
-          });
-        indices.push_back({
-            prev_slice + curr_idx,
-            curr_slice + curr_idx,
-            curr_slice + prev_idx,
-          });
+        indices.push_back ({
+          prev_slice + curr_idx,
+          curr_slice + prev_idx,
+          prev_slice + prev_idx,
+        });
+        indices.push_back ({
+          prev_slice + curr_idx,
+          curr_slice + curr_idx,
+          curr_slice + prev_idx,
+        });
       }
       prev1 = curr1;
       prev2 = curr2;
     }
-    curr_outline += o.vertices.size();
+    curr_outline += o.vertices.size ();
   }
 }
 
-size_t calc_num_slices(const LinearExtrudeNode& node, const Polygon2d& poly) {
+size_t calc_num_slices (const LinearExtrudeNode &node, const Polygon2d &poly) {
   size_t num_slices;
   if (node.has_slices) {
     num_slices = node.slices;
   } else if (node.has_twist) {
     double max_r1_sqr = 0; // r1 is before scaling
-    Vector2d scale(node.scale_x, node.scale_y);
-    for (const auto& o : poly.outlines())
-      for (const auto& v : o.vertices)
-        max_r1_sqr = fmax(max_r1_sqr, v.squaredNorm());
+    Vector2d scale (node.scale_x, node.scale_y);
+    for (const auto &o : poly.outlines ())
+      for (const auto &v : o.vertices)
+        max_r1_sqr = fmax (max_r1_sqr, v.squaredNorm ());
     // Calculate Helical curve length for Twist with no Scaling
     if (node.scale_x == 1.0 && node.scale_y == 1.0) {
-      num_slices = (unsigned int)Calc::get_helix_slices(max_r1_sqr, node.height[2], node.twist, node.fn, node.fs, node.fa);
-    } else if (node.scale_x != node.scale_y) {  // non uniform scaling with twist using max slices from twist and non uniform scale
+      num_slices = (unsigned int)Calc::get_helix_slices (max_r1_sqr, node.height[2], node.twist, node.fn, node.fs, node.fa);
+    } else if (node.scale_x != node.scale_y) { // non uniform scaling with twist using max slices from twist and non uniform scale
       double max_delta_sqr = 0; // delta from before/after scaling
-      Vector2d scale(node.scale_x, node.scale_y);
-      for (const auto& o : poly.outlines()) {
-        for (const auto& v : o.vertices) {
-          max_delta_sqr = fmax(max_delta_sqr, (v - v.cwiseProduct(scale)).squaredNorm());
+      Vector2d scale (node.scale_x, node.scale_y);
+      for (const auto &o : poly.outlines ()) {
+        for (const auto &v : o.vertices) {
+          max_delta_sqr = fmax (max_delta_sqr, (v - v.cwiseProduct (scale)).squaredNorm ());
         }
       }
       size_t slicesNonUniScale;
       size_t slicesTwist;
-      slicesNonUniScale = (unsigned int)Calc::get_diagonal_slices(max_delta_sqr, node.height[2], node.fn, node.fs);
-      slicesTwist = (unsigned int)Calc::get_helix_slices(max_r1_sqr, node.height[2], node.twist, node.fn, node.fs, node.fa);
-      num_slices = std::max(slicesNonUniScale, slicesTwist);
+      slicesNonUniScale = (unsigned int)Calc::get_diagonal_slices (max_delta_sqr, node.height[2], node.fn, node.fs);
+      slicesTwist = (unsigned int)Calc::get_helix_slices (max_r1_sqr, node.height[2], node.twist, node.fn, node.fs, node.fa);
+      num_slices = std::max (slicesNonUniScale, slicesTwist);
     } else { // uniform scaling with twist, use conical helix calculation
-      num_slices = (unsigned int)Calc::get_conical_helix_slices(max_r1_sqr, node.height[2], node.twist, node.scale_x, node.fn, node.fs, node.fa);
+      num_slices = (unsigned int)Calc::get_conical_helix_slices (max_r1_sqr, node.height[2], node.twist, node.scale_x, node.fn, node.fs, node.fa);
     }
   } else if (node.scale_x != node.scale_y) {
     // Non uniform scaling, w/o twist
     double max_delta_sqr = 0; // delta from before/after scaling
-    Vector2d scale(node.scale_x, node.scale_y);
-    for (const auto& o : poly.outlines()) {
-      for (const auto& v : o.vertices) {
-        max_delta_sqr = fmax(max_delta_sqr, (v - v.cwiseProduct(scale)).squaredNorm());
+    Vector2d scale (node.scale_x, node.scale_y);
+    for (const auto &o : poly.outlines ()) {
+      for (const auto &v : o.vertices) {
+        max_delta_sqr = fmax (max_delta_sqr, (v - v.cwiseProduct (scale)).squaredNorm ());
       }
     }
-    num_slices = Calc::get_diagonal_slices(max_delta_sqr, node.height[2], node.fn, node.fs);
+    num_slices = Calc::get_diagonal_slices (max_delta_sqr, node.height[2], node.fn, node.fs);
   } else {
     // uniform or [1,1] scaling w/o twist needs only one slice
     num_slices = 1;
@@ -400,25 +403,26 @@ size_t calc_num_slices(const LinearExtrudeNode& node, const Polygon2d& poly) {
   return num_slices;
 }
 
-}  // namespace
+} // namespace
 
 /*!
    Input to extrude should be sanitized. This means non-intersecting, correct winding order
    etc., the input coming from a library like Clipper.
  */
-std::unique_ptr<Geometry> extrudePolygon(const LinearExtrudeNode& node, const Polygon2d& poly)
-{
-  assert(poly.isSanitized());
-  if (node.height[2] <= 0) return PolySet::createEmpty();
+std::unique_ptr<Geometry> extrudePolygon (const LinearExtrudeNode &node, const Polygon2d &poly) {
+  assert (poly.isSanitized ());
+  if (node.height[2] <= 0)
+    return PolySet::createEmpty ();
 
   bool non_linear = node.twist != 0 || node.scale_x != node.scale_y;
-  boost::tribool isConvex{poly.is_convex()};
+  boost::tribool isConvex{poly.is_convex ()};
   // Twist makes convex polygons into unknown polyhedrons
-  if (isConvex && non_linear) isConvex = unknown;
+  if (isConvex && non_linear)
+    isConvex = unknown;
 
   // num_slices is the number of volumetric segments, minimum 1.
   // The number of rings of vertices will be num_slices+1.
-  auto num_slices = calc_num_slices(node, poly);
+  auto num_slices = calc_num_slices (node, poly);
 
   // Calculate outline segments if appropriate.
   Polygon2d seg_poly;
@@ -426,36 +430,36 @@ std::unique_ptr<Geometry> extrudePolygon(const LinearExtrudeNode& node, const Po
   if (node.has_segments) {
     // Set segments = 0 to disable
     if (node.segments > 0) {
-      for (const auto& o : poly.outlines()) {
-        if (o.vertices.size() >= node.segments) {
-          seg_poly.addOutline(o);
+      for (const auto &o : poly.outlines ()) {
+        if (o.vertices.size () >= node.segments) {
+          seg_poly.addOutline (o);
         } else {
-          seg_poly.addOutline(splitOutlineByFn(o, node.twist, node.scale_x, node.scale_y, node.segments, num_slices));
+          seg_poly.addOutline (splitOutlineByFn (o, node.twist, node.scale_x, node.scale_y, node.segments, num_slices));
         }
       }
       is_segmented = true;
     }
   } else if (non_linear) {
     if (node.fn > 0.0) {
-      for (const auto& o : poly.outlines()) {
-        if (o.vertices.size() >= node.fn) {
-          seg_poly.addOutline(o);
+      for (const auto &o : poly.outlines ()) {
+        if (o.vertices.size () >= node.fn) {
+          seg_poly.addOutline (o);
         } else {
-          seg_poly.addOutline(splitOutlineByFn(o, node.twist, node.scale_x, node.scale_y, node.fn, num_slices));
+          seg_poly.addOutline (splitOutlineByFn (o, node.twist, node.scale_x, node.scale_y, node.fn, num_slices));
         }
       }
     } else { // $fs and $fa based segmentation
-      auto fa_segs = static_cast<unsigned int>(std::ceil(360.0 / node.fa));
-      for (const auto& o : poly.outlines()) {
-        if (o.vertices.size() >= fa_segs) {
-          seg_poly.addOutline(o);
+      auto fa_segs = static_cast<unsigned int> (std::ceil (360.0 / node.fa));
+      for (const auto &o : poly.outlines ()) {
+        if (o.vertices.size () >= fa_segs) {
+          seg_poly.addOutline (o);
         } else {
           // try splitting by $fs, then check if $fa results in less segments
-          auto fsOutline = splitOutlineByFs(o, node.twist, node.scale_x, node.scale_y, node.fs, num_slices);
-          if (fsOutline.vertices.size() >= fa_segs) {
-            seg_poly.addOutline(splitOutlineByFn(o, node.twist, node.scale_x, node.scale_y, fa_segs, num_slices));
+          auto fsOutline = splitOutlineByFs (o, node.twist, node.scale_x, node.scale_y, node.fs, num_slices);
+          if (fsOutline.vertices.size () >= fa_segs) {
+            seg_poly.addOutline (splitOutlineByFn (o, node.twist, node.scale_x, node.scale_y, fa_segs, num_slices));
           } else {
-            seg_poly.addOutline(std::move(fsOutline));
+            seg_poly.addOutline (std::move (fsOutline));
           }
         }
       }
@@ -463,9 +467,9 @@ std::unique_ptr<Geometry> extrudePolygon(const LinearExtrudeNode& node, const Po
     is_segmented = true;
   }
 
-  const Polygon2d& polyref = is_segmented ? seg_poly : poly;
+  const Polygon2d &polyref = is_segmented ? seg_poly : poly;
 
-  Vector3d h1 = Vector3d::Zero();
+  Vector3d h1 = Vector3d::Zero ();
   Vector3d h2 = node.height;
 
   if (node.center) {
@@ -474,27 +478,27 @@ std::unique_ptr<Geometry> extrudePolygon(const LinearExtrudeNode& node, const Po
   }
 
   int slice_stride = 0;
-  for (const auto& o : polyref.outlines()) {
-    slice_stride += o.vertices.size();
+  for (const auto &o : polyref.outlines ()) {
+    slice_stride += o.vertices.size ();
   }
   std::vector<Vector3d> vertices;
-  vertices.reserve(slice_stride * (num_slices + 1));
+  vertices.reserve (slice_stride * (num_slices + 1));
   PolygonIndices indices;
-  indices.reserve(slice_stride * (num_slices + 1) * 2); // sides + endcaps
+  indices.reserve (slice_stride * (num_slices + 1) * 2); // sides + endcaps
 
   // Calculate all vertices
-  Vector2d full_scale(1 - node.scale_x, 1 - node.scale_y);
+  Vector2d full_scale (1 - node.scale_x, 1 - node.scale_y);
   double full_rot = -node.twist;
   auto full_height = (h2 - h1);
   for (unsigned int slice_idx = 0; slice_idx <= num_slices; slice_idx++) {
-    Eigen::Affine2d trans(
-      Eigen::Scaling(Vector2d(1, 1) - full_scale * slice_idx / num_slices) *
-      Eigen::Affine2d(rotate_degrees(full_rot * slice_idx / num_slices)));
+    Eigen::Affine2d trans (
+      Eigen::Scaling (Vector2d (1, 1) - full_scale * slice_idx / num_slices) *
+      Eigen::Affine2d (rotate_degrees (full_rot * slice_idx / num_slices)));
 
-    for (const auto& o : polyref.outlines()) {
-      for (const auto& v : o.vertices) {
+    for (const auto &o : polyref.outlines ()) {
+      for (const auto &v : o.vertices) {
         auto tmp = trans * v;
-        vertices.emplace_back(Vector3d(tmp[0], tmp[1], 0.0) + h1 + full_height * slice_idx / num_slices);
+        vertices.emplace_back (Vector3d (tmp[0], tmp[1], 0.0) + h1 + full_height * slice_idx / num_slices);
       }
     }
   }
@@ -505,11 +509,11 @@ std::unique_ptr<Geometry> extrudePolygon(const LinearExtrudeNode& node, const Po
     double rot_curr = node.twist * slice_idx / num_slices;
     auto height_prev = h1 + (h2 - h1) * (slice_idx - 1) / num_slices;
     auto height_curr = h1 + (h2 - h1) * slice_idx / num_slices;
-    Vector2d scale_prev(1 - (1 - node.scale_x) * (slice_idx - 1) / num_slices,
-                        1 - (1 - node.scale_y) * (slice_idx - 1) / num_slices);
-    Vector2d scale_curr(1 - (1 - node.scale_x) * slice_idx / num_slices,
-                        1 - (1 - node.scale_y) * slice_idx / num_slices);
-    add_slice_indices(indices, slice_idx, slice_stride, polyref, rot_prev, rot_curr, scale_prev, scale_curr);
+    Vector2d scale_prev (1 - (1 - node.scale_x) * (slice_idx - 1) / num_slices,
+                         1 - (1 - node.scale_y) * (slice_idx - 1) / num_slices);
+    Vector2d scale_curr (1 - (1 - node.scale_x) * slice_idx / num_slices,
+                         1 - (1 - node.scale_y) * slice_idx / num_slices);
+    add_slice_indices (indices, slice_idx, slice_stride, polyref, rot_prev, rot_curr, scale_prev, scale_curr);
   }
 
   // For Manifold, we can tesselate the endcaps using existing vertices to build a manifold mesh.
@@ -517,13 +521,13 @@ std::unique_ptr<Geometry> extrudePolygon(const LinearExtrudeNode& node, const Po
   // the polyset from vertices using PolySetBuilder
 
 #ifdef ENABLE_MANIFOLD
-  if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
-    return assemblePolySetForManifold(polyref, vertices, indices,
-                                      node.convexity, isConvex, slice_stride * num_slices);
+  if (RenderSettings::inst ()->backend3D == RenderBackend3D::ManifoldBackend) {
+    return assemblePolySetForManifold (polyref, vertices, indices,
+                                       node.convexity, isConvex, slice_stride * num_slices);
   } else
 #endif
-  return assemblePolySetForCGAL(polyref, vertices, indices,
-                                node.convexity, isConvex,
-                                node.scale_x, node.scale_y,
-                                h1, h2, node.twist);
+    return assemblePolySetForCGAL (polyref, vertices, indices,
+                                   node.convexity, isConvex,
+                                   node.scale_x, node.scale_y,
+                                   h1, h2, node.twist);
 }
diff --git a/src/geometry/linear_extrude.h b/src/geometry/linear_extrude.h
index 68182df6b..523807b42 100644
--- a/src/geometry/linear_extrude.h
+++ b/src/geometry/linear_extrude.h
@@ -6,4 +6,4 @@
 #include "geometry/Geometry.h"
 #include "core/LinearExtrudeNode.h"
 
-std::unique_ptr<Geometry> extrudePolygon(const LinearExtrudeNode& node, const Polygon2d& poly);
+std::unique_ptr<Geometry> extrudePolygon (const LinearExtrudeNode &node, const Polygon2d &poly);
diff --git a/src/geometry/manifold/ManifoldGeometry.cc b/src/geometry/manifold/ManifoldGeometry.cc
index 83f1cd7be..7c11cbc9a 100644
--- a/src/geometry/manifold/ManifoldGeometry.cc
+++ b/src/geometry/manifold/ManifoldGeometry.cc
@@ -28,151 +28,150 @@
 namespace {
 
 template <typename Result, typename V>
-Result vector_convert(V const& v) {
-  return Result(v[0], v[1], v[2]);
+Result vector_convert (V const &v) {
+  return Result (v[0], v[1], v[2]);
 }
 
-}
+} // namespace
 
-ManifoldGeometry::ManifoldGeometry() : manifold_(manifold::Manifold()) {}
+ManifoldGeometry::ManifoldGeometry ()
+  : manifold_ (manifold::Manifold ()) {}
 
-ManifoldGeometry::ManifoldGeometry(
+ManifoldGeometry::ManifoldGeometry (
   manifold::Manifold mani,
-  const std::set<uint32_t>& originalIDs,
-  const std::map<uint32_t, Color4f>& originalIDToColor,
-  const std::set<uint32_t>& subtractedIDs)
-  : manifold_(std::move(mani)),
-  originalIDs_(originalIDs),
-  originalIDToColor_(originalIDToColor),
-  subtractedIDs_(subtractedIDs)
-{
+  const std::set<uint32_t> &originalIDs,
+  const std::map<uint32_t, Color4f> &originalIDToColor,
+  const std::set<uint32_t> &subtractedIDs)
+  : manifold_ (std::move (mani))
+  , originalIDs_ (originalIDs)
+  , originalIDToColor_ (originalIDToColor)
+  , subtractedIDs_ (subtractedIDs) {
 }
 
-std::unique_ptr<Geometry> ManifoldGeometry::copy() const
-{
-  return std::make_unique<ManifoldGeometry>(*this);
+std::unique_ptr<Geometry> ManifoldGeometry::copy () const {
+  return std::make_unique<ManifoldGeometry> (*this);
 }
 
-const manifold::Manifold& ManifoldGeometry::getManifold() const {
+const manifold::Manifold &ManifoldGeometry::getManifold () const {
   return manifold_;
 }
 
-bool ManifoldGeometry::isEmpty() const {
-  return getManifold().IsEmpty();
+bool ManifoldGeometry::isEmpty () const {
+  return getManifold ().IsEmpty ();
 }
 
-size_t ManifoldGeometry::numFacets() const {
-  return getManifold().NumTri();
+size_t ManifoldGeometry::numFacets () const {
+  return getManifold ().NumTri ();
 }
 
-size_t ManifoldGeometry::numVertices() const {
-  return getManifold().NumVert();
+size_t ManifoldGeometry::numVertices () const {
+  return getManifold ().NumVert ();
 }
 
-bool ManifoldGeometry::isManifold() const {
-  return getManifold().Status() == manifold::Manifold::Error::NoError;
+bool ManifoldGeometry::isManifold () const {
+  return getManifold ().Status () == manifold::Manifold::Error::NoError;
 }
 
-bool ManifoldGeometry::isValid() const {
-  return manifold_.Status() == manifold::Manifold::Error::NoError;
+bool ManifoldGeometry::isValid () const {
+  return manifold_.Status () == manifold::Manifold::Error::NoError;
 }
 
-void ManifoldGeometry::clear() {
-  manifold_ = manifold::Manifold();
+void ManifoldGeometry::clear () {
+  manifold_ = manifold::Manifold ();
 }
 
-size_t ManifoldGeometry::memsize() const {
+size_t ManifoldGeometry::memsize () const {
   // We don't introspect on the manifold here, as this would force it to leaf node (ie. would render it).
   return 0;
 }
 
-std::string ManifoldGeometry::dump() const {
+std::string ManifoldGeometry::dump () const {
   std::ostringstream out;
-  auto& manifold = getManifold();
-  auto meshgl = manifold.GetMeshGL64();
+  auto &manifold = getManifold ();
+  auto meshgl = manifold.GetMeshGL64 ();
   out << "Manifold:"
-      << "\n status: " << ManifoldUtils::statusToString(manifold.Status())
-      << "\n genus: " << manifold.Genus()
-      << "\n num vertices: " << meshgl.NumVert()
-      << "\n num polygons: " << meshgl.NumTri()
+      << "\n status: " << ManifoldUtils::statusToString (manifold.Status ())
+      << "\n genus: " << manifold.Genus ()
+      << "\n num vertices: " << meshgl.NumVert ()
+      << "\n num polygons: " << meshgl.NumTri ()
       << "\n polygons data:";
 
-  for (size_t faceid = 0; faceid < meshgl.NumTri(); faceid++) {
+  for (size_t faceid = 0; faceid < meshgl.NumTri (); faceid++) {
     out << "\n  polygon begin:";
     for (const int j : {0, 1, 2}) {
-      auto v = vector_convert<Vector3d>(meshgl.GetVertPos(meshgl.GetTriVerts(faceid)[j]));
+      auto v = vector_convert<Vector3d> (meshgl.GetVertPos (meshgl.GetTriVerts (faceid)[j]));
       out << "\n   vertex:" << v;
     }
   }
   out << "Manifold end";
-  return out.str();
+  return out.str ();
 }
 
-std::shared_ptr<PolySet> ManifoldGeometry::toPolySet() const {
-  manifold::MeshGL64 mesh = getManifold().GetMeshGL64();
-  auto ps = std::make_shared<PolySet>(3);
-  ps->setTriangular(true);
-  ps->vertices.reserve(mesh.NumVert());
-  ps->indices.reserve(mesh.NumTri());
-  ps->setConvexity(convexity);
+std::shared_ptr<PolySet> ManifoldGeometry::toPolySet () const {
+  manifold::MeshGL64 mesh = getManifold ().GetMeshGL64 ();
+  auto ps = std::make_shared<PolySet> (3);
+  ps->setTriangular (true);
+  ps->vertices.reserve (mesh.NumVert ());
+  ps->indices.reserve (mesh.NumTri ());
+  ps->setConvexity (convexity);
 
   // first 3 channels are xyz coordinate
-  for (size_t i = 0; i < mesh.vertProperties.size(); i += mesh.numProp)
-    ps->vertices.emplace_back(
+  for (size_t i = 0; i < mesh.vertProperties.size (); i += mesh.numProp)
+    ps->vertices.emplace_back (
       mesh.vertProperties[i],
       mesh.vertProperties[i + 1],
       mesh.vertProperties[i + 2]);
 
-  ps->colors.reserve(originalIDToColor_.size());
-  ps->color_indices.reserve(ps->indices.size());
+  ps->colors.reserve (originalIDToColor_.size ());
+  ps->color_indices.reserve (ps->indices.size ());
 
-  auto colorScheme = ColorMap::inst()->findColorScheme(RenderSettings::inst()->colorscheme);
+  auto colorScheme = ColorMap::inst ()->findColorScheme (RenderSettings::inst ()->colorscheme);
   int32_t faceFrontColorIndex = -1;
   int32_t faceBackColorIndex = -1;
 
   std::map<Color4f, int32_t> colorToIndex;
   std::map<uint32_t, int32_t> originalIDToColorIndex;
 
-  auto getFaceFrontColorIndex = [&]() -> int {
-      if (faceFrontColorIndex < 0) {
-        faceFrontColorIndex = ps->colors.size();
-        ps->colors.push_back(ColorMap::getColor(*colorScheme, RenderColor::CGAL_FACE_FRONT_COLOR));
-      }
-      return faceFrontColorIndex;
-    };
-  auto getFaceBackColorIndex = [&]() -> int {
-      if (faceBackColorIndex < 0) {
-        faceBackColorIndex = ps->colors.size();
-        ps->colors.push_back(ColorMap::getColor(*colorScheme, RenderColor::CGAL_FACE_BACK_COLOR));
-      }
-      return faceBackColorIndex;
-    };
+  auto getFaceFrontColorIndex = [&] () -> int {
+    if (faceFrontColorIndex < 0) {
+      faceFrontColorIndex = ps->colors.size ();
+      ps->colors.push_back (ColorMap::getColor (*colorScheme, RenderColor::CGAL_FACE_FRONT_COLOR));
+    }
+    return faceFrontColorIndex;
+  };
+  auto getFaceBackColorIndex = [&] () -> int {
+    if (faceBackColorIndex < 0) {
+      faceBackColorIndex = ps->colors.size ();
+      ps->colors.push_back (ColorMap::getColor (*colorScheme, RenderColor::CGAL_FACE_BACK_COLOR));
+    }
+    return faceBackColorIndex;
+  };
 
-  auto getColorIndex = [&](uint32_t originalID) -> int32_t {
-      if (subtractedIDs_.find(originalID) != subtractedIDs_.end()) {
-        return getFaceBackColorIndex();
-      }
-      auto colorIndexIt = originalIDToColorIndex.find(originalID);
-      if (colorIndexIt != originalIDToColorIndex.end()) {
-        return colorIndexIt->second;
-      }
-      auto colorIt = originalIDToColor_.find(originalID);
-      if (colorIt == originalIDToColor_.end()) {
-        return getFaceFrontColorIndex();
-      }
-      const auto& color = colorIt->second;
+  auto getColorIndex = [&] (uint32_t originalID) -> int32_t {
+    if (subtractedIDs_.find (originalID) != subtractedIDs_.end ()) {
+      return getFaceBackColorIndex ();
+    }
+    auto colorIndexIt = originalIDToColorIndex.find (originalID);
+    if (colorIndexIt != originalIDToColorIndex.end ()) {
+      return colorIndexIt->second;
+    }
+    auto colorIt = originalIDToColor_.find (originalID);
+    if (colorIt == originalIDToColor_.end ()) {
+      return getFaceFrontColorIndex ();
+    }
+    const auto &color = colorIt->second;
 
-      auto pair = colorToIndex.insert({color, ps->colors.size()});
-      if (pair.second) {
-        ps->colors.push_back(color);
-      }
-      int32_t color_index = pair.first->second;
-      originalIDToColorIndex[originalID] = color_index;
-      return color_index;
-    };
+    auto pair = colorToIndex.insert ({color, ps->colors.size ()});
+    if (pair.second) {
+      ps->colors.push_back (color);
+    }
+    int32_t color_index = pair.first->second;
+    originalIDToColorIndex[originalID] = color_index;
+    return color_index;
+  };
 
   auto start = mesh.runIndex[0];
-  for (int run = 0, numRun = mesh.runIndex.size() - 1; run < numRun; ++run) {
+  for (int run = 0, numRun = mesh.runIndex.size () - 1; run < numRun; ++run) {
     const auto id = mesh.runOriginalID[run];
     const auto end = mesh.runIndex[run + 1];
     const size_t numTri = (end - start) / 3;
@@ -180,13 +179,12 @@ std::shared_ptr<PolySet> ManifoldGeometry::toPolySet() const {
       continue;
     }
 
-    auto colorIndex = getColorIndex(id);
+    auto colorIndex = getColorIndex (id);
     for (size_t i = start; i < end; i += 3) {
-      ps->indices.push_back({
-        static_cast<int>(mesh.triVerts[i]),
-        static_cast<int>(mesh.triVerts[i + 1]),
-        static_cast<int>(mesh.triVerts[i + 2])});
-      ps->color_indices.push_back(colorIndex);
+      ps->indices.push_back ({static_cast<int> (mesh.triVerts[i]),
+                              static_cast<int> (mesh.triVerts[i + 1]),
+                              static_cast<int> (mesh.triVerts[i + 2])});
+      ps->color_indices.push_back (colorIndex);
     }
     start = end;
   }
@@ -199,180 +197,181 @@ class CGALPolyhedronBuilderFromManifold : public CGAL::Modifier_base<typename Po
 {
   using HDS = typename Polyhedron::HalfedgeDS;
   using CGAL_Polybuilder = CGAL::Polyhedron_incremental_builder_3<typename Polyhedron::HalfedgeDS>;
+
 public:
   using CGALPoint = typename CGAL_Polybuilder::Point_3;
 
-  const manifold::MeshGL64& meshgl;
-  CGALPolyhedronBuilderFromManifold(const manifold::MeshGL64& mesh) : meshgl(mesh) { }
+  const manifold::MeshGL64 &meshgl;
+  CGALPolyhedronBuilderFromManifold (const manifold::MeshGL64 &mesh)
+    : meshgl (mesh) {}
 
-  void operator()(HDS& hds) override {
-    CGAL_Polybuilder B(hds, true);
+  void operator() (HDS &hds) override {
+    CGAL_Polybuilder B (hds, true);
 
-    B.begin_surface(meshgl.NumVert(), meshgl.NumTri());
-    for (size_t vertid = 0; vertid < meshgl.NumVert(); vertid++)
-      B.add_vertex(CGALUtils::vector_convert<CGALPoint>(meshgl.GetVertPos(vertid)));
+    B.begin_surface (meshgl.NumVert (), meshgl.NumTri ());
+    for (size_t vertid = 0; vertid < meshgl.NumVert (); vertid++)
+      B.add_vertex (CGALUtils::vector_convert<CGALPoint> (meshgl.GetVertPos (vertid)));
 
-    for (size_t faceid = 0; faceid < meshgl.NumTri(); faceid++) {
-      const auto tv = meshgl.GetTriVerts(faceid);
-      B.begin_facet();
+    for (size_t faceid = 0; faceid < meshgl.NumTri (); faceid++) {
+      const auto tv = meshgl.GetTriVerts (faceid);
+      B.begin_facet ();
       for (const int j : {0, 1, 2}) {
-        B.add_vertex_to_facet(tv[j]);
+        B.add_vertex_to_facet (tv[j]);
       }
-      B.end_facet();
+      B.end_facet ();
     }
-    B.end_surface();
+    B.end_surface ();
   }
 };
 
 template <class Polyhedron>
-std::shared_ptr<Polyhedron> ManifoldGeometry::toPolyhedron() const
-{
-  auto p = std::make_shared<Polyhedron>();
+std::shared_ptr<Polyhedron> ManifoldGeometry::toPolyhedron () const {
+  auto p = std::make_shared<Polyhedron> ();
   try {
-    auto meshgl = getManifold().GetMeshGL64();
-    CGALPolyhedronBuilderFromManifold<Polyhedron> builder(meshgl);
-    p->delegate(builder);
-  } catch (const CGAL::Assertion_exception& e) {
-    LOG(message_group::Error, "CGAL error in ManifoldGeometry::toPolyhedron(): %1$s", e.what());
+    auto meshgl = getManifold ().GetMeshGL64 ();
+    CGALPolyhedronBuilderFromManifold<Polyhedron> builder (meshgl);
+    p->delegate (builder);
+  } catch (const CGAL::Assertion_exception &e) {
+    LOG (message_group::Error, "CGAL error in ManifoldGeometry::toPolyhedron(): %1$s", e.what ());
   }
   return p;
 }
 
-template std::shared_ptr<CGAL::Polyhedron_3<CGAL_Kernel3>> ManifoldGeometry::toPolyhedron() const;
+template std::shared_ptr<CGAL::Polyhedron_3<CGAL_Kernel3>> ManifoldGeometry::toPolyhedron () const;
 
 #endif // ifdef ENABLE_CGAL
 
-ManifoldGeometry ManifoldGeometry::binOp(const ManifoldGeometry& lhs, const ManifoldGeometry& rhs, manifold::OpType opType) const {
-  auto mani = lhs.manifold_.Boolean(rhs.manifold_, opType);
+ManifoldGeometry ManifoldGeometry::binOp (const ManifoldGeometry &lhs, const ManifoldGeometry &rhs, manifold::OpType opType) const {
+  auto mani = lhs.manifold_.Boolean (rhs.manifold_, opType);
   auto originalIDToColor = lhs.originalIDToColor_;
   auto subtractedIDs = lhs.subtractedIDs_;
 
   auto originalIDs = lhs.originalIDs_;
-  originalIDs.insert(rhs.originalIDs_.begin(), rhs.originalIDs_.end());
+  originalIDs.insert (rhs.originalIDs_.begin (), rhs.originalIDs_.end ());
 
   if (opType == manifold::OpType::Subtract) {
     // Mark all the original ids coming from rhs as subtracted, unless they're mapped to a color.
     for (const auto id : rhs.originalIDs_) {
-      auto it = rhs.originalIDToColor_.find(id);
-      if (it != rhs.originalIDToColor_.end()) {
+      auto it = rhs.originalIDToColor_.find (id);
+      if (it != rhs.originalIDToColor_.end ()) {
         originalIDToColor[id] = it->second;
       } else {
-        subtractedIDs.insert(id);
+        subtractedIDs.insert (id);
       }
     }
   } else {
     // Add the id -> color mapping from the rhs.
-    originalIDToColor.insert(rhs.originalIDToColor_.begin(), rhs.originalIDToColor_.end());
-    subtractedIDs.insert(rhs.subtractedIDs_.begin(), rhs.subtractedIDs_.end());
+    originalIDToColor.insert (rhs.originalIDToColor_.begin (), rhs.originalIDToColor_.end ());
+    subtractedIDs.insert (rhs.subtractedIDs_.begin (), rhs.subtractedIDs_.end ());
   }
   return {mani, originalIDs, originalIDToColor, subtractedIDs};
 }
 
-std::shared_ptr<ManifoldGeometry> minkowskiOp(const ManifoldGeometry& lhs, const ManifoldGeometry& rhs) {
+std::shared_ptr<ManifoldGeometry> minkowskiOp (const ManifoldGeometry &lhs, const ManifoldGeometry &rhs) {
 // FIXME: How to deal with operation not supported?
 #ifdef ENABLE_CGAL
-  auto lhs_nef = std::shared_ptr<CGALNefGeometry>(CGALUtils::createNefPolyhedronFromPolySet(*lhs.toPolySet()));
-  auto rhs_nef = std::shared_ptr<CGALNefGeometry>(CGALUtils::createNefPolyhedronFromPolySet(*rhs.toPolySet()));
-  if (lhs_nef->isEmpty() || rhs_nef->isEmpty()) {
+  auto lhs_nef = std::shared_ptr<CGALNefGeometry> (CGALUtils::createNefPolyhedronFromPolySet (*lhs.toPolySet ()));
+  auto rhs_nef = std::shared_ptr<CGALNefGeometry> (CGALUtils::createNefPolyhedronFromPolySet (*rhs.toPolySet ()));
+  if (lhs_nef->isEmpty () || rhs_nef->isEmpty ()) {
     return {};
   }
   std::shared_ptr<const PolySet> ps;
   try {
-    lhs_nef->minkowski(*rhs_nef);
-    ps = PolySetUtils::getGeometryAsPolySet(lhs_nef);
+    lhs_nef->minkowski (*rhs_nef);
+    ps = PolySetUtils::getGeometryAsPolySet (lhs_nef);
     if (ps) {
-      return ManifoldUtils::createManifoldFromPolySet(*ps);
+      return ManifoldUtils::createManifoldFromPolySet (*ps);
     }
-  } catch (const std::exception& e) {
-    LOG(message_group::Error,
-        "Nef minkoswki operation failed: %1$s\n", e.what());
+  } catch (const std::exception &e) {
+    LOG (message_group::Error,
+         "Nef minkoswki operation failed: %1$s\n", e.what ());
   } catch (...) {
-    LOG(message_group::Warning,
-        "Nef minkowski hard-crashed");
+    LOG (message_group::Warning,
+         "Nef minkowski hard-crashed");
   }
 #endif // ifdef ENABLE_CGAL
   return {};
 }
 
-ManifoldGeometry ManifoldGeometry::operator+(const ManifoldGeometry& other) const {
-  return binOp(*this, other, manifold::OpType::Add);
+ManifoldGeometry ManifoldGeometry::operator+ (const ManifoldGeometry &other) const {
+  return binOp (*this, other, manifold::OpType::Add);
 }
 
-ManifoldGeometry ManifoldGeometry::operator*(const ManifoldGeometry& other) const {
-  return binOp(*this, other, manifold::OpType::Intersect);
+ManifoldGeometry ManifoldGeometry::operator* (const ManifoldGeometry &other) const {
+  return binOp (*this, other, manifold::OpType::Intersect);
 }
 
-ManifoldGeometry ManifoldGeometry::operator-(const ManifoldGeometry& other) const {
-  return binOp(*this, other, manifold::OpType::Subtract);
+ManifoldGeometry ManifoldGeometry::operator- (const ManifoldGeometry &other) const {
+  return binOp (*this, other, manifold::OpType::Subtract);
 }
 
-ManifoldGeometry ManifoldGeometry::minkowski(const ManifoldGeometry& other) const {
-  std::shared_ptr<ManifoldGeometry> geom = minkowskiOp(*this, other);
-  if (geom) return *geom;
-  else return {};
+ManifoldGeometry ManifoldGeometry::minkowski (const ManifoldGeometry &other) const {
+  std::shared_ptr<ManifoldGeometry> geom = minkowskiOp (*this, other);
+  if (geom)
+    return *geom;
+  else
+    return {};
 }
 
-Polygon2d ManifoldGeometry::slice() const {
-  auto cross_section = manifold::CrossSection(manifold_.Slice());
-  return ManifoldUtils::polygonsToPolygon2d(cross_section.ToPolygons());
+Polygon2d ManifoldGeometry::slice () const {
+  auto cross_section = manifold::CrossSection (manifold_.Slice ());
+  return ManifoldUtils::polygonsToPolygon2d (cross_section.ToPolygons ());
 }
 
-Polygon2d ManifoldGeometry::project() const {
-  auto cross_section = manifold::CrossSection(manifold_.Project());
-  return ManifoldUtils::polygonsToPolygon2d(cross_section.ToPolygons());
+Polygon2d ManifoldGeometry::project () const {
+  auto cross_section = manifold::CrossSection (manifold_.Project ());
+  return ManifoldUtils::polygonsToPolygon2d (cross_section.ToPolygons ());
 }
 
-void ManifoldGeometry::transform(const Transform3d& mat) {
-  manifold::mat3x4 glMat(
+void ManifoldGeometry::transform (const Transform3d &mat) {
+  manifold::mat3x4 glMat (
     // Column-major ordering
-    {mat(0, 0), mat(1, 0), mat(2, 0)},
-    {mat(0, 1), mat(1, 1), mat(2, 1)},
-    {mat(0, 2), mat(1, 2), mat(2, 2)},
-    {mat(0, 3), mat(1, 3), mat(2, 3)}
-    );
-  manifold_ = getManifold().Transform(glMat);
+    {mat (0, 0), mat (1, 0), mat (2, 0)},
+    {mat (0, 1), mat (1, 1), mat (2, 1)},
+    {mat (0, 2), mat (1, 2), mat (2, 2)},
+    {mat (0, 3), mat (1, 3), mat (2, 3)});
+  manifold_ = getManifold ().Transform (glMat);
 }
 
-void ManifoldGeometry::setColor(const Color4f& c) {
-  if (manifold_.OriginalID() == -1) {
-    manifold_ = manifold_.AsOriginal();
+void ManifoldGeometry::setColor (const Color4f &c) {
+  if (manifold_.OriginalID () == -1) {
+    manifold_ = manifold_.AsOriginal ();
   }
-  originalIDs_.clear();
-  originalIDs_.insert(manifold_.OriginalID());
-  originalIDToColor_.clear();
-  originalIDToColor_[manifold_.OriginalID()] = c;
-  subtractedIDs_.clear();
+  originalIDs_.clear ();
+  originalIDs_.insert (manifold_.OriginalID ());
+  originalIDToColor_.clear ();
+  originalIDToColor_[manifold_.OriginalID ()] = c;
+  subtractedIDs_.clear ();
 }
 
-void ManifoldGeometry::toOriginal() {
-  if (manifold_.OriginalID() == -1) {
-    manifold_ = manifold_.AsOriginal();
+void ManifoldGeometry::toOriginal () {
+  if (manifold_.OriginalID () == -1) {
+    manifold_ = manifold_.AsOriginal ();
   }
-  originalIDs_.clear();
-  originalIDs_.insert(manifold_.OriginalID());
-  originalIDToColor_.clear();
-  subtractedIDs_.clear();
+  originalIDs_.clear ();
+  originalIDs_.insert (manifold_.OriginalID ());
+  originalIDToColor_.clear ();
+  subtractedIDs_.clear ();
 }
 
-BoundingBox ManifoldGeometry::getBoundingBox() const
-{
+BoundingBox ManifoldGeometry::getBoundingBox () const {
   BoundingBox result;
-  manifold::Box bbox = getManifold().BoundingBox();
-  result.extend(vector_convert<Eigen::Vector3d>(bbox.min));
-  result.extend(vector_convert<Eigen::Vector3d>(bbox.max));
+  manifold::Box bbox = getManifold ().BoundingBox ();
+  result.extend (vector_convert<Eigen::Vector3d> (bbox.min));
+  result.extend (vector_convert<Eigen::Vector3d> (bbox.max));
   return result;
 }
 
-void ManifoldGeometry::resize(const Vector3d& newsize, const Eigen::Matrix<bool, 3, 1>& autosize) {
-  transform(GeometryUtils::getResizeTransform(this->getBoundingBox(), newsize, autosize));
+void ManifoldGeometry::resize (const Vector3d &newsize, const Eigen::Matrix<bool, 3, 1> &autosize) {
+  transform (GeometryUtils::getResizeTransform (this->getBoundingBox (), newsize, autosize));
 }
 
 /*! Iterate over all vertices' points until the function returns true (for done). */
-void ManifoldGeometry::foreachVertexUntilTrue(const std::function<bool(const manifold::vec3& pt)>& f) const {
-  auto mesh = getManifold().GetMeshGL64();
-  const auto numVert = mesh.NumVert();
+void ManifoldGeometry::foreachVertexUntilTrue (const std::function<bool (const manifold::vec3 &pt)> &f) const {
+  auto mesh = getManifold ().GetMeshGL64 ();
+  const auto numVert = mesh.NumVert ();
   for (size_t v = 0; v < numVert; ++v) {
-    if (f(mesh.GetVertPos(v))) {
+    if (f (mesh.GetVertPos (v))) {
       return;
     }
   }
diff --git a/src/geometry/manifold/ManifoldGeometry.h b/src/geometry/manifold/ManifoldGeometry.h
index 1bcce76e3..bf99cb78d 100644
--- a/src/geometry/manifold/ManifoldGeometry.h
+++ b/src/geometry/manifold/ManifoldGeometry.h
@@ -21,59 +21,61 @@ class Manifold;
 class ManifoldGeometry : public Geometry
 {
 public:
-  VISITABLE_GEOMETRY();
+  VISITABLE_GEOMETRY ();
 
-  ManifoldGeometry();
-  ManifoldGeometry(
+  ManifoldGeometry ();
+  ManifoldGeometry (
     manifold::Manifold object,
-    const std::set<uint32_t>& originalIDs = {},
-    const std::map<uint32_t, Color4f>& originalIDToColor = {},
-    const std::set<uint32_t>& subtractedIDs = {});
-  ManifoldGeometry(const ManifoldGeometry& other) = default;
+    const std::set<uint32_t> &originalIDs = {},
+    const std::map<uint32_t, Color4f> &originalIDToColor = {},
+    const std::set<uint32_t> &subtractedIDs = {});
+  ManifoldGeometry (const ManifoldGeometry &other) = default;
 
-  [[nodiscard]] bool isEmpty() const override;
-  [[nodiscard]] size_t numFacets() const override;
-  [[nodiscard]] size_t numVertices() const;
-  [[nodiscard]] bool isManifold() const;
-  [[nodiscard]] bool isValid() const;
-  void clear();
+  [[nodiscard]] bool isEmpty () const override;
+  [[nodiscard]] size_t numFacets () const override;
+  [[nodiscard]] size_t numVertices () const;
+  [[nodiscard]] bool isManifold () const;
+  [[nodiscard]] bool isValid () const;
+  void clear ();
 
-  [[nodiscard]] size_t memsize() const override;
-  [[nodiscard]] BoundingBox getBoundingBox() const override;
+  [[nodiscard]] size_t memsize () const override;
+  [[nodiscard]] BoundingBox getBoundingBox () const override;
 
-  [[nodiscard]] std::string dump() const override;
-  [[nodiscard]] unsigned int getDimension() const override { return 3; }
-  [[nodiscard]] std::unique_ptr<Geometry> copy() const override;
+  [[nodiscard]] std::string dump () const override;
+  [[nodiscard]] unsigned int getDimension () const override {
+    return 3;
+  }
+  [[nodiscard]] std::unique_ptr<Geometry> copy () const override;
 
-  [[nodiscard]] std::shared_ptr<PolySet> toPolySet() const;
+  [[nodiscard]] std::shared_ptr<PolySet> toPolySet () const;
 
   template <class Polyhedron>
-  [[nodiscard]] std::shared_ptr<Polyhedron> toPolyhedron() const;
+  [[nodiscard]] std::shared_ptr<Polyhedron> toPolyhedron () const;
 
   /*! union. */
-  ManifoldGeometry operator+(const ManifoldGeometry& other) const;
+  ManifoldGeometry operator+ (const ManifoldGeometry &other) const;
   /*! intersection. */
-  ManifoldGeometry operator*(const ManifoldGeometry& other) const;
+  ManifoldGeometry operator* (const ManifoldGeometry &other) const;
   /*! difference. */
-  ManifoldGeometry operator-(const ManifoldGeometry& other) const;
+  ManifoldGeometry operator- (const ManifoldGeometry &other) const;
   /*! minkowksi operation. */
-  ManifoldGeometry minkowski(const ManifoldGeometry& other) const;
+  ManifoldGeometry minkowski (const ManifoldGeometry &other) const;
 
-  Polygon2d slice() const;
-  Polygon2d project() const;
+  Polygon2d slice () const;
+  Polygon2d project () const;
 
-  void transform(const Transform3d& mat) override;
-  void setColor(const Color4f& c) override;
-  void toOriginal();
-  void resize(const Vector3d& newsize, const Eigen::Matrix<bool, 3, 1>& autosize) override;
+  void transform (const Transform3d &mat) override;
+  void setColor (const Color4f &c) override;
+  void toOriginal ();
+  void resize (const Vector3d &newsize, const Eigen::Matrix<bool, 3, 1> &autosize) override;
 
   /*! Iterate over all vertices' points until the function returns true (for done). */
-  void foreachVertexUntilTrue(const std::function<bool(const manifold::vec3& pt)>& f) const;
+  void foreachVertexUntilTrue (const std::function<bool (const manifold::vec3 &pt)> &f) const;
 
-  const manifold::Manifold& getManifold() const;
+  const manifold::Manifold &getManifold () const;
 
 private:
-  ManifoldGeometry binOp(const ManifoldGeometry& lhs, const ManifoldGeometry& rhs, manifold::OpType opType) const;
+  ManifoldGeometry binOp (const ManifoldGeometry &lhs, const ManifoldGeometry &rhs, manifold::OpType opType) const;
 
   manifold::Manifold manifold_;
   std::set<uint32_t> originalIDs_;
diff --git a/src/geometry/manifold/Polygon2d-manifold.cc b/src/geometry/manifold/Polygon2d-manifold.cc
index a992c4691..cac5ff5af 100644
--- a/src/geometry/manifold/Polygon2d-manifold.cc
+++ b/src/geometry/manifold/Polygon2d-manifold.cc
@@ -7,9 +7,8 @@
 /*!
    Triangulates this polygon2d and returns a 2D-in-3D PolySet.
  */
-std::unique_ptr<PolySet> Polygon2d::tessellate() const
-{
-  PRINTDB("Polygon2d::tessellate(): %d outlines", this->outlines().size());
-  return std::make_unique<PolySet>(*this);
+std::unique_ptr<PolySet> Polygon2d::tessellate () const {
+  PRINTDB ("Polygon2d::tessellate(): %d outlines", this->outlines ().size ());
+  return std::make_unique<PolySet> (*this);
 }
 #endif
diff --git a/src/geometry/manifold/manifold-applyops-minkowski.cc b/src/geometry/manifold/manifold-applyops-minkowski.cc
index 6d7ae9e2c..8ecce8c1d 100644
--- a/src/geometry/manifold/manifold-applyops-minkowski.cc
+++ b/src/geometry/manifold/manifold-applyops-minkowski.cc
@@ -26,221 +26,226 @@ namespace ManifoldUtils {
 /*!
    children cannot contain nullptr objects
  */
-std::shared_ptr<const Geometry> applyMinkowski(const Geometry::Geometries& children)
-{
-  assert(children.size() >= 2);
+std::shared_ptr<const Geometry> applyMinkowski (const Geometry::Geometries &children) {
+  assert (children.size () >= 2);
 
   using Hull_kernel = CGAL::Epick;
   using Hull_Mesh = CGAL::Surface_mesh<CGAL::Point_3<Hull_kernel>>;
   using Hull_Points = std::vector<CGAL::Point_3<Hull_kernel>>;
 
-  auto surfaceMeshFromGeometry = [](const std::shared_ptr<const Geometry>& geom, bool *pIsConvexOut) -> std::shared_ptr<CGAL_Kernel3Mesh>
-    {
-      auto ps = std::dynamic_pointer_cast<const PolySet>(geom);
-      if (ps) {
-        auto mesh = CGALUtils::createSurfaceMeshFromPolySet<CGAL_Kernel3Mesh>(*ps);
-        if (pIsConvexOut) *pIsConvexOut = ps->isConvex();
+  auto surfaceMeshFromGeometry = [] (const std::shared_ptr<const Geometry> &geom, bool *pIsConvexOut) -> std::shared_ptr<CGAL_Kernel3Mesh> {
+    auto ps = std::dynamic_pointer_cast<const PolySet> (geom);
+    if (ps) {
+      auto mesh = CGALUtils::createSurfaceMeshFromPolySet<CGAL_Kernel3Mesh> (*ps);
+      if (pIsConvexOut)
+        *pIsConvexOut = ps->isConvex ();
+      return mesh;
+    } else {
+      if (auto mani = std::dynamic_pointer_cast<const ManifoldGeometry> (geom)) {
+        auto mesh = ManifoldUtils::createSurfaceMeshFromManifold<CGAL_Kernel3Mesh> (mani->getManifold ());
+        if (pIsConvexOut)
+          *pIsConvexOut = CGALUtils::is_weakly_convex (*mesh);
         return mesh;
-      } else {
-        if (auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
-          auto mesh = ManifoldUtils::createSurfaceMeshFromManifold<CGAL_Kernel3Mesh>(mani->getManifold());
-          if (pIsConvexOut) *pIsConvexOut = CGALUtils::is_weakly_convex(*mesh);
-          return mesh;
-        } else throw 0;
-      }
-      throw 0;
-    };
+      } else
+        throw 0;
+    }
+    throw 0;
+  };
 
   CGAL::Cartesian_converter<CGAL_Kernel3, Hull_kernel> conv;
-  auto getHullPoints = [&](const CGAL_Polyhedron& poly) {
-      std::vector<Hull_kernel::Point_3> out;
-      out.reserve(poly.size_of_vertices());
-      for (auto pi = poly.vertices_begin(); pi != poly.vertices_end(); ++pi) {
-        out.push_back(conv(pi->point()));
-      }
-      return out;
-    };
-  auto getHullPointsFromMesh = [&](const CGAL_Kernel3Mesh& mesh) {
-      std::vector<Hull_kernel::Point_3> out;
-      out.reserve(mesh.number_of_vertices());
-      for (auto idx : mesh.vertices()) {
-        out.push_back(conv(mesh.point(idx)));
-      }
-      return out;
-    };
+  auto getHullPoints = [&] (const CGAL_Polyhedron &poly) {
+    std::vector<Hull_kernel::Point_3> out;
+    out.reserve (poly.size_of_vertices ());
+    for (auto pi = poly.vertices_begin (); pi != poly.vertices_end (); ++pi) {
+      out.push_back (conv (pi->point ()));
+    }
+    return out;
+  };
+  auto getHullPointsFromMesh = [&] (const CGAL_Kernel3Mesh &mesh) {
+    std::vector<Hull_kernel::Point_3> out;
+    out.reserve (mesh.number_of_vertices ());
+    for (auto idx : mesh.vertices ()) {
+      out.push_back (conv (mesh.point (idx)));
+    }
+    return out;
+  };
 
   CGAL::Timer t_tot;
-  t_tot.start();
+  t_tot.start ();
 
-  auto it = children.begin();
-  std::vector<std::shared_ptr<const Geometry>> operands = {it->second, std::shared_ptr<const Geometry>()};
+  auto it = children.begin ();
+  std::vector<std::shared_ptr<const Geometry>> operands = {it->second, std::shared_ptr<const Geometry> ()};
 
   try {
     // Note: we could parallelize more, e.g. compute all decompositions ahead of time instead of doing them 2 by 2,
     // but this could use substantially more memory.
-    while (++it != children.end()) {
+    while (++it != children.end ()) {
       operands[1] = it->second;
 
-      std::vector<std::list<Hull_Points>> part_points(2);
-
-      parallelizable_transform(operands.begin(), operands.begin() + 2, part_points.begin(),
-                               [&](std::shared_ptr<const Geometry>& operand) {
-          std::list<Hull_Points> part_points;
-
-          bool is_convex;
-          auto mesh = surfaceMeshFromGeometry(operand, &is_convex);
-          if (!mesh) throw 0;
-          if (mesh->is_empty()) {
-            throw 0;
-          }
-
-          if (is_convex) {
-            part_points.emplace_back(getHullPointsFromMesh(*mesh));
-          } else {
-            // The CGAL_Nef_polyhedron3 constructor can crash on bad polyhedron, so don't try
-            if (!mesh->is_valid()) throw 0;
-            CGAL_Nef_polyhedron3 decomposed_nef;
-            CGALUtils::convertSurfaceMeshToNef(*mesh, decomposed_nef);
-            CGAL::Timer t;
-            t.start();
-            CGAL::convex_decomposition_3(decomposed_nef);
-
-            // the first volume is the outer volume, which ignored in the decomposition
-            CGAL_Nef_polyhedron3::Volume_const_iterator ci = ++decomposed_nef.volumes_begin();
-            for (; ci != decomposed_nef.volumes_end(); ++ci) {
-              if (ci->mark()) {
-                CGAL_Polyhedron poly;
-                decomposed_nef.convert_inner_shell_to_polyhedron(ci->shells_begin(), poly);
-                part_points.emplace_back(getHullPoints(poly));
-              }
-            }
-
-            PRINTDB("Minkowski: decomposed into %d convex parts", part_points.size());
-            t.stop();
-            PRINTDB("Minkowski: decomposition took %f s", t.time());
-          }
-          return part_points;
-        });
+      std::vector<std::list<Hull_Points>> part_points (2);
+
+      parallelizable_transform (operands.begin (), operands.begin () + 2, part_points.begin (),
+                                [&] (std::shared_ptr<const Geometry> &operand) {
+                                  std::list<Hull_Points> part_points;
+
+                                  bool is_convex;
+                                  auto mesh = surfaceMeshFromGeometry (operand, &is_convex);
+                                  if (!mesh)
+                                    throw 0;
+                                  if (mesh->is_empty ()) {
+                                    throw 0;
+                                  }
+
+                                  if (is_convex) {
+                                    part_points.emplace_back (getHullPointsFromMesh (*mesh));
+                                  } else {
+                                    // The CGAL_Nef_polyhedron3 constructor can crash on bad polyhedron, so don't try
+                                    if (!mesh->is_valid ())
+                                      throw 0;
+                                    CGAL_Nef_polyhedron3 decomposed_nef;
+                                    CGALUtils::convertSurfaceMeshToNef (*mesh, decomposed_nef);
+                                    CGAL::Timer t;
+                                    t.start ();
+                                    CGAL::convex_decomposition_3 (decomposed_nef);
+
+                                    // the first volume is the outer volume, which ignored in the decomposition
+                                    CGAL_Nef_polyhedron3::Volume_const_iterator ci = ++decomposed_nef.volumes_begin ();
+                                    for (; ci != decomposed_nef.volumes_end (); ++ci) {
+                                      if (ci->mark ()) {
+                                        CGAL_Polyhedron poly;
+                                        decomposed_nef.convert_inner_shell_to_polyhedron (ci->shells_begin (), poly);
+                                        part_points.emplace_back (getHullPoints (poly));
+                                      }
+                                    }
+
+                                    PRINTDB ("Minkowski: decomposed into %d convex parts", part_points.size ());
+                                    t.stop ();
+                                    PRINTDB ("Minkowski: decomposition took %f s", t.time ());
+                                  }
+                                  return part_points;
+                                });
 
       std::vector<Hull_kernel::Point_3> minkowski_points;
 
-      auto combineParts = [&](const Hull_Points& points0, const Hull_Points& points1) -> std::shared_ptr<const ManifoldGeometry> {
-          CGAL::Timer t;
+      auto combineParts = [&] (const Hull_Points &points0, const Hull_Points &points1) -> std::shared_ptr<const ManifoldGeometry> {
+        CGAL::Timer t;
 
-          t.start();
-          std::vector<Hull_kernel::Point_3> minkowski_points;
-
-          minkowski_points.reserve(points0.size() * points1.size());
-          for (const auto& p0 : points0) {
-            for (const auto p1 : points1) {
-              minkowski_points.push_back(p0 + (p1 - CGAL::ORIGIN));
-            }
-          }
+        t.start ();
+        std::vector<Hull_kernel::Point_3> minkowski_points;
 
-          if (minkowski_points.size() <= 3) {
-            t.stop();
-            return std::make_shared<ManifoldGeometry>();
+        minkowski_points.reserve (points0.size () * points1.size ());
+        for (const auto &p0 : points0) {
+          for (const auto p1 : points1) {
+            minkowski_points.push_back (p0 + (p1 - CGAL::ORIGIN));
           }
+        }
 
-          t.stop();
-          PRINTDB("Minkowski: Point cloud creation (%d  %d -> %d) took %f ms", points0.size() % points1.size() % minkowski_points.size() % (t.time() * 1000));
-          t.reset();
+        if (minkowski_points.size () <= 3) {
+          t.stop ();
+          return std::make_shared<ManifoldGeometry> ();
+        }
 
-          t.start();
+        t.stop ();
+        PRINTDB ("Minkowski: Point cloud creation (%d  %d -> %d) took %f ms", points0.size () % points1.size () % minkowski_points.size () % (t.time () * 1000));
+        t.reset ();
 
-          Hull_Mesh mesh;
-          CGAL::convex_hull_3(minkowski_points.begin(), minkowski_points.end(), mesh);
+        t.start ();
 
-          std::vector<Hull_kernel::Point_3> strict_points;
-          strict_points.reserve(minkowski_points.size());
+        Hull_Mesh mesh;
+        CGAL::convex_hull_3 (minkowski_points.begin (), minkowski_points.end (), mesh);
 
-          for (auto v : mesh.vertices()) {
-            auto& p = mesh.point(v);
+        std::vector<Hull_kernel::Point_3> strict_points;
+        strict_points.reserve (minkowski_points.size ());
 
-            auto h = mesh.halfedge(v);
-            auto e = h;
-            bool collinear = false;
-            bool coplanar = true;
+        for (auto v : mesh.vertices ()) {
+          auto &p = mesh.point (v);
 
-            do {
-              auto& q = mesh.point(mesh.target(mesh.opposite(h)));
-              if (coplanar && !CGAL::coplanar(p, q,
-                                              mesh.point(mesh.target(mesh.next(h))),
-                                              mesh.point(mesh.target(mesh.next(mesh.opposite(mesh.next(h))))))) {
-                coplanar = false;
-              }
+          auto h = mesh.halfedge (v);
+          auto e = h;
+          bool collinear = false;
+          bool coplanar = true;
 
+          do {
+            auto &q = mesh.point (mesh.target (mesh.opposite (h)));
+            if (coplanar && !CGAL::coplanar (p, q,
+                                             mesh.point (mesh.target (mesh.next (h))),
+                                             mesh.point (mesh.target (mesh.next (mesh.opposite (mesh.next (h))))))) {
+              coplanar = false;
+            }
 
-              for (auto j = mesh.opposite(mesh.next(h));
-                   j != h && !collinear && !coplanar;
-                   j = mesh.opposite(mesh.next(j))) {
+            for (auto j = mesh.opposite (mesh.next (h));
+                 j != h && !collinear && !coplanar;
+                 j = mesh.opposite (mesh.next (j))) {
 
-                auto& r = mesh.point(mesh.target(mesh.opposite(j)));
-                if (CGAL::collinear(p, q, r)) {
-                  collinear = true;
-                }
+              auto &r = mesh.point (mesh.target (mesh.opposite (j)));
+              if (CGAL::collinear (p, q, r)) {
+                collinear = true;
               }
+            }
 
-              h = mesh.opposite(mesh.next(h));
-            } while (h != e && !collinear);
+            h = mesh.opposite (mesh.next (h));
+          } while (h != e && !collinear);
 
-            if (!collinear && !coplanar) strict_points.push_back(p);
-          }
+          if (!collinear && !coplanar)
+            strict_points.push_back (p);
+        }
 
-          mesh.clear();
-          CGAL::convex_hull_3(strict_points.begin(), strict_points.end(), mesh);
+        mesh.clear ();
+        CGAL::convex_hull_3 (strict_points.begin (), strict_points.end (), mesh);
 
-          t.stop();
-          PRINTDB("Minkowski: Computing convex hull took %f s", t.time());
-          t.reset();
+        t.stop ();
+        PRINTDB ("Minkowski: Computing convex hull took %f s", t.time ());
+        t.reset ();
 
-          CGALUtils::triangulateFaces(mesh);
-          return ManifoldUtils::createManifoldFromSurfaceMesh(mesh);
-        };
+        CGALUtils::triangulateFaces (mesh);
+        return ManifoldUtils::createManifoldFromSurfaceMesh (mesh);
+      };
 
-      std::vector<std::shared_ptr<const ManifoldGeometry>> result_parts(part_points[0].size() * part_points[1].size());
-      parallelizable_cross_product_transform(
+      std::vector<std::shared_ptr<const ManifoldGeometry>> result_parts (part_points[0].size () * part_points[1].size ());
+      parallelizable_cross_product_transform (
         part_points[0], part_points[1],
-        result_parts.begin(),
+        result_parts.begin (),
         combineParts);
 
-      if (it != std::next(children.begin())) operands[0].reset();
+      if (it != std::next (children.begin ()))
+        operands[0].reset ();
 
       CGAL::Timer t;
-      t.start();
-      PRINTDB("Minkowski: Computing union of %d parts", result_parts.size());
+      t.start ();
+      PRINTDB ("Minkowski: Computing union of %d parts", result_parts.size ());
       Geometry::Geometries fake_children;
-      for (const auto& part : result_parts) {
-        fake_children.push_back(std::make_pair(std::shared_ptr<const AbstractNode>(),
-                                               part));
+      for (const auto &part : result_parts) {
+        fake_children.push_back (std::make_pair (std::shared_ptr<const AbstractNode> (),
+                                                 part));
       }
-      auto N = ManifoldUtils::applyOperator3DManifold(fake_children, OpenSCADOperator::UNION);
+      auto N = ManifoldUtils::applyOperator3DManifold (fake_children, OpenSCADOperator::UNION);
 
       // FIXME: This should really never throw.
       // Assert once we figured out what went wrong with issue #1069?
-      if (!N) throw 0;
-      t.stop();
-      PRINTDB("Minkowski: Union done: %f s", t.time());
-      t.reset();
+      if (!N)
+        throw 0;
+      t.stop ();
+      PRINTDB ("Minkowski: Union done: %f s", t.time ());
+      t.reset ();
 
-      N->toOriginal();
+      N->toOriginal ();
       operands[0] = N;
     }
 
-    t_tot.stop();
-    PRINTDB("Minkowski: Total execution time %f s", t_tot.time());
-    t_tot.reset();
+    t_tot.stop ();
+    PRINTDB ("Minkowski: Total execution time %f s", t_tot.time ());
+    t_tot.reset ();
     return operands[0];
-  } catch (const std::exception& e) {
-    LOG(message_group::Warning,
-        "[manifold] Minkowski failed with error, falling back to Nef operation: %1$s\n", e.what());
+  } catch (const std::exception &e) {
+    LOG (message_group::Warning,
+         "[manifold] Minkowski failed with error, falling back to Nef operation: %1$s\n", e.what ());
   } catch (...) {
-    LOG(message_group::Warning,
-        "[manifold] Minkowski hard-crashed, falling back to Nef operation.");
+    LOG (message_group::Warning,
+         "[manifold] Minkowski hard-crashed, falling back to Nef operation.");
   }
-  return ManifoldUtils::applyOperator3DManifold(children, OpenSCADOperator::MINKOWSKI);
+  return ManifoldUtils::applyOperator3DManifold (children, OpenSCADOperator::MINKOWSKI);
 }
 
-}  // namespace ManifoldUtils
+} // namespace ManifoldUtils
 
 #endif // ENABLE_MANIFOLD
diff --git a/src/geometry/manifold/manifold-applyops.cc b/src/geometry/manifold/manifold-applyops.cc
index ee67c4f34..1673f3d7b 100644
--- a/src/geometry/manifold/manifold-applyops.cc
+++ b/src/geometry/manifold/manifold-applyops.cc
@@ -14,26 +14,24 @@
 
 namespace ManifoldUtils {
 
-Location getLocation(const std::shared_ptr<const AbstractNode>& node)
-{
-  return node && node->modinst ? node->modinst->location() : Location::NONE;
+Location getLocation (const std::shared_ptr<const AbstractNode> &node) {
+  return node && node->modinst ? node->modinst->location () : Location::NONE;
 }
 
 /*!
    Applies op to all children and returns the result.
    The child list should be guaranteed to contain non-NULL 3D or empty Geometry objects
  */
-std::shared_ptr<ManifoldGeometry> applyOperator3DManifold(const Geometry::Geometries& children, OpenSCADOperator op)
-{
+std::shared_ptr<ManifoldGeometry> applyOperator3DManifold (const Geometry::Geometries &children, OpenSCADOperator op) {
   std::shared_ptr<ManifoldGeometry> geom;
 
   bool foundFirst = false;
 
-  for (const auto& item : children) {
-    auto chN = item.second ? createManifoldFromGeometry(item.second) : nullptr;
+  for (const auto &item : children) {
+    auto chN = item.second ? createManifoldFromGeometry (item.second) : nullptr;
 
     // Intersecting something with nothing results in nothing
-    if (!chN || chN->isEmpty()) {
+    if (!chN || chN->isEmpty ()) {
       if (op == OpenSCADOperator::INTERSECTION) {
         geom = nullptr;
         break;
@@ -47,7 +45,7 @@ std::shared_ptr<ManifoldGeometry> applyOperator3DManifold(const Geometry::Geomet
 
     // Initialize geom with first expected geometric object
     if (!foundFirst) {
-      geom = std::make_shared<ManifoldGeometry>(*chN);
+      geom = std::make_shared<ManifoldGeometry> (*chN);
       foundFirst = true;
       continue;
     }
@@ -63,16 +61,17 @@ std::shared_ptr<ManifoldGeometry> applyOperator3DManifold(const Geometry::Geomet
       *geom = *geom - *chN;
       break;
     case OpenSCADOperator::MINKOWSKI:
-      *geom = geom->minkowski(*chN);
+      *geom = geom->minkowski (*chN);
       break;
     default:
-      LOG(message_group::Error, "Unsupported CGAL operator: %1$d", static_cast<int>(op));
+      LOG (message_group::Error, "Unsupported CGAL operator: %1$d", static_cast<int> (op));
     }
-    if (item.first) item.first->progress_report();
+    if (item.first)
+      item.first->progress_report ();
   }
   return geom;
 }
 
-}   // namespace ManifoldUtils
+} // namespace ManifoldUtils
 
 #endif // ENABLE_MANIFOLD
diff --git a/src/geometry/manifold/manifoldutils.cc b/src/geometry/manifold/manifoldutils.cc
index 4ce153fa2..5ee14bbcc 100644
--- a/src/geometry/manifold/manifoldutils.cc
+++ b/src/geometry/manifold/manifoldutils.cc
@@ -33,282 +33,292 @@ using Error = manifold::Manifold::Error;
 
 namespace {
 
-std::shared_ptr<ManifoldGeometry> createManifoldFromTriangularPolySet(const PolySet& ps)
-{
-  assert(ps.isTriangular());
+std::shared_ptr<ManifoldGeometry> createManifoldFromTriangularPolySet (const PolySet &ps) {
+  assert (ps.isTriangular ());
 
   manifold::MeshGL64 mesh;
 
   mesh.numProp = 3;
-  mesh.vertProperties.reserve(ps.vertices.size() * 3);
-  for (const auto& v : ps.vertices) {
-    mesh.vertProperties.push_back(v.x());
-    mesh.vertProperties.push_back(v.y());
-    mesh.vertProperties.push_back(v.z());
+  mesh.vertProperties.reserve (ps.vertices.size () * 3);
+  for (const auto &v : ps.vertices) {
+    mesh.vertProperties.push_back (v.x ());
+    mesh.vertProperties.push_back (v.y ());
+    mesh.vertProperties.push_back (v.z ());
   }
 
-  mesh.triVerts.reserve(ps.indices.size() * 3);
+  mesh.triVerts.reserve (ps.indices.size () * 3);
 
   std::set<uint32_t> originalIDs;
   std::map<uint32_t, Color4f> originalIDToColor;
 
   std::map<std::optional<Color4f>, std::vector<size_t>> colorToFaceIndices;
-  for (size_t i = 0, n = ps.indices.size(); i < n; i++) {
-    auto color_index = i < ps.color_indices.size() ? ps.color_indices[i] : -1;
+  for (size_t i = 0, n = ps.indices.size (); i < n; i++) {
+    auto color_index = i < ps.color_indices.size () ? ps.color_indices[i] : -1;
     std::optional<Color4f> color;
     if (color_index >= 0) {
       color = ps.colors[color_index];
     }
-    colorToFaceIndices[color].push_back(i);
+    colorToFaceIndices[color].push_back (i);
   }
-  auto next_id = manifold::Manifold::ReserveIDs(colorToFaceIndices.size());
-  for (const auto& [color, faceIndices] : colorToFaceIndices) {
+  auto next_id = manifold::Manifold::ReserveIDs (colorToFaceIndices.size ());
+  for (const auto &[color, faceIndices] : colorToFaceIndices) {
 
     auto id = next_id++;
-    if (color.has_value()) {
-      originalIDToColor[id] = color.value();
+    if (color.has_value ()) {
+      originalIDToColor[id] = color.value ();
     }
 
-    mesh.runIndex.push_back(mesh.triVerts.size());
-    mesh.runOriginalID.push_back(id);
-    originalIDs.insert(id);
+    mesh.runIndex.push_back (mesh.triVerts.size ());
+    mesh.runOriginalID.push_back (id);
+    originalIDs.insert (id);
 
     for (size_t faceIndex : faceIndices) {
-      auto& face = ps.indices[faceIndex];
-      assert(face.size() == 3);
-      mesh.triVerts.push_back(face[0]);
-      mesh.triVerts.push_back(face[1]);
-      mesh.triVerts.push_back(face[2]);
+      auto &face = ps.indices[faceIndex];
+      assert (face.size () == 3);
+      mesh.triVerts.push_back (face[0]);
+      mesh.triVerts.push_back (face[1]);
+      mesh.triVerts.push_back (face[2]);
     }
   }
-  mesh.runIndex.push_back(mesh.triVerts.size());
-
-  auto mani = manifold::Manifold(mesh);
-
-  if (mani.Status() != Error::NoError) {
-    PRINTD("Manifold creation initially failed");
-    bool merged = mesh.Merge();
-    mani = manifold::Manifold(mesh);
-    if (mani.Status() == Error::NoError && merged) {
-      PRINTD("..succeeded after merge");
-    } else if (mani.Status() != Error::NoError && merged) {
-      PRINTD("..still failing after merge");
-    } else if (mani.Status() != Error::NoError && !merged) {
-      PRINTD("..unable to merge");
-    } else if (mani.Status() == Error::NoError && !merged) {
-      PRINTD("..unable to merge, but somehow succeeded anyway?");
+  mesh.runIndex.push_back (mesh.triVerts.size ());
+
+  auto mani = manifold::Manifold (mesh);
+
+  if (mani.Status () != Error::NoError) {
+    PRINTD ("Manifold creation initially failed");
+    bool merged = mesh.Merge ();
+    mani = manifold::Manifold (mesh);
+    if (mani.Status () == Error::NoError && merged) {
+      PRINTD ("..succeeded after merge");
+    } else if (mani.Status () != Error::NoError && merged) {
+      PRINTD ("..still failing after merge");
+    } else if (mani.Status () != Error::NoError && !merged) {
+      PRINTD ("..unable to merge");
+    } else if (mani.Status () == Error::NoError && !merged) {
+      PRINTD ("..unable to merge, but somehow succeeded anyway?");
     }
   }
 
-  return std::make_shared<ManifoldGeometry>(mani, originalIDs, originalIDToColor);
+  return std::make_shared<ManifoldGeometry> (mani, originalIDs, originalIDToColor);
 }
 
-}  // namespace
+} // namespace
 
 namespace ManifoldUtils {
 
-const char *statusToString(Error status) {
+const char *statusToString (Error status) {
   switch (status) {
-  case Error::NoError: return "NoError";
-  case Error::NonFiniteVertex: return "NonFiniteVertex";
-  case Error::NotManifold: return "NotManifold";
-  case Error::VertexOutOfBounds: return "VertexOutOfBounds";
-  case Error::PropertiesWrongLength: return "PropertiesWrongLength";
-  case Error::MissingPositionProperties: return "MissingPositionProperties";
-  case Error::MergeVectorsDifferentLengths: return "MergeVectorsDifferentLengths";
-  case Error::MergeIndexOutOfBounds: return "MergeIndexOutOfBounds";
-  case Error::TransformWrongLength: return "TransformWrongLength";
-  case Error::RunIndexWrongLength: return "RunIndexWrongLength";
-  case Error::FaceIDWrongLength: return "FaceIDWrongLength";
-  default: return "unknown";
+  case Error::NoError:
+    return "NoError";
+  case Error::NonFiniteVertex:
+    return "NonFiniteVertex";
+  case Error::NotManifold:
+    return "NotManifold";
+  case Error::VertexOutOfBounds:
+    return "VertexOutOfBounds";
+  case Error::PropertiesWrongLength:
+    return "PropertiesWrongLength";
+  case Error::MissingPositionProperties:
+    return "MissingPositionProperties";
+  case Error::MergeVectorsDifferentLengths:
+    return "MergeVectorsDifferentLengths";
+  case Error::MergeIndexOutOfBounds:
+    return "MergeIndexOutOfBounds";
+  case Error::TransformWrongLength:
+    return "TransformWrongLength";
+  case Error::RunIndexWrongLength:
+    return "RunIndexWrongLength";
+  case Error::FaceIDWrongLength:
+    return "FaceIDWrongLength";
+  default:
+    return "unknown";
   }
 }
 
-std::shared_ptr<ManifoldGeometry> createManifoldFromPolySet(const PolySet& ps)
-{
+std::shared_ptr<ManifoldGeometry> createManifoldFromPolySet (const PolySet &ps) {
   // 1. If the PolySet is already manifold, we should be able to build a Manifold object directly
   // (through using manifold::Mesh).
   // We need to make sure our PolySet is triangulated before doing that.
   // Note: We currently don't have a way of directly checking if a PolySet is manifold,
   // so we just try converting to a Manifold object and check its status.
   std::unique_ptr<const PolySet> triangulated;
-  if (!ps.isTriangular()) {
-    triangulated = PolySetUtils::tessellate_faces(ps);
+  if (!ps.isTriangular ()) {
+    triangulated = PolySetUtils::tessellate_faces (ps);
   }
-  const PolySet& triangle_set = ps.isTriangular() ? ps : *triangulated;
+  const PolySet &triangle_set = ps.isTriangular () ? ps : *triangulated;
 
   // Note: This function also performs a merge if the first attempt fails.
-  auto mani = createManifoldFromTriangularPolySet(triangle_set);
-  if (mani->getManifold().Status() == Error::NoError) {
+  auto mani = createManifoldFromTriangularPolySet (triangle_set);
+  if (mani->getManifold ().Status () == Error::NoError) {
     return mani;
   }
 
-  LOG(message_group::Warning, "PolySet -> Manifold conversion failed: %1$s\n"
-      "Trying to repair and reconstruct mesh..",
-      ManifoldUtils::statusToString(mani->getManifold().Status()));
+  LOG (message_group::Warning,
+       "PolySet -> Manifold conversion failed: %1$s\n"
+       "Trying to repair and reconstruct mesh..",
+       ManifoldUtils::statusToString (mani->getManifold ().Status ()));
 
   // 2. If the PolySet couldn't be converted into a Manifold object, let's try to repair it.
   // We currently have to utilize some CGAL functions to do this.
 #ifdef ENABLE_CGAL
   try {
-    PolySet psq(ps);
+    PolySet psq (ps);
     std::vector<Vector3d> points3d;
-    psq.quantizeVertices(&points3d);
-    auto ps_tri = PolySetUtils::tessellate_faces(psq);
+    psq.quantizeVertices (&points3d);
+    auto ps_tri = PolySetUtils::tessellate_faces (psq);
 
     CGAL_DoubleMesh m;
 
-    if (ps_tri->isConvex()) {
+    if (ps_tri->isConvex ()) {
       using K = CGAL::Epick;
       // Collect point cloud
-      std::vector<K::Point_3> points(points3d.size());
-      for (size_t i = 0, n = points3d.size(); i < n; i++) {
-        points[i] = CGALUtils::vector_convert<K::Point_3>(points3d[i]);
+      std::vector<K::Point_3> points (points3d.size ());
+      for (size_t i = 0, n = points3d.size (); i < n; i++) {
+        points[i] = CGALUtils::vector_convert<K::Point_3> (points3d[i]);
       }
-      if (points.size() <= 3) return std::make_shared<ManifoldGeometry>();
+      if (points.size () <= 3)
+        return std::make_shared<ManifoldGeometry> ();
 
       // Apply hull
       CGAL::Surface_mesh<CGAL::Point_3<K>> r;
-      CGAL::convex_hull_3(points.begin(), points.end(), r);
-      CGALUtils::copyMesh(r, m);
+      CGAL::convex_hull_3 (points.begin (), points.end (), r);
+      CGALUtils::copyMesh (r, m);
     } else {
-      m = CGALUtils::repairPolySet(*ps_tri);
+      m = CGALUtils::repairPolySet (*ps_tri);
     }
 
-    if (!ps_tri->isConvex()) {
-      if (CGALUtils::isClosed(m)) {
-        CGALUtils::orientToBoundAVolume(m);
+    if (!ps_tri->isConvex ()) {
+      if (CGALUtils::isClosed (m)) {
+        CGALUtils::orientToBoundAVolume (m);
       } else {
-        LOG(message_group::Error, "[manifold] Input mesh is not closed!");
+        LOG (message_group::Error, "[manifold] Input mesh is not closed!");
       }
     }
 
-    auto geom = createManifoldFromSurfaceMesh(m);
+    auto geom = createManifoldFromSurfaceMesh (m);
     // TODO: preserve color if polyset is fully monochrome, or maybe pass colors around in surface mesh?
     return geom;
-  } catch (const std::exception& e) {
-    LOG(message_group::Error, "[manifold] CGAL error: %1$s", e.what());
+  } catch (const std::exception &e) {
+    LOG (message_group::Error, "[manifold] CGAL error: %1$s", e.what ());
   }
 #endif // ifdef ENABLE_CGAL
-  return std::make_shared<ManifoldGeometry>();
+  return std::make_shared<ManifoldGeometry> ();
 }
 
-std::shared_ptr<const ManifoldGeometry> createManifoldFromGeometry(const std::shared_ptr<const Geometry>& geom) {
-  if (auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
+std::shared_ptr<const ManifoldGeometry> createManifoldFromGeometry (const std::shared_ptr<const Geometry> &geom) {
+  if (auto mani = std::dynamic_pointer_cast<const ManifoldGeometry> (geom)) {
     return mani;
   }
-  if (auto ps = PolySetUtils::getGeometryAsPolySet(geom)) {
-    return createManifoldFromPolySet(*ps);
+  if (auto ps = PolySetUtils::getGeometryAsPolySet (geom)) {
+    return createManifoldFromPolySet (*ps);
   }
   return nullptr;
 }
 
-Polygon2d polygonsToPolygon2d(const manifold::Polygons& polygons) {
+Polygon2d polygonsToPolygon2d (const manifold::Polygons &polygons) {
   Polygon2d poly2d;
-  for (const auto& polygon : polygons) {
+  for (const auto &polygon : polygons) {
     Outline2d outline;
-    for (const auto& v : polygon) {
-      outline.vertices.emplace_back(v[0], v[1]);
+    for (const auto &v : polygon) {
+      outline.vertices.emplace_back (v[0], v[1]);
     }
-    poly2d.addOutline(std::move(outline));
+    poly2d.addOutline (std::move (outline));
   }
   return poly2d;
 }
 
-std::unique_ptr<PolySet> createTriangulatedPolySetFromPolygon2d(const Polygon2d& polygon2d)
-{
-  auto polyset = std::make_unique<PolySet>(2);
-  polyset->setTriangular(true);
+std::unique_ptr<PolySet> createTriangulatedPolySetFromPolygon2d (const Polygon2d &polygon2d) {
+  auto polyset = std::make_unique<PolySet> (2);
+  polyset->setTriangular (true);
 
   manifold::Polygons polygons;
-  for (const auto& outline : polygon2d.outlines()) {
+  for (const auto &outline : polygon2d.outlines ()) {
     manifold::SimplePolygon simplePolygon;
-    for (const auto& vertex : outline.vertices) {
-      polyset->vertices.emplace_back(vertex[0], vertex[1], 0.0);
-      simplePolygon.emplace_back(vertex[0], vertex[1]);
+    for (const auto &vertex : outline.vertices) {
+      polyset->vertices.emplace_back (vertex[0], vertex[1], 0.0);
+      simplePolygon.emplace_back (vertex[0], vertex[1]);
     }
-    polygons.push_back(std::move(simplePolygon));
+    polygons.push_back (std::move (simplePolygon));
   }
 
-  const auto triangles = manifold::Triangulate(polygons);
+  const auto triangles = manifold::Triangulate (polygons);
 
-  for (const auto& triangle : triangles) {
-    polyset->indices.push_back({triangle[0], triangle[1], triangle[2]});
+  for (const auto &triangle : triangles) {
+    polyset->indices.push_back ({triangle[0], triangle[1], triangle[2]});
   }
   return polyset;
-
 }
 
 template <class SurfaceMesh>
-std::shared_ptr<ManifoldGeometry> createManifoldFromSurfaceMesh(const SurfaceMesh& tm)
-{
+std::shared_ptr<ManifoldGeometry> createManifoldFromSurfaceMesh (const SurfaceMesh &tm) {
   using vertex_descriptor = typename SurfaceMesh::Vertex_index;
 
   manifold::MeshGL64 meshgl;
 
   meshgl.numProp = 3;
-  meshgl.vertProperties.resize(tm.number_of_vertices() * 3);
-  for (vertex_descriptor vd : tm.vertices()){
-    const auto& v = tm.point(vd);
-    meshgl.vertProperties[3 * vd] = v.x();
-    meshgl.vertProperties[3 * vd + 1] = v.y();
-    meshgl.vertProperties[3 * vd + 2] = v.z();
+  meshgl.vertProperties.resize (tm.number_of_vertices () * 3);
+  for (vertex_descriptor vd : tm.vertices ()) {
+    const auto &v = tm.point (vd);
+    meshgl.vertProperties[3 * vd] = v.x ();
+    meshgl.vertProperties[3 * vd + 1] = v.y ();
+    meshgl.vertProperties[3 * vd + 2] = v.z ();
   }
 
-  meshgl.triVerts.reserve(tm.number_of_faces() * 3);
-  for (const auto& f : tm.faces()) {
+  meshgl.triVerts.reserve (tm.number_of_faces () * 3);
+  for (const auto &f : tm.faces ()) {
     size_t idx[3];
     size_t i = 0;
-    for (vertex_descriptor vd : vertices_around_face(tm.halfedge(f), tm)) {
-      if (i >= 3) break;
+    for (vertex_descriptor vd : vertices_around_face (tm.halfedge (f), tm)) {
+      if (i >= 3)
+        break;
       idx[i++] = vd;
     }
-    if (i < 3) continue;
+    if (i < 3)
+      continue;
     for (size_t j : {0, 1, 2})
-      meshgl.triVerts.emplace_back(idx[j]);
+      meshgl.triVerts.emplace_back (idx[j]);
   }
 
-  assert((meshgl.triVerts.size() == tm.number_of_faces() * 3) || !"Mesh was not triangular!");
+  assert ((meshgl.triVerts.size () == tm.number_of_faces () * 3) || !"Mesh was not triangular!");
 
-  auto mani = manifold::Manifold(meshgl).AsOriginal();
-  if (mani.Status() != Error::NoError) {
-    LOG(message_group::Error,
-        "[manifold] Surface_mesh -> Manifold conversion failed: %1$s",
-        ManifoldUtils::statusToString(mani.Status()));
+  auto mani = manifold::Manifold (meshgl).AsOriginal ();
+  if (mani.Status () != Error::NoError) {
+    LOG (message_group::Error,
+         "[manifold] Surface_mesh -> Manifold conversion failed: %1$s",
+         ManifoldUtils::statusToString (mani.Status ()));
     return nullptr;
   }
   std::set<uint32_t> originalIDs;
-  auto id = mani.OriginalID();
+  auto id = mani.OriginalID ();
   if (id >= 0) {
-    originalIDs.insert(id);
+    originalIDs.insert (id);
   }
-  return std::make_shared<ManifoldGeometry>(mani, originalIDs);
+  return std::make_shared<ManifoldGeometry> (mani, originalIDs);
 }
 
 template <class SurfaceMesh>
-std::shared_ptr<SurfaceMesh> createSurfaceMeshFromManifold(const manifold::Manifold& mani)
-{
-  const auto meshgl = mani.GetMeshGL64();
-  auto mesh = std::make_shared<SurfaceMesh>();
-  mesh->reserve(meshgl.NumVert(), meshgl.NumTri() * 3, meshgl.NumTri());
-  for (auto i = 0; i < meshgl.NumVert(); i++) {
-    const auto& v = meshgl.GetVertPos(i);
-    mesh->add_vertex(typename SurfaceMesh::Point(v[0], v[1], v[2]));
+std::shared_ptr<SurfaceMesh> createSurfaceMeshFromManifold (const manifold::Manifold &mani) {
+  const auto meshgl = mani.GetMeshGL64 ();
+  auto mesh = std::make_shared<SurfaceMesh> ();
+  mesh->reserve (meshgl.NumVert (), meshgl.NumTri () * 3, meshgl.NumTri ());
+  for (auto i = 0; i < meshgl.NumVert (); i++) {
+    const auto &v = meshgl.GetVertPos (i);
+    mesh->add_vertex (typename SurfaceMesh::Point (v[0], v[1], v[2]));
   }
-  for (auto i = 0; i < meshgl.NumTri(); i++) {
-    const auto& tri = meshgl.GetTriVerts(i);
-    mesh->add_face(typename SurfaceMesh::Vertex_index(tri[0]),
-                   typename SurfaceMesh::Vertex_index(tri[1]),
-                   typename SurfaceMesh::Vertex_index(tri[2]));
+  for (auto i = 0; i < meshgl.NumTri (); i++) {
+    const auto &tri = meshgl.GetTriVerts (i);
+    mesh->add_face (typename SurfaceMesh::Vertex_index (tri[0]),
+                    typename SurfaceMesh::Vertex_index (tri[1]),
+                    typename SurfaceMesh::Vertex_index (tri[2]));
   }
   return mesh;
 }
 
 #ifdef ENABLE_CGAL
-template std::shared_ptr<ManifoldGeometry> createManifoldFromSurfaceMesh(const CGAL::Surface_mesh<CGAL::Point_3<CGAL::Epick>>& tm);
-template std::shared_ptr<ManifoldGeometry> createManifoldFromSurfaceMesh(const CGAL_DoubleMesh& tm);
-template std::shared_ptr<CGAL::Surface_mesh<manifold::vec3>> createSurfaceMeshFromManifold<CGAL::Surface_mesh<manifold::vec3>>(const manifold::Manifold& mani);
-template std::shared_ptr<CGAL::Surface_mesh<CGAL_Point_3>> createSurfaceMeshFromManifold<CGAL::Surface_mesh<CGAL_Point_3>>(const manifold::Manifold& mani);
+template std::shared_ptr<ManifoldGeometry> createManifoldFromSurfaceMesh (const CGAL::Surface_mesh<CGAL::Point_3<CGAL::Epick>> &tm);
+template std::shared_ptr<ManifoldGeometry> createManifoldFromSurfaceMesh (const CGAL_DoubleMesh &tm);
+template std::shared_ptr<CGAL::Surface_mesh<manifold::vec3>> createSurfaceMeshFromManifold<CGAL::Surface_mesh<manifold::vec3>> (const manifold::Manifold &mani);
+template std::shared_ptr<CGAL::Surface_mesh<CGAL_Point_3>> createSurfaceMeshFromManifold<CGAL::Surface_mesh<CGAL_Point_3>> (const manifold::Manifold &mani);
 #endif
 
-}  // namespace ManifoldUtils
+} // namespace ManifoldUtils
diff --git a/src/geometry/manifold/manifoldutils.h b/src/geometry/manifold/manifoldutils.h
index 475869f9f..1e613f4c8 100644
--- a/src/geometry/manifold/manifoldutils.h
+++ b/src/geometry/manifold/manifoldutils.h
@@ -11,24 +11,24 @@
 
 namespace ManifoldUtils {
 
-const char *statusToString(manifold::Manifold::Error status);
+const char *statusToString (manifold::Manifold::Error status);
 
-std::shared_ptr<ManifoldGeometry> createManifoldFromPolySet(const PolySet& ps);
-std::shared_ptr<const ManifoldGeometry> createManifoldFromGeometry(const std::shared_ptr<const Geometry>& geom);
+std::shared_ptr<ManifoldGeometry> createManifoldFromPolySet (const PolySet &ps);
+std::shared_ptr<const ManifoldGeometry> createManifoldFromGeometry (const std::shared_ptr<const Geometry> &geom);
 
 template <class SurfaceMesh>
-std::shared_ptr<ManifoldGeometry> createManifoldFromSurfaceMesh(const SurfaceMesh& mesh);
+std::shared_ptr<ManifoldGeometry> createManifoldFromSurfaceMesh (const SurfaceMesh &mesh);
 template <typename SurfaceMesh>
-std::shared_ptr<SurfaceMesh> createSurfaceMeshFromManifold(const manifold::Manifold& mani);
+std::shared_ptr<SurfaceMesh> createSurfaceMeshFromManifold (const manifold::Manifold &mani);
 
-std::shared_ptr<ManifoldGeometry> applyOperator3DManifold(const Geometry::Geometries& children, OpenSCADOperator op);
+std::shared_ptr<ManifoldGeometry> applyOperator3DManifold (const Geometry::Geometries &children, OpenSCADOperator op);
 
-Polygon2d polygonsToPolygon2d(const manifold::Polygons& polygons);
+Polygon2d polygonsToPolygon2d (const manifold::Polygons &polygons);
 
 #ifdef ENABLE_CGAL
 // FIXME: This shouldn't return const, but it does due to internal implementation details.
-std::shared_ptr<const Geometry> applyMinkowski(const Geometry::Geometries& children);
+std::shared_ptr<const Geometry> applyMinkowski (const Geometry::Geometries &children);
 #endif
 
-std::unique_ptr<PolySet> createTriangulatedPolySetFromPolygon2d(const Polygon2d& polygon2d);
-}
+std::unique_ptr<PolySet> createTriangulatedPolySetFromPolygon2d (const Polygon2d &polygon2d);
+} // namespace ManifoldUtils
diff --git a/src/geometry/roof_ss.cc b/src/geometry/roof_ss.cc
index 2d781b76b..b9c391e89 100644
--- a/src/geometry/roof_ss.cc
+++ b/src/geometry/roof_ss.cc
@@ -29,7 +29,7 @@
 #include "geometry/PolySetBuilder.h"
 
 #define RAISE_ROOF_EXCEPTION(message) \
-        throw RoofNode::roof_exception((boost::format("%s line %d: %s") % __FILE__ % __LINE__ % (message)).str());
+  throw RoofNode::roof_exception ((boost::format ("%s line %d: %s") % __FILE__ % __LINE__ % (message)).str ());
 
 namespace roof_ss {
 
@@ -50,92 +50,89 @@ using CGAL_SsPtr = boost::shared_ptr<CGAL_Ss>;
 using CGAL_SsPtr = std::shared_ptr<CGAL_Ss>;
 #endif
 
-CGAL_Polygon_2 to_cgal_polygon_2(const Clipper2Lib::Path64& path, int scale_bits)
-{
+CGAL_Polygon_2 to_cgal_polygon_2 (const Clipper2Lib::Path64 &path, int scale_bits) {
   CGAL_Polygon_2 poly;
-  const double scale = std::ldexp(1.0, -scale_bits);
+  const double scale = std::ldexp (1.0, -scale_bits);
   for (auto v : path) {
-    poly.push_back({v.x * scale, v.y * scale});
+    poly.push_back ({v.x * scale, v.y * scale});
   }
   return poly;
 }
 
 // break a list of outlines into polygons with holes
-std::vector<CGAL_Polygon_with_holes_2> polygons_with_holes(const Clipper2Lib::PolyTree64& polytree, int scale_bits)
-{
+std::vector<CGAL_Polygon_with_holes_2> polygons_with_holes (const Clipper2Lib::PolyTree64 &polytree, int scale_bits) {
   std::vector<CGAL_Polygon_with_holes_2> ret;
 
   // lambda for recursive walk through polytree
-  std::function<void (const Clipper2Lib::PolyPath64&)> walk = [&](const Clipper2Lib::PolyPath64& c) {
-      // outer path
-      CGAL_Polygon_with_holes_2 c_poly(to_cgal_polygon_2(c.Polygon(), scale_bits));
-      // holes
-      for (const auto& cc : c) {
-        c_poly.add_hole(to_cgal_polygon_2(cc->Polygon(), scale_bits));
-        for (const auto& ccc : *cc)
-          walk(*ccc);
-      }
-      ret.push_back(c_poly);
-      return;
-    };
+  std::function<void (const Clipper2Lib::PolyPath64 &)> walk = [&] (const Clipper2Lib::PolyPath64 &c) {
+    // outer path
+    CGAL_Polygon_with_holes_2 c_poly (to_cgal_polygon_2 (c.Polygon (), scale_bits));
+    // holes
+    for (const auto &cc : c) {
+      c_poly.add_hole (to_cgal_polygon_2 (cc->Polygon (), scale_bits));
+      for (const auto &ccc : *cc)
+        walk (*ccc);
+    }
+    ret.push_back (c_poly);
+    return;
+  };
 
-  for (const auto& root_node : polytree)
-    walk(*root_node);
+  for (const auto &root_node : polytree)
+    walk (*root_node);
 
   return ret;
 }
 
-std::unique_ptr<PolySet> straight_skeleton_roof(const Polygon2d& poly)
-{
+std::unique_ptr<PolySet> straight_skeleton_roof (const Polygon2d &poly) {
   PolySetBuilder hatbuilder;
 
-  const int scale_bits = ClipperUtils::scaleBitsFromPrecision();
-  const Clipper2Lib::Paths64 paths = ClipperUtils::fromPolygon2d(poly, scale_bits);
-  const std::unique_ptr<Clipper2Lib::PolyTree64> polytree = ClipperUtils::sanitize(paths);
-  auto poly_sanitized = ClipperUtils::toPolygon2d(*polytree, scale_bits);
+  const int scale_bits = ClipperUtils::scaleBitsFromPrecision ();
+  const Clipper2Lib::Paths64 paths = ClipperUtils::fromPolygon2d (poly, scale_bits);
+  const std::unique_ptr<Clipper2Lib::PolyTree64> polytree = ClipperUtils::sanitize (paths);
+  auto poly_sanitized = ClipperUtils::toPolygon2d (*polytree, scale_bits);
 
   try {
     // roof
-    const std::vector<CGAL_Polygon_with_holes_2> shapes = polygons_with_holes(*polytree, scale_bits);
-    for (const CGAL_Polygon_with_holes_2& shape : shapes) {
-      const CGAL_SsPtr ss = CGAL::create_interior_straight_skeleton_2(shape);
+    const std::vector<CGAL_Polygon_with_holes_2> shapes = polygons_with_holes (*polytree, scale_bits);
+    for (const CGAL_Polygon_with_holes_2 &shape : shapes) {
+      const CGAL_SsPtr ss = CGAL::create_interior_straight_skeleton_2 (shape);
       // store heights of vertices
-      auto vector2d_comp = [](const Vector2d& a, const Vector2d& b) {
-          return (a[0] < b[0]) || (a[0] == b[0] && a[1] < b[1]);
-        };
-      std::map<Vector2d, double, decltype(vector2d_comp)> heights(vector2d_comp);
-      for (auto v = ss->vertices_begin(); v != ss->vertices_end(); v++) {
-        const Vector2d p(v->point().x(), v->point().y());
-        heights[p] = v->time();
+      auto vector2d_comp = [] (const Vector2d &a, const Vector2d &b) {
+        return (a[0] < b[0]) || (a[0] == b[0] && a[1] < b[1]);
+      };
+      std::map<Vector2d, double, decltype (vector2d_comp)> heights (vector2d_comp);
+      for (auto v = ss->vertices_begin (); v != ss->vertices_end (); v++) {
+        const Vector2d p (v->point ().x (), v->point ().y ());
+        heights[p] = v->time ();
       }
 
-      for (auto ss_face = ss->faces_begin(); ss_face != ss->faces_end(); ss_face++) {
+      for (auto ss_face = ss->faces_begin (); ss_face != ss->faces_end (); ss_face++) {
         // convert ss_face to cgal polygon
         CGAL_Polygon_2 face;
-        for (auto h = ss_face->halfedge(); ;) {
-          const CGAL_Point_2 pp = h->vertex()->point();
-          face.push_back(pp);
-          h = h->next();
-          if (h == ss_face->halfedge()) {
+        for (auto h = ss_face->halfedge ();;) {
+          const CGAL_Point_2 pp = h->vertex ()->point ();
+          face.push_back (pp);
+          h = h->next ();
+          if (h == ss_face->halfedge ()) {
             break;
           }
         }
-        if (!face.is_simple()) {
-          RAISE_ROOF_EXCEPTION("A non-simple face in straight skeleton, likely cause is cgal issue #5177");
+        if (!face.is_simple ()) {
+          RAISE_ROOF_EXCEPTION ("A non-simple face in straight skeleton, likely cause is cgal issue #5177");
         }
 
         // do convex partition if necessary
         std::vector<CGAL_PT::Polygon_2> facets;
-        CGAL::approx_convex_partition_2(face.vertices_begin(), face.vertices_end(),
-                                        std::back_inserter(facets));
+        CGAL::approx_convex_partition_2 (face.vertices_begin (), face.vertices_end (),
+                                         std::back_inserter (facets));
 
-        for (const auto& facet : facets) {
+        for (const auto &facet : facets) {
           std::vector<int> roof;
-          for (auto v = facet.vertices_begin(); v != facet.vertices_end(); v++) {
-            const Vector2d vv(v->x(), v->y());
-            roof.push_back(hatbuilder.vertexIndex(Vector3d(v->x(), v->y(), heights[vv])));
+          for (auto v = facet.vertices_begin (); v != facet.vertices_end (); v++) {
+            const Vector2d vv (v->x (), v->y ());
+            roof.push_back (hatbuilder.vertexIndex (Vector3d (v->x (), v->y (), heights[vv])));
           }
-          hatbuilder.appendPolygon(roof);
+          hatbuilder.appendPolygon (roof);
         }
       }
     }
@@ -144,22 +141,22 @@ std::unique_ptr<PolySet> straight_skeleton_roof(const Polygon2d& poly)
     {
       // poly has to go through clipper just as it does for the roof
       // because this may change coordinates
-      auto tess = poly_sanitized->tessellate();
-      for (const IndexedFace& triangle : tess->indices) {
+      auto tess = poly_sanitized->tessellate ();
+      for (const IndexedFace &triangle : tess->indices) {
         std::vector<int> floor;
         for (const int tv : triangle) {
-          floor.push_back(hatbuilder.vertexIndex(tess->vertices[tv]));
+          floor.push_back (hatbuilder.vertexIndex (tess->vertices[tv]));
         }
         // floor has wrong orientation
-        std::reverse(floor.begin(), floor.end());
-        hatbuilder.appendPolygon(floor);
+        std::reverse (floor.begin (), floor.end ());
+        hatbuilder.appendPolygon (floor);
       }
     }
 
-    return hatbuilder.build();
-  } catch (RoofNode::roof_exception& e) {
+    return hatbuilder.build ();
+  } catch (RoofNode::roof_exception &e) {
     throw;
   }
 }
 
-} // roof_ss
+} // namespace roof_ss
diff --git a/src/geometry/roof_ss.h b/src/geometry/roof_ss.h
index 4d1817946..4f19d3b0a 100644
--- a/src/geometry/roof_ss.h
+++ b/src/geometry/roof_ss.h
@@ -8,5 +8,5 @@
 #include "geometry/PolySet.h"
 
 namespace roof_ss {
-std::unique_ptr<PolySet> straight_skeleton_roof(const Polygon2d& poly);
+std::unique_ptr<PolySet> straight_skeleton_roof (const Polygon2d &poly);
 }
diff --git a/src/geometry/roof_vd.cc b/src/geometry/roof_vd.cc
index de90db677..5d0ae0801 100644
--- a/src/geometry/roof_vd.cc
+++ b/src/geometry/roof_vd.cc
@@ -21,7 +21,7 @@
 #include "core/RoofNode.h"
 
 #define RAISE_ROOF_EXCEPTION(message) \
-        throw RoofNode::roof_exception((boost::format("%s line %d: %s") % __FILE__ % __LINE__ % (message)).str());
+  throw RoofNode::roof_exception ((boost::format ("%s line %d: %s") % __FILE__ % __LINE__ % (message)).str ());
 
 namespace roof_vd {
 
@@ -32,8 +32,10 @@ using voronoi_diagram = ::boost::polygon::voronoi_diagram<double>;
 struct Point {
   VD_int a;
   VD_int b;
-  Point(VD_int x, VD_int y) : a(x), b(y) {}
-  friend std::ostream& operator<<(std::ostream& os, const Point& point) {
+  Point (VD_int x, VD_int y)
+    : a (x)
+    , b (y) {}
+  friend std::ostream &operator<< (std::ostream &os, const Point &point) {
     return os << "(" << point.a << ", " << point.b << ")";
   }
 };
@@ -41,13 +43,15 @@ struct Point {
 struct Segment {
   Point p0;
   Point p1;
-  Segment(VD_int x1, VD_int y1, VD_int x2, VD_int y2) : p0(x1, y1), p1(x2, y2) {}
-  friend std::ostream& operator<<(std::ostream& os, const Segment& segment) {
+  Segment (VD_int x1, VD_int y1, VD_int x2, VD_int y2)
+    : p0 (x1, y1)
+    , p1 (x2, y2) {}
+  friend std::ostream &operator<< (std::ostream &os, const Segment &segment) {
     return os << segment.p0 << " -- " << segment.p1;
   }
 };
 
-} // roof_vd
+} // namespace roof_vd
 
 // pass our Point and Segment structures to boost::polygon
 namespace boost::polygon {
@@ -59,8 +63,8 @@ template <>
 struct point_traits<roof_vd::Point> {
   using coordinate_type = roof_vd::VD_int;
 
-  static inline coordinate_type get(
-    const roof_vd::Point& point, const orientation_2d& orient) {
+  static inline coordinate_type get (
+    const roof_vd::Point &point, const orientation_2d &orient) {
     return (orient == HORIZONTAL) ? point.a : point.b;
   }
 };
@@ -73,61 +77,57 @@ struct segment_traits<roof_vd::Segment> {
   using coordinate_type = roof_vd::VD_int;
   using point_type = roof_vd::Point;
 
-  static inline point_type get(const roof_vd::Segment& segment, const direction_1d& dir) {
-    return dir.to_int() ? segment.p1 : segment.p0;
+  static inline point_type get (const roof_vd::Segment &segment, const direction_1d &dir) {
+    return dir.to_int () ? segment.p1 : segment.p0;
   }
 };
-}  // boost::polygon
-
+} // namespace boost::polygon
 
 namespace roof_vd {
 
-bool operator==(const Point& lhs, const Point& rhs)
-{
-  return lhs.a == rhs.a  &&  lhs.b == rhs.b;
+bool operator== (const Point &lhs, const Point &rhs) {
+  return lhs.a == rhs.a && lhs.b == rhs.b;
 }
 
-bool operator==(const Segment& lhs, const Segment& rhs)
-{
-  return lhs.p0 == rhs.p0  &&  lhs.p1 == rhs.p1;
+bool operator== (const Segment &lhs, const Segment &rhs) {
+  return lhs.p0 == rhs.p0 && lhs.p1 == rhs.p1;
 }
 
-bool segment_has_endpoint(const Segment& segment, const Point& point) {
+bool segment_has_endpoint (const Segment &segment, const Point &point) {
   return segment.p0 == point || segment.p1 == point;
 }
 
-double distance_to_segment(const Vector2d& vertex, const Segment& segment) {
-  Vector2d segment_normal(-(segment.p1.b - segment.p0.b), segment.p1.a - segment.p0.a);
-  segment_normal.normalize();
-  Vector2d p0_to_vertex(vertex[0] - segment.p0.a, vertex[1] - segment.p0.b);
-  return std::abs(segment_normal.dot(p0_to_vertex));
+double distance_to_segment (const Vector2d &vertex, const Segment &segment) {
+  Vector2d segment_normal (-(segment.p1.b - segment.p0.b), segment.p1.a - segment.p0.a);
+  segment_normal.normalize ();
+  Vector2d p0_to_vertex (vertex[0] - segment.p0.a, vertex[1] - segment.p0.b);
+  return std::abs (segment_normal.dot (p0_to_vertex));
 }
 
-double distance_to_point(const Vector2d& vertex, const Point& point) {
-  Vector2d point_to_vertex(vertex[0] - point.a, vertex[1] - point.b);
-  return point_to_vertex.norm();
+double distance_to_point (const Vector2d &vertex, const Point &point) {
+  Vector2d point_to_vertex (vertex[0] - point.a, vertex[1] - point.b);
+  return point_to_vertex.norm ();
 }
 
-std::vector<Vector2d> discretize_arc(const Point& point, const Segment& segment,
-                                     const Vector2d& v0, const Vector2d& v1,
-                                     double fa, double fs)
-{
+std::vector<Vector2d> discretize_arc (const Point &point, const Segment &segment,
+                                      const Vector2d &v0, const Vector2d &v1,
+                                      double fa, double fs) {
   std::vector<Vector2d> ret;
 
   const double max_angle_deviation = M_PI / 180.0 * fa / 2.0;
   const double max_segment_sqr_length = fs * fs;
 
-  const Vector2d p(point.a, point.b);
-  const Vector2d p0(segment.p0.a, segment.p0.b);
-  const Vector2d p1(segment.p1.a, segment.p1.b);
-  const Vector2d p0_to_p1_norm = (p1 - p0).normalized();
+  const Vector2d p (point.a, point.b);
+  const Vector2d p0 (segment.p0.a, segment.p0.b);
+  const Vector2d p1 (segment.p1.a, segment.p1.b);
+  const Vector2d p0_to_p1_norm = (p1 - p0).normalized ();
 
-  const Vector2d projected_point = p0 + p0_to_p1_norm * p0_to_p1_norm.dot(p - p0);
+  const Vector2d projected_point = p0 + p0_to_p1_norm * p0_to_p1_norm.dot (p - p0);
 
-  const double point_distance = (p - projected_point).norm();
+  const double point_distance = (p - projected_point).norm ();
 
   if (!(point_distance > 0)) {
-    RAISE_ROOF_EXCEPTION("error in parabolic arc discretization");
+    RAISE_ROOF_EXCEPTION ("error in parabolic arc discretization");
   }
 
   const Vector2d point_direction = (p - projected_point) / point_distance;
@@ -136,62 +136,62 @@ std::vector<Vector2d> discretize_arc(const Point& point, const Segment& segment,
   // segment parallel to the x axes on the negative side
   //     a_point -> A(a_point - point)
   Eigen::Matrix2d A, Ai;
-  Ai << point_direction.y(), point_direction.x(), -point_direction.x(), point_direction.y();
-  A = Ai.inverse();
+  Ai << point_direction.y (), point_direction.x (), -point_direction.x (), point_direction.y ();
+  A = Ai.inverse ();
 
   // x coordinates of source and target
   const double transformed_v0_x = (A * (v0 - p))[0];
   const double transformed_v1_x = (A * (v1 - p))[0];
   if (!(transformed_v0_x < transformed_v1_x)) {
-    RAISE_ROOF_EXCEPTION("error in parabolic arc discretization");
+    RAISE_ROOF_EXCEPTION ("error in parabolic arc discretization");
   }
 
   // in transformed coordinates the parabola has equation y = (x^2 - point_distance^2) / (2 point_distance)
-  auto y = [point_distance](double x) {
-      return (x * x - point_distance * point_distance) / (2 * point_distance);
-    };
-  auto y_prime = [point_distance](double x) {
-      return x / point_distance;
-    };
+  auto y = [point_distance] (double x) {
+    return (x * x - point_distance * point_distance) / (2 * point_distance);
+  };
+  auto y_prime = [point_distance] (double x) {
+    return x / point_distance;
+  };
   // angle between a segment and the parabola
-  auto segment_angle = [y, y_prime](double x1, double x2){
-      double dx = x2 - x1,
-       dy = y(x2) - y(x1);
-      double tx = 1,
-             ty = (std::abs(x1) < std::abs(x2)) ? y_prime(x1) : y_prime(x2);
-      return std::abs(std::atan2(dx * ty - dy * tx, dx * tx + dy * ty));
-    };
+  auto segment_angle = [y, y_prime] (double x1, double x2) {
+    double dx = x2 - x1,
+           dy = y (x2) - y (x1);
+    double tx = 1,
+           ty = (std::abs (x1) < std::abs (x2)) ? y_prime (x1) : y_prime (x2);
+    return std::abs (std::atan2 (dx * ty - dy * tx, dx * tx + dy * ty));
+  };
   // squared length of segment
-  auto segment_sqr_length = [y](double x1, double x2){
-      double dx = x2 - x1,
-       dy = y(x2) - y(x1);
-      return dx * dx + dy * dy;
-    };
+  auto segment_sqr_length = [y] (double x1, double x2) {
+    double dx = x2 - x1,
+           dy = y (x2) - y (x1);
+    return dx * dx + dy * dy;
+  };
 
   std::vector<double> transformed_points_x = {transformed_v0_x, transformed_v1_x};
 
   for (;;) {
-    double x1 = transformed_points_x.end()[-2];
-    double x2 = transformed_points_x.end()[-1];
-    if (segment_angle(x1, x2) > max_angle_deviation ||
-        (max_segment_sqr_length > 0 && segment_sqr_length(x1, x2) > max_segment_sqr_length)) {
-      transformed_points_x.end()[-1] = 0.5 * x1 + 0.5 * x2;
+    double x1 = transformed_points_x.end ()[-2];
+    double x2 = transformed_points_x.end ()[-1];
+    if (segment_angle (x1, x2) > max_angle_deviation ||
+        (max_segment_sqr_length > 0 && segment_sqr_length (x1, x2) > max_segment_sqr_length)) {
+      transformed_points_x.end ()[-1] = 0.5 * x1 + 0.5 * x2;
     } else {
       if (x2 == transformed_v1_x) {
         break;
       } else {
-        transformed_points_x.push_back(transformed_v1_x);
+        transformed_points_x.push_back (transformed_v1_x);
       }
     }
   }
 
   for (auto x : transformed_points_x) {
     if (x == transformed_v0_x) {
-      ret.push_back(v0);
+      ret.push_back (v0);
     } else if (x == transformed_v1_x) {
-      ret.push_back(v1);
+      ret.push_back (v1);
     } else {
-      ret.emplace_back(p + Ai * Vector2d(x, y(x)));
+      ret.emplace_back (p + Ai * Vector2d (x, y (x)));
     }
   }
 
@@ -201,7 +201,7 @@ std::vector<Vector2d> discretize_arc(const Point& point, const Segment& segment,
 // a structure that saves 2d faces and heights of vertices
 struct Faces_2_plus_1 {
   struct Vector2d_comp {
-    bool operator()(const Vector2d& lhs, const Vector2d& rhs) const {
+    bool operator() (const Vector2d &lhs, const Vector2d &rhs) const {
       return (lhs[0] < rhs[0]) || (lhs[0] == rhs[0] && lhs[1] < rhs[1]);
     }
   };
@@ -209,123 +209,116 @@ struct Faces_2_plus_1 {
   std::map<Vector2d, double, Vector2d_comp> heights;
 };
 
-Faces_2_plus_1 vd_inner_faces(const voronoi_diagram& vd,
-                              const std::vector<Segment>& segments,
-                              double fa, double fs) {
+Faces_2_plus_1 vd_inner_faces (const voronoi_diagram &vd,
+                               const std::vector<Segment> &segments,
+                               double fa, double fs) {
   Faces_2_plus_1 ret;
 
-  auto cell_contains_boundary_point = [&segments](const voronoi_diagram::cell_type *cell,
-                                                  const Point& point) {
-      Segment segment = segments[cell->source_index()];
-      return (cell->contains_segment() && segment_has_endpoint(segment, point) )
-             || (cell->source_category() == ::boost::polygon::SOURCE_CATEGORY_SEGMENT_START_POINT
-                 && segment.p0 == point)
-             || (cell->source_category() == ::boost::polygon::SOURCE_CATEGORY_SEGMENT_END_POINT
-                 && segment.p1 == point);
-    };
-
-  for (const auto& cell : vd.cells()) {
-
-    std::size_t cell_index = cell.source_index();
-    if (cell.is_degenerate()) {
-      RAISE_ROOF_EXCEPTION("Voronoi error");
+  auto cell_contains_boundary_point = [&segments] (const voronoi_diagram::cell_type *cell,
+                                                   const Point &point) {
+    Segment segment = segments[cell->source_index ()];
+    return (cell->contains_segment () && segment_has_endpoint (segment, point)) || (cell->source_category () == ::boost::polygon::SOURCE_CATEGORY_SEGMENT_START_POINT && segment.p0 == point) || (cell->source_category () == ::boost::polygon::SOURCE_CATEGORY_SEGMENT_END_POINT && segment.p1 == point);
+  };
+
+  for (const auto &cell : vd.cells ()) {
+
+    std::size_t cell_index = cell.source_index ();
+    if (cell.is_degenerate ()) {
+      RAISE_ROOF_EXCEPTION ("Voronoi error");
     }
-    const Segment& segment = segments[cell_index];
+    const Segment &segment = segments[cell_index];
 
-    if (cell.contains_segment()) {
+    if (cell.contains_segment ()) {
       // walk around the cell, find edge starting from segment.p1 or passing through it
-      const voronoi_diagram::edge_type *edge = cell.incident_edge();
+      const voronoi_diagram::edge_type *edge = cell.incident_edge ();
       for (;;) {
-        if (cell_contains_boundary_point(edge->twin()->cell(), segment.p1)
-            && !cell_contains_boundary_point(edge->next()->twin()->cell(), segment.p1)) {
+        if (cell_contains_boundary_point (edge->twin ()->cell (), segment.p1) && !cell_contains_boundary_point (edge->next ()->twin ()->cell (), segment.p1)) {
           break;
         }
-        edge = edge->next();
-        if (edge == cell.incident_edge()) {
-          RAISE_ROOF_EXCEPTION("Voronoi error");
+        edge = edge->next ();
+        if (edge == cell.incident_edge ()) {
+          RAISE_ROOF_EXCEPTION ("Voronoi error");
         }
       }
       // add all inside edges
-      ret.faces.emplace_back();
+      ret.faces.emplace_back ();
       {
-        Vector2d p(segment.p1.a, segment.p1.b);
-        ret.faces.back().push_back(p);
+        Vector2d p (segment.p1.a, segment.p1.b);
+        ret.faces.back ().push_back (p);
         ret.heights[p] = 0.0;
       }
       do {
-        if (edge->is_linear()) { // linear edge is simple
-          Vector2d p(edge->vertex1()->x(), edge->vertex1()->y());
-          ret.faces.back().push_back(p);
-          ret.heights[p] = distance_to_segment(p, segment);
+        if (edge->is_linear ()) { // linear edge is simple
+          Vector2d p (edge->vertex1 ()->x (), edge->vertex1 ()->y ());
+          ret.faces.back ().push_back (p);
+          ret.heights[p] = distance_to_segment (p, segment);
         } else { // discretize a parabolic edge
-          const voronoi_diagram::cell_type *twin_cell = edge->twin()->cell();
-          if (!(twin_cell->contains_point())) {
-            RAISE_ROOF_EXCEPTION("Voronoi error");
+          const voronoi_diagram::cell_type *twin_cell = edge->twin ()->cell ();
+          if (!(twin_cell->contains_point ())) {
+            RAISE_ROOF_EXCEPTION ("Voronoi error");
           }
-          Segment twin_segment = segments[twin_cell->source_index()];
+          Segment twin_segment = segments[twin_cell->source_index ()];
           Point twin_point =
-            (twin_cell->source_category() == ::boost::polygon::SOURCE_CATEGORY_SEGMENT_START_POINT) ?
-            twin_segment.p0 : twin_segment.p1;
-          Vector2d v0(edge->vertex0()->x(), edge->vertex0()->y()),
-          v1(edge->vertex1()->x(), edge->vertex1()->y());
-          std::vector<Vector2d> discr = discretize_arc(twin_point, segment, v1, v0, fa, fs);
-          std::reverse(discr.begin(), discr.end());
-          for (std::size_t k = 1; k < discr.size(); k++) {
-            ret.faces.back().push_back(discr[k]);
-            ret.heights[discr[k]] = distance_to_segment(discr[k], segment);
+            (twin_cell->source_category () == ::boost::polygon::SOURCE_CATEGORY_SEGMENT_START_POINT) ? twin_segment.p0 : twin_segment.p1;
+          Vector2d v0 (edge->vertex0 ()->x (), edge->vertex0 ()->y ()),
+            v1 (edge->vertex1 ()->x (), edge->vertex1 ()->y ());
+          std::vector<Vector2d> discr = discretize_arc (twin_point, segment, v1, v0, fa, fs);
+          std::reverse (discr.begin (), discr.end ());
+          for (std::size_t k = 1; k < discr.size (); k++) {
+            ret.faces.back ().push_back (discr[k]);
+            ret.heights[discr[k]] = distance_to_segment (discr[k], segment);
           }
         }
-        edge = edge->next();
-      } while (!cell_contains_boundary_point(edge->twin()->cell(), segment.p0));
+        edge = edge->next ();
+      } while (!cell_contains_boundary_point (edge->twin ()->cell (), segment.p0));
       {
-        Vector2d p(segment.p0.a, segment.p0.b);
-        ret.faces.back().push_back(p);
+        Vector2d p (segment.p0.a, segment.p0.b);
+        ret.faces.back ().push_back (p);
         ret.heights[p] = 0.0;
       }
     } else { // point cell
-      const voronoi_diagram::edge_type *edge = cell.incident_edge();
-      const Point point = (cell.source_category() == ::boost::polygon::SOURCE_CATEGORY_SEGMENT_START_POINT) ?
-        segment.p0 : segment.p1;
-      while (!(edge->is_secondary() && edge->prev()->is_secondary() )) {
-        edge = edge->next();
-        if (edge == cell.incident_edge()) {
-          RAISE_ROOF_EXCEPTION("Voronoi error");
+      const voronoi_diagram::edge_type *edge = cell.incident_edge ();
+      const Point point = (cell.source_category () == ::boost::polygon::SOURCE_CATEGORY_SEGMENT_START_POINT) ? segment.p0 : segment.p1;
+      while (!(edge->is_secondary () && edge->prev ()->is_secondary ())) {
+        edge = edge->next ();
+        if (edge == cell.incident_edge ()) {
+          RAISE_ROOF_EXCEPTION ("Voronoi error");
         }
       }
 
-      auto add_triangle = [&ret, &point](const Vector2d& v0, const Vector2d& v1) {
-          ret.faces.emplace_back();
+      auto add_triangle = [&ret, &point] (const Vector2d &v0, const Vector2d &v1) {
+        ret.faces.emplace_back ();
 
-          Vector2d p(point.a, point.b);
-          ret.faces.back().push_back(p);
-          ret.heights[p] = 0.0;
+        Vector2d p (point.a, point.b);
+        ret.faces.back ().push_back (p);
+        ret.heights[p] = 0.0;
 
-          ret.faces.back().push_back(v0);
-          ret.heights[v0] = distance_to_point(v0, point);
+        ret.faces.back ().push_back (v0);
+        ret.heights[v0] = distance_to_point (v0, point);
 
-          ret.faces.back().push_back(v1);
-          ret.heights[v1] = distance_to_point(v1, point);
-        };
+        ret.faces.back ().push_back (v1);
+        ret.heights[v1] = distance_to_point (v1, point);
+      };
 
-      if (edge->next()->next() != edge &&
-          segments[edge->twin()->cell()->source_index()].p0 ==
-          segments[edge->prev()->twin()->cell()->source_index()].p1) {
+      if (edge->next ()->next () != edge &&
+          segments[edge->twin ()->cell ()->source_index ()].p0 ==
+            segments[edge->prev ()->twin ()->cell ()->source_index ()].p1) {
         // inner non-degenerate cell
         for (;;) {
-          edge = edge->next();
-          if (edge->is_secondary()) {
+          edge = edge->next ();
+          if (edge->is_secondary ()) {
             break;
           } else {
-            Vector2d v0(edge->vertex0()->x(), edge->vertex0()->y()),
-            v1(edge->vertex1()->x(), edge->vertex1()->y());
-            if (edge->is_curved()) {
-              Segment twin_segment = segments[edge->twin()->cell()->source_index()];
-              std::vector<Vector2d> discr = discretize_arc(point, twin_segment, v0, v1, fa, fs);
-              for (std::size_t k = 1; k < discr.size(); k++) {
-                add_triangle(discr[k - 1], discr[k]);
+            Vector2d v0 (edge->vertex0 ()->x (), edge->vertex0 ()->y ()),
+              v1 (edge->vertex1 ()->x (), edge->vertex1 ()->y ());
+            if (edge->is_curved ()) {
+              Segment twin_segment = segments[edge->twin ()->cell ()->source_index ()];
+              std::vector<Vector2d> discr = discretize_arc (point, twin_segment, v0, v1, fa, fs);
+              for (std::size_t k = 1; k < discr.size (); k++) {
+                add_triangle (discr[k - 1], discr[k]);
               }
             } else {
-              add_triangle(v0, v1);
+              add_triangle (v0, v1);
             }
           }
         }
@@ -335,58 +328,57 @@ Faces_2_plus_1 vd_inner_faces(const voronoi_diagram& vd,
   return ret;
 }
 
-std::unique_ptr<PolySet> voronoi_diagram_roof(const Polygon2d& poly, double fa, double fs)
-{
-  PolySetBuilder hatbuilder = PolySetBuilder();
+std::unique_ptr<PolySet> voronoi_diagram_roof (const Polygon2d &poly, double fa, double fs) {
+  PolySetBuilder hatbuilder = PolySetBuilder ();
 
   try {
 
     // input data for voronoi diagram is 32 bit integers
     // FIXME: Why does this need to be 32 bits? The default we use elsewhere is
     // scaleBitsFromPrecision(DEFAULT_PRECISION) which is 10^8.
-    const int scale_bits = ClipperUtils::scaleBitsFromBounds(poly.getBoundingBox(), 32);
-    const double scale = std::ldexp(1.0, scale_bits);
+    const int scale_bits = ClipperUtils::scaleBitsFromBounds (poly.getBoundingBox (), 32);
+    const double scale = std::ldexp (1.0, scale_bits);
 
-    Clipper2Lib::Paths64 paths = ClipperUtils::fromPolygon2d(poly, scale_bits);
+    Clipper2Lib::Paths64 paths = ClipperUtils::fromPolygon2d (poly, scale_bits);
     // sanitize is important e.g. when after converting to 32 bit integers we have double points
-    paths = Clipper2Lib::PolyTreeToPaths64(*ClipperUtils::sanitize(paths));
+    paths = Clipper2Lib::PolyTreeToPaths64 (*ClipperUtils::sanitize (paths));
     std::vector<Segment> segments;
 
     for (auto path : paths) {
-      auto prev = path.back();
+      auto prev = path.back ();
       for (auto p : path) {
-        segments.emplace_back(prev.x, prev.y, p.x, p.y);
+        segments.emplace_back (prev.x, prev.y, p.x, p.y);
         prev = p;
       }
     }
 
     voronoi_diagram vd;
-    ::boost::polygon::construct_voronoi(segments.begin(), segments.end(), &vd);
-    Faces_2_plus_1 inner_faces = vd_inner_faces(vd, segments, fa, scale * fs);
+    ::boost::polygon::construct_voronoi (segments.begin (), segments.end (), &vd);
+    Faces_2_plus_1 inner_faces = vd_inner_faces (vd, segments, fa, scale * fs);
 
     // roof
-    for (const std::vector<Vector2d>& face : inner_faces.faces) {
-      if (!(face.size() >= 3)) {
-        RAISE_ROOF_EXCEPTION("Voronoi error");
+    for (const std::vector<Vector2d> &face : inner_faces.faces) {
+      if (!(face.size () >= 3)) {
+        RAISE_ROOF_EXCEPTION ("Voronoi error");
       }
       // convex partition (actually a triangulation - maybe do a proper convex partition later)
       Polygon2d face_poly;
       Outline2d outline;
       outline.vertices = face;
-      face_poly.addOutline(outline);
-      auto tess = face_poly.tessellate();
-      for (const IndexedFace& triangle : tess->indices) {
+      face_poly.addOutline (outline);
+      auto tess = face_poly.tessellate ();
+      for (const IndexedFace &triangle : tess->indices) {
         std::vector<int> roof;
         for (int tvind : triangle) {
           Vector3d tv = tess->vertices[tvind];
           Vector2d v;
           v << tv[0], tv[1];
-          if (!(inner_faces.heights.find(v) != inner_faces.heights.end())) {
-            RAISE_ROOF_EXCEPTION("Voronoi error");
+          if (!(inner_faces.heights.find (v) != inner_faces.heights.end ())) {
+            RAISE_ROOF_EXCEPTION ("Voronoi error");
           }
-          roof.push_back(hatbuilder.vertexIndex(Vector3d(v[0] / scale, v[1] / scale, inner_faces.heights[v] / scale)));
+          roof.push_back (hatbuilder.vertexIndex (Vector3d (v[0] / scale, v[1] / scale, inner_faces.heights[v] / scale)));
         }
-        hatbuilder.appendPolygon(roof);
+        hatbuilder.appendPolygon (roof);
       }
     }
 
@@ -395,29 +387,29 @@ std::unique_ptr<PolySet> voronoi_diagram_roof(const Polygon2d& poly, double fa,
       // poly has to go through clipper just as it does for the roof
       // because this may change coordinates
       Polygon2d poly_floor;
-      for (const auto& path : paths) {
+      for (const auto &path : paths) {
         Outline2d o;
         for (auto p : path) {
-          o.vertices.push_back({p.x / scale, p.y / scale});
+          o.vertices.push_back ({p.x / scale, p.y / scale});
         }
-        poly_floor.addOutline(o);
+        poly_floor.addOutline (o);
       }
-      auto tess = poly_floor.tessellate();
-      for (const IndexedFace& triangle : tess->indices) {
+      auto tess = poly_floor.tessellate ();
+      for (const IndexedFace &triangle : tess->indices) {
         std::vector<int> floor;
         for (const int tv : triangle) {
-          floor.push_back(hatbuilder.vertexIndex(tess->vertices[tv]));
+          floor.push_back (hatbuilder.vertexIndex (tess->vertices[tv]));
         }
         // floor has reverse orientation
-        std::reverse(floor.begin(), floor.end());
-        hatbuilder.appendPolygon(floor);
+        std::reverse (floor.begin (), floor.end ());
+        hatbuilder.appendPolygon (floor);
       }
     }
-  } catch (RoofNode::roof_exception& e) {
+  } catch (RoofNode::roof_exception &e) {
     throw;
   }
 
-  return hatbuilder.build();
+  return hatbuilder.build ();
 }
 
-} // roof_vd
+} // namespace roof_vd
diff --git a/src/geometry/roof_vd.h b/src/geometry/roof_vd.h
index 6744bf464..24351f0f2 100644
--- a/src/geometry/roof_vd.h
+++ b/src/geometry/roof_vd.h
@@ -8,5 +8,5 @@
 #include "geometry/PolySet.h"
 
 namespace roof_vd {
-std::unique_ptr<PolySet> voronoi_diagram_roof(const Polygon2d& poly, double fa, double fs);
+std::unique_ptr<PolySet> voronoi_diagram_roof (const Polygon2d &poly, double fa, double fs);
 }
diff --git a/src/geometry/rotate_extrude.cc b/src/geometry/rotate_extrude.cc
index 00e565885..0e7136a90 100644
--- a/src/geometry/rotate_extrude.cc
+++ b/src/geometry/rotate_extrude.cc
@@ -21,40 +21,39 @@
 #include "utils/degree_trig.h"
 #include "utils/printutils.h"
 
-static std::unique_ptr<PolySet> assemblePolySetForManifold(const Polygon2d& polyref,
-                                                           std::vector<Vector3d>& vertices,
-                                                           PolygonIndices& indices, bool closed, int convexity,
-                                                           int index_offset, bool flip_faces)
-{
-  auto final_polyset = std::make_unique<PolySet>(3, false);
-  final_polyset->setTriangular(true);
-  final_polyset->setConvexity(convexity);
-  final_polyset->vertices = std::move(vertices);
-  final_polyset->indices = std::move(indices);
+static std::unique_ptr<PolySet> assemblePolySetForManifold (const Polygon2d &polyref,
+                                                            std::vector<Vector3d> &vertices,
+                                                            PolygonIndices &indices, bool closed, int convexity,
+                                                            int index_offset, bool flip_faces) {
+  auto final_polyset = std::make_unique<PolySet> (3, false);
+  final_polyset->setTriangular (true);
+  final_polyset->setConvexity (convexity);
+  final_polyset->vertices = std::move (vertices);
+  final_polyset->indices = std::move (indices);
 
   if (!closed) {
     // Create top and bottom face.
-    auto ps_bottom = polyref.tessellate();  // bottom
+    auto ps_bottom = polyref.tessellate (); // bottom
     // Flip vertex ordering for bottom polygon unless flip_faces is true
     if (!flip_faces) {
-      for (auto& p : ps_bottom->indices) {
-        std::reverse(p.begin(), p.end());
+      for (auto &p : ps_bottom->indices) {
+        std::reverse (p.begin (), p.end ());
       }
     }
-    std::copy(ps_bottom->indices.begin(), ps_bottom->indices.end(),
-              std::back_inserter(final_polyset->indices));
+    std::copy (ps_bottom->indices.begin (), ps_bottom->indices.end (),
+               std::back_inserter (final_polyset->indices));
 
-    for (auto& p : ps_bottom->indices) {
-      std::reverse(p.begin(), p.end());
-      for (auto& i : p) {
+    for (auto &p : ps_bottom->indices) {
+      std::reverse (p.begin (), p.end ());
+      for (auto &i : p) {
         i += index_offset;
       }
     }
-    std::copy(ps_bottom->indices.begin(), ps_bottom->indices.end(),
-              std::back_inserter(final_polyset->indices));
+    std::copy (ps_bottom->indices.begin (), ps_bottom->indices.end (),
+               std::back_inserter (final_polyset->indices));
   }
 
-//  LOG(PolySetUtils::polySetToPolyhedronSource(*final_polyset));
+  //  LOG(PolySetUtils::polySetToPolyhedronSource(*final_polyset));
 
   return final_polyset;
 }
@@ -76,21 +75,21 @@ static std::unique_ptr<PolySet> assemblePolySetForManifold(const Polygon2d& poly
 
    Currently, we generate a lot of zero-area triangles
  */
-std::unique_ptr<Geometry> rotatePolygon(const RotateExtrudeNode& node, const Polygon2d& poly)
-{
-  if (node.angle == 0) return nullptr;
+std::unique_ptr<Geometry> rotatePolygon (const RotateExtrudeNode &node, const Polygon2d &poly) {
+  if (node.angle == 0)
+    return nullptr;
 
   double min_x = 0;
   double max_x = 0;
-  for (const auto& o : poly.outlines()) {
-    for (const auto& v : o.vertices) {
-      min_x = fmin(min_x, v[0]);
-      max_x = fmax(max_x, v[0]);
+  for (const auto &o : poly.outlines ()) {
+    for (const auto &v : o.vertices) {
+      min_x = fmin (min_x, v[0]);
+      max_x = fmax (max_x, v[0]);
     }
   }
 
   if (max_x > 0 && min_x < 0) {
-    LOG(
+    LOG (
       message_group::Error,
       "all points for rotate_extrude() must have the same X coordinate sign (range is %1$.2f -> %2$.2f)",
       min_x, max_x);
@@ -99,9 +98,9 @@ std::unique_ptr<Geometry> rotatePolygon(const RotateExtrudeNode& node, const Pol
 
   // # of sections. For closed rotations, # vertices is thus fragments*outline_size. For open
   // rotations # vertices is (fragments+1)*outline_size.
-  const auto num_sections = (unsigned int)std::ceil(fmax(
-                                                      Calc::get_fragments_from_r(max_x - min_x, node.fn, node.fs, node.fa) * std::abs(node.angle) / 360,
-                                                      1));
+  const auto num_sections = (unsigned int)std::ceil (fmax (
+    Calc::get_fragments_from_r (max_x - min_x, node.fn, node.fs, node.fa) * std::abs (node.angle) / 360,
+    1));
   const bool closed = node.angle == 360;
   // # of rings of vertices
   const int num_rings = num_sections + (closed ? 0 : 1);
@@ -110,21 +109,21 @@ std::unique_ptr<Geometry> rotatePolygon(const RotateExtrudeNode& node, const Pol
 
   // slice_stride is the number of vertices in a single ring
   size_t slice_stride = 0;
-  for (const auto& o : poly.outlines()) {
-    slice_stride += o.vertices.size();
+  for (const auto &o : poly.outlines ()) {
+    slice_stride += o.vertices.size ();
   }
   const int num_vertices = slice_stride * num_rings;
   std::vector<Vector3d> vertices;
-  vertices.reserve(num_vertices);
+  vertices.reserve (num_vertices);
   PolygonIndices indices;
-  indices.reserve(slice_stride * num_rings * 2);  // sides + endcaps if needed
+  indices.reserve (slice_stride * num_rings * 2); // sides + endcaps if needed
 
   // Calculate all vertices
   for (unsigned int j = 0; j < num_rings; ++j) {
-    for (const auto& outline : poly.outlines()) {
-      const double angle = node.start + j * node.angle / num_sections;  // start on the X axis
-      for (const auto& v : outline.vertices) {
-        vertices.emplace_back(v[0] * cos_degrees(angle), v[0] * sin_degrees(angle), v[1]);
+    for (const auto &outline : poly.outlines ()) {
+      const double angle = node.start + j * node.angle / num_sections; // start on the X axis
+      for (const auto &v : outline.vertices) {
+        vertices.emplace_back (v[0] * cos_degrees (angle), v[0] * sin_degrees (angle), v[1]);
       }
     }
   }
@@ -134,43 +133,42 @@ std::unique_ptr<Geometry> rotatePolygon(const RotateExtrudeNode& node, const Pol
     const int prev_slice = (slice_idx - 1) * slice_stride;
     const int curr_slice = slice_idx * slice_stride;
     int curr_outline = 0;
-    for (const auto& outline : poly.outlines()) {
-      assert(outline.vertices.size() > 2);
-      for (int i = 1; i <= outline.vertices.size(); ++i) {
-        const int curr_idx = curr_outline + (i % outline.vertices.size());
+    for (const auto &outline : poly.outlines ()) {
+      assert (outline.vertices.size () > 2);
+      for (int i = 1; i <= outline.vertices.size (); ++i) {
+        const int curr_idx = curr_outline + (i % outline.vertices.size ());
         const int prev_idx = curr_outline + i - 1;
         if (flip_faces) {
-          indices.push_back({
+          indices.push_back ({
             (prev_slice + prev_idx) % num_vertices,
             (curr_slice + curr_idx) % num_vertices,
             (prev_slice + curr_idx) % num_vertices,
           });
-          indices.push_back({
+          indices.push_back ({
             (curr_slice + curr_idx) % num_vertices,
             (prev_slice + prev_idx) % num_vertices,
             (curr_slice + prev_idx) % num_vertices,
           });
         } else {
-          indices.push_back({
+          indices.push_back ({
             (prev_slice + curr_idx) % num_vertices,
             (curr_slice + curr_idx) % num_vertices,
             (prev_slice + prev_idx) % num_vertices,
           });
-          indices.push_back({
+          indices.push_back ({
             (curr_slice + prev_idx) % num_vertices,
             (prev_slice + prev_idx) % num_vertices,
             (curr_slice + curr_idx) % num_vertices,
           });
         }
       }
-      curr_outline += outline.vertices.size();
+      curr_outline += outline.vertices.size ();
     }
   }
 
   // TODO(kintel): Without Manifold, we don't have such tessellator available which guarantees to not modify vertices, so we technically may end up with
   // broken end caps if we build OpenSCAD without ENABLE_MANIFOLD. Should be fixed, but it's low priority and it's not
   // trivial to come up with a test case for this.
-  return assemblePolySetForManifold(poly, vertices, indices, closed, node.convexity,
-                                    slice_stride * num_sections, flip_faces);
-
+  return assemblePolySetForManifold (poly, vertices, indices, closed, node.convexity,
+                                     slice_stride * num_sections, flip_faces);
 }
diff --git a/src/geometry/rotate_extrude.h b/src/geometry/rotate_extrude.h
index 380593fbf..13e8a269d 100644
--- a/src/geometry/rotate_extrude.h
+++ b/src/geometry/rotate_extrude.h
@@ -6,4 +6,4 @@
 #include "geometry/Geometry.h"
 #include "geometry/Polygon2d.h"
 
-std::unique_ptr<Geometry> rotatePolygon(const RotateExtrudeNode& node, const Polygon2d& poly);
+std::unique_ptr<Geometry> rotatePolygon (const RotateExtrudeNode &node, const Polygon2d &poly);
diff --git a/src/glview/Camera.cc b/src/glview/Camera.cc
index c631f31bd..6e2be77cd 100644
--- a/src/glview/Camera.cc
+++ b/src/glview/Camera.cc
@@ -15,86 +15,81 @@ constexpr double DEFAULT_FOV = 22.5;
 constexpr int DEFAULT_WIDTH = 512;
 constexpr int DEFAULT_HEIGHT = 512;
 
-}  // namespace
+} // namespace
 
-Camera::Camera() : fov(DEFAULT_FOV)
-{
-  PRINTD("Camera()");
+Camera::Camera ()
+  : fov (DEFAULT_FOV) {
+  PRINTD ("Camera()");
 
   // gimbal cam values
-  resetView();
+  resetView ();
 
   pixel_width = DEFAULT_WIDTH;
   pixel_height = DEFAULT_HEIGHT;
   locked = false;
 }
 
-void Camera::setup(std::vector<double> params)
-{
-  if (params.size() == 7) {
-    setVpt(params[0], params[1], params[2]);
-    setVpr(params[3], params[4], params[5]);
+void Camera::setup (std::vector<double> params) {
+  if (params.size () == 7) {
+    setVpt (params[0], params[1], params[2]);
+    setVpr (params[3], params[4], params[5]);
     viewer_distance = params[6];
-  } else if (params.size() == 6) {
-    const Eigen::Vector3d eye(params[0], params[1], params[2]);
-    const Eigen::Vector3d center(params[3], params[4], params[5]);
+  } else if (params.size () == 6) {
+    const Eigen::Vector3d eye (params[0], params[1], params[2]);
+    const Eigen::Vector3d center (params[3], params[4], params[5]);
     object_trans = -center;
     auto dir = center - eye;
-    viewer_distance = dir.norm();
-    object_rot.z() = (!dir[1] && !dir[0]) ? dir[2] < 0 ? 0
-                                           : 180
-                              : -atan2_degrees(dir[1], dir[0]) + 90;
-    object_rot.y() = 0;
-    Eigen::Vector3d projection(dir[0], dir[1], 0);
-    object_rot.x() = -atan2_degrees(dir[2], projection.norm());
+    viewer_distance = dir.norm ();
+    object_rot.z () = (!dir[1] && !dir[0]) ? dir[2] < 0 ? 0
+                                                        : 180
+                                           : -atan2_degrees (dir[1], dir[0]) + 90;
+    object_rot.y () = 0;
+    Eigen::Vector3d projection (dir[0], dir[1], 0);
+    object_rot.x () = -atan2_degrees (dir[2], projection.norm ());
   } else {
-    assert(false && "Gimbal cam needs 7 numbers, Vector camera needs 6");
+    assert (false && "Gimbal cam needs 7 numbers, Vector camera needs 6");
   }
   locked = true;
 }
 /*!
    Moves camera so that the given bbox is fully visible.
  */
-void Camera::viewAll(const BoundingBox& bbox)
-{
-  if (bbox.isEmpty()) {
-    setVpt(0, 0, 0);
-    setVpd(DEFAULT_DISTANCE);
+void Camera::viewAll (const BoundingBox &bbox) {
+  if (bbox.isEmpty ()) {
+    setVpt (0, 0, 0);
+    setVpd (DEFAULT_DISTANCE);
   } else {
 
     if (this->autocenter) {
       // autocenter = point camera at the center of the bounding box.
-      this->object_trans = -bbox.center();
+      this->object_trans = -bbox.center ();
     }
 
-    double bboxRadius = bbox.diagonal().norm() / 2;
-    double radius = (bbox.center() + object_trans).norm() + bboxRadius;
-    this->viewer_distance = radius / sin_degrees(this->fov / 2);
-    PRINTDB("modified obj trans x y z %f %f %f", object_trans.x() % object_trans.y() % object_trans.z());
-    PRINTDB("modified obj rot   x y z %f %f %f", object_rot.x() % object_rot.y() % object_rot.z());
+    double bboxRadius = bbox.diagonal ().norm () / 2;
+    double radius = (bbox.center () + object_trans).norm () + bboxRadius;
+    this->viewer_distance = radius / sin_degrees (this->fov / 2);
+    PRINTDB ("modified obj trans x y z %f %f %f", object_trans.x () % object_trans.y () % object_trans.z ());
+    PRINTDB ("modified obj rot   x y z %f %f %f", object_rot.x () % object_rot.y () % object_rot.z ());
   }
 }
 
-void Camera::zoom(int zoom, bool relative)
-{
+void Camera::zoom (int zoom, bool relative) {
   if (relative) {
-    this->viewer_distance *= pow(0.9, zoom / 120.0);
+    this->viewer_distance *= pow (0.9, zoom / 120.0);
   } else {
     this->viewer_distance = zoom;
   }
 }
 
-void Camera::setProjection(ProjectionType type)
-{
+void Camera::setProjection (ProjectionType type) {
   this->projection = type;
 }
 
-void Camera::resetView()
-{
-  setVpr(55, 0, 25); // set in user space units
-  setVpt(0, 0, 0);
-  setVpd(DEFAULT_DISTANCE);
-  setVpf(DEFAULT_FOV);
+void Camera::resetView () {
+  setVpr (55, 0, 25); // set in user space units
+  setVpt (0, 0, 0);
+  setVpd (DEFAULT_DISTANCE);
+  setVpf (DEFAULT_FOV);
 }
 
 /*!
@@ -102,111 +97,99 @@ void Camera::resetView()
  * are assigned on top-level, the values are used to change the camera
  * rotation, translation and distance.
  */
-void Camera::updateView(const std::shared_ptr<const FileContext>& context, bool enableWarning)
-{
-  if (locked) return;
+void Camera::updateView (const std::shared_ptr<const FileContext> &context, bool enableWarning) {
+  if (locked)
+    return;
 
   bool noauto = false;
   double x, y, z;
-  const auto vpr = context->lookup_local_variable("$vpr");
+  const auto vpr = context->lookup_local_variable ("$vpr");
   if (vpr) {
-    if (vpr->getVec3(x, y, z, 0.0)) {
-      setVpr(x, y, z);
+    if (vpr->getVec3 (x, y, z, 0.0)) {
+      setVpr (x, y, z);
       noauto = true;
     } else {
-      LOG(message_group::Warning, "Unable to convert $vpr=%1$s to a vec3 or vec2 of numbers", vpr->toEchoString());
+      LOG (message_group::Warning, "Unable to convert $vpr=%1$s to a vec3 or vec2 of numbers", vpr->toEchoString ());
     }
   }
 
-  const auto vpt = context->lookup_local_variable("$vpt");
+  const auto vpt = context->lookup_local_variable ("$vpt");
   if (vpt) {
-    if (vpt->getVec3(x, y, z, 0.0)) {
-      setVpt(x, y, z);
+    if (vpt->getVec3 (x, y, z, 0.0)) {
+      setVpt (x, y, z);
       noauto = true;
     } else {
-      LOG(message_group::Warning, "Unable to convert $vpt=%1$s to a vec3 or vec2 of numbers", vpt->toEchoString());
+      LOG (message_group::Warning, "Unable to convert $vpt=%1$s to a vec3 or vec2 of numbers", vpt->toEchoString ());
     }
   }
 
-  const auto vpd = context->lookup_local_variable("$vpd");
+  const auto vpd = context->lookup_local_variable ("$vpd");
   if (vpd) {
-    if (vpd->type() == Value::Type::NUMBER) {
-      setVpd(vpd->toDouble());
+    if (vpd->type () == Value::Type::NUMBER) {
+      setVpd (vpd->toDouble ());
       noauto = true;
     } else {
-      LOG(message_group::Warning, "Unable to convert $vpd=%1$s to a number", vpd->toEchoString());
+      LOG (message_group::Warning, "Unable to convert $vpd=%1$s to a number", vpd->toEchoString ());
     }
   }
 
-  const auto vpf = context->lookup_local_variable("$vpf");
+  const auto vpf = context->lookup_local_variable ("$vpf");
   if (vpf) {
-    if (vpf->type() == Value::Type::NUMBER) {
-      setVpf(vpf->toDouble());
+    if (vpf->type () == Value::Type::NUMBER) {
+      setVpf (vpf->toDouble ());
       noauto = true;
     } else {
-      LOG(message_group::Warning, "Unable to convert $vpf=%1$s to a number", vpf->toEchoString());
+      LOG (message_group::Warning, "Unable to convert $vpf=%1$s to a number", vpf->toEchoString ());
     }
   }
 
   if (enableWarning && (viewall || autocenter) && noauto) {
-    LOG(message_group::UI_Warning, "Viewall and autocenter disabled in favor of $vp*");
+    LOG (message_group::UI_Warning, "Viewall and autocenter disabled in favor of $vp*");
     viewall = false;
     autocenter = false;
   }
 }
 
-Eigen::Vector3d Camera::getVpt() const
-{
+Eigen::Vector3d Camera::getVpt () const {
   return -object_trans;
 }
 
-void Camera::setVpt(double x, double y, double z)
-{
+void Camera::setVpt (double x, double y, double z) {
   object_trans << -x, -y, -z;
 }
 
-static double wrap(double angle)
-{
-  return fmod(360.0 + angle, 360.0); // force angle to be 0-360
+static double wrap (double angle) {
+  return fmod (360.0 + angle, 360.0); // force angle to be 0-360
 }
 
-Eigen::Vector3d Camera::getVpr() const
-{
-  return {wrap(90 - object_rot.x()), wrap(-object_rot.y()), wrap(-object_rot.z())};
+Eigen::Vector3d Camera::getVpr () const {
+  return {wrap (90 - object_rot.x ()), wrap (-object_rot.y ()), wrap (-object_rot.z ())};
 }
 
-void Camera::setVpr(double x, double y, double z)
-{
-  object_rot << wrap(90 - x), wrap(-y), wrap(-z);
+void Camera::setVpr (double x, double y, double z) {
+  object_rot << wrap (90 - x), wrap (-y), wrap (-z);
 }
 
-void Camera::setVpd(double d)
-{
+void Camera::setVpd (double d) {
   viewer_distance = d;
 }
 
-double Camera::zoomValue() const
-{
+double Camera::zoomValue () const {
   return viewer_distance;
 }
 
-void Camera::setVpf(double f)
-{
+void Camera::setVpf (double f) {
   fov = f;
 }
 
-double Camera::fovValue() const
-{
+double Camera::fovValue () const {
   return fov;
 }
 
-std::string Camera::statusText() const
-{
-  const auto vpt = getVpt();
-  const auto vpr = getVpr();
-  boost::format fmt(_("Viewport: translate = [ %.2f %.2f %.2f ], rotate = [ %.2f %.2f %.2f ], distance = %.2f, fov = %.2f"));
-  fmt % vpt.x() % vpt.y() % vpt.z()
-  % vpr.x() % vpr.y() % vpr.z()
-  % viewer_distance % fov;
-  return fmt.str();
+std::string Camera::statusText () const {
+  const auto vpt = getVpt ();
+  const auto vpr = getVpr ();
+  boost::format fmt (_ ("Viewport: translate = [ %.2f %.2f %.2f ], rotate = [ %.2f %.2f %.2f ], distance = %.2f, fov = %.2f"));
+  fmt % vpt.x () % vpt.y () % vpt.z () % vpr.x () % vpr.y () % vpr.z () % viewer_distance % fov;
+  return fmt.str ();
 }
diff --git a/src/glview/Camera.h b/src/glview/Camera.h
index 1d76b53c2..e934ca20d 100644
--- a/src/glview/Camera.h
+++ b/src/glview/Camera.h
@@ -26,26 +26,27 @@
 class Camera
 {
 public:
-  enum class ProjectionType { ORTHOGONAL, PERSPECTIVE } projection{ProjectionType::PERSPECTIVE};
-  Camera();
-  void setup(std::vector<double> params);
-  void gimbalDefaultTranslate();
-  void setProjection(ProjectionType type);
-  void zoom(int delta, bool relative);
-  [[nodiscard]] double zoomValue() const;
-  [[nodiscard]] double fovValue() const;
-  void resetView();
-  void updateView(const std::shared_ptr<const class FileContext>& context, bool enableWarning);
-  void viewAll(const BoundingBox& bbox);
-  [[nodiscard]] std::string statusText() const;
+  enum class ProjectionType { ORTHOGONAL,
+                              PERSPECTIVE } projection{ProjectionType::PERSPECTIVE};
+  Camera ();
+  void setup (std::vector<double> params);
+  void gimbalDefaultTranslate ();
+  void setProjection (ProjectionType type);
+  void zoom (int delta, bool relative);
+  [[nodiscard]] double zoomValue () const;
+  [[nodiscard]] double fovValue () const;
+  void resetView ();
+  void updateView (const std::shared_ptr<const class FileContext> &context, bool enableWarning);
+  void viewAll (const BoundingBox &bbox);
+  [[nodiscard]] std::string statusText () const;
 
   // accessors to get and set camera settings in the user space format (different for historical reasons)
-  [[nodiscard]] Eigen::Vector3d getVpt() const;
-  void setVpt(double x, double y, double z);
-  [[nodiscard]] Eigen::Vector3d getVpr() const;
-  void setVpr(double x, double y, double z);
-  void setVpd(double d);
-  void setVpf(double d);
+  [[nodiscard]] Eigen::Vector3d getVpt () const;
+  void setVpt (double x, double y, double z);
+  [[nodiscard]] Eigen::Vector3d getVpr () const;
+  void setVpr (double x, double y, double z);
+  void setVpd (double d);
+  void setVpf (double d);
 
   // Gimbalcam
   Eigen::Vector3d object_trans;
diff --git a/src/glview/ColorMap.cc b/src/glview/ColorMap.cc
index 181ae5bb6..54638be55 100644
--- a/src/glview/ColorMap.cc
+++ b/src/glview/ColorMap.cc
@@ -18,117 +18,107 @@ namespace fs = std::filesystem;
 
 static const char *DEFAULT_COLOR_SCHEME_NAME = "Cornfield";
 
-RenderColorScheme::RenderColorScheme() : _path("")
-{
+RenderColorScheme::RenderColorScheme ()
+  : _path ("") {
   _name = DEFAULT_COLOR_SCHEME_NAME;
   _index = 1000;
   _show_in_gui = true;
 
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::BACKGROUND_COLOR, Color4f(0xff, 0xff, 0xe5)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::BACKGROUND_STOP_COLOR, Color4f(0xff, 0xff, 0xe5)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::AXES_COLOR, Color4f(0x00, 0x00, 0x00)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::OPENCSG_FACE_FRONT_COLOR, Color4f(0xf9, 0xd7, 0x2c)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::OPENCSG_FACE_BACK_COLOR, Color4f(0x9d, 0xcb, 0x51)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::CGAL_FACE_FRONT_COLOR, Color4f(0xf9, 0xd7, 0x2c)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::CGAL_FACE_2D_COLOR, Color4f(0x00, 0xbf, 0x99)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::CGAL_FACE_BACK_COLOR, Color4f(0x9d, 0xcb, 0x51)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::CGAL_EDGE_FRONT_COLOR, Color4f(0xff, 0xec, 0x5e)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::CGAL_EDGE_BACK_COLOR, Color4f(0xab, 0xd8, 0x56)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::CGAL_EDGE_2D_COLOR, Color4f(0xff, 0x00, 0x00)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::CROSSHAIR_COLOR, Color4f(0x80, 0x00, 0x00)));
-}
-
-RenderColorScheme::RenderColorScheme(const fs::path& path) : _path(path)
-{
+  _color_scheme.insert (ColorScheme::value_type (RenderColor::BACKGROUND_COLOR, Color4f (0xff, 0xff, 0xe5)));
+  _color_scheme.insert (ColorScheme::value_type (RenderColor::BACKGROUND_STOP_COLOR, Color4f (0xff, 0xff, 0xe5)));
+  _color_scheme.insert (ColorScheme::value_type (RenderColor::AXES_COLOR, Color4f (0x00, 0x00, 0x00)));
+  _color_scheme.insert (ColorScheme::value_type (RenderColor::OPENCSG_FACE_FRONT_COLOR, Color4f (0xf9, 0xd7, 0x2c)));
+  _color_scheme.insert (ColorScheme::value_type (RenderColor::OPENCSG_FACE_BACK_COLOR, Color4f (0x9d, 0xcb, 0x51)));
+  _color_scheme.insert (ColorScheme::value_type (RenderColor::CGAL_FACE_FRONT_COLOR, Color4f (0xf9, 0xd7, 0x2c)));
+  _color_scheme.insert (ColorScheme::value_type (RenderColor::CGAL_FACE_2D_COLOR, Color4f (0x00, 0xbf, 0x99)));
+  _color_scheme.insert (ColorScheme::value_type (RenderColor::CGAL_FACE_BACK_COLOR, Color4f (0x9d, 0xcb, 0x51)));
+  _color_scheme.insert (ColorScheme::value_type (RenderColor::CGAL_EDGE_FRONT_COLOR, Color4f (0xff, 0xec, 0x5e)));
+  _color_scheme.insert (ColorScheme::value_type (RenderColor::CGAL_EDGE_BACK_COLOR, Color4f (0xab, 0xd8, 0x56)));
+  _color_scheme.insert (ColorScheme::value_type (RenderColor::CGAL_EDGE_2D_COLOR, Color4f (0xff, 0x00, 0x00)));
+  _color_scheme.insert (ColorScheme::value_type (RenderColor::CROSSHAIR_COLOR, Color4f (0x80, 0x00, 0x00)));
+}
+
+RenderColorScheme::RenderColorScheme (const fs::path &path)
+  : _path (path) {
   try {
-    boost::property_tree::read_json(path.generic_string().c_str(), pt);
-    _name = pt.get<std::string>("name");
-    _index = pt.get<int>("index");
-    _show_in_gui = pt.get<bool>("show-in-gui");
-
-    addColor(RenderColor::BACKGROUND_COLOR, "background");
-    addColor(RenderColor::AXES_COLOR, "axes-color");
-    addColor(RenderColor::OPENCSG_FACE_FRONT_COLOR, "opencsg-face-front");
-    addColor(RenderColor::OPENCSG_FACE_BACK_COLOR, "opencsg-face-back");
-    addColor(RenderColor::CGAL_FACE_FRONT_COLOR, "cgal-face-front");
-    addColor(RenderColor::CGAL_FACE_2D_COLOR, "cgal-face-2d");
-    addColor(RenderColor::CGAL_FACE_BACK_COLOR, "cgal-face-back");
-    addColor(RenderColor::CGAL_EDGE_FRONT_COLOR, "cgal-edge-front");
-    addColor(RenderColor::CGAL_EDGE_BACK_COLOR, "cgal-edge-back");
-    addColor(RenderColor::CGAL_EDGE_2D_COLOR, "cgal-edge-2d");
-    addColor(RenderColor::CROSSHAIR_COLOR, "crosshair");
-    try{
-      addColor(RenderColor::BACKGROUND_STOP_COLOR, "background-stop");
-    } catch (const std::exception& e) {
-      addColor(RenderColor::BACKGROUND_STOP_COLOR, "background");
+    boost::property_tree::read_json (path.generic_string ().c_str (), pt);
+    _name = pt.get<std::string> ("name");
+    _index = pt.get<int> ("index");
+    _show_in_gui = pt.get<bool> ("show-in-gui");
+
+    addColor (RenderColor::BACKGROUND_COLOR, "background");
+    addColor (RenderColor::AXES_COLOR, "axes-color");
+    addColor (RenderColor::OPENCSG_FACE_FRONT_COLOR, "opencsg-face-front");
+    addColor (RenderColor::OPENCSG_FACE_BACK_COLOR, "opencsg-face-back");
+    addColor (RenderColor::CGAL_FACE_FRONT_COLOR, "cgal-face-front");
+    addColor (RenderColor::CGAL_FACE_2D_COLOR, "cgal-face-2d");
+    addColor (RenderColor::CGAL_FACE_BACK_COLOR, "cgal-face-back");
+    addColor (RenderColor::CGAL_EDGE_FRONT_COLOR, "cgal-edge-front");
+    addColor (RenderColor::CGAL_EDGE_BACK_COLOR, "cgal-edge-back");
+    addColor (RenderColor::CGAL_EDGE_2D_COLOR, "cgal-edge-2d");
+    addColor (RenderColor::CROSSHAIR_COLOR, "crosshair");
+    try {
+      addColor (RenderColor::BACKGROUND_STOP_COLOR, "background-stop");
+    } catch (const std::exception &e) {
+      addColor (RenderColor::BACKGROUND_STOP_COLOR, "background");
     }
-  } catch (const std::exception& e) {
-    LOG("Error reading color scheme file: '%1$s': %2$s", path.generic_string().c_str(), e.what());
-    _error = e.what();
+  } catch (const std::exception &e) {
+    LOG ("Error reading color scheme file: '%1$s': %2$s", path.generic_string ().c_str (), e.what ());
+    _error = e.what ();
     _name = "";
     _index = 0;
     _show_in_gui = false;
   }
 }
 
-bool RenderColorScheme::valid() const
-{
-  return !_name.empty();
+bool RenderColorScheme::valid () const {
+  return !_name.empty ();
 }
 
-const std::string& RenderColorScheme::name() const
-{
+const std::string &RenderColorScheme::name () const {
   return _name;
 }
 
-int RenderColorScheme::index() const
-{
+int RenderColorScheme::index () const {
   return _index;
 }
 
-bool RenderColorScheme::showInGui() const
-{
+bool RenderColorScheme::showInGui () const {
   return _show_in_gui;
 }
 
-std::string RenderColorScheme::path() const
-{
-  return _path.string();
+std::string RenderColorScheme::path () const {
+  return _path.string ();
 }
 
-std::string RenderColorScheme::error() const
-{
+std::string RenderColorScheme::error () const {
   return _error;
 }
 
-ColorScheme& RenderColorScheme::colorScheme()
-{
+ColorScheme &RenderColorScheme::colorScheme () {
   return _color_scheme;
 }
 
-const boost::property_tree::ptree& RenderColorScheme::propertyTree() const
-{
+const boost::property_tree::ptree &RenderColorScheme::propertyTree () const {
   return pt;
 }
 
-void RenderColorScheme::addColor(RenderColor colorKey, const std::string& key)
-{
-  const boost::property_tree::ptree& colors = pt.get_child("colors");
-  auto color = colors.get<std::string>(key);
-  if ((color.length() == 7) && (color.at(0) == '#')) {
+void RenderColorScheme::addColor (RenderColor colorKey, const std::string &key) {
+  const boost::property_tree::ptree &colors = pt.get_child ("colors");
+  auto color = colors.get<std::string> (key);
+  if ((color.length () == 7) && (color.at (0) == '#')) {
     char *endptr;
-    unsigned int val = strtol(color.substr(1).c_str(), &endptr, 16);
+    unsigned int val = strtol (color.substr (1).c_str (), &endptr, 16);
     int r = (val >> 16) & 0xff;
     int g = (val >> 8) & 0xff;
     int b = val & 0xff;
-    _color_scheme.insert(ColorScheme::value_type(colorKey, Color4f(r, g, b)));
+    _color_scheme.insert (ColorScheme::value_type (colorKey, Color4f (r, g, b)));
   } else {
-    throw std::invalid_argument(std::string("invalid color value for key '") + key + "': '" + color + "'");
+    throw std::invalid_argument (std::string ("invalid color value for key '") + key + "': '" + color + "'");
   }
 }
 
-ColorMap *ColorMap::inst(bool erase)
-{
+ColorMap *ColorMap::inst (bool erase) {
   static auto *instance = new ColorMap;
   if (erase) {
     delete instance;
@@ -137,116 +127,109 @@ ColorMap *ColorMap::inst(bool erase)
   return instance;
 }
 
-ColorMap::ColorMap()
-{
-  colorSchemeSet = enumerateColorSchemes();
-  dump();
+ColorMap::ColorMap () {
+  colorSchemeSet = enumerateColorSchemes ();
+  dump ();
 }
 
-const char *ColorMap::defaultColorSchemeName() const
-{
+const char *ColorMap::defaultColorSchemeName () const {
   return DEFAULT_COLOR_SCHEME_NAME;
 }
 
-const ColorScheme& ColorMap::defaultColorScheme() const
-{
-  return *findColorScheme(DEFAULT_COLOR_SCHEME_NAME);
+const ColorScheme &ColorMap::defaultColorScheme () const {
+  return *findColorScheme (DEFAULT_COLOR_SCHEME_NAME);
 }
 
-const ColorScheme *ColorMap::findColorScheme(const std::string& name) const
-{
-  for (const auto& item : colorSchemeSet) {
-    RenderColorScheme *scheme = item.second.get();
-    if (name == scheme->name()) {
-      return &scheme->colorScheme();
+const ColorScheme *ColorMap::findColorScheme (const std::string &name) const {
+  for (const auto &item : colorSchemeSet) {
+    RenderColorScheme *scheme = item.second.get ();
+    if (name == scheme->name ()) {
+      return &scheme->colorScheme ();
     }
   }
   return nullptr;
 }
 
-void ColorMap::dump() const
-{
-  PRINTD("Listing available color schemes...");
+void ColorMap::dump () const {
+  PRINTD ("Listing available color schemes...");
 
-  std::list<std::string> names = colorSchemeNames();
+  std::list<std::string> names = colorSchemeNames ();
   unsigned int length = 0;
-  for (const auto& name : names) {
-    length = name.length() > length ? name.length() : length;
+  for (const auto &name : names) {
+    length = name.length () > length ? name.length () : length;
   }
 
-  for (const auto& item : colorSchemeSet) {
-    const RenderColorScheme *cs = item.second.get();
-    const char gui = cs->showInGui() ? 'G' : '-';
-    if (cs->path().empty()) {
-      PRINTDB("%6d:%c: %s (built-in)", cs->index() % gui % boost::io::group(std::setw(length), cs->name()));
+  for (const auto &item : colorSchemeSet) {
+    const RenderColorScheme *cs = item.second.get ();
+    const char gui = cs->showInGui () ? 'G' : '-';
+    if (cs->path ().empty ()) {
+      PRINTDB ("%6d:%c: %s (built-in)", cs->index () % gui % boost::io::group (std::setw (length), cs->name ()));
     } else {
-      PRINTDB("%6d:%c: %s from %s", cs->index() % gui % boost::io::group(std::setw(length), cs->name()) % cs->path());
+      PRINTDB ("%6d:%c: %s from %s", cs->index () % gui % boost::io::group (std::setw (length), cs->name ()) % cs->path ());
     }
   }
-  PRINTD("done.");
+  PRINTD ("done.");
 }
 
-std::list<std::string> ColorMap::colorSchemeNames(bool guiOnly) const
-{
+std::list<std::string> ColorMap::colorSchemeNames (bool guiOnly) const {
   std::list<std::string> colorSchemeNames;
-  for (const auto& item : colorSchemeSet) {
-    const RenderColorScheme *scheme = item.second.get();
-    if (guiOnly && !scheme->showInGui()) {
+  for (const auto &item : colorSchemeSet) {
+    const RenderColorScheme *scheme = item.second.get ();
+    if (guiOnly && !scheme->showInGui ()) {
       continue;
     }
-    colorSchemeNames.push_back(scheme->name());
+    colorSchemeNames.push_back (scheme->name ());
   }
   return colorSchemeNames;
 }
 
-Color4f ColorMap::getColor(const ColorScheme& cs, const RenderColor rc)
-{
-  if (cs.count(rc)) return cs.at(rc);
-  if (ColorMap::inst()->defaultColorScheme().count(rc)) return ColorMap::inst()->defaultColorScheme().at(rc);
+Color4f ColorMap::getColor (const ColorScheme &cs, const RenderColor rc) {
+  if (cs.count (rc))
+    return cs.at (rc);
+  if (ColorMap::inst ()->defaultColorScheme ().count (rc))
+    return ColorMap::inst ()->defaultColorScheme ().at (rc);
   return {0, 0, 0, 127};
 }
 
-void ColorMap::enumerateColorSchemesInPath(colorscheme_set_t& result_set, const fs::path& basePath)
-{
+void ColorMap::enumerateColorSchemesInPath (colorscheme_set_t &result_set, const fs::path &basePath) {
   const fs::path color_schemes = basePath / "color-schemes" / "render";
 
-  PRINTDB("Enumerating color schemes from '%s'", color_schemes.generic_string().c_str());
+  PRINTDB ("Enumerating color schemes from '%s'", color_schemes.generic_string ().c_str ());
 
   fs::directory_iterator end_iter;
 
-  if (fs::exists(color_schemes) && fs::is_directory(color_schemes)) {
-    for (fs::directory_iterator dir_iter(color_schemes); dir_iter != end_iter; ++dir_iter) {
-      if (!fs::is_regular_file(dir_iter->status())) {
+  if (fs::exists (color_schemes) && fs::is_directory (color_schemes)) {
+    for (fs::directory_iterator dir_iter (color_schemes); dir_iter != end_iter; ++dir_iter) {
+      if (!fs::is_regular_file (dir_iter->status ())) {
         continue;
       }
 
-      const fs::path path = (*dir_iter).path();
-      if (!(path.extension() == ".json")) {
+      const fs::path path = (*dir_iter).path ();
+      if (!(path.extension () == ".json")) {
         continue;
       }
 
-      auto *colorScheme = new RenderColorScheme(path);
-      if (colorScheme->valid() && (findColorScheme(colorScheme->name()) == nullptr)) {
-        result_set.insert(colorscheme_set_t::value_type(colorScheme->index(), std::shared_ptr<RenderColorScheme>(colorScheme)));
-        PRINTDB("Found file '%s' with color scheme '%s' and index %d",
-                colorScheme->path() % colorScheme->name() % colorScheme->index());
+      auto *colorScheme = new RenderColorScheme (path);
+      if (colorScheme->valid () && (findColorScheme (colorScheme->name ()) == nullptr)) {
+        result_set.insert (colorscheme_set_t::value_type (colorScheme->index (), std::shared_ptr<RenderColorScheme> (colorScheme)));
+        PRINTDB ("Found file '%s' with color scheme '%s' and index %d",
+                 colorScheme->path () % colorScheme->name () % colorScheme->index ());
       } else {
-        PRINTDB("Invalid file '%s': %s", colorScheme->path() % colorScheme->error());
+        PRINTDB ("Invalid file '%s': %s", colorScheme->path () % colorScheme->error ());
         delete colorScheme;
       }
     }
   }
 }
 
-ColorMap::colorscheme_set_t ColorMap::enumerateColorSchemes()
-{
+ColorMap::colorscheme_set_t ColorMap::enumerateColorSchemes () {
   colorscheme_set_t result_set;
 
-  auto *defaultColorScheme = new RenderColorScheme();
-  result_set.insert(colorscheme_set_t::value_type(defaultColorScheme->index(),
-                                                  std::shared_ptr<RenderColorScheme>(defaultColorScheme)));
-  enumerateColorSchemesInPath(result_set, PlatformUtils::resourceBasePath());
-  enumerateColorSchemesInPath(result_set, PlatformUtils::userConfigPath());
+  auto *defaultColorScheme = new RenderColorScheme ();
+  result_set.insert (colorscheme_set_t::value_type (defaultColorScheme->index (),
+                                                    std::shared_ptr<RenderColorScheme> (defaultColorScheme)));
+  enumerateColorSchemesInPath (result_set, PlatformUtils::resourceBasePath ());
+  enumerateColorSchemesInPath (result_set, PlatformUtils::userConfigPath ());
 
   return result_set;
 }
diff --git a/src/glview/ColorMap.h b/src/glview/ColorMap.h
index 90ed649f0..328d8a245 100644
--- a/src/glview/ColorMap.h
+++ b/src/glview/ColorMap.h
@@ -48,24 +48,24 @@ public:
   /**
    * Constructor for the default color scheme Cornfield.
    */
-  RenderColorScheme();
+  RenderColorScheme ();
   /**
    * Constructor for reading external JSON files.
    */
-  RenderColorScheme(const fs::path& path);
-  virtual ~RenderColorScheme() = default;
+  RenderColorScheme (const fs::path &path);
+  virtual ~RenderColorScheme () = default;
 
-  [[nodiscard]] const std::string& name() const;
-  [[nodiscard]] int index() const;
-  [[nodiscard]] bool valid() const;
-  [[nodiscard]] bool showInGui() const;
-  ColorScheme& colorScheme();
-  [[nodiscard]] const boost::property_tree::ptree& propertyTree() const;
+  [[nodiscard]] const std::string &name () const;
+  [[nodiscard]] int index () const;
+  [[nodiscard]] bool valid () const;
+  [[nodiscard]] bool showInGui () const;
+  ColorScheme &colorScheme ();
+  [[nodiscard]] const boost::property_tree::ptree &propertyTree () const;
 
 private:
-  [[nodiscard]] std::string path() const;
-  [[nodiscard]] std::string error() const;
-  void addColor(RenderColor colorKey, const std::string& key);
+  [[nodiscard]] std::string path () const;
+  [[nodiscard]] std::string error () const;
+  void addColor (RenderColor colorKey, const std::string &key);
 
   friend class ColorMap;
 };
@@ -75,22 +75,22 @@ class ColorMap
   using colorscheme_set_t = std::multimap<int, std::shared_ptr<RenderColorScheme>, std::less<>>;
 
 public:
-  static ColorMap *inst(bool erase = false);
+  static ColorMap *inst (bool erase = false);
 
-  [[nodiscard]] const char *defaultColorSchemeName() const;
-  [[nodiscard]] const ColorScheme& defaultColorScheme() const;
-  [[nodiscard]] const ColorScheme *findColorScheme(const std::string& name) const;
-  [[nodiscard]] std::list<std::string> colorSchemeNames(bool guiOnly = false) const;
+  [[nodiscard]] const char *defaultColorSchemeName () const;
+  [[nodiscard]] const ColorScheme &defaultColorScheme () const;
+  [[nodiscard]] const ColorScheme *findColorScheme (const std::string &name) const;
+  [[nodiscard]] std::list<std::string> colorSchemeNames (bool guiOnly = false) const;
 
-  static Color4f getColor(const ColorScheme& cs, const RenderColor rc);
-  static Color4f getContrastColor(const Color4f& col);
-  static Color4f getColorHSV(const Color4f& col);
+  static Color4f getColor (const ColorScheme &cs, const RenderColor rc);
+  static Color4f getContrastColor (const Color4f &col);
+  static Color4f getColorHSV (const Color4f &col);
 
 private:
-  ColorMap();
-  virtual ~ColorMap() = default;
-  void dump() const;
-  colorscheme_set_t enumerateColorSchemes();
-  void enumerateColorSchemesInPath(colorscheme_set_t& result_set, const fs::path& path);
+  ColorMap ();
+  virtual ~ColorMap () = default;
+  void dump () const;
+  colorscheme_set_t enumerateColorSchemes ();
+  void enumerateColorSchemesInPath (colorscheme_set_t &result_set, const fs::path &path);
   colorscheme_set_t colorSchemeSet;
 };
diff --git a/src/glview/CsgInfo.h b/src/glview/CsgInfo.h
index 6fd180ca1..437909a41 100644
--- a/src/glview/CsgInfo.h
+++ b/src/glview/CsgInfo.h
@@ -11,55 +11,54 @@
 #include "glview/RenderSettings.h"
 #include "utils/printutils.h"
 
-
 /*
    Small helper class for compiling and normalizing node trees into CSG products
  */
 class CsgInfo
 {
 public:
-  CsgInfo() = default;
+  CsgInfo () = default;
   std::shared_ptr<class CSGProducts> root_products;
   std::shared_ptr<CSGProducts> highlights_products;
   std::shared_ptr<CSGProducts> background_products;
 
-  bool compile_products(const Tree& tree) {
-    auto& root_node = tree.root();
-    GeometryEvaluator geomevaluator(tree);
-    CSGTreeEvaluator evaluator(tree, &geomevaluator);
-    const std::shared_ptr<CSGNode> csgRoot = evaluator.buildCSGTree(*root_node);
-    std::vector<std::shared_ptr<CSGNode>> highlightNodes = evaluator.getHighlightNodes();
-    std::vector<std::shared_ptr<CSGNode>> backgroundNodes = evaluator.getBackgroundNodes();
+  bool compile_products (const Tree &tree) {
+    auto &root_node = tree.root ();
+    GeometryEvaluator geomevaluator (tree);
+    CSGTreeEvaluator evaluator (tree, &geomevaluator);
+    const std::shared_ptr<CSGNode> csgRoot = evaluator.buildCSGTree (*root_node);
+    std::vector<std::shared_ptr<CSGNode>> highlightNodes = evaluator.getHighlightNodes ();
+    std::vector<std::shared_ptr<CSGNode>> backgroundNodes = evaluator.getBackgroundNodes ();
 
-    LOG("Compiling design (CSG Products normalization)...");
-    CSGTreeNormalizer normalizer(RenderSettings::inst()->openCSGTermLimit);
+    LOG ("Compiling design (CSG Products normalization)...");
+    CSGTreeNormalizer normalizer (RenderSettings::inst ()->openCSGTermLimit);
     if (csgRoot) {
-      const std::shared_ptr<CSGNode> normalizedRoot = normalizer.normalize(csgRoot);
+      const std::shared_ptr<CSGNode> normalizedRoot = normalizer.normalize (csgRoot);
       if (normalizedRoot) {
-        this->root_products = std::make_shared<CSGProducts>();
-        this->root_products->import(normalizedRoot);
-        LOG("Normalized CSG tree has %1$d elements", int(this->root_products->size()));
+        this->root_products = std::make_shared<CSGProducts> ();
+        this->root_products->import (normalizedRoot);
+        LOG ("Normalized CSG tree has %1$d elements", int (this->root_products->size ()));
       } else {
-        this->root_products.reset();
-        LOG(message_group::Warning, "CSG normalization resulted in an empty tree");
+        this->root_products.reset ();
+        LOG (message_group::Warning, "CSG normalization resulted in an empty tree");
       }
     }
 
-    if (highlightNodes.size() > 0) {
-      LOG("Compiling highlights (%1$i CSG Trees)...", highlightNodes.size());
-      this->highlights_products = std::make_shared<CSGProducts>();
-      for (auto& highlightNode : highlightNodes) {
-        highlightNode = normalizer.normalize(highlightNode);
-        this->highlights_products->import(highlightNode);
+    if (highlightNodes.size () > 0) {
+      LOG ("Compiling highlights (%1$i CSG Trees)...", highlightNodes.size ());
+      this->highlights_products = std::make_shared<CSGProducts> ();
+      for (auto &highlightNode : highlightNodes) {
+        highlightNode = normalizer.normalize (highlightNode);
+        this->highlights_products->import (highlightNode);
       }
     }
 
-    if (backgroundNodes.size() > 0) {
-      LOG("Compiling background (%1$i CSG Trees)...", backgroundNodes.size());
-      this->background_products = std::make_shared<CSGProducts>();
-      for (auto& backgroundNode : backgroundNodes) {
-        backgroundNode = normalizer.normalize(backgroundNode);
-        this->background_products->import(backgroundNode);
+    if (backgroundNodes.size () > 0) {
+      LOG ("Compiling background (%1$i CSG Trees)...", backgroundNodes.size ());
+      this->background_products = std::make_shared<CSGProducts> ();
+      for (auto &backgroundNode : backgroundNodes) {
+        backgroundNode = normalizer.normalize (backgroundNode);
+        this->background_products->import (backgroundNode);
       }
     }
     return true;
diff --git a/src/glview/GLView.cc b/src/glview/GLView.cc
index fb133f138..36d8faa19 100644
--- a/src/glview/GLView.cc
+++ b/src/glview/GLView.cc
@@ -18,16 +18,15 @@
 #include <opencsg.h>
 #endif
 
-GLView::GLView()
-{
+GLView::GLView () {
   aspectratio = 1;
   showedges = false;
   showaxes = false;
   showcrosshairs = false;
   showscale = false;
-  colorscheme = &ColorMap::inst()->defaultColorScheme();
-  cam = Camera();
-  far_far_away = RenderSettings::inst()->far_gl_clip_limit;
+  colorscheme = &ColorMap::inst ()->defaultColorScheme ();
+  cam = Camera ();
+  far_far_away = RenderSettings::inst ()->far_gl_clip_limit;
 #ifdef ENABLE_OPENCSG
   is_opencsg_capable = false;
   has_shaders = false;
@@ -36,190 +35,187 @@ GLView::GLView()
 #endif
 }
 
-GLView::~GLView()
-{
-  teardownShader();
+GLView::~GLView () {
+  teardownShader ();
 }
 
-void GLView::setupShader() {
-  if (edge_shader) return;
+void GLView::setupShader () {
+  if (edge_shader)
+    return;
 
-  auto resource = ShaderUtils::compileShaderProgram(ShaderUtils::loadShaderSource("ViewEdges.vert"),
-                                                    ShaderUtils::loadShaderSource("ViewEdges.frag"));
+  auto resource = ShaderUtils::compileShaderProgram (ShaderUtils::loadShaderSource ("ViewEdges.vert"),
+                                                     ShaderUtils::loadShaderSource ("ViewEdges.frag"));
 
-  edge_shader = std::make_unique<ShaderUtils::ShaderInfo>(ShaderUtils::ShaderInfo{
+  edge_shader = std::make_unique<ShaderUtils::ShaderInfo> (ShaderUtils::ShaderInfo{
     .resource = resource,
     .type = ShaderUtils::ShaderType::EDGE_RENDERING,
-    .uniforms = {
-    },
+    .uniforms = {},
     .attributes = {
-      {"barycentric", glGetAttribLocation(resource.shader_program, "barycentric")},
+      {"barycentric", glGetAttribLocation (resource.shader_program, "barycentric")},
     },
   });
 }
 
-void GLView::teardownShader() {
-  if (edge_shader == nullptr) return; // if OpenGL context was not initialized
+void GLView::teardownShader () {
+  if (edge_shader == nullptr)
+    return; // if OpenGL context was not initialized
   if (edge_shader->resource.shader_program) {
-    glDeleteProgram(edge_shader->resource.shader_program);
+    glDeleteProgram (edge_shader->resource.shader_program);
   }
   if (edge_shader->resource.vertex_shader) {
-    glDeleteShader(edge_shader->resource.vertex_shader);
+    glDeleteShader (edge_shader->resource.vertex_shader);
   }
   if (edge_shader->resource.fragment_shader) {
-    glDeleteShader(edge_shader->resource.fragment_shader);
+    glDeleteShader (edge_shader->resource.fragment_shader);
   }
 }
 
-void GLView::setRenderer(std::shared_ptr<Renderer> r)
-{
+void GLView::setRenderer (std::shared_ptr<Renderer> r) {
   this->renderer = r;
 }
 
 /* update the color schemes of the Renderer attached to this GLView
    to match the colorscheme of this GLView.*/
-void GLView::updateColorScheme()
-{
-  if (this->renderer) this->renderer->setColorScheme(*this->colorscheme);
+void GLView::updateColorScheme () {
+  if (this->renderer)
+    this->renderer->setColorScheme (*this->colorscheme);
 }
 
 /* change this GLView's colorscheme to the one given, and update the
    Renderer attached to this GLView as well. */
-void GLView::setColorScheme(const ColorScheme& cs)
-{
+void GLView::setColorScheme (const ColorScheme &cs) {
   this->colorscheme = &cs;
-  this->updateColorScheme();
+  this->updateColorScheme ();
 }
 
-void GLView::setColorScheme(const std::string& cs)
-{
-  const auto colorscheme = ColorMap::inst()->findColorScheme(cs);
+void GLView::setColorScheme (const std::string &cs) {
+  const auto colorscheme = ColorMap::inst ()->findColorScheme (cs);
   if (colorscheme) {
-    setColorScheme(*colorscheme);
+    setColorScheme (*colorscheme);
   } else {
-    LOG(message_group::UI_Warning, "GLView: unknown colorscheme %1$s", cs);
+    LOG (message_group::UI_Warning, "GLView: unknown colorscheme %1$s", cs);
   }
 }
 
-void GLView::resizeGL(int w, int h)
-{
+void GLView::resizeGL (int w, int h) {
   cam.pixel_width = w;
   cam.pixel_height = h;
-  glViewport(0, 0, w, h);
+  glViewport (0, 0, w, h);
   aspectratio = 1.0 * w / h;
 
   // FIXME: Only run once, not every time the window is resized
-  setupShader();
+  setupShader ();
 }
 
-void GLView::setCamera(const Camera& cam)
-{
+void GLView::setCamera (const Camera &cam) {
   this->cam = cam;
 }
 
-void GLView::setupCamera()
-{
-  glMatrixMode(GL_PROJECTION);
-  glLoadIdentity();
-  auto dist = cam.zoomValue();
+void GLView::setupCamera () {
+  glMatrixMode (GL_PROJECTION);
+  glLoadIdentity ();
+  auto dist = cam.zoomValue ();
   switch (this->cam.projection) {
   case Camera::ProjectionType::PERSPECTIVE: {
-    gluPerspective(cam.fov, aspectratio, 0.1 * dist, 100 * dist);
+    gluPerspective (cam.fov, aspectratio, 0.1 * dist, 100 * dist);
     break;
   }
   default:
   case Camera::ProjectionType::ORTHOGONAL: {
-    auto height = dist * tan_degrees(cam.fov / 2);
-    glOrtho(-height * aspectratio, height * aspectratio,
-            -height, height,
-            -100 * dist, +100 * dist);
+    auto height = dist * tan_degrees (cam.fov / 2);
+    glOrtho (-height * aspectratio, height * aspectratio,
+             -height, height,
+             -100 * dist, +100 * dist);
     break;
   }
   }
-  glMatrixMode(GL_MODELVIEW);
-  glLoadIdentity();
-  gluLookAt(0.0, -dist, 0.0, // eye
-            0.0, 0.0,   0.0,// center
-            0.0, 0.0,   1.0);// up
-
-  glRotated(cam.object_rot.x(), 1.0, 0.0, 0.0);
-  glRotated(cam.object_rot.y(), 0.0, 1.0, 0.0);
-  glRotated(cam.object_rot.z(), 0.0, 0.0, 1.0);
-  glTranslated(cam.object_trans[0], cam.object_trans[1], cam.object_trans[2]); // translation be part of modelview matrix!
-  glGetDoublev(GL_MODELVIEW_MATRIX, this->modelview);
-  glTranslated(-cam.object_trans[0], -cam.object_trans[1], -cam.object_trans[2]);
-  glGetDoublev(GL_PROJECTION_MATRIX, this->projection);
+  glMatrixMode (GL_MODELVIEW);
+  glLoadIdentity ();
+  gluLookAt (0.0, -dist, 0.0, // eye
+             0.0, 0.0, 0.0, // center
+             0.0, 0.0, 1.0); // up
+
+  glRotated (cam.object_rot.x (), 1.0, 0.0, 0.0);
+  glRotated (cam.object_rot.y (), 0.0, 1.0, 0.0);
+  glRotated (cam.object_rot.z (), 0.0, 0.0, 1.0);
+  glTranslated (cam.object_trans[0], cam.object_trans[1], cam.object_trans[2]); // translation be part of modelview matrix!
+  glGetDoublev (GL_MODELVIEW_MATRIX, this->modelview);
+  glTranslated (-cam.object_trans[0], -cam.object_trans[1], -cam.object_trans[2]);
+  glGetDoublev (GL_PROJECTION_MATRIX, this->projection);
 }
 
-void GLView::paintGL()
-{
-  glDisable(GL_LIGHTING);
-  auto bgcol = ColorMap::getColor(*this->colorscheme, RenderColor::BACKGROUND_COLOR);
-  auto bgstopcol = ColorMap::getColor(*this->colorscheme, RenderColor::BACKGROUND_STOP_COLOR);
-  auto axescolor = ColorMap::getColor(*this->colorscheme, RenderColor::AXES_COLOR);
-  auto crosshaircol = ColorMap::getColor(*this->colorscheme, RenderColor::CROSSHAIR_COLOR);
+void GLView::paintGL () {
+  glDisable (GL_LIGHTING);
+  auto bgcol = ColorMap::getColor (*this->colorscheme, RenderColor::BACKGROUND_COLOR);
+  auto bgstopcol = ColorMap::getColor (*this->colorscheme, RenderColor::BACKGROUND_STOP_COLOR);
+  auto axescolor = ColorMap::getColor (*this->colorscheme, RenderColor::AXES_COLOR);
+  auto crosshaircol = ColorMap::getColor (*this->colorscheme, RenderColor::CROSSHAIR_COLOR);
 
-  glClearColor(bgcol.r(), bgcol.g(), bgcol.b(), 1.0);
-  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
+  glClearColor (bgcol.r (), bgcol.g (), bgcol.b (), 1.0);
+  glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
 
   if (bgcol != bgstopcol) {
-    glDisable(GL_DEPTH_TEST);
+    glDisable (GL_DEPTH_TEST);
 
-    glMatrixMode(GL_PROJECTION);
-    glLoadIdentity();
+    glMatrixMode (GL_PROJECTION);
+    glLoadIdentity ();
 
-    glMatrixMode(GL_MODELVIEW);
-    glLoadIdentity();
+    glMatrixMode (GL_MODELVIEW);
+    glLoadIdentity ();
 
     //draw screen aligned quad with color gradient
-    glBegin(GL_QUADS);
-    glColor3f(bgcol.r(), bgcol.g(), bgcol.b());
-    glVertex2f(-1.0f, +1.0f);
-    glVertex2f(+1.0f, +1.0f);
-
-    glColor3f(bgstopcol.r(), bgstopcol.g(), bgstopcol.b());
-    glVertex2f(+1.0f, -1.0f);
-    glVertex2f(-1.0f, -1.0f);
-    glEnd();
-    glEnable(GL_DEPTH_TEST);
+    glBegin (GL_QUADS);
+    glColor3f (bgcol.r (), bgcol.g (), bgcol.b ());
+    glVertex2f (-1.0f, +1.0f);
+    glVertex2f (+1.0f, +1.0f);
+
+    glColor3f (bgstopcol.r (), bgstopcol.g (), bgstopcol.b ());
+    glVertex2f (+1.0f, -1.0f);
+    glVertex2f (-1.0f, -1.0f);
+    glEnd ();
+    glEnable (GL_DEPTH_TEST);
   }
 
-  setupCamera();
+  setupCamera ();
 
   // The crosshair should be fixed at the center of the viewport...
-  if (showcrosshairs) GLView::showCrosshairs(crosshaircol);
-  glTranslated(cam.object_trans.x(), cam.object_trans.y(), cam.object_trans.z());
+  if (showcrosshairs)
+    GLView::showCrosshairs (crosshaircol);
+  glTranslated (cam.object_trans.x (), cam.object_trans.y (), cam.object_trans.z ());
   // ...the axis lines need to follow the object translation.
-  if (showaxes) GLView::showAxes(axescolor);
+  if (showaxes)
+    GLView::showAxes (axescolor);
   // mark the scale along the axis lines
-  if (showaxes && showscale) GLView::showScalemarkers(axescolor);
+  if (showaxes && showscale)
+    GLView::showScalemarkers (axescolor);
 
-  glEnable(GL_LIGHTING);
-  glDepthFunc(GL_LESS);
-  glCullFace(GL_BACK);
-  glDisable(GL_CULL_FACE);
-  glLineWidth(2);
-  glColor3d(1.0, 0.0, 0.0);
+  glEnable (GL_LIGHTING);
+  glDepthFunc (GL_LESS);
+  glCullFace (GL_BACK);
+  glDisable (GL_CULL_FACE);
+  glLineWidth (2);
+  glColor3d (1.0, 0.0, 0.0);
 
   if (this->renderer) {
 #if defined(ENABLE_OPENCSG)
     // FIXME: This belongs in the OpenCSG renderer, but it doesn't know about this ID yet
-    OpenCSG::setContext(this->opencsg_id);
+    OpenCSG::setContext (this->opencsg_id);
 #endif
-    this->renderer->prepare(edge_shader.get());
-    this->renderer->draw(showedges, edge_shader.get());
+    this->renderer->prepare (edge_shader.get ());
+    this->renderer->draw (showedges, edge_shader.get ());
   }
-  Vector3d eyedir(this->modelview[2], this->modelview[6], this->modelview[10]);
-  glColor3f(1, 0, 0);
-  for (const SelectedObject& obj:this->selected_obj) {
-    showObject(obj, eyedir);
+  Vector3d eyedir (this->modelview[2], this->modelview[6], this->modelview[10]);
+  glColor3f (1, 0, 0);
+  for (const SelectedObject &obj : this->selected_obj) {
+    showObject (obj, eyedir);
   }
-  glColor3f(0, 1, 0);
-  for (const SelectedObject& obj: this->shown_obj) {
-    showObject(obj, eyedir);
+  glColor3f (0, 1, 0);
+  for (const SelectedObject &obj : this->shown_obj) {
+    showObject (obj, eyedir);
   }
-  glDisable(GL_LIGHTING);
-  if (showaxes) GLView::showSmallaxes(axescolor);
+  glDisable (GL_LIGHTING);
+  if (showaxes)
+    GLView::showSmallaxes (axescolor);
 
   // Workaround for inconsistent QT behavior related to handling custom OpenGL widgets that
   // leave non opaque alpha values in final output.
@@ -233,28 +229,27 @@ void GLView::paintGL()
   //
   // Originally developed by @karliss for FreeCAD (https://github.com/FreeCAD/FreeCAD/pull/19499).
   GLboolean mask[4];
-  glGetBooleanv(GL_COLOR_WRITEMASK, mask);
-  glColorMask(false, false, false, true);
-  glClearColor(0, 0, 0, 1);
-  glClear(GL_COLOR_BUFFER_BIT);
-  glColorMask(mask[0], mask[1], mask[2], mask[3]);
+  glGetBooleanv (GL_COLOR_WRITEMASK, mask);
+  glColorMask (false, false, false, true);
+  glClearColor (0, 0, 0, 1);
+  glClear (GL_COLOR_BUFFER_BIT);
+  glColorMask (mask[0], mask[1], mask[2], mask[3]);
 }
 
 #ifdef ENABLE_OPENCSG
 
-void glCompileCheck(GLuint shader) {
+void glCompileCheck (GLuint shader) {
   GLint status;
-  glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
+  glGetShaderiv (shader, GL_COMPILE_STATUS, &status);
   if (status == GL_FALSE) {
     int loglen;
     char logbuffer[1000];
-    glGetShaderInfoLog(shader, sizeof(logbuffer), &loglen, logbuffer);
-    PRINTDB("OpenGL Shader Program Compile Error:\n%s", logbuffer);
+    glGetShaderInfoLog (shader, sizeof (logbuffer), &loglen, logbuffer);
+    PRINTDB ("OpenGL Shader Program Compile Error:\n%s", logbuffer);
   }
 }
 
-void GLView::enable_opencsg_shaders()
-{
+void GLView::enable_opencsg_shaders () {
   // All OpenGL 2 contexts are OpenCSG capable
 #ifdef USE_GLEW
   const bool hasOpenGL2_0 = GLEW_VERSION_2_0;
@@ -266,12 +261,11 @@ void GLView::enable_opencsg_shaders()
     this->is_opencsg_capable = true;
     this->has_shaders = true;
   } else {
-    display_opencsg_warning();
+    display_opencsg_warning ();
   }
 }
 #endif // ifdef ENABLE_OPENCSG
 
-
 #ifdef DEBUG
 // Requires OpenGL 4.3+
 /*
@@ -285,8 +279,7 @@ void GLView::enable_opencsg_shaders()
    //*/
 #endif
 
-void GLView::initializeGL()
-{
+void GLView::initializeGL () {
 #ifdef DEBUG
 /*
    // Requires OpenGL 4.3+
@@ -295,214 +288,230 @@ void GLView::initializeGL()
    //*/
 #endif
 
-  glEnable(GL_DEPTH_TEST);
-  glDepthRange(-far_far_away, +far_far_away);
+  glEnable (GL_DEPTH_TEST);
+  glDepthRange (-far_far_away, +far_far_away);
 
-  glEnable(GL_BLEND);
-  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+  glEnable (GL_BLEND);
+  glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 
   GLfloat light_diffuse[] = {1.0, 1.0, 1.0, 1.0};
   GLfloat light_position0[] = {-1.0, +1.0, +1.0, 0.0};
   GLfloat light_position1[] = {+1.0, -1.0, -1.0, 0.0};
 
-  glMatrixMode(GL_MODELVIEW);
-  glLoadIdentity();
-  glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);
-  glLightfv(GL_LIGHT0, GL_POSITION, light_position0);
-  glEnable(GL_LIGHT0);
-  glLightfv(GL_LIGHT1, GL_DIFFUSE, light_diffuse);
-  glLightfv(GL_LIGHT1, GL_POSITION, light_position1);
-  glEnable(GL_LIGHT1);
-  glEnable(GL_LIGHTING);
-  glEnable(GL_NORMALIZE);
-
-  glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
+  glMatrixMode (GL_MODELVIEW);
+  glLoadIdentity ();
+  glLightfv (GL_LIGHT0, GL_DIFFUSE, light_diffuse);
+  glLightfv (GL_LIGHT0, GL_POSITION, light_position0);
+  glEnable (GL_LIGHT0);
+  glLightfv (GL_LIGHT1, GL_DIFFUSE, light_diffuse);
+  glLightfv (GL_LIGHT1, GL_POSITION, light_position1);
+  glEnable (GL_LIGHT1);
+  glEnable (GL_LIGHTING);
+  glEnable (GL_NORMALIZE);
+
+  glColorMaterial (GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
   // The following line is reported to fix issue #71
-  glMateriali(GL_FRONT_AND_BACK, GL_SHININESS, 64);
-  glEnable(GL_COLOR_MATERIAL);
+  glMateriali (GL_FRONT_AND_BACK, GL_SHININESS, 64);
+  glEnable (GL_COLOR_MATERIAL);
 #ifdef ENABLE_OPENCSG
-  enable_opencsg_shaders();
+  enable_opencsg_shaders ();
 #endif
 }
 
-void GLView::showSmallaxes(const Color4f& col)
-{
-  auto dpi = this->getDPI();
+void GLView::showSmallaxes (const Color4f &col) {
+  auto dpi = this->getDPI ();
   // Small axis cross in the lower left corner
-  glDepthFunc(GL_ALWAYS);
+  glDepthFunc (GL_ALWAYS);
 
   // Set up an orthographic projection of the axis cross in the corner
-  glMatrixMode(GL_PROJECTION);
-  glLoadIdentity();
-  glTranslatef(-0.8f, -0.8f, 0.0f);
+  glMatrixMode (GL_PROJECTION);
+  glLoadIdentity ();
+  glTranslatef (-0.8f, -0.8f, 0.0f);
   auto scale = 90.0;
-  glOrtho(-scale * dpi * aspectratio, scale * dpi * aspectratio,
-          -scale * dpi, scale * dpi,
-          -scale * dpi, scale * dpi);
-  gluLookAt(0.0, -1.0, 0.0,
-            0.0, 0.0, 0.0,
-            0.0, 0.0, 1.0);
-
-  glMatrixMode(GL_MODELVIEW);
-  glLoadIdentity();
-  glRotated(cam.object_rot.x(), 1.0, 0.0, 0.0);
-  glRotated(cam.object_rot.y(), 0.0, 1.0, 0.0);
-  glRotated(cam.object_rot.z(), 0.0, 0.0, 1.0);
-
-  glLineWidth(dpi);
-  glBegin(GL_LINES);
-  glColor3d(1.0, 0.0, 0.0);
-  glVertex3d(0, 0, 0); glVertex3d(10 * dpi, 0, 0);
-  glColor3d(0.0, 1.0, 0.0);
-  glVertex3d(0, 0, 0); glVertex3d(0, 10 * dpi, 0);
-  glColor3d(0.0, 0.0, 1.0);
-  glVertex3d(0, 0, 0); glVertex3d(0, 0, 10 * dpi);
-  glEnd();
+  glOrtho (-scale * dpi * aspectratio, scale * dpi * aspectratio,
+           -scale * dpi, scale * dpi,
+           -scale * dpi, scale * dpi);
+  gluLookAt (0.0, -1.0, 0.0,
+             0.0, 0.0, 0.0,
+             0.0, 0.0, 1.0);
+
+  glMatrixMode (GL_MODELVIEW);
+  glLoadIdentity ();
+  glRotated (cam.object_rot.x (), 1.0, 0.0, 0.0);
+  glRotated (cam.object_rot.y (), 0.0, 1.0, 0.0);
+  glRotated (cam.object_rot.z (), 0.0, 0.0, 1.0);
+
+  glLineWidth (dpi);
+  glBegin (GL_LINES);
+  glColor3d (1.0, 0.0, 0.0);
+  glVertex3d (0, 0, 0);
+  glVertex3d (10 * dpi, 0, 0);
+  glColor3d (0.0, 1.0, 0.0);
+  glVertex3d (0, 0, 0);
+  glVertex3d (0, 10 * dpi, 0);
+  glColor3d (0.0, 0.0, 1.0);
+  glVertex3d (0, 0, 0);
+  glVertex3d (0, 0, 10 * dpi);
+  glEnd ();
 
   GLdouble mat_model[16];
-  glGetDoublev(GL_MODELVIEW_MATRIX, mat_model);
+  glGetDoublev (GL_MODELVIEW_MATRIX, mat_model);
 
   GLdouble mat_proj[16];
-  glGetDoublev(GL_PROJECTION_MATRIX, mat_proj);
+  glGetDoublev (GL_PROJECTION_MATRIX, mat_proj);
 
   GLint viewport[4];
-  glGetIntegerv(GL_VIEWPORT, viewport);
+  glGetIntegerv (GL_VIEWPORT, viewport);
 
   GLdouble xlabel_x, xlabel_y, xlabel_z;
-  gluProject(12 * dpi, 0, 0, mat_model, mat_proj, viewport, &xlabel_x, &xlabel_y, &xlabel_z);
-  xlabel_x = std::round(xlabel_x); xlabel_y = std::round(xlabel_y);
+  gluProject (12 * dpi, 0, 0, mat_model, mat_proj, viewport, &xlabel_x, &xlabel_y, &xlabel_z);
+  xlabel_x = std::round (xlabel_x);
+  xlabel_y = std::round (xlabel_y);
 
   GLdouble ylabel_x, ylabel_y, ylabel_z;
-  gluProject(0, 12 * dpi, 0, mat_model, mat_proj, viewport, &ylabel_x, &ylabel_y, &ylabel_z);
-  ylabel_x = std::round(ylabel_x); ylabel_y = std::round(ylabel_y);
+  gluProject (0, 12 * dpi, 0, mat_model, mat_proj, viewport, &ylabel_x, &ylabel_y, &ylabel_z);
+  ylabel_x = std::round (ylabel_x);
+  ylabel_y = std::round (ylabel_y);
 
   GLdouble zlabel_x, zlabel_y, zlabel_z;
-  gluProject(0, 0, 12 * dpi, mat_model, mat_proj, viewport, &zlabel_x, &zlabel_y, &zlabel_z);
-  zlabel_x = std::round(zlabel_x); zlabel_y = std::round(zlabel_y);
+  gluProject (0, 0, 12 * dpi, mat_model, mat_proj, viewport, &zlabel_x, &zlabel_y, &zlabel_z);
+  zlabel_x = std::round (zlabel_x);
+  zlabel_y = std::round (zlabel_y);
 
-  glMatrixMode(GL_PROJECTION);
-  glLoadIdentity();
-  glTranslated(-1, -1, 0);
-  glScaled(2.0 / viewport[2], 2.0 / viewport[3], 1);
+  glMatrixMode (GL_PROJECTION);
+  glLoadIdentity ();
+  glTranslated (-1, -1, 0);
+  glScaled (2.0 / viewport[2], 2.0 / viewport[3], 1);
 
-  glMatrixMode(GL_MODELVIEW);
-  glLoadIdentity();
+  glMatrixMode (GL_MODELVIEW);
+  glLoadIdentity ();
 
-  glColor3f(col.r(), col.g(), col.b());
+  glColor3f (col.r (), col.g (), col.b ());
 
   float d = 3 * dpi;
-  glBegin(GL_LINES);
+  glBegin (GL_LINES);
   // X Label
-  glVertex3d(xlabel_x - d, xlabel_y - d, 0); glVertex3d(xlabel_x + d, xlabel_y + d, 0);
-  glVertex3d(xlabel_x - d, xlabel_y + d, 0); glVertex3d(xlabel_x + d, xlabel_y - d, 0);
+  glVertex3d (xlabel_x - d, xlabel_y - d, 0);
+  glVertex3d (xlabel_x + d, xlabel_y + d, 0);
+  glVertex3d (xlabel_x - d, xlabel_y + d, 0);
+  glVertex3d (xlabel_x + d, xlabel_y - d, 0);
   // Y Label
-  glVertex3d(ylabel_x - d, ylabel_y - d, 0); glVertex3d(ylabel_x + d, ylabel_y + d, 0);
-  glVertex3d(ylabel_x - d, ylabel_y + d, 0); glVertex3d(ylabel_x, ylabel_y, 0);
+  glVertex3d (ylabel_x - d, ylabel_y - d, 0);
+  glVertex3d (ylabel_x + d, ylabel_y + d, 0);
+  glVertex3d (ylabel_x - d, ylabel_y + d, 0);
+  glVertex3d (ylabel_x, ylabel_y, 0);
   // Z Label
-  glVertex3d(zlabel_x - d, zlabel_y - d, 0); glVertex3d(zlabel_x + d, zlabel_y - d, 0);
-  glVertex3d(zlabel_x - d, zlabel_y + d, 0); glVertex3d(zlabel_x + d, zlabel_y + d, 0);
-  glVertex3d(zlabel_x - d, zlabel_y - d, 0); glVertex3d(zlabel_x + d, zlabel_y + d, 0);
-  glEnd();
+  glVertex3d (zlabel_x - d, zlabel_y - d, 0);
+  glVertex3d (zlabel_x + d, zlabel_y - d, 0);
+  glVertex3d (zlabel_x - d, zlabel_y + d, 0);
+  glVertex3d (zlabel_x + d, zlabel_y + d, 0);
+  glVertex3d (zlabel_x - d, zlabel_y - d, 0);
+  glVertex3d (zlabel_x + d, zlabel_y + d, 0);
+  glEnd ();
 }
 
-void GLView::showAxes(const Color4f& col)
-{
+void GLView::showAxes (const Color4f &col) {
   // Large gray axis cross inline with the model
-  glLineWidth(this->getDPI());
-  glColor3f(col.r(), col.g(), col.b());
-
-  glBegin(GL_LINES);
-  glVertex4d(0, 0, 0, 1);
-  glVertex4d(1, 0, 0, 0); // w = 0 goes to infinity
-  glVertex4d(0, 0, 0, 1);
-  glVertex4d(0, 1, 0, 0);
-  glVertex4d(0, 0, 0, 1);
-  glVertex4d(0, 0, 1, 0);
-  glEnd();
-
-  glPushAttrib(GL_LINE_BIT);
-  glEnable(GL_LINE_STIPPLE);
-  glLineStipple(3, 0xAAAA);
-  glBegin(GL_LINES);
-  glVertex4d(0, 0, 0, 1);
-  glVertex4d(-1, 0, 0, 0);
-  glVertex4d(0, 0, 0, 1);
-  glVertex4d(0, -1, 0, 0);
-  glVertex4d(0, 0, 0, 1);
-  glVertex4d(0, 0, -1, 0);
-  glEnd();
-  glPopAttrib();
+  glLineWidth (this->getDPI ());
+  glColor3f (col.r (), col.g (), col.b ());
+
+  glBegin (GL_LINES);
+  glVertex4d (0, 0, 0, 1);
+  glVertex4d (1, 0, 0, 0); // w = 0 goes to infinity
+  glVertex4d (0, 0, 0, 1);
+  glVertex4d (0, 1, 0, 0);
+  glVertex4d (0, 0, 0, 1);
+  glVertex4d (0, 0, 1, 0);
+  glEnd ();
+
+  glPushAttrib (GL_LINE_BIT);
+  glEnable (GL_LINE_STIPPLE);
+  glLineStipple (3, 0xAAAA);
+  glBegin (GL_LINES);
+  glVertex4d (0, 0, 0, 1);
+  glVertex4d (-1, 0, 0, 0);
+  glVertex4d (0, 0, 0, 1);
+  glVertex4d (0, -1, 0, 0);
+  glVertex4d (0, 0, 0, 1);
+  glVertex4d (0, 0, -1, 0);
+  glEnd ();
+  glPopAttrib ();
 }
 
-void GLView::showCrosshairs(const Color4f& col)
-{
-  glLineWidth(this->getDPI());
-  glColor3f(col.r(), col.g(), col.b());
-  glBegin(GL_LINES);
+void GLView::showCrosshairs (const Color4f &col) {
+  glLineWidth (this->getDPI ());
+  glColor3f (col.r (), col.g (), col.b ());
+  glBegin (GL_LINES);
   for (double xf : {-1.0, 1.0})
     for (double yf : {-1.0, 1.0}) {
-      auto vd = cam.zoomValue() / 8;
-      glVertex3d(-xf * vd, -yf * vd, -vd);
-      glVertex3d(+xf * vd, +yf * vd, +vd);
+      auto vd = cam.zoomValue () / 8;
+      glVertex3d (-xf * vd, -yf * vd, -vd);
+      glVertex3d (+xf * vd, +yf * vd, +vd);
     }
-  glEnd();
+  glEnd ();
 }
 
-void GLView::showObject(const SelectedObject& obj, const Vector3d& eyedir)
-{
-  auto vd = cam.zoomValue() / 200.0;
+void GLView::showObject (const SelectedObject &obj, const Vector3d &eyedir) {
+  auto vd = cam.zoomValue () / 200.0;
   switch (obj.type) {
-  case SelectionType::SELECTION_POINT:
-  {
-    double n = 1 / sqrt(3);
+  case SelectionType::SELECTION_POINT: {
+    double n = 1 / sqrt (3);
     // create an octaeder
     //x- x+ y- y+ z- z+
-    int sequence[] = { 2, 0, 4, 1, 2, 4, 0, 3, 4, 3, 1, 4, 0, 2, 5, 2, 1, 5, 3, 0, 5, 1, 3, 5 };
-    glBegin(GL_TRIANGLES);
+    int sequence[] = {2, 0, 4, 1, 2, 4, 0, 3, 4, 3, 1, 4, 0, 2, 5, 2, 1, 5, 3, 0, 5, 1, 3, 5};
+    glBegin (GL_TRIANGLES);
     for (int i = 0; i < 8; i++) {
-      glNormal3f((i & 1)?-n:n, (i & 2)?-n:n, (i & 4)?-n:n);
+      glNormal3f ((i & 1) ? -n : n, (i & 2) ? -n : n, (i & 4) ? -n : n);
       for (int j = 0; j < 3; j++) {
         int code = sequence[i * 3 + j];
         switch (code) {
-        case 0: glVertex3d(obj.p1[0] - vd, obj.p1[1], obj.p1[2]); break;
-        case 1: glVertex3d(obj.p1[0] + vd, obj.p1[1], obj.p1[2]); break;
-        case 2: glVertex3d(obj.p1[0], obj.p1[1] - vd, obj.p1[2]); break;
-        case 3: glVertex3d(obj.p1[0], obj.p1[1] + vd, obj.p1[2]); break;
-        case 4: glVertex3d(obj.p1[0], obj.p1[1], obj.p1[2] - vd); break;
-        case 5: glVertex3d(obj.p1[0], obj.p1[1], obj.p1[2] + vd); break;
+        case 0:
+          glVertex3d (obj.p1[0] - vd, obj.p1[1], obj.p1[2]);
+          break;
+        case 1:
+          glVertex3d (obj.p1[0] + vd, obj.p1[1], obj.p1[2]);
+          break;
+        case 2:
+          glVertex3d (obj.p1[0], obj.p1[1] - vd, obj.p1[2]);
+          break;
+        case 3:
+          glVertex3d (obj.p1[0], obj.p1[1] + vd, obj.p1[2]);
+          break;
+        case 4:
+          glVertex3d (obj.p1[0], obj.p1[1], obj.p1[2] - vd);
+          break;
+        case 5:
+          glVertex3d (obj.p1[0], obj.p1[1], obj.p1[2] + vd);
+          break;
         }
       }
     }
-    glEnd();
-  }
-  break;
-  case SelectionType::SELECTION_LINE:
-  {
+    glEnd ();
+  } break;
+  case SelectionType::SELECTION_LINE: {
     Vector3d diff = obj.p2 - obj.p1;
-    Vector3d wdir = eyedir.cross(diff).normalized() * vd / 2.0;
-    glBegin(GL_QUADS);
-    glVertex3d(obj.p1[0] - wdir[0], obj.p1[1] - wdir[1], obj.p1[2] - wdir[2]);
-    glVertex3d(obj.p2[0] - wdir[0], obj.p2[1] - wdir[1], obj.p2[2] - wdir[2]);
-    glVertex3d(obj.p2[0] + wdir[0], obj.p2[1] + wdir[1], obj.p2[2] + wdir[2]);
-    glVertex3d(obj.p1[0] + wdir[0], obj.p1[1] + wdir[1], obj.p1[2] + wdir[2]);
-    glEnd();
-  }
-  break;
+    Vector3d wdir = eyedir.cross (diff).normalized () * vd / 2.0;
+    glBegin (GL_QUADS);
+    glVertex3d (obj.p1[0] - wdir[0], obj.p1[1] - wdir[1], obj.p1[2] - wdir[2]);
+    glVertex3d (obj.p2[0] - wdir[0], obj.p2[1] - wdir[1], obj.p2[2] - wdir[2]);
+    glVertex3d (obj.p2[0] + wdir[0], obj.p2[1] + wdir[1], obj.p2[2] + wdir[2]);
+    glVertex3d (obj.p1[0] + wdir[0], obj.p1[1] + wdir[1], obj.p1[2] + wdir[2]);
+    glEnd ();
+  } break;
   }
 }
 
-void GLView::showScalemarkers(const Color4f& col)
-{
+void GLView::showScalemarkers (const Color4f &col) {
   // Add scale ticks on large axes
-  auto l = cam.zoomValue();
-  glLineWidth(this->getDPI());
-  glColor3f(col.r(), col.g(), col.b());
+  auto l = cam.zoomValue ();
+  glLineWidth (this->getDPI ());
+  glColor3f (col.r (), col.g (), col.b ());
 
   // Take log of l, discretize, then exponentiate. This is done so that the tick
   // denominations change every time the viewport gets 10x bigger or smaller,
   // but stays constant in-between. l_adjusted is a step function of l.
-  const int log_l = static_cast<int>(floor(log10(l)));
-  const double l_adjusted = pow(10, log_l);
+  const int log_l = static_cast<int> (floor (log10 (l)));
+  const double l_adjusted = pow (10, log_l);
 
   // Calculate tick width.
   const double tick_width = l_adjusted / 10.0;
@@ -516,8 +525,8 @@ void GLView::showScalemarkers(const Color4f& col)
     int size_div;
     if (line_cnt > 0 && line_cnt % 10 == 0) { // major tick
       size_div = size_div_sm * .5; // resize to a major tick
-      GLView::decodeMarkerValue(i, l, size_div_sm); // print number
-    } else {        // minor tick
+      GLView::decodeMarkerValue (i, l, size_div_sm); // print number
+    } else { // minor tick
       size_div = size_div_sm; // set the minor tick to the standard size
 
       // Draw additional labels if there are few major tick labels visible due to
@@ -533,7 +542,7 @@ void GLView::showScalemarkers(const Color4f& col)
       // draw additional labels every 2 minor ticks
       const int more_labels_freq = 2;
       if (line_cnt > 0 && line_cnt % more_labels_freq == 0 && l / l_adjusted < more_labels_threshold) {
-        GLView::decodeMarkerValue(i, l, size_div_sm); // print number
+        GLView::decodeMarkerValue (i, l, size_div_sm); // print number
       }
     }
     line_cnt++;
@@ -548,96 +557,104 @@ void GLView::showScalemarkers(const Color4f& col)
      */
 
     // positive axes
-    glBegin(GL_LINES);
+    glBegin (GL_LINES);
     // x
-    glVertex3d(i, 0, 0); glVertex3d(i, -l / size_div, 0); // 1 arm
+    glVertex3d (i, 0, 0);
+    glVertex3d (i, -l / size_div, 0); // 1 arm
     //glVertex3d(i,-l/size_div,0); glVertex3d(i,l/size_div,0); // 2 arms
     //glVertex3d(i,0,-l/size_div); glVertex3d(i,0,l/size_div); // 4 arms (w/ 2 arms line)
 
     // y
-    glVertex3d(0, i, 0); glVertex3d(-l / size_div, i, 0); // 1 arm
+    glVertex3d (0, i, 0);
+    glVertex3d (-l / size_div, i, 0); // 1 arm
     //glVertex3d(-l/size_div,i,0); glVertex3d(l/size_div,i,0); // 2 arms
     //glVertex3d(0,i,-l/size_div); glVertex3d(0,i,l/size_div); // 4 arms (w/ 2 arms line)
 
     // z
-    glVertex3d(0, 0, i); glVertex3d(-l / size_div, 0, i); // 1 arm
+    glVertex3d (0, 0, i);
+    glVertex3d (-l / size_div, 0, i); // 1 arm
     //glVertex3d(-l/size_div,0,i); glVertex3d(l/size_div,0,i); // 2 arms
     //glVertex3d(0,-l/size_div,i); glVertex3d(0,l/size_div,i); // 4 arms (w/ 2 arms line)
-    glEnd();
+    glEnd ();
 
     // negative axes
-    glPushAttrib(GL_LINE_BIT);
-    glEnable(GL_LINE_STIPPLE);
-    glLineStipple(3, 0xAAAA);
-    glBegin(GL_LINES);
+    glPushAttrib (GL_LINE_BIT);
+    glEnable (GL_LINE_STIPPLE);
+    glLineStipple (3, 0xAAAA);
+    glBegin (GL_LINES);
     // x
-    glVertex3d(-i, 0, 0); glVertex3d(-i, -l / size_div, 0); // 1 arm
+    glVertex3d (-i, 0, 0);
+    glVertex3d (-i, -l / size_div, 0); // 1 arm
     //glVertex3d(-i,-l/size_div,0); glVertex3d(-i,l/size_div,0); // 2 arms
     //glVertex3d(-i,0,-l/size_div); glVertex3d(-i,0,l/size_div); // 4 arms (w/ 2 arms line)
 
     // y
-    glVertex3d(0, -i, 0); glVertex3d(-l / size_div, -i, 0); // 1 arm
+    glVertex3d (0, -i, 0);
+    glVertex3d (-l / size_div, -i, 0); // 1 arm
     //glVertex3d(-l/size_div,-i,0); glVertex3d(l/size_div,-i,0); // 2 arms
     //glVertex3d(0,-i,-l/size_div); glVertex3d(0,-i,l/size_div); // 4 arms (w/ 2 arms line)
 
     // z
-    glVertex3d(0, 0, -i); glVertex3d(-l / size_div, 0, -i); // 1 arm
+    glVertex3d (0, 0, -i);
+    glVertex3d (-l / size_div, 0, -i); // 1 arm
     //glVertex3d(-l/size_div,0,-i); glVertex3d(l/size_div,0,-i); // 2 arms
     //glVertex3d(0,-l/size_div,-i); glVertex3d(0,l/size_div,-i); // 4 arms (w/ 2 arms line)
-    glEnd();
-    glPopAttrib();
+    glEnd ();
+    glPopAttrib ();
   }
 }
 
-void GLView::decodeMarkerValue(double i, double l, int size_div_sm)
-{
+void GLView::decodeMarkerValue (double i, double l, int size_div_sm) {
   // We draw both at once the positive and corresponding negative number.
-  const std::string pos_number_str = STR(i);
+  const std::string pos_number_str = STR (i);
   const std::string neg_number_str = "-" + pos_number_str;
 
   const float font_size = (l / size_div_sm);
-  const float baseline_offset = font_size / 5;  // hovering a bit above axis
+  const float baseline_offset = font_size / 5; // hovering a bit above axis
 
   // Length of the minus sign. We want the digits to be centered around
   // their ticks, but not have the minus prefix shift center of gravity.
-  const float prefix_offset = hershey::TextWidth("-", font_size) / 2;
+  const float prefix_offset = hershey::TextWidth ("-", font_size) / 2;
 
   // Draw functions that help map 2D axis label drawings into their plane.
   // Since we're just on axis, no need for fancy affine transformation,
   // just calling glVertex3d() with coordinates in the right plane.
   using PlaneVertexDraw = std::function<void (
-                                          float x, float y, float font_height, float baseline_offset)>;
+    float x, float y, float font_height, float baseline_offset)>;
 
   const PlaneVertexDraw axis_draw_planes[3] = {
-    [](float x, float y, float /*fh*/, float bl) {
-      glVertex3d(x, y + bl, 0);  // x-label along x-axis; font drawn above line
+    [] (float x, float y, float /*fh*/, float bl) {
+      glVertex3d (x, y + bl, 0); // x-label along x-axis; font drawn above line
     },
-    [](float x, float y, float fh, float bl) {
-      glVertex3d(-y + (fh + bl), x, 0);  // y-label along y-axis; font below
+    [] (float x, float y, float fh, float bl) {
+      glVertex3d (-y + (fh + bl), x, 0); // y-label along y-axis; font below
     },
-    [](float x, float y, float fh, float bl) {
-      glVertex3d(-y + (fh + bl), 0, x);  // z-label along z-axis; font below
+    [] (float x, float y, float fh, float bl) {
+      glVertex3d (-y + (fh + bl), 0, x); // z-label along z-axis; font below
     },
   };
   bool needs_glend = false;
-  for (const PlaneVertexDraw& axis_draw : axis_draw_planes) {
+  for (const PlaneVertexDraw &axis_draw : axis_draw_planes) {
     // We get 'plot instructions', a sequence of vertices. Translate into gl ops
-    const auto plot_fun = [&](bool pen_down, float x, float y) {
-        if (!pen_down) { // Start a new line, coordinates just move not draw
-          if (needs_glend) glEnd();
-          glBegin(GL_LINE_STRIP);
-          needs_glend = true;
-        }
-        axis_draw(x, y, font_size, baseline_offset);
-      };
+    const auto plot_fun = [&] (bool pen_down, float x, float y) {
+      if (!pen_down) { // Start a new line, coordinates just move not draw
+        if (needs_glend)
+          glEnd ();
+        glBegin (GL_LINE_STRIP);
+        needs_glend = true;
+      }
+      axis_draw (x, y, font_size, baseline_offset);
+    };
 
-    hershey::DrawText(pos_number_str, i, 0,
-                      hershey::TextAlign::kCenter, font_size, plot_fun);
-    if (needs_glend) glEnd();
+    hershey::DrawText (pos_number_str, i, 0,
+                       hershey::TextAlign::kCenter, font_size, plot_fun);
+    if (needs_glend)
+      glEnd ();
     needs_glend = false;
-    hershey::DrawText(neg_number_str, -i - prefix_offset, 0,
-                      hershey::TextAlign::kCenter, font_size, plot_fun);
-    if (needs_glend) glEnd();
+    hershey::DrawText (neg_number_str, -i - prefix_offset, 0,
+                       hershey::TextAlign::kCenter, font_size, plot_fun);
+    if (needs_glend)
+      glEnd ();
     needs_glend = false;
   }
 }
diff --git a/src/glview/GLView.h b/src/glview/GLView.h
index 3e32daeb4..da80ae27d 100644
--- a/src/glview/GLView.h
+++ b/src/glview/GLView.h
@@ -32,38 +32,58 @@
 class GLView
 {
 public:
-  GLView();
-  virtual ~GLView();
-
-  void setupShader();
-  void teardownShader();
-
-  void setRenderer(std::shared_ptr<Renderer> r);
-  [[nodiscard]] Renderer *getRenderer() const { return this->renderer.get(); }
-
-  void initializeGL();
-  void resizeGL(int w, int h);
-  virtual void paintGL();
-
-  void setCamera(const Camera& cam);
-  void setupCamera();
-
-  void setColorScheme(const ColorScheme& cs);
-  void setColorScheme(const std::string& cs);
-  void updateColorScheme();
-
-  [[nodiscard]] bool showAxes() const { return this->showaxes; }
-  void setShowAxes(bool enabled) { this->showaxes = enabled; }
-  [[nodiscard]] bool showScaleProportional() const { return this->showscale; }
-  void setShowScaleProportional(bool enabled) { this->showscale = enabled; }
-  [[nodiscard]] bool showEdges() const { return this->showedges; }
-  void setShowEdges(bool enabled) { this->showedges = enabled; }
-  [[nodiscard]] bool showCrosshairs() const { return this->showcrosshairs; }
-  void setShowCrosshairs(bool enabled) { this->showcrosshairs = enabled; }
-
-  virtual bool save(const char *filename) const = 0;
-  [[nodiscard]] virtual std::string getRendererInfo() const = 0;
-  virtual float getDPI() { return 1.0f; }
+  GLView ();
+  virtual ~GLView ();
+
+  void setupShader ();
+  void teardownShader ();
+
+  void setRenderer (std::shared_ptr<Renderer> r);
+  [[nodiscard]] Renderer *getRenderer () const {
+    return this->renderer.get ();
+  }
+
+  void initializeGL ();
+  void resizeGL (int w, int h);
+  virtual void paintGL ();
+
+  void setCamera (const Camera &cam);
+  void setupCamera ();
+
+  void setColorScheme (const ColorScheme &cs);
+  void setColorScheme (const std::string &cs);
+  void updateColorScheme ();
+
+  [[nodiscard]] bool showAxes () const {
+    return this->showaxes;
+  }
+  void setShowAxes (bool enabled) {
+    this->showaxes = enabled;
+  }
+  [[nodiscard]] bool showScaleProportional () const {
+    return this->showscale;
+  }
+  void setShowScaleProportional (bool enabled) {
+    this->showscale = enabled;
+  }
+  [[nodiscard]] bool showEdges () const {
+    return this->showedges;
+  }
+  void setShowEdges (bool enabled) {
+    this->showedges = enabled;
+  }
+  [[nodiscard]] bool showCrosshairs () const {
+    return this->showcrosshairs;
+  }
+  void setShowCrosshairs (bool enabled) {
+    this->showcrosshairs = enabled;
+  }
+
+  virtual bool save (const char *filename) const = 0;
+  [[nodiscard]] virtual std::string getRendererInfo () const = 0;
+  virtual float getDPI () {
+    return 1.0f;
+  }
 
   std::unique_ptr<ShaderUtils::ShaderInfo> edge_shader;
   std::shared_ptr<Renderer> renderer;
@@ -83,15 +103,16 @@ public:
 #ifdef ENABLE_OPENCSG
   bool is_opencsg_capable;
   bool has_shaders;
-  void enable_opencsg_shaders();
-  virtual void display_opencsg_warning() = 0;
+  void enable_opencsg_shaders ();
+  virtual void display_opencsg_warning () = 0;
   int opencsg_id;
 #endif
-  void showObject(const SelectedObject& pt, const Vector3d& eyedir);
+  void showObject (const SelectedObject &pt, const Vector3d &eyedir);
+
 private:
-  void showCrosshairs(const Color4f& col);
-  void showAxes(const Color4f& col);
-  void showSmallaxes(const Color4f& col);
-  void showScalemarkers(const Color4f& col);
-  void decodeMarkerValue(double i, double l, int size_div_sm);
+  void showCrosshairs (const Color4f &col);
+  void showAxes (const Color4f &col);
+  void showSmallaxes (const Color4f &col);
+  void showScalemarkers (const Color4f &col);
+  void decodeMarkerValue (double i, double l, int size_div_sm);
 };
diff --git a/src/glview/NULLGL.cc b/src/glview/NULLGL.cc
index 41e355a86..b3b898799 100644
--- a/src/glview/NULLGL.cc
+++ b/src/glview/NULLGL.cc
@@ -14,24 +14,42 @@
 #include "glview/OpenGLContext.h"
 #include "glview/system-gl.h"
 
-bool FBO::resize(size_t, size_t) { return false; }
-FBO::FBO(int, int, bool) {}
-GLuint FBO::bind() { return 0; }
-GLView::~GLView() = default;
-GLView::GLView() = default;
-std::string gl_dump() { return {"GL Renderer: NULLGL\n"}; }
-std::string gl_extensions_dump() { return {"NULLGL Extensions"}; }
-std::unique_ptr<FBO> createFBO(int, int) {return nullptr;}
-std::vector<uint8_t> OpenGLContext::getFramebuffer() const { return {}; }
-void FBO::destroy() {}
-void FBO::unbind() {}
-void GLView::initializeGL() {}
-void GLView::paintGL() {}
-void GLView::resizeGL(int w, int h) {}
-void GLView::setCamera(const Camera& /*cam*/) {assert(false && "not implemented");}
-void GLView::setColorScheme(const ColorScheme& /*cs*/){assert(false && "not implemented");}
-void GLView::setColorScheme(const std::string& /*cs*/) {assert(false && "not implemented");}
-void GLView::setRenderer(std::shared_ptr<Renderer>) {}
-void GLView::showAxes(const Color4f& col) {}
-void GLView::showCrosshairs(const Color4f& col) {}
-void GLView::showSmallaxes(const Color4f& col) {}
\ No newline at end of file
+bool FBO::resize (size_t, size_t) {
+  return false;
+}
+FBO::FBO (int, int, bool) {}
+GLuint FBO::bind () {
+  return 0;
+}
+GLView::~GLView () = default;
+GLView::GLView () = default;
+std::string gl_dump () {
+  return {"GL Renderer: NULLGL\n"};
+}
+std::string gl_extensions_dump () {
+  return {"NULLGL Extensions"};
+}
+std::unique_ptr<FBO> createFBO (int, int) {
+  return nullptr;
+}
+std::vector<uint8_t> OpenGLContext::getFramebuffer () const {
+  return {};
+}
+void FBO::destroy () {}
+void FBO::unbind () {}
+void GLView::initializeGL () {}
+void GLView::paintGL () {}
+void GLView::resizeGL (int w, int h) {}
+void GLView::setCamera (const Camera & /*cam*/) {
+  assert (false && "not implemented");
+}
+void GLView::setColorScheme (const ColorScheme & /*cs*/) {
+  assert (false && "not implemented");
+}
+void GLView::setColorScheme (const std::string & /*cs*/) {
+  assert (false && "not implemented");
+}
+void GLView::setRenderer (std::shared_ptr<Renderer>) {}
+void GLView::showAxes (const Color4f &col) {}
+void GLView::showCrosshairs (const Color4f &col) {}
+void GLView::showSmallaxes (const Color4f &col) {}
\ No newline at end of file
diff --git a/src/glview/OffscreenContext.h b/src/glview/OffscreenContext.h
index 794b8d68b..35f70f1e5 100644
--- a/src/glview/OffscreenContext.h
+++ b/src/glview/OffscreenContext.h
@@ -6,5 +6,6 @@
 class OffscreenContext : public OpenGLContext
 {
 public:
-  OffscreenContext(uint32_t width, uint32_t height) : OpenGLContext(width, height) {}
+  OffscreenContext (uint32_t width, uint32_t height)
+    : OpenGLContext (width, height) {}
 };
diff --git a/src/glview/OffscreenContextCGL.cc b/src/glview/OffscreenContextCGL.cc
index 5d8af174e..81d392ec3 100644
--- a/src/glview/OffscreenContextCGL.cc
+++ b/src/glview/OffscreenContextCGL.cc
@@ -13,34 +13,36 @@ class OffscreenContextCGL : public OffscreenContext
 {
 
 public:
-  OffscreenContextCGL(int width, int height) : OffscreenContext(width, height) {}
-  ~OffscreenContextCGL() {
-    CGLDestroyContext(cglContext);
+  OffscreenContextCGL (int width, int height)
+    : OffscreenContext (width, height) {}
+  ~OffscreenContextCGL () {
+    CGLDestroyContext (cglContext);
   }
 
   // FIXME: What info are we really interested in here?
-  std::string getInfo() const override {
+  std::string getInfo () const override {
     std::ostringstream out;
     out << "GL context creator: CGL (new)\n"
         << "PNG generator: Core Foundation\n";
-    return out.str();
+    return out.str ();
   }
 
-  bool makeCurrent() const override {
-    return CGLSetCurrentContext(this->cglContext) == kCGLNoError;
+  bool makeCurrent () const override {
+    return CGLSetCurrentContext (this->cglContext) == kCGLNoError;
   }
 
   CGLContextObj cglContext = nullptr;
 };
 
-std::shared_ptr<OffscreenContext> CreateOffscreenContextCGL(size_t width, size_t height,
-                                                            size_t majorGLVersion, size_t minorGLVersion)
-{
-  auto ctx = std::make_shared<OffscreenContextCGL>(width, height);
+std::shared_ptr<OffscreenContext> CreateOffscreenContextCGL (size_t width, size_t height,
+                                                             size_t majorGLVersion, size_t minorGLVersion) {
+  auto ctx = std::make_shared<OffscreenContextCGL> (width, height);
 
   CGLOpenGLProfile glVersion = kCGLOGLPVersion_Legacy;
-  if (majorGLVersion >= 4) glVersion = kCGLOGLPVersion_GL4_Core;
-  else if (majorGLVersion >= 3) glVersion = kCGLOGLPVersion_GL3_Core;
+  if (majorGLVersion >= 4)
+    glVersion = kCGLOGLPVersion_GL4_Core;
+  else if (majorGLVersion >= 3)
+    glVersion = kCGLOGLPVersion_GL3_Core;
 
   CGLPixelFormatAttribute attributes[13] = {
     kCGLPFAOpenGLProfile, (CGLPixelFormatAttribute)glVersion,
@@ -48,18 +50,17 @@ std::shared_ptr<OffscreenContext> CreateOffscreenContextCGL(size_t width, size_t
     kCGLPFAAlphaSize, (CGLPixelFormatAttribute)8,
     kCGLPFADoubleBuffer,
     kCGLPFASampleBuffers, (CGLPixelFormatAttribute)1,
-    kCGLPFASamples,  (CGLPixelFormatAttribute)4,
-    (CGLPixelFormatAttribute) 0
-  };
+    kCGLPFASamples, (CGLPixelFormatAttribute)4,
+    (CGLPixelFormatAttribute)0};
   CGLPixelFormatObj pixelFormat = NULL;
   GLint numPixelFormats = 0;
-  const auto status = CGLChoosePixelFormat(attributes, &pixelFormat, &numPixelFormats);
+  const auto status = CGLChoosePixelFormat (attributes, &pixelFormat, &numPixelFormats);
   if (status != kCGLNoError) {
-    std::cerr << "CGLChoosePixelFormat() failed: " << CGLErrorString(status) << std::endl;
+    std::cerr << "CGLChoosePixelFormat() failed: " << CGLErrorString (status) << std::endl;
     return nullptr;
   }
-  CGLCreateContext(pixelFormat, NULL, &ctx->cglContext);
-  CGLDestroyPixelFormat(pixelFormat);
+  CGLCreateContext (pixelFormat, NULL, &ctx->cglContext);
+  CGLDestroyPixelFormat (pixelFormat);
 
   return ctx;
 }
diff --git a/src/glview/OffscreenContextCGL.h b/src/glview/OffscreenContextCGL.h
index 0fc65b545..9e189abfe 100644
--- a/src/glview/OffscreenContextCGL.h
+++ b/src/glview/OffscreenContextCGL.h
@@ -5,5 +5,5 @@
 
 #include "glview/OffscreenContext.h"
 
-std::shared_ptr<OffscreenContext> CreateOffscreenContextCGL(size_t width, size_t height,
-                                                            size_t majorGLVersion, size_t minorGLVersion);
+std::shared_ptr<OffscreenContext> CreateOffscreenContextCGL (size_t width, size_t height,
+                                                             size_t majorGLVersion, size_t minorGLVersion);
diff --git a/src/glview/OffscreenContextEGL.cc b/src/glview/OffscreenContextEGL.cc
index ea811f883..0e96d34fa 100644
--- a/src/glview/OffscreenContextEGL.cc
+++ b/src/glview/OffscreenContextEGL.cc
@@ -15,26 +15,28 @@
 
 namespace {
 
-#define CASE_STR(value) case value: return #value;
-const char *eglGetErrorString(EGLint error)
-{
+#define CASE_STR(value) \
+  case value:           \
+    return #value;
+const char *eglGetErrorString (EGLint error) {
   switch (error) {
-  CASE_STR(EGL_SUCCESS)
-  CASE_STR(EGL_NOT_INITIALIZED)
-  CASE_STR(EGL_BAD_ACCESS)
-  CASE_STR(EGL_BAD_ALLOC)
-  CASE_STR(EGL_BAD_ATTRIBUTE)
-  CASE_STR(EGL_BAD_CONTEXT)
-  CASE_STR(EGL_BAD_CONFIG)
-  CASE_STR(EGL_BAD_CURRENT_SURFACE)
-  CASE_STR(EGL_BAD_DISPLAY)
-  CASE_STR(EGL_BAD_SURFACE)
-  CASE_STR(EGL_BAD_MATCH)
-  CASE_STR(EGL_BAD_PARAMETER)
-  CASE_STR(EGL_BAD_NATIVE_PIXMAP)
-  CASE_STR(EGL_BAD_NATIVE_WINDOW)
-  CASE_STR(EGL_CONTEXT_LOST)
-  default: return "Unknown";
+    CASE_STR (EGL_SUCCESS)
+    CASE_STR (EGL_NOT_INITIALIZED)
+    CASE_STR (EGL_BAD_ACCESS)
+    CASE_STR (EGL_BAD_ALLOC)
+    CASE_STR (EGL_BAD_ATTRIBUTE)
+    CASE_STR (EGL_BAD_CONTEXT)
+    CASE_STR (EGL_BAD_CONFIG)
+    CASE_STR (EGL_BAD_CURRENT_SURFACE)
+    CASE_STR (EGL_BAD_DISPLAY)
+    CASE_STR (EGL_BAD_SURFACE)
+    CASE_STR (EGL_BAD_MATCH)
+    CASE_STR (EGL_BAD_PARAMETER)
+    CASE_STR (EGL_BAD_NATIVE_PIXMAP)
+    CASE_STR (EGL_BAD_NATIVE_WINDOW)
+    CASE_STR (EGL_CONTEXT_LOST)
+  default:
+    return "Unknown";
   }
 }
 #undef CASE_STR
@@ -49,60 +51,65 @@ public:
   EGLSurface eglSurface;
   EGLContext eglContext;
 
-  OffscreenContextEGL(int width, int height) : OffscreenContext(width, height) {}
-  ~OffscreenContextEGL() {
-    if (this->eglSurface) eglDestroySurface(this->eglDisplay, this->eglSurface);
-    if (this->eglDisplay) eglTerminate(this->eglDisplay);
+  OffscreenContextEGL (int width, int height)
+    : OffscreenContext (width, height) {}
+  ~OffscreenContextEGL () {
+    if (this->eglSurface)
+      eglDestroySurface (this->eglDisplay, this->eglSurface);
+    if (this->eglDisplay)
+      eglTerminate (this->eglDisplay);
   }
 
-  std::string getInfo() const override {
+  std::string getInfo () const override {
     std::ostringstream result;
 
-    const char *eglVersion = eglQueryString(this->eglDisplay, EGL_VERSION);
+    const char *eglVersion = eglQueryString (this->eglDisplay, EGL_VERSION);
 
     result << "GL context creator: EGL (new)\n"
            << "EGL version: " << eglVersion << "\n"
            << "PNG generator: lodepng\n";
 
-    return result.str();
+    return result.str ();
   }
 
-  bool makeCurrent() const override {
-    return eglMakeCurrent(this->eglDisplay, this->eglSurface, this->eglSurface, this->eglContext);
+  bool makeCurrent () const override {
+    return eglMakeCurrent (this->eglDisplay, this->eglSurface, this->eglSurface, this->eglContext);
   }
 
-  void findPlatformDisplay() {
+  void findPlatformDisplay () {
     std::set<std::string> clientExtensions;
-    std::string ext = eglQueryString(EGL_NO_DISPLAY, EGL_EXTENSIONS);
-    std::istringstream iss(ext);
+    std::string ext = eglQueryString (EGL_NO_DISPLAY, EGL_EXTENSIONS);
+    std::istringstream iss (ext);
     while (iss) {
       std::string extension;
       iss >> extension;
-      clientExtensions.insert(extension);
+      clientExtensions.insert (extension);
     }
 
-    if (clientExtensions.find("EGL_EXT_platform_device") == clientExtensions.end()) {
+    if (clientExtensions.find ("EGL_EXT_platform_device") == clientExtensions.end ()) {
       return;
     }
 
     if (eglQueryDevicesEXT && eglGetPlatformDisplayEXT) {
       EGLDeviceEXT eglDevice;
       EGLint numDevices = 0;
-      eglQueryDevicesEXT(1, &eglDevice, &numDevices);
+      eglQueryDevicesEXT (1, &eglDevice, &numDevices);
       if (numDevices > 0) {
         // FIXME: Attribs
-        this->eglDisplay = eglGetPlatformDisplayEXT(EGL_PLATFORM_DEVICE_EXT, eglDevice, nullptr);
+        this->eglDisplay = eglGetPlatformDisplayEXT (EGL_PLATFORM_DEVICE_EXT, eglDevice, nullptr);
       }
     }
   }
 
-  void createSurface(const EGLConfig& config, size_t width, size_t height) {
+  void createSurface (const EGLConfig &config, size_t width, size_t height) {
     const EGLint pbufferAttribs[] = {
-      EGL_WIDTH, static_cast<EGLint>(width),
-      EGL_HEIGHT, static_cast<EGLint>(height),
+      EGL_WIDTH,
+      static_cast<EGLint> (width),
+      EGL_HEIGHT,
+      static_cast<EGLint> (height),
       EGL_NONE,
     };
-    this->eglSurface = eglCreatePbufferSurface(this->eglDisplay, config, pbufferAttribs);
+    this->eglSurface = eglCreatePbufferSurface (this->eglDisplay, config, pbufferAttribs);
   }
 };
 
@@ -110,25 +117,28 @@ public:
 // OpenGL core major.minor
 // OpenGL compatibility major.minor
 // OpenGL ES major.minor
-std::shared_ptr<OffscreenContext> CreateOffscreenContextEGL(size_t width, size_t height,
-                                                            size_t majorGLVersion, size_t minorGLVersion,
-                                                            bool gles, bool compatibilityProfile)
-{
-  auto ctx = std::make_shared<OffscreenContextEGL>(width, height);
+std::shared_ptr<OffscreenContext> CreateOffscreenContextEGL (size_t width, size_t height,
+                                                             size_t majorGLVersion, size_t minorGLVersion,
+                                                             bool gles, bool compatibilityProfile) {
+  auto ctx = std::make_shared<OffscreenContextEGL> (width, height);
 
-  int initialEglVersion = gladLoaderLoadEGL(nullptr);
+  int initialEglVersion = gladLoaderLoadEGL (nullptr);
   if (!initialEglVersion) {
-    LOG("gladLoaderLoadEGL(NULL): Unable to load EGL");
+    LOG ("gladLoaderLoadEGL(NULL): Unable to load EGL");
     return nullptr;
   }
-  PRINTDB("GLAD: Loaded EGL %d.%d on first load",
-          GLAD_VERSION_MAJOR(initialEglVersion) % GLAD_VERSION_MINOR(initialEglVersion));
+  PRINTDB ("GLAD: Loaded EGL %d.%d on first load",
+           GLAD_VERSION_MAJOR (initialEglVersion) % GLAD_VERSION_MINOR (initialEglVersion));
 
   EGLint conformant;
-  if (!gles) conformant = EGL_OPENGL_BIT;
-  else if (majorGLVersion >= 3) conformant = EGL_OPENGL_ES3_BIT;
-  else if (majorGLVersion >= 2) conformant = EGL_OPENGL_ES2_BIT;
-  else conformant = EGL_OPENGL_ES_BIT;
+  if (!gles)
+    conformant = EGL_OPENGL_BIT;
+  else if (majorGLVersion >= 3)
+    conformant = EGL_OPENGL_ES3_BIT;
+  else if (majorGLVersion >= 2)
+    conformant = EGL_OPENGL_ES2_BIT;
+  else
+    conformant = EGL_OPENGL_ES_BIT;
 
   const EGLint configAttribs[] = {
     EGL_SURFACE_TYPE, EGL_PBUFFER_BIT,
@@ -140,66 +150,67 @@ std::shared_ptr<OffscreenContext> CreateOffscreenContextEGL(size_t width, size_t
     EGL_STENCIL_SIZE, 8,
     EGL_CONFORMANT, conformant,
     EGL_CONFIG_CAVEAT, EGL_NONE,
-    EGL_NONE
-  };
+    EGL_NONE};
 
   // FIXME: Should we try default display first?
   // If so, we also have to try initializing it
-  ctx->findPlatformDisplay();
+  ctx->findPlatformDisplay ();
   if (ctx->eglDisplay == EGL_NO_DISPLAY) {
-    ctx->eglDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);
+    ctx->eglDisplay = eglGetDisplay (EGL_DEFAULT_DISPLAY);
   }
 
   if (ctx->eglDisplay == EGL_NO_DISPLAY) {
-    LOG("No EGL display found");
+    LOG ("No EGL display found");
     return nullptr;
   }
 
   EGLint major, minor;
-  if (!eglInitialize(ctx->eglDisplay, &major, &minor)) {
-    LOG("Unable to initialize EGL: %1$s", eglGetErrorString(eglGetError()));
+  if (!eglInitialize (ctx->eglDisplay, &major, &minor)) {
+    LOG ("Unable to initialize EGL: %1$s", eglGetErrorString (eglGetError ()));
     return nullptr;
   }
 
-  PRINTDB("Initialized EGL version: %d.%d (%s)", major % minor % eglQueryString(ctx->eglDisplay, EGL_VENDOR));
+  PRINTDB ("Initialized EGL version: %d.%d (%s)", major % minor % eglQueryString (ctx->eglDisplay, EGL_VENDOR));
 
-  const auto eglVersion = gladLoaderLoadEGL(ctx->eglDisplay);
+  const auto eglVersion = gladLoaderLoadEGL (ctx->eglDisplay);
   if (!eglVersion) {
-    LOG("gladLoaderLoadEGL(eglDisplay): Unable to reload EGL");
+    LOG ("gladLoaderLoadEGL(eglDisplay): Unable to reload EGL");
     return nullptr;
   }
-  PRINTDB("GLAD: Loaded EGL %d.%d after reload", GLAD_VERSION_MAJOR(eglVersion) % GLAD_VERSION_MINOR(eglVersion));
+  PRINTDB ("GLAD: Loaded EGL %d.%d after reload", GLAD_VERSION_MAJOR (eglVersion) % GLAD_VERSION_MINOR (eglVersion));
 
   EGLint numConfigs;
   EGLConfig config;
-  bool gotConfig = eglChooseConfig(ctx->eglDisplay, configAttribs, &config, 1, &numConfigs);
+  bool gotConfig = eglChooseConfig (ctx->eglDisplay, configAttribs, &config, 1, &numConfigs);
   if (!gotConfig || numConfigs == 0) {
-    LOG("Failed to choose config (eglError: %1$x)", eglGetError());
+    LOG ("Failed to choose config (eglError: %1$x)", eglGetError ());
     return nullptr;
   }
-  if (!eglBindAPI(gles ? EGL_OPENGL_ES_API : EGL_OPENGL_API)) {
-    LOG("eglBindAPI() failed!");
+  if (!eglBindAPI (gles ? EGL_OPENGL_ES_API : EGL_OPENGL_API)) {
+    LOG ("eglBindAPI() failed!");
     return nullptr;
   }
 
-  ctx->createSurface(config, width, height);
+  ctx->createSurface (config, width, height);
   if (ctx->eglSurface == EGL_NO_SURFACE) {
-    LOG("Unable to create EGL surface (eglError: %1$x)", eglGetError());
+    LOG ("Unable to create EGL surface (eglError: %1$x)", eglGetError ());
     return nullptr;
   }
 
   std::vector<EGLint> ctxattr = {
-    EGL_CONTEXT_MAJOR_VERSION, static_cast<EGLint>(majorGLVersion),
-    EGL_CONTEXT_MINOR_VERSION, static_cast<EGLint>(minorGLVersion),
+    EGL_CONTEXT_MAJOR_VERSION,
+    static_cast<EGLint> (majorGLVersion),
+    EGL_CONTEXT_MINOR_VERSION,
+    static_cast<EGLint> (minorGLVersion),
   };
   if (!gles) {
-    ctxattr.push_back(EGL_CONTEXT_OPENGL_PROFILE_MASK);
-    ctxattr.push_back(compatibilityProfile ? EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT : EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT);
+    ctxattr.push_back (EGL_CONTEXT_OPENGL_PROFILE_MASK);
+    ctxattr.push_back (compatibilityProfile ? EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT : EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT);
   }
-  ctxattr.push_back(EGL_NONE);
-  ctx->eglContext = eglCreateContext(ctx->eglDisplay, config, EGL_NO_CONTEXT, ctxattr.data());
+  ctxattr.push_back (EGL_NONE);
+  ctx->eglContext = eglCreateContext (ctx->eglDisplay, config, EGL_NO_CONTEXT, ctxattr.data ());
   if (ctx->eglContext == EGL_NO_CONTEXT) {
-    LOG("Unable to create EGL context (eglError: %1$x)", eglGetError());
+    LOG ("Unable to create EGL context (eglError: %1$x)", eglGetError ());
     return nullptr;
   }
 
diff --git a/src/glview/OffscreenContextEGL.h b/src/glview/OffscreenContextEGL.h
index d446e9970..cebbe1460 100644
--- a/src/glview/OffscreenContextEGL.h
+++ b/src/glview/OffscreenContextEGL.h
@@ -5,6 +5,6 @@
 
 #include "glview/OffscreenContext.h"
 
-std::shared_ptr<OffscreenContext> CreateOffscreenContextEGL(
+std::shared_ptr<OffscreenContext> CreateOffscreenContextEGL (
   size_t width, size_t height, size_t majorGLVersion,
   size_t minorGLVersion, bool gles, bool compatibilityProfile);
diff --git a/src/glview/OffscreenContextFactory.cc b/src/glview/OffscreenContextFactory.cc
index c0b45b8ad..633e8b1e8 100644
--- a/src/glview/OffscreenContextFactory.cc
+++ b/src/glview/OffscreenContextFactory.cc
@@ -26,7 +26,7 @@
 
 namespace OffscreenContextFactory {
 
-const char *defaultProvider() {
+const char *defaultProvider () {
 #ifdef NULLGL
   return "nullgl";
 #else
@@ -42,67 +42,66 @@ const char *defaultProvider() {
 #ifdef _WIN32
   return "wgl-old";
 #endif
-#endif  // NULLGL
+#endif // NULLGL
 }
 
-std::shared_ptr<OpenGLContext> create(const std::string& provider, const OffscreenContextFactory::ContextAttributes& attrib)
-{
-  PRINTDB("Creating OpenGL context with the %1s provider:", provider);
-  PRINTDB("  Size: %d x %d", attrib.width % attrib.height);
-  PRINTDB("  Version: %s %d.%d %s", (attrib.gles ? "OpenGL ES" : "OpenGL") % attrib.majorGLVersion % attrib.minorGLVersion %
-          (attrib.compatibilityProfile ? "(compatibility profile requested)" : ""));
+std::shared_ptr<OpenGLContext> create (const std::string &provider, const OffscreenContextFactory::ContextAttributes &attrib) {
+  PRINTDB ("Creating OpenGL context with the %1s provider:", provider);
+  PRINTDB ("  Size: %d x %d", attrib.width % attrib.height);
+  PRINTDB ("  Version: %s %d.%d %s", (attrib.gles ? "OpenGL ES" : "OpenGL") % attrib.majorGLVersion % attrib.minorGLVersion %
+                                       (attrib.compatibilityProfile ? "(compatibility profile requested)" : ""));
   // FIXME: We should log an error if the chosen provider doesn't support all our attribs.
 #ifdef NULLGL
   if (provider == "nullgl") {
-    return CreateOffscreenContextNULL();
+    return CreateOffscreenContextNULL ();
   }
 #else
 #ifdef __APPLE__
   if (provider == "nsopengl-old") {
     if (attrib.gles) {
-      LOG("GLES is not supported on macOS");
+      LOG ("GLES is not supported on macOS");
     }
     if (attrib.compatibilityProfile) {
-      LOG("Compatibility context is not available on macOS");
+      LOG ("Compatibility context is not available on macOS");
     }
-    return offscreen_old::CreateOffscreenContextNSOpenGL(attrib.width, attrib.height, attrib.majorGLVersion, attrib.minorGLVersion);
+    return offscreen_old::CreateOffscreenContextNSOpenGL (attrib.width, attrib.height, attrib.majorGLVersion, attrib.minorGLVersion);
   } else if (provider == "cgl") {
-    return CreateOffscreenContextCGL(attrib.width, attrib.height, attrib.majorGLVersion, attrib.minorGLVersion);
+    return CreateOffscreenContextCGL (attrib.width, attrib.height, attrib.majorGLVersion, attrib.minorGLVersion);
   }
 #endif // ifdef __APPLE__
 #if ENABLE_EGL
   if (provider == "egl-old") {
-    return offscreen_old::CreateOffscreenContextEGL(attrib.width, attrib.height,
-                                                    attrib.majorGLVersion, attrib.minorGLVersion,
-                                                    attrib.gles, attrib.compatibilityProfile);
+    return offscreen_old::CreateOffscreenContextEGL (attrib.width, attrib.height,
+                                                     attrib.majorGLVersion, attrib.minorGLVersion,
+                                                     attrib.gles, attrib.compatibilityProfile);
   } else if (provider == "egl") {
-    return CreateOffscreenContextEGL(attrib.width, attrib.height,
-                                     attrib.majorGLVersion, attrib.minorGLVersion,
-                                     attrib.gles, attrib.compatibilityProfile);
+    return CreateOffscreenContextEGL (attrib.width, attrib.height,
+                                      attrib.majorGLVersion, attrib.minorGLVersion,
+                                      attrib.gles, attrib.compatibilityProfile);
   } else
 #endif
 #ifdef ENABLE_GLX
-  if (provider == "glx-old") {
-    return offscreen_old::CreateOffscreenContextGLX(attrib.width, attrib.height, attrib.majorGLVersion, attrib.minorGLVersion,
-                                                    attrib.gles, attrib.compatibilityProfile);
+    if (provider == "glx-old") {
+    return offscreen_old::CreateOffscreenContextGLX (attrib.width, attrib.height, attrib.majorGLVersion, attrib.minorGLVersion,
+                                                     attrib.gles, attrib.compatibilityProfile);
   } else if (provider == "glx") {
-    return CreateOffscreenContextGLX(attrib.width, attrib.height, attrib.majorGLVersion, attrib.minorGLVersion,
-                                     attrib.gles, attrib.compatibilityProfile);
+    return CreateOffscreenContextGLX (attrib.width, attrib.height, attrib.majorGLVersion, attrib.minorGLVersion,
+                                      attrib.gles, attrib.compatibilityProfile);
   }
 #endif
 #ifdef _WIN32
   if (provider == "wgl-old") {
     if (attrib.gles) {
-      LOG("GLES is not supported on Windows");
+      LOG ("GLES is not supported on Windows");
     }
-    return offscreen_old::CreateOffscreenContextWGL(attrib.width, attrib.height,
-                                                    attrib.majorGLVersion, attrib.minorGLVersion,
-                                                    attrib.compatibilityProfile);
+    return offscreen_old::CreateOffscreenContextWGL (attrib.width, attrib.height,
+                                                     attrib.majorGLVersion, attrib.minorGLVersion,
+                                                     attrib.compatibilityProfile);
   } else
 #endif
-#endif  // NULLGL
-  LOG("GL context provider '%1$s' not found", provider);
+#endif // NULLGL
+  LOG ("GL context provider '%1$s' not found", provider);
   return nullptr;
 }
 
-}  // namespace OffscreenContextFactory
+} // namespace OffscreenContextFactory
diff --git a/src/glview/OffscreenContextFactory.h b/src/glview/OffscreenContextFactory.h
index 9b83e0559..75def3306 100644
--- a/src/glview/OffscreenContextFactory.h
+++ b/src/glview/OffscreenContextFactory.h
@@ -9,15 +9,15 @@
 namespace OffscreenContextFactory {
 
 struct ContextAttributes {
-  uint32_t width;            // Context size in pixels
-  uint32_t height;           //
-  uint32_t majorGLVersion;   // Minimum OpenGL or GLES major version
-  uint32_t minorGLVersion;   // Minimum OpenGL or GLES minor version
-  bool gles;                 // Request a GLES context
+  uint32_t width; // Context size in pixels
+  uint32_t height; //
+  uint32_t majorGLVersion; // Minimum OpenGL or GLES major version
+  uint32_t minorGLVersion; // Minimum OpenGL or GLES minor version
+  bool gles; // Request a GLES context
   bool compatibilityProfile; // Request a compatibility context (to support legacy OpenGL calls)
 };
 
-const char *defaultProvider();
-std::shared_ptr<OpenGLContext> create(const std::string& provider, const ContextAttributes& attrib);
+const char *defaultProvider ();
+std::shared_ptr<OpenGLContext> create (const std::string &provider, const ContextAttributes &attrib);
 
-}  // namespace OffscreenContextFactory
+} // namespace OffscreenContextFactory
diff --git a/src/glview/OffscreenContextGLX.cc b/src/glview/OffscreenContextGLX.cc
index 06d1604da..bab4024ac 100644
--- a/src/glview/OffscreenContextGLX.cc
+++ b/src/glview/OffscreenContextGLX.cc
@@ -16,12 +16,12 @@
 namespace {
 
 int xlibLastError = 0;
-int xlibErrorHandler(Display *dpy, XErrorEvent *event) {
+int xlibErrorHandler (Display *dpy, XErrorEvent *event) {
   xlibLastError = event->error_code;
   return 0;
 }
 
-}  // namespace
+} // namespace
 
 class OffscreenContextGLX : public OffscreenContext
 {
@@ -29,31 +29,34 @@ public:
   GLXContext glxContext = nullptr;
   Display *display = nullptr;
   Window xWindow = 0;
-  OffscreenContextGLX(int width, int height) : OffscreenContext(width, height) {}
-  ~OffscreenContextGLX() {
+  OffscreenContextGLX (int width, int height)
+    : OffscreenContext (width, height) {}
+  ~OffscreenContextGLX () {
     if (this->display) {
-      if (this->glxContext) glXDestroyContext(this->display, this->glxContext);
-      if (this->xWindow) XDestroyWindow(this->display, this->xWindow);
-      XCloseDisplay(this->display);
+      if (this->glxContext)
+        glXDestroyContext (this->display, this->glxContext);
+      if (this->xWindow)
+        XDestroyWindow (this->display, this->xWindow);
+      XCloseDisplay (this->display);
     }
   }
 
   // FIXME: What info are we really interested in here?
-  std::string getInfo() const override {
+  std::string getInfo () const override {
     std::ostringstream result;
 
     int major, minor;
-    glXQueryVersion(this->display, &major, &minor);
+    glXQueryVersion (this->display, &major, &minor);
 
     result << "GL context creator: GLX (new)\n"
            << "GLX version: " << major << "." << minor << "\n"
            << "PNG generator: lodepng\n";
 
-    return result.str();
+    return result.str ();
   }
 
-  bool makeCurrent() const override {
-    return glXMakeContextCurrent(this->display, this->xWindow, this->xWindow, this->glxContext);
+  bool makeCurrent () const override {
+    return glXMakeContextCurrent (this->display, this->xWindow, this->xWindow, this->glxContext);
   }
 
   // Create an OpenGL context, and a dummy X11 window to draw into, without showing (mapping) it.
@@ -62,7 +65,7 @@ public:
   // GLX 1.3 function when GLX 1.3 is not supported! This is an application bug!"
 
   //  This function will alter ctx.openGLContext and ctx.xwindow if successful
-  bool createGLXContext(size_t majorGLVersion, size_t minorGLVersion, bool compatibilityProfile) {
+  bool createGLXContext (size_t majorGLVersion, size_t minorGLVersion, bool compatibilityProfile) {
     const int attributes[] = {
       GLX_DRAWABLE_TYPE, GLX_WINDOW_BIT | GLX_PIXMAP_BIT,
       GLX_RENDER_TYPE, GLX_RGBA_BIT,
@@ -72,68 +75,68 @@ public:
       GLX_ALPHA_SIZE, 8,
       GLX_DEPTH_SIZE, 24, // depth-stencil for OpenCSG
       GLX_STENCIL_SIZE, 8,
-      None
-    };
+      None};
 
     int numConfigs = 0;
     GLXFBConfig *fbconfigs = nullptr;
     XVisualInfo *visinfo = nullptr;
-    auto guard = sg::make_scope_guard([&fbconfigs, &visinfo]() {
-      if (fbconfigs) XFree(fbconfigs);
-      if (visinfo) XFree(visinfo);
+    auto guard = sg::make_scope_guard ([&fbconfigs, &visinfo] () {
+      if (fbconfigs)
+        XFree (fbconfigs);
+      if (visinfo)
+        XFree (visinfo);
     });
-    fbconfigs = glXChooseFBConfig(this->display, DefaultScreen(this->display), attributes, &numConfigs);
+    fbconfigs = glXChooseFBConfig (this->display, DefaultScreen (this->display), attributes, &numConfigs);
     if (fbconfigs == nullptr) {
-      LOG("glXChooseFBConfig() failed");
+      LOG ("glXChooseFBConfig() failed");
       return false;
     }
-    visinfo = glXGetVisualFromFBConfig(this->display, fbconfigs[0]);
+    visinfo = glXGetVisualFromFBConfig (this->display, fbconfigs[0]);
     if (visinfo == nullptr) {
-      LOG("glXGetVisualFromFBConfig failed");
+      LOG ("glXGetVisualFromFBConfig failed");
       return false;
     }
 
     // We can't depend on XCreateWindow() returning 0 on failure, so we use a custom Xlib error handler
-    XErrorHandler originalErrorHandler = XSetErrorHandler(xlibErrorHandler);
-    auto errorGuard = sg::make_scope_guard([originalErrorHandler]() {
-      XSetErrorHandler(originalErrorHandler);
+    XErrorHandler originalErrorHandler = XSetErrorHandler (xlibErrorHandler);
+    auto errorGuard = sg::make_scope_guard ([originalErrorHandler] () {
+      XSetErrorHandler (originalErrorHandler);
     });
 
-    const auto root = DefaultRootWindow(this->display);
+    const auto root = DefaultRootWindow (this->display);
     XSetWindowAttributes windowAttributes = {
       .event_mask = StructureNotifyMask | ExposureMask | KeyPressMask,
-      .colormap = XCreateColormap(this->display, root, visinfo->visual, AllocNone),
+      .colormap = XCreateColormap (this->display, root, visinfo->visual, AllocNone),
     };
     unsigned long mask = CWBackPixel | CWBorderPixel | CWColormap | CWEventMask;
 
     this->xWindow =
-      XCreateWindow(this->display, root, 0, 0, this->width(), this->height(), 0,
-                    visinfo->depth, InputOutput, visinfo->visual, mask, &windowAttributes);
-    XSync(this->display, false);
+      XCreateWindow (this->display, root, 0, 0, this->width (), this->height (), 0,
+                     visinfo->depth, InputOutput, visinfo->visual, mask, &windowAttributes);
+    XSync (this->display, false);
     if (xlibLastError != Success) {
       char description[1024];
-      XGetErrorText(this->display, xlibLastError, description, 1023);
-      LOG("XCreateWindow() failed: %1$s", description);
+      XGetErrorText (this->display, xlibLastError, description, 1023);
+      LOG ("XCreateWindow() failed: %1$s", description);
       return false;
     }
 
     GLint context_attributes[] = {
-      GLX_CONTEXT_MAJOR_VERSION_ARB, static_cast<GLint>(majorGLVersion),
-      GLX_CONTEXT_MINOR_VERSION_ARB, static_cast<GLint>(minorGLVersion),
+      GLX_CONTEXT_MAJOR_VERSION_ARB, static_cast<GLint> (majorGLVersion),
+      GLX_CONTEXT_MINOR_VERSION_ARB, static_cast<GLint> (minorGLVersion),
       GLX_CONTEXT_PROFILE_MASK_ARB, compatibilityProfile ? GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB : GLX_CONTEXT_CORE_PROFILE_BIT_ARB,
-      None
-    };
+      None};
 
     if (glXCreateContextAttribsARB) {
-      this->glxContext = glXCreateContextAttribsARB(this->display, fbconfigs[0], nullptr, 1, context_attributes);
+      this->glxContext = glXCreateContextAttribsARB (this->display, fbconfigs[0], nullptr, 1, context_attributes);
       if (!this->glxContext) {
-        LOG("Unable to create GLX context using glXCreateContextAttribsARB()");
+        LOG ("Unable to create GLX context using glXCreateContextAttribsARB()");
       }
     }
     if (!this->glxContext) {
-      this->glxContext = glXCreateNewContext(this->display, fbconfigs[0], GLX_RGBA_TYPE, nullptr, 1);
+      this->glxContext = glXCreateNewContext (this->display, fbconfigs[0], GLX_RGBA_TYPE, nullptr, 1);
       if (!this->glxContext) {
-        LOG("Unable to create GLX context using glXCreateNewContext()");
+        LOG ("Unable to create GLX context using glXCreateNewContext()");
         return false;
       }
     }
@@ -141,7 +144,6 @@ public:
   }
 };
 
-
 /*
    create a dummy X window without showing it. (without 'mapping' it)
    and save information to the ctx.
@@ -152,38 +154,37 @@ public:
 
    This function will alter ctx.openGLContext and ctx.xwindow if successful
  */
-std::shared_ptr<OffscreenContext> CreateOffscreenContextGLX(size_t width, size_t height,
-                                                            size_t majorGLVersion, size_t minorGLVersion, bool gles, bool compatibilityProfile)
-{
-  auto ctx = std::make_shared<OffscreenContextGLX>(width, height);
+std::shared_ptr<OffscreenContext> CreateOffscreenContextGLX (size_t width, size_t height,
+                                                             size_t majorGLVersion, size_t minorGLVersion, bool gles, bool compatibilityProfile) {
+  auto ctx = std::make_shared<OffscreenContextGLX> (width, height);
 
-  ctx->display = XOpenDisplay(nullptr);
+  ctx->display = XOpenDisplay (nullptr);
   if (ctx->display == nullptr) {
-    LOG("Unable to open a connection to the X server.");
-    char *dpyenv = getenv("DISPLAY");
-    LOG("  DISPLAY=%1$s", (dpyenv?dpyenv:""));
+    LOG ("Unable to open a connection to the X server.");
+    char *dpyenv = getenv ("DISPLAY");
+    LOG ("  DISPLAY=%1$s", (dpyenv ? dpyenv : ""));
     return nullptr;
   }
 
-  int glxVersion = gladLoaderLoadGLX(ctx->display, DefaultScreen(ctx->display));
+  int glxVersion = gladLoaderLoadGLX (ctx->display, DefaultScreen (ctx->display));
   if (!glxVersion) {
-    LOG("GLAD: Unable to load GLX");
+    LOG ("GLAD: Unable to load GLX");
     return nullptr;
   }
-  int glxMajor = GLAD_VERSION_MAJOR(glxVersion);
-  int glxMinor = GLAD_VERSION_MINOR(glxVersion);
-  PRINTDB("GLAD: Loaded GLX %d.%d", glxMajor % glxMinor);
+  int glxMajor = GLAD_VERSION_MAJOR (glxVersion);
+  int glxMinor = GLAD_VERSION_MINOR (glxVersion);
+  PRINTDB ("GLAD: Loaded GLX %d.%d", glxMajor % glxMinor);
 
   // We require GLX >= 1.3.
   // However, glxQueryVersion sometimes returns an earlier version than is actually available, so
   // we also accept GLX < 1.3 as long as glXGetVisualFromFBConfig() exists.
   // FIXME: Figure out if this is still relevant with GLAD, as we may want to check functions anyway?
   if (glxMajor == 1 && glxMinor <= 2 && glXGetVisualFromFBConfig == nullptr) {
-    LOG("Error: GLX version 1.3 functions missing. Your GLX version: %1$d.%2$d", glxMajor, glxMinor);
+    LOG ("Error: GLX version 1.3 functions missing. Your GLX version: %1$d.%2$d", glxMajor, glxMinor);
     return nullptr;
   }
 
-  if (!ctx->createGLXContext(majorGLVersion, minorGLVersion, compatibilityProfile)) {
+  if (!ctx->createGLXContext (majorGLVersion, minorGLVersion, compatibilityProfile)) {
     return nullptr;
   }
 
diff --git a/src/glview/OffscreenContextGLX.h b/src/glview/OffscreenContextGLX.h
index 7cec59866..60c29d9f6 100644
--- a/src/glview/OffscreenContextGLX.h
+++ b/src/glview/OffscreenContextGLX.h
@@ -5,6 +5,6 @@
 
 #include "glview/OffscreenContext.h"
 
-std::shared_ptr<OffscreenContext> CreateOffscreenContextGLX(
+std::shared_ptr<OffscreenContext> CreateOffscreenContextGLX (
   size_t width, size_t height, size_t majorGLVersion,
   size_t minorGLVersion, bool gles, bool compatibilityProfile);
diff --git a/src/glview/OffscreenContextNULL.cc b/src/glview/OffscreenContextNULL.cc
index 16b43449a..c9cb55faf 100644
--- a/src/glview/OffscreenContextNULL.cc
+++ b/src/glview/OffscreenContextNULL.cc
@@ -12,16 +12,18 @@
 class OffscreenContextNULL : public OffscreenContext
 {
 public:
-  OffscreenContextNULL() : OffscreenContext(0, 0) {}
-  ~OffscreenContextNULL() override = default;
+  OffscreenContextNULL ()
+    : OffscreenContext (0, 0) {}
+  ~OffscreenContextNULL () override = default;
 
-  std::string getInfo() const override {
+  std::string getInfo () const override {
     return "GL context creator: NULLGL";
   }
-  bool makeCurrent() const override { return true; }
+  bool makeCurrent () const override {
+    return true;
+  }
 };
 
-std::shared_ptr<OffscreenContext> CreateOffscreenContextNULL()
-{
-  return std::make_shared<OffscreenContextNULL>();
+std::shared_ptr<OffscreenContext> CreateOffscreenContextNULL () {
+  return std::make_shared<OffscreenContextNULL> ();
 }
diff --git a/src/glview/OffscreenContextNULL.h b/src/glview/OffscreenContextNULL.h
index 86bda5b8d..bb5fa45b4 100644
--- a/src/glview/OffscreenContextNULL.h
+++ b/src/glview/OffscreenContextNULL.h
@@ -4,4 +4,4 @@
 
 #include "glview/OffscreenContext.h"
 
-std::shared_ptr<OffscreenContext> CreateOffscreenContextNULL();
+std::shared_ptr<OffscreenContext> CreateOffscreenContextNULL ();
diff --git a/src/glview/OffscreenView.cc b/src/glview/OffscreenView.cc
index 00e6f6e0c..fbb5b7cb2 100644
--- a/src/glview/OffscreenView.cc
+++ b/src/glview/OffscreenView.cc
@@ -24,111 +24,107 @@ namespace {
    Capture framebuffer from OpenGL and write it to the given ostream.
    Called by save_framebuffer() from platform-specific code.
  */
-bool save_framebuffer(const OpenGLContext *ctx, std::ostream& output)
-{
-  if (!ctx) return false;
+bool save_framebuffer (const OpenGLContext *ctx, std::ostream &output) {
+  if (!ctx)
+    return false;
 
-  const auto pixels = ctx->getFramebuffer();
+  const auto pixels = ctx->getFramebuffer ();
 
   const size_t samplesPerPixel = 4; // R, G, B and A
   // Flip it vertically - images read from OpenGL buffers are upside-down
-  std::vector<uint8_t> flippedBuffer(samplesPerPixel * ctx->height() * ctx->width());
-  flip_image(&pixels[0], flippedBuffer.data(), samplesPerPixel, ctx->width(), ctx->height());
+  std::vector<uint8_t> flippedBuffer (samplesPerPixel * ctx->height () * ctx->width ());
+  flip_image (&pixels[0], flippedBuffer.data (), samplesPerPixel, ctx->width (), ctx->height ());
 
-  return write_png(output, flippedBuffer.data(), ctx->width(), ctx->height());
+  return write_png (output, flippedBuffer.data (), ctx->width (), ctx->height ());
 }
 
-}  // namespace
+} // namespace
 
-OffscreenView::OffscreenView(uint32_t width, uint32_t height)
-{
+OffscreenView::OffscreenView (uint32_t width, uint32_t height) {
   OffscreenContextFactory::ContextAttributes attrib = {
     .width = width,
     .height = height,
     .majorGLVersion = 2,
     .minorGLVersion = 0,
   };
-  auto provider = OffscreenContextFactory::defaultProvider();
+  auto provider = OffscreenContextFactory::defaultProvider ();
   // We cannot initialize GLX GLEW with an EGL context:
   // https://github.com/nigels-com/glew/issues/273
   // ..so if we're using GLEW, default to creating a GLX context.
   // FIXME: It's possible that GLEW was built using EGL, in which case this
   // logic isn't correct, but we don't have a good way of determining how GLEW was built.
 #if defined(USE_GLEW) || defined(OPENCSG_GLEW)
-  provider = !strcmp(provider, "egl") ? "glx" : provider;
+  provider = !strcmp (provider, "egl") ? "glx" : provider;
 #endif
-  this->ctx = OffscreenContextFactory::create(provider, attrib);
+  this->ctx = OffscreenContextFactory::create (provider, attrib);
   if (!this->ctx) {
     // If the provider defaulted to EGL, fall back to GLX if EGL failed
-    if (!strcmp(provider, "egl")) {
-      this->ctx = OffscreenContextFactory::create("glx", attrib);
+    if (!strcmp (provider, "egl")) {
+      this->ctx = OffscreenContextFactory::create ("glx", attrib);
     }
     if (!this->ctx) {
-      throw OffscreenViewException("Unable to obtain GL Context");
+      throw OffscreenViewException ("Unable to obtain GL Context");
     }
   }
-  if (!this->ctx->makeCurrent()) throw OffscreenViewException("Unable to make GL context current");
+  if (!this->ctx->makeCurrent ())
+    throw OffscreenViewException ("Unable to make GL context current");
 
 #ifndef NULLGL
 #if defined(USE_GLEW) || defined(OPENCSG_GLEW)
-  if (!initializeGlew()) {
-    throw OffscreenViewException("Unable to initialize Glew");
+  if (!initializeGlew ()) {
+    throw OffscreenViewException ("Unable to initialize Glew");
   }
 #endif // USE_GLEW
 #ifdef USE_GLAD
   // We could ask for gladLoadGLES2UserPtr() here if we want to use GLES2+
-  const auto version = gladLoaderLoadGL();
+  const auto version = gladLoaderLoadGL ();
   if (version == 0) {
-    throw OffscreenViewException("Unable to initialize GLAD");
+    throw OffscreenViewException ("Unable to initialize GLAD");
   }
-  PRINTDB("GLAD: Loaded OpenGL %d.%d", GLAD_VERSION_MAJOR(version) % GLAD_VERSION_MINOR(version));
+  PRINTDB ("GLAD: Loaded OpenGL %d.%d", GLAD_VERSION_MAJOR (version) % GLAD_VERSION_MINOR (version));
 #endif // USE_GLAD
 
 #endif // NULLGL
 
-  PRINTD(gl_dump());
+  PRINTD (gl_dump ());
 
-  this->fbo = createFBO(width, height);
+  this->fbo = createFBO (width, height);
   if (!fbo) {
-    throw OffscreenViewException("Unable to create FBO");
+    throw OffscreenViewException ("Unable to create FBO");
   }
-  GLView::initializeGL();
-  GLView::resizeGL(width, height);
+  GLView::initializeGL ();
+  GLView::resizeGL (width, height);
 }
 
-OffscreenView::~OffscreenView()
-{
-  fbo.reset();
+OffscreenView::~OffscreenView () {
+  fbo.reset ();
 }
 
 #ifdef ENABLE_OPENCSG
-void OffscreenView::display_opencsg_warning()
-{
-  LOG("OpenSCAD recommended OpenGL version is 2.0.");
+void OffscreenView::display_opencsg_warning () {
+  LOG ("OpenSCAD recommended OpenGL version is 2.0.");
 }
 #endif
 
-bool OffscreenView::save(const char *filename) const
-{
-  std::ofstream fstream(filename, std::ios::out | std::ios::binary);
-  if (!fstream.is_open()) {
+bool OffscreenView::save (const char *filename) const {
+  std::ofstream fstream (filename, std::ios::out | std::ios::binary);
+  if (!fstream.is_open ()) {
     std::cerr << "Can't open file " << filename << " for writing";
     return false;
   } else {
-    save_framebuffer(this->ctx.get(), fstream);
-    fstream.close();
+    save_framebuffer (this->ctx.get (), fstream);
+    fstream.close ();
   }
   return true;
 }
 
-bool OffscreenView::save(std::ostream& output) const
-{
-  return save_framebuffer(this->ctx.get(), output);
+bool OffscreenView::save (std::ostream &output) const {
+  return save_framebuffer (this->ctx.get (), output);
 }
 
-std::string OffscreenView::getRendererInfo() const
-{
+std::string OffscreenView::getRendererInfo () const {
   std::ostringstream result;
-  result << this->ctx->getInfo() << "\n" << gl_dump();
-  return result.str();
+  result << this->ctx->getInfo () << "\n"
+         << gl_dump ();
+  return result.str ();
 }
diff --git a/src/glview/OffscreenView.h b/src/glview/OffscreenView.h
index 6d7d1ce2d..c12473a67 100644
--- a/src/glview/OffscreenView.h
+++ b/src/glview/OffscreenView.h
@@ -13,23 +13,24 @@
 class OffscreenViewException : public std::runtime_error
 {
 public:
-  OffscreenViewException(const std::string& what_arg) : std::runtime_error(what_arg) {}
+  OffscreenViewException (const std::string &what_arg)
+    : std::runtime_error (what_arg) {}
 };
 
 class OffscreenView : public GLView
 {
 public:
-  OffscreenView(uint32_t width, uint32_t height);
-  ~OffscreenView() override;
-  bool save(std::ostream& output) const;
+  OffscreenView (uint32_t width, uint32_t height);
+  ~OffscreenView () override;
+  bool save (std::ostream &output) const;
   // TODO: Do we need to worry about deletion order?
   std::shared_ptr<OpenGLContext> ctx;
   std::unique_ptr<FBO> fbo;
 
   // overrides
-  bool save(const char *filename) const override;
-  [[nodiscard]] std::string getRendererInfo() const override;
+  bool save (const char *filename) const override;
+  [[nodiscard]] std::string getRendererInfo () const override;
 #ifdef ENABLE_OPENCSG
-  void display_opencsg_warning() override;
+  void display_opencsg_warning () override;
 #endif
 };
diff --git a/src/glview/OpenGLContext.cc b/src/glview/OpenGLContext.cc
index fffe784c9..c4dedae13 100644
--- a/src/glview/OpenGLContext.cc
+++ b/src/glview/OpenGLContext.cc
@@ -6,10 +6,9 @@
 
 #include "glview/system-gl.h"
 
-std::vector<uint8_t> OpenGLContext::getFramebuffer() const
-{
+std::vector<uint8_t> OpenGLContext::getFramebuffer () const {
   const size_t samplesPerPixel = 4; // R, G, B and A
-  std::vector<uint8_t> buffer(samplesPerPixel * this->width_ * this->height_);
-  GL_CHECK(glReadPixels(0, 0, this->width_, this->height_, GL_RGBA, GL_UNSIGNED_BYTE, buffer.data()));
+  std::vector<uint8_t> buffer (samplesPerPixel * this->width_ * this->height_);
+  GL_CHECK (glReadPixels (0, 0, this->width_, this->height_, GL_RGBA, GL_UNSIGNED_BYTE, buffer.data ()));
   return buffer;
 }
diff --git a/src/glview/OpenGLContext.h b/src/glview/OpenGLContext.h
index d350c1edb..c729961a6 100644
--- a/src/glview/OpenGLContext.h
+++ b/src/glview/OpenGLContext.h
@@ -11,11 +11,17 @@ protected:
   uint32_t height_;
 
 public:
-  OpenGLContext(uint32_t width, uint32_t height) : width_(width), height_(height) {}
-  virtual ~OpenGLContext() = default;
-  uint32_t width() const { return this->width_; }
-  uint32_t height() const { return this->height_; }
-  virtual bool makeCurrent() const = 0;
-  virtual std::string getInfo() const = 0;
-  std::vector<uint8_t> getFramebuffer() const;
+  OpenGLContext (uint32_t width, uint32_t height)
+    : width_ (width)
+    , height_ (height) {}
+  virtual ~OpenGLContext () = default;
+  uint32_t width () const {
+    return this->width_;
+  }
+  uint32_t height () const {
+    return this->height_;
+  }
+  virtual bool makeCurrent () const = 0;
+  virtual std::string getInfo () const = 0;
+  std::vector<uint8_t> getFramebuffer () const;
 };
diff --git a/src/glview/PolySetRenderer.cc b/src/glview/PolySetRenderer.cc
index ed481c4ac..9fb981808 100644
--- a/src/glview/PolySetRenderer.cc
+++ b/src/glview/PolySetRenderer.cc
@@ -60,278 +60,273 @@
 #endif
 
 // This renderer is used in Manifold mode (F6 with Manifold as geometry engine)
-PolySetRenderer::PolySetRenderer(const std::shared_ptr<const class Geometry>& geom)
-{
-  this->addGeometry(geom);
+PolySetRenderer::PolySetRenderer (const std::shared_ptr<const class Geometry> &geom) {
+  this->addGeometry (geom);
 }
 
-void PolySetRenderer::addGeometry(const std::shared_ptr<const Geometry>& geom)
-{
-  assert(geom != nullptr);
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
-    for (const auto& item : geomlist->getChildren()) {
-      this->addGeometry(item.second);
+void PolySetRenderer::addGeometry (const std::shared_ptr<const Geometry> &geom) {
+  assert (geom != nullptr);
+  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList> (geom)) {
+    for (const auto &item : geomlist->getChildren ()) {
+      this->addGeometry (item.second);
     }
-  } else if (const auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
-    assert(ps->getDimension() == 3);
+  } else if (const auto ps = std::dynamic_pointer_cast<const PolySet> (geom)) {
+    assert (ps->getDimension () == 3);
     // We need to tessellate here, in case the generated PolySet contains concave polygons
     // See tests/data/scad/3D/features/polyhedron-concave-test.scad
-    this->polysets_.push_back(PolySetUtils::tessellate_faces(*ps));
-  } else if (const auto poly = std::dynamic_pointer_cast<const Polygon2d>(geom)) {
-    this->polygons_.emplace_back(
-      poly, std::shared_ptr<const PolySet>(poly->tessellate()));
+    this->polysets_.push_back (PolySetUtils::tessellate_faces (*ps));
+  } else if (const auto poly = std::dynamic_pointer_cast<const Polygon2d> (geom)) {
+    this->polygons_.emplace_back (
+      poly, std::shared_ptr<const PolySet> (poly->tessellate ()));
 #ifdef ENABLE_MANIFOLD
-  } else if (const auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
-    this->polysets_.push_back(mani->toPolySet());
+  } else if (const auto mani = std::dynamic_pointer_cast<const ManifoldGeometry> (geom)) {
+    this->polysets_.push_back (mani->toPolySet ());
 #endif
 #ifdef ENABLE_CGAL
-  } else if (const auto N = std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
+  } else if (const auto N = std::dynamic_pointer_cast<const CGALNefGeometry> (geom)) {
     // Note: It's rare, but possible for Nef polyhedrons to exist among geometries in Manifold mode.
     // One way is through import("file.nef3")
-    assert(N->getDimension() == 3);
-    if (!N->isEmpty()) {
-      if (auto ps = CGALUtils::createPolySetFromNefPolyhedron3(*N->p3)) {
-        ps->setConvexity(N->getConvexity());
-        this->polysets_.push_back(std::shared_ptr<PolySet>(std::move(ps)));
+    assert (N->getDimension () == 3);
+    if (!N->isEmpty ()) {
+      if (auto ps = CGALUtils::createPolySetFromNefPolyhedron3 (*N->p3)) {
+        ps->setConvexity (N->getConvexity ());
+        this->polysets_.push_back (std::shared_ptr<PolySet> (std::move (ps)));
       }
     }
 #endif // ifdef ENABLE_CGAL
   } else {
-    const auto& geom_ref = *geom.get();
-    LOG("Unsupported geom '%1$s' in PolySetRenderer", typeid(geom_ref).name());
-    assert(false && "Unsupported geom in PolySetRenderer");
+    const auto &geom_ref = *geom.get ();
+    LOG ("Unsupported geom '%1$s' in PolySetRenderer", typeid (geom_ref).name ());
+    assert (false && "Unsupported geom in PolySetRenderer");
   }
 }
 
 // Overridden from Renderer
-void PolySetRenderer::setColorScheme(const ColorScheme& cs)
-{
-  Renderer::setColorScheme(cs);
-  colormap_[ColorMode::CGAL_FACE_2D_COLOR] = ColorMap::getColor(cs, RenderColor::CGAL_FACE_2D_COLOR);
-  colormap_[ColorMode::CGAL_EDGE_2D_COLOR] = ColorMap::getColor(cs, RenderColor::CGAL_EDGE_2D_COLOR);
+void PolySetRenderer::setColorScheme (const ColorScheme &cs) {
+  Renderer::setColorScheme (cs);
+  colormap_[ColorMode::CGAL_FACE_2D_COLOR] = ColorMap::getColor (cs, RenderColor::CGAL_FACE_2D_COLOR);
+  colormap_[ColorMode::CGAL_EDGE_2D_COLOR] = ColorMap::getColor (cs, RenderColor::CGAL_EDGE_2D_COLOR);
 }
 
+void PolySetRenderer::createPolySetStates (const ShaderUtils::ShaderInfo *shaderinfo) {
+  VertexStateContainer &vertex_state_container = polyset_vertex_state_containers_.emplace_back ();
+  VBOBuilder vbo_builder (std::make_unique<VertexStateFactory> (), vertex_state_container);
 
-void PolySetRenderer::createPolySetStates(const ShaderUtils::ShaderInfo *shaderinfo) {
-  VertexStateContainer& vertex_state_container = polyset_vertex_state_containers_.emplace_back();
-  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(), vertex_state_container);
-
-  vbo_builder.addSurfaceData(); // position, normal, color
-  vbo_builder.addShaderData();
+  vbo_builder.addSurfaceData (); // position, normal, color
+  vbo_builder.addShaderData ();
   const bool enable_barycentric = true;
 
   size_t num_vertices = 0;
-  for (const auto& polyset : this->polysets_) {
-    num_vertices += calcNumVertices(*polyset);
+  for (const auto &polyset : this->polysets_) {
+    num_vertices += calcNumVertices (*polyset);
   }
-  vbo_builder.allocateBuffers(num_vertices);
+  vbo_builder.allocateBuffers (num_vertices);
 
-  for (const auto& polyset : this->polysets_) {
+  for (const auto &polyset : this->polysets_) {
     Color4f color;
-    if (!polyset->colors.empty()) color = polyset->colors[0];
-    getShaderColor(ColorMode::MATERIAL, color, color);
-    add_shader_pointers(vbo_builder, shaderinfo);
+    if (!polyset->colors.empty ())
+      color = polyset->colors[0];
+    getShaderColor (ColorMode::MATERIAL, color, color);
+    add_shader_pointers (vbo_builder, shaderinfo);
 
-    vbo_builder.writeSurface();
-    vbo_builder.create_surface(*polyset, Transform3d::Identity(), color, enable_barycentric, false);
+    vbo_builder.writeSurface ();
+    vbo_builder.create_surface (*polyset, Transform3d::Identity (), color, enable_barycentric, false);
   }
 
-  vbo_builder.createInterleavedVBOs();
+  vbo_builder.createInterleavedVBOs ();
 }
 
-void PolySetRenderer::createPolygonStates() {
-  createPolygonSurfaceStates();
-  createPolygonEdgeStates();
+void PolySetRenderer::createPolygonStates () {
+  createPolygonSurfaceStates ();
+  createPolygonEdgeStates ();
 }
 
-void PolySetRenderer::createPolygonSurfaceStates() {
-  VertexStateContainer& vertex_state_container = polygon_vertex_state_containers_.emplace_back();
-  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(), vertex_state_container);
-  vbo_builder.addSurfaceData();
+void PolySetRenderer::createPolygonSurfaceStates () {
+  VertexStateContainer &vertex_state_container = polygon_vertex_state_containers_.emplace_back ();
+  VBOBuilder vbo_builder (std::make_unique<VertexStateFactory> (), vertex_state_container);
+  vbo_builder.addSurfaceData ();
 
   size_t num_vertices = 0;
-  for (const auto&[_, polyset] : this->polygons_) {
-    num_vertices += calcNumVertices(*polyset);
+  for (const auto &[_, polyset] : this->polygons_) {
+    num_vertices += calcNumVertices (*polyset);
   }
 
-  vbo_builder.allocateBuffers(num_vertices);
+  vbo_builder.allocateBuffers (num_vertices);
 
-  std::shared_ptr<VertexState> init_state = std::make_shared<VertexState>();
-  init_state->glBegin().emplace_back([]() {
-    GL_TRACE0("glDisable(GL_LIGHTING)");
-    GL_CHECKD(glDisable(GL_LIGHTING));
+  std::shared_ptr<VertexState> init_state = std::make_shared<VertexState> ();
+  init_state->glBegin ().emplace_back ([] () {
+    GL_TRACE0 ("glDisable(GL_LIGHTING)");
+    GL_CHECKD (glDisable (GL_LIGHTING));
   });
-  vertex_state_container.states().emplace_back(std::move(init_state));
+  vertex_state_container.states ().emplace_back (std::move (init_state));
 
-  for (const auto&[polygon, polyset] : this->polygons_) {
+  for (const auto &[polygon, polyset] : this->polygons_) {
     Color4f color;
-    getColorSchemeColor(ColorMode::CGAL_FACE_2D_COLOR, color);
-    vbo_builder.create_polygons(*polyset, Transform3d::Identity(), color);
+    getColorSchemeColor (ColorMode::CGAL_FACE_2D_COLOR, color);
+    vbo_builder.create_polygons (*polyset, Transform3d::Identity (), color);
   }
 
-  vbo_builder.createInterleavedVBOs();
+  vbo_builder.createInterleavedVBOs ();
 }
 
-void PolySetRenderer::createPolygonEdgeStates() {
-  VertexStateContainer& vertex_state_container = polygon_vertex_state_containers_.emplace_back();
-  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(), vertex_state_container);
+void PolySetRenderer::createPolygonEdgeStates () {
+  VertexStateContainer &vertex_state_container = polygon_vertex_state_containers_.emplace_back ();
+  VBOBuilder vbo_builder (std::make_unique<VertexStateFactory> (), vertex_state_container);
 
-  vbo_builder.addEdgeData();
+  vbo_builder.addEdgeData ();
 
   size_t num_vertices = 0;
-  for (const auto&[polygon, _] : this->polygons_) {
-    num_vertices += calcNumEdgeVertices(*polygon);
+  for (const auto &[polygon, _] : this->polygons_) {
+    num_vertices += calcNumEdgeVertices (*polygon);
   }
 
-  vbo_builder.allocateBuffers(num_vertices);
+  vbo_builder.allocateBuffers (num_vertices);
 
-  std::shared_ptr<VertexState> edge_state = std::make_shared<VertexState>();
-  edge_state->glBegin().emplace_back([]() {
-    GL_TRACE0("glDisable(GL_DEPTH_TEST)");
-    GL_CHECKD(glDisable(GL_DEPTH_TEST));
-    GL_TRACE0("glLineWidth(2)");
-    GL_CHECKD(glLineWidth(2));
+  std::shared_ptr<VertexState> edge_state = std::make_shared<VertexState> ();
+  edge_state->glBegin ().emplace_back ([] () {
+    GL_TRACE0 ("glDisable(GL_DEPTH_TEST)");
+    GL_CHECKD (glDisable (GL_DEPTH_TEST));
+    GL_TRACE0 ("glLineWidth(2)");
+    GL_CHECKD (glLineWidth (2));
   });
-  vertex_state_container.states().emplace_back(std::move(edge_state));
+  vertex_state_container.states ().emplace_back (std::move (edge_state));
 
-  for (const auto&[polygon, _] : this->polygons_) {
+  for (const auto &[polygon, _] : this->polygons_) {
     Color4f color;
-    getColorSchemeColor(ColorMode::CGAL_EDGE_2D_COLOR, color);
-    vbo_builder.writeEdge();
-    vbo_builder.create_edges(*polygon, Transform3d::Identity(), color);
+    getColorSchemeColor (ColorMode::CGAL_EDGE_2D_COLOR, color);
+    vbo_builder.writeEdge ();
+    vbo_builder.create_edges (*polygon, Transform3d::Identity (), color);
   }
 
-  std::shared_ptr<VertexState> end_state = std::make_shared<VertexState>();
-  end_state->glBegin().emplace_back([]() {
-    GL_TRACE0("glEnable(GL_DEPTH_TEST)");
-    GL_CHECKD(glEnable(GL_DEPTH_TEST));
+  std::shared_ptr<VertexState> end_state = std::make_shared<VertexState> ();
+  end_state->glBegin ().emplace_back ([] () {
+    GL_TRACE0 ("glEnable(GL_DEPTH_TEST)");
+    GL_CHECKD (glEnable (GL_DEPTH_TEST));
   });
-  vertex_state_container.states().emplace_back(std::move(end_state));
+  vertex_state_container.states ().emplace_back (std::move (end_state));
 
-  vbo_builder.createInterleavedVBOs();
+  vbo_builder.createInterleavedVBOs ();
 }
 
-
-void PolySetRenderer::prepare(const ShaderUtils::ShaderInfo *shaderinfo)
-{
-  if (polyset_vertex_state_containers_.empty() && polygon_vertex_state_containers_.empty()) {
-    if (!this->polysets_.empty() && !this->polygons_.empty()) {
-      LOG(message_group::Error, "PolySetRenderer::prepare() called with both polysets and polygons");
-    } else if (!this->polysets_.empty()) {
-      createPolySetStates(shaderinfo);
-    } else if (!this->polygons_.empty()) {
-      createPolygonStates();
+void PolySetRenderer::prepare (const ShaderUtils::ShaderInfo *shaderinfo) {
+  if (polyset_vertex_state_containers_.empty () && polygon_vertex_state_containers_.empty ()) {
+    if (!this->polysets_.empty () && !this->polygons_.empty ()) {
+      LOG (message_group::Error, "PolySetRenderer::prepare() called with both polysets and polygons");
+    } else if (!this->polysets_.empty ()) {
+      createPolySetStates (shaderinfo);
+    } else if (!this->polygons_.empty ()) {
+      createPolygonStates ();
     }
   }
 }
 
-void PolySetRenderer::draw(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const
-{
+void PolySetRenderer::draw (bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const {
 
-  drawPolySets(showedges, shaderinfo);
-  drawPolygons();
+  drawPolySets (showedges, shaderinfo);
+  drawPolygons ();
 }
 
-void PolySetRenderer::drawPolySets(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const
-{
+void PolySetRenderer::drawPolySets (bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const {
   // Only use shader if select rendering or showedges
-  const bool enable_shader = shaderinfo && (
-    shaderinfo->type == ShaderUtils::ShaderType::EDGE_RENDERING && showedges ||
-    shaderinfo->type == ShaderUtils::ShaderType::SELECT_RENDERING);
+  const bool enable_shader = shaderinfo && (shaderinfo->type == ShaderUtils::ShaderType::EDGE_RENDERING && showedges ||
+                                            shaderinfo->type == ShaderUtils::ShaderType::SELECT_RENDERING);
   if (enable_shader) {
-    GL_TRACE("glUseProgram(%d)", shaderinfo->resource.shader_program);
-    GL_CHECKD(glUseProgram(shaderinfo->resource.shader_program));
-    VBOUtils::shader_attribs_enable(*shaderinfo);
+    GL_TRACE ("glUseProgram(%d)", shaderinfo->resource.shader_program);
+    GL_CHECKD (glUseProgram (shaderinfo->resource.shader_program));
+    VBOUtils::shader_attribs_enable (*shaderinfo);
   }
 
-  for (const auto& container : polyset_vertex_state_containers_) {
-    for (const auto& vertex_state : container.states()) {
-      const auto shader_vs = std::dynamic_pointer_cast<VBOShaderVertexState>(vertex_state);
+  for (const auto &container : polyset_vertex_state_containers_) {
+    for (const auto &vertex_state : container.states ()) {
+      const auto shader_vs = std::dynamic_pointer_cast<VBOShaderVertexState> (vertex_state);
       if (!shader_vs || (shader_vs && showedges)) {
-        vertex_state->draw();
+        vertex_state->draw ();
       }
     }
   }
 
   if (enable_shader) {
-    VBOUtils::shader_attribs_disable(*shaderinfo);
-    glUseProgram(0);
+    VBOUtils::shader_attribs_disable (*shaderinfo);
+    glUseProgram (0);
   }
 }
 
-void PolySetRenderer::drawPolygons() const {
+void PolySetRenderer::drawPolygons () const {
   // grab current state to restore after
   GLfloat current_point_size, current_line_width;
-  const GLboolean origVBOBuilderState = glIsEnabled(GL_VERTEX_ARRAY);
-  const GLboolean origNormalArrayState = glIsEnabled(GL_NORMAL_ARRAY);
-  const GLboolean origColorArrayState = glIsEnabled(GL_COLOR_ARRAY);
+  const GLboolean origVBOBuilderState = glIsEnabled (GL_VERTEX_ARRAY);
+  const GLboolean origNormalArrayState = glIsEnabled (GL_NORMAL_ARRAY);
+  const GLboolean origColorArrayState = glIsEnabled (GL_COLOR_ARRAY);
 
-  GL_CHECKD(glGetFloatv(GL_POINT_SIZE, &current_point_size));
-  GL_CHECKD(glGetFloatv(GL_LINE_WIDTH, &current_line_width));
+  GL_CHECKD (glGetFloatv (GL_POINT_SIZE, &current_point_size));
+  GL_CHECKD (glGetFloatv (GL_LINE_WIDTH, &current_line_width));
 
-  for (const auto& container : polygon_vertex_state_containers_) {
-    for (const auto& vertex_state : container.states()) {
-      if (vertex_state)vertex_state->draw();
+  for (const auto &container : polygon_vertex_state_containers_) {
+    for (const auto &vertex_state : container.states ()) {
+      if (vertex_state)
+        vertex_state->draw ();
     }
   }
 
   // restore states
-  GL_TRACE("glPointSize(%d)", current_point_size);
-  GL_CHECKD(glPointSize(current_point_size));
-  GL_TRACE("glLineWidth(%d)", current_line_width);
-  GL_CHECKD(glLineWidth(current_line_width));
-
-  if (!origVBOBuilderState) glDisableClientState(GL_VERTEX_ARRAY);
-  if (!origNormalArrayState) glDisableClientState(GL_NORMAL_ARRAY);
-  if (!origColorArrayState) glDisableClientState(GL_COLOR_ARRAY);
+  GL_TRACE ("glPointSize(%d)", current_point_size);
+  GL_CHECKD (glPointSize (current_point_size));
+  GL_TRACE ("glLineWidth(%d)", current_line_width);
+  GL_CHECKD (glLineWidth (current_line_width));
+
+  if (!origVBOBuilderState)
+    glDisableClientState (GL_VERTEX_ARRAY);
+  if (!origNormalArrayState)
+    glDisableClientState (GL_NORMAL_ARRAY);
+  if (!origColorArrayState)
+    glDisableClientState (GL_COLOR_ARRAY);
 }
 
-BoundingBox PolySetRenderer::getBoundingBox() const
-{
+BoundingBox PolySetRenderer::getBoundingBox () const {
   BoundingBox bbox;
 
-  for (const auto& ps : this->polysets_) {
-    bbox.extend(ps->getBoundingBox());
+  for (const auto &ps : this->polysets_) {
+    bbox.extend (ps->getBoundingBox ());
   }
-  for (const auto&[polygon, polyset] : this->polygons_) {
-    bbox.extend(polygon->getBoundingBox());
+  for (const auto &[polygon, polyset] : this->polygons_) {
+    bbox.extend (polygon->getBoundingBox ());
   }
   return bbox;
 }
 
-std::vector<SelectedObject> PolySetRenderer::findModelObject(const Vector3d& near_pt, const Vector3d& far_pt, int /*mouse_x*/, int /*mouse_y*/, double tolerance) {
+std::vector<SelectedObject> PolySetRenderer::findModelObject (const Vector3d &near_pt, const Vector3d &far_pt, int /*mouse_x*/, int /*mouse_y*/, double tolerance) {
   std::vector<SelectedObject> results;
   double dist_near;
   double dist_nearest = NAN;
   Vector3d pt1_nearest;
   Vector3d pt2_nearest;
-  for (const auto& ps : this->polysets_) {
-    for (const auto& pt: ps->vertices) {
-      const double dist_pt = calculateLinePointDistance(near_pt, far_pt, pt, dist_near);
+  for (const auto &ps : this->polysets_) {
+    for (const auto &pt : ps->vertices) {
+      const double dist_pt = calculateLinePointDistance (near_pt, far_pt, pt, dist_near);
       if (dist_pt < tolerance) {
-        if (isnan(dist_nearest) || dist_near < dist_nearest) {
+        if (isnan (dist_nearest) || dist_near < dist_nearest) {
           dist_nearest = dist_near;
           pt1_nearest = pt;
         }
       }
     }
   }
-  if (!isnan(dist_nearest)) {
+  if (!isnan (dist_nearest)) {
     const SelectedObject obj = {
       .type = SelectionType::SELECTION_POINT,
       .p1 = pt1_nearest,
     };
-    results.push_back(obj);
+    results.push_back (obj);
     return results;
   }
-  for (const std::shared_ptr<const PolySet>& ps : this->polysets_) {
-    for (const auto& pol : ps->indices) {
-      const int n = pol.size();
+  for (const std::shared_ptr<const PolySet> &ps : this->polysets_) {
+    for (const auto &pol : ps->indices) {
+      const int n = pol.size ();
       for (int i = 0; i < n; i++) {
         const int ind1 = pol[i];
         const int ind2 = pol[(i + 1) % n];
         double dist_lat;
-        const double dist_norm = std::fabs(calculateLineLineDistance(ps->vertices[ind1], ps->vertices[ind2], near_pt, far_pt, dist_lat));
+        const double dist_norm = std::fabs (calculateLineLineDistance (ps->vertices[ind1], ps->vertices[ind2], near_pt, far_pt, dist_lat));
         if (dist_lat >= 0 && dist_lat <= 1 && dist_norm < tolerance) {
           dist_nearest = dist_lat;
           pt1_nearest = ps->vertices[ind1];
@@ -341,13 +336,13 @@ std::vector<SelectedObject> PolySetRenderer::findModelObject(const Vector3d& nea
     }
   }
 
-  if (!isnan(dist_nearest)) {
+  if (!isnan (dist_nearest)) {
     const SelectedObject obj = {
       .type = SelectionType::SELECTION_LINE,
       .p1 = pt1_nearest,
       .p2 = pt2_nearest,
     };
-    results.push_back(obj);
+    results.push_back (obj);
     return results;
   }
   return results;
diff --git a/src/glview/PolySetRenderer.h b/src/glview/PolySetRenderer.h
index 745dde2bf..1b0e5cd9b 100644
--- a/src/glview/PolySetRenderer.h
+++ b/src/glview/PolySetRenderer.h
@@ -17,23 +17,23 @@
 class PolySetRenderer : public VBORenderer
 {
 public:
-  PolySetRenderer(const std::shared_ptr<const class Geometry>& geom);
-  ~PolySetRenderer() override = default;
-  void prepare(const ShaderUtils::ShaderInfo *shaderinfo) override;
-  void draw(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const override;
-  void setColorScheme(const ColorScheme& cs) override;
-  BoundingBox getBoundingBox() const override;
-  std::vector<SelectedObject> findModelObject(const Vector3d& near_pt, const Vector3d& far_pt, int mouse_x, int mouse_y, double tolerance) override;
+  PolySetRenderer (const std::shared_ptr<const class Geometry> &geom);
+  ~PolySetRenderer () override = default;
+  void prepare (const ShaderUtils::ShaderInfo *shaderinfo) override;
+  void draw (bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const override;
+  void setColorScheme (const ColorScheme &cs) override;
+  BoundingBox getBoundingBox () const override;
+  std::vector<SelectedObject> findModelObject (const Vector3d &near_pt, const Vector3d &far_pt, int mouse_x, int mouse_y, double tolerance) override;
 
 private:
-  void addGeometry(const std::shared_ptr<const class Geometry>& geom);
-  void createPolySetStates(const ShaderUtils::ShaderInfo *shaderinfo);
-  void createPolygonStates();
-  void createPolygonSurfaceStates();
-  void createPolygonEdgeStates();
+  void addGeometry (const std::shared_ptr<const class Geometry> &geom);
+  void createPolySetStates (const ShaderUtils::ShaderInfo *shaderinfo);
+  void createPolygonStates ();
+  void createPolygonSurfaceStates ();
+  void createPolygonEdgeStates ();
 
-  void drawPolySets(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const;
-  void drawPolygons() const;
+  void drawPolySets (bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const;
+  void drawPolygons () const;
 
   std::vector<std::shared_ptr<const class PolySet>> polysets_;
   std::vector<std::pair<std::shared_ptr<const Polygon2d>, std::shared_ptr<const PolySet>>> polygons_;
diff --git a/src/glview/RenderSettings.cc b/src/glview/RenderSettings.cc
index b7e5843fe..4e10142ec 100644
--- a/src/glview/RenderSettings.cc
+++ b/src/glview/RenderSettings.cc
@@ -3,35 +3,35 @@
 #include <string>
 #include "utils/printutils.h"
 
-std::string renderBackend3DToString(RenderBackend3D backend) {
+std::string renderBackend3DToString (RenderBackend3D backend) {
   switch (backend) {
   case RenderBackend3D::CGALBackend:
     return "CGAL";
   case RenderBackend3D::ManifoldBackend:
     return "Manifold";
   default:
-    throw std::runtime_error("Unknown rendering backend");
+    throw std::runtime_error ("Unknown rendering backend");
   }
 }
 
-RenderBackend3D renderBackend3DFromString(std::string backend) {
-  boost::algorithm::to_lower(backend);
+RenderBackend3D renderBackend3DFromString (std::string backend) {
+  boost::algorithm::to_lower (backend);
   if (backend == "cgal") {
     return RenderBackend3D::CGALBackend;
   } else if (backend == "manifold") {
     return RenderBackend3D::ManifoldBackend;
   } else {
-    if (!backend.empty()) {
-      LOG(message_group::Warning,
-          "Unknown rendering backend '%1$s'. Using default '%2$s'.",
-          backend.c_str(),
-          renderBackend3DToString(DEFAULT_RENDERING_BACKEND_3D).c_str());
+    if (!backend.empty ()) {
+      LOG (message_group::Warning,
+           "Unknown rendering backend '%1$s'. Using default '%2$s'.",
+           backend.c_str (),
+           renderBackend3DToString (DEFAULT_RENDERING_BACKEND_3D).c_str ());
     }
     return DEFAULT_RENDERING_BACKEND_3D;
   }
 }
 
-RenderSettings *RenderSettings::inst(bool erase) {
+RenderSettings *RenderSettings::inst (bool erase) {
   static auto instance = new RenderSettings;
   if (erase) {
     delete instance;
@@ -40,7 +40,7 @@ RenderSettings *RenderSettings::inst(bool erase) {
   return instance;
 }
 
-RenderSettings::RenderSettings() {
+RenderSettings::RenderSettings () {
   backend3D = DEFAULT_RENDERING_BACKEND_3D;
   openCSGTermLimit = 100000;
   far_gl_clip_limit = 100000.0;
diff --git a/src/glview/RenderSettings.h b/src/glview/RenderSettings.h
index 915f4fde0..8f6dc943f 100644
--- a/src/glview/RenderSettings.h
+++ b/src/glview/RenderSettings.h
@@ -10,18 +10,19 @@ enum class RenderBackend3D {
 
 inline constexpr RenderBackend3D DEFAULT_RENDERING_BACKEND_3D = RenderBackend3D::CGALBackend; // ManifoldBackend;
 
-std::string renderBackend3DToString(RenderBackend3D backend);
-RenderBackend3D renderBackend3DFromString(std::string backend);
+std::string renderBackend3DToString (RenderBackend3D backend);
+RenderBackend3D renderBackend3DFromString (std::string backend);
 
 class RenderSettings
 {
 public:
-  static RenderSettings *inst(bool erase = false);
+  static RenderSettings *inst (bool erase = false);
 
   RenderBackend3D backend3D;
   unsigned int openCSGTermLimit;
   double far_gl_clip_limit;
   std::string colorscheme;
+
 private:
-  RenderSettings();
+  RenderSettings ();
 };
diff --git a/src/glview/Renderer.cc b/src/glview/Renderer.cc
index 43dd3e496..d339df7a1 100644
--- a/src/glview/Renderer.cc
+++ b/src/glview/Renderer.cc
@@ -13,104 +13,104 @@
 
 #ifndef NULLGL
 
-
 namespace {
 
-GLuint compileShader(const std::string& name, GLuint shader_type) {
-  auto shader_source = ShaderUtils::loadShaderSource(name);
-  const GLuint shader = glCreateShader(shader_type);
-  auto *c_source = shader_source.c_str();
-  glShaderSource(shader, 1, (const GLchar **)&c_source, nullptr);
-  glCompileShader(shader);
+GLuint compileShader (const std::string &name, GLuint shader_type) {
+  auto shader_source = ShaderUtils::loadShaderSource (name);
+  const GLuint shader = glCreateShader (shader_type);
+  auto *c_source = shader_source.c_str ();
+  glShaderSource (shader, 1, (const GLchar **)&c_source, nullptr);
+  glCompileShader (shader);
   GLint status;
-  glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
+  glGetShaderiv (shader, GL_COMPILE_STATUS, &status);
   if (!status) {
     int loglen;
     char logbuffer[1000];
-    glGetShaderInfoLog(shader, sizeof(logbuffer), &loglen, logbuffer);
-    PRINTDB("OpenGL shader compilation error:\n%s", logbuffer);
+    glGetShaderInfoLog (shader, sizeof (logbuffer), &loglen, logbuffer);
+    PRINTDB ("OpenGL shader compilation error:\n%s", logbuffer);
     return 0;
   }
   return shader;
 }
 
-}  // namespace
+} // namespace
 
 namespace RendererUtils {
 
-CSGMode getCsgMode(const bool highlight_mode, const bool background_mode, const OpenSCADOperator type) {
+CSGMode getCsgMode (const bool highlight_mode, const bool background_mode, const OpenSCADOperator type) {
   int csgmode = highlight_mode ? CSGMODE_HIGHLIGHT : (background_mode ? CSGMODE_BACKGROUND : CSGMODE_NORMAL);
-  if (type == OpenSCADOperator::DIFFERENCE) csgmode |= CSGMODE_DIFFERENCE_FLAG;
-  return static_cast<CSGMode>(csgmode);
+  if (type == OpenSCADOperator::DIFFERENCE)
+    csgmode |= CSGMODE_DIFFERENCE_FLAG;
+  return static_cast<CSGMode> (csgmode);
 }
 
-std::string loadShaderSource(const std::string& name) {
-  std::string shaderPath = (PlatformUtils::resourcePath("shaders") / name).string();
+std::string loadShaderSource (const std::string &name) {
+  std::string shaderPath = (PlatformUtils::resourcePath ("shaders") / name).string ();
   std::ostringstream buffer;
-  const std::ifstream f(shaderPath);
-  if (f.is_open()) {
-    buffer << f.rdbuf();
+  const std::ifstream f (shaderPath);
+  if (f.is_open ()) {
+    buffer << f.rdbuf ();
   } else {
-    LOG(message_group::UI_Error, "Cannot open shader source file: '%1$s'", shaderPath);
+    LOG (message_group::UI_Error, "Cannot open shader source file: '%1$s'", shaderPath);
   }
-  return buffer.str();
+  return buffer.str ();
 }
 
-ShaderUtils::ShaderResource compileShaderProgram(const std::string& vs_str, const std::string& fs_str) {
+ShaderUtils::ShaderResource compileShaderProgram (const std::string &vs_str, const std::string &fs_str) {
   int shaderstatus;
-  const char *vs_source = vs_str.c_str();
-  const char *fs_source = fs_str.c_str();
+  const char *vs_source = vs_str.c_str ();
+  const char *fs_source = fs_str.c_str ();
   // Compile the shaders
-  GL_CHECKD(auto vertex_shader = glCreateShader(GL_VERTEX_SHADER));
-  glShaderSource(vertex_shader, 1, (const GLchar **)&vs_source, nullptr);
-  glCompileShader(vertex_shader);
-  glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &shaderstatus);
+  GL_CHECKD (auto vertex_shader = glCreateShader (GL_VERTEX_SHADER));
+  glShaderSource (vertex_shader, 1, (const GLchar **)&vs_source, nullptr);
+  glCompileShader (vertex_shader);
+  glGetShaderiv (vertex_shader, GL_COMPILE_STATUS, &shaderstatus);
   if (shaderstatus != GL_TRUE) {
     int loglen;
     char logbuffer[1000];
-    glGetShaderInfoLog(vertex_shader, sizeof(logbuffer), &loglen, logbuffer);
+    glGetShaderInfoLog (vertex_shader, sizeof (logbuffer), &loglen, logbuffer);
     // FIXME: Use OpenCAD log to error instead of stderr
-    fprintf(stderr, __FILE__ ": OpenGL vertex shader Error:\n%.*s\n\n", loglen, logbuffer);
+    fprintf (stderr, __FILE__ ": OpenGL vertex shader Error:\n%.*s\n\n", loglen, logbuffer);
     return {};
   }
 
-  GL_CHECKD(auto fragment_shader = glCreateShader(GL_FRAGMENT_SHADER));
-  glShaderSource(fragment_shader, 1, (const GLchar **)&fs_source, nullptr);
-  glCompileShader(fragment_shader);
-  glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &shaderstatus);
+  GL_CHECKD (auto fragment_shader = glCreateShader (GL_FRAGMENT_SHADER));
+  glShaderSource (fragment_shader, 1, (const GLchar **)&fs_source, nullptr);
+  glCompileShader (fragment_shader);
+  glGetShaderiv (fragment_shader, GL_COMPILE_STATUS, &shaderstatus);
   if (shaderstatus != GL_TRUE) {
     int loglen;
     char logbuffer[1000];
-    glGetShaderInfoLog(fragment_shader, sizeof(logbuffer), &loglen, logbuffer);
+    glGetShaderInfoLog (fragment_shader, sizeof (logbuffer), &loglen, logbuffer);
     // FIXME: Use OpenCAD log to error instead of stderr
-    fprintf(stderr, __FILE__ ": OpenGL fragment shader Error:\n%.*s\n\n", loglen, logbuffer);
+    fprintf (stderr, __FILE__ ": OpenGL fragment shader Error:\n%.*s\n\n", loglen, logbuffer);
     return {};
   }
 
   // Link
-  auto shader_prog = glCreateProgram();
-  glAttachShader(shader_prog, vertex_shader);
-  glAttachShader(shader_prog, fragment_shader);
-  GL_CHECKD(glLinkProgram(shader_prog));
+  auto shader_prog = glCreateProgram ();
+  glAttachShader (shader_prog, vertex_shader);
+  glAttachShader (shader_prog, fragment_shader);
+  GL_CHECKD (glLinkProgram (shader_prog));
 
   GLint status;
-  glGetProgramiv(shader_prog, GL_LINK_STATUS, &status);
+  glGetProgramiv (shader_prog, GL_LINK_STATUS, &status);
   if (status == GL_FALSE) {
     int loglen;
     char logbuffer[1000];
-    glGetProgramInfoLog(shader_prog, sizeof(logbuffer), &loglen, logbuffer);
+    glGetProgramInfoLog (shader_prog, sizeof (logbuffer), &loglen, logbuffer);
     // FIXME: Use OpenCAD log to error instead of stderr
-    fprintf(stderr, __FILE__ ": OpenGL Program Linker Error:\n%.*s\n\n", loglen, logbuffer);
+    fprintf (stderr, __FILE__ ": OpenGL Program Linker Error:\n%.*s\n\n", loglen, logbuffer);
     return {};
   } else {
-    glValidateProgram(shader_prog);
-    glGetProgramiv(shader_prog, GL_VALIDATE_STATUS, &status);
+    glValidateProgram (shader_prog);
+    glGetProgramiv (shader_prog, GL_VALIDATE_STATUS, &status);
     if (!status) {
       int loglen;
       char logbuffer[1000];
-      glGetProgramInfoLog(shader_prog, sizeof(logbuffer), &loglen, logbuffer);
+      glGetProgramInfoLog (shader_prog, sizeof (logbuffer), &loglen, logbuffer);
       // FIXME: Use OpenCAD log to error instead of stderr
-      fprintf(stderr, __FILE__ ": OpenGL Program Validation results:\n%.*s\n\n", loglen, logbuffer);
+      fprintf (stderr, __FILE__ ": OpenGL Program Validation results:\n%.*s\n\n", loglen, logbuffer);
       return {};
     }
   }
@@ -122,11 +122,10 @@ ShaderUtils::ShaderResource compileShaderProgram(const std::string& vs_str, cons
   };
 }
 
-}  // namespace RendererUtils
+} // namespace RendererUtils
 
-Renderer::Renderer()
-{
-  PRINTD("Renderer() start");
+Renderer::Renderer () {
+  PRINTD ("Renderer() start");
 
   // Setup default colors
   // The main colors, MATERIAL and CUTOUT, come from this object's
@@ -143,66 +142,77 @@ Renderer::Renderer()
   colormap_[ColorMode::HIGHLIGHT_EDGES] = {255, 171, 86, 128};
   colormap_[ColorMode::BACKGROUND_EDGES] = {150, 150, 150, 128};
 
-  Renderer::setColorScheme(ColorMap::inst()->defaultColorScheme());
+  Renderer::setColorScheme (ColorMap::inst ()->defaultColorScheme ());
 
-  PRINTD("Renderer() end");
+  PRINTD ("Renderer() end");
 }
 
-bool Renderer::getColorSchemeColor(Renderer::ColorMode colormode, Color4f& outcolor) const
-{
-  if (const auto it = colormap_.find(colormode); it != colormap_.end()) {
+bool Renderer::getColorSchemeColor (Renderer::ColorMode colormode, Color4f &outcolor) const {
+  if (const auto it = colormap_.find (colormode); it != colormap_.end ()) {
     outcolor = it->second;
     return true;
   }
   return false;
 }
 
-bool Renderer::getShaderColor(Renderer::ColorMode colormode, const Color4f& object_color,
-                              Color4f& outcolor) const
-{
+bool Renderer::getShaderColor (Renderer::ColorMode colormode, const Color4f &object_color,
+                               Color4f &outcolor) const {
   // If an object was colored, use any set components from that color, except in pure highlight mode
   if ((colormode == ColorMode::BACKGROUND || colormode != ColorMode::HIGHLIGHT)) {
-    if (object_color.hasRgb()) outcolor.setRgb(object_color.r(), object_color.g(), object_color.b());
-    if (object_color.hasAlpha()) outcolor.setAlpha(object_color.a());
-    if (outcolor.isValid()) return true;
+    if (object_color.hasRgb ())
+      outcolor.setRgb (object_color.r (), object_color.g (), object_color.b ());
+    if (object_color.hasAlpha ())
+      outcolor.setAlpha (object_color.a ());
+    if (outcolor.isValid ())
+      return true;
   }
 
   // Fill in missing components with the color from the colorscheme
   Color4f basecol;
-  if (Renderer::getColorSchemeColor(colormode, basecol)) {
-    if (!outcolor.hasRgb()) outcolor.setRgb(basecol.r(), basecol.g(), basecol.b());
-    if (!outcolor.hasAlpha()) outcolor.setAlpha(basecol.a());
+  if (Renderer::getColorSchemeColor (colormode, basecol)) {
+    if (!outcolor.hasRgb ())
+      outcolor.setRgb (basecol.r (), basecol.g (), basecol.b ());
+    if (!outcolor.hasAlpha ())
+      outcolor.setAlpha (basecol.a ());
     return true;
   }
 
   return false;
 }
 
-
-
 /* fill colormap_ with matching entries from the colorscheme. note
    this does not change Highlight or Background colors as they are not
    represented in the colorscheme (yet). Also edgecolors are currently the
    same for CGAL & OpenCSG */
-void Renderer::setColorScheme(const ColorScheme& cs) {
-  PRINTD("setColorScheme");
-  colormap_[ColorMode::MATERIAL] = ColorMap::getColor(cs, RenderColor::OPENCSG_FACE_FRONT_COLOR);
-  colormap_[ColorMode::CUTOUT] = ColorMap::getColor(cs, RenderColor::OPENCSG_FACE_BACK_COLOR);
-  colormap_[ColorMode::MATERIAL_EDGES] = ColorMap::getColor(cs, RenderColor::CGAL_EDGE_FRONT_COLOR);
-  colormap_[ColorMode::CUTOUT_EDGES] = ColorMap::getColor(cs, RenderColor::CGAL_EDGE_BACK_COLOR);
-  colormap_[ColorMode::EMPTY_SPACE] = ColorMap::getColor(cs, RenderColor::BACKGROUND_COLOR);
+void Renderer::setColorScheme (const ColorScheme &cs) {
+  PRINTD ("setColorScheme");
+  colormap_[ColorMode::MATERIAL] = ColorMap::getColor (cs, RenderColor::OPENCSG_FACE_FRONT_COLOR);
+  colormap_[ColorMode::CUTOUT] = ColorMap::getColor (cs, RenderColor::OPENCSG_FACE_BACK_COLOR);
+  colormap_[ColorMode::MATERIAL_EDGES] = ColorMap::getColor (cs, RenderColor::CGAL_EDGE_FRONT_COLOR);
+  colormap_[ColorMode::CUTOUT_EDGES] = ColorMap::getColor (cs, RenderColor::CGAL_EDGE_BACK_COLOR);
+  colormap_[ColorMode::EMPTY_SPACE] = ColorMap::getColor (cs, RenderColor::BACKGROUND_COLOR);
   colorscheme_ = &cs;
 }
 
-
-std::vector<SelectedObject> Renderer::findModelObject(const Vector3d& /*near_pt*/, const Vector3d& /*far_pt*/, int /*mouse_x*/, int /*mouse_y*/, double /*tolerance*/) { return {}; }
+std::vector<SelectedObject> Renderer::findModelObject (const Vector3d & /*near_pt*/, const Vector3d & /*far_pt*/, int /*mouse_x*/, int /*mouse_y*/, double /*tolerance*/) {
+  return {};
+}
 #else //NULLGL
 
-Renderer::Renderer() : colorscheme_(nullptr) {}
-bool Renderer::getColorSchemeColor(Renderer::ColorMode colormode, Color4f& outcolor) const {return false; }
-bool Renderer::getShaderColor(Renderer::ColorMode colormode, const Color4f& object_color, Color4f& outcolor) const { return false; }
-std::string ShaderUtils::loadShaderSource(const std::string& name) { return ""; }
-void Renderer::setColorScheme(const ColorScheme& cs) {}
-std::vector<SelectedObject> Renderer::findModelObject(const Vector3d& /*near_pt*/, const Vector3d& /*far_pt*/, int /*mouse_x*/, int /*mouse_y*/, double /*tolerance*/) { return {}; }
+Renderer::Renderer ()
+  : colorscheme_ (nullptr) {}
+bool Renderer::getColorSchemeColor (Renderer::ColorMode colormode, Color4f &outcolor) const {
+  return false;
+}
+bool Renderer::getShaderColor (Renderer::ColorMode colormode, const Color4f &object_color, Color4f &outcolor) const {
+  return false;
+}
+std::string ShaderUtils::loadShaderSource (const std::string &name) {
+  return "";
+}
+void Renderer::setColorScheme (const ColorScheme &cs) {}
+std::vector<SelectedObject> Renderer::findModelObject (const Vector3d & /*near_pt*/, const Vector3d & /*far_pt*/, int /*mouse_x*/, int /*mouse_y*/, double /*tolerance*/) {
+  return {};
+}
 
 #endif //NULLGL
diff --git a/src/glview/Renderer.h b/src/glview/Renderer.h
index 78d41edd2..cf34ce28a 100644
--- a/src/glview/Renderer.h
+++ b/src/glview/Renderer.h
@@ -18,29 +18,28 @@ namespace RendererUtils {
 #define CSGMODE_DIFFERENCE_FLAG 0x10
 
 enum CSGMode {
-  CSGMODE_NONE                  = 0x00,
-  CSGMODE_NORMAL                = 0x01,
-  CSGMODE_DIFFERENCE            = CSGMODE_NORMAL | CSGMODE_DIFFERENCE_FLAG,
-  CSGMODE_BACKGROUND            = 0x02,
+  CSGMODE_NONE = 0x00,
+  CSGMODE_NORMAL = 0x01,
+  CSGMODE_DIFFERENCE = CSGMODE_NORMAL | CSGMODE_DIFFERENCE_FLAG,
+  CSGMODE_BACKGROUND = 0x02,
   CSGMODE_BACKGROUND_DIFFERENCE = CSGMODE_BACKGROUND | CSGMODE_DIFFERENCE_FLAG,
-  CSGMODE_HIGHLIGHT             = 0x03,
-  CSGMODE_HIGHLIGHT_DIFFERENCE  = CSGMODE_HIGHLIGHT | CSGMODE_DIFFERENCE_FLAG
+  CSGMODE_HIGHLIGHT = 0x03,
+  CSGMODE_HIGHLIGHT_DIFFERENCE = CSGMODE_HIGHLIGHT | CSGMODE_DIFFERENCE_FLAG
 };
 
-CSGMode getCsgMode(const bool highlight_mode, const bool background_mode, const OpenSCADOperator type = OpenSCADOperator::UNION);
+CSGMode getCsgMode (const bool highlight_mode, const bool background_mode, const OpenSCADOperator type = OpenSCADOperator::UNION);
 
 } // namespace RendererUtils
 
 class Renderer
 {
 public:
-  Renderer();
-  virtual ~Renderer() = default;
-
-  virtual void prepare(const ShaderUtils::ShaderInfo *shaderinfo) = 0;
-  virtual void draw(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const = 0;
-  [[nodiscard]] virtual BoundingBox getBoundingBox() const = 0;
+  Renderer ();
+  virtual ~Renderer () = default;
 
+  virtual void prepare (const ShaderUtils::ShaderInfo *shaderinfo) = 0;
+  virtual void draw (bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const = 0;
+  [[nodiscard]] virtual BoundingBox getBoundingBox () const = 0;
 
   enum class ColorMode {
     NONE,
@@ -57,14 +56,14 @@ public:
     EMPTY_SPACE
   };
 
-  bool getColorSchemeColor(ColorMode colormode, Color4f& outcolor) const;
-  bool getShaderColor(Renderer::ColorMode colormode, const Color4f& object_color, Color4f& outcolor) const;
-  virtual void setColorScheme(const ColorScheme& cs);
+  bool getColorSchemeColor (ColorMode colormode, Color4f &outcolor) const;
+  bool getShaderColor (Renderer::ColorMode colormode, const Color4f &object_color, Color4f &outcolor) const;
+  virtual void setColorScheme (const ColorScheme &cs);
 
-  virtual std::vector<SelectedObject> findModelObject(const Vector3d& near_pt, const Vector3d& far_pt, int mouse_x, int mouse_y, double tolerance);
+  virtual std::vector<SelectedObject> findModelObject (const Vector3d &near_pt, const Vector3d &far_pt, int mouse_x, int mouse_y, double tolerance);
 
 protected:
   std::map<ColorMode, Color4f> colormap_;
   const ColorScheme *colorscheme_{nullptr};
-  void setupShader();
+  void setupShader ();
 };
diff --git a/src/glview/ShaderUtils.cc b/src/glview/ShaderUtils.cc
index 207462928..37e53741b 100644
--- a/src/glview/ShaderUtils.cc
+++ b/src/glview/ShaderUtils.cc
@@ -8,95 +8,95 @@
 
 namespace {
 
-GLuint compileShader(const std::string& name, GLuint shader_type) {
-  auto shader_source = ShaderUtils::loadShaderSource(name);
-  const GLuint shader = glCreateShader(shader_type);
-  auto *c_source = shader_source.c_str();
-  glShaderSource(shader, 1, (const GLchar **)&c_source, nullptr);
-  glCompileShader(shader);
+GLuint compileShader (const std::string &name, GLuint shader_type) {
+  auto shader_source = ShaderUtils::loadShaderSource (name);
+  const GLuint shader = glCreateShader (shader_type);
+  auto *c_source = shader_source.c_str ();
+  glShaderSource (shader, 1, (const GLchar **)&c_source, nullptr);
+  glCompileShader (shader);
   GLint status;
-  glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
+  glGetShaderiv (shader, GL_COMPILE_STATUS, &status);
   if (!status) {
     int loglen;
     char logbuffer[1000];
-    glGetShaderInfoLog(shader, sizeof(logbuffer), &loglen, logbuffer);
-    PRINTDB("OpenGL shader compilation error:\n%s", logbuffer);
+    glGetShaderInfoLog (shader, sizeof (logbuffer), &loglen, logbuffer);
+    PRINTDB ("OpenGL shader compilation error:\n%s", logbuffer);
     return 0;
   }
   return shader;
 }
 
-}  // namespace
+} // namespace
 
 namespace ShaderUtils {
 
-std::string loadShaderSource(const std::string& name) {
-  std::string shaderPath = (PlatformUtils::resourcePath("shaders") / name).string();
+std::string loadShaderSource (const std::string &name) {
+  std::string shaderPath = (PlatformUtils::resourcePath ("shaders") / name).string ();
   std::ostringstream buffer;
-  const std::ifstream f(shaderPath);
-  if (f.is_open()) {
-    buffer << f.rdbuf();
+  const std::ifstream f (shaderPath);
+  if (f.is_open ()) {
+    buffer << f.rdbuf ();
   } else {
-    LOG(message_group::UI_Error, "Cannot open shader source file: '%1$s'", shaderPath);
+    LOG (message_group::UI_Error, "Cannot open shader source file: '%1$s'", shaderPath);
   }
-  return buffer.str();
+  return buffer.str ();
 }
 
-ShaderResource compileShaderProgram(const std::string& vs_str, const std::string& fs_str) {
+ShaderResource compileShaderProgram (const std::string &vs_str, const std::string &fs_str) {
   int shaderstatus;
-  const char *vs_source = vs_str.c_str();
-  const char *fs_source = fs_str.c_str();
+  const char *vs_source = vs_str.c_str ();
+  const char *fs_source = fs_str.c_str ();
   // Compile the shaders
-  GL_CHECKD(auto vertex_shader = glCreateShader(GL_VERTEX_SHADER));
-  glShaderSource(vertex_shader, 1, (const GLchar **)&vs_source, nullptr);
-  glCompileShader(vertex_shader);
-  glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &shaderstatus);
+  GL_CHECKD (auto vertex_shader = glCreateShader (GL_VERTEX_SHADER));
+  glShaderSource (vertex_shader, 1, (const GLchar **)&vs_source, nullptr);
+  glCompileShader (vertex_shader);
+  glGetShaderiv (vertex_shader, GL_COMPILE_STATUS, &shaderstatus);
   if (shaderstatus != GL_TRUE) {
     int loglen;
     char logbuffer[1000];
-    glGetShaderInfoLog(vertex_shader, sizeof(logbuffer), &loglen, logbuffer);
+    glGetShaderInfoLog (vertex_shader, sizeof (logbuffer), &loglen, logbuffer);
     // FIXME: Use OpenCAD log to error instead of stderr
-    fprintf(stderr, __FILE__ ": OpenGL vertex shader Error:\n%.*s\n\n", loglen, logbuffer);
+    fprintf (stderr, __FILE__ ": OpenGL vertex shader Error:\n%.*s\n\n", loglen, logbuffer);
     return {};
   }
 
-  GL_CHECKD(auto fragment_shader = glCreateShader(GL_FRAGMENT_SHADER));
-  glShaderSource(fragment_shader, 1, (const GLchar **)&fs_source, nullptr);
-  glCompileShader(fragment_shader);
-  glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &shaderstatus);
+  GL_CHECKD (auto fragment_shader = glCreateShader (GL_FRAGMENT_SHADER));
+  glShaderSource (fragment_shader, 1, (const GLchar **)&fs_source, nullptr);
+  glCompileShader (fragment_shader);
+  glGetShaderiv (fragment_shader, GL_COMPILE_STATUS, &shaderstatus);
   if (shaderstatus != GL_TRUE) {
     int loglen;
     char logbuffer[1000];
-    glGetShaderInfoLog(fragment_shader, sizeof(logbuffer), &loglen, logbuffer);
+    glGetShaderInfoLog (fragment_shader, sizeof (logbuffer), &loglen, logbuffer);
     // FIXME: Use OpenCAD log to error instead of stderr
-    fprintf(stderr, __FILE__ ": OpenGL fragment shader Error:\n%.*s\n\n", loglen, logbuffer);
+    fprintf (stderr, __FILE__ ": OpenGL fragment shader Error:\n%.*s\n\n", loglen, logbuffer);
     return {};
   }
 
   // Link
-  auto shader_prog = glCreateProgram();
-  glAttachShader(shader_prog, vertex_shader);
-  glAttachShader(shader_prog, fragment_shader);
-  GL_CHECKD(glLinkProgram(shader_prog));
+  auto shader_prog = glCreateProgram ();
+  glAttachShader (shader_prog, vertex_shader);
+  glAttachShader (shader_prog, fragment_shader);
+  GL_CHECKD (glLinkProgram (shader_prog));
 
   GLint status;
-  glGetProgramiv(shader_prog, GL_LINK_STATUS, &status);
+  glGetProgramiv (shader_prog, GL_LINK_STATUS, &status);
   if (status == GL_FALSE) {
     int loglen;
     char logbuffer[1000];
-    glGetProgramInfoLog(shader_prog, sizeof(logbuffer), &loglen, logbuffer);
+    glGetProgramInfoLog (shader_prog, sizeof (logbuffer), &loglen, logbuffer);
     // FIXME: Use OpenCAD log to error instead of stderr
-    fprintf(stderr, __FILE__ ": OpenGL Program Linker Error:\n%.*s\n\n", loglen, logbuffer);
+    fprintf (stderr, __FILE__ ": OpenGL Program Linker Error:\n%.*s\n\n", loglen, logbuffer);
     return {};
   } else {
-    glValidateProgram(shader_prog);
-    glGetProgramiv(shader_prog, GL_VALIDATE_STATUS, &status);
+    glValidateProgram (shader_prog);
+    glGetProgramiv (shader_prog, GL_VALIDATE_STATUS, &status);
     if (!status) {
       int loglen;
       char logbuffer[1000];
-      glGetProgramInfoLog(shader_prog, sizeof(logbuffer), &loglen, logbuffer);
+      glGetProgramInfoLog (shader_prog, sizeof (logbuffer), &loglen, logbuffer);
       // FIXME: Use OpenCAD log to error instead of stderr
-      fprintf(stderr, __FILE__ ": OpenGL Program Validation results:\n%.*s\n\n", loglen, logbuffer);
+      fprintf (stderr, __FILE__ ": OpenGL Program Validation results:\n%.*s\n\n", loglen, logbuffer);
       return {};
     }
   }
@@ -108,4 +108,4 @@ ShaderResource compileShaderProgram(const std::string& vs_str, const std::string
   };
 }
 
-}  // namespace ShaderUtils
+} // namespace ShaderUtils
diff --git a/src/glview/ShaderUtils.h b/src/glview/ShaderUtils.h
index 2fcb29d55..36da83c68 100644
--- a/src/glview/ShaderUtils.h
+++ b/src/glview/ShaderUtils.h
@@ -26,7 +26,7 @@ struct ShaderInfo {
   std::unordered_map<std::string, int> attributes;
 };
 
-std::string loadShaderSource(const std::string& name);
-ShaderResource compileShaderProgram(const std::string& vs_str, const std::string& fs_str);
+std::string loadShaderSource (const std::string &name);
+ShaderResource compileShaderProgram (const std::string &vs_str, const std::string &fs_str);
 
 } // namespace ShaderUtils
diff --git a/src/glview/VBOBuilder.cc b/src/glview/VBOBuilder.cc
index d5831d0b4..ba63217e7 100644
--- a/src/glview/VBOBuilder.cc
+++ b/src/glview/VBOBuilder.cc
@@ -12,98 +12,92 @@
 #include "geometry/linalg.h"
 #include "geometry/Polygon2d.h"
 #include "utils/printutils.h"
-#include "utils/hash.h"  // IWYU pragma: keep
+#include "utils/hash.h" // IWYU pragma: keep
 
 namespace {
 
 // Since we transform each verted on the CPU, we cache already transformed vertices in the same PolySet
 // to avoid redundantly transforming the same vertex value twice, while we process non-indexed PolySets.
-Vector3d uniqueMultiply(std::unordered_map<Vector3d, Vector3d>& vert_mult_map, const Vector3d& in_vert,
-                        const Transform3d& m)
-{
-  auto entry = vert_mult_map.find(in_vert);
-  if (entry == vert_mult_map.end()) {
+Vector3d uniqueMultiply (std::unordered_map<Vector3d, Vector3d> &vert_mult_map, const Vector3d &in_vert,
+                         const Transform3d &m) {
+  auto entry = vert_mult_map.find (in_vert);
+  if (entry == vert_mult_map.end ()) {
     Vector3d out_vert = m * in_vert;
-    vert_mult_map.emplace(in_vert, out_vert);
+    vert_mult_map.emplace (in_vert, out_vert);
     return out_vert;
   }
   return entry->second;
 }
 
-}  // namespace
+} // namespace
 
-void addAttributeValues(IAttributeData&) {}
+void addAttributeValues (IAttributeData &) {}
 
-void VertexData::getLastVertex(std::vector<GLbyte>& interleaved_buffer) const
-{
-  GLbyte *dst_start = interleaved_buffer.data();
-  for (const auto& data : attributes_) {
-    size_t size = data->sizeofAttribute();
+void VertexData::getLastVertex (std::vector<GLbyte> &interleaved_buffer) const {
+  GLbyte *dst_start = interleaved_buffer.data ();
+  for (const auto &data : attributes_) {
+    size_t size = data->sizeofAttribute ();
     GLbyte *dst = dst_start;
-    const GLbyte *src = data->toBytes() + data->sizeInBytes() - data->sizeofAttribute();
-    std::memcpy((void *)dst, (void *)src, size);
+    const GLbyte *src = data->toBytes () + data->sizeInBytes () - data->sizeofAttribute ();
+    std::memcpy ((void *)dst, (void *)src, size);
     dst_start += size;
   }
 }
 
-void VertexData::remove(size_t count)
-{
-  for (const auto& data : attributes_) {
-    data->remove(count);
+void VertexData::remove (size_t count) {
+  for (const auto &data : attributes_) {
+    data->remove (count);
   }
 }
 
 // Adds attributes needed for regular 3D polygon rendering:
 // position, normal, color
-void VBOBuilder::addSurfaceData()
-{
-  auto vertex_data = std::make_shared<VertexData>();
-  vertex_data->addPositionData(std::make_shared<AttributeData<GLfloat, 3, GL_FLOAT>>());
-  vertex_data->addNormalData(std::make_shared<AttributeData<GLfloat, 3, GL_FLOAT>>());
-  vertex_data->addColorData(std::make_shared<AttributeData<GLfloat, 4, GL_FLOAT>>());
-  surface_index_ = vertices_.size();
-  vertices_.emplace_back(std::move(vertex_data));
+void VBOBuilder::addSurfaceData () {
+  auto vertex_data = std::make_shared<VertexData> ();
+  vertex_data->addPositionData (std::make_shared<AttributeData<GLfloat, 3, GL_FLOAT>> ());
+  vertex_data->addNormalData (std::make_shared<AttributeData<GLfloat, 3, GL_FLOAT>> ());
+  vertex_data->addColorData (std::make_shared<AttributeData<GLfloat, 4, GL_FLOAT>> ());
+  surface_index_ = vertices_.size ();
+  vertices_.emplace_back (std::move (vertex_data));
 }
 
-void VBOBuilder::addEdgeData()
-{
-  auto vertex_data = std::make_shared<VertexData>();
-  vertex_data->addPositionData(std::make_shared<AttributeData<GLfloat, 3, GL_FLOAT>>());
-  vertex_data->addColorData(std::make_shared<AttributeData<GLfloat, 4, GL_FLOAT>>());
-  edge_index_ = vertices_.size();
-  vertices_.emplace_back(std::move(vertex_data));
+void VBOBuilder::addEdgeData () {
+  auto vertex_data = std::make_shared<VertexData> ();
+  vertex_data->addPositionData (std::make_shared<AttributeData<GLfloat, 3, GL_FLOAT>> ());
+  vertex_data->addColorData (std::make_shared<AttributeData<GLfloat, 4, GL_FLOAT>> ());
+  edge_index_ = vertices_.size ();
+  vertices_.emplace_back (std::move (vertex_data));
 }
 
-void VBOBuilder::createVertex(const std::array<Vector3d, 3>& points,
-                              const std::array<Vector3d, 3>& normals,
-                              const Color4f& color,
-                              size_t active_point_index, size_t primitive_index,
-                              size_t shape_size, bool outlines, bool /*mirror*/)
-{
-  addAttributeValues(*(data()->positionData()), points[active_point_index][0], points[active_point_index][1], points[active_point_index][2]);
-  if (data()->hasNormalData()) {
-    addAttributeValues(*(data()->normalData()), normals[active_point_index][0], normals[active_point_index][1], normals[active_point_index][2]);
+void VBOBuilder::createVertex (const std::array<Vector3d, 3> &points,
+                               const std::array<Vector3d, 3> &normals,
+                               const Color4f &color,
+                               size_t active_point_index, size_t primitive_index,
+                               size_t shape_size, bool outlines, bool /*mirror*/) {
+  addAttributeValues (*(data ()->positionData ()), points[active_point_index][0], points[active_point_index][1], points[active_point_index][2]);
+  if (data ()->hasNormalData ()) {
+    addAttributeValues (*(data ()->normalData ()), normals[active_point_index][0], normals[active_point_index][1], normals[active_point_index][2]);
   }
-  if (data()->hasColorData()) {
-    addAttributeValues(*(data()->colorData()), color.r(), color.g(), color.b(), color.a());
+  if (data ()->hasColorData ()) {
+    addAttributeValues (*(data ()->colorData ()), color.r (), color.g (), color.b (), color.a ());
   }
 
-  if (useElements()) {
+  if (useElements ()) {
     std::vector<GLbyte> interleaved_vertex;
-    interleaved_vertex.resize(data()->stride());
-    data()->getLastVertex(interleaved_vertex);
+    interleaved_vertex.resize (data ()->stride ());
+    data ()->getLastVertex (interleaved_vertex);
     std::pair<ElementsMap::iterator, bool> entry;
-    entry.first = elements_map_.find(interleaved_vertex);
-    if (entry.first == elements_map_.end()) {
+    entry.first = elements_map_.find (interleaved_vertex);
+    if (entry.first == elements_map_.end ()) {
       // append vertex data if this is a new element
-      if (!interleaved_buffer_.empty()) {
-        memcpy(interleaved_buffer_.data() + vertices_offset_, interleaved_vertex.data(), interleaved_vertex.size());
-        data()->clear();
+      if (!interleaved_buffer_.empty ()) {
+        memcpy (interleaved_buffer_.data () + vertices_offset_, interleaved_vertex.data (), interleaved_vertex.size ());
+        data ()->clear ();
       }
-      vertices_offset_ += interleaved_vertex.size();
-      entry = elements_map_.emplace(interleaved_vertex, elements_map_.size());
+      vertices_offset_ += interleaved_vertex.size ();
+      entry = elements_map_.emplace (interleaved_vertex, elements_map_.size ());
     } else {
-      data()->remove();
+      data ()->remove ();
 #if 0
       if (OpenSCAD::debug != "") {
         // in debug, check for bad hash matches
@@ -124,59 +118,58 @@ void VBOBuilder::createVertex(const std::array<Vector3d, 3>& points,
     }
 
     // append element data
-    addAttributeValues(*elementsData(), entry.first->second);
-    elements_offset_ += elementsData()->sizeofAttribute();
+    addAttributeValues (*elementsData (), entry.first->second);
+    elements_offset_ += elementsData ()->sizeofAttribute ();
   } else { // !useElements()
-    if (interleaved_buffer_.empty()) {
-      vertices_offset_ = sizeInBytes();
+    if (interleaved_buffer_.empty ()) {
+      vertices_offset_ = sizeInBytes ();
     } else {
       std::vector<GLbyte> interleaved_vertex;
-      interleaved_vertex.resize(data()->stride());
-      data()->getLastVertex(interleaved_vertex);
-      memcpy(interleaved_buffer_.data() + vertices_offset_, interleaved_vertex.data(), interleaved_vertex.size());
-      vertices_offset_ += interleaved_vertex.size();
-      data()->clear();
+      interleaved_vertex.resize (data ()->stride ());
+      data ()->getLastVertex (interleaved_vertex);
+      memcpy (interleaved_buffer_.data () + vertices_offset_, interleaved_vertex.data (), interleaved_vertex.size ());
+      vertices_offset_ += interleaved_vertex.size ();
+      data ()->clear ();
     }
   }
 }
 
-void VBOBuilder::createInterleavedVBOs()
-{
-  for (const auto& state : vertex_state_container_.states()) {
-    state->setDrawOffset(this->indexOffset(state->drawOffset()));
+void VBOBuilder::createInterleavedVBOs () {
+  for (const auto &state : vertex_state_container_.states ()) {
+    state->setDrawOffset (this->indexOffset (state->drawOffset ()));
   }
 
   // If the upfront size was not known, the the buffer has to be built
-  size_t total_size = this->sizeInBytes();
+  size_t total_size = this->sizeInBytes ();
   // If VertexArray is not empty, and initial size is zero
-  if (interleaved_buffer_.empty() && total_size) {
-    GL_TRACE("glBindBuffer(GL_ARRAY_BUFFER, %d)", vertex_state_container_.verticesVBO());
-    GL_CHECKD(glBindBuffer(GL_ARRAY_BUFFER, vertex_state_container_.verticesVBO()));
-    GL_TRACE("glBufferData(GL_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)", total_size % (void *)nullptr);
-    GL_CHECKD(glBufferData(GL_ARRAY_BUFFER, total_size, nullptr, GL_STATIC_DRAW));
+  if (interleaved_buffer_.empty () && total_size) {
+    GL_TRACE ("glBindBuffer(GL_ARRAY_BUFFER, %d)", vertex_state_container_.verticesVBO ());
+    GL_CHECKD (glBindBuffer (GL_ARRAY_BUFFER, vertex_state_container_.verticesVBO ()));
+    GL_TRACE ("glBufferData(GL_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)", total_size % (void *)nullptr);
+    GL_CHECKD (glBufferData (GL_ARRAY_BUFFER, total_size, nullptr, GL_STATIC_DRAW));
 
     size_t dst_start = 0;
-    for (const auto& vertex_data : vertices_) {
+    for (const auto &vertex_data : vertices_) {
       // All attribute vectors need to be the same size to interleave
-      size_t idx = 0, last_size = 0, stride = vertex_data->stride();
-      for (const auto& data : vertex_data->attributes()) {
-        size_t size = data->sizeofAttribute();
-        const GLbyte *src = data->toBytes();
+      size_t idx = 0, last_size = 0, stride = vertex_data->stride ();
+      for (const auto &data : vertex_data->attributes ()) {
+        size_t size = data->sizeofAttribute ();
+        const GLbyte *src = data->toBytes ();
         size_t dst = dst_start;
 
         if (src) {
           if (idx != 0) {
-            if (last_size != data->size() / data->count()) {
-              PRINTDB("attribute data for vertex incorrect size at index %d = %d", idx % (data->size() / data->count()));
-              PRINTDB("last_size = %d", last_size);
-              assert(false);
+            if (last_size != data->size () / data->count ()) {
+              PRINTDB ("attribute data for vertex incorrect size at index %d = %d", idx % (data->size () / data->count ()));
+              PRINTDB ("last_size = %d", last_size);
+              assert (false);
             }
           }
-          last_size = data->size() / data->count();
+          last_size = data->size () / data->count ();
           for (size_t i = 0; i < last_size; ++i) {
             // This path is chosen in vertex-object-renderers non-direct mode
-            GL_TRACE("A glBufferSubData(GL_ARRAY_BUFFER, %p, %d, %p)", (void *)dst % size % (void *)src);
-            GL_CHECKD(glBufferSubData(GL_ARRAY_BUFFER, dst, size, src));
+            GL_TRACE ("A glBufferSubData(GL_ARRAY_BUFFER, %p, %d, %p)", (void *)dst % size % (void *)src);
+            GL_CHECKD (glBufferSubData (GL_ARRAY_BUFFER, dst, size, src));
             src += size;
             dst += stride;
           }
@@ -184,157 +177,155 @@ void VBOBuilder::createInterleavedVBOs()
         }
         idx++;
       }
-      dst_start = vertex_data->sizeInBytes();
+      dst_start = vertex_data->sizeInBytes ();
     }
 
-    GL_TRACE0("glBindBuffer(GL_ARRAY_BUFFER, 0)");
-    GL_CHECKD(glBindBuffer(GL_ARRAY_BUFFER, 0));
-  } else if (!interleaved_buffer_.empty()) {
-    GL_TRACE("glBindBuffer(GL_ARRAY_BUFFER, %d)", vertex_state_container_.verticesVBO());
-    GL_CHECKD(glBindBuffer(GL_ARRAY_BUFFER, vertex_state_container_.verticesVBO()));
-    GL_TRACE("glBufferData(GL_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)", interleaved_buffer_.size() % (void *)interleaved_buffer_.data());
-    GL_CHECKD(glBufferData(GL_ARRAY_BUFFER, interleaved_buffer_.size(), interleaved_buffer_.data(), GL_STATIC_DRAW));
-    GL_TRACE0("glBindBuffer(GL_ARRAY_BUFFER, 0)");
-    GL_CHECKD(glBindBuffer(GL_ARRAY_BUFFER, 0));
+    GL_TRACE0 ("glBindBuffer(GL_ARRAY_BUFFER, 0)");
+    GL_CHECKD (glBindBuffer (GL_ARRAY_BUFFER, 0));
+  } else if (!interleaved_buffer_.empty ()) {
+    GL_TRACE ("glBindBuffer(GL_ARRAY_BUFFER, %d)", vertex_state_container_.verticesVBO ());
+    GL_CHECKD (glBindBuffer (GL_ARRAY_BUFFER, vertex_state_container_.verticesVBO ()));
+    GL_TRACE ("glBufferData(GL_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)", interleaved_buffer_.size () % (void *)interleaved_buffer_.data ());
+    GL_CHECKD (glBufferData (GL_ARRAY_BUFFER, interleaved_buffer_.size (), interleaved_buffer_.data (), GL_STATIC_DRAW));
+    GL_TRACE0 ("glBindBuffer(GL_ARRAY_BUFFER, 0)");
+    GL_CHECKD (glBindBuffer (GL_ARRAY_BUFFER, 0));
   }
 
-  PRINTDB("useElements() = %d, elements_size_ = %d", useElements() % elements_size_);
-  if (useElements()) {
-    GL_TRACE("glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, %d)", vertex_state_container_.elementsVBO());
-    GL_CHECKD(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vertex_state_container_.elementsVBO()));
+  PRINTDB ("useElements() = %d, elements_size_ = %d", useElements () % elements_size_);
+  if (useElements ()) {
+    GL_TRACE ("glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, %d)", vertex_state_container_.elementsVBO ());
+    GL_CHECKD (glBindBuffer (GL_ELEMENT_ARRAY_BUFFER, vertex_state_container_.elementsVBO ()));
     if (elements_size_ == 0) {
-      GL_TRACE("glBufferData(GL_ELEMENT_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)", elements_.sizeInBytes() % (void *)nullptr);
-      GL_CHECKD(glBufferData(GL_ELEMENT_ARRAY_BUFFER, elements_.sizeInBytes(), nullptr, GL_STATIC_DRAW));
+      GL_TRACE ("glBufferData(GL_ELEMENT_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)", elements_.sizeInBytes () % (void *)nullptr);
+      GL_CHECKD (glBufferData (GL_ELEMENT_ARRAY_BUFFER, elements_.sizeInBytes (), nullptr, GL_STATIC_DRAW));
     }
     size_t last_size = 0;
-    for (const auto& e : elements_.attributes()) {
-      GL_TRACE("glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, %d, %d, %p)", last_size % e->sizeInBytes() % (void *)e->toBytes());
-      GL_CHECKD(glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, last_size, e->sizeInBytes(), e->toBytes()));
-      last_size += e->sizeInBytes();
+    for (const auto &e : elements_.attributes ()) {
+      GL_TRACE ("glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, %d, %d, %p)", last_size % e->sizeInBytes () % (void *)e->toBytes ());
+      GL_CHECKD (glBufferSubData (GL_ELEMENT_ARRAY_BUFFER, last_size, e->sizeInBytes (), e->toBytes ()));
+      last_size += e->sizeInBytes ();
     }
-    GL_TRACE0("glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0)");
-    GL_CHECKD(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0));
+    GL_TRACE0 ("glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0)");
+    GL_CHECKD (glBindBuffer (GL_ELEMENT_ARRAY_BUFFER, 0));
   }
 }
 
-void VBOBuilder::addAttributePointers(size_t start_offset)
-{
-  if (!this->data()) return;
+void VBOBuilder::addAttributePointers (size_t start_offset) {
+  if (!this->data ())
+    return;
 
-  std::shared_ptr<VertexData> vertex_data = this->data();
-  std::shared_ptr<VertexState> vertex_state = vertex_state_container_.states().back();
+  std::shared_ptr<VertexData> vertex_data = this->data ();
+  std::shared_ptr<VertexState> vertex_state = vertex_state_container_.states ().back ();
 
-  GLsizei count = vertex_data->positionData()->count();
-  GLenum type = vertex_data->positionData()->glType();
-  GLsizei stride = vertex_data->stride();
-  size_t offset = start_offset + vertex_data->interleavedOffset(vertex_data->positionIndex());
+  GLsizei count = vertex_data->positionData ()->count ();
+  GLenum type = vertex_data->positionData ()->glType ();
+  GLsizei stride = vertex_data->stride ();
+  size_t offset = start_offset + vertex_data->interleavedOffset (vertex_data->positionIndex ());
   // Note: Some code, like OpenCSGRenderer::createVBOPrimitive() relies on this order of
   // glBegin/glEnd functions for unlit/uncolored vertex rendering.
-  vertex_state->glBegin().emplace_back([]() {
-    GL_TRACE0("glEnableClientState(GL_VERTEX_ARRAY)");
-    GL_CHECKD(glEnableClientState(GL_VERTEX_ARRAY));
+  vertex_state->glBegin ().emplace_back ([] () {
+    GL_TRACE0 ("glEnableClientState(GL_VERTEX_ARRAY)");
+    GL_CHECKD (glEnableClientState (GL_VERTEX_ARRAY));
   });
-  vertex_state->glBegin().emplace_back([count, type, stride, offset, vs_ptr = std::weak_ptr<VertexState>(vertex_state)]() {
-    auto vs = vs_ptr.lock();
+  vertex_state->glBegin ().emplace_back ([count, type, stride, offset, vs_ptr = std::weak_ptr<VertexState> (vertex_state)] () {
+    auto vs = vs_ptr.lock ();
     if (vs) {
       // NOLINTBEGIN(performance-no-int-to-ptr)
-      GL_TRACE("glVertexPointer(%d, %d, %d, %p)",
-               count % type % stride % (GLvoid *)(vs->drawOffset() + offset));
-      GL_CHECKD(glVertexPointer(count, type, stride, (GLvoid *)(vs->drawOffset() + offset)));
+      GL_TRACE ("glVertexPointer(%d, %d, %d, %p)",
+                count % type % stride % (GLvoid *)(vs->drawOffset () + offset));
+      GL_CHECKD (glVertexPointer (count, type, stride, (GLvoid *)(vs->drawOffset () + offset)));
       // NOLINTEND(performance-no-int-to-ptr)
     }
   });
-  vertex_state->glEnd().emplace_back([]() {
-    GL_TRACE0("glDisableClientState(GL_VERTEX_ARRAY)");
-    GL_CHECKD(glDisableClientState(GL_VERTEX_ARRAY));
+  vertex_state->glEnd ().emplace_back ([] () {
+    GL_TRACE0 ("glDisableClientState(GL_VERTEX_ARRAY)");
+    GL_CHECKD (glDisableClientState (GL_VERTEX_ARRAY));
   });
 
-  if (vertex_data->hasNormalData()) {
-    type = vertex_data->normalData()->glType();
-    size_t offset = start_offset + vertex_data->interleavedOffset(vertex_data->normalIndex());
-    vertex_state->glBegin().emplace_back([]() {
-      GL_TRACE0("glEnableClientState(GL_NORMAL_ARRAY)");
-      GL_CHECKD(glEnableClientState(GL_NORMAL_ARRAY));
+  if (vertex_data->hasNormalData ()) {
+    type = vertex_data->normalData ()->glType ();
+    size_t offset = start_offset + vertex_data->interleavedOffset (vertex_data->normalIndex ());
+    vertex_state->glBegin ().emplace_back ([] () {
+      GL_TRACE0 ("glEnableClientState(GL_NORMAL_ARRAY)");
+      GL_CHECKD (glEnableClientState (GL_NORMAL_ARRAY));
     });
-    vertex_state->glBegin().emplace_back([type, stride, offset, vs_ptr = std::weak_ptr<VertexState>(vertex_state)]() {
-      auto vs = vs_ptr.lock();
+    vertex_state->glBegin ().emplace_back ([type, stride, offset, vs_ptr = std::weak_ptr<VertexState> (vertex_state)] () {
+      auto vs = vs_ptr.lock ();
       if (vs) {
         // NOLINTBEGIN(performance-no-int-to-ptr)
-        GL_TRACE("glNormalPointer(%d, %d, %p)", type % stride % (GLvoid *)(vs->drawOffset() + offset));
-        GL_CHECKD(glNormalPointer(type, stride, (GLvoid *)(vs->drawOffset() + offset)));
+        GL_TRACE ("glNormalPointer(%d, %d, %p)", type % stride % (GLvoid *)(vs->drawOffset () + offset));
+        GL_CHECKD (glNormalPointer (type, stride, (GLvoid *)(vs->drawOffset () + offset)));
         // NOLINTEND(performance-no-int-to-ptr)
       }
     });
-    vertex_state->glEnd().emplace_back([]() {
-      GL_TRACE0("glDisableClientState(GL_NORMAL_ARRAY)");
-      GL_CHECKD(glDisableClientState(GL_NORMAL_ARRAY));
+    vertex_state->glEnd ().emplace_back ([] () {
+      GL_TRACE0 ("glDisableClientState(GL_NORMAL_ARRAY)");
+      GL_CHECKD (glDisableClientState (GL_NORMAL_ARRAY));
     });
   }
-  if (vertex_data->hasColorData()) {
-    count = vertex_data->colorData()->count();
-    type = vertex_data->colorData()->glType();
-    size_t offset = start_offset + vertex_data->interleavedOffset(vertex_data->colorIndex());
-    vertex_state->glBegin().emplace_back([]() {
-      GL_TRACE0("glEnableClientState(GL_COLOR_ARRAY)");
-      GL_CHECKD(glEnableClientState(GL_COLOR_ARRAY));
+  if (vertex_data->hasColorData ()) {
+    count = vertex_data->colorData ()->count ();
+    type = vertex_data->colorData ()->glType ();
+    size_t offset = start_offset + vertex_data->interleavedOffset (vertex_data->colorIndex ());
+    vertex_state->glBegin ().emplace_back ([] () {
+      GL_TRACE0 ("glEnableClientState(GL_COLOR_ARRAY)");
+      GL_CHECKD (glEnableClientState (GL_COLOR_ARRAY));
     });
-    vertex_state->glBegin().emplace_back([count, type, stride, offset, vs_ptr = std::weak_ptr<VertexState>(vertex_state)]() {
-      auto vs = vs_ptr.lock();
+    vertex_state->glBegin ().emplace_back ([count, type, stride, offset, vs_ptr = std::weak_ptr<VertexState> (vertex_state)] () {
+      auto vs = vs_ptr.lock ();
       if (vs) {
         // NOLINTBEGIN(performance-no-int-to-ptr)
-        GL_TRACE("glColorPointer(%d, %d, %d, %p)", count % type % stride % (GLvoid *)(vs->drawOffset() + offset));
-        GL_CHECKD(glColorPointer(count, type, stride, (GLvoid *)(vs->drawOffset() + offset)));
+        GL_TRACE ("glColorPointer(%d, %d, %d, %p)", count % type % stride % (GLvoid *)(vs->drawOffset () + offset));
+        GL_CHECKD (glColorPointer (count, type, stride, (GLvoid *)(vs->drawOffset () + offset)));
         // NOLINTEND(performance-no-int-to-ptr)
       }
     });
-    vertex_state->glEnd().emplace_back([]() {
-      GL_TRACE0("glDisableClientState(GL_COLOR_ARRAY)");
-      GL_CHECKD(glDisableClientState(GL_COLOR_ARRAY));
+    vertex_state->glEnd ().emplace_back ([] () {
+      GL_TRACE0 ("glDisableClientState(GL_COLOR_ARRAY)");
+      GL_CHECKD (glDisableClientState (GL_COLOR_ARRAY));
     });
   }
 }
 
 // Allocates GPU memory for vertices (and elements if enabled)
 // for holding the given number of vertices.
-void VBOBuilder::allocateBuffers(size_t num_vertices) {
-  size_t vbo_buffer_size = num_vertices * stride();
-  interleaved_buffer_.resize(vbo_buffer_size);
-  GL_TRACE("glBindBuffer(GL_ARRAY_BUFFER, %d)", vertex_state_container_.verticesVBO());
-  GL_CHECKD(glBindBuffer(GL_ARRAY_BUFFER, vertex_state_container_.verticesVBO()));
-  GL_TRACE("glBufferData(GL_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)", vbo_buffer_size % (void *)nullptr);
-  GL_CHECKD(glBufferData(GL_ARRAY_BUFFER, vbo_buffer_size, nullptr, GL_STATIC_DRAW));
-  if (Feature::ExperimentalVxORenderersIndexing.is_enabled()) {
+void VBOBuilder::allocateBuffers (size_t num_vertices) {
+  size_t vbo_buffer_size = num_vertices * stride ();
+  interleaved_buffer_.resize (vbo_buffer_size);
+  GL_TRACE ("glBindBuffer(GL_ARRAY_BUFFER, %d)", vertex_state_container_.verticesVBO ());
+  GL_CHECKD (glBindBuffer (GL_ARRAY_BUFFER, vertex_state_container_.verticesVBO ()));
+  GL_TRACE ("glBufferData(GL_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)", vbo_buffer_size % (void *)nullptr);
+  GL_CHECKD (glBufferData (GL_ARRAY_BUFFER, vbo_buffer_size, nullptr, GL_STATIC_DRAW));
+  if (Feature::ExperimentalVxORenderersIndexing.is_enabled ()) {
     // Use smallest possible index data type
     if (num_vertices <= 0xff) {
-      addElementsData(std::make_shared<AttributeData<GLubyte, 1, GL_UNSIGNED_BYTE>>());
+      addElementsData (std::make_shared<AttributeData<GLubyte, 1, GL_UNSIGNED_BYTE>> ());
     } else if (num_vertices <= 0xffff) {
-      addElementsData(std::make_shared<AttributeData<GLushort, 1, GL_UNSIGNED_SHORT>>());
+      addElementsData (std::make_shared<AttributeData<GLushort, 1, GL_UNSIGNED_SHORT>> ());
     } else {
-      addElementsData(std::make_shared<AttributeData<GLuint, 1, GL_UNSIGNED_INT>>());
+      addElementsData (std::make_shared<AttributeData<GLuint, 1, GL_UNSIGNED_INT>> ());
     }
     // FIXME: How do we know how much to allocate?
     // FIXME: Should we preallocate so we don't have to make a bunch of glBufferSubData() calls?
-    size_t elements_size = num_vertices * elements_.stride();
-    setElementsSize(elements_size);
-    GL_TRACE("glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, %d)", vertex_state_container_.elementsVBO());
-    GL_CHECKD(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vertex_state_container_.elementsVBO()));
-    GL_TRACE("glBufferData(GL_ELEMENT_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)", elements_size % (void *)nullptr);
-    GL_CHECKD(glBufferData(GL_ELEMENT_ARRAY_BUFFER, elements_size, nullptr, GL_STATIC_DRAW));
+    size_t elements_size = num_vertices * elements_.stride ();
+    setElementsSize (elements_size);
+    GL_TRACE ("glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, %d)", vertex_state_container_.elementsVBO ());
+    GL_CHECKD (glBindBuffer (GL_ELEMENT_ARRAY_BUFFER, vertex_state_container_.elementsVBO ()));
+    GL_TRACE ("glBufferData(GL_ELEMENT_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)", elements_size % (void *)nullptr);
+    GL_CHECKD (glBufferData (GL_ELEMENT_ARRAY_BUFFER, elements_size, nullptr, GL_STATIC_DRAW));
   }
 }
 
 // FIXME: This specifically adds barycentric vertex attributes, so document/rename accordingly
-void VBOBuilder::addShaderData()
-{
-  const std::shared_ptr<VertexData> vertex_data = data();
-  shader_attributes_index_ = vertex_data->attributes().size();
-  vertex_data->addAttributeData(std::make_shared<AttributeData<GLubyte, 4, GL_UNSIGNED_BYTE>>()); // barycentric
+void VBOBuilder::addShaderData () {
+  const std::shared_ptr<VertexData> vertex_data = data ();
+  shader_attributes_index_ = vertex_data->attributes ().size ();
+  vertex_data->addAttributeData (std::make_shared<AttributeData<GLubyte, 4, GL_UNSIGNED_BYTE>> ()); // barycentric
 }
 
-void VBOBuilder::add_barycentric_attribute(size_t active_point_index,
-                                           size_t primitive_index, size_t shape_size, bool outlines)
-{
-  const std::shared_ptr<VertexData> vertex_data = data();
+void VBOBuilder::add_barycentric_attribute (size_t active_point_index,
+                                            size_t primitive_index, size_t shape_size, bool outlines) {
+  const std::shared_ptr<VertexData> vertex_data = data ();
 
   // Get edge states
   std::array<GLubyte, 3> barycentric_flags;
@@ -364,222 +355,223 @@ void VBOBuilder::add_barycentric_attribute(size_t active_point_index,
 
   barycentric_flags[active_point_index] = 1;
 
-  addAttributeValues(
-    *(vertex_data->attributes()[shader_attributes_index_ + BARYCENTRIC_ATTRIB]),
+  addAttributeValues (
+    *(vertex_data->attributes ()[shader_attributes_index_ + BARYCENTRIC_ATTRIB]),
     barycentric_flags[0], barycentric_flags[1], barycentric_flags[2], 0);
 }
 
-void VBOBuilder::create_triangle(const Color4f& color, const Vector3d& p0,
-                                 const Vector3d& p1, const Vector3d& p2, size_t primitive_index,
-                                 size_t shape_size, bool outlines, bool enable_barycentric, bool mirror)
-{
+void VBOBuilder::create_triangle (const Color4f &color, const Vector3d &p0,
+                                  const Vector3d &p1, const Vector3d &p2, size_t primitive_index,
+                                  size_t shape_size, bool outlines, bool enable_barycentric, bool mirror) {
   const double ax = p1[0] - p0[0], bx = p1[0] - p2[0];
   const double ay = p1[1] - p0[1], by = p1[1] - p2[1];
   const double az = p1[2] - p0[2], bz = p1[2] - p2[2];
   const double nx = ay * bz - az * by;
   const double ny = az * bx - ax * bz;
   const double nz = ax * by - ay * bx;
-  const double nl = sqrt(nx * nx + ny * ny + nz * nz);
-  const Vector3d n = Vector3d(nx / nl, ny / nl, nz / nl);
+  const double nl = sqrt (nx * nx + ny * ny + nz * nz);
+  const Vector3d n = Vector3d (nx / nl, ny / nl, nz / nl);
 
-  if (!data()) return;
+  if (!data ())
+    return;
 
   if (enable_barycentric) {
-    add_barycentric_attribute(0, primitive_index, shape_size, outlines);
+    add_barycentric_attribute (0, primitive_index, shape_size, outlines);
   }
-  createVertex({p0, p1, p2}, {n, n, n}, color, 0, primitive_index, shape_size,
-               outlines, mirror);
+  createVertex ({p0, p1, p2}, {n, n, n}, color, 0, primitive_index, shape_size,
+                outlines, mirror);
 
   if (!mirror) {
     if (enable_barycentric) {
-      add_barycentric_attribute(1, primitive_index, shape_size, outlines);
+      add_barycentric_attribute (1, primitive_index, shape_size, outlines);
     }
-    createVertex({p0, p1, p2}, {n, n, n}, color, 1, primitive_index, shape_size, outlines,
-                 mirror);
+    createVertex ({p0, p1, p2}, {n, n, n}, color, 1, primitive_index, shape_size, outlines,
+                  mirror);
   }
   if (enable_barycentric) {
-    add_barycentric_attribute(2, primitive_index, shape_size, outlines);
+    add_barycentric_attribute (2, primitive_index, shape_size, outlines);
   }
-  createVertex({p0, p1, p2}, {n, n, n}, color, 2, primitive_index, shape_size, outlines,
-               mirror);
+  createVertex ({p0, p1, p2}, {n, n, n}, color, 2, primitive_index, shape_size, outlines,
+                mirror);
   if (mirror) {
     if (enable_barycentric) {
-      add_barycentric_attribute(1, primitive_index, shape_size, outlines);
+      add_barycentric_attribute (1, primitive_index, shape_size, outlines);
     }
-    createVertex({p0, p1, p2}, {n, n, n}, color, 1, primitive_index, shape_size, outlines,
-                 mirror);
+    createVertex ({p0, p1, p2}, {n, n, n}, color, 1, primitive_index, shape_size, outlines,
+                  mirror);
   }
 }
 
 // Creates a VBO "surface" from the PolySet.
 // This will usually create a new VertexState and append it to our
 // vertex states
-void VBOBuilder::create_surface(const PolySet& ps, const Transform3d& m,
-                                const Color4f& default_color, bool enable_barycentric, bool force_default_color)
-{
-  const std::shared_ptr<VertexData> vertex_data = data();
+void VBOBuilder::create_surface (const PolySet &ps, const Transform3d &m,
+                                 const Color4f &default_color, bool enable_barycentric, bool force_default_color) {
+  const std::shared_ptr<VertexData> vertex_data = data ();
 
   if (!vertex_data) {
     return;
   }
 
-  const bool mirrored = m.matrix().determinant() < 0;
+  const bool mirrored = m.matrix ().determinant () < 0;
   size_t triangle_count = 0;
 
   std::unordered_map<Vector3d, Vector3d> vert_mult_map;
-  const auto last_size = verticesOffset();
+  const auto last_size = verticesOffset ();
 
   size_t elements_offset = 0;
-  if (useElements()) {
-    elements_offset = elementsOffset();
-    elementsMap().clear();
+  if (useElements ()) {
+    elements_offset = elementsOffset ();
+    elementsMap ().clear ();
   }
 
-  auto has_colors = !ps.color_indices.empty();
+  auto has_colors = !ps.color_indices.empty ();
 
-  for (int i = 0, n = ps.indices.size(); i < n; i++) {
-    const auto& poly = ps.indices[i];
-    const auto color_index = has_colors && i < ps.color_indices.size() ? ps.color_indices[i] : -1;
-    const auto& color = !force_default_color && color_index >= 0 && color_index < ps.colors.size() &&
-      ps.colors[color_index].isValid()
+  for (int i = 0, n = ps.indices.size (); i < n; i++) {
+    const auto &poly = ps.indices[i];
+    const auto color_index = has_colors && i < ps.color_indices.size () ? ps.color_indices[i] : -1;
+    const auto &color = !force_default_color && color_index >= 0 && color_index < ps.colors.size () &&
+                            ps.colors[color_index].isValid ()
                           ? ps.colors[color_index]
                           : default_color;
-    if (poly.size() == 3) {
-      const Vector3d p0 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(0)], m);
-      const Vector3d p1 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(1)], m);
-      const Vector3d p2 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(2)], m);
+    if (poly.size () == 3) {
+      const Vector3d p0 = uniqueMultiply (vert_mult_map, ps.vertices[poly.at (0)], m);
+      const Vector3d p1 = uniqueMultiply (vert_mult_map, ps.vertices[poly.at (1)], m);
+      const Vector3d p2 = uniqueMultiply (vert_mult_map, ps.vertices[poly.at (2)], m);
 
-      create_triangle(color, p0, p1, p2, 0, poly.size(), false, enable_barycentric, mirrored);
+      create_triangle (color, p0, p1, p2, 0, poly.size (), false, enable_barycentric, mirrored);
       triangle_count++;
-    } else if (poly.size() == 4) {
-      const Vector3d p0 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(0)], m);
-      const Vector3d p1 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(1)], m);
-      const Vector3d p2 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(2)], m);
-      const Vector3d p3 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(3)], m);
-
-      create_triangle(color, p0, p1, p3, 0, poly.size(), false, enable_barycentric, mirrored);
-      create_triangle(color, p2, p3, p1, 1, poly.size(), false, enable_barycentric, mirrored);
+    } else if (poly.size () == 4) {
+      const Vector3d p0 = uniqueMultiply (vert_mult_map, ps.vertices[poly.at (0)], m);
+      const Vector3d p1 = uniqueMultiply (vert_mult_map, ps.vertices[poly.at (1)], m);
+      const Vector3d p2 = uniqueMultiply (vert_mult_map, ps.vertices[poly.at (2)], m);
+      const Vector3d p3 = uniqueMultiply (vert_mult_map, ps.vertices[poly.at (3)], m);
+
+      create_triangle (color, p0, p1, p3, 0, poly.size (), false, enable_barycentric, mirrored);
+      create_triangle (color, p2, p3, p1, 1, poly.size (), false, enable_barycentric, mirrored);
       triangle_count += 2;
     } else {
-      Vector3d center = Vector3d::Zero();
-      for (const auto& idx : poly) {
+      Vector3d center = Vector3d::Zero ();
+      for (const auto &idx : poly) {
         center += ps.vertices[idx];
       }
-      center /= poly.size();
-      for (size_t i = 1; i <= poly.size(); i++) {
-        const Vector3d p0 = uniqueMultiply(vert_mult_map, center, m);
-        const Vector3d p1 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(i % poly.size())], m);
-        const Vector3d p2 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(i - 1)], m);
+      center /= poly.size ();
+      for (size_t i = 1; i <= poly.size (); i++) {
+        const Vector3d p0 = uniqueMultiply (vert_mult_map, center, m);
+        const Vector3d p1 = uniqueMultiply (vert_mult_map, ps.vertices[poly.at (i % poly.size ())], m);
+        const Vector3d p2 = uniqueMultiply (vert_mult_map, ps.vertices[poly.at (i - 1)], m);
 
-        create_triangle(color, p0, p2, p1, i - 1, poly.size(), false, enable_barycentric, mirrored);
+        create_triangle (color, p0, p2, p1, i - 1, poly.size (), false, enable_barycentric, mirrored);
         triangle_count++;
       }
     }
   }
 
   GLenum elements_type = 0;
-  if (useElements()) elements_type = elementsData()->glType();
-  std::shared_ptr<VertexState> vertex_state = createVertexState(
-    GL_TRIANGLES, triangle_count * 3, elements_type, writeIndex(), elements_offset);
-  vertex_state_container_.states().emplace_back(std::move(vertex_state));
-  addAttributePointers(last_size);
+  if (useElements ())
+    elements_type = elementsData ()->glType ();
+  std::shared_ptr<VertexState> vertex_state = createVertexState (
+    GL_TRIANGLES, triangle_count * 3, elements_type, writeIndex (), elements_offset);
+  vertex_state_container_.states ().emplace_back (std::move (vertex_state));
+  addAttributePointers (last_size);
 }
 
-void VBOBuilder::create_edges(const Polygon2d& polygon,
-                              const Transform3d& m,
-                              const Color4f& color)
-{
-  const std::shared_ptr<VertexData> vertex_data = data();
+void VBOBuilder::create_edges (const Polygon2d &polygon,
+                               const Transform3d &m,
+                               const Color4f &color) {
+  const std::shared_ptr<VertexData> vertex_data = data ();
 
-  if (!vertex_data) return;
+  if (!vertex_data)
+    return;
 
-  auto& vertex_states = states();
+  auto &vertex_states = states ();
   std::unordered_map<Vector3d, Vector3d> vert_mult_map;
 
   // Render only outlines
-  for (const Outline2d& o : polygon.outlines()) {
-    const auto last_size = verticesOffset();
+  for (const Outline2d &o : polygon.outlines ()) {
+    const auto last_size = verticesOffset ();
     size_t elements_offset = 0;
-    if (useElements()) {
-      elements_offset = elementsOffset();
-      elementsMap().clear();
+    if (useElements ()) {
+      elements_offset = elementsOffset ();
+      elementsMap ().clear ();
     }
-    for (const Vector2d& v : o.vertices) {
-      const Vector3d p0 = uniqueMultiply(vert_mult_map, Vector3d(v[0], v[1], 0.0), m);
-      createVertex({p0}, {}, color, 0, 0, o.vertices.size(), true, false);
+    for (const Vector2d &v : o.vertices) {
+      const Vector3d p0 = uniqueMultiply (vert_mult_map, Vector3d (v[0], v[1], 0.0), m);
+      createVertex ({p0}, {}, color, 0, 0, o.vertices.size (), true, false);
     }
 
     GLenum elements_type = 0;
-    if (useElements()) elements_type = elementsData()->glType();
-    std::shared_ptr<VertexState> line_loop = createVertexState(
-      GL_LINE_LOOP, o.vertices.size(), elements_type, writeIndex(), elements_offset);
-    vertex_states.emplace_back(std::move(line_loop));
-    addAttributePointers(last_size);
+    if (useElements ())
+      elements_type = elementsData ()->glType ();
+    std::shared_ptr<VertexState> line_loop = createVertexState (
+      GL_LINE_LOOP, o.vertices.size (), elements_type, writeIndex (), elements_offset);
+    vertex_states.emplace_back (std::move (line_loop));
+    addAttributePointers (last_size);
   }
 }
 
-void VBOBuilder::create_polygons(const PolySet& ps, const Transform3d& m, const Color4f& color)
-{
-  assert(ps.getDimension() == 2);
-  const std::shared_ptr<VertexData> vertex_data = data();
+void VBOBuilder::create_polygons (const PolySet &ps, const Transform3d &m, const Color4f &color) {
+  assert (ps.getDimension () == 2);
+  const std::shared_ptr<VertexData> vertex_data = data ();
 
-  if (!vertex_data) return;
+  if (!vertex_data)
+    return;
 
-  auto& vertex_states = states();
+  auto &vertex_states = states ();
   std::unordered_map<Vector3d, Vector3d> vert_mult_map;
 
-  PRINTD("create_polygons 2D");
-  const bool mirrored = m.matrix().determinant() < 0;
+  PRINTD ("create_polygons 2D");
+  const bool mirrored = m.matrix ().determinant () < 0;
   size_t triangle_count = 0;
-  const auto last_size = verticesOffset();
+  const auto last_size = verticesOffset ();
   size_t elements_offset = 0;
-  if (useElements()) {
-    elements_offset = elementsOffset();
-    elementsMap().clear();
+  if (useElements ()) {
+    elements_offset = elementsOffset ();
+    elementsMap ().clear ();
   }
 
-  for (const auto& poly : ps.indices) {
-    if (poly.size() == 3) {
-      const Vector3d p0 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(0)], m);
-      const Vector3d p1 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(1)], m);
-      const Vector3d p2 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(2)], m);
+  for (const auto &poly : ps.indices) {
+    if (poly.size () == 3) {
+      const Vector3d p0 = uniqueMultiply (vert_mult_map, ps.vertices[poly.at (0)], m);
+      const Vector3d p1 = uniqueMultiply (vert_mult_map, ps.vertices[poly.at (1)], m);
+      const Vector3d p2 = uniqueMultiply (vert_mult_map, ps.vertices[poly.at (2)], m);
 
-      create_triangle(color, p0, p1, p2, 0, poly.size(), false, false, mirrored);
+      create_triangle (color, p0, p1, p2, 0, poly.size (), false, false, mirrored);
       triangle_count++;
-    } else if (poly.size() == 4) {
-      const Vector3d p0 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(0)], m);
-      const Vector3d p1 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(1)], m);
-      const Vector3d p2 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(2)], m);
-      const Vector3d p3 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(3)], m);
-
-      create_triangle(color, p0, p1, p3, 0, poly.size(), false, false, mirrored);
-      create_triangle(color, p2, p3, p1, 1, poly.size(), false, false, mirrored);
+    } else if (poly.size () == 4) {
+      const Vector3d p0 = uniqueMultiply (vert_mult_map, ps.vertices[poly.at (0)], m);
+      const Vector3d p1 = uniqueMultiply (vert_mult_map, ps.vertices[poly.at (1)], m);
+      const Vector3d p2 = uniqueMultiply (vert_mult_map, ps.vertices[poly.at (2)], m);
+      const Vector3d p3 = uniqueMultiply (vert_mult_map, ps.vertices[poly.at (3)], m);
+
+      create_triangle (color, p0, p1, p3, 0, poly.size (), false, false, mirrored);
+      create_triangle (color, p2, p3, p1, 1, poly.size (), false, false, mirrored);
       triangle_count += 2;
     } else {
-      Vector3d center = Vector3d::Zero();
-      for (const auto& point : poly) {
+      Vector3d center = Vector3d::Zero ();
+      for (const auto &point : poly) {
         center[0] += ps.vertices[point][0];
         center[1] += ps.vertices[point][1];
       }
-      center[0] /= poly.size();
-      center[1] /= poly.size();
+      center[0] /= poly.size ();
+      center[1] /= poly.size ();
 
-      for (size_t i = 1; i <= poly.size(); i++) {
-        const Vector3d p0 = uniqueMultiply(vert_mult_map, center, m);
-        const Vector3d p1 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(i % poly.size())], m);
-        const Vector3d p2 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(i - 1)], m);
+      for (size_t i = 1; i <= poly.size (); i++) {
+        const Vector3d p0 = uniqueMultiply (vert_mult_map, center, m);
+        const Vector3d p1 = uniqueMultiply (vert_mult_map, ps.vertices[poly.at (i % poly.size ())], m);
+        const Vector3d p2 = uniqueMultiply (vert_mult_map, ps.vertices[poly.at (i - 1)], m);
 
-        create_triangle(color, p0, p2, p1, i - 1, poly.size(), false, false, mirrored);
+        create_triangle (color, p0, p2, p1, i - 1, poly.size (), false, false, mirrored);
         triangle_count++;
       }
     }
   }
 
   GLenum elements_type = 0;
-  if (useElements()) elements_type = elementsData()->glType();
-  std::shared_ptr<VertexState> vs = createVertexState(
-    GL_TRIANGLES, triangle_count * 3, elements_type, writeIndex(), elements_offset);
-  vertex_states.emplace_back(std::move(vs));
-  addAttributePointers(last_size);
+  if (useElements ())
+    elements_type = elementsData ()->glType ();
+  std::shared_ptr<VertexState> vs = createVertexState (
+    GL_TRIANGLES, triangle_count * 3, elements_type, writeIndex (), elements_offset);
+  vertex_states.emplace_back (std::move (vs));
+  addAttributePointers (last_size);
 }
-
diff --git a/src/glview/VBOBuilder.h b/src/glview/VBOBuilder.h
index 3a2f30c82..39c4c037d 100644
--- a/src/glview/VBOBuilder.h
+++ b/src/glview/VBOBuilder.h
@@ -25,9 +25,10 @@ enum ShaderAttribIndex {
 // Hash function for opengl vertex data.
 template <typename T>
 struct vertex_hash {
-  std::size_t operator()(T const& vertex) const {
+  std::size_t operator() (T const &vertex) const {
     size_t seed = 0;
-    for (size_t i = 0; i < vertex.size(); ++i) boost::hash_combine(seed, vertex.data()[i]);
+    for (size_t i = 0; i < vertex.size (); ++i)
+      boost::hash_combine (seed, vertex.data ()[i]);
     return seed;
   }
 };
@@ -38,54 +39,54 @@ using ElementsMap = std::unordered_map<std::vector<GLbyte>, GLuint, vertex_hash<
 class IAttributeData
 {
 public:
-  IAttributeData() = default;
-  virtual ~IAttributeData() = default;
+  IAttributeData () = default;
+  virtual ~IAttributeData () = default;
 
   // Return number of elements that make up one attribute
-  [[nodiscard]] virtual size_t count() const = 0;
+  [[nodiscard]] virtual size_t count () const = 0;
   // Return number of elements in vector
-  [[nodiscard]] virtual size_t size() const = 0;
+  [[nodiscard]] virtual size_t size () const = 0;
   // Return size in bytes of the element type
-  [[nodiscard]] virtual size_t sizeofType() const = 0;
+  [[nodiscard]] virtual size_t sizeofType () const = 0;
   // Return the total size in bytes of one attribute
-  [[nodiscard]] virtual size_t sizeofAttribute() const = 0;
+  [[nodiscard]] virtual size_t sizeofAttribute () const = 0;
   // Return the total size in bytes of entire element vector
-  [[nodiscard]] virtual size_t sizeInBytes() const = 0;
+  [[nodiscard]] virtual size_t sizeInBytes () const = 0;
   // Return the OpenGL type of the element
-  [[nodiscard]] virtual GLenum glType() const = 0;
+  [[nodiscard]] virtual GLenum glType () const = 0;
   // Return pointer to the raw bytes of the element vector
-  [[nodiscard]] virtual const GLbyte *toBytes() const = 0;
+  [[nodiscard]] virtual const GLbyte *toBytes () const = 0;
   // Clear the entire attribute
-  virtual void clear() = 0;
+  virtual void clear () = 0;
   // Remove data from the end of the attribute
-  virtual void remove(size_t count) = 0;
+  virtual void remove (size_t count) = 0;
 
   // Add common types to element vector
-  virtual void addData(GLbyte data) = 0;
-  virtual void addData(GLshort data) = 0;
-  virtual void addData(GLushort data) = 0;
-  virtual void addData(GLint data) = 0;
-  virtual void addData(GLuint data) = 0;
-  virtual void addData(GLfloat data) = 0;
-  virtual void addData(GLdouble data) = 0;
+  virtual void addData (GLbyte data) = 0;
+  virtual void addData (GLshort data) = 0;
+  virtual void addData (GLushort data) = 0;
+  virtual void addData (GLint data) = 0;
+  virtual void addData (GLuint data) = 0;
+  virtual void addData (GLfloat data) = 0;
+  virtual void addData (GLdouble data) = 0;
 };
 
 // Helper function to finish recursion in addAttributeValues call
-void addAttributeValues(IAttributeData&);
+void addAttributeValues (IAttributeData &);
 // Template helper function to load multiple attribute values in one call
-template <typename T, typename ... Args>
-void addAttributeValues(IAttributeData& attrib, T value, Args... values) {
-  attrib.addData(value);
-  addAttributeValues(attrib, values ...);
+template <typename T, typename... Args>
+void addAttributeValues (IAttributeData &attrib, T value, Args... values) {
+  attrib.addData (value);
+  addAttributeValues (attrib, values...);
 }
 
 // Template helper function to load multiple copies of the same multiple attribute values in one call.
 // Used to add the same normal and colors to multiple triangle points.
-template <typename T, typename ... Args>
-void addAttributeValues(size_t copies, IAttributeData& attrib, T value, Args... values) {
+template <typename T, typename... Args>
+void addAttributeValues (size_t copies, IAttributeData &attrib, T value, Args... values) {
   if (copies > 0) {
-    addAttributeValues(attrib, value, values ...);
-    addAttributeValues(copies - 1, attrib, value, values ...);
+    addAttributeValues (attrib, value, values...);
+    addAttributeValues (copies - 1, attrib, value, values...);
   }
 }
 
@@ -94,32 +95,69 @@ template <typename T, size_t C, GLenum E>
 class AttributeData : public IAttributeData
 {
 public:
-  AttributeData() : data_() {}
-
-  [[nodiscard]] inline size_t count() const override { return C; }
-  [[nodiscard]] inline size_t size() const override { return data_.size(); }
-  [[nodiscard]] inline size_t sizeofType() const override { return sizeof(T); }
-  [[nodiscard]] inline size_t sizeofAttribute() const override { return sizeof(T) * C; }
-  [[nodiscard]] inline size_t sizeInBytes() const override { return data_.size() * sizeof(T); }
-  [[nodiscard]] inline GLenum glType() const override { return E; }
-  void clear() override { data_.clear(); }
-  void remove(size_t count) override { data_.erase(data_.end() - (count * C), data_.end()); }
-  [[nodiscard]] inline const GLbyte *toBytes() const override { return (GLbyte *)(data_.data()); }
-
-  inline void addData(GLbyte value) override { add_data((T)value); }
-  inline void addData(GLshort value) override { add_data((T)value); }
-  inline void addData(GLushort value) override { add_data((T)value); }
-  inline void addData(GLint value) override { add_data((T)value); }
-  inline void addData(GLuint value) override { add_data((T)value); }
-  inline void addData(GLfloat value) override { add_data((T)value); }
-  inline void addData(GLdouble value) override { add_data((T)value); }
+  AttributeData ()
+    : data_ () {}
+
+  [[nodiscard]] inline size_t count () const override {
+    return C;
+  }
+  [[nodiscard]] inline size_t size () const override {
+    return data_.size ();
+  }
+  [[nodiscard]] inline size_t sizeofType () const override {
+    return sizeof (T);
+  }
+  [[nodiscard]] inline size_t sizeofAttribute () const override {
+    return sizeof (T) * C;
+  }
+  [[nodiscard]] inline size_t sizeInBytes () const override {
+    return data_.size () * sizeof (T);
+  }
+  [[nodiscard]] inline GLenum glType () const override {
+    return E;
+  }
+  void clear () override {
+    data_.clear ();
+  }
+  void remove (size_t count) override {
+    data_.erase (data_.end () - (count * C), data_.end ());
+  }
+  [[nodiscard]] inline const GLbyte *toBytes () const override {
+    return (GLbyte *)(data_.data ());
+  }
+
+  inline void addData (GLbyte value) override {
+    add_data ((T)value);
+  }
+  inline void addData (GLshort value) override {
+    add_data ((T)value);
+  }
+  inline void addData (GLushort value) override {
+    add_data ((T)value);
+  }
+  inline void addData (GLint value) override {
+    add_data ((T)value);
+  }
+  inline void addData (GLuint value) override {
+    add_data ((T)value);
+  }
+  inline void addData (GLfloat value) override {
+    add_data ((T)value);
+  }
+  inline void addData (GLdouble value) override {
+    add_data ((T)value);
+  }
 
   // Return the template type element vector
-  [[nodiscard]] inline std::shared_ptr<std::vector<T>> getData() const { return std::shared_ptr<std::vector<T>>(data_); }
+  [[nodiscard]] inline std::shared_ptr<std::vector<T>> getData () const {
+    return std::shared_ptr<std::vector<T>> (data_);
+  }
 
 private:
   // Internal method to add data of template type to element vector
-  void add_data(T value) { data_.emplace_back(value); }
+  void add_data (T value) {
+    data_.emplace_back (value);
+  }
 
   std::vector<T> data_;
 };
@@ -128,91 +166,130 @@ private:
 class VertexData
 {
 public:
-  VertexData() : position_data_(nullptr), normal_data_(nullptr), color_data_(nullptr) {}
-  virtual ~VertexData() = default;
+  VertexData ()
+    : position_data_ (nullptr)
+    , normal_data_ (nullptr)
+    , color_data_ (nullptr) {}
+  virtual ~VertexData () = default;
 
   // Add generic attribute data to vertex vector
-  void addAttributeData(std::shared_ptr<IAttributeData> data)
-  {
-    stride_ += data->sizeofAttribute();
-    attributes_.emplace_back(data);
+  void addAttributeData (std::shared_ptr<IAttributeData> data) {
+    stride_ += data->sizeofAttribute ();
+    attributes_.emplace_back (data);
   }
 
   // Add position attribute data to vertex vector
-  void addPositionData(std::shared_ptr<IAttributeData> data)
-  {
-    position_index_ = attributes_.size();
-    stride_ += data->sizeofAttribute();
-    position_data_ = attributes_.emplace_back(std::move(data));
+  void addPositionData (std::shared_ptr<IAttributeData> data) {
+    position_index_ = attributes_.size ();
+    stride_ += data->sizeofAttribute ();
+    position_data_ = attributes_.emplace_back (std::move (data));
   }
   // Add normal attribute data to vertex vector
-  void addNormalData(std::shared_ptr<IAttributeData> data)
-  {
-    normal_index_ = attributes_.size();
-    stride_ += data->sizeofAttribute();
-    normal_data_ = attributes_.emplace_back(std::move(data));
+  void addNormalData (std::shared_ptr<IAttributeData> data) {
+    normal_index_ = attributes_.size ();
+    stride_ += data->sizeofAttribute ();
+    normal_data_ = attributes_.emplace_back (std::move (data));
   }
   // Add color attribute data to vertex vector
-  void addColorData(std::shared_ptr<IAttributeData> data)
-  {
-    color_index_ = attributes_.size();
-    stride_ += data->sizeofAttribute();
-    color_data_ = attributes_.emplace_back(std::move(data));
+  void addColorData (std::shared_ptr<IAttributeData> data) {
+    color_index_ = attributes_.size ();
+    stride_ += data->sizeofAttribute ();
+    color_data_ = attributes_.emplace_back (std::move (data));
   }
 
-  void clear() { for (auto& a : attributes_) a->clear(); }
+  void clear () {
+    for (auto &a : attributes_)
+      a->clear ();
+  }
   // Remove the last n interleaved vertices
-  void remove(size_t count = 1);
+  void remove (size_t count = 1);
 
   // Return reference to internal IAttributeData vector
-  [[nodiscard]] inline const std::vector<std::shared_ptr<IAttributeData>>& attributes() const { return attributes_; }
+  [[nodiscard]] inline const std::vector<std::shared_ptr<IAttributeData>> &attributes () const {
+    return attributes_;
+  }
   // Return reference to the last added IAttributeData. This is typically where elements data is stored.
-  [[nodiscard]] inline const std::shared_ptr<IAttributeData> attributeData() const { if (attributes_.size()) return attributes_.back(); else return nullptr; }
+  [[nodiscard]] inline const std::shared_ptr<IAttributeData> attributeData () const {
+    if (attributes_.size ())
+      return attributes_.back ();
+    else
+      return nullptr;
+  }
   // Return reference to position attribute data
-  [[nodiscard]] inline const std::shared_ptr<IAttributeData>& positionData() const { return position_data_; }
+  [[nodiscard]] inline const std::shared_ptr<IAttributeData> &positionData () const {
+    return position_data_;
+  }
   // Return reference to normal attribute data
-  [[nodiscard]] inline const std::shared_ptr<IAttributeData>& normalData() const { return normal_data_; }
+  [[nodiscard]] inline const std::shared_ptr<IAttributeData> &normalData () const {
+    return normal_data_;
+  }
   // Return reference to color data
-  [[nodiscard]] inline const std::shared_ptr<IAttributeData>& colorData() const { return color_data_; }
+  [[nodiscard]] inline const std::shared_ptr<IAttributeData> &colorData () const {
+    return color_data_;
+  }
   // Check if VertexData has position data
-  [[nodiscard]] inline bool hasPositionData() const { return (position_data_ != nullptr); }
+  [[nodiscard]] inline bool hasPositionData () const {
+    return (position_data_ != nullptr);
+  }
   // Return position attribute data vector index
-  [[nodiscard]] inline size_t positionIndex() const { return position_index_; }
+  [[nodiscard]] inline size_t positionIndex () const {
+    return position_index_;
+  }
   // Check if VertexData has normal data
-  [[nodiscard]] inline bool hasNormalData() const { return (normal_data_ != nullptr); }
+  [[nodiscard]] inline bool hasNormalData () const {
+    return (normal_data_ != nullptr);
+  }
   // Return normal attribute data vector index
-  [[nodiscard]] inline size_t normalIndex() const { return normal_index_; }
+  [[nodiscard]] inline size_t normalIndex () const {
+    return normal_index_;
+  }
   // Check if VertexData has color data
-  [[nodiscard]] inline bool hasColorData() const { return (color_data_ != nullptr); }
+  [[nodiscard]] inline bool hasColorData () const {
+    return (color_data_ != nullptr);
+  }
   // Return color attribute data vector index
-  [[nodiscard]] inline size_t colorIndex() const { return color_index_; }
+  [[nodiscard]] inline size_t colorIndex () const {
+    return color_index_;
+  }
   // Return stride of VertexData
-  [[nodiscard]] inline size_t stride() const { return stride_; }
+  [[nodiscard]] inline size_t stride () const {
+    return stride_;
+  }
 
   // Calculate the offset of interleaved attribute data based on VertexData index
-  [[nodiscard]] size_t interleavedOffset(size_t index) const {
-    if (index && attributes_.size()) {
+  [[nodiscard]] size_t interleavedOffset (size_t index) const {
+    if (index && attributes_.size ()) {
       --index;
-      return (attributes_[index]->sizeofAttribute() + interleavedOffset(index));
+      return (attributes_[index]->sizeofAttribute () + interleavedOffset (index));
     }
     return 0;
   }
   // Calculate the total size of the buffer in bytes
-  [[nodiscard]] size_t sizeInBytes() const { size_t size = 0; for (const auto& data : attributes_) size += data->sizeInBytes(); return size; }
+  [[nodiscard]] size_t sizeInBytes () const {
+    size_t size = 0;
+    for (const auto &data : attributes_)
+      size += data->sizeInBytes ();
+    return size;
+  }
   // Calculate the total number of items in buffer
-  [[nodiscard]] inline size_t size() const {
+  [[nodiscard]] inline size_t size () const {
     if (stride_) {
-      return sizeInBytes() / stride();
+      return sizeInBytes () / stride ();
     } else {
-      size_t size = 0; for (const auto& data : attributes_) size += data->size(); return size;
+      size_t size = 0;
+      for (const auto &data : attributes_)
+        size += data->size ();
+      return size;
     }
   }
-  [[nodiscard]] inline bool empty() const { return attributes_.empty(); }
+  [[nodiscard]] inline bool empty () const {
+    return attributes_.empty ();
+  }
 
-  void allocateBuffers(size_t num_vertices);
+  void allocateBuffers (size_t num_vertices);
 
   // Get the last interleaved vertex
-  void getLastVertex(std::vector<GLbyte>& interleaved_buffer) const;
+  void getLastVertex (std::vector<GLbyte> &interleaved_buffer) const;
   // Create an interleaved buffer in the provided vbo.
   // If the vbo does not exist it will be created and returned.
   // void createInterleavedVBO(GLuint& vbo) const;
@@ -232,121 +309,162 @@ private:
 class VBOBuilder
 {
 public:
-  VBOBuilder(std::unique_ptr<VertexStateFactory> factory, VertexStateContainer& vertex_state_container)
-    : factory_(std::move(factory)), vertex_state_container_(vertex_state_container)
-  {
+  VBOBuilder (std::unique_ptr<VertexStateFactory> factory, VertexStateContainer &vertex_state_container)
+    : factory_ (std::move (factory))
+    , vertex_state_container_ (vertex_state_container) {
   }
 
-  virtual ~VBOBuilder() {
-    if (Feature::ExperimentalVxORenderersIndexing.is_enabled()) {
-      GL_TRACE0("glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0)");
-      GL_CHECKD(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0));
+  virtual ~VBOBuilder () {
+    if (Feature::ExperimentalVxORenderersIndexing.is_enabled ()) {
+      GL_TRACE0 ("glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0)");
+      GL_CHECKD (glBindBuffer (GL_ELEMENT_ARRAY_BUFFER, 0));
     }
-    GL_TRACE0("glBindBuffer(GL_ARRAY_BUFFER, 0)");
-    GL_CHECKD(glBindBuffer(GL_ARRAY_BUFFER, 0));
+    GL_TRACE0 ("glBindBuffer(GL_ARRAY_BUFFER, 0)");
+    GL_CHECKD (glBindBuffer (GL_ARRAY_BUFFER, 0));
   }
 
   // Add common surface data vertex layout PNC
-  void addSurfaceData();
+  void addSurfaceData ();
   // Add common edge data vertex layout PC
-  void addEdgeData();
+  void addEdgeData ();
   // Add elements data to VertexArray
-  void addElementsData(std::shared_ptr<IAttributeData> data) {
-    elements_.addAttributeData(std::move(data));
+  void addElementsData (std::shared_ptr<IAttributeData> data) {
+    elements_.addAttributeData (std::move (data));
   }
 
   // Clear all data from the VertexArray
-  void clear() { for (auto& v : vertices_) v->clear(); }
+  void clear () {
+    for (auto &v : vertices_)
+      v->clear ();
+  }
 
   // Create a single vertex in the VertexArray
   // The method parameters provide a common interface to pass all data
   // necessary to create a complete vertex
-  void createVertex(const std::array<Vector3d, 3>& points,
-                    const std::array<Vector3d, 3>& normals,
-                    const Color4f& color,
-                    size_t active_point_index = 0, size_t primitive_index = 0,
-                    size_t shape_size = 0,
-                    bool outlines = false, bool mirror = false);
+  void createVertex (const std::array<Vector3d, 3> &points,
+                     const std::array<Vector3d, 3> &normals,
+                     const Color4f &color,
+                     size_t active_point_index = 0, size_t primitive_index = 0,
+                     size_t shape_size = 0,
+                     bool outlines = false, bool mirror = false);
 
   // Return reference to the VertexStates
-  inline std::vector<std::shared_ptr<VertexState>>& states() { return vertex_state_container_.states(); }
+  inline std::vector<std::shared_ptr<VertexState>> &states () {
+    return vertex_state_container_.states ();
+  }
   // Return reference to VertexData at current internal write index
-  inline std::shared_ptr<VertexData> data() { return vertices_[write_index_]; }
+  inline std::shared_ptr<VertexData> data () {
+    return vertices_[write_index_];
+  }
   // Return reference to elements
-  inline VertexData& elements() { return elements_; }
+  inline VertexData &elements () {
+    return elements_;
+  }
   // Return reference to elements data if it exists
-  inline std::shared_ptr<IAttributeData> elementsData() { return elements_.attributeData(); }
+  inline std::shared_ptr<IAttributeData> elementsData () {
+    return elements_.attributeData ();
+  }
   // Return the number of VertexData in the array
-  inline size_t size() const { return vertices_.size(); }
+  inline size_t size () const {
+    return vertices_.size ();
+  }
   // Calculate the total size of the buffer in bytes
-  inline size_t sizeInBytes() const { size_t size = 0; for (const auto& data : vertices_) size += data->sizeInBytes(); return size; }
+  inline size_t sizeInBytes () const {
+    size_t size = 0;
+    for (const auto &data : vertices_)
+      size += data->sizeInBytes ();
+    return size;
+  }
   // Return the current internal write index
-  inline size_t writeIndex() const { return write_index_; }
+  inline size_t writeIndex () const {
+    return write_index_;
+  }
   // Set the internal write index to the surface index
-  inline void writeSurface() { write_index_ = surface_index_; }
+  inline void writeSurface () {
+    write_index_ = surface_index_;
+  }
   // Set the internal write index to the edge index
-  inline void writeEdge() { write_index_ = edge_index_; }
+  inline void writeEdge () {
+    write_index_ = edge_index_;
+  }
   // Return the total stride for all buffers
-  inline size_t stride() const {
-    size_t stride = 0; for (const auto& v : vertices_) {
-      stride += v->stride();
+  inline size_t stride () const {
+    size_t stride = 0;
+    for (const auto &v : vertices_) {
+      stride += v->stride ();
     }
     return stride;
   }
 
   // Calculate and return the offset in bytes of a given index
-  size_t indexOffset(size_t index) const {
+  size_t indexOffset (size_t index) const {
     if (index) {
       --index;
-      return vertices_[index]->sizeInBytes() + indexOffset(index);
+      return vertices_[index]->sizeInBytes () + indexOffset (index);
     }
     return 0;
   }
 
   // Use VertexStateFactory to create a new VertexState object
-  std::shared_ptr<VertexState> createVertexState(GLenum draw_mode, size_t draw_size, GLenum draw_type, size_t draw_offset, size_t element_offset) const {
-    return factory_->createVertexState(draw_mode, draw_size, draw_type, draw_offset, element_offset,
-                                       vertex_state_container_.verticesVBO(), vertex_state_container_.elementsVBO());
+  std::shared_ptr<VertexState> createVertexState (GLenum draw_mode, size_t draw_size, GLenum draw_type, size_t draw_offset, size_t element_offset) const {
+    return factory_->createVertexState (draw_mode, draw_size, draw_type, draw_offset, element_offset,
+                                        vertex_state_container_.verticesVBO (), vertex_state_container_.elementsVBO ());
   }
 
-  void allocateBuffers(size_t num_vertices);
+  void allocateBuffers (size_t num_vertices);
 
   // Create an interleaved VBO from the VertexData in the array.
-  void createInterleavedVBOs();
+  void createInterleavedVBOs ();
 
   // Method adds begin/end states that enable and point to the VertexData in the array
-  void addAttributePointers(size_t start_offset = 0);
+  void addAttributePointers (size_t start_offset = 0);
 
-  inline GLuint verticesVBO() const { return vertex_state_container_.verticesVBO(); }
-  inline size_t verticesOffset() const { return vertices_offset_; }
+  inline GLuint verticesVBO () const {
+    return vertex_state_container_.verticesVBO ();
+  }
+  inline size_t verticesOffset () const {
+    return vertices_offset_;
+  }
 
   // Return whether this Vertex Array uses elements (indexed rendering)
-  inline bool useElements() const { return vertex_state_container_.elementsVBO() != 0; }
-  inline GLuint elementsVBO() const { return vertex_state_container_.elementsVBO(); }
-  inline size_t elementsOffset() const { return elements_offset_; }
-  inline void setElementsOffset(size_t offset) { elements_offset_ = offset; }
+  inline bool useElements () const {
+    return vertex_state_container_.elementsVBO () != 0;
+  }
+  inline GLuint elementsVBO () const {
+    return vertex_state_container_.elementsVBO ();
+  }
+  inline size_t elementsOffset () const {
+    return elements_offset_;
+  }
+  inline void setElementsOffset (size_t offset) {
+    elements_offset_ = offset;
+  }
 
   // Return the internal unique vertex/element map
-  inline ElementsMap& elementsMap() { return elements_map_; }
+  inline ElementsMap &elementsMap () {
+    return elements_map_;
+  }
 
   size_t shader_attributes_index_{0};
-  void addShaderData();
-
-  void add_barycentric_attribute(size_t active_point_index,
-                                 size_t primitive_index, size_t shape_size, bool outlines);
-  void create_triangle(const Color4f& color, const Vector3d& p0,
-                       const Vector3d& p1, const Vector3d& p2, size_t primitive_index,
-                       size_t shape_size, bool outlines, bool enable_barycentric, bool mirror);
-  void create_surface(const PolySet& ps, const Transform3d& m,
-                      const Color4f& default_color, bool enable_barycentric, bool force_default_color = false);
-  void create_edges(const Polygon2d& polygon, const Transform3d& m, const Color4f& color);
-  void create_polygons(const PolySet& ps, const Transform3d& m, const Color4f& color);
+  void addShaderData ();
+
+  void add_barycentric_attribute (size_t active_point_index,
+                                  size_t primitive_index, size_t shape_size, bool outlines);
+  void create_triangle (const Color4f &color, const Vector3d &p0,
+                        const Vector3d &p1, const Vector3d &p2, size_t primitive_index,
+                        size_t shape_size, bool outlines, bool enable_barycentric, bool mirror);
+  void create_surface (const PolySet &ps, const Transform3d &m,
+                       const Color4f &default_color, bool enable_barycentric, bool force_default_color = false);
+  void create_edges (const Polygon2d &polygon, const Transform3d &m, const Color4f &color);
+  void create_polygons (const PolySet &ps, const Transform3d &m, const Color4f &color);
 
 private:
-  inline void setElementsSize(size_t elements_size) { elements_size_ = elements_size; }
+  inline void setElementsSize (size_t elements_size) {
+    elements_size_ = elements_size;
+  }
 
   std::unique_ptr<VertexStateFactory> factory_;
-  VertexStateContainer& vertex_state_container_;
+  VertexStateContainer &vertex_state_container_;
   size_t write_index_{0};
   size_t surface_index_{0};
   size_t edge_index_{0};
diff --git a/src/glview/VBORenderer.cc b/src/glview/VBORenderer.cc
index 36c8d8089..6144ee2c2 100644
--- a/src/glview/VBORenderer.cc
+++ b/src/glview/VBORenderer.cc
@@ -30,7 +30,7 @@
 #include "geometry/PolySet.h"
 #include "core/CSGNode.h"
 #include "utils/printutils.h"
-#include "utils/hash.h"  // IWYU pragma: keep
+#include "utils/hash.h" // IWYU pragma: keep
 
 #include <cassert>
 #include <array>
@@ -41,127 +41,123 @@
 
 namespace VBOUtils {
 
-void shader_attribs_enable(const ShaderUtils::ShaderInfo& shaderinfo)
-{
-  for (const auto& [name, location] : shaderinfo.attributes) {
-    GL_TRACE("glEnableVertexAttribArray(%d)", location);
-    GL_CHECKD(glEnableVertexAttribArray(location));
+void shader_attribs_enable (const ShaderUtils::ShaderInfo &shaderinfo) {
+  for (const auto &[name, location] : shaderinfo.attributes) {
+    GL_TRACE ("glEnableVertexAttribArray(%d)", location);
+    GL_CHECKD (glEnableVertexAttribArray (location));
   }
 }
 
-void shader_attribs_disable(const ShaderUtils::ShaderInfo& shaderinfo)
-{
-  for (const auto& [name, location] : shaderinfo.attributes) {
-    GL_TRACE("glEnableVertexAttribArray(%d)", location);
-    GL_CHECKD(glDisableVertexAttribArray(location));
+void shader_attribs_disable (const ShaderUtils::ShaderInfo &shaderinfo) {
+  for (const auto &[name, location] : shaderinfo.attributes) {
+    GL_TRACE ("glEnableVertexAttribArray(%d)", location);
+    GL_CHECKD (glDisableVertexAttribArray (location));
   }
 }
 
-}  // namespace VBOUtils
+} // namespace VBOUtils
 
-VBORenderer::VBORenderer() : Renderer() {}
+VBORenderer::VBORenderer ()
+  : Renderer () {}
 
-size_t VBORenderer::calcNumVertices(const std::shared_ptr<CSGProducts>& products,
-                                    bool unique_geometry) const
-{
+size_t VBORenderer::calcNumVertices (const std::shared_ptr<CSGProducts> &products,
+                                     bool unique_geometry) const {
   size_t buffer_size = 0;
-  if (unique_geometry) this->geom_visit_mark_.clear();
+  if (unique_geometry)
+    this->geom_visit_mark_.clear ();
 
-  for (const auto& product : products->products) {
-    for (const auto& csgobj : product.intersections) {
-      buffer_size += calcNumVertices(csgobj);
+  for (const auto &product : products->products) {
+    for (const auto &csgobj : product.intersections) {
+      buffer_size += calcNumVertices (csgobj);
     }
-    for (const auto& csgobj : product.subtractions) {
-      buffer_size += calcNumVertices(csgobj);
+    for (const auto &csgobj : product.subtractions) {
+      buffer_size += calcNumVertices (csgobj);
     }
   }
   return buffer_size;
 }
 
-size_t VBORenderer::calcNumVertices(const CSGChainObject& csgobj, bool unique_geometry) const
-{
+size_t VBORenderer::calcNumVertices (const CSGChainObject &csgobj, bool unique_geometry) const {
   size_t buffer_size = 0;
   if (unique_geometry &&
-      this->geom_visit_mark_[std::make_pair(csgobj.leaf->polyset.get(), &csgobj.leaf->matrix)]++ > 0)return 0;
+      this->geom_visit_mark_[std::make_pair (csgobj.leaf->polyset.get (), &csgobj.leaf->matrix)]++ > 0)
+    return 0;
 
   if (csgobj.leaf->polyset) {
-    buffer_size += calcNumVertices(*csgobj.leaf->polyset);
+    buffer_size += calcNumVertices (*csgobj.leaf->polyset);
   }
   return buffer_size;
 }
 
-size_t VBORenderer::calcNumVertices(const PolySet& polyset) const
-{
+size_t VBORenderer::calcNumVertices (const PolySet &polyset) const {
   size_t buffer_size = 0;
-  for (const auto& poly : polyset.indices) {
-    if (poly.size() == 3) {
+  for (const auto &poly : polyset.indices) {
+    if (poly.size () == 3) {
       buffer_size++;
-    } else if (poly.size() == 4) {
+    } else if (poly.size () == 4) {
       buffer_size += 2;
     } else {
       // poly.size() because we'll render a triangle fan from the centroid
       // FIXME: Are we still using this code path?
-      buffer_size += poly.size();
+      buffer_size += poly.size ();
     }
   }
   return buffer_size * 3;
 }
 
-size_t VBORenderer::calcNumEdgeVertices(const PolySet& polyset) const
-{
+size_t VBORenderer::calcNumEdgeVertices (const PolySet &polyset) const {
   size_t buffer_size = 0;
-  for (const auto& polygon : polyset.indices) {
-    buffer_size += polygon.size();
+  for (const auto &polygon : polyset.indices) {
+    buffer_size += polygon.size ();
   }
   return buffer_size;
 }
 
-size_t VBORenderer::calcNumEdgeVertices(const Polygon2d& polygon) const
-{
+size_t VBORenderer::calcNumEdgeVertices (const Polygon2d &polygon) const {
   size_t buffer_size = 0;
   // Render only outlines
-  for (const Outline2d& o : polygon.outlines()) {
-    buffer_size += o.vertices.size();
+  for (const Outline2d &o : polygon.outlines ()) {
+    buffer_size += o.vertices.size ();
   }
   return buffer_size;
 }
 
-void VBORenderer::add_shader_pointers(VBOBuilder& vbo_builder, const ShaderUtils::ShaderInfo *shaderinfo)
-{
-  const std::shared_ptr<VertexData> vertex_data = vbo_builder.data();
+void VBORenderer::add_shader_pointers (VBOBuilder &vbo_builder, const ShaderUtils::ShaderInfo *shaderinfo) {
+  const std::shared_ptr<VertexData> vertex_data = vbo_builder.data ();
 
-  if (!vertex_data) return;
+  if (!vertex_data)
+    return;
 
-  const auto start_offset = vbo_builder.verticesOffset();
+  const auto start_offset = vbo_builder.verticesOffset ();
 
-  std::shared_ptr<VertexState> ss = std::make_shared<VBOShaderVertexState>(
-    vbo_builder.writeIndex(), 0, vbo_builder.verticesVBO(), vbo_builder.elementsVBO());
+  std::shared_ptr<VertexState> ss = std::make_shared<VBOShaderVertexState> (
+    vbo_builder.writeIndex (), 0, vbo_builder.verticesVBO (), vbo_builder.elementsVBO ());
   GLsizei count = 0, stride = 0;
   GLenum type = 0;
   size_t offset = 0;
 
-  GLuint attribute_index = shaderinfo->attributes.at("barycentric");
+  GLuint attribute_index = shaderinfo->attributes.at ("barycentric");
   if (attribute_index > 0) {
     count =
-      vertex_data->attributes()[vbo_builder.shader_attributes_index_ + BARYCENTRIC_ATTRIB]->count();
+      vertex_data->attributes ()[vbo_builder.shader_attributes_index_ + BARYCENTRIC_ATTRIB]->count ();
     type =
-      vertex_data->attributes()[vbo_builder.shader_attributes_index_ + BARYCENTRIC_ATTRIB]->glType();
-    stride = vertex_data->stride();
+      vertex_data->attributes ()[vbo_builder.shader_attributes_index_ + BARYCENTRIC_ATTRIB]->glType ();
+    stride = vertex_data->stride ();
     offset = start_offset +
-      vertex_data->interleavedOffset(vbo_builder.shader_attributes_index_ + BARYCENTRIC_ATTRIB);
-    ss->glBegin().emplace_back(
-      [attribute_index, count, type, stride, offset, ss_ptr = std::weak_ptr<VertexState>(ss)]() {
-      auto ss = ss_ptr.lock();
-      if (ss) {
-        // NOLINTBEGIN(performance-no-int-to-ptr)
-        GL_TRACE("glVertexAttribPointer(%d, %d, %d, GL_FALSE, %d, %p)",
-                 attribute_index % count % type % stride % (GLvoid *)(ss->drawOffset() + offset));
-        GL_CHECKD(glVertexAttribPointer(attribute_index, count, type, GL_FALSE, stride,
-                                        (GLvoid *)(ss->drawOffset() + offset)));
-        // NOLINTEND(performance-no-int-to-ptr)
-      }
-    });
+             vertex_data->interleavedOffset (vbo_builder.shader_attributes_index_ + BARYCENTRIC_ATTRIB);
+    ss->glBegin ().emplace_back (
+      [attribute_index, count, type, stride, offset, ss_ptr = std::weak_ptr<VertexState> (ss)] () {
+        auto ss = ss_ptr.lock ();
+        if (ss) {
+          // NOLINTBEGIN(performance-no-int-to-ptr)
+          GL_TRACE ("glVertexAttribPointer(%d, %d, %d, GL_FALSE, %d, %p)",
+                    attribute_index % count % type % stride % (GLvoid *)(ss->drawOffset () + offset));
+          GL_CHECKD (glVertexAttribPointer (attribute_index, count, type, GL_FALSE, stride,
+                                            (GLvoid *)(ss->drawOffset () + offset)));
+          // NOLINTEND(performance-no-int-to-ptr)
+        }
+      });
   }
 
-  vbo_builder.states().emplace_back(std::move(ss));
+  vbo_builder.states ().emplace_back (std::move (ss));
 }
diff --git a/src/glview/VBORenderer.h b/src/glview/VBORenderer.h
index 4270383ca..690e0695f 100644
--- a/src/glview/VBORenderer.h
+++ b/src/glview/VBORenderer.h
@@ -18,37 +18,38 @@
 
 namespace VBOUtils {
 
-void shader_attribs_enable(const ShaderUtils::ShaderInfo& shaderinfo);
-void shader_attribs_disable(const ShaderUtils::ShaderInfo& shaderinfo);
+void shader_attribs_enable (const ShaderUtils::ShaderInfo &shaderinfo);
+void shader_attribs_disable (const ShaderUtils::ShaderInfo &shaderinfo);
 
-}  // namespace VBOUtils
+} // namespace VBOUtils
 
 class VBOShaderVertexState : public VertexState
 {
 public:
-  VBOShaderVertexState(size_t draw_offset, size_t element_offset, GLuint vertices_vbo, GLuint elements_vbo)
-    : VertexState(0, 0, 0, draw_offset, element_offset, vertices_vbo, elements_vbo) {}
+  VBOShaderVertexState (size_t draw_offset, size_t element_offset, GLuint vertices_vbo, GLuint elements_vbo)
+    : VertexState (0, 0, 0, draw_offset, element_offset, vertices_vbo, elements_vbo) {}
 };
 
 class VBORenderer : public Renderer
 {
 public:
-  VBORenderer();
-  virtual size_t calcNumVertices(const std::shared_ptr<CSGProducts>& products, bool unique_geometry = false) const;
-  virtual size_t calcNumVertices(const CSGChainObject& csgobj, bool unique_geometry = false) const;
-  virtual size_t calcNumVertices(const PolySet& polyset) const;
-  virtual size_t calcNumEdgeVertices(const PolySet& polyset) const;
-  virtual size_t calcNumEdgeVertices(const Polygon2d& polygon) const;
+  VBORenderer ();
+  virtual size_t calcNumVertices (const std::shared_ptr<CSGProducts> &products, bool unique_geometry = false) const;
+  virtual size_t calcNumVertices (const CSGChainObject &csgobj, bool unique_geometry = false) const;
+  virtual size_t calcNumVertices (const PolySet &polyset) const;
+  virtual size_t calcNumEdgeVertices (const PolySet &polyset) const;
+  virtual size_t calcNumEdgeVertices (const Polygon2d &polygon) const;
 
-  void add_shader_pointers(VBOBuilder& vbo_builder, const ShaderUtils::ShaderInfo *shaderinfo); // This could stay protected, were it not for VertexStateManager
+  void add_shader_pointers (VBOBuilder &vbo_builder, const ShaderUtils::ShaderInfo *shaderinfo); // This could stay protected, were it not for VertexStateManager
 
 protected:
-  void add_shader_data(VBOBuilder& vbo_builder);
-  void shader_attribs_enable(const ShaderUtils::ShaderInfo&) const;
-  void shader_attribs_disable(const ShaderUtils::ShaderInfo&) const;
+  void add_shader_data (VBOBuilder &vbo_builder);
+  void shader_attribs_enable (const ShaderUtils::ShaderInfo &) const;
+  void shader_attribs_disable (const ShaderUtils::ShaderInfo &) const;
 
   mutable std::unordered_map<std::pair<const PolySet *, const Transform3d *>, int,
-                             boost::hash<std::pair<const PolySet *, const Transform3d *>>> geom_visit_mark_;
+                             boost::hash<std::pair<const PolySet *, const Transform3d *>>>
+    geom_visit_mark_;
 
 private:
 };
diff --git a/src/glview/VertexState.cc b/src/glview/VertexState.cc
index 858ca9f92..3136209e7 100644
--- a/src/glview/VertexState.cc
+++ b/src/glview/VertexState.cc
@@ -1,63 +1,62 @@
 #include "glview/VertexState.h"
 
-void VertexState::draw() const
-{
+void VertexState::draw () const {
   if (vertices_vbo_) {
-    GL_TRACE("glBindBuffer(GL_ARRAY_BUFFER, %d)", vertices_vbo_);
-    GL_CHECKD(glBindBuffer(GL_ARRAY_BUFFER, vertices_vbo_));
+    GL_TRACE ("glBindBuffer(GL_ARRAY_BUFFER, %d)", vertices_vbo_);
+    GL_CHECKD (glBindBuffer (GL_ARRAY_BUFFER, vertices_vbo_));
   }
   if (elements_vbo_) {
-    GL_TRACE("glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, %d)", elements_vbo_);
-    GL_CHECKD(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, elements_vbo_));
+    GL_TRACE ("glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, %d)", elements_vbo_);
+    GL_CHECKD (glBindBuffer (GL_ELEMENT_ARRAY_BUFFER, elements_vbo_));
   }
-  for (const auto& gl_func : gl_begin_) {
-    gl_func();
+  for (const auto &gl_func : gl_begin_) {
+    gl_func ();
   }
   if (draw_size_ > 0) {
     if (elements_vbo_) {
-      GL_TRACE("glDrawElements(%s, %d, %s, %d)",
-               (draw_mode_ == GL_POINTS ? "GL_POINTS" :
-                draw_mode_ == GL_LINES ? "GL_LINES" :
-                draw_mode_ == GL_LINE_LOOP ? "GL_LINE_LOOP" :
-                draw_mode_ == GL_LINE_STRIP ? "GL_LINE_STRIP" :
-                draw_mode_ == GL_TRIANGLES ? "GL_TRIANGLES" :
-                draw_mode_ == GL_TRIANGLE_STRIP ? "GL_TRIANGLE_STRIP" :
-                draw_mode_ == GL_TRIANGLE_FAN ? "GL_TRIANGLE_FAN" :
-                draw_mode_ == GL_QUADS ? "GL_QUADS" :
-                draw_mode_ == GL_QUAD_STRIP ? "GL_QUAD_STRIP" :
-                draw_mode_ == GL_POLYGON ? "GL_POLYGON" :
-                "UNKNOWN") % draw_size_ %
-               (draw_type_ == GL_UNSIGNED_BYTE ? "GL_UNSIGNED_BYTE" :
-                draw_type_ == GL_UNSIGNED_SHORT ? "GL_UNSIGNED_SHORT" :
-                draw_type_ == GL_UNSIGNED_INT ? "GL_UNSIGNED_INT" :
-                "UNKNOWN") % element_offset_);
+      GL_TRACE ("glDrawElements(%s, %d, %s, %d)",
+                (draw_mode_ == GL_POINTS ? "GL_POINTS" : draw_mode_ == GL_LINES          ? "GL_LINES"
+                                                       : draw_mode_ == GL_LINE_LOOP      ? "GL_LINE_LOOP"
+                                                       : draw_mode_ == GL_LINE_STRIP     ? "GL_LINE_STRIP"
+                                                       : draw_mode_ == GL_TRIANGLES      ? "GL_TRIANGLES"
+                                                       : draw_mode_ == GL_TRIANGLE_STRIP ? "GL_TRIANGLE_STRIP"
+                                                       : draw_mode_ == GL_TRIANGLE_FAN   ? "GL_TRIANGLE_FAN"
+                                                       : draw_mode_ == GL_QUADS          ? "GL_QUADS"
+                                                       : draw_mode_ == GL_QUAD_STRIP     ? "GL_QUAD_STRIP"
+                                                       : draw_mode_ == GL_POLYGON        ? "GL_POLYGON"
+                                                                                         : "UNKNOWN") %
+                  draw_size_ %
+                  (draw_type_ == GL_UNSIGNED_BYTE ? "GL_UNSIGNED_BYTE" : draw_type_ == GL_UNSIGNED_SHORT ? "GL_UNSIGNED_SHORT"
+                                                                       : draw_type_ == GL_UNSIGNED_INT   ? "GL_UNSIGNED_INT"
+                                                                                                         : "UNKNOWN") %
+                  element_offset_);
       // NOLINTNEXTLINE(performance-no-int-to-ptr)
-      glDrawElements(draw_mode_, draw_size_, draw_type_, (GLvoid *)element_offset_);
+      glDrawElements (draw_mode_, draw_size_, draw_type_, (GLvoid *)element_offset_);
     } else {
-      GL_TRACE("glDrawArrays(%s, 0, %d)",
-               (draw_mode_ == GL_POINTS ? "GL_POINTS" :
-                draw_mode_ == GL_LINES ? "GL_LINES" :
-                draw_mode_ == GL_LINE_LOOP ? "GL_LINE_LOOP" :
-                draw_mode_ == GL_LINE_STRIP ? "GL_LINE_STRIP" :
-                draw_mode_ == GL_TRIANGLES ? "GL_TRIANGLES" :
-                draw_mode_ == GL_TRIANGLE_STRIP ? "GL_TRIANGLE_STRIP" :
-                draw_mode_ == GL_TRIANGLE_FAN ? "GL_TRIANGLE_FAN" :
-                draw_mode_ == GL_QUADS ? "GL_QUADS" :
-                draw_mode_ == GL_QUAD_STRIP ? "GL_QUAD_STRIP" :
-                draw_mode_ == GL_POLYGON ? "GL_POLYGON" :
-                "UNKNOWN") % draw_size_);
-      glDrawArrays(draw_mode_, 0, draw_size_);
+      GL_TRACE ("glDrawArrays(%s, 0, %d)",
+                (draw_mode_ == GL_POINTS ? "GL_POINTS" : draw_mode_ == GL_LINES          ? "GL_LINES"
+                                                       : draw_mode_ == GL_LINE_LOOP      ? "GL_LINE_LOOP"
+                                                       : draw_mode_ == GL_LINE_STRIP     ? "GL_LINE_STRIP"
+                                                       : draw_mode_ == GL_TRIANGLES      ? "GL_TRIANGLES"
+                                                       : draw_mode_ == GL_TRIANGLE_STRIP ? "GL_TRIANGLE_STRIP"
+                                                       : draw_mode_ == GL_TRIANGLE_FAN   ? "GL_TRIANGLE_FAN"
+                                                       : draw_mode_ == GL_QUADS          ? "GL_QUADS"
+                                                       : draw_mode_ == GL_QUAD_STRIP     ? "GL_QUAD_STRIP"
+                                                       : draw_mode_ == GL_POLYGON        ? "GL_POLYGON"
+                                                                                         : "UNKNOWN") %
+                  draw_size_);
+      glDrawArrays (draw_mode_, 0, draw_size_);
     }
   }
-  for (const auto& gl_func : gl_end_) {
-    gl_func();
+  for (const auto &gl_func : gl_end_) {
+    gl_func ();
   }
   if (elements_vbo_) {
-    GL_TRACE0("glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0)");
-    GL_CHECKD(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0));
+    GL_TRACE0 ("glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0)");
+    GL_CHECKD (glBindBuffer (GL_ELEMENT_ARRAY_BUFFER, 0));
   }
   if (vertices_vbo_) {
-    GL_TRACE0("glBindBuffer(GL_ARRAY_BUFFER, 0)");
-    GL_CHECKD(glBindBuffer(GL_ARRAY_BUFFER, 0));
+    GL_TRACE0 ("glBindBuffer(GL_ARRAY_BUFFER, 0)");
+    GL_CHECKD (glBindBuffer (GL_ARRAY_BUFFER, 0));
   }
 }
diff --git a/src/glview/VertexState.h b/src/glview/VertexState.h
index 04549a5da..1e7c1dcc0 100644
--- a/src/glview/VertexState.h
+++ b/src/glview/VertexState.h
@@ -12,16 +12,24 @@
 #define GL_TRACE_ENABLE
 #ifdef GL_TRACE_ENABLE
 // NOLINTBEGIN(bugprone-macro-parentheses)
-#define GL_TRACE(fmt_, args) do { \
-          if (OpenSCAD::debug != "") PRINTDB("%d : " fmt_, __LINE__ % args); \
-} while (0)
+#define GL_TRACE(fmt_, args)                   \
+  do {                                         \
+    if (OpenSCAD::debug != "")                 \
+      PRINTDB ("%d : " fmt_, __LINE__ % args); \
+  } while (0)
 // NOLINTEND(bugprone-macro-parentheses)
-#define GL_TRACE0(fmt_) do { \
-          if (OpenSCAD::debug != "") PRINTDB("%d : " fmt_, __LINE__); \
-} while (0)
+#define GL_TRACE0(fmt_)                 \
+  do {                                  \
+    if (OpenSCAD::debug != "")          \
+      PRINTDB ("%d : " fmt_, __LINE__); \
+  } while (0)
 #else // GL_TRACE_ENABLE
-#define GL_TRACE(fmt_, args) do {} while (0)
-#define GL_TRACE0(fmt_) do {} while (0)
+#define GL_TRACE(fmt_, args) \
+  do {                       \
+  } while (0)
+#define GL_TRACE0(fmt_) \
+  do {                  \
+  } while (0)
 #endif // GL_TRACE_ENABLE
 
 // Storage for minimum state information necessary to draw VBO.
@@ -30,48 +38,88 @@
 class VertexState
 {
 public:
-  VertexState()
-    : draw_mode_(GL_TRIANGLES), draw_size_(0), draw_type_(0), draw_offset_(0),
-    element_offset_(0), vertices_vbo_(0), elements_vbo_(0)
-  {}
-  VertexState(GLenum draw_mode, GLsizei draw_size, GLenum draw_type, size_t draw_offset, size_t element_offset, GLuint vertices_vbo, GLuint elements_vbo)
-    : draw_mode_(draw_mode), draw_size_(draw_size), draw_type_(draw_type), draw_offset_(draw_offset),
-    element_offset_(element_offset), vertices_vbo_(vertices_vbo), elements_vbo_(elements_vbo)
-  {}
-  virtual ~VertexState() = default;
+  VertexState ()
+    : draw_mode_ (GL_TRIANGLES)
+    , draw_size_ (0)
+    , draw_type_ (0)
+    , draw_offset_ (0)
+    , element_offset_ (0)
+    , vertices_vbo_ (0)
+    , elements_vbo_ (0) {}
+  VertexState (GLenum draw_mode, GLsizei draw_size, GLenum draw_type, size_t draw_offset, size_t element_offset, GLuint vertices_vbo, GLuint elements_vbo)
+    : draw_mode_ (draw_mode)
+    , draw_size_ (draw_size)
+    , draw_type_ (draw_type)
+    , draw_offset_ (draw_offset)
+    , element_offset_ (element_offset)
+    , vertices_vbo_ (vertices_vbo)
+    , elements_vbo_ (elements_vbo) {}
+  virtual ~VertexState () = default;
 
   // Return the OpenGL mode for glDrawArrays/glDrawElements call
-  [[nodiscard]] inline GLenum drawMode() const { return draw_mode_; }
+  [[nodiscard]] inline GLenum drawMode () const {
+    return draw_mode_;
+  }
   // Set the OpenGL mode for glDrawArrays/glDrawElements call
-  inline void setDrawMode(GLenum draw_mode) { draw_mode_ = draw_mode; }
+  inline void setDrawMode (GLenum draw_mode) {
+    draw_mode_ = draw_mode;
+  }
   // Return the number of vertices for glDrawArrays/glDrawElements call
-  [[nodiscard]] inline GLsizei drawSize() const { return draw_size_; }
+  [[nodiscard]] inline GLsizei drawSize () const {
+    return draw_size_;
+  }
   // Set the number of vertices for glDrawArrays/glDrawElements call
-  inline void setDrawSize(GLsizei draw_size) { draw_size_ = draw_size; }
+  inline void setDrawSize (GLsizei draw_size) {
+    draw_size_ = draw_size;
+  }
   // Return the OpenGL type for glDrawElements call
-  [[nodiscard]] inline GLenum drawType() const { return draw_type_; }
+  [[nodiscard]] inline GLenum drawType () const {
+    return draw_type_;
+  }
   // Set the OpenGL type for glDrawElements call
-  inline void setDrawType(GLenum draw_type) { draw_type_ = draw_type; }
+  inline void setDrawType (GLenum draw_type) {
+    draw_type_ = draw_type;
+  }
   // Return the VBO offset for glDrawArrays call
-  [[nodiscard]] inline size_t drawOffset() const { return draw_offset_; }
+  [[nodiscard]] inline size_t drawOffset () const {
+    return draw_offset_;
+  }
   // Set the VBO offset for glDrawArrays call
-  inline void setDrawOffset(size_t draw_offset) { draw_offset_ = draw_offset; }
+  inline void setDrawOffset (size_t draw_offset) {
+    draw_offset_ = draw_offset;
+  }
   // Return the Element VBO offset for glDrawElements call
-  [[nodiscard]] inline size_t elementOffset() const { return element_offset_; }
+  [[nodiscard]] inline size_t elementOffset () const {
+    return element_offset_;
+  }
   // Set the Element VBO offset for glDrawElements call
-  inline void setElementOffset(size_t element_offset) { element_offset_ = element_offset; }
+  inline void setElementOffset (size_t element_offset) {
+    element_offset_ = element_offset;
+  }
 
   // Wrap glDrawArrays/glDrawElements call and use gl_begin/gl_end state information
-  virtual void draw() const;
+  virtual void draw () const;
 
   // Mimic VAO state functionality. Lambda functions used to hold OpenGL state calls.
-  inline std::vector<std::function<void()>>& glBegin() { return gl_begin_; }
-  inline std::vector<std::function<void()>>& glEnd() { return gl_end_; }
+  inline std::vector<std::function<void ()>> &glBegin () {
+    return gl_begin_;
+  }
+  inline std::vector<std::function<void ()>> &glEnd () {
+    return gl_end_;
+  }
 
-  [[nodiscard]] inline GLuint verticesVBO() const { return vertices_vbo_; }
-  inline void setVerticesVBO(GLuint vbo) { vertices_vbo_ = vbo; }
-  [[nodiscard]] inline GLuint elementsVBO() const { return elements_vbo_; }
-  inline void setElementsVBO(GLuint vbo) { elements_vbo_ = vbo; }
+  [[nodiscard]] inline GLuint verticesVBO () const {
+    return vertices_vbo_;
+  }
+  inline void setVerticesVBO (GLuint vbo) {
+    vertices_vbo_ = vbo;
+  }
+  [[nodiscard]] inline GLuint elementsVBO () const {
+    return elements_vbo_;
+  }
+  inline void setElementsVBO (GLuint vbo) {
+    elements_vbo_ = vbo;
+  }
 
 private:
   GLenum draw_mode_;
@@ -81,8 +129,8 @@ private:
   size_t element_offset_;
   GLuint vertices_vbo_;
   GLuint elements_vbo_;
-  std::vector<std::function<void()>> gl_begin_;
-  std::vector<std::function<void()>> gl_end_;
+  std::vector<std::function<void ()>> gl_begin_;
+  std::vector<std::function<void ()>> gl_end_;
 };
 
 // Allows Renderers to override VertexState objects with their own derived
@@ -91,51 +139,59 @@ private:
 class VertexStateFactory
 {
 public:
-  VertexStateFactory() = default;
-  virtual ~VertexStateFactory() = default;
+  VertexStateFactory () = default;
+  virtual ~VertexStateFactory () = default;
 
   // Create and return a VertexState object
-  [[nodiscard]] virtual std::shared_ptr<VertexState> createVertexState(GLenum draw_mode, size_t draw_size, GLenum draw_type, size_t draw_offset, size_t element_offset, GLuint vertices_vbo, GLuint elements_vbo) const {
-    return std::make_shared<VertexState>(draw_mode, draw_size, draw_type, draw_offset, element_offset, vertices_vbo, elements_vbo);
+  [[nodiscard]] virtual std::shared_ptr<VertexState> createVertexState (GLenum draw_mode, size_t draw_size, GLenum draw_type, size_t draw_offset, size_t element_offset, GLuint vertices_vbo, GLuint elements_vbo) const {
+    return std::make_shared<VertexState> (draw_mode, draw_size, draw_type, draw_offset, element_offset, vertices_vbo, elements_vbo);
   }
 };
 
 class VertexStateContainer
 {
 public:
-  VertexStateContainer() {
-    GL_TRACE("glGenBuffers(1, %p)", &vertices_vbo_);
-    GL_CHECKD(glGenBuffers(1, &vertices_vbo_));
-    if (Feature::ExperimentalVxORenderersIndexing.is_enabled()) {
-      GL_TRACE("glGenBuffers(1, %p)", &elements_vbo_);
-      GL_CHECKD(glGenBuffers(1, &elements_vbo_));
+  VertexStateContainer () {
+    GL_TRACE ("glGenBuffers(1, %p)", &vertices_vbo_);
+    GL_CHECKD (glGenBuffers (1, &vertices_vbo_));
+    if (Feature::ExperimentalVxORenderersIndexing.is_enabled ()) {
+      GL_TRACE ("glGenBuffers(1, %p)", &elements_vbo_);
+      GL_CHECKD (glGenBuffers (1, &elements_vbo_));
     }
   }
-  VertexStateContainer(const VertexStateContainer& o) = delete;
-  VertexStateContainer(VertexStateContainer&& o) noexcept {
+  VertexStateContainer (const VertexStateContainer &o) = delete;
+  VertexStateContainer (VertexStateContainer &&o) noexcept {
     vertices_vbo_ = o.vertices_vbo_;
     elements_vbo_ = o.elements_vbo_;
-    vertex_states_ = std::move(o.vertex_states_);
+    vertex_states_ = std::move (o.vertex_states_);
     o.vertices_vbo_ = 0;
     o.elements_vbo_ = 0;
   }
 
-  virtual ~VertexStateContainer() {
+  virtual ~VertexStateContainer () {
     if (vertices_vbo_) {
-      GL_TRACE("glDeleteBuffers(1, %p)", &vertices_vbo_);
-      GL_CHECKD(glDeleteBuffers(1, &vertices_vbo_));
+      GL_TRACE ("glDeleteBuffers(1, %p)", &vertices_vbo_);
+      GL_CHECKD (glDeleteBuffers (1, &vertices_vbo_));
     }
     if (elements_vbo_) {
-      GL_TRACE("glDeleteBuffers(1, %p)", &elements_vbo_);
-      GL_CHECKD(glDeleteBuffers(1, &elements_vbo_));
+      GL_TRACE ("glDeleteBuffers(1, %p)", &elements_vbo_);
+      GL_CHECKD (glDeleteBuffers (1, &elements_vbo_));
     }
   }
 
-  GLuint verticesVBO() const { return vertices_vbo_; }
-  GLuint elementsVBO() const { return elements_vbo_; }
+  GLuint verticesVBO () const {
+    return vertices_vbo_;
+  }
+  GLuint elementsVBO () const {
+    return elements_vbo_;
+  }
 
-  std::vector<std::shared_ptr<VertexState>>& states() { return vertex_states_; }
-  const std::vector<std::shared_ptr<VertexState>>& states() const { return vertex_states_; }
+  std::vector<std::shared_ptr<VertexState>> &states () {
+    return vertex_states_;
+  }
+  const std::vector<std::shared_ptr<VertexState>> &states () const {
+    return vertex_states_;
+  }
 
 private:
   GLuint vertices_vbo_;
diff --git a/src/glview/cgal/CGALRenderUtils.cc b/src/glview/cgal/CGALRenderUtils.cc
index 57e9917e4..89defc906 100644
--- a/src/glview/cgal/CGALRenderUtils.cc
+++ b/src/glview/cgal/CGALRenderUtils.cc
@@ -3,17 +3,16 @@
 
 #include <algorithm>
 
-
 // this function resolves a 3x3 linear eqauation system
 /*
  * res[0] * v1 + res[1] *v2 + res[2] * vf3 = pt
  */
 
-bool linsystem(Vector3d v1, Vector3d v2, Vector3d v3, Vector3d pt, Vector3d& res, double *detptr)
-{
+bool linsystem (Vector3d v1, Vector3d v2, Vector3d v3, Vector3d pt, Vector3d &res, double *detptr) {
   double det, ad11, ad12, ad13, ad21, ad22, ad23, ad31, ad32, ad33;
   det = v1[0] * (v2[1] * v3[2] - v3[1] * v2[2]) - v1[1] * (v2[0] * v3[2] - v3[0] * v2[2]) + v1[2] * (v2[0] * v3[1] - v3[0] * v2[1]);
-  if (detptr != nullptr) *detptr = det;
+  if (detptr != nullptr)
+    *detptr = det;
   ad11 = v2[1] * v3[2] - v3[1] * v2[2];
   ad12 = v3[0] * v2[2] - v2[0] * v3[2];
   ad13 = v2[0] * v3[1] - v3[0] * v2[1];
@@ -24,7 +23,8 @@ bool linsystem(Vector3d v1, Vector3d v2, Vector3d v3, Vector3d pt, Vector3d& res
   ad32 = v2[0] * v1[2] - v1[0] * v2[2];
   ad33 = v1[0] * v2[1] - v2[0] * v1[1];
 
-  if (fabs(det) < 0.00001)return true;
+  if (fabs (det) < 0.00001)
+    return true;
 
   res[0] = (ad11 * pt[0] + ad12 * pt[1] + ad13 * pt[2]) / det;
   res[1] = (ad21 * pt[0] + ad22 * pt[1] + ad23 * pt[2]) / det;
@@ -32,43 +32,42 @@ bool linsystem(Vector3d v1, Vector3d v2, Vector3d v3, Vector3d pt, Vector3d& res
   return false;
 }
 
-double calculateLinePointDistance(const Vector3d& l1, const Vector3d& l2, const Vector3d& pt, double& dist_lat) {
+double calculateLinePointDistance (const Vector3d &l1, const Vector3d &l2, const Vector3d &pt, double &dist_lat) {
   Vector3d d = (l2 - l1);
-  double l = d.norm();
-  d.normalize();
-  dist_lat = std::clamp((pt - l1).dot(d), 0.0, l);
-  return (l1 + d * dist_lat - pt).norm();
+  double l = d.norm ();
+  d.normalize ();
+  dist_lat = std::clamp ((pt - l1).dot (d), 0.0, l);
+  return (l1 + d * dist_lat - pt).norm ();
 }
 
-double calculateLineLineDistance(const Vector3d& l1b, const Vector3d& l1e, const Vector3d& l2b, const Vector3d& l2e, double& dist_lat)
-{
+double calculateLineLineDistance (const Vector3d &l1b, const Vector3d &l1e, const Vector3d &l2b, const Vector3d &l2e, double &dist_lat) {
   double d;
   Vector3d v1 = l1e - l1b;
   Vector3d v2 = l2e - l2b;
-  Vector3d n = v1.cross(v2);
-  if (n.norm() == 0) {
-    return calculateLinePointDistance(l1b, l1e, l2b, d);
+  Vector3d n = v1.cross (v2);
+  if (n.norm () == 0) {
+    return calculateLinePointDistance (l1b, l1e, l2b, d);
   }
-  double t = n.norm();
-  n.normalize();
-  d = n.dot(l1b - l2b);
-  dist_lat = (v2.cross(n)).dot(l2b - l1b) / t;
+  double t = n.norm ();
+  n.normalize ();
+  d = n.dot (l1b - l2b);
+  dist_lat = (v2.cross (n)).dot (l2b - l1b) / t;
   return d;
 }
 
-double calculateSegSegDistance(const Vector3d& l1b, const Vector3d& l1e, const Vector3d& l2b, const Vector3d& l2e, double& dist_lat)
-{
+double calculateSegSegDistance (const Vector3d &l1b, const Vector3d &l1e, const Vector3d &l2b, const Vector3d &l2e, double &dist_lat) {
   double d;
   Vector3d v1 = l1e - l1b;
   Vector3d v2 = l2e - l2b;
-  Vector3d n = v1.cross(v2);
+  Vector3d n = v1.cross (v2);
   Vector3d res;
-  if (n.norm() < 1e-6) {
-    return calculateLinePointDistance(l1b, l1e, l2b, d);
+  if (n.norm () < 1e-6) {
+    return calculateLinePointDistance (l1b, l1e, l2b, d);
   }
-  if (linsystem(v1, n, v2, l2e - l1b, res, nullptr))return NAN;
-  double d1 = std::clamp(res[0], 0.0, 1.0);
-  double d2 = std::clamp(res[2], 0.0, 1.0);
+  if (linsystem (v1, n, v2, l2e - l1b, res, nullptr))
+    return NAN;
+  double d1 = std::clamp (res[0], 0.0, 1.0);
+  double d2 = std::clamp (res[2], 0.0, 1.0);
   Vector3d dist = (l2e - v2 * d2) - (l1b + v1 * d1);
-  return dist.norm();
+  return dist.norm ();
 }
diff --git a/src/glview/cgal/CGALRenderUtils.h b/src/glview/cgal/CGALRenderUtils.h
index fa651143d..269382116 100644
--- a/src/glview/cgal/CGALRenderUtils.h
+++ b/src/glview/cgal/CGALRenderUtils.h
@@ -2,5 +2,5 @@
 
 #include "geometry/linalg.h"
 
-double calculateLinePointDistance(const Vector3d& l1, const Vector3d& l2, const Vector3d& pt, double& dist_lat);
-double calculateLineLineDistance(const Vector3d& l1b, const Vector3d& l1e, const Vector3d& l2b, const Vector3d& l2e, double& dist_lat);
+double calculateLinePointDistance (const Vector3d &l1, const Vector3d &l2, const Vector3d &pt, double &dist_lat);
+double calculateLineLineDistance (const Vector3d &l1b, const Vector3d &l1e, const Vector3d &l2b, const Vector3d &l2e, double &dist_lat);
diff --git a/src/glview/cgal/CGALRenderer.cc b/src/glview/cgal/CGALRenderer.cc
index 1c169d878..41b3392e8 100644
--- a/src/glview/cgal/CGALRenderer.cc
+++ b/src/glview/cgal/CGALRenderer.cc
@@ -59,255 +59,259 @@
 #include "geometry/manifold/ManifoldGeometry.h"
 #endif
 
-
-CGALRenderer::CGALRenderer(const std::shared_ptr<const class Geometry>& geom) {
-  this->addGeometry(geom);
-  PRINTD("CGALRenderer::CGALRenderer() -> createPolyhedrons()");
+CGALRenderer::CGALRenderer (const std::shared_ptr<const class Geometry> &geom) {
+  this->addGeometry (geom);
+  PRINTD ("CGALRenderer::CGALRenderer() -> createPolyhedrons()");
 #ifdef ENABLE_CGAL
-  if (!this->nefPolyhedrons_.empty() && this->polyhedrons_.empty())createPolyhedrons();
+  if (!this->nefPolyhedrons_.empty () && this->polyhedrons_.empty ())
+    createPolyhedrons ();
 #endif
 }
 
-void CGALRenderer::addGeometry(const std::shared_ptr<const Geometry>& geom) {
+void CGALRenderer::addGeometry (const std::shared_ptr<const Geometry> &geom) {
   if (const auto geomlist =
-        std::dynamic_pointer_cast<const GeometryList>(geom)) {
-    for (const auto& item : geomlist->getChildren()) {
-      this->addGeometry(item.second);
+        std::dynamic_pointer_cast<const GeometryList> (geom)) {
+    for (const auto &item : geomlist->getChildren ()) {
+      this->addGeometry (item.second);
     }
-  } else if (const auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
-    assert(ps->getDimension() == 3);
+  } else if (const auto ps = std::dynamic_pointer_cast<const PolySet> (geom)) {
+    assert (ps->getDimension () == 3);
     // We need to tessellate here, in case the generated PolySet contains
     // concave polygons See
     // tests/data/scad/3D/features/polyhedron-concave-test.scad
-    this->polysets_.push_back(PolySetUtils::tessellate_faces(*ps));
+    this->polysets_.push_back (PolySetUtils::tessellate_faces (*ps));
   } else if (const auto poly =
-               std::dynamic_pointer_cast<const Polygon2d>(geom)) {
-    this->polygons_.emplace_back(
-      poly, std::shared_ptr<const PolySet>(poly->tessellate()));
+               std::dynamic_pointer_cast<const Polygon2d> (geom)) {
+    this->polygons_.emplace_back (
+      poly, std::shared_ptr<const PolySet> (poly->tessellate ()));
 #ifdef ENABLE_CGAL
   } else if (const auto new_N =
-               std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
-    assert(new_N->getDimension() == 3);
-    if (!new_N->isEmpty()) {
-      this->nefPolyhedrons_.push_back(new_N);
+               std::dynamic_pointer_cast<const CGALNefGeometry> (geom)) {
+    assert (new_N->getDimension () == 3);
+    if (!new_N->isEmpty ()) {
+      this->nefPolyhedrons_.push_back (new_N);
     }
 #endif
 #ifdef ENABLE_MANIFOLD
   } else if (const auto mani =
-               std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
-    this->polysets_.push_back(mani->toPolySet());
+               std::dynamic_pointer_cast<const ManifoldGeometry> (geom)) {
+    this->polysets_.push_back (mani->toPolySet ());
 #endif
   } else {
-    assert(false && "unsupported geom in CGALRenderer");
+    assert (false && "unsupported geom in CGALRenderer");
   }
 }
 
-CGALRenderer::~CGALRenderer() {
+CGALRenderer::~CGALRenderer () {
 }
 
 #ifdef ENABLE_CGAL
-void CGALRenderer::createPolyhedrons() {
-  PRINTD("createPolyhedrons");
-  this->polyhedrons_.clear();
-  for (const auto& N : this->nefPolyhedrons_) {
-    auto p = std::make_shared<VBOPolyhedron>(*colorscheme_);
-    CGAL::OGL::Nef3_Converter<CGAL_Nef_polyhedron3>::convert_to_OGLPolyhedron(
-      *N->p3, p.get());
+void CGALRenderer::createPolyhedrons () {
+  PRINTD ("createPolyhedrons");
+  this->polyhedrons_.clear ();
+  for (const auto &N : this->nefPolyhedrons_) {
+    auto p = std::make_shared<VBOPolyhedron> (*colorscheme_);
+    CGAL::OGL::Nef3_Converter<CGAL_Nef_polyhedron3>::convert_to_OGLPolyhedron (
+      *N->p3, p.get ());
     // CGAL_NEF3_MARKED_FACET_COLOR <- CGAL_FACE_BACK_COLOR
     // CGAL_NEF3_UNMARKED_FACET_COLOR <- CGAL_FACE_FRONT_COLOR
-    p->init();
-    this->polyhedrons_.push_back(p);
+    p->init ();
+    this->polyhedrons_.push_back (p);
   }
-  PRINTD("createPolyhedrons() end");
+  PRINTD ("createPolyhedrons() end");
 }
 #endif // ifdef ENABLE_CGAL
 
 // Overridden from Renderer
-void CGALRenderer::setColorScheme(const ColorScheme& cs) {
-  PRINTD("setColorScheme");
-  Renderer::setColorScheme(cs);
+void CGALRenderer::setColorScheme (const ColorScheme &cs) {
+  PRINTD ("setColorScheme");
+  Renderer::setColorScheme (cs);
   colormap_[ColorMode::CGAL_FACE_2D_COLOR] =
-    ColorMap::getColor(cs, RenderColor::CGAL_FACE_2D_COLOR);
+    ColorMap::getColor (cs, RenderColor::CGAL_FACE_2D_COLOR);
   colormap_[ColorMode::CGAL_EDGE_2D_COLOR] =
-    ColorMap::getColor(cs, RenderColor::CGAL_EDGE_2D_COLOR);
+    ColorMap::getColor (cs, RenderColor::CGAL_EDGE_2D_COLOR);
 #ifdef ENABLE_CGAL
-  this->polyhedrons_.clear(); // Mark as dirty
+  this->polyhedrons_.clear (); // Mark as dirty
 #endif
-  vertex_state_containers_.clear(); // Mark as dirty
-  PRINTD("setColorScheme done");
+  vertex_state_containers_.clear (); // Mark as dirty
+  PRINTD ("setColorScheme done");
 }
 
-void CGALRenderer::createPolySetStates() {
-  PRINTD("createPolySetStates() polyset");
+void CGALRenderer::createPolySetStates () {
+  PRINTD ("createPolySetStates() polyset");
 
-  VertexStateContainer& vertex_state_container = vertex_state_containers_.emplace_back();
+  VertexStateContainer &vertex_state_container = vertex_state_containers_.emplace_back ();
 
-  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(), vertex_state_container);
+  VBOBuilder vbo_builder (std::make_unique<VertexStateFactory> (), vertex_state_container);
 
-  vbo_builder.addSurfaceData(); // position, normal, color
+  vbo_builder.addSurfaceData (); // position, normal, color
 
   size_t num_vertices = 0;
-  for (const auto& polyset : this->polysets_) {
-    num_vertices += calcNumVertices(*polyset);
+  for (const auto &polyset : this->polysets_) {
+    num_vertices += calcNumVertices (*polyset);
   }
-  vbo_builder.allocateBuffers(num_vertices);
+  vbo_builder.allocateBuffers (num_vertices);
 
-  for (const auto& polyset : this->polysets_) {
+  for (const auto &polyset : this->polysets_) {
     Color4f color;
-    getColorSchemeColor(ColorMode::MATERIAL, color);
-    vbo_builder.writeSurface();
-    vbo_builder.create_surface(*polyset, Transform3d::Identity(), color, false);
+    getColorSchemeColor (ColorMode::MATERIAL, color);
+    vbo_builder.writeSurface ();
+    vbo_builder.create_surface (*polyset, Transform3d::Identity (), color, false);
   }
 
-  vbo_builder.createInterleavedVBOs();
+  vbo_builder.createInterleavedVBOs ();
 }
 
-void CGALRenderer::createPolygonStates() {
-  createPolygonSurfaceStates();
-  createPolygonEdgeStates();
+void CGALRenderer::createPolygonStates () {
+  createPolygonSurfaceStates ();
+  createPolygonEdgeStates ();
 }
 
-void CGALRenderer::createPolygonSurfaceStates() {
-  VertexStateContainer& vertex_state_container = vertex_state_containers_.emplace_back();
-  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(), vertex_state_container);
-  vbo_builder.addSurfaceData();
+void CGALRenderer::createPolygonSurfaceStates () {
+  VertexStateContainer &vertex_state_container = vertex_state_containers_.emplace_back ();
+  VBOBuilder vbo_builder (std::make_unique<VertexStateFactory> (), vertex_state_container);
+  vbo_builder.addSurfaceData ();
 
   size_t num_vertices = 0;
-  for (const auto&[_, polyset] : this->polygons_) {
-    num_vertices += calcNumVertices(*polyset);
+  for (const auto &[_, polyset] : this->polygons_) {
+    num_vertices += calcNumVertices (*polyset);
   }
 
-  vbo_builder.allocateBuffers(num_vertices);
+  vbo_builder.allocateBuffers (num_vertices);
 
-  std::shared_ptr<VertexState> init_state = std::make_shared<VertexState>();
-  init_state->glBegin().emplace_back([]() {
-    GL_TRACE0("glDisable(GL_LIGHTING)");
-    GL_CHECKD(glDisable(GL_LIGHTING));
+  std::shared_ptr<VertexState> init_state = std::make_shared<VertexState> ();
+  init_state->glBegin ().emplace_back ([] () {
+    GL_TRACE0 ("glDisable(GL_LIGHTING)");
+    GL_CHECKD (glDisable (GL_LIGHTING));
   });
-  vertex_state_container.states().emplace_back(std::move(init_state));
+  vertex_state_container.states ().emplace_back (std::move (init_state));
 
-  for (const auto&[polygon, polyset] : this->polygons_) {
+  for (const auto &[polygon, polyset] : this->polygons_) {
     Color4f color;
-    getColorSchemeColor(ColorMode::CGAL_FACE_2D_COLOR, color);
-    vbo_builder.create_polygons(*polyset, Transform3d::Identity(), color);
+    getColorSchemeColor (ColorMode::CGAL_FACE_2D_COLOR, color);
+    vbo_builder.create_polygons (*polyset, Transform3d::Identity (), color);
   }
 
-  vbo_builder.createInterleavedVBOs();
+  vbo_builder.createInterleavedVBOs ();
 }
 
-void CGALRenderer::createPolygonEdgeStates() {
-  PRINTD("createPolygonStates()");
+void CGALRenderer::createPolygonEdgeStates () {
+  PRINTD ("createPolygonStates()");
 
-  VertexStateContainer& vertex_state_container = vertex_state_containers_.emplace_back();
-  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(), vertex_state_container);
+  VertexStateContainer &vertex_state_container = vertex_state_containers_.emplace_back ();
+  VBOBuilder vbo_builder (std::make_unique<VertexStateFactory> (), vertex_state_container);
 
-  vbo_builder.addEdgeData();
+  vbo_builder.addEdgeData ();
 
   size_t num_vertices = 0;
-  for (const auto&[polygon, _] : this->polygons_) {
-    num_vertices += calcNumEdgeVertices(*polygon);
+  for (const auto &[polygon, _] : this->polygons_) {
+    num_vertices += calcNumEdgeVertices (*polygon);
   }
 
-  vbo_builder.allocateBuffers(num_vertices);
+  vbo_builder.allocateBuffers (num_vertices);
 
-  std::shared_ptr<VertexState> edge_state = std::make_shared<VertexState>();
-  edge_state->glBegin().emplace_back([]() {
-    GL_TRACE0("glDisable(GL_DEPTH_TEST)");
-    GL_CHECKD(glDisable(GL_DEPTH_TEST));
-    GL_TRACE0("glLineWidth(2)");
-    GL_CHECKD(glLineWidth(2));
+  std::shared_ptr<VertexState> edge_state = std::make_shared<VertexState> ();
+  edge_state->glBegin ().emplace_back ([] () {
+    GL_TRACE0 ("glDisable(GL_DEPTH_TEST)");
+    GL_CHECKD (glDisable (GL_DEPTH_TEST));
+    GL_TRACE0 ("glLineWidth(2)");
+    GL_CHECKD (glLineWidth (2));
   });
-  vertex_state_container.states().emplace_back(std::move(edge_state));
+  vertex_state_container.states ().emplace_back (std::move (edge_state));
 
-  for (const auto&[polygon, _] : this->polygons_) {
+  for (const auto &[polygon, _] : this->polygons_) {
     Color4f color;
-    getColorSchemeColor(ColorMode::CGAL_EDGE_2D_COLOR, color);
-    vbo_builder.writeEdge();
-    vbo_builder.create_edges(*polygon, Transform3d::Identity(), color);
+    getColorSchemeColor (ColorMode::CGAL_EDGE_2D_COLOR, color);
+    vbo_builder.writeEdge ();
+    vbo_builder.create_edges (*polygon, Transform3d::Identity (), color);
   }
 
-  std::shared_ptr<VertexState> end_state = std::make_shared<VertexState>();
-  end_state->glBegin().emplace_back([]() {
-    GL_TRACE0("glEnable(GL_DEPTH_TEST)");
-    GL_CHECKD(glEnable(GL_DEPTH_TEST));
+  std::shared_ptr<VertexState> end_state = std::make_shared<VertexState> ();
+  end_state->glBegin ().emplace_back ([] () {
+    GL_TRACE0 ("glEnable(GL_DEPTH_TEST)");
+    GL_CHECKD (glEnable (GL_DEPTH_TEST));
   });
-  vertex_state_container.states().emplace_back(std::move(end_state));
+  vertex_state_container.states ().emplace_back (std::move (end_state));
 
-  vbo_builder.createInterleavedVBOs();
+  vbo_builder.createInterleavedVBOs ();
 }
 
-void CGALRenderer::prepare(const ShaderUtils::ShaderInfo * /*shaderinfo*/) {
-  PRINTD("prepare()");
-  if (!vertex_state_containers_.size()) {
-    if (!this->polysets_.empty() && !this->polygons_.empty()) {
-      LOG(message_group::Error, "CGALRenderer::prepare() called with both polysets and polygons");
-    } else if (!this->polysets_.empty()) {
-      createPolySetStates();
-    } else if (!this->polygons_.empty()) {
-      createPolygonStates();
+void CGALRenderer::prepare (const ShaderUtils::ShaderInfo * /*shaderinfo*/) {
+  PRINTD ("prepare()");
+  if (!vertex_state_containers_.size ()) {
+    if (!this->polysets_.empty () && !this->polygons_.empty ()) {
+      LOG (message_group::Error, "CGALRenderer::prepare() called with both polysets and polygons");
+    } else if (!this->polysets_.empty ()) {
+      createPolySetStates ();
+    } else if (!this->polygons_.empty ()) {
+      createPolygonStates ();
     }
   }
 
 #ifdef ENABLE_CGAL
-  if (!this->nefPolyhedrons_.empty() && this->polyhedrons_.empty())createPolyhedrons();
+  if (!this->nefPolyhedrons_.empty () && this->polyhedrons_.empty ())
+    createPolyhedrons ();
 #endif
 
-  PRINTD("prepare() end");
+  PRINTD ("prepare() end");
 }
 
-void CGALRenderer::draw(bool showedges, const ShaderUtils::ShaderInfo * /*shaderinfo*/) const {
-  PRINTD("draw()");
-// grab current state to restore after
+void CGALRenderer::draw (bool showedges, const ShaderUtils::ShaderInfo * /*shaderinfo*/) const {
+  PRINTD ("draw()");
+  // grab current state to restore after
   GLfloat current_point_size, current_line_width;
-  const GLboolean origVertexArrayState = glIsEnabled(GL_VERTEX_ARRAY);
-  const GLboolean origNormalArrayState = glIsEnabled(GL_NORMAL_ARRAY);
-  const GLboolean origColorArrayState = glIsEnabled(GL_COLOR_ARRAY);
+  const GLboolean origVertexArrayState = glIsEnabled (GL_VERTEX_ARRAY);
+  const GLboolean origNormalArrayState = glIsEnabled (GL_NORMAL_ARRAY);
+  const GLboolean origColorArrayState = glIsEnabled (GL_COLOR_ARRAY);
 
-  GL_CHECKD(glGetFloatv(GL_POINT_SIZE, &current_point_size));
-  GL_CHECKD(glGetFloatv(GL_LINE_WIDTH, &current_line_width));
+  GL_CHECKD (glGetFloatv (GL_POINT_SIZE, &current_point_size));
+  GL_CHECKD (glGetFloatv (GL_LINE_WIDTH, &current_line_width));
 
-  for (const auto& container : vertex_state_containers_) {
-    for (const auto& vertex_state : container.states()) {
-      if (vertex_state)vertex_state->draw();
+  for (const auto &container : vertex_state_containers_) {
+    for (const auto &vertex_state : container.states ()) {
+      if (vertex_state)
+        vertex_state->draw ();
     }
   }
 
   // restore states
-  GL_TRACE("glPointSize(%d)", current_point_size);
-  GL_CHECKD(glPointSize(current_point_size));
-  GL_TRACE("glLineWidth(%d)", current_line_width);
-  GL_CHECKD(glLineWidth(current_line_width));
-
-  if (!origVertexArrayState)glDisableClientState(GL_VERTEX_ARRAY);
-  if (!origNormalArrayState)glDisableClientState(GL_NORMAL_ARRAY);
-  if (!origColorArrayState)glDisableClientState(GL_COLOR_ARRAY);
+  GL_TRACE ("glPointSize(%d)", current_point_size);
+  GL_CHECKD (glPointSize (current_point_size));
+  GL_TRACE ("glLineWidth(%d)", current_line_width);
+  GL_CHECKD (glLineWidth (current_line_width));
+
+  if (!origVertexArrayState)
+    glDisableClientState (GL_VERTEX_ARRAY);
+  if (!origNormalArrayState)
+    glDisableClientState (GL_NORMAL_ARRAY);
+  if (!origColorArrayState)
+    glDisableClientState (GL_COLOR_ARRAY);
 
 #ifdef ENABLE_CGAL
-  for (const auto& p : this->getPolyhedrons()) {
-    p->draw(showedges);
+  for (const auto &p : this->getPolyhedrons ()) {
+    p->draw (showedges);
   }
 #endif
 
-  PRINTD("draw() end");
+  PRINTD ("draw() end");
 }
 
-BoundingBox CGALRenderer::getBoundingBox() const {
+BoundingBox CGALRenderer::getBoundingBox () const {
   BoundingBox bbox;
 
 #ifdef ENABLE_CGAL
-  for (const auto& p : this->getPolyhedrons()) {
-    const CGAL::Bbox_3 cgalbbox = p->bbox();
-    bbox.extend(BoundingBox(
-                  Vector3d(cgalbbox.xmin(), cgalbbox.ymin(), cgalbbox.zmin()),
-                  Vector3d(cgalbbox.xmax(), cgalbbox.ymax(), cgalbbox.zmax())));
+  for (const auto &p : this->getPolyhedrons ()) {
+    const CGAL::Bbox_3 cgalbbox = p->bbox ();
+    bbox.extend (BoundingBox (
+      Vector3d (cgalbbox.xmin (), cgalbbox.ymin (), cgalbbox.zmin ()),
+      Vector3d (cgalbbox.xmax (), cgalbbox.ymax (), cgalbbox.zmax ())));
   }
 #endif
-  for (const auto& ps : this->polysets_) {
-    bbox.extend(ps->getBoundingBox());
+  for (const auto &ps : this->polysets_) {
+    bbox.extend (ps->getBoundingBox ());
   }
-  for (const auto&[polygon, polyset] : this->polygons_) {
-    bbox.extend(polygon->getBoundingBox());
+  for (const auto &[polygon, polyset] : this->polygons_) {
+    bbox.extend (polygon->getBoundingBox ());
   }
   return bbox;
 }
-
diff --git a/src/glview/cgal/CGALRenderer.h b/src/glview/cgal/CGALRenderer.h
index c7afea62d..6c0f6eaa4 100644
--- a/src/glview/cgal/CGALRenderer.h
+++ b/src/glview/cgal/CGALRenderer.h
@@ -18,26 +18,28 @@
 class CGALRenderer : public VBORenderer
 {
 public:
-  CGALRenderer(const std::shared_ptr<const class Geometry>& geom);
-  ~CGALRenderer() override;
-  void prepare(const ShaderUtils::ShaderInfo *shaderinfo = nullptr) override;
-  void draw(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo = nullptr) const override;
-  void setColorScheme(const ColorScheme& cs) override;
-  BoundingBox getBoundingBox() const override;
+  CGALRenderer (const std::shared_ptr<const class Geometry> &geom);
+  ~CGALRenderer () override;
+  void prepare (const ShaderUtils::ShaderInfo *shaderinfo = nullptr) override;
+  void draw (bool showedges, const ShaderUtils::ShaderInfo *shaderinfo = nullptr) const override;
+  void setColorScheme (const ColorScheme &cs) override;
+  BoundingBox getBoundingBox () const override;
 
 private:
-  void addGeometry(const std::shared_ptr<const class Geometry>& geom);
+  void addGeometry (const std::shared_ptr<const class Geometry> &geom);
 #ifdef ENABLE_CGAL
-  const std::vector<std::shared_ptr<class VBOPolyhedron>>& getPolyhedrons() const { return this->polyhedrons_; }
-  void createPolyhedrons();
+  const std::vector<std::shared_ptr<class VBOPolyhedron>> &getPolyhedrons () const {
+    return this->polyhedrons_;
+  }
+  void createPolyhedrons ();
 #endif
 
   // FIXME: PolySet and Polygon2d features are only needed for the lazy-union feature,
   // when a GeometryList may contain a mixture of CGAL and Polygon2d/PolySet geometries.
-  void createPolySetStates();
-  void createPolygonStates();
-  void createPolygonSurfaceStates();
-  void createPolygonEdgeStates();
+  void createPolySetStates ();
+  void createPolygonStates ();
+  void createPolygonSurfaceStates ();
+  void createPolygonEdgeStates ();
 
   std::vector<std::shared_ptr<const class PolySet>> polysets_;
   std::vector<std::pair<std::shared_ptr<const Polygon2d>, std::shared_ptr<const PolySet>>> polygons_;
diff --git a/src/glview/cgal/VBOPolyhedron.h b/src/glview/cgal/VBOPolyhedron.h
index aecab992f..9c233ee76 100644
--- a/src/glview/cgal/VBOPolyhedron.h
+++ b/src/glview/cgal/VBOPolyhedron.h
@@ -55,43 +55,43 @@ public:
     NUM_COLORS
   };
 
-  VBOPolyhedron(const ColorScheme& cs) {
+  VBOPolyhedron (const ColorScheme &cs) {
     // Set default colors.
-    setColor(CGALColorIndex::MARKED_VERTEX_COLOR, {0xb7, 0xe8, 0x5c});
-    setColor(CGALColorIndex::UNMARKED_VERTEX_COLOR, {0xff, 0xf6, 0x7c});
-    setColor(CGALColorIndex::MARKED_FACET_COLOR, ColorMap::getColor(cs, RenderColor::CGAL_FACE_BACK_COLOR));
-    setColor(CGALColorIndex::UNMARKED_FACET_COLOR, ColorMap::getColor(cs, RenderColor::CGAL_FACE_FRONT_COLOR));
-    setColor(CGALColorIndex::MARKED_EDGE_COLOR, ColorMap::getColor(cs, RenderColor::CGAL_EDGE_BACK_COLOR));
-    setColor(CGALColorIndex::UNMARKED_EDGE_COLOR, ColorMap::getColor(cs, RenderColor::CGAL_EDGE_FRONT_COLOR));
+    setColor (CGALColorIndex::MARKED_VERTEX_COLOR, {0xb7, 0xe8, 0x5c});
+    setColor (CGALColorIndex::UNMARKED_VERTEX_COLOR, {0xff, 0xf6, 0x7c});
+    setColor (CGALColorIndex::MARKED_FACET_COLOR, ColorMap::getColor (cs, RenderColor::CGAL_FACE_BACK_COLOR));
+    setColor (CGALColorIndex::UNMARKED_FACET_COLOR, ColorMap::getColor (cs, RenderColor::CGAL_FACE_FRONT_COLOR));
+    setColor (CGALColorIndex::MARKED_EDGE_COLOR, ColorMap::getColor (cs, RenderColor::CGAL_EDGE_BACK_COLOR));
+    setColor (CGALColorIndex::UNMARKED_EDGE_COLOR, ColorMap::getColor (cs, RenderColor::CGAL_EDGE_FRONT_COLOR));
   }
 
-  ~VBOPolyhedron() override = default;
+  ~VBOPolyhedron () override = default;
 
-  void draw(Vertex_iterator v, VBOBuilder& vbo_builder) const {
-    PRINTD("draw(Vertex_iterator)");
+  void draw (Vertex_iterator v, VBOBuilder &vbo_builder) const {
+    PRINTD ("draw(Vertex_iterator)");
 
-    CGAL::Color c = getVertexColor(v);
-    vbo_builder.createVertex({Vector3d(v->x(), v->y(), v->z())},
-                             {},
-                             Color4f(c.red(), c.green(), c.blue()),
-                             0, 0, 1);
+    CGAL::Color c = getVertexColor (v);
+    vbo_builder.createVertex ({Vector3d (v->x (), v->y (), v->z ())},
+                              {},
+                              Color4f (c.red (), c.green (), c.blue ()),
+                              0, 0, 1);
   }
 
-  void draw(Edge_iterator e, VBOBuilder& vbo_builder) const {
-    PRINTD("draw(Edge_iterator)");
-
-    const Double_point p = e->source(), q = e->target();
-    const CGAL::Color c = getEdgeColor(e);
-    const Color4f color(c.red(), c.green(), c.blue());
-
-    vbo_builder.createVertex({Vector3d(p.x(), p.y(), p.z())},
-                             {},
-                             color,
-                             0, 0, true);
-    vbo_builder.createVertex({Vector3d(q.x(), q.y(), q.z())},
-                             {},
-                             color,
-                             0, 1, true);
+  void draw (Edge_iterator e, VBOBuilder &vbo_builder) const {
+    PRINTD ("draw(Edge_iterator)");
+
+    const Double_point p = e->source (), q = e->target ();
+    const CGAL::Color c = getEdgeColor (e);
+    const Color4f color (c.red (), c.green (), c.blue ());
+
+    vbo_builder.createVertex ({Vector3d (p.x (), p.y (), p.z ())},
+                              {},
+                              color,
+                              0, 0, true);
+    vbo_builder.createVertex ({Vector3d (q.x (), q.y (), q.z ())},
+                              {},
+                              color,
+                              0, 1, true);
   }
 
   struct TessUserData {
@@ -103,48 +103,49 @@ public:
     size_t last_size;
     size_t draw_size;
     size_t elements_offset;
-    VBOBuilder& vbo_builder;
+    VBOBuilder &vbo_builder;
   };
 
-  static inline void CGAL_GLU_TESS_CALLBACK beginCallback(GLenum which, GLvoid *user) {
-    auto *tess(static_cast<TessUserData *>(user));
+  static inline void CGAL_GLU_TESS_CALLBACK beginCallback (GLenum which, GLvoid *user) {
+    auto *tess (static_cast<TessUserData *> (user));
     // Create separate vertex set since "which" could be different draw type
     tess->which = which;
     tess->draw_size = 0;
 
-    tess->last_size = tess->vbo_builder.data()->sizeInBytes();
+    tess->last_size = tess->vbo_builder.data ()->sizeInBytes ();
     tess->elements_offset = 0;
-    if (tess->vbo_builder.useElements()) {
-      tess->elements_offset = tess->vbo_builder.elements().sizeInBytes();
+    if (tess->vbo_builder.useElements ()) {
+      tess->elements_offset = tess->vbo_builder.elements ().sizeInBytes ();
       // this can vary size if polyset provides triangles
-      tess->vbo_builder.addElementsData(std::make_shared<AttributeData<GLuint, 1, GL_UNSIGNED_INT>>());
-      tess->vbo_builder.elementsMap().clear();
+      tess->vbo_builder.addElementsData (std::make_shared<AttributeData<GLuint, 1, GL_UNSIGNED_INT>> ());
+      tess->vbo_builder.elementsMap ().clear ();
     }
   }
 
-  static inline void CGAL_GLU_TESS_CALLBACK endCallback(GLvoid *user) {
-    auto *tess(static_cast<TessUserData *>(user));
+  static inline void CGAL_GLU_TESS_CALLBACK endCallback (GLvoid *user) {
+    auto *tess (static_cast<TessUserData *> (user));
 
     GLenum elements_type = 0;
-    if (tess->vbo_builder.useElements()) elements_type = tess->vbo_builder.elementsData()->glType();
-    std::shared_ptr<VertexState> vs = tess->vbo_builder.createVertexState(
+    if (tess->vbo_builder.useElements ())
+      elements_type = tess->vbo_builder.elementsData ()->glType ();
+    std::shared_ptr<VertexState> vs = tess->vbo_builder.createVertexState (
       tess->which, tess->draw_size, elements_type,
-      tess->vbo_builder.writeIndex(), tess->elements_offset);
-    tess->vbo_builder.states().emplace_back(std::move(vs));
-    tess->vbo_builder.addAttributePointers(tess->last_size);
+      tess->vbo_builder.writeIndex (), tess->elements_offset);
+    tess->vbo_builder.states ().emplace_back (std::move (vs));
+    tess->vbo_builder.addAttributePointers (tess->last_size);
     tess->primitive_index++;
   }
 
-  static inline void CGAL_GLU_TESS_CALLBACK errorCallback(GLenum errorCode) {
+  static inline void CGAL_GLU_TESS_CALLBACK errorCallback (GLenum errorCode) {
     const GLubyte *estring;
-    estring = gluErrorString(errorCode);
-    fprintf(stderr, "Tessellation Error: %s\n", estring);
-    std::exit(0);
+    estring = gluErrorString (errorCode);
+    fprintf (stderr, "Tessellation Error: %s\n", estring);
+    std::exit (0);
   }
 
-  static inline void CGAL_GLU_TESS_CALLBACK vertexCallback(GLvoid *vertex_arg, GLvoid *user_arg) {
-    auto *vertex(static_cast<GLdouble *>(vertex_arg));
-    auto *tess(static_cast<TessUserData *>(user_arg));
+  static inline void CGAL_GLU_TESS_CALLBACK vertexCallback (GLvoid *vertex_arg, GLvoid *user_arg) {
+    auto *vertex (static_cast<GLdouble *> (vertex_arg));
+    auto *tess (static_cast<TessUserData *> (user_arg));
     size_t shape_size = 0;
 
     switch (tess->which) {
@@ -157,244 +158,247 @@ public:
       shape_size = 1;
       break;
     default:
-      assert(false && "Unsupported primitive type");
+      assert (false && "Unsupported primitive type");
       break;
     }
 
-
-    tess->vbo_builder.createVertex({Vector3d(vertex)},
-                                   {Vector3d(tess->normal)},
-                                   Color4f(tess->color.red(), tess->color.green(), tess->color.blue()),
-                                   0, 0, shape_size);
+    tess->vbo_builder.createVertex ({Vector3d (vertex)},
+                                    {Vector3d (tess->normal)},
+                                    Color4f (tess->color.red (), tess->color.green (), tess->color.blue ()),
+                                    0, 0, shape_size);
     tess->draw_size++;
     tess->active_point_index++;
   }
 
-  static inline void CGAL_GLU_TESS_CALLBACK combineCallback(GLdouble coords[3], GLvoid *[4], GLfloat [4], GLvoid **dataOut) {
+  static inline void CGAL_GLU_TESS_CALLBACK combineCallback (GLdouble coords[3], GLvoid *[4], GLfloat[4], GLvoid **dataOut) {
     static std::vector<std::unique_ptr<Vector3d>> vertexCache;
     if (dataOut) {
-      vertexCache.push_back(std::make_unique<Vector3d>(coords));
-      *dataOut = vertexCache.back().get();
+      vertexCache.push_back (std::make_unique<Vector3d> (coords));
+      *dataOut = vertexCache.back ().get ();
     } else {
-      vertexCache.clear();
+      vertexCache.clear ();
     }
   }
 
-  void draw(Halffacet_iterator f, VBOBuilder& vbo_builder) const {
-    PRINTD("draw(Halffacet_iterator)");
-
-    GLUtesselator *tess_ = gluNewTess();
-    gluTessCallback(tess_, GLenum(GLU_TESS_VERTEX_DATA),
-                    (GLvoid(CGAL_GLU_TESS_CALLBACK *)(CGAL_GLU_TESS_DOTS)) & vertexCallback);
-    gluTessCallback(tess_, GLenum(GLU_TESS_COMBINE),
-                    (GLvoid(CGAL_GLU_TESS_CALLBACK *)(CGAL_GLU_TESS_DOTS)) & combineCallback);
-    gluTessCallback(tess_, GLenum(GLU_TESS_BEGIN_DATA),
-                    (GLvoid(CGAL_GLU_TESS_CALLBACK *)(CGAL_GLU_TESS_DOTS)) & beginCallback);
-    gluTessCallback(tess_, GLenum(GLU_TESS_END_DATA),
-                    (GLvoid(CGAL_GLU_TESS_CALLBACK *)(CGAL_GLU_TESS_DOTS)) & endCallback);
-    gluTessCallback(tess_, GLenum(GLU_TESS_ERROR),
-                    (GLvoid(CGAL_GLU_TESS_CALLBACK *)(CGAL_GLU_TESS_DOTS)) & errorCallback);
-    gluTessProperty(tess_, GLenum(GLU_TESS_WINDING_RULE),
-                    GLU_TESS_WINDING_POSITIVE);
+  void draw (Halffacet_iterator f, VBOBuilder &vbo_builder) const {
+    PRINTD ("draw(Halffacet_iterator)");
+
+    GLUtesselator *tess_ = gluNewTess ();
+    gluTessCallback (tess_, GLenum (GLU_TESS_VERTEX_DATA),
+                     (GLvoid (CGAL_GLU_TESS_CALLBACK *) (CGAL_GLU_TESS_DOTS))&vertexCallback);
+    gluTessCallback (tess_, GLenum (GLU_TESS_COMBINE),
+                     (GLvoid (CGAL_GLU_TESS_CALLBACK *) (CGAL_GLU_TESS_DOTS))&combineCallback);
+    gluTessCallback (tess_, GLenum (GLU_TESS_BEGIN_DATA),
+                     (GLvoid (CGAL_GLU_TESS_CALLBACK *) (CGAL_GLU_TESS_DOTS))&beginCallback);
+    gluTessCallback (tess_, GLenum (GLU_TESS_END_DATA),
+                     (GLvoid (CGAL_GLU_TESS_CALLBACK *) (CGAL_GLU_TESS_DOTS))&endCallback);
+    gluTessCallback (tess_, GLenum (GLU_TESS_ERROR),
+                     (GLvoid (CGAL_GLU_TESS_CALLBACK *) (CGAL_GLU_TESS_DOTS))&errorCallback);
+    gluTessProperty (tess_, GLenum (GLU_TESS_WINDING_RULE),
+                     GLU_TESS_WINDING_POSITIVE);
 
     CGAL::OGL::DFacet::Coord_const_iterator cit;
     TessUserData tess_data = {
-      0, f->normal(), getFacetColor(f),
-      0, 0, 0, 0, 0, vbo_builder
-    };
+      0, f->normal (), getFacetColor (f),
+      0, 0, 0, 0, 0, vbo_builder};
 
-    gluTessBeginPolygon(tess_, &tess_data);
+    gluTessBeginPolygon (tess_, &tess_data);
     // forall facet cycles of f:
-    for (unsigned i = 0; i < f->number_of_facet_cycles(); ++i) {
-      gluTessBeginContour(tess_);
+    for (unsigned i = 0; i < f->number_of_facet_cycles (); ++i) {
+      gluTessBeginContour (tess_);
       // put all vertices in facet cycle into contour:
-      for (cit = f->facet_cycle_begin(i);
-           cit != f->facet_cycle_end(i); ++cit) {
-        gluTessVertex(tess_, *cit, *cit);
+      for (cit = f->facet_cycle_begin (i);
+           cit != f->facet_cycle_end (i); ++cit) {
+        gluTessVertex (tess_, *cit, *cit);
       }
-      gluTessEndContour(tess_);
+      gluTessEndContour (tess_);
     }
-    gluTessEndPolygon(tess_);
-    gluDeleteTess(tess_);
-    combineCallback(nullptr, nullptr, nullptr, nullptr);
+    gluTessEndPolygon (tess_);
+    gluDeleteTess (tess_);
+    combineCallback (nullptr, nullptr, nullptr, nullptr);
   }
 
-  void create_polyhedron() {
-    PRINTD("create_polyhedron");
+  void create_polyhedron () {
+    PRINTD ("create_polyhedron");
 
-    points_edges_container_ = std::make_unique<VertexStateContainer>();
+    points_edges_container_ = std::make_unique<VertexStateContainer> ();
 
-    VBOBuilder points_edges_builder(std::make_unique<VertexStateFactory>(), *points_edges_container_.get());
+    VBOBuilder points_edges_builder (std::make_unique<VertexStateFactory> (), *points_edges_container_.get ());
 
-    points_edges_builder.addEdgeData();
-    points_edges_builder.writeEdge();
+    points_edges_builder.addEdgeData ();
+    points_edges_builder.writeEdge ();
     size_t last_size = 0;
     size_t elements_offset = 0;
 
-    const size_t num_vertices = vertices_.size() + edges_.size() * 2, elements_size = 0;
-    points_edges_builder.allocateBuffers(num_vertices);
+    const size_t num_vertices = vertices_.size () + edges_.size () * 2, elements_size = 0;
+    points_edges_builder.allocateBuffers (num_vertices);
 
     // Points
     Vertex_iterator v;
-    if (points_edges_builder.useElements()) {
-      elements_offset = points_edges_builder.elementsOffset();
-      points_edges_builder.elementsMap().clear();
+    if (points_edges_builder.useElements ()) {
+      elements_offset = points_edges_builder.elementsOffset ();
+      points_edges_builder.elementsMap ().clear ();
     }
 
-    std::shared_ptr<VertexState> settings = std::make_shared<VertexState>();
-    settings->glBegin().emplace_back([]() {
-      GL_TRACE0("glDisable(GL_LIGHTING)");
-      GL_CHECKD(glDisable(GL_LIGHTING));
+    std::shared_ptr<VertexState> settings = std::make_shared<VertexState> ();
+    settings->glBegin ().emplace_back ([] () {
+      GL_TRACE0 ("glDisable(GL_LIGHTING)");
+      GL_CHECKD (glDisable (GL_LIGHTING));
     });
-    settings->glBegin().emplace_back([]() {
-      GL_TRACE0("glPointSize(10.0f)");
-      GL_CHECKD(glPointSize(10.0f));
+    settings->glBegin ().emplace_back ([] () {
+      GL_TRACE0 ("glPointSize(10.0f)");
+      GL_CHECKD (glPointSize (10.0f));
     });
-    points_edges_container_->states().emplace_back(std::move(settings));
+    points_edges_container_->states ().emplace_back (std::move (settings));
 
-    for (v = vertices_.begin(); v != vertices_.end(); ++v)
-      draw(v, points_edges_builder);
+    for (v = vertices_.begin (); v != vertices_.end (); ++v)
+      draw (v, points_edges_builder);
 
     GLenum elements_type = 0;
-    if (points_edges_builder.useElements()) elements_type = points_edges_builder.elementsData()->glType();
-    std::shared_ptr<VertexState> vs = points_edges_builder.createVertexState(
-      GL_POINTS, vertices_.size(), elements_type,
-      points_edges_builder.writeIndex(), elements_offset);
-    points_edges_container_->states().emplace_back(std::move(vs));
-    points_edges_builder.addAttributePointers(last_size);
+    if (points_edges_builder.useElements ())
+      elements_type = points_edges_builder.elementsData ()->glType ();
+    std::shared_ptr<VertexState> vs = points_edges_builder.createVertexState (
+      GL_POINTS, vertices_.size (), elements_type,
+      points_edges_builder.writeIndex (), elements_offset);
+    points_edges_container_->states ().emplace_back (std::move (vs));
+    points_edges_builder.addAttributePointers (last_size);
 
     // Edges
     Edge_iterator e;
-    last_size = points_edges_builder.verticesOffset();
+    last_size = points_edges_builder.verticesOffset ();
     elements_offset = 0;
-    if (points_edges_builder.useElements()) {
-      elements_offset = points_edges_builder.elementsOffset();
-      points_edges_builder.elementsMap().clear();
+    if (points_edges_builder.useElements ()) {
+      elements_offset = points_edges_builder.elementsOffset ();
+      points_edges_builder.elementsMap ().clear ();
     }
 
-    settings = std::make_shared<VertexState>();
-    settings->glBegin().emplace_back([]() {
-      GL_TRACE0("glDisable(GL_LIGHTING)");
-      GL_CHECKD(glDisable(GL_LIGHTING));
+    settings = std::make_shared<VertexState> ();
+    settings->glBegin ().emplace_back ([] () {
+      GL_TRACE0 ("glDisable(GL_LIGHTING)");
+      GL_CHECKD (glDisable (GL_LIGHTING));
     });
-    settings->glBegin().emplace_back([]() {
-      GL_TRACE0("glLineWidth(5.0f)");
-      GL_CHECKD(glLineWidth(5.0f));
+    settings->glBegin ().emplace_back ([] () {
+      GL_TRACE0 ("glLineWidth(5.0f)");
+      GL_CHECKD (glLineWidth (5.0f));
     });
-    points_edges_container_->states().emplace_back(std::move(settings));
-
-    for (e = edges_.begin(); e != edges_.end(); ++e)
-      draw(e, points_edges_builder);
+    points_edges_container_->states ().emplace_back (std::move (settings));
 
+    for (e = edges_.begin (); e != edges_.end (); ++e)
+      draw (e, points_edges_builder);
 
     elements_type = 0;
-    if (points_edges_builder.useElements()) elements_type = points_edges_builder.elementsData()->glType();
-    vs = points_edges_builder.createVertexState(
-      GL_LINES, edges_.size() * 2, elements_type,
-      points_edges_builder.writeIndex(), elements_offset);
-    points_edges_container_->states().emplace_back(std::move(vs));
-    points_edges_builder.addAttributePointers(last_size);
+    if (points_edges_builder.useElements ())
+      elements_type = points_edges_builder.elementsData ()->glType ();
+    vs = points_edges_builder.createVertexState (
+      GL_LINES, edges_.size () * 2, elements_type,
+      points_edges_builder.writeIndex (), elements_offset);
+    points_edges_container_->states ().emplace_back (std::move (vs));
+    points_edges_builder.addAttributePointers (last_size);
 
-    points_edges_builder.createInterleavedVBOs();
+    points_edges_builder.createInterleavedVBOs ();
 
     // Halffacets
-    halffacets_container_ = std::make_unique<VertexStateContainer>();
+    halffacets_container_ = std::make_unique<VertexStateContainer> ();
 
     // FIXME: We don't know the size of this VertexArray in advanced, so we have to deal with some fallback mechanism for filling in the data. This complicates code quite a bit
-    VBOBuilder halffacets_builder(std::make_unique<VertexStateFactory>(), *halffacets_container_.get());
-    halffacets_builder.addSurfaceData();
-    halffacets_builder.writeSurface();
-
-    settings = std::make_shared<VertexState>();
-    settings->glBegin().emplace_back([]() {
-      GL_TRACE0("glEnable(GL_LIGHTING)");
-      GL_CHECKD(glEnable(GL_LIGHTING));
+    VBOBuilder halffacets_builder (std::make_unique<VertexStateFactory> (), *halffacets_container_.get ());
+    halffacets_builder.addSurfaceData ();
+    halffacets_builder.writeSurface ();
+
+    settings = std::make_shared<VertexState> ();
+    settings->glBegin ().emplace_back ([] () {
+      GL_TRACE0 ("glEnable(GL_LIGHTING)");
+      GL_CHECKD (glEnable (GL_LIGHTING));
     });
-    settings->glBegin().emplace_back([]() {
-      GL_TRACE0("glLineWidth(5.0f)");
-      GL_CHECKD(glLineWidth(5.0f));
+    settings->glBegin ().emplace_back ([] () {
+      GL_TRACE0 ("glLineWidth(5.0f)");
+      GL_CHECKD (glLineWidth (5.0f));
     });
-    halffacets_container_->states().emplace_back(std::move(settings));
+    halffacets_container_->states ().emplace_back (std::move (settings));
 
     Halffacet_iterator f;
-    for (f = halffacets_.begin(); f != halffacets_.end(); ++f) {
-      draw(f, halffacets_builder);
+    for (f = halffacets_.begin (); f != halffacets_.end (); ++f) {
+      draw (f, halffacets_builder);
     }
 
-    halffacets_builder.createInterleavedVBOs();
+    halffacets_builder.createInterleavedVBOs ();
   }
 
-  void init() override {
-    PRINTD("VBO init()");
-    create_polyhedron();
-    PRINTD("VBO init() end");
+  void init () override {
+    PRINTD ("VBO init()");
+    create_polyhedron ();
+    PRINTD ("VBO init() end");
   }
 
-  void draw() const override {
-    PRINTD("VBO draw()");
-    PRINTD("VBO draw() end");
+  void draw () const override {
+    PRINTD ("VBO draw()");
+    PRINTD ("VBO draw() end");
   }
 
-  void draw(bool showedges) const override {
-    PRINTDB("VBO draw(showedges = %d)", showedges);
+  void draw (bool showedges) const override {
+    PRINTDB ("VBO draw(showedges = %d)", showedges);
     // grab current state to restore after
     GLfloat current_point_size, current_line_width;
-    const GLboolean origVertexArrayState = glIsEnabled(GL_VERTEX_ARRAY);
-    const GLboolean origNormalArrayState = glIsEnabled(GL_NORMAL_ARRAY);
-    const GLboolean origColorArrayState = glIsEnabled(GL_COLOR_ARRAY);
+    const GLboolean origVertexArrayState = glIsEnabled (GL_VERTEX_ARRAY);
+    const GLboolean origNormalArrayState = glIsEnabled (GL_NORMAL_ARRAY);
+    const GLboolean origColorArrayState = glIsEnabled (GL_COLOR_ARRAY);
 
-    GL_CHECKD(glGetFloatv(GL_POINT_SIZE, &current_point_size));
-    GL_CHECKD(glGetFloatv(GL_LINE_WIDTH, &current_line_width));
+    GL_CHECKD (glGetFloatv (GL_POINT_SIZE, &current_point_size));
+    GL_CHECKD (glGetFloatv (GL_LINE_WIDTH, &current_line_width));
 
-    for (const auto& halffacet : halffacets_container_->states()) {
-      if (halffacet) halffacet->draw();
+    for (const auto &halffacet : halffacets_container_->states ()) {
+      if (halffacet)
+        halffacet->draw ();
     }
 
     if (showedges) {
-      for (const auto& point_edge : points_edges_container_->states()) {
-        if (point_edge) point_edge->draw();
+      for (const auto &point_edge : points_edges_container_->states ()) {
+        if (point_edge)
+          point_edge->draw ();
       }
     }
 
     // restore states
-    GL_TRACE("glPointSize(%d)", current_point_size);
-    GL_CHECKD(glPointSize(current_point_size));
-    GL_TRACE("glLineWidth(%d)", current_line_width);
-    GL_CHECKD(glLineWidth(current_line_width));
-
-    if (!origVertexArrayState) glDisableClientState(GL_VERTEX_ARRAY);
-    if (!origNormalArrayState) glDisableClientState(GL_NORMAL_ARRAY);
-    if (!origColorArrayState) glDisableClientState(GL_COLOR_ARRAY);
-
-    PRINTD("VBO draw() end");
+    GL_TRACE ("glPointSize(%d)", current_point_size);
+    GL_CHECKD (glPointSize (current_point_size));
+    GL_TRACE ("glLineWidth(%d)", current_line_width);
+    GL_CHECKD (glLineWidth (current_line_width));
+
+    if (!origVertexArrayState)
+      glDisableClientState (GL_VERTEX_ARRAY);
+    if (!origNormalArrayState)
+      glDisableClientState (GL_NORMAL_ARRAY);
+    if (!origColorArrayState)
+      glDisableClientState (GL_COLOR_ARRAY);
+
+    PRINTD ("VBO draw() end");
   }
 
-
   // overrides function in OGL_helper.h
-  [[nodiscard]] CGAL::Color getVertexColor(Vertex_iterator v) const override {
-    PRINTD("getVertexColor");
-    CGAL::Color c = v->mark() ? colors[CGALColorIndex::UNMARKED_VERTEX_COLOR] : colors[CGALColorIndex::MARKED_VERTEX_COLOR];
+  [[nodiscard]] CGAL::Color getVertexColor (Vertex_iterator v) const override {
+    PRINTD ("getVertexColor");
+    CGAL::Color c = v->mark () ? colors[CGALColorIndex::UNMARKED_VERTEX_COLOR] : colors[CGALColorIndex::MARKED_VERTEX_COLOR];
     return c;
   }
 
   // overrides function in OGL_helper.h
-  [[nodiscard]] CGAL::Color getEdgeColor(Edge_iterator e) const override {
-    PRINTD("getEdgeColor");
-    CGAL::Color c = e->mark() ? colors[CGALColorIndex::UNMARKED_EDGE_COLOR] : colors[CGALColorIndex::MARKED_EDGE_COLOR];
+  [[nodiscard]] CGAL::Color getEdgeColor (Edge_iterator e) const override {
+    PRINTD ("getEdgeColor");
+    CGAL::Color c = e->mark () ? colors[CGALColorIndex::UNMARKED_EDGE_COLOR] : colors[CGALColorIndex::MARKED_EDGE_COLOR];
     return c;
   }
 
   // overrides function in OGL_helper.h
-  [[nodiscard]] CGAL::Color getFacetColor(Halffacet_iterator f) const override {
-    CGAL::Color c = f->mark() ? colors[CGALColorIndex::UNMARKED_FACET_COLOR] : colors[CGALColorIndex::MARKED_FACET_COLOR];
+  [[nodiscard]] CGAL::Color getFacetColor (Halffacet_iterator f) const override {
+    CGAL::Color c = f->mark () ? colors[CGALColorIndex::UNMARKED_FACET_COLOR] : colors[CGALColorIndex::MARKED_FACET_COLOR];
     return c;
   }
 
-  void setColor(CGALColorIndex color_index, const Color4f& c) {
+  void setColor (CGALColorIndex color_index, const Color4f &c) {
     // Note: Not setting alpha here as none of our built-in colors currently have an alpha component
     // This _may_ yield unexpected results for user-defined colors with alpha components.
-    PRINTDB("setColor %i %f %f %f", color_index % c.r() % c.g() % c.b());
-    this->colors[color_index] = CGAL::Color(c.r() * 255, c.g() * 255, c.b() * 255);
+    PRINTDB ("setColor %i %f %f %f", color_index % c.r () % c.g () % c.b ());
+    this->colors[color_index] = CGAL::Color (c.r () * 255, c.g () * 255, c.b () * 255);
   }
 
 protected:
diff --git a/src/glview/fbo.cc b/src/glview/fbo.cc
index 08c6bc309..6422f6160 100644
--- a/src/glview/fbo.cc
+++ b/src/glview/fbo.cc
@@ -7,8 +7,8 @@
 
 namespace {
 
-bool checkFBOStatus() {
-  const auto status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
+bool checkFBOStatus () {
+  const auto status = glCheckFramebufferStatus (GL_FRAMEBUFFER);
 
   const char *statusString = nullptr;
   switch (status) {
@@ -43,74 +43,77 @@ bool checkFBOStatus() {
     break;
   }
 
-  LOG(message_group::Error, "glCheckFramebufferStatus(): %1$s",
-      statusString ? statusString : "Unknown status " + std::to_string(status));
+  LOG (message_group::Error, "glCheckFramebufferStatus(): %1$s",
+       statusString ? statusString : "Unknown status " + std::to_string (status));
   return false;
 }
 
-}  // namespace
+} // namespace
 
-std::unique_ptr<FBO> createFBO(int width, int height) {
-  if (hasGLExtension(ARB_framebuffer_object)) {
-    return std::make_unique<FBO>(width, height, /*useEXT*/ false);
-  } else if (hasGLExtension(EXT_framebuffer_object)) {
-    return std::make_unique<FBO>(width, height, /*useEXT*/ true);
+std::unique_ptr<FBO> createFBO (int width, int height) {
+  if (hasGLExtension (ARB_framebuffer_object)) {
+    return std::make_unique<FBO> (width, height, /*useEXT*/ false);
+  } else if (hasGLExtension (EXT_framebuffer_object)) {
+    return std::make_unique<FBO> (width, height, /*useEXT*/ true);
   } else {
-    LOG(message_group::Error, "Framebuffer Objects not supported");
+    LOG (message_group::Error, "Framebuffer Objects not supported");
     return nullptr;
   }
 }
 
-FBO::FBO(int width, int height, bool useEXT) : width_(width), height_(height), use_ext_(useEXT) {
+FBO::FBO (int width, int height, bool useEXT)
+  : width_ (width)
+  , height_ (height)
+  , use_ext_ (useEXT) {
   // Generate and bind FBO
-  GL_CHECKD(glGenFramebuffers(1, &this->fbo_id_));
-  this->bind();
+  GL_CHECKD (glGenFramebuffers (1, &this->fbo_id_));
+  this->bind ();
 
   // Generate depth and render buffers
-  GL_CHECKD(glGenRenderbuffers(1, &this->depthbuf_id_));
-  GL_CHECKD(glGenRenderbuffers(1, &this->renderbuf_id_));
+  GL_CHECKD (glGenRenderbuffers (1, &this->depthbuf_id_));
+  GL_CHECKD (glGenRenderbuffers (1, &this->renderbuf_id_));
 
   // Create buffers with correct size
-  if (!this->resize(width, height)) return;
+  if (!this->resize (width, height))
+    return;
 
   // Attach render and depth buffers
-  GL_CHECKD(glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
-                                      GL_RENDERBUFFER, this->renderbuf_id_));
+  GL_CHECKD (glFramebufferRenderbuffer (GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
+                                        GL_RENDERBUFFER, this->renderbuf_id_));
 
-  if (!checkFBOStatus()) {
-    LOG(message_group::Error, "Problem with OpenGL framebuffer after specifying color render buffer.");
+  if (!checkFBOStatus ()) {
+    LOG (message_group::Error, "Problem with OpenGL framebuffer after specifying color render buffer.");
     return;
   }
 
   // to prevent Mesa's software renderer from crashing, do this in two stages.
   // ie. instead of using GL_DEPTH_STENCIL_ATTACHMENT, do DEPTH then STENCIL.
-  GL_CHECKD(glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
-                                      GL_RENDERBUFFER, this->depthbuf_id_));
-  GL_CHECKD(glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT,
-                                      GL_RENDERBUFFER, this->depthbuf_id_));
+  GL_CHECKD (glFramebufferRenderbuffer (GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
+                                        GL_RENDERBUFFER, this->depthbuf_id_));
+  GL_CHECKD (glFramebufferRenderbuffer (GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT,
+                                        GL_RENDERBUFFER, this->depthbuf_id_));
 
-  if (!checkFBOStatus()) {
-    LOG(message_group::Error, "Problem with OpenGL framebuffer after specifying depth render buffer.");
+  if (!checkFBOStatus ()) {
+    LOG (message_group::Error, "Problem with OpenGL framebuffer after specifying depth render buffer.");
     return;
   }
 
   this->complete_ = true;
 }
 
-bool FBO::resize(size_t width, size_t height)
-{
+bool FBO::resize (size_t width, size_t height) {
   if (this->use_ext_) {
-    GL_CHECKD(glBindRenderbufferEXT(GL_RENDERBUFFER, this->renderbuf_id_));
+    GL_CHECKD (glBindRenderbufferEXT (GL_RENDERBUFFER, this->renderbuf_id_));
   } else {
-    GL_CHECKD(glBindRenderbuffer(GL_RENDERBUFFER, this->renderbuf_id_));
+    GL_CHECKD (glBindRenderbuffer (GL_RENDERBUFFER, this->renderbuf_id_));
   }
-  GL_CHECKD(glRenderbufferStorage(GL_RENDERBUFFER, GL_RGBA8, width, height));
+  GL_CHECKD (glRenderbufferStorage (GL_RENDERBUFFER, GL_RGBA8, width, height));
   if (this->use_ext_) {
-    GL_CHECKD(glBindRenderbufferEXT(GL_RENDERBUFFER, this->depthbuf_id_));
+    GL_CHECKD (glBindRenderbufferEXT (GL_RENDERBUFFER, this->depthbuf_id_));
   } else {
-    GL_CHECKD(glBindRenderbuffer(GL_RENDERBUFFER, this->depthbuf_id_));
+    GL_CHECKD (glBindRenderbuffer (GL_RENDERBUFFER, this->depthbuf_id_));
   }
-  GL_CHECKD(glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, width, height));
+  GL_CHECKD (glRenderbufferStorage (GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, width, height));
 
   width_ = width;
   height_ = height;
@@ -119,41 +122,38 @@ bool FBO::resize(size_t width, size_t height)
 }
 
 // Bind this VBO. Returs the old FBO id.
-GLuint FBO::bind()
-{
-  glGetIntegerv(GL_FRAMEBUFFER_BINDING, reinterpret_cast<GLint *>(&this->old_fbo_id_));
+GLuint FBO::bind () {
+  glGetIntegerv (GL_FRAMEBUFFER_BINDING, reinterpret_cast<GLint *> (&this->old_fbo_id_));
   if (this->use_ext_) {
-    GL_CHECKD(glBindFramebufferEXT(GL_FRAMEBUFFER, this->fbo_id_));
+    GL_CHECKD (glBindFramebufferEXT (GL_FRAMEBUFFER, this->fbo_id_));
   } else {
-    GL_CHECKD(glBindFramebuffer(GL_FRAMEBUFFER, this->fbo_id_));
+    GL_CHECKD (glBindFramebuffer (GL_FRAMEBUFFER, this->fbo_id_));
   }
   return this->old_fbo_id_;
 }
 
 // Unbind this VBO, and bind the previous FBO id.
-void FBO::unbind()
-{
+void FBO::unbind () {
   if (this->use_ext_) {
-    GL_CHECKD(glBindFramebufferEXT(GL_FRAMEBUFFER, this->old_fbo_id_));
+    GL_CHECKD (glBindFramebufferEXT (GL_FRAMEBUFFER, this->old_fbo_id_));
   } else {
-    GL_CHECKD(glBindFramebuffer(GL_FRAMEBUFFER, this->old_fbo_id_));
+    GL_CHECKD (glBindFramebuffer (GL_FRAMEBUFFER, this->old_fbo_id_));
   }
   this->old_fbo_id_ = 0;
 }
 
-void FBO::destroy()
-{
-  this->unbind();
+void FBO::destroy () {
+  this->unbind ();
   if (this->depthbuf_id_ != 0) {
-    GL_CHECKD(glDeleteRenderbuffers(1, &this->depthbuf_id_));
+    GL_CHECKD (glDeleteRenderbuffers (1, &this->depthbuf_id_));
     this->depthbuf_id_ = 0;
   }
   if (this->renderbuf_id_ != 0) {
-    GL_CHECKD(glDeleteRenderbuffers(1, &this->renderbuf_id_));
+    GL_CHECKD (glDeleteRenderbuffers (1, &this->renderbuf_id_));
     this->renderbuf_id_ = 0;
   }
   if (this->fbo_id_ != 0) {
-    GL_CHECKD(glDeleteFramebuffers(1, &this->fbo_id_));
+    GL_CHECKD (glDeleteFramebuffers (1, &this->fbo_id_));
     this->fbo_id_ = 0;
   }
 }
diff --git a/src/glview/fbo.h b/src/glview/fbo.h
index 901cf0b48..53f47227f 100644
--- a/src/glview/fbo.h
+++ b/src/glview/fbo.h
@@ -8,19 +8,27 @@
 class FBO
 {
 public:
-  FBO(int width, int height, bool useEXT);
-  ~FBO() { destroy(); }
-
-  int width() const { return this->width_; }
-  int height() const { return this->height_; }
-  bool isComplete() const { return this->complete_; }
-
-  bool resize(size_t width, size_t height);
-  GLuint bind();
-  void unbind();
+  FBO (int width, int height, bool useEXT);
+  ~FBO () {
+    destroy ();
+  }
+
+  int width () const {
+    return this->width_;
+  }
+  int height () const {
+    return this->height_;
+  }
+  bool isComplete () const {
+    return this->complete_;
+  }
+
+  bool resize (size_t width, size_t height);
+  GLuint bind ();
+  void unbind ();
 
 private:
-  void destroy();
+  void destroy ();
 
   bool use_ext_;
   int width_ = 0;
@@ -32,4 +40,4 @@ private:
   bool complete_ = false;
 };
 
-std::unique_ptr<FBO> createFBO(int width, int height);
+std::unique_ptr<FBO> createFBO (int width, int height);
diff --git a/src/glview/glew-utils.cc b/src/glview/glew-utils.cc
index de5fec911..bee619293 100644
--- a/src/glview/glew-utils.cc
+++ b/src/glview/glew-utils.cc
@@ -3,10 +3,10 @@
 
 #include <GL/glew.h>
 
-bool initializeGlew() {
-  auto err = glewInit();
+bool initializeGlew () {
+  auto err = glewInit ();
   if (err != GLEW_OK) {
-    fprintf(stderr, "GLEW Error: %s\n", glewGetErrorString(err));
+    fprintf (stderr, "GLEW Error: %s\n", glewGetErrorString (err));
     return false;
   }
   return true;
diff --git a/src/glview/glew-utils.h b/src/glview/glew-utils.h
index 17f6ed731..8c8d1a9a6 100644
--- a/src/glview/glew-utils.h
+++ b/src/glview/glew-utils.h
@@ -1,3 +1,3 @@
 #pragma once
 
-bool initializeGlew();
+bool initializeGlew ();
diff --git a/src/glview/hershey.cc b/src/glview/hershey.cc
index 56a5e6292..4cb412a44 100644
--- a/src/glview/hershey.cc
+++ b/src/glview/hershey.cc
@@ -16,49 +16,53 @@ struct HersheyGlyph {
   } operations[55];
 };
 extern const HersheyGlyph hershey_simplex[];
-}  // namespace
+} // namespace
 
 namespace hershey {
-float TextWidth(std::string_view str, float size) {
+float TextWidth (std::string_view str, float size) {
   float longest_line = 0;
-  size /= 25.0f;  // The actual coordinates are roughly in the range 0..25
+  size /= 25.0f; // The actual coordinates are roughly in the range 0..25
 
   float w = 0;
   for (char c : str) {
     if (c == '\n') {
-      longest_line = std::max(longest_line, w);
+      longest_line = std::max (longest_line, w);
       w = 0;
     }
-    if (c < 32 || c > 126) continue;
-    const HersheyGlyph& glyph = hershey_simplex[c - 32];
+    if (c < 32 || c > 126)
+      continue;
+    const HersheyGlyph &glyph = hershey_simplex[c - 32];
     w += size * glyph.width;
   }
-  return std::max(longest_line, w);
+  return std::max (longest_line, w);
 }
 
-void DrawText(std::string_view str, float tx, float ty, TextAlign align,
-              float size,
-              const std::function<void(bool do_line, float x, float y)>& draw) {
+void DrawText (std::string_view str, float tx, float ty, TextAlign align,
+               float size,
+               const std::function<void (bool do_line, float x, float y)> &draw) {
   float dx = 0;
-  if (align == TextAlign::kRight)dx = -TextWidth(str, size);
-  else if (align == TextAlign::kCenter)dx = -TextWidth(str, size) / 2;
-  size /= 25.0f;  // The actual coordinates are roughly in the range 0..25
+  if (align == TextAlign::kRight)
+    dx = -TextWidth (str, size);
+  else if (align == TextAlign::kCenter)
+    dx = -TextWidth (str, size) / 2;
+  size /= 25.0f; // The actual coordinates are roughly in the range 0..25
   float x = 0, y = 0;
   for (char c : str) {
     if (c == '\n') {
       y -= 30 * size;
       x = 0;
     }
-    if (c < 32 || c > 126) continue;
-    const HersheyGlyph& glyph = hershey_simplex[c - 32];
+    if (c < 32 || c > 126)
+      continue;
+    const HersheyGlyph &glyph = hershey_simplex[c - 32];
     bool pen_up = true;
     for (int op = 0; op < glyph.number_of_ops; ++op) {
-      const auto& coor = glyph.operations[op];
+      const auto &coor = glyph.operations[op];
       if (coor.x == -1 && coor.y == -1) {
         pen_up = true;
         continue;
       }
-      draw(!pen_up, tx + x + size * coor.x + dx, ty + y + size * coor.y);
+      draw (!pen_up, tx + x + size * coor.x + dx, ty + y + size * coor.y);
       pen_up = false;
     }
     x += size * glyph.width;
@@ -360,4 +364,4 @@ const HersheyGlyph hershey_simplex[] = {
 };
 /* *INDENT-ON* */
 /* clang-format on */
-}  // namespace
+} // namespace
diff --git a/src/glview/hershey.h b/src/glview/hershey.h
index d6a24c3d7..0d6145479 100644
--- a/src/glview/hershey.h
+++ b/src/glview/hershey.h
@@ -9,10 +9,12 @@
 namespace hershey {
 
 // Determine the width of the text if drawn with DrawText()
-float TextWidth(std::string_view str, float size);
+float TextWidth (std::string_view str, float size);
 
 // Horizontal alignment
-enum class TextAlign { kLeft, kCenter, kRight };
+enum class TextAlign { kLeft,
+                       kCenter,
+                       kRight };
 
 // Draw a text at position (tx,ty) with the given alignment and size,
 // output is sent to the 2D output 'draw()' function that receives.
@@ -20,7 +22,7 @@ enum class TextAlign { kLeft, kCenter, kRight };
 //   "x", "y"   - the position to moveto/lineto
 // The function makes it independent of any output device and easy to
 // adapt in any environment including 3D projection.
-void DrawText(std::string_view str, float tx, float ty, TextAlign align,
-              float size,
-              const std::function<void(bool pen_down, float x, float y)>& draw);
-}  // namespace hershey
+void DrawText (std::string_view str, float tx, float ty, TextAlign align,
+               float size,
+               const std::function<void (bool pen_down, float x, float y)> &draw);
+} // namespace hershey
diff --git a/src/glview/offscreen-old/OffscreenContextEGL.cc b/src/glview/offscreen-old/OffscreenContextEGL.cc
index 60b9602ff..539d3229c 100644
--- a/src/glview/offscreen-old/OffscreenContextEGL.cc
+++ b/src/glview/offscreen-old/OffscreenContextEGL.cc
@@ -46,32 +46,33 @@ namespace {
 class OffscreenContextEGL : public OffscreenContext
 {
 public:
-  OffscreenContextEGL(uint32_t width, uint32_t height) : OffscreenContext(width, height) {}
-  ~OffscreenContextEGL() {
+  OffscreenContextEGL (uint32_t width, uint32_t height)
+    : OffscreenContext (width, height) {}
+  ~OffscreenContextEGL () {
     if (this->display != nullptr) {
-      eglTerminate(this->display);
+      eglTerminate (this->display);
     }
   }
 
-  std::string getInfo() const override {
+  std::string getInfo () const override {
     if (!this->context) {
       return {"No GL Context initialized. No information to report\n"};
     }
 
     std::ostringstream result;
 
-    const char *vendor = eglQueryString(display, EGL_VENDOR);
-    const char *version = eglQueryString(display, EGL_VERSION);
+    const char *vendor = eglQueryString (display, EGL_VENDOR);
+    const char *version = eglQueryString (display, EGL_VERSION);
 
     result << "GL context creator: EGL (old)\n"
            << "EGL version: " << version << " (" << vendor << ")\n"
            << "PNG generator: lodepng\n";
 
-    return result.str();
+    return result.str ();
   }
 
-  bool makeCurrent() const override {
-    return eglMakeCurrent(this->display, this->surface, this->surface, this->context);
+  bool makeCurrent () const override {
+    return eglMakeCurrent (this->display, this->surface, this->surface, this->context);
   }
 
   EGLContext context{nullptr};
@@ -79,8 +80,7 @@ public:
   EGLSurface surface{EGL_NO_SURFACE};
 };
 
-static bool create_egl_dummy_context(OffscreenContextEGL& ctx)
-{
+static bool create_egl_dummy_context (OffscreenContextEGL &ctx) {
   static const EGLint configAttribs[] = {
     EGL_SURFACE_TYPE, EGL_PBUFFER_BIT,
     EGL_BLUE_SIZE, 8,
@@ -89,68 +89,69 @@ static bool create_egl_dummy_context(OffscreenContextEGL& ctx)
     EGL_ALPHA_SIZE, 8,
     EGL_DEPTH_SIZE, 24,
     EGL_CONFORMANT, EGL_OPENGL_BIT,
-    EGL_NONE
-  };
+    EGL_NONE};
 
   const EGLint pbufferAttribs[] = {
-    EGL_WIDTH, static_cast<EGLint>(ctx.width()),
-    EGL_HEIGHT, static_cast<EGLint>(ctx.height()),
+    EGL_WIDTH,
+    static_cast<EGLint> (ctx.width ()),
+    EGL_HEIGHT,
+    static_cast<EGLint> (ctx.height ()),
     EGL_NONE,
   };
 
-  PFNEGLQUERYDEVICESEXTPROC eglQueryDevicesEXT = (PFNEGLQUERYDEVICESEXTPROC) eglGetProcAddress("eglQueryDevicesEXT");
-  PFNEGLGETPLATFORMDISPLAYEXTPROC eglGetPlatformDisplayEXT = (PFNEGLGETPLATFORMDISPLAYEXTPROC) eglGetProcAddress("eglGetPlatformDisplayEXT");
+  PFNEGLQUERYDEVICESEXTPROC eglQueryDevicesEXT = (PFNEGLQUERYDEVICESEXTPROC)eglGetProcAddress ("eglQueryDevicesEXT");
+  PFNEGLGETPLATFORMDISPLAYEXTPROC eglGetPlatformDisplayEXT = (PFNEGLGETPLATFORMDISPLAYEXTPROC)eglGetProcAddress ("eglGetPlatformDisplayEXT");
   if (eglQueryDevicesEXT && eglGetPlatformDisplayEXT) {
     const int MAX_DEVICES = 10;
     EGLDeviceEXT eglDevs[MAX_DEVICES];
     EGLint numDevices = 0;
 
-    eglQueryDevicesEXT(MAX_DEVICES, eglDevs, &numDevices);
-    PRINTDB("Found %d EGL devices.", numDevices);
+    eglQueryDevicesEXT (MAX_DEVICES, eglDevs, &numDevices);
+    PRINTDB ("Found %d EGL devices.", numDevices);
     for (int idx = 0; idx < numDevices; idx++) {
-      EGLDisplay disp = eglGetPlatformDisplayEXT(EGL_PLATFORM_DEVICE_EXT, eglDevs[idx], nullptr);
+      EGLDisplay disp = eglGetPlatformDisplayEXT (EGL_PLATFORM_DEVICE_EXT, eglDevs[idx], nullptr);
       if (disp != EGL_NO_DISPLAY) {
         ctx.display = disp;
         break;
       }
     }
   } else {
-    PRINTD("Trying default EGL display...");
-    ctx.display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
+    PRINTD ("Trying default EGL display...");
+    ctx.display = eglGetDisplay (EGL_DEFAULT_DISPLAY);
   }
 
   if (ctx.display == EGL_NO_DISPLAY) {
-    PRINTD("No EGL display found.");
+    PRINTD ("No EGL display found.");
     return false;
   }
 
-  PFNEGLGETDISPLAYDRIVERNAMEPROC eglGetDisplayDriverName = (PFNEGLGETDISPLAYDRIVERNAMEPROC) eglGetProcAddress("eglGetDisplayDriverName");
+  PFNEGLGETDISPLAYDRIVERNAMEPROC eglGetDisplayDriverName = (PFNEGLGETDISPLAYDRIVERNAMEPROC)eglGetProcAddress ("eglGetDisplayDriverName");
   if (eglGetDisplayDriverName) {
-    const char *name = eglGetDisplayDriverName(ctx.display);
-    PRINTDB("Got EGL display with driver name '%s'", name);
+    const char *name = eglGetDisplayDriverName (ctx.display);
+    PRINTDB ("Got EGL display with driver name '%s'", name);
   }
 
   EGLint major, minor;
-  if (!eglInitialize(ctx.display, &major, &minor)) {
+  if (!eglInitialize (ctx.display, &major, &minor)) {
     std::cerr << "Unable to initialize EGL" << std::endl;
     return false;
   }
 
-  PRINTDB("EGL Version: %d.%d (%s)", major % minor % eglQueryString(ctx.display, EGL_VENDOR));
+  PRINTDB ("EGL Version: %d.%d (%s)", major % minor % eglQueryString (ctx.display, EGL_VENDOR));
 
   EGLint numConfigs;
   EGLConfig config;
-  if (!eglChooseConfig(ctx.display, configAttribs, &config, 1, &numConfigs)) {
-    std::cerr << "Failed to choose config (eglError: " << std::hex << eglGetError() << ")" << std::endl;
+  if (!eglChooseConfig (ctx.display, configAttribs, &config, 1, &numConfigs)) {
+    std::cerr << "Failed to choose config (eglError: " << std::hex << eglGetError () << ")" << std::endl;
     return false;
   }
-  if (!eglBindAPI(EGL_OPENGL_API)) {
+  if (!eglBindAPI (EGL_OPENGL_API)) {
     std::cerr << "Bind EGL_OPENGL_API failed!" << std::endl;
     return false;
   }
-  ctx.surface = eglCreatePbufferSurface(ctx.display, config, pbufferAttribs);
+  ctx.surface = eglCreatePbufferSurface (ctx.display, config, pbufferAttribs);
   if (ctx.surface == EGL_NO_SURFACE) {
-    std::cerr << "Unable to create EGL surface (eglError: " << eglGetError() << ")" << std::endl;
+    std::cerr << "Unable to create EGL surface (eglError: " << eglGetError () << ")" << std::endl;
     return false;
   }
 
@@ -158,31 +159,29 @@ static bool create_egl_dummy_context(OffscreenContextEGL& ctx)
     EGL_CONTEXT_MAJOR_VERSION, 2,
     EGL_CONTEXT_MINOR_VERSION, 0,
     EGL_CONTEXT_OPENGL_PROFILE_MASK, EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT,
-    EGL_NONE
-  };
-  ctx.context = eglCreateContext(ctx.display, config, EGL_NO_CONTEXT, ctxattr);
+    EGL_NONE};
+  ctx.context = eglCreateContext (ctx.display, config, EGL_NO_CONTEXT, ctxattr);
   if (ctx.context == EGL_NO_CONTEXT) {
-    std::cerr << "Unable to create EGL context (eglError: " << eglGetError() << ")" << std::endl;
+    std::cerr << "Unable to create EGL context (eglError: " << eglGetError () << ")" << std::endl;
     return false;
   }
 
   return true;
 }
 
-}  // namespace
+} // namespace
 
 namespace offscreen_old {
 
-std::shared_ptr<OffscreenContext> CreateOffscreenContextEGL(
+std::shared_ptr<OffscreenContext> CreateOffscreenContextEGL (
   uint32_t width, uint32_t height, uint32_t majorGLVersion,
-  uint32_t minorGLVersion, bool gles, bool compatibilityProfile)
-{
-  auto ctx = std::make_shared<OffscreenContextEGL>(width, height);
+  uint32_t minorGLVersion, bool gles, bool compatibilityProfile) {
+  auto ctx = std::make_shared<OffscreenContextEGL> (width, height);
 
-  if (!create_egl_dummy_context(*ctx)) {
+  if (!create_egl_dummy_context (*ctx)) {
     return nullptr;
   }
   return ctx;
 }
 
-}  // namespace offscreen_old
+} // namespace offscreen_old
diff --git a/src/glview/offscreen-old/OffscreenContextEGL.h b/src/glview/offscreen-old/OffscreenContextEGL.h
index 6eb5f60c3..6a8d3637b 100644
--- a/src/glview/offscreen-old/OffscreenContextEGL.h
+++ b/src/glview/offscreen-old/OffscreenContextEGL.h
@@ -7,8 +7,8 @@
 
 namespace offscreen_old {
 
-std::shared_ptr<OffscreenContext> CreateOffscreenContextEGL(
+std::shared_ptr<OffscreenContext> CreateOffscreenContextEGL (
   uint32_t width, uint32_t height, uint32_t majorGLVersion,
   uint32_t minorGLVersion, bool gles, bool compatibilityProfile);
 
-}  // namespace offscreen_old
+} // namespace offscreen_old
diff --git a/src/glview/offscreen-old/OffscreenContextGLX.cc b/src/glview/offscreen-old/OffscreenContextGLX.cc
index 08c74c22b..6c2a8674c 100644
--- a/src/glview/offscreen-old/OffscreenContextGLX.cc
+++ b/src/glview/offscreen-old/OffscreenContextGLX.cc
@@ -36,7 +36,6 @@
  */
 #include "glview/offscreen-old/OffscreenContextGLX.h"
 
-
 #include "glview/system-gl.h"
 #include <iostream>
 #include <cstdint>
@@ -56,14 +55,18 @@ namespace {
 class OffscreenContextGLX : public OffscreenContext
 {
 public:
-  OffscreenContextGLX(uint32_t width, uint32_t height) : OffscreenContext(width, height) {}
-  ~OffscreenContextGLX() {
-    if (this->xwindow) XDestroyWindow(this->xdisplay, this->xwindow);
-    if (this->openGLContext) glXDestroyContext(this->xdisplay, this->openGLContext);
-    if (this->xdisplay) XCloseDisplay(this->xdisplay);
+  OffscreenContextGLX (uint32_t width, uint32_t height)
+    : OffscreenContext (width, height) {}
+  ~OffscreenContextGLX () {
+    if (this->xwindow)
+      XDestroyWindow (this->xdisplay, this->xwindow);
+    if (this->openGLContext)
+      glXDestroyContext (this->xdisplay, this->openGLContext);
+    if (this->xdisplay)
+      XCloseDisplay (this->xdisplay);
   }
 
-  std::string getInfo() const override {
+  std::string getInfo () const override {
     if (!this->xdisplay) {
       return {"No GL Context initialized. No information to report\n"};
     }
@@ -71,17 +74,17 @@ public:
     std::ostringstream result;
 
     int major, minor;
-    glXQueryVersion(this->xdisplay, &major, &minor);
+    glXQueryVersion (this->xdisplay, &major, &minor);
 
     result << "GL context creator: GLX (old)\n"
            << "GLX version: " << major << "." << minor << "\n"
            << "PNG generator: lodepng\n";
 
-    return result.str();
+    return result.str ();
   }
 
-  bool makeCurrent() const override {
-    return glXMakeContextCurrent(this->xdisplay, this->xwindow, this->xwindow, this->openGLContext);
+  bool makeCurrent () const override {
+    return glXMakeContextCurrent (this->xdisplay, this->xwindow, this->xwindow, this->openGLContext);
   }
 
   GLXContext openGLContext{nullptr};
@@ -91,13 +94,12 @@ public:
 
 static XErrorHandler original_xlib_handler = nullptr;
 static auto XCreateWindow_failed = false;
-static int XCreateWindow_error(Display *dpy, XErrorEvent *event)
-{
+static int XCreateWindow_error (Display *dpy, XErrorEvent *event) {
   std::cerr << "XCreateWindow failed: XID: " << event->resourceid
-            << " request: " << static_cast<int>(event->request_code)
-            << " minor: " << static_cast<int>(event->minor_code) << "\n";
+            << " request: " << static_cast<int> (event->request_code)
+            << " minor: " << static_cast<int> (event->minor_code) << "\n";
   char description[1024];
-  XGetErrorText(dpy, event->error_code, description, 1023);
+  XGetErrorText (dpy, event->error_code, description, 1023);
   std::cerr << " error message: " << description << "\n";
   XCreateWindow_failed = true;
   return 0;
@@ -113,11 +115,10 @@ static int XCreateWindow_error(Display *dpy, XErrorEvent *event)
 
    This function will alter ctx.openGLContext and ctx.xwindow if successful
  */
-bool create_glx_dummy_window(OffscreenContextGLX& ctx)
-{
+bool create_glx_dummy_window (OffscreenContextGLX &ctx) {
   int attributes[] = {
     GLX_DRAWABLE_TYPE, GLX_WINDOW_BIT | GLX_PIXMAP_BIT | GLX_PBUFFER_BIT, //support all 3, for OpenCSG
-    GLX_RENDER_TYPE,   GLX_RGBA_BIT,
+    GLX_RENDER_TYPE, GLX_RGBA_BIT,
     GLX_RED_SIZE, 8,
     GLX_GREEN_SIZE, 8,
     GLX_BLUE_SIZE, 8,
@@ -125,62 +126,61 @@ bool create_glx_dummy_window(OffscreenContextGLX& ctx)
     GLX_DEPTH_SIZE, 24, // depth-stencil for OpenCSG
     GLX_STENCIL_SIZE, 8,
     GLX_DOUBLEBUFFER, true,
-    None
-  };
+    None};
 
   auto dpy = ctx.xdisplay;
 
   int num_returned = 0;
-  auto fbconfigs = glXChooseFBConfig(dpy, DefaultScreen(dpy), attributes, &num_returned);
+  auto fbconfigs = glXChooseFBConfig (dpy, DefaultScreen (dpy), attributes, &num_returned);
   if (fbconfigs == nullptr) {
     std::cerr << "glXChooseFBConfig failed\n";
     return false;
   }
 
-  auto visinfo = glXGetVisualFromFBConfig(dpy, fbconfigs[0]);
+  auto visinfo = glXGetVisualFromFBConfig (dpy, fbconfigs[0]);
   if (visinfo == nullptr) {
     std::cerr << "glXGetVisualFromFBConfig failed\n";
-    XFree(fbconfigs);
+    XFree (fbconfigs);
     return false;
   }
 
   // can't depend on xWin==nullptr at failure. use a custom Xlib error handler instead.
-  original_xlib_handler = XSetErrorHandler(XCreateWindow_error);
+  original_xlib_handler = XSetErrorHandler (XCreateWindow_error);
 
-  auto root = DefaultRootWindow(dpy);
+  auto root = DefaultRootWindow (dpy);
   XSetWindowAttributes xwin_attr;
-  auto width = ctx.width();
-  auto height = ctx.height();
+  auto width = ctx.width ();
+  auto height = ctx.height ();
   xwin_attr.background_pixmap = None;
   xwin_attr.background_pixel = 0;
   xwin_attr.border_pixel = 0;
-  xwin_attr.colormap = XCreateColormap(dpy, root, visinfo->visual, AllocNone);
+  xwin_attr.colormap = XCreateColormap (dpy, root, visinfo->visual, AllocNone);
   xwin_attr.event_mask = StructureNotifyMask | ExposureMask | KeyPressMask;
   unsigned long int mask = CWBackPixel | CWBorderPixel | CWColormap | CWEventMask;
 
-  auto xWin = XCreateWindow(dpy, root, 0, 0, width, height,
-                            0, visinfo->depth, InputOutput,
-                            visinfo->visual, mask, &xwin_attr);
+  auto xWin = XCreateWindow (dpy, root, 0, 0, width, height,
+                             0, visinfo->depth, InputOutput,
+                             visinfo->visual, mask, &xwin_attr);
 
   // Window xWin = XCreateSimpleWindow( dpy, DefaultRootWindow(dpy), 0,0,42,42, 0,0,0 );
 
-  XSync(dpy, false);
+  XSync (dpy, false);
   if (XCreateWindow_failed) {
-    XFree(visinfo);
-    XFree(fbconfigs);
+    XFree (visinfo);
+    XFree (fbconfigs);
     return false;
   }
-  XSetErrorHandler(original_xlib_handler);
+  XSetErrorHandler (original_xlib_handler);
 
   // Most programs would call XMapWindow here. But we don't, to keep the window hidden
   // XMapWindow( dpy, xWin );
 
-  auto context = glXCreateNewContext(dpy, fbconfigs[0], GLX_RGBA_TYPE, nullptr, true);
+  auto context = glXCreateNewContext (dpy, fbconfigs[0], GLX_RGBA_TYPE, nullptr, true);
   if (context == nullptr) {
     std::cerr << "glXCreateNewContext failed\n";
-    XDestroyWindow(dpy, xWin);
-    XFree(visinfo);
-    XFree(fbconfigs);
+    XDestroyWindow (dpy, xWin);
+    XFree (visinfo);
+    XFree (fbconfigs);
     return false;
   }
 
@@ -189,62 +189,60 @@ bool create_glx_dummy_window(OffscreenContextGLX& ctx)
   ctx.openGLContext = context;
   ctx.xwindow = xWin;
 
-  XFree(visinfo);
-  XFree(fbconfigs);
+  XFree (visinfo);
+  XFree (fbconfigs);
 
   return true;
 }
 
-
 #pragma GCC diagnostic ignored "-Waddress"
-bool create_glx_dummy_context(OffscreenContextGLX& ctx)
-{
+bool create_glx_dummy_context (OffscreenContextGLX &ctx) {
   // This will alter ctx.openGLContext and ctx.xdisplay and ctx.xwindow if successful
   int major;
   int minor;
   auto result = false;
 
-  ctx.xdisplay = XOpenDisplay(nullptr);
+  ctx.xdisplay = XOpenDisplay (nullptr);
   if (ctx.xdisplay == nullptr) {
     std::cerr << "Unable to open a connection to the X server.\n";
-    auto dpyenv = getenv("DISPLAY");
-    std::cerr << "DISPLAY=" << (dpyenv?dpyenv:"") << "\n";
+    auto dpyenv = getenv ("DISPLAY");
+    std::cerr << "DISPLAY=" << (dpyenv ? dpyenv : "") << "\n";
     return false;
   }
 
   // glxQueryVersion is not always reliable. Use it, but then
   // also check to see if GLX 1.3 functions exist
 
-  glXQueryVersion(ctx.xdisplay, &major, &minor);
+  glXQueryVersion (ctx.xdisplay, &major, &minor);
   if (major == 1 && minor <= 2 && glXGetVisualFromFBConfig == nullptr) {
     std::cerr << "Error: GLX version 1.3 functions missing. "
               << "Your GLX version: " << major << "." << minor << std::endl;
   } else {
-    result = create_glx_dummy_window(ctx);
+    result = create_glx_dummy_window (ctx);
   }
 
-  if (!result) XCloseDisplay(ctx.xdisplay);
+  if (!result)
+    XCloseDisplay (ctx.xdisplay);
   return result;
 }
 
-}  // namespace
+} // namespace
 
 namespace offscreen_old {
 
-std::shared_ptr<OffscreenContext> CreateOffscreenContextGLX(
+std::shared_ptr<OffscreenContext> CreateOffscreenContextGLX (
   uint32_t width, uint32_t height, uint32_t majorGLVersion,
-  uint32_t minorGLVersion, bool gles, bool compatibilityProfile)
-{
-  auto ctx = std::make_shared<OffscreenContextGLX>(width, height);
+  uint32_t minorGLVersion, bool gles, bool compatibilityProfile) {
+  auto ctx = std::make_shared<OffscreenContextGLX> (width, height);
 
   // before an FBO can be setup, a GLX context must be created
   // this call alters ctx->xDisplay and ctx->openGLContext
   // and ctx->xwindow if successful
-  if (!create_glx_dummy_context(*ctx)) {
+  if (!create_glx_dummy_context (*ctx)) {
     return nullptr;
   }
 
   return ctx;
 }
 
-}  // namespace offscreen_old
+} // namespace offscreen_old
diff --git a/src/glview/offscreen-old/OffscreenContextGLX.h b/src/glview/offscreen-old/OffscreenContextGLX.h
index ed36b43a0..a5f51081a 100644
--- a/src/glview/offscreen-old/OffscreenContextGLX.h
+++ b/src/glview/offscreen-old/OffscreenContextGLX.h
@@ -7,8 +7,8 @@
 
 namespace offscreen_old {
 
-std::shared_ptr<OffscreenContext> CreateOffscreenContextGLX(
+std::shared_ptr<OffscreenContext> CreateOffscreenContextGLX (
   uint32_t width, uint32_t height, uint32_t majorGLVersion,
   uint32_t minorGLVersion, bool gles, bool compatibilityProfile);
 
-}  // namespace offscreen_old
+} // namespace offscreen_old
diff --git a/src/glview/offscreen-old/OffscreenContextNSOpenGL.h b/src/glview/offscreen-old/OffscreenContextNSOpenGL.h
index bb4d985ba..f18f0d529 100644
--- a/src/glview/offscreen-old/OffscreenContextNSOpenGL.h
+++ b/src/glview/offscreen-old/OffscreenContextNSOpenGL.h
@@ -7,8 +7,8 @@
 
 namespace offscreen_old {
 
-std::shared_ptr<OffscreenContext> CreateOffscreenContextNSOpenGL(
+std::shared_ptr<OffscreenContext> CreateOffscreenContextNSOpenGL (
   uint32_t width, uint32_t height, uint32_t majorGLVersion,
   uint32_t minorGLVersion);
 
-}  // namespace offscreen_old
+} // namespace offscreen_old
diff --git a/src/glview/offscreen-old/OffscreenContextWGL.cc b/src/glview/offscreen-old/OffscreenContextWGL.cc
index 7111b0757..296aca608 100644
--- a/src/glview/offscreen-old/OffscreenContextWGL.cc
+++ b/src/glview/offscreen-old/OffscreenContextWGL.cc
@@ -24,30 +24,30 @@
 #include "glview/system-gl.h"
 #include <GL/gl.h> // must be included after glew.h
 
-
 namespace {
 
 class OffscreenContextWGL : public OffscreenContext
 {
 public:
-  OffscreenContextWGL(uint32_t width, uint32_t height) : OffscreenContext(width, height) {}
-  ~OffscreenContextWGL() {
-    wglMakeCurrent(nullptr, nullptr);
-    wglDeleteContext(this->openGLContext);
-    ReleaseDC(this->window, this->dev_context);
+  OffscreenContextWGL (uint32_t width, uint32_t height)
+    : OffscreenContext (width, height) {}
+  ~OffscreenContextWGL () {
+    wglMakeCurrent (nullptr, nullptr);
+    wglDeleteContext (this->openGLContext);
+    ReleaseDC (this->window, this->dev_context);
   }
 
-  std::string getInfo() const override {
+  std::string getInfo () const override {
     std::stringstream result;
     // should probably get some info from WGL context here?
     result << "GL context creator: WGL (old)\n"
            << "PNG generator: lodepng\n";
 
-    return result.str();
+    return result.str ();
   }
 
-  bool makeCurrent() const override {
-    return wglMakeCurrent(this->dev_context, this->openGLContext);
+  bool makeCurrent () const override {
+    return wglMakeCurrent (this->dev_context, this->openGLContext);
   }
 
   HWND window{nullptr};
@@ -55,30 +55,28 @@ public:
   HGLRC openGLContext{nullptr};
 };
 
-LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam)
-{
-  return DefWindowProc(hwnd, message, wparam, lparam);
+LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam) {
+  return DefWindowProc (hwnd, message, wparam, lparam);
 }
 
-bool create_wgl_dummy_context(OffscreenContextWGL& ctx)
-{
+bool create_wgl_dummy_context (OffscreenContextWGL &ctx) {
   // this function alters ctx->window and ctx->openGLContext
   //  and ctx->dev_context if successful
 
   // create window
   LPCWSTR lpClassName = L"OpenSCAD";
 
-  HINSTANCE inst = GetModuleHandleW(0);
+  HINSTANCE inst = GetModuleHandleW (0);
   WNDCLASSW wc;
-  ZeroMemory(&wc, sizeof(wc) );
+  ZeroMemory (&wc, sizeof (wc));
   wc.style = CS_OWNDC;
   wc.lpfnWndProc = WndProc;
   wc.hInstance = inst;
   wc.lpszClassName = lpClassName;
-  ATOM class_atom = RegisterClassW(&wc);
+  ATOM class_atom = RegisterClassW (&wc);
 
   if (class_atom == 0) {
-    const DWORD last_error = GetLastError();
+    const DWORD last_error = GetLastError ();
     if (last_error != ERROR_CLASS_ALREADY_EXISTS) {
       std::cerr << "MS GDI - RegisterClass failed\n";
       std::cerr << "last-error code: " << last_error << "\n";
@@ -90,19 +88,19 @@ bool create_wgl_dummy_context(OffscreenContextWGL& ctx)
   DWORD dwStyle = WS_CAPTION | WS_POPUPWINDOW; // | WS_VISIBLE
   int x = 0;
   int y = 0;
-  int nWidth = ctx.width();
-  int nHeight = ctx.height();
+  int nWidth = ctx.width ();
+  int nHeight = ctx.height ();
   HWND hWndParent = nullptr;
   HMENU hMenu = nullptr;
   HINSTANCE hInstance = inst;
   LPVOID lpParam = nullptr;
 
-  HWND window = CreateWindowW(lpClassName, lpWindowName, dwStyle, x, y,
-                              nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
+  HWND window = CreateWindowW (lpClassName, lpWindowName, dwStyle, x, y,
+                               nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
 
   if (window == nullptr) {
     std::cerr << "MS GDI - CreateWindow failed\n";
-    std::cerr << "last-error code: " << GetLastError() << "\n";
+    std::cerr << "last-error code: " << GetLastError () << "\n";
     return false;
   }
 
@@ -110,15 +108,15 @@ bool create_wgl_dummy_context(OffscreenContextWGL& ctx)
 
   PIXELFORMATDESCRIPTOR pixformat;
   int chosenformat;
-  HDC dev_context = GetDC(window);
+  HDC dev_context = GetDC (window);
   if (dev_context == nullptr) {
     std::cerr << "MS GDI - GetDC failed\n";
-    std::cerr << "last-error code: " << GetLastError() << "\n";
+    std::cerr << "last-error code: " << GetLastError () << "\n";
     return false;
   }
 
-  ZeroMemory(&pixformat, sizeof(pixformat) );
-  pixformat.nSize = sizeof(pixformat);
+  ZeroMemory (&pixformat, sizeof (pixformat));
+  pixformat.nSize = sizeof (pixformat);
   pixformat.nVersion = 1;
   pixformat.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;
   pixformat.iPixelType = PFD_TYPE_RGBA;
@@ -129,25 +127,25 @@ bool create_wgl_dummy_context(OffscreenContextWGL& ctx)
   pixformat.cDepthBits = 24;
   pixformat.cStencilBits = 8;
 
-  chosenformat = ChoosePixelFormat(dev_context, &pixformat);
+  chosenformat = ChoosePixelFormat (dev_context, &pixformat);
   if (chosenformat == 0) {
     std::cerr << "MS GDI - ChoosePixelFormat failed\n";
-    std::cerr << "last-error code: " << GetLastError() << "\n";
+    std::cerr << "last-error code: " << GetLastError () << "\n";
     return false;
   }
 
-  bool spfok = SetPixelFormat(dev_context, chosenformat, &pixformat);
+  bool spfok = SetPixelFormat (dev_context, chosenformat, &pixformat);
   if (!spfok) {
     std::cerr << "MS GDI - SetPixelFormat failed\n";
-    std::cerr << "last-error code: " << GetLastError() << "\n";
+    std::cerr << "last-error code: " << GetLastError () << "\n";
     return false;
   }
 
-  HGLRC gl_render_context = wglCreateContext(dev_context);
+  HGLRC gl_render_context = wglCreateContext (dev_context);
   if (gl_render_context == nullptr) {
     std::cerr << "MS WGL - wglCreateContext failed\n";
-    std::cerr << "last-error code: " << GetLastError() << "\n";
-    ReleaseDC(ctx.window, ctx.dev_context);
+    std::cerr << "last-error code: " << GetLastError () << "\n";
+    ReleaseDC (ctx.window, ctx.dev_context);
     return false;
   }
 
@@ -158,24 +156,23 @@ bool create_wgl_dummy_context(OffscreenContextWGL& ctx)
   return true;
 }
 
-}  // namespace
+} // namespace
 
 namespace offscreen_old {
 
-std::shared_ptr<OffscreenContext> CreateOffscreenContextWGL(
+std::shared_ptr<OffscreenContext> CreateOffscreenContextWGL (
   uint32_t width, uint32_t height, uint32_t majorGLVersion,
-  uint32_t minorGLVersion, bool compatibilityProfile)
-{
-  auto ctx = std::make_shared<OffscreenContextWGL>(width, height);
+  uint32_t minorGLVersion, bool compatibilityProfile) {
+  auto ctx = std::make_shared<OffscreenContextWGL> (width, height);
 
   // Before an FBO can be setup, a WGL context must be created.
   // This call alters ctx->window and ctx->openGLContext
   //  and ctx->dev_context if successful
-  if (!create_wgl_dummy_context(*ctx)) {
+  if (!create_wgl_dummy_context (*ctx)) {
     return nullptr;
   }
 
   return ctx;
 }
 
-}  // namespace offscreen_old
+} // namespace offscreen_old
diff --git a/src/glview/offscreen-old/OffscreenContextWGL.h b/src/glview/offscreen-old/OffscreenContextWGL.h
index 1b32a31b4..c66afadb4 100644
--- a/src/glview/offscreen-old/OffscreenContextWGL.h
+++ b/src/glview/offscreen-old/OffscreenContextWGL.h
@@ -7,8 +7,8 @@
 
 namespace offscreen_old {
 
-std::shared_ptr<OffscreenContext> CreateOffscreenContextWGL(
+std::shared_ptr<OffscreenContext> CreateOffscreenContextWGL (
   uint32_t width, uint32_t height, uint32_t majorGLVersion,
   uint32_t minorGLVersion, bool compatibilityProfile);
 
-}  // namespace offscreen_old
+} // namespace offscreen_old
diff --git a/src/glview/preview/CSGTreeNormalizer.cc b/src/glview/preview/CSGTreeNormalizer.cc
index a7dddaea0..bbad9994f 100644
--- a/src/glview/preview/CSGTreeNormalizer.cc
+++ b/src/glview/preview/CSGTreeNormalizer.cc
@@ -23,13 +23,12 @@ static bool validate_tree(const std::shared_ptr<CSGNode>& node)
 /*!
    NB! for e.g. empty intersections, this can normalize a tree to nothing and return nullptr.
  */
-std::shared_ptr<CSGNode> CSGTreeNormalizer::normalize(const std::shared_ptr<CSGNode>& root)
-{
+std::shared_ptr<CSGNode> CSGTreeNormalizer::normalize (const std::shared_ptr<CSGNode> &root) {
   this->aborted = false;
   this->nodecount = 0;
   std::shared_ptr<CSGNode> temp = root;
-  temp = normalizePass(temp);
-  this->rootnode.reset();
+  temp = normalizePass (temp);
+  this->rootnode.reset ();
   return temp;
 }
 
@@ -39,33 +38,33 @@ std::shared_ptr<CSGNode> CSGTreeNormalizer::normalize(const std::shared_ptr<CSGN
    This will search for nullptr children an recursively repair the corresponding
    subtree.
  */
-std::shared_ptr<CSGNode> CSGTreeNormalizer::cleanup_term(std::shared_ptr<CSGNode>& t)
-{
-  if (std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation>(t)) {
-    if (op->left()) op->left() = cleanup_term(op->left());
-    if (op->right()) op->right() = cleanup_term(op->right());
-    return collapse_null_terms(op);
+std::shared_ptr<CSGNode> CSGTreeNormalizer::cleanup_term (std::shared_ptr<CSGNode> &t) {
+  if (std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation> (t)) {
+    if (op->left ())
+      op->left () = cleanup_term (op->left ());
+    if (op->right ())
+      op->right () = cleanup_term (op->right ());
+    return collapse_null_terms (op);
   }
   return t;
 }
 
-static bool isUnion(const std::shared_ptr<CSGNode>& node) {
-  std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation>(node);
-  return op && op->getType() == OpenSCADOperator::UNION;
+static bool isUnion (const std::shared_ptr<CSGNode> &node) {
+  std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation> (node);
+  return op && op->getType () == OpenSCADOperator::UNION;
 }
 
-static bool hasRightNonLeaf(const std::shared_ptr<CSGNode>& node) {
-  std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation>(node);
-  return op->right() && (std::dynamic_pointer_cast<CSGLeaf>(op->right()) == nullptr);
+static bool hasRightNonLeaf (const std::shared_ptr<CSGNode> &node) {
+  std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation> (node);
+  return op->right () && (std::dynamic_pointer_cast<CSGLeaf> (op->right ()) == nullptr);
 }
 
-static bool hasLeftUnion(const std::shared_ptr<CSGNode>& node) {
-  std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation>(node);
-  return op && isUnion(op->left());
+static bool hasLeftUnion (const std::shared_ptr<CSGNode> &node) {
+  std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation> (node);
+  return op && isUnion (op->left ());
 }
 
-std::shared_ptr<CSGNode> CSGTreeNormalizer::normalizePass(std::shared_ptr<CSGNode> node)
-{
+std::shared_ptr<CSGNode> CSGTreeNormalizer::normalizePass (std::shared_ptr<CSGNode> node) {
   // This function implements the CSG normalization
   // Reference:
   // Goldfeather, J., Molnar, S., Turk, G., and Fuchs, H. Near
@@ -86,166 +85,173 @@ std::shared_ptr<CSGNode> CSGTreeNormalizer::normalizePass(std::shared_ptr<CSGNod
   std::stack<stackframe_t> callstack;
 
 entrypoint:
-  if (std::dynamic_pointer_cast<CSGLeaf>(node)) goto return_node;
+  if (std::dynamic_pointer_cast<CSGLeaf> (node))
+    goto return_node;
   do {
-    while (node && match_and_replace(node)) {
+    while (node && match_and_replace (node)) {
     }
     this->nodecount++;
     if (nodecount > this->limit) {
-      LOG(message_group::Warning, "Normalized tree is growing past %1$d elements. Aborting normalization.\n", this->limit);
+      LOG (message_group::Warning, "Normalized tree is growing past %1$d elements. Aborting normalization.\n", this->limit);
       this->aborted = true;
       return {};
     }
-    if (!node || std::dynamic_pointer_cast<CSGLeaf>(node)) goto return_node;
+    if (!node || std::dynamic_pointer_cast<CSGLeaf> (node))
+      goto return_node;
     goto normalize_left_if_op;
-cont_left:;
-  } while (!this->aborted && !isUnion(node) && (hasRightNonLeaf(node) || hasLeftUnion(node)));
+  cont_left:;
+  } while (!this->aborted && !isUnion (node) && (hasRightNonLeaf (node) || hasLeftUnion (node)));
 
   if (!this->aborted) {
     goto normalize_right;
-cont_right:;
+  cont_right:;
   }
 
   // FIXME: Do we need to take into account any transformation of item here?
-  node = collapse_null_terms(node);
+  node = collapse_null_terms (node);
 
   if (this->aborted) {
-    if (node) node = cleanup_term(node);
+    if (node)
+      node = cleanup_term (node);
   }
 
 return_node:
-  if (callstack.empty()) {
+  if (callstack.empty ()) {
     return node;
   } else {
-    stackframe_t frame = callstack.top();
-    callstack.pop();
+    stackframe_t frame = callstack.top ();
+    callstack.pop ();
     if (frame.second) { // came from a left call
-      frame.first->left() = node;
+      frame.first->left () = node;
       node = frame.first;
       goto cont_left;
     } else { // came from a right call
-      frame.first->right() = node;
+      frame.first->right () = node;
       node = frame.first;
       goto cont_right;
     }
   }
 normalize_left_if_op:
-  if (std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation>(node)) {
-    callstack.emplace(op, true);
-    node = op->left();
+  if (std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation> (node)) {
+    callstack.emplace (op, true);
+    node = op->left ();
     goto entrypoint;
   }
   goto cont_left;
 normalize_right:
-  std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation>(node);
-  assert(op);
-  callstack.emplace(op, false);
-  node = op->right();
+  std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation> (node);
+  assert (op);
+  callstack.emplace (op, false);
+  node = op->right ();
   goto entrypoint;
 }
 
-std::shared_ptr<CSGNode> CSGTreeNormalizer::collapse_null_terms(const std::shared_ptr<CSGNode>& node)
-{
-  std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation>(node);
+std::shared_ptr<CSGNode> CSGTreeNormalizer::collapse_null_terms (const std::shared_ptr<CSGNode> &node) {
+  std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation> (node);
   if (op) {
-    if (!op->right()) {
+    if (!op->right ()) {
       this->nodecount--;
-      if (op->getType() == OpenSCADOperator::UNION || op->getType() == OpenSCADOperator::DIFFERENCE) return op->left();
-      else return op->right();
+      if (op->getType () == OpenSCADOperator::UNION || op->getType () == OpenSCADOperator::DIFFERENCE)
+        return op->left ();
+      else
+        return op->right ();
     }
-    if (!op->left()) {
+    if (!op->left ()) {
       this->nodecount--;
-      if (op->getType() == OpenSCADOperator::UNION) return op->right();
-      else return op->left();
+      if (op->getType () == OpenSCADOperator::UNION)
+        return op->right ();
+      else
+        return op->left ();
     }
   }
   return node;
 }
 
-bool CSGTreeNormalizer::match_and_replace(std::shared_ptr<CSGNode>& node)
-{
-  std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation>(node);
-  if (!op) return false;
-  if (op->getType() == OpenSCADOperator::UNION) return false;
+bool CSGTreeNormalizer::match_and_replace (std::shared_ptr<CSGNode> &node) {
+  std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation> (node);
+  if (!op)
+    return false;
+  if (op->getType () == OpenSCADOperator::UNION)
+    return false;
 
   // Part A: The 'x . (y . z)' expressions
 
-  std::shared_ptr<CSGOperation> rightop = std::dynamic_pointer_cast<CSGOperation>(op->right());
+  std::shared_ptr<CSGOperation> rightop = std::dynamic_pointer_cast<CSGOperation> (op->right ());
   if (rightop) {
-    std::shared_ptr<CSGNode> x = op->left();
-    std::shared_ptr<CSGNode> y = rightop->left();
-    std::shared_ptr<CSGNode> z = rightop->right();
+    std::shared_ptr<CSGNode> x = op->left ();
+    std::shared_ptr<CSGNode> y = rightop->left ();
+    std::shared_ptr<CSGNode> z = rightop->right ();
 
     // 1.  x - (y + z) -> (x - y) - z
-    if (op->getType() == OpenSCADOperator::DIFFERENCE && rightop->getType() == OpenSCADOperator::UNION) {
-      node = CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE,
-                                         CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, x, y),
-                                         z);
+    if (op->getType () == OpenSCADOperator::DIFFERENCE && rightop->getType () == OpenSCADOperator::UNION) {
+      node = CSGOperation::createCSGNode (OpenSCADOperator::DIFFERENCE,
+                                          CSGOperation::createCSGNode (OpenSCADOperator::DIFFERENCE, x, y),
+                                          z);
       return true;
     }
     // 2.  x * (y + z) -> (x * y) + (x * z)
-    else if (op->getType() == OpenSCADOperator::INTERSECTION && rightop->getType() == OpenSCADOperator::UNION) {
-      node = CSGOperation::createCSGNode(OpenSCADOperator::UNION,
-                                         CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, y),
-                                         CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, z));
+    else if (op->getType () == OpenSCADOperator::INTERSECTION && rightop->getType () == OpenSCADOperator::UNION) {
+      node = CSGOperation::createCSGNode (OpenSCADOperator::UNION,
+                                          CSGOperation::createCSGNode (OpenSCADOperator::INTERSECTION, x, y),
+                                          CSGOperation::createCSGNode (OpenSCADOperator::INTERSECTION, x, z));
       return true;
     }
     // 3.  x - (y * z) -> (x - y) + (x - z)
-    else if (op->getType() == OpenSCADOperator::DIFFERENCE && rightop->getType() == OpenSCADOperator::INTERSECTION) {
-      node = CSGOperation::createCSGNode(OpenSCADOperator::UNION,
-                                         CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, x, y),
-                                         CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, x, z));
+    else if (op->getType () == OpenSCADOperator::DIFFERENCE && rightop->getType () == OpenSCADOperator::INTERSECTION) {
+      node = CSGOperation::createCSGNode (OpenSCADOperator::UNION,
+                                          CSGOperation::createCSGNode (OpenSCADOperator::DIFFERENCE, x, y),
+                                          CSGOperation::createCSGNode (OpenSCADOperator::DIFFERENCE, x, z));
       return true;
     }
     // 4.  x * (y * z) -> (x * y) * z
-    else if (op->getType() == OpenSCADOperator::INTERSECTION && rightop->getType() == OpenSCADOperator::INTERSECTION) {
-      node = CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION,
-                                         CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, y),
-                                         z);
+    else if (op->getType () == OpenSCADOperator::INTERSECTION && rightop->getType () == OpenSCADOperator::INTERSECTION) {
+      node = CSGOperation::createCSGNode (OpenSCADOperator::INTERSECTION,
+                                          CSGOperation::createCSGNode (OpenSCADOperator::INTERSECTION, x, y),
+                                          z);
       return true;
     }
     // 5.  x - (y - z) -> (x - y) + (x * z)
-    else if (op->getType() == OpenSCADOperator::DIFFERENCE && rightop->getType() == OpenSCADOperator::DIFFERENCE) {
-      node = CSGOperation::createCSGNode(OpenSCADOperator::UNION,
-                                         CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, x, y),
-                                         CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, z));
+    else if (op->getType () == OpenSCADOperator::DIFFERENCE && rightop->getType () == OpenSCADOperator::DIFFERENCE) {
+      node = CSGOperation::createCSGNode (OpenSCADOperator::UNION,
+                                          CSGOperation::createCSGNode (OpenSCADOperator::DIFFERENCE, x, y),
+                                          CSGOperation::createCSGNode (OpenSCADOperator::INTERSECTION, x, z));
       return true;
     }
     // 6.  x * (y - z) -> (x * y) - z
-    else if (op->getType() == OpenSCADOperator::INTERSECTION && rightop->getType() == OpenSCADOperator::DIFFERENCE) {
-      node = CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE,
-                                         CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, y),
-                                         z);
+    else if (op->getType () == OpenSCADOperator::INTERSECTION && rightop->getType () == OpenSCADOperator::DIFFERENCE) {
+      node = CSGOperation::createCSGNode (OpenSCADOperator::DIFFERENCE,
+                                          CSGOperation::createCSGNode (OpenSCADOperator::INTERSECTION, x, y),
+                                          z);
       return true;
     }
   }
 
-  std::shared_ptr<CSGOperation> leftop = std::dynamic_pointer_cast<CSGOperation>(op->left());
+  std::shared_ptr<CSGOperation> leftop = std::dynamic_pointer_cast<CSGOperation> (op->left ());
   if (leftop) {
     // Part B: The '(x . y) . z' expressions
-    std::shared_ptr<CSGNode> x = leftop->left();
-    std::shared_ptr<CSGNode> y = leftop->right();
-    std::shared_ptr<CSGNode> z = op->right();
+    std::shared_ptr<CSGNode> x = leftop->left ();
+    std::shared_ptr<CSGNode> y = leftop->right ();
+    std::shared_ptr<CSGNode> z = op->right ();
 
     // 7. (x - y) * z  -> (x * z) - y
-    if (leftop->getType() == OpenSCADOperator::DIFFERENCE && op->getType() == OpenSCADOperator::INTERSECTION) {
-      node = CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE,
-                                         CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, z),
-                                         y);
+    if (leftop->getType () == OpenSCADOperator::DIFFERENCE && op->getType () == OpenSCADOperator::INTERSECTION) {
+      node = CSGOperation::createCSGNode (OpenSCADOperator::DIFFERENCE,
+                                          CSGOperation::createCSGNode (OpenSCADOperator::INTERSECTION, x, z),
+                                          y);
       return true;
     }
     // 8. (x + y) - z  -> (x - z) + (y - z)
-    else if (leftop->getType() == OpenSCADOperator::UNION && op->getType() == OpenSCADOperator::DIFFERENCE) {
-      node = CSGOperation::createCSGNode(OpenSCADOperator::UNION,
-                                         CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, x, z),
-                                         CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, y, z));
+    else if (leftop->getType () == OpenSCADOperator::UNION && op->getType () == OpenSCADOperator::DIFFERENCE) {
+      node = CSGOperation::createCSGNode (OpenSCADOperator::UNION,
+                                          CSGOperation::createCSGNode (OpenSCADOperator::DIFFERENCE, x, z),
+                                          CSGOperation::createCSGNode (OpenSCADOperator::DIFFERENCE, y, z));
       return true;
     }
     // 9. (x + y) * z  -> (x * z) + (y * z)
-    else if (leftop->getType() == OpenSCADOperator::UNION && op->getType() == OpenSCADOperator::INTERSECTION) {
-      node = CSGOperation::createCSGNode(OpenSCADOperator::UNION,
-                                         CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, z),
-                                         CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, y, z));
+    else if (leftop->getType () == OpenSCADOperator::UNION && op->getType () == OpenSCADOperator::INTERSECTION) {
+      node = CSGOperation::createCSGNode (OpenSCADOperator::UNION,
+                                          CSGOperation::createCSGNode (OpenSCADOperator::INTERSECTION, x, z),
+                                          CSGOperation::createCSGNode (OpenSCADOperator::INTERSECTION, y, z));
       return true;
     }
   }
@@ -253,10 +259,9 @@ bool CSGTreeNormalizer::match_and_replace(std::shared_ptr<CSGNode>& node)
 }
 
 // Counts all non-leaf nodes
-unsigned int CSGTreeNormalizer::count(const std::shared_ptr<CSGNode>& node) const
-{
-  if (std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation>(node)) {
-    return 1 + count(op->left()) + count(op->right());
+unsigned int CSGTreeNormalizer::count (const std::shared_ptr<CSGNode> &node) const {
+  if (std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation> (node)) {
+    return 1 + count (op->left ()) + count (op->right ());
   }
   return 0;
 }
diff --git a/src/glview/preview/CSGTreeNormalizer.h b/src/glview/preview/CSGTreeNormalizer.h
index 7fd02b5d1..f18abab77 100644
--- a/src/glview/preview/CSGTreeNormalizer.h
+++ b/src/glview/preview/CSGTreeNormalizer.h
@@ -6,16 +6,17 @@
 class CSGTreeNormalizer
 {
 public:
-  CSGTreeNormalizer(size_t limit) : limit(limit) {}
+  CSGTreeNormalizer (size_t limit)
+    : limit (limit) {}
 
-  std::shared_ptr<class CSGNode> normalize(const std::shared_ptr<CSGNode>& term);
+  std::shared_ptr<class CSGNode> normalize (const std::shared_ptr<CSGNode> &term);
 
 private:
-  std::shared_ptr<CSGNode> normalizePass(std::shared_ptr<CSGNode> term);
-  bool match_and_replace(std::shared_ptr<class CSGNode>& term);
-  std::shared_ptr<CSGNode> collapse_null_terms(const std::shared_ptr<CSGNode>& term);
-  std::shared_ptr<CSGNode> cleanup_term(std::shared_ptr<CSGNode>& t);
-  [[nodiscard]] unsigned int count(const std::shared_ptr<CSGNode>& term) const;
+  std::shared_ptr<CSGNode> normalizePass (std::shared_ptr<CSGNode> term);
+  bool match_and_replace (std::shared_ptr<class CSGNode> &term);
+  std::shared_ptr<CSGNode> collapse_null_terms (const std::shared_ptr<CSGNode> &term);
+  std::shared_ptr<CSGNode> cleanup_term (std::shared_ptr<CSGNode> &t);
+  [[nodiscard]] unsigned int count (const std::shared_ptr<CSGNode> &term) const;
 
   bool aborted{false};
   size_t limit;
diff --git a/src/glview/preview/OpenCSGRenderer.cc b/src/glview/preview/OpenCSGRenderer.cc
index a211c28e1..39970a0e8 100644
--- a/src/glview/preview/OpenCSGRenderer.cc
+++ b/src/glview/preview/OpenCSGRenderer.cc
@@ -46,15 +46,16 @@ namespace {
 class OpenCSGVBOPrim : public OpenCSG::Primitive
 {
 public:
-  OpenCSGVBOPrim(OpenCSG::Operation operation, unsigned int convexity,
-                 std::unique_ptr<VertexState> vertex_state)
-    : OpenCSG::Primitive(operation, convexity),
-    vertex_state(std::move(vertex_state)) {}
-  void render() override {
+  OpenCSGVBOPrim (OpenCSG::Operation operation, unsigned int convexity,
+                  std::unique_ptr<VertexState> vertex_state)
+    : OpenCSG::Primitive (operation, convexity)
+    , vertex_state (std::move (vertex_state)) {}
+  void render () override {
     if (vertex_state != nullptr) {
-      vertex_state->draw();
+      vertex_state->draw ();
     } else {
-      if (OpenSCAD::debug != "") PRINTD("OpenCSGVBOPrim vertex_state was null");
+      if (OpenSCAD::debug != "")
+        PRINTD ("OpenCSGVBOPrim vertex_state was null");
     }
   }
 
@@ -65,105 +66,106 @@ private:
 // Primitive for drawing using OpenCSG
 // Makes a copy of the given VertexState enabling just unlit/uncolored vertex
 // rendering
-OpenCSGVBOPrim *createVBOPrimitive(
-  const std::shared_ptr<OpenCSGVertexState>& vertex_state,
+OpenCSGVBOPrim *createVBOPrimitive (
+  const std::shared_ptr<OpenCSGVertexState> &vertex_state,
   const OpenCSG::Operation operation, const unsigned int convexity) {
-  std::unique_ptr<VertexState> opencsg_vs = std::make_unique<VertexState>(
-    vertex_state->drawMode(), vertex_state->drawSize(),
-    vertex_state->drawType(), vertex_state->drawOffset(),
-    vertex_state->elementOffset(), vertex_state->verticesVBO(),
-    vertex_state->elementsVBO());
+  std::unique_ptr<VertexState> opencsg_vs = std::make_unique<VertexState> (
+    vertex_state->drawMode (), vertex_state->drawSize (),
+    vertex_state->drawType (), vertex_state->drawOffset (),
+    vertex_state->elementOffset (), vertex_state->verticesVBO (),
+    vertex_state->elementsVBO ());
   // First two glBegin entries are the vertex position calls
-  opencsg_vs->glBegin().insert(opencsg_vs->glBegin().begin(),
-                               vertex_state->glBegin().begin(),
-                               vertex_state->glBegin().begin() + 2);
+  opencsg_vs->glBegin ().insert (opencsg_vs->glBegin ().begin (),
+                                 vertex_state->glBegin ().begin (),
+                                 vertex_state->glBegin ().begin () + 2);
   // First glEnd entry is the disable vertex position call
-  opencsg_vs->glEnd().insert(opencsg_vs->glEnd().begin(),
-                             vertex_state->glEnd().begin(),
-                             vertex_state->glEnd().begin() + 1);
+  opencsg_vs->glEnd ().insert (opencsg_vs->glEnd ().begin (),
+                               vertex_state->glEnd ().begin (),
+                               vertex_state->glEnd ().begin () + 1);
 
-  return new OpenCSGVBOPrim(operation, convexity, std::move(opencsg_vs));
+  return new OpenCSGVBOPrim (operation, convexity, std::move (opencsg_vs));
 }
 
-}  // namespace
+} // namespace
 
 #endif // ENABLE_OPENCSG
 
-OpenCSGRenderer::OpenCSGRenderer(
+OpenCSGRenderer::OpenCSGRenderer (
   std::shared_ptr<CSGProducts> root_products,
   std::shared_ptr<CSGProducts> highlights_products,
   std::shared_ptr<CSGProducts> background_products)
-  : root_products_(std::move(root_products)),
-  highlights_products_(std::move(highlights_products)),
-  background_products_(std::move(background_products)) {
-  opencsg_vertex_shader_code_ = ShaderUtils::loadShaderSource("OpenCSG.vert");
+  : root_products_ (std::move (root_products))
+  , highlights_products_ (std::move (highlights_products))
+  , background_products_ (std::move (background_products)) {
+  opencsg_vertex_shader_code_ = ShaderUtils::loadShaderSource ("OpenCSG.vert");
 }
 
-void OpenCSGRenderer::prepare(const ShaderUtils::ShaderInfo *shaderinfo) {
-  if (vertex_state_containers_.empty()) {
+void OpenCSGRenderer::prepare (const ShaderUtils::ShaderInfo *shaderinfo) {
+  if (vertex_state_containers_.empty ()) {
     if (root_products_) {
-      createCSGVBOProducts(*root_products_, false, false, shaderinfo);
+      createCSGVBOProducts (*root_products_, false, false, shaderinfo);
     }
     if (background_products_) {
-      createCSGVBOProducts(*background_products_, false, true, shaderinfo);
+      createCSGVBOProducts (*background_products_, false, true, shaderinfo);
     }
     if (highlights_products_) {
-      createCSGVBOProducts(*highlights_products_, true, false, shaderinfo);
+      createCSGVBOProducts (*highlights_products_, true, false, shaderinfo);
     }
   }
 }
 
-void OpenCSGRenderer::draw(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const {
+void OpenCSGRenderer::draw (bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const {
 #ifdef ENABLE_OPENCSG
   // Only use shader if select rendering or showedges
-  bool enable_shader = shaderinfo && (
-    shaderinfo->type == ShaderUtils::ShaderType::EDGE_RENDERING && showedges ||
-    shaderinfo->type == ShaderUtils::ShaderType::SELECT_RENDERING);
+  bool enable_shader = shaderinfo && (shaderinfo->type == ShaderUtils::ShaderType::EDGE_RENDERING && showedges ||
+                                      shaderinfo->type == ShaderUtils::ShaderType::SELECT_RENDERING);
 
-  for (const auto& product : vertex_state_containers_) {
-    if (product->primitives().size() > 1) {
+  for (const auto &product : vertex_state_containers_) {
+    if (product->primitives ().size () > 1) {
 #if OPENCSG_VERSION >= 0x0180
-      if (enable_shader)OpenCSG::setVertexShader(opencsg_vertex_shader_code_);
-      else OpenCSG::setVertexShader({});
+      if (enable_shader)
+        OpenCSG::setVertexShader (opencsg_vertex_shader_code_);
+      else
+        OpenCSG::setVertexShader ({});
 #endif
-      GL_CHECKD(OpenCSG::render(product->primitives()));
-      GL_TRACE0("glDepthFunc(GL_EQUAL)");
-      GL_CHECKD(glDepthFunc(GL_EQUAL));
+      GL_CHECKD (OpenCSG::render (product->primitives ()));
+      GL_TRACE0 ("glDepthFunc(GL_EQUAL)");
+      GL_CHECKD (glDepthFunc (GL_EQUAL));
     }
 
     if (enable_shader) {
-      GL_TRACE("glUseProgram(%d)", shaderinfo->resource.shader_program);
-      GL_CHECKD(glUseProgram(shaderinfo->resource.shader_program));
-      VBOUtils::shader_attribs_enable(*shaderinfo);
+      GL_TRACE ("glUseProgram(%d)", shaderinfo->resource.shader_program);
+      GL_CHECKD (glUseProgram (shaderinfo->resource.shader_program));
+      VBOUtils::shader_attribs_enable (*shaderinfo);
     }
 
-    for (const auto& vertex_state : product->states()) {
+    for (const auto &vertex_state : product->states ()) {
       // Specify ID color if we're using select rendering
       if (shaderinfo && shaderinfo->type == ShaderUtils::ShaderType::SELECT_RENDERING) {
-        if (const auto csg_vs = std::dynamic_pointer_cast<OpenCSGVertexState>(vertex_state)) {
-          GL_TRACE("glUniform3f(%d, %f, %f, %f)", shaderinfo->uniforms.at("frag_idcolor") %
-                   (((csg_vs->csgObjectIndex() >> 0) & 0xff) / 255.0f) %
-                   (((csg_vs->csgObjectIndex() >> 8) & 0xff) / 255.0f) %
-                   (((csg_vs->csgObjectIndex() >> 16) & 0xff) / 255.0f));
-          GL_CHECKD(glUniform3f(shaderinfo->uniforms.at("frag_idcolor"),
-                                ((csg_vs->csgObjectIndex() >> 0) & 0xff) / 255.0f,
-                                ((csg_vs->csgObjectIndex() >> 8) & 0xff) / 255.0f,
-                                ((csg_vs->csgObjectIndex() >> 16) & 0xff) / 255.0f));
+        if (const auto csg_vs = std::dynamic_pointer_cast<OpenCSGVertexState> (vertex_state)) {
+          GL_TRACE ("glUniform3f(%d, %f, %f, %f)", shaderinfo->uniforms.at ("frag_idcolor") %
+                                                     (((csg_vs->csgObjectIndex () >> 0) & 0xff) / 255.0f) %
+                                                     (((csg_vs->csgObjectIndex () >> 8) & 0xff) / 255.0f) %
+                                                     (((csg_vs->csgObjectIndex () >> 16) & 0xff) / 255.0f));
+          GL_CHECKD (glUniform3f (shaderinfo->uniforms.at ("frag_idcolor"),
+                                  ((csg_vs->csgObjectIndex () >> 0) & 0xff) / 255.0f,
+                                  ((csg_vs->csgObjectIndex () >> 8) & 0xff) / 255.0f,
+                                  ((csg_vs->csgObjectIndex () >> 16) & 0xff) / 255.0f));
         }
       }
-      const auto shader_vs = std::dynamic_pointer_cast<VBOShaderVertexState>(vertex_state);
+      const auto shader_vs = std::dynamic_pointer_cast<VBOShaderVertexState> (vertex_state);
       if (!shader_vs || (showedges && shader_vs)) {
-        vertex_state->draw();
+        vertex_state->draw ();
       }
     }
 
     if (enable_shader) {
-      GL_TRACE0("glUseProgram(0)");
-      GL_CHECKD(glUseProgram(0));
-      VBOUtils::shader_attribs_disable(*shaderinfo);
+      GL_TRACE0 ("glUseProgram(0)");
+      GL_CHECKD (glUseProgram (0));
+      VBOUtils::shader_attribs_disable (*shaderinfo);
     }
-    GL_TRACE0("glDepthFunc(GL_LEQUAL)");
-    GL_CHECKD(glDepthFunc(GL_LEQUAL));
+    GL_TRACE0 ("glDepthFunc(GL_LEQUAL)");
+    GL_CHECKD (glDepthFunc (GL_LEQUAL));
   }
 #endif // ENABLE_OPENCSG
 }
@@ -175,39 +177,39 @@ void OpenCSGRenderer::draw(bool showedges, const ShaderUtils::ShaderInfo *shader
 // reuse VBOs, but that requires some more careful state management.
 // Note: This function can be called multiple times for different products.
 // Each call will add to vbo_vertex_products_.
-void OpenCSGRenderer::createCSGVBOProducts(
-  const CSGProducts& products, bool highlight_mode, bool background_mode, const ShaderUtils::ShaderInfo *shaderinfo) {
+void OpenCSGRenderer::createCSGVBOProducts (
+  const CSGProducts &products, bool highlight_mode, bool background_mode, const ShaderUtils::ShaderInfo *shaderinfo) {
 #ifdef ENABLE_OPENCSG
   bool enable_barycentric = true;
-  for (const auto& product : products.products) {
-    std::unique_ptr<OpenCSGVBOProduct> vertex_state_container = std::make_unique<OpenCSGVBOProduct>();
+  for (const auto &product : products.products) {
+    std::unique_ptr<OpenCSGVBOProduct> vertex_state_container = std::make_unique<OpenCSGVBOProduct> ();
 
     Color4f last_color;
-    std::vector<OpenCSG::Primitive *>& primitives = vertex_state_container->primitives();
-    auto& vertex_states = vertex_state_container->states();
-    VBOBuilder vbo_builder(std::make_unique<OpenCSGVertexStateFactory>(), *vertex_state_container.get());
-    vbo_builder.addSurfaceData();
-    vbo_builder.writeSurface();
-    vbo_builder.addShaderData(); // Always enable barycentric coordinates
+    std::vector<OpenCSG::Primitive *> &primitives = vertex_state_container->primitives ();
+    auto &vertex_states = vertex_state_container->states ();
+    VBOBuilder vbo_builder (std::make_unique<OpenCSGVertexStateFactory> (), *vertex_state_container.get ());
+    vbo_builder.addSurfaceData ();
+    vbo_builder.writeSurface ();
+    vbo_builder.addShaderData (); // Always enable barycentric coordinates
 
     size_t num_vertices = 0;
-    for (const auto& csgobj : product.intersections) {
+    for (const auto &csgobj : product.intersections) {
       if (csgobj.leaf->polyset) {
-        num_vertices += calcNumVertices(csgobj);
+        num_vertices += calcNumVertices (csgobj);
       }
     }
-    for (const auto& csgobj : product.subtractions) {
+    for (const auto &csgobj : product.subtractions) {
       if (csgobj.leaf->polyset) {
-        num_vertices += calcNumVertices(csgobj);
+        num_vertices += calcNumVertices (csgobj);
       }
     }
 
-    vbo_builder.allocateBuffers(num_vertices);
+    vbo_builder.allocateBuffers (num_vertices);
 
-    for (const auto& csgobj : product.intersections) {
+    for (const auto &csgobj : product.intersections) {
       if (csgobj.leaf->polyset) {
-        const Color4f& c = csgobj.leaf->color;
-        const auto csgmode = RendererUtils::getCsgMode(highlight_mode, background_mode);
+        const Color4f &c = csgobj.leaf->color;
+        const auto csgmode = RendererUtils::getCsgMode (highlight_mode, background_mode);
 
         ColorMode colormode = ColorMode::NONE;
         bool override_color;
@@ -219,73 +221,75 @@ void OpenCSGRenderer::createCSGVBOProducts(
           override_color = true;
         } else {
           colormode = ColorMode::MATERIAL;
-          override_color = c.isValid();
+          override_color = c.isValid ();
         }
 
         Color4f color;
-        if (getShaderColor(colormode, c, color)) {
+        if (getShaderColor (colormode, c, color)) {
           last_color = color;
         }
 
-        add_shader_pointers(vbo_builder, shaderinfo);
+        add_shader_pointers (vbo_builder, shaderinfo);
 
-        if (color.a() == 1.0f) {
+        if (color.a () == 1.0f) {
           // object is opaque, draw normally
-          vbo_builder.create_surface(*csgobj.leaf->polyset,
-                                     csgobj.leaf->matrix, last_color, enable_barycentric, override_color);
-          if (const auto csg_vs = std::dynamic_pointer_cast<OpenCSGVertexState>(
-                vertex_states.back())) {
-            csg_vs->setCsgObjectIndex(csgobj.leaf->index);
-            primitives.emplace_back(
-              createVBOPrimitive(csg_vs, OpenCSG::Intersection,
-                                 csgobj.leaf->polyset->getConvexity()));
+          vbo_builder.create_surface (*csgobj.leaf->polyset,
+                                      csgobj.leaf->matrix, last_color, enable_barycentric, override_color);
+          if (const auto csg_vs = std::dynamic_pointer_cast<OpenCSGVertexState> (
+                vertex_states.back ())) {
+            csg_vs->setCsgObjectIndex (csgobj.leaf->index);
+            primitives.emplace_back (
+              createVBOPrimitive (csg_vs, OpenCSG::Intersection,
+                                  csgobj.leaf->polyset->getConvexity ()));
           }
         } else {
           // object is transparent, so draw rear faces first.  Issue #1496
-          std::shared_ptr<VertexState> cull = std::make_shared<VertexState>();
-          cull->glBegin().emplace_back([]() {
-            GL_TRACE0("glEnable(GL_CULL_FACE)"); glEnable(GL_CULL_FACE);
-            GL_TRACE0("glCullFace(GL_FRONT)"); glCullFace(GL_FRONT);
+          std::shared_ptr<VertexState> cull = std::make_shared<VertexState> ();
+          cull->glBegin ().emplace_back ([] () {
+            GL_TRACE0 ("glEnable(GL_CULL_FACE)");
+            glEnable (GL_CULL_FACE);
+            GL_TRACE0 ("glCullFace(GL_FRONT)");
+            glCullFace (GL_FRONT);
           });
-          vertex_states.emplace_back(std::move(cull));
-
-          vbo_builder.create_surface(*csgobj.leaf->polyset,
-                                     csgobj.leaf->matrix, last_color, enable_barycentric, override_color);
-          if (const auto csg_vs = std::dynamic_pointer_cast<OpenCSGVertexState>(
-                vertex_states.back())) {
-            csg_vs->setCsgObjectIndex(csgobj.leaf->index);
-
-            primitives.emplace_back(
-              createVBOPrimitive(csg_vs, OpenCSG::Intersection,
-                                 csgobj.leaf->polyset->getConvexity()));
-
-            cull = std::make_shared<VertexState>();
-            cull->glBegin().emplace_back([]() {
-              GL_TRACE0("glCullFace(GL_BACK)");
-              glCullFace(GL_BACK);
+          vertex_states.emplace_back (std::move (cull));
+
+          vbo_builder.create_surface (*csgobj.leaf->polyset,
+                                      csgobj.leaf->matrix, last_color, enable_barycentric, override_color);
+          if (const auto csg_vs = std::dynamic_pointer_cast<OpenCSGVertexState> (
+                vertex_states.back ())) {
+            csg_vs->setCsgObjectIndex (csgobj.leaf->index);
+
+            primitives.emplace_back (
+              createVBOPrimitive (csg_vs, OpenCSG::Intersection,
+                                  csgobj.leaf->polyset->getConvexity ()));
+
+            cull = std::make_shared<VertexState> ();
+            cull->glBegin ().emplace_back ([] () {
+              GL_TRACE0 ("glCullFace(GL_BACK)");
+              glCullFace (GL_BACK);
             });
-            vertex_states.emplace_back(std::move(cull));
+            vertex_states.emplace_back (std::move (cull));
 
-            vertex_states.emplace_back(csg_vs);
+            vertex_states.emplace_back (csg_vs);
 
-            cull = std::make_shared<VertexState>();
-            cull->glEnd().emplace_back([]() {
-              GL_TRACE0("glDisable(GL_CULL_FACE)");
-              glDisable(GL_CULL_FACE);
+            cull = std::make_shared<VertexState> ();
+            cull->glEnd ().emplace_back ([] () {
+              GL_TRACE0 ("glDisable(GL_CULL_FACE)");
+              glDisable (GL_CULL_FACE);
             });
-            vertex_states.emplace_back(std::move(cull));
+            vertex_states.emplace_back (std::move (cull));
           } else {
-            assert(false && "Intersection surface state was nullptr");
+            assert (false && "Intersection surface state was nullptr");
           }
         }
       }
     }
 
-    for (const auto& csgobj : product.subtractions) {
+    for (const auto &csgobj : product.subtractions) {
       if (csgobj.leaf->polyset) {
-        const Color4f& c = csgobj.leaf->color;
-        const auto csgmode = RendererUtils::getCsgMode(highlight_mode, background_mode,
-                                                       OpenSCADOperator::DIFFERENCE);
+        const Color4f &c = csgobj.leaf->color;
+        const auto csgmode = RendererUtils::getCsgMode (highlight_mode, background_mode,
+                                                        OpenSCADOperator::DIFFERENCE);
 
         ColorMode colormode = ColorMode::NONE;
         bool override_color;
@@ -301,73 +305,72 @@ void OpenCSGRenderer::createCSGVBOProducts(
         }
 
         Color4f color;
-        if (getShaderColor(colormode, c, color)) {
+        if (getShaderColor (colormode, c, color)) {
           last_color = color;
         }
 
-        add_shader_pointers(vbo_builder, shaderinfo);
+        add_shader_pointers (vbo_builder, shaderinfo);
 
         // negative objects should only render rear faces
-        std::shared_ptr<VertexState> cull = std::make_shared<VertexState>();
-        cull->glBegin().emplace_back([]() {
-          GL_TRACE0("glEnable(GL_CULL_FACE)");
-          GL_CHECKD(glEnable(GL_CULL_FACE));
+        std::shared_ptr<VertexState> cull = std::make_shared<VertexState> ();
+        cull->glBegin ().emplace_back ([] () {
+          GL_TRACE0 ("glEnable(GL_CULL_FACE)");
+          GL_CHECKD (glEnable (GL_CULL_FACE));
         });
-        cull->glBegin().emplace_back([]() {
-          GL_TRACE0("glCullFace(GL_FRONT)");
-          GL_CHECKD(glCullFace(GL_FRONT));
+        cull->glBegin ().emplace_back ([] () {
+          GL_TRACE0 ("glCullFace(GL_FRONT)");
+          GL_CHECKD (glCullFace (GL_FRONT));
         });
-        vertex_states.emplace_back(std::move(cull));
+        vertex_states.emplace_back (std::move (cull));
         Transform3d tmp = csgobj.leaf->matrix;
-        if (csgobj.leaf->polyset->getDimension() == 2) {
+        if (csgobj.leaf->polyset->getDimension () == 2) {
           // Scale 2D negative objects 10% in the Z direction to avoid z fighting
-          tmp *= Eigen::Scaling(1.0, 1.0, 1.1);
+          tmp *= Eigen::Scaling (1.0, 1.0, 1.1);
         }
-        vbo_builder.create_surface(*csgobj.leaf->polyset, tmp,
-                                   last_color, enable_barycentric, override_color);
-        if (const auto csg_vs = std::dynamic_pointer_cast<OpenCSGVertexState>(
-              vertex_states.back())) {
-          csg_vs->setCsgObjectIndex(csgobj.leaf->index);
-          primitives.emplace_back(
-            createVBOPrimitive(csg_vs, OpenCSG::Subtraction,
-                               csgobj.leaf->polyset->getConvexity()));
+        vbo_builder.create_surface (*csgobj.leaf->polyset, tmp,
+                                    last_color, enable_barycentric, override_color);
+        if (const auto csg_vs = std::dynamic_pointer_cast<OpenCSGVertexState> (
+              vertex_states.back ())) {
+          csg_vs->setCsgObjectIndex (csgobj.leaf->index);
+          primitives.emplace_back (
+            createVBOPrimitive (csg_vs, OpenCSG::Subtraction,
+                                csgobj.leaf->polyset->getConvexity ()));
         } else {
-          assert(false && "Subtraction surface state was nullptr");
+          assert (false && "Subtraction surface state was nullptr");
         }
 
-        cull = std::make_shared<VertexState>();
-        cull->glEnd().emplace_back([]() {
-          GL_TRACE0("glDisable(GL_CULL_FACE)");
-          GL_CHECKD(glDisable(GL_CULL_FACE));
+        cull = std::make_shared<VertexState> ();
+        cull->glEnd ().emplace_back ([] () {
+          GL_TRACE0 ("glDisable(GL_CULL_FACE)");
+          GL_CHECKD (glDisable (GL_CULL_FACE));
         });
-        vertex_states.emplace_back(std::move(cull));
+        vertex_states.emplace_back (std::move (cull));
       }
     }
 
-    if (Feature::ExperimentalVxORenderersIndexing.is_enabled()) {
-      GL_TRACE0("glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0)");
-      GL_CHECKD(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0));
+    if (Feature::ExperimentalVxORenderersIndexing.is_enabled ()) {
+      GL_TRACE0 ("glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0)");
+      GL_CHECKD (glBindBuffer (GL_ELEMENT_ARRAY_BUFFER, 0));
     }
-    GL_TRACE0("glBindBuffer(GL_ARRAY_BUFFER, 0)");
-    GL_CHECKD(glBindBuffer(GL_ARRAY_BUFFER, 0));
-
-    vbo_builder.createInterleavedVBOs();
-    vertex_state_containers_.push_back(std::move(vertex_state_container));
+    GL_TRACE0 ("glBindBuffer(GL_ARRAY_BUFFER, 0)");
+    GL_CHECKD (glBindBuffer (GL_ARRAY_BUFFER, 0));
 
+    vbo_builder.createInterleavedVBOs ();
+    vertex_state_containers_.push_back (std::move (vertex_state_container));
   }
 #endif // ENABLE_OPENCSG
 }
 
-BoundingBox OpenCSGRenderer::getBoundingBox() const {
+BoundingBox OpenCSGRenderer::getBoundingBox () const {
   BoundingBox bbox;
   if (root_products_) {
-    bbox = root_products_->getBoundingBox();
+    bbox = root_products_->getBoundingBox ();
   }
   if (highlights_products_) {
-    bbox.extend(highlights_products_->getBoundingBox());
+    bbox.extend (highlights_products_->getBoundingBox ());
   }
   if (background_products_) {
-    bbox.extend(background_products_->getBoundingBox());
+    bbox.extend (background_products_->getBoundingBox ());
   }
 
   return bbox;
diff --git a/src/glview/preview/OpenCSGRenderer.h b/src/glview/preview/OpenCSGRenderer.h
index 5584089b2..edeec0390 100644
--- a/src/glview/preview/OpenCSGRenderer.h
+++ b/src/glview/preview/OpenCSGRenderer.h
@@ -19,16 +19,20 @@
 class OpenCSGVertexState : public VertexState
 {
 public:
-  OpenCSGVertexState(size_t csg_object_index = 0)
-    : csg_object_index_(csg_object_index) {}
-  OpenCSGVertexState(GLenum draw_mode, GLsizei draw_size, GLenum draw_type,
-                     size_t draw_offset, size_t element_offset, GLuint vertices_vbo, GLuint elements_vbo,
-                     size_t csg_object_index = 0)
-    : VertexState(draw_mode, draw_size, draw_type, draw_offset, element_offset, vertices_vbo, elements_vbo),
-    csg_object_index_(csg_object_index) {}
+  OpenCSGVertexState (size_t csg_object_index = 0)
+    : csg_object_index_ (csg_object_index) {}
+  OpenCSGVertexState (GLenum draw_mode, GLsizei draw_size, GLenum draw_type,
+                      size_t draw_offset, size_t element_offset, GLuint vertices_vbo, GLuint elements_vbo,
+                      size_t csg_object_index = 0)
+    : VertexState (draw_mode, draw_size, draw_type, draw_offset, element_offset, vertices_vbo, elements_vbo)
+    , csg_object_index_ (csg_object_index) {}
 
-  [[nodiscard]] size_t csgObjectIndex() const { return csg_object_index_; }
-  void setCsgObjectIndex(size_t csg_object_index) { csg_object_index_ = csg_object_index; }
+  [[nodiscard]] size_t csgObjectIndex () const {
+    return csg_object_index_;
+  }
+  void setCsgObjectIndex (size_t csg_object_index) {
+    csg_object_index_ = csg_object_index;
+  }
 
 private:
   size_t csg_object_index_;
@@ -37,24 +41,26 @@ private:
 class OpenCSGVertexStateFactory : public VertexStateFactory
 {
 public:
-  OpenCSGVertexStateFactory() = default;
+  OpenCSGVertexStateFactory () = default;
 
-  [[nodiscard]] std::shared_ptr<VertexState> createVertexState(GLenum draw_mode, size_t draw_size, GLenum draw_type,
-                                                               size_t draw_offset, size_t element_offset,
-                                                               GLuint vertices_vbo, GLuint elements_vbo) const override {
-    return std::make_shared<OpenCSGVertexState>(draw_mode, draw_size, draw_type, draw_offset, element_offset, vertices_vbo, elements_vbo);
+  [[nodiscard]] std::shared_ptr<VertexState> createVertexState (GLenum draw_mode, size_t draw_size, GLenum draw_type,
+                                                                size_t draw_offset, size_t element_offset,
+                                                                GLuint vertices_vbo, GLuint elements_vbo) const override {
+    return std::make_shared<OpenCSGVertexState> (draw_mode, draw_size, draw_type, draw_offset, element_offset, vertices_vbo, elements_vbo);
   }
 };
 
 class OpenCSGVBOProduct : public VertexStateContainer
 {
 public:
-  OpenCSGVBOProduct() = default;
-  OpenCSGVBOProduct(const OpenCSGVBOProduct& o) = delete;
-  OpenCSGVBOProduct(OpenCSGVBOProduct&& o) = delete;
-  virtual ~OpenCSGVBOProduct() = default;
+  OpenCSGVBOProduct () = default;
+  OpenCSGVBOProduct (const OpenCSGVBOProduct &o) = delete;
+  OpenCSGVBOProduct (OpenCSGVBOProduct &&o) = delete;
+  virtual ~OpenCSGVBOProduct () = default;
 
-  [[nodiscard]] std::vector<OpenCSG::Primitive *>& primitives() { return primitives_; }
+  [[nodiscard]] std::vector<OpenCSG::Primitive *> &primitives () {
+    return primitives_;
+  }
 
 private:
   // primitives_ is used to create the OpenCSG depth buffer (unlit rendering).
@@ -66,16 +72,17 @@ private:
 class OpenCSGRenderer : public VBORenderer
 {
 public:
-  OpenCSGRenderer(std::shared_ptr<CSGProducts> root_products,
-                  std::shared_ptr<CSGProducts> highlights_products,
-                  std::shared_ptr<CSGProducts> background_products);
-  ~OpenCSGRenderer() override = default;
-  void prepare(const ShaderUtils::ShaderInfo *shaderinfo = nullptr) override;
-  void draw(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo = nullptr) const override;
+  OpenCSGRenderer (std::shared_ptr<CSGProducts> root_products,
+                   std::shared_ptr<CSGProducts> highlights_products,
+                   std::shared_ptr<CSGProducts> background_products);
+  ~OpenCSGRenderer () override = default;
+  void prepare (const ShaderUtils::ShaderInfo *shaderinfo = nullptr) override;
+  void draw (bool showedges, const ShaderUtils::ShaderInfo *shaderinfo = nullptr) const override;
+
+  BoundingBox getBoundingBox () const override;
 
-  BoundingBox getBoundingBox() const override;
 private:
-  void createCSGVBOProducts(const CSGProducts& products, bool highlight_mode, bool background_mode, const ShaderUtils::ShaderInfo *shaderinfo);
+  void createCSGVBOProducts (const CSGProducts &products, bool highlight_mode, bool background_mode, const ShaderUtils::ShaderInfo *shaderinfo);
 
   std::vector<std::unique_ptr<OpenCSGVBOProduct>> vertex_state_containers_;
   std::shared_ptr<CSGProducts> root_products_;
diff --git a/src/glview/preview/ThrownTogetherRenderer.cc b/src/glview/preview/ThrownTogetherRenderer.cc
index 82d69633f..f830676df 100644
--- a/src/glview/preview/ThrownTogetherRenderer.cc
+++ b/src/glview/preview/ThrownTogetherRenderer.cc
@@ -45,8 +45,8 @@
 
 namespace {
 
-Renderer::ColorMode getColorMode(const CSGNode::Flag& flags, bool highlight_mode,
-                                 bool background_mode, bool fberror, OpenSCADOperator type) {
+Renderer::ColorMode getColorMode (const CSGNode::Flag &flags, bool highlight_mode,
+                                  bool background_mode, bool fberror, OpenSCADOperator type) {
   Renderer::ColorMode colormode = Renderer::ColorMode::NONE;
 
   if (highlight_mode) {
@@ -74,188 +74,188 @@ Renderer::ColorMode getColorMode(const CSGNode::Flag& flags, bool highlight_mode
   return colormode;
 }
 
-}  // namespace
+} // namespace
 
-ThrownTogetherRenderer::ThrownTogetherRenderer(std::shared_ptr<CSGProducts> root_products,
-                                               std::shared_ptr<CSGProducts> highlight_products,
-                                               std::shared_ptr<CSGProducts> background_products)
-  : root_products_(std::move(root_products)), highlight_products_(std::move(highlight_products)), background_products_(std::move(background_products))
-{
+ThrownTogetherRenderer::ThrownTogetherRenderer (std::shared_ptr<CSGProducts> root_products,
+                                                std::shared_ptr<CSGProducts> highlight_products,
+                                                std::shared_ptr<CSGProducts> background_products)
+  : root_products_ (std::move (root_products))
+  , highlight_products_ (std::move (highlight_products))
+  , background_products_ (std::move (background_products)) {
 }
 
-void ThrownTogetherRenderer::prepare(const ShaderUtils::ShaderInfo *shaderinfo)
-{
-  PRINTD("Thrown prepare");
-  if (vertex_state_containers_.empty()) {
-    VertexStateContainer& vertex_state_container = vertex_state_containers_.emplace_back();
+void ThrownTogetherRenderer::prepare (const ShaderUtils::ShaderInfo *shaderinfo) {
+  PRINTD ("Thrown prepare");
+  if (vertex_state_containers_.empty ()) {
+    VertexStateContainer &vertex_state_container = vertex_state_containers_.emplace_back ();
 
-    VBOBuilder vbo_builder(std::make_unique<TTRVertexStateFactory>(), vertex_state_container);
-    vbo_builder.addSurfaceData();
-    vbo_builder.addShaderData(); // Always enable barycentric coordinates
+    VBOBuilder vbo_builder (std::make_unique<TTRVertexStateFactory> (), vertex_state_container);
+    vbo_builder.addSurfaceData ();
+    vbo_builder.addShaderData (); // Always enable barycentric coordinates
 
     size_t num_vertices = 0;
-    if (this->root_products_) num_vertices += (calcNumVertices(this->root_products_, true) * 2);
-    if (this->background_products_) num_vertices += calcNumVertices(this->background_products_, true);
-    if (this->highlight_products_) num_vertices += calcNumVertices(this->highlight_products_, true);
-
-    vbo_builder.allocateBuffers(num_vertices);
-
-    if (this->root_products_) createCSGProducts(*this->root_products_, vertex_state_container, vbo_builder, false, false, shaderinfo);
-    if (this->background_products_) createCSGProducts(*this->background_products_, vertex_state_container, vbo_builder, false, true, shaderinfo);
-    if (this->highlight_products_) createCSGProducts(*this->highlight_products_, vertex_state_container, vbo_builder, true, false, shaderinfo);
-
-    vbo_builder.createInterleavedVBOs();
+    if (this->root_products_)
+      num_vertices += (calcNumVertices (this->root_products_, true) * 2);
+    if (this->background_products_)
+      num_vertices += calcNumVertices (this->background_products_, true);
+    if (this->highlight_products_)
+      num_vertices += calcNumVertices (this->highlight_products_, true);
+
+    vbo_builder.allocateBuffers (num_vertices);
+
+    if (this->root_products_)
+      createCSGProducts (*this->root_products_, vertex_state_container, vbo_builder, false, false, shaderinfo);
+    if (this->background_products_)
+      createCSGProducts (*this->background_products_, vertex_state_container, vbo_builder, false, true, shaderinfo);
+    if (this->highlight_products_)
+      createCSGProducts (*this->highlight_products_, vertex_state_container, vbo_builder, true, false, shaderinfo);
+
+    vbo_builder.createInterleavedVBOs ();
   }
 }
 
-
-void ThrownTogetherRenderer::draw(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const
-{
+void ThrownTogetherRenderer::draw (bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const {
   // Only use shader if select rendering or showedges
-  const bool enable_shader = shaderinfo && (
-    shaderinfo->type == ShaderUtils::ShaderType::EDGE_RENDERING && showedges ||
-    shaderinfo->type == ShaderUtils::ShaderType::SELECT_RENDERING);
+  const bool enable_shader = shaderinfo && (shaderinfo->type == ShaderUtils::ShaderType::EDGE_RENDERING && showedges ||
+                                            shaderinfo->type == ShaderUtils::ShaderType::SELECT_RENDERING);
   if (enable_shader) {
-    GL_TRACE("glUseProgram(%d)", shaderinfo->resource.shader_program);
-    GL_CHECKD(glUseProgram(shaderinfo->resource.shader_program));
-    VBOUtils::shader_attribs_enable(*shaderinfo);
+    GL_TRACE ("glUseProgram(%d)", shaderinfo->resource.shader_program);
+    GL_CHECKD (glUseProgram (shaderinfo->resource.shader_program));
+    VBOUtils::shader_attribs_enable (*shaderinfo);
   }
 
-  GL_TRACE0("glDepthFunc(GL_LEQUAL)");
-  GL_CHECKD(glDepthFunc(GL_LEQUAL));
-  for (const auto& container : vertex_state_containers_) {
-    for (const auto& vertex_state : container.states()) {
+  GL_TRACE0 ("glDepthFunc(GL_LEQUAL)");
+  GL_CHECKD (glDepthFunc (GL_LEQUAL));
+  for (const auto &container : vertex_state_containers_) {
+    for (const auto &vertex_state : container.states ()) {
       // Specify ID color if we're using select rendering
       if (shaderinfo && shaderinfo->type == ShaderUtils::ShaderType::SELECT_RENDERING) {
-        if (const auto ttr_vs = std::dynamic_pointer_cast<TTRVertexState>(vertex_state)) {
-          GL_TRACE("glUniform3f(%d, %f, %f, %f)",
-                   shaderinfo->uniforms.at("frag_idcolor") %
-                   (((ttr_vs->csgObjectIndex() >> 0) & 0xff) / 255.0f) %
-                   (((ttr_vs->csgObjectIndex() >> 8) & 0xff) / 255.0f) %
-                   (((ttr_vs->csgObjectIndex() >> 16) & 0xff) / 255.0f));
-          GL_CHECKD(glUniform3f(shaderinfo->uniforms.at("frag_idcolor"),
-                                ((ttr_vs->csgObjectIndex() >> 0) & 0xff) / 255.0f,
-                                ((ttr_vs->csgObjectIndex() >> 8) & 0xff) / 255.0f,
-                                ((ttr_vs->csgObjectIndex() >> 16) & 0xff) / 255.0f));
+        if (const auto ttr_vs = std::dynamic_pointer_cast<TTRVertexState> (vertex_state)) {
+          GL_TRACE ("glUniform3f(%d, %f, %f, %f)",
+                    shaderinfo->uniforms.at ("frag_idcolor") %
+                      (((ttr_vs->csgObjectIndex () >> 0) & 0xff) / 255.0f) %
+                      (((ttr_vs->csgObjectIndex () >> 8) & 0xff) / 255.0f) %
+                      (((ttr_vs->csgObjectIndex () >> 16) & 0xff) / 255.0f));
+          GL_CHECKD (glUniform3f (shaderinfo->uniforms.at ("frag_idcolor"),
+                                  ((ttr_vs->csgObjectIndex () >> 0) & 0xff) / 255.0f,
+                                  ((ttr_vs->csgObjectIndex () >> 8) & 0xff) / 255.0f,
+                                  ((ttr_vs->csgObjectIndex () >> 16) & 0xff) / 255.0f));
         }
       }
-      const auto shader_vs = std::dynamic_pointer_cast<VBOShaderVertexState>(vertex_state);
+      const auto shader_vs = std::dynamic_pointer_cast<VBOShaderVertexState> (vertex_state);
       if (!shader_vs || (shader_vs && showedges)) {
-        vertex_state->draw();
+        vertex_state->draw ();
       }
     }
   }
 
   if (enable_shader) {
-    VBOUtils::shader_attribs_disable(*shaderinfo);
-    glUseProgram(0);
+    VBOUtils::shader_attribs_disable (*shaderinfo);
+    glUseProgram (0);
   }
 }
 
-void ThrownTogetherRenderer::createChainObject(VertexStateContainer& container, VBOBuilder& vbo_builder,
-                                               const CSGChainObject& csgobj, bool highlight_mode,
-                                               bool background_mode, OpenSCADOperator type, const ShaderUtils::ShaderInfo *shaderinfo)
-{
+void ThrownTogetherRenderer::createChainObject (VertexStateContainer &container, VBOBuilder &vbo_builder,
+                                                const CSGChainObject &csgobj, bool highlight_mode,
+                                                bool background_mode, OpenSCADOperator type, const ShaderUtils::ShaderInfo *shaderinfo) {
   if (!csgobj.leaf->polyset ||
-      this->geom_visit_mark_[std::make_pair(csgobj.leaf->polyset.get(), &csgobj.leaf->matrix)]++ > 0) {
+      this->geom_visit_mark_[std::make_pair (csgobj.leaf->polyset.get (), &csgobj.leaf->matrix)]++ > 0) {
     return;
   }
 
   const bool enable_barycentric = true;
 
-  const auto& leaf_color = csgobj.leaf->color;
+  const auto &leaf_color = csgobj.leaf->color;
 
-  vbo_builder.writeSurface();
+  vbo_builder.writeSurface ();
 
   Color4f color;
   if (highlight_mode || background_mode) {
-    const ColorMode colormode = getColorMode(csgobj.flags, highlight_mode, background_mode, false, type);
-    getShaderColor(colormode, leaf_color, color);
+    const ColorMode colormode = getColorMode (csgobj.flags, highlight_mode, background_mode, false, type);
+    getShaderColor (colormode, leaf_color, color);
 
-    add_shader_pointers(vbo_builder, shaderinfo);
+    add_shader_pointers (vbo_builder, shaderinfo);
 
-    vbo_builder.create_surface(*csgobj.leaf->polyset, csgobj.leaf->matrix, color, enable_barycentric);
-    if (const auto ttr_vs = std::dynamic_pointer_cast<TTRVertexState>(vbo_builder.states().back())) {
-      ttr_vs->setCsgObjectIndex(csgobj.leaf->index);
+    vbo_builder.create_surface (*csgobj.leaf->polyset, csgobj.leaf->matrix, color, enable_barycentric);
+    if (const auto ttr_vs = std::dynamic_pointer_cast<TTRVertexState> (vbo_builder.states ().back ())) {
+      ttr_vs->setCsgObjectIndex (csgobj.leaf->index);
     }
   } else { // root mode
-    ColorMode colormode = getColorMode(csgobj.flags, highlight_mode, background_mode, false, type);
-    getShaderColor(colormode, leaf_color, color);
+    ColorMode colormode = getColorMode (csgobj.flags, highlight_mode, background_mode, false, type);
+    getShaderColor (colormode, leaf_color, color);
 
-    add_shader_pointers(vbo_builder, shaderinfo);
+    add_shader_pointers (vbo_builder, shaderinfo);
 
-    auto cull = std::make_shared<VertexState>();
-    cull->glBegin().emplace_back([]() {
-      GL_TRACE0("glEnable(GL_CULL_FACE)");
-      GL_CHECKD(glEnable(GL_CULL_FACE));
-      GL_TRACE0("glCullFace(GL_BACK)");
-      GL_CHECKD(glCullFace(GL_BACK));
+    auto cull = std::make_shared<VertexState> ();
+    cull->glBegin ().emplace_back ([] () {
+      GL_TRACE0 ("glEnable(GL_CULL_FACE)");
+      GL_CHECKD (glEnable (GL_CULL_FACE));
+      GL_TRACE0 ("glCullFace(GL_BACK)");
+      GL_CHECKD (glCullFace (GL_BACK));
     });
-    container.states().emplace_back(std::move(cull));
+    container.states ().emplace_back (std::move (cull));
 
     Transform3d mat = csgobj.leaf->matrix;
-    if (csgobj.leaf->polyset->getDimension() == 2 && type == OpenSCADOperator::DIFFERENCE) {
+    if (csgobj.leaf->polyset->getDimension () == 2 && type == OpenSCADOperator::DIFFERENCE) {
       // Scale 2D negative objects 10% in the Z direction to avoid z fighting
-      mat *= Eigen::Scaling(1.0, 1.0, 1.1);
+      mat *= Eigen::Scaling (1.0, 1.0, 1.1);
     }
-    vbo_builder.create_surface(*csgobj.leaf->polyset, mat, color, enable_barycentric);
-    if (auto ttr_vs = std::dynamic_pointer_cast<TTRVertexState>(vbo_builder.states().back())) {
-      ttr_vs->setCsgObjectIndex(csgobj.leaf->index);
+    vbo_builder.create_surface (*csgobj.leaf->polyset, mat, color, enable_barycentric);
+    if (auto ttr_vs = std::dynamic_pointer_cast<TTRVertexState> (vbo_builder.states ().back ())) {
+      ttr_vs->setCsgObjectIndex (csgobj.leaf->index);
     }
 
-    color.setRgb(1.0f, 0.0f, 1.0f); // override leaf color on front/back error
+    color.setRgb (1.0f, 0.0f, 1.0f); // override leaf color on front/back error
 
-    colormode = getColorMode(csgobj.flags, highlight_mode, background_mode, true, type);
-    getShaderColor(colormode, leaf_color, color);
+    colormode = getColorMode (csgobj.flags, highlight_mode, background_mode, true, type);
+    getShaderColor (colormode, leaf_color, color);
 
-    add_shader_pointers(vbo_builder, shaderinfo);
+    add_shader_pointers (vbo_builder, shaderinfo);
 
-    cull = std::make_shared<VertexState>();
-    cull->glBegin().emplace_back([]() {
-      GL_TRACE0("glCullFace(GL_FRONT)");
-      GL_CHECKD(glCullFace(GL_FRONT));
+    cull = std::make_shared<VertexState> ();
+    cull->glBegin ().emplace_back ([] () {
+      GL_TRACE0 ("glCullFace(GL_FRONT)");
+      GL_CHECKD (glCullFace (GL_FRONT));
     });
-    container.states().emplace_back(std::move(cull));
+    container.states ().emplace_back (std::move (cull));
 
-    vbo_builder.create_surface(*csgobj.leaf->polyset, csgobj.leaf->matrix, color, enable_barycentric);
-    if (auto ttr_vs = std::dynamic_pointer_cast<TTRVertexState>(vbo_builder.states().back())) {
-      ttr_vs->setCsgObjectIndex(csgobj.leaf->index);
+    vbo_builder.create_surface (*csgobj.leaf->polyset, csgobj.leaf->matrix, color, enable_barycentric);
+    if (auto ttr_vs = std::dynamic_pointer_cast<TTRVertexState> (vbo_builder.states ().back ())) {
+      ttr_vs->setCsgObjectIndex (csgobj.leaf->index);
     }
 
-    container.states().back()->glEnd().emplace_back([]() {
-      GL_TRACE0("glDisable(GL_CULL_FACE)");
-      GL_CHECKD(glDisable(GL_CULL_FACE));
+    container.states ().back ()->glEnd ().emplace_back ([] () {
+      GL_TRACE0 ("glDisable(GL_CULL_FACE)");
+      GL_CHECKD (glDisable (GL_CULL_FACE));
     });
   }
 }
 
-void ThrownTogetherRenderer::createCSGProducts(const CSGProducts& products, VertexStateContainer& container, VBOBuilder& vbo_builder,
-                                               bool highlight_mode, bool background_mode, const ShaderUtils::ShaderInfo *shaderinfo)
-{
-  PRINTD("Thrown renderCSGProducts");
-  this->geom_visit_mark_.clear();
+void ThrownTogetherRenderer::createCSGProducts (const CSGProducts &products, VertexStateContainer &container, VBOBuilder &vbo_builder,
+                                                bool highlight_mode, bool background_mode, const ShaderUtils::ShaderInfo *shaderinfo) {
+  PRINTD ("Thrown renderCSGProducts");
+  this->geom_visit_mark_.clear ();
 
-  for (const auto& product : products.products) {
-    for (const auto& csgobj : product.intersections) {
-      createChainObject(container, vbo_builder, csgobj, highlight_mode, background_mode, OpenSCADOperator::INTERSECTION, shaderinfo);
+  for (const auto &product : products.products) {
+    for (const auto &csgobj : product.intersections) {
+      createChainObject (container, vbo_builder, csgobj, highlight_mode, background_mode, OpenSCADOperator::INTERSECTION, shaderinfo);
     }
-    for (const auto& csgobj : product.subtractions) {
-      createChainObject(container, vbo_builder, csgobj, highlight_mode, background_mode, OpenSCADOperator::DIFFERENCE, shaderinfo);
+    for (const auto &csgobj : product.subtractions) {
+      createChainObject (container, vbo_builder, csgobj, highlight_mode, background_mode, OpenSCADOperator::DIFFERENCE, shaderinfo);
     }
   }
 }
 
-BoundingBox ThrownTogetherRenderer::getBoundingBox() const
-{
+BoundingBox ThrownTogetherRenderer::getBoundingBox () const {
   BoundingBox bbox;
   if (this->root_products_) {
-    bbox = this->root_products_->getBoundingBox(true);
+    bbox = this->root_products_->getBoundingBox (true);
   }
   if (this->highlight_products_) {
-    bbox.extend(this->highlight_products_->getBoundingBox(true));
+    bbox.extend (this->highlight_products_->getBoundingBox (true));
   }
   if (this->background_products_) {
-    bbox.extend(this->background_products_->getBoundingBox(true));
+    bbox.extend (this->background_products_->getBoundingBox (true));
   }
   return bbox;
 }
diff --git a/src/glview/preview/ThrownTogetherRenderer.h b/src/glview/preview/ThrownTogetherRenderer.h
index dbe881493..5e6b8fc62 100644
--- a/src/glview/preview/ThrownTogetherRenderer.h
+++ b/src/glview/preview/ThrownTogetherRenderer.h
@@ -19,16 +19,20 @@ class CSGChainObject;
 class TTRVertexState : public VertexState
 {
 public:
-  TTRVertexState(size_t csg_object_index = 0)
-    : csg_object_index_(csg_object_index) {}
-  TTRVertexState(GLenum draw_mode, GLsizei draw_size, GLenum draw_type,
-                 size_t draw_offset, size_t element_offset, GLuint vertices_vbo, GLuint elements_vbo,
-                 size_t csg_object_index = 0)
-    : VertexState(draw_mode, draw_size, draw_type, draw_offset, element_offset, vertices_vbo, elements_vbo), csg_object_index_(csg_object_index)
-  {}
+  TTRVertexState (size_t csg_object_index = 0)
+    : csg_object_index_ (csg_object_index) {}
+  TTRVertexState (GLenum draw_mode, GLsizei draw_size, GLenum draw_type,
+                  size_t draw_offset, size_t element_offset, GLuint vertices_vbo, GLuint elements_vbo,
+                  size_t csg_object_index = 0)
+    : VertexState (draw_mode, draw_size, draw_type, draw_offset, element_offset, vertices_vbo, elements_vbo)
+    , csg_object_index_ (csg_object_index) {}
 
-  [[nodiscard]] size_t csgObjectIndex() const { return csg_object_index_; }
-  void setCsgObjectIndex(size_t csg_object_index) { csg_object_index_ = csg_object_index; }
+  [[nodiscard]] size_t csgObjectIndex () const {
+    return csg_object_index_;
+  }
+  void setCsgObjectIndex (size_t csg_object_index) {
+    csg_object_index_ = csg_object_index;
+  }
 
 private:
   size_t csg_object_index_;
@@ -37,36 +41,37 @@ private:
 class TTRVertexStateFactory : public VertexStateFactory
 {
 public:
-  TTRVertexStateFactory() = default;
+  TTRVertexStateFactory () = default;
 
-  [[nodiscard]] std::shared_ptr<VertexState> createVertexState(GLenum draw_mode, size_t draw_size, GLenum draw_type,
-                                                               size_t draw_offset, size_t element_offset,
-                                                               GLuint vertices_vbo, GLuint elements_vbo) const override {
-    return std::make_shared<TTRVertexState>(draw_mode, draw_size, draw_type, draw_offset, element_offset, vertices_vbo, elements_vbo);
+  [[nodiscard]] std::shared_ptr<VertexState> createVertexState (GLenum draw_mode, size_t draw_size, GLenum draw_type,
+                                                                size_t draw_offset, size_t element_offset,
+                                                                GLuint vertices_vbo, GLuint elements_vbo) const override {
+    return std::make_shared<TTRVertexState> (draw_mode, draw_size, draw_type, draw_offset, element_offset, vertices_vbo, elements_vbo);
   }
 };
 
 class ThrownTogetherRenderer : public VBORenderer
 {
 public:
-  ThrownTogetherRenderer(std::shared_ptr<CSGProducts> root_products,
-                         std::shared_ptr<CSGProducts> highlight_products,
-                         std::shared_ptr<CSGProducts> background_products);
-  ~ThrownTogetherRenderer() override = default;
-  void prepare(const ShaderUtils::ShaderInfo *shaderinfo = nullptr) override;
-  void draw(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo = nullptr) const override;
+  ThrownTogetherRenderer (std::shared_ptr<CSGProducts> root_products,
+                          std::shared_ptr<CSGProducts> highlight_products,
+                          std::shared_ptr<CSGProducts> background_products);
+  ~ThrownTogetherRenderer () override = default;
+  void prepare (const ShaderUtils::ShaderInfo *shaderinfo = nullptr) override;
+  void draw (bool showedges, const ShaderUtils::ShaderInfo *shaderinfo = nullptr) const override;
+
+  BoundingBox getBoundingBox () const override;
 
-  BoundingBox getBoundingBox() const override;
 private:
-  void renderCSGProducts(const std::shared_ptr<CSGProducts>& products, bool showedges = false,
-                         const ShaderUtils::ShaderInfo *shaderinfo = nullptr,
-                         bool highlight_mode = false, bool background_mode = false,
-                         bool fberror = false) const;
+  void renderCSGProducts (const std::shared_ptr<CSGProducts> &products, bool showedges = false,
+                          const ShaderUtils::ShaderInfo *shaderinfo = nullptr,
+                          bool highlight_mode = false, bool background_mode = false,
+                          bool fberror = false) const;
 
-  void createCSGProducts(const CSGProducts& products, VertexStateContainer& container, VBOBuilder& vbo_builder,
-                         bool highlight_mode, bool background_mode, const ShaderUtils::ShaderInfo *shaderinfo);
-  void createChainObject(VertexStateContainer& container, VBOBuilder& vbo_builder, const CSGChainObject& csgobj,
-                         bool highlight_mode, bool background_mode, OpenSCADOperator type, const ShaderUtils::ShaderInfo *shaderinfo);
+  void createCSGProducts (const CSGProducts &products, VertexStateContainer &container, VBOBuilder &vbo_builder,
+                          bool highlight_mode, bool background_mode, const ShaderUtils::ShaderInfo *shaderinfo);
+  void createChainObject (VertexStateContainer &container, VBOBuilder &vbo_builder, const CSGChainObject &csgobj,
+                          bool highlight_mode, bool background_mode, OpenSCADOperator type, const ShaderUtils::ShaderInfo *shaderinfo);
 
   std::shared_ptr<CSGProducts> root_products_;
   std::shared_ptr<CSGProducts> highlight_products_;
diff --git a/src/glview/system-gl.cc b/src/glview/system-gl.cc
index fddc5f0fb..118dca895 100644
--- a/src/glview/system-gl.cc
+++ b/src/glview/system-gl.cc
@@ -20,13 +20,12 @@
 #include <boost/algorithm/string.hpp>
 #include <boost/format.hpp>
 
-static double gl_version()
-{
-  std::string tmp((const char *)glGetString(GL_VERSION));
+static double gl_version () {
+  std::string tmp ((const char *)glGetString (GL_VERSION));
   std::vector<std::string> strs;
-  boost::split(strs, tmp, boost::is_any_of("."));
+  boost::split (strs, tmp, boost::is_any_of ("."));
   std::stringstream out;
-  if (strs.size() >= 2) {
+  if (strs.size () >= 2) {
     out << strs[0] << "." << strs[1];
   } else {
     out << "0.0";
@@ -36,58 +35,56 @@ static double gl_version()
   return d;
 }
 
-std::string gl_extensions_dump()
-{
+std::string gl_extensions_dump () {
   std::string tmp;
-  if (gl_version() >= 3.0) {
+  if (gl_version () >= 3.0) {
     GLint numexts = 0;
-    glGetIntegerv(GL_NUM_EXTENSIONS, &numexts);
+    glGetIntegerv (GL_NUM_EXTENSIONS, &numexts);
     for (int i = 0; i < numexts; ++i) {
-      tmp += (const char *) glGetStringi(GL_EXTENSIONS, i);
+      tmp += (const char *)glGetStringi (GL_EXTENSIONS, i);
       tmp += " ";
     }
   } else {
-    tmp = (const char *) glGetString(GL_EXTENSIONS);
+    tmp = (const char *)glGetString (GL_EXTENSIONS);
   }
   std::vector<std::string> extensions;
-  boost::split(extensions, tmp, boost::is_any_of(" "));
-  std::sort(extensions.begin(), extensions.end());
+  boost::split (extensions, tmp, boost::is_any_of (" "));
+  std::sort (extensions.begin (), extensions.end ());
   std::ostringstream out;
   out << "GL Extensions:";
-  for (auto& extension : extensions) {
+  for (auto &extension : extensions) {
     out << extension << "\n";
   }
-  return out.str();
+  return out.str ();
 }
 
-std::string gl_dump()
-{
+std::string gl_dump () {
   GLint rbits, gbits, bbits, abits, dbits, sbits;
-  glGetIntegerv(GL_RED_BITS, &rbits);
-  glGetIntegerv(GL_GREEN_BITS, &gbits);
-  glGetIntegerv(GL_BLUE_BITS, &bbits);
-  glGetIntegerv(GL_ALPHA_BITS, &abits);
-  glGetIntegerv(GL_DEPTH_BITS, &dbits);
-  glGetIntegerv(GL_STENCIL_BITS, &sbits);
+  glGetIntegerv (GL_RED_BITS, &rbits);
+  glGetIntegerv (GL_GREEN_BITS, &gbits);
+  glGetIntegerv (GL_BLUE_BITS, &bbits);
+  glGetIntegerv (GL_ALPHA_BITS, &abits);
+  glGetIntegerv (GL_DEPTH_BITS, &dbits);
+  glGetIntegerv (GL_STENCIL_BITS, &sbits);
 
   std::ostringstream out;
 #ifdef USE_GLEW
-  out << "GLEW version: " << glewGetString(GLEW_VERSION);
+  out << "GLEW version: " << glewGetString (GLEW_VERSION);
 #endif
 #ifdef USE_GLAD
   out << "GLAD version: " << GLAD_GENERATOR_VERSION;
 #endif
-  out << "\nOpenGL Version: " << (const char *)glGetString(GL_VERSION)
-      << "\nGL Renderer: " << (const char *)glGetString(GL_RENDERER)
-      << "\nGL Vendor: " << (const char *)glGetString(GL_VENDOR)
-      << boost::format("\nRGBA(%d%d%d%d), depth(%d), stencil(%d)") %
-    rbits % gbits % bbits % abits % dbits % sbits;
+  out << "\nOpenGL Version: " << (const char *)glGetString (GL_VERSION)
+      << "\nGL Renderer: " << (const char *)glGetString (GL_RENDERER)
+      << "\nGL Vendor: " << (const char *)glGetString (GL_VENDOR)
+      << boost::format ("\nRGBA(%d%d%d%d), depth(%d), stencil(%d)") %
+           rbits % gbits % bbits % abits % dbits % sbits;
   out << "\nGL_ARB_framebuffer_object: "
-      << (hasGLExtension(ARB_framebuffer_object) ? "yes" : "no")
+      << (hasGLExtension (ARB_framebuffer_object) ? "yes" : "no")
       << "\nGL_EXT_framebuffer_object: "
-      << (hasGLExtension(EXT_framebuffer_object) ? "yes" : "no")
+      << (hasGLExtension (EXT_framebuffer_object) ? "yes" : "no")
       << "\nGL_EXT_packed_depth_stencil: "
-      << (hasGLExtension(EXT_packed_depth_stencil) ? "yes" : "no")
+      << (hasGLExtension (EXT_packed_depth_stencil) ? "yes" : "no")
       << "\n";
-  return out.str();
+  return out.str ();
 }
diff --git a/src/glview/system-gl.h b/src/glview/system-gl.h
index 07aecfd38..0d027336b 100644
--- a/src/glview/system-gl.h
+++ b/src/glview/system-gl.h
@@ -6,17 +6,17 @@
 #include <GL/glew.h>
 #endif
 #ifdef USE_GLAD
-  #ifdef _WIN32
-  #define NORESOURCE // To avoid picking up DIFFERENCE from winuser.h, conflicting with OpenSCADOperator::DIFFERENCE
-  #include <windows.h>
-  #endif
+#ifdef _WIN32
+#define NORESOURCE // To avoid picking up DIFFERENCE from winuser.h, conflicting with OpenSCADOperator::DIFFERENCE
+#include <windows.h>
+#endif
 #include "glad/gl.h"
 #endif
 
 #ifdef __APPLE__
- #include <OpenGL/glu.h>  // IWYU pragma: export
+#include <OpenGL/glu.h> // IWYU pragma: export
 #else
- #include <GL/glu.h>
+#include <GL/glu.h>
 #endif
 
 #include <string>
@@ -25,23 +25,24 @@
 namespace {
 
 // Returns true on OK, false on error
-[[maybe_unused]] bool glCheck(const char *stmt, const char *file, int line)
-{
-  if (const auto err = glGetError(); err != GL_NO_ERROR) {
-    LOG(message_group::Error, Location::NONE, "",
-        "OpenGL error: %1$s (0x%2$04x) in %3$s:%4$d\n"
-        "              %5$s\n", gluErrorString(err), err, file, line, stmt);
+[[maybe_unused]] bool glCheck (const char *stmt, const char *file, int line) {
+  if (const auto err = glGetError (); err != GL_NO_ERROR) {
+    LOG (message_group::Error, Location::NONE, "",
+         "OpenGL error: %1$s (0x%2$04x) in %3$s:%4$d\n"
+         "              %5$s\n",
+         gluErrorString (err), err, file, line, stmt);
     return false;
   }
   return true;
 }
 
 // Returns true on OK, false on error
-[[maybe_unused]] bool glCheckd(const char *stmt, const char *file, int line)
-{
-  if (const auto err = glGetError(); err != GL_NO_ERROR) {
-    PRINTDB("OpenGL error: %s (0x%04x) in %s:%d\n"
-            "              %s\n", gluErrorString(err) % err % file % line % stmt);
+[[maybe_unused]] bool glCheckd (const char *stmt, const char *file, int line) {
+  if (const auto err = glGetError (); err != GL_NO_ERROR) {
+    PRINTDB (
+      "OpenGL error: %s (0x%04x) in %s:%d\n"
+      "              %s\n",
+      gluErrorString (err) % err % file % line % stmt);
     return false;
   }
   return true;
@@ -69,14 +70,18 @@ namespace {
 //
 // This example will print an error if glClear() fails:
 // GL_CHECK(glClear());
-#define GL_CHECK(stmt) stmt; glCheck(#stmt, __FILE__, __LINE__)
+#define GL_CHECK(stmt) \
+  stmt;                \
+  glCheck (#stmt, __FILE__, __LINE__)
 
 // IF_GL_CHECK(statement) then_statement;
 // Use this for important error handling which always causes an error, also in release mode
 //
 // This example will print an error and return false if glClear() fails:
 // IF_GL_CHECK(glClear()) return false;
-#define IF_GL_CHECK(stmt) stmt; if (!glCheck(#stmt, __FILE__, __LINE__))
+#define IF_GL_CHECK(stmt) \
+  stmt;                   \
+  if (!glCheck (#stmt, __FILE__, __LINE__))
 
 // GL_CHECKD(statement);
 // Use this for OpenGL debug error output which should make it into the release build
@@ -85,7 +90,9 @@ namespace {
 //
 // This example will print an error if glClear() fails, and if --debug is specified:
 // GL_CHECKD(glClear());
-#define GL_CHECKD(stmt) stmt; glCheckd(#stmt, __FILE__, __LINE__)
+#define GL_CHECKD(stmt) \
+  stmt;                 \
+  glCheckd (#stmt, __FILE__, __LINE__)
 
 // GL_DEBUG_CHECKD(statement)
 // Use this for OpenGL debug output which needs to be fast in release mode
@@ -94,7 +101,9 @@ namespace {
 // This example will print an error if glClear() fails if --debug is specified, but yields just glClear in release mode.
 // GL_DEBUG_CHECKD(glClear());
 #ifdef DEBUG
-#define GL_DEBUG_CHECKD(stmt) stmt; glCheckd(#stmt, __FILE__, __LINE__)
+#define GL_DEBUG_CHECKD(stmt) \
+  stmt;                       \
+  glCheckd (#stmt, __FILE__, __LINE__)
 #else
 #define GL_DEBUG_CHECKD(stmt) stmt
 #endif
@@ -104,16 +113,16 @@ namespace {
 #define GLint int
 #define GLuint unsigned int
 #define GLdouble unsigned int
-inline void glColor4fv(float *c) {}
+inline void glColor4fv (float *c) {}
 
 #endif // NULLGL
 
 #ifdef USE_GLEW
-#define hasGLExtension(ext) glewIsSupported("GL_" #ext)
+#define hasGLExtension(ext) glewIsSupported ("GL_" #ext)
 #endif
 #ifdef USE_GLAD
-#define hasGLExtension(ext) GLAD_GL_ ## ext
+#define hasGLExtension(ext) GLAD_GL_##ext
 #endif
 
-std::string gl_dump();
-std::string gl_extensions_dump();
+std::string gl_dump ();
+std::string gl_extensions_dump ();
diff --git a/src/gui/AboutDialog.h b/src/gui/AboutDialog.h
index 3f61029da..96b3904d8 100644
--- a/src/gui/AboutDialog.h
+++ b/src/gui/AboutDialog.h
@@ -9,15 +9,18 @@
 class AboutDialog : public QDialog, public Ui::AboutDialog
 {
   Q_OBJECT;
+
 public:
-  AboutDialog(QWidget *) {
-    setupUi(this);
-    this->setWindowTitle(QString(_("About OpenSCAD")) + " " + openscad_shortversionnumber.c_str());
-    QString tmp = this->aboutText->toHtml();
-    tmp.replace("__VERSION__", openscad_detailedversionnumber.c_str());
-    this->aboutText->setHtml(tmp);
+  AboutDialog (QWidget *) {
+    setupUi (this);
+    this->setWindowTitle (QString (_ ("About OpenSCAD")) + " " + openscad_shortversionnumber.c_str ());
+    QString tmp = this->aboutText->toHtml ();
+    tmp.replace ("__VERSION__", openscad_detailedversionnumber.c_str ());
+    this->aboutText->setHtml (tmp);
   }
 
 public slots:
-  void on_okPushButton_clicked() { accept(); }
+  void on_okPushButton_clicked () {
+    accept ();
+  }
 };
diff --git a/src/gui/Animate.cc b/src/gui/Animate.cc
index 44b18e069..b38cc3dd3 100644
--- a/src/gui/Animate.cc
+++ b/src/gui/Animate.cc
@@ -18,61 +18,56 @@
 #include "gui/UIUtils.h"
 #include "openscad_gui.h"
 
-Animate::Animate(QWidget *parent) : QWidget(parent)
-{
-  setupUi(this);
-  initGUI();
-
-  const auto width = groupBoxParameter->minimumSizeHint().width();
-  const auto margins = layout()->contentsMargins();
-  const auto scrollMargins = scrollAreaWidgetContents->layout()->contentsMargins();
-  const auto parameterMargins = groupBoxParameter->layout()->contentsMargins();
-  initMinWidth = width + margins.left() + margins.right() + scrollMargins.left() + scrollMargins.right()
-    + parameterMargins.left() + parameterMargins.right();
+Animate::Animate (QWidget *parent)
+  : QWidget (parent) {
+  setupUi (this);
+  initGUI ();
+
+  const auto width = groupBoxParameter->minimumSizeHint ().width ();
+  const auto margins = layout ()->contentsMargins ();
+  const auto scrollMargins = scrollAreaWidgetContents->layout ()->contentsMargins ();
+  const auto parameterMargins = groupBoxParameter->layout ()->contentsMargins ();
+  initMinWidth = width + margins.left () + margins.right () + scrollMargins.left () + scrollMargins.right () + parameterMargins.left () + parameterMargins.right ();
 }
 
-void Animate::initGUI()
-{
+void Animate::initGUI () {
   this->animStep = 0;
   this->animNumSteps = 0;
   this->animTVal = 0.0;
   this->animDumping = false;
   this->animDumpStartStep = 0;
 
-  this->iconRun = QIcon::fromTheme("chokusen-animate-play");
-  this->iconPause = QIcon::fromTheme("chokusen-animate-pause");
-  this->iconDisabled = QIcon::fromTheme("chokusen-animate-disabled");
+  this->iconRun = QIcon::fromTheme ("chokusen-animate-play");
+  this->iconPause = QIcon::fromTheme ("chokusen-animate-pause");
+  this->iconDisabled = QIcon::fromTheme ("chokusen-animate-disabled");
 
-  animateTimer = new QTimer(this);
-  connect(animateTimer, &QTimer::timeout, this, &Animate::incrementTVal);
+  animateTimer = new QTimer (this);
+  connect (animateTimer, &QTimer::timeout, this, &Animate::incrementTVal);
 
-  connect(this->e_tval, &QLineEdit::textChanged, this, &Animate::updatedAnimTval);
-  connect(this->e_fps, &QLineEdit::textChanged, this, &Animate::updatedAnimFpsAndAnimSteps);
-  connect(this->e_fsteps, &QLineEdit::textChanged, this, &Animate::updatedAnimFpsAndAnimSteps);
-  connect(this->e_dump, &QCheckBox::toggled, this, &Animate::updatedAnimDump);
+  connect (this->e_tval, &QLineEdit::textChanged, this, &Animate::updatedAnimTval);
+  connect (this->e_fps, &QLineEdit::textChanged, this, &Animate::updatedAnimFpsAndAnimSteps);
+  connect (this->e_fsteps, &QLineEdit::textChanged, this, &Animate::updatedAnimFpsAndAnimSteps);
+  connect (this->e_dump, &QCheckBox::toggled, this, &Animate::updatedAnimDump);
 }
 
-void Animate::setMainWindow(MainWindow *mainWindow)
-{
+void Animate::setMainWindow (MainWindow *mainWindow) {
   this->mainWindow = mainWindow;
 
-  connectAction(this->actionAnimationPauseUnpause, pauseButton);
-  connectAction(this->actionAnimationStart, pushButton_MoveToBeginning);
-  connectAction(this->actionAnimationStepBack, pushButton_StepBack);
-  connectAction(this->actionAnimationStepForward, pushButton_StepForward);
-  connectAction(this->actionAnimationEnd, pushButton_MoveToEnd);
-  updatePauseButtonIcon();
+  connectAction (this->actionAnimationPauseUnpause, pauseButton);
+  connectAction (this->actionAnimationStart, pushButton_MoveToBeginning);
+  connectAction (this->actionAnimationStepBack, pushButton_StepBack);
+  connectAction (this->actionAnimationStepForward, pushButton_StepForward);
+  connectAction (this->actionAnimationEnd, pushButton_MoveToEnd);
+  updatePauseButtonIcon ();
 }
 
-void Animate::connectAction(QAction *action, QPushButton *button)
-{
-  connect(action, &QAction::triggered, button, &QPushButton::click);
-  this->actionList.append(action);
+void Animate::connectAction (QAction *action, QPushButton *button) {
+  connect (action, &QAction::triggered, button, &QPushButton::click);
+  this->actionList.append (action);
 }
 
-void Animate::updatedAnimTval()
-{
-  double t = this->e_tval->text().toDouble(&this->tOK);
+void Animate::updatedAnimTval () {
+  double t = this->e_tval->text ().toDouble (&this->tOK);
   // Clamp t to 0-1
   if (this->tOK) {
     t = t < 0 ? 0.0 : ((t > 1.0) ? 1.0 : t);
@@ -81,16 +76,15 @@ void Animate::updatedAnimTval()
   }
 
   this->animTVal = t;
-  emit mainWindow->actionRenderPreview();
+  emit mainWindow->actionRenderPreview ();
 
-  updatePauseButtonIcon();
+  updatePauseButtonIcon ();
 }
 
-void Animate::updatedAnimFpsAndAnimSteps()
-{
-  animateTimer->stop();
+void Animate::updatedAnimFpsAndAnimSteps () {
+  animateTimer->stop ();
 
-  int numsteps = this->e_fsteps->text().toInt(&this->steps_ok);
+  int numsteps = this->e_fsteps->text ().toInt (&this->steps_ok);
   if (this->steps_ok) {
     this->animNumSteps = numsteps;
   } else {
@@ -98,49 +92,49 @@ void Animate::updatedAnimFpsAndAnimSteps()
   }
   this->animDumping = false;
 
-  double fps = this->e_fps->text().toDouble(&this->fpsOK);
-  animateTimer->stop();
+  double fps = this->e_fps->text ().toDouble (&this->fpsOK);
+  animateTimer->stop ();
   if (this->fpsOK && fps > 0 && this->animNumSteps > 0) {
-    this->animStep = int(this->animTVal * this->animNumSteps) % this->animNumSteps;
-    animateTimer->setSingleShot(false);
-    animateTimer->setInterval(int(1000 / fps));
-    animateTimer->start();
+    this->animStep = int (this->animTVal * this->animNumSteps) % this->animNumSteps;
+    animateTimer->setSingleShot (false);
+    animateTimer->setInterval (int (1000 / fps));
+    animateTimer->start ();
   }
 
   QPalette defaultPalette;
-  const auto bgColor = defaultPalette.base().color().toRgb();
-  QString redStyleSheet = UIUtils::blendForBackgroundColorStyleSheet(bgColor, errorBlendColor);
+  const auto bgColor = defaultPalette.base ().color ().toRgb ();
+  QString redStyleSheet = UIUtils::blendForBackgroundColorStyleSheet (bgColor, errorBlendColor);
 
-  if (this->steps_ok || this->e_fsteps->text() == "") {
-    this->e_fsteps->setStyleSheet("");
+  if (this->steps_ok || this->e_fsteps->text () == "") {
+    this->e_fsteps->setStyleSheet ("");
   } else {
-    this->e_fsteps->setStyleSheet(redStyleSheet);
+    this->e_fsteps->setStyleSheet (redStyleSheet);
   }
 
-  if (this->fpsOK || this->e_fps->text() == "") {
-    this->e_fps->setStyleSheet("");
+  if (this->fpsOK || this->e_fps->text () == "") {
+    this->e_fps->setStyleSheet ("");
   } else {
-    this->e_fps->setStyleSheet(redStyleSheet);
+    this->e_fps->setStyleSheet (redStyleSheet);
   }
 
-  updatePauseButtonIcon();
+  updatePauseButtonIcon ();
 }
 
+void Animate::updatedAnimDump (bool checked) {
+  if (!checked)
+    this->animDumping = false;
 
-void Animate::updatedAnimDump(bool checked)
-{
-  if (!checked) this->animDumping = false;
-
-  updatePauseButtonIcon();
+  updatePauseButtonIcon ();
 }
 
 // Only called from animate_timer
-void Animate::incrementTVal()
-{
-  if (this->animNumSteps == 0) return;
+void Animate::incrementTVal () {
+  if (this->animNumSteps == 0)
+    return;
 
-  if (mainWindow->parameterDock->isVisible()) {
-    if (mainWindow->activeEditor->parameterWidget->childHasFocus()) return;
+  if (mainWindow->parameterDock->isVisible ()) {
+    if (mainWindow->activeEditor->parameterWidget->childHasFocus ())
+      return;
   }
 
   if (this->animNumSteps > 1) {
@@ -151,15 +145,15 @@ void Animate::incrementTVal()
     this->animTVal = 0.0;
   }
 
-  const QString txt = QString::number(this->animTVal, 'f', 5);
-  this->e_tval->setText(txt);
+  const QString txt = QString::number (this->animTVal, 'f', 5);
+  this->e_tval->setText (txt);
 
-  updatePauseButtonIcon();
+  updatePauseButtonIcon ();
 }
 
-void Animate::updateTVal()
-{
-  if (this->animNumSteps == 0) return;
+void Animate::updateTVal () {
+  if (this->animNumSteps == 0)
+    return;
 
   if (this->animStep < 0) {
     this->animStep = this->animNumSteps - this->animStep - 2;
@@ -173,72 +167,69 @@ void Animate::updateTVal()
     this->animTVal = 0.0;
   }
 
-  const QString txt = QString::number(this->animTVal, 'f', 5);
-  this->e_tval->setText(txt);
+  const QString txt = QString::number (this->animTVal, 'f', 5);
+  this->e_tval->setText (txt);
 
-  updatePauseButtonIcon();
+  updatePauseButtonIcon ();
 }
 
-void Animate::pauseAnimation(){
-  animateTimer->stop();
-  updatePauseButtonIcon();
+void Animate::pauseAnimation () {
+  animateTimer->stop ();
+  updatePauseButtonIcon ();
 }
 
-void Animate::on_pauseButton_pressed()
-{
-  if (animateTimer->isActive()) {
-    animateTimer->stop();
-    updatePauseButtonIcon();
+void Animate::on_pauseButton_pressed () {
+  if (animateTimer->isActive ()) {
+    animateTimer->stop ();
+    updatePauseButtonIcon ();
   } else {
-    this->updatedAnimFpsAndAnimSteps();
+    this->updatedAnimFpsAndAnimSteps ();
   }
 }
 
-void Animate::updatePauseButtonIcon()
-{
-  if (animateTimer->isActive()) {
-    pauseButton->setIcon(this->iconPause);
-    pauseButton->setToolTip(_("press to pause animation") );
+void Animate::updatePauseButtonIcon () {
+  if (animateTimer->isActive ()) {
+    pauseButton->setIcon (this->iconPause);
+    pauseButton->setToolTip (_ ("press to pause animation"));
   } else {
     if (this->fpsOK && this->steps_ok) {
-      pauseButton->setIcon(this->iconRun);
-      pauseButton->setToolTip(_("press to start animation") );
+      pauseButton->setIcon (this->iconRun);
+      pauseButton->setToolTip (_ ("press to start animation"));
     } else {
-      pauseButton->setIcon(this->iconDisabled);
-      pauseButton->setToolTip(_("incorrect values") );
+      pauseButton->setIcon (this->iconDisabled);
+      pauseButton->setToolTip (_ ("incorrect values"));
     }
   }
 }
 
-void Animate::cameraChanged(){
-  this->animateUpdate(); //for now so that we do not change the behavior
+void Animate::cameraChanged () {
+  this->animateUpdate (); //for now so that we do not change the behavior
 }
 
-void Animate::editorContentChanged(){
-  this->animateUpdate(); //for now so that we do not change the behavior
+void Animate::editorContentChanged () {
+  this->animateUpdate (); //for now so that we do not change the behavior
 }
 
-void Animate::animateUpdate()
-{
-  if (mainWindow->animateDockContents->isVisible()) {
-    double fps = this->e_fps->text().toDouble(&this->fpsOK);
-    if (this->fpsOK && fps <= 0 && !animateTimer->isActive()) {
-      animateTimer->stop();
-      animateTimer->setSingleShot(true);
-      animateTimer->setInterval(50);
-      animateTimer->start();
+void Animate::animateUpdate () {
+  if (mainWindow->animateDockContents->isVisible ()) {
+    double fps = this->e_fps->text ().toDouble (&this->fpsOK);
+    if (this->fpsOK && fps <= 0 && !animateTimer->isActive ()) {
+      animateTimer->stop ();
+      animateTimer->setSingleShot (true);
+      animateTimer->setInterval (50);
+      animateTimer->start ();
     }
   }
 }
 
-bool Animate::dumpPictures(){
-  return this->e_dump->isChecked() && this->animateTimer->isActive();
+bool Animate::dumpPictures () {
+  return this->e_dump->isChecked () && this->animateTimer->isActive ();
 }
 
-int Animate::nextFrame(){
+int Animate::nextFrame () {
   if (animDumping && animDumpStartStep == animStep) {
     animDumping = false;
-    e_dump->setChecked(false);
+    e_dump->setChecked (false);
   } else {
     if (!animDumping) {
       animDumping = true;
@@ -248,69 +239,67 @@ int Animate::nextFrame(){
   return animStep;
 }
 
-void Animate::resizeEvent(QResizeEvent *event)
-{
-  auto layoutParameters = dynamic_cast<QBoxLayout *>(groupBoxParameter->layout());
-  auto layoutButtons = dynamic_cast<QBoxLayout *>(groupBoxButtons->layout());
+void Animate::resizeEvent (QResizeEvent *event) {
+  auto layoutParameters = dynamic_cast<QBoxLayout *> (groupBoxParameter->layout ());
+  auto layoutButtons = dynamic_cast<QBoxLayout *> (groupBoxButtons->layout ());
 
   if (layoutParameters && layoutButtons) {
-    if (layoutParameters->direction() == QBoxLayout::LeftToRight) {
-      if (event->size().width() < initMinWidth) {
-        layoutParameters->setDirection(QBoxLayout::TopToBottom);
-        layoutButtons->setDirection(QBoxLayout::TopToBottom);
-        scrollAreaWidgetContents->layout()->invalidate();
+    if (layoutParameters->direction () == QBoxLayout::LeftToRight) {
+      if (event->size ().width () < initMinWidth) {
+        layoutParameters->setDirection (QBoxLayout::TopToBottom);
+        layoutButtons->setDirection (QBoxLayout::TopToBottom);
+        scrollAreaWidgetContents->layout ()->invalidate ();
       }
     } else {
-      if (event->size().width() > initMinWidth) {
-        layoutParameters->setDirection(QBoxLayout::LeftToRight);
-        layoutButtons->setDirection(QBoxLayout::LeftToRight);
-        scrollAreaWidgetContents->layout()->invalidate();
+      if (event->size ().width () > initMinWidth) {
+        layoutParameters->setDirection (QBoxLayout::LeftToRight);
+        layoutButtons->setDirection (QBoxLayout::LeftToRight);
+        scrollAreaWidgetContents->layout ()->invalidate ();
       }
     }
   }
 
-  QWidget::resizeEvent(event);
+  QWidget::resizeEvent (event);
 }
 
-const QList<QAction *>& Animate::actions(){
+const QList<QAction *> &Animate::actions () {
   return actionList;
 }
 
-void Animate::onActionEvent(InputEventAction *event)
-{
+void Animate::onActionEvent (InputEventAction *event) {
   const std::string actionString = event->action;
-  const std::string actionName = actionString.substr(actionString.find("::") + 2, std::string::npos);
+  const std::string actionName = actionString.substr (actionString.find ("::") + 2, std::string::npos);
   for (auto action : actionList) {
-    if (actionName == action->objectName().toStdString()) {
-      action->trigger();
+    if (actionName == action->objectName ().toStdString ()) {
+      action->trigger ();
     }
   }
 }
 
-double Animate::getAnimTval(){
+double Animate::getAnimTval () {
   return animTVal;
 }
 
-void Animate::on_pushButton_MoveToBeginning_clicked(){
-  pauseAnimation();
+void Animate::on_pushButton_MoveToBeginning_clicked () {
+  pauseAnimation ();
   this->animStep = 0;
-  this->updateTVal();
+  this->updateTVal ();
 }
 
-void Animate::on_pushButton_StepBack_clicked(){
-  pauseAnimation();
+void Animate::on_pushButton_StepBack_clicked () {
+  pauseAnimation ();
   this->animStep -= 1;
-  this->updateTVal();
+  this->updateTVal ();
 }
 
-void Animate::on_pushButton_StepForward_clicked(){
-  pauseAnimation();
+void Animate::on_pushButton_StepForward_clicked () {
+  pauseAnimation ();
   this->animStep += 1;
-  this->updateTVal();
+  this->updateTVal ();
 }
 
-void Animate::on_pushButton_MoveToEnd_clicked(){
-  pauseAnimation();
+void Animate::on_pushButton_MoveToEnd_clicked () {
+  pauseAnimation ();
   this->animStep = this->animNumSteps - 1;
-  this->updateTVal();
+  this->updateTVal ();
 }
diff --git a/src/gui/Animate.h b/src/gui/Animate.h
index ea2a29094..559764fcc 100644
--- a/src/gui/Animate.h
+++ b/src/gui/Animate.h
@@ -20,45 +20,44 @@ class Animate : public QWidget, public Ui::AnimateWidget
   Q_OBJECT
 
 public:
-  Animate(QWidget *parent = nullptr);
-  Animate(const Animate& source) = delete;
-  Animate(Animate&& source) = delete;
-  Animate& operator=(const Animate& source) = delete;
-  Animate& operator=(Animate&& source) = delete;
-  ~Animate() override = default;
+  Animate (QWidget *parent = nullptr);
+  Animate (const Animate &source) = delete;
+  Animate (Animate &&source) = delete;
+  Animate &operator= (const Animate &source) = delete;
+  Animate &operator= (Animate &&source) = delete;
+  ~Animate () override = default;
 
-  void initGUI();
-  bool dumpPictures();
-  int nextFrame();
+  void initGUI ();
+  bool dumpPictures ();
+  int nextFrame ();
 
   QTimer *animateTimer;
 
-  void setMainWindow(MainWindow *mainWindow);
+  void setMainWindow (MainWindow *mainWindow);
 
-  const QList<QAction *>& actions();
-  double getAnimTval();
+  const QList<QAction *> &actions ();
+  double getAnimTval ();
 
 public slots:
-  void animateUpdate();
-  void cameraChanged();
-  void editorContentChanged();
-  void onActionEvent(InputEventAction *event);
-  void pauseAnimation();
+  void animateUpdate ();
+  void cameraChanged ();
+  void editorContentChanged ();
+  void onActionEvent (InputEventAction *event);
+  void pauseAnimation ();
 
-  void on_pushButton_MoveToBeginning_clicked();
-  void on_pushButton_StepBack_clicked();
-  void on_pushButton_StepForward_clicked();
-  void on_pushButton_MoveToEnd_clicked();
+  void on_pushButton_MoveToBeginning_clicked ();
+  void on_pushButton_StepBack_clicked ();
+  void on_pushButton_StepForward_clicked ();
+  void on_pushButton_MoveToEnd_clicked ();
 
 protected:
-  void resizeEvent(QResizeEvent *event) override;
-
+  void resizeEvent (QResizeEvent *event) override;
 
 private:
   MainWindow *mainWindow;
 
-  void updatePauseButtonIcon();
-  void connectAction(QAction *, QPushButton *);
+  void updatePauseButtonIcon ();
+  void connectAction (QAction *, QPushButton *);
 
   double animTVal;
   bool animDumping;
@@ -81,10 +80,10 @@ private:
 signals:
 
 private slots:
-  void updatedAnimTval();
-  void updatedAnimFpsAndAnimSteps();
-  void updatedAnimDump(bool checked);
-  void incrementTVal();
-  void updateTVal();
-  void on_pauseButton_pressed();
+  void updatedAnimTval ();
+  void updatedAnimFpsAndAnimSteps ();
+  void updatedAnimDump (bool checked);
+  void incrementTVal ();
+  void updateTVal ();
+  void on_pauseButton_pressed ();
 };
diff --git a/src/gui/AppleEvents.cc b/src/gui/AppleEvents.cc
index c5c0205e1..a3244bef1 100644
--- a/src/gui/AppleEvents.cc
+++ b/src/gui/AppleEvents.cc
@@ -6,30 +6,29 @@
 #include "gui/MainWindow.h"
 
 extern "C" {
-OSErr eventHandler(const AppleEvent *ev, AppleEvent *reply, SRefCon refcon);
+OSErr eventHandler (const AppleEvent *ev, AppleEvent *reply, SRefCon refcon);
 }
 
-OSErr eventHandler(const AppleEvent *, AppleEvent *, SRefCon)
-{
-// FIXME: Ugly hack; just using the first MainWindow we can find
+OSErr eventHandler (const AppleEvent *, AppleEvent *, SRefCon) {
+  // FIXME: Ugly hack; just using the first MainWindow we can find
   MainWindow *mainwin = nullptr;
-  for (auto& w : QApplication::topLevelWidgets()) {
-    mainwin = qobject_cast<MainWindow *>(w);
-    if (mainwin) break;
+  for (auto &w : QApplication::topLevelWidgets ()) {
+    mainwin = qobject_cast<MainWindow *> (w);
+    if (mainwin)
+      break;
   }
   if (mainwin) {
-    mainwin->actionReloadRenderPreview();
+    mainwin->actionReloadRenderPreview ();
   }
   return noErr;
 }
 
-void installAppleEventHandlers()
-{
+void installAppleEventHandlers () {
   // Reload handler
-  auto err = AEInstallEventHandler('SCAD', 'relo', NewAEEventHandlerUPP(eventHandler), nullptr, true);
-  __Require_noErr(err, CantInstallAppleEventHandler);
+  auto err = AEInstallEventHandler ('SCAD', 'relo', NewAEEventHandlerUPP (eventHandler), nullptr, true);
+  __Require_noErr (err, CantInstallAppleEventHandler);
   return;
 
 CantInstallAppleEventHandler:
-  fprintf(stderr, "AEInstallEventHandler() failed: %d\n", err);
+  fprintf (stderr, "AEInstallEventHandler() failed: %d\n", err);
 }
diff --git a/src/gui/AppleEvents.h b/src/gui/AppleEvents.h
index 204fb5b86..df6aa4026 100644
--- a/src/gui/AppleEvents.h
+++ b/src/gui/AppleEvents.h
@@ -1,3 +1,3 @@
 #pragma once
 
-void installAppleEventHandlers();
+void installAppleEventHandlers ();
diff --git a/src/gui/AutoUpdater.cc b/src/gui/AutoUpdater.cc
index 92279e24c..044711b55 100644
--- a/src/gui/AutoUpdater.cc
+++ b/src/gui/AutoUpdater.cc
@@ -4,20 +4,18 @@
 
 AutoUpdater *AutoUpdater::updater_instance = nullptr;
 
-void AutoUpdater::init()
-{
+void AutoUpdater::init () {
 #ifdef OPENSCAD_UPDATER
   if (!this->updateAction) {
-    auto mb = new QMenuBar();
-    this->updateMenu = mb->addMenu("special");
-    this->updateAction = new QAction("Check for Update...", this);
+    auto mb = new QMenuBar ();
+    this->updateMenu = mb->addMenu ("special");
+    this->updateAction = new QAction ("Check for Update...", this);
     // Add to application menu
-    this->updateAction->setMenuRole(QAction::ApplicationSpecificRole);
-    this->updateAction->setEnabled(true);
-    this->connect(this->updateAction, &AutoUpdater::triggered, this, &AutoUpdater::checkForUpdates);
-
-    this->updateMenu->addAction(this->updateAction);
+    this->updateAction->setMenuRole (QAction::ApplicationSpecificRole);
+    this->updateAction->setEnabled (true);
+    this->connect (this->updateAction, &AutoUpdater::triggered, this, &AutoUpdater::checkForUpdates);
 
+    this->updateMenu->addAction (this->updateAction);
   }
 #endif // ifdef OPENSCAD_UPDATER
 }
diff --git a/src/gui/AutoUpdater.h b/src/gui/AutoUpdater.h
index 8df135493..ec2fe17d0 100644
--- a/src/gui/AutoUpdater.h
+++ b/src/gui/AutoUpdater.h
@@ -11,21 +11,24 @@ class AutoUpdater : public QObject
   Q_OBJECT;
 
 public:
-  AutoUpdater() = default;
-
-  virtual void setAutomaticallyChecksForUpdates(bool on) = 0;
-  virtual bool automaticallyChecksForUpdates() = 0;
-  virtual void setEnableSnapshots(bool on) = 0;
-  virtual bool enableSnapshots() = 0;
-  virtual QString lastUpdateCheckDate() = 0;
-  virtual void init();
-
-  static AutoUpdater *updater() { return updater_instance; }
-  static void setUpdater(AutoUpdater *updater) { updater_instance = updater; }
+  AutoUpdater () = default;
+
+  virtual void setAutomaticallyChecksForUpdates (bool on) = 0;
+  virtual bool automaticallyChecksForUpdates () = 0;
+  virtual void setEnableSnapshots (bool on) = 0;
+  virtual bool enableSnapshots () = 0;
+  virtual QString lastUpdateCheckDate () = 0;
+  virtual void init ();
+
+  static AutoUpdater *updater () {
+    return updater_instance;
+  }
+  static void setUpdater (AutoUpdater *updater) {
+    updater_instance = updater;
+  }
 
 public slots:
-  virtual void checkForUpdates() = 0;
-
+  virtual void checkForUpdates () = 0;
 
 public:
   QAction *updateAction{nullptr};
diff --git a/src/gui/CGALWorker.cc b/src/gui/CGALWorker.cc
index c229e46dc..4a5019b26 100644
--- a/src/gui/CGALWorker.cc
+++ b/src/gui/CGALWorker.cc
@@ -17,60 +17,58 @@
 #include "python/python_public.h"
 #endif
 
-CGALWorker::CGALWorker()
-{
+CGALWorker::CGALWorker () {
   this->tree = nullptr;
-  this->thread = new QThread();
-  if (this->thread->stackSize() < 1024 * 1024) this->thread->setStackSize(1024 * 1024);
-  connect(this->thread, &QThread::started, this, &CGALWorker::work);
-  moveToThread(this->thread);
+  this->thread = new QThread ();
+  if (this->thread->stackSize () < 1024 * 1024)
+    this->thread->setStackSize (1024 * 1024);
+  connect (this->thread, &QThread::started, this, &CGALWorker::work);
+  moveToThread (this->thread);
 }
 
-CGALWorker::~CGALWorker()
-{
+CGALWorker::~CGALWorker () {
   delete this->thread;
 }
 
-void CGALWorker::start(const Tree& tree)
-{
+void CGALWorker::start (const Tree &tree) {
 #ifdef ENABLE_PYTHON
-  python_unlock();
+  python_unlock ();
 #endif
   this->tree = &tree;
-  this->thread->start();
+  this->thread->start ();
 }
 
-void CGALWorker::work()
-{
+void CGALWorker::work () {
   // this is a worker thread: we don't want any exceptions escaping and crashing the app.
 #ifdef ENABLE_PYTHON
-  python_lock();
+  python_lock ();
 #endif
   std::shared_ptr<const Geometry> root_geom;
   try {
-    GeometryEvaluator evaluator(*this->tree);
-    root_geom = evaluator.evaluateGeometry(*this->tree->root(), true);
+    GeometryEvaluator evaluator (*this->tree);
+    root_geom = evaluator.evaluateGeometry (*this->tree->root (), true);
 
 #ifdef ENABLE_MANIFOLD
-    if (auto manifold = std::dynamic_pointer_cast<const ManifoldGeometry>(root_geom)) {
+    if (auto manifold = std::dynamic_pointer_cast<const ManifoldGeometry> (root_geom)) {
       // calling status forces evaluation
       // we should complete evaluation within the worker thread, so computation
       // will not block the GUI.
-      if (manifold->getManifold().Status() != manifold::Manifold::Error::NoError)LOG(message_group::Error, "Rendering cancelled due to unknown manifold error.");
+      if (manifold->getManifold ().Status () != manifold::Manifold::Error::NoError)
+        LOG (message_group::Error, "Rendering cancelled due to unknown manifold error.");
     }
 #endif
-  } catch (const ProgressCancelException& e) {
-    LOG("Rendering cancelled.");
-  } catch (const HardWarningException& e) {
-    LOG("Rendering cancelled on first warning.");
-  } catch (const std::exception& e) {
-    LOG(message_group::Error, "Rendering cancelled by exception %1$s", e.what());
+  } catch (const ProgressCancelException &e) {
+    LOG ("Rendering cancelled.");
+  } catch (const HardWarningException &e) {
+    LOG ("Rendering cancelled on first warning.");
+  } catch (const std::exception &e) {
+    LOG (message_group::Error, "Rendering cancelled by exception %1$s", e.what ());
   } catch (...) {
-    LOG(message_group::Error, "Rendering cancelled by unknown exception.");
+    LOG (message_group::Error, "Rendering cancelled by unknown exception.");
   }
- #ifdef ENABLE_PYTHON
-  python_unlock();
- #endif
-  emit done(root_geom);
-  thread->quit();
+#ifdef ENABLE_PYTHON
+  python_unlock ();
+#endif
+  emit done (root_geom);
+  thread->quit ();
 }
diff --git a/src/gui/CGALWorker.h b/src/gui/CGALWorker.h
index 7bb4f85fc..a1f616f33 100644
--- a/src/gui/CGALWorker.h
+++ b/src/gui/CGALWorker.h
@@ -8,21 +8,21 @@ class Tree;
 class CGALWorker : public QObject
 {
   Q_OBJECT;
+
 public:
-  CGALWorker();
-  ~CGALWorker() override;
+  CGALWorker ();
+  ~CGALWorker () override;
 
 public slots:
-  void start(const Tree& tree);
+  void start (const Tree &tree);
 
 protected slots:
-  void work();
+  void work ();
 
 signals:
-  void done(std::shared_ptr<const class Geometry>);
+  void done (std::shared_ptr<const class Geometry>);
 
 protected:
-
   class QThread *thread;
   const class Tree *tree;
 };
diff --git a/src/gui/Console.cc b/src/gui/Console.cc
index d69cee757..59f8b04a1 100644
--- a/src/gui/Console.cc
+++ b/src/gui/Console.cc
@@ -46,143 +46,132 @@
 #include "gui/Preferences.h"
 #include "gui/UIUtils.h"
 
-Console::Console(QWidget *parent) : QPlainTextEdit(parent)
-{
-  setupUi(this);
-  connect(this->actionClear, &QAction::triggered, this, &Console::actionClearConsole_triggered);
-  connect(this->actionSaveAs, &QAction::triggered, this, &Console::actionSaveAs_triggered);
-  connect(this, &Console::linkActivated, this, &Console::hyperlinkClicked);
-  this->setUndoRedoEnabled(false);
-  this->appendCursor = this->textCursor();
+Console::Console (QWidget *parent)
+  : QPlainTextEdit (parent) {
+  setupUi (this);
+  connect (this->actionClear, &QAction::triggered, this, &Console::actionClearConsole_triggered);
+  connect (this->actionSaveAs, &QAction::triggered, this, &Console::actionSaveAs_triggered);
+  connect (this, &Console::linkActivated, this, &Console::hyperlinkClicked);
+  this->setUndoRedoEnabled (false);
+  this->appendCursor = this->textCursor ();
 }
 
-void Console::focusInEvent(QFocusEvent * /*event*/)
-{
+void Console::focusInEvent (QFocusEvent * /*event*/) {
   QWidget *current = this;
   MainWindow *mw;
-  while (current && !(mw = dynamic_cast<MainWindow *>(current->window()))) {
-    current = current->parentWidget();
+  while (current && !(mw = dynamic_cast<MainWindow *> (current->window ()))) {
+    current = current->parentWidget ();
   }
-  assert(mw);
-  if (mw) mw->setLastFocus(this);
+  assert (mw);
+  if (mw)
+    mw->setLastFocus (this);
 }
 
-void Console::addMessage(const Message& msg)
-{
+void Console::addMessage (const Message &msg) {
   // Messages with links to source must be inserted separately,
   // since anchor href is set via the "format" argument of:
   //    QTextCursor::insertText(const QString &text, const QTextCharFormat &format)
   // But if no link, and matching colors, then concat message strings with newline in between.
   // This results in less calls to insertText in Console::update(), and much better performance.
-  if (!this->msgBuffer.empty() && msg.loc.isNone() && this->msgBuffer.back().link.isEmpty() &&
-      (getGroupColor(msg.group) == getGroupColor(this->msgBuffer.back().group)) ) {
-    auto& lastmsg = this->msgBuffer.back().message;
-    lastmsg += QChar('\n');
-    lastmsg += QString::fromStdString(msg.str());
+  if (!this->msgBuffer.empty () && msg.loc.isNone () && this->msgBuffer.back ().link.isEmpty () &&
+      (getGroupColor (msg.group) == getGroupColor (this->msgBuffer.back ().group))) {
+    auto &lastmsg = this->msgBuffer.back ().message;
+    lastmsg += QChar ('\n');
+    lastmsg += QString::fromStdString (msg.str ());
   } else {
-    this->msgBuffer.push_back(
-    {
-      QString::fromStdString(msg.str()),
-      (getGroupTextPlain(msg.group) || msg.loc.isNone()) ?
-      QString() :
-      QString("%1,%2").arg(msg.loc.firstLine()).arg(QString::fromStdString(msg.loc.fileName())),
-      msg.group
-    }
-      );
+    this->msgBuffer.push_back (
+      {QString::fromStdString (msg.str ()),
+       (getGroupTextPlain (msg.group) || msg.loc.isNone ()) ? QString () : QString ("%1,%2").arg (msg.loc.firstLine ()).arg (QString::fromStdString (msg.loc.fileName ())),
+       msg.group});
   }
 }
 
 // Slow due to HTML parsing required, only used for initial Console header.
-void Console::addHtml(const QString& html)
-{
-  this->appendHtml(html + QStringLiteral("&nbsp;"));
-  this->appendCursor.movePosition(QTextCursor::End);
-  this->setTextCursor(this->appendCursor);
+void Console::addHtml (const QString &html) {
+  this->appendHtml (html + QStringLiteral ("&nbsp;"));
+  this->appendCursor.movePosition (QTextCursor::End);
+  this->setTextCursor (this->appendCursor);
 }
 
-void Console::setFont(const QString& fontFamily, uint ptSize) {
-  this->document()->setDefaultFont(QFont(fontFamily, ptSize));
+void Console::setFont (const QString &fontFamily, uint ptSize) {
+  this->document ()->setDefaultFont (QFont (fontFamily, ptSize));
 }
 
-void Console::update()
-{
+void Console::update () {
   // Faster to ignore block count until group of messages are done inserting.
-  this->setMaximumBlockCount(0);
-  for (const auto& line : this->msgBuffer) {
+  this->setMaximumBlockCount (0);
+  for (const auto &line : this->msgBuffer) {
     QTextCharFormat charFormat;
-    if (line.group != message_group::NONE && line.group != message_group::Echo) charFormat.setForeground(QBrush(QColor("#000000")));
-    charFormat.setBackground(QBrush(QColor(getGroupColor(line.group).c_str())));
-    if (!line.link.isEmpty()) {
-      charFormat.setAnchor(true);
-      charFormat.setAnchorHref(line.link);
-      charFormat.setFontUnderline(true);
+    if (line.group != message_group::NONE && line.group != message_group::Echo)
+      charFormat.setForeground (QBrush (QColor ("#000000")));
+    charFormat.setBackground (QBrush (QColor (getGroupColor (line.group).c_str ())));
+    if (!line.link.isEmpty ()) {
+      charFormat.setAnchor (true);
+      charFormat.setAnchorHref (line.link);
+      charFormat.setFontUnderline (true);
     }
     // TODO insert timestamp as tooltip? (see #3570)
     //   may have to get rid of concatenation feature of Console::addMessage,
     //   or just live with grouped messages using the same timestamp
     //charFormat.setToolTip(timestr);
 
-    appendCursor.insertBlock();
-    appendCursor.insertText(line.message, charFormat);
+    appendCursor.insertBlock ();
+    appendCursor.insertText (line.message, charFormat);
   }
-  msgBuffer.clear();
-  this->setTextCursor(appendCursor);
-  this->setMaximumBlockCount(GlobalPreferences::inst()->getValue("advanced/consoleMaxLines").toUInt());
+  msgBuffer.clear ();
+  this->setTextCursor (appendCursor);
+  this->setMaximumBlockCount (GlobalPreferences::inst ()->getValue ("advanced/consoleMaxLines").toUInt ());
 }
 
-void Console::actionClearConsole_triggered()
-{
-  this->msgBuffer.clear();
-  this->document()->clear();
-  this->appendCursor = this->textCursor();
+void Console::actionClearConsole_triggered () {
+  this->msgBuffer.clear ();
+  this->document ()->clear ();
+  this->appendCursor = this->textCursor ();
 }
 
-void Console::actionSaveAs_triggered()
-{
-  const auto& text = this->document()->toPlainText();
-  const auto fileName = QFileDialog::getSaveFileName(this, _("Save console content"));
-  QFile file(fileName);
-  if (file.open(QIODevice::ReadWrite)) {
-    QTextStream stream(&file);
+void Console::actionSaveAs_triggered () {
+  const auto &text = this->document ()->toPlainText ();
+  const auto fileName = QFileDialog::getSaveFileName (this, _ ("Save console content"));
+  QFile file (fileName);
+  if (file.open (QIODevice::ReadWrite)) {
+    QTextStream stream (&file);
     stream << text;
-    stream.flush();
-    LOG("Console content saved to '%1$s'.", fileName.toStdString());
+    stream.flush ();
+    LOG ("Console content saved to '%1$s'.", fileName.toStdString ());
   }
 }
 
-void Console::contextMenuEvent(QContextMenuEvent *event)
-{
+void Console::contextMenuEvent (QContextMenuEvent *event) {
   // Clear leaves characterCount() at 1, not 0
-  const bool hasContent = this->document()->characterCount() > 1;
-  this->actionClear->setEnabled(hasContent);
-  this->actionSaveAs->setEnabled(hasContent);
-  QMenu *menu = createStandardContextMenu();
-  menu->insertAction(menu->actions().at(0), this->actionClear);
-  menu->addSeparator();
-  menu->addAction(this->actionSaveAs);
-  menu->exec(event->globalPos());
+  const bool hasContent = this->document ()->characterCount () > 1;
+  this->actionClear->setEnabled (hasContent);
+  this->actionSaveAs->setEnabled (hasContent);
+  QMenu *menu = createStandardContextMenu ();
+  menu->insertAction (menu->actions ().at (0), this->actionClear);
+  menu->addSeparator ();
+  menu->addAction (this->actionSaveAs);
+  menu->exec (event->globalPos ());
   delete menu;
 }
 
-void Console::hyperlinkClicked(const QString& url)
-{
-  if (url.startsWith("http://") || url.startsWith("https://")) {
-    UIUtils::openURL(url);
+void Console::hyperlinkClicked (const QString &url) {
+  if (url.startsWith ("http://") || url.startsWith ("https://")) {
+    UIUtils::openURL (url);
     return;
   }
 
-  const QRegularExpression regEx("^(\\d+),(.*)$");
-  const auto match = regEx.match(url);
-  if (match.hasMatch()) {
-    const auto line = match.captured(1).toInt();
-    const auto file = match.captured(2);
-    const auto info = QFileInfo(file);
-    if (info.isFile()) {
-      if (info.isReadable()) {
-        emit openFile(file, line - 1);
+  const QRegularExpression regEx ("^(\\d+),(.*)$");
+  const auto match = regEx.match (url);
+  if (match.hasMatch ()) {
+    const auto line = match.captured (1).toInt ();
+    const auto file = match.captured (2);
+    const auto info = QFileInfo (file);
+    if (info.isFile ()) {
+      if (info.isReadable ()) {
+        emit openFile (file, line - 1);
       }
     } else {
-      openFile(QString(), line - 1);
+      openFile (QString (), line - 1);
     }
   }
 }
diff --git a/src/gui/Console.h b/src/gui/Console.h
index d822b154e..6485e4b6c 100644
--- a/src/gui/Console.h
+++ b/src/gui/Console.h
@@ -52,38 +52,36 @@ private:
   QTextCursor appendCursor; // keep a cursor always at the end of document.
 
 public:
-  Console(QWidget *parent = nullptr);
+  Console (QWidget *parent = nullptr);
   QString clickedAnchor;
-  void contextMenuEvent(QContextMenuEvent *event) override;
+  void contextMenuEvent (QContextMenuEvent *event) override;
 
-  void mousePressEvent(QMouseEvent *e) override
-  {
-    clickedAnchor = (e->button() & Qt::LeftButton) ? anchorAt(e->pos()) : QString();
-    QPlainTextEdit::mousePressEvent(e);
+  void mousePressEvent (QMouseEvent *e) override {
+    clickedAnchor = (e->button () & Qt::LeftButton) ? anchorAt (e->pos ()) : QString ();
+    QPlainTextEdit::mousePressEvent (e);
   }
 
-  void mouseReleaseEvent(QMouseEvent *e) override
-  {
-    if (e->button() & Qt::LeftButton && !clickedAnchor.isEmpty() &&
-        anchorAt(e->pos()) == clickedAnchor) {
-      emit linkActivated(clickedAnchor);
+  void mouseReleaseEvent (QMouseEvent *e) override {
+    if (e->button () & Qt::LeftButton && !clickedAnchor.isEmpty () &&
+        anchorAt (e->pos ()) == clickedAnchor) {
+      emit linkActivated (clickedAnchor);
     }
 
-    QPlainTextEdit::mouseReleaseEvent(e);
+    QPlainTextEdit::mouseReleaseEvent (e);
   }
 
-  void focusInEvent(QFocusEvent *event) override;
-  void addMessage(const Message& msg);
-  void addHtml(const QString& html);
+  void focusInEvent (QFocusEvent *event) override;
+  void addMessage (const Message &msg);
+  void addHtml (const QString &html);
 
 signals:
-  void linkActivated(QString);
-  void openFile(QString, int);
+  void linkActivated (QString);
+  void openFile (QString, int);
 
 public slots:
-  void actionClearConsole_triggered();
-  void actionSaveAs_triggered();
-  void hyperlinkClicked(const QString& loc);
-  void setFont(const QString& fontFamily, uint ptSize);
-  void update();
+  void actionClearConsole_triggered ();
+  void actionSaveAs_triggered ();
+  void hyperlinkClicked (const QString &loc);
+  void setFont (const QString &fontFamily, uint ptSize);
+  void update ();
 };
diff --git a/src/gui/Dock.cc b/src/gui/Dock.cc
index f05847beb..8f21f95b0 100644
--- a/src/gui/Dock.cc
+++ b/src/gui/Dock.cc
@@ -4,76 +4,69 @@
 #include <QWidget>
 #include "gui/QSettingsCached.h"
 
+Dock::Dock (QWidget *parent)
+  : QDockWidget (parent) {
+  connect (this, &QDockWidget::topLevelChanged, this, &Dock::onTopLevelStatusChanged);
+  connect (this, &QDockWidget::visibilityChanged, this, &Dock::onVisibilityChanged);
 
-Dock::Dock(QWidget *parent) : QDockWidget(parent)
-{
-  connect(this, &QDockWidget::topLevelChanged, this, &Dock::onTopLevelStatusChanged);
-  connect(this, &QDockWidget::visibilityChanged, this, &Dock::onVisibilityChanged);
-
-  dockTitleWidget = new QWidget();
+  dockTitleWidget = new QWidget ();
 }
 
-Dock::~Dock()
-{
+Dock::~Dock () {
   delete dockTitleWidget;
 }
 
-void Dock::disableSettingsUpdate()
-{
+void Dock::disableSettingsUpdate () {
   updateSettings = false;
 }
 
-void Dock::onVisibilityChanged(bool isDockVisible)
-{
+void Dock::onVisibilityChanged (bool isDockVisible) {
   if (updateSettings) {
     QSettingsCached settings;
-    settings.setValue(configKey, !isVisible());
+    settings.setValue (configKey, !isVisible ());
   }
 }
 
-void Dock::setTitleBarVisibility(bool isVisible)
-{
-  setTitleBarWidget(isVisible? dockTitleWidget : nullptr);
+void Dock::setTitleBarVisibility (bool isVisible) {
+  setTitleBarWidget (isVisible ? dockTitleWidget : nullptr);
 }
 
-void Dock::setConfigKey(const QString& configKey)
-{
+void Dock::setConfigKey (const QString &configKey) {
   this->configKey = configKey;
 }
 
-void Dock::updateTitle(){
-  QString title(name);
-  if (isFloating() && !namesuffix.isEmpty()) {
+void Dock::updateTitle () {
+  QString title (name);
+  if (isFloating () && !namesuffix.isEmpty ()) {
     title += " (" + namesuffix + ")";
   }
-  setWindowTitle(title);
+  setWindowTitle (title);
 }
 
-void Dock::setName(const QString& name_) {
+void Dock::setName (const QString &name_) {
   name = name_;
-  updateTitle();
+  updateTitle ();
 }
 
-QString Dock::getName() const {
+QString Dock::getName () const {
   return name;
 }
 
-void Dock::setNameSuffix(const QString& namesuffix_) {
+void Dock::setNameSuffix (const QString &namesuffix_) {
   namesuffix = namesuffix_;
-  updateTitle();
+  updateTitle ();
 }
 
-void Dock::onTopLevelStatusChanged(bool isTopLevel)
-{
+void Dock::onTopLevelStatusChanged (bool isTopLevel) {
   // update the title of the window so it contains the title suffix (in general filename)
   // also update the flags and visibility to provide interactive feedback on the user action
   // while it is moving the dock in topLevel=true state. The purpose of such setting
   // on Qt::Window flag is to allow the dock to be floating behind the main window,
   // something which isn't supported for regular QDockWidgets.
-  Qt::WindowFlags flags = (windowFlags() & ~Qt::WindowType_Mask) | Qt::Window;
+  Qt::WindowFlags flags = (windowFlags () & ~Qt::WindowType_Mask) | Qt::Window;
   if (isTopLevel) {
-    setWindowFlags(flags);
-    show();
+    setWindowFlags (flags);
+    show ();
   }
-  updateTitle();
+  updateTitle ();
 }
diff --git a/src/gui/Dock.h b/src/gui/Dock.h
index 37d14df49..dbdadd53b 100644
--- a/src/gui/Dock.h
+++ b/src/gui/Dock.h
@@ -9,22 +9,22 @@ class Dock : public QDockWidget
   Q_OBJECT
 
 public:
-  Dock(QWidget *parent = nullptr);
-  virtual ~Dock();
+  Dock (QWidget *parent = nullptr);
+  virtual ~Dock ();
 
-  void setConfigKey(const QString& configKey);
-  void disableSettingsUpdate();
+  void setConfigKey (const QString &configKey);
+  void disableSettingsUpdate ();
 
-  void setName(const QString& name_);
-  [[nodiscard]] QString getName() const;
+  void setName (const QString &name_);
+  [[nodiscard]] QString getName () const;
 
-  void setNameSuffix(const QString& namesuffix_);
-  void setTitleBarVisibility(bool isVisible);
-  void updateTitle();
+  void setNameSuffix (const QString &namesuffix_);
+  void setTitleBarVisibility (bool isVisible);
+  void updateTitle ();
 
 public slots:
-  void onVisibilityChanged(bool visible);
-  void onTopLevelStatusChanged(bool);
+  void onVisibilityChanged (bool visible);
+  void onTopLevelStatusChanged (bool);
 
 private:
   QString name;
diff --git a/src/gui/Editor.cc b/src/gui/Editor.cc
index 20e73ad38..4d213c37a 100644
--- a/src/gui/Editor.cc
+++ b/src/gui/Editor.cc
@@ -4,14 +4,15 @@
 #include "gui/Preferences.h"
 #include "gui/QSettingsCached.h"
 
-void EditorInterface::wheelEvent(QWheelEvent *event)
-{
+void EditorInterface::wheelEvent (QWheelEvent *event) {
   QSettingsCached settings;
-  bool wheelzoom_enabled = GlobalPreferences::inst()->getValue("editor/ctrlmousewheelzoom").toBool();
-  if ((event->modifiers() == Qt::ControlModifier) && wheelzoom_enabled) {
-    if (event->angleDelta().y() > 0) zoomIn();
-    else if (event->angleDelta().y() < 0) zoomOut();
+  bool wheelzoom_enabled = GlobalPreferences::inst ()->getValue ("editor/ctrlmousewheelzoom").toBool ();
+  if ((event->modifiers () == Qt::ControlModifier) && wheelzoom_enabled) {
+    if (event->angleDelta ().y () > 0)
+      zoomIn ();
+    else if (event->angleDelta ().y () < 0)
+      zoomOut ();
   } else {
-    QWidget::wheelEvent(event);
+    QWidget::wheelEvent (event);
   }
 }
diff --git a/src/gui/Editor.h b/src/gui/Editor.h
index f91937df3..6f16e386d 100644
--- a/src/gui/Editor.h
+++ b/src/gui/Editor.h
@@ -13,8 +13,7 @@
 #include <string>
 #include <vector>
 
-enum class EditorSelectionIndicatorStatus
-{
+enum class EditorSelectionIndicatorStatus {
   SELECTED,
   IMPACTED
 };
@@ -23,63 +22,70 @@ class EditorInterface : public QWidget
 {
   Q_OBJECT
 public:
-  EditorInterface(QWidget *parent) : QWidget(parent) {}
-  QSize sizeHint() const override { QSize size; return size;}
-  virtual void setInitialSizeHint(const QSize&) { }
-  void wheelEvent(QWheelEvent *) override;
-  virtual QString toPlainText() = 0;
-  virtual QTextDocument *document(){auto *t = new QTextDocument; return t;}
-  virtual QString selectedText() = 0;
-  virtual int updateFindIndicators(const QString& findText, bool visibility = true) = 0;
-  virtual bool find(const QString&, bool findNext = false, bool findBackwards = false) = 0;
-  virtual void replaceSelectedText(const QString& newText) = 0;
-  virtual void replaceAll(const QString& findText, const QString& replaceText) = 0;
-  virtual QStringList colorSchemes() = 0;
-  virtual bool canUndo() = 0;
-  virtual void addTemplate() = 0;
-  virtual void resetHighlighting() = 0;
-  virtual void setIndicator(const std::vector<IndicatorData>& indicatorData) = 0;
-  virtual QMenu *createStandardContextMenu() = 0;
-  virtual QPoint mapToGlobal(const QPoint&) = 0;
-  virtual void setCursorPosition(int /*line*/, int /*col*/) {}
-  virtual void setFocus() = 0;
+  EditorInterface (QWidget *parent)
+    : QWidget (parent) {}
+  QSize sizeHint () const override {
+    QSize size;
+    return size;
+  }
+  virtual void setInitialSizeHint (const QSize &) {}
+  void wheelEvent (QWheelEvent *) override;
+  virtual QString toPlainText () = 0;
+  virtual QTextDocument *document () {
+    auto *t = new QTextDocument;
+    return t;
+  }
+  virtual QString selectedText () = 0;
+  virtual int updateFindIndicators (const QString &findText, bool visibility = true) = 0;
+  virtual bool find (const QString &, bool findNext = false, bool findBackwards = false) = 0;
+  virtual void replaceSelectedText (const QString &newText) = 0;
+  virtual void replaceAll (const QString &findText, const QString &replaceText) = 0;
+  virtual QStringList colorSchemes () = 0;
+  virtual bool canUndo () = 0;
+  virtual void addTemplate () = 0;
+  virtual void resetHighlighting () = 0;
+  virtual void setIndicator (const std::vector<IndicatorData> &indicatorData) = 0;
+  virtual QMenu *createStandardContextMenu () = 0;
+  virtual QPoint mapToGlobal (const QPoint &) = 0;
+  virtual void setCursorPosition (int /*line*/, int /*col*/) {}
+  virtual void setFocus () = 0;
 
 signals:
-  void contentsChanged();
-  void modificationChanged(EditorInterface *);
-  void showContextMenuEvent(const QPoint& pos);
-  void focusIn();
-  void escapePressed();
+  void contentsChanged ();
+  void modificationChanged (EditorInterface *);
+  void showContextMenuEvent (const QPoint &pos);
+  void focusIn ();
+  void escapePressed ();
 
 public slots:
-  virtual void zoomIn() = 0;
-  virtual void zoomOut() = 0;
-  virtual void setContentModified(bool) = 0;
-  virtual bool isContentModified() = 0;
-  virtual void indentSelection() = 0;
-  virtual void unindentSelection() = 0;
-  virtual void commentSelection() = 0;
-  virtual void uncommentSelection() = 0;
-  virtual void setPlainText(const QString&) = 0;
-  virtual void setSelectionIndicatorStatus(EditorSelectionIndicatorStatus status, int level, int lineFrom, int colFrom, int lineTo, int colTo) = 0;
-  virtual void clearAllSelectionIndicators() = 0;
-  virtual void highlightError(int) = 0;
-  virtual void unhighlightLastError() = 0;
-  virtual void setHighlightScheme(const QString&) = 0;
-  virtual void insert(const QString&) = 0;
-  virtual void setText(const QString&) = 0;
-  virtual void undo() = 0;
-  virtual void redo() = 0;
-  virtual void cut() = 0;
-  virtual void copy() = 0;
-  virtual void paste() = 0;
-  virtual void initFont(const QString&, uint) = 0;
-  virtual void displayTemplates() = 0;
-  virtual void foldUnfold() = 0;
-  virtual void toggleBookmark() = 0;
-  virtual void nextBookmark() = 0;
-  virtual void prevBookmark() = 0;
-  virtual void jumpToNextError() = 0;
+  virtual void zoomIn () = 0;
+  virtual void zoomOut () = 0;
+  virtual void setContentModified (bool) = 0;
+  virtual bool isContentModified () = 0;
+  virtual void indentSelection () = 0;
+  virtual void unindentSelection () = 0;
+  virtual void commentSelection () = 0;
+  virtual void uncommentSelection () = 0;
+  virtual void setPlainText (const QString &) = 0;
+  virtual void setSelectionIndicatorStatus (EditorSelectionIndicatorStatus status, int level, int lineFrom, int colFrom, int lineTo, int colTo) = 0;
+  virtual void clearAllSelectionIndicators () = 0;
+  virtual void highlightError (int) = 0;
+  virtual void unhighlightLastError () = 0;
+  virtual void setHighlightScheme (const QString &) = 0;
+  virtual void insert (const QString &) = 0;
+  virtual void setText (const QString &) = 0;
+  virtual void undo () = 0;
+  virtual void redo () = 0;
+  virtual void cut () = 0;
+  virtual void copy () = 0;
+  virtual void paste () = 0;
+  virtual void initFont (const QString &, uint) = 0;
+  virtual void displayTemplates () = 0;
+  virtual void foldUnfold () = 0;
+  virtual void toggleBookmark () = 0;
+  virtual void nextBookmark () = 0;
+  virtual void prevBookmark () = 0;
+  virtual void jumpToNextError () = 0;
 
 private:
   QSize initialSizeHint;
diff --git a/src/gui/ErrorLog.cc b/src/gui/ErrorLog.cc
index 962f0b57b..890baa443 100644
--- a/src/gui/ErrorLog.cc
+++ b/src/gui/ErrorLog.cc
@@ -10,148 +10,141 @@
 #include <QWidget>
 #include <filesystem>
 
-ErrorLog::ErrorLog(QWidget *parent) : QWidget(parent)
-{
-  setupUi(this);
-  initGUI();
+ErrorLog::ErrorLog (QWidget *parent)
+  : QWidget (parent) {
+  setupUi (this);
+  initGUI ();
 }
 
-void ErrorLog::initGUI()
-{
+void ErrorLog::initGUI () {
   row = 0;
-  QList<QString> labels = QList<QString>() << QString("Group") << QString("File") << QString("Line") << QString("Info");
-
-  const int numColumns = labels.count();
-  this->errorLogModel = new QStandardItemModel(row, numColumns, logTable);
-
-  errorLogModel->setHorizontalHeaderLabels(labels);
-  logTable->verticalHeader()->hide();
-  logTable->setModel(errorLogModel);
-  logTable->setSelectionMode(QAbstractItemView::SelectionMode::SingleSelection);
-  logTable->setColumnWidth(errorLog_column::group, 80);
-  logTable->setColumnWidth(errorLog_column::file, 200);
-  logTable->setColumnWidth(errorLog_column::lineNo, 80);
-  logTable->addAction(actionRowSelected);
+  QList<QString> labels = QList<QString> () << QString ("Group") << QString ("File") << QString ("Line") << QString ("Info");
+
+  const int numColumns = labels.count ();
+  this->errorLogModel = new QStandardItemModel (row, numColumns, logTable);
+
+  errorLogModel->setHorizontalHeaderLabels (labels);
+  logTable->verticalHeader ()->hide ();
+  logTable->setModel (errorLogModel);
+  logTable->setSelectionMode (QAbstractItemView::SelectionMode::SingleSelection);
+  logTable->setColumnWidth (errorLog_column::group, 80);
+  logTable->setColumnWidth (errorLog_column::file, 200);
+  logTable->setColumnWidth (errorLog_column::lineNo, 80);
+  logTable->addAction (actionRowSelected);
   //last column will stretch itself
 
-  connect(logTable->horizontalHeader(), &QHeaderView::sectionResized, this, &ErrorLog::onSectionResized);
+  connect (logTable->horizontalHeader (), &QHeaderView::sectionResized, this, &ErrorLog::onSectionResized);
 }
 
-void ErrorLog::toErrorLog(const Message& logMsg)
-{
-  lastMessages.push_back(logMsg);
-  QString currGroup = errorLogComboBox->currentText();
+void ErrorLog::toErrorLog (const Message &logMsg) {
+  lastMessages.push_back (logMsg);
+  QString currGroup = errorLogComboBox->currentText ();
 
   //handle combobox
-  if (errorLogComboBox->currentIndex() == 0);
-  else if (currGroup.toStdString() != getGroupName(logMsg.group)) return;
+  if (errorLogComboBox->currentIndex () == 0)
+    ;
+  else if (currGroup.toStdString () != getGroupName (logMsg.group))
+    return;
 
-  showtheErrorInGUI(logMsg);
+  showtheErrorInGUI (logMsg);
 }
 
-void ErrorLog::showtheErrorInGUI(const Message& logMsg)
-{
-  auto *groupName = new QStandardItem(QString::fromStdString(getGroupName(logMsg.group)));
-  groupName->setEditable(false);
+void ErrorLog::showtheErrorInGUI (const Message &logMsg) {
+  auto *groupName = new QStandardItem (QString::fromStdString (getGroupName (logMsg.group)));
+  groupName->setEditable (false);
 
-  if (logMsg.group == message_group::Error) groupName->setForeground(QColor::fromRgb(255, 0, 0)); //make this item red.
-  else if (logMsg.group == message_group::Warning) groupName->setForeground(QColor::fromRgb(252, 211, 3)); //make this item yellow
+  if (logMsg.group == message_group::Error)
+    groupName->setForeground (QColor::fromRgb (255, 0, 0)); //make this item red.
+  else if (logMsg.group == message_group::Warning)
+    groupName->setForeground (QColor::fromRgb (252, 211, 3)); //make this item yellow
 
-  errorLogModel->setItem(row, errorLog_column::group, groupName);
+  errorLogModel->setItem (row, errorLog_column::group, groupName);
 
   QStandardItem *fileName;
   QStandardItem *lineNo;
-  if (!logMsg.loc.isNone()) {
-    const auto& filePath = logMsg.loc.filePath();
-    if (is_regular_file(filePath)) {
-      const auto path = QString::fromStdString(filePath.generic_string());
-      fileName = new QStandardItem(QString::fromStdString(filePath.filename().generic_string()));
-      fileName->setToolTip(path);
-      fileName->setData(path, Qt::UserRole);
+  if (!logMsg.loc.isNone ()) {
+    const auto &filePath = logMsg.loc.filePath ();
+    if (is_regular_file (filePath)) {
+      const auto path = QString::fromStdString (filePath.generic_string ());
+      fileName = new QStandardItem (QString::fromStdString (filePath.filename ().generic_string ()));
+      fileName->setToolTip (path);
+      fileName->setData (path, Qt::UserRole);
     } else {
-      fileName = new QStandardItem(QString());
+      fileName = new QStandardItem (QString ());
     }
-    lineNo = new QStandardItem(QString::number(logMsg.loc.firstLine()));
+    lineNo = new QStandardItem (QString::number (logMsg.loc.firstLine ()));
   } else {
-    fileName = new QStandardItem(QString());
-    lineNo = new QStandardItem(QString());
+    fileName = new QStandardItem (QString ());
+    lineNo = new QStandardItem (QString ());
   }
-  fileName->setEditable(false);
-  lineNo->setEditable(false);
-  lineNo->setTextAlignment(Qt::AlignVCenter | Qt::AlignRight);
-  errorLogModel->setItem(row, errorLog_column::file, fileName);
-  errorLogModel->setItem(row, errorLog_column::lineNo, lineNo);
+  fileName->setEditable (false);
+  lineNo->setEditable (false);
+  lineNo->setTextAlignment (Qt::AlignVCenter | Qt::AlignRight);
+  errorLogModel->setItem (row, errorLog_column::file, fileName);
+  errorLogModel->setItem (row, errorLog_column::lineNo, lineNo);
 
-  auto *msg = new QStandardItem(QString::fromStdString(logMsg.msg));
-  msg->setEditable(false);
-  errorLogModel->setItem(row, errorLog_column::message, msg);
-  errorLogModel->setRowCount(++row);
+  auto *msg = new QStandardItem (QString::fromStdString (logMsg.msg));
+  msg->setEditable (false);
+  errorLogModel->setItem (row, errorLog_column::message, msg);
+  errorLogModel->setRowCount (++row);
 
-  this->resize();
+  this->resize ();
 
-  if (!logTable->selectionModel()->hasSelection()) {
-    logTable->selectRow(0);
+  if (!logTable->selectionModel ()->hasSelection ()) {
+    logTable->selectRow (0);
   }
 }
 
-void ErrorLog::resize()
-{
-  logTable->resizeRowsToContents();
+void ErrorLog::resize () {
+  logTable->resizeRowsToContents ();
 }
 
-void ErrorLog::onSectionResized(int /*logicalIndex*/, int /*oldSize*/, int /*newSize*/){
-  this->resize();
+void ErrorLog::onSectionResized (int /*logicalIndex*/, int /*oldSize*/, int /*newSize*/) {
+  this->resize ();
 }
 
-void ErrorLog::resizeEvent(QResizeEvent *event)
-{
-  QWidget::resizeEvent(event);
-  this->resize();
+void ErrorLog::resizeEvent (QResizeEvent *event) {
+  QWidget::resizeEvent (event);
+  this->resize ();
 }
 
-void ErrorLog::clearModel()
-{
-  errorLogModel->clear();
-  initGUI();
-  lastMessages.clear();
+void ErrorLog::clearModel () {
+  errorLogModel->clear ();
+  initGUI ();
+  lastMessages.clear ();
 }
 
-int ErrorLog::getLine(int row, int col)
-{
-  return logTable->model()->index(row, col).data().toInt();
+int ErrorLog::getLine (int row, int col) {
+  return logTable->model ()->index (row, col).data ().toInt ();
 }
 
-void ErrorLog::on_errorLogComboBox_currentTextChanged(const QString& group)
-{
-  errorLogModel->clear();
-  initGUI();
-  for (auto& lastMessage : lastMessages) {
-    if (group == QString::fromStdString("All") ||
-        group == QString::fromStdString(getGroupName(lastMessage.group))) {
-      showtheErrorInGUI(lastMessage);
+void ErrorLog::on_errorLogComboBox_currentTextChanged (const QString &group) {
+  errorLogModel->clear ();
+  initGUI ();
+  for (auto &lastMessage : lastMessages) {
+    if (group == QString::fromStdString ("All") ||
+        group == QString::fromStdString (getGroupName (lastMessage.group))) {
+      showtheErrorInGUI (lastMessage);
     }
   }
 }
 
-void ErrorLog::on_logTable_doubleClicked(const QModelIndex& index)
-{
-  onIndexSelected(index);
+void ErrorLog::on_logTable_doubleClicked (const QModelIndex &index) {
+  onIndexSelected (index);
 }
 
-void ErrorLog::on_actionRowSelected_triggered(bool)
-{
-  const auto indexes = logTable->selectionModel()->selectedRows(0);
-  if (indexes.size() == 1) {
-    onIndexSelected(indexes.first());
+void ErrorLog::on_actionRowSelected_triggered (bool) {
+  const auto indexes = logTable->selectionModel ()->selectedRows (0);
+  if (indexes.size () == 1) {
+    onIndexSelected (indexes.first ());
   }
 }
 
-void ErrorLog::onIndexSelected(const QModelIndex& index)
-{
-  if (index.isValid()) {
-    const int r = index.row();
-    const int line = getLine(r, errorLog_column::lineNo);
-    const auto path = logTable->model()->index(r, errorLog_column::file).data(Qt::UserRole).toString();
-    emit openFile(path, line - 1);
+void ErrorLog::onIndexSelected (const QModelIndex &index) {
+  if (index.isValid ()) {
+    const int r = index.row ();
+    const int line = getLine (r, errorLog_column::lineNo);
+    const auto path = logTable->model ()->index (r, errorLog_column::file).data (Qt::UserRole).toString ();
+    emit openFile (path, line - 1);
   }
 }
diff --git a/src/gui/ErrorLog.h b/src/gui/ErrorLog.h
index 485ae90a9..56115419b 100644
--- a/src/gui/ErrorLog.h
+++ b/src/gui/ErrorLog.h
@@ -11,7 +11,10 @@
 #include <QStandardItemModel>
 
 enum errorLog_column {
-  group = 0, file, lineNo, message
+  group = 0,
+  file,
+  lineNo,
+  message
 };
 
 class ErrorLog : public QWidget, public Ui::errorLogWidget
@@ -19,37 +22,37 @@ class ErrorLog : public QWidget, public Ui::errorLogWidget
   Q_OBJECT
 
 public:
-  ErrorLog(QWidget *parent = nullptr);
-  ErrorLog(const ErrorLog& source) = delete;
-  ErrorLog(ErrorLog&& source) = delete;
-  ErrorLog& operator=(const ErrorLog& source) = delete;
-  ErrorLog& operator=(ErrorLog&& source) = delete;
-  ~ErrorLog() override = default;
-  void initGUI();
-  void toErrorLog(const Message& logMsg);
-  void showtheErrorInGUI(const Message& logMsg);
-  void clearModel();
-  int getLine(int row, int col);
+  ErrorLog (QWidget *parent = nullptr);
+  ErrorLog (const ErrorLog &source) = delete;
+  ErrorLog (ErrorLog &&source) = delete;
+  ErrorLog &operator= (const ErrorLog &source) = delete;
+  ErrorLog &operator= (ErrorLog &&source) = delete;
+  ~ErrorLog () override = default;
+  void initGUI ();
+  void toErrorLog (const Message &logMsg);
+  void showtheErrorInGUI (const Message &logMsg);
+  void clearModel ();
+  int getLine (int row, int col);
   QStandardItemModel *errorLogModel;
   QHash<QString, bool> logsMap;
   int row;
 
 protected:
-  void resizeEvent(QResizeEvent *event) override;
+  void resizeEvent (QResizeEvent *event) override;
 
 private:
-  void onIndexSelected(const QModelIndex& index);
-  void resize();
+  void onIndexSelected (const QModelIndex &index);
+  void resize ();
 
 private:
   std::list<Message> lastMessages;
 
 signals:
-  void openFile(const QString, int);
+  void openFile (const QString, int);
 
 private slots:
-  void on_logTable_doubleClicked(const QModelIndex& index);
-  void on_errorLogComboBox_currentTextChanged(const QString& arg1);
-  void on_actionRowSelected_triggered(bool);
-  void onSectionResized(int, int, int);
+  void on_logTable_doubleClicked (const QModelIndex &index);
+  void on_errorLogComboBox_currentTextChanged (const QString &arg1);
+  void on_actionRowSelected_triggered (bool);
+  void onSectionResized (int, int, int);
 };
diff --git a/src/gui/EventFilter.h b/src/gui/EventFilter.h
index d172b7545..94f4ea267 100644
--- a/src/gui/EventFilter.h
+++ b/src/gui/EventFilter.h
@@ -10,25 +10,27 @@ class SCADEventFilter : public QObject
   Q_OBJECT;
 
 public:
-  SCADEventFilter(QObject *parent) : QObject(parent) {}
+  SCADEventFilter (QObject *parent)
+    : QObject (parent) {}
+
 protected:
-  bool eventFilter(QObject *obj, QEvent *event) override {
+  bool eventFilter (QObject *obj, QEvent *event) override {
     // Handle Apple event for opening files, only available on OS X
-    if (event->type() == QEvent::FileOpen) {
-      QFileOpenEvent *foe = static_cast<QFileOpenEvent *>(event);
-      const QString& filename = foe->file();
-      if (LaunchingScreen *ls = LaunchingScreen::getDialog()) {
+    if (event->type () == QEvent::FileOpen) {
+      QFileOpenEvent *foe = static_cast<QFileOpenEvent *> (event);
+      const QString &filename = foe->file ();
+      if (LaunchingScreen *ls = LaunchingScreen::getDialog ()) {
         // We need to invoke the method since, apparently, we receive
         // this event in another thread.
-        QMetaObject::invokeMethod(ls, "openFile", Qt::QueuedConnection,
-                                  Q_ARG(QString, filename));
+        QMetaObject::invokeMethod (ls, "openFile", Qt::QueuedConnection,
+                                   Q_ARG (QString, filename));
       } else {
-        scadApp->requestOpenFile(filename);
+        scadApp->requestOpenFile (filename);
       }
       return true;
     } else {
       // standard event processing
-      return QObject::eventFilter(obj, event);
+      return QObject::eventFilter (obj, event);
     }
   }
 };
diff --git a/src/gui/Export3mfDialog.cc b/src/gui/Export3mfDialog.cc
index ed3392975..6e9fbbbf8 100644
--- a/src/gui/Export3mfDialog.cc
+++ b/src/gui/Export3mfDialog.cc
@@ -44,81 +44,75 @@ using S = Settings::SettingsExport3mf;
 using SEBool = Settings::SettingsEntryBool;
 using SEString = Settings::SettingsEntryString;
 
-Export3mfDialog::Export3mfDialog()
-{
-  setupUi(this);
-  this->checkBoxAlwaysShowDialog->setChecked(S::export3mfAlwaysShowDialog.value());
-  initButtonGroup(this->buttonGroupColors, S::export3mfColorMode);
-  initButtonGroup(this->buttonGroupUnit, S::export3mfUnit);
-  this->color = QColor(QString::fromStdString(S::export3mfColor.value()));
-  this->labelColorsSelected->setStyleSheet(UIUtils::getBackgroundColorStyleSheet(this->color));
-  this->spinBoxDecimalPrecision->setValue(S::export3mfDecimalPrecision.value());
-  initComboBox(this->comboBoxMaterialType, S::export3mfMaterialType);
+Export3mfDialog::Export3mfDialog () {
+  setupUi (this);
+  this->checkBoxAlwaysShowDialog->setChecked (S::export3mfAlwaysShowDialog.value ());
+  initButtonGroup (this->buttonGroupColors, S::export3mfColorMode);
+  initButtonGroup (this->buttonGroupUnit, S::export3mfUnit);
+  this->color = QColor (QString::fromStdString (S::export3mfColor.value ()));
+  this->labelColorsSelected->setStyleSheet (UIUtils::getBackgroundColorStyleSheet (this->color));
+  this->spinBoxDecimalPrecision->setValue (S::export3mfDecimalPrecision.value ());
+  initComboBox (this->comboBoxMaterialType, S::export3mfMaterialType);
 
-  groupMetaData->setChecked(S::export3mfAddMetaData.value());
-  initMetaData(nullptr, this->lineEditMetaDataTitle, nullptr, S::export3mfMetaDataTitle);
-  initMetaData(this->checkBoxMetaDataDesigner, this->lineEditMetaDataDesigner, &S::export3mfAddMetaDataDesigner, S::export3mfMetaDataDesigner);
-  initMetaData(this->checkBoxMetaDataDescription, this->lineEditMetaDataDescription, &S::export3mfAddMetaDataDescription, S::export3mfMetaDataDescription);
-  initMetaData(this->checkBoxMetaDataCopyright, this->lineEditMetaDataCopyright, &S::export3mfAddMetaDataCopyright, S::export3mfMetaDataCopyright);
-  initMetaData(this->checkBoxMetaDataLicenseTerms, this->lineEditMetaDataLicenseTerms, &S::export3mfAddMetaDataLicenseTerms, S::export3mfMetaDataLicenseTerms);
-  initMetaData(this->checkBoxMetaDataRating, this->lineEditMetaDataRating, &S::export3mfAddMetaDataRating, S::export3mfMetaDataRating);
+  groupMetaData->setChecked (S::export3mfAddMetaData.value ());
+  initMetaData (nullptr, this->lineEditMetaDataTitle, nullptr, S::export3mfMetaDataTitle);
+  initMetaData (this->checkBoxMetaDataDesigner, this->lineEditMetaDataDesigner, &S::export3mfAddMetaDataDesigner, S::export3mfMetaDataDesigner);
+  initMetaData (this->checkBoxMetaDataDescription, this->lineEditMetaDataDescription, &S::export3mfAddMetaDataDescription, S::export3mfMetaDataDescription);
+  initMetaData (this->checkBoxMetaDataCopyright, this->lineEditMetaDataCopyright, &S::export3mfAddMetaDataCopyright, S::export3mfMetaDataCopyright);
+  initMetaData (this->checkBoxMetaDataLicenseTerms, this->lineEditMetaDataLicenseTerms, &S::export3mfAddMetaDataLicenseTerms, S::export3mfMetaDataLicenseTerms);
+  initMetaData (this->checkBoxMetaDataRating, this->lineEditMetaDataRating, &S::export3mfAddMetaDataRating, S::export3mfMetaDataRating);
 
-  const auto library_version = get_lib3mf_version();
-  if (library_version.compare(0, 2, "1.") == 0) {
-    this->spinBoxDecimalPrecision->setEnabled(false);
-    this->toolButtonDecimalPrecisionReset->setEnabled(false);
-    this->labelDecimalPrecision->setEnabled(false);
-    this->spinBoxDecimalPrecision->setToolTip(_("This OpenSCAD build uses lib3mf version 1. Setting the decimal precision for export needs version 2 or later."));
-    this->toolButtonDecimalPrecisionReset->setToolTip("");
+  const auto library_version = get_lib3mf_version ();
+  if (library_version.compare (0, 2, "1.") == 0) {
+    this->spinBoxDecimalPrecision->setEnabled (false);
+    this->toolButtonDecimalPrecisionReset->setEnabled (false);
+    this->labelDecimalPrecision->setEnabled (false);
+    this->spinBoxDecimalPrecision->setToolTip (_ ("This OpenSCAD build uses lib3mf version 1. Setting the decimal precision for export needs version 2 or later."));
+    this->toolButtonDecimalPrecisionReset->setToolTip ("");
   }
 }
 
-void Export3mfDialog::updateColor(const QColor& color)
-{
+void Export3mfDialog::updateColor (const QColor &color) {
   this->color = color;
-  this->labelColorsSelected->setStyleSheet(UIUtils::getBackgroundColorStyleSheet(this->color));
+  this->labelColorsSelected->setStyleSheet (UIUtils::getBackgroundColorStyleSheet (this->color));
 }
 
-int Export3mfDialog::exec()
-{
-  bool showDialog = this->checkBoxAlwaysShowDialog->isChecked();
-  if ((QApplication::keyboardModifiers() & Qt::ShiftModifier) != 0) {
+int Export3mfDialog::exec () {
+  bool showDialog = this->checkBoxAlwaysShowDialog->isChecked ();
+  if ((QApplication::keyboardModifiers () & Qt::ShiftModifier) != 0) {
     showDialog = true;
   }
 
-  const auto result = showDialog ? QDialog::exec() : QDialog::Accepted;
+  const auto result = showDialog ? QDialog::exec () : QDialog::Accepted;
 
   if (result == QDialog::Accepted) {
-    S::export3mfAlwaysShowDialog.setValue(this->checkBoxAlwaysShowDialog->isChecked());
-    applyButtonGroup(this->buttonGroupColors, S::export3mfColorMode);
-    applyButtonGroup(this->buttonGroupUnit, S::export3mfUnit);
-    S::export3mfColor.setValue(this->color.toRgb().name().toStdString());
-    S::export3mfMaterialType.setIndex(this->comboBoxMaterialType->currentIndex());
-    S::export3mfDecimalPrecision.setValue(this->spinBoxDecimalPrecision->value());
-    S::export3mfAddMetaData.setValue(this->groupMetaData->isChecked());
-    applyMetaData(nullptr, this->lineEditMetaDataTitle, nullptr, S::export3mfMetaDataTitle);
-    applyMetaData(this->checkBoxMetaDataDesigner, this->lineEditMetaDataDesigner, &S::export3mfAddMetaDataDesigner, S::export3mfMetaDataDesigner);
-    applyMetaData(this->checkBoxMetaDataDescription, this->lineEditMetaDataDescription, &S::export3mfAddMetaDataDescription, S::export3mfMetaDataDescription);
-    applyMetaData(this->checkBoxMetaDataCopyright, this->lineEditMetaDataCopyright, &S::export3mfAddMetaDataCopyright, S::export3mfMetaDataCopyright);
-    applyMetaData(this->checkBoxMetaDataLicenseTerms, this->lineEditMetaDataLicenseTerms, &S::export3mfAddMetaDataLicenseTerms, S::export3mfMetaDataLicenseTerms);
-    applyMetaData(this->checkBoxMetaDataRating, this->lineEditMetaDataRating, &S::export3mfAddMetaDataRating, S::export3mfMetaDataRating);
-    Settings::Settings::visit(SettingsWriter());
+    S::export3mfAlwaysShowDialog.setValue (this->checkBoxAlwaysShowDialog->isChecked ());
+    applyButtonGroup (this->buttonGroupColors, S::export3mfColorMode);
+    applyButtonGroup (this->buttonGroupUnit, S::export3mfUnit);
+    S::export3mfColor.setValue (this->color.toRgb ().name ().toStdString ());
+    S::export3mfMaterialType.setIndex (this->comboBoxMaterialType->currentIndex ());
+    S::export3mfDecimalPrecision.setValue (this->spinBoxDecimalPrecision->value ());
+    S::export3mfAddMetaData.setValue (this->groupMetaData->isChecked ());
+    applyMetaData (nullptr, this->lineEditMetaDataTitle, nullptr, S::export3mfMetaDataTitle);
+    applyMetaData (this->checkBoxMetaDataDesigner, this->lineEditMetaDataDesigner, &S::export3mfAddMetaDataDesigner, S::export3mfMetaDataDesigner);
+    applyMetaData (this->checkBoxMetaDataDescription, this->lineEditMetaDataDescription, &S::export3mfAddMetaDataDescription, S::export3mfMetaDataDescription);
+    applyMetaData (this->checkBoxMetaDataCopyright, this->lineEditMetaDataCopyright, &S::export3mfAddMetaDataCopyright, S::export3mfMetaDataCopyright);
+    applyMetaData (this->checkBoxMetaDataLicenseTerms, this->lineEditMetaDataLicenseTerms, &S::export3mfAddMetaDataLicenseTerms, S::export3mfMetaDataLicenseTerms);
+    applyMetaData (this->checkBoxMetaDataRating, this->lineEditMetaDataRating, &S::export3mfAddMetaDataRating, S::export3mfMetaDataRating);
+    Settings::Settings::visit (SettingsWriter ());
   }
 
   return result;
 }
 
-void Export3mfDialog::on_toolButtonColorsSelected_clicked()
-{
-  updateColor(QColorDialog::getColor(this->color));
+void Export3mfDialog::on_toolButtonColorsSelected_clicked () {
+  updateColor (QColorDialog::getColor (this->color));
 }
 
-void Export3mfDialog::on_toolButtonColorsSelectedReset_clicked()
-{
-  updateColor(QColor(QString::fromStdString(S::export3mfColor.defaultValue())));
+void Export3mfDialog::on_toolButtonColorsSelectedReset_clicked () {
+  updateColor (QColor (QString::fromStdString (S::export3mfColor.defaultValue ())));
 }
 
-void Export3mfDialog::on_toolButtonDecimalPrecisionReset_clicked()
-{
-  this->spinBoxDecimalPrecision->setValue(S::export3mfDecimalPrecision.defaultValue());
+void Export3mfDialog::on_toolButtonDecimalPrecisionReset_clicked () {
+  this->spinBoxDecimalPrecision->setValue (S::export3mfDecimalPrecision.defaultValue ());
 }
diff --git a/src/gui/Export3mfDialog.h b/src/gui/Export3mfDialog.h
index d579aeeee..89070e71c 100644
--- a/src/gui/Export3mfDialog.h
+++ b/src/gui/Export3mfDialog.h
@@ -43,21 +43,21 @@ class Export3mfDialog : public QDialog, public Ui::Export3mfDialog, public InitC
   Q_OBJECT;
 
 public:
-  Export3mfDialog();
+  Export3mfDialog ();
 
-  int exec() override;
+  int exec () override;
 
-  std::shared_ptr<const Export3mfOptions> getOptions() const {
-    return Export3mfOptions::fromSettings();
+  std::shared_ptr<const Export3mfOptions> getOptions () const {
+    return Export3mfOptions::fromSettings ();
   }
 
 private slots:
-  void on_toolButtonColorsSelected_clicked();
-  void on_toolButtonColorsSelectedReset_clicked();
-  void on_toolButtonDecimalPrecisionReset_clicked();
+  void on_toolButtonColorsSelected_clicked ();
+  void on_toolButtonColorsSelectedReset_clicked ();
+  void on_toolButtonDecimalPrecisionReset_clicked ();
 
 private:
-  void updateColor(const QColor& color);
+  void updateColor (const QColor &color);
 
   QColor color;
 };
diff --git a/src/gui/ExportPdfDialog.cc b/src/gui/ExportPdfDialog.cc
index 859525f26..ae183d65a 100644
--- a/src/gui/ExportPdfDialog.cc
+++ b/src/gui/ExportPdfDialog.cc
@@ -37,159 +37,145 @@
 
 using S = Settings::SettingsExportPdf;
 
-ExportPdfDialog::ExportPdfDialog()
-{
-  setupUi(this);
-  this->checkBoxAlwaysShowDialog->setChecked(S::exportPdfAlwaysShowDialog.value());
+ExportPdfDialog::ExportPdfDialog () {
+  setupUi (this);
+  this->checkBoxAlwaysShowDialog->setChecked (S::exportPdfAlwaysShowDialog.value ());
 
-  initButtonGroup(this->buttonGroupPaperSize, S::exportPdfPaperSize);
-  initButtonGroup(this->buttonGroupOrientation, S::exportPdfOrientation);
+  initButtonGroup (this->buttonGroupPaperSize, S::exportPdfPaperSize);
+  initButtonGroup (this->buttonGroupOrientation, S::exportPdfOrientation);
 
   // Get current settings or defaults
-  this->checkBoxShowFilename->setChecked(S::exportPdfShowFilename.value());
-  this->groupScale->setChecked(S::exportPdfShowScale.value());
-  this->checkBoxShowScaleMessage->setChecked(S::exportPdfShowScaleMessage.value());
-  this->groupGrid->setChecked(S::exportPdfShowGrid.value());
+  this->checkBoxShowFilename->setChecked (S::exportPdfShowFilename.value ());
+  this->groupScale->setChecked (S::exportPdfShowScale.value ());
+  this->checkBoxShowScaleMessage->setChecked (S::exportPdfShowScaleMessage.value ());
+  this->groupGrid->setChecked (S::exportPdfShowGrid.value ());
 
   // Initialize grid size from settings
-  const auto gridSize = S::exportPdfGridSize.value();
-  for (auto *button : buttonGroupGridSize->buttons()) {
-    if (button->property("_selected_value").toDouble() == gridSize) {
-      button->setChecked(true);
+  const auto gridSize = S::exportPdfGridSize.value ();
+  for (auto *button : buttonGroupGridSize->buttons ()) {
+    if (button->property ("_selected_value").toDouble () == gridSize) {
+      button->setChecked (true);
       break;
     }
   }
 
   // Fill settings
-  this->checkBoxEnableFill->setChecked(S::exportPdfFill.value());
-  this->fillColor = QColor(QString::fromStdString(S::exportPdfFillColor.value()));
-  updateFillColor(this->fillColor);
-  updateFillControlsEnabled();
+  this->checkBoxEnableFill->setChecked (S::exportPdfFill.value ());
+  this->fillColor = QColor (QString::fromStdString (S::exportPdfFillColor.value ()));
+  updateFillColor (this->fillColor);
+  updateFillControlsEnabled ();
 
   // Stroke settings
-  this->checkBoxEnableStroke->setChecked(S::exportPdfStroke.value());
-  this->strokeColor = QColor(QString::fromStdString(S::exportPdfStrokeColor.value()));
-  this->doubleSpinBoxStrokeWidth->setValue(S::exportPdfStrokeWidth.value());
-  updateStrokeColor(this->strokeColor);
-  updateStrokeControlsEnabled();
-
-  groupMetaData->setChecked(S::exportPdfAddMetaData.value());
-  initMetaData(nullptr, this->lineEditMetaDataTitle, nullptr, S::exportPdfMetaDataTitle);
-  initMetaData(this->checkBoxMetaDataAuthor, this->lineEditMetaDataAuthor, &S::exportPdfAddMetaDataAuthor, S::exportPdfMetaDataAuthor);
-  initMetaData(this->checkBoxMetaDataSubject, this->lineEditMetaDataSubject, &S::exportPdfAddMetaDataSubject, S::exportPdfMetaDataSubject);
-  initMetaData(this->checkBoxMetaDataKeywords, this->lineEditMetaDataKeywords, &S::exportPdfAddMetaDataKeywords, S::exportPdfMetaDataKeywords);
+  this->checkBoxEnableStroke->setChecked (S::exportPdfStroke.value ());
+  this->strokeColor = QColor (QString::fromStdString (S::exportPdfStrokeColor.value ()));
+  this->doubleSpinBoxStrokeWidth->setValue (S::exportPdfStrokeWidth.value ());
+  updateStrokeColor (this->strokeColor);
+  updateStrokeControlsEnabled ();
+
+  groupMetaData->setChecked (S::exportPdfAddMetaData.value ());
+  initMetaData (nullptr, this->lineEditMetaDataTitle, nullptr, S::exportPdfMetaDataTitle);
+  initMetaData (this->checkBoxMetaDataAuthor, this->lineEditMetaDataAuthor, &S::exportPdfAddMetaDataAuthor, S::exportPdfMetaDataAuthor);
+  initMetaData (this->checkBoxMetaDataSubject, this->lineEditMetaDataSubject, &S::exportPdfAddMetaDataSubject, S::exportPdfMetaDataSubject);
+  initMetaData (this->checkBoxMetaDataKeywords, this->lineEditMetaDataKeywords, &S::exportPdfAddMetaDataKeywords, S::exportPdfMetaDataKeywords);
 }
 
-int ExportPdfDialog::exec()
-{
-  bool showDialog = this->checkBoxAlwaysShowDialog->isChecked();
-  if ((QApplication::keyboardModifiers() & Qt::ShiftModifier) != 0) {
+int ExportPdfDialog::exec () {
+  bool showDialog = this->checkBoxAlwaysShowDialog->isChecked ();
+  if ((QApplication::keyboardModifiers () & Qt::ShiftModifier) != 0) {
     showDialog = true;
   }
 
-  const auto result = showDialog ? QDialog::exec() : QDialog::Accepted;
+  const auto result = showDialog ? QDialog::exec () : QDialog::Accepted;
 
   if (result == QDialog::Accepted) {
-    S::exportPdfAlwaysShowDialog.setValue(this->checkBoxAlwaysShowDialog->isChecked());
-    applyButtonGroup(this->buttonGroupPaperSize, S::exportPdfPaperSize);
-    applyButtonGroup(this->buttonGroupOrientation, S::exportPdfOrientation);
-    S::exportPdfShowFilename.setValue(this->checkBoxShowFilename->isChecked());
-    S::exportPdfShowScale.setValue(this->groupScale->isChecked());
-    S::exportPdfShowScaleMessage.setValue(this->checkBoxShowScaleMessage->isChecked());
-    S::exportPdfShowGrid.setValue(this->groupGrid->isChecked());
-    S::exportPdfGridSize.setValue(getGridSize());
-    S::exportPdfFill.setValue(this->checkBoxEnableFill->isChecked());
-    S::exportPdfFillColor.setValue(this->fillColor.name().toStdString());
-    S::exportPdfStroke.setValue(this->checkBoxEnableStroke->isChecked());
-    S::exportPdfStrokeColor.setValue(this->strokeColor.name().toStdString());
-    S::exportPdfStrokeWidth.setValue(this->doubleSpinBoxStrokeWidth->value());
-    S::exportPdfAddMetaData.setValue(this->groupMetaData->isChecked());
-    applyMetaData(nullptr, this->lineEditMetaDataTitle, nullptr, S::exportPdfMetaDataTitle);
-    applyMetaData(this->checkBoxMetaDataAuthor, this->lineEditMetaDataAuthor, &S::exportPdfAddMetaDataAuthor, S::exportPdfMetaDataAuthor);
-    applyMetaData(this->checkBoxMetaDataSubject, this->lineEditMetaDataSubject, &S::exportPdfAddMetaDataSubject, S::exportPdfMetaDataSubject);
-    applyMetaData(this->checkBoxMetaDataKeywords, this->lineEditMetaDataKeywords, &S::exportPdfAddMetaDataKeywords, S::exportPdfMetaDataKeywords);
-    Settings::Settings::visit(SettingsWriter());
+    S::exportPdfAlwaysShowDialog.setValue (this->checkBoxAlwaysShowDialog->isChecked ());
+    applyButtonGroup (this->buttonGroupPaperSize, S::exportPdfPaperSize);
+    applyButtonGroup (this->buttonGroupOrientation, S::exportPdfOrientation);
+    S::exportPdfShowFilename.setValue (this->checkBoxShowFilename->isChecked ());
+    S::exportPdfShowScale.setValue (this->groupScale->isChecked ());
+    S::exportPdfShowScaleMessage.setValue (this->checkBoxShowScaleMessage->isChecked ());
+    S::exportPdfShowGrid.setValue (this->groupGrid->isChecked ());
+    S::exportPdfGridSize.setValue (getGridSize ());
+    S::exportPdfFill.setValue (this->checkBoxEnableFill->isChecked ());
+    S::exportPdfFillColor.setValue (this->fillColor.name ().toStdString ());
+    S::exportPdfStroke.setValue (this->checkBoxEnableStroke->isChecked ());
+    S::exportPdfStrokeColor.setValue (this->strokeColor.name ().toStdString ());
+    S::exportPdfStrokeWidth.setValue (this->doubleSpinBoxStrokeWidth->value ());
+    S::exportPdfAddMetaData.setValue (this->groupMetaData->isChecked ());
+    applyMetaData (nullptr, this->lineEditMetaDataTitle, nullptr, S::exportPdfMetaDataTitle);
+    applyMetaData (this->checkBoxMetaDataAuthor, this->lineEditMetaDataAuthor, &S::exportPdfAddMetaDataAuthor, S::exportPdfMetaDataAuthor);
+    applyMetaData (this->checkBoxMetaDataSubject, this->lineEditMetaDataSubject, &S::exportPdfAddMetaDataSubject, S::exportPdfMetaDataSubject);
+    applyMetaData (this->checkBoxMetaDataKeywords, this->lineEditMetaDataKeywords, &S::exportPdfAddMetaDataKeywords, S::exportPdfMetaDataKeywords);
+    Settings::Settings::visit (SettingsWriter ());
   }
 
   return result;
 }
 
-double ExportPdfDialog::getGridSize() const
-{
-  const auto button = buttonGroupGridSize->checkedButton();
-  return button ? button->property("_selected_value").toDouble() : 10.0;
+double ExportPdfDialog::getGridSize () const {
+  const auto button = buttonGroupGridSize->checkedButton ();
+  return button ? button->property ("_selected_value").toDouble () : 10.0;
 }
 
-void ExportPdfDialog::updateFillColor(const QColor& color)
-{
+void ExportPdfDialog::updateFillColor (const QColor &color) {
   this->fillColor = color;
-  QString styleSheet = QString("QLabel { background-color: %1; }").arg(color.name());
-  this->labelFillColor->setStyleSheet(styleSheet);
+  QString styleSheet = QString ("QLabel { background-color: %1; }").arg (color.name ());
+  this->labelFillColor->setStyleSheet (styleSheet);
 }
 
-void ExportPdfDialog::updateStrokeColor(const QColor& color)
-{
+void ExportPdfDialog::updateStrokeColor (const QColor &color) {
   this->strokeColor = color;
-  QString styleSheet = QString("QLabel { background-color: %1; }").arg(color.name());
-  this->labelStrokeColor->setStyleSheet(styleSheet);
+  QString styleSheet = QString ("QLabel { background-color: %1; }").arg (color.name ());
+  this->labelStrokeColor->setStyleSheet (styleSheet);
 }
 
-void ExportPdfDialog::updateFillControlsEnabled()
-{
-  bool enabled = this->checkBoxEnableFill->isChecked();
-  this->labelFillColor->setEnabled(enabled);
-  this->toolButtonFillColor->setEnabled(enabled);
-  this->toolButtonFillColorReset->setEnabled(enabled);
+void ExportPdfDialog::updateFillControlsEnabled () {
+  bool enabled = this->checkBoxEnableFill->isChecked ();
+  this->labelFillColor->setEnabled (enabled);
+  this->toolButtonFillColor->setEnabled (enabled);
+  this->toolButtonFillColorReset->setEnabled (enabled);
 }
 
-void ExportPdfDialog::updateStrokeControlsEnabled()
-{
-  bool enabled = this->checkBoxEnableStroke->isChecked();
-  this->labelStrokeColor->setEnabled(enabled);
-  this->toolButtonStrokeColor->setEnabled(enabled);
-  this->toolButtonStrokeColorReset->setEnabled(enabled);
-  this->labelStrokeWidth->setEnabled(enabled);
-  this->doubleSpinBoxStrokeWidth->setEnabled(enabled);
-  this->toolButtonStrokeWidthReset->setEnabled(enabled);
+void ExportPdfDialog::updateStrokeControlsEnabled () {
+  bool enabled = this->checkBoxEnableStroke->isChecked ();
+  this->labelStrokeColor->setEnabled (enabled);
+  this->toolButtonStrokeColor->setEnabled (enabled);
+  this->toolButtonStrokeColorReset->setEnabled (enabled);
+  this->labelStrokeWidth->setEnabled (enabled);
+  this->doubleSpinBoxStrokeWidth->setEnabled (enabled);
+  this->toolButtonStrokeWidthReset->setEnabled (enabled);
 }
 
-void ExportPdfDialog::on_toolButtonFillColor_clicked()
-{
-  QColor color = QColorDialog::getColor(this->fillColor, this);
-  if (color.isValid()) {
-    updateFillColor(color);
+void ExportPdfDialog::on_toolButtonFillColor_clicked () {
+  QColor color = QColorDialog::getColor (this->fillColor, this);
+  if (color.isValid ()) {
+    updateFillColor (color);
   }
 }
 
-void ExportPdfDialog::on_toolButtonStrokeColor_clicked()
-{
-  QColor color = QColorDialog::getColor(this->strokeColor, this);
-  if (color.isValid()) {
-    updateStrokeColor(color);
+void ExportPdfDialog::on_toolButtonStrokeColor_clicked () {
+  QColor color = QColorDialog::getColor (this->strokeColor, this);
+  if (color.isValid ()) {
+    updateStrokeColor (color);
   }
 }
 
-void ExportPdfDialog::on_toolButtonFillColorReset_clicked()
-{
-  updateFillColor(QColor(QString::fromStdString(S::exportPdfFillColor.defaultValue())));
+void ExportPdfDialog::on_toolButtonFillColorReset_clicked () {
+  updateFillColor (QColor (QString::fromStdString (S::exportPdfFillColor.defaultValue ())));
 }
 
-void ExportPdfDialog::on_toolButtonStrokeColorReset_clicked()
-{
-  updateStrokeColor(QColor(QString::fromStdString(S::exportPdfStrokeColor.defaultValue())));
+void ExportPdfDialog::on_toolButtonStrokeColorReset_clicked () {
+  updateStrokeColor (QColor (QString::fromStdString (S::exportPdfStrokeColor.defaultValue ())));
 }
 
-void ExportPdfDialog::on_toolButtonStrokeWidthReset_clicked()
-{
-  this->doubleSpinBoxStrokeWidth->setValue(this->defaultStrokeWidth);
+void ExportPdfDialog::on_toolButtonStrokeWidthReset_clicked () {
+  this->doubleSpinBoxStrokeWidth->setValue (this->defaultStrokeWidth);
 }
 
-void ExportPdfDialog::on_checkBoxEnableFill_toggled(bool checked)
-{
-  updateFillControlsEnabled();
+void ExportPdfDialog::on_checkBoxEnableFill_toggled (bool checked) {
+  updateFillControlsEnabled ();
 }
 
-void ExportPdfDialog::on_checkBoxEnableStroke_toggled(bool checked)
-{
-  updateStrokeControlsEnabled();
+void ExportPdfDialog::on_checkBoxEnableStroke_toggled (bool checked) {
+  updateStrokeControlsEnabled ();
 }
diff --git a/src/gui/ExportPdfDialog.h b/src/gui/ExportPdfDialog.h
index f04d42f29..dc7001e00 100644
--- a/src/gui/ExportPdfDialog.h
+++ b/src/gui/ExportPdfDialog.h
@@ -40,38 +40,33 @@ class ExportPdfDialog : public QDialog, public Ui::ExportPdfDialog, public InitC
   Q_OBJECT;
 
 public:
-  ExportPdfDialog();
+  ExportPdfDialog ();
 
-  int exec() override;
+  int exec () override;
 
-  double getGridSize() const;
-  void setGridSize(double value);
+  double getGridSize () const;
+  void setGridSize (double value);
 
-  std::shared_ptr<const ExportPdfOptions> getOptions() const {
-    return ExportPdfOptions::fromSettings();
+  std::shared_ptr<const ExportPdfOptions> getOptions () const {
+    return ExportPdfOptions::fromSettings ();
   }
 
 private slots:
-  void on_toolButtonFillColor_clicked();
-  void on_toolButtonFillColorReset_clicked();
-  void on_checkBoxEnableFill_toggled(bool checked);
-  void on_toolButtonStrokeColor_clicked();
-  void on_toolButtonStrokeColorReset_clicked();
-  void on_checkBoxEnableStroke_toggled(bool checked);
-  void on_toolButtonStrokeWidthReset_clicked();
+  void on_toolButtonFillColor_clicked ();
+  void on_toolButtonFillColorReset_clicked ();
+  void on_checkBoxEnableFill_toggled (bool checked);
+  void on_toolButtonStrokeColor_clicked ();
+  void on_toolButtonStrokeColorReset_clicked ();
+  void on_checkBoxEnableStroke_toggled (bool checked);
+  void on_toolButtonStrokeWidthReset_clicked ();
 
 private:
-  void updateFillColor(const QColor& color);
-  void updateFillControlsEnabled();
-  void updateStrokeColor(const QColor& color);
-  void updateStrokeControlsEnabled();
+  void updateFillColor (const QColor &color);
+  void updateFillControlsEnabled ();
+  void updateStrokeColor (const QColor &color);
+  void updateStrokeControlsEnabled ();
 
   QColor fillColor;
   QColor strokeColor;
   double defaultStrokeWidth = 0.35;
 };
-
-
-
-
-
diff --git a/src/gui/ExternalToolInterface.cc b/src/gui/ExternalToolInterface.cc
index 4b817f18d..b4af82f9f 100644
--- a/src/gui/ExternalToolInterface.cc
+++ b/src/gui/ExternalToolInterface.cc
@@ -41,180 +41,169 @@
 
 namespace {
 
-QString getArgValue(const Settings::LocalAppParameter& arg,
-                    const std::string& exportedFilename,
-                    const std::string& sourceFilename)
-{
-  const QFileInfo info(QString::fromStdString(exportedFilename));
+QString getArgValue (const Settings::LocalAppParameter &arg,
+                     const std::string &exportedFilename,
+                     const std::string &sourceFilename) {
+  const QFileInfo info (QString::fromStdString (exportedFilename));
   switch (arg.type) {
   case Settings::LocalAppParameterType::string:
-    return QString::fromStdString(arg.value);
+    return QString::fromStdString (arg.value);
   case Settings::LocalAppParameterType::file:
-    return QString::fromStdString(exportedFilename);
+    return QString::fromStdString (exportedFilename);
   case Settings::LocalAppParameterType::dir:
-    return info.absoluteDir().path();
+    return info.absoluteDir ().path ();
   case Settings::LocalAppParameterType::extension:
-    return info.suffix();
+    return info.suffix ();
   case Settings::LocalAppParameterType::source:
-    return QString::fromStdString(sourceFilename);
+    return QString::fromStdString (sourceFilename);
   case Settings::LocalAppParameterType::sourcedir:
-    return QFileInfo(QString::fromStdString(sourceFilename)).absoluteDir().path();
+    return QFileInfo (QString::fromStdString (sourceFilename)).absoluteDir ().path ();
   default:
     return {};
   }
 }
 
-}  // namespace
+} // namespace
 
-bool ExternalToolInterface::exportTemporaryFile(const std::shared_ptr<const Geometry>& rootGeometry,
-                                                const QString& sourceFileName, const Camera *const camera)
-{
+bool ExternalToolInterface::exportTemporaryFile (const std::shared_ptr<const Geometry> &rootGeometry,
+                                                 const QString &sourceFileName, const Camera *const camera) {
   // FIXME: Remove original suffix first
-  QTemporaryFile exportFile{getTempDir().filePath(
-                              QString("%1.XXXXXX.%2").
-                              arg(QString::fromStdString(sourceFileName.toStdString())).
-                              arg(QString::fromStdString(fileformat::toSuffix(exportFormat_))))};
+  QTemporaryFile exportFile{getTempDir ().filePath (
+    QString ("%1.XXXXXX.%2").arg (QString::fromStdString (sourceFileName.toStdString ())).arg (QString::fromStdString (fileformat::toSuffix (exportFormat_))))};
   // FIXME: When is it safe to remove the file?
   // * Octoprint: After uploading?
   // * PrintService: After uploading?
   // * Local slicer: Never?
-  exportFile.setAutoRemove(false);
-  if (!exportFile.open()) {
-    LOG("Could not open temporary file.");
+  exportFile.setAutoRemove (false);
+  if (!exportFile.open ()) {
+    LOG ("Could not open temporary file.");
     return false;
   }
-  const QString exportFileName = exportFile.fileName();
+  const QString exportFileName = exportFile.fileName ();
 
-  sourceFilename_ = sourceFileName.toStdString();
-  exportedFilename_ = exportFileName.toStdString();
-  ExportInfo exportInfo = createExportInfo(exportFormat_, fileformat::info(exportFormat_), sourceFileName.toStdString(), camera, {});
-  const bool ok = exportFileByName(rootGeometry, exportedFilename_, exportInfo);
-  LOG("Exported temporary file %1$s", exportedFilename_);
+  sourceFilename_ = sourceFileName.toStdString ();
+  exportedFilename_ = exportFileName.toStdString ();
+  ExportInfo exportInfo = createExportInfo (exportFormat_, fileformat::info (exportFormat_), sourceFileName.toStdString (), camera, {});
+  const bool ok = exportFileByName (rootGeometry, exportedFilename_, exportInfo);
+  LOG ("Exported temporary file %1$s", exportedFilename_);
   return ok;
 }
 
-bool OctoPrintService::process(const std::string& displayName, std::function<bool (double)> progress_cb)
-{
+bool OctoPrintService::process (const std::string &displayName, std::function<bool (double)> progress_cb) {
   const OctoPrint octoPrint;
 
   try {
-    const QString fileUrl = octoPrint.upload(QString::fromStdString(exportedFilename_), QString::fromStdString(displayName), progress_cb);
+    const QString fileUrl = octoPrint.upload (QString::fromStdString (exportedFilename_), QString::fromStdString (displayName), progress_cb);
     if (this->action == "upload") {
       return true;
     }
 
-    const QString slicer = QString::fromStdString(Settings::Settings::octoPrintSlicerEngine.value());
-    const QString profile = QString::fromStdString(Settings::Settings::octoPrintSlicerProfile.value());
-    octoPrint.slice(fileUrl, slicer, profile, action != "slice", action == "print");
-  } catch (const NetworkException& e) {
-    LOG(message_group::Error, "%1$s", e.getErrorMessage());
+    const QString slicer = QString::fromStdString (Settings::Settings::octoPrintSlicerEngine.value ());
+    const QString profile = QString::fromStdString (Settings::Settings::octoPrintSlicerProfile.value ());
+    octoPrint.slice (fileUrl, slicer, profile, action != "slice", action == "print");
+  } catch (const NetworkException &e) {
+    LOG (message_group::Error, "%1$s", e.getErrorMessage ());
   }
   return true;
 }
 
-QDir LocalProgramService::getTempDir() const
-{
-  const auto& tempDirConfig = Settings::Settings::localAppTempDir.value();
-  if (tempDirConfig.empty()) {
-    return QDir::temp();
+QDir LocalProgramService::getTempDir () const {
+  const auto &tempDirConfig = Settings::Settings::localAppTempDir.value ();
+  if (tempDirConfig.empty ()) {
+    return QDir::temp ();
   }
-  const auto tempDir = QDir{QString::fromStdString(tempDirConfig)};
-  if (!tempDir.exists()) {
-    LOG(message_group::Warning, "Configured temporary directory does not exist: '%1$s'", tempDirConfig);
-    return QDir::temp();
+  const auto tempDir = QDir{QString::fromStdString (tempDirConfig)};
+  if (!tempDir.exists ()) {
+    LOG (message_group::Warning, "Configured temporary directory does not exist: '%1$s'", tempDirConfig);
+    return QDir::temp ();
   }
   return tempDir;
 }
 
-bool LocalProgramService::process(const std::string& displayName, std::function<bool (double)> progress_cb)
-{
+bool LocalProgramService::process (const std::string &displayName, std::function<bool (double)> progress_cb) {
   QProcess process;
-  process.setProcessChannelMode(QProcess::MergedChannels);
+  process.setProcessChannelMode (QProcess::MergedChannels);
 
-  const QString application = QString::fromStdString(Settings::Settings::localAppExecutable.value());
+  const QString application = QString::fromStdString (Settings::Settings::localAppExecutable.value ());
 
-  if (application.trimmed().isEmpty()) {
-    LOG(message_group::Error, "No application configured, check Preferences -> 3D Print -> Local Application");
+  if (application.trimmed ().isEmpty ()) {
+    LOG (message_group::Error, "No application configured, check Preferences -> 3D Print -> Local Application");
     return false;
   }
 
 #ifdef Q_OS_MACOS
   QStringList fileArgs, otherArgs;
-  for (const auto& arg : Settings::Settings::localAppParameterList.value()) {
+  for (const auto &arg : Settings::Settings::localAppParameterList.value ()) {
     if (arg.type == Settings::LocalAppParameterType::file) {
-      fileArgs << getArgValue(arg, exportedFilename_, sourceFilename_);
+      fileArgs << getArgValue (arg, exportedFilename_, sourceFilename_);
     } else {
-      otherArgs << getArgValue(arg, exportedFilename_, sourceFilename_);
+      otherArgs << getArgValue (arg, exportedFilename_, sourceFilename_);
     }
   }
 
-  QStringList commandArgs(fileArgs);
+  QStringList commandArgs (fileArgs);
   commandArgs << "-a" << application;
-  if (!otherArgs.isEmpty()) {
+  if (!otherArgs.isEmpty ()) {
     commandArgs << "--args" << otherArgs;
   }
-  PRINTD("Executing: open " + commandArgs.join(" ").toStdString());
-  if (!process.startDetached("open", commandArgs)) {
+  PRINTD ("Executing: open " + commandArgs.join (" ").toStdString ());
+  if (!process.startDetached ("open", commandArgs)) {
 #else
   QStringList args;
-  for (const auto& arg : Settings::Settings::localAppParameterList.value()) {
-    args << getArgValue(arg, exportedFilename_, sourceFilename_);
+  for (const auto &arg : Settings::Settings::localAppParameterList.value ()) {
+    args << getArgValue (arg, exportedFilename_, sourceFilename_);
   }
-  PRINTD("Executing: " + application.toStdString() + " " + args.join(" ").toStdString());
-  if (!process.startDetached(application, args)) {
+  PRINTD ("Executing: " + application.toStdString () + " " + args.join (" ").toStdString ());
+  if (!process.startDetached (application, args)) {
 #endif // ifdef Q_OS_MACOS
-    LOG(message_group::Error, "Could not start local application '%1$s': %2$s", application.toStdString(), process.errorString().toStdString());
-    const auto output = process.readAll();
-    if (output.length() > 0) {
-      LOG(message_group::Error, "Output: %1$s", output.toStdString());
+    LOG (message_group::Error, "Could not start local application '%1$s': %2$s", application.toStdString (), process.errorString ().toStdString ());
+    const auto output = process.readAll ();
+    if (output.length () > 0) {
+      LOG (message_group::Error, "Output: %1$s", output.toStdString ());
     }
   }
   return true;
 }
 
-bool ExternalPrintService::process(const std::string& displayName, std::function<bool (double)> progress_cb)
-{
-  QFile file(QString::fromStdString(exportedFilename_));
-  if (!file.open(QIODevice::ReadOnly)) {
-    LOG(message_group::Error, "Unable to open exported STL file.");
+bool ExternalPrintService::process (const std::string &displayName, std::function<bool (double)> progress_cb) {
+  QFile file (QString::fromStdString (exportedFilename_));
+  if (!file.open (QIODevice::ReadOnly)) {
+    LOG (message_group::Error, "Unable to open exported STL file.");
     return false;
   }
-  const QString fileContentBase64 = file.readAll().toBase64();
+  const QString fileContentBase64 = file.readAll ().toBase64 ();
 
-  if (fileContentBase64.length() > printService->getFileSizeLimit()) {
-    const auto msg = QString{_("Exported design exceeds the service upload limit of (%1 MB).")}.arg(printService->getFileSizeLimitMB());
+  if (fileContentBase64.length () > printService->getFileSizeLimit ()) {
+    const auto msg = QString{_ ("Exported design exceeds the service upload limit of (%1 MB).")}.arg (printService->getFileSizeLimitMB ());
     // FIXME: Move back to MainWindow
-//    QMessageBox::warning(this, _("Upload Error"), msg, QMessageBox::Ok);
+    //    QMessageBox::warning(this, _("Upload Error"), msg, QMessageBox::Ok);
     //LOG(message_group::Error, "%1$s", msg.toStdString());
     return false;
   }
   try {
-    const QString partUrl = printService->upload(QString::fromStdString(displayName), fileContentBase64, progress_cb);
-    this->url = partUrl.toStdString();
-  } catch (const NetworkException& e) {
-    LOG(message_group::Error, "%1$s", e.getErrorMessage());
+    const QString partUrl = printService->upload (QString::fromStdString (displayName), fileContentBase64, progress_cb);
+    this->url = partUrl.toStdString ();
+  } catch (const NetworkException &e) {
+    LOG (message_group::Error, "%1$s", e.getErrorMessage ());
   }
   return true;
 }
 
-std::unique_ptr<ExternalPrintService> createExternalPrintService(const PrintService *printService, FileFormat fileFormat) {
-  return std::make_unique<ExternalPrintService>(fileFormat, printService);
+std::unique_ptr<ExternalPrintService> createExternalPrintService (const PrintService *printService, FileFormat fileFormat) {
+  return std::make_unique<ExternalPrintService> (fileFormat, printService);
 }
 
-std::unique_ptr<OctoPrintService> createOctoPrintService(FileFormat fileFormat)
-{
-  auto octoPrintService = std::make_unique<OctoPrintService>(fileFormat);
-
-
-// TODO: set action, slicerEngine, slicerAction
-//    const std::string& action = Settings::Settings::octoPrintAction.value();
-// const QString slicer = QString::fromStdString(Settings::Settings::octoPrintSlicerEngine.value());
-// const QString profile = QString::fromStdString(Settings::Settings::octoPrintSlicerProfile.value());
+std::unique_ptr<OctoPrintService> createOctoPrintService (FileFormat fileFormat) {
+  auto octoPrintService = std::make_unique<OctoPrintService> (fileFormat);
 
+  // TODO: set action, slicerEngine, slicerAction
+  //    const std::string& action = Settings::Settings::octoPrintAction.value();
+  // const QString slicer = QString::fromStdString(Settings::Settings::octoPrintSlicerEngine.value());
+  // const QString profile = QString::fromStdString(Settings::Settings::octoPrintSlicerProfile.value());
 
   return octoPrintService;
 }
 
-std::unique_ptr<LocalProgramService> createLocalProgramService(FileFormat fileFormat) {
-  return std::make_unique<LocalProgramService>(fileFormat);
+std::unique_ptr<LocalProgramService> createLocalProgramService (FileFormat fileFormat) {
+  return std::make_unique<LocalProgramService> (fileFormat);
 }
diff --git a/src/gui/ExternalToolInterface.h b/src/gui/ExternalToolInterface.h
index 6744db775..6714205e4 100644
--- a/src/gui/ExternalToolInterface.h
+++ b/src/gui/ExternalToolInterface.h
@@ -41,41 +41,53 @@
 class ExternalToolInterface
 {
 public:
-  ExternalToolInterface(FileFormat fileFormat) : exportFormat_(fileFormat) {}
-  virtual ~ExternalToolInterface() = default;
+  ExternalToolInterface (FileFormat fileFormat)
+    : exportFormat_ (fileFormat) {}
+  virtual ~ExternalToolInterface () = default;
+
+  virtual bool exportTemporaryFile (const std::shared_ptr<const Geometry> &rootGeometry, const QString &sourceFileName, const Camera *const camera);
+  virtual bool process (const std::string &displayName, std::function<bool (double)>) = 0;
+
+  FileFormat fileFormat () const {
+    return exportFormat_;
+  }
+  virtual std::string getURL () const {
+    return "";
+  }
+  virtual QDir getTempDir () const {
+    return QDir::temp ();
+  }
 
-  virtual bool exportTemporaryFile(const std::shared_ptr<const Geometry>& rootGeometry, const QString& sourceFileName, const Camera *const camera);
-  virtual bool process(const std::string& displayName, std::function<bool (double)>) = 0;
-
-  FileFormat fileFormat() const { return exportFormat_; }
-  virtual std::string getURL() const { return ""; }
-  virtual QDir getTempDir() const { return QDir::temp(); }
 protected:
   std::string sourceFilename_;
   FileFormat exportFormat_;
   std::string exportedFilename_;
 };
 
-
 class ExternalPrintService : public ExternalToolInterface
 {
 public:
-  ExternalPrintService(FileFormat fileFormat, const PrintService *printService) : ExternalToolInterface(fileFormat), printService(printService) {}
-  bool process(const std::string& displayName, std::function<bool (double)>) override;
-  std::string getURL() const override {return url;}
+  ExternalPrintService (FileFormat fileFormat, const PrintService *printService)
+    : ExternalToolInterface (fileFormat)
+    , printService (printService) {}
+  bool process (const std::string &displayName, std::function<bool (double)>) override;
+  std::string getURL () const override {
+    return url;
+  }
 
 private:
   std::string url;
   const PrintService *printService;
 };
 
-std::unique_ptr<ExternalPrintService> createExternalPrintService(const PrintService *printService, FileFormat fileFormat);
+std::unique_ptr<ExternalPrintService> createExternalPrintService (const PrintService *printService, FileFormat fileFormat);
 
 class OctoPrintService : public ExternalToolInterface
 {
 public:
-  OctoPrintService(FileFormat fileFormat) : ExternalToolInterface(fileFormat) {}
-  bool process(const std::string& displayName, std::function<bool (double)>) override;
+  OctoPrintService (FileFormat fileFormat)
+    : ExternalToolInterface (fileFormat) {}
+  bool process (const std::string &displayName, std::function<bool (double)>) override;
 
 private:
   std::string action;
@@ -83,14 +95,15 @@ private:
   std::string slicerAction;
 };
 
-std::unique_ptr<OctoPrintService> createOctoPrintService(FileFormat fileFormat);
+std::unique_ptr<OctoPrintService> createOctoPrintService (FileFormat fileFormat);
 
 class LocalProgramService : public ExternalToolInterface
 {
 public:
-  LocalProgramService(FileFormat fileFormat) : ExternalToolInterface(fileFormat) {}
-  bool process(const std::string& displayName, std::function<bool (double)>) override;
-  QDir getTempDir() const override;
+  LocalProgramService (FileFormat fileFormat)
+    : ExternalToolInterface (fileFormat) {}
+  bool process (const std::string &displayName, std::function<bool (double)>) override;
+  QDir getTempDir () const override;
 };
 
-std::unique_ptr<LocalProgramService> createLocalProgramService(FileFormat fileFormat);
+std::unique_ptr<LocalProgramService> createLocalProgramService (FileFormat fileFormat);
diff --git a/src/gui/FontList.cc b/src/gui/FontList.cc
index b25a1aa6e..6b4e306de 100644
--- a/src/gui/FontList.cc
+++ b/src/gui/FontList.cc
@@ -34,329 +34,294 @@
 #include "FontCache.h"
 #include "utils/printutils.h"
 
-FontItemDelegate::FontItemDelegate(QObject *parent) : QStyledItemDelegate(parent)
-{
+FontItemDelegate::FontItemDelegate (QObject *parent)
+  : QStyledItemDelegate (parent) {
 }
 
-int FontItemDelegate::fontSize() const
-{
+int FontItemDelegate::fontSize () const {
   return _fontSize;
 }
 
-void FontItemDelegate::setFontSize(int fontSize)
-{
+void FontItemDelegate::setFontSize (int fontSize) {
   _fontSize = fontSize;
 }
 
-QString FontItemDelegate::text() const
-{
+QString FontItemDelegate::text () const {
   return _text;
 }
 
-void FontItemDelegate::setText(const QString& text)
-{
+void FontItemDelegate::setText (const QString &text) {
   _text = text;
 }
 
-void FontItemDelegate::initStyleOption(QStyleOptionViewItem *opt, const QModelIndex& idx) const
-{
-  QStyledItemDelegate::initStyleOption(opt, idx);
+void FontItemDelegate::initStyleOption (QStyleOptionViewItem *opt, const QModelIndex &idx) const {
+  QStyledItemDelegate::initStyleOption (opt, idx);
 
-  opt->font.setStyleStrategy(QFont::NoFontMerging);
-  opt->font.setPointSize(_fontSize);
+  opt->font.setStyleStrategy (QFont::NoFontMerging);
+  opt->font.setPointSize (_fontSize);
   opt->textElideMode = Qt::ElideNone;
 }
 
-QWidget *FontItemDelegate::createEditor(QWidget *, const QStyleOptionViewItem&, const QModelIndex&) const
-{
+QWidget *FontItemDelegate::createEditor (QWidget *, const QStyleOptionViewItem &, const QModelIndex &) const {
   return nullptr;
 }
 
-QSize FontItemDelegate::sizeHint(const QStyleOptionViewItem& option, const QModelIndex& idx) const
-{
+QSize FontItemDelegate::sizeHint (const QStyleOptionViewItem &option, const QModelIndex &idx) const {
   QStyleOptionViewItem opt = option;
-  initStyleOption(&opt, idx);
+  initStyleOption (&opt, idx);
 
-  const auto text = opt.text.isEmpty() ? this->text() : opt.text;
+  const auto text = opt.text.isEmpty () ? this->text () : opt.text;
 
-  QFontMetrics fm(opt.font);
+  QFontMetrics fm (opt.font);
   // Using the default font for speed, so adding some extra generous padding
   // This also prevents the columns from getting very wide due to some random
   // font having some extra wide glyphs.
-  return {4 * fm.height() + fm.horizontalAdvance(text), fm.height()};
+  return {4 * fm.height () + fm.horizontalAdvance (text), fm.height ()};
 }
 
-void FontItemDelegate::paint(QPainter *painter, const QStyleOptionViewItem& option, const QModelIndex& idx) const
-{
+void FontItemDelegate::paint (QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &idx) const {
   QStyleOptionViewItem opt = option;
-  initStyleOption(&opt, idx);
+  initStyleOption (&opt, idx);
 
-  const auto fontName = FontList::colStr(idx, FontList::COL_FONT_NAME);
-  const auto fontStyle = FontList::colStr(idx, FontList::COL_FONT_STYLE);
+  const auto fontName = FontList::colStr (idx, FontList::COL_FONT_NAME);
+  const auto fontStyle = FontList::colStr (idx, FontList::COL_FONT_STYLE);
 
-  opt.font.setFamily(fontName);
-  opt.font.setStyleName(fontStyle);
-  opt.text = text(); // only used if idx points to empty string
+  opt.font.setFamily (fontName);
+  opt.font.setStyleName (fontStyle);
+  opt.text = text (); // only used if idx points to empty string
 
-  QStyledItemDelegate::paint(painter, opt, idx);
+  QStyledItemDelegate::paint (painter, opt, idx);
 }
 
-FontSortFilterProxyModel::FontSortFilterProxyModel(QObject *parent) : QSortFilterProxyModel(parent)
-{
+FontSortFilterProxyModel::FontSortFilterProxyModel (QObject *parent)
+  : QSortFilterProxyModel (parent) {
 }
 
-void FontSortFilterProxyModel::clearFilter()
-{
-  filterHashes.clear();
+void FontSortFilterProxyModel::clearFilter () {
+  filterHashes.clear ();
 }
 
-void FontSortFilterProxyModel::appendFilterHashes(const std::vector<uint32_t>& hashes)
-{
+void FontSortFilterProxyModel::appendFilterHashes (const std::vector<uint32_t> &hashes) {
   for (const auto hash : hashes) {
-    filterHashes.insert(QString::number(hash, 16));
+    filterHashes.insert (QString::number (hash, 16));
   }
 }
 
-bool FontSortFilterProxyModel::filterAcceptsRow(int sourceRow, const QModelIndex& sourceParent) const
-{
-  const bool parentResult = QSortFilterProxyModel::filterAcceptsRow(sourceRow, sourceParent);
-  if (filterHashes.empty()) {
+bool FontSortFilterProxyModel::filterAcceptsRow (int sourceRow, const QModelIndex &sourceParent) const {
+  const bool parentResult = QSortFilterProxyModel::filterAcceptsRow (sourceRow, sourceParent);
+  if (filterHashes.empty ()) {
     return parentResult;
   }
 
-  const auto idx = sourceModel()->index(sourceRow, FontList::COL_HASH, sourceParent);
-  const auto& data = sourceModel()->data(idx);
-  const bool result = filterHashes.contains(data.toString());
+  const auto idx = sourceModel ()->index (sourceRow, FontList::COL_HASH, sourceParent);
+  const auto &data = sourceModel ()->data (idx);
+  const bool result = filterHashes.contains (data.toString ());
   return parentResult && result;
 }
 
-FontList::FontList(QWidget *parent) : QWidget(parent), model(nullptr), proxy(nullptr)
-{
-  setupUi(this);
-  lineEditSampleText->addAction(actionResetSampleText, QLineEdit::TrailingPosition);
-  actionResetSampleText->trigger();
-  lineEditFontNameSelected->addAction(actionCopyFontName, QLineEdit::TrailingPosition);
-  lineEditFontPathSelected->addAction(actionOpenFolder, QLineEdit::TrailingPosition);
-  lineEditFontPathSelected->addAction(actionCopyFullPath, QLineEdit::TrailingPosition);
-  lineEditFcStyleSelected->addAction(actionCopyStyle, QLineEdit::TrailingPosition);
-  spinBoxFontSize->setValue(tableView->fontInfo().pointSize());
-  selection_changed({}, {});
+FontList::FontList (QWidget *parent)
+  : QWidget (parent)
+  , model (nullptr)
+  , proxy (nullptr) {
+  setupUi (this);
+  lineEditSampleText->addAction (actionResetSampleText, QLineEdit::TrailingPosition);
+  actionResetSampleText->trigger ();
+  lineEditFontNameSelected->addAction (actionCopyFontName, QLineEdit::TrailingPosition);
+  lineEditFontPathSelected->addAction (actionOpenFolder, QLineEdit::TrailingPosition);
+  lineEditFontPathSelected->addAction (actionCopyFullPath, QLineEdit::TrailingPosition);
+  lineEditFcStyleSelected->addAction (actionCopyStyle, QLineEdit::TrailingPosition);
+  spinBoxFontSize->setValue (tableView->fontInfo ().pointSize ());
+  selection_changed ({}, {});
 
-  tableView->horizontalHeader()->setContextMenuPolicy(Qt::CustomContextMenu);
-  connect(tableView->horizontalHeader(), &QHeaderView::customContextMenuRequested, this, &FontList::customHeaderContexMenuRequested);
+  tableView->horizontalHeader ()->setContextMenuPolicy (Qt::CustomContextMenu);
+  connect (tableView->horizontalHeader (), &QHeaderView::customContextMenuRequested, this, &FontList::customHeaderContexMenuRequested);
 }
 
-void FontList::on_lineEditFontName_textChanged(const QString& text)
-{
-  updateFilter(comboBoxSearchType->currentIndex(), text);
+void FontList::on_lineEditFontName_textChanged (const QString &text) {
+  updateFilter (comboBoxSearchType->currentIndex (), text);
 }
 
-void FontList::on_comboBoxSearchType_currentIndexChanged(int idx)
-{
-  updateFilter(idx, lineEditFontName->text());
+void FontList::on_comboBoxSearchType_currentIndexChanged (int idx) {
+  updateFilter (idx, lineEditFontName->text ());
 }
 
-void FontList::updateFilter(int searchTypeIdx, const QString& text)
-{
-  const auto regExp = QRegularExpression(text, QRegularExpression::CaseInsensitiveOption);
+void FontList::updateFilter (int searchTypeIdx, const QString &text) {
+  const auto regExp = QRegularExpression (text, QRegularExpression::CaseInsensitiveOption);
 
   switch (searchTypeIdx) {
   case 0:
-    proxy->setFilterFixedString(text);
+    proxy->setFilterFixedString (text);
     break;
   case 1:
-    proxy->setFilterWildcard(text);
+    proxy->setFilterWildcard (text);
     break;
   default:
-    proxy->setFilterRegularExpression(regExp);
+    proxy->setFilterRegularExpression (regExp);
     break;
   }
-  groupBoxFilter->setTitle(QString("Filter (%1 fonts found)").arg(proxy->rowCount()));
+  groupBoxFilter->setTitle (QString ("Filter (%1 fonts found)").arg (proxy->rowCount ()));
 }
 
-void FontList::on_comboBoxCharFilterType_currentIndexChanged(int idx)
-{
-  updateCharFilter(idx, lineEditChars->text());
+void FontList::on_comboBoxCharFilterType_currentIndexChanged (int idx) {
+  updateCharFilter (idx, lineEditChars->text ());
 }
 
-void FontList::on_lineEditChars_textChanged(const QString& text)
-{
-  updateCharFilter(comboBoxCharFilterType->currentIndex(), text);
+void FontList::on_lineEditChars_textChanged (const QString &text) {
+  updateCharFilter (comboBoxCharFilterType->currentIndex (), text);
 }
 
-void FontList::updateCharFilter(int charFilterType, const QString& text)
-{
-  proxy->clearFilter();
-  if (text.length() > 0) {
+void FontList::updateCharFilter (int charFilterType, const QString &text) {
+  proxy->clearFilter ();
+  if (text.length () > 0) {
     if (charFilterType == 0) {
       // AND / All
-      const auto hashes = FontCache::instance()->filter(text.toStdU32String());
-      proxy->appendFilterHashes(hashes);
+      const auto hashes = FontCache::instance ()->filter (text.toStdU32String ());
+      proxy->appendFilterHashes (hashes);
     } else {
       // OR / Any
-      for (const auto ch : text.toStdU32String()) {
-        const auto hashes = FontCache::instance()->filter(std::u32string{ch});
-        proxy->appendFilterHashes(hashes);
+      for (const auto ch : text.toStdU32String ()) {
+        const auto hashes = FontCache::instance ()->filter (std::u32string{ch});
+        proxy->appendFilterHashes (hashes);
       }
     }
   }
-  proxy->invalidate();
-  groupBoxFilter->setTitle(QString("Filter (%1 fonts found)").arg(proxy->rowCount()));
+  proxy->invalidate ();
+  groupBoxFilter->setTitle (QString ("Filter (%1 fonts found)").arg (proxy->rowCount ()));
 }
 
-void FontList::on_actionResetSampleText_triggered()
-{
-  lineEditSampleText->setText(SAMPLE_TEXT_DEFAULT);
-  lineEditSampleText->setCursorPosition(0);
+void FontList::on_actionResetSampleText_triggered () {
+  lineEditSampleText->setText (SAMPLE_TEXT_DEFAULT);
+  lineEditSampleText->setCursorPosition (0);
 }
 
-void FontList::on_lineEditSampleText_textChanged(const QString& text)
-{
-  updateSampleText(text, spinBoxFontSize->value());
+void FontList::on_lineEditSampleText_textChanged (const QString &text) {
+  updateSampleText (text, spinBoxFontSize->value ());
 }
 
-void FontList::on_spinBoxFontSize_valueChanged(int value)
-{
-  updateSampleText(lineEditSampleText->text(), value);
+void FontList::on_spinBoxFontSize_valueChanged (int value) {
+  updateSampleText (lineEditSampleText->text (), value);
 }
 
-void FontList::updateSampleText(const QString& text, int fontSize)
-{
-  delegate.setText(text);
-  delegate.setFontSize(fontSize);
+void FontList::updateSampleText (const QString &text, int fontSize) {
+  delegate.setText (text);
+  delegate.setFontSize (fontSize);
 
-  QFont font = tableView->font();
-  font.setPointSize(fontSize);
-  const QFontMetrics fm(font);
-  const int size = fm.height() + fm.height() / 4;
-  tableView->verticalHeader()->setMinimumSectionSize(1);
-  tableView->verticalHeader()->setMaximumSectionSize(size);
-  tableView->verticalHeader()->setDefaultSectionSize(size);
-  tableView->resizeColumnToContents(COL_SAMPLE);
-  tableView->resizeColumnToContents(COL_STYLED_FONT_NAME);
+  QFont font = tableView->font ();
+  font.setPointSize (fontSize);
+  const QFontMetrics fm (font);
+  const int size = fm.height () + fm.height () / 4;
+  tableView->verticalHeader ()->setMinimumSectionSize (1);
+  tableView->verticalHeader ()->setMaximumSectionSize (size);
+  tableView->verticalHeader ()->setDefaultSectionSize (size);
+  tableView->resizeColumnToContents (COL_SAMPLE);
+  tableView->resizeColumnToContents (COL_STYLED_FONT_NAME);
 
   if (proxy) {
-    proxy->invalidate();
+    proxy->invalidate ();
   }
 }
 
-void FontList::customHeaderContexMenuRequested(const QPoint& pos)
-{
-  auto *menu = new QMenu(this);
-  menu->addAction(actionShowFontNameColumn);
-  menu->addAction(actionShowStyledFontNameColumn);
-  menu->addAction(actionShowFontStyleColumn);
-  menu->addAction(actionShowFontSampleColumn);
-  menu->addAction(actionShowFileNameColumn);
-  menu->addAction(actionShowFilePathColumn);
-  menu->addSeparator();
-  menu->addAction(actionResetColumns);
-  menu->popup(tableView->horizontalHeader()->viewport()->mapToGlobal(pos));
+void FontList::customHeaderContexMenuRequested (const QPoint &pos) {
+  auto *menu = new QMenu (this);
+  menu->addAction (actionShowFontNameColumn);
+  menu->addAction (actionShowStyledFontNameColumn);
+  menu->addAction (actionShowFontStyleColumn);
+  menu->addAction (actionShowFontSampleColumn);
+  menu->addAction (actionShowFileNameColumn);
+  menu->addAction (actionShowFilePathColumn);
+  menu->addSeparator ();
+  menu->addAction (actionResetColumns);
+  menu->popup (tableView->horizontalHeader ()->viewport ()->mapToGlobal (pos));
 }
 
-void FontList::showColumn(int column, bool show) {
-  tableView->setColumnHidden(column, !show);
+void FontList::showColumn (int column, bool show) {
+  tableView->setColumnHidden (column, !show);
   if (show) {
-    tableView->resizeColumnToContents(column);
+    tableView->resizeColumnToContents (column);
   }
 }
 
-void FontList::on_actionShowFontNameColumn_toggled(bool show)
-{
-  showColumn(COL_FONT_NAME, show);
+void FontList::on_actionShowFontNameColumn_toggled (bool show) {
+  showColumn (COL_FONT_NAME, show);
 }
 
-void FontList::on_actionShowStyledFontNameColumn_toggled(bool show)
-{
-  showColumn(COL_STYLED_FONT_NAME, show);
+void FontList::on_actionShowStyledFontNameColumn_toggled (bool show) {
+  showColumn (COL_STYLED_FONT_NAME, show);
 }
 
-void FontList::on_actionShowFontStyleColumn_toggled(bool show)
-{
-  showColumn(COL_FONT_STYLE, show);
+void FontList::on_actionShowFontStyleColumn_toggled (bool show) {
+  showColumn (COL_FONT_STYLE, show);
 }
 
-void FontList::on_actionShowFontSampleColumn_toggled(bool show)
-{
-  showColumn(COL_SAMPLE, show);
+void FontList::on_actionShowFontSampleColumn_toggled (bool show) {
+  showColumn (COL_SAMPLE, show);
 }
 
-void FontList::on_actionShowFileNameColumn_toggled(bool show)
-{
-  showColumn(COL_FILE_NAME, show);
+void FontList::on_actionShowFileNameColumn_toggled (bool show) {
+  showColumn (COL_FILE_NAME, show);
 }
 
-void FontList::on_actionShowFilePathColumn_toggled(bool show)
-{
-  showColumn(COL_FILE_PATH, show);
+void FontList::on_actionShowFilePathColumn_toggled (bool show) {
+  showColumn (COL_FILE_PATH, show);
 }
 
-void FontList::on_actionResetColumns_triggered()
-{
-  actionShowFontNameColumn->setChecked(true);
-  actionShowStyledFontNameColumn->setChecked(false);
-  actionShowFontStyleColumn->setChecked(true);
-  actionShowFontSampleColumn->setChecked(true);
-  actionShowFileNameColumn->setChecked(true);
-  actionShowFilePathColumn->setChecked(false);
+void FontList::on_actionResetColumns_triggered () {
+  actionShowFontNameColumn->setChecked (true);
+  actionShowStyledFontNameColumn->setChecked (false);
+  actionShowFontStyleColumn->setChecked (true);
+  actionShowFontSampleColumn->setChecked (true);
+  actionShowFileNameColumn->setChecked (true);
+  actionShowFilePathColumn->setChecked (false);
   // depending on the initial state of the action, the
   // toggle callback might not trigger, so force the sync
   // of the column state
-  tableView->hideColumn(COL_STYLED_FONT_NAME);
-  tableView->hideColumn(COL_FILE_PATH);
-  tableView->hideColumn(COL_HASH);
+  tableView->hideColumn (COL_STYLED_FONT_NAME);
+  tableView->hideColumn (COL_FILE_PATH);
+  tableView->hideColumn (COL_HASH);
 }
 
-void FontList::on_tableView_customContextMenuRequested(const QPoint& pos)
-{
-  auto *menu = new QMenu(this);
-  menu->addAction(actionCopyStyle);
-  menu->addSeparator();
-  menu->addAction(actionCopyFontName);
-  menu->addAction(actionCopyFolder);
-  menu->addAction(actionCopyFullPath);
-  menu->addSeparator();
-  menu->addAction(actionOpenFolder);
-  menu->popup(tableView->viewport()->mapToGlobal(pos));
+void FontList::on_tableView_customContextMenuRequested (const QPoint &pos) {
+  auto *menu = new QMenu (this);
+  menu->addAction (actionCopyStyle);
+  menu->addSeparator ();
+  menu->addAction (actionCopyFontName);
+  menu->addAction (actionCopyFolder);
+  menu->addAction (actionCopyFullPath);
+  menu->addSeparator ();
+  menu->addAction (actionOpenFolder);
+  menu->popup (tableView->viewport ()->mapToGlobal (pos));
 }
 
-const QModelIndex FontList::currentIndex() const
-{
-  return tableView->selectionModel()->currentIndex();
+const QModelIndex FontList::currentIndex () const {
+  return tableView->selectionModel ()->currentIndex ();
 }
 
-void FontList::on_actionCopyFontName_triggered()
-{
-  QApplication::clipboard()->setText(colStr(currentIndex(), COL_FONT_NAME));
+void FontList::on_actionCopyFontName_triggered () {
+  QApplication::clipboard ()->setText (colStr (currentIndex (), COL_FONT_NAME));
 }
 
-void FontList::on_actionCopyStyle_triggered()
-{
-  font_selected(selection);
-  QApplication::clipboard()->setText(selection);
+void FontList::on_actionCopyStyle_triggered () {
+  font_selected (selection);
+  QApplication::clipboard ()->setText (selection);
 }
 
-void FontList::on_actionCopyFolder_triggered()
-{
-  const QFileInfo fileInfo(colStr(currentIndex(), COL_FILE_PATH));
-  QApplication::clipboard()->setText(fileInfo.dir().canonicalPath());
+void FontList::on_actionCopyFolder_triggered () {
+  const QFileInfo fileInfo (colStr (currentIndex (), COL_FILE_PATH));
+  QApplication::clipboard ()->setText (fileInfo.dir ().canonicalPath ());
 }
 
-void FontList::on_actionCopyFullPath_triggered()
-{
-  QApplication::clipboard()->setText(colStr(currentIndex(), COL_FILE_PATH));
+void FontList::on_actionCopyFullPath_triggered () {
+  QApplication::clipboard ()->setText (colStr (currentIndex (), COL_FILE_PATH));
 }
 
-void FontList::on_actionOpenFolder_triggered()
-{
-  const QFileInfo fileInfo(colStr(currentIndex(), COL_FILE_PATH));
-  if (fileInfo.dir().exists()) {
-    QDesktopServices::openUrl(QUrl::fromLocalFile(fileInfo.dir().absolutePath()));
+void FontList::on_actionOpenFolder_triggered () {
+  const QFileInfo fileInfo (colStr (currentIndex (), COL_FILE_PATH));
+  if (fileInfo.dir ().exists ()) {
+    QDesktopServices::openUrl (QUrl::fromLocalFile (fileInfo.dir ().absolutePath ()));
   }
 }
 
-void FontList::selection_changed(const QItemSelection& current, const QItemSelection&)
-{
+void FontList::selection_changed (const QItemSelection &current, const QItemSelection &) {
   const std::array<QAction *, 5> actions = {
     actionCopyFontName,
     actionCopyStyle,
@@ -365,36 +330,35 @@ void FontList::selection_changed(const QItemSelection& current, const QItemSelec
     actionOpenFolder,
   };
 
-  const bool disabled = current.count() == 0;
+  const bool disabled = current.count () == 0;
   for (const auto action : actions) {
-    action->setDisabled(disabled);
-    action->setVisible(!disabled);
+    action->setDisabled (disabled);
+    action->setVisible (!disabled);
   }
 
   if (disabled) {
-    tableView->setDragText("");
-    lineEditFontNameSelected->setText("");
-    lineEditFontPathSelected->setText("");
-    lineEditFcStyleSelected->setText("");
+    tableView->setDragText ("");
+    lineEditFontNameSelected->setText ("");
+    lineEditFontPathSelected->setText ("");
+    lineEditFcStyleSelected->setText ("");
     return;
   }
 
-  const auto& idx = proxy->mapToSource(current.indexes().at(0));
-  const auto name = model->item(idx.row(), COL_FONT_NAME)->text();
-  const auto path = model->item(idx.row(), COL_FILE_PATH)->text();
-  const auto style = model->item(idx.row(), COL_FONT_STYLE)->text();
-  const auto fcStyle = QString("%1:style=%2").arg(quote(name)).arg(quote(style));
+  const auto &idx = proxy->mapToSource (current.indexes ().at (0));
+  const auto name = model->item (idx.row (), COL_FONT_NAME)->text ();
+  const auto path = model->item (idx.row (), COL_FILE_PATH)->text ();
+  const auto style = model->item (idx.row (), COL_FONT_STYLE)->text ();
+  const auto fcStyle = QString ("%1:style=%2").arg (quote (name)).arg (quote (style));
   this->selection = "\"" + fcStyle + "\"";
-  tableView->setDragText(this->selection);
-  lineEditFontNameSelected->setText(name);
-  lineEditFontNameSelected->setCursorPosition(0);
-  lineEditFontPathSelected->setText(path); // keep cursor at the end to prefer the file name
-  lineEditFcStyleSelected->setText(fcStyle);
-  lineEditFcStyleSelected->setCursorPosition(0);
+  tableView->setDragText (this->selection);
+  lineEditFontNameSelected->setText (name);
+  lineEditFontNameSelected->setCursorPosition (0);
+  lineEditFontPathSelected->setText (path); // keep cursor at the end to prefer the file name
+  lineEditFcStyleSelected->setText (fcStyle);
+  lineEditFcStyleSelected->setCursorPosition (0);
 }
 
-void FontList::update_font_list()
-{
+void FontList::update_font_list () {
   if (proxy) {
     delete proxy;
     proxy = nullptr;
@@ -404,72 +368,71 @@ void FontList::update_font_list()
     model = nullptr;
   }
 
-  const FontInfoList *list = FontCache::instance()->list_fonts();
-  model = new QStandardItemModel(list->size(), COL_COUNT, this);
-  model->setHorizontalHeaderItem(COL_FONT_NAME, new QStandardItem(_("Font name")));
-  model->setHorizontalHeaderItem(COL_STYLED_FONT_NAME, new QStandardItem(_("Styled font name")));
-  model->setHorizontalHeaderItem(COL_FONT_STYLE, new QStandardItem(_("Font style")));
-  model->setHorizontalHeaderItem(COL_SAMPLE, new QStandardItem(_("Sample text"))); // text handled by delegate
-  model->setHorizontalHeaderItem(COL_FILE_NAME, new QStandardItem(_("File name")));
-  model->setHorizontalHeaderItem(COL_FILE_PATH, new QStandardItem(_("File path")));
-  model->setHorizontalHeaderItem(COL_HASH, new QStandardItem(_("Hash")));
+  const FontInfoList *list = FontCache::instance ()->list_fonts ();
+  model = new QStandardItemModel (list->size (), COL_COUNT, this);
+  model->setHorizontalHeaderItem (COL_FONT_NAME, new QStandardItem (_ ("Font name")));
+  model->setHorizontalHeaderItem (COL_STYLED_FONT_NAME, new QStandardItem (_ ("Styled font name")));
+  model->setHorizontalHeaderItem (COL_FONT_STYLE, new QStandardItem (_ ("Font style")));
+  model->setHorizontalHeaderItem (COL_SAMPLE, new QStandardItem (_ ("Sample text"))); // text handled by delegate
+  model->setHorizontalHeaderItem (COL_FILE_NAME, new QStandardItem (_ ("File name")));
+  model->setHorizontalHeaderItem (COL_FILE_PATH, new QStandardItem (_ ("File path")));
+  model->setHorizontalHeaderItem (COL_HASH, new QStandardItem (_ ("Hash")));
 
   const QString toolTip = R"(<table style="white-space:pre"><tr><td>Name:</td><td><b>%1</b></td></tr><tr><td>Style:</td><td>%2</td></tr></table>)";
 
   int idx = 0;
-  for (auto it = list->begin(); it != list->end(); it++, idx++) {
-    const FontInfo& font_info = (*it);
-
-    auto *family = new QStandardItem(QString::fromStdString(font_info.get_family()));
-    family->setEditable(false);
-    model->setItem(idx, COL_FONT_NAME, family);
-
-    auto *style = new QStandardItem(QString::fromStdString(font_info.get_style()));
-    style->setEditable(false);
-    model->setItem(idx, COL_FONT_STYLE, style);
-
-    auto *styledFamily = new QStandardItem(QString::fromStdString(font_info.get_family()));
-    styledFamily->setEditable(false);
-    styledFamily->setToolTip(toolTip.arg(family->text()).arg(style->text()));
-    model->setItem(idx, COL_STYLED_FONT_NAME, styledFamily);
-
-    const QFileInfo fileInfo(QString::fromStdString(font_info.get_file()));
-    auto *file = new QStandardItem(fileInfo.fileName());
-    file->setEditable(false);
-    file->setToolTip(fileInfo.canonicalFilePath());
-    model->setItem(idx, COL_FILE_NAME, file);
-    auto *filePath = new QStandardItem(fileInfo.canonicalFilePath());
-    filePath->setEditable(false);
-    model->setItem(idx, COL_FILE_PATH, filePath);
-
-    auto *hash = new QStandardItem(QString::number(font_info.get_hash(), 16));
-    hash->setEditable(false);
-    model->setItem(idx, COL_HASH, hash);
+  for (auto it = list->begin (); it != list->end (); it++, idx++) {
+    const FontInfo &font_info = (*it);
+
+    auto *family = new QStandardItem (QString::fromStdString (font_info.get_family ()));
+    family->setEditable (false);
+    model->setItem (idx, COL_FONT_NAME, family);
+
+    auto *style = new QStandardItem (QString::fromStdString (font_info.get_style ()));
+    style->setEditable (false);
+    model->setItem (idx, COL_FONT_STYLE, style);
+
+    auto *styledFamily = new QStandardItem (QString::fromStdString (font_info.get_family ()));
+    styledFamily->setEditable (false);
+    styledFamily->setToolTip (toolTip.arg (family->text ()).arg (style->text ()));
+    model->setItem (idx, COL_STYLED_FONT_NAME, styledFamily);
+
+    const QFileInfo fileInfo (QString::fromStdString (font_info.get_file ()));
+    auto *file = new QStandardItem (fileInfo.fileName ());
+    file->setEditable (false);
+    file->setToolTip (fileInfo.canonicalFilePath ());
+    model->setItem (idx, COL_FILE_NAME, file);
+    auto *filePath = new QStandardItem (fileInfo.canonicalFilePath ());
+    filePath->setEditable (false);
+    model->setItem (idx, COL_FILE_PATH, filePath);
+
+    auto *hash = new QStandardItem (QString::number (font_info.get_hash (), 16));
+    hash->setEditable (false);
+    model->setItem (idx, COL_HASH, hash);
   }
 
-  proxy = new FontSortFilterProxyModel(this);
-  proxy->setSourceModel(model);
-  proxy->setFilterCaseSensitivity(Qt::CaseInsensitive);
-  groupBoxFilter->setTitle(QString("Filter (%1 fonts found)").arg(proxy->rowCount()));
+  proxy = new FontSortFilterProxyModel (this);
+  proxy->setSourceModel (model);
+  proxy->setFilterCaseSensitivity (Qt::CaseInsensitive);
+  groupBoxFilter->setTitle (QString ("Filter (%1 fonts found)").arg (proxy->rowCount ()));
 
-  this->tableView->setModel(proxy);
-  on_actionResetColumns_triggered();
-  this->tableView->setItemDelegateForColumn(COL_STYLED_FONT_NAME, &delegate);
-  this->tableView->setItemDelegateForColumn(COL_SAMPLE, &delegate);
-  this->tableView->setSelectionMode(QAbstractItemView::SingleSelection);
-  this->tableView->setSelectionBehavior(QAbstractItemView::SelectRows);
-  this->tableView->sortByColumn(COL_FONT_NAME, Qt::AscendingOrder);
-  this->tableView->resizeColumnsToContents();
-  this->tableView->setSortingEnabled(true);
+  this->tableView->setModel (proxy);
+  on_actionResetColumns_triggered ();
+  this->tableView->setItemDelegateForColumn (COL_STYLED_FONT_NAME, &delegate);
+  this->tableView->setItemDelegateForColumn (COL_SAMPLE, &delegate);
+  this->tableView->setSelectionMode (QAbstractItemView::SingleSelection);
+  this->tableView->setSelectionBehavior (QAbstractItemView::SelectRows);
+  this->tableView->sortByColumn (COL_FONT_NAME, Qt::AscendingOrder);
+  this->tableView->resizeColumnsToContents ();
+  this->tableView->setSortingEnabled (true);
 
-  connect(tableView->selectionModel(), &QItemSelectionModel::selectionChanged, this, &FontList::selection_changed);
+  connect (tableView->selectionModel (), &QItemSelectionModel::selectionChanged, this, &FontList::selection_changed);
 
   delete list;
 }
 
-void FontList::resizeEvent(QResizeEvent *event)
-{
-  QWidget::resizeEvent(event);
+void FontList::resizeEvent (QResizeEvent *event) {
+  QWidget::resizeEvent (event);
 }
 
 /**
@@ -485,26 +448,21 @@ void FontList::resizeEvent(QResizeEvent *event)
  * @param text unquoted string
  * @return quoted text
  */
-QString FontList::quote(const QString& text)
-{
+QString FontList::quote (const QString &text) {
   QString result = text;
-  result.replace('\\', R"(\\\\)")
-  .replace('-', "\\\\-")
-  .replace(':', "\\\\:")
-  .replace(',', "\\\\,")
-  .replace('=', "\\\\=")
-  .replace('_', "\\\\_");
+  result.replace ('\\', R"(\\\\)")
+    .replace ('-', "\\\\-")
+    .replace (':', "\\\\:")
+    .replace (',', "\\\\,")
+    .replace ('=', "\\\\=")
+    .replace ('_', "\\\\_");
   return result;
 }
 
-const QModelIndex FontList::colIdx(const QModelIndex& idx, int column)
-{
-  return idx.model()->index(idx.row(), column, idx.parent());
+const QModelIndex FontList::colIdx (const QModelIndex &idx, int column) {
+  return idx.model ()->index (idx.row (), column, idx.parent ());
 }
 
-const QString FontList::colStr(const QModelIndex& idx, int column)
-{
-  return idx.model() ?
-         idx.model()->data(colIdx(idx, column)).toString() :
-         QString{};
+const QString FontList::colStr (const QModelIndex &idx, int column) {
+  return idx.model () ? idx.model ()->data (colIdx (idx, column)).toString () : QString{};
 }
diff --git a/src/gui/FontList.h b/src/gui/FontList.h
index 5b9162219..f2d15376e 100644
--- a/src/gui/FontList.h
+++ b/src/gui/FontList.h
@@ -25,17 +25,17 @@ class FontItemDelegate : public QStyledItemDelegate
   Q_OBJECT
 
 public:
-  explicit FontItemDelegate(QObject *parent = nullptr);
-  int fontSize() const;
-  void setFontSize(int fontSize);
-  QString text() const;
-  void setText(const QString&);
-  QSize sizeHint(const QStyleOptionViewItem& option, const QModelIndex& index) const override;
-  void paint(QPainter *painter, const QStyleOptionViewItem& option, const QModelIndex& index) const override;
+  explicit FontItemDelegate (QObject *parent = nullptr);
+  int fontSize () const;
+  void setFontSize (int fontSize);
+  QString text () const;
+  void setText (const QString &);
+  QSize sizeHint (const QStyleOptionViewItem &option, const QModelIndex &index) const override;
+  void paint (QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &index) const override;
 
 protected:
-  void initStyleOption(QStyleOptionViewItem *option, const QModelIndex& index) const override;
-  QWidget *createEditor(QWidget *parent, const QStyleOptionViewItem& option, const QModelIndex& index) const override;
+  void initStyleOption (QStyleOptionViewItem *option, const QModelIndex &index) const override;
+  QWidget *createEditor (QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &index) const override;
 
 private:
   int _fontSize;
@@ -47,13 +47,13 @@ class FontSortFilterProxyModel : public QSortFilterProxyModel
   Q_OBJECT
 
 public:
-  FontSortFilterProxyModel(QObject *parent = nullptr);
+  FontSortFilterProxyModel (QObject *parent = nullptr);
 
-  void clearFilter();
-  void appendFilterHashes(const std::vector<uint32_t>&);
+  void clearFilter ();
+  void appendFilterHashes (const std::vector<uint32_t> &);
 
 protected:
-  bool filterAcceptsRow(int sourceRow, const QModelIndex& sourceParent) const override;
+  bool filterAcceptsRow (int sourceRow, const QModelIndex &sourceParent) const override;
 
 private:
   QSet<QString> filterHashes;
@@ -65,15 +65,15 @@ class FontList : public QWidget, public Ui::FontListWidget
   static constexpr char SAMPLE_TEXT_DEFAULT[] = "abcdef ABCDEF 012345 0O5S8B 1Iil !$%&/()#";
 
 public:
-  FontList(QWidget *parent = nullptr);
-  FontList(const FontList& source) = delete;
-  FontList(FontList&& source) = delete;
-  FontList& operator=(const FontList& source) = delete;
-  FontList& operator=(FontList&& source) = delete;
-  ~FontList() override = default;
+  FontList (QWidget *parent = nullptr);
+  FontList (const FontList &source) = delete;
+  FontList (FontList &&source) = delete;
+  FontList &operator= (const FontList &source) = delete;
+  FontList &operator= (FontList &&source) = delete;
+  ~FontList () override = default;
 
-  void initGUI();
-  void update_font_list();
+  void initGUI ();
+  void update_font_list ();
 
   static constexpr int COL_FONT_NAME = 0;
   static constexpr int COL_STYLED_FONT_NAME = 1;
@@ -85,49 +85,49 @@ public:
   static constexpr int COL_COUNT = 7;
 
 public slots:
-  void on_lineEditFontName_textChanged(const QString&);
-  void on_comboBoxSearchType_currentIndexChanged(int);
-  void updateFilter(int, const QString&);
-
-  void on_comboBoxCharFilterType_currentIndexChanged(int);
-  void on_lineEditChars_textChanged(const QString&);
-  void updateCharFilter(int, const QString&);
-
-  void on_actionResetSampleText_triggered();
-  void on_lineEditSampleText_textChanged(const QString&);
-  void on_spinBoxFontSize_valueChanged(int);
-  void updateSampleText(const QString&, int);
-
-  void customHeaderContexMenuRequested(const QPoint&);
-  void on_tableView_customContextMenuRequested(const QPoint&);
-  void on_actionCopyFontName_triggered();
-  void on_actionCopyStyle_triggered();
-  void on_actionCopyFolder_triggered();
-  void on_actionCopyFullPath_triggered();
-  void on_actionOpenFolder_triggered();
-  void selection_changed(const QItemSelection&, const QItemSelection&);
-
-  void showColumn(int, bool);
-  void on_actionShowFontNameColumn_toggled(bool);
-  void on_actionShowStyledFontNameColumn_toggled(bool);
-  void on_actionShowFontStyleColumn_toggled(bool);
-  void on_actionShowFontSampleColumn_toggled(bool);
-  void on_actionShowFileNameColumn_toggled(bool);
-  void on_actionShowFilePathColumn_toggled(bool);
-  void on_actionResetColumns_triggered();
-
-  static const QModelIndex colIdx(const QModelIndex& idx, int column);
-  static const QString colStr(const QModelIndex& idx, int column);
+  void on_lineEditFontName_textChanged (const QString &);
+  void on_comboBoxSearchType_currentIndexChanged (int);
+  void updateFilter (int, const QString &);
+
+  void on_comboBoxCharFilterType_currentIndexChanged (int);
+  void on_lineEditChars_textChanged (const QString &);
+  void updateCharFilter (int, const QString &);
+
+  void on_actionResetSampleText_triggered ();
+  void on_lineEditSampleText_textChanged (const QString &);
+  void on_spinBoxFontSize_valueChanged (int);
+  void updateSampleText (const QString &, int);
+
+  void customHeaderContexMenuRequested (const QPoint &);
+  void on_tableView_customContextMenuRequested (const QPoint &);
+  void on_actionCopyFontName_triggered ();
+  void on_actionCopyStyle_triggered ();
+  void on_actionCopyFolder_triggered ();
+  void on_actionCopyFullPath_triggered ();
+  void on_actionOpenFolder_triggered ();
+  void selection_changed (const QItemSelection &, const QItemSelection &);
+
+  void showColumn (int, bool);
+  void on_actionShowFontNameColumn_toggled (bool);
+  void on_actionShowStyledFontNameColumn_toggled (bool);
+  void on_actionShowFontStyleColumn_toggled (bool);
+  void on_actionShowFontSampleColumn_toggled (bool);
+  void on_actionShowFileNameColumn_toggled (bool);
+  void on_actionShowFilePathColumn_toggled (bool);
+  void on_actionResetColumns_triggered ();
+
+  static const QModelIndex colIdx (const QModelIndex &idx, int column);
+  static const QString colStr (const QModelIndex &idx, int column);
 
 signals:
-  void font_selected(const QString font);
+  void font_selected (const QString font);
 
 protected:
-  const QModelIndex currentIndex() const;
-  void resizeEvent(QResizeEvent *event) override;
+  const QModelIndex currentIndex () const;
+  void resizeEvent (QResizeEvent *event) override;
 
 private:
-  QString quote(const QString& text);
+  QString quote (const QString &text);
 
   QString selection;
   FontItemDelegate delegate;
diff --git a/src/gui/FontListDialog.cc b/src/gui/FontListDialog.cc
index 933971d1a..332f823d1 100644
--- a/src/gui/FontListDialog.cc
+++ b/src/gui/FontListDialog.cc
@@ -35,46 +35,41 @@
 
 #include "FontCache.h"
 
-FontListDialog::FontListDialog()
-{
+FontListDialog::FontListDialog () {
   model = nullptr;
   proxy = nullptr;
-  setupUi(this);
-  connect(this->okButton, &QPushButton::clicked, this, &FontListDialog::accept);
+  setupUi (this);
+  connect (this->okButton, &QPushButton::clicked, this, &FontListDialog::accept);
 }
 
-void FontListDialog::on_copyButton_clicked()
-{
-  font_selected(selection);
+void FontListDialog::on_copyButton_clicked () {
+  font_selected (selection);
 
-  QClipboard *clipboard = QApplication::clipboard();
-  clipboard->setText(selection);
+  QClipboard *clipboard = QApplication::clipboard ();
+  clipboard->setText (selection);
 }
 
-void FontListDialog::on_filterLineEdit_textChanged(const QString& text)
-{
-  proxy->setFilterWildcard(text);
+void FontListDialog::on_filterLineEdit_textChanged (const QString &text) {
+  proxy->setFilterWildcard (text);
 }
 
-void FontListDialog::selection_changed(const QItemSelection& current, const QItemSelection&)
-{
-  if (current.count() == 0) {
-    copyButton->setEnabled(false);
-    tableView->setDragText("");
+void FontListDialog::selection_changed (const QItemSelection &current, const QItemSelection &) {
+  if (current.count () == 0) {
+    copyButton->setEnabled (false);
+    tableView->setDragText ("");
     return;
   }
 
-  const QModelIndex& idx = proxy->mapToSource(current.indexes().at(0));
-  const QString name = model->item(idx.row(), 0)->text();
-  const QString style = model->item(idx.row(), 1)->text();
-  selection = QString("\"%1:style=%2\"").arg(quote(name)).arg(quote(style));
-  copyButton->setEnabled(true);
-  tableView->setDragText(selection);
+  const QModelIndex &idx = proxy->mapToSource (current.indexes ().at (0));
+  const QString name = model->item (idx.row (), 0)->text ();
+  const QString style = model->item (idx.row (), 1)->text ();
+  selection = QString ("\"%1:style=%2\"").arg (quote (name)).arg (quote (style));
+  copyButton->setEnabled (true);
+  tableView->setDragText (selection);
 }
 
-void FontListDialog::updateFontList()
-{
-  copyButton->setEnabled(false);
+void FontListDialog::updateFontList () {
+  copyButton->setEnabled (false);
 
   if (proxy) {
     delete proxy;
@@ -85,37 +80,37 @@ void FontListDialog::updateFontList()
     model = nullptr;
   }
 
-  FontInfoList *list = FontCache::instance()->list_fonts();
-  model = new QStandardItemModel(list->size(), 3, this);
-  model->setHorizontalHeaderItem(0, new QStandardItem(_("Font name")));
-  model->setHorizontalHeaderItem(1, new QStandardItem(_("Font style")));
-  model->setHorizontalHeaderItem(2, new QStandardItem(_("Filename")));
+  FontInfoList *list = FontCache::instance ()->list_fonts ();
+  model = new QStandardItemModel (list->size (), 3, this);
+  model->setHorizontalHeaderItem (0, new QStandardItem (_ ("Font name")));
+  model->setHorizontalHeaderItem (1, new QStandardItem (_ ("Font style")));
+  model->setHorizontalHeaderItem (2, new QStandardItem (_ ("Filename")));
 
   int idx = 0;
-  for (auto it = list->begin(); it != list->end(); it++, idx++) {
-    const FontInfo& font_info = (*it);
-    auto *family = new QStandardItem(QString(font_info.get_family().c_str()));
-    family->setEditable(false);
-    model->setItem(idx, 0, family);
-    auto *style = new QStandardItem(QString(font_info.get_style().c_str()));
-    style->setEditable(false);
-    model->setItem(idx, 1, style);
-    auto *file = new QStandardItem(QString(font_info.get_file().c_str()));
-    file->setEditable(false);
-    model->setItem(idx, 2, file);
+  for (auto it = list->begin (); it != list->end (); it++, idx++) {
+    const FontInfo &font_info = (*it);
+    auto *family = new QStandardItem (QString (font_info.get_family ().c_str ()));
+    family->setEditable (false);
+    model->setItem (idx, 0, family);
+    auto *style = new QStandardItem (QString (font_info.get_style ().c_str ()));
+    style->setEditable (false);
+    model->setItem (idx, 1, style);
+    auto *file = new QStandardItem (QString (font_info.get_file ().c_str ()));
+    file->setEditable (false);
+    model->setItem (idx, 2, file);
   }
 
-  proxy = new QSortFilterProxyModel(this);
-  proxy->setSourceModel(model);
-  proxy->setFilterCaseSensitivity(Qt::CaseInsensitive);
+  proxy = new QSortFilterProxyModel (this);
+  proxy->setSourceModel (model);
+  proxy->setFilterCaseSensitivity (Qt::CaseInsensitive);
 
-  this->tableView->setModel(proxy);
-  this->tableView->setSelectionMode(QAbstractItemView::SingleSelection);
-  this->tableView->sortByColumn(0, Qt::AscendingOrder);
-  this->tableView->resizeColumnsToContents();
-  this->tableView->setSortingEnabled(true);
+  this->tableView->setModel (proxy);
+  this->tableView->setSelectionMode (QAbstractItemView::SingleSelection);
+  this->tableView->sortByColumn (0, Qt::AscendingOrder);
+  this->tableView->resizeColumnsToContents ();
+  this->tableView->setSortingEnabled (true);
 
-  connect(tableView->selectionModel(), &QItemSelectionModel::selectionChanged, this, &FontListDialog::selection_changed);
+  connect (tableView->selectionModel (), &QItemSelectionModel::selectionChanged, this, &FontListDialog::selection_changed);
 
   delete list;
 }
@@ -133,14 +128,13 @@ void FontListDialog::updateFontList()
  * @param text unquoted string
  * @return quoted text
  */
-QString FontListDialog::quote(const QString& text)
-{
+QString FontListDialog::quote (const QString &text) {
   QString result = text;
-  result.replace('\\', R"(\\\\)")
-  .replace('-', "\\\\-")
-  .replace(':', "\\\\:")
-  .replace(',', "\\\\,")
-  .replace('=', "\\\\=")
-  .replace('_', "\\\\_");
+  result.replace ('\\', R"(\\\\)")
+    .replace ('-', "\\\\-")
+    .replace (':', "\\\\:")
+    .replace (',', "\\\\,")
+    .replace ('=', "\\\\=")
+    .replace ('_', "\\\\_");
   return result;
 }
diff --git a/src/gui/FontListDialog.h b/src/gui/FontListDialog.h
index 89f540b51..78ec91c7d 100644
--- a/src/gui/FontListDialog.h
+++ b/src/gui/FontListDialog.h
@@ -12,21 +12,22 @@
 class FontListDialog : public QDialog, public Ui::FontListDialog
 {
   Q_OBJECT;
+
 public:
-  FontListDialog();
+  FontListDialog ();
 
-  void updateFontList();
+  void updateFontList ();
 
 public slots:
-  void on_copyButton_clicked();
-  void on_filterLineEdit_textChanged(const QString&);
-  void selection_changed(const QItemSelection&, const QItemSelection&);
+  void on_copyButton_clicked ();
+  void on_filterLineEdit_textChanged (const QString &);
+  void selection_changed (const QItemSelection &, const QItemSelection &);
 
 signals:
-  void font_selected(const QString font);
+  void font_selected (const QString font);
 
 private:
-  QString quote(const QString& text);
+  QString quote (const QString &text);
 
   QString selection;
   QStandardItemModel *model;
diff --git a/src/gui/FontListTableView.cc b/src/gui/FontListTableView.cc
index 00bf5291b..889aa3f7d 100644
--- a/src/gui/FontListTableView.cc
+++ b/src/gui/FontListTableView.cc
@@ -34,35 +34,34 @@
 #include <QMimeData>
 #include <QTableView>
 
-FontListTableView::FontListTableView(QWidget *parent) : QTableView(parent)
-{
+FontListTableView::FontListTableView (QWidget *parent)
+  : QTableView (parent) {
 }
 
-void FontListTableView::setDragText(const QString& text)
-{
-  this->text = text.trimmed();
+void FontListTableView::setDragText (const QString &text) {
+  this->text = text.trimmed ();
 }
 
-void FontListTableView::startDrag(Qt::DropActions supportedActions)
-{
-  if (text.isEmpty()) return;
+void FontListTableView::startDrag (Qt::DropActions supportedActions) {
+  if (text.isEmpty ())
+    return;
 
   auto mimeData = new QMimeData;
-  mimeData->setText(text);
+  mimeData->setText (text);
 
-  QFontMetrics fm(font());
-  QRect rect(0, 0, fm.boundingRect(text).width() + 8, fm.height() + 8);
-  QPixmap pixmap(rect.width(), rect.height());
-  pixmap.fill({240, 240, 240, 160});
+  QFontMetrics fm (font ());
+  QRect rect (0, 0, fm.boundingRect (text).width () + 8, fm.height () + 8);
+  QPixmap pixmap (rect.width (), rect.height ());
+  pixmap.fill ({240, 240, 240, 160});
 
-  QPainter painter(&pixmap);
-  painter.setFont(font());
-  painter.drawText(rect, Qt::AlignCenter, text);
-  painter.drawRect(0, 0, rect.width() - 1, rect.height() - 1);
+  QPainter painter (&pixmap);
+  painter.setFont (font ());
+  painter.drawText (rect, Qt::AlignCenter, text);
+  painter.drawRect (0, 0, rect.width () - 1, rect.height () - 1);
 
-  auto drag = new QDrag(this);
-  drag->setPixmap(pixmap);
-  drag->setMimeData(mimeData);
-  drag->setHotSpot({-10, rect.height() + 6});
-  drag->exec(supportedActions, Qt::CopyAction);
+  auto drag = new QDrag (this);
+  drag->setPixmap (pixmap);
+  drag->setMimeData (mimeData);
+  drag->setHotSpot ({-10, rect.height () + 6});
+  drag->exec (supportedActions, Qt::CopyAction);
 }
diff --git a/src/gui/FontListTableView.h b/src/gui/FontListTableView.h
index f2f0b4496..c6e46979b 100644
--- a/src/gui/FontListTableView.h
+++ b/src/gui/FontListTableView.h
@@ -9,11 +9,11 @@ class FontListTableView : public QTableView
   Q_OBJECT;
 
 public:
-  FontListTableView(QWidget *parent = nullptr);
-  void setDragText(const QString& text);
+  FontListTableView (QWidget *parent = nullptr);
+  void setDragText (const QString &text);
 
 protected:
-  void startDrag(Qt::DropActions supportedActions) override;
+  void startDrag (Qt::DropActions supportedActions) override;
 
 private:
   QString text;
diff --git a/src/gui/IgnoreWheelWhenNotFocused.cc b/src/gui/IgnoreWheelWhenNotFocused.cc
index fc12a915b..24e4661aa 100644
--- a/src/gui/IgnoreWheelWhenNotFocused.cc
+++ b/src/gui/IgnoreWheelWhenNotFocused.cc
@@ -6,49 +6,47 @@
 #include <QSpinBox>
 #include <QDoubleSpinBox>
 
-void installIgnoreWheelWhenNotFocused(QWidget *parent){
-  auto comboBoxes = parent->findChildren<QComboBox *>();
-  auto spinBoxes = parent->findChildren<QSpinBox *>();
-  auto spinDoubleBoxes = parent->findChildren<QDoubleSpinBox *>();
+void installIgnoreWheelWhenNotFocused (QWidget *parent) {
+  auto comboBoxes = parent->findChildren<QComboBox *> ();
+  auto spinBoxes = parent->findChildren<QSpinBox *> ();
+  auto spinDoubleBoxes = parent->findChildren<QDoubleSpinBox *> ();
 
-  if (comboBoxes.size() == 0 && spinBoxes.size() == 0 && spinDoubleBoxes.size() == 0){
+  if (comboBoxes.size () == 0 && spinBoxes.size () == 0 && spinDoubleBoxes.size () == 0) {
     return; //nothing do
   }
 
-  auto *ignoreWheelWhenNotFocused = new IgnoreWheelWhenNotFocused(parent);
+  auto *ignoreWheelWhenNotFocused = new IgnoreWheelWhenNotFocused (parent);
 
   for (auto comboBox : comboBoxes) {
-    comboBox->installEventFilter(ignoreWheelWhenNotFocused);
-    comboBox->setFocusPolicy(Qt::StrongFocus);
+    comboBox->installEventFilter (ignoreWheelWhenNotFocused);
+    comboBox->setFocusPolicy (Qt::StrongFocus);
   }
 
-  for (const auto& spinBox : spinBoxes){
-    spinBox->installEventFilter(ignoreWheelWhenNotFocused);
-    spinBox->setFocusPolicy(Qt::StrongFocus);
+  for (const auto &spinBox : spinBoxes) {
+    spinBox->installEventFilter (ignoreWheelWhenNotFocused);
+    spinBox->setFocusPolicy (Qt::StrongFocus);
   }
 
   for (auto spinDoubleBox : spinDoubleBoxes) {
-    spinDoubleBox->installEventFilter(ignoreWheelWhenNotFocused);
-    spinDoubleBox->setFocusPolicy(Qt::StrongFocus);
+    spinDoubleBox->installEventFilter (ignoreWheelWhenNotFocused);
+    spinDoubleBox->setFocusPolicy (Qt::StrongFocus);
   }
 
-}  // NOLINT(clang-analyzer-cplusplus.NewDeleteLeaks): False positive
+} // NOLINT(clang-analyzer-cplusplus.NewDeleteLeaks): False positive
 
-IgnoreWheelWhenNotFocused::IgnoreWheelWhenNotFocused(QWidget *parent) : QObject(parent)
-{
+IgnoreWheelWhenNotFocused::IgnoreWheelWhenNotFocused (QWidget *parent)
+  : QObject (parent) {
 }
 
 //https://stackoverflow.com/questions/5821802/qspinbox-inside-a-qscrollarea-how-to-prevent-spin-box-from-stealing-focus-when
-bool IgnoreWheelWhenNotFocused::eventFilter(QObject *obj, QEvent *event)
-{
-  if (event->type() == QEvent::Wheel) {
-    if (!((QWidget *)obj)->hasFocus()) {
+bool IgnoreWheelWhenNotFocused::eventFilter (QObject *obj, QEvent *event) {
+  if (event->type () == QEvent::Wheel) {
+    if (!((QWidget *)obj)->hasFocus ()) {
       return true;
     } else {
-      return QObject::eventFilter(obj, event);
+      return QObject::eventFilter (obj, event);
     }
   } else {
-    return QObject::eventFilter(obj, event);
+    return QObject::eventFilter (obj, event);
   }
 }
-
diff --git a/src/gui/IgnoreWheelWhenNotFocused.h b/src/gui/IgnoreWheelWhenNotFocused.h
index 192b80d77..f4c5d1344 100644
--- a/src/gui/IgnoreWheelWhenNotFocused.h
+++ b/src/gui/IgnoreWheelWhenNotFocused.h
@@ -17,15 +17,14 @@
 #include <QWidget>
 #include <QMouseEvent>
 
-void installIgnoreWheelWhenNotFocused(QWidget *parent);
+void installIgnoreWheelWhenNotFocused (QWidget *parent);
 
 class IgnoreWheelWhenNotFocused : public QObject
 {
   Q_OBJECT
 public:
-  IgnoreWheelWhenNotFocused(QWidget *parent);
+  IgnoreWheelWhenNotFocused (QWidget *parent);
 
 protected:
-  bool eventFilter(QObject *obj, QEvent *event) override;
+  bool eventFilter (QObject *obj, QEvent *event) override;
 };
-
diff --git a/src/gui/ImportUtils.cc b/src/gui/ImportUtils.cc
index 25097a58d..9fbbfef9d 100644
--- a/src/gui/ImportUtils.cc
+++ b/src/gui/ImportUtils.cc
@@ -2,7 +2,7 @@
 
 QMap<QString, QString> Importer::knownFileExtensions;
 
-int Importer::init(){
+int Importer::init () {
   const QString importStatement = "import(\"%1\");\n";
   const QString surfaceStatement = "surface(\"%1\");\n";
   const QString importFunction = "data = import(\"%1\");\n";
@@ -24,4 +24,4 @@ int Importer::init(){
   return 0;
 }
 
-int forceInit = Importer::init();
+int forceInit = Importer::init ();
diff --git a/src/gui/ImportUtils.h b/src/gui/ImportUtils.h
index f186ad3c8..380813cc9 100644
--- a/src/gui/ImportUtils.h
+++ b/src/gui/ImportUtils.h
@@ -6,6 +6,6 @@
 class Importer
 {
 public:
-  static int init();
+  static int init ();
   static QMap<QString, QString> knownFileExtensions;
 };
diff --git a/src/gui/InitConfigurator.cc b/src/gui/InitConfigurator.cc
index 14ed64320..1f2c24e66 100644
--- a/src/gui/InitConfigurator.cc
+++ b/src/gui/InitConfigurator.cc
@@ -17,88 +17,81 @@
 
 #include <string>
 
-void InitConfigurator::writeSettings()
-{
-  Settings::Settings::visit(SettingsWriter());
+void InitConfigurator::writeSettings () {
+  Settings::Settings::visit (SettingsWriter ());
 }
 
-void InitConfigurator::initUpdateCheckBox(const BlockSignals<QCheckBox *>& checkBox, const Settings::SettingsEntryBool& entry)
-{
-  checkBox->setChecked(entry.value());
+void InitConfigurator::initUpdateCheckBox (const BlockSignals<QCheckBox *> &checkBox, const Settings::SettingsEntryBool &entry) {
+  checkBox->setChecked (entry.value ());
 }
 
-void InitConfigurator::initIntSpinBox(const BlockSignals<QSpinBox *>& spinBox, const Settings::SettingsEntryInt& entry)
-{
-  spinBox->setMinimum(entry.minimum());
-  spinBox->setMaximum(entry.maximum());
+void InitConfigurator::initIntSpinBox (const BlockSignals<QSpinBox *> &spinBox, const Settings::SettingsEntryInt &entry) {
+  spinBox->setMinimum (entry.minimum ());
+  spinBox->setMaximum (entry.maximum ());
 }
 
-void InitConfigurator::updateIntSpinBox(const BlockSignals<QSpinBox *>& spinBox, const Settings::SettingsEntryInt& entry)
-{
-  spinBox->setValue(entry.value());
+void InitConfigurator::updateIntSpinBox (const BlockSignals<QSpinBox *> &spinBox, const Settings::SettingsEntryInt &entry) {
+  spinBox->setValue (entry.value ());
 }
 
-void InitConfigurator::initUpdateDoubleSpinBox(QDoubleSpinBox *spinBox, const Settings::SettingsEntryDouble& entry)
-{
-  spinBox->blockSignals(true);
-  spinBox->setSingleStep(entry.step());
-  spinBox->setMinimum(entry.minimum());
-  spinBox->setMaximum(entry.maximum());
-  spinBox->setValue(entry.value());
-  spinBox->blockSignals(false);
+void InitConfigurator::initUpdateDoubleSpinBox (QDoubleSpinBox *spinBox, const Settings::SettingsEntryDouble &entry) {
+  spinBox->blockSignals (true);
+  spinBox->setSingleStep (entry.step ());
+  spinBox->setMinimum (entry.minimum ());
+  spinBox->setMaximum (entry.maximum ());
+  spinBox->setValue (entry.value ());
+  spinBox->blockSignals (false);
 }
 
-void InitConfigurator::initListBox(QListWidget *listBox, const Settings::SettingsEntryList<Settings::LocalAppParameter>& list)
-{
-  listBox->blockSignals(true);
-  listBox->clear();
-  for (const auto& listitem : list.value()) {
+void InitConfigurator::initListBox (QListWidget *listBox, const Settings::SettingsEntryList<Settings::LocalAppParameter> &list) {
+  listBox->blockSignals (true);
+  listBox->clear ();
+  for (const auto &listitem : list.value ()) {
     if (listitem.type == Settings::LocalAppParameterType::string) {
-      const auto item = createListItem(Settings::LocalAppParameterType(Settings::LocalAppParameterType::string), QString::fromStdString(listitem.value));
-      listBox->insertItem(listBox->count(), item);
+      const auto item = createListItem (Settings::LocalAppParameterType (Settings::LocalAppParameterType::string), QString::fromStdString (listitem.value));
+      listBox->insertItem (listBox->count (), item);
     } else if (listitem.type == Settings::LocalAppParameterType::file) {
-      const auto item = createListItem(Settings::LocalAppParameterType(Settings::LocalAppParameterType::file));
-      listBox->insertItem(listBox->count(), item);
+      const auto item = createListItem (Settings::LocalAppParameterType (Settings::LocalAppParameterType::file));
+      listBox->insertItem (listBox->count (), item);
     } else if (listitem.type == Settings::LocalAppParameterType::dir) {
-      const auto item = createListItem(Settings::LocalAppParameterType(Settings::LocalAppParameterType::dir));
-      listBox->insertItem(listBox->count(), item);
+      const auto item = createListItem (Settings::LocalAppParameterType (Settings::LocalAppParameterType::dir));
+      listBox->insertItem (listBox->count (), item);
     } else if (listitem.type == Settings::LocalAppParameterType::extension) {
-      const auto item = createListItem(Settings::LocalAppParameterType(Settings::LocalAppParameterType::extension));
-      listBox->insertItem(listBox->count(), item);
+      const auto item = createListItem (Settings::LocalAppParameterType (Settings::LocalAppParameterType::extension));
+      listBox->insertItem (listBox->count (), item);
     } else if (listitem.type == Settings::LocalAppParameterType::source) {
-      const auto item = createListItem(Settings::LocalAppParameterType(Settings::LocalAppParameterType::source));
-      listBox->insertItem(listBox->count(), item);
+      const auto item = createListItem (Settings::LocalAppParameterType (Settings::LocalAppParameterType::source));
+      listBox->insertItem (listBox->count (), item);
     } else if (listitem.type == Settings::LocalAppParameterType::sourcedir) {
-      const auto item = createListItem(Settings::LocalAppParameterType(Settings::LocalAppParameterType::sourcedir));
-      listBox->insertItem(listBox->count(), item);
+      const auto item = createListItem (Settings::LocalAppParameterType (Settings::LocalAppParameterType::sourcedir));
+      listBox->insertItem (listBox->count (), item);
     }
   }
-  listBox->selectionModel()->clearSelection();
-  listBox->blockSignals(false);
+  listBox->selectionModel ()->clearSelection ();
+  listBox->blockSignals (false);
 }
 
-void InitConfigurator::updateComboBox(const BlockSignals<QComboBox *>& comboBox, const std::string& value)
-{
-  int index = comboBox->findData(QString::fromStdString(value));
+void InitConfigurator::updateComboBox (const BlockSignals<QComboBox *> &comboBox, const std::string &value) {
+  int index = comboBox->findData (QString::fromStdString (value));
   if (index >= 0) {
-    comboBox->setCurrentIndex(index);
+    comboBox->setCurrentIndex (index);
   } else {
-    comboBox->setCurrentIndex(0);
+    comboBox->setCurrentIndex (0);
   }
 }
 
-void InitConfigurator::initMetaData(QCheckBox *checkBox, QLineEdit *lineEdit, Settings::SettingsEntryBool *settingsEntryFlag, Settings::SettingsEntryString& settingsEntry) {
-  lineEdit->setText(QString::fromStdString(settingsEntry.value()));
+void InitConfigurator::initMetaData (QCheckBox *checkBox, QLineEdit *lineEdit, Settings::SettingsEntryBool *settingsEntryFlag, Settings::SettingsEntryString &settingsEntry) {
+  lineEdit->setText (QString::fromStdString (settingsEntry.value ()));
   if (checkBox && settingsEntryFlag) {
-    checkBox->setChecked(settingsEntryFlag->value());
+    checkBox->setChecked (settingsEntryFlag->value ());
   }
 }
 
-void InitConfigurator::applyMetaData(const QCheckBox *checkBox, const QLineEdit *lineEdit, Settings::SettingsEntryBool *settingsEntryFlag, Settings::SettingsEntryString& settingsEntry) {
+void InitConfigurator::applyMetaData (const QCheckBox *checkBox, const QLineEdit *lineEdit, Settings::SettingsEntryBool *settingsEntryFlag, Settings::SettingsEntryString &settingsEntry) {
   if (checkBox && settingsEntryFlag) {
-    settingsEntryFlag->setValue(checkBox->isChecked());
+    settingsEntryFlag->setValue (checkBox->isChecked ());
   }
-  const auto value = lineEdit->text().trimmed().toStdString();
-  settingsEntry.setValue(value);
+  const auto value = lineEdit->text ().trimmed ().toStdString ();
+  settingsEntry.setValue (value);
   return;
 }
diff --git a/src/gui/InitConfigurator.h b/src/gui/InitConfigurator.h
index 10557128c..3cf8d99cd 100644
--- a/src/gui/InitConfigurator.h
+++ b/src/gui/InitConfigurator.h
@@ -16,12 +16,19 @@ template <class WidgetPtr>
 class BlockSignals
 {
 public:
-  BlockSignals(WidgetPtr w) : w(w) { w->blockSignals(true); }
-  ~BlockSignals() { w->blockSignals(false); }
-  WidgetPtr operator->() const { return w; }
+  BlockSignals (WidgetPtr w)
+    : w (w) {
+    w->blockSignals (true);
+  }
+  ~BlockSignals () {
+    w->blockSignals (false);
+  }
+  WidgetPtr operator->() const {
+    return w;
+  }
 
-  BlockSignals(const BlockSignals&) = delete;
-  BlockSignals& operator=(BlockSignals const&) = delete;
+  BlockSignals (const BlockSignals &) = delete;
+  BlockSignals &operator= (BlockSignals const &) = delete;
 
 private:
   WidgetPtr w;
@@ -30,83 +37,79 @@ private:
 class InitConfigurator
 {
 protected:
-  void writeSettings();
+  void writeSettings ();
   /** Set checkbox status from the settings value */
-  void initUpdateCheckBox(const BlockSignals<QCheckBox *>& checkBox, const Settings::SettingsEntryBool& entry);
+  void initUpdateCheckBox (const BlockSignals<QCheckBox *> &checkBox, const Settings::SettingsEntryBool &entry);
   /** Initialize spinbox min/max values from the settings range values */
-  void initIntSpinBox(const BlockSignals<QSpinBox *>& spinBox, const Settings::SettingsEntryInt& entry);
+  void initIntSpinBox (const BlockSignals<QSpinBox *> &spinBox, const Settings::SettingsEntryInt &entry);
   /** Set spinbox value from the settings value */
-  void updateIntSpinBox(const BlockSignals<QSpinBox *>& spinBox, const Settings::SettingsEntryInt& entry);
+  void updateIntSpinBox (const BlockSignals<QSpinBox *> &spinBox, const Settings::SettingsEntryInt &entry);
   /** Set spinbox value and min/max/step from the settings value */
-  void initUpdateDoubleSpinBox(QDoubleSpinBox *spinBox, const Settings::SettingsEntryDouble& entry);
+  void initUpdateDoubleSpinBox (QDoubleSpinBox *spinBox, const Settings::SettingsEntryDouble &entry);
   /** Initialize specialized list box */
-  void initListBox(QListWidget *listBox, const Settings::SettingsEntryList<Settings::LocalAppParameter>& list);
+  void initListBox (QListWidget *listBox, const Settings::SettingsEntryList<Settings::LocalAppParameter> &list);
   /** Initialize combobox list values from the settings range values */
   template <typename enum_type>
-  void initComboBox(QComboBox *comboBox, const Settings::SettingsEntryEnum<enum_type>& entry);
+  void initComboBox (QComboBox *comboBox, const Settings::SettingsEntryEnum<enum_type> &entry);
   /** Update combobox from current settings */
   template <typename enum_type>
-  void updateComboBox(const BlockSignals<QComboBox *>& comboBox, const Settings::SettingsEntryEnum<enum_type>& entry);
+  void updateComboBox (const BlockSignals<QComboBox *> &comboBox, const Settings::SettingsEntryEnum<enum_type> &entry);
   /** Update combobox from current settings */
-  void updateComboBox(const BlockSignals<QComboBox *>& comboBox, const std::string& value);
+  void updateComboBox (const BlockSignals<QComboBox *> &comboBox, const std::string &value);
   /** Init a button group with an enum setting, this needs a custom property on the radio buttons */
   template <typename enum_type>
-  void initButtonGroup(const BlockSignals<QButtonGroup *>& buttonGroup, const Settings::SettingsEntryEnum<enum_type>& entry);
+  void initButtonGroup (const BlockSignals<QButtonGroup *> &buttonGroup, const Settings::SettingsEntryEnum<enum_type> &entry);
   /** Apply selected value from button to settings, this needs a custom property on the radio buttons */
   template <typename enum_type>
-  void applyButtonGroup(const BlockSignals<QButtonGroup *>& buttonGroup, Settings::SettingsEntryEnum<enum_type>& entry);
+  void applyButtonGroup (const BlockSignals<QButtonGroup *> &buttonGroup, Settings::SettingsEntryEnum<enum_type> &entry);
 
-  void initMetaData(QCheckBox *, QLineEdit *, Settings::SettingsEntryBool *, Settings::SettingsEntryString&);
-  void applyMetaData(const QCheckBox *, const QLineEdit *, Settings::SettingsEntryBool *, Settings::SettingsEntryString&);
+  void initMetaData (QCheckBox *, QLineEdit *, Settings::SettingsEntryBool *, Settings::SettingsEntryString &);
+  void applyMetaData (const QCheckBox *, const QLineEdit *, Settings::SettingsEntryBool *, Settings::SettingsEntryString &);
 
   template <typename item_type>
-  QListWidgetItem *createListItem(const item_type& itemType, const QString& text = "", bool editable = false) {
-    const auto icon = QIcon::fromTheme(QString::fromStdString(itemType.icon()));
-    std::string description = itemType.description();
-    const auto itemText = description.empty() ? text : QString::fromStdString(description);
-    const auto listItem = new QListWidgetItem(icon, itemText,
-                                              nullptr,
-                                              static_cast<int>(QListWidgetItem::UserType) + static_cast<int>(itemType));
+  QListWidgetItem *createListItem (const item_type &itemType, const QString &text = "", bool editable = false) {
+    const auto icon = QIcon::fromTheme (QString::fromStdString (itemType.icon ()));
+    std::string description = itemType.description ();
+    const auto itemText = description.empty () ? text : QString::fromStdString (description);
+    const auto listItem = new QListWidgetItem (icon, itemText,
+                                               nullptr,
+                                               static_cast<int> (QListWidgetItem::UserType) + static_cast<int> (itemType));
     if (editable) {
-      listItem->setFlags(listItem->flags() | Qt::ItemIsEditable);
+      listItem->setFlags (listItem->flags () | Qt::ItemIsEditable);
     }
     return listItem;
   }
 };
 
 template <typename enum_type>
-void InitConfigurator::initComboBox(QComboBox *comboBox, const Settings::SettingsEntryEnum<enum_type>& entry)
-{
-  comboBox->clear();
-  for (const auto& item : entry.items()) {
-    comboBox->addItem(QString::fromStdString(item.description), QString::fromStdString(item.name));
+void InitConfigurator::initComboBox (QComboBox *comboBox, const Settings::SettingsEntryEnum<enum_type> &entry) {
+  comboBox->clear ();
+  for (const auto &item : entry.items ()) {
+    comboBox->addItem (QString::fromStdString (item.description), QString::fromStdString (item.name));
   }
-  updateComboBox(comboBox, entry);
+  updateComboBox (comboBox, entry);
 }
 
 template <typename enum_type>
-void InitConfigurator::updateComboBox(const BlockSignals<QComboBox *>& comboBox, const Settings::SettingsEntryEnum<enum_type>& entry)
-{
-  comboBox->setCurrentIndex(entry.index());
+void InitConfigurator::updateComboBox (const BlockSignals<QComboBox *> &comboBox, const Settings::SettingsEntryEnum<enum_type> &entry) {
+  comboBox->setCurrentIndex (entry.index ());
 }
 
 template <typename enum_type>
-void InitConfigurator::initButtonGroup(const BlockSignals<QButtonGroup *>& buttonGroup, const Settings::SettingsEntryEnum<enum_type>& entry)
-{
-  for (const auto button : buttonGroup->buttons()) {
-    const auto settingsValue = button->property(Settings::PROPERTY_NAME).toString().toStdString();
-    if (settingsValue == entry.item().name) {
-      button->setChecked(true);
+void InitConfigurator::initButtonGroup (const BlockSignals<QButtonGroup *> &buttonGroup, const Settings::SettingsEntryEnum<enum_type> &entry) {
+  for (const auto button : buttonGroup->buttons ()) {
+    const auto settingsValue = button->property (Settings::PROPERTY_NAME).toString ().toStdString ();
+    if (settingsValue == entry.item ().name) {
+      button->setChecked (true);
     }
   }
 }
 
 template <typename enum_type>
-void InitConfigurator::applyButtonGroup(const BlockSignals<QButtonGroup *>& buttonGroup, Settings::SettingsEntryEnum<enum_type>& entry)
-{
-  const auto button = buttonGroup->checkedButton();
+void InitConfigurator::applyButtonGroup (const BlockSignals<QButtonGroup *> &buttonGroup, Settings::SettingsEntryEnum<enum_type> &entry) {
+  const auto button = buttonGroup->checkedButton ();
   if (button) {
-    const auto settingsValue = button->property(Settings::PROPERTY_NAME).toString().toStdString();
-    entry.setValue(entry.decode(settingsValue));
+    const auto settingsValue = button->property (Settings::PROPERTY_NAME).toString ().toStdString ();
+    entry.setValue (entry.decode (settingsValue));
   }
 }
diff --git a/src/gui/LaunchingScreen.cc b/src/gui/LaunchingScreen.cc
index adc36e103..7c0c4ac67 100644
--- a/src/gui/LaunchingScreen.cc
+++ b/src/gui/LaunchingScreen.cc
@@ -16,144 +16,132 @@
 
 LaunchingScreen *LaunchingScreen::inst = nullptr;
 
-LaunchingScreen *LaunchingScreen::getDialog() {
+LaunchingScreen *LaunchingScreen::getDialog () {
   return LaunchingScreen::inst;
 }
 
 // Called (possibly multiple times) by EventFilter on MacOS, e.g.
 // when the user opens files from Finder.
-void LaunchingScreen::openFile(const QString& filename)
-{
-  QVariant v(filename);
-  this->checkOpen(v, false);
-  this->done(QDialog::Accepted);
+void LaunchingScreen::openFile (const QString &filename) {
+  QVariant v (filename);
+  this->checkOpen (v, false);
+  this->done (QDialog::Accepted);
 }
 
-LaunchingScreen::LaunchingScreen(QWidget *parent) : QDialog(parent)
-{
+LaunchingScreen::LaunchingScreen (QWidget *parent)
+  : QDialog (parent) {
   LaunchingScreen::inst = this;
-  setupUi(this);
+  setupUi (this);
 
-  this->setStyleSheet("QDialog {background-image:url(':/icons/background.png')} QPushButton {color:white;}");
+  this->setStyleSheet ("QDialog {background-image:url(':/icons/background.png')} QPushButton {color:white;}");
 
-  this->versionNumberLabel->setText("OpenSCAD " + QString::fromStdString(openscad_displayversionnumber));
+  this->versionNumberLabel->setText ("OpenSCAD " + QString::fromStdString (openscad_displayversionnumber));
 
-  QStringList recentFiles = UIUtils::recentFiles();
-  for (const auto& recentFile : recentFiles) {
-    QFileInfo fileInfo(recentFile);
-    auto item = new QListWidgetItem(fileInfo.fileName());
-    item->setData(Qt::ToolTipRole, fileInfo.canonicalPath());
-    item->setData(Qt::UserRole, fileInfo.canonicalFilePath());
-    this->recentList->addItem(item);
+  QStringList recentFiles = UIUtils::recentFiles ();
+  for (const auto &recentFile : recentFiles) {
+    QFileInfo fileInfo (recentFile);
+    auto item = new QListWidgetItem (fileInfo.fileName ());
+    item->setData (Qt::ToolTipRole, fileInfo.canonicalPath ());
+    item->setData (Qt::UserRole, fileInfo.canonicalFilePath ());
+    this->recentList->addItem (item);
   }
 
-  for (const auto& category : UIUtils::exampleCategories()) {
-    auto examples = UIUtils::exampleFiles(category.name);
-    auto categoryItem = new QTreeWidgetItem(QStringList(gettext(category.name.toStdString().c_str())));
-    if (!category.tooltip.trimmed().isEmpty()) {
-      categoryItem->setToolTip(0, gettext(category.tooltip.toStdString().c_str()));
+  for (const auto &category : UIUtils::exampleCategories ()) {
+    auto examples = UIUtils::exampleFiles (category.name);
+    auto categoryItem = new QTreeWidgetItem (QStringList (gettext (category.name.toStdString ().c_str ())));
+    if (!category.tooltip.trimmed ().isEmpty ()) {
+      categoryItem->setToolTip (0, gettext (category.tooltip.toStdString ().c_str ()));
     }
 
-    for (const auto& example : examples) {
-      auto exampleItem = new QTreeWidgetItem(QStringList(example.fileName()));
-      exampleItem->setData(0, Qt::UserRole, example.canonicalFilePath());
-      categoryItem->addChild(exampleItem);
+    for (const auto &example : examples) {
+      auto exampleItem = new QTreeWidgetItem (QStringList (example.fileName ()));
+      exampleItem->setData (0, Qt::UserRole, example.canonicalFilePath ());
+      categoryItem->addChild (exampleItem);
     }
 
-    this->treeWidget->addTopLevelItem(categoryItem);
+    this->treeWidget->addTopLevelItem (categoryItem);
   }
 
-  connect(this->pushButtonNew, &QPushButton::clicked, this, &LaunchingScreen::accept);
-  connect(this->pushButtonOpen, &QPushButton::clicked, this, &LaunchingScreen::openUserFile);
-  connect(this->pushButtonHelp, &QPushButton::clicked, this, &LaunchingScreen::openUserManualURL);
-  connect(this->recentList->selectionModel(), &QItemSelectionModel::currentRowChanged, this, &LaunchingScreen::enableRecentButton);
+  connect (this->pushButtonNew, &QPushButton::clicked, this, &LaunchingScreen::accept);
+  connect (this->pushButtonOpen, &QPushButton::clicked, this, &LaunchingScreen::openUserFile);
+  connect (this->pushButtonHelp, &QPushButton::clicked, this, &LaunchingScreen::openUserManualURL);
+  connect (this->recentList->selectionModel (), &QItemSelectionModel::currentRowChanged, this, &LaunchingScreen::enableRecentButton);
 
-  connect(this->recentList, &QListWidget::itemDoubleClicked, this, &LaunchingScreen::openRecent);
-  connect(this->treeWidget, &QTreeWidget::currentItemChanged, this, &LaunchingScreen::enableExampleButton);
+  connect (this->recentList, &QListWidget::itemDoubleClicked, this, &LaunchingScreen::openRecent);
+  connect (this->treeWidget, &QTreeWidget::currentItemChanged, this, &LaunchingScreen::enableExampleButton);
 
-  connect(this->treeWidget, &QTreeWidget::itemDoubleClicked, this, &LaunchingScreen::openExample);
-  connect(this->openRecentButton, &QPushButton::clicked, this, &LaunchingScreen::openRecent);
-  connect(this->openExampleButton, &QPushButton::clicked, this, &LaunchingScreen::openExample);
-  connect(this->checkBox, &QCheckBox::toggled, this, &LaunchingScreen::checkboxState);
+  connect (this->treeWidget, &QTreeWidget::itemDoubleClicked, this, &LaunchingScreen::openExample);
+  connect (this->openRecentButton, &QPushButton::clicked, this, &LaunchingScreen::openRecent);
+  connect (this->openExampleButton, &QPushButton::clicked, this, &LaunchingScreen::openExample);
+  connect (this->checkBox, &QCheckBox::toggled, this, &LaunchingScreen::checkboxState);
 }
 
-LaunchingScreen::~LaunchingScreen()
-{
+LaunchingScreen::~LaunchingScreen () {
   LaunchingScreen::inst = nullptr;
 }
 
-QStringList LaunchingScreen::selectedFiles() const
-{
+QStringList LaunchingScreen::selectedFiles () const {
   return this->files;
 }
 
-bool LaunchingScreen::isForceShowEditor() const
-{
-  return this->forceShowEditor || this->files.isEmpty();
+bool LaunchingScreen::isForceShowEditor () const {
+  return this->forceShowEditor || this->files.isEmpty ();
 }
 
-void LaunchingScreen::enableRecentButton(const QModelIndex&, const QModelIndex&)
-{
-  this->openRecentButton->setEnabled(true);
-  this->openRecentButton->setDefault(true);
+void LaunchingScreen::enableRecentButton (const QModelIndex &, const QModelIndex &) {
+  this->openRecentButton->setEnabled (true);
+  this->openRecentButton->setDefault (true);
 }
 
-void LaunchingScreen::openRecent()
-{
-  QListWidgetItem *item = this->recentList->currentItem();
+void LaunchingScreen::openRecent () {
+  QListWidgetItem *item = this->recentList->currentItem ();
   if (item == nullptr) {
     return;
   }
 
-  checkOpen(item->data(Qt::UserRole), false);
+  checkOpen (item->data (Qt::UserRole), false);
 }
 
-void LaunchingScreen::enableExampleButton(QTreeWidgetItem *current, QTreeWidgetItem *)
-{
-  const bool enable = current->childCount() == 0;
-  this->openExampleButton->setEnabled(enable);
-  this->openExampleButton->setDefault(true);
+void LaunchingScreen::enableExampleButton (QTreeWidgetItem *current, QTreeWidgetItem *) {
+  const bool enable = current->childCount () == 0;
+  this->openExampleButton->setEnabled (enable);
+  this->openExampleButton->setDefault (true);
 }
 
-void LaunchingScreen::openExample()
-{
-  QTreeWidgetItem *item = this->treeWidget->currentItem();
+void LaunchingScreen::openExample () {
+  QTreeWidgetItem *item = this->treeWidget->currentItem ();
   if (item == nullptr) {
     return;
   }
 
-  checkOpen(item->data(0, Qt::UserRole), true);
+  checkOpen (item->data (0, Qt::UserRole), true);
 }
 
-void LaunchingScreen::checkOpen(const QVariant& data, bool forceShowEditor)
-{
-  const QString path = data.toString();
-  if (path.isEmpty()) {
+void LaunchingScreen::checkOpen (const QVariant &data, bool forceShowEditor) {
+  const QString path = data.toString ();
+  if (path.isEmpty ()) {
     return;
   }
 
   this->forceShowEditor = forceShowEditor;
-  this->files.append(path);
-  accept();
+  this->files.append (path);
+  accept ();
 }
 
-void LaunchingScreen::openUserFile()
-{
-  QFileInfo fileInfo = UIUtils::openFile(this);
-  if (fileInfo.exists()) {
+void LaunchingScreen::openUserFile () {
+  QFileInfo fileInfo = UIUtils::openFile (this);
+  if (fileInfo.exists ()) {
     this->forceShowEditor = false;
-    this->files.append(fileInfo.canonicalFilePath());
-    accept();
+    this->files.append (fileInfo.canonicalFilePath ());
+    accept ();
   }
 }
 
-void LaunchingScreen::checkboxState(bool state) const
-{
+void LaunchingScreen::checkboxState (bool state) const {
   QSettingsCached settings;
-  settings.setValue("launcher/showOnStartup", !state);
+  settings.setValue ("launcher/showOnStartup", !state);
 }
 
-void LaunchingScreen::openUserManualURL() const
-{
-  UIUtils::openUserManualURL();
+void LaunchingScreen::openUserManualURL () const {
+  UIUtils::openUserManualURL ();
 }
diff --git a/src/gui/LaunchingScreen.h b/src/gui/LaunchingScreen.h
index dba08efa9..5bfc2d17b 100644
--- a/src/gui/LaunchingScreen.h
+++ b/src/gui/LaunchingScreen.h
@@ -16,26 +16,26 @@ class LaunchingScreen : public QDialog, public Ui::LaunchingScreen
   Q_OBJECT
 
 public:
-  static LaunchingScreen *getDialog();
-  explicit LaunchingScreen(QWidget *parent = nullptr);
-  ~LaunchingScreen() override;
-  QStringList selectedFiles() const;
-  bool isForceShowEditor() const;
+  static LaunchingScreen *getDialog ();
+  explicit LaunchingScreen (QWidget *parent = nullptr);
+  ~LaunchingScreen () override;
+  QStringList selectedFiles () const;
+  bool isForceShowEditor () const;
 
 public slots:
-  void openFile(const QString& filename);
+  void openFile (const QString &filename);
 
 private slots:
-  void checkboxState(bool state) const;
-  void enableRecentButton(const QModelIndex& current, const QModelIndex& previous);
-  void enableExampleButton(QTreeWidgetItem *current, QTreeWidgetItem *previous);
-  void openUserFile();
-  void openRecent();
-  void openExample();
-  void openUserManualURL() const;
+  void checkboxState (bool state) const;
+  void enableRecentButton (const QModelIndex &current, const QModelIndex &previous);
+  void enableExampleButton (QTreeWidgetItem *current, QTreeWidgetItem *previous);
+  void openUserFile ();
+  void openRecent ();
+  void openExample ();
+  void openUserManualURL () const;
 
 private:
-  void checkOpen(const QVariant& data, bool forceShowEditor);
+  void checkOpen (const QVariant &data, bool forceShowEditor);
 
   QStringList files;
   bool forceShowEditor{true};
diff --git a/src/gui/LibraryInfoDialog.cc b/src/gui/LibraryInfoDialog.cc
index 9742125a9..652a17fa0 100644
--- a/src/gui/LibraryInfoDialog.cc
+++ b/src/gui/LibraryInfoDialog.cc
@@ -6,38 +6,36 @@
 #include <QTextEdit>
 #include "LibraryInfo.h"
 
-LibraryInfoDialog::LibraryInfoDialog(const QString& rendererInfo)
-{
-  setupUi(this);
-  connect(this->okButton, &QPushButton::clicked, this, &LibraryInfoDialog::accept);
-  updateLibraryInfo(rendererInfo);
+LibraryInfoDialog::LibraryInfoDialog (const QString &rendererInfo) {
+  setupUi (this);
+  connect (this->okButton, &QPushButton::clicked, this, &LibraryInfoDialog::accept);
+  updateLibraryInfo (rendererInfo);
 }
 
-void LibraryInfoDialog::updateLibraryInfo(const QString& rendererInfo)
-{
+void LibraryInfoDialog::updateLibraryInfo (const QString &rendererInfo) {
   //Get library infos
-  QString info(LibraryInfo::info().c_str());
+  QString info (LibraryInfo::info ().c_str ());
   info += rendererInfo;
 
   //Parse infos and make it html
-  info = info.replace("<", "&lt;").replace(">", "&gt;").replace("\n", "<br/>");
+  info = info.replace ("<", "&lt;").replace (">", "&gt;").replace ("\n", "<br/>");
 
   auto end = false;
   int startIndex = 0;
   while (!end) {
-    int endIndex = info.indexOf(":", startIndex);
+    int endIndex = info.indexOf (":", startIndex);
     if (endIndex != -1) {
       //add bold to property name
-      info = info.insert(startIndex, "<b>");
+      info = info.insert (startIndex, "<b>");
       endIndex += 3;
-      info = info.replace(endIndex, 1, ":</b>");
-      startIndex = info.indexOf("<br/>", endIndex);
+      info = info.replace (endIndex, 1, ":</b>");
+      startIndex = info.indexOf ("<br/>", endIndex);
 
       //handle property with multiple lines
-      auto endInd = info.indexOf(":", startIndex);
+      auto endInd = info.indexOf (":", startIndex);
       if (endInd != -1) {
-        QStringRef lines(&info, startIndex, endInd - startIndex);
-        auto lastIndex = lines.lastIndexOf("<br/>");
+        QStringRef lines (&info, startIndex, endInd - startIndex);
+        auto lastIndex = lines.lastIndexOf ("<br/>");
         startIndex = lastIndex != -1 ? lastIndex + startIndex : startIndex;
       }
     } else {
@@ -45,5 +43,5 @@ void LibraryInfoDialog::updateLibraryInfo(const QString& rendererInfo)
     }
   }
 
-  this->infoTextBox->setHtml(info);
+  this->infoTextBox->setHtml (info);
 }
diff --git a/src/gui/LibraryInfoDialog.h b/src/gui/LibraryInfoDialog.h
index c7f6c8fa4..5308d0b93 100644
--- a/src/gui/LibraryInfoDialog.h
+++ b/src/gui/LibraryInfoDialog.h
@@ -11,7 +11,7 @@ class LibraryInfoDialog : public QDialog, public Ui::LibraryInfoDialog
   Q_OBJECT;
 
 public:
-  LibraryInfoDialog(const QString& rendererInfo);
+  LibraryInfoDialog (const QString &rendererInfo);
 
-  void updateLibraryInfo(const QString& rendererInfo);
+  void updateLibraryInfo (const QString &rendererInfo);
 };
diff --git a/src/gui/MainWindow.cc b/src/gui/MainWindow.cc
index 9bb195a24..ec573151d 100644
--- a/src/gui/MainWindow.cc
+++ b/src/gui/MainWindow.cc
@@ -169,21 +169,21 @@
 #include "nettle/sha2.h"
 #include "nettle/base64.h"
 
-std::string SHA256HashString(std::string aString){
+std::string SHA256HashString (std::string aString) {
   uint8_t digest[SHA256_DIGEST_SIZE];
   sha256_ctx sha256_ctx;
 
-  sha256_init(&sha256_ctx);
-  sha256_update(&sha256_ctx, aString.length(), (uint8_t *) aString.c_str());
-  sha256_digest(&sha256_ctx, SHA256_DIGEST_SIZE, digest);
+  sha256_init (&sha256_ctx);
+  sha256_update (&sha256_ctx, aString.length (), (uint8_t *)aString.c_str ());
+  sha256_digest (&sha256_ctx, SHA256_DIGEST_SIZE, digest);
 
   base64_encode_ctx base64_ctx;
-  char digest_base64[BASE64_ENCODE_LENGTH(SHA256_DIGEST_SIZE) + 1];
-  memset(digest_base64, 0, sizeof(digest_base64));
+  char digest_base64[BASE64_ENCODE_LENGTH (SHA256_DIGEST_SIZE) + 1];
+  memset (digest_base64, 0, sizeof (digest_base64));
 
-  base64_encode_init(&base64_ctx);
-  base64_encode_update(&base64_ctx, digest_base64, SHA256_DIGEST_SIZE, digest);
-  base64_encode_final(&base64_ctx, digest_base64);
+  base64_encode_init (&base64_ctx);
+  base64_encode_update (&base64_ctx, digest_base64, SHA256_DIGEST_SIZE, digest);
+  base64_encode_final (&base64_ctx, digest_base64);
   return digest_base64;
 }
 
@@ -191,14 +191,13 @@ std::string SHA256HashString(std::string aString){
 
 #include "gui/PrintService.h"
 
-
 // Global application state
 unsigned int GuiLocker::guiLocked = 0;
 
 bool MainWindow::undockMode = false;
 bool MainWindow::reorderMode = false;
 const int MainWindow::tabStopWidth = 15;
-QElapsedTimer *MainWindow::progressThrottle = new QElapsedTimer();
+QElapsedTimer *MainWindow::progressThrottle = new QElapsedTimer ();
 
 namespace {
 
@@ -212,72 +211,71 @@ const char copyrighttext[] =
 
 struct DockFocus {
   Dock *widget;
-  std::function<void(MainWindow *)> focus;
+  std::function<void (MainWindow *)> focus;
 };
 
-QAction *findAction(const QList<QAction *>& actions, const std::string& name)
-{
+QAction *findAction (const QList<QAction *> &actions, const std::string &name) {
   for (const auto action : actions) {
-    if (action->objectName().toStdString() == name) {
+    if (action->objectName ().toStdString () == name) {
       return action;
     }
-    if (action->menu()) {
-      auto foundAction = findAction(action->menu()->actions(), name);
-      if (foundAction) return foundAction;
+    if (action->menu ()) {
+      auto foundAction = findAction (action->menu ()->actions (), name);
+      if (foundAction)
+        return foundAction;
     }
   }
   return nullptr;
 }
 
-void fileExportedMessage(const QString& format, const QString& filename) {
-  LOG("%1$s export finished: %2$s", format.toUtf8().constData(), filename.toUtf8().constData());
+void fileExportedMessage (const QString &format, const QString &filename) {
+  LOG ("%1$s export finished: %2$s", format.toUtf8 ().constData (), filename.toUtf8 ().constData ());
 }
 
-void removeExportActions(QToolBar *toolbar, QAction *action) {
-  int idx = toolbar->actions().indexOf(action);
+void removeExportActions (QToolBar *toolbar, QAction *action) {
+  int idx = toolbar->actions ().indexOf (action);
   while (idx > 0) {
-    QAction *a = toolbar->actions().at(idx - 1);
-    if (a->objectName().isEmpty())     // separator
+    QAction *a = toolbar->actions ().at (idx - 1);
+    if (a->objectName ().isEmpty ()) // separator
       break;
-    toolbar->removeAction(a);
+    toolbar->removeAction (a);
     idx--;
   }
 }
 
-void addExportActions(const MainWindow *mainWindow, QToolBar *toolbar, QAction *action) {
-  for (const std::string& identifier : {Settings::Settings::toolbarExport3D.value(),
-                                        Settings::Settings::toolbarExport2D.value()}) {
+void addExportActions (const MainWindow *mainWindow, QToolBar *toolbar, QAction *action) {
+  for (const std::string &identifier : {Settings::Settings::toolbarExport3D.value (),
+                                        Settings::Settings::toolbarExport2D.value ()}) {
     FileFormat format;
-    fileformat::fromIdentifier(identifier, format);
-    const auto it = mainWindow->exportMap.find(format);
+    fileformat::fromIdentifier (identifier, format);
+    const auto it = mainWindow->exportMap.find (format);
     // FIXME: Allow turning off the toolbar entry?
-    if (it != mainWindow->exportMap.end()) {
-      toolbar->insertAction(action, it->second);
+    if (it != mainWindow->exportMap.end ()) {
+      toolbar->insertAction (action, it->second);
     }
   }
 }
 
-std::unique_ptr<ExternalToolInterface> createExternalToolService(
-  print_service_t serviceType, const QString& serviceName, FileFormat fileFormat)
-{
+std::unique_ptr<ExternalToolInterface> createExternalToolService (
+  print_service_t serviceType, const QString &serviceName, FileFormat fileFormat) {
   switch (serviceType) {
   case print_service_t::NONE:
     // TODO: Print warning
     return nullptr;
     break;
   case print_service_t::PRINT_SERVICE: {
-    if (const auto printService = PrintService::getPrintService(serviceName.toStdString())) {
-      return createExternalPrintService(printService, fileFormat);
+    if (const auto printService = PrintService::getPrintService (serviceName.toStdString ())) {
+      return createExternalPrintService (printService, fileFormat);
     }
-    LOG("Unknown print service \"%1$s\"", serviceName.toStdString());
+    LOG ("Unknown print service \"%1$s\"", serviceName.toStdString ());
     return nullptr;
     break;
   }
   case print_service_t::OCTOPRINT:
-    return createOctoPrintService(fileFormat);
+    return createOctoPrintService (fileFormat);
     break;
   case print_service_t::LOCAL_APPLICATION:
-    return createLocalProgramService(fileFormat);
+    return createLocalProgramService (fileFormat);
     break;
   }
   return {};
@@ -285,227 +283,224 @@ std::unique_ptr<ExternalToolInterface> createExternalToolService(
 
 } // namespace
 
-MainWindow::MainWindow(const QStringList& filenames) :
-  rubberBandManager(this)
-{
-  installEventFilter(this);
-  setupUi(this);
+MainWindow::MainWindow (const QStringList &filenames)
+  : rubberBandManager (this) {
+  installEventFilter (this);
+  setupUi (this);
 
-  consoleUpdater = new QTimer(this);
-  consoleUpdater->setSingleShot(true);
-  connect(consoleUpdater, &QTimer::timeout, this->console, &Console::update);
+  consoleUpdater = new QTimer (this);
+  consoleUpdater->setSingleShot (true);
+  connect (consoleUpdater, &QTimer::timeout, this->console, &Console::update);
 
-  this->animateWidget->setMainWindow(this);
-  this->viewportControlWidget->setMainWindow(this);
+  this->animateWidget->setMainWindow (this);
+  this->viewportControlWidget->setMainWindow (this);
   // actions not included in menu
-  this->addAction(editActionInsertTemplate);
-  this->addAction(editActionFoldAll);
+  this->addAction (editActionInsertTemplate);
+  this->addAction (editActionFoldAll);
 
   docks = {
-    {editorDock, QString(_("Editor"))},
-    {consoleDock, QString(_("Console"))},
-    {parameterDock, QString(_("Customizer"))},
-    {errorLogDock, QString(_("Error-Log"))},
-    {animateDock, QString(_("Animate"))},
-    {fontListDock, QString(_("Font Lists"))},
-    {viewportControlDock, QString(_("Viewport-Control"))}
-  };
-
-  this->editorDock->setConfigKey("view/hideEditor");
-  this->consoleDock->setConfigKey("view/hideConsole");
-  this->parameterDock->setConfigKey("view/hideCustomizer");
-  this->errorLogDock->setConfigKey("view/hideErrorLog");
-  this->animateDock->setConfigKey("view/hideAnimate");
-  this->fontListDock->setConfigKey("view/hideFontList");
-  this->viewportControlDock->setConfigKey("view/hideViewportControl");
-
-  this->versionLabel = nullptr;   // must be initialized before calling updateStatusBar()
-  updateStatusBar(nullptr);
-
-  renderCompleteSoundEffect = new QSoundEffect();
-  renderCompleteSoundEffect->setSource(QUrl("qrc:/sounds/complete.wav"));
+    {editorDock, QString (_ ("Editor"))},
+    {consoleDock, QString (_ ("Console"))},
+    {parameterDock, QString (_ ("Customizer"))},
+    {errorLogDock, QString (_ ("Error-Log"))},
+    {animateDock, QString (_ ("Animate"))},
+    {fontListDock, QString (_ ("Font Lists"))},
+    {viewportControlDock, QString (_ ("Viewport-Control"))}};
+
+  this->editorDock->setConfigKey ("view/hideEditor");
+  this->consoleDock->setConfigKey ("view/hideConsole");
+  this->parameterDock->setConfigKey ("view/hideCustomizer");
+  this->errorLogDock->setConfigKey ("view/hideErrorLog");
+  this->animateDock->setConfigKey ("view/hideAnimate");
+  this->fontListDock->setConfigKey ("view/hideFontList");
+  this->viewportControlDock->setConfigKey ("view/hideViewportControl");
+
+  this->versionLabel = nullptr; // must be initialized before calling updateStatusBar()
+  updateStatusBar (nullptr);
+
+  renderCompleteSoundEffect = new QSoundEffect ();
+  renderCompleteSoundEffect->setSource (QUrl ("qrc:/sounds/complete.wav"));
 
   rootFile = nullptr;
   parsedFile = nullptr;
   absoluteRootNode = nullptr;
 
   // Open Recent
-  for (auto& recent : this->actionRecentFile) {
-    recent = new QAction(this);
-    recent->setVisible(false);
-    this->menuOpenRecent->addAction(recent);
-    connect(recent, &QAction::triggered, this, &MainWindow::actionOpenRecent);
+  for (auto &recent : this->actionRecentFile) {
+    recent = new QAction (this);
+    recent->setVisible (false);
+    this->menuOpenRecent->addAction (recent);
+    connect (recent, &QAction::triggered, this, &MainWindow::actionOpenRecent);
   }
 
   // Preferences initialization happens on first tab creation, and depends on colorschemes from editor.
   // Any code dependent on Preferences must come after the TabManager instantiation
-  tabManager = new TabManager(this, filenames.isEmpty() ? QString() : filenames[0]);
-  editorDockContents->layout()->addWidget(tabManager->getTabContent());
+  tabManager = new TabManager (this, filenames.isEmpty () ? QString () : filenames[0]);
+  editorDockContents->layout ()->addWidget (tabManager->getTabContent ());
 
-  connect(this, &MainWindow::highlightError, tabManager, &TabManager::highlightError);
-  connect(this, &MainWindow::unhighlightLastError, tabManager, &TabManager::unhighlightLastError);
+  connect (this, &MainWindow::highlightError, tabManager, &TabManager::highlightError);
+  connect (this, &MainWindow::unhighlightLastError, tabManager, &TabManager::unhighlightLastError);
 
-  connect(this->editActionUndo, &QAction::triggered, tabManager, &TabManager::undo);
-  connect(this->editActionRedo, &QAction::triggered, tabManager, &TabManager::redo);
-  connect(this->editActionRedo_2, &QAction::triggered, tabManager, &TabManager::redo);
-  connect(this->editActionCut, &QAction::triggered, tabManager, &TabManager::cut);
-  connect(this->editActionPaste, &QAction::triggered, tabManager, &TabManager::paste);
+  connect (this->editActionUndo, &QAction::triggered, tabManager, &TabManager::undo);
+  connect (this->editActionRedo, &QAction::triggered, tabManager, &TabManager::redo);
+  connect (this->editActionRedo_2, &QAction::triggered, tabManager, &TabManager::redo);
+  connect (this->editActionCut, &QAction::triggered, tabManager, &TabManager::cut);
+  connect (this->editActionPaste, &QAction::triggered, tabManager, &TabManager::paste);
 
-  connect(this->editActionIndent, &QAction::triggered, tabManager, &TabManager::indentSelection);
-  connect(this->editActionUnindent, &QAction::triggered, tabManager, &TabManager::unindentSelection);
-  connect(this->editActionComment, &QAction::triggered, tabManager, &TabManager::commentSelection);
-  connect(this->editActionUncomment, &QAction::triggered, tabManager, &TabManager::uncommentSelection);
+  connect (this->editActionIndent, &QAction::triggered, tabManager, &TabManager::indentSelection);
+  connect (this->editActionUnindent, &QAction::triggered, tabManager, &TabManager::unindentSelection);
+  connect (this->editActionComment, &QAction::triggered, tabManager, &TabManager::commentSelection);
+  connect (this->editActionUncomment, &QAction::triggered, tabManager, &TabManager::uncommentSelection);
 
-  connect(this->editActionToggleBookmark, &QAction::triggered, tabManager, &TabManager::toggleBookmark);
-  connect(this->editActionNextBookmark, &QAction::triggered, tabManager, &TabManager::nextBookmark);
-  connect(this->editActionPrevBookmark, &QAction::triggered, tabManager, &TabManager::prevBookmark);
-  connect(this->editActionJumpToNextError, &QAction::triggered, tabManager, &TabManager::jumpToNextError);
+  connect (this->editActionToggleBookmark, &QAction::triggered, tabManager, &TabManager::toggleBookmark);
+  connect (this->editActionNextBookmark, &QAction::triggered, tabManager, &TabManager::nextBookmark);
+  connect (this->editActionPrevBookmark, &QAction::triggered, tabManager, &TabManager::prevBookmark);
+  connect (this->editActionJumpToNextError, &QAction::triggered, tabManager, &TabManager::jumpToNextError);
 
-  connect(tabManager, &TabManager::editorAboutToClose, this, &MainWindow::onTabManagerAboutToCloseEditor);
-  connect(tabManager, &TabManager::currentEditorChanged, this, &MainWindow::onTabManagerEditorChanged);
-  connect(tabManager, &TabManager::editorContentReloaded, this, &MainWindow::onTabManagerEditorContentReloaded);
+  connect (tabManager, &TabManager::editorAboutToClose, this, &MainWindow::onTabManagerAboutToCloseEditor);
+  connect (tabManager, &TabManager::currentEditorChanged, this, &MainWindow::onTabManagerEditorChanged);
+  connect (tabManager, &TabManager::editorContentReloaded, this, &MainWindow::onTabManagerEditorContentReloaded);
 
-  connect(GlobalPreferences::inst(), &Preferences::consoleFontChanged, this->console, &Console::setFont);
+  connect (GlobalPreferences::inst (), &Preferences::consoleFontChanged, this->console, &Console::setFont);
 
-  const QString version = QString("<b>OpenSCAD %1</b>").arg(QString::fromStdString(openscad_versionnumber));
+  const QString version = QString ("<b>OpenSCAD %1</b>").arg (QString::fromStdString (openscad_versionnumber));
   const QString weblink = "<a href=\"https://www.openscad.org/\">https://www.openscad.org/</a><br>";
-  this->console->setFont(
-    GlobalPreferences::inst()->getValue("advanced/consoleFontFamily").toString(),
-    GlobalPreferences::inst()->getValue("advanced/consoleFontSize").toUInt()
-    );
+  this->console->setFont (
+    GlobalPreferences::inst ()->getValue ("advanced/consoleFontFamily").toString (),
+    GlobalPreferences::inst ()->getValue ("advanced/consoleFontSize").toUInt ());
 
-  consoleOutputRaw(version);
-  consoleOutputRaw(weblink);
-  consoleOutputRaw(copyrighttext);
-  this->consoleUpdater->start(0);   // Show "Loaded Design" message from TabManager
+  consoleOutputRaw (version);
+  consoleOutputRaw (weblink);
+  consoleOutputRaw (copyrighttext);
+  this->consoleUpdater->start (0); // Show "Loaded Design" message from TabManager
 
-  connect(this->errorLogWidget, &ErrorLog::openFile, this, &MainWindow::openFileFromPath);
-  connect(this->console, &Console::openFile, this, &MainWindow::openFileFromPath);
+  connect (this->errorLogWidget, &ErrorLog::openFile, this, &MainWindow::openFileFromPath);
+  connect (this->console, &Console::openFile, this, &MainWindow::openFileFromPath);
 
-  connect(GlobalPreferences::inst()->ButtonConfig, &ButtonConfigWidget::inputMappingChanged, InputDriverManager::instance(), &InputDriverManager::onInputMappingUpdated, Qt::UniqueConnection);
-  connect(GlobalPreferences::inst()->AxisConfig, &AxisConfigWidget::inputMappingChanged, InputDriverManager::instance(), &InputDriverManager::onInputMappingUpdated, Qt::UniqueConnection);
-  connect(GlobalPreferences::inst()->AxisConfig, &AxisConfigWidget::inputCalibrationChanged, InputDriverManager::instance(), &InputDriverManager::onInputCalibrationUpdated, Qt::UniqueConnection);
-  connect(GlobalPreferences::inst()->AxisConfig, &AxisConfigWidget::inputGainChanged, InputDriverManager::instance(), &InputDriverManager::onInputGainUpdated, Qt::UniqueConnection);
+  connect (GlobalPreferences::inst ()->ButtonConfig, &ButtonConfigWidget::inputMappingChanged, InputDriverManager::instance (), &InputDriverManager::onInputMappingUpdated, Qt::UniqueConnection);
+  connect (GlobalPreferences::inst ()->AxisConfig, &AxisConfigWidget::inputMappingChanged, InputDriverManager::instance (), &InputDriverManager::onInputMappingUpdated, Qt::UniqueConnection);
+  connect (GlobalPreferences::inst ()->AxisConfig, &AxisConfigWidget::inputCalibrationChanged, InputDriverManager::instance (), &InputDriverManager::onInputCalibrationUpdated, Qt::UniqueConnection);
+  connect (GlobalPreferences::inst ()->AxisConfig, &AxisConfigWidget::inputGainChanged, InputDriverManager::instance (), &InputDriverManager::onInputGainUpdated, Qt::UniqueConnection);
 
-  setCorner(Qt::TopLeftCorner, Qt::LeftDockWidgetArea);
-  setCorner(Qt::TopRightCorner, Qt::RightDockWidgetArea);
-  setCorner(Qt::BottomLeftCorner, Qt::LeftDockWidgetArea);
-  setCorner(Qt::BottomRightCorner, Qt::RightDockWidgetArea);
+  setCorner (Qt::TopLeftCorner, Qt::LeftDockWidgetArea);
+  setCorner (Qt::TopRightCorner, Qt::RightDockWidgetArea);
+  setCorner (Qt::BottomLeftCorner, Qt::LeftDockWidgetArea);
+  setCorner (Qt::BottomRightCorner, Qt::RightDockWidgetArea);
 
-  this->setAttribute(Qt::WA_DeleteOnClose);
+  this->setAttribute (Qt::WA_DeleteOnClose);
 
-  scadApp->windowManager.add(this);
+  scadApp->windowManager.add (this);
 
-  this->cgalworker = new CGALWorker();
-  connect(this->cgalworker, &CGALWorker::done, this, &MainWindow::actionRenderDone);
+  this->cgalworker = new CGALWorker ();
+  connect (this->cgalworker, &CGALWorker::done, this, &MainWindow::actionRenderDone);
 
   rootNode = nullptr;
 
-  this->qglview->statusLabel = new QLabel(this);
-  this->qglview->statusLabel->setMinimumWidth(100);
-  statusBar()->addWidget(this->qglview->statusLabel);
+  this->qglview->statusLabel = new QLabel (this);
+  this->qglview->statusLabel->setMinimumWidth (100);
+  statusBar ()->addWidget (this->qglview->statusLabel);
 
   const QSettingsCached settings;
-  this->qglview->setMouseCentricZoom(Settings::Settings::mouseCentricZoom.value());
-  this->qglview->setMouseSwapButtons(Settings::Settings::mouseSwapButtons.value());
-  this->meas.setView(qglview);
-  this->designActionMeasureDist->setEnabled(false);
-  this->designActionMeasureAngle->setEnabled(false);
-
-  autoReloadTimer = new QTimer(this);
-  autoReloadTimer->setSingleShot(false);
-  autoReloadTimer->setInterval(autoReloadPollingPeriodMS);
-  connect(autoReloadTimer, &QTimer::timeout, this, &MainWindow::checkAutoReload);
-
-  this->exportFormatMapper = new QSignalMapper(this);
+  this->qglview->setMouseCentricZoom (Settings::Settings::mouseCentricZoom.value ());
+  this->qglview->setMouseSwapButtons (Settings::Settings::mouseSwapButtons.value ());
+  this->meas.setView (qglview);
+  this->designActionMeasureDist->setEnabled (false);
+  this->designActionMeasureAngle->setEnabled (false);
+
+  autoReloadTimer = new QTimer (this);
+  autoReloadTimer->setSingleShot (false);
+  autoReloadTimer->setInterval (autoReloadPollingPeriodMS);
+  connect (autoReloadTimer, &QTimer::timeout, this, &MainWindow::checkAutoReload);
+
+  this->exportFormatMapper = new QSignalMapper (this);
 #if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
-  connect(this->exportFormatMapper, &QSignalMapper::mappedInt, this, &MainWindow::actionExportFileFormat);
+  connect (this->exportFormatMapper, &QSignalMapper::mappedInt, this, &MainWindow::actionExportFileFormat);
 #else
-  connect(this->exportFormatMapper, static_cast<void (QSignalMapper::*)(int)>(&QSignalMapper::mapped), this, &MainWindow::actionExportFileFormat);
+  connect (this->exportFormatMapper, static_cast<void (QSignalMapper::*) (int)> (&QSignalMapper::mapped), this, &MainWindow::actionExportFileFormat);
 #endif
 
-  waitAfterReloadTimer = new QTimer(this);
-  waitAfterReloadTimer->setSingleShot(true);
-  waitAfterReloadTimer->setInterval(autoReloadPollingPeriodMS);
-  connect(waitAfterReloadTimer, &QTimer::timeout, this, &MainWindow::waitAfterReload);
-  connect(GlobalPreferences::inst(), &Preferences::ExperimentalChanged, this, &MainWindow::changeParameterWidget);
+  waitAfterReloadTimer = new QTimer (this);
+  waitAfterReloadTimer->setSingleShot (true);
+  waitAfterReloadTimer->setInterval (autoReloadPollingPeriodMS);
+  connect (waitAfterReloadTimer, &QTimer::timeout, this, &MainWindow::waitAfterReload);
+  connect (GlobalPreferences::inst (), &Preferences::ExperimentalChanged, this, &MainWindow::changeParameterWidget);
 
-  progressThrottle->start();
+  progressThrottle->start ();
 
-  this->hideFind();
-  frameCompileResult->hide();
-  this->labelCompileResultMessage->setOpenExternalLinks(false);
-  connect(this->labelCompileResultMessage, &QLabel::linkActivated, this, &MainWindow::showLink);
+  this->hideFind ();
+  frameCompileResult->hide ();
+  this->labelCompileResultMessage->setOpenExternalLinks (false);
+  connect (this->labelCompileResultMessage, &QLabel::linkActivated, this, &MainWindow::showLink);
 
   // File menu
-  connect(this->fileActionNewWindow, &QAction::triggered, this, &MainWindow::actionNewWindow);
-  connect(this->fileActionNew, &QAction::triggered, tabManager, &TabManager::actionNew);
-  connect(this->fileActionOpenWindow, &QAction::triggered, this, &MainWindow::actionOpenWindow);
-  connect(this->fileActionOpen, &QAction::triggered, this, &MainWindow::actionOpen);
-  connect(this->fileActionSave, &QAction::triggered, this, &MainWindow::actionSave);
-  connect(this->fileActionSaveAs, &QAction::triggered, this, &MainWindow::actionSaveAs);
-  connect(this->fileActionSaveACopy, &QAction::triggered, this, &MainWindow::actionSaveACopy);
-  connect(this->fileActionSaveAll, &QAction::triggered, tabManager, &TabManager::saveAll);
-  connect(this->fileActionReload, &QAction::triggered, this, &MainWindow::actionReload);
-  connect(this->fileActionClose, &QAction::triggered, tabManager, &TabManager::closeCurrentTab);
-  connect(this->fileActionQuit, &QAction::triggered, scadApp, &OpenSCADApp::quit, Qt::QueuedConnection);
-  connect(this->fileShowLibraryFolder, &QAction::triggered, this, &MainWindow::actionShowLibraryFolder);
+  connect (this->fileActionNewWindow, &QAction::triggered, this, &MainWindow::actionNewWindow);
+  connect (this->fileActionNew, &QAction::triggered, tabManager, &TabManager::actionNew);
+  connect (this->fileActionOpenWindow, &QAction::triggered, this, &MainWindow::actionOpenWindow);
+  connect (this->fileActionOpen, &QAction::triggered, this, &MainWindow::actionOpen);
+  connect (this->fileActionSave, &QAction::triggered, this, &MainWindow::actionSave);
+  connect (this->fileActionSaveAs, &QAction::triggered, this, &MainWindow::actionSaveAs);
+  connect (this->fileActionSaveACopy, &QAction::triggered, this, &MainWindow::actionSaveACopy);
+  connect (this->fileActionSaveAll, &QAction::triggered, tabManager, &TabManager::saveAll);
+  connect (this->fileActionReload, &QAction::triggered, this, &MainWindow::actionReload);
+  connect (this->fileActionClose, &QAction::triggered, tabManager, &TabManager::closeCurrentTab);
+  connect (this->fileActionQuit, &QAction::triggered, scadApp, &OpenSCADApp::quit, Qt::QueuedConnection);
+  connect (this->fileShowLibraryFolder, &QAction::triggered, this, &MainWindow::actionShowLibraryFolder);
 
 #ifdef ENABLE_PYTHON
-  connect(this->fileActionPythonRevoke, &QAction::triggered, this, &MainWindow::actionPythonRevokeTrustedFiles);
-  connect(this->fileActionPythonCreateVenv, &QAction::triggered, this, &MainWindow::actionPythonCreateVenv);
-  connect(this->fileActionPythonSelectVenv, &QAction::triggered, this, &MainWindow::actionPythonSelectVenv);
+  connect (this->fileActionPythonRevoke, &QAction::triggered, this, &MainWindow::actionPythonRevokeTrustedFiles);
+  connect (this->fileActionPythonCreateVenv, &QAction::triggered, this, &MainWindow::actionPythonCreateVenv);
+  connect (this->fileActionPythonSelectVenv, &QAction::triggered, this, &MainWindow::actionPythonSelectVenv);
 #else
-  this->menuPython->menuAction()->setVisible(false);
+  this->menuPython->menuAction ()->setVisible (false);
 #endif
 
 #ifndef __APPLE__
-  auto shortcuts = this->fileActionSave->shortcuts();
-  this->fileActionSave->setShortcuts(shortcuts);
-  shortcuts = this->fileActionReload->shortcuts();
-  shortcuts.push_back(QKeySequence(Qt::Key_F3));
-  this->fileActionReload->setShortcuts(shortcuts);
+  auto shortcuts = this->fileActionSave->shortcuts ();
+  this->fileActionSave->setShortcuts (shortcuts);
+  shortcuts = this->fileActionReload->shortcuts ();
+  shortcuts.push_back (QKeySequence (Qt::Key_F3));
+  this->fileActionReload->setShortcuts (shortcuts);
 #endif
 
-  this->menuOpenRecent->addSeparator();
-  this->menuOpenRecent->addAction(this->fileActionClearRecent);
-  connect(this->fileActionClearRecent, &QAction::triggered, this, &MainWindow::clearRecentFiles);
+  this->menuOpenRecent->addSeparator ();
+  this->menuOpenRecent->addAction (this->fileActionClearRecent);
+  connect (this->fileActionClearRecent, &QAction::triggered, this, &MainWindow::clearRecentFiles);
 
-  show_examples();
+  show_examples ();
 
-  connect(this->editActionNextTab, &QAction::triggered, tabManager, &TabManager::nextTab);
-  connect(this->editActionPrevTab, &QAction::triggered, tabManager, &TabManager::prevTab);
+  connect (this->editActionNextTab, &QAction::triggered, tabManager, &TabManager::nextTab);
+  connect (this->editActionPrevTab, &QAction::triggered, tabManager, &TabManager::prevTab);
 
-  connect(this->editActionCopy, &QAction::triggered, this, &MainWindow::copyText);
-  connect(this->editActionCopyViewport, &QAction::triggered, this, &MainWindow::actionCopyViewport);
-  connect(this->editActionConvertTabsToSpaces, &QAction::triggered, this, &MainWindow::convertTabsToSpaces);
-  connect(this->editActionCopyVPT, &QAction::triggered, this, &MainWindow::copyViewportTranslation);
-  connect(this->editActionCopyVPR, &QAction::triggered, this, &MainWindow::copyViewportRotation);
-  connect(this->editActionCopyVPD, &QAction::triggered, this, &MainWindow::copyViewportDistance);
-  connect(this->editActionCopyVPF, &QAction::triggered, this, &MainWindow::copyViewportFov);
-  connect(this->editActionPreferences, &QAction::triggered, this, &MainWindow::preferences);
+  connect (this->editActionCopy, &QAction::triggered, this, &MainWindow::copyText);
+  connect (this->editActionCopyViewport, &QAction::triggered, this, &MainWindow::actionCopyViewport);
+  connect (this->editActionConvertTabsToSpaces, &QAction::triggered, this, &MainWindow::convertTabsToSpaces);
+  connect (this->editActionCopyVPT, &QAction::triggered, this, &MainWindow::copyViewportTranslation);
+  connect (this->editActionCopyVPR, &QAction::triggered, this, &MainWindow::copyViewportRotation);
+  connect (this->editActionCopyVPD, &QAction::triggered, this, &MainWindow::copyViewportDistance);
+  connect (this->editActionCopyVPF, &QAction::triggered, this, &MainWindow::copyViewportFov);
+  connect (this->editActionPreferences, &QAction::triggered, this, &MainWindow::preferences);
   // Edit->Find
-  connect(this->editActionFind, &QAction::triggered, this, &MainWindow::actionShowFind);
-  connect(this->editActionFindAndReplace, &QAction::triggered, this, &MainWindow::actionShowFindAndReplace);
+  connect (this->editActionFind, &QAction::triggered, this, &MainWindow::actionShowFind);
+  connect (this->editActionFindAndReplace, &QAction::triggered, this, &MainWindow::actionShowFindAndReplace);
 #ifdef Q_OS_WIN
-  this->editActionFindAndReplace->setShortcut(QKeySequence("Ctrl+Shift+F"));
+  this->editActionFindAndReplace->setShortcut (QKeySequence ("Ctrl+Shift+F"));
 #endif
-  connect(this->editActionFindNext, &QAction::triggered, this, &MainWindow::findNext);
-  connect(this->editActionFindPrevious, &QAction::triggered, this, &MainWindow::findPrev);
-  connect(this->editActionUseSelectionForFind, &QAction::triggered, this, &MainWindow::useSelectionForFind);
+  connect (this->editActionFindNext, &QAction::triggered, this, &MainWindow::findNext);
+  connect (this->editActionFindPrevious, &QAction::triggered, this, &MainWindow::findPrev);
+  connect (this->editActionUseSelectionForFind, &QAction::triggered, this, &MainWindow::useSelectionForFind);
 
   // Design menu
-  connect(this->designActionAutoReload, &QAction::toggled, this, &MainWindow::autoReloadSet);
-  connect(this->designActionReloadAndPreview, &QAction::triggered, this, &MainWindow::actionReloadRenderPreview);
-  connect(this->designActionPreview, &QAction::triggered, this, &MainWindow::actionRenderPreview);
-  connect(this->designActionRender, &QAction::triggered, this, &MainWindow::actionRender);
-  connect(this->designActionMeasureDist, &QAction::triggered, this, &MainWindow::actionMeasureDistance);
-  connect(this->designActionMeasureAngle, &QAction::triggered, this, &MainWindow::actionMeasureAngle);
-  connect(this->designAction3DPrint, &QAction::triggered, this, &MainWindow::action3DPrint);
-  connect(this->designCheckValidity, &QAction::triggered, this, &MainWindow::actionCheckValidity);
-  connect(this->designActionDisplayAST, &QAction::triggered, this, &MainWindow::actionDisplayAST);
-  connect(this->designActionDisplayCSGTree, &QAction::triggered, this, &MainWindow::actionDisplayCSGTree);
-  connect(this->designActionDisplayCSGProducts, &QAction::triggered, this, &MainWindow::actionDisplayCSGProducts);
+  connect (this->designActionAutoReload, &QAction::toggled, this, &MainWindow::autoReloadSet);
+  connect (this->designActionReloadAndPreview, &QAction::triggered, this, &MainWindow::actionReloadRenderPreview);
+  connect (this->designActionPreview, &QAction::triggered, this, &MainWindow::actionRenderPreview);
+  connect (this->designActionRender, &QAction::triggered, this, &MainWindow::actionRender);
+  connect (this->designActionMeasureDist, &QAction::triggered, this, &MainWindow::actionMeasureDistance);
+  connect (this->designActionMeasureAngle, &QAction::triggered, this, &MainWindow::actionMeasureAngle);
+  connect (this->designAction3DPrint, &QAction::triggered, this, &MainWindow::action3DPrint);
+  connect (this->designCheckValidity, &QAction::triggered, this, &MainWindow::actionCheckValidity);
+  connect (this->designActionDisplayAST, &QAction::triggered, this, &MainWindow::actionDisplayAST);
+  connect (this->designActionDisplayCSGTree, &QAction::triggered, this, &MainWindow::actionDisplayCSGTree);
+  connect (this->designActionDisplayCSGProducts, &QAction::triggered, this, &MainWindow::actionDisplayCSGProducts);
 
   exportMap[FileFormat::BINARY_STL] = this->fileActionExportBinarySTL;
   exportMap[FileFormat::ASCII_STL] = this->fileActionExportAsciiSTL;
@@ -521,164 +516,164 @@ MainWindow::MainWindow(const QStringList& filenames) :
   exportMap[FileFormat::CSG] = this->fileActionExportCSG;
   exportMap[FileFormat::PNG] = this->fileActionExportImage;
 
-  for (auto& [format, action] : exportMap) {
-    connect(action, &QAction::triggered, this->exportFormatMapper, QOverload<>::of(&QSignalMapper::map));
-    this->exportFormatMapper->setMapping(action, int(format));
+  for (auto &[format, action] : exportMap) {
+    connect (action, &QAction::triggered, this->exportFormatMapper, QOverload<>::of (&QSignalMapper::map));
+    this->exportFormatMapper->setMapping (action, int (format));
   }
 
-  connect(this->designActionFlushCaches, &QAction::triggered, this, &MainWindow::actionFlushCaches);
+  connect (this->designActionFlushCaches, &QAction::triggered, this, &MainWindow::actionFlushCaches);
 
 #ifndef ENABLE_LIB3MF
-  this->fileActionExport3MF->setVisible(false);
+  this->fileActionExport3MF->setVisible (false);
 #endif
 
   // View menu
-  this->viewActionThrownTogether->setEnabled(false);
-  this->viewActionPreview->setEnabled(false);
-  if (this->qglview->hasOpenCSGSupport()) {
-    this->viewActionPreview->setChecked(true);
-    this->viewActionThrownTogether->setChecked(false);
+  this->viewActionThrownTogether->setEnabled (false);
+  this->viewActionPreview->setEnabled (false);
+  if (this->qglview->hasOpenCSGSupport ()) {
+    this->viewActionPreview->setChecked (true);
+    this->viewActionThrownTogether->setChecked (false);
   } else {
-    this->viewActionPreview->setChecked(false);
-    this->viewActionThrownTogether->setChecked(true);
-  }
-
-  connect(this->viewActionPreview, &QAction::triggered, this, &MainWindow::viewModePreview);
-  connect(this->viewActionThrownTogether, &QAction::triggered, this, &MainWindow::viewModeThrownTogether);
-  connect(this->viewActionShowEdges, &QAction::triggered, this, &MainWindow::viewModeShowEdges);
-  connect(this->viewActionShowAxes, &QAction::triggered, this, &MainWindow::viewModeShowAxes);
-  connect(this->viewActionShowCrosshairs, &QAction::triggered, this, &MainWindow::viewModeShowCrosshairs);
-  connect(this->viewActionShowScaleProportional, &QAction::triggered, this, &MainWindow::viewModeShowScaleProportional);
-  connect(this->viewActionTop, &QAction::triggered, this, &MainWindow::viewAngleTop);
-  connect(this->viewActionBottom, &QAction::triggered, this, &MainWindow::viewAngleBottom);
-  connect(this->viewActionLeft, &QAction::triggered, this, &MainWindow::viewAngleLeft);
-  connect(this->viewActionRight, &QAction::triggered, this, &MainWindow::viewAngleRight);
-  connect(this->viewActionFront, &QAction::triggered, this, &MainWindow::viewAngleFront);
-  connect(this->viewActionBack, &QAction::triggered, this, &MainWindow::viewAngleBack);
-  connect(this->viewActionDiagonal, &QAction::triggered, this, &MainWindow::viewAngleDiagonal);
-  connect(this->viewActionCenter, &QAction::triggered, this, &MainWindow::viewCenter);
-  connect(this->viewActionResetView, &QAction::triggered, this, &MainWindow::viewResetView);
-  connect(this->viewActionViewAll, &QAction::triggered, this, &MainWindow::viewAll);
-  connect(this->viewActionPerspective, &QAction::triggered, this, &MainWindow::viewPerspective);
-  connect(this->viewActionOrthogonal, &QAction::triggered, this, &MainWindow::viewOrthogonal);
-  connect(this->viewActionZoomIn, &QAction::triggered, qglview, &QGLView::ZoomIn);
-  connect(this->viewActionZoomOut, &QAction::triggered, qglview, &QGLView::ZoomOut);
-  connect(this->viewActionHideEditorToolBar, &QAction::triggered, this, &MainWindow::hideEditorToolbar);
-  connect(this->viewActionHide3DViewToolBar, &QAction::triggered, this, &MainWindow::hide3DViewToolbar);
+    this->viewActionPreview->setChecked (false);
+    this->viewActionThrownTogether->setChecked (true);
+  }
+
+  connect (this->viewActionPreview, &QAction::triggered, this, &MainWindow::viewModePreview);
+  connect (this->viewActionThrownTogether, &QAction::triggered, this, &MainWindow::viewModeThrownTogether);
+  connect (this->viewActionShowEdges, &QAction::triggered, this, &MainWindow::viewModeShowEdges);
+  connect (this->viewActionShowAxes, &QAction::triggered, this, &MainWindow::viewModeShowAxes);
+  connect (this->viewActionShowCrosshairs, &QAction::triggered, this, &MainWindow::viewModeShowCrosshairs);
+  connect (this->viewActionShowScaleProportional, &QAction::triggered, this, &MainWindow::viewModeShowScaleProportional);
+  connect (this->viewActionTop, &QAction::triggered, this, &MainWindow::viewAngleTop);
+  connect (this->viewActionBottom, &QAction::triggered, this, &MainWindow::viewAngleBottom);
+  connect (this->viewActionLeft, &QAction::triggered, this, &MainWindow::viewAngleLeft);
+  connect (this->viewActionRight, &QAction::triggered, this, &MainWindow::viewAngleRight);
+  connect (this->viewActionFront, &QAction::triggered, this, &MainWindow::viewAngleFront);
+  connect (this->viewActionBack, &QAction::triggered, this, &MainWindow::viewAngleBack);
+  connect (this->viewActionDiagonal, &QAction::triggered, this, &MainWindow::viewAngleDiagonal);
+  connect (this->viewActionCenter, &QAction::triggered, this, &MainWindow::viewCenter);
+  connect (this->viewActionResetView, &QAction::triggered, this, &MainWindow::viewResetView);
+  connect (this->viewActionViewAll, &QAction::triggered, this, &MainWindow::viewAll);
+  connect (this->viewActionPerspective, &QAction::triggered, this, &MainWindow::viewPerspective);
+  connect (this->viewActionOrthogonal, &QAction::triggered, this, &MainWindow::viewOrthogonal);
+  connect (this->viewActionZoomIn, &QAction::triggered, qglview, &QGLView::ZoomIn);
+  connect (this->viewActionZoomOut, &QAction::triggered, qglview, &QGLView::ZoomOut);
+  connect (this->viewActionHideEditorToolBar, &QAction::triggered, this, &MainWindow::hideEditorToolbar);
+  connect (this->viewActionHide3DViewToolBar, &QAction::triggered, this, &MainWindow::hide3DViewToolbar);
 
   // Create the docks and connect corresponding action
-  for (auto& [dock, title] : docks) {
-    dock->setName(title);
-    dock->setFocusPolicy(Qt::FocusPolicy::StrongFocus);
+  for (auto &[dock, title] : docks) {
+    dock->setName (title);
+    dock->setFocusPolicy (Qt::FocusPolicy::StrongFocus);
 
     // It is neede to have the event filter installed in each dock so that the events are
     // correctly processed when the dock are floating (is in a different window that the mainwindow)
-    dock->installEventFilter(this);
+    dock->installEventFilter (this);
 
-    menuWindow->addAction(dock->toggleViewAction());
+    menuWindow->addAction (dock->toggleViewAction ());
   }
 
   // Help menu
-  connect(this->helpActionAbout, &QAction::triggered, this, &MainWindow::helpAbout);
-  connect(this->helpActionHomepage, &QAction::triggered, this, &MainWindow::helpHomepage);
-  connect(this->helpActionManual, &QAction::triggered, this, &MainWindow::helpManual);
-  connect(this->helpActionCheatSheet, &QAction::triggered, this, &MainWindow::helpCheatSheet);
-  connect(this->helpActionLibraryInfo, &QAction::triggered, this, &MainWindow::helpLibrary);
-  connect(this->helpActionFontInfo, &QAction::triggered, this, &MainWindow::helpFontInfo);
+  connect (this->helpActionAbout, &QAction::triggered, this, &MainWindow::helpAbout);
+  connect (this->helpActionHomepage, &QAction::triggered, this, &MainWindow::helpHomepage);
+  connect (this->helpActionManual, &QAction::triggered, this, &MainWindow::helpManual);
+  connect (this->helpActionCheatSheet, &QAction::triggered, this, &MainWindow::helpCheatSheet);
+  connect (this->helpActionLibraryInfo, &QAction::triggered, this, &MainWindow::helpLibrary);
+  connect (this->helpActionFontInfo, &QAction::triggered, this, &MainWindow::helpFontInfo);
 
   // Checks if the Documentation has been downloaded and hides the Action otherwise
-  if (UIUtils::hasOfflineUserManual()) {
-    connect(this->helpActionOfflineManual, &QAction::triggered, this, &MainWindow::helpOfflineManual);
+  if (UIUtils::hasOfflineUserManual ()) {
+    connect (this->helpActionOfflineManual, &QAction::triggered, this, &MainWindow::helpOfflineManual);
   } else {
-    this->helpActionOfflineManual->setVisible(false);
+    this->helpActionOfflineManual->setVisible (false);
   }
-  if (UIUtils::hasOfflineCheatSheet()) {
-    connect(this->helpActionOfflineCheatSheet, &QAction::triggered, this, &MainWindow::helpOfflineCheatSheet);
+  if (UIUtils::hasOfflineCheatSheet ()) {
+    connect (this->helpActionOfflineCheatSheet, &QAction::triggered, this, &MainWindow::helpOfflineCheatSheet);
   } else {
-    this->helpActionOfflineCheatSheet->setVisible(false);
+    this->helpActionOfflineCheatSheet->setVisible (false);
   }
 #ifdef OPENSCAD_UPDATER
-  this->menuBar()->addMenu(AutoUpdater::updater()->updateMenu);
+  this->menuBar ()->addMenu (AutoUpdater::updater ()->updateMenu);
 #endif
 
-  connect(this->qglview, &QGLView::cameraChanged, animateWidget, &Animate::cameraChanged);
-  connect(this->qglview, &QGLView::cameraChanged, viewportControlWidget, &ViewportControl::cameraChanged);
-  connect(this->qglview, &QGLView::resized, viewportControlWidget, &ViewportControl::viewResized);
-  connect(this->qglview, &QGLView::doRightClick, this, &MainWindow::rightClick);
-  connect(this->qglview, &QGLView::doLeftClick, this, &MainWindow::leftClick);
+  connect (this->qglview, &QGLView::cameraChanged, animateWidget, &Animate::cameraChanged);
+  connect (this->qglview, &QGLView::cameraChanged, viewportControlWidget, &ViewportControl::cameraChanged);
+  connect (this->qglview, &QGLView::resized, viewportControlWidget, &ViewportControl::viewResized);
+  connect (this->qglview, &QGLView::doRightClick, this, &MainWindow::rightClick);
+  connect (this->qglview, &QGLView::doLeftClick, this, &MainWindow::leftClick);
 
-  connect(GlobalPreferences::inst(), &Preferences::requestRedraw, this->qglview, QOverload<>::of(&QGLView::update));
-  connect(GlobalPreferences::inst(), &Preferences::updateMouseCentricZoom, this->qglview, &QGLView::setMouseCentricZoom);
-  connect(GlobalPreferences::inst(), &Preferences::updateMouseSwapButtons, this->qglview, &QGLView::setMouseSwapButtons);
-  connect(GlobalPreferences::inst(), &Preferences::updateReorderMode, this, &MainWindow::updateReorderMode);
-  connect(GlobalPreferences::inst(), &Preferences::updateUndockMode, this, &MainWindow::updateUndockMode);
-  connect(GlobalPreferences::inst(), &Preferences::openCSGSettingsChanged, this, &MainWindow::openCSGSettingsChanged);
-  connect(GlobalPreferences::inst(), &Preferences::colorSchemeChanged, this, &MainWindow::setColorScheme);
-  connect(GlobalPreferences::inst(), &Preferences::toolbarExportChanged, this, &MainWindow::updateExportActions);
+  connect (GlobalPreferences::inst (), &Preferences::requestRedraw, this->qglview, QOverload<>::of (&QGLView::update));
+  connect (GlobalPreferences::inst (), &Preferences::updateMouseCentricZoom, this->qglview, &QGLView::setMouseCentricZoom);
+  connect (GlobalPreferences::inst (), &Preferences::updateMouseSwapButtons, this->qglview, &QGLView::setMouseSwapButtons);
+  connect (GlobalPreferences::inst (), &Preferences::updateReorderMode, this, &MainWindow::updateReorderMode);
+  connect (GlobalPreferences::inst (), &Preferences::updateUndockMode, this, &MainWindow::updateUndockMode);
+  connect (GlobalPreferences::inst (), &Preferences::openCSGSettingsChanged, this, &MainWindow::openCSGSettingsChanged);
+  connect (GlobalPreferences::inst (), &Preferences::colorSchemeChanged, this, &MainWindow::setColorScheme);
+  connect (GlobalPreferences::inst (), &Preferences::toolbarExportChanged, this, &MainWindow::updateExportActions);
 
-  GlobalPreferences::inst()->apply_win();   // not sure if to be commented, checked must not be commented(done some changes in apply())
+  GlobalPreferences::inst ()->apply_win (); // not sure if to be commented, checked must not be commented(done some changes in apply())
 
-  const QString cs = GlobalPreferences::inst()->getValue("3dview/colorscheme").toString();
-  this->setColorScheme(cs);
+  const QString cs = GlobalPreferences::inst ()->getValue ("3dview/colorscheme").toString ();
+  this->setColorScheme (cs);
 
   //find and replace panel
-  connect(this->findTypeComboBox, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &MainWindow::actionSelectFind);
-  connect(this->findInputField, &QWordSearchField::textChanged, this, &MainWindow::findString);
-  connect(this->findInputField, &QWordSearchField::returnPressed, this->findNextButton, [this] {
-    this->findNextButton->animateClick();
+  connect (this->findTypeComboBox, QOverload<int>::of (&QComboBox::currentIndexChanged), this, &MainWindow::actionSelectFind);
+  connect (this->findInputField, &QWordSearchField::textChanged, this, &MainWindow::findString);
+  connect (this->findInputField, &QWordSearchField::returnPressed, this->findNextButton, [this] {
+    this->findNextButton->animateClick ();
   });
-  find_panel->installEventFilter(this);
-  if (QApplication::clipboard()->supportsFindBuffer()) {
-    connect(this->findInputField, &QWordSearchField::textChanged, this, &MainWindow::updateFindBuffer);
-    connect(QApplication::clipboard(), &QClipboard::findBufferChanged, this, &MainWindow::findBufferChanged);
+  find_panel->installEventFilter (this);
+  if (QApplication::clipboard ()->supportsFindBuffer ()) {
+    connect (this->findInputField, &QWordSearchField::textChanged, this, &MainWindow::updateFindBuffer);
+    connect (QApplication::clipboard (), &QClipboard::findBufferChanged, this, &MainWindow::findBufferChanged);
     // With Qt 4.8.6, there seems to be a bug that often gives an incorrect findbuffer content when
     // the app receives focus for the first time
-    this->findInputField->setText(QApplication::clipboard()->text(QClipboard::FindBuffer));
+    this->findInputField->setText (QApplication::clipboard ()->text (QClipboard::FindBuffer));
   }
 
-  connect(this->findPrevButton, &QPushButton::clicked, this, &MainWindow::findPrev);
-  connect(this->findNextButton, &QPushButton::clicked, this, &MainWindow::findNext);
-  connect(this->cancelButton, &QPushButton::clicked, this, &MainWindow::hideFind);
-  connect(this->replaceButton, &QPushButton::clicked, this, &MainWindow::replace);
-  connect(this->replaceAllButton, &QPushButton::clicked, this, &MainWindow::replaceAll);
-  connect(this->replaceInputField, &QLineEdit::returnPressed, this->replaceButton, [this] {
-    this->replaceButton->animateClick();
+  connect (this->findPrevButton, &QPushButton::clicked, this, &MainWindow::findPrev);
+  connect (this->findNextButton, &QPushButton::clicked, this, &MainWindow::findNext);
+  connect (this->cancelButton, &QPushButton::clicked, this, &MainWindow::hideFind);
+  connect (this->replaceButton, &QPushButton::clicked, this, &MainWindow::replace);
+  connect (this->replaceAllButton, &QPushButton::clicked, this, &MainWindow::replaceAll);
+  connect (this->replaceInputField, &QLineEdit::returnPressed, this->replaceButton, [this] {
+    this->replaceButton->animateClick ();
   });
-  addKeyboardShortCut(this->viewerToolBar->actions());
-  addKeyboardShortCut(this->editortoolbar->actions());
+  addKeyboardShortCut (this->viewerToolBar->actions ());
+  addKeyboardShortCut (this->editortoolbar->actions ());
 
-  Preferences *instance = GlobalPreferences::inst();
+  Preferences *instance = GlobalPreferences::inst ();
 
-  InputDriverManager::instance()->registerActions(this->menuBar()->actions(), "", "");
-  InputDriverManager::instance()->registerActions(this->animateWidget->actions(), "animation", "animate");
-  instance->ButtonConfig->init();
+  InputDriverManager::instance ()->registerActions (this->menuBar ()->actions (), "", "");
+  InputDriverManager::instance ()->registerActions (this->animateWidget->actions (), "animation", "animate");
+  instance->ButtonConfig->init ();
 
   // fetch window states to be restored after restoreState() call
-  const bool isConsoldDockVisible = !settings.value("view/hideConsole").toBool();
-  const bool isEditorDockVisible = !settings.value("view/hideEditor").toBool();
-  bool isCustomizerDockVisible = !settings.value("view/hideCustomizer").toBool();
-  const bool isErrorLogVisible = !settings.value("view/hideErrorLog").toBool();
-  const bool isAnimateDockVisible = !settings.value("view/hideAnimate").toBool();
-  const bool isFontListDockVisible = !settings.value("view/hideFontList").toBool();
-  bool isViewportControlVisible = !settings.value("view/hideViewportControl").toBool();
-  const bool isEditorToolbarVisible = !settings.value("view/hideEditorToolbar").toBool();
-  const bool is3DViewToolbarVisible = !settings.value("view/hide3DViewToolbar").toBool();
+  const bool isConsoldDockVisible = !settings.value ("view/hideConsole").toBool ();
+  const bool isEditorDockVisible = !settings.value ("view/hideEditor").toBool ();
+  bool isCustomizerDockVisible = !settings.value ("view/hideCustomizer").toBool ();
+  const bool isErrorLogVisible = !settings.value ("view/hideErrorLog").toBool ();
+  const bool isAnimateDockVisible = !settings.value ("view/hideAnimate").toBool ();
+  const bool isFontListDockVisible = !settings.value ("view/hideFontList").toBool ();
+  bool isViewportControlVisible = !settings.value ("view/hideViewportControl").toBool ();
+  const bool isEditorToolbarVisible = !settings.value ("view/hideEditorToolbar").toBool ();
+  const bool is3DViewToolbarVisible = !settings.value ("view/hide3DViewToolbar").toBool ();
 
   // make sure it looks nice..
-  const auto windowState = settings.value("window/state", QByteArray()).toByteArray();
-  restoreGeometry(settings.value("window/geometry", QByteArray()).toByteArray());
+  const auto windowState = settings.value ("window/state", QByteArray ()).toByteArray ();
+  restoreGeometry (settings.value ("window/geometry", QByteArray ()).toByteArray ());
 #if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
   // Workaround for a Qt bug (possible QTBUG-46620, but it's still there in Qt-6.5.3)
   // Blindly restoring a maximized window to a different screen resolution causes a crash
   // on the next move/resize operation on macOS:
   // https://github.com/openscad/openscad/issues/5486
-  if (isMaximized()) {
-    setGeometry(screen()->availableGeometry());
+  if (isMaximized ()) {
+    setGeometry (screen ()->availableGeometry ());
   }
 #endif
-  restoreState(windowState);
+  restoreState (windowState);
 
-  if (windowState.size() == 0) {
+  if (windowState.size () == 0) {
     /*
      * This triggers only in case the configuration file has no
      * window state information (or no configuration file at all).
@@ -691,11 +686,11 @@ MainWindow::MainWindow(const QStringList& filenames) :
      * ignored by the layouting as the editor is set to expand to
      * fill the available space.
      */
-    activeEditor->setInitialSizeHint(QSize((5 * this->width() / 11), 100));
-    tabifyDockWidget(consoleDock, errorLogDock);
-    tabifyDockWidget(errorLogDock, fontListDock);
-    tabifyDockWidget(fontListDock, animateDock);
-    consoleDock->show();
+    activeEditor->setInitialSizeHint (QSize ((5 * this->width () / 11), 100));
+    tabifyDockWidget (consoleDock, errorLogDock);
+    tabifyDockWidget (errorLogDock, fontListDock);
+    tabifyDockWidget (fontListDock, animateDock);
+    consoleDock->show ();
     isCustomizerDockVisible = true;
     isViewportControlVisible = true;
   } else {
@@ -706,181 +701,184 @@ MainWindow::MainWindow(const QStringList& filenames) :
     // again.
     // On Windows that causes the main window to open in a not
     // easily reachable place.
-    auto primaryScreen = QApplication::primaryScreen();
-    auto desktopRect = primaryScreen->availableGeometry().adjusted(250, 150, -250, -150).normalized();
-    auto windowRect = frameGeometry();
-    if (!desktopRect.intersects(windowRect)) {
-      windowRect.moveCenter(desktopRect.center());
-      windowRect = windowRect.intersected(desktopRect);
-      move(windowRect.topLeft());
-      resize(windowRect.size());
+    auto primaryScreen = QApplication::primaryScreen ();
+    auto desktopRect = primaryScreen->availableGeometry ().adjusted (250, 150, -250, -150).normalized ();
+    auto windowRect = frameGeometry ();
+    if (!desktopRect.intersects (windowRect)) {
+      windowRect.moveCenter (desktopRect.center ());
+      windowRect = windowRect.intersected (desktopRect);
+      move (windowRect.topLeft ());
+      resize (windowRect.size ());
     }
 #endif // ifdef Q_OS_WIN
   }
 
-  updateWindowSettings(isConsoldDockVisible, isEditorDockVisible, isCustomizerDockVisible, isErrorLogVisible, isEditorToolbarVisible, is3DViewToolbarVisible, isAnimateDockVisible, isFontListDockVisible, isViewportControlVisible);
+  updateWindowSettings (isConsoldDockVisible, isEditorDockVisible, isCustomizerDockVisible, isErrorLogVisible, isEditorToolbarVisible, is3DViewToolbarVisible, isAnimateDockVisible, isFontListDockVisible, isViewportControlVisible);
 
   // Connect the menu "Windows/Navigation" to slot that process it by opening in a pop menu
   // the navigationMenu.
-  connect(windowActionJumpTo, &QAction::triggered, this, &MainWindow::onNavigationOpenContextMenu);
+  connect (windowActionJumpTo, &QAction::triggered, this, &MainWindow::onNavigationOpenContextMenu);
 
   // Create the popup menu to navigate between the docks by keyboard.
-  navigationMenu = new QMenu();
-  for (auto& [dock, title] : docks) {
-    auto action2 = navigationMenu->addAction(title);
-    action2->setProperty("id", QVariant::fromValue(dock));
-    connect(action2, &QAction::triggered, this, &MainWindow::onNavigationTriggerContextMenuEntry);
-    connect(action2, &QAction::hovered, this, &MainWindow::onNavigationHoveredContextMenuEntry);
+  navigationMenu = new QMenu ();
+  for (auto &[dock, title] : docks) {
+    auto action2 = navigationMenu->addAction (title);
+    action2->setProperty ("id", QVariant::fromValue (dock));
+    connect (action2, &QAction::triggered, this, &MainWindow::onNavigationTriggerContextMenuEntry);
+    connect (action2, &QAction::hovered, this, &MainWindow::onNavigationHoveredContextMenuEntry);
   }
-  connect(navigationMenu, &QMenu::aboutToHide, this, &MainWindow::onNavigationCloseContextMenu);
-  connect(menuWindow, &QMenu::aboutToHide, this, &MainWindow::onNavigationCloseContextMenu);
-  windowActionJumpTo->setMenu(navigationMenu);
+  connect (navigationMenu, &QMenu::aboutToHide, this, &MainWindow::onNavigationCloseContextMenu);
+  connect (menuWindow, &QMenu::aboutToHide, this, &MainWindow::onNavigationCloseContextMenu);
+  windowActionJumpTo->setMenu (navigationMenu);
 
   // connect the signal of next/prev windowAction and the dedicated slot
   // hovering is connected to rubberband activation while triggering is for actual
   // activation of the corresponding dock.
   const std::vector<QAction *> actions = {windowActionNextWindow, windowActionPreviousWindow};
-  for (auto& action : actions) {
-    connect(action, &QAction::hovered, this, &MainWindow::onWindowActionNextPrevHovered);
-    connect(action, &QAction::triggered, this, &MainWindow::onWindowActionNextPrevTriggered);
+  for (auto &action : actions) {
+    connect (action, &QAction::hovered, this, &MainWindow::onWindowActionNextPrevHovered);
+    connect (action, &QAction::triggered, this, &MainWindow::onWindowActionNextPrevTriggered);
   }
 
   // Adds shortcut for the prev/next window switching
-  shortcutNextWindow = new QShortcut(QKeySequence(Qt::CTRL + Qt::Key_K), this);
-  QObject::connect(shortcutNextWindow,    &QShortcut::activated,
-                   this,        &MainWindow::onWindowShortcutNextPrevActivated);
-  shortcutPreviousWindow = new QShortcut(QKeySequence(Qt::CTRL + Qt::Key_H), this);
-  QObject::connect(shortcutPreviousWindow,    &QShortcut::activated,
-                   this,        &MainWindow::onWindowShortcutNextPrevActivated);
+  shortcutNextWindow = new QShortcut (QKeySequence (Qt::CTRL + Qt::Key_K), this);
+  QObject::connect (shortcutNextWindow, &QShortcut::activated,
+                    this, &MainWindow::onWindowShortcutNextPrevActivated);
+  shortcutPreviousWindow = new QShortcut (QKeySequence (Qt::CTRL + Qt::Key_H), this);
+  QObject::connect (shortcutPreviousWindow, &QShortcut::activated,
+                    this, &MainWindow::onWindowShortcutNextPrevActivated);
 
   // Adds dock specific behavior on visibility change
-  QObject::connect(editorDock,  &Dock::visibilityChanged,
-                   this,        &MainWindow::onEditorDockVisibilityChanged);
-  QObject::connect(consoleDock,  &Dock::visibilityChanged,
-                   this,        &MainWindow::onConsoleDockVisibilityChanged);
-  QObject::connect(errorLogDock,  &Dock::visibilityChanged,
-                   this,        &MainWindow::onErrorLogDockVisibilityChanged);
-  QObject::connect(animateDock,  &Dock::visibilityChanged,
-                   this,        &MainWindow::onAnimateDockVisibilityChanged);
-  QObject::connect(fontListDock,  &Dock::visibilityChanged,
-                   this,        &MainWindow::onFontListDockVisibilityChanged);
-  QObject::connect(viewportControlDock,  &Dock::visibilityChanged,
-                   this,        &MainWindow::onViewportControlDockVisibilityChanged);
-  QObject::connect(parameterDock,  &Dock::visibilityChanged,
-                   this,        &MainWindow::onParametersDockVisibilityChanged);
-
-  connect(this->activeEditor, &EditorInterface::escapePressed, this, &MainWindow::measureFinished);
+  QObject::connect (editorDock, &Dock::visibilityChanged,
+                    this, &MainWindow::onEditorDockVisibilityChanged);
+  QObject::connect (consoleDock, &Dock::visibilityChanged,
+                    this, &MainWindow::onConsoleDockVisibilityChanged);
+  QObject::connect (errorLogDock, &Dock::visibilityChanged,
+                    this, &MainWindow::onErrorLogDockVisibilityChanged);
+  QObject::connect (animateDock, &Dock::visibilityChanged,
+                    this, &MainWindow::onAnimateDockVisibilityChanged);
+  QObject::connect (fontListDock, &Dock::visibilityChanged,
+                    this, &MainWindow::onFontListDockVisibilityChanged);
+  QObject::connect (viewportControlDock, &Dock::visibilityChanged,
+                    this, &MainWindow::onViewportControlDockVisibilityChanged);
+  QObject::connect (parameterDock, &Dock::visibilityChanged,
+                    this, &MainWindow::onParametersDockVisibilityChanged);
+
+  connect (this->activeEditor, &EditorInterface::escapePressed, this, &MainWindow::measureFinished);
   // display this window and check for OpenGL 2.0 (OpenCSG) support
-  viewModeThrownTogether();
-  show();
+  viewModeThrownTogether ();
+  show ();
 
-  setCurrentOutput();
+  setCurrentOutput ();
 
 #ifdef ENABLE_OPENCSG
-  viewModePreview();
+  viewModePreview ();
 #else
-  viewModeThrownTogether();
+  viewModeThrownTogether ();
 #endif
-  loadViewSettings();
-  loadDesignSettings();
+  loadViewSettings ();
+  loadDesignSettings ();
 
-  setAcceptDrops(true);
-  clearCurrentOutput();
+  setAcceptDrops (true);
+  clearCurrentOutput ();
 
-  for (int i = 1; i < filenames.size(); ++i)
-    tabManager->createTab(filenames[i]);
+  for (int i = 1; i < filenames.size (); ++i)
+    tabManager->createTab (filenames[i]);
 
-  updateExportActions();
+  updateExportActions ();
 
-  activeEditor->setFocus();
+  activeEditor->setFocus ();
 
   // Configure the highlighting color scheme from the active editor one.
   // This is done only one time at creation of the first MainWindow instance
-  auto preferences = GlobalPreferences::inst();
-  if (!preferences->hasHighlightingColorScheme())preferences->setHighlightingColorSchemes(activeEditor->colorSchemes());
+  auto preferences = GlobalPreferences::inst ();
+  if (!preferences->hasHighlightingColorScheme ())
+    preferences->setHighlightingColorSchemes (activeEditor->colorSchemes ());
 
-  onTabManagerEditorChanged(activeEditor);
+  onTabManagerEditorChanged (activeEditor);
 
   // fills the content of the Recents Files menu.
-  updateRecentFileActions();
+  updateRecentFileActions ();
 }
 
-void MainWindow::onNavigationOpenContextMenu() {
-  navigationMenu->exec(QCursor::pos());
+void MainWindow::onNavigationOpenContextMenu () {
+  navigationMenu->exec (QCursor::pos ());
 }
 
-void MainWindow::onNavigationCloseContextMenu() {
-  rubberBandManager.hide();
+void MainWindow::onNavigationCloseContextMenu () {
+  rubberBandManager.hide ();
 }
 
-void MainWindow::onNavigationTriggerContextMenuEntry(){
-  auto *action = qobject_cast<QAction *>(sender());
-  if (!action || !action->property("id").isValid()) return;
+void MainWindow::onNavigationTriggerContextMenuEntry () {
+  auto *action = qobject_cast<QAction *> (sender ());
+  if (!action || !action->property ("id").isValid ())
+    return;
 
-  Dock *dock = action->property("id").value<Dock *>();
-  assert(dock != nullptr);
+  Dock *dock = action->property ("id").value<Dock *> ();
+  assert (dock != nullptr);
 
-  dock->raise();
-  dock->show();
-  dock->setFocus();
+  dock->raise ();
+  dock->show ();
+  dock->setFocus ();
 
   // Forward the focus on the content of the tabmanager
   if (dock == editorDock) {
-    tabManager->setFocus();
+    tabManager->setFocus ();
   }
 }
 
-void MainWindow::onNavigationHoveredContextMenuEntry(){
-  auto *action = qobject_cast<QAction *>(sender());
-  if (!action || !action->property("id").isValid()) return;
+void MainWindow::onNavigationHoveredContextMenuEntry () {
+  auto *action = qobject_cast<QAction *> (sender ());
+  if (!action || !action->property ("id").isValid ())
+    return;
 
-  Dock *dock = action->property("id").value<Dock *>();
-  assert(dock != nullptr);
+  Dock *dock = action->property ("id").value<Dock *> ();
+  assert (dock != nullptr);
 
   // Hover signal is emitted at each mouse move, to avoid excessive
   // load we only raise/emphasize if it is not yet done.
-  if (rubberBandManager.isEmphasized(dock)) return;
+  if (rubberBandManager.isEmphasized (dock))
+    return;
 
-  dock->raise();
-  rubberBandManager.emphasize(dock);
+  dock->raise ();
+  rubberBandManager.emphasize (dock);
 }
 
-void MainWindow::updateExportActions() {
-  removeExportActions(editortoolbar, this->designAction3DPrint);
-  addExportActions(this, editortoolbar, this->designAction3DPrint);
+void MainWindow::updateExportActions () {
+  removeExportActions (editortoolbar, this->designAction3DPrint);
+  addExportActions (this, editortoolbar, this->designAction3DPrint);
 
   //handle the hide/show of export action in view toolbar according to the visibility of editor dock
-  removeExportActions(viewerToolBar, this->viewActionViewAll);
-  if (!editorDock->isVisible()) {
-    addExportActions(this, viewerToolBar, this->viewActionViewAll);
+  removeExportActions (viewerToolBar, this->viewActionViewAll);
+  if (!editorDock->isVisible ()) {
+    addExportActions (this, viewerToolBar, this->viewActionViewAll);
   }
 }
 
-void MainWindow::openFileFromPath(const QString& path, int line)
-{
-  if (editorDock->isVisible()) {
-    activeEditor->setFocus();
-    if (!path.isEmpty()) tabManager->open(path);
-    activeEditor->setFocus();
-    activeEditor->setCursorPosition(line, 0);
+void MainWindow::openFileFromPath (const QString &path, int line) {
+  if (editorDock->isVisible ()) {
+    activeEditor->setFocus ();
+    if (!path.isEmpty ())
+      tabManager->open (path);
+    activeEditor->setFocus ();
+    activeEditor->setCursorPosition (line, 0);
   }
 }
 
-void MainWindow::addKeyboardShortCut(const QList<QAction *>& actions)
-{
-  for (auto& action : actions) {
+void MainWindow::addKeyboardShortCut (const QList<QAction *> &actions) {
+  for (auto &action : actions) {
     // prevent adding shortcut twice if action is added to multiple toolbars
-    if (action->toolTip().contains("&nbsp;")) {
+    if (action->toolTip ().contains ("&nbsp;")) {
       continue;
     }
 
-    const QString shortCut(action->shortcut().toString(QKeySequence::NativeText));
-    if (shortCut.isEmpty()) {
+    const QString shortCut (action->shortcut ().toString (QKeySequence::NativeText));
+    if (shortCut.isEmpty ()) {
       continue;
     }
 
-    const QString toolTip("%1 &nbsp;<span style=\"color: gray; font-size: small; font-style: italic\">%2</span>");
-    action->setToolTip(toolTip.arg(action->toolTip(), shortCut));
+    const QString toolTip ("%1 &nbsp;<span style=\"color: gray; font-size: small; font-style: italic\">%2</span>");
+    action->setToolTip (toolTip.arg (action->toolTip (), shortCut));
   }
 }
 
@@ -889,246 +887,230 @@ void MainWindow::addKeyboardShortCut(const QList<QAction *>& actions)
  * Qt call. So the values are loaded before the call and restored here
  * regardless of the (potential outdated) serialized state.
  */
-void MainWindow::updateWindowSettings(bool isConsoleVisible,
-                                      bool isEditorVisible,
-                                      bool isCustomizerVisible,
-                                      bool isErrorLogVisible,
-                                      bool isEditorToolbarVisible,
-                                      bool isViewToolbarVisible,
-                                      bool isAnimateVisible,
-                                      bool isFontListVisible,
-                                      bool isViewportControlVisible)
-{
-  editorDock->setVisible(isEditorVisible);
-  consoleDock->setVisible(isConsoleVisible);
-  errorLogDock->setVisible(isErrorLogVisible);
-  parameterDock->setVisible(isCustomizerVisible);
-  animateDock->setVisible(isAnimateVisible);
-  fontListDock->setVisible(isFontListVisible);
-  viewportControlDock->setVisible(isViewportControlVisible);
+void MainWindow::updateWindowSettings (bool isConsoleVisible,
+                                       bool isEditorVisible,
+                                       bool isCustomizerVisible,
+                                       bool isErrorLogVisible,
+                                       bool isEditorToolbarVisible,
+                                       bool isViewToolbarVisible,
+                                       bool isAnimateVisible,
+                                       bool isFontListVisible,
+                                       bool isViewportControlVisible) {
+  editorDock->setVisible (isEditorVisible);
+  consoleDock->setVisible (isConsoleVisible);
+  errorLogDock->setVisible (isErrorLogVisible);
+  parameterDock->setVisible (isCustomizerVisible);
+  animateDock->setVisible (isAnimateVisible);
+  fontListDock->setVisible (isFontListVisible);
+  viewportControlDock->setVisible (isViewportControlVisible);
 
-  viewActionHideEditorToolBar->setChecked(!isEditorToolbarVisible);
-  hideEditorToolbar();
-  viewActionHide3DViewToolBar->setChecked(!isViewToolbarVisible);
-  hide3DViewToolbar();
+  viewActionHideEditorToolBar->setChecked (!isEditorToolbarVisible);
+  hideEditorToolbar ();
+  viewActionHide3DViewToolBar->setChecked (!isViewToolbarVisible);
+  hide3DViewToolbar ();
 }
 
-void MainWindow::onAxisChanged(InputEventAxisChanged *)
-{
-
+void MainWindow::onAxisChanged (InputEventAxisChanged *) {
 }
 
-void MainWindow::onButtonChanged(InputEventButtonChanged *)
-{
-
+void MainWindow::onButtonChanged (InputEventButtonChanged *) {
 }
 
-void MainWindow::onTranslateEvent(InputEventTranslate *event)
-{
-  const double zoomFactor = 0.001 * qglview->cam.zoomValue();
+void MainWindow::onTranslateEvent (InputEventTranslate *event) {
+  const double zoomFactor = 0.001 * qglview->cam.zoomValue ();
 
   if (event->viewPortRelative) {
-    qglview->translate(event->x, event->y, event->z, event->relative, true);
+    qglview->translate (event->x, event->y, event->z, event->relative, true);
   } else {
-    qglview->translate(zoomFactor * event->x, event->y, zoomFactor * event->z, event->relative, false);
+    qglview->translate (zoomFactor * event->x, event->y, zoomFactor * event->z, event->relative, false);
   }
 }
 
-void MainWindow::onRotateEvent(InputEventRotate *event)
-{
-  qglview->rotate(event->x, event->y, event->z, event->relative);
+void MainWindow::onRotateEvent (InputEventRotate *event) {
+  qglview->rotate (event->x, event->y, event->z, event->relative);
 }
 
-void MainWindow::onRotate2Event(InputEventRotate2 *event)
-{
-  qglview->rotate2(event->x, event->y, event->z);
+void MainWindow::onRotate2Event (InputEventRotate2 *event) {
+  qglview->rotate2 (event->x, event->y, event->z);
 }
 
-void MainWindow::onActionEvent(InputEventAction *event)
-{
+void MainWindow::onActionEvent (InputEventAction *event) {
   const std::string actionName = event->action;
-  if (actionName.find("::") == std::string::npos) {
-    QAction *action = findAction(this->menuBar()->actions(), actionName);
+  if (actionName.find ("::") == std::string::npos) {
+    QAction *action = findAction (this->menuBar ()->actions (), actionName);
     if (action) {
-      action->trigger();
+      action->trigger ();
     } else if ("viewActionTogglePerspective" == actionName) {
-      viewTogglePerspective();
+      viewTogglePerspective ();
     }
   } else {
-    const std::string target = actionName.substr(0, actionName.find("::"));
+    const std::string target = actionName.substr (0, actionName.find ("::"));
     if (target == "animate") {
-      this->animateWidget->onActionEvent(event);
+      this->animateWidget->onActionEvent (event);
     } else {
       std::cout << "unknown onActionEvent target: " << actionName << std::endl;
     }
   }
 }
 
-void MainWindow::onZoomEvent(InputEventZoom *event)
-{
-  qglview->zoom(event->zoom, event->relative);
+void MainWindow::onZoomEvent (InputEventZoom *event) {
+  qglview->zoom (event->zoom, event->relative);
 }
 
-void MainWindow::loadViewSettings(){
+void MainWindow::loadViewSettings () {
   const QSettingsCached settings;
 
-  if (settings.value("view/showEdges").toBool()) {
-    viewActionShowEdges->setChecked(true);
-    viewModeShowEdges();
+  if (settings.value ("view/showEdges").toBool ()) {
+    viewActionShowEdges->setChecked (true);
+    viewModeShowEdges ();
   }
-  if (settings.value("view/showAxes", true).toBool()) {
-    viewActionShowAxes->setChecked(true);
-    viewModeShowAxes();
+  if (settings.value ("view/showAxes", true).toBool ()) {
+    viewActionShowAxes->setChecked (true);
+    viewModeShowAxes ();
   }
-  if (settings.value("view/showCrosshairs").toBool()) {
-    viewActionShowCrosshairs->setChecked(true);
-    viewModeShowCrosshairs();
+  if (settings.value ("view/showCrosshairs").toBool ()) {
+    viewActionShowCrosshairs->setChecked (true);
+    viewModeShowCrosshairs ();
   }
-  if (settings.value("view/showScaleProportional", true).toBool()) {
-    viewActionShowScaleProportional->setChecked(true);
-    viewModeShowScaleProportional();
+  if (settings.value ("view/showScaleProportional", true).toBool ()) {
+    viewActionShowScaleProportional->setChecked (true);
+    viewModeShowScaleProportional ();
   }
-  if (settings.value("view/orthogonalProjection").toBool()) {
-    viewOrthogonal();
+  if (settings.value ("view/orthogonalProjection").toBool ()) {
+    viewOrthogonal ();
   } else {
-    viewPerspective();
+    viewPerspective ();
   }
 
-  updateUndockMode(GlobalPreferences::inst()->getValue("advanced/undockableWindows").toBool());
-  updateReorderMode(GlobalPreferences::inst()->getValue("advanced/reorderWindows").toBool());
+  updateUndockMode (GlobalPreferences::inst ()->getValue ("advanced/undockableWindows").toBool ());
+  updateReorderMode (GlobalPreferences::inst ()->getValue ("advanced/reorderWindows").toBool ());
 }
 
-void MainWindow::loadDesignSettings()
-{
+void MainWindow::loadDesignSettings () {
   const QSettingsCached settings;
-  if (settings.value("design/autoReload", false).toBool()) {
-    designActionAutoReload->setChecked(true);
+  if (settings.value ("design/autoReload", false).toBool ()) {
+    designActionAutoReload->setChecked (true);
   }
-  auto polySetCacheSizeMB = GlobalPreferences::inst()->getValue("advanced/polysetCacheSizeMB").toUInt();
-  GeometryCache::instance()->setMaxSizeMB(polySetCacheSizeMB);
-  auto cgalCacheSizeMB = GlobalPreferences::inst()->getValue("advanced/cgalCacheSizeMB").toUInt();
-  CGALCache::instance()->setMaxSizeMB(cgalCacheSizeMB);
-  auto backend3D = GlobalPreferences::inst()->getValue("advanced/renderBackend3D").toString().toStdString();
-  RenderSettings::inst()->backend3D = renderBackend3DFromString(backend3D);
+  auto polySetCacheSizeMB = GlobalPreferences::inst ()->getValue ("advanced/polysetCacheSizeMB").toUInt ();
+  GeometryCache::instance ()->setMaxSizeMB (polySetCacheSizeMB);
+  auto cgalCacheSizeMB = GlobalPreferences::inst ()->getValue ("advanced/cgalCacheSizeMB").toUInt ();
+  CGALCache::instance ()->setMaxSizeMB (cgalCacheSizeMB);
+  auto backend3D = GlobalPreferences::inst ()->getValue ("advanced/renderBackend3D").toString ().toStdString ();
+  RenderSettings::inst ()->backend3D = renderBackend3DFromString (backend3D);
 }
 
-void MainWindow::updateUndockMode(bool undockMode)
-{
+void MainWindow::updateUndockMode (bool undockMode) {
   MainWindow::undockMode = undockMode;
   if (undockMode) {
-    editorDock->setFeatures(editorDock->features() | QDockWidget::DockWidgetFloatable);
-    consoleDock->setFeatures(consoleDock->features() | QDockWidget::DockWidgetFloatable);
-    parameterDock->setFeatures(parameterDock->features() | QDockWidget::DockWidgetFloatable);
-    errorLogDock->setFeatures(errorLogDock->features() | QDockWidget::DockWidgetFloatable);
-    animateDock->setFeatures(animateDock->features() | QDockWidget::DockWidgetFloatable);
-    fontListDock->setFeatures(fontListDock->features() | QDockWidget::DockWidgetFloatable);
-    viewportControlDock->setFeatures(viewportControlDock->features() | QDockWidget::DockWidgetFloatable);
+    editorDock->setFeatures (editorDock->features () | QDockWidget::DockWidgetFloatable);
+    consoleDock->setFeatures (consoleDock->features () | QDockWidget::DockWidgetFloatable);
+    parameterDock->setFeatures (parameterDock->features () | QDockWidget::DockWidgetFloatable);
+    errorLogDock->setFeatures (errorLogDock->features () | QDockWidget::DockWidgetFloatable);
+    animateDock->setFeatures (animateDock->features () | QDockWidget::DockWidgetFloatable);
+    fontListDock->setFeatures (fontListDock->features () | QDockWidget::DockWidgetFloatable);
+    viewportControlDock->setFeatures (viewportControlDock->features () | QDockWidget::DockWidgetFloatable);
   } else {
-    if (editorDock->isFloating()) {
-      editorDock->setFloating(false);
+    if (editorDock->isFloating ()) {
+      editorDock->setFloating (false);
     }
-    editorDock->setFeatures(editorDock->features() & ~QDockWidget::DockWidgetFloatable);
+    editorDock->setFeatures (editorDock->features () & ~QDockWidget::DockWidgetFloatable);
 
-    if (consoleDock->isFloating()) {
-      consoleDock->setFloating(false);
+    if (consoleDock->isFloating ()) {
+      consoleDock->setFloating (false);
     }
-    consoleDock->setFeatures(consoleDock->features() & ~QDockWidget::DockWidgetFloatable);
+    consoleDock->setFeatures (consoleDock->features () & ~QDockWidget::DockWidgetFloatable);
 
-    if (parameterDock->isFloating()) {
-      parameterDock->setFloating(false);
+    if (parameterDock->isFloating ()) {
+      parameterDock->setFloating (false);
     }
-    parameterDock->setFeatures(parameterDock->features() & ~QDockWidget::DockWidgetFloatable);
+    parameterDock->setFeatures (parameterDock->features () & ~QDockWidget::DockWidgetFloatable);
 
-    if (errorLogDock->isFloating()) {
-      errorLogDock->setFloating(false);
+    if (errorLogDock->isFloating ()) {
+      errorLogDock->setFloating (false);
     }
-    errorLogDock->setFeatures(errorLogDock->features() & ~QDockWidget::DockWidgetFloatable);
+    errorLogDock->setFeatures (errorLogDock->features () & ~QDockWidget::DockWidgetFloatable);
 
-    if (animateDock->isFloating()) {
-      animateDock->setFloating(false);
+    if (animateDock->isFloating ()) {
+      animateDock->setFloating (false);
     }
-    animateDock->setFeatures(animateDock->features() & ~QDockWidget::DockWidgetFloatable);
+    animateDock->setFeatures (animateDock->features () & ~QDockWidget::DockWidgetFloatable);
 
-    if (fontListDock->isFloating()) {
-      fontListDock->setFloating(false);
+    if (fontListDock->isFloating ()) {
+      fontListDock->setFloating (false);
     }
-    fontListDock->setFeatures(fontListDock->features() & ~QDockWidget::DockWidgetFloatable);
+    fontListDock->setFeatures (fontListDock->features () & ~QDockWidget::DockWidgetFloatable);
 
-    if (viewportControlDock->isFloating()) {
-      viewportControlDock->setFloating(false);
+    if (viewportControlDock->isFloating ()) {
+      viewportControlDock->setFloating (false);
     }
-    viewportControlDock->setFeatures(viewportControlDock->features() & ~QDockWidget::DockWidgetFloatable);
+    viewportControlDock->setFeatures (viewportControlDock->features () & ~QDockWidget::DockWidgetFloatable);
   }
 }
 
-void MainWindow::updateReorderMode(bool reorderMode)
-{
+void MainWindow::updateReorderMode (bool reorderMode) {
   MainWindow::reorderMode = reorderMode;
-  for (auto& [dock, name] : docks) {
-    dock->setTitleBarVisibility(!reorderMode);
+  for (auto &[dock, name] : docks) {
+    dock->setTitleBarVisibility (!reorderMode);
   }
 }
 
-MainWindow::~MainWindow()
-{
+MainWindow::~MainWindow () {
   // If root_file is not null then it will be the same as parsed_file,
   // so no need to delete it.
   delete parsedFile;
-  scadApp->windowManager.remove(this);
-  if (scadApp->windowManager.getWindows().empty()) {
+  scadApp->windowManager.remove (this);
+  if (scadApp->windowManager.getWindows ().empty ()) {
     // Quit application even in case some other windows like
     // Preferences are still open.
-    scadApp->quit();
+    scadApp->quit ();
   }
 }
 
-void MainWindow::showProgress()
-{
-  updateStatusBar(qobject_cast<ProgressWidget *>(sender()));
+void MainWindow::showProgress () {
+  updateStatusBar (qobject_cast<ProgressWidget *> (sender ()));
 }
 
-void MainWindow::report_func(const std::shared_ptr<const AbstractNode>&, void *vp, int mark)
-{
+void MainWindow::report_func (const std::shared_ptr<const AbstractNode> &, void *vp, int mark) {
   // limit to progress bar update calls to 5 per second
   static const qint64 MIN_TIMEOUT = 200;
-  if (progressThrottle->hasExpired(MIN_TIMEOUT)) {
-    progressThrottle->start();
+  if (progressThrottle->hasExpired (MIN_TIMEOUT)) {
+    progressThrottle->start ();
 
-    auto thisp = static_cast<MainWindow *>(vp);
-    auto v = static_cast<int>((mark * 1000.0) / progress_report_count);
+    auto thisp = static_cast<MainWindow *> (vp);
+    auto v = static_cast<int> ((mark * 1000.0) / progress_report_count);
     auto permille = v < 1000 ? v : 999;
-    if (permille > thisp->progresswidget->value()) {
-      QMetaObject::invokeMethod(thisp->progresswidget, "setValue", Qt::QueuedConnection,
-                                Q_ARG(int, permille));
-      QApplication::processEvents();
+    if (permille > thisp->progresswidget->value ()) {
+      QMetaObject::invokeMethod (thisp->progresswidget, "setValue", Qt::QueuedConnection,
+                                 Q_ARG (int, permille));
+      QApplication::processEvents ();
     }
 
     // FIXME: Check if cancel was requested by e.g. Application quit
-    if (thisp->progresswidget->wasCanceled()) throw ProgressCancelException();
+    if (thisp->progresswidget->wasCanceled ())
+      throw ProgressCancelException ();
   }
 }
 
-bool MainWindow::network_progress_func(const double permille)
-{
-  QMetaObject::invokeMethod(this->progresswidget, "setValue", Qt::QueuedConnection, Q_ARG(int, (int)permille));
-  return (progresswidget && progresswidget->wasCanceled());
+bool MainWindow::network_progress_func (const double permille) {
+  QMetaObject::invokeMethod (this->progresswidget, "setValue", Qt::QueuedConnection, Q_ARG (int, (int)permille));
+  return (progresswidget && progresswidget->wasCanceled ());
 }
 
-void MainWindow::updateRecentFiles(const QString& FileSavedOrOpened)
-{
+void MainWindow::updateRecentFiles (const QString &FileSavedOrOpened) {
   // Check that the canonical file path exists - only update recent files
   // if it does. Should prevent empty list items on initial open etc.
-  QSettingsCached settings;   // already set up properly via main.cpp
-  auto files = settings.value("recentFileList").toStringList();
-  files.removeAll(FileSavedOrOpened);
-  files.prepend(FileSavedOrOpened);
-  while (files.size() > UIUtils::maxRecentFiles) files.removeLast();
-  settings.setValue("recentFileList", files);
-
-  for (auto& widget : QApplication::topLevelWidgets()) {
-    auto mainWin = qobject_cast<MainWindow *>(widget);
+  QSettingsCached settings; // already set up properly via main.cpp
+  auto files = settings.value ("recentFileList").toStringList ();
+  files.removeAll (FileSavedOrOpened);
+  files.prepend (FileSavedOrOpened);
+  while (files.size () > UIUtils::maxRecentFiles)
+    files.removeLast ();
+  settings.setValue ("recentFileList", files);
+
+  for (auto &widget : QApplication::topLevelWidgets ()) {
+    auto mainWin = qobject_cast<MainWindow *> (widget);
     if (mainWin) {
-      mainWin->updateRecentFileActions();
+      mainWin->updateRecentFileActions ();
     }
   }
 }
@@ -1136,38 +1118,37 @@ void MainWindow::updateRecentFiles(const QString& FileSavedOrOpened)
 /*!
    compiles the design. Calls compileDone() if anything was compiled
  */
-void MainWindow::compile(bool reload, bool forcedone)
-{
-  OpenSCAD::hardwarnings = GlobalPreferences::inst()->getValue("advanced/enableHardwarnings").toBool();
-  OpenSCAD::traceDepth = GlobalPreferences::inst()->getValue("advanced/traceDepth").toUInt();
-  OpenSCAD::traceUsermoduleParameters = GlobalPreferences::inst()->getValue("advanced/enableTraceUsermoduleParameters").toBool();
-  OpenSCAD::parameterCheck = GlobalPreferences::inst()->getValue("advanced/enableParameterCheck").toBool();
-  OpenSCAD::rangeCheck = GlobalPreferences::inst()->getValue("advanced/enableParameterRangeCheck").toBool();
-
-  try{
+void MainWindow::compile (bool reload, bool forcedone) {
+  OpenSCAD::hardwarnings = GlobalPreferences::inst ()->getValue ("advanced/enableHardwarnings").toBool ();
+  OpenSCAD::traceDepth = GlobalPreferences::inst ()->getValue ("advanced/traceDepth").toUInt ();
+  OpenSCAD::traceUsermoduleParameters = GlobalPreferences::inst ()->getValue ("advanced/enableTraceUsermoduleParameters").toBool ();
+  OpenSCAD::parameterCheck = GlobalPreferences::inst ()->getValue ("advanced/enableParameterCheck").toBool ();
+  OpenSCAD::rangeCheck = GlobalPreferences::inst ()->getValue ("advanced/enableParameterRangeCheck").toBool ();
+
+  try {
     bool shouldcompiletoplevel = false;
     bool didcompile = false;
 
     compileErrors = 0;
     compileWarnings = 0;
 
-    this->renderStatistic.start();
+    this->renderStatistic.start ();
 
     // Reload checks the timestamp of the toplevel file and refreshes if necessary,
     if (reload) {
       // Refresh files if it has changed on disk
-      if (fileChangedOnDisk() && checkEditorModified()) {
-        shouldcompiletoplevel = tabManager->refreshDocument();         // don't compile if we couldn't open the file
-        if (shouldcompiletoplevel && GlobalPreferences::inst()->getValue("advanced/autoReloadRaise").toBool()) {
+      if (fileChangedOnDisk () && checkEditorModified ()) {
+        shouldcompiletoplevel = tabManager->refreshDocument (); // don't compile if we couldn't open the file
+        if (shouldcompiletoplevel && GlobalPreferences::inst ()->getValue ("advanced/autoReloadRaise").toBool ()) {
           // reloading the 'same' document brings the 'old' one to front.
-          this->raise();
+          this->raise ();
         }
       }
       // If the file has some content and there is no currently compiled content,
       // then we force the top level compilation.
       else {
-        auto current_doc = activeEditor->toPlainText();
-        if (current_doc.size() && lastCompiledDoc.size() == 0) {
+        auto current_doc = activeEditor->toPlainText ();
+        if (current_doc.size () && lastCompiledDoc.size () == 0) {
           shouldcompiletoplevel = true;
         }
       }
@@ -1176,7 +1157,7 @@ void MainWindow::compile(bool reload, bool forcedone)
     }
 
     if (this->parsedFile) {
-      auto mtime = this->parsedFile->includesChanged();
+      auto mtime = this->parsedFile->includesChanged ();
       if (mtime > this->includesMTime) {
         this->includesMTime = mtime;
         shouldcompiletoplevel = true;
@@ -1185,224 +1166,224 @@ void MainWindow::compile(bool reload, bool forcedone)
 
     // Parsing and dependency handling must run to completion even with stop on errors to prevent auto
     // reload picking up where it left off, thwarting the stop, so we turn off exceptions in PRINT.
-    no_exceptions_for_warnings();
+    no_exceptions_for_warnings ();
     if (shouldcompiletoplevel) {
-      initialize_rng();
-      this->errorLogWidget->clearModel();
-      if (GlobalPreferences::inst()->getValue("advanced/consoleAutoClear").toBool()) {
-        this->console->actionClearConsole_triggered();
+      initialize_rng ();
+      this->errorLogWidget->clearModel ();
+      if (GlobalPreferences::inst ()->getValue ("advanced/consoleAutoClear").toBool ()) {
+        this->console->actionClearConsole_triggered ();
       }
-      if (activeEditor->isContentModified()) saveBackup();
-      parseTopLevelDocument();
+      if (activeEditor->isContentModified ())
+        saveBackup ();
+      parseTopLevelDocument ();
       didcompile = true;
     }
 
     if (didcompile && parser_error_pos != lastParserErrorPos) {
-      if (lastParserErrorPos >= 0) emit unhighlightLastError();
-      if (parser_error_pos >= 0) emit highlightError(parser_error_pos);
+      if (lastParserErrorPos >= 0)
+        emit unhighlightLastError ();
+      if (parser_error_pos >= 0)
+        emit highlightError (parser_error_pos);
       lastParserErrorPos = parser_error_pos;
     }
 
     if (this->rootFile) {
-      auto mtime = this->rootFile->handleDependencies();
+      auto mtime = this->rootFile->handleDependencies ();
       if (mtime > this->depsMTime) {
         this->depsMTime = mtime;
-        LOG("Used file cache size: %1$d files", SourceFileCache::instance()->size());
+        LOG ("Used file cache size: %1$d files", SourceFileCache::instance ()->size ());
         didcompile = true;
       }
     }
 
     // Had any errors in the parse that would have caused exceptions via PRINT.
-    if (would_have_thrown()) throw HardWarningException("");
+    if (would_have_thrown ())
+      throw HardWarningException ("");
     // If we're auto-reloading, listen for a cascade of changes by starting a timer
     // if something changed _and_ there are any external dependencies
     if (reload && didcompile && this->rootFile) {
-      if (this->rootFile->hasIncludes() || this->rootFile->usesLibraries()) {
-        this->waitAfterReloadTimer->start();
+      if (this->rootFile->hasIncludes () || this->rootFile->usesLibraries ()) {
+        this->waitAfterReloadTimer->start ();
         this->procevents = false;
         return;
       }
     }
 
-    compileDone(didcompile | forcedone);
-  } catch (const HardWarningException&) {
-    exceptionCleanup();
-  } catch (const std::exception& ex) {
-    UnknownExceptionCleanup(ex.what());
+    compileDone (didcompile | forcedone);
+  } catch (const HardWarningException &) {
+    exceptionCleanup ();
+  } catch (const std::exception &ex) {
+    UnknownExceptionCleanup (ex.what ());
   } catch (...) {
-    UnknownExceptionCleanup();
+    UnknownExceptionCleanup ();
   }
 }
 
-void MainWindow::waitAfterReload()
-{
-  no_exceptions_for_warnings();
-  auto mtime = this->rootFile->handleDependencies();
-  auto stop = would_have_thrown();
-  if (mtime > this->depsMTime) this->depsMTime = mtime;
+void MainWindow::waitAfterReload () {
+  no_exceptions_for_warnings ();
+  auto mtime = this->rootFile->handleDependencies ();
+  auto stop = would_have_thrown ();
+  if (mtime > this->depsMTime)
+    this->depsMTime = mtime;
   else if (!stop) {
-    compile(true, true);     // In case file itself or top-level includes changed during dependency updates
+    compile (true, true); // In case file itself or top-level includes changed during dependency updates
     return;
   }
-  this->waitAfterReloadTimer->start();
+  this->waitAfterReloadTimer->start ();
 }
 
-void MainWindow::on_toolButtonCompileResultClose_clicked()
-{
-  frameCompileResult->hide();
+void MainWindow::on_toolButtonCompileResultClose_clicked () {
+  frameCompileResult->hide ();
 }
 
-void MainWindow::updateCompileResult()
-{
+void MainWindow::updateCompileResult () {
   if ((compileErrors == 0) && (compileWarnings == 0)) {
-    frameCompileResult->hide();
+    frameCompileResult->hide ();
     return;
   }
 
-  if (!Settings::Settings::showWarningsIn3dView.value()) {
+  if (!Settings::Settings::showWarningsIn3dView.value ()) {
     return;
   }
 
   QString msg;
   if (compileErrors > 0) {
-    if (activeEditor->filepath.isEmpty()) {
-      msg = QString(_("Compile error."));
+    if (activeEditor->filepath.isEmpty ()) {
+      msg = QString (_ ("Compile error."));
     } else {
-      const QFileInfo fileInfo(activeEditor->filepath);
-      msg = QString(_("Error while compiling '%1'.")).arg(fileInfo.fileName());
+      const QFileInfo fileInfo (activeEditor->filepath);
+      msg = QString (_ ("Error while compiling '%1'.")).arg (fileInfo.fileName ());
     }
-    toolButtonCompileResultIcon->setIcon(QIcon(QString::fromUtf8(":/icons/information-icons-error.png")));
+    toolButtonCompileResultIcon->setIcon (QIcon (QString::fromUtf8 (":/icons/information-icons-error.png")));
   } else {
-    const char *fmt = ngettext("Compilation generated %1 warning.", "Compilation generated %1 warnings.", compileWarnings);
-    msg = QString(fmt).arg(compileWarnings);
-    toolButtonCompileResultIcon->setIcon(QIcon(QString::fromUtf8(":/icons/information-icons-warning.png")));
+    const char *fmt = ngettext ("Compilation generated %1 warning.", "Compilation generated %1 warnings.", compileWarnings);
+    msg = QString (fmt).arg (compileWarnings);
+    toolButtonCompileResultIcon->setIcon (QIcon (QString::fromUtf8 (":/icons/information-icons-warning.png")));
   }
-  const QFontMetrics fm(labelCompileResultMessage->font());
-  const int sizeIcon = std::max(12, std::min(32, fm.height()));
-  const int sizeClose = std::max(10, std::min(32, fm.height()) - 4);
-  toolButtonCompileResultIcon->setIconSize(QSize(sizeIcon, sizeIcon));
-  toolButtonCompileResultClose->setIconSize(QSize(sizeClose, sizeClose));
+  const QFontMetrics fm (labelCompileResultMessage->font ());
+  const int sizeIcon = std::max (12, std::min (32, fm.height ()));
+  const int sizeClose = std::max (10, std::min (32, fm.height ()) - 4);
+  toolButtonCompileResultIcon->setIconSize (QSize (sizeIcon, sizeIcon));
+  toolButtonCompileResultClose->setIconSize (QSize (sizeClose, sizeClose));
 
-  msg += _(R"( For details see the <a href="#errorlog">error log</a> and <a href="#console">console window</a>.)");
-  labelCompileResultMessage->setText(msg);
-  frameCompileResult->show();
+  msg += _ (R"( For details see the <a href="#errorlog">error log</a> and <a href="#console">console window</a>.)");
+  labelCompileResultMessage->setText (msg);
+  frameCompileResult->show ();
 }
 
-void MainWindow::compileDone(bool didchange)
-{
-  OpenSCAD::hardwarnings = GlobalPreferences::inst()->getValue("advanced/enableHardwarnings").toBool();
-  try{
+void MainWindow::compileDone (bool didchange) {
+  OpenSCAD::hardwarnings = GlobalPreferences::inst ()->getValue ("advanced/enableHardwarnings").toBool ();
+  try {
     const char *callslot;
     if (didchange) {
-      instantiateRoot();
-      updateCompileResult();
+      instantiateRoot ();
+      updateCompileResult ();
       callslot = afterCompileSlot;
     } else {
       callslot = "compileEnded";
     }
 
     this->procevents = false;
-    QMetaObject::invokeMethod(this, callslot);
-  } catch (const HardWarningException&) {
-    exceptionCleanup();
+    QMetaObject::invokeMethod (this, callslot);
+  } catch (const HardWarningException &) {
+    exceptionCleanup ();
   }
 }
 
-void MainWindow::compileEnded()
-{
-  clearCurrentOutput();
-  GuiLocker::unlock();
-  if (designActionAutoReload->isChecked()) autoReloadTimer->start();
+void MainWindow::compileEnded () {
+  clearCurrentOutput ();
+  GuiLocker::unlock ();
+  if (designActionAutoReload->isChecked ())
+    autoReloadTimer->start ();
 #ifdef ENABLE_GUI_TESTS
-  emit compilationDone(this->rootFile);
+  emit compilationDone (this->rootFile);
 #endif
 }
 
 #ifdef ENABLE_GUI_TESTS
-std::shared_ptr<AbstractNode> MainWindow::instantiateRootFromSource(SourceFile *file)
-{
-  EvaluationSession session{file->getFullpath()};
-  ContextHandle<BuiltinContext> builtin_context{Context::create<BuiltinContext>(&session)};
-  setRenderVariables(builtin_context);
+std::shared_ptr<AbstractNode> MainWindow::instantiateRootFromSource (SourceFile *file) {
+  EvaluationSession session{file->getFullpath ()};
+  ContextHandle<BuiltinContext> builtin_context{Context::create<BuiltinContext> (&session)};
+  setRenderVariables (builtin_context);
 
   std::shared_ptr<const FileContext> file_context;
-  std::shared_ptr<AbstractNode> node = this->rootFile->instantiate(*builtin_context, &file_context);
+  std::shared_ptr<AbstractNode> node = this->rootFile->instantiate (*builtin_context, &file_context);
 
   return node;
 }
 #endif // ifdef ENABLE_GUI_TESTS
 
-void MainWindow::instantiateRoot()
-{
+void MainWindow::instantiateRoot () {
   // Go on and instantiate root_node, then call the continuation slot
 
   // Invalidate renderers before we kill the CSG tree
-  this->qglview->setRenderer(nullptr);
+  this->qglview->setRenderer (nullptr);
 #ifdef ENABLE_OPENCSG
   this->previewRenderer = nullptr;
 #endif
   this->thrownTogetherRenderer = nullptr;
 
   // Remove previous CSG tree
-  this->absoluteRootNode.reset();
+  this->absoluteRootNode.reset ();
 
-  this->csgRoot.reset();
-  this->normalizedRoot.reset();
-  this->rootProduct.reset();
+  this->csgRoot.reset ();
+  this->normalizedRoot.reset ();
+  this->rootProduct.reset ();
 
-  this->rootNode.reset();
-  this->tree.setRoot(nullptr);
+  this->rootNode.reset ();
+  this->tree.setRoot (nullptr);
 
-  const std::filesystem::path doc(activeEditor->filepath.toStdString());
-  this->tree.setDocumentPath(doc.parent_path().string());
+  const std::filesystem::path doc (activeEditor->filepath.toStdString ());
+  this->tree.setDocumentPath (doc.parent_path ().string ());
 
   renderedEditor = activeEditor;
 
   if (this->rootFile) {
     // Evaluate CSG tree
-    LOG("Compiling design (CSG Tree generation)...");
-    this->processEvents();
+    LOG ("Compiling design (CSG Tree generation)...");
+    this->processEvents ();
 
-    AbstractNode::resetIndexCounter();
+    AbstractNode::resetIndexCounter ();
 
-    EvaluationSession session{doc.parent_path().string()};
-    ContextHandle<BuiltinContext> builtin_context{Context::create<BuiltinContext>(&session)};
-    setRenderVariables(builtin_context);
+    EvaluationSession session{doc.parent_path ().string ()};
+    ContextHandle<BuiltinContext> builtin_context{Context::create<BuiltinContext> (&session)};
+    setRenderVariables (builtin_context);
 
     std::shared_ptr<const FileContext> file_context;
 #ifdef ENABLE_PYTHON
-    if (python_result_node != NULL && this->python_active) this->absoluteRootNode = python_result_node;
+    if (python_result_node != NULL && this->python_active)
+      this->absoluteRootNode = python_result_node;
     else
 #endif
-    this->absoluteRootNode = this->rootFile->instantiate(*builtin_context, &file_context);
+      this->absoluteRootNode = this->rootFile->instantiate (*builtin_context, &file_context);
     if (file_context) {
-      this->qglview->cam.updateView(file_context, false);
-      viewportControlWidget->cameraChanged();
+      this->qglview->cam.updateView (file_context, false);
+      viewportControlWidget->cameraChanged ();
     }
 
     if (this->absoluteRootNode) {
       // Do we have an explicit root node (! modifier)?
       const Location *nextLocation = nullptr;
-      if (!(this->rootNode = find_root_tag(this->absoluteRootNode, &nextLocation))) {
+      if (!(this->rootNode = find_root_tag (this->absoluteRootNode, &nextLocation))) {
         this->rootNode = this->absoluteRootNode;
       }
       if (nextLocation) {
-        LOG(message_group::NONE, *nextLocation, builtin_context->documentRoot(), "More than one Root Modifier (!)");
+        LOG (message_group::NONE, *nextLocation, builtin_context->documentRoot (), "More than one Root Modifier (!)");
       }
 
       // FIXME: Consider giving away ownership of root_node to the Tree, or use reference counted pointers
-      this->tree.setRoot(this->rootNode);
+      this->tree.setRoot (this->rootNode);
     }
   }
 
   if (!this->rootNode) {
     if (parser_error_pos < 0) {
-      LOG(message_group::Error, "Compilation failed! (no top level object found)");
+      LOG (message_group::Error, "Compilation failed! (no top level object found)");
     } else {
-      LOG(message_group::Error, "Compilation failed!");
+      LOG (message_group::Error, "Compilation failed!");
     }
-    LOG(" ");
-    this->processEvents();
+    LOG (" ");
+    this->processEvents ();
   }
 }
 
@@ -1410,191 +1391,185 @@ void MainWindow::instantiateRoot()
    Generates CSG tree for OpenCSG evaluation.
    Assumes that the design has been parsed and evaluated (this->root_node is set)
  */
-void MainWindow::compileCSG()
-{
-  OpenSCAD::hardwarnings = GlobalPreferences::inst()->getValue("advanced/enableHardwarnings").toBool();
-  try{
-    assert(this->rootNode);
-    LOG("Compiling design (CSG Products generation)...");
-    this->processEvents();
+void MainWindow::compileCSG () {
+  OpenSCAD::hardwarnings = GlobalPreferences::inst ()->getValue ("advanced/enableHardwarnings").toBool ();
+  try {
+    assert (this->rootNode);
+    LOG ("Compiling design (CSG Products generation)...");
+    this->processEvents ();
 
     // Main CSG evaluation
-    this->progresswidget = new ProgressWidget(this);
-    connect(this->progresswidget, &ProgressWidget::requestShow, this, &MainWindow::showProgress);
+    this->progresswidget = new ProgressWidget (this);
+    connect (this->progresswidget, &ProgressWidget::requestShow, this, &MainWindow::showProgress);
 
-    GeometryEvaluator geomevaluator(this->tree);
+    GeometryEvaluator geomevaluator (this->tree);
 #ifdef ENABLE_OPENCSG
-    CSGTreeEvaluator csgrenderer(this->tree, &geomevaluator);
+    CSGTreeEvaluator csgrenderer (this->tree, &geomevaluator);
 #endif
 
-    if (!isClosing) progress_report_prep(this->rootNode, report_func, this);
-    else return;
+    if (!isClosing)
+      progress_report_prep (this->rootNode, report_func, this);
+    else
+      return;
     try {
 #ifdef ENABLE_OPENCSG
-      this->processEvents();
-      this->csgRoot = csgrenderer.buildCSGTree(*rootNode);
+      this->processEvents ();
+      this->csgRoot = csgrenderer.buildCSGTree (*rootNode);
 #endif
-      renderStatistic.printCacheStatistic();
-      this->processEvents();
-    } catch (const ProgressCancelException&) {
-      LOG("CSG generation cancelled.");
-    } catch (const HardWarningException&) {
-      LOG("CSG generation cancelled due to hardwarning being enabled.");
+      renderStatistic.printCacheStatistic ();
+      this->processEvents ();
+    } catch (const ProgressCancelException &) {
+      LOG ("CSG generation cancelled.");
+    } catch (const HardWarningException &) {
+      LOG ("CSG generation cancelled due to hardwarning being enabled.");
     }
-    progress_report_fin();
-    updateStatusBar(nullptr);
+    progress_report_fin ();
+    updateStatusBar (nullptr);
 
-    LOG("Compiling design (CSG Products normalization)...");
-    this->processEvents();
+    LOG ("Compiling design (CSG Products normalization)...");
+    this->processEvents ();
 
-    const size_t normalizelimit = 2ul * GlobalPreferences::inst()->getValue("advanced/openCSGLimit").toUInt();
-    CSGTreeNormalizer normalizer(normalizelimit);
+    const size_t normalizelimit = 2ul * GlobalPreferences::inst ()->getValue ("advanced/openCSGLimit").toUInt ();
+    CSGTreeNormalizer normalizer (normalizelimit);
 
     if (this->csgRoot) {
-      this->normalizedRoot = normalizer.normalize(this->csgRoot);
+      this->normalizedRoot = normalizer.normalize (this->csgRoot);
       if (this->normalizedRoot) {
-        this->rootProduct = std::make_shared<CSGProducts>();
-        this->rootProduct->import(this->normalizedRoot);
+        this->rootProduct = std::make_shared<CSGProducts> ();
+        this->rootProduct->import (this->normalizedRoot);
       } else {
-        this->rootProduct.reset();
-        LOG(message_group::Warning, "CSG normalization resulted in an empty tree");
-        this->processEvents();
+        this->rootProduct.reset ();
+        LOG (message_group::Warning, "CSG normalization resulted in an empty tree");
+        this->processEvents ();
       }
     }
 
-    const std::vector<std::shared_ptr<CSGNode>>& highlight_terms = csgrenderer.getHighlightNodes();
-    if (highlight_terms.size() > 0) {
-      LOG("Compiling highlights (%1$d CSG Trees)...", highlight_terms.size());
-      this->processEvents();
+    const std::vector<std::shared_ptr<CSGNode>> &highlight_terms = csgrenderer.getHighlightNodes ();
+    if (highlight_terms.size () > 0) {
+      LOG ("Compiling highlights (%1$d CSG Trees)...", highlight_terms.size ());
+      this->processEvents ();
 
-      this->highlightsProducts = std::make_shared<CSGProducts>();
-      for (const auto& highlight_term : highlight_terms) {
-        auto nterm = normalizer.normalize(highlight_term);
+      this->highlightsProducts = std::make_shared<CSGProducts> ();
+      for (const auto &highlight_term : highlight_terms) {
+        auto nterm = normalizer.normalize (highlight_term);
         if (nterm) {
-          this->highlightsProducts->import(nterm);
+          this->highlightsProducts->import (nterm);
         }
       }
     } else {
-      this->highlightsProducts.reset();
+      this->highlightsProducts.reset ();
     }
 
-    const auto& background_terms = csgrenderer.getBackgroundNodes();
-    if (background_terms.size() > 0) {
-      LOG("Compiling background (%1$d CSG Trees)...", background_terms.size());
-      this->processEvents();
+    const auto &background_terms = csgrenderer.getBackgroundNodes ();
+    if (background_terms.size () > 0) {
+      LOG ("Compiling background (%1$d CSG Trees)...", background_terms.size ());
+      this->processEvents ();
 
-      this->backgroundProducts = std::make_shared<CSGProducts>();
-      for (const auto& background_term : background_terms) {
-        auto nterm = normalizer.normalize(background_term);
+      this->backgroundProducts = std::make_shared<CSGProducts> ();
+      for (const auto &background_term : background_terms) {
+        auto nterm = normalizer.normalize (background_term);
         if (nterm) {
-          this->backgroundProducts->import(nterm);
+          this->backgroundProducts->import (nterm);
         }
       }
     } else {
-      this->backgroundProducts.reset();
+      this->backgroundProducts.reset ();
     }
 
     if (this->rootProduct &&
-        (this->rootProduct->size() >
-         GlobalPreferences::inst()->getValue("advanced/openCSGLimit").toUInt())) {
-      LOG(message_group::UI_Warning, "Normalized tree has %1$d elements!", this->rootProduct->size());
-      LOG(message_group::UI_Warning, "OpenCSG rendering has been disabled.");
+        (this->rootProduct->size () >
+         GlobalPreferences::inst ()->getValue ("advanced/openCSGLimit").toUInt ())) {
+      LOG (message_group::UI_Warning, "Normalized tree has %1$d elements!", this->rootProduct->size ());
+      LOG (message_group::UI_Warning, "OpenCSG rendering has been disabled.");
     }
 #ifdef ENABLE_OPENCSG
     else {
-      LOG("Normalized tree has %1$d elements!",
-          (this->rootProduct ? this->rootProduct->size() : 0));
-      this->previewRenderer = std::make_shared<OpenCSGRenderer>(this->rootProduct,
-                                                                this->highlightsProducts,
-                                                                this->backgroundProducts);
+      LOG ("Normalized tree has %1$d elements!",
+           (this->rootProduct ? this->rootProduct->size () : 0));
+      this->previewRenderer = std::make_shared<OpenCSGRenderer> (this->rootProduct,
+                                                                 this->highlightsProducts,
+                                                                 this->backgroundProducts);
     }
 #endif // ifdef ENABLE_OPENCSG
-    this->thrownTogetherRenderer = std::make_shared<ThrownTogetherRenderer>(this->rootProduct,
-                                                                            this->highlightsProducts,
-                                                                            this->backgroundProducts);
-    LOG("Compile and preview finished.");
-    renderStatistic.printRenderingTime();
-    this->processEvents();
-  } catch (const HardWarningException&) {
-    exceptionCleanup();
-  }
-}
-
-void MainWindow::actionOpen()
-{
-  auto fileInfoList = UIUtils::openFiles(this);
-  for (auto& i : fileInfoList) {
-    if (!i.exists()) {
+    this->thrownTogetherRenderer = std::make_shared<ThrownTogetherRenderer> (this->rootProduct,
+                                                                             this->highlightsProducts,
+                                                                             this->backgroundProducts);
+    LOG ("Compile and preview finished.");
+    renderStatistic.printRenderingTime ();
+    this->processEvents ();
+  } catch (const HardWarningException &) {
+    exceptionCleanup ();
+  }
+}
+
+void MainWindow::actionOpen () {
+  auto fileInfoList = UIUtils::openFiles (this);
+  for (auto &i : fileInfoList) {
+    if (!i.exists ()) {
       return;
     }
-    tabManager->open(i.filePath());
+    tabManager->open (i.filePath ());
   }
 }
 
-void MainWindow::actionNewWindow()
-{
-  new MainWindow(QStringList());
+void MainWindow::actionNewWindow () {
+  new MainWindow (QStringList ());
 }
 
-void MainWindow::actionOpenWindow()
-{
-  auto fileInfoList = UIUtils::openFiles(this);
-  for (auto& i : fileInfoList) {
-    if (!i.exists()) {
+void MainWindow::actionOpenWindow () {
+  auto fileInfoList = UIUtils::openFiles (this);
+  for (auto &i : fileInfoList) {
+    if (!i.exists ()) {
       return;
     }
-    new MainWindow(QStringList(i.filePath()));
+    new MainWindow (QStringList (i.filePath ()));
   }
 }
 
-void MainWindow::actionOpenRecent()
-{
-  auto action = qobject_cast<QAction *>(sender());
-  tabManager->open(action->data().toString());
+void MainWindow::actionOpenRecent () {
+  auto action = qobject_cast<QAction *> (sender ());
+  tabManager->open (action->data ().toString ());
 }
 
-void MainWindow::clearRecentFiles()
-{
-  QSettingsCached settings;   // already set up properly via main.cpp
+void MainWindow::clearRecentFiles () {
+  QSettingsCached settings; // already set up properly via main.cpp
   const QStringList files;
-  settings.setValue("recentFileList", files);
+  settings.setValue ("recentFileList", files);
 
-  updateRecentFileActions();
+  updateRecentFileActions ();
 }
 
 // Updates the content of the recent files menu entries
 // by iterating over the recently opened files.
-void MainWindow::updateRecentFileActions()
-{
-  auto files = UIUtils::recentFiles();
+void MainWindow::updateRecentFileActions () {
+  auto files = UIUtils::recentFiles ();
 
-  for (int i = 0; i < files.size(); ++i) {
-    this->actionRecentFile[i]->setText(QFileInfo(files[i]).fileName().replace("&", "&&"));
-    this->actionRecentFile[i]->setData(files[i]);
-    this->actionRecentFile[i]->setVisible(true);
+  for (int i = 0; i < files.size (); ++i) {
+    this->actionRecentFile[i]->setText (QFileInfo (files[i]).fileName ().replace ("&", "&&"));
+    this->actionRecentFile[i]->setData (files[i]);
+    this->actionRecentFile[i]->setVisible (true);
   }
-  for (int i = files.size(); i < UIUtils::maxRecentFiles; ++i) {
-    this->actionRecentFile[i]->setVisible(false);
+  for (int i = files.size (); i < UIUtils::maxRecentFiles; ++i) {
+    this->actionRecentFile[i]->setVisible (false);
   }
 }
 
-void MainWindow::show_examples()
-{
+void MainWindow::show_examples () {
   bool found_example = false;
 
-  for (const auto& cat : UIUtils::exampleCategories()) {
-    auto examples = UIUtils::exampleFiles(cat.name);
-    auto menu = this->menuExamples->addMenu(gettext(cat.name.toStdString().c_str()));
-    if (!cat.tooltip.trimmed().isEmpty()) {
-      menu->setToolTip(gettext(cat.tooltip.toStdString().c_str()));
-      menu->setToolTipsVisible(true);
+  for (const auto &cat : UIUtils::exampleCategories ()) {
+    auto examples = UIUtils::exampleFiles (cat.name);
+    auto menu = this->menuExamples->addMenu (gettext (cat.name.toStdString ().c_str ()));
+    if (!cat.tooltip.trimmed ().isEmpty ()) {
+      menu->setToolTip (gettext (cat.tooltip.toStdString ().c_str ()));
+      menu->setToolTipsVisible (true);
     }
 
-    for (const auto& ex : examples) {
-      auto openAct = new QAction(ex.fileName().replace("&", "&&"), this);
-      connect(openAct, &QAction::triggered, this, &MainWindow::actionOpenExample);
-      menu->addAction(openAct);
-      openAct->setData(ex.canonicalFilePath());
+    for (const auto &ex : examples) {
+      auto openAct = new QAction (ex.fileName ().replace ("&", "&&"), this);
+      connect (openAct, &QAction::triggered, this, &MainWindow::actionOpenExample);
+      menu->addAction (openAct);
+      openAct->setData (ex.canonicalFilePath ());
       found_example = true;
     }
   }
@@ -1605,44 +1580,42 @@ void MainWindow::show_examples()
   }
 }
 
-void MainWindow::actionOpenExample()
-{
-  const auto action = qobject_cast<QAction *>(sender());
+void MainWindow::actionOpenExample () {
+  const auto action = qobject_cast<QAction *> (sender ());
   if (action) {
-    const auto& path = action->data().toString();
-    tabManager->open(path);
+    const auto &path = action->data ().toString ();
+    tabManager->open (path);
   }
 }
 
-void MainWindow::writeBackup(QFile *file)
-{
+void MainWindow::writeBackup (QFile *file) {
   // see MainWindow::saveBackup()
-  file->resize(0);
-  QTextStream writer(file);
+  file->resize (0);
+  QTextStream writer (file);
 #if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
-  writer.setCodec("UTF-8");
+  writer.setCodec ("UTF-8");
 #endif
-  writer << activeEditor->toPlainText();
-  this->activeEditor->parameterWidget->saveBackupFile(file->fileName());
+  writer << activeEditor->toPlainText ();
+  this->activeEditor->parameterWidget->saveBackupFile (file->fileName ());
 
-  LOG("Saved backup file: %1$s", file->fileName().toUtf8().constData());
+  LOG ("Saved backup file: %1$s", file->fileName ().toUtf8 ().constData ());
 }
 
-void MainWindow::saveBackup()
-{
-  auto path = PlatformUtils::backupPath();
-  if ((!fs::exists(path)) && (!PlatformUtils::createBackupPath())) {
-    LOG(message_group::UI_Warning, "Cannot create backup path: %1$s", path);
+void MainWindow::saveBackup () {
+  auto path = PlatformUtils::backupPath ();
+  if ((!fs::exists (path)) && (!PlatformUtils::createBackupPath ())) {
+    LOG (message_group::UI_Warning, "Cannot create backup path: %1$s", path);
     return;
   }
 
-  auto backupPath = QString::fromLocal8Bit(path.c_str());
-  if (!backupPath.endsWith("/")) backupPath.append("/");
+  auto backupPath = QString::fromLocal8Bit (path.c_str ());
+  if (!backupPath.endsWith ("/"))
+    backupPath.append ("/");
 
   QString basename = "unsaved";
-  if (!activeEditor->filepath.isEmpty()) {
-    auto fileInfo = QFileInfo(activeEditor->filepath);
-    basename = fileInfo.baseName();
+  if (!activeEditor->filepath.isEmpty ()) {
+    auto fileInfo = QFileInfo (activeEditor->filepath);
+    basename = fileInfo.baseName ();
   }
 
   if (!this->tempFile) {
@@ -1651,255 +1624,232 @@ void MainWindow::saveBackup()
 #else
     const QString suffix = "scad";
 #endif
-    this->tempFile = new QTemporaryFile(backupPath.append(basename + "-backup-XXXXXXXX." + suffix));
+    this->tempFile = new QTemporaryFile (backupPath.append (basename + "-backup-XXXXXXXX." + suffix));
   }
 
-  if ((!this->tempFile->isOpen()) && (!this->tempFile->open())) {
-    LOG(message_group::UI_Warning, "Failed to create backup file");
+  if ((!this->tempFile->isOpen ()) && (!this->tempFile->open ())) {
+    LOG (message_group::UI_Warning, "Failed to create backup file");
     return;
   }
-  return writeBackup(this->tempFile);
+  return writeBackup (this->tempFile);
 }
 
-void MainWindow::actionSave()
-{
-  tabManager->save(activeEditor);
+void MainWindow::actionSave () {
+  tabManager->save (activeEditor);
 }
 
-void MainWindow::actionSaveAs()
-{
-  tabManager->saveAs(activeEditor);
+void MainWindow::actionSaveAs () {
+  tabManager->saveAs (activeEditor);
 }
 
-void MainWindow::actionPythonRevokeTrustedFiles()
-{
+void MainWindow::actionPythonRevokeTrustedFiles () {
   QSettingsCached settings;
 #ifdef ENABLE_PYTHON
   python_trusted = false;
   this->trusted_edit_document_name = "";
 #endif
-  settings.remove("python_hash");
-  QMessageBox::information(this, _("Trusted Files"), "All trusted python files revoked", QMessageBox::Ok);
+  settings.remove ("python_hash");
+  QMessageBox::information (this, _ ("Trusted Files"), "All trusted python files revoked", QMessageBox::Ok);
 }
 
-void MainWindow::actionPythonCreateVenv()
-{
+void MainWindow::actionPythonCreateVenv () {
 #ifdef ENABLE_PYTHON
-  const QString selectedDir = QFileDialog::getExistingDirectory(this, "Create Virtual Environment");
-  if (selectedDir.isEmpty()) {
+  const QString selectedDir = QFileDialog::getExistingDirectory (this, "Create Virtual Environment");
+  if (selectedDir.isEmpty ()) {
     return;
   }
 
   const QDir venvDir{selectedDir};
-  if (!venvDir.exists()) {
+  if (!venvDir.exists ()) {
     // Should not happen, but just in case double check...
-    QMessageBox::critical(this, _("Create Virtual Environment"),
-                          "Directory does not exist. Can't create virtual environment.",
-                          QMessageBox::Ok);
+    QMessageBox::critical (this, _ ("Create Virtual Environment"),
+                           "Directory does not exist. Can't create virtual environment.",
+                           QMessageBox::Ok);
     return;
   }
 
-  if (!venvDir.isEmpty()) {
-    QMessageBox::critical(this, _("Create Virtual Environment"),
-                          "Directory is not empty. Can't create virtual environment.",
-                          QMessageBox::Ok);
+  if (!venvDir.isEmpty ()) {
+    QMessageBox::critical (this, _ ("Create Virtual Environment"),
+                           "Directory is not empty. Can't create virtual environment.",
+                           QMessageBox::Ok);
     return;
   }
 
-  const auto& path = venvDir.absolutePath().toStdString();
-  LOG("Creating Python virtual environment in '%1$s'...", path);
-  int result = pythonCreateVenv(path);
+  const auto &path = venvDir.absolutePath ().toStdString ();
+  LOG ("Creating Python virtual environment in '%1$s'...", path);
+  int result = pythonCreateVenv (path);
 
   if (result == 0) {
-    Settings::SettingsPython::pythonVirtualEnv.setValue(path);
-    Settings::Settings::visit(SettingsWriter());
-    LOG("Python virtual environment creation successfull.");
-    QMessageBox::information(this, _("Create Virtual Environment"),
-                             "Virtual environment created, please restart OpenSCAD to activate.",
-                             QMessageBox::Ok);
+    Settings::SettingsPython::pythonVirtualEnv.setValue (path);
+    Settings::Settings::visit (SettingsWriter ());
+    LOG ("Python virtual environment creation successfull.");
+    QMessageBox::information (this, _ ("Create Virtual Environment"),
+                              "Virtual environment created, please restart OpenSCAD to activate.",
+                              QMessageBox::Ok);
   } else {
-    LOG("Python virtual environment creation failed.");
-    QMessageBox::critical(this, _("Create Virtual Environment"),
-                          "Virtual environment creation failed.",
-                          QMessageBox::Ok);
+    LOG ("Python virtual environment creation failed.");
+    QMessageBox::critical (this, _ ("Create Virtual Environment"),
+                           "Virtual environment creation failed.",
+                           QMessageBox::Ok);
   }
 #endif // ifdef ENABLE_PYTHON
 }
 
-void MainWindow::actionPythonSelectVenv()
-{
+void MainWindow::actionPythonSelectVenv () {
 #ifdef ENABLE_PYTHON
-  const QString venvDir = QFileDialog::getExistingDirectory(this, "Select Virtual Environment");
-  if (venvDir.isEmpty()) {
+  const QString venvDir = QFileDialog::getExistingDirectory (this, "Select Virtual Environment");
+  if (venvDir.isEmpty ()) {
     return;
   }
   const QFileInfo fileInfo{QDir{venvDir}, "pyvenv.cfg"};
-  if (fileInfo.exists()) {
-    Settings::SettingsPython::pythonVirtualEnv.setValue(venvDir.toStdString());
-    Settings::Settings::visit(SettingsWriter());
-    QMessageBox::information(this, _("Select Virtual Environment"),
-                             "Virtual environment selected, please restart OpenSCAD to activate.",
-                             QMessageBox::Ok);
+  if (fileInfo.exists ()) {
+    Settings::SettingsPython::pythonVirtualEnv.setValue (venvDir.toStdString ());
+    Settings::Settings::visit (SettingsWriter ());
+    QMessageBox::information (this, _ ("Select Virtual Environment"),
+                              "Virtual environment selected, please restart OpenSCAD to activate.",
+                              QMessageBox::Ok);
   }
 #endif // ifdef ENABLE_PYTHON
 }
 
-void MainWindow::actionSaveACopy()
-{
-  tabManager->saveACopy(activeEditor);
+void MainWindow::actionSaveACopy () {
+  tabManager->saveACopy (activeEditor);
 }
 
-void MainWindow::actionShowLibraryFolder()
-{
-  auto path = PlatformUtils::userLibraryPath();
-  if (!fs::exists(path)) {
-    LOG(message_group::UI_Warning, "Library path %1$s doesn't exist. Creating", path);
-    if (!PlatformUtils::createUserLibraryPath()) {
-      LOG(message_group::UI_Error, "Cannot create library path: %1$s", path);
+void MainWindow::actionShowLibraryFolder () {
+  auto path = PlatformUtils::userLibraryPath ();
+  if (!fs::exists (path)) {
+    LOG (message_group::UI_Warning, "Library path %1$s doesn't exist. Creating", path);
+    if (!PlatformUtils::createUserLibraryPath ()) {
+      LOG (message_group::UI_Error, "Cannot create library path: %1$s", path);
     }
   }
-  auto url = QString::fromStdString(path);
-  LOG("Opening file browser for %1$s", url.toStdString());
-  QDesktopServices::openUrl(QUrl::fromLocalFile(url));
+  auto url = QString::fromStdString (path);
+  LOG ("Opening file browser for %1$s", url.toStdString ());
+  QDesktopServices::openUrl (QUrl::fromLocalFile (url));
 }
 
-void MainWindow::actionReload()
-{
-  if (checkEditorModified()) {
-    fileChangedOnDisk();     // force cached autoReloadId to update
-    (void)tabManager->refreshDocument();     // ignore errors opening the file
+void MainWindow::actionReload () {
+  if (checkEditorModified ()) {
+    fileChangedOnDisk (); // force cached autoReloadId to update
+    (void)tabManager->refreshDocument (); // ignore errors opening the file
   }
 }
 
-void MainWindow::copyViewportTranslation()
-{
-  const auto vpt = qglview->cam.getVpt();
-  const QString txt = QString("[ %1, %2, %3 ]")
-    .arg(vpt.x(), 0, 'f', 2)
-    .arg(vpt.y(), 0, 'f', 2)
-    .arg(vpt.z(), 0, 'f', 2);
-  QApplication::clipboard()->setText(txt);
+void MainWindow::copyViewportTranslation () {
+  const auto vpt = qglview->cam.getVpt ();
+  const QString txt = QString ("[ %1, %2, %3 ]")
+                        .arg (vpt.x (), 0, 'f', 2)
+                        .arg (vpt.y (), 0, 'f', 2)
+                        .arg (vpt.z (), 0, 'f', 2);
+  QApplication::clipboard ()->setText (txt);
 }
 
-void MainWindow::copyViewportRotation()
-{
-  const auto vpr = qglview->cam.getVpr();
-  const QString txt = QString("[ %1, %2, %3 ]")
-    .arg(vpr.x(), 0, 'f', 2)
-    .arg(vpr.y(), 0, 'f', 2)
-    .arg(vpr.z(), 0, 'f', 2);
-  QApplication::clipboard()->setText(txt);
+void MainWindow::copyViewportRotation () {
+  const auto vpr = qglview->cam.getVpr ();
+  const QString txt = QString ("[ %1, %2, %3 ]")
+                        .arg (vpr.x (), 0, 'f', 2)
+                        .arg (vpr.y (), 0, 'f', 2)
+                        .arg (vpr.z (), 0, 'f', 2);
+  QApplication::clipboard ()->setText (txt);
 }
 
-void MainWindow::copyViewportDistance()
-{
-  const QString txt = QString::number(qglview->cam.zoomValue(), 'f', 2);
-  QApplication::clipboard()->setText(txt);
+void MainWindow::copyViewportDistance () {
+  const QString txt = QString::number (qglview->cam.zoomValue (), 'f', 2);
+  QApplication::clipboard ()->setText (txt);
 }
 
-void MainWindow::copyViewportFov()
-{
-  const QString txt = QString::number(qglview->cam.fovValue(), 'f', 2);
-  QApplication::clipboard()->setText(txt);
+void MainWindow::copyViewportFov () {
+  const QString txt = QString::number (qglview->cam.fovValue (), 'f', 2);
+  QApplication::clipboard ()->setText (txt);
 }
 
-QList<double> MainWindow::getTranslation() const
-{
+QList<double> MainWindow::getTranslation () const {
   QList<double> ret;
-  ret.append(qglview->cam.object_trans.x());
-  ret.append(qglview->cam.object_trans.y());
-  ret.append(qglview->cam.object_trans.z());
+  ret.append (qglview->cam.object_trans.x ());
+  ret.append (qglview->cam.object_trans.y ());
+  ret.append (qglview->cam.object_trans.z ());
   return ret;
 }
 
-QList<double> MainWindow::getRotation() const
-{
+QList<double> MainWindow::getRotation () const {
   QList<double> ret;
-  ret.append(qglview->cam.object_rot.x());
-  ret.append(qglview->cam.object_rot.y());
-  ret.append(qglview->cam.object_rot.z());
+  ret.append (qglview->cam.object_rot.x ());
+  ret.append (qglview->cam.object_rot.y ());
+  ret.append (qglview->cam.object_rot.z ());
   return ret;
 }
 
-void MainWindow::hideFind()
-{
-  find_panel->hide();
+void MainWindow::hideFind () {
+  find_panel->hide ();
   activeEditor->findState = TabManager::FIND_HIDDEN;
-  editActionFindNext->setEnabled(false);
-  editActionFindPrevious->setEnabled(false);
-  this->findInputField->setFindCount(activeEditor->updateFindIndicators(this->findInputField->text(), false));
-  this->processEvents();
+  editActionFindNext->setEnabled (false);
+  editActionFindPrevious->setEnabled (false);
+  this->findInputField->setFindCount (activeEditor->updateFindIndicators (this->findInputField->text (), false));
+  this->processEvents ();
 }
 
 // Prepare the UI for the find (and replace if requested)
 // Among other thing it makes the text field and replacement field visible and well as it configures the
 // activeEditor to appropriate search mode.
-void MainWindow::showFind(bool doFindAndReplace)
-{
-  findInputField->setFindCount(activeEditor->updateFindIndicators(findInputField->text()));
-  processEvents();
-
-  if (doFindAndReplace){
-    findTypeComboBox->setCurrentIndex(1);
-    replaceInputField->show();
-    replaceButton->show();
-    replaceAllButton->show();
+void MainWindow::showFind (bool doFindAndReplace) {
+  findInputField->setFindCount (activeEditor->updateFindIndicators (findInputField->text ()));
+  processEvents ();
+
+  if (doFindAndReplace) {
+    findTypeComboBox->setCurrentIndex (1);
+    replaceInputField->show ();
+    replaceButton->show ();
+    replaceAllButton->show ();
     activeEditor->findState = TabManager::FIND_REPLACE_VISIBLE;
   } else {
-    findTypeComboBox->setCurrentIndex(0);
-    replaceInputField->hide();
-    replaceButton->hide();
-    replaceAllButton->hide();
+    findTypeComboBox->setCurrentIndex (0);
+    replaceInputField->hide ();
+    replaceButton->hide ();
+    replaceAllButton->hide ();
     activeEditor->findState = TabManager::FIND_VISIBLE;
   }
 
-  find_panel->show();
-  editActionFindNext->setEnabled(true);
-  editActionFindPrevious->setEnabled(true);
-  if (!activeEditor->selectedText().isEmpty()) {
-    findInputField->setText(activeEditor->selectedText());
+  find_panel->show ();
+  editActionFindNext->setEnabled (true);
+  editActionFindPrevious->setEnabled (true);
+  if (!activeEditor->selectedText ().isEmpty ()) {
+    findInputField->setText (activeEditor->selectedText ());
   }
-  findInputField->setFocus();
-  findInputField->selectAll();
+  findInputField->setFocus ();
+  findInputField->selectAll ();
 }
 
-void MainWindow::actionShowFind()
-{
-  showFind(false);
+void MainWindow::actionShowFind () {
+  showFind (false);
 }
 
-void MainWindow::findString(const QString& textToFind)
-{
-  this->findInputField->setFindCount(activeEditor->updateFindIndicators(textToFind));
-  this->processEvents();
-  activeEditor->find(textToFind);
+void MainWindow::findString (const QString &textToFind) {
+  this->findInputField->setFindCount (activeEditor->updateFindIndicators (textToFind));
+  this->processEvents ();
+  activeEditor->find (textToFind);
 }
 
-void MainWindow::actionShowFindAndReplace()
-{
-  showFind(true);
+void MainWindow::actionShowFindAndReplace () {
+  showFind (true);
 }
 
-void MainWindow::actionSelectFind(int type)
-{
+void MainWindow::actionSelectFind (int type) {
   // If type is one, then we shows the find and replace UI component
-  showFind(type == 1);
+  showFind (type == 1);
 }
 
-void MainWindow::replace()
-{
-  activeEditor->replaceSelectedText(this->replaceInputField->text());
-  activeEditor->find(this->findInputField->text());
+void MainWindow::replace () {
+  activeEditor->replaceSelectedText (this->replaceInputField->text ());
+  activeEditor->find (this->findInputField->text ());
 }
 
-void MainWindow::replaceAll()
-{
-  activeEditor->replaceAll(this->findInputField->text(), this->replaceInputField->text());
+void MainWindow::replaceAll () {
+  activeEditor->replaceAll (this->findInputField->text (), this->replaceInputField->text ());
 }
 
-void MainWindow::convertTabsToSpaces()
-{
-  const auto text = activeEditor->toPlainText();
+void MainWindow::convertTabsToSpaces () {
+  const auto text = activeEditor->toPlainText ();
 
   QString converted;
 
@@ -1907,109 +1857,102 @@ void MainWindow::convertTabsToSpaces()
   for (auto c : text) {
     if (c == '\t') {
       for (; cnt > 0; cnt--) {
-        converted.append(' ');
+        converted.append (' ');
       }
     } else {
-      converted.append(c);
+      converted.append (c);
     }
     if (cnt <= 0 || c == '\n') {
       cnt = 5;
     }
     cnt--;
   }
-  activeEditor->setText(converted);
+  activeEditor->setText (converted);
 }
 
-void MainWindow::findNext()
-{
-  activeEditor->find(this->findInputField->text(), true);
+void MainWindow::findNext () {
+  activeEditor->find (this->findInputField->text (), true);
 }
 
-void MainWindow::findPrev()
-{
-  activeEditor->find(this->findInputField->text(), true, true);
+void MainWindow::findPrev () {
+  activeEditor->find (this->findInputField->text (), true, true);
 }
 
-void MainWindow::useSelectionForFind()
-{
-  findInputField->setText(activeEditor->selectedText());
+void MainWindow::useSelectionForFind () {
+  findInputField->setText (activeEditor->selectedText ());
 }
 
-void MainWindow::updateFindBuffer(const QString& s)
-{
-  QApplication::clipboard()->setText(s, QClipboard::FindBuffer);
+void MainWindow::updateFindBuffer (const QString &s) {
+  QApplication::clipboard ()->setText (s, QClipboard::FindBuffer);
 }
 
-void MainWindow::findBufferChanged()
-{
-  auto t = QApplication::clipboard()->text(QClipboard::FindBuffer);
+void MainWindow::findBufferChanged () {
+  auto t = QApplication::clipboard ()->text (QClipboard::FindBuffer);
   // The convention seems to be to not update the search field if the findbuffer is empty
-  if (!t.isEmpty()) {
-    findInputField->setText(t);
+  if (!t.isEmpty ()) {
+    findInputField->setText (t);
   }
 }
 
-bool MainWindow::event(QEvent *event) {
-  if (event->type() == InputEvent::eventType) {
-    auto *inputEvent = dynamic_cast<InputEvent *>(event);
+bool MainWindow::event (QEvent *event) {
+  if (event->type () == InputEvent::eventType) {
+    auto *inputEvent = dynamic_cast<InputEvent *> (event);
     if (inputEvent) {
-      inputEvent->deliver(this);
+      inputEvent->deliver (this);
     }
-    event->accept();
+    event->accept ();
     return true;
   }
-  return QMainWindow::event(event);
+  return QMainWindow::event (event);
 }
 
-bool MainWindow::eventFilter(QObject *obj, QEvent *event)
-{
-  if (rubberBandManager.isVisible()) {
-    if (event->type() == QEvent::KeyRelease) {
-      auto keyEvent = static_cast<QKeyEvent *>(event);
-      if (keyEvent->key() == Qt::Key_Control) {
-        rubberBandManager.hide();
+bool MainWindow::eventFilter (QObject *obj, QEvent *event) {
+  if (rubberBandManager.isVisible ()) {
+    if (event->type () == QEvent::KeyRelease) {
+      auto keyEvent = static_cast<QKeyEvent *> (event);
+      if (keyEvent->key () == Qt::Key_Control) {
+        rubberBandManager.hide ();
       }
     }
   }
 
   if (obj == find_panel) {
-    if (event->type() == QEvent::KeyPress) {
-      auto keyEvent = static_cast<QKeyEvent *>(event);
-      if (keyEvent->key() == Qt::Key_Escape) {
-        this->hideFind();
+    if (event->type () == QEvent::KeyPress) {
+      auto keyEvent = static_cast<QKeyEvent *> (event);
+      if (keyEvent->key () == Qt::Key_Escape) {
+        this->hideFind ();
         return true;
       }
     }
     return false;
   }
 
-  return QMainWindow::eventFilter(obj, event);
+  return QMainWindow::eventFilter (obj, event);
 }
 
-void MainWindow::setRenderVariables(ContextHandle<BuiltinContext>& context)
-{
+void MainWindow::setRenderVariables (ContextHandle<BuiltinContext> &context) {
   const RenderVariables r = {
     .preview = this->isPreview,
-    .time = this->animateWidget->getAnimTval(),
+    .time = this->animateWidget->getAnimTval (),
     .camera = qglview->cam,
   };
-  r.applyToContext(context);
+  r.applyToContext (context);
 }
 
 /*!
    Returns true if the current document is a file on disk and that file has new content.
    Returns false if a file on disk has disappeared or if we haven't yet saved.
  */
-bool MainWindow::fileChangedOnDisk()
-{
-  if (!activeEditor->filepath.isEmpty()) {
+bool MainWindow::fileChangedOnDisk () {
+  if (!activeEditor->filepath.isEmpty ()) {
     struct stat st;
-    memset(&st, 0, sizeof(struct stat));
-    const bool valid = (stat(activeEditor->filepath.toLocal8Bit(), &st) == 0);
+    memset (&st, 0, sizeof (struct stat));
+    const bool valid = (stat (activeEditor->filepath.toLocal8Bit (), &st) == 0);
     // If file isn't there, just return and use current editor text
-    if (!valid) return false;
+    if (!valid)
+      return false;
 
-    auto newid = str(boost::format("%x.%x") % st.st_mtime % st.st_size);
+    auto newid = str (boost::format ("%x.%x") % st.st_mtime % st.st_size);
     if (newid != activeEditor->autoReloadId) {
       activeEditor->autoReloadId = newid;
       return true;
@@ -2023,35 +1966,37 @@ bool MainWindow::fileChangedOnDisk()
  */
 
 #ifdef ENABLE_PYTHON
-bool MainWindow::trust_python_file(const std::string& file,  const std::string& content) {
+bool MainWindow::trust_python_file (const std::string &file, const std::string &content) {
   QSettingsCached settings;
   char setting_key[256];
-  if (python_trusted) return true;
+  if (python_trusted)
+    return true;
 
   std::string act_hash, ref_hash;
-  snprintf(setting_key, sizeof(setting_key) - 1, "python_hash/%s", file.c_str());
-  act_hash = SHA256HashString(content);
+  snprintf (setting_key, sizeof (setting_key) - 1, "python_hash/%s", file.c_str ());
+  act_hash = SHA256HashString (content);
 
-  if (file == this->untrusted_edit_document_name) return false;
+  if (file == this->untrusted_edit_document_name)
+    return false;
 
   if (file == this->trusted_edit_document_name) {
-    settings.setValue(setting_key, act_hash.c_str());
+    settings.setValue (setting_key, act_hash.c_str ());
     return true;
   }
 
-  if (content.size() <= 1) {   // 1st character already typed
+  if (content.size () <= 1) { // 1st character already typed
     this->trusted_edit_document_name = file;
     return true;
   }
-  if (content.rfind("from openscad import", 0) == 0) {   // 1st character already typed
+  if (content.rfind ("from openscad import", 0) == 0) { // 1st character already typed
     this->trusted_edit_document_name = file;
     return true;
   }
 
-  if (settings.contains(setting_key)) {
-    QString str = settings.value(setting_key).toString();
-    QByteArray ba = str.toLocal8Bit();
-    ref_hash = std::string(ba.data());
+  if (settings.contains (setting_key)) {
+    QString str = settings.value (setting_key).toString ();
+    QByteArray ba = str.toLocal8Bit ();
+    ref_hash = std::string (ba.data ());
   }
 
   if (act_hash == ref_hash) {
@@ -2059,16 +2004,17 @@ bool MainWindow::trust_python_file(const std::string& file,  const std::string&
     return true;
   }
 
-  auto ret = QMessageBox::warning(this, "Application",
-                                  _("Python files can potentially contain harmful stuff.\n"
-                                    "Do you trust this file ?\n"), QMessageBox::Yes | QMessageBox::YesAll | QMessageBox::No);
+  auto ret = QMessageBox::warning (this, "Application",
+                                   _ ("Python files can potentially contain harmful stuff.\n"
+                                      "Do you trust this file ?\n"),
+                                   QMessageBox::Yes | QMessageBox::YesAll | QMessageBox::No);
   if (ret == QMessageBox::YesAll) {
     python_trusted = true;
     return true;
   }
   if (ret == QMessageBox::Yes) {
     this->trusted_edit_document_name = file;
-    settings.setValue(setting_key, act_hash.c_str());
+    settings.setValue (setting_key, act_hash.c_str ());
     return true;
   }
 
@@ -2080,107 +2026,102 @@ bool MainWindow::trust_python_file(const std::string& file,  const std::string&
 }
 #endif // ifdef ENABLE_PYTHON
 
+SourceFile *MainWindow::parseDocument (EditorInterface *editor) {
+  resetSuppressedMessages ();
 
-SourceFile *MainWindow::parseDocument(EditorInterface *editor)
-{
-  resetSuppressedMessages();
+  auto document = editor->toPlainText ();
+  auto fulltext = std::string (document.toUtf8 ().constData ()) + "\n\x03\n" + commandline_commands;
+  auto fnameba = editor->filepath.toLocal8Bit ();
 
-  auto document = editor->toPlainText();
-  auto fulltext = std::string(document.toUtf8().constData()) + "\n\x03\n" + commandline_commands;
-  auto fnameba = editor->filepath.toLocal8Bit();
-
-  const char *fname = editor->filepath.isEmpty() ? "" : fnameba.constData();
+  const char *fname = editor->filepath.isEmpty () ? "" : fnameba.constData ();
 #ifdef ENABLE_PYTHON
   this->python_active = false;
   if (fname != NULL) {
-    if (boost::algorithm::ends_with(fname, ".py")) {
-      std::string content = std::string(this->lastCompiledDoc.toUtf8().constData());
+    if (boost::algorithm::ends_with (fname, ".py")) {
+      std::string content = std::string (this->lastCompiledDoc.toUtf8 ().constData ());
       if (
-        Feature::ExperimentalPythonEngine.is_enabled()
-        && trust_python_file(std::string(fname), content)) this->python_active = true;
-      else LOG(message_group::Warning, Location::NONE, "", "Python is not enabled");
+        Feature::ExperimentalPythonEngine.is_enabled () && trust_python_file (std::string (fname), content))
+        this->python_active = true;
+      else
+        LOG (message_group::Warning, Location::NONE, "", "Python is not enabled");
     }
   }
 
   if (this->python_active) {
     auto fulltext_py =
-      std::string(this->lastCompiledDoc.toUtf8().constData());
+      std::string (this->lastCompiledDoc.toUtf8 ().constData ());
 
-    const auto& venv = venvBinDirFromSettings();
-    const auto& binDir = venv.empty() ? PlatformUtils::applicationPath() : venv;
-    initPython(binDir, this->animateWidget->getAnimTval());
+    const auto &venv = venvBinDirFromSettings ();
+    const auto &binDir = venv.empty () ? PlatformUtils::applicationPath () : venv;
+    initPython (binDir, this->animateWidget->getAnimTval ());
 
-    if (venv.empty()) {
-      LOG("Running %1$s without venv.", python_version());
+    if (venv.empty ()) {
+      LOG ("Running %1$s without venv.", python_version ());
     } else {
-      const auto& v = Settings::SettingsPython::pythonVirtualEnv.value();
-      LOG("Running %1$s in venv '%2$s'.", python_version(), v);
+      const auto &v = Settings::SettingsPython::pythonVirtualEnv.value ();
+      LOG ("Running %1$s in venv '%2$s'.", python_version (), v);
     }
-    auto error = evaluatePython(fulltext_py, false);
-    if (error.size() > 0) LOG(message_group::Error, Location::NONE, "", error.c_str());
+    auto error = evaluatePython (fulltext_py, false);
+    if (error.size () > 0)
+      LOG (message_group::Error, Location::NONE, "", error.c_str ());
     fulltext = "\n";
   }
 #endif // ifdef ENABLE_PYTHON
 
   SourceFile *sourceFile;
-  sourceFile = parse(sourceFile, fulltext, fname, fname, false) ? sourceFile : nullptr;
+  sourceFile = parse (sourceFile, fulltext, fname, fname, false) ? sourceFile : nullptr;
 
-  editor->resetHighlighting();
+  editor->resetHighlighting ();
   if (sourceFile) {
     //add parameters as annotation in AST
-    CommentParser::collectParameters(fulltext, sourceFile);
-    editor->parameterWidget->setParameters(sourceFile, fulltext);
-    editor->parameterWidget->applyParameters(sourceFile);
-    editor->parameterWidget->setEnabled(true);
-    editor->setIndicator(sourceFile->indicatorData);
+    CommentParser::collectParameters (fulltext, sourceFile);
+    editor->parameterWidget->setParameters (sourceFile, fulltext);
+    editor->parameterWidget->applyParameters (sourceFile);
+    editor->parameterWidget->setEnabled (true);
+    editor->setIndicator (sourceFile->indicatorData);
   } else {
-    editor->parameterWidget->setEnabled(false);
+    editor->parameterWidget->setEnabled (false);
   }
 
   return sourceFile;
 }
 
-void MainWindow::parseTopLevelDocument()
-{
-  resetSuppressedMessages();
+void MainWindow::parseTopLevelDocument () {
+  resetSuppressedMessages ();
 
-  this->lastCompiledDoc = activeEditor->toPlainText();
+  this->lastCompiledDoc = activeEditor->toPlainText ();
 
-  activeEditor->resetHighlighting();
-  this->rootFile = parseDocument(activeEditor);
+  activeEditor->resetHighlighting ();
+  this->rootFile = parseDocument (activeEditor);
   this->parsedFile = this->rootFile;
 }
 
-void MainWindow::changeParameterWidget()
-{
-  parameterDock->setVisible(true);
+void MainWindow::changeParameterWidget () {
+  parameterDock->setVisible (true);
 }
 
-void MainWindow::checkAutoReload()
-{
-  if (!activeEditor->filepath.isEmpty()) {
-    actionReloadRenderPreview();
+void MainWindow::checkAutoReload () {
+  if (!activeEditor->filepath.isEmpty ()) {
+    actionReloadRenderPreview ();
   }
 }
 
-void MainWindow::autoReloadSet(bool on)
-{
+void MainWindow::autoReloadSet (bool on) {
   QSettingsCached settings;
-  settings.setValue("design/autoReload", designActionAutoReload->isChecked());
+  settings.setValue ("design/autoReload", designActionAutoReload->isChecked ());
   if (on) {
-    autoReloadTimer->start(autoReloadPollingPeriodMS);
+    autoReloadTimer->start (autoReloadPollingPeriodMS);
   } else {
-    autoReloadTimer->stop();
+    autoReloadTimer->stop ();
   }
 }
 
-bool MainWindow::checkEditorModified()
-{
-  if (activeEditor->isContentModified()) {
-    auto ret = QMessageBox::warning(this, _("Application"),
-                                    _("The document has been modified.\n"
-                                      "Do you really want to reload the file?"),
-                                    QMessageBox::Yes | QMessageBox::No);
+bool MainWindow::checkEditorModified () {
+  if (activeEditor->isContentModified ()) {
+    auto ret = QMessageBox::warning (this, _ ("Application"),
+                                     _ ("The document has been modified.\n"
+                                        "Do you really want to reload the file?"),
+                                     QMessageBox::Yes | QMessageBox::No);
     if (ret != QMessageBox::Yes) {
       return false;
     }
@@ -2188,265 +2129,262 @@ bool MainWindow::checkEditorModified()
   return true;
 }
 
-void MainWindow::actionReloadRenderPreview()
-{
-  if (GuiLocker::isLocked()) return;
-  GuiLocker::lock();
-  autoReloadTimer->stop();
-  setCurrentOutput();
+void MainWindow::actionReloadRenderPreview () {
+  if (GuiLocker::isLocked ())
+    return;
+  GuiLocker::lock ();
+  autoReloadTimer->stop ();
+  setCurrentOutput ();
 
   this->afterCompileSlot = "csgReloadRender";
   this->procevents = true;
   this->isPreview = true;
-  compile(true);
+  compile (true);
 }
 
-void MainWindow::csgReloadRender()
-{
-  if (this->rootNode) compileCSG();
+void MainWindow::csgReloadRender () {
+  if (this->rootNode)
+    compileCSG ();
 
   // Go to non-CGAL view mode
-  if (viewActionThrownTogether->isChecked()) {
-    viewModeThrownTogether();
+  if (viewActionThrownTogether->isChecked ()) {
+    viewModeThrownTogether ();
   } else {
 #ifdef ENABLE_OPENCSG
-    viewModePreview();
+    viewModePreview ();
 #else
-    viewModeThrownTogether();
+    viewModeThrownTogether ();
 #endif
   }
-  compileEnded();
+  compileEnded ();
 }
 
-void MainWindow::prepareCompile(const char *afterCompileSlot, bool procevents, bool preview)
-{
-  autoReloadTimer->stop();
-  setCurrentOutput();
-  LOG(" ");
-  LOG("Parsing design (AST generation)...");
-  this->processEvents();
+void MainWindow::prepareCompile (const char *afterCompileSlot, bool procevents, bool preview) {
+  autoReloadTimer->stop ();
+  setCurrentOutput ();
+  LOG (" ");
+  LOG ("Parsing design (AST generation)...");
+  this->processEvents ();
   this->afterCompileSlot = afterCompileSlot;
   this->procevents = procevents;
   this->isPreview = preview;
 }
 
-void MainWindow::actionRenderPreview()
-{
+void MainWindow::actionRenderPreview () {
   static bool preview_requested;
   preview_requested = true;
 
-  if (GuiLocker::isLocked()) return;
+  if (GuiLocker::isLocked ())
+    return;
 
-  GuiLocker::lock();
+  GuiLocker::lock ();
   preview_requested = false;
 
-  this->designActionMeasureDist->setEnabled(false);
-  this->designActionMeasureAngle->setEnabled(false);
+  this->designActionMeasureDist->setEnabled (false);
+  this->designActionMeasureAngle->setEnabled (false);
 
-  prepareCompile("csgRender", !animateDock->isVisible(), true);
-  compile(false, false);
+  prepareCompile ("csgRender", !animateDock->isVisible (), true);
+  compile (false, false);
 
   if (preview_requested) {
     // if the action was called when the gui was locked, we must request it one more time
     // however, it's not possible to call it directly NOR make the loop
     // it must be called from the mainloop
-    QTimer::singleShot(0, this, &MainWindow::actionRenderPreview);
+    QTimer::singleShot (0, this, &MainWindow::actionRenderPreview);
     return;
   }
 }
 
-void MainWindow::csgRender()
-{
-  if (this->rootNode) compileCSG();
+void MainWindow::csgRender () {
+  if (this->rootNode)
+    compileCSG ();
 
   // Go to non-CGAL view mode
-  if (viewActionThrownTogether->isChecked()) {
-    viewModeThrownTogether();
+  if (viewActionThrownTogether->isChecked ()) {
+    viewModeThrownTogether ();
   } else {
 #ifdef ENABLE_OPENCSG
-    viewModePreview();
+    viewModePreview ();
 #else
-    viewModeThrownTogether();
+    viewModeThrownTogether ();
 #endif
   }
 
-  if (animateWidget->dumpPictures() ) {
-    const int steps = animateWidget->nextFrame();
-    const QImage img = this->qglview->grabFrame();
-    const QString filename = QString("frame%1.png").arg(steps, 5, 10, QChar('0'));
-    img.save(filename, "PNG");
+  if (animateWidget->dumpPictures ()) {
+    const int steps = animateWidget->nextFrame ();
+    const QImage img = this->qglview->grabFrame ();
+    const QString filename = QString ("frame%1.png").arg (steps, 5, 10, QChar ('0'));
+    img.save (filename, "PNG");
   }
 
-  compileEnded();
+  compileEnded ();
 }
 
-void MainWindow::sendToExternalTool(ExternalToolInterface& externalToolService)
-{
-  const QFileInfo activeFile(activeEditor->filepath);
-  QString activeFileName = activeFile.fileName();
-  if (activeFileName.isEmpty()) activeFileName = "Untitled.scad";
+void MainWindow::sendToExternalTool (ExternalToolInterface &externalToolService) {
+  const QFileInfo activeFile (activeEditor->filepath);
+  QString activeFileName = activeFile.fileName ();
+  if (activeFileName.isEmpty ())
+    activeFileName = "Untitled.scad";
   // TODO: Replace suffix to match exported file format?
 
-  activeFileName = activeFileName + QString::fromStdString("." + fileformat::toSuffix(externalToolService.fileFormat()));
+  activeFileName = activeFileName + QString::fromStdString ("." + fileformat::toSuffix (externalToolService.fileFormat ()));
 
-  const bool export_status = externalToolService.exportTemporaryFile(rootGeom, activeFileName, &qglview->cam);
+  const bool export_status = externalToolService.exportTemporaryFile (rootGeom, activeFileName, &qglview->cam);
   if (!export_status) {
     return;
   }
 
-  this->progresswidget = new ProgressWidget(this);
-  connect(this->progresswidget, &ProgressWidget::requestShow, this, &MainWindow::showProgress);
+  this->progresswidget = new ProgressWidget (this);
+  connect (this->progresswidget, &ProgressWidget::requestShow, this, &MainWindow::showProgress);
 
-  const bool process_status = externalToolService.process(activeFileName.toStdString(), [this](double permille) {
-    return network_progress_func(permille);
+  const bool process_status = externalToolService.process (activeFileName.toStdString (), [this] (double permille) {
+    return network_progress_func (permille);
   });
-  updateStatusBar(nullptr);
+  updateStatusBar (nullptr);
   if (!process_status) {
     return;
   }
 
-  const auto url = externalToolService.getURL();
-  if (!url.empty()) {
-    QDesktopServices::openUrl(QUrl{QString::fromStdString(url)});
+  const auto url = externalToolService.getURL ();
+  if (!url.empty ()) {
+    QDesktopServices::openUrl (QUrl{QString::fromStdString (url)});
   }
 }
 
-void MainWindow::action3DPrint()
-{
-  if (GuiLocker::isLocked()) return;
+void MainWindow::action3DPrint () {
+  if (GuiLocker::isLocked ())
+    return;
   const GuiLocker lock;
 
-  setCurrentOutput();
+  setCurrentOutput ();
 
   //Make sure we can export:
   const unsigned int dim = 3;
-  if (!canExport(dim)) return;
+  if (!canExport (dim))
+    return;
 
   PrintInitDialog printInitDialog;
-  const auto status = printInitDialog.exec();
+  const auto status = printInitDialog.exec ();
 
   if (status == QDialog::Accepted) {
-    const print_service_t serviceType = printInitDialog.getServiceType();
-    const QString serviceName = printInitDialog.getServiceName();
-    const FileFormat fileFormat = printInitDialog.getFileFormat();
+    const print_service_t serviceType = printInitDialog.getServiceType ();
+    const QString serviceName = printInitDialog.getServiceName ();
+    const FileFormat fileFormat = printInitDialog.getFileFormat ();
 
-    LOG("Selected File format: %1$s", fileformat::info(fileFormat).description);
+    LOG ("Selected File format: %1$s", fileformat::info (fileFormat).description);
 
-    GlobalPreferences::inst()->updateGUI();
-    const auto externalToolService = createExternalToolService(serviceType, serviceName, fileFormat);
+    GlobalPreferences::inst ()->updateGUI ();
+    const auto externalToolService = createExternalToolService (serviceType, serviceName, fileFormat);
     if (!externalToolService) {
-      LOG("Error: Unable to create service: %1$d %2$s %3$d", static_cast<int>(serviceType), serviceName.toStdString(), static_cast<int>(fileFormat));
+      LOG ("Error: Unable to create service: %1$d %2$s %3$d", static_cast<int> (serviceType), serviceName.toStdString (), static_cast<int> (fileFormat));
       return;
     }
-    sendToExternalTool(*externalToolService);
+    sendToExternalTool (*externalToolService);
   }
 }
 
-void MainWindow::actionRender()
-{
-  if (GuiLocker::isLocked()) return;
-  GuiLocker::lock();
+void MainWindow::actionRender () {
+  if (GuiLocker::isLocked ())
+    return;
+  GuiLocker::lock ();
 
-  prepareCompile("cgalRender", true, false);
-  compile(false);
+  prepareCompile ("cgalRender", true, false);
+  compile (false);
 }
 
-void MainWindow::cgalRender()
-{
+void MainWindow::cgalRender () {
   if (!this->rootFile || !this->rootNode) {
-    compileEnded();
+    compileEnded ();
     return;
   }
 
-  this->qglview->setRenderer(nullptr);
+  this->qglview->setRenderer (nullptr);
   this->geomRenderer = nullptr;
-  rootGeom.reset();
+  rootGeom.reset ();
 
-  LOG("Rendering Polygon Mesh using %1$s...",
-      renderBackend3DToString(RenderSettings::inst()->backend3D).c_str());
+  LOG ("Rendering Polygon Mesh using %1$s...",
+       renderBackend3DToString (RenderSettings::inst ()->backend3D).c_str ());
 
-  this->progresswidget = new ProgressWidget(this);
-  connect(this->progresswidget, &ProgressWidget::requestShow, this, &MainWindow::showProgress);
+  this->progresswidget = new ProgressWidget (this);
+  connect (this->progresswidget, &ProgressWidget::requestShow, this, &MainWindow::showProgress);
 
-  if (!isClosing) progress_report_prep(this->rootNode, report_func, this);
-  else return;
+  if (!isClosing)
+    progress_report_prep (this->rootNode, report_func, this);
+  else
+    return;
 
-  this->cgalworker->start(this->tree);
+  this->cgalworker->start (this->tree);
 }
 
-void MainWindow::actionRenderDone(const std::shared_ptr<const Geometry>& root_geom)
-{
+void MainWindow::actionRenderDone (const std::shared_ptr<const Geometry> &root_geom) {
 #ifdef ENABLE_PYTHON
-  python_lock();
+  python_lock ();
 #endif
-  progress_report_fin();
+  progress_report_fin ();
   if (root_geom) {
     std::vector<std::string> options;
-    if (Settings::Settings::summaryCamera.value()) {
-      options.emplace_back(RenderStatistic::CAMERA);
+    if (Settings::Settings::summaryCamera.value ()) {
+      options.emplace_back (RenderStatistic::CAMERA);
     }
-    if (Settings::Settings::summaryArea.value()) {
-      options.emplace_back(RenderStatistic::AREA);
+    if (Settings::Settings::summaryArea.value ()) {
+      options.emplace_back (RenderStatistic::AREA);
     }
-    if (Settings::Settings::summaryBoundingBox.value()) {
-      options.emplace_back(RenderStatistic::BOUNDING_BOX);
+    if (Settings::Settings::summaryBoundingBox.value ()) {
+      options.emplace_back (RenderStatistic::BOUNDING_BOX);
     }
-    renderStatistic.printAll(root_geom, qglview->cam, options);
-    LOG("Rendering finished.");
+    renderStatistic.printAll (root_geom, qglview->cam, options);
+    LOG ("Rendering finished.");
 
     this->rootGeom = root_geom;
     // Choose PolySetRenderer for PolySet and Polygon2d, and for Manifold since we
     // know that all geometries are convertible to PolySet.
-    if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend ||
-        std::dynamic_pointer_cast<const PolySet>(this->rootGeom) ||
-        std::dynamic_pointer_cast<const Polygon2d>(this->rootGeom)) {
-      this->geomRenderer = std::make_shared<PolySetRenderer>(this->rootGeom);
+    if (RenderSettings::inst ()->backend3D == RenderBackend3D::ManifoldBackend ||
+        std::dynamic_pointer_cast<const PolySet> (this->rootGeom) ||
+        std::dynamic_pointer_cast<const Polygon2d> (this->rootGeom)) {
+      this->geomRenderer = std::make_shared<PolySetRenderer> (this->rootGeom);
     } else {
-      this->geomRenderer = std::make_shared<CGALRenderer>(this->rootGeom);
+      this->geomRenderer = std::make_shared<CGALRenderer> (this->rootGeom);
     }
 
     // Go to CGAL view mode
-    viewModeRender();
-    this->designActionMeasureDist->setEnabled(true);
-    this->designActionMeasureAngle->setEnabled(true);
+    viewModeRender ();
+    this->designActionMeasureDist->setEnabled (true);
+    this->designActionMeasureAngle->setEnabled (true);
   } else {
-    this->designActionMeasureDist->setEnabled(false);
-    this->designActionMeasureAngle->setEnabled(false);
-    LOG(message_group::UI_Warning, "No top level geometry to render");
+    this->designActionMeasureDist->setEnabled (false);
+    this->designActionMeasureAngle->setEnabled (false);
+    LOG (message_group::UI_Warning, "No top level geometry to render");
   }
 
-  updateStatusBar(nullptr);
+  updateStatusBar (nullptr);
 
-  const bool renderSoundEnabled = GlobalPreferences::inst()->getValue("advanced/enableSoundNotification").toBool();
-  const uint soundThreshold = GlobalPreferences::inst()->getValue("advanced/timeThresholdOnRenderCompleteSound").toUInt();
-  if (renderSoundEnabled && soundThreshold <= renderStatistic.ms().count() / 1000) {
-    renderCompleteSoundEffect->play();
+  const bool renderSoundEnabled = GlobalPreferences::inst ()->getValue ("advanced/enableSoundNotification").toBool ();
+  const uint soundThreshold = GlobalPreferences::inst ()->getValue ("advanced/timeThresholdOnRenderCompleteSound").toUInt ();
+  if (renderSoundEnabled && soundThreshold <= renderStatistic.ms ().count () / 1000) {
+    renderCompleteSoundEffect->play ();
   }
 
   renderedEditor = activeEditor;
   activeEditor->contentsRendered = true;
-  compileEnded();
+  compileEnded ();
 }
 
-void MainWindow::actionMeasureDistance()
-{
-  meas.startMeasureDist();
+void MainWindow::actionMeasureDistance () {
+  meas.startMeasureDist ();
 }
 
-void MainWindow::actionMeasureAngle()
-{
-  meas.startMeasureAngle();
+void MainWindow::actionMeasureAngle () {
+  meas.startMeasureAngle ();
 }
 
-void MainWindow::leftClick(QPoint mouse)
-{
-  const QString str = meas.statemachine(mouse);
-  if (str.size() > 0) {
+void MainWindow::leftClick (QPoint mouse) {
+  const QString str = meas.statemachine (mouse);
+  if (str.size () > 0) {
     this->qglview->measure_state = MEASURE_IDLE;
-    QMenu resultmenu(this);
-    auto action = resultmenu.addAction(str);
-    connect(action, &QAction::triggered, this, &MainWindow::measureFinished);
-    resultmenu.exec(qglview->mapToGlobal(mouse));
+    QMenu resultmenu (this);
+    auto action = resultmenu.addAction (str);
+    connect (action, &QAction::triggered, this, &MainWindow::measureFinished);
+    resultmenu.exec (qglview->mapToGlobal (mouse));
   }
 }
 
@@ -2455,8 +2393,7 @@ void MainWindow::leftClick(QPoint mouse)
  * Use the generated ID and try to find it within the list of products
  * And finally move the cursor to the beginning of the selected object in the editor
  */
-void MainWindow::rightClick(QPoint position)
-{
+void MainWindow::rightClick (QPoint position) {
   // selecting without a renderer?!
   if (!this->qglview->renderer) {
     return;
@@ -2467,183 +2404,181 @@ void MainWindow::rightClick(QPoint position)
   }
 
   // Select the object at mouse coordinates
-  const int index = this->qglview->pickObject(position);
+  const int index = this->qglview->pickObject (position);
   std::deque<std::shared_ptr<const AbstractNode>> path;
-  const std::shared_ptr<const AbstractNode> result = this->rootNode->getNodeByID(index, path);
+  const std::shared_ptr<const AbstractNode> result = this->rootNode->getNodeByID (index, path);
 
   if (result) {
     // Create context menu with the backtrace
-    QMenu tracemenu(this);
+    QMenu tracemenu (this);
     std::stringstream ss;
-    for (auto& step : path) {
+    for (auto &step : path) {
       // Skip certain node types
-      if (step->name() == "root") {
+      if (step->name () == "root") {
         continue;
       }
-      auto location = step->modinst->location();
-      ss.str("");
+      auto location = step->modinst->location ();
+      ss.str ("");
 
       // Remove the "module" prefix if any as it induce confusion between the module declaration and instanciation
-      const int first_position = (step->verbose_name().find("module") == std::string::npos)? 0 : 7;
-      std::string name = step->verbose_name().substr(first_position);
+      const int first_position = (step->verbose_name ().find ("module") == std::string::npos) ? 0 : 7;
+      std::string name = step->verbose_name ().substr (first_position);
 
       // It happens that the verbose_name is empty (eg: in for loops), when this happens instead of letting
       // empty entry in the menu we prefer using the name in the modinstanciation.
-      if (step->verbose_name().empty()) name = step->modinst->name();
+      if (step->verbose_name ().empty ())
+        name = step->modinst->name ();
 
       // Check if the path is contained in a library (using parsersettings.h)
-      const fs::path libpath = get_library_for_path(location.filePath());
-      if (!libpath.empty()) {
+      const fs::path libpath = get_library_for_path (location.filePath ());
+      if (!libpath.empty ()) {
         // Display the library (without making the window too wide!)
         ss << name << " (library "
-           << location.fileName().substr(libpath.string().length() + 1) << ":"
-           << location.firstLine() << ")";
-      } else if (renderedEditor->filepath.toStdString() == location.fileName()) {
+           << location.fileName ().substr (libpath.string ().length () + 1) << ":"
+           << location.firstLine () << ")";
+      } else if (renderedEditor->filepath.toStdString () == location.fileName ()) {
         // removes the "module" prefix if any as it makes it not clear if it is module declaration or call.
-        ss << name << " (" << location.filePath().filename().string() << ":"
-           << location.firstLine() << ")";
+        ss << name << " (" << location.filePath ().filename ().string () << ":"
+           << location.firstLine () << ")";
       } else {
-        auto relative_filename = fs_uncomplete(location.filePath(), fs::path(renderedEditor->filepath.toStdString()).parent_path())
-          .generic_string();
+        auto relative_filename = fs_uncomplete (location.filePath (), fs::path (renderedEditor->filepath.toStdString ()).parent_path ())
+                                   .generic_string ();
 
         // Set the displayed name relative to the active editor window
-        ss << name << " (" << relative_filename << ":" << location.firstLine() << ")";
+        ss << name << " (" << relative_filename << ":" << location.firstLine () << ")";
       }
       // Prepare the action to be sent
-      auto action = tracemenu.addAction(QString::fromStdString(ss.str()));
-      if (editorDock->isVisible()) {
-        action->setProperty("id", step->idx);
-        connect(action, &QAction::hovered, this, &MainWindow::onHoveredObjectInSelectionMenu);
+      auto action = tracemenu.addAction (QString::fromStdString (ss.str ()));
+      if (editorDock->isVisible ()) {
+        action->setProperty ("id", step->idx);
+        connect (action, &QAction::hovered, this, &MainWindow::onHoveredObjectInSelectionMenu);
       }
     }
 
     // Before starting we need to lock the GUI to avoid interferance with reload/update
     // triggered by other part of the application (eg: changing the renderedEditor)
-    GuiLocker::lock();
+    GuiLocker::lock ();
 
     // Execute this lambda function when the selection menu is closing.
-    connect(&tracemenu, &QMenu::aboutToHide, [this](){
+    connect (&tracemenu, &QMenu::aboutToHide, [this] () {
       // remove the visual hints in the editor
-      renderedEditor->clearAllSelectionIndicators();
+      renderedEditor->clearAllSelectionIndicators ();
       // unlock the GUI so the other part of the interface can now be updated.
       // (eg: changing the renderedEditor)
-      GuiLocker::unlock();
+      GuiLocker::unlock ();
     });
-    tracemenu.exec(this->qglview->mapToGlobal(position));
+    tracemenu.exec (this->qglview->mapToGlobal (position));
   } else {
-    clearAllSelectionIndicators();
+    clearAllSelectionIndicators ();
   }
 }
 
-void MainWindow::measureFinished()
-{
-  meas.stopMeasure();
+void MainWindow::measureFinished () {
+  meas.stopMeasure ();
 }
 
-void MainWindow::clearAllSelectionIndicators()
-{
-  this->activeEditor->clearAllSelectionIndicators();
+void MainWindow::clearAllSelectionIndicators () {
+  this->activeEditor->clearAllSelectionIndicators ();
 }
 
-void MainWindow::setSelectionIndicatorStatus(EditorInterface *editor, int nodeIndex, EditorSelectionIndicatorStatus status)
-{
+void MainWindow::setSelectionIndicatorStatus (EditorInterface *editor, int nodeIndex, EditorSelectionIndicatorStatus status) {
   std::deque<std::shared_ptr<const AbstractNode>> stack;
-  this->rootNode->getNodeByID(nodeIndex, stack);
+  this->rootNode->getNodeByID (nodeIndex, stack);
 
   int level = 1;
 
   // first we flags all the nodes in the stack of the provided index
   // ends at size - 1 because we are not doing anything for the root node.
   // starts at 1 because we will process this one after later
-  for (int i = 1; i < stack.size() - 1; i++) {
-    const auto& node = stack[i];
+  for (int i = 1; i < stack.size () - 1; i++) {
+    const auto &node = stack[i];
 
-    auto& location = node->modinst->location();
-    if (location.filePath().compare(editor->filepath.toStdString()) != 0) {
+    auto &location = node->modinst->location ();
+    if (location.filePath ().compare (editor->filepath.toStdString ()) != 0) {
       level++;
       continue;
     }
 
-    if (node->verbose_name().rfind("module", 0) == 0 || node->modinst->name() == "children") {
-      editor->setSelectionIndicatorStatus(
+    if (node->verbose_name ().rfind ("module", 0) == 0 || node->modinst->name () == "children") {
+      editor->setSelectionIndicatorStatus (
         status, level,
-        location.firstLine() - 1, location.firstColumn() - 1, location.lastLine() - 1, location.lastColumn() - 1);
+        location.firstLine () - 1, location.firstColumn () - 1, location.lastLine () - 1, location.lastColumn () - 1);
       level++;
     }
   }
 
-  auto& node = stack[0];
-  auto location = node->modinst->location();
-  auto line = location.firstLine();
-  auto column = location.firstColumn();
-  auto lastLine = location.lastLine();
-  auto lastColumn = location.lastColumn();
+  auto &node = stack[0];
+  auto location = node->modinst->location ();
+  auto line = location.firstLine ();
+  auto column = location.firstColumn ();
+  auto lastLine = location.lastLine ();
+  auto lastColumn = location.lastColumn ();
 
   // Update the location returned by location to cover the whole section.
-  node->getCodeLocation(0, 0, &line, &column, &lastLine, &lastColumn, 0);
+  node->getCodeLocation (0, 0, &line, &column, &lastLine, &lastColumn, 0);
 
-  editor->setSelectionIndicatorStatus(status, 0, line - 1, column - 1, lastLine - 1, lastColumn - 1);
+  editor->setSelectionIndicatorStatus (status, 0, line - 1, column - 1, lastLine - 1, lastColumn - 1);
 }
 
-void MainWindow::setSelection(int index)
-{
-  assert(renderedEditor != nullptr);
-  if (currentlySelectedObject == index) return;
+void MainWindow::setSelection (int index) {
+  assert (renderedEditor != nullptr);
+  if (currentlySelectedObject == index)
+    return;
 
   std::deque<std::shared_ptr<const AbstractNode>> path;
-  const std::shared_ptr<const AbstractNode> selected_node = rootNode->getNodeByID(index, path);
+  const std::shared_ptr<const AbstractNode> selected_node = rootNode->getNodeByID (index, path);
 
-  if (!selected_node) return;
+  if (!selected_node)
+    return;
 
   currentlySelectedObject = index;
 
-  auto location = selected_node->modinst->location();
-  auto file = location.fileName();
-  auto line = location.firstLine();
-  auto column = location.firstColumn();
+  auto location = selected_node->modinst->location ();
+  auto file = location.fileName ();
+  auto line = location.firstLine ();
+  auto column = location.firstColumn ();
 
   // Unsaved files do have the pwd as current path, therefore we will not open a new
   // tab on click
-  if (!fs::is_directory(fs::path(file))) {
-    tabManager->open(QString::fromStdString(file));
+  if (!fs::is_directory (fs::path (file))) {
+    tabManager->open (QString::fromStdString (file));
   }
 
   // removes all previsly configure selection indicators.
-  renderedEditor->clearAllSelectionIndicators();
-  renderedEditor->show();
+  renderedEditor->clearAllSelectionIndicators ();
+  renderedEditor->show ();
 
   std::vector<std::shared_ptr<const AbstractNode>> nodesSameModule{};
-  rootNode->findNodesWithSameMod(selected_node, nodesSameModule);
+  rootNode->findNodesWithSameMod (selected_node, nodesSameModule);
 
   // highlight in the text editor all the text fragment of the hierarchy of object with same mode.
-  for (const auto& element : nodesSameModule) {
-    if (element->index() != currentlySelectedObject) {
-      setSelectionIndicatorStatus(renderedEditor, element->index(), EditorSelectionIndicatorStatus::IMPACTED);
+  for (const auto &element : nodesSameModule) {
+    if (element->index () != currentlySelectedObject) {
+      setSelectionIndicatorStatus (renderedEditor, element->index (), EditorSelectionIndicatorStatus::IMPACTED);
     }
   }
 
   // highlight in the text editor only the fragment correponding to the selected stack.
   // this step must be done after all the impacted element have been marked.
-  setSelectionIndicatorStatus(renderedEditor, currentlySelectedObject, EditorSelectionIndicatorStatus::SELECTED);
+  setSelectionIndicatorStatus (renderedEditor, currentlySelectedObject, EditorSelectionIndicatorStatus::SELECTED);
 
-  renderedEditor->setCursorPosition(line - 1, column - 1);
+  renderedEditor->setCursorPosition (line - 1, column - 1);
 }
 
 /**
  * Expects the sender to have properties "id" defined
  */
-void MainWindow::onHoveredObjectInSelectionMenu()
-{
-  assert(renderedEditor != nullptr);
-  auto *action = qobject_cast<QAction *>(sender());
-  if (!action || !action->property("id").isValid()) {
+void MainWindow::onHoveredObjectInSelectionMenu () {
+  assert (renderedEditor != nullptr);
+  auto *action = qobject_cast<QAction *> (sender ());
+  if (!action || !action->property ("id").isValid ()) {
     return;
   }
 
-  setSelection(action->property("id").toInt());
+  setSelection (action->property ("id").toInt ());
 }
 
-void MainWindow::setLastFocus(QWidget *widget) {
+void MainWindow::setLastFocus (QWidget *widget) {
   this->lastFocus = widget;
 }
 
@@ -2657,141 +2592,139 @@ void MainWindow::setLastFocus(QWidget *widget) {
  * @param progressWidget a pointer to the progress widget to show or nullptr in
  * case the display should switch back to the version label.
  */
-void MainWindow::updateStatusBar(ProgressWidget *progressWidget)
-{
-  auto sb = this->statusBar();
+void MainWindow::updateStatusBar (ProgressWidget *progressWidget) {
+  auto sb = this->statusBar ();
   if (progressWidget == nullptr) {
     if (this->progresswidget != nullptr) {
-      sb->removeWidget(this->progresswidget);
+      sb->removeWidget (this->progresswidget);
       delete this->progresswidget;
       this->progresswidget = nullptr;
     }
     if (versionLabel == nullptr) {
-      versionLabel = new QLabel("OpenSCAD " + QString::fromStdString(openscad_displayversionnumber));
-      sb->addPermanentWidget(this->versionLabel);
+      versionLabel = new QLabel ("OpenSCAD " + QString::fromStdString (openscad_displayversionnumber));
+      sb->addPermanentWidget (this->versionLabel);
     }
   } else {
     if (this->versionLabel != nullptr) {
-      sb->removeWidget(this->versionLabel);
+      sb->removeWidget (this->versionLabel);
       delete this->versionLabel;
       this->versionLabel = nullptr;
     }
-    sb->addPermanentWidget(progressWidget);
+    sb->addPermanentWidget (progressWidget);
   }
 }
 
-void MainWindow::exceptionCleanup(){
-  LOG("Execution aborted");
-  LOG(" ");
-  GuiLocker::unlock();
-  if (designActionAutoReload->isChecked()) autoReloadTimer->start();
+void MainWindow::exceptionCleanup () {
+  LOG ("Execution aborted");
+  LOG (" ");
+  GuiLocker::unlock ();
+  if (designActionAutoReload->isChecked ())
+    autoReloadTimer->start ();
 }
 
-void MainWindow::UnknownExceptionCleanup(std::string msg){
-  setCurrentOutput();   // we need to show this error
-  if (msg.size() == 0) {
-    LOG(message_group::Error, "Compilation aborted by unknown exception");
+void MainWindow::UnknownExceptionCleanup (std::string msg) {
+  setCurrentOutput (); // we need to show this error
+  if (msg.size () == 0) {
+    LOG (message_group::Error, "Compilation aborted by unknown exception");
   } else {
-    LOG(message_group::Error, "Compilation aborted by exception: %1$s", msg);
+    LOG (message_group::Error, "Compilation aborted by exception: %1$s", msg);
   }
-  LOG(" ");
-  GuiLocker::unlock();
-  if (designActionAutoReload->isChecked()) autoReloadTimer->start();
+  LOG (" ");
+  GuiLocker::unlock ();
+  if (designActionAutoReload->isChecked ())
+    autoReloadTimer->start ();
 }
 
-void MainWindow::showTextInWindow(const QString& type, const QString& content)
-{
-  auto e = new QTextEdit(this);
-  e->setAttribute(Qt::WA_DeleteOnClose);
-  e->setWindowFlags(Qt::Window);
-  e->setTabStopDistance(tabStopWidth);
-  e->setWindowTitle(type + " Dump");
-  if (content.isEmpty())e->setPlainText("No " + type + " to dump. Please try compiling first...");
-  else e->setPlainText(content);
+void MainWindow::showTextInWindow (const QString &type, const QString &content) {
+  auto e = new QTextEdit (this);
+  e->setAttribute (Qt::WA_DeleteOnClose);
+  e->setWindowFlags (Qt::Window);
+  e->setTabStopDistance (tabStopWidth);
+  e->setWindowTitle (type + " Dump");
+  if (content.isEmpty ())
+    e->setPlainText ("No " + type + " to dump. Please try compiling first...");
+  else
+    e->setPlainText (content);
 
-  e->setReadOnly(true);
-  e->resize(600, 400);
-  e->show();
+  e->setReadOnly (true);
+  e->resize (600, 400);
+  e->show ();
 }
 
-void MainWindow::actionDisplayAST()
-{
-  setCurrentOutput();
-  QString text = (rootFile)? QString::fromStdString(rootFile->dump("")) : "";
-  showTextInWindow("AST", text);
-  clearCurrentOutput();
+void MainWindow::actionDisplayAST () {
+  setCurrentOutput ();
+  QString text = (rootFile) ? QString::fromStdString (rootFile->dump ("")) : "";
+  showTextInWindow ("AST", text);
+  clearCurrentOutput ();
 }
 
-void MainWindow::actionDisplayCSGTree()
-{
-  setCurrentOutput();
-  QString text = (rootNode)? QString::fromStdString(tree.getString(*rootNode, "  ")) : "";
-  showTextInWindow("CSG", text);
-  clearCurrentOutput();
+void MainWindow::actionDisplayCSGTree () {
+  setCurrentOutput ();
+  QString text = (rootNode) ? QString::fromStdString (tree.getString (*rootNode, "  ")) : "";
+  showTextInWindow ("CSG", text);
+  clearCurrentOutput ();
 }
 
-void MainWindow::actionDisplayCSGProducts()
-{
-  setCurrentOutput();
+void MainWindow::actionDisplayCSGProducts () {
+  setCurrentOutput ();
   // a small lambda to avoid code duplication
-  auto constexpr dump = [](auto node){
-      return QString::fromStdString(node? node->dump() : "N/A");
-    };
-  auto text = QString("\nCSG before normalization:\n%1\n\n\nCSG after normalization:\n%2\n\n\nCSG rendering chain:\n%3\n\n\nHighlights CSG rendering chain:\n%4\n\n\nBackground CSG rendering chain:\n%5\n")
-    .arg(dump(csgRoot), dump(normalizedRoot), dump(rootProduct), dump(highlightsProducts), dump(backgroundProducts));
-  showTextInWindow("CSG Products Dump", text);
-  clearCurrentOutput();
-}
-
-void MainWindow::actionCheckValidity()
-{
-  if (GuiLocker::isLocked()) return;
+  auto constexpr dump = [] (auto node) {
+    return QString::fromStdString (node ? node->dump () : "N/A");
+  };
+  auto text = QString ("\nCSG before normalization:\n%1\n\n\nCSG after normalization:\n%2\n\n\nCSG rendering chain:\n%3\n\n\nHighlights CSG rendering chain:\n%4\n\n\nBackground CSG rendering chain:\n%5\n")
+                .arg (dump (csgRoot), dump (normalizedRoot), dump (rootProduct), dump (highlightsProducts), dump (backgroundProducts));
+  showTextInWindow ("CSG Products Dump", text);
+  clearCurrentOutput ();
+}
+
+void MainWindow::actionCheckValidity () {
+  if (GuiLocker::isLocked ())
+    return;
   const GuiLocker lock;
-  setCurrentOutput();
+  setCurrentOutput ();
 
   if (!rootGeom) {
-    LOG("Nothing to validate! Try building first (press F6).");
-    clearCurrentOutput();
+    LOG ("Nothing to validate! Try building first (press F6).");
+    clearCurrentOutput ();
     return;
   }
 
-  if (rootGeom->getDimension() != 3) {
-    LOG("Current top level object is not a 3D object.");
-    clearCurrentOutput();
+  if (rootGeom->getDimension () != 3) {
+    LOG ("Current top level object is not a 3D object.");
+    clearCurrentOutput ();
     return;
   }
 
   bool valid = true;
 #ifdef ENABLE_CGAL
-  if (auto N = std::dynamic_pointer_cast<const CGALNefGeometry>(rootGeom)) {
-    valid = N->p3 ? const_cast<CGAL_Nef_polyhedron3&>(*N->p3).is_valid() : false;
+  if (auto N = std::dynamic_pointer_cast<const CGALNefGeometry> (rootGeom)) {
+    valid = N->p3 ? const_cast<CGAL_Nef_polyhedron3 &> (*N->p3).is_valid () : false;
   } else
 #endif
 #ifdef ENABLE_MANIFOLD
-  if (auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(rootGeom)) {
-    valid = mani->isValid();
+    if (auto mani = std::dynamic_pointer_cast<const ManifoldGeometry> (rootGeom)) {
+    valid = mani->isValid ();
   }
 #endif
-  LOG("Valid:      %1$6s", (valid ? "yes" : "no"));
-  clearCurrentOutput();
+  LOG ("Valid:      %1$6s", (valid ? "yes" : "no"));
+  clearCurrentOutput ();
 }
 
 //Returns if we can export (true) or not(false) (bool)
 //Separated into it's own function for re-use.
-bool MainWindow::canExport(unsigned int dim)
-{
+bool MainWindow::canExport (unsigned int dim) {
   if (!rootGeom) {
-    LOG(message_group::Error, "Nothing to export! Try rendering first (press F6)");
-    clearCurrentOutput();
+    LOG (message_group::Error, "Nothing to export! Try rendering first (press F6)");
+    clearCurrentOutput ();
     return false;
   }
 
   // editor has changed since last render
   if (!activeEditor->contentsRendered) {
-    auto ret = QMessageBox::warning(this, "Application",
-                                    "The current tab has been modified since its last render (F6).\n"
-                                    "Do you really want to export the previous content?",
-                                    QMessageBox::Yes | QMessageBox::No);
+    auto ret = QMessageBox::warning (this, "Application",
+                                     "The current tab has been modified since its last render (F6).\n"
+                                     "Do you really want to export the previous content?",
+                                     QMessageBox::Yes | QMessageBox::No);
     if (ret != QMessageBox::Yes) {
       return false;
     }
@@ -2799,642 +2732,598 @@ bool MainWindow::canExport(unsigned int dim)
 
   // other tab contents most recently rendered
   if (renderedEditor != activeEditor) {
-    auto ret = QMessageBox::warning(this, "Application",
-                                    "The rendered data is of different tab.\n"
-                                    "Do you really want to export the another tab's content?",
-                                    QMessageBox::Yes | QMessageBox::No);
+    auto ret = QMessageBox::warning (this, "Application",
+                                     "The rendered data is of different tab.\n"
+                                     "Do you really want to export the another tab's content?",
+                                     QMessageBox::Yes | QMessageBox::No);
     if (ret != QMessageBox::Yes) {
       return false;
     }
   }
 
-  if (rootGeom->getDimension() != dim) {
-    LOG(message_group::UI_Error, "Current top level object is not a %1$dD object.", dim);
-    clearCurrentOutput();
+  if (rootGeom->getDimension () != dim) {
+    LOG (message_group::UI_Error, "Current top level object is not a %1$dD object.", dim);
+    clearCurrentOutput ();
     return false;
   }
 
-  if (rootGeom->isEmpty()) {
-    LOG(message_group::UI_Error, "Current top level object is empty.");
-    clearCurrentOutput();
+  if (rootGeom->isEmpty ()) {
+    LOG (message_group::UI_Error, "Current top level object is empty.");
+    clearCurrentOutput ();
     return false;
   }
 
 #ifdef ENABLE_CGAL
-  auto N = dynamic_cast<const CGALNefGeometry *>(rootGeom.get());
-  if (N && !N->p3->is_simple()) {
-    LOG(message_group::UI_Warning, "Object may not be a valid 2-manifold and may need repair! See https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/STL_Import_and_Export");
+  auto N = dynamic_cast<const CGALNefGeometry *> (rootGeom.get ());
+  if (N && !N->p3->is_simple ()) {
+    LOG (message_group::UI_Warning, "Object may not be a valid 2-manifold and may need repair! See https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/STL_Import_and_Export");
   }
 #endif
 #ifdef ENABLE_MANIFOLD
-  auto manifold = dynamic_cast<const ManifoldGeometry *>(rootGeom.get());
-  if (manifold && !manifold->isValid() ) {
-    LOG(message_group::UI_Warning, "Object may not be a valid manifold and may need repair! "
-        "Error message: %1$s. See https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/STL_Import_and_Export",
-        ManifoldUtils::statusToString(manifold->getManifold().Status()));
+  auto manifold = dynamic_cast<const ManifoldGeometry *> (rootGeom.get ());
+  if (manifold && !manifold->isValid ()) {
+    LOG (message_group::UI_Warning,
+         "Object may not be a valid manifold and may need repair! "
+         "Error message: %1$s. See https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/STL_Import_and_Export",
+         ManifoldUtils::statusToString (manifold->getManifold ().Status ()));
   }
 #endif
 
   return true;
 }
 
-void MainWindow::actionExport(unsigned int dim, ExportInfo& exportInfo)
-{
-  const auto type_name = QString::fromStdString(exportInfo.info.description);
-  const auto suffix = QString::fromStdString(exportInfo.info.suffix);
+void MainWindow::actionExport (unsigned int dim, ExportInfo &exportInfo) {
+  const auto type_name = QString::fromStdString (exportInfo.info.description);
+  const auto suffix = QString::fromStdString (exportInfo.info.suffix);
 
   //Setting filename skips the file selection dialog and uses the path provided instead.
-  if (GuiLocker::isLocked()) return;
+  if (GuiLocker::isLocked ())
+    return;
   const GuiLocker lock;
 
-  setCurrentOutput();
+  setCurrentOutput ();
 
   //Return if something is wrong and we can't export.
-  if (!canExport(dim)) return;
+  if (!canExport (dim))
+    return;
 
-  auto title = QString(_("Export %1 File")).arg(type_name);
-  auto filter = QString(_("%1 Files (*%2)")).arg(type_name, suffix);
-  auto exportFilename = QFileDialog::getSaveFileName(this, title, exportPath(suffix), filter);
-  if (exportFilename.isEmpty()) {
-    clearCurrentOutput();
+  auto title = QString (_ ("Export %1 File")).arg (type_name);
+  auto filter = QString (_ ("%1 Files (*%2)")).arg (type_name, suffix);
+  auto exportFilename = QFileDialog::getSaveFileName (this, title, exportPath (suffix), filter);
+  if (exportFilename.isEmpty ()) {
+    clearCurrentOutput ();
     return;
   }
   this->exportPaths[suffix] = exportFilename;
 
-  const bool exportResult = exportFileByName(rootGeom, exportFilename.toStdString(), exportInfo);
+  const bool exportResult = exportFileByName (rootGeom, exportFilename.toStdString (), exportInfo);
 
-  if (exportResult) fileExportedMessage(type_name, exportFilename);
-  clearCurrentOutput();
+  if (exportResult)
+    fileExportedMessage (type_name, exportFilename);
+  clearCurrentOutput ();
 }
 
-void MainWindow::actionExportFileFormat(int fmt)
-{
-  const auto format = static_cast<FileFormat>(fmt);
-  const FileFormatInfo& info = fileformat::info(format);
+void MainWindow::actionExportFileFormat (int fmt) {
+  const auto format = static_cast<FileFormat> (fmt);
+  const FileFormatInfo &info = fileformat::info (format);
 
-  ExportInfo exportInfo = createExportInfo(format, info, activeEditor->filepath.toStdString(), &qglview->cam, {});
+  ExportInfo exportInfo = createExportInfo (format, info, activeEditor->filepath.toStdString (), &qglview->cam, {});
 
   switch (format) {
-  case FileFormat::PDF:
-  {
+  case FileFormat::PDF: {
     ExportPdfDialog exportPdfDialog;
-    if (exportPdfDialog.exec() == QDialog::Rejected) {
+    if (exportPdfDialog.exec () == QDialog::Rejected) {
       return;
     }
 
-    exportInfo.optionsPdf = exportPdfDialog.getOptions();
-    actionExport(2, exportInfo);
-  }
-  break;
-  case FileFormat::_3MF:
-  {
+    exportInfo.optionsPdf = exportPdfDialog.getOptions ();
+    actionExport (2, exportInfo);
+  } break;
+  case FileFormat::_3MF: {
     Export3mfDialog export3mfDialog;
-    if (export3mfDialog.exec() == QDialog::Rejected) {
+    if (export3mfDialog.exec () == QDialog::Rejected) {
       return;
     }
 
-    exportInfo.options3mf = export3mfDialog.getOptions();
-    actionExport(3, exportInfo);
-  }
-  break;
-  case FileFormat::CSG:
-  {
-    setCurrentOutput();
+    exportInfo.options3mf = export3mfDialog.getOptions ();
+    actionExport (3, exportInfo);
+  } break;
+  case FileFormat::CSG: {
+    setCurrentOutput ();
 
     if (!this->rootNode) {
-      LOG(message_group::Error, "Nothing to export. Please try compiling first.");
-      clearCurrentOutput();
+      LOG (message_group::Error, "Nothing to export. Please try compiling first.");
+      clearCurrentOutput ();
       return;
     }
     const QString suffix = "csg";
-    auto csg_filename = QFileDialog::getSaveFileName(this,
-                                                     _("Export CSG File"), exportPath(suffix), _("CSG Files (*.csg)"));
+    auto csg_filename = QFileDialog::getSaveFileName (this,
+                                                      _ ("Export CSG File"), exportPath (suffix), _ ("CSG Files (*.csg)"));
 
-    if (csg_filename.isEmpty()) {
-      clearCurrentOutput();
+    if (csg_filename.isEmpty ()) {
+      clearCurrentOutput ();
       return;
     }
 
-    std::ofstream fstream(csg_filename.toLocal8Bit());
-    if (!fstream.is_open()) {
-      LOG("Can't open file \"%1$s\" for export", csg_filename.toLocal8Bit().constData());
+    std::ofstream fstream (csg_filename.toLocal8Bit ());
+    if (!fstream.is_open ()) {
+      LOG ("Can't open file \"%1$s\" for export", csg_filename.toLocal8Bit ().constData ());
     } else {
-      fstream << this->tree.getString(*this->rootNode, "\t") << "\n";
-      fstream.close();
-      fileExportedMessage("CSG", csg_filename);
+      fstream << this->tree.getString (*this->rootNode, "\t") << "\n";
+      fstream.close ();
+      fileExportedMessage ("CSG", csg_filename);
       this->exportPaths[suffix] = csg_filename;
     }
 
-    clearCurrentOutput();
-  }      break;
-  case FileFormat::PNG:
-  {
+    clearCurrentOutput ();
+  } break;
+  case FileFormat::PNG: {
     // Grab first to make sure dialog box isn't part of the grabbed image
-    qglview->grabFrame();
+    qglview->grabFrame ();
     const QString suffix = "png";
-    auto img_filename = QFileDialog::getSaveFileName(this,
-                                                     _("Export Image"), exportPath(suffix), _("PNG Files (*.png)"));
-    if (!img_filename.isEmpty()) {
-      const bool saveResult = qglview->save(img_filename.toLocal8Bit().constData());
+    auto img_filename = QFileDialog::getSaveFileName (this,
+                                                      _ ("Export Image"), exportPath (suffix), _ ("PNG Files (*.png)"));
+    if (!img_filename.isEmpty ()) {
+      const bool saveResult = qglview->save (img_filename.toLocal8Bit ().constData ());
       if (saveResult) {
         this->exportPaths[suffix] = img_filename;
-        setCurrentOutput();
-        fileExportedMessage("PNG", img_filename);
-        clearCurrentOutput();
+        setCurrentOutput ();
+        fileExportedMessage ("PNG", img_filename);
+        clearCurrentOutput ();
       } else {
-        LOG("Can't open file \"%1$s\" for export image", img_filename.toLocal8Bit().constData());
+        LOG ("Can't open file \"%1$s\" for export image", img_filename.toLocal8Bit ().constData ());
       }
     }
-  }
-  break;
+  } break;
   default:
-    actionExport(fileformat::is3D(format) ? 3 : fileformat::is2D(format) ? 2 : 0, exportInfo);
+    actionExport (fileformat::is3D (format) ? 3 : fileformat::is2D (format) ? 2
+                                                                            : 0,
+                  exportInfo);
   }
 }
 
-void MainWindow::copyText()
-{
-  auto *c = dynamic_cast<Console *>(lastFocus);
+void MainWindow::copyText () {
+  auto *c = dynamic_cast<Console *> (lastFocus);
   if (c) {
-    c->copy();
+    c->copy ();
   } else {
-    tabManager->copy();
+    tabManager->copy ();
   }
 }
 
-void MainWindow::actionCopyViewport()
-{
-  const auto& image = qglview->grabFrame();
-  auto clipboard = QApplication::clipboard();
-  clipboard->setImage(image);
+void MainWindow::actionCopyViewport () {
+  const auto &image = qglview->grabFrame ();
+  auto clipboard = QApplication::clipboard ();
+  clipboard->setImage (image);
 }
 
-void MainWindow::actionFlushCaches()
-{
-  GeometryCache::instance()->clear();
-  CGALCache::instance()->clear();
-  dxf_dim_cache.clear();
-  dxf_cross_cache.clear();
-  SourceFileCache::instance()->clear();
+void MainWindow::actionFlushCaches () {
+  GeometryCache::instance ()->clear ();
+  CGALCache::instance ()->clear ();
+  dxf_dim_cache.clear ();
+  dxf_cross_cache.clear ();
+  SourceFileCache::instance ()->clear ();
 
-  setCurrentOutput();
-  LOG("Caches Flushed");
+  setCurrentOutput ();
+  LOG ("Caches Flushed");
 }
 
-void MainWindow::viewModeActionsUncheck()
-{
-  viewActionPreview->setChecked(false);
-  viewActionThrownTogether->setChecked(false);
+void MainWindow::viewModeActionsUncheck () {
+  viewActionPreview->setChecked (false);
+  viewActionThrownTogether->setChecked (false);
 }
 
 #ifdef ENABLE_OPENCSG
 
-void MainWindow::viewModeRender()
-{
-  viewActionThrownTogether->setEnabled(false);
-  viewActionPreview->setEnabled(false);
-  this->qglview->setRenderer(this->geomRenderer);
-  this->qglview->updateColorScheme();
-  this->qglview->update();
+void MainWindow::viewModeRender () {
+  viewActionThrownTogether->setEnabled (false);
+  viewActionPreview->setEnabled (false);
+  this->qglview->setRenderer (this->geomRenderer);
+  this->qglview->updateColorScheme ();
+  this->qglview->update ();
 }
 
 /*!
    Go to the OpenCSG view mode.
    Falls back to thrown together mode if OpenCSG is not available
  */
-void MainWindow::viewModePreview()
-{
-  viewActionThrownTogether->setEnabled(true);
-  viewActionPreview->setEnabled(this->qglview->hasOpenCSGSupport());
-  if (this->qglview->hasOpenCSGSupport()) {
-    viewActionPreview->setChecked(true);
-    viewActionThrownTogether->setChecked(false);
-    this->qglview->setRenderer(this->previewRenderer ? this->previewRenderer : this->thrownTogetherRenderer);
-    this->qglview->updateColorScheme();
-    this->qglview->update();
+void MainWindow::viewModePreview () {
+  viewActionThrownTogether->setEnabled (true);
+  viewActionPreview->setEnabled (this->qglview->hasOpenCSGSupport ());
+  if (this->qglview->hasOpenCSGSupport ()) {
+    viewActionPreview->setChecked (true);
+    viewActionThrownTogether->setChecked (false);
+    this->qglview->setRenderer (this->previewRenderer ? this->previewRenderer : this->thrownTogetherRenderer);
+    this->qglview->updateColorScheme ();
+    this->qglview->update ();
   } else {
-    viewModeThrownTogether();
+    viewModeThrownTogether ();
   }
 }
 
 #endif /* ENABLE_OPENCSG */
 
-void MainWindow::viewModeThrownTogether()
-{
-  viewActionThrownTogether->setEnabled(true);
-  viewActionPreview->setEnabled(this->qglview->hasOpenCSGSupport());
-  viewActionThrownTogether->setChecked(true);
-  viewActionPreview->setChecked(false);
-  this->qglview->setRenderer(this->thrownTogetherRenderer);
-  this->qglview->updateColorScheme();
-  this->qglview->update();
+void MainWindow::viewModeThrownTogether () {
+  viewActionThrownTogether->setEnabled (true);
+  viewActionPreview->setEnabled (this->qglview->hasOpenCSGSupport ());
+  viewActionThrownTogether->setChecked (true);
+  viewActionPreview->setChecked (false);
+  this->qglview->setRenderer (this->thrownTogetherRenderer);
+  this->qglview->updateColorScheme ();
+  this->qglview->update ();
 }
 
-void MainWindow::viewModeShowEdges()
-{
+void MainWindow::viewModeShowEdges () {
   QSettingsCached settings;
-  settings.setValue("view/showEdges", viewActionShowEdges->isChecked());
-  this->qglview->setShowEdges(viewActionShowEdges->isChecked());
-  this->qglview->update();
+  settings.setValue ("view/showEdges", viewActionShowEdges->isChecked ());
+  this->qglview->setShowEdges (viewActionShowEdges->isChecked ());
+  this->qglview->update ();
 }
 
-void MainWindow::viewModeShowAxes()
-{
-  const bool showaxes = viewActionShowAxes->isChecked();
+void MainWindow::viewModeShowAxes () {
+  const bool showaxes = viewActionShowAxes->isChecked ();
   QSettingsCached settings;
-  settings.setValue("view/showAxes", showaxes);
-  this->viewActionShowScaleProportional->setEnabled(showaxes);
-  this->qglview->setShowAxes(showaxes);
-  this->qglview->update();
+  settings.setValue ("view/showAxes", showaxes);
+  this->viewActionShowScaleProportional->setEnabled (showaxes);
+  this->qglview->setShowAxes (showaxes);
+  this->qglview->update ();
 }
 
-void MainWindow::viewModeShowCrosshairs()
-{
+void MainWindow::viewModeShowCrosshairs () {
   QSettingsCached settings;
-  settings.setValue("view/showCrosshairs", viewActionShowCrosshairs->isChecked());
-  this->qglview->setShowCrosshairs(viewActionShowCrosshairs->isChecked());
-  this->qglview->update();
+  settings.setValue ("view/showCrosshairs", viewActionShowCrosshairs->isChecked ());
+  this->qglview->setShowCrosshairs (viewActionShowCrosshairs->isChecked ());
+  this->qglview->update ();
 }
 
-void MainWindow::viewModeShowScaleProportional()
-{
+void MainWindow::viewModeShowScaleProportional () {
   QSettingsCached settings;
-  settings.setValue("view/showScaleProportional", viewActionShowScaleProportional->isChecked());
-  this->qglview->setShowScaleProportional(viewActionShowScaleProportional->isChecked());
-  this->qglview->update();
+  settings.setValue ("view/showScaleProportional", viewActionShowScaleProportional->isChecked ());
+  this->qglview->setShowScaleProportional (viewActionShowScaleProportional->isChecked ());
+  this->qglview->update ();
 }
 
-bool MainWindow::isEmpty()
-{
-  return activeEditor->toPlainText().isEmpty();
+bool MainWindow::isEmpty () {
+  return activeEditor->toPlainText ().isEmpty ();
 }
 
-void MainWindow::editorContentChanged()
-{
+void MainWindow::editorContentChanged () {
   // this slot is called when the content of the active editor changed.
   // it rely on the activeEditor member to pick the new data.
 
-  auto current_doc = activeEditor->toPlainText();
+  auto current_doc = activeEditor->toPlainText ();
   if (current_doc != lastCompiledDoc) {
-    animateWidget->editorContentChanged();
+    animateWidget->editorContentChanged ();
 
     // removes the live selection feedbacks in both the 3d view and editor.
-    clearAllSelectionIndicators();
+    clearAllSelectionIndicators ();
   }
 }
 
-void MainWindow::viewAngleTop()
-{
+void MainWindow::viewAngleTop () {
   qglview->cam.object_rot << 90, 0, 0;
-  this->qglview->update();
+  this->qglview->update ();
 }
 
-void MainWindow::viewAngleBottom()
-{
+void MainWindow::viewAngleBottom () {
   qglview->cam.object_rot << 270, 0, 0;
-  this->qglview->update();
+  this->qglview->update ();
 }
 
-void MainWindow::viewAngleLeft()
-{
+void MainWindow::viewAngleLeft () {
   qglview->cam.object_rot << 0, 0, 90;
-  this->qglview->update();
+  this->qglview->update ();
 }
 
-void MainWindow::viewAngleRight()
-{
+void MainWindow::viewAngleRight () {
   qglview->cam.object_rot << 0, 0, 270;
-  this->qglview->update();
+  this->qglview->update ();
 }
 
-void MainWindow::viewAngleFront()
-{
+void MainWindow::viewAngleFront () {
   qglview->cam.object_rot << 0, 0, 0;
-  this->qglview->update();
+  this->qglview->update ();
 }
 
-void MainWindow::viewAngleBack()
-{
+void MainWindow::viewAngleBack () {
   qglview->cam.object_rot << 0, 0, 180;
-  this->qglview->update();
+  this->qglview->update ();
 }
 
-void MainWindow::viewAngleDiagonal()
-{
+void MainWindow::viewAngleDiagonal () {
   qglview->cam.object_rot << 35, 0, -25;
-  this->qglview->update();
+  this->qglview->update ();
 }
 
-void MainWindow::viewCenter()
-{
+void MainWindow::viewCenter () {
   qglview->cam.object_trans << 0, 0, 0;
-  this->qglview->update();
+  this->qglview->update ();
 }
 
-void MainWindow::setProjectionType(ProjectionType mode)
-{
+void MainWindow::setProjectionType (ProjectionType mode) {
   bool isOrthogonal = ProjectionType::ORTHOGONAL == mode;
   QSettingsCached settings;
-  settings.setValue("view/orthogonalProjection", isOrthogonal);
-  viewActionPerspective->setChecked(!isOrthogonal);
-  viewActionOrthogonal->setChecked(isOrthogonal);
-  qglview->setOrthoMode(isOrthogonal);
-  qglview->update();
+  settings.setValue ("view/orthogonalProjection", isOrthogonal);
+  viewActionPerspective->setChecked (!isOrthogonal);
+  viewActionOrthogonal->setChecked (isOrthogonal);
+  qglview->setOrthoMode (isOrthogonal);
+  qglview->update ();
 }
 
-void MainWindow::viewPerspective()
-{
-  setProjectionType(ProjectionType::PERSPECTIVE);
+void MainWindow::viewPerspective () {
+  setProjectionType (ProjectionType::PERSPECTIVE);
 }
 
-void MainWindow::viewOrthogonal()
-{
-  setProjectionType(ProjectionType::ORTHOGONAL);
+void MainWindow::viewOrthogonal () {
+  setProjectionType (ProjectionType::ORTHOGONAL);
 }
 
-void MainWindow::viewTogglePerspective()
-{
+void MainWindow::viewTogglePerspective () {
   const QSettingsCached settings;
-  bool isOrtho = settings.value("view/orthogonalProjection").toBool();
-  setProjectionType(isOrtho?ProjectionType::PERSPECTIVE:ProjectionType::ORTHOGONAL);
+  bool isOrtho = settings.value ("view/orthogonalProjection").toBool ();
+  setProjectionType (isOrtho ? ProjectionType::PERSPECTIVE : ProjectionType::ORTHOGONAL);
 }
 
-void MainWindow::viewResetView()
-{
-  this->qglview->resetView();
-  this->qglview->update();
+void MainWindow::viewResetView () {
+  this->qglview->resetView ();
+  this->qglview->update ();
 }
 
-void MainWindow::viewAll()
-{
-  this->qglview->viewAll();
-  this->qglview->update();
+void MainWindow::viewAll () {
+  this->qglview->viewAll ();
+  this->qglview->update ();
 }
 
-void MainWindow::hideEditorToolbar()
-{
+void MainWindow::hideEditorToolbar () {
   QSettingsCached settings;
-  const bool shouldHide = viewActionHideEditorToolBar->isChecked();
-  settings.setValue("view/hideEditorToolbar", shouldHide);
+  const bool shouldHide = viewActionHideEditorToolBar->isChecked ();
+  settings.setValue ("view/hideEditorToolbar", shouldHide);
 
   if (shouldHide) {
-    editortoolbar->hide();
+    editortoolbar->hide ();
   } else {
-    editortoolbar->show();
+    editortoolbar->show ();
   }
 }
 
-void MainWindow::hide3DViewToolbar()
-{
+void MainWindow::hide3DViewToolbar () {
   QSettingsCached settings;
-  const bool shouldHide = viewActionHide3DViewToolBar->isChecked();
-  settings.setValue("view/hide3DViewToolbar", shouldHide);
+  const bool shouldHide = viewActionHide3DViewToolBar->isChecked ();
+  settings.setValue ("view/hide3DViewToolbar", shouldHide);
 
   if (shouldHide) {
-    viewerToolBar->hide();
+    viewerToolBar->hide ();
   } else {
-    viewerToolBar->show();
+    viewerToolBar->show ();
   }
 }
 
-void MainWindow::showLink(const QString& link)
-{
+void MainWindow::showLink (const QString &link) {
   if (link == "#console") {
-    consoleDock->show();
+    consoleDock->show ();
   } else if (link == "#errorlog") {
-    errorLogDock->show();
+    errorLogDock->show ();
   }
 }
 
-void MainWindow::onEditorDockVisibilityChanged(bool isVisible)
-{
-  auto e = (ScintillaEditor *) this->activeEditor;
+void MainWindow::onEditorDockVisibilityChanged (bool isVisible) {
+  auto e = (ScintillaEditor *)this->activeEditor;
   if (isVisible) {
-    e->qsci->setReadOnly(false);
-    e->setupAutoComplete(false);
-    editorDock->raise();
-    tabManager->setFocus();
+    e->qsci->setReadOnly (false);
+    e->setupAutoComplete (false);
+    editorDock->raise ();
+    tabManager->setFocus ();
   } else {
     // Workaround manually disabling interactions with editor by setting it
     // to read-only when not being shown.  This is an upstream bug from Qt
     // (tracking ticket: https://bugreports.qt.io/browse/QTBUG-82939) and
     // may eventually get resolved at which point this bit and the stuff in
     // the else should be removed. Currently known to affect 5.14.1 and 5.15.0
-    e->qsci->setReadOnly(true);
-    e->setupAutoComplete(true);
+    e->qsci->setReadOnly (true);
+    e->setupAutoComplete (true);
   }
-  updateExportActions();
+  updateExportActions ();
 }
 
-void MainWindow::onConsoleDockVisibilityChanged(bool isVisible)
-{
+void MainWindow::onConsoleDockVisibilityChanged (bool isVisible) {
   if (isVisible) {
-    frameCompileResult->hide();
-    consoleDock->raise();
-    console->setFocus();
+    frameCompileResult->hide ();
+    consoleDock->raise ();
+    console->setFocus ();
   }
 }
 
-void MainWindow::onErrorLogDockVisibilityChanged(bool isVisible)
-{
+void MainWindow::onErrorLogDockVisibilityChanged (bool isVisible) {
   if (isVisible) {
-    frameCompileResult->hide();
-    errorLogDock->raise();
-    errorLogWidget->logTable->setFocus();
+    frameCompileResult->hide ();
+    errorLogDock->raise ();
+    errorLogWidget->logTable->setFocus ();
   }
 }
 
-void MainWindow::onAnimateDockVisibilityChanged(bool isVisible)
-{
+void MainWindow::onAnimateDockVisibilityChanged (bool isVisible) {
   if (isVisible) {
-    animateDock->raise();
-    animateWidget->setFocus();
+    animateDock->raise ();
+    animateWidget->setFocus ();
   }
 }
 
-void MainWindow::onFontListDockVisibilityChanged(bool isVisible)
-{
+void MainWindow::onFontListDockVisibilityChanged (bool isVisible) {
   if (isVisible) {
-    fontListWidget->update_font_list();
-    fontListWidget->setFocus();
-    fontListDock->raise();
+    fontListWidget->update_font_list ();
+    fontListWidget->setFocus ();
+    fontListDock->raise ();
   }
 }
 
-void MainWindow::onViewportControlDockVisibilityChanged(bool isVisible)
-{
+void MainWindow::onViewportControlDockVisibilityChanged (bool isVisible) {
   if (isVisible) {
-    viewportControlDock->raise();
-    viewportControlWidget->setFocus();
+    viewportControlDock->raise ();
+    viewportControlWidget->setFocus ();
   }
 }
 
-void MainWindow::onParametersDockVisibilityChanged(bool isVisible)
-{
+void MainWindow::onParametersDockVisibilityChanged (bool isVisible) {
   if (isVisible) {
-    parameterDock->raise();
-    activeEditor->parameterWidget->scrollArea->setFocus();
+    parameterDock->raise ();
+    activeEditor->parameterWidget->scrollArea->setFocus ();
   }
 }
 
 // Use the sender's to detect if we are moving forward/backward in docks
 // and search for the next dock to "activate" or "emphasize"
 // If no dock can be found, returns the first one.
-Dock *MainWindow::getNextDockFromSender(QObject *sender)
-{
+Dock *MainWindow::getNextDockFromSender (QObject *sender) {
   int direction = 0;
 
-  auto *action = qobject_cast<QAction *>(sender);
+  auto *action = qobject_cast<QAction *> (sender);
   if (action != nullptr) {
     direction = (action == windowActionNextWindow) ? 1 : -1;
   } else {
-    auto *shortcut = qobject_cast<QShortcut *>(sender);
+    auto *shortcut = qobject_cast<QShortcut *> (sender);
     direction = (shortcut == shortcutNextWindow) ? 1 : -1;
   }
 
-  return findVisibleDockToActivate(direction);
+  return findVisibleDockToActivate (direction);
 }
 
-void MainWindow::onWindowActionNextPrevHovered()
-{
-  auto dock = getNextDockFromSender(sender());
+void MainWindow::onWindowActionNextPrevHovered () {
+  auto dock = getNextDockFromSender (sender ());
 
   // This can happens if there is no visible dock at all
-  if (dock == nullptr) return;
+  if (dock == nullptr)
+    return;
 
   // Hover signal is emitted at each mouse move, to avoid excessive
   // load we only raise/emphasize if it is not yet done.
-  if (rubberBandManager.isEmphasized(dock)) return;
+  if (rubberBandManager.isEmphasized (dock))
+    return;
 
-  dock->raise();
-  rubberBandManager.emphasize(dock);
+  dock->raise ();
+  rubberBandManager.emphasize (dock);
 }
 
-void MainWindow::onWindowActionNextPrevTriggered()
-{
-  auto dock = getNextDockFromSender(sender());
+void MainWindow::onWindowActionNextPrevTriggered () {
+  auto dock = getNextDockFromSender (sender ());
 
   // This can happens if there is no visible dock at all
-  if (dock == nullptr) return;
+  if (dock == nullptr)
+    return;
 
-  activateDock(dock);
+  activateDock (dock);
 }
 
-void MainWindow::onWindowShortcutNextPrevActivated()
-{
-  auto dock = getNextDockFromSender(sender());
+void MainWindow::onWindowShortcutNextPrevActivated () {
+  auto dock = getNextDockFromSender (sender ());
 
   // This can happens if there is no visible dock at all
-  if (dock == nullptr) return;
+  if (dock == nullptr)
+    return;
 
-  activateDock(dock);
-  rubberBandManager.emphasize(dock);
+  activateDock (dock);
+  rubberBandManager.emphasize (dock);
 }
 
-void MainWindow::on_editActionInsertTemplate_triggered()
-{
-  activeEditor->displayTemplates();
+void MainWindow::on_editActionInsertTemplate_triggered () {
+  activeEditor->displayTemplates ();
 }
 
-void MainWindow::on_editActionFoldAll_triggered()
-{
-  activeEditor->foldUnfold();
+void MainWindow::on_editActionFoldAll_triggered () {
+  activeEditor->foldUnfold ();
 }
 
-QString MainWindow::getCurrentFileName() const
-{
-  if (activeEditor == nullptr) return {};
+QString MainWindow::getCurrentFileName () const {
+  if (activeEditor == nullptr)
+    return {};
 
-  const QFileInfo fileInfo(activeEditor->filepath);
-  QString fname = _("Untitled.scad");
-  if (!fileInfo.fileName().isEmpty()) fname = fileInfo.fileName();
-  return fname.replace("&", "&&");
+  const QFileInfo fileInfo (activeEditor->filepath);
+  QString fname = _ ("Untitled.scad");
+  if (!fileInfo.fileName ().isEmpty ())
+    fname = fileInfo.fileName ();
+  return fname.replace ("&", "&&");
 }
 
-void MainWindow::onTabManagerAboutToCloseEditor(EditorInterface *closingEditor)
-{
+void MainWindow::onTabManagerAboutToCloseEditor (EditorInterface *closingEditor) {
   // This slots is in charge of closing properly the preview when the
   // associated editor is about to close.
   if (closingEditor == renderedEditor) {
     renderedEditor = nullptr;
 
     // Invalidate renderers before we kill the CSG tree
-    this->qglview->setRenderer(nullptr);
-       #ifdef ENABLE_OPENCSG
+    this->qglview->setRenderer (nullptr);
+#ifdef ENABLE_OPENCSG
     this->previewRenderer = nullptr;
-       #endif
+#endif
     this->thrownTogetherRenderer = nullptr;
 
     // Remove previous CSG tree
-    this->absoluteRootNode.reset();
+    this->absoluteRootNode.reset ();
 
-    this->csgRoot.reset();
-    this->normalizedRoot.reset();
-    this->rootProduct.reset();
+    this->csgRoot.reset ();
+    this->normalizedRoot.reset ();
+    this->rootProduct.reset ();
 
-    this->rootNode.reset();
-    this->tree.setRoot(nullptr);
-    this->qglview->update();
+    this->rootNode.reset ();
+    this->tree.setRoot (nullptr);
+    this->qglview->update ();
   }
 }
 
-void MainWindow::onTabManagerEditorContentReloaded(EditorInterface *reloadedEditor)
-{
+void MainWindow::onTabManagerEditorContentReloaded (EditorInterface *reloadedEditor) {
   try {
     // when a new editor is created, it is important to compile the initial geometry
     // so the customizer panels are ok.
-    parseDocument(reloadedEditor);
-  } catch (const HardWarningException&) {
-    exceptionCleanup();
-  } catch (const std::exception& ex) {
-    UnknownExceptionCleanup(ex.what());
+    parseDocument (reloadedEditor);
+  } catch (const HardWarningException &) {
+    exceptionCleanup ();
+  } catch (const std::exception &ex) {
+    UnknownExceptionCleanup (ex.what ());
   } catch (...) {
-    UnknownExceptionCleanup();
+    UnknownExceptionCleanup ();
   }
 
   // updates the content of the Recents Files menu to integrate the one possibly
   // associated with the created editor. The reason is that an editor can be created
   // or updated without a file associated with it.
-  updateRecentFileActions();
+  updateRecentFileActions ();
 }
 
-void MainWindow::onTabManagerEditorChanged(EditorInterface *newEditor)
-{
+void MainWindow::onTabManagerEditorChanged (EditorInterface *newEditor) {
   activeEditor = newEditor;
 
-  if (newEditor == nullptr) return;
+  if (newEditor == nullptr)
+    return;
 
-  parameterDock->setWidget(newEditor->parameterWidget);
-  editActionUndo->setEnabled(newEditor->canUndo());
+  parameterDock->setWidget (newEditor->parameterWidget);
+  editActionUndo->setEnabled (newEditor->canUndo ());
 
-  const QString name = getCurrentFileName();
-  setWindowTitle(name);
+  const QString name = getCurrentFileName ();
+  setWindowTitle (name);
 
-  consoleDock->setNameSuffix(name);
-  errorLogDock->setNameSuffix(name);
-  animateDock->setNameSuffix(name);
-  fontListDock->setNameSuffix(name);
-  viewportControlDock->setNameSuffix(name);
+  consoleDock->setNameSuffix (name);
+  errorLogDock->setNameSuffix (name);
+  animateDock->setNameSuffix (name);
+  fontListDock->setNameSuffix (name);
+  viewportControlDock->setNameSuffix (name);
 
   // If there is no renderedEditor we request for a new preview.
   if (renderedEditor == nullptr) {
-    actionRenderPreview();
+    actionRenderPreview ();
   }
 }
 
-Dock *MainWindow::findVisibleDockToActivate(int offset) const
-{
-  const unsigned int dockCount = docks.size();
+Dock *MainWindow::findVisibleDockToActivate (int offset) const {
+  const unsigned int dockCount = docks.size ();
 
   int focusedDockIndice = -1;
 
   // search among the docks the one that is having the focus. This is done by
   // traversing the widget hierarchy from the focused widget up to the docks that
   // contains it.
-  const auto focusWidget = QApplication::focusWidget();
-  for (auto widget = focusWidget; widget != nullptr; widget = widget->parentWidget()) {
+  const auto focusWidget = QApplication::focusWidget ();
+  for (auto widget = focusWidget; widget != nullptr; widget = widget->parentWidget ()) {
     for (unsigned int index = 0; index < dockCount; ++index) {
-      auto dock = std::get<0>(docks[index]);
+      auto dock = std::get<0> (docks[index]);
       if (dock == focusWidget) {
         focusedDockIndice = index;
       }
@@ -3450,172 +3339,161 @@ Dock *MainWindow::findVisibleDockToActivate(int offset) const
     // to find the first visible one. dockCount is there so there is no situation in which
     // (-1) % dockCount
     const int target = (dockCount + focusedDockIndice + o * offset) % dockCount;
-    const auto& dock = std::get<0>(docks.at(target));
+    const auto &dock = std::get<0> (docks.at (target));
 
-    if (dock->isVisible()) {
+    if (dock->isVisible ()) {
       return dock;
     }
   }
   return nullptr;
 }
 
-void MainWindow::activateDock(Dock *dock)
-{
-  if (dock == nullptr) return;
+void MainWindow::activateDock (Dock *dock) {
+  if (dock == nullptr)
+    return;
 
   // We always need to activate the window.
-  if (dock->isFloating()) dock->activateWindow();
-  else QMainWindow::activateWindow();
+  if (dock->isFloating ())
+    dock->activateWindow ();
+  else
+    QMainWindow::activateWindow ();
 
-  dock->raise();
-  dock->setFocus();
+  dock->raise ();
+  dock->setFocus ();
 }
 
-void MainWindow::dragEnterEvent(QDragEnterEvent *event)
-{
-  if (event->mimeData()->hasUrls()) {
-    event->acceptProposedAction();
+void MainWindow::dragEnterEvent (QDragEnterEvent *event) {
+  if (event->mimeData ()->hasUrls ()) {
+    event->acceptProposedAction ();
   }
 }
 
-void MainWindow::dropEvent(QDropEvent *event)
-{
-  setCurrentOutput();
-  const QList<QUrl> urls = event->mimeData()->urls();
-  for (const auto& url : urls) {
-    handleFileDrop(url);
+void MainWindow::dropEvent (QDropEvent *event) {
+  setCurrentOutput ();
+  const QList<QUrl> urls = event->mimeData ()->urls ();
+  for (const auto &url : urls) {
+    handleFileDrop (url);
   }
-  clearCurrentOutput();
+  clearCurrentOutput ();
 }
 
-void MainWindow::handleFileDrop(const QUrl& url)
-{
-  if (url.scheme() != "file") return;
-  const auto fileName = url.toLocalFile();
+void MainWindow::handleFileDrop (const QUrl &url) {
+  if (url.scheme () != "file")
+    return;
+  const auto fileName = url.toLocalFile ();
   const auto fileInfo = QFileInfo{fileName};
-  const auto suffix = fileInfo.suffix().toLower();
+  const auto suffix = fileInfo.suffix ().toLower ();
   const auto cmd = Importer::knownFileExtensions[suffix];
-  if (cmd.isEmpty()) {
-    tabManager->open(fileName);
+  if (cmd.isEmpty ()) {
+    tabManager->open (fileName);
   } else {
-    activeEditor->insert(cmd.arg(fileName));
+    activeEditor->insert (cmd.arg (fileName));
   }
 }
 
-void MainWindow::helpAbout()
-{
-  qApp->setWindowIcon(QApplication::windowIcon());
-  auto dialog = new AboutDialog(this);
-  dialog->exec();
-  dialog->deleteLater();
+void MainWindow::helpAbout () {
+  qApp->setWindowIcon (QApplication::windowIcon ());
+  auto dialog = new AboutDialog (this);
+  dialog->exec ();
+  dialog->deleteLater ();
 }
 
-void MainWindow::helpHomepage()
-{
-  UIUtils::openHomepageURL();
+void MainWindow::helpHomepage () {
+  UIUtils::openHomepageURL ();
 }
 
-void MainWindow::helpManual()
-{
-  UIUtils::openUserManualURL();
+void MainWindow::helpManual () {
+  UIUtils::openUserManualURL ();
 }
 
-void MainWindow::helpOfflineManual()
-{
-  UIUtils::openOfflineUserManual();
+void MainWindow::helpOfflineManual () {
+  UIUtils::openOfflineUserManual ();
 }
 
-void MainWindow::helpCheatSheet()
-{
-  UIUtils::openCheatSheetURL();
+void MainWindow::helpCheatSheet () {
+  UIUtils::openCheatSheetURL ();
 }
 
-void MainWindow::helpOfflineCheatSheet()
-{
-  UIUtils::openOfflineCheatSheet();
+void MainWindow::helpOfflineCheatSheet () {
+  UIUtils::openOfflineCheatSheet ();
 }
 
-void MainWindow::helpLibrary()
-{
+void MainWindow::helpLibrary () {
   if (!this->libraryInfoDialog) {
-    const QString rendererInfo(qglview->getRendererInfo().c_str());
-    auto dialog = new LibraryInfoDialog(rendererInfo);
+    const QString rendererInfo (qglview->getRendererInfo ().c_str ());
+    auto dialog = new LibraryInfoDialog (rendererInfo);
     this->libraryInfoDialog = dialog;
   }
-  this->libraryInfoDialog->show();
+  this->libraryInfoDialog->show ();
 }
 
-void MainWindow::helpFontInfo()
-{
+void MainWindow::helpFontInfo () {
   if (!this->fontListDialog) {
-    auto dialog = new FontListDialog();
+    auto dialog = new FontListDialog ();
     this->fontListDialog = dialog;
   }
-  this->fontListDialog->updateFontList();
-  this->fontListDialog->show();
+  this->fontListDialog->updateFontList ();
+  this->fontListDialog->show ();
 }
 
-void MainWindow::closeEvent(QCloseEvent *event)
-{
-  if (tabManager->shouldClose()) {
+void MainWindow::closeEvent (QCloseEvent *event) {
+  if (tabManager->shouldClose ()) {
     isClosing = true;
-    progress_report_fin();
+    progress_report_fin ();
     // Disable invokeMethod calls for consoleOutput during shutdown,
     // otherwise will segfault if echos are in progress.
-    hideCurrentOutput();
+    hideCurrentOutput ();
 
     QSettingsCached settings;
-    settings.setValue("window/geometry", saveGeometry());
-    settings.setValue("window/state", saveState());
+    settings.setValue ("window/geometry", saveGeometry ());
+    settings.setValue ("window/state", saveState ());
     if (this->tempFile) {
       delete this->tempFile;
       this->tempFile = nullptr;
     }
-    for (auto dock : findChildren<Dock *>()) {
-      dock->disableSettingsUpdate();
+    for (auto dock : findChildren<Dock *> ()) {
+      dock->disableSettingsUpdate ();
     }
-    event->accept();
+    event->accept ();
   } else {
-    event->ignore();
+    event->ignore ();
   }
 }
 
-void MainWindow::preferences()
-{
-  GlobalPreferences::inst()->update();
-  GlobalPreferences::inst()->show();
-  GlobalPreferences::inst()->activateWindow();
-  GlobalPreferences::inst()->raise();
+void MainWindow::preferences () {
+  GlobalPreferences::inst ()->update ();
+  GlobalPreferences::inst ()->show ();
+  GlobalPreferences::inst ()->activateWindow ();
+  GlobalPreferences::inst ()->raise ();
 }
 
-void MainWindow::setColorScheme(const QString& scheme)
-{
-  RenderSettings::inst()->colorscheme = scheme.toStdString();
-  this->qglview->setColorScheme(scheme.toStdString());
-  this->qglview->update();
+void MainWindow::setColorScheme (const QString &scheme) {
+  RenderSettings::inst ()->colorscheme = scheme.toStdString ();
+  this->qglview->setColorScheme (scheme.toStdString ());
+  this->qglview->update ();
 }
 
-void MainWindow::setFont(const QString& family, uint size)
-{
+void MainWindow::setFont (const QString &family, uint size) {
   QFont font;
-  if (!family.isEmpty()) font.setFamily(family);
-  else font.setFixedPitch(true);
-  if (size > 0) font.setPointSize(size);
-  font.setStyleHint(QFont::TypeWriter);
-  activeEditor->setFont(font);
+  if (!family.isEmpty ())
+    font.setFamily (family);
+  else
+    font.setFixedPitch (true);
+  if (size > 0)
+    font.setPointSize (size);
+  font.setStyleHint (QFont::TypeWriter);
+  activeEditor->setFont (font);
 }
 
-void MainWindow::consoleOutput(const Message& msgObj, void *userdata)
-{
+void MainWindow::consoleOutput (const Message &msgObj, void *userdata) {
   // Invoke the method in the main thread in case the output
   // originates in a worker thread.
-  auto thisp = static_cast<MainWindow *>(userdata);
-  QMetaObject::invokeMethod(thisp, "consoleOutput", Q_ARG(Message, msgObj));
+  auto thisp = static_cast<MainWindow *> (userdata);
+  QMetaObject::invokeMethod (thisp, "consoleOutput", Q_ARG (Message, msgObj));
 }
 
-void MainWindow::consoleOutput(const Message& msgObj)
-{
-  this->console->addMessage(msgObj);
+void MainWindow::consoleOutput (const Message &msgObj) {
+  this->console->addMessage (msgObj);
   if (msgObj.group == message_group::Warning || msgObj.group == message_group::Deprecated) {
     ++this->compileWarnings;
   } else if (msgObj.group == message_group::Error) {
@@ -3623,72 +3501,63 @@ void MainWindow::consoleOutput(const Message& msgObj)
   }
   // FIXME: scad parsing/evaluation should be done on separate thread so as not to block the gui.
   // Then processEvents should no longer be needed here.
-  this->processEvents();
-  if (consoleUpdater && !consoleUpdater->isActive()) {
-    consoleUpdater->start(50);     // Limit console updates to 20 FPS
+  this->processEvents ();
+  if (consoleUpdater && !consoleUpdater->isActive ()) {
+    consoleUpdater->start (50); // Limit console updates to 20 FPS
   }
 }
 
-void MainWindow::consoleOutputRaw(const QString& html)
-{
-  this->console->addHtml(html);
-  this->processEvents();
+void MainWindow::consoleOutputRaw (const QString &html) {
+  this->console->addHtml (html);
+  this->processEvents ();
 }
 
-void MainWindow::errorLogOutput(const Message& log_msg, void *userdata)
-{
-  auto thisp = static_cast<MainWindow *>(userdata);
-  QMetaObject::invokeMethod(thisp, "errorLogOutput", Q_ARG(Message, log_msg));
+void MainWindow::errorLogOutput (const Message &log_msg, void *userdata) {
+  auto thisp = static_cast<MainWindow *> (userdata);
+  QMetaObject::invokeMethod (thisp, "errorLogOutput", Q_ARG (Message, log_msg));
 }
 
-void MainWindow::errorLogOutput(const Message& log_msg)
-{
-  this->errorLogWidget->toErrorLog(log_msg);
+void MainWindow::errorLogOutput (const Message &log_msg) {
+  this->errorLogWidget->toErrorLog (log_msg);
 }
 
-void MainWindow::setCurrentOutput()
-{
-  set_output_handler(&MainWindow::consoleOutput, &MainWindow::errorLogOutput, this);
+void MainWindow::setCurrentOutput () {
+  set_output_handler (&MainWindow::consoleOutput, &MainWindow::errorLogOutput, this);
 }
 
-void MainWindow::hideCurrentOutput()
-{
-  set_output_handler(&MainWindow::noOutputConsole, &MainWindow::noOutputErrorLog, this);
+void MainWindow::hideCurrentOutput () {
+  set_output_handler (&MainWindow::noOutputConsole, &MainWindow::noOutputErrorLog, this);
 }
 
-void MainWindow::clearCurrentOutput()
-{
-  set_output_handler(nullptr, nullptr, nullptr);
+void MainWindow::clearCurrentOutput () {
+  set_output_handler (nullptr, nullptr, nullptr);
 }
 
-void MainWindow::openCSGSettingsChanged()
-{
+void MainWindow::openCSGSettingsChanged () {
 #ifdef ENABLE_OPENCSG
-  OpenCSG::setOption(OpenCSG::AlgorithmSetting, GlobalPreferences::inst()->getValue("advanced/forceGoldfeather").toBool() ?
-                     OpenCSG::Goldfeather : OpenCSG::Automatic);
+  OpenCSG::setOption (OpenCSG::AlgorithmSetting, GlobalPreferences::inst ()->getValue ("advanced/forceGoldfeather").toBool () ? OpenCSG::Goldfeather : OpenCSG::Automatic);
 #endif
 }
 
-void MainWindow::processEvents()
-{
-  if (this->procevents) QApplication::processEvents();
+void MainWindow::processEvents () {
+  if (this->procevents)
+    QApplication::processEvents ();
 }
 
-QString MainWindow::exportPath(const QString& suffix) {
-  const auto path_it = this->exportPaths.find(suffix);
-  const auto basename = activeEditor->filepath.isEmpty() ? "Untitled" : QFileInfo(activeEditor->filepath).completeBaseName();
+QString MainWindow::exportPath (const QString &suffix) {
+  const auto path_it = this->exportPaths.find (suffix);
+  const auto basename = activeEditor->filepath.isEmpty () ? "Untitled" : QFileInfo (activeEditor->filepath).completeBaseName ();
   QString dir;
-  if (path_it != exportPaths.end()) {
-    dir = QFileInfo(path_it->second).absolutePath();
-  } else if (activeEditor->filepath.isEmpty()) {
-    dir = QString::fromStdString(PlatformUtils::userDocumentsPath());
+  if (path_it != exportPaths.end ()) {
+    dir = QFileInfo (path_it->second).absolutePath ();
+  } else if (activeEditor->filepath.isEmpty ()) {
+    dir = QString::fromStdString (PlatformUtils::userDocumentsPath ());
   } else {
-    dir = QFileInfo(activeEditor->filepath).absolutePath();
+    dir = QFileInfo (activeEditor->filepath).absolutePath ();
   }
-  return QString("%1/%2.%3").arg(dir, basename, suffix);
+  return QString ("%1/%2.%3").arg (dir, basename, suffix);
 }
 
-void MainWindow::jumpToLine(int line, int col)
-{
-  this->activeEditor->setCursorPosition(line, col);
+void MainWindow::jumpToLine (int line, int col) {
+  this->activeEditor->setCursorPosition (line, col);
 }
diff --git a/src/gui/MainWindow.h b/src/gui/MainWindow.h
index 5f46b993c..b5f4fdd88 100644
--- a/src/gui/MainWindow.h
+++ b/src/gui/MainWindow.h
@@ -38,7 +38,7 @@
 #include "core/SourceFile.h"
 #ifdef STATIC_QT_SVG_PLUGIN
 #include <QtPlugin>
-Q_IMPORT_PLUGIN(QSvgPlugin)
+Q_IMPORT_PLUGIN (QSvgPlugin)
 #endif
 
 class BuiltinContext;
@@ -94,7 +94,7 @@ public:
   bool python_active;
   std::string trusted_edit_document_name;
   std::string untrusted_edit_document_name;
-  bool trust_python_file(const std::string& file, const std::string& content);
+  bool trust_python_file (const std::string &file, const std::string &content);
 #endif
   Tree tree;
   EditorInterface *activeEditor;
@@ -120,8 +120,8 @@ public:
   int compileErrors;
   int compileWarnings;
 
-  MainWindow(const QStringList& filenames);
-  ~MainWindow() override;
+  MainWindow (const QStringList &filenames);
+  ~MainWindow () override;
 
 private:
   RubberBandManager rubberBandManager;
@@ -129,272 +129,273 @@ private:
   std::vector<std::tuple<Dock *, QString>> docks;
 
   volatile bool isClosing = false;
-  void consoleOutputRaw(const QString& msg);
-  void clearAllSelectionIndicators();
-  void setSelectionIndicatorStatus(EditorInterface *editor, int nodeIndex, EditorSelectionIndicatorStatus status);
+  void consoleOutputRaw (const QString &msg);
+  void clearAllSelectionIndicators ();
+  void setSelectionIndicatorStatus (EditorInterface *editor, int nodeIndex, EditorSelectionIndicatorStatus status);
 
 protected:
-  void closeEvent(QCloseEvent *event) override;
+  void closeEvent (QCloseEvent *event) override;
 
 private slots:
-  void updateUndockMode(bool undockMode);
-  void updateReorderMode(bool reorderMode);
-  void setFont(const QString& family, uint size);
-  void setColorScheme(const QString& cs);
-  void showProgress();
-  void openCSGSettingsChanged();
-  void consoleOutput(const Message& msgObj);
-  void setSelection(int index);
+  void updateUndockMode (bool undockMode);
+  void updateReorderMode (bool reorderMode);
+  void setFont (const QString &family, uint size);
+  void setColorScheme (const QString &cs);
+  void showProgress ();
+  void openCSGSettingsChanged ();
+  void consoleOutput (const Message &msgObj);
+  void setSelection (int index);
 
   // implements the actions to be done when the selection menu is closing
   // the seclection menu is the one that show up when right click on the geometry in the 3d view.
-  void onHoveredObjectInSelectionMenu();
+  void onHoveredObjectInSelectionMenu ();
 
-  void measureFinished();
-  void errorLogOutput(const Message& log_msg);
-  void onNavigationOpenContextMenu();
-  void onNavigationCloseContextMenu();
-  void onNavigationHoveredContextMenuEntry();
-  void onNavigationTriggerContextMenuEntry();
+  void measureFinished ();
+  void errorLogOutput (const Message &log_msg);
+  void onNavigationOpenContextMenu ();
+  void onNavigationCloseContextMenu ();
+  void onNavigationHoveredContextMenuEntry ();
+  void onNavigationTriggerContextMenuEntry ();
 
   // implement the different actions needed when
   // the tab manager editor is changed.
-  void onTabManagerEditorChanged(EditorInterface *);
+  void onTabManagerEditorChanged (EditorInterface *);
 
   // implement the different actions needed when
   // the tab manager editor is about to close one of the tab
-  void onTabManagerAboutToCloseEditor(EditorInterface *);
+  void onTabManagerAboutToCloseEditor (EditorInterface *);
 
   // implement the different actions needed when an editor
   // has its content replaced (because of load)
-  void onTabManagerEditorContentReloaded(EditorInterface *reloadedEditor);
+  void onTabManagerEditorContentReloaded (EditorInterface *reloadedEditor);
 
 public:
-  static void consoleOutput(const Message& msgObj, void *userdata);
-  static void errorLogOutput(const Message& log_msg, void *userdata);
-  static void noOutputConsole(const Message&, void *) {} // /dev/null
-  static void noOutputErrorLog(const Message&, void *) {} // /dev/null
+  static void consoleOutput (const Message &msgObj, void *userdata);
+  static void errorLogOutput (const Message &log_msg, void *userdata);
+  static void noOutputConsole (const Message &, void *) {} // /dev/null
+  static void noOutputErrorLog (const Message &, void *) {} // /dev/null
 
-  bool fileChangedOnDisk();
+  bool fileChangedOnDisk ();
 
   // Parse the document contained in the editor, update the editors's parameters and returns a SourceFile object
   // if parsing suceeded. Nullptr otherwise.
-  SourceFile *parseDocument(EditorInterface *editor);
+  SourceFile *parseDocument (EditorInterface *editor);
 
-  void parseTopLevelDocument();
-  void exceptionCleanup();
-  void setLastFocus(QWidget *widget);
-  void UnknownExceptionCleanup(std::string msg = "");
-  void showFind(bool doFindAndReplace);
+  void parseTopLevelDocument ();
+  void exceptionCleanup ();
+  void setLastFocus (QWidget *widget);
+  void UnknownExceptionCleanup (std::string msg = "");
+  void showFind (bool doFindAndReplace);
 
 private:
-  [[nodiscard]] QString getCurrentFileName() const;
+  [[nodiscard]] QString getCurrentFileName () const;
 
-  void setRenderVariables(ContextHandle<BuiltinContext>& context);
-  void updateCompileResult();
-  void compile(bool reload, bool forcedone = false);
-  void compileCSG();
-  bool checkEditorModified();
-  QString dumpCSGTree(const std::shared_ptr<AbstractNode>& root);
+  void setRenderVariables (ContextHandle<BuiltinContext> &context);
+  void updateCompileResult ();
+  void compile (bool reload, bool forcedone = false);
+  void compileCSG ();
+  bool checkEditorModified ();
+  QString dumpCSGTree (const std::shared_ptr<AbstractNode> &root);
 
   // Opens an independent windows with a text area showing the text given in argument
   // The "type" is used to specify the type of content with the title of the window,
-  void showTextInWindow(const QString& type, const QString& textToShow);
+  void showTextInWindow (const QString &type, const QString &textToShow);
 
   // Change the perspective mode of the 3D view.
   typedef Camera::ProjectionType ProjectionType;
-  void setProjectionType(ProjectionType mode);
-
-  void loadViewSettings();
-  void loadDesignSettings();
-  void prepareCompile(const char *afterCompileSlot, bool procevents, bool preview);
-  void updateWindowSettings(bool console, bool editor, bool customizer, bool errorLog, bool editorToolbar, bool viewToolbar, bool animate, bool fontList, bool ViewportControlWidget);
-  void saveBackup();
-  void writeBackup(QFile *file);
-  void show_examples();
-  void addKeyboardShortCut(const QList<QAction *>& actions);
-  void updateStatusBar(ProgressWidget *progressWidget);
-  void activateDock(Dock *);
-  Dock *findVisibleDockToActivate(int offset) const;
-  Dock *getNextDockFromSender(QObject *sender);
+  void setProjectionType (ProjectionType mode);
+
+  void loadViewSettings ();
+  void loadDesignSettings ();
+  void prepareCompile (const char *afterCompileSlot, bool procevents, bool preview);
+  void updateWindowSettings (bool console, bool editor, bool customizer, bool errorLog, bool editorToolbar, bool viewToolbar, bool animate, bool fontList, bool ViewportControlWidget);
+  void saveBackup ();
+  void writeBackup (QFile *file);
+  void show_examples ();
+  void addKeyboardShortCut (const QList<QAction *> &actions);
+  void updateStatusBar (ProgressWidget *progressWidget);
+  void activateDock (Dock *);
+  Dock *findVisibleDockToActivate (int offset) const;
+  Dock *getNextDockFromSender (QObject *sender);
 
   LibraryInfoDialog *libraryInfoDialog{nullptr};
   FontListDialog *fontListDialog{nullptr};
   QSignalMapper *exportFormatMapper;
 
 public slots:
-  void updateExportActions();
-  void updateRecentFiles(const QString& FileSavedOrOpened);
-  void updateRecentFileActions();
-  void handleFileDrop(const QUrl& url);
+  void updateExportActions ();
+  void updateRecentFiles (const QString &FileSavedOrOpened);
+  void updateRecentFileActions ();
+  void handleFileDrop (const QUrl &url);
 
 private slots:
-  void actionOpen();
-  void actionNewWindow();
-  void actionOpenWindow();
-  void actionOpenRecent();
-  void actionOpenExample();
-  void clearRecentFiles();
-  void actionSave();
-  void actionSaveAs();
-  void actionPythonRevokeTrustedFiles();
-  void actionPythonCreateVenv();
-  void actionPythonSelectVenv();
-  void actionSaveACopy();
-  void actionReload();
-  void actionShowLibraryFolder();
-  void convertTabsToSpaces();
-  void copyText();
-
-  void instantiateRoot();
-  void compileDone(bool didchange);
-  void compileEnded();
-  void changeParameterWidget();
+  void actionOpen ();
+  void actionNewWindow ();
+  void actionOpenWindow ();
+  void actionOpenRecent ();
+  void actionOpenExample ();
+  void clearRecentFiles ();
+  void actionSave ();
+  void actionSaveAs ();
+  void actionPythonRevokeTrustedFiles ();
+  void actionPythonCreateVenv ();
+  void actionPythonSelectVenv ();
+  void actionSaveACopy ();
+  void actionReload ();
+  void actionShowLibraryFolder ();
+  void convertTabsToSpaces ();
+  void copyText ();
+
+  void instantiateRoot ();
+  void compileDone (bool didchange);
+  void compileEnded ();
+  void changeParameterWidget ();
 
 private slots:
-  void copyViewportTranslation();
-  void copyViewportRotation();
-  void copyViewportDistance();
-  void copyViewportFov();
-  void preferences();
-  void hideEditorToolbar();
-  void hide3DViewToolbar();
-  void showLink(const QString&);
+  void copyViewportTranslation ();
+  void copyViewportRotation ();
+  void copyViewportDistance ();
+  void copyViewportFov ();
+  void preferences ();
+  void hideEditorToolbar ();
+  void hide3DViewToolbar ();
+  void showLink (const QString &);
 
   // Handle the Next/Prev dock menu action when the is hovered, currently this activate the rubberband
-  void onWindowActionNextPrevHovered();
+  void onWindowActionNextPrevHovered ();
 
   // Handle the Next/Prev dock menu action when the is validatee, currently switch to the targetted dock
   // and remove the rubberband
-  void onWindowActionNextPrevTriggered();
+  void onWindowActionNextPrevTriggered ();
 
   // Handle the Next/Prev shortcut, currently switch to the targetted dock
   // and adds the rubberband, the rubbreband is removed on shortcut key release.
-  void onWindowShortcutNextPrevActivated();
+  void onWindowShortcutNextPrevActivated ();
 
-  void onEditorDockVisibilityChanged(bool isVisible);
-  void onConsoleDockVisibilityChanged(bool isVisible);
-  void onErrorLogDockVisibilityChanged(bool isVisible);
-  void onAnimateDockVisibilityChanged(bool isVisible);
-  void onFontListDockVisibilityChanged(bool isVisible);
-  void onViewportControlDockVisibilityChanged(bool isVisible);
-  void onParametersDockVisibilityChanged(bool isVisible);
+  void onEditorDockVisibilityChanged (bool isVisible);
+  void onConsoleDockVisibilityChanged (bool isVisible);
+  void onErrorLogDockVisibilityChanged (bool isVisible);
+  void onAnimateDockVisibilityChanged (bool isVisible);
+  void onFontListDockVisibilityChanged (bool isVisible);
+  void onViewportControlDockVisibilityChanged (bool isVisible);
+  void onParametersDockVisibilityChanged (bool isVisible);
 
-  void on_editActionInsertTemplate_triggered();
-  void on_editActionFoldAll_triggered();
+  void on_editActionInsertTemplate_triggered ();
+  void on_editActionFoldAll_triggered ();
 
 public slots:
-  void hideFind();
-  void actionShowFind();
-  void actionShowFindAndReplace();
+  void hideFind ();
+  void actionShowFind ();
+  void actionShowFindAndReplace ();
 
 private slots:
-  void actionSelectFind(int);
-  void findString(const QString&);
-  void findNext();
-  void findPrev();
-  void useSelectionForFind();
-  void replace();
-  void replaceAll();
+  void actionSelectFind (int);
+  void findString (const QString &);
+  void findNext ();
+  void findPrev ();
+  void useSelectionForFind ();
+  void replace ();
+  void replaceAll ();
 
   // Mac OSX FindBuffer support
-  void findBufferChanged();
-  void updateFindBuffer(const QString&);
-  bool event(QEvent *event) override;
+  void findBufferChanged ();
+  void updateFindBuffer (const QString &);
+  bool event (QEvent *event) override;
+
 protected:
-  bool eventFilter(QObject *obj, QEvent *event) override;
+  bool eventFilter (QObject *obj, QEvent *event) override;
 
 public slots:
-  void actionRenderPreview();
+  void actionRenderPreview ();
 private slots:
-  void csgRender();
-  void csgReloadRender();
-  void action3DPrint();
-  void sendToExternalTool(class ExternalToolInterface &externalToolService);
-  void actionRender();
-  void actionRenderDone(const std::shared_ptr<const Geometry>&);
-  void cgalRender();
-  void actionMeasureDistance();
-  void actionMeasureAngle();
-  void actionCheckValidity();
-  void actionDisplayAST();
-  void actionDisplayCSGTree();
-  void actionDisplayCSGProducts();
-  bool canExport(unsigned int dim);
-  void actionExport(unsigned int dim, ExportInfo& exportInfo);
-  void actionExportFileFormat(int fmt);
-  void actionCopyViewport();
-  void actionFlushCaches();
+  void csgRender ();
+  void csgReloadRender ();
+  void action3DPrint ();
+  void sendToExternalTool (class ExternalToolInterface &externalToolService);
+  void actionRender ();
+  void actionRenderDone (const std::shared_ptr<const Geometry> &);
+  void cgalRender ();
+  void actionMeasureDistance ();
+  void actionMeasureAngle ();
+  void actionCheckValidity ();
+  void actionDisplayAST ();
+  void actionDisplayCSGTree ();
+  void actionDisplayCSGProducts ();
+  bool canExport (unsigned int dim);
+  void actionExport (unsigned int dim, ExportInfo &exportInfo);
+  void actionExportFileFormat (int fmt);
+  void actionCopyViewport ();
+  void actionFlushCaches ();
 
 public:
-  void viewModeActionsUncheck();
-  void setCurrentOutput();
-  void clearCurrentOutput();
-  void hideCurrentOutput();
-  bool isEmpty();
-
-  void onAxisChanged(InputEventAxisChanged *event) override;
-  void onButtonChanged(InputEventButtonChanged *event) override;
-
-  void onTranslateEvent(InputEventTranslate *event) override;
-  void onRotateEvent(InputEventRotate *event) override;
-  void onRotate2Event(InputEventRotate2 *event) override;
-  void onActionEvent(InputEventAction *event) override;
-  void onZoomEvent(InputEventZoom *event) override;
-
-  QList<double> getTranslation() const;
-  QList<double> getRotation() const;
+  void viewModeActionsUncheck ();
+  void setCurrentOutput ();
+  void clearCurrentOutput ();
+  void hideCurrentOutput ();
+  bool isEmpty ();
+
+  void onAxisChanged (InputEventAxisChanged *event) override;
+  void onButtonChanged (InputEventButtonChanged *event) override;
+
+  void onTranslateEvent (InputEventTranslate *event) override;
+  void onRotateEvent (InputEventRotate *event) override;
+  void onRotate2Event (InputEventRotate2 *event) override;
+  void onActionEvent (InputEventAction *event) override;
+  void onZoomEvent (InputEventZoom *event) override;
+
+  QList<double> getTranslation () const;
+  QList<double> getRotation () const;
   std::unordered_map<FileFormat, QAction *> exportMap;
 
 public slots:
-  void actionReloadRenderPreview();
-  void on_toolButtonCompileResultClose_clicked();
-  void processEvents();
-  void jumpToLine(int, int);
-  void openFileFromPath(const QString&, int);
+  void actionReloadRenderPreview ();
+  void on_toolButtonCompileResultClose_clicked ();
+  void processEvents ();
+  void jumpToLine (int, int);
+  void openFileFromPath (const QString &, int);
 
-  void viewModeRender();
+  void viewModeRender ();
 #ifdef ENABLE_OPENCSG
-  void viewModePreview();
+  void viewModePreview ();
 #endif
-  void viewModeThrownTogether();
-  void viewModeShowEdges();
-  void viewModeShowAxes();
-  void viewModeShowCrosshairs();
-  void viewModeShowScaleProportional();
-  void viewAngleTop();
-  void viewAngleBottom();
-  void viewAngleLeft();
-  void viewAngleRight();
-  void viewAngleFront();
-  void viewAngleBack();
-  void viewAngleDiagonal();
-  void viewCenter();
-  void viewPerspective();
-  void viewOrthogonal();
-  void viewTogglePerspective();
-  void viewResetView();
-  void viewAll();
-  void editorContentChanged();
-  void leftClick(QPoint coordinate);
-  void rightClick(QPoint coordinate);
-  void dragEnterEvent(QDragEnterEvent *event) override;
-  void dropEvent(QDropEvent *event) override;
-  void helpAbout();
-  void helpHomepage();
-  void helpManual();
-  void helpOfflineManual();
-  void helpCheatSheet();
-  void helpOfflineCheatSheet();
-  void helpLibrary();
-  void helpFontInfo();
-  void checkAutoReload();
-  void waitAfterReload();
-  void autoReloadSet(bool);
+  void viewModeThrownTogether ();
+  void viewModeShowEdges ();
+  void viewModeShowAxes ();
+  void viewModeShowCrosshairs ();
+  void viewModeShowScaleProportional ();
+  void viewAngleTop ();
+  void viewAngleBottom ();
+  void viewAngleLeft ();
+  void viewAngleRight ();
+  void viewAngleFront ();
+  void viewAngleBack ();
+  void viewAngleDiagonal ();
+  void viewCenter ();
+  void viewPerspective ();
+  void viewOrthogonal ();
+  void viewTogglePerspective ();
+  void viewResetView ();
+  void viewAll ();
+  void editorContentChanged ();
+  void leftClick (QPoint coordinate);
+  void rightClick (QPoint coordinate);
+  void dragEnterEvent (QDragEnterEvent *event) override;
+  void dropEvent (QDropEvent *event) override;
+  void helpAbout ();
+  void helpHomepage ();
+  void helpManual ();
+  void helpOfflineManual ();
+  void helpCheatSheet ();
+  void helpOfflineCheatSheet ();
+  void helpLibrary ();
+  void helpFontInfo ();
+  void checkAutoReload ();
+  void waitAfterReload ();
+  void autoReloadSet (bool);
 
 private:
-  bool network_progress_func(const double permille);
-  static void report_func(const std::shared_ptr<const AbstractNode>&, void *vp, int mark);
+  bool network_progress_func (const double permille);
+  static void report_func (const std::shared_ptr<const AbstractNode> &, void *vp, int mark);
   static bool undockMode;
   static bool reorderMode;
   static const int tabStopWidth;
@@ -406,7 +407,7 @@ private:
   std::shared_ptr<CSGProducts> rootProduct;
   std::shared_ptr<CSGProducts> highlightsProducts;
   std::shared_ptr<CSGProducts> backgroundProducts;
-  int currentlySelectedObject {-1};
+  int currentlySelectedObject{-1};
 
   char const *afterCompileSlot;
   bool procevents{false};
@@ -418,45 +419,46 @@ private:
   time_t includesMTime{0}; // latest include mod time
   time_t depsMTime{0}; // latest dependency mod time
   std::unordered_map<QString, QString> exportPaths; // for each file type, where it was exported to last
-  QString exportPath(const QString& suffix); // look up the last export path and generate one if not found
+  QString exportPath (const QString &suffix); // look up the last export path and generate one if not found
   int lastParserErrorPos{-1}; // last highlighted error position
   int tabCount = 0;
-  ExportPdfPaperSize sizeString2Enum(const QString& current);
-  ExportPdfPaperOrientation orientationsString2Enum(const QString& current);
+  ExportPdfPaperSize sizeString2Enum (const QString &current);
+  ExportPdfPaperOrientation orientationsString2Enum (const QString &current);
 
   QMenu *navigationMenu{nullptr};
   QSoundEffect *renderCompleteSoundEffect;
   std::vector<std::unique_ptr<QTemporaryFile>> allTempFiles;
 
 signals:
-  void highlightError(int);
-  void unhighlightLastError();
+  void highlightError (int);
+  void unhighlightLastError ();
 
 #ifdef ENABLE_GUI_TESTS
 public:
-  std::shared_ptr<AbstractNode> instantiateRootFromSource(SourceFile *file);
+  std::shared_ptr<AbstractNode> instantiateRootFromSource (SourceFile *file);
 signals:
   // This is a new signal introduced while drafting the testing framework, while in experimental mode
   // we protected it using the #ifdef/endif so it should not be considered as part of the MainWindow API.
-  void compilationDone(SourceFile *);
+  void compilationDone (SourceFile *);
 #endif //
-
 };
 
 class GuiLocker
 {
 public:
-  GuiLocker() {
-    GuiLocker::lock();
+  GuiLocker () {
+    GuiLocker::lock ();
+  }
+  ~GuiLocker () {
+    GuiLocker::unlock ();
   }
-  ~GuiLocker() {
-    GuiLocker::unlock();
+  static bool isLocked () {
+    return guiLocked > 0;
   }
-  static bool isLocked() { return guiLocked > 0; }
-  static void lock() {
+  static void lock () {
     guiLocked++;
   }
-  static void unlock() {
+  static void unlock () {
     guiLocked--;
   }
 
diff --git a/src/gui/Measurement.cc b/src/gui/Measurement.cc
index 579e51478..c60ac3153 100644
--- a/src/gui/Measurement.cc
+++ b/src/gui/Measurement.cc
@@ -32,118 +32,121 @@
 #include <cmath>
 #include <sstream>
 
-Measurement::Measurement()
-{
+Measurement::Measurement () {
 }
 
-void Measurement::setView(QGLView *qglview) {
+void Measurement::setView (QGLView *qglview) {
   this->qglview = qglview;
   this->qglview->measure_state = MEASURE_IDLE;
 }
 
-void Measurement::startMeasureDist(void)
-{
-  this->qglview->selected_obj.clear();
-  this->qglview->update();
+void Measurement::startMeasureDist (void) {
+  this->qglview->selected_obj.clear ();
+  this->qglview->update ();
   this->qglview->measure_state = MEASURE_DIST1;
 }
 
-void Measurement::startMeasureAngle(void)
-{
-  this->qglview->selected_obj.clear();
-  this->qglview->update();
+void Measurement::startMeasureAngle (void) {
+  this->qglview->selected_obj.clear ();
+  this->qglview->update ();
   this->qglview->measure_state = MEASURE_ANG1;
 }
 
-void Measurement::stopMeasure()
-{
-  qglview->selected_obj.clear();
-  qglview->shown_obj.clear();
-  qglview->update();
+void Measurement::stopMeasure () {
+  qglview->selected_obj.clear ();
+  qglview->shown_obj.clear ();
+  qglview->update ();
   qglview->measure_state = MEASURE_IDLE;
 }
 
-QString Measurement::statemachine(QPoint mouse)
-{
-  if (qglview->measure_state == MEASURE_IDLE)return "";
-  qglview->selectPoint(mouse.x(), mouse.y());
+QString Measurement::statemachine (QPoint mouse) {
+  if (qglview->measure_state == MEASURE_IDLE)
+    return "";
+  qglview->selectPoint (mouse.x (), mouse.y ());
   double ang = NAN;
   double dist = NAN;
   SelectedObject obj1, obj2, obj3;
   switch (qglview->measure_state) {
   case MEASURE_DIST1:
-    if (qglview->selected_obj.size() == 1) qglview->measure_state = MEASURE_DIST2;
+    if (qglview->selected_obj.size () == 1)
+      qglview->measure_state = MEASURE_DIST2;
     break;
   case MEASURE_DIST2:
-    if (qglview->selected_obj.size() == 2){
+    if (qglview->selected_obj.size () == 2) {
       double lat;
       obj1 = qglview->selected_obj[0];
       obj2 = qglview->selected_obj[1];
-      if (obj1.type == SelectionType::SELECTION_POINT && obj2.type == SelectionType::SELECTION_POINT) dist = (obj2.p1 - obj1.p1).norm();
-      if (obj1.type == SelectionType::SELECTION_POINT && obj2.type == SelectionType::SELECTION_LINE) dist = calculateLinePointDistance(obj2.p1, obj2.p2, obj1.p1, lat);
-      if (obj1.type == SelectionType::SELECTION_LINE && obj2.type == SelectionType::SELECTION_POINT) dist = calculateLinePointDistance(obj1.p1, obj1.p2, obj2.p1, lat);
-      if (obj1.type == SelectionType::SELECTION_LINE && obj2.type == SelectionType::SELECTION_LINE) dist = calculateSegSegDistance(obj1.p1, obj1.p2, obj2.p1, obj2.p2, lat);
-      if (!std::isnan(dist)) {
-        return QString("Distance is %1").arg(fabs(dist));
+      if (obj1.type == SelectionType::SELECTION_POINT && obj2.type == SelectionType::SELECTION_POINT)
+        dist = (obj2.p1 - obj1.p1).norm ();
+      if (obj1.type == SelectionType::SELECTION_POINT && obj2.type == SelectionType::SELECTION_LINE)
+        dist = calculateLinePointDistance (obj2.p1, obj2.p2, obj1.p1, lat);
+      if (obj1.type == SelectionType::SELECTION_LINE && obj2.type == SelectionType::SELECTION_POINT)
+        dist = calculateLinePointDistance (obj1.p1, obj1.p2, obj2.p1, lat);
+      if (obj1.type == SelectionType::SELECTION_LINE && obj2.type == SelectionType::SELECTION_LINE)
+        dist = calculateSegSegDistance (obj1.p1, obj1.p2, obj2.p1, obj2.p2, lat);
+      if (!std::isnan (dist)) {
+        return QString ("Distance is %1").arg (fabs (dist));
       }
-      stopMeasure();
+      stopMeasure ();
     }
     break;
   case MEASURE_ANG1:
-    if (qglview->selected_obj.size() == 1) qglview->measure_state = MEASURE_ANG2;
+    if (qglview->selected_obj.size () == 1)
+      qglview->measure_state = MEASURE_ANG2;
     break;
   case MEASURE_ANG2:
-    if (qglview->selected_obj.size() == 2){
+    if (qglview->selected_obj.size () == 2) {
       obj1 = qglview->selected_obj[0];
       obj2 = qglview->selected_obj[1];
       Vector3d side1, side2;
-      if (obj1.type == SelectionType::SELECTION_LINE && obj2.type == SelectionType::SELECTION_POINT){
-        side1 = (obj1.p2 - obj1.p1).normalized();
-        side2 = (obj1.p2 - obj2.p1).normalized();
-        ang = acos(side1.dot(side2)) * 180.0 / 3.14159265359;
+      if (obj1.type == SelectionType::SELECTION_LINE && obj2.type == SelectionType::SELECTION_POINT) {
+        side1 = (obj1.p2 - obj1.p1).normalized ();
+        side2 = (obj1.p2 - obj2.p1).normalized ();
+        ang = acos (side1.dot (side2)) * 180.0 / 3.14159265359;
         goto display_angle;
       } else if (obj1.type == SelectionType::SELECTION_POINT && obj2.type == SelectionType::SELECTION_LINE) {
-        side1 = (obj2.p2 - obj2.p1).normalized();
-        side2 = (obj2.p2 - obj1.p1).normalized();
-        ang = acos(side1.dot(side2)) * 180.0 / 3.14159265359;
+        side1 = (obj2.p2 - obj2.p1).normalized ();
+        side2 = (obj2.p2 - obj1.p1).normalized ();
+        ang = acos (side1.dot (side2)) * 180.0 / 3.14159265359;
         goto display_angle;
       } else if (obj1.type == SelectionType::SELECTION_LINE && obj2.type == SelectionType::SELECTION_LINE) {
         // Check all 4 permutations of the lines' directions and use the one where the starting points are closest to one another as the corner point for the angle
         double nearestDist = INFINITY;
-        auto permutation = [&nearestDist, &side1, &side2](const Vector3d& s1s, const Vector3d& s1e, const Vector3d& s2s, const Vector3d& s2e) {
-            double dist = (s1s - s2s).squaredNorm();
-            if (dist < nearestDist) {
-              nearestDist = dist;
-              side1 = (s1e - s1s).normalized();
-              side2 = (s2e - s2s).normalized();
-            }
-          };
+        auto permutation = [&nearestDist, &side1, &side2] (const Vector3d &s1s, const Vector3d &s1e, const Vector3d &s2s, const Vector3d &s2e) {
+          double dist = (s1s - s2s).squaredNorm ();
+          if (dist < nearestDist) {
+            nearestDist = dist;
+            side1 = (s1e - s1s).normalized ();
+            side2 = (s2e - s2s).normalized ();
+          }
+        };
 
-        permutation(obj1.p1, obj1.p2, obj2.p1, obj2.p2);
-        permutation(obj1.p2, obj1.p1, obj2.p1, obj2.p2);
-        permutation(obj1.p1, obj1.p2, obj2.p2, obj2.p1);
-        permutation(obj1.p2, obj1.p1, obj2.p2, obj2.p1);
+        permutation (obj1.p1, obj1.p2, obj2.p1, obj2.p2);
+        permutation (obj1.p2, obj1.p1, obj2.p1, obj2.p2);
+        permutation (obj1.p1, obj1.p2, obj2.p2, obj2.p1);
+        permutation (obj1.p2, obj1.p1, obj2.p2, obj2.p1);
 
-        ang = acos(side1.dot(side2)) * 180.0 / 3.14159265359;
+        ang = acos (side1.dot (side2)) * 180.0 / 3.14159265359;
         goto display_angle;
-      } else qglview->measure_state = MEASURE_ANG3;
+      } else
+        qglview->measure_state = MEASURE_ANG3;
     }
     break;
   case MEASURE_ANG3:
-    if (qglview->selected_obj.size() == 3){
+    if (qglview->selected_obj.size () == 3) {
       obj1 = qglview->selected_obj[0];
       obj2 = qglview->selected_obj[1];
       obj3 = qglview->selected_obj[2];
-      if (obj1.type == SelectionType::SELECTION_POINT && obj2.type == SelectionType::SELECTION_POINT && obj3.type == SelectionType::SELECTION_POINT){
-        Vector3d side1 = (obj2.p1 - obj1.p1).normalized();
-        Vector3d side2 = (obj2.p1 - obj3.p1).normalized();
-        ang = acos(side1.dot(side2)) * 180.0 / 3.14159265359;
+      if (obj1.type == SelectionType::SELECTION_POINT && obj2.type == SelectionType::SELECTION_POINT && obj3.type == SelectionType::SELECTION_POINT) {
+        Vector3d side1 = (obj2.p1 - obj1.p1).normalized ();
+        Vector3d side2 = (obj2.p1 - obj3.p1).normalized ();
+        ang = acos (side1.dot (side2)) * 180.0 / 3.14159265359;
       }
-display_angle:
-      if (!std::isnan(ang)){
-        return QString("Angle  is %1 Degrees").arg(ang);
+    display_angle:
+      if (!std::isnan (ang)) {
+        return QString ("Angle  is %1 Degrees").arg (ang);
       }
-      stopMeasure();
+      stopMeasure ();
     }
     break;
   }
diff --git a/src/gui/Measurement.h b/src/gui/Measurement.h
index 21254b65a..23e777638 100644
--- a/src/gui/Measurement.h
+++ b/src/gui/Measurement.h
@@ -6,21 +6,27 @@
 #include "geometry/linalg.h"
 #include "gui/QGLView.h"
 
-enum { MEASURE_IDLE, MEASURE_DIST1, MEASURE_DIST2, MEASURE_ANG1, MEASURE_ANG2, MEASURE_ANG3 };
+enum { MEASURE_IDLE,
+       MEASURE_DIST1,
+       MEASURE_DIST2,
+       MEASURE_ANG1,
+       MEASURE_ANG2,
+       MEASURE_ANG3 };
 
-extern double calculateLinePointDistance(const Vector3d& l1, const Vector3d& l2, const Vector3d& pt, double& dist_lat);
-extern double calculateLineLineDistance(const Vector3d& l1b, const Vector3d& l1e, const Vector3d& l2b, const Vector3d& l2e, double& dist_lat);
-extern double calculateSegSegDistance(const Vector3d& l1b, const Vector3d& l1e, const Vector3d& l2b, const Vector3d& l2e, double& dist_lat);
+extern double calculateLinePointDistance (const Vector3d &l1, const Vector3d &l2, const Vector3d &pt, double &dist_lat);
+extern double calculateLineLineDistance (const Vector3d &l1b, const Vector3d &l1e, const Vector3d &l2b, const Vector3d &l2e, double &dist_lat);
+extern double calculateSegSegDistance (const Vector3d &l1b, const Vector3d &l1e, const Vector3d &l2b, const Vector3d &l2e, double &dist_lat);
 
 class Measurement
 {
 public:
-  Measurement(void);
-  void setView(QGLView *qglview);
-  QString statemachine(QPoint mouse);
-  void startMeasureDist(void);
-  void startMeasureAngle(void);
-  void stopMeasure();
+  Measurement (void);
+  void setView (QGLView *qglview);
+  QString statemachine (QPoint mouse);
+  void startMeasureDist (void);
+  void startMeasureAngle (void);
+  void stopMeasure ();
+
 private:
   QGLView *qglview;
 };
diff --git a/src/gui/MouseSelector.cc b/src/gui/MouseSelector.cc
index cbbb5df67..c1b5220ef 100644
--- a/src/gui/MouseSelector.cc
+++ b/src/gui/MouseSelector.cc
@@ -19,39 +19,40 @@
  * might do "fancy" optimization.
  */
 
-MouseSelector::MouseSelector(GLView *view) {
+MouseSelector::MouseSelector (GLView *view) {
   this->view = view;
-  if (view) this->reset(view);
+  if (view)
+    this->reset (view);
 }
 
 /**
  * Resize the framebuffer whenever it changed
  */
-void MouseSelector::reset(GLView *view) {
+void MouseSelector::reset (GLView *view) {
   this->view = view;
-  this->setupFramebuffer(view->cam.pixel_width, view->cam.pixel_height);
+  this->setupFramebuffer (view->cam.pixel_width, view->cam.pixel_height);
 }
 
 /**
  * Initialize the used shaders and setup the ShaderInfo struct
  */
-void MouseSelector::initShader() {
+void MouseSelector::initShader () {
   // Attributes:
   // frag_idcolor - (uniform) 24 bit of the selected object's id encoded into R/G/B components as float values
-  const auto selectshader = ShaderUtils::compileShaderProgram(
-    ShaderUtils::loadShaderSource("MouseSelector.vert"),
-    ShaderUtils::loadShaderSource("MouseSelector.frag"));
+  const auto selectshader = ShaderUtils::compileShaderProgram (
+    ShaderUtils::loadShaderSource ("MouseSelector.vert"),
+    ShaderUtils::loadShaderSource ("MouseSelector.frag"));
 
-  const GLint frag_idcolor = glGetUniformLocation(selectshader.shader_program, "frag_idcolor");
+  const GLint frag_idcolor = glGetUniformLocation (selectshader.shader_program, "frag_idcolor");
   if (frag_idcolor < 0) {
     // TODO: Surface error better
-    fprintf(stderr, __FILE__ ": OpenGL symbol retrieval went wrong, id is %i\n\n", frag_idcolor);
+    fprintf (stderr, __FILE__ ": OpenGL symbol retrieval went wrong, id is %i\n\n", frag_idcolor);
   }
   this->shaderinfo = {
     .resource = selectshader,
     .type = ShaderUtils::ShaderType::SELECT_RENDERING,
     .uniforms = {
-      {"frag_idcolor", glGetUniformLocation(selectshader.shader_program, "frag_idcolor")},
+      {"frag_idcolor", glGetUniformLocation (selectshader.shader_program, "frag_idcolor")},
     },
   };
 }
@@ -59,16 +60,16 @@ void MouseSelector::initShader() {
 /**
  * Resize or create the framebuffer
  */
-void MouseSelector::setupFramebuffer(int width, int height) {
+void MouseSelector::setupFramebuffer (int width, int height) {
   if (!this->framebuffer ||
-      this->framebuffer->width() != width ||
-      this->framebuffer->height() != height) {
-    this->framebuffer = createFBO(width, height);
+      this->framebuffer->width () != width ||
+      this->framebuffer->height () != height) {
+    this->framebuffer = createFBO (width, height);
     // We bind the framebuffer before initializing shaders since
     // shader validation requires a valid framebuffer.
-    this->framebuffer->bind();
-    this->initShader();
-    this->framebuffer->unbind();
+    this->framebuffer->bind ();
+    this->initShader ();
+    this->framebuffer->unbind ();
   }
 }
 
@@ -79,7 +80,7 @@ void MouseSelector::setupFramebuffer(int width, int height) {
  *
  * returns index of picked node (AbstractNode::idx) or -1 if no object was found.
  */
-int MouseSelector::select(const Renderer *renderer, int x, int y) {
+int MouseSelector::select (const Renderer *renderer, int x, int y) {
   // This function should render a frame, as usual, with the following changes:
   // * Render to as custom framebuffer
   // * The shader should be the selector shader
@@ -100,39 +101,39 @@ int MouseSelector::select(const Renderer *renderer, int x, int y) {
   // of the currently selected frame.
   // For now, i will use a texture the same size as the normal viewport
   // and select the identifier at the mouse coordinates
-  GL_CHECKD(this->framebuffer->bind());
+  GL_CHECKD (this->framebuffer->bind ());
 
-  glClearColor(0, 0, 0, 1.0);
-  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
+  glClearColor (0, 0, 0, 1.0);
+  glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
 
-  glViewport(0, 0, width, height);
-  this->view->setupCamera();
-  glTranslated(this->view->cam.object_trans.x(),
-               this->view->cam.object_trans.y(),
-               this->view->cam.object_trans.z());
+  glViewport (0, 0, width, height);
+  this->view->setupCamera ();
+  glTranslated (this->view->cam.object_trans.x (),
+                this->view->cam.object_trans.y (),
+                this->view->cam.object_trans.z ());
 
-  glDisable(GL_LIGHTING);
-  glDepthFunc(GL_LESS);
-  glCullFace(GL_BACK);
-  glDisable(GL_CULL_FACE);
-  glEnable(GL_DEPTH_TEST);
+  glDisable (GL_LIGHTING);
+  glDepthFunc (GL_LESS);
+  glCullFace (GL_BACK);
+  glDisable (GL_CULL_FACE);
+  glEnable (GL_DEPTH_TEST);
 
   // call the renderer with the selector shader
-  GL_CHECKD(renderer->draw(false, &this->shaderinfo));
+  GL_CHECKD (renderer->draw (false, &this->shaderinfo));
 
   // Not strictly necessary, but a nop if not required.
-  glFlush();
-  glFinish();
+  glFlush ();
+  glFinish ();
 
   // Grab the color from the framebuffer and convert it back to an identifier
-  GLubyte color[3] = { 0 };
+  GLubyte color[3] = {0};
   // Qt position is originated top-left, so flip y to get GL coordinates.
-  GL_CHECKD(glReadPixels(x, height - y, 1, 1, GL_RGB, GL_UNSIGNED_BYTE, color));
+  GL_CHECKD (glReadPixels (x, height - y, 1, 1, GL_RGB, GL_UNSIGNED_BYTE, color));
 
   const int index = (uint32_t)color[0] | ((uint32_t)color[1] << 8) | ((uint32_t)color[2] << 16);
 
   // Switch the active framebuffer back to the default
-  this->framebuffer->unbind();
+  this->framebuffer->unbind ();
 
   return index;
 }
diff --git a/src/gui/MouseSelector.h b/src/gui/MouseSelector.h
index dbfc6a8b5..bb26e6b52 100644
--- a/src/gui/MouseSelector.h
+++ b/src/gui/MouseSelector.h
@@ -12,18 +12,18 @@
 class MouseSelector
 {
 public:
-  MouseSelector(GLView *view);
+  MouseSelector (GLView *view);
 
   /// Resize the renderbuffer
-  void reset(GLView *view);
+  void reset (GLView *view);
 
-  int select(const Renderer *renderer, int x, int y);
+  int select (const Renderer *renderer, int x, int y);
 
   ShaderUtils::ShaderInfo shaderinfo;
 
 private:
-  void initShader();
-  void setupFramebuffer(int width, int height);
+  void initShader ();
+  void setupFramebuffer (int width, int height);
 
   std::unique_ptr<FBO> framebuffer;
 
diff --git a/src/gui/Network.h b/src/gui/Network.h
index 70db4f4e5..7c7c87338 100644
--- a/src/gui/Network.h
+++ b/src/gui/Network.h
@@ -49,14 +49,19 @@
 class NetworkException : public std::exception
 {
 public:
-  NetworkException(const QNetworkReply::NetworkError& error, const QString& errorMessage) : error(error), errorMessage(errorMessage.toStdString()) { }
+  NetworkException (const QNetworkReply::NetworkError &error, const QString &errorMessage)
+    : error (error)
+    , errorMessage (errorMessage.toStdString ()) {}
 
-  const QNetworkReply::NetworkError& getError() const { return error; }
-  const std::string& getErrorMessage() const { return errorMessage; }
+  const QNetworkReply::NetworkError &getError () const {
+    return error;
+  }
+  const std::string &getErrorMessage () const {
+    return errorMessage;
+  }
 
-  const char *what() const noexcept override
-  {
-    return errorMessage.c_str();
+  const char *what () const noexcept override {
+    return errorMessage.c_str ();
   }
 
 private:
@@ -70,19 +75,22 @@ template <typename ResultType>
 class NetworkRequest
 {
 public:
-  using setup_func_t = std::function<void (QNetworkRequest&)>;
-  using reply_func_t = std::function<QNetworkReply *(QNetworkAccessManager&, QNetworkRequest&)>;
+  using setup_func_t = std::function<void (QNetworkRequest &)>;
+  using reply_func_t = std::function<QNetworkReply *(QNetworkAccessManager &, QNetworkRequest &)>;
   using transform_func_t = std::function<ResultType (QNetworkReply *)>;
   using error_func_t = std::function<ResultType (QNetworkReply *)>;
 
-  NetworkRequest(QUrl url, std::vector<int> accepted_codes, const int timeout_seconds)
-    : url(std::move(url)), accepted_codes(std::move(accepted_codes)), timeout_seconds(timeout_seconds)
-  { }
-  virtual ~NetworkRequest() = default;
+  NetworkRequest (QUrl url, std::vector<int> accepted_codes, const int timeout_seconds)
+    : url (std::move (url))
+    , accepted_codes (std::move (accepted_codes))
+    , timeout_seconds (timeout_seconds) {}
+  virtual ~NetworkRequest () = default;
 
-  void set_progress_func(const network_progress_func_t& progress_func) { this->progress_func = progress_func; }
-  ResultType execute(const setup_func_t& setup_func, const reply_func_t& reply_func, const transform_func_t& transform_func);
-  ResultType execute(const setup_func_t& setup_func, const reply_func_t& reply_func, const transform_func_t& transform_func, const error_func_t& error_func);
+  void set_progress_func (const network_progress_func_t &progress_func) {
+    this->progress_func = progress_func;
+  }
+  ResultType execute (const setup_func_t &setup_func, const reply_func_t &reply_func, const transform_func_t &transform_func);
+  ResultType execute (const setup_func_t &setup_func, const reply_func_t &reply_func, const transform_func_t &transform_func, const error_func_t &error_func);
 
 private:
   QUrl url;
@@ -92,67 +100,65 @@ private:
 };
 
 template <typename ResultType>
-ResultType NetworkRequest<ResultType>::execute(
-  const NetworkRequest::setup_func_t& setup_func,
-  const NetworkRequest::reply_func_t& reply_func,
-  const NetworkRequest::transform_func_t& transform_func)
-{
-  return execute(setup_func, reply_func, transform_func, [](QNetworkReply *reply) -> ResultType {
-    throw NetworkException{reply->error(), reply->errorString()};
+ResultType NetworkRequest<ResultType>::execute (
+  const NetworkRequest::setup_func_t &setup_func,
+  const NetworkRequest::reply_func_t &reply_func,
+  const NetworkRequest::transform_func_t &transform_func) {
+  return execute (setup_func, reply_func, transform_func, [] (QNetworkReply *reply) -> ResultType {
+    throw NetworkException{reply->error (), reply->errorString ()};
   });
 }
 
 template <typename ResultType>
-ResultType NetworkRequest<ResultType>::execute(
-  const NetworkRequest::setup_func_t& setup_func,
-  const NetworkRequest::reply_func_t& reply_func,
-  const NetworkRequest::transform_func_t& transform_func,
-  const NetworkRequest::error_func_t& error_func)
-{
-  QNetworkRequest request(url);
-  request.setHeader(QNetworkRequest::UserAgentHeader, QString::fromStdString(PlatformUtils::user_agent()));
-  setup_func(request);
+ResultType NetworkRequest<ResultType>::execute (
+  const NetworkRequest::setup_func_t &setup_func,
+  const NetworkRequest::reply_func_t &reply_func,
+  const NetworkRequest::transform_func_t &transform_func,
+  const NetworkRequest::error_func_t &error_func) {
+  QNetworkRequest request (url);
+  request.setHeader (QNetworkRequest::UserAgentHeader, QString::fromStdString (PlatformUtils::user_agent ()));
+  setup_func (request);
 
   QNetworkAccessManager nam;
-  QNetworkReply *reply = reply_func(nam, request);
+  QNetworkReply *reply = reply_func (nam, request);
 
   QTimer timer;
   QEventLoop loop;
-  NetworkSignal forwarder{nullptr, [&](qint64 bytesSent, qint64 bytesTotal) {
+  NetworkSignal forwarder{nullptr, [&] (qint64 bytesSent, qint64 bytesTotal) {
                             const double permille = (1000.0 * bytesSent) / bytesTotal;
-                            timer.start();
-                            if (progress_func && progress_func(permille)) {
-                              reply->abort();
+                            timer.start ();
+                            if (progress_func && progress_func (permille)) {
+                              reply->abort ();
                             }
                           }};
-  QObject::connect(&timer, &QTimer::timeout, &loop, &QEventLoop::quit);
-  QObject::connect(reply, &QNetworkReply::finished, &loop, &QEventLoop::quit);
-  QObject::connect(reply, &QNetworkReply::uploadProgress, &forwarder, &NetworkSignal::network_progress);
-  timer.setSingleShot(true);
-  timer.start(timeout_seconds * 1000);
-  loop.exec();
+  QObject::connect (&timer, &QTimer::timeout, &loop, &QEventLoop::quit);
+  QObject::connect (reply, &QNetworkReply::finished, &loop, &QEventLoop::quit);
+  QObject::connect (reply, &QNetworkReply::uploadProgress, &forwarder, &NetworkSignal::network_progress);
+  timer.setSingleShot (true);
+  timer.start (timeout_seconds * 1000);
+  loop.exec ();
 
   bool isTimeout = false;
-  if (timer.isActive()) {
-    timer.stop();
+  if (timer.isActive ()) {
+    timer.stop ();
   }
-  if (!reply->isFinished()) {
-    reply->abort();
+  if (!reply->isFinished ()) {
+    reply->abort ();
     isTimeout = true;
   }
 
-  reply->deleteLater();
+  reply->deleteLater ();
   if (isTimeout) {
-    throw NetworkException{QNetworkReply::TimeoutError, _("Timeout error")};
+    throw NetworkException{QNetworkReply::TimeoutError, _ ("Timeout error")};
   }
-  if (reply->error() != QNetworkReply::NoError) {
-    return error_func(reply);
+  if (reply->error () != QNetworkReply::NoError) {
+    return error_func (reply);
   } else {
-    const auto statusCode = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
-    if (std::find(accepted_codes.begin(), accepted_codes.end(), statusCode) == accepted_codes.end()) {
-      QString reason = reply->attribute(QNetworkRequest::HttpReasonPhraseAttribute).toString();
+    const auto statusCode = reply->attribute (QNetworkRequest::HttpStatusCodeAttribute).toInt ();
+    if (std::find (accepted_codes.begin (), accepted_codes.end (), statusCode) == accepted_codes.end ()) {
+      QString reason = reply->attribute (QNetworkRequest::HttpReasonPhraseAttribute).toString ();
       throw NetworkException{QNetworkReply::ProtocolFailure, reason};
     }
   }
-  return transform_func(reply);
+  return transform_func (reply);
 }
diff --git a/src/gui/NetworkSignal.h b/src/gui/NetworkSignal.h
index f51832ed5..ca010570b 100644
--- a/src/gui/NetworkSignal.h
+++ b/src/gui/NetworkSignal.h
@@ -39,15 +39,18 @@ class NetworkSignal : public QObject
 
   using callback_t = std::function<void (qint64, qint64)>;
 
-  NetworkSignal(QObject *parent, callback_t callback) : QObject(parent), callback(std::move(callback)) { }
+  NetworkSignal (QObject *parent, callback_t callback)
+    : QObject (parent)
+    , callback (std::move (callback)) {}
 
 public slots:
-  void network_progress(qint64 bytesSent, qint64 bytesTotal) {
-    callback(bytesSent, bytesTotal);
+  void network_progress (qint64 bytesSent, qint64 bytesTotal) {
+    callback (bytesSent, bytesTotal);
   }
 
 private:
   callback_t callback;
 
-  template <typename T> friend class NetworkRequest;
+  template <typename T>
+  friend class NetworkRequest;
 };
diff --git a/src/gui/OctoPrint.cc b/src/gui/OctoPrint.cc
index eed99045d..9e1d49276 100644
--- a/src/gui/OctoPrint.cc
+++ b/src/gui/OctoPrint.cc
@@ -42,63 +42,57 @@
 #include "utils/printutils.h"
 #include "platform/PlatformUtils.h"
 
-const QString OctoPrint::url() const
-{
-  return QString::fromStdString(Settings::Settings::octoPrintUrl.value());
+const QString OctoPrint::url () const {
+  return QString::fromStdString (Settings::Settings::octoPrintUrl.value ());
 }
 
-const std::string OctoPrint::apiKey() const
-{
-  return Settings::Settings::octoPrintApiKey.value();
+const std::string OctoPrint::apiKey () const {
+  return Settings::Settings::octoPrintApiKey.value ();
 }
 
-const QJsonDocument OctoPrint::getJsonData(const QString& endpoint) const
-{
-  if (url().trimmed().isEmpty()) {
+const QJsonDocument OctoPrint::getJsonData (const QString &endpoint) const {
+  if (url ().trimmed ().isEmpty ()) {
     throw NetworkException{QNetworkReply::ProtocolFailure, "OctoPrint URL not configured."};
   }
 
-  auto networkRequest = NetworkRequest<const QJsonDocument>{QUrl{url() + endpoint}, { 200 }, 30};
-
-  return networkRequest.execute(
-    [&](QNetworkRequest& request) {
-    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
-    request.setRawHeader(QByteArray{"X-Api-Key"}, QByteArray{apiKey().c_str()});
-  },
-    [](QNetworkAccessManager& nam, QNetworkRequest& request) {
-    return nam.get(request);
-  },
-    [](QNetworkReply *reply) -> const QJsonDocument {
-    auto doc = QJsonDocument::fromJson(reply->readAll());
-    PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
-    return doc;
-  }
-    );
+  auto networkRequest = NetworkRequest<const QJsonDocument>{QUrl{url () + endpoint}, {200}, 30};
+
+  return networkRequest.execute (
+    [&] (QNetworkRequest &request) {
+      request.setHeader (QNetworkRequest::ContentTypeHeader, "application/json");
+      request.setRawHeader (QByteArray{"X-Api-Key"}, QByteArray{apiKey ().c_str ()});
+    },
+    [] (QNetworkAccessManager &nam, QNetworkRequest &request) {
+      return nam.get (request);
+    },
+    [] (QNetworkReply *reply) -> const QJsonDocument {
+      auto doc = QJsonDocument::fromJson (reply->readAll ());
+      PRINTDB ("Response: %s", QString{doc.toJson ()}.toStdString ());
+      return doc;
+    });
 }
 
-const std::vector<std::pair<const QString, const QString>> OctoPrint::getSlicers() const
-{
-  const auto obj = getJsonData("/slicing").object();
+const std::vector<std::pair<const QString, const QString>> OctoPrint::getSlicers () const {
+  const auto obj = getJsonData ("/slicing").object ();
   std::vector<std::pair<const QString, const QString>> slicers;
-  for (const auto& key : obj.keys()) {
-    slicers.emplace_back(std::make_pair(key, obj[key].toObject().value("displayName").toString()));
+  for (const auto &key : obj.keys ()) {
+    slicers.emplace_back (std::make_pair (key, obj[key].toObject ().value ("displayName").toString ()));
   }
   return slicers;
 }
 
-const std::vector<std::pair<const QString, const QString>> OctoPrint::getProfiles(const QString& slicer) const
-{
-  const auto obj = getJsonData("/slicing").object();
+const std::vector<std::pair<const QString, const QString>> OctoPrint::getProfiles (const QString &slicer) const {
+  const auto obj = getJsonData ("/slicing").object ();
   std::vector<std::pair<const QString, const QString>> profiles;
-  for (const auto& key : obj.keys()) {
-    const auto entry = obj[key].toObject();
-    const auto name = entry.value("key").toString();
-    const auto isDefault = entry.value("default").toBool();
-    if ((slicer == name) || (slicer.isEmpty() && isDefault)) {
-      const auto profilesObject = entry.value("profiles").toObject();
-      for (const auto& profileKey : profilesObject.keys()) {
-        const auto displayName = profilesObject[profileKey].toObject().value("displayName").toString();
-        profiles.emplace_back(std::make_pair(profileKey, displayName));
+  for (const auto &key : obj.keys ()) {
+    const auto entry = obj[key].toObject ();
+    const auto name = entry.value ("key").toString ();
+    const auto isDefault = entry.value ("default").toBool ();
+    if ((slicer == name) || (slicer.isEmpty () && isDefault)) {
+      const auto profilesObject = entry.value ("profiles").toObject ();
+      for (const auto &profileKey : profilesObject.keys ()) {
+        const auto displayName = profilesObject[profileKey].toObject ().value ("displayName").toString ();
+        profiles.emplace_back (std::make_pair (profileKey, displayName));
       }
       break;
     }
@@ -106,119 +100,111 @@ const std::vector<std::pair<const QString, const QString>> OctoPrint::getProfile
   return profiles;
 }
 
-const std::pair<const QString, const QString> OctoPrint::getVersion() const
-{
-  const auto obj = getJsonData("/version").object();
-  const auto api_version = obj.value("api").toString();
-  const auto server_version = obj.value("server").toString();
-  const auto result = std::make_pair(api_version, server_version);
+const std::pair<const QString, const QString> OctoPrint::getVersion () const {
+  const auto obj = getJsonData ("/version").object ();
+  const auto api_version = obj.value ("api").toString ();
+  const auto server_version = obj.value ("server").toString ();
+  const auto result = std::make_pair (api_version, server_version);
   return result;
 }
 
-const QString OctoPrint::requestApiKey() const
-{
+const QString OctoPrint::requestApiKey () const {
   QJsonObject jsonInput;
-  jsonInput.insert("app", QString{"OpenSCAD"});
-
-  auto networkRequest = NetworkRequest<QString>{QUrl{url() + "/../plugin/appkeys/request"}, { 201 }, 30};
-  return networkRequest.execute(
-    [&](QNetworkRequest& request) {
-    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
-  },
-    [&](QNetworkAccessManager& nam, QNetworkRequest& request) {
-    return nam.post(request, QJsonDocument(jsonInput).toJson());
-  },
-    [](QNetworkReply *reply) -> QString {
-    const auto doc = QJsonDocument::fromJson(reply->readAll());
-    PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
-    const auto obj = doc.object();
-    const auto token = obj.value("app_token").toString();
-    return token;
-  }
-    );
+  jsonInput.insert ("app", QString{"OpenSCAD"});
+
+  auto networkRequest = NetworkRequest<QString>{QUrl{url () + "/../plugin/appkeys/request"}, {201}, 30};
+  return networkRequest.execute (
+    [&] (QNetworkRequest &request) {
+      request.setHeader (QNetworkRequest::ContentTypeHeader, "application/json");
+    },
+    [&] (QNetworkAccessManager &nam, QNetworkRequest &request) {
+      return nam.post (request, QJsonDocument (jsonInput).toJson ());
+    },
+    [] (QNetworkReply *reply) -> QString {
+      const auto doc = QJsonDocument::fromJson (reply->readAll ());
+      PRINTDB ("Response: %s", QString{doc.toJson ()}.toStdString ());
+      const auto obj = doc.object ();
+      const auto token = obj.value ("app_token").toString ();
+      return token;
+    });
 }
 
-const std::pair<int, QString> OctoPrint::pollApiKeyApproval(const QString& token) const
-{
-  auto networkRequest = NetworkRequest<std::pair<int, QString>>{QUrl{url() + "/../plugin/appkeys/request/" + token}, { 200, 202, 404 }, 30};
-  return networkRequest.execute(
-    [&](QNetworkRequest& request) {
-    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
-  },
-    [&](QNetworkAccessManager& nam, QNetworkRequest& request) {
-    return nam.get(request);
-  },
-    [](QNetworkReply *reply) -> std::pair<int, QString> {
-    const auto code = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
-    PRINTDB("Response Code: %d", code);
-    const auto obj = QJsonDocument::fromJson(reply->readAll()).object();
-    return std::make_pair(code, obj.value("api_key").toString());
-  },
-    [](QNetworkReply *reply) -> std::pair<int, QString> {
-    const auto code = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
-    PRINTDB("Response (Error) Code: %d", code);
-    return std::make_pair(code, "");
-  }
-    );
+const std::pair<int, QString> OctoPrint::pollApiKeyApproval (const QString &token) const {
+  auto networkRequest = NetworkRequest<std::pair<int, QString>>{QUrl{url () + "/../plugin/appkeys/request/" + token}, {200, 202, 404}, 30};
+  return networkRequest.execute (
+    [&] (QNetworkRequest &request) {
+      request.setHeader (QNetworkRequest::ContentTypeHeader, "application/json");
+    },
+    [&] (QNetworkAccessManager &nam, QNetworkRequest &request) {
+      return nam.get (request);
+    },
+    [] (QNetworkReply *reply) -> std::pair<int, QString> {
+      const auto code = reply->attribute (QNetworkRequest::HttpStatusCodeAttribute).toInt ();
+      PRINTDB ("Response Code: %d", code);
+      const auto obj = QJsonDocument::fromJson (reply->readAll ()).object ();
+      return std::make_pair (code, obj.value ("api_key").toString ());
+    },
+    [] (QNetworkReply *reply) -> std::pair<int, QString> {
+      const auto code = reply->attribute (QNetworkRequest::HttpStatusCodeAttribute).toInt ();
+      PRINTDB ("Response (Error) Code: %d", code);
+      return std::make_pair (code, "");
+    });
 }
 
-const QString OctoPrint::upload(const QString& exportFileName, const QString& fileName, const network_progress_func_t& progress_func) const {
+const QString OctoPrint::upload (const QString &exportFileName, const QString &fileName, const network_progress_func_t &progress_func) const {
 
-  auto *multiPart = new QHttpMultiPart(QHttpMultiPart::FormDataType);
+  auto *multiPart = new QHttpMultiPart (QHttpMultiPart::FormDataType);
   QHttpPart filePart;
-  filePart.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant{R"(form-data; name="file"; filename=")" + fileName + "\""});
-  filePart.setHeader(QNetworkRequest::ContentTypeHeader, QVariant{"application/octet-stream"});
-
-  auto *file = new QFile(exportFileName, multiPart);
-  file->open(QIODevice::ReadOnly);
-  filePart.setBodyDevice(file);
-
-  multiPart->append(filePart);
-
-  auto networkRequest = NetworkRequest<const QString>{QUrl{url() + "/files/local"}, { 200, 201 }, 180};
-  networkRequest.set_progress_func(progress_func);
-  return networkRequest.execute(
-    [&](QNetworkRequest& request) {
-    request.setHeader(QNetworkRequest::UserAgentHeader, QString::fromStdString(PlatformUtils::user_agent()));
-    request.setRawHeader(QByteArray{"X-Api-Key"}, QByteArray{apiKey().c_str()});
-  },
-    [&](QNetworkAccessManager& nam, QNetworkRequest& request) {
-    const auto reply = nam.post(request, multiPart);
-    multiPart->setParent(reply);
-    return reply;
-  },
-    [](QNetworkReply *reply) -> const QString {
-    const auto doc = QJsonDocument::fromJson(reply->readAll());
-    PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
-    auto location = reply->header(QNetworkRequest::LocationHeader).toString();
-    LOG("Uploaded successfully to %1$s", location.toStdString());
-    return location;
-  }
-    );
+  filePart.setHeader (QNetworkRequest::ContentDispositionHeader, QVariant{R"(form-data; name="file"; filename=")" + fileName + "\""});
+  filePart.setHeader (QNetworkRequest::ContentTypeHeader, QVariant{"application/octet-stream"});
+
+  auto *file = new QFile (exportFileName, multiPart);
+  file->open (QIODevice::ReadOnly);
+  filePart.setBodyDevice (file);
+
+  multiPart->append (filePart);
+
+  auto networkRequest = NetworkRequest<const QString>{QUrl{url () + "/files/local"}, {200, 201}, 180};
+  networkRequest.set_progress_func (progress_func);
+  return networkRequest.execute (
+    [&] (QNetworkRequest &request) {
+      request.setHeader (QNetworkRequest::UserAgentHeader, QString::fromStdString (PlatformUtils::user_agent ()));
+      request.setRawHeader (QByteArray{"X-Api-Key"}, QByteArray{apiKey ().c_str ()});
+    },
+    [&] (QNetworkAccessManager &nam, QNetworkRequest &request) {
+      const auto reply = nam.post (request, multiPart);
+      multiPart->setParent (reply);
+      return reply;
+    },
+    [] (QNetworkReply *reply) -> const QString {
+      const auto doc = QJsonDocument::fromJson (reply->readAll ());
+      PRINTDB ("Response: %s", QString{doc.toJson ()}.toStdString ());
+      auto location = reply->header (QNetworkRequest::LocationHeader).toString ();
+      LOG ("Uploaded successfully to %1$s", location.toStdString ());
+      return location;
+    });
 }
 
-void OctoPrint::slice(const QString& fileUrl, const QString& slicer, const QString& profile, const bool select, const bool print) const
-{
+void OctoPrint::slice (const QString &fileUrl, const QString &slicer, const QString &profile, const bool select, const bool print) const {
   QJsonObject jsonInput;
-  jsonInput.insert("command", QString{"slice"});
-  jsonInput.insert("slicer", slicer);
-  jsonInput.insert("profile", profile);
-  jsonInput.insert("select", QString{select ? "true" : "false"});
-  jsonInput.insert("print", QString{print ? "true" : "false"});
-
-  auto networkRequest = NetworkRequest<void>{QUrl{fileUrl}, { 200, 202 }, 30};
-  return networkRequest.execute(
-    [&](QNetworkRequest& request) {
-    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
-    request.setRawHeader(QByteArray{"X-Api-Key"}, QByteArray{apiKey().c_str()});
-  },
-    [&](QNetworkAccessManager& nam, QNetworkRequest& request) {
-    return nam.post(request, QJsonDocument(jsonInput).toJson());
-  },
-    [](QNetworkReply *reply) {
-    const auto doc = QJsonDocument::fromJson(reply->readAll());
-    PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
-    LOG("Slice command successfully executed.");
-  }
-    );
+  jsonInput.insert ("command", QString{"slice"});
+  jsonInput.insert ("slicer", slicer);
+  jsonInput.insert ("profile", profile);
+  jsonInput.insert ("select", QString{select ? "true" : "false"});
+  jsonInput.insert ("print", QString{print ? "true" : "false"});
+
+  auto networkRequest = NetworkRequest<void>{QUrl{fileUrl}, {200, 202}, 30};
+  return networkRequest.execute (
+    [&] (QNetworkRequest &request) {
+      request.setHeader (QNetworkRequest::ContentTypeHeader, "application/json");
+      request.setRawHeader (QByteArray{"X-Api-Key"}, QByteArray{apiKey ().c_str ()});
+    },
+    [&] (QNetworkAccessManager &nam, QNetworkRequest &request) {
+      return nam.post (request, QJsonDocument (jsonInput).toJson ());
+    },
+    [] (QNetworkReply *reply) {
+      const auto doc = QJsonDocument::fromJson (reply->readAll ());
+      PRINTDB ("Response: %s", QString{doc.toJson ()}.toStdString ());
+      LOG ("Slice command successfully executed.");
+    });
 }
diff --git a/src/gui/OctoPrint.h b/src/gui/OctoPrint.h
index b4f39e82c..3f4e2dca0 100644
--- a/src/gui/OctoPrint.h
+++ b/src/gui/OctoPrint.h
@@ -39,19 +39,19 @@
 class OctoPrint
 {
 public:
-  OctoPrint() = default;
-  virtual ~OctoPrint() = default;
+  OctoPrint () = default;
+  virtual ~OctoPrint () = default;
 
-  const QString url() const;
-  const std::string apiKey() const;
-  const std::pair<const QString, const QString> getVersion() const;
-  const QString requestApiKey() const;
-  const std::pair<int, QString> pollApiKeyApproval(const QString& token) const;
-  const std::vector<std::pair<const QString, const QString>> getSlicers() const;
-  const std::vector<std::pair<const QString, const QString>> getProfiles(const QString& slicer) const;
-  const QString upload(const QString& exportFileName, const QString& fileName, const network_progress_func_t& progress_func) const;
-  void slice(const QString& fileUrl, const QString& slicer, const QString& profile, const bool select, const bool print) const;
+  const QString url () const;
+  const std::string apiKey () const;
+  const std::pair<const QString, const QString> getVersion () const;
+  const QString requestApiKey () const;
+  const std::pair<int, QString> pollApiKeyApproval (const QString &token) const;
+  const std::vector<std::pair<const QString, const QString>> getSlicers () const;
+  const std::vector<std::pair<const QString, const QString>> getProfiles (const QString &slicer) const;
+  const QString upload (const QString &exportFileName, const QString &fileName, const network_progress_func_t &progress_func) const;
+  void slice (const QString &fileUrl, const QString &slicer, const QString &profile, const bool select, const bool print) const;
 
 private:
-  const QJsonDocument getJsonData(const QString& endpoint) const;
+  const QJsonDocument getJsonData (const QString &endpoint) const;
 };
diff --git a/src/gui/OctoPrintApiKeyDialog.cc b/src/gui/OctoPrintApiKeyDialog.cc
index 5495bdc68..bccaacfa2 100644
--- a/src/gui/OctoPrintApiKeyDialog.cc
+++ b/src/gui/OctoPrintApiKeyDialog.cc
@@ -38,99 +38,90 @@
 
 #include "OctoPrint.h"
 
-OctoPrintApiKeyDialog::OctoPrintApiKeyDialog()
-{
-  setupUi(this);
-  QObject::connect(&networkTimer, &QTimer::timeout, this, &OctoPrintApiKeyDialog::timeout);
-  QObject::connect(&animationTimer, &QTimer::timeout, this, &OctoPrintApiKeyDialog::animationUpdate);
+OctoPrintApiKeyDialog::OctoPrintApiKeyDialog () {
+  setupUi (this);
+  QObject::connect (&networkTimer, &QTimer::timeout, this, &OctoPrintApiKeyDialog::timeout);
+  QObject::connect (&animationTimer, &QTimer::timeout, this, &OctoPrintApiKeyDialog::animationUpdate);
 
-  this->iconOk = QIcon::fromTheme("chokusen-circle-checkmark");
-  this->iconError = QIcon::fromTheme("chokusen-circle-error");
-  this->iconWaiting = QIcon::fromTheme("chokusen-loading");
+  this->iconOk = QIcon::fromTheme ("chokusen-circle-checkmark");
+  this->iconError = QIcon::fromTheme ("chokusen-circle-error");
+  this->iconWaiting = QIcon::fromTheme ("chokusen-loading");
 }
 
-void OctoPrintApiKeyDialog::startRequest()
-{
+void OctoPrintApiKeyDialog::startRequest () {
   OctoPrint octoPrint;
-  this->token = octoPrint.requestApiKey();
-  this->apiKey.clear();
-  this->labelMessage->setText(_("API key created, waiting for approval in OctoPrint..."));
-  networkTimer.setSingleShot(true);
-  networkTimer.start(1000);
-  animationTimer.setInterval(100);
-  animationTimer.start();
-  this->pushButtonOk->setEnabled(false);
-  this->pushButtonRetry->setEnabled(false);
+  this->token = octoPrint.requestApiKey ();
+  this->apiKey.clear ();
+  this->labelMessage->setText (_ ("API key created, waiting for approval in OctoPrint..."));
+  networkTimer.setSingleShot (true);
+  networkTimer.start (1000);
+  animationTimer.setInterval (100);
+  animationTimer.start ();
+  this->pushButtonOk->setEnabled (false);
+  this->pushButtonRetry->setEnabled (false);
 }
 
-void OctoPrintApiKeyDialog::paintIcon(const QIcon& icon, const qreal rotation)
-{
+void OctoPrintApiKeyDialog::paintIcon (const QIcon &icon, const qreal rotation) {
   QPalette palette;
-  QImage image(this->labelIcon->width(), this->labelIcon->width(), QImage::Format_ARGB32);
-  image.fill(0x000000ff);
-  QPainter painter(&image);
-  painter.translate(QPoint{this->labelIcon->width() / 2, this->labelIcon->width() / 2});
-  painter.rotate(rotation);
-  painter.translate(QPoint{-this->labelIcon->width() / 2, -this->labelIcon->width() / 2});
-  icon.paint(&painter, image.rect());
-  QPixmap pixmap = QPixmap::fromImage(image);
-  this->labelIcon->setPixmap(QPixmap::fromImage(image));
+  QImage image (this->labelIcon->width (), this->labelIcon->width (), QImage::Format_ARGB32);
+  image.fill (0x000000ff);
+  QPainter painter (&image);
+  painter.translate (QPoint{this->labelIcon->width () / 2, this->labelIcon->width () / 2});
+  painter.rotate (rotation);
+  painter.translate (QPoint{-this->labelIcon->width () / 2, -this->labelIcon->width () / 2});
+  icon.paint (&painter, image.rect ());
+  QPixmap pixmap = QPixmap::fromImage (image);
+  this->labelIcon->setPixmap (QPixmap::fromImage (image));
 }
 
-void OctoPrintApiKeyDialog::timeout()
-{
+void OctoPrintApiKeyDialog::timeout () {
   OctoPrint octoPrint;
-  const auto [code, apiKey] = octoPrint.pollApiKeyApproval(this->token);
+  const auto [code, apiKey] = octoPrint.pollApiKeyApproval (this->token);
   switch (code) {
   case 200:
-    this->token.clear();
+    this->token.clear ();
     this->apiKey = apiKey;
-    this->labelMessage->setText(_("API key approved."));
-    animationTimer.stop();
-    paintIcon(this->iconOk);
-    this->pushButtonOk->setEnabled(true);
+    this->labelMessage->setText (_ ("API key approved."));
+    animationTimer.stop ();
+    paintIcon (this->iconOk);
+    this->pushButtonOk->setEnabled (true);
     break;
   case 202:
-    networkTimer.start(1000);
+    networkTimer.start (1000);
     break;
   case 404:
   default:
-    this->token.clear();
-    this->apiKey.clear();
-    this->labelMessage->setText(_("API key approval failed."));
-    animationTimer.stop();
-    paintIcon(this->iconError);
-    this->pushButtonRetry->setEnabled(true);
+    this->token.clear ();
+    this->apiKey.clear ();
+    this->labelMessage->setText (_ ("API key approval failed."));
+    animationTimer.stop ();
+    paintIcon (this->iconError);
+    this->pushButtonRetry->setEnabled (true);
     break;
   }
 }
 
-void OctoPrintApiKeyDialog::animationUpdate()
-{
+void OctoPrintApiKeyDialog::animationUpdate () {
   static qreal rotation = 0.0;
-  paintIcon(this->iconWaiting, rotation);
+  paintIcon (this->iconWaiting, rotation);
   rotation += 30;
 }
 
-int OctoPrintApiKeyDialog::exec()
-{
-  startRequest();
-  return QDialog::exec();
+int OctoPrintApiKeyDialog::exec () {
+  startRequest ();
+  return QDialog::exec ();
 }
 
-void OctoPrintApiKeyDialog::on_pushButtonRetry_clicked()
-{
-  startRequest();
+void OctoPrintApiKeyDialog::on_pushButtonRetry_clicked () {
+  startRequest ();
 }
 
-void OctoPrintApiKeyDialog::on_pushButtonOk_clicked()
-{
-  accept();
+void OctoPrintApiKeyDialog::on_pushButtonOk_clicked () {
+  accept ();
 }
 
-void OctoPrintApiKeyDialog::on_pushButtonCancel_clicked()
-{
-  this->token.clear();
-  this->apiKey.clear();
-  reject();
+void OctoPrintApiKeyDialog::on_pushButtonCancel_clicked () {
+  this->token.clear ();
+  this->apiKey.clear ();
+  reject ();
 }
diff --git a/src/gui/OctoPrintApiKeyDialog.h b/src/gui/OctoPrintApiKeyDialog.h
index 78b1b3a8a..a1458b4a4 100644
--- a/src/gui/OctoPrintApiKeyDialog.h
+++ b/src/gui/OctoPrintApiKeyDialog.h
@@ -39,21 +39,23 @@ class OctoPrintApiKeyDialog : public QDialog, public Ui::OctoPrintApiKeyDialog
   Q_OBJECT;
 
 public:
-  OctoPrintApiKeyDialog();
+  OctoPrintApiKeyDialog ();
 
-  int exec() override;
-  const QString& getApiKey() const { return apiKey; }
+  int exec () override;
+  const QString &getApiKey () const {
+    return apiKey;
+  }
 
 private slots:
-  void timeout();
-  void animationUpdate();
-  void on_pushButtonRetry_clicked();
-  void on_pushButtonOk_clicked();
-  void on_pushButtonCancel_clicked();
+  void timeout ();
+  void animationUpdate ();
+  void on_pushButtonRetry_clicked ();
+  void on_pushButtonOk_clicked ();
+  void on_pushButtonCancel_clicked ();
 
 private:
-  void startRequest();
-  void paintIcon(const QIcon& icon, const qreal rotation = 0.0);
+  void startRequest ();
+  void paintIcon (const QIcon &icon, const qreal rotation = 0.0);
 
   QString token;
   QString apiKey;
diff --git a/src/gui/OpenCSGWarningDialog.cc b/src/gui/OpenCSGWarningDialog.cc
index 642f858c1..4e8c06db8 100644
--- a/src/gui/OpenCSGWarningDialog.cc
+++ b/src/gui/OpenCSGWarningDialog.cc
@@ -3,18 +3,15 @@
 #include <QWidget>
 #include "gui/Preferences.h"
 
-OpenCSGWarningDialog::OpenCSGWarningDialog(QWidget *)
-{
-  setupUi(this);
+OpenCSGWarningDialog::OpenCSGWarningDialog (QWidget *) {
+  setupUi (this);
 
-  connect(this->showBox, &QCheckBox::toggled,
-          GlobalPreferences::inst()->openCSGWarningBox, &QCheckBox::setChecked);
-  connect(this->showBox, &QCheckBox::toggled,
-          GlobalPreferences::inst(), &Preferences::on_openCSGWarningBox_toggled);
+  connect (this->showBox, &QCheckBox::toggled,
+           GlobalPreferences::inst ()->openCSGWarningBox, &QCheckBox::setChecked);
+  connect (this->showBox, &QCheckBox::toggled,
+           GlobalPreferences::inst (), &Preferences::on_openCSGWarningBox_toggled);
 }
 
-void OpenCSGWarningDialog::setText(const QString& text)
-{
-  this->warningText->setPlainText(text);
+void OpenCSGWarningDialog::setText (const QString &text) {
+  this->warningText->setPlainText (text);
 }
-
diff --git a/src/gui/OpenCSGWarningDialog.h b/src/gui/OpenCSGWarningDialog.h
index 0a58e0090..4ae13b386 100644
--- a/src/gui/OpenCSGWarningDialog.h
+++ b/src/gui/OpenCSGWarningDialog.h
@@ -8,9 +8,10 @@
 class OpenCSGWarningDialog : public QDialog, public Ui::OpenCSGWarningDialog
 {
   Q_OBJECT;
+
 public:
-  OpenCSGWarningDialog(QWidget *parent);
+  OpenCSGWarningDialog (QWidget *parent);
 
 public slots:
-  void setText(const QString& text);
+  void setText (const QString &text);
 };
diff --git a/src/gui/OpenSCADApp.cc b/src/gui/OpenSCADApp.cc
index 2f9b07ee8..9d6b3c991 100644
--- a/src/gui/OpenSCADApp.cc
+++ b/src/gui/OpenSCADApp.cc
@@ -15,65 +15,60 @@
 #include <boost/foreach.hpp>
 #include "gui/QSettingsCached.h"
 
-OpenSCADApp::OpenSCADApp(int& argc, char **argv)
-  : QApplication(argc, argv)
-{
+OpenSCADApp::OpenSCADApp (int &argc, char **argv)
+  : QApplication (argc, argv) {
 #ifdef Q_OS_MACOS
-  this->installEventFilter(new SCADEventFilter(this));
+  this->installEventFilter (new SCADEventFilter (this));
 #endif
 }
 
-OpenSCADApp::~OpenSCADApp()
-{
+OpenSCADApp::~OpenSCADApp () {
   delete this->fontCacheDialog;
 }
 
 #include <QMessageBox>
 
-bool OpenSCADApp::notify(QObject *object, QEvent *event)
-{
+bool OpenSCADApp::notify (QObject *object, QEvent *event) {
   QString msg;
   try {
-    return QApplication::notify(object, event);
-  } catch (const std::exception& e) {
-    msg = e.what();
+    return QApplication::notify (object, event);
+  } catch (const std::exception &e) {
+    msg = e.what ();
   } catch (...) {
-    msg = _("Unknown error");
+    msg = _ ("Unknown error");
   }
   // This happens when an uncaught exception is thrown in a Qt event handler
-  QMessageBox::critical(nullptr, QString(_("Critical Error")), QString(_("A critical error was caught. The application may have become unstable:\n%1")).arg(QString(msg)));
+  QMessageBox::critical (nullptr, QString (_ ("Critical Error")), QString (_ ("A critical error was caught. The application may have become unstable:\n%1")).arg (QString (msg)));
   return false;
 }
 
 /*!
    Requests to open a file from an external event, e.g. by double-clicking a filename.
  */
-void OpenSCADApp::requestOpenFile(const QString& filename)
-{
-  for (auto win : this->windowManager.getWindows()) {
+void OpenSCADApp::requestOpenFile (const QString &filename) {
+  for (auto win : this->windowManager.getWindows ()) {
     // if we have an empty open window, use that one
-    if (win->isEmpty()) {
-      win->tabManager->createTab(filename);
+    if (win->isEmpty ()) {
+      win->tabManager->createTab (filename);
       return;
     }
   }
 
   // ..otherwise, create a new one
-  new MainWindow(QStringList(filename));
+  new MainWindow (QStringList (filename));
 }
 
-void OpenSCADApp::showFontCacheDialog()
-{
-  if (!this->fontCacheDialog) this->fontCacheDialog = new QProgressDialog();
-  this->fontCacheDialog->setLabelText(_("Fontconfig needs to update its font cache.\nThis can take up to a couple of minutes."));
-  this->fontCacheDialog->setMinimum(0);
-  this->fontCacheDialog->setMaximum(0);
-  this->fontCacheDialog->setCancelButton(nullptr);
-  this->fontCacheDialog->exec();
+void OpenSCADApp::showFontCacheDialog () {
+  if (!this->fontCacheDialog)
+    this->fontCacheDialog = new QProgressDialog ();
+  this->fontCacheDialog->setLabelText (_ ("Fontconfig needs to update its font cache.\nThis can take up to a couple of minutes."));
+  this->fontCacheDialog->setMinimum (0);
+  this->fontCacheDialog->setMaximum (0);
+  this->fontCacheDialog->setCancelButton (nullptr);
+  this->fontCacheDialog->exec ();
 }
 
-void OpenSCADApp::hideFontCacheDialog()
-{
-  assert(this->fontCacheDialog);
-  this->fontCacheDialog->reset();
+void OpenSCADApp::hideFontCacheDialog () {
+  assert (this->fontCacheDialog);
+  this->fontCacheDialog->reset ();
 }
diff --git a/src/gui/OpenSCADApp.h b/src/gui/OpenSCADApp.h
index 720c2c4a9..97989ee62 100644
--- a/src/gui/OpenSCADApp.h
+++ b/src/gui/OpenSCADApp.h
@@ -13,15 +13,15 @@ class OpenSCADApp : public QApplication
   Q_OBJECT
 
 public:
-  OpenSCADApp(int& argc, char **argv);
-  ~OpenSCADApp() override;
+  OpenSCADApp (int &argc, char **argv);
+  ~OpenSCADApp () override;
 
-  bool notify(QObject *object, QEvent *event) override;
-  void requestOpenFile(const QString& filename);
+  bool notify (QObject *object, QEvent *event) override;
+  void requestOpenFile (const QString &filename);
 
 public slots:
-  void showFontCacheDialog();
-  void hideFontCacheDialog();
+  void showFontCacheDialog ();
+  void hideFontCacheDialog ();
 
 public:
   WindowManager windowManager;
@@ -30,4 +30,4 @@ private:
   QProgressDialog *fontCacheDialog{nullptr};
 };
 
-#define scadApp (static_cast<OpenSCADApp *>(QCoreApplication::instance()))
+#define scadApp (static_cast<OpenSCADApp *> (QCoreApplication::instance ()))
diff --git a/src/gui/Preferences.cc b/src/gui/Preferences.cc
index 35e4e3bac..a1f7b44b3 100644
--- a/src/gui/Preferences.cc
+++ b/src/gui/Preferences.cc
@@ -74,62 +74,61 @@
 
 #include <string>
 
-
 static const char *featurePropertyName = "FeatureProperty";
 
 using S = Settings::Settings;
 
-Q_DECLARE_METATYPE(Feature *);
+Q_DECLARE_METATYPE (Feature *);
 
 class SettingsReader : public Settings::SettingsVisitor
 {
   QSettingsCached settings;
 
-  void handle(Settings::SettingsEntryBase& entry) const override
-  {
-    if (settings.contains(QString::fromStdString(entry.key()))) {
-      std::string value = settings.value(QString::fromStdString(entry.key())).toString().toStdString();
-      PRINTDB("SettingsReader R: %s = '%s'", entry.key() % value);
-      entry.set(value);
+  void handle (Settings::SettingsEntryBase &entry) const override {
+    if (settings.contains (QString::fromStdString (entry.key ()))) {
+      std::string value = settings.value (QString::fromStdString (entry.key ())).toString ().toStdString ();
+      PRINTDB ("SettingsReader R: %s = '%s'", entry.key () % value);
+      entry.set (value);
     }
   }
 };
 
-Preferences::Preferences(QWidget *parent) : QMainWindow(parent)
-{
-  setupUi(this);
+Preferences::Preferences (QWidget *parent)
+  : QMainWindow (parent) {
+  setupUi (this);
 
-  std::list<std::string> names = ColorMap::inst()->colorSchemeNames(true);
+  std::list<std::string> names = ColorMap::inst ()->colorSchemeNames (true);
   QStringList renderColorSchemes;
-  for (const auto& name : names) renderColorSchemes << name.c_str();
+  for (const auto &name : names)
+    renderColorSchemes << name.c_str ();
 
-  syntaxHighlight->clear();
-  colorSchemeChooser->clear();
-  colorSchemeChooser->addItems(renderColorSchemes);
-  init();
-  AxisConfig->init();
-  setupFeaturesPage();
-  setup3DPrintPage();
-  updateGUI();
+  syntaxHighlight->clear ();
+  colorSchemeChooser->clear ();
+  colorSchemeChooser->addItems (renderColorSchemes);
+  init ();
+  AxisConfig->init ();
+  setupFeaturesPage ();
+  setup3DPrintPage ();
+  updateGUI ();
 }
 
-void Preferences::init() {
+void Preferences::init () {
   // Editor pane
   // Setup default font (Try to use a nice monospace font)
-  const QFont font = QFontDatabase::systemFont(QFontDatabase::FixedFont);
-  const QString found_family{QFontInfo{font}.family()};
+  const QFont font = QFontDatabase::systemFont (QFontDatabase::FixedFont);
+  const QString found_family{QFontInfo{font}.family ()};
   this->defaultmap["editor/fontfamily"] = found_family;
   this->defaultmap["editor/fontsize"] = 12;
   this->defaultmap["editor/syntaxhighlight"] = "For Light Background";
 
   // Leave Console font with default if user has not chosen another.
-  const QFont font2 = QTextDocument().defaultFont();
-  this->defaultmap["advanced/consoleFontFamily"] = font2.family();
-  this->defaultmap["advanced/consoleFontSize"] = font2.pointSize();
+  const QFont font2 = QTextDocument ().defaultFont ();
+  this->defaultmap["advanced/consoleFontFamily"] = font2.family ();
+  this->defaultmap["advanced/consoleFontSize"] = font2.pointSize ();
 
   // Leave Customizer font with default if user has not chosen another.
-  this->defaultmap["advanced/customizerFontFamily"] = font2.family();
-  this->defaultmap["advanced/customizerFontSize"] = font2.pointSize();
+  this->defaultmap["advanced/customizerFontFamily"] = font2.family ();
+  this->defaultmap["advanced/customizerFontSize"] = font2.pointSize ();
 
 #ifdef Q_OS_MACOS
   this->defaultmap["editor/ctrlmousewheelzoom"] = false;
@@ -137,21 +136,21 @@ void Preferences::init() {
   this->defaultmap["editor/ctrlmousewheelzoom"] = true;
 #endif
 
-  createFontSizeMenu(fontSize, "editor/fontsize");
-  createFontSizeMenu(consoleFontSize, "advanced/consoleFontSize");
-  createFontSizeMenu(customizerFontSize, "advanced/customizerFontSize");
+  createFontSizeMenu (fontSize, "editor/fontsize");
+  createFontSizeMenu (consoleFontSize, "advanced/consoleFontSize");
+  createFontSizeMenu (customizerFontSize, "advanced/customizerFontSize");
 
   // Setup default settings
   this->defaultmap["advanced/opencsg_show_warning"] = true;
-  this->defaultmap["advanced/polysetCacheSize"] = qulonglong(GeometryCache::instance()->maxSizeMB()) * 1024ul * 1024ul;
-  this->defaultmap["advanced/polysetCacheSizeMB"] = getValue("advanced/polysetCacheSize").toULongLong() / (1024ul * 1024ul); // carry over old settings if they exist
-  this->defaultmap["advanced/cgalCacheSize"] = qulonglong(CGALCache::instance()->maxSizeMB()) * 1024ul * 1024ul;
-  this->defaultmap["advanced/cgalCacheSizeMB"] = getValue("advanced/cgalCacheSize").toULongLong() / (1024ul * 1024ul); // carry over old settings if they exist
-  this->defaultmap["advanced/openCSGLimit"] = RenderSettings::inst()->openCSGTermLimit;
+  this->defaultmap["advanced/polysetCacheSize"] = qulonglong (GeometryCache::instance ()->maxSizeMB ()) * 1024ul * 1024ul;
+  this->defaultmap["advanced/polysetCacheSizeMB"] = getValue ("advanced/polysetCacheSize").toULongLong () / (1024ul * 1024ul); // carry over old settings if they exist
+  this->defaultmap["advanced/cgalCacheSize"] = qulonglong (CGALCache::instance ()->maxSizeMB ()) * 1024ul * 1024ul;
+  this->defaultmap["advanced/cgalCacheSizeMB"] = getValue ("advanced/cgalCacheSize").toULongLong () / (1024ul * 1024ul); // carry over old settings if they exist
+  this->defaultmap["advanced/openCSGLimit"] = RenderSettings::inst ()->openCSGTermLimit;
   this->defaultmap["advanced/forceGoldfeather"] = false;
   this->defaultmap["advanced/undockableWindows"] = false;
   this->defaultmap["advanced/reorderWindows"] = true;
-  this->defaultmap["advanced/renderBackend3D"] = QString::fromStdString(renderBackend3DToString(RenderSettings::inst()->backend3D));
+  this->defaultmap["advanced/renderBackend3D"] = QString::fromStdString (renderBackend3DToString (RenderSettings::inst ()->backend3D));
   this->defaultmap["launcher/showOnStartup"] = true;
   this->defaultmap["advanced/localization"] = true;
   this->defaultmap["advanced/autoReloadRaise"] = false;
@@ -175,116 +174,114 @@ void Preferences::init() {
   this->defaultmap["editor/stepSize"] = 1;
 
   // Toolbar
-  auto *group = new QActionGroup(this);
-  addPrefPage(group, prefsAction3DView, page3DView);
-  addPrefPage(group, prefsActionEditor, pageEditor);
+  auto *group = new QActionGroup (this);
+  addPrefPage (group, prefsAction3DView, page3DView);
+  addPrefPage (group, prefsActionEditor, pageEditor);
 #ifdef OPENSCAD_UPDATER
-  addPrefPage(group, prefsActionUpdate, pageUpdate);
+  addPrefPage (group, prefsActionUpdate, pageUpdate);
 #else
-  this->toolBar->removeAction(prefsActionUpdate);
+  this->toolBar->removeAction (prefsActionUpdate);
 #endif
-  addPrefPage(group, prefsAction3DPrint, page3DPrint);
+  addPrefPage (group, prefsAction3DPrint, page3DPrint);
 #ifdef ENABLE_EXPERIMENTAL
-  addPrefPage(group, prefsActionFeatures, pageFeatures);
+  addPrefPage (group, prefsActionFeatures, pageFeatures);
 #else
-  this->toolBar->removeAction(prefsActionFeatures);
+  this->toolBar->removeAction (prefsActionFeatures);
 #endif
-  addPrefPage(group, prefsActionInput, pageInput);
-  addPrefPage(group, prefsActionInputButton, pageInputButton);
-  addPrefPage(group, prefsActionAdvanced, pageAdvanced);
-  addPrefPage(group, prefsActionDialogs, pageDialogs);
+  addPrefPage (group, prefsActionInput, pageInput);
+  addPrefPage (group, prefsActionInputButton, pageInputButton);
+  addPrefPage (group, prefsActionAdvanced, pageAdvanced);
+  addPrefPage (group, prefsActionDialogs, pageDialogs);
 
-  connect(group, &QActionGroup::triggered, this, &Preferences::actionTriggered);
+  connect (group, &QActionGroup::triggered, this, &Preferences::actionTriggered);
 
-  prefsAction3DView->setChecked(true);
-  this->actionTriggered(this->prefsAction3DView);
+  prefsAction3DView->setChecked (true);
+  this->actionTriggered (this->prefsAction3DView);
 
   // 3D View pane
   this->defaultmap["3dview/colorscheme"] = "Cornfield";
 
   // Advanced pane
-  const int absolute_max = (sizeof(void *) == 8) ? 1024 * 1024 : 2048; // 1TB for 64bit or 2GB for 32bit
-  QValidator *memvalidator = new QIntValidator(1, absolute_max, this);
-  auto *uintValidator = new QIntValidator(this);
-  uintValidator->setBottom(0);
-  QValidator *validator1 = new QRegularExpressionValidator(QRegularExpression("[1-9][0-9]{0,1}"), this); // range between 1-99 both inclusive
+  const int absolute_max = (sizeof (void *) == 8) ? 1024 * 1024 : 2048; // 1TB for 64bit or 2GB for 32bit
+  QValidator *memvalidator = new QIntValidator (1, absolute_max, this);
+  auto *uintValidator = new QIntValidator (this);
+  uintValidator->setBottom (0);
+  QValidator *validator1 = new QRegularExpressionValidator (QRegularExpression ("[1-9][0-9]{0,1}"), this); // range between 1-99 both inclusive
 #ifdef ENABLE_CGAL
-  this->cgalCacheSizeMBEdit->setValidator(memvalidator);
+  this->cgalCacheSizeMBEdit->setValidator (memvalidator);
 #endif
-  this->polysetCacheSizeMBEdit->setValidator(memvalidator);
-  this->opencsgLimitEdit->setValidator(uintValidator);
-  this->timeThresholdOnRenderCompleteSoundEdit->setValidator(uintValidator);
-  this->consoleMaxLinesEdit->setValidator(uintValidator);
-  this->lineEditCharacterThreshold->setValidator(validator1);
-  this->lineEditStepSize->setValidator(validator1);
-  this->traceDepthEdit->setValidator(uintValidator);
-
-  auto menu = new QMenu();
-  menu->addAction(actionLocalAppParameterFile);
-  menu->addAction(actionLocalAppParameterDir);
-  menu->addAction(actionLocalAppParameterExtension);
-  menu->addAction(actionLocalAppParameterSource);
-  menu->addAction(actionLocalAppParameterSourceDir);
-  toolButtonLocalAppParameterAddFile->setMenu(menu);
-
-  Settings::Settings::visit(SettingsReader());
-
-  initComboBox(this->comboBoxIndentUsing, Settings::Settings::indentStyle);
-  initComboBox(this->comboBoxLineWrap, Settings::Settings::lineWrap);
-  initComboBox(this->comboBoxLineWrapIndentationStyle, Settings::Settings::lineWrapIndentationStyle);
-  initComboBox(this->comboBoxLineWrapVisualizationEnd, Settings::Settings::lineWrapVisualizationEnd);
-  initComboBox(this->comboBoxLineWrapVisualizationStart, Settings::Settings::lineWrapVisualizationBegin);
-  initComboBox(this->comboBoxShowWhitespace, Settings::Settings::showWhitespace);
-  initComboBox(this->comboBoxModifierNumberScrollWheel, Settings::Settings::modifierNumberScrollWheel);
-  initIntSpinBox(this->spinBoxIndentationWidth, Settings::Settings::indentationWidth);
-  initIntSpinBox(this->spinBoxLineWrapIndentationIndent, Settings::Settings::lineWrapIndentation);
-  initIntSpinBox(this->spinBoxShowWhitespaceSize, Settings::Settings::showWhitespaceSize);
-  initIntSpinBox(this->spinBoxTabWidth, Settings::Settings::tabWidth);
-
-  initComboBox(this->comboBoxOctoPrintFileFormat, Settings::Settings::octoPrintFileFormat);
-  initComboBox(this->comboBoxOctoPrintAction, Settings::Settings::octoPrintAction);
-  initComboBox(this->comboBoxLocalAppFileFormat, Settings::Settings::localAppFileFormat);
-  initComboBox(this->comboBoxRenderBackend3D, Settings::Settings::renderBackend3D);
-  initComboBox(this->comboBoxToolbarExport3D, Settings::Settings::toolbarExport3D);
-  initComboBox(this->comboBoxToolbarExport2D, Settings::Settings::toolbarExport2D);
-
-  initListBox(this->listWidgetLocalAppParams, Settings::Settings::localAppParameterList);
-  connect(this->listWidgetLocalAppParams->model(), &QAbstractItemModel::dataChanged, this, &Preferences::listWidgetLocalAppParamsModelDataChanged);
-  connect(this->listWidgetLocalAppParams->model(), &QAbstractItemModel::rowsInserted, this, &Preferences::listWidgetLocalAppParamsModelDataChanged);
-  connect(this->listWidgetLocalAppParams->model(), &QAbstractItemModel::rowsRemoved, this, &Preferences::listWidgetLocalAppParamsModelDataChanged);
-
-  installIgnoreWheelWhenNotFocused(this);
-
-  const QString slicer = QString::fromStdString(Settings::Settings::octoPrintSlicerEngine.value());
-  const QString slicerDesc = QString::fromStdString(Settings::Settings::octoPrintSlicerEngineDesc.value());
-  const QString profile = QString::fromStdString(Settings::Settings::octoPrintSlicerProfile.value());
-  const QString profileDesc = QString::fromStdString(Settings::Settings::octoPrintSlicerProfileDesc.value());
-  BlockSignals<QLineEdit *>(this->lineEditLocalAppExecutable)->setText(QString::fromStdString(Settings::Settings::localAppExecutable.value()));
-  BlockSignals<QLineEdit *>(this->lineEditLocalAppTempDir)->setText(QString::fromStdString(Settings::Settings::localAppTempDir.value()));
-  this->comboBoxOctoPrintSlicingEngine->clear();
-  this->comboBoxOctoPrintSlicingEngine->addItem(_("<Default>"), QVariant{""});
-  if (!slicer.isEmpty()) {
-    this->comboBoxOctoPrintSlicingEngine->addItem(slicerDesc, QVariant{slicer});
+  this->polysetCacheSizeMBEdit->setValidator (memvalidator);
+  this->opencsgLimitEdit->setValidator (uintValidator);
+  this->timeThresholdOnRenderCompleteSoundEdit->setValidator (uintValidator);
+  this->consoleMaxLinesEdit->setValidator (uintValidator);
+  this->lineEditCharacterThreshold->setValidator (validator1);
+  this->lineEditStepSize->setValidator (validator1);
+  this->traceDepthEdit->setValidator (uintValidator);
+
+  auto menu = new QMenu ();
+  menu->addAction (actionLocalAppParameterFile);
+  menu->addAction (actionLocalAppParameterDir);
+  menu->addAction (actionLocalAppParameterExtension);
+  menu->addAction (actionLocalAppParameterSource);
+  menu->addAction (actionLocalAppParameterSourceDir);
+  toolButtonLocalAppParameterAddFile->setMenu (menu);
+
+  Settings::Settings::visit (SettingsReader ());
+
+  initComboBox (this->comboBoxIndentUsing, Settings::Settings::indentStyle);
+  initComboBox (this->comboBoxLineWrap, Settings::Settings::lineWrap);
+  initComboBox (this->comboBoxLineWrapIndentationStyle, Settings::Settings::lineWrapIndentationStyle);
+  initComboBox (this->comboBoxLineWrapVisualizationEnd, Settings::Settings::lineWrapVisualizationEnd);
+  initComboBox (this->comboBoxLineWrapVisualizationStart, Settings::Settings::lineWrapVisualizationBegin);
+  initComboBox (this->comboBoxShowWhitespace, Settings::Settings::showWhitespace);
+  initComboBox (this->comboBoxModifierNumberScrollWheel, Settings::Settings::modifierNumberScrollWheel);
+  initIntSpinBox (this->spinBoxIndentationWidth, Settings::Settings::indentationWidth);
+  initIntSpinBox (this->spinBoxLineWrapIndentationIndent, Settings::Settings::lineWrapIndentation);
+  initIntSpinBox (this->spinBoxShowWhitespaceSize, Settings::Settings::showWhitespaceSize);
+  initIntSpinBox (this->spinBoxTabWidth, Settings::Settings::tabWidth);
+
+  initComboBox (this->comboBoxOctoPrintFileFormat, Settings::Settings::octoPrintFileFormat);
+  initComboBox (this->comboBoxOctoPrintAction, Settings::Settings::octoPrintAction);
+  initComboBox (this->comboBoxLocalAppFileFormat, Settings::Settings::localAppFileFormat);
+  initComboBox (this->comboBoxRenderBackend3D, Settings::Settings::renderBackend3D);
+  initComboBox (this->comboBoxToolbarExport3D, Settings::Settings::toolbarExport3D);
+  initComboBox (this->comboBoxToolbarExport2D, Settings::Settings::toolbarExport2D);
+
+  initListBox (this->listWidgetLocalAppParams, Settings::Settings::localAppParameterList);
+  connect (this->listWidgetLocalAppParams->model (), &QAbstractItemModel::dataChanged, this, &Preferences::listWidgetLocalAppParamsModelDataChanged);
+  connect (this->listWidgetLocalAppParams->model (), &QAbstractItemModel::rowsInserted, this, &Preferences::listWidgetLocalAppParamsModelDataChanged);
+  connect (this->listWidgetLocalAppParams->model (), &QAbstractItemModel::rowsRemoved, this, &Preferences::listWidgetLocalAppParamsModelDataChanged);
+
+  installIgnoreWheelWhenNotFocused (this);
+
+  const QString slicer = QString::fromStdString (Settings::Settings::octoPrintSlicerEngine.value ());
+  const QString slicerDesc = QString::fromStdString (Settings::Settings::octoPrintSlicerEngineDesc.value ());
+  const QString profile = QString::fromStdString (Settings::Settings::octoPrintSlicerProfile.value ());
+  const QString profileDesc = QString::fromStdString (Settings::Settings::octoPrintSlicerProfileDesc.value ());
+  BlockSignals<QLineEdit *> (this->lineEditLocalAppExecutable)->setText (QString::fromStdString (Settings::Settings::localAppExecutable.value ()));
+  BlockSignals<QLineEdit *> (this->lineEditLocalAppTempDir)->setText (QString::fromStdString (Settings::Settings::localAppTempDir.value ()));
+  this->comboBoxOctoPrintSlicingEngine->clear ();
+  this->comboBoxOctoPrintSlicingEngine->addItem (_ ("<Default>"), QVariant{""});
+  if (!slicer.isEmpty ()) {
+    this->comboBoxOctoPrintSlicingEngine->addItem (slicerDesc, QVariant{slicer});
   }
-  this->comboBoxOctoPrintSlicingProfile->clear();
-  this->comboBoxOctoPrintSlicingProfile->addItem(_("<Default>"), QVariant{""});
-  if (!profile.isEmpty()) {
-    this->comboBoxOctoPrintSlicingProfile->addItem(profileDesc, QVariant{profile});
+  this->comboBoxOctoPrintSlicingProfile->clear ();
+  this->comboBoxOctoPrintSlicingProfile->addItem (_ ("<Default>"), QVariant{""});
+  if (!profile.isEmpty ()) {
+    this->comboBoxOctoPrintSlicingProfile->addItem (profileDesc, QVariant{profile});
   }
 
-  emit editorConfigChanged();
+  emit editorConfigChanged ();
 }
 
-Preferences::~Preferences()
-{
-  removeDefaultSettings();
+Preferences::~Preferences () {
+  removeDefaultSettings ();
 }
 
-void Preferences::update()
-{
-  this->checkBoxAlwaysShowExportPdfDialog->setChecked(Settings::SettingsExportPdf::exportPdfAlwaysShowDialog.value());
-  this->checkBoxAlwaysShowExport3mfDialog->setChecked(Settings::SettingsExport3mf::export3mfAlwaysShowDialog.value());
-  this->checkBoxAlwaysShowPrintServiceDialog->setChecked(Settings::Settings::printServiceAlwaysShowDialog.value());
+void Preferences::update () {
+  this->checkBoxAlwaysShowExportPdfDialog->setChecked (Settings::SettingsExportPdf::exportPdfAlwaysShowDialog.value ());
+  this->checkBoxAlwaysShowExport3mfDialog->setChecked (Settings::SettingsExport3mf::export3mfAlwaysShowDialog.value ());
+  this->checkBoxAlwaysShowPrintServiceDialog->setChecked (Settings::Settings::printServiceAlwaysShowDialog.value ());
 }
 
 /**
@@ -298,9 +295,8 @@ void Preferences::update()
  * @param widget The widget that should be shown when the action is triggered.
  *               This must be a child page of the stackedWidget.
  */
-void Preferences::addPrefPage(QActionGroup *group, QAction *action, QWidget *widget)
-{
-  group->addAction(action);
+void Preferences::addPrefPage (QActionGroup *group, QAction *action, QWidget *widget) {
+  group->addAction (action);
   prefPages[action] = widget;
 }
 
@@ -309,27 +305,24 @@ void Preferences::addPrefPage(QActionGroup *group, QAction *action, QWidget *wid
  *
  * @param action The action triggered by the user.
  */
-void Preferences::actionTriggered(QAction *action)
-{
-  this->stackedWidget->setCurrentWidget(prefPages[action]);
+void Preferences::actionTriggered (QAction *action) {
+  this->stackedWidget->setCurrentWidget (prefPages[action]);
 }
 
 /**
  * Called at least on showing / closing the Preferences dialog
  * and when switching tabs.
  */
-void Preferences::hidePasswords()
-{
-  this->pushButtonOctoPrintApiKey->setChecked(false);
-  this->lineEditOctoPrintApiKey->setEchoMode(QLineEdit::EchoMode::PasswordEchoOnEdit);
+void Preferences::hidePasswords () {
+  this->pushButtonOctoPrintApiKey->setChecked (false);
+  this->lineEditOctoPrintApiKey->setEchoMode (QLineEdit::EchoMode::PasswordEchoOnEdit);
 }
 
-void Preferences::on_stackedWidget_currentChanged(int)
-{
-  hidePasswords();
-  this->labelOctoPrintCheckConnection->setText("");
-  this->AxisConfig->updateStates();
-  this->ButtonConfig->updateStates();
+void Preferences::on_stackedWidget_currentChanged (int) {
+  hidePasswords ();
+  this->labelOctoPrintCheckConnection->setText ("");
+  this->AxisConfig->updateStates ();
+  this->ButtonConfig->updateStates ();
 }
 
 /**
@@ -339,21 +332,20 @@ void Preferences::on_stackedWidget_currentChanged(int)
  *
  * @param state the state of the checkbox.
  */
-void Preferences::featuresCheckBoxToggled(bool state)
-{
-  const QObject *sender = QObject::sender();
+void Preferences::featuresCheckBoxToggled (bool state) {
+  const QObject *sender = QObject::sender ();
   if (sender == nullptr) {
     return;
   }
-  QVariant v = sender->property(featurePropertyName);
-  if (!v.isValid()) {
+  QVariant v = sender->property (featurePropertyName);
+  if (!v.isValid ()) {
     return;
   }
-  auto *feature = v.value<Feature *>();
-  feature->enable(state);
+  auto *feature = v.value<Feature *> ();
+  feature->enable (state);
   QSettingsCached settings;
-  settings.setValue(QString("feature/%1").arg(QString::fromStdString(feature->get_name())), state);
-  emit ExperimentalChanged();
+  settings.setValue (QString ("feature/%1").arg (QString::fromStdString (feature->get_name ())), state);
+  emit ExperimentalChanged ();
 }
 
 /**
@@ -363,1044 +355,922 @@ void Preferences::featuresCheckBoxToggled(bool state)
  * from commandline is ignored. This always uses the value coming from the
  * QSettings.
  */
-void Preferences::setupFeaturesPage()
-{
+void Preferences::setupFeaturesPage () {
   int row = 0;
-  for (auto it = Feature::begin(); it != Feature::end(); ++it) {
+  for (auto it = Feature::begin (); it != Feature::end (); ++it) {
     Feature *feature = *it;
 
-    QString featurekey = QString("feature/%1").arg(QString::fromStdString(feature->get_name()));
+    QString featurekey = QString ("feature/%1").arg (QString::fromStdString (feature->get_name ()));
     this->defaultmap[featurekey] = false;
 
     // spacer item between the features, just for some optical separation
-    gridLayoutExperimentalFeatures->addItem(new QSpacerItem(1, 8, QSizePolicy::Expanding, QSizePolicy::Fixed), row, 1, 1, 1, Qt::AlignCenter);
+    gridLayoutExperimentalFeatures->addItem (new QSpacerItem (1, 8, QSizePolicy::Expanding, QSizePolicy::Fixed), row, 1, 1, 1, Qt::AlignCenter);
     row++;
 
-    auto *cb = new QCheckBox(QString::fromStdString(feature->get_name()), pageFeatures);
-    QFont bold_font(cb->font());
-    bold_font.setBold(true);
-    cb->setFont(bold_font);
+    auto *cb = new QCheckBox (QString::fromStdString (feature->get_name ()), pageFeatures);
+    QFont bold_font (cb->font ());
+    bold_font.setBold (true);
+    cb->setFont (bold_font);
     // synchronize Qt settings with the feature settings
-    bool value = getValue(featurekey).toBool();
-    feature->enable(value);
-    cb->setChecked(value);
-    cb->setProperty(featurePropertyName, QVariant::fromValue<Feature *>(feature));
-    connect(cb, &QCheckBox::toggled, this, &Preferences::featuresCheckBoxToggled);
-    gridLayoutExperimentalFeatures->addWidget(cb, row, 0, 1, 2, Qt::AlignLeading);
+    bool value = getValue (featurekey).toBool ();
+    feature->enable (value);
+    cb->setChecked (value);
+    cb->setProperty (featurePropertyName, QVariant::fromValue<Feature *> (feature));
+    connect (cb, &QCheckBox::toggled, this, &Preferences::featuresCheckBoxToggled);
+    gridLayoutExperimentalFeatures->addWidget (cb, row, 0, 1, 2, Qt::AlignLeading);
     row++;
 
-    auto *l = new QLabel(QString::fromStdString(feature->get_description()), pageFeatures);
-    l->setTextFormat(Qt::RichText);
-    gridLayoutExperimentalFeatures->addWidget(l, row, 1, 1, 1, Qt::AlignLeading);
+    auto *l = new QLabel (QString::fromStdString (feature->get_description ()), pageFeatures);
+    l->setTextFormat (Qt::RichText);
+    gridLayoutExperimentalFeatures->addWidget (l, row, 1, 1, 1, Qt::AlignLeading);
     row++;
   }
   // Force fixed indentation, the checkboxes use column span of 2 so
   // first row is not constrained in size by the visible controls. The
   // fixed size space essentially gives the first row the width of the
   // spacer item itself.
-  gridLayoutExperimentalFeatures->addItem(new QSpacerItem(20, 0, QSizePolicy::Fixed, QSizePolicy::Fixed), 1, 0, 1, 1, Qt::AlignLeading);
+  gridLayoutExperimentalFeatures->addItem (new QSpacerItem (20, 0, QSizePolicy::Fixed, QSizePolicy::Fixed), 1, 0, 1, 1, Qt::AlignLeading);
 }
 
-void Preferences::setup3DPrintPage()
-{
-  const auto& currentPrintService = Settings::Settings::defaultPrintService.value();
-  const auto currentPrintServiceName = QString::fromStdString(Settings::Settings::printServiceName.value());
-  checkBoxEnableRemotePrintServices->setChecked(Settings::Settings::enableRemotePrintServices.value());
-  comboBoxDefaultPrintService->clear();
+void Preferences::setup3DPrintPage () {
+  const auto &currentPrintService = Settings::Settings::defaultPrintService.value ();
+  const auto currentPrintServiceName = QString::fromStdString (Settings::Settings::printServiceName.value ());
+  checkBoxEnableRemotePrintServices->setChecked (Settings::Settings::enableRemotePrintServices.value ());
+  comboBoxDefaultPrintService->clear ();
   const std::unordered_map<std::string, QString> services = {
-    {"NONE", _("NONE")},
-    {"OCTOPRINT", _("OctoPrint")},
-    {"LOCAL_APPLICATION", _("Local Application")},
+    {"NONE", _ ("NONE")},
+    {"OCTOPRINT", _ ("OctoPrint")},
+    {"LOCAL_APPLICATION", _ ("Local Application")},
   };
 
-  comboBoxDefaultPrintService->addItem(services.at("NONE"),
-                                       QStringList{"NONE", ""});
-  for (const auto& printServiceItem : PrintService::getPrintServices()) {
-    const auto& key = printServiceItem.first;
-    const auto& printService = printServiceItem.second;
-    const auto settingValue = QStringList{"PRINT_SERVICE", QString::fromStdString(key)};
-    const auto displayName = QString(printService->getDisplayName());
-    comboBoxDefaultPrintService->addItem(displayName, settingValue);
-    if (key == currentPrintServiceName.toStdString()) {
-      comboBoxDefaultPrintService->setCurrentText(
-        QString(printService->getDisplayName()));
+  comboBoxDefaultPrintService->addItem (services.at ("NONE"),
+                                        QStringList{"NONE", ""});
+  for (const auto &printServiceItem : PrintService::getPrintServices ()) {
+    const auto &key = printServiceItem.first;
+    const auto &printService = printServiceItem.second;
+    const auto settingValue = QStringList{"PRINT_SERVICE", QString::fromStdString (key)};
+    const auto displayName = QString (printService->getDisplayName ());
+    comboBoxDefaultPrintService->addItem (displayName, settingValue);
+    if (key == currentPrintServiceName.toStdString ()) {
+      comboBoxDefaultPrintService->setCurrentText (
+        QString (printService->getDisplayName ()));
     }
   }
-  comboBoxDefaultPrintService->addItem(services.at("OCTOPRINT"),
-                                       QStringList{"OCTOPRINT", ""});
-  comboBoxDefaultPrintService->addItem(services.at("LOCAL_APPLICATION"),
-                                       QStringList{"LOCAL_APPLICATION", ""});
-
-  auto it = services.find(currentPrintService);
-  if (it != services.end()) {
-    comboBoxDefaultPrintService->setCurrentText(it->second);
+  comboBoxDefaultPrintService->addItem (services.at ("OCTOPRINT"),
+                                        QStringList{"OCTOPRINT", ""});
+  comboBoxDefaultPrintService->addItem (services.at ("LOCAL_APPLICATION"),
+                                        QStringList{"LOCAL_APPLICATION", ""});
+
+  auto it = services.find (currentPrintService);
+  if (it != services.end ()) {
+    comboBoxDefaultPrintService->setCurrentText (it->second);
   }
 }
 
-void Preferences::on_colorSchemeChooser_itemSelectionChanged()
-{
-  QString scheme = this->colorSchemeChooser->currentItem()->text();
+void Preferences::on_colorSchemeChooser_itemSelectionChanged () {
+  QString scheme = this->colorSchemeChooser->currentItem ()->text ();
   QSettingsCached settings;
-  settings.setValue("3dview/colorscheme", scheme);
-  emit colorSchemeChanged(scheme);
+  settings.setValue ("3dview/colorscheme", scheme);
+  emit colorSchemeChanged (scheme);
 }
 
-void Preferences::on_fontChooser_currentFontChanged(const QFont& font)
-{
+void Preferences::on_fontChooser_currentFontChanged (const QFont &font) {
   QSettingsCached settings;
-  settings.setValue("editor/fontfamily", font.family());
-  emit fontChanged(font.family(), getValue("editor/fontsize").toUInt());
+  settings.setValue ("editor/fontfamily", font.family ());
+  emit fontChanged (font.family (), getValue ("editor/fontsize").toUInt ());
 }
 
-void Preferences::on_fontSize_currentIndexChanged(int index)
-{
-  uint intsize = this->fontSize->itemText(index).toUInt();
+void Preferences::on_fontSize_currentIndexChanged (int index) {
+  uint intsize = this->fontSize->itemText (index).toUInt ();
   QSettingsCached settings;
-  settings.setValue("editor/fontsize", intsize);
-  emit fontChanged(getValue("editor/fontfamily").toString(), intsize);
+  settings.setValue ("editor/fontsize", intsize);
+  emit fontChanged (getValue ("editor/fontfamily").toString (), intsize);
 }
 
-void Preferences::on_syntaxHighlight_currentTextChanged(const QString& s)
-{
+void Preferences::on_syntaxHighlight_currentTextChanged (const QString &s) {
   QSettingsCached settings;
-  settings.setValue("editor/syntaxhighlight", s);
-  emit syntaxHighlightChanged(s);
+  settings.setValue ("editor/syntaxhighlight", s);
+  emit syntaxHighlightChanged (s);
 }
 
-void unimplemented_msg()
-{
+void unimplemented_msg () {
   QMessageBox mbox;
-  mbox.setText("Sorry, this feature is not implemented on your Operating System");
-  mbox.exec();
+  mbox.setText ("Sorry, this feature is not implemented on your Operating System");
+  mbox.exec ();
 }
 
-void Preferences::on_updateCheckBox_toggled(bool on)
-{
-  if (AutoUpdater *updater = AutoUpdater::updater()) {
-    updater->setAutomaticallyChecksForUpdates(on);
+void Preferences::on_updateCheckBox_toggled (bool on) {
+  if (AutoUpdater *updater = AutoUpdater::updater ()) {
+    updater->setAutomaticallyChecksForUpdates (on);
   } else {
-    unimplemented_msg();
+    unimplemented_msg ();
   }
 }
 
-void Preferences::on_snapshotCheckBox_toggled(bool on)
-{
-  if (AutoUpdater *updater = AutoUpdater::updater()) {
-    updater->setEnableSnapshots(on);
+void Preferences::on_snapshotCheckBox_toggled (bool on) {
+  if (AutoUpdater *updater = AutoUpdater::updater ()) {
+    updater->setEnableSnapshots (on);
   } else {
-    unimplemented_msg();
+    unimplemented_msg ();
   }
 }
 
-void Preferences::on_checkNowButton_clicked()
-{
-  if (AutoUpdater *updater = AutoUpdater::updater()) {
-    updater->checkForUpdates();
+void Preferences::on_checkNowButton_clicked () {
+  if (AutoUpdater *updater = AutoUpdater::updater ()) {
+    updater->checkForUpdates ();
   } else {
-    unimplemented_msg();
+    unimplemented_msg ();
   }
 }
 
-void
-Preferences::on_reorderCheckBox_toggled(bool state)
-{
+void Preferences::on_reorderCheckBox_toggled (bool state) {
   if (!state) {
-    undockCheckBox->setChecked(false);
+    undockCheckBox->setChecked (false);
   }
-  undockCheckBox->setEnabled(state);
+  undockCheckBox->setEnabled (state);
   QSettingsCached settings;
-  settings.setValue("advanced/reorderWindows", state);
-  emit updateReorderMode(state);
+  settings.setValue ("advanced/reorderWindows", state);
+  emit updateReorderMode (state);
 }
 
-void
-Preferences::on_undockCheckBox_toggled(bool state)
-{
+void Preferences::on_undockCheckBox_toggled (bool state) {
   QSettingsCached settings;
-  settings.setValue("advanced/undockableWindows", state);
-  emit updateUndockMode(state);
+  settings.setValue ("advanced/undockableWindows", state);
+  emit updateUndockMode (state);
 }
 
-void
-Preferences::on_openCSGWarningBox_toggled(bool state)
-{
+void Preferences::on_openCSGWarningBox_toggled (bool state) {
   QSettingsCached settings;
-  settings.setValue("advanced/opencsg_show_warning", state);
+  settings.setValue ("advanced/opencsg_show_warning", state);
 }
 
-void Preferences::on_cgalCacheSizeMBEdit_textChanged(const QString& text)
-{
+void Preferences::on_cgalCacheSizeMBEdit_textChanged (const QString &text) {
   QSettingsCached settings;
-  settings.setValue("advanced/cgalCacheSizeMB", text);
-  CGALCache::instance()->setMaxSizeMB(text.toULong());
+  settings.setValue ("advanced/cgalCacheSizeMB", text);
+  CGALCache::instance ()->setMaxSizeMB (text.toULong ());
 }
 
-void Preferences::on_polysetCacheSizeMBEdit_textChanged(const QString& text)
-{
+void Preferences::on_polysetCacheSizeMBEdit_textChanged (const QString &text) {
   QSettingsCached settings;
-  settings.setValue("advanced/polysetCacheSizeMB", text);
-  GeometryCache::instance()->setMaxSizeMB(text.toULong());
+  settings.setValue ("advanced/polysetCacheSizeMB", text);
+  GeometryCache::instance ()->setMaxSizeMB (text.toULong ());
 }
 
-void Preferences::on_opencsgLimitEdit_textChanged(const QString& text)
-{
+void Preferences::on_opencsgLimitEdit_textChanged (const QString &text) {
   QSettingsCached settings;
-  settings.setValue("advanced/openCSGLimit", text);
+  settings.setValue ("advanced/openCSGLimit", text);
   // FIXME: Set this globally?
 }
 
-void Preferences::on_localizationCheckBox_toggled(bool state)
-{
+void Preferences::on_localizationCheckBox_toggled (bool state) {
   QSettingsCached settings;
-  settings.setValue("advanced/localization", state);
+  settings.setValue ("advanced/localization", state);
 }
 
-void Preferences::on_autoReloadRaiseCheckBox_toggled(bool state)
-{
+void Preferences::on_autoReloadRaiseCheckBox_toggled (bool state) {
   QSettingsCached settings;
-  settings.setValue("advanced/autoReloadRaise", state);
+  settings.setValue ("advanced/autoReloadRaise", state);
 }
 
-void Preferences::on_forceGoldfeatherBox_toggled(bool state)
-{
+void Preferences::on_forceGoldfeatherBox_toggled (bool state) {
   QSettingsCached settings;
-  settings.setValue("advanced/forceGoldfeather", state);
-  emit openCSGSettingsChanged();
+  settings.setValue ("advanced/forceGoldfeather", state);
+  emit openCSGSettingsChanged ();
 }
 
-void Preferences::on_mouseWheelZoomBox_toggled(bool state)
-{
+void Preferences::on_mouseWheelZoomBox_toggled (bool state) {
   QSettingsCached settings;
-  settings.setValue("editor/ctrlmousewheelzoom", state);
+  settings.setValue ("editor/ctrlmousewheelzoom", state);
 }
 
-void Preferences::on_launcherBox_toggled(bool state)
-{
+void Preferences::on_launcherBox_toggled (bool state) {
   QSettingsCached settings;
-  settings.setValue("launcher/showOnStartup", state);
+  settings.setValue ("launcher/showOnStartup", state);
 }
 
-void Preferences::on_checkBoxShowWarningsIn3dView_toggled(bool val)
-{
-  Settings::Settings::showWarningsIn3dView.setValue(val);
-  writeSettings();
+void Preferences::on_checkBoxShowWarningsIn3dView_toggled (bool val) {
+  Settings::Settings::showWarningsIn3dView.setValue (val);
+  writeSettings ();
 }
 
-void Preferences::on_checkBoxMouseCentricZoom_toggled(bool val)
-{
-  Settings::Settings::mouseCentricZoom.setValue(val);
-  writeSettings();
-  emit updateMouseCentricZoom(val);
+void Preferences::on_checkBoxMouseCentricZoom_toggled (bool val) {
+  Settings::Settings::mouseCentricZoom.setValue (val);
+  writeSettings ();
+  emit updateMouseCentricZoom (val);
 }
 
-void Preferences::on_checkBoxMouseSwapButtons_toggled(bool val)
-{
-  Settings::Settings::mouseSwapButtons.setValue(val);
-  writeSettings();
-  emit updateMouseSwapButtons(val);
+void Preferences::on_checkBoxMouseSwapButtons_toggled (bool val) {
+  Settings::Settings::mouseSwapButtons.setValue (val);
+  writeSettings ();
+  emit updateMouseSwapButtons (val);
 }
 
-void Preferences::on_spinBoxIndentationWidth_valueChanged(int val)
-{
-  Settings::Settings::indentationWidth.setValue(val);
-  writeSettings();
+void Preferences::on_spinBoxIndentationWidth_valueChanged (int val) {
+  Settings::Settings::indentationWidth.setValue (val);
+  writeSettings ();
 }
 
-void Preferences::on_spinBoxTabWidth_valueChanged(int val)
-{
-  Settings::Settings::tabWidth.setValue(val);
-  writeSettings();
+void Preferences::on_spinBoxTabWidth_valueChanged (int val) {
+  Settings::Settings::tabWidth.setValue (val);
+  writeSettings ();
 }
 
-void Preferences::on_comboBoxLineWrap_activated(int val)
-{
-  applyComboBox(comboBoxLineWrap, val, Settings::Settings::lineWrap);
+void Preferences::on_comboBoxLineWrap_activated (int val) {
+  applyComboBox (comboBoxLineWrap, val, Settings::Settings::lineWrap);
 }
 
-void Preferences::on_comboBoxLineWrapIndentationStyle_activated(int val)
-{
+void Preferences::on_comboBoxLineWrapIndentationStyle_activated (int val) {
   //Next Line disables the Indent Spin-Box when 'Same' or 'Indented' is chosen from LineWrapIndentationStyle Combo-Box.
-  spinBoxLineWrapIndentationIndent->setDisabled(comboBoxLineWrapIndentationStyle->currentData() == "Same" || comboBoxLineWrapIndentationStyle->currentData() == "Indented");
+  spinBoxLineWrapIndentationIndent->setDisabled (comboBoxLineWrapIndentationStyle->currentData () == "Same" || comboBoxLineWrapIndentationStyle->currentData () == "Indented");
 
-  applyComboBox(comboBoxLineWrapIndentationStyle, val, Settings::Settings::lineWrapIndentationStyle);
+  applyComboBox (comboBoxLineWrapIndentationStyle, val, Settings::Settings::lineWrapIndentationStyle);
 }
 
-void Preferences::on_spinBoxLineWrapIndentationIndent_valueChanged(int val)
-{
-  Settings::Settings::lineWrapIndentation.setValue(val);
-  writeSettings();
+void Preferences::on_spinBoxLineWrapIndentationIndent_valueChanged (int val) {
+  Settings::Settings::lineWrapIndentation.setValue (val);
+  writeSettings ();
 }
 
-void Preferences::on_comboBoxLineWrapVisualizationStart_activated(int val)
-{
-  applyComboBox(comboBoxLineWrapVisualizationStart, val, Settings::Settings::lineWrapVisualizationBegin);
+void Preferences::on_comboBoxLineWrapVisualizationStart_activated (int val) {
+  applyComboBox (comboBoxLineWrapVisualizationStart, val, Settings::Settings::lineWrapVisualizationBegin);
 }
 
-void Preferences::on_comboBoxLineWrapVisualizationEnd_activated(int val)
-{
-  applyComboBox(comboBoxLineWrapVisualizationEnd, val, Settings::Settings::lineWrapVisualizationEnd);
+void Preferences::on_comboBoxLineWrapVisualizationEnd_activated (int val) {
+  applyComboBox (comboBoxLineWrapVisualizationEnd, val, Settings::Settings::lineWrapVisualizationEnd);
 }
 
-void Preferences::on_comboBoxShowWhitespace_activated(int val)
-{
-  applyComboBox(comboBoxShowWhitespace, val, Settings::Settings::showWhitespace);
+void Preferences::on_comboBoxShowWhitespace_activated (int val) {
+  applyComboBox (comboBoxShowWhitespace, val, Settings::Settings::showWhitespace);
 }
 
-void Preferences::on_spinBoxShowWhitespaceSize_valueChanged(int val)
-{
-  Settings::Settings::showWhitespaceSize.setValue(val);
-  writeSettings();
+void Preferences::on_spinBoxShowWhitespaceSize_valueChanged (int val) {
+  Settings::Settings::showWhitespaceSize.setValue (val);
+  writeSettings ();
 }
 
-void Preferences::on_checkBoxAutoIndent_toggled(bool val)
-{
-  Settings::Settings::autoIndent.setValue(val);
-  writeSettings();
+void Preferences::on_checkBoxAutoIndent_toggled (bool val) {
+  Settings::Settings::autoIndent.setValue (val);
+  writeSettings ();
 }
 
-void Preferences::on_checkBoxBackspaceUnindents_toggled(bool val)
-{
-  Settings::Settings::backspaceUnindents.setValue(val);
-  writeSettings();
+void Preferences::on_checkBoxBackspaceUnindents_toggled (bool val) {
+  Settings::Settings::backspaceUnindents.setValue (val);
+  writeSettings ();
 }
 
-void Preferences::on_comboBoxIndentUsing_activated(int val)
-{
-  applyComboBox(comboBoxIndentUsing, val, Settings::Settings::indentStyle);
+void Preferences::on_comboBoxIndentUsing_activated (int val) {
+  applyComboBox (comboBoxIndentUsing, val, Settings::Settings::indentStyle);
 }
 
-void Preferences::on_comboBoxTabKeyFunction_activated(int val)
-{
-  applyComboBox(comboBoxTabKeyFunction, val, Settings::Settings::tabKeyFunction);
+void Preferences::on_comboBoxTabKeyFunction_activated (int val) {
+  applyComboBox (comboBoxTabKeyFunction, val, Settings::Settings::tabKeyFunction);
 }
 
-void Preferences::on_checkBoxHighlightCurrentLine_toggled(bool val)
-{
-  Settings::Settings::highlightCurrentLine.setValue(val);
-  writeSettings();
+void Preferences::on_checkBoxHighlightCurrentLine_toggled (bool val) {
+  Settings::Settings::highlightCurrentLine.setValue (val);
+  writeSettings ();
 }
 
-void Preferences::on_checkBoxEnableBraceMatching_toggled(bool val)
-{
-  Settings::Settings::enableBraceMatching.setValue(val);
-  writeSettings();
+void Preferences::on_checkBoxEnableBraceMatching_toggled (bool val) {
+  Settings::Settings::enableBraceMatching.setValue (val);
+  writeSettings ();
 }
 
-void Preferences::on_checkBoxEnableLineNumbers_toggled(bool val)
-{
-  Settings::Settings::enableLineNumbers.setValue(val);
-  writeSettings();
+void Preferences::on_checkBoxEnableLineNumbers_toggled (bool val) {
+  Settings::Settings::enableLineNumbers.setValue (val);
+  writeSettings ();
 }
 
-void Preferences::on_checkBoxEnableNumberScrollWheel_toggled(bool val)
-{
-  Settings::Settings::enableNumberScrollWheel.setValue(val);
-  comboBoxModifierNumberScrollWheel->setDisabled(!val);
-  writeSettings();
+void Preferences::on_checkBoxEnableNumberScrollWheel_toggled (bool val) {
+  Settings::Settings::enableNumberScrollWheel.setValue (val);
+  comboBoxModifierNumberScrollWheel->setDisabled (!val);
+  writeSettings ();
 }
 
-void Preferences::on_enableSoundOnRenderCompleteCheckBox_toggled(bool state)
-{
+void Preferences::on_enableSoundOnRenderCompleteCheckBox_toggled (bool state) {
   QSettingsCached settings;
-  settings.setValue("advanced/enableSoundNotification", state);
-  this->timeThresholdOnRenderCompleteSoundLabel->setEnabled(state);
-  this->secLabelOnRenderCompleteSound->setEnabled(state);
-  this->timeThresholdOnRenderCompleteSoundEdit->setEnabled(state);
+  settings.setValue ("advanced/enableSoundNotification", state);
+  this->timeThresholdOnRenderCompleteSoundLabel->setEnabled (state);
+  this->secLabelOnRenderCompleteSound->setEnabled (state);
+  this->timeThresholdOnRenderCompleteSoundEdit->setEnabled (state);
 }
 
-void Preferences::on_timeThresholdOnRenderCompleteSoundEdit_textChanged(const QString& text)
-{
+void Preferences::on_timeThresholdOnRenderCompleteSoundEdit_textChanged (const QString &text) {
   QSettingsCached settings;
-  settings.setValue("advanced/timeThresholdOnRenderCompleteSound", text);
+  settings.setValue ("advanced/timeThresholdOnRenderCompleteSound", text);
 }
 
-void Preferences::on_enableClearConsoleCheckBox_toggled(bool state)
-{
+void Preferences::on_enableClearConsoleCheckBox_toggled (bool state) {
   QSettingsCached settings;
-  settings.setValue("advanced/consoleAutoClear", state);
+  settings.setValue ("advanced/consoleAutoClear", state);
 }
 
-void Preferences::on_consoleMaxLinesEdit_textChanged(const QString& text)
-{
+void Preferences::on_consoleMaxLinesEdit_textChanged (const QString &text) {
   QSettingsCached settings;
-  settings.setValue("advanced/consoleMaxLines", text);
+  settings.setValue ("advanced/consoleMaxLines", text);
 }
 
-void Preferences::on_consoleFontChooser_currentFontChanged(const QFont& font)
-{
+void Preferences::on_consoleFontChooser_currentFontChanged (const QFont &font) {
   QSettingsCached settings;
-  settings.setValue("advanced/consoleFontFamily", font.family());
-  emit consoleFontChanged(font.family(), getValue("advanced/consoleFontSize").toUInt());
+  settings.setValue ("advanced/consoleFontFamily", font.family ());
+  emit consoleFontChanged (font.family (), getValue ("advanced/consoleFontSize").toUInt ());
 }
 
-void Preferences::on_consoleFontSize_currentIndexChanged(int index)
-{
-  uint intsize = this->consoleFontSize->itemText(index).toUInt();
+void Preferences::on_consoleFontSize_currentIndexChanged (int index) {
+  uint intsize = this->consoleFontSize->itemText (index).toUInt ();
   QSettingsCached settings;
-  settings.setValue("advanced/consoleFontSize", intsize);
-  emit consoleFontChanged(getValue("advanced/consoleFontFamily").toString(), intsize);
+  settings.setValue ("advanced/consoleFontSize", intsize);
+  emit consoleFontChanged (getValue ("advanced/consoleFontFamily").toString (), intsize);
 }
 
-void Preferences::on_customizerFontChooser_currentFontChanged(const QFont& font)
-{
+void Preferences::on_customizerFontChooser_currentFontChanged (const QFont &font) {
   QSettingsCached settings;
-  settings.setValue("advanced/customizerFontFamily", font.family());
-  emit customizerFontChanged(font.family(), getValue("advanced/customizerFontSize").toUInt());
+  settings.setValue ("advanced/customizerFontFamily", font.family ());
+  emit customizerFontChanged (font.family (), getValue ("advanced/customizerFontSize").toUInt ());
 }
 
-void Preferences::on_customizerFontSize_currentIndexChanged(int index)
-{
-  uint intsize = this->customizerFontSize->itemText(index).toUInt();
+void Preferences::on_customizerFontSize_currentIndexChanged (int index) {
+  uint intsize = this->customizerFontSize->itemText (index).toUInt ();
   QSettingsCached settings;
-  settings.setValue("advanced/customizerFontSize", intsize);
-  emit customizerFontChanged(getValue("advanced/customizerFontFamily").toString(), intsize);
+  settings.setValue ("advanced/customizerFontSize", intsize);
+  emit customizerFontChanged (getValue ("advanced/customizerFontFamily").toString (), intsize);
 }
 
-void Preferences::on_checkBoxEnableAutocomplete_toggled(bool state)
-{
+void Preferences::on_checkBoxEnableAutocomplete_toggled (bool state) {
   QSettingsCached settings;
-  settings.setValue("editor/enableAutocomplete", state);
-  this->labelCharacterThreshold->setEnabled(state);
-  this->lineEditCharacterThreshold->setEnabled(state);
-  emit autocompleteChanged(state);
+  settings.setValue ("editor/enableAutocomplete", state);
+  this->labelCharacterThreshold->setEnabled (state);
+  this->lineEditCharacterThreshold->setEnabled (state);
+  emit autocompleteChanged (state);
 }
 
-void Preferences::on_lineEditCharacterThreshold_textChanged(const QString& text)
-{
+void Preferences::on_lineEditCharacterThreshold_textChanged (const QString &text) {
   QSettingsCached settings;
-  settings.setValue("editor/characterThreshold", text);
-  emit characterThresholdChanged(text.toInt());
+  settings.setValue ("editor/characterThreshold", text);
+  emit characterThresholdChanged (text.toInt ());
 }
 
-void Preferences::on_lineEditStepSize_textChanged(const QString& text)
-{
+void Preferences::on_lineEditStepSize_textChanged (const QString &text) {
   QSettingsCached settings;
-  settings.setValue("editor/stepSize", text);
-  emit stepSizeChanged(text.toInt());
+  settings.setValue ("editor/stepSize", text);
+  emit stepSizeChanged (text.toInt ());
 }
 
-void Preferences::on_comboBoxModifierNumberScrollWheel_activated(int val)
-{
-  applyComboBox(comboBoxModifierNumberScrollWheel, val, Settings::Settings::modifierNumberScrollWheel);
+void Preferences::on_comboBoxModifierNumberScrollWheel_activated (int val) {
+  applyComboBox (comboBoxModifierNumberScrollWheel, val, Settings::Settings::modifierNumberScrollWheel);
 }
 
-void Preferences::on_enableHardwarningsCheckBox_toggled(bool state)
-{
+void Preferences::on_enableHardwarningsCheckBox_toggled (bool state) {
   QSettingsCached settings;
-  settings.setValue("advanced/enableHardwarnings", state);
+  settings.setValue ("advanced/enableHardwarnings", state);
 }
 
-void Preferences::on_traceDepthEdit_textChanged(const QString& text)
-{
+void Preferences::on_traceDepthEdit_textChanged (const QString &text) {
   QSettingsCached settings;
-  settings.setValue("advanced/traceDepth", text);
+  settings.setValue ("advanced/traceDepth", text);
 }
 
-void Preferences::on_enableTraceUsermoduleParametersCheckBox_toggled(bool state)
-{
+void Preferences::on_enableTraceUsermoduleParametersCheckBox_toggled (bool state) {
   QSettingsCached settings;
-  settings.setValue("advanced/enableTraceUsermoduleParameters", state);
+  settings.setValue ("advanced/enableTraceUsermoduleParameters", state);
 }
 
-void Preferences::on_enableParameterCheckBox_toggled(bool state)
-{
+void Preferences::on_enableParameterCheckBox_toggled (bool state) {
   QSettingsCached settings;
-  settings.setValue("advanced/enableParameterCheck", state);
+  settings.setValue ("advanced/enableParameterCheck", state);
 }
 
-void Preferences::on_enableRangeCheckBox_toggled(bool state)
-{
+void Preferences::on_enableRangeCheckBox_toggled (bool state) {
   QSettingsCached settings;
-  settings.setValue("advanced/enableParameterRangeCheck", state);
+  settings.setValue ("advanced/enableParameterRangeCheck", state);
 }
 
-void
-Preferences::on_comboBoxRenderBackend3D_activated(int val)
-{
-  applyComboBox(this->comboBoxRenderBackend3D, val, Settings::Settings::renderBackend3D);
-  RenderSettings::inst()->backend3D =
-    renderBackend3DFromString(Settings::Settings::renderBackend3D.value());
+void Preferences::on_comboBoxRenderBackend3D_activated (int val) {
+  applyComboBox (this->comboBoxRenderBackend3D, val, Settings::Settings::renderBackend3D);
+  RenderSettings::inst ()->backend3D =
+    renderBackend3DFromString (Settings::Settings::renderBackend3D.value ());
 }
 
-void Preferences::on_comboBoxToolbarExport3D_activated(int val)
-{
-  applyComboBox(this->comboBoxToolbarExport3D, val, Settings::Settings::toolbarExport3D);
-  emit toolbarExportChanged();
+void Preferences::on_comboBoxToolbarExport3D_activated (int val) {
+  applyComboBox (this->comboBoxToolbarExport3D, val, Settings::Settings::toolbarExport3D);
+  emit toolbarExportChanged ();
 }
 
-void Preferences::on_comboBoxToolbarExport2D_activated(int val)
-{
-  applyComboBox(this->comboBoxToolbarExport2D, val, Settings::Settings::toolbarExport2D);
-  emit toolbarExportChanged();
+void Preferences::on_comboBoxToolbarExport2D_activated (int val) {
+  applyComboBox (this->comboBoxToolbarExport2D, val, Settings::Settings::toolbarExport2D);
+  emit toolbarExportChanged ();
 }
 
-void Preferences::on_checkBoxSummaryCamera_toggled(bool checked)
-{
-  Settings::Settings::summaryCamera.setValue(checked);
-  writeSettings();
+void Preferences::on_checkBoxSummaryCamera_toggled (bool checked) {
+  Settings::Settings::summaryCamera.setValue (checked);
+  writeSettings ();
 }
 
-void Preferences::on_checkBoxSummaryArea_toggled(bool checked)
-{
-  Settings::Settings::summaryArea.setValue(checked);
-  writeSettings();
+void Preferences::on_checkBoxSummaryArea_toggled (bool checked) {
+  Settings::Settings::summaryArea.setValue (checked);
+  writeSettings ();
 }
 
-void Preferences::on_checkBoxSummaryBoundingBox_toggled(bool checked)
-{
-  Settings::Settings::summaryBoundingBox.setValue(checked);
-  writeSettings();
+void Preferences::on_checkBoxSummaryBoundingBox_toggled (bool checked) {
+  Settings::Settings::summaryBoundingBox.setValue (checked);
+  writeSettings ();
 }
 
-void Preferences::on_enableHidapiTraceCheckBox_toggled(bool checked)
-{
-  Settings::Settings::inputEnableDriverHIDAPILog.setValue(checked);
-  writeSettings();
+void Preferences::on_enableHidapiTraceCheckBox_toggled (bool checked) {
+  Settings::Settings::inputEnableDriverHIDAPILog.setValue (checked);
+  writeSettings ();
 }
 
-void Preferences::on_checkBoxEnableRemotePrintServices_toggled(bool checked)
-{
-  S::enableRemotePrintServices.setValue(checked);
-  writeSettings();
+void Preferences::on_checkBoxEnableRemotePrintServices_toggled (bool checked) {
+  S::enableRemotePrintServices.setValue (checked);
+  writeSettings ();
 }
 
-void Preferences::on_comboBoxDefaultPrintService_activated(int)
-{
-  QStringList currentPrintServiceList = comboBoxDefaultPrintService->currentData().toStringList();
-  Settings::Settings::defaultPrintService.setValue(currentPrintServiceList[0].toStdString());
-  Settings::Settings::printServiceName.setValue(currentPrintServiceList[1].toStdString());
-  writeSettings();
+void Preferences::on_comboBoxDefaultPrintService_activated (int) {
+  QStringList currentPrintServiceList = comboBoxDefaultPrintService->currentData ().toStringList ();
+  Settings::Settings::defaultPrintService.setValue (currentPrintServiceList[0].toStdString ());
+  Settings::Settings::printServiceName.setValue (currentPrintServiceList[1].toStdString ());
+  writeSettings ();
 }
 
-void Preferences::on_comboBoxOctoPrintAction_activated(int val)
-{
-  applyComboBox(comboBoxOctoPrintAction, val, Settings::Settings::octoPrintAction);
+void Preferences::on_comboBoxOctoPrintAction_activated (int val) {
+  applyComboBox (comboBoxOctoPrintAction, val, Settings::Settings::octoPrintAction);
 }
 
-void Preferences::on_lineEditOctoPrintURL_editingFinished()
-{
-  Settings::Settings::octoPrintUrl.setValue(this->lineEditOctoPrintURL->text().toStdString());
-  writeSettings();
+void Preferences::on_lineEditOctoPrintURL_editingFinished () {
+  Settings::Settings::octoPrintUrl.setValue (this->lineEditOctoPrintURL->text ().toStdString ());
+  writeSettings ();
 }
 
-void Preferences::on_lineEditOctoPrintApiKey_editingFinished()
-{
-  Settings::Settings::octoPrintApiKey.setValue(this->lineEditOctoPrintApiKey->text().toStdString());
-  writeSettings();
+void Preferences::on_lineEditOctoPrintApiKey_editingFinished () {
+  Settings::Settings::octoPrintApiKey.setValue (this->lineEditOctoPrintApiKey->text ().toStdString ());
+  writeSettings ();
 }
 
-void Preferences::on_pushButtonOctoPrintApiKey_clicked()
-{
-  this->lineEditOctoPrintApiKey->setEchoMode(this->pushButtonOctoPrintApiKey->isChecked() ? QLineEdit::EchoMode::Normal : QLineEdit::EchoMode::PasswordEchoOnEdit);
+void Preferences::on_pushButtonOctoPrintApiKey_clicked () {
+  this->lineEditOctoPrintApiKey->setEchoMode (this->pushButtonOctoPrintApiKey->isChecked () ? QLineEdit::EchoMode::Normal : QLineEdit::EchoMode::PasswordEchoOnEdit);
 }
 
-void Preferences::on_pushButtonOctoPrintRequestApiKey_clicked()
-{
+void Preferences::on_pushButtonOctoPrintRequestApiKey_clicked () {
   OctoPrintApiKeyDialog dialog;
-  if (dialog.exec() == QDialog::Accepted) {
-    const auto& apiKey = dialog.getApiKey();
-    this->lineEditOctoPrintApiKey->setText(apiKey);
-    S::octoPrintApiKey.setValue(apiKey.toStdString());
-    writeSettings();
+  if (dialog.exec () == QDialog::Accepted) {
+    const auto &apiKey = dialog.getApiKey ();
+    this->lineEditOctoPrintApiKey->setText (apiKey);
+    S::octoPrintApiKey.setValue (apiKey.toStdString ());
+    writeSettings ();
   }
 }
 
-void Preferences::on_comboBoxOctoPrintFileFormat_activated(int val)
-{
-  applyComboBox(this->comboBoxOctoPrintFileFormat, val, Settings::Settings::octoPrintFileFormat);
+void Preferences::on_comboBoxOctoPrintFileFormat_activated (int val) {
+  applyComboBox (this->comboBoxOctoPrintFileFormat, val, Settings::Settings::octoPrintFileFormat);
 }
 
-void Preferences::on_comboBoxLocalAppFileFormat_activated(int val)
-{
-  applyComboBox(this->comboBoxLocalAppFileFormat, val, Settings::Settings::localAppFileFormat);
-  writeSettings();
+void Preferences::on_comboBoxLocalAppFileFormat_activated (int val) {
+  applyComboBox (this->comboBoxLocalAppFileFormat, val, Settings::Settings::localAppFileFormat);
+  writeSettings ();
 }
 
-void Preferences::on_lineEditLocalAppExecutable_editingFinished()
-{
-  Settings::Settings::localAppExecutable.setValue(this->lineEditLocalAppExecutable->text().toStdString());
-  writeSettings();
+void Preferences::on_lineEditLocalAppExecutable_editingFinished () {
+  Settings::Settings::localAppExecutable.setValue (this->lineEditLocalAppExecutable->text ().toStdString ());
+  writeSettings ();
 }
 
-void Preferences::on_toolButtonLocalAppSelectExecutable_clicked()
-{
-  const QString fileName = QFileDialog::getOpenFileName(this, "Select application");
-  if (fileName.isEmpty()) {
+void Preferences::on_toolButtonLocalAppSelectExecutable_clicked () {
+  const QString fileName = QFileDialog::getOpenFileName (this, "Select application");
+  if (fileName.isEmpty ()) {
     return;
   }
 
-  this->lineEditLocalAppExecutable->setText(fileName);
-  on_lineEditLocalAppExecutable_editingFinished();
+  this->lineEditLocalAppExecutable->setText (fileName);
+  on_lineEditLocalAppExecutable_editingFinished ();
 }
 
-void Preferences::on_lineEditLocalAppTempDir_editingFinished()
-{
-  Settings::Settings::localAppTempDir.setValue(this->lineEditLocalAppTempDir->text().toStdString());
-  writeSettings();
+void Preferences::on_lineEditLocalAppTempDir_editingFinished () {
+  Settings::Settings::localAppTempDir.setValue (this->lineEditLocalAppTempDir->text ().toStdString ());
+  writeSettings ();
 }
 
-void Preferences::on_toolButtonLocalAppSelectTempDir_clicked()
-{
-  const QString tempDir = QFileDialog::getExistingDirectory(this, "Select temporary directory");
-  if (tempDir.isEmpty()) {
+void Preferences::on_toolButtonLocalAppSelectTempDir_clicked () {
+  const QString tempDir = QFileDialog::getExistingDirectory (this, "Select temporary directory");
+  if (tempDir.isEmpty ()) {
     return;
   }
 
-  this->lineEditLocalAppTempDir->setText(tempDir);
-  on_lineEditLocalAppTempDir_editingFinished();
+  this->lineEditLocalAppTempDir->setText (tempDir);
+  on_lineEditLocalAppTempDir_editingFinished ();
 }
 
-void Preferences::moveListBoxRow(QListWidget *listBox, int offset)
-{
-  const auto& index = listBox->selectionModel()->currentIndex();
-  int newRow = index.row() + offset;
-  if (newRow >= 0 && newRow <= listBox->count()) {
-    auto item = listBox->takeItem(index.row());
-    listBox->insertItem(newRow, item);
-    listBox->setCurrentRow(newRow);
+void Preferences::moveListBoxRow (QListWidget *listBox, int offset) {
+  const auto &index = listBox->selectionModel ()->currentIndex ();
+  int newRow = index.row () + offset;
+  if (newRow >= 0 && newRow <= listBox->count ()) {
+    auto item = listBox->takeItem (index.row ());
+    listBox->insertItem (newRow, item);
+    listBox->setCurrentRow (newRow);
   }
 }
 
-void Preferences::on_toolButtonLocalAppParameterUp_clicked()
-{
-  moveListBoxRow(this->listWidgetLocalAppParams, -1);
+void Preferences::on_toolButtonLocalAppParameterUp_clicked () {
+  moveListBoxRow (this->listWidgetLocalAppParams, -1);
 }
 
-void Preferences::on_toolButtonLocalAppParameterDown_clicked()
-{
-  moveListBoxRow(this->listWidgetLocalAppParams, 1);
+void Preferences::on_toolButtonLocalAppParameterDown_clicked () {
+  moveListBoxRow (this->listWidgetLocalAppParams, 1);
 }
 
-void Preferences::on_toolButtonLocalAppParameterRemove_clicked()
-{
-  const auto& index = this->listWidgetLocalAppParams->selectionModel()->currentIndex();
-  if (index.row() >= 0) {
-    auto item = this->listWidgetLocalAppParams->takeItem(index.row());
+void Preferences::on_toolButtonLocalAppParameterRemove_clicked () {
+  const auto &index = this->listWidgetLocalAppParams->selectionModel ()->currentIndex ();
+  if (index.row () >= 0) {
+    auto item = this->listWidgetLocalAppParams->takeItem (index.row ());
     delete item;
   }
 }
 
-void Preferences::insertListItem(QListWidget *listBox, QListWidgetItem *listItem) {
-  const auto hasSelection = listBox->selectionModel()->hasSelection();
-  const auto pos = hasSelection ? listBox->selectionModel()->currentIndex().row() + 1 : listBox->count();
-  listBox->insertItem(pos, listItem);
-  listBox->setCurrentRow(pos);
-  listBox->editItem(listItem);
+void Preferences::insertListItem (QListWidget *listBox, QListWidgetItem *listItem) {
+  const auto hasSelection = listBox->selectionModel ()->hasSelection ();
+  const auto pos = hasSelection ? listBox->selectionModel ()->currentIndex ().row () + 1 : listBox->count ();
+  listBox->insertItem (pos, listItem);
+  listBox->setCurrentRow (pos);
+  listBox->editItem (listItem);
 }
 
-void Preferences::on_toolButtonLocalAppParameterAdd_clicked()
-{
-  auto listItem = createListItem(Settings::LocalAppParameterType(Settings::LocalAppParameterType::string), "", true);
-  insertListItem(this->listWidgetLocalAppParams, listItem);
+void Preferences::on_toolButtonLocalAppParameterAdd_clicked () {
+  auto listItem = createListItem (Settings::LocalAppParameterType (Settings::LocalAppParameterType::string), "", true);
+  insertListItem (this->listWidgetLocalAppParams, listItem);
 }
 
-void Preferences::addLocalAppParameter(const Settings::LocalAppParameterType& type)
-{
-  auto listItem = createListItem(Settings::LocalAppParameterType(type));
-  insertListItem(this->listWidgetLocalAppParams, listItem);
+void Preferences::addLocalAppParameter (const Settings::LocalAppParameterType &type) {
+  auto listItem = createListItem (Settings::LocalAppParameterType (type));
+  insertListItem (this->listWidgetLocalAppParams, listItem);
 }
 
-void Preferences::on_toolButtonLocalAppParameterAddFile_clicked()
-{
-  addLocalAppParameter(Settings::LocalAppParameterType::file);
+void Preferences::on_toolButtonLocalAppParameterAddFile_clicked () {
+  addLocalAppParameter (Settings::LocalAppParameterType::file);
 }
 
-void Preferences::on_listWidgetLocalAppParams_itemSelectionChanged()
-{
-  const auto hasSelection = this->listWidgetLocalAppParams->selectionModel()->hasSelection();
-  const auto& index = this->listWidgetLocalAppParams->selectionModel()->currentIndex();
-  this->toolButtonLocalAppParameterRemove->setEnabled(hasSelection);
-  this->toolButtonLocalAppParameterUp->setEnabled(hasSelection && index.row() > 0);
-  this->toolButtonLocalAppParameterDown->setEnabled(hasSelection && index.row() < this->listWidgetLocalAppParams->count() - 1);
+void Preferences::on_listWidgetLocalAppParams_itemSelectionChanged () {
+  const auto hasSelection = this->listWidgetLocalAppParams->selectionModel ()->hasSelection ();
+  const auto &index = this->listWidgetLocalAppParams->selectionModel ()->currentIndex ();
+  this->toolButtonLocalAppParameterRemove->setEnabled (hasSelection);
+  this->toolButtonLocalAppParameterUp->setEnabled (hasSelection && index.row () > 0);
+  this->toolButtonLocalAppParameterDown->setEnabled (hasSelection && index.row () < this->listWidgetLocalAppParams->count () - 1);
 }
 
-void Preferences::updateLocalAppParams()
-{
+void Preferences::updateLocalAppParams () {
   std::vector<Settings::LocalAppParameter> items;
-  for (int idx = 0; idx < this->listWidgetLocalAppParams->count(); ++idx) {
-    const auto item = this->listWidgetLocalAppParams->item(idx);
-    if (item->type() == static_cast<int>(QListWidgetItem::UserType) + static_cast<int>(Settings::LocalAppParameterType::string)) {
-      items.emplace_back(Settings::LocalAppParameterType::string, item->text().toStdString());
-    } else if (item->type() == static_cast<int>(QListWidgetItem::UserType) + static_cast<int>(Settings::LocalAppParameterType::file)) {
-      items.emplace_back(Settings::LocalAppParameterType::file, std::string{});
-    } else if (item->type() == static_cast<int>(QListWidgetItem::UserType) + static_cast<int>(Settings::LocalAppParameterType::dir)) {
-      items.emplace_back(Settings::LocalAppParameterType::dir, std::string{});
-    } else if (item->type() == static_cast<int>(QListWidgetItem::UserType) + static_cast<int>(Settings::LocalAppParameterType::extension)) {
-      items.emplace_back(Settings::LocalAppParameterType::extension, std::string{});
-    } else if (item->type() == static_cast<int>(QListWidgetItem::UserType) + static_cast<int>(Settings::LocalAppParameterType::source)) {
-      items.emplace_back(Settings::LocalAppParameterType::source, std::string{});
-    } else if (item->type() == static_cast<int>(QListWidgetItem::UserType) + static_cast<int>(Settings::LocalAppParameterType::sourcedir)) {
-      items.emplace_back(Settings::LocalAppParameterType::sourcedir, std::string{});
+  for (int idx = 0; idx < this->listWidgetLocalAppParams->count (); ++idx) {
+    const auto item = this->listWidgetLocalAppParams->item (idx);
+    if (item->type () == static_cast<int> (QListWidgetItem::UserType) + static_cast<int> (Settings::LocalAppParameterType::string)) {
+      items.emplace_back (Settings::LocalAppParameterType::string, item->text ().toStdString ());
+    } else if (item->type () == static_cast<int> (QListWidgetItem::UserType) + static_cast<int> (Settings::LocalAppParameterType::file)) {
+      items.emplace_back (Settings::LocalAppParameterType::file, std::string{});
+    } else if (item->type () == static_cast<int> (QListWidgetItem::UserType) + static_cast<int> (Settings::LocalAppParameterType::dir)) {
+      items.emplace_back (Settings::LocalAppParameterType::dir, std::string{});
+    } else if (item->type () == static_cast<int> (QListWidgetItem::UserType) + static_cast<int> (Settings::LocalAppParameterType::extension)) {
+      items.emplace_back (Settings::LocalAppParameterType::extension, std::string{});
+    } else if (item->type () == static_cast<int> (QListWidgetItem::UserType) + static_cast<int> (Settings::LocalAppParameterType::source)) {
+      items.emplace_back (Settings::LocalAppParameterType::source, std::string{});
+    } else if (item->type () == static_cast<int> (QListWidgetItem::UserType) + static_cast<int> (Settings::LocalAppParameterType::sourcedir)) {
+      items.emplace_back (Settings::LocalAppParameterType::sourcedir, std::string{});
     }
   }
-  Settings::Settings::localAppParameterList.setValue(items);
-  writeSettings();
+  Settings::Settings::localAppParameterList.setValue (items);
+  writeSettings ();
 }
 
-void Preferences::on_listWidgetLocalAppParams_itemChanged(QListWidgetItem *) {
+void Preferences::on_listWidgetLocalAppParams_itemChanged (QListWidgetItem *) {
   // called when parameter values are edited
-  updateLocalAppParams();
+  updateLocalAppParams ();
 }
 
-void Preferences::listWidgetLocalAppParamsModelDataChanged()
-{
+void Preferences::listWidgetLocalAppParamsModelDataChanged () {
   // called when rows are added or removed
-  updateLocalAppParams();
+  updateLocalAppParams ();
 }
 
-void Preferences::on_actionLocalAppParameterFile_triggered()
-{
-  addLocalAppParameter(Settings::LocalAppParameterType::file);
+void Preferences::on_actionLocalAppParameterFile_triggered () {
+  addLocalAppParameter (Settings::LocalAppParameterType::file);
 }
 
-void Preferences::on_actionLocalAppParameterDir_triggered()
-{
-  addLocalAppParameter(Settings::LocalAppParameterType::dir);
+void Preferences::on_actionLocalAppParameterDir_triggered () {
+  addLocalAppParameter (Settings::LocalAppParameterType::dir);
 }
 
-void Preferences::on_actionLocalAppParameterExtension_triggered()
-{
-  addLocalAppParameter(Settings::LocalAppParameterType::extension);
+void Preferences::on_actionLocalAppParameterExtension_triggered () {
+  addLocalAppParameter (Settings::LocalAppParameterType::extension);
 }
 
-void Preferences::on_actionLocalAppParameterSource_triggered()
-{
-  addLocalAppParameter(Settings::LocalAppParameterType::source);
+void Preferences::on_actionLocalAppParameterSource_triggered () {
+  addLocalAppParameter (Settings::LocalAppParameterType::source);
 }
 
-void Preferences::on_actionLocalAppParameterSourceDir_triggered()
-{
-  addLocalAppParameter(Settings::LocalAppParameterType::sourcedir);
+void Preferences::on_actionLocalAppParameterSourceDir_triggered () {
+  addLocalAppParameter (Settings::LocalAppParameterType::sourcedir);
 }
 
-void Preferences::on_pushButtonOctoPrintCheckConnection_clicked()
-{
+void Preferences::on_pushButtonOctoPrintCheckConnection_clicked () {
   OctoPrint octoPrint;
 
   try {
     QString api_version;
     QString server_version;
-    std::tie(api_version, server_version) = octoPrint.getVersion();
-    this->labelOctoPrintCheckConnection->setText(QString{_("Success: Server Version = %2, API Version = %1")}.arg(api_version).arg(server_version));
-  } catch (const NetworkException& e) {
-    QMessageBox::critical(this, _("Error"), QString::fromStdString(e.getErrorMessage()), QMessageBox::Ok);
-    this->labelOctoPrintCheckConnection->setText("");
+    std::tie (api_version, server_version) = octoPrint.getVersion ();
+    this->labelOctoPrintCheckConnection->setText (QString{_ ("Success: Server Version = %2, API Version = %1")}.arg (api_version).arg (server_version));
+  } catch (const NetworkException &e) {
+    QMessageBox::critical (this, _ ("Error"), QString::fromStdString (e.getErrorMessage ()), QMessageBox::Ok);
+    this->labelOctoPrintCheckConnection->setText ("");
   }
 }
 
-void Preferences::on_pushButtonOctoPrintSlicingEngine_clicked()
-{
+void Preferences::on_pushButtonOctoPrintSlicingEngine_clicked () {
   OctoPrint octoPrint;
 
-  const QString selection = this->comboBoxOctoPrintSlicingEngine->currentText();
+  const QString selection = this->comboBoxOctoPrintSlicingEngine->currentText ();
 
   try {
-    const auto slicers = octoPrint.getSlicers();
-    this->comboBoxOctoPrintSlicingEngine->clear();
-    this->comboBoxOctoPrintSlicingEngine->addItem(_("<Default>"), QVariant{""});
-    for (const auto& entry : slicers) {
-      this->comboBoxOctoPrintSlicingEngine->addItem(entry.second, QVariant{entry.first});
+    const auto slicers = octoPrint.getSlicers ();
+    this->comboBoxOctoPrintSlicingEngine->clear ();
+    this->comboBoxOctoPrintSlicingEngine->addItem (_ ("<Default>"), QVariant{""});
+    for (const auto &entry : slicers) {
+      this->comboBoxOctoPrintSlicingEngine->addItem (entry.second, QVariant{entry.first});
     }
 
-    const int idx = this->comboBoxOctoPrintSlicingEngine->findText(selection);
+    const int idx = this->comboBoxOctoPrintSlicingEngine->findText (selection);
     if (idx >= 0) {
-      this->comboBoxOctoPrintSlicingEngine->setCurrentIndex(idx);
+      this->comboBoxOctoPrintSlicingEngine->setCurrentIndex (idx);
     }
-  } catch (const NetworkException& e) {
-    QMessageBox::critical(this, _("Error"), QString::fromStdString(e.getErrorMessage()), QMessageBox::Ok);
+  } catch (const NetworkException &e) {
+    QMessageBox::critical (this, _ ("Error"), QString::fromStdString (e.getErrorMessage ()), QMessageBox::Ok);
   }
 }
 
-void Preferences::on_comboBoxOctoPrintSlicingEngine_activated(int val)
-{
-  const QString text = this->comboBoxOctoPrintSlicingEngine->itemData(val).toString();
-  const QString desc = text.isEmpty() ? QString{} : this->comboBoxOctoPrintSlicingEngine->itemText(val);
-  Settings::Settings::octoPrintSlicerEngine.setValue(text.toStdString());
-  Settings::Settings::octoPrintSlicerEngineDesc.setValue(desc.toStdString());
-  Settings::Settings::octoPrintSlicerProfile.setValue("");
-  Settings::Settings::octoPrintSlicerProfileDesc.setValue("");
-  writeSettings();
-  this->comboBoxOctoPrintSlicingProfile->setCurrentIndex(0);
+void Preferences::on_comboBoxOctoPrintSlicingEngine_activated (int val) {
+  const QString text = this->comboBoxOctoPrintSlicingEngine->itemData (val).toString ();
+  const QString desc = text.isEmpty () ? QString{} : this->comboBoxOctoPrintSlicingEngine->itemText (val);
+  Settings::Settings::octoPrintSlicerEngine.setValue (text.toStdString ());
+  Settings::Settings::octoPrintSlicerEngineDesc.setValue (desc.toStdString ());
+  Settings::Settings::octoPrintSlicerProfile.setValue ("");
+  Settings::Settings::octoPrintSlicerProfileDesc.setValue ("");
+  writeSettings ();
+  this->comboBoxOctoPrintSlicingProfile->setCurrentIndex (0);
 }
 
-void Preferences::on_pushButtonOctoPrintSlicingProfile_clicked()
-{
+void Preferences::on_pushButtonOctoPrintSlicingProfile_clicked () {
   OctoPrint octoPrint;
 
-  const QString selection = this->comboBoxOctoPrintSlicingProfile->currentText();
-  const QString slicer = this->comboBoxOctoPrintSlicingEngine->itemData(this->comboBoxOctoPrintSlicingEngine->currentIndex()).toString();
+  const QString selection = this->comboBoxOctoPrintSlicingProfile->currentText ();
+  const QString slicer = this->comboBoxOctoPrintSlicingEngine->itemData (this->comboBoxOctoPrintSlicingEngine->currentIndex ()).toString ();
 
   try {
-    const auto profiles = octoPrint.getProfiles(slicer);
-    this->comboBoxOctoPrintSlicingProfile->clear();
-    this->comboBoxOctoPrintSlicingProfile->addItem(_("<Default>"), QVariant{""});
-    for (const auto& entry : profiles) {
-      this->comboBoxOctoPrintSlicingProfile->addItem(entry.second, QVariant{entry.first});
+    const auto profiles = octoPrint.getProfiles (slicer);
+    this->comboBoxOctoPrintSlicingProfile->clear ();
+    this->comboBoxOctoPrintSlicingProfile->addItem (_ ("<Default>"), QVariant{""});
+    for (const auto &entry : profiles) {
+      this->comboBoxOctoPrintSlicingProfile->addItem (entry.second, QVariant{entry.first});
     }
 
-    const int idx = this->comboBoxOctoPrintSlicingProfile->findText(selection);
+    const int idx = this->comboBoxOctoPrintSlicingProfile->findText (selection);
     if (idx >= 0) {
-      this->comboBoxOctoPrintSlicingProfile->setCurrentIndex(idx);
+      this->comboBoxOctoPrintSlicingProfile->setCurrentIndex (idx);
     }
-  } catch (const NetworkException& e) {
-    QMessageBox::critical(this, _("Error"), QString::fromStdString(e.getErrorMessage()), QMessageBox::Ok);
+  } catch (const NetworkException &e) {
+    QMessageBox::critical (this, _ ("Error"), QString::fromStdString (e.getErrorMessage ()), QMessageBox::Ok);
   }
 }
 
-void Preferences::on_comboBoxOctoPrintSlicingProfile_activated(int val)
-{
-  const QString text = this->comboBoxOctoPrintSlicingProfile->itemData(val).toString();
-  const QString desc = text.isEmpty() ? QString{} : this->comboBoxOctoPrintSlicingProfile->itemText(val);
-  Settings::Settings::octoPrintSlicerProfile.setValue(text.toStdString());
-  Settings::Settings::octoPrintSlicerProfileDesc.setValue(desc.toStdString());
-  writeSettings();
+void Preferences::on_comboBoxOctoPrintSlicingProfile_activated (int val) {
+  const QString text = this->comboBoxOctoPrintSlicingProfile->itemData (val).toString ();
+  const QString desc = text.isEmpty () ? QString{} : this->comboBoxOctoPrintSlicingProfile->itemText (val);
+  Settings::Settings::octoPrintSlicerProfile.setValue (text.toStdString ());
+  Settings::Settings::octoPrintSlicerProfileDesc.setValue (desc.toStdString ());
+  writeSettings ();
 }
 
-void Preferences::on_checkBoxAlwaysShowExportPdfDialog_toggled(bool state)
-{
-  Settings::SettingsExportPdf::exportPdfAlwaysShowDialog.setValue(state);
-  writeSettings();
+void Preferences::on_checkBoxAlwaysShowExportPdfDialog_toggled (bool state) {
+  Settings::SettingsExportPdf::exportPdfAlwaysShowDialog.setValue (state);
+  writeSettings ();
 }
 
-void Preferences::on_checkBoxAlwaysShowExport3mfDialog_toggled(bool state)
-{
-  Settings::SettingsExport3mf::export3mfAlwaysShowDialog.setValue(state);
-  writeSettings();
+void Preferences::on_checkBoxAlwaysShowExport3mfDialog_toggled (bool state) {
+  Settings::SettingsExport3mf::export3mfAlwaysShowDialog.setValue (state);
+  writeSettings ();
 }
 
-void Preferences::on_checkBoxAlwaysShowPrintServiceDialog_toggled(bool state)
-{
-  Settings::Settings::printServiceAlwaysShowDialog.setValue(state);
-  writeSettings();
+void Preferences::on_checkBoxAlwaysShowPrintServiceDialog_toggled (bool state) {
+  Settings::Settings::printServiceAlwaysShowDialog.setValue (state);
+  writeSettings ();
 }
 
-void Preferences::writeSettings()
-{
-  Settings::Settings::visit(SettingsWriter());
-  fireEditorConfigChanged();
+void Preferences::writeSettings () {
+  Settings::Settings::visit (SettingsWriter ());
+  fireEditorConfigChanged ();
 }
 
-void Preferences::fireEditorConfigChanged() const
-{
-  emit editorConfigChanged();
+void Preferences::fireEditorConfigChanged () const {
+  emit editorConfigChanged ();
 }
 
-void Preferences::keyPressEvent(QKeyEvent *e)
-{
+void Preferences::keyPressEvent (QKeyEvent *e) {
 #ifdef Q_OS_MACOS
-  if (e->modifiers() == Qt::ControlModifier && e->key() == Qt::Key_Period) {
-    close();
+  if (e->modifiers () == Qt::ControlModifier && e->key () == Qt::Key_Period) {
+    close ();
   } else
 #endif
-  if ((e->modifiers() == Qt::ControlModifier && e->key() == Qt::Key_W) ||
-      e->key() == Qt::Key_Escape) {
-    close();
+    if ((e->modifiers () == Qt::ControlModifier && e->key () == Qt::Key_W) ||
+        e->key () == Qt::Key_Escape) {
+    close ();
   }
 }
 
-void Preferences::showEvent(QShowEvent *e)
-{
-  QMainWindow::showEvent(e);
-  hidePasswords();
+void Preferences::showEvent (QShowEvent *e) {
+  QMainWindow::showEvent (e);
+  hidePasswords ();
 }
 
-void Preferences::closeEvent(QCloseEvent *e)
-{
-  hidePasswords();
-  QMainWindow::closeEvent(e);
+void Preferences::closeEvent (QCloseEvent *e) {
+  hidePasswords ();
+  QMainWindow::closeEvent (e);
 }
 
 /*!
    Removes settings that are the same as the default settings to avoid
    overwriting future changes to default settings.
  */
-void Preferences::removeDefaultSettings()
-{
+void Preferences::removeDefaultSettings () {
   QSettingsCached settings;
-  for (QSettings::SettingsMap::const_iterator iter = this->defaultmap.begin();
-       iter != this->defaultmap.end();
+  for (QSettings::SettingsMap::const_iterator iter = this->defaultmap.begin ();
+       iter != this->defaultmap.end ();
        iter++) {
-    if (settings.value(iter.key()) == iter.value()) {
-      settings.remove(iter.key());
+    if (settings.value (iter.key ()) == iter.value ()) {
+      settings.remove (iter.key ());
     }
   }
 }
 
-QVariant Preferences::getValue(const QString& key) const
-{
+QVariant Preferences::getValue (const QString &key) const {
   QSettingsCached settings;
-  assert(settings.contains(key) || this->defaultmap.contains(key));
-  return settings.value(key, this->defaultmap[key]);
+  assert (settings.contains (key) || this->defaultmap.contains (key));
+  return settings.value (key, this->defaultmap[key]);
 }
 
-void Preferences::updateGUI()
-{
-  const auto found = this->colorSchemeChooser->findItems(getValue("3dview/colorscheme").toString(), Qt::MatchExactly);
-  if (!found.isEmpty()) BlockSignals<QListWidget *>(this->colorSchemeChooser)->setCurrentItem(found.first());
+void Preferences::updateGUI () {
+  const auto found = this->colorSchemeChooser->findItems (getValue ("3dview/colorscheme").toString (), Qt::MatchExactly);
+  if (!found.isEmpty ())
+    BlockSignals<QListWidget *> (this->colorSchemeChooser)->setCurrentItem (found.first ());
 
-  updateGUIFontFamily(fontChooser, "editor/fontfamily");
-  updateGUIFontSize(fontSize, "editor/fontsize");
+  updateGUIFontFamily (fontChooser, "editor/fontfamily");
+  updateGUIFontSize (fontSize, "editor/fontsize");
 
-  const auto shighlight = getValue("editor/syntaxhighlight").toString();
-  const auto shidx = this->syntaxHighlight->findText(shighlight);
-  const auto sheffidx = shidx >= 0 ? shidx : this->syntaxHighlight->findText("Off");
+  const auto shighlight = getValue ("editor/syntaxhighlight").toString ();
+  const auto shidx = this->syntaxHighlight->findText (shighlight);
+  const auto sheffidx = shidx >= 0 ? shidx : this->syntaxHighlight->findText ("Off");
   if (sheffidx >= 0) {
-    BlockSignals<QComboBox *>(this->syntaxHighlight)->setCurrentIndex(sheffidx);
+    BlockSignals<QComboBox *> (this->syntaxHighlight)->setCurrentIndex (sheffidx);
   }
 
-  BlockSignals<QCheckBox *>(this->mouseWheelZoomBox)->setChecked(getValue("editor/ctrlmousewheelzoom").toBool());
+  BlockSignals<QCheckBox *> (this->mouseWheelZoomBox)->setChecked (getValue ("editor/ctrlmousewheelzoom").toBool ());
 
-  if (AutoUpdater *updater = AutoUpdater::updater()) {
-    BlockSignals<QCheckBox *>(this->updateCheckBox)->setChecked(updater->automaticallyChecksForUpdates());
-    BlockSignals<QCheckBox *>(this->snapshotCheckBox)->setChecked(updater->enableSnapshots());
-    BlockSignals<QLabel *>(this->lastCheckedLabel)->setText(updater->lastUpdateCheckDate());
+  if (AutoUpdater *updater = AutoUpdater::updater ()) {
+    BlockSignals<QCheckBox *> (this->updateCheckBox)->setChecked (updater->automaticallyChecksForUpdates ());
+    BlockSignals<QCheckBox *> (this->snapshotCheckBox)->setChecked (updater->enableSnapshots ());
+    BlockSignals<QLabel *> (this->lastCheckedLabel)->setText (updater->lastUpdateCheckDate ());
   }
 
-  BlockSignals<QCheckBox *>(this->openCSGWarningBox)->setChecked(getValue("advanced/opencsg_show_warning").toBool());
-  BlockSignals<QLineEdit *>(this->cgalCacheSizeMBEdit)->setText(getValue("advanced/cgalCacheSizeMB").toString());
-  BlockSignals<QLineEdit *>(this->polysetCacheSizeMBEdit)->setText(getValue("advanced/polysetCacheSizeMB").toString());
-  BlockSignals<QLineEdit *>(this->opencsgLimitEdit)->setText(getValue("advanced/openCSGLimit").toString());
-  BlockSignals<QCheckBox *>(this->localizationCheckBox)->setChecked(getValue("advanced/localization").toBool());
-  BlockSignals<QCheckBox *>(this->autoReloadRaiseCheckBox)->setChecked(getValue("advanced/autoReloadRaise").toBool());
-  BlockSignals<QCheckBox *>(this->forceGoldfeatherBox)->setChecked(getValue("advanced/forceGoldfeather").toBool());
-  BlockSignals<QCheckBox *>(this->reorderCheckBox)->setChecked(getValue("advanced/reorderWindows").toBool());
-  BlockSignals<QCheckBox *>(this->undockCheckBox)->setChecked(getValue("advanced/undockableWindows").toBool());
-  BlockSignals<QCheckBox *>(this->launcherBox)->setChecked(getValue("launcher/showOnStartup").toBool());
-  BlockSignals<QCheckBox *>(this->enableSoundOnRenderCompleteCheckBox)->setChecked(getValue("advanced/enableSoundNotification").toBool());
-  BlockSignals<QLineEdit *>(this->timeThresholdOnRenderCompleteSoundEdit)->setText(getValue("advanced/timeThresholdOnRenderCompleteSound").toString());
-  BlockSignals<QCheckBox *>(this->enableClearConsoleCheckBox)->setChecked(getValue("advanced/consoleAutoClear").toBool());
-  BlockSignals<QLineEdit *>(this->consoleMaxLinesEdit)->setText(getValue("advanced/consoleMaxLines").toString());
-
-  updateGUIFontFamily(consoleFontChooser, "advanced/consoleFontFamily");
-  updateGUIFontSize(consoleFontSize, "advanced/consoleFontSize");
-
-  updateGUIFontFamily(customizerFontChooser, "advanced/customizerFontFamily");
-  updateGUIFontSize(customizerFontSize, "advanced/customizerFontSize");
-
-  BlockSignals<QCheckBox *>(this->enableHardwarningsCheckBox)->setChecked(getValue("advanced/enableHardwarnings").toBool());
-  BlockSignals<QLineEdit *>(this->traceDepthEdit)->setText(getValue("advanced/traceDepth").toString());
-  BlockSignals<QCheckBox *>(this->enableTraceUsermoduleParametersCheckBox)->setChecked(getValue("advanced/enableTraceUsermoduleParameters").toBool());
-  BlockSignals<QCheckBox *>(this->enableParameterCheckBox)->setChecked(getValue("advanced/enableParameterCheck").toBool());
-  BlockSignals<QCheckBox *>(this->enableRangeCheckBox)->setChecked(getValue("advanced/enableParameterRangeCheck").toBool());
-  updateComboBox(this->comboBoxToolbarExport3D, Settings::Settings::toolbarExport3D);
-  updateComboBox(this->comboBoxToolbarExport2D, Settings::Settings::toolbarExport2D);
-
-  BlockSignals<QCheckBox *>(this->checkBoxSummaryCamera)->setChecked(Settings::Settings::summaryCamera.value());
-  BlockSignals<QCheckBox *>(this->checkBoxSummaryArea)->setChecked(Settings::Settings::summaryArea.value());
-  BlockSignals<QCheckBox *>(this->checkBoxSummaryBoundingBox)->setChecked(Settings::Settings::summaryBoundingBox.value());
-
-  BlockSignals<QCheckBox *>(this->enableHidapiTraceCheckBox)->setChecked(Settings::Settings::inputEnableDriverHIDAPILog.value());
-  BlockSignals<QCheckBox *>(this->checkBoxEnableAutocomplete)->setChecked(getValue("editor/enableAutocomplete").toBool());
-  BlockSignals<QLineEdit *>(this->lineEditCharacterThreshold)->setText(getValue("editor/characterThreshold").toString());
-  BlockSignals<QLineEdit *>(this->lineEditStepSize)->setText(getValue("editor/stepSize").toString());
-
-  this->secLabelOnRenderCompleteSound->setEnabled(getValue("advanced/enableSoundNotification").toBool());
-  this->undockCheckBox->setEnabled(this->reorderCheckBox->isChecked());
-  this->timeThresholdOnRenderCompleteSoundLabel->setEnabled(getValue("advanced/enableSoundNotification").toBool());
-  this->timeThresholdOnRenderCompleteSoundEdit->setEnabled(getValue("advanced/enableSoundNotification").toBool());
-  this->labelCharacterThreshold->setEnabled(getValue("editor/enableAutocomplete").toBool());
-  this->lineEditCharacterThreshold->setEnabled(getValue("editor/enableAutocomplete").toBool());
-  this->lineEditStepSize->setEnabled(getValue("editor/stepSize").toBool());
-
-  updateComboBox(this->comboBoxRenderBackend3D, Settings::Settings::renderBackend3D);
-  updateComboBox(this->comboBoxLineWrap, Settings::Settings::lineWrap);
-  updateComboBox(this->comboBoxLineWrapIndentationStyle, Settings::Settings::lineWrapIndentationStyle);
-  updateComboBox(this->comboBoxLineWrapVisualizationStart, Settings::Settings::lineWrapVisualizationBegin);
-  updateComboBox(this->comboBoxLineWrapVisualizationEnd, Settings::Settings::lineWrapVisualizationEnd);
-  updateComboBox(this->comboBoxShowWhitespace, Settings::Settings::showWhitespace);
-  updateComboBox(this->comboBoxIndentUsing, Settings::Settings::indentStyle);
-  updateComboBox(this->comboBoxTabKeyFunction, Settings::Settings::tabKeyFunction);
-  updateComboBox(this->comboBoxModifierNumberScrollWheel, Settings::Settings::modifierNumberScrollWheel);
-  updateIntSpinBox(this->spinBoxIndentationWidth, Settings::Settings::indentationWidth);
-  updateIntSpinBox(this->spinBoxTabWidth, Settings::Settings::tabWidth);
-  updateIntSpinBox(this->spinBoxLineWrapIndentationIndent, Settings::Settings::lineWrapIndentation);
-  updateIntSpinBox(this->spinBoxShowWhitespaceSize, Settings::Settings::showWhitespaceSize);
-  initUpdateCheckBox(this->checkBoxAutoIndent, Settings::Settings::autoIndent);
-  initUpdateCheckBox(this->checkBoxBackspaceUnindents, Settings::Settings::backspaceUnindents);
-  initUpdateCheckBox(this->checkBoxHighlightCurrentLine, Settings::Settings::highlightCurrentLine);
-  initUpdateCheckBox(this->checkBoxEnableBraceMatching, Settings::Settings::enableBraceMatching);
-  initUpdateCheckBox(this->checkBoxEnableNumberScrollWheel, Settings::Settings::enableNumberScrollWheel);
-  initUpdateCheckBox(this->checkBoxShowWarningsIn3dView, Settings::Settings::showWarningsIn3dView);
-  initUpdateCheckBox(this->checkBoxMouseCentricZoom, Settings::Settings::mouseCentricZoom);
-  initUpdateCheckBox(this->checkBoxMouseSwapButtons, Settings::Settings::mouseSwapButtons);
-  initUpdateCheckBox(this->checkBoxEnableLineNumbers, Settings::Settings::enableLineNumbers);
-
-
+  BlockSignals<QCheckBox *> (this->openCSGWarningBox)->setChecked (getValue ("advanced/opencsg_show_warning").toBool ());
+  BlockSignals<QLineEdit *> (this->cgalCacheSizeMBEdit)->setText (getValue ("advanced/cgalCacheSizeMB").toString ());
+  BlockSignals<QLineEdit *> (this->polysetCacheSizeMBEdit)->setText (getValue ("advanced/polysetCacheSizeMB").toString ());
+  BlockSignals<QLineEdit *> (this->opencsgLimitEdit)->setText (getValue ("advanced/openCSGLimit").toString ());
+  BlockSignals<QCheckBox *> (this->localizationCheckBox)->setChecked (getValue ("advanced/localization").toBool ());
+  BlockSignals<QCheckBox *> (this->autoReloadRaiseCheckBox)->setChecked (getValue ("advanced/autoReloadRaise").toBool ());
+  BlockSignals<QCheckBox *> (this->forceGoldfeatherBox)->setChecked (getValue ("advanced/forceGoldfeather").toBool ());
+  BlockSignals<QCheckBox *> (this->reorderCheckBox)->setChecked (getValue ("advanced/reorderWindows").toBool ());
+  BlockSignals<QCheckBox *> (this->undockCheckBox)->setChecked (getValue ("advanced/undockableWindows").toBool ());
+  BlockSignals<QCheckBox *> (this->launcherBox)->setChecked (getValue ("launcher/showOnStartup").toBool ());
+  BlockSignals<QCheckBox *> (this->enableSoundOnRenderCompleteCheckBox)->setChecked (getValue ("advanced/enableSoundNotification").toBool ());
+  BlockSignals<QLineEdit *> (this->timeThresholdOnRenderCompleteSoundEdit)->setText (getValue ("advanced/timeThresholdOnRenderCompleteSound").toString ());
+  BlockSignals<QCheckBox *> (this->enableClearConsoleCheckBox)->setChecked (getValue ("advanced/consoleAutoClear").toBool ());
+  BlockSignals<QLineEdit *> (this->consoleMaxLinesEdit)->setText (getValue ("advanced/consoleMaxLines").toString ());
+
+  updateGUIFontFamily (consoleFontChooser, "advanced/consoleFontFamily");
+  updateGUIFontSize (consoleFontSize, "advanced/consoleFontSize");
+
+  updateGUIFontFamily (customizerFontChooser, "advanced/customizerFontFamily");
+  updateGUIFontSize (customizerFontSize, "advanced/customizerFontSize");
+
+  BlockSignals<QCheckBox *> (this->enableHardwarningsCheckBox)->setChecked (getValue ("advanced/enableHardwarnings").toBool ());
+  BlockSignals<QLineEdit *> (this->traceDepthEdit)->setText (getValue ("advanced/traceDepth").toString ());
+  BlockSignals<QCheckBox *> (this->enableTraceUsermoduleParametersCheckBox)->setChecked (getValue ("advanced/enableTraceUsermoduleParameters").toBool ());
+  BlockSignals<QCheckBox *> (this->enableParameterCheckBox)->setChecked (getValue ("advanced/enableParameterCheck").toBool ());
+  BlockSignals<QCheckBox *> (this->enableRangeCheckBox)->setChecked (getValue ("advanced/enableParameterRangeCheck").toBool ());
+  updateComboBox (this->comboBoxToolbarExport3D, Settings::Settings::toolbarExport3D);
+  updateComboBox (this->comboBoxToolbarExport2D, Settings::Settings::toolbarExport2D);
+
+  BlockSignals<QCheckBox *> (this->checkBoxSummaryCamera)->setChecked (Settings::Settings::summaryCamera.value ());
+  BlockSignals<QCheckBox *> (this->checkBoxSummaryArea)->setChecked (Settings::Settings::summaryArea.value ());
+  BlockSignals<QCheckBox *> (this->checkBoxSummaryBoundingBox)->setChecked (Settings::Settings::summaryBoundingBox.value ());
+
+  BlockSignals<QCheckBox *> (this->enableHidapiTraceCheckBox)->setChecked (Settings::Settings::inputEnableDriverHIDAPILog.value ());
+  BlockSignals<QCheckBox *> (this->checkBoxEnableAutocomplete)->setChecked (getValue ("editor/enableAutocomplete").toBool ());
+  BlockSignals<QLineEdit *> (this->lineEditCharacterThreshold)->setText (getValue ("editor/characterThreshold").toString ());
+  BlockSignals<QLineEdit *> (this->lineEditStepSize)->setText (getValue ("editor/stepSize").toString ());
+
+  this->secLabelOnRenderCompleteSound->setEnabled (getValue ("advanced/enableSoundNotification").toBool ());
+  this->undockCheckBox->setEnabled (this->reorderCheckBox->isChecked ());
+  this->timeThresholdOnRenderCompleteSoundLabel->setEnabled (getValue ("advanced/enableSoundNotification").toBool ());
+  this->timeThresholdOnRenderCompleteSoundEdit->setEnabled (getValue ("advanced/enableSoundNotification").toBool ());
+  this->labelCharacterThreshold->setEnabled (getValue ("editor/enableAutocomplete").toBool ());
+  this->lineEditCharacterThreshold->setEnabled (getValue ("editor/enableAutocomplete").toBool ());
+  this->lineEditStepSize->setEnabled (getValue ("editor/stepSize").toBool ());
+
+  updateComboBox (this->comboBoxRenderBackend3D, Settings::Settings::renderBackend3D);
+  updateComboBox (this->comboBoxLineWrap, Settings::Settings::lineWrap);
+  updateComboBox (this->comboBoxLineWrapIndentationStyle, Settings::Settings::lineWrapIndentationStyle);
+  updateComboBox (this->comboBoxLineWrapVisualizationStart, Settings::Settings::lineWrapVisualizationBegin);
+  updateComboBox (this->comboBoxLineWrapVisualizationEnd, Settings::Settings::lineWrapVisualizationEnd);
+  updateComboBox (this->comboBoxShowWhitespace, Settings::Settings::showWhitespace);
+  updateComboBox (this->comboBoxIndentUsing, Settings::Settings::indentStyle);
+  updateComboBox (this->comboBoxTabKeyFunction, Settings::Settings::tabKeyFunction);
+  updateComboBox (this->comboBoxModifierNumberScrollWheel, Settings::Settings::modifierNumberScrollWheel);
+  updateIntSpinBox (this->spinBoxIndentationWidth, Settings::Settings::indentationWidth);
+  updateIntSpinBox (this->spinBoxTabWidth, Settings::Settings::tabWidth);
+  updateIntSpinBox (this->spinBoxLineWrapIndentationIndent, Settings::Settings::lineWrapIndentation);
+  updateIntSpinBox (this->spinBoxShowWhitespaceSize, Settings::Settings::showWhitespaceSize);
+  initUpdateCheckBox (this->checkBoxAutoIndent, Settings::Settings::autoIndent);
+  initUpdateCheckBox (this->checkBoxBackspaceUnindents, Settings::Settings::backspaceUnindents);
+  initUpdateCheckBox (this->checkBoxHighlightCurrentLine, Settings::Settings::highlightCurrentLine);
+  initUpdateCheckBox (this->checkBoxEnableBraceMatching, Settings::Settings::enableBraceMatching);
+  initUpdateCheckBox (this->checkBoxEnableNumberScrollWheel, Settings::Settings::enableNumberScrollWheel);
+  initUpdateCheckBox (this->checkBoxShowWarningsIn3dView, Settings::Settings::showWarningsIn3dView);
+  initUpdateCheckBox (this->checkBoxMouseCentricZoom, Settings::Settings::mouseCentricZoom);
+  initUpdateCheckBox (this->checkBoxMouseSwapButtons, Settings::Settings::mouseSwapButtons);
+  initUpdateCheckBox (this->checkBoxEnableLineNumbers, Settings::Settings::enableLineNumbers);
 
   /* Next Line disables the Indent Spin-Box,for 'Same' and 'Indented' LineWrapStyle selection from LineWrapIndentationStyle Combo-box, just after launching the openscad application.
      Removing this line will cause misbehaviour, and will not disable the Indent spin-box until you interact with the LineWrapStyle Combo-Box first-time and choose a style for which disabling has been handled.
      For normal cases, a similar line, inside the function 'on_comboBoxLineWrapIndentationStyle_activated()' handles the disabling functionality.
    */
-  this->spinBoxLineWrapIndentationIndent->setDisabled(comboBoxLineWrapIndentationStyle->currentData() == "Same" || comboBoxLineWrapIndentationStyle->currentData() == "Indented");
-  this->comboBoxModifierNumberScrollWheel->setDisabled(!checkBoxEnableNumberScrollWheel->isChecked());
-  BlockSignals<QLineEdit *>(this->lineEditOctoPrintURL)->setText(QString::fromStdString(Settings::Settings::octoPrintUrl.value()));
-  BlockSignals<QLineEdit *>(this->lineEditOctoPrintApiKey)->setText(QString::fromStdString(Settings::Settings::octoPrintApiKey.value()));
-  updateComboBox(this->comboBoxOctoPrintAction, Settings::Settings::octoPrintAction);
-  updateComboBox(this->comboBoxOctoPrintSlicingEngine, Settings::Settings::octoPrintSlicerEngine.value());
-  updateComboBox(this->comboBoxOctoPrintSlicingProfile, Settings::Settings::octoPrintSlicerProfile.value());
+  this->spinBoxLineWrapIndentationIndent->setDisabled (comboBoxLineWrapIndentationStyle->currentData () == "Same" || comboBoxLineWrapIndentationStyle->currentData () == "Indented");
+  this->comboBoxModifierNumberScrollWheel->setDisabled (!checkBoxEnableNumberScrollWheel->isChecked ());
+  BlockSignals<QLineEdit *> (this->lineEditOctoPrintURL)->setText (QString::fromStdString (Settings::Settings::octoPrintUrl.value ()));
+  BlockSignals<QLineEdit *> (this->lineEditOctoPrintApiKey)->setText (QString::fromStdString (Settings::Settings::octoPrintApiKey.value ()));
+  updateComboBox (this->comboBoxOctoPrintAction, Settings::Settings::octoPrintAction);
+  updateComboBox (this->comboBoxOctoPrintSlicingEngine, Settings::Settings::octoPrintSlicerEngine.value ());
+  updateComboBox (this->comboBoxOctoPrintSlicingProfile, Settings::Settings::octoPrintSlicerProfile.value ());
 }
 
-void Preferences::applyComboBox(QComboBox * /*comboBox*/, int val, Settings::SettingsEntryEnum<std::string>& entry)
-{
-  entry.setIndex(val);
-  writeSettings();
+void Preferences::applyComboBox (QComboBox * /*comboBox*/, int val, Settings::SettingsEntryEnum<std::string> &entry) {
+  entry.setIndex (val);
+  writeSettings ();
 }
 
-void Preferences::apply_win() const
-{
-  emit requestRedraw();
-  emit openCSGSettingsChanged();
+void Preferences::apply_win () const {
+  emit requestRedraw ();
+  emit openCSGSettingsChanged ();
 }
 
-bool Preferences::hasHighlightingColorScheme() const
-{
-  return BlockSignals<QComboBox *>(syntaxHighlight)->count() != 0;
+bool Preferences::hasHighlightingColorScheme () const {
+  return BlockSignals<QComboBox *> (syntaxHighlight)->count () != 0;
 }
 
-void Preferences::setHighlightingColorSchemes(const QStringList& colorSchemes)
-{
-  auto combobox = BlockSignals<QComboBox *>(syntaxHighlight);
-  combobox->clear();
-  combobox->addItems(colorSchemes);
+void Preferences::setHighlightingColorSchemes (const QStringList &colorSchemes) {
+  auto combobox = BlockSignals<QComboBox *> (syntaxHighlight);
+  combobox->clear ();
+  combobox->addItems (colorSchemes);
 }
 
-void Preferences::createFontSizeMenu(QComboBox *boxarg, const QString& setting)
-{
-  uint savedsize = getValue(setting).toUInt();
+void Preferences::createFontSizeMenu (QComboBox *boxarg, const QString &setting) {
+  uint savedsize = getValue (setting).toUInt ();
   const QFontDatabase db;
   BlockSignals<QComboBox *> box{boxarg};
-  for (auto size : db.standardSizes()) {
-    box->addItem(QString::number(size));
-    if (static_cast<uint>(size) == savedsize) {
-      box->setCurrentIndex(box->count() - 1);
+  for (auto size : db.standardSizes ()) {
+    box->addItem (QString::number (size));
+    if (static_cast<uint> (size) == savedsize) {
+      box->setCurrentIndex (box->count () - 1);
     }
   }
   // reset GUI fontsize if fontSize->addItem emitted signals that changed it.
-  box->setEditText(QString("%1").arg(savedsize) );
+  box->setEditText (QString ("%1").arg (savedsize));
 }
 
-void Preferences::updateGUIFontFamily(QFontComboBox *ffSelector, const QString& setting)
-{
-  const auto fontfamily = getValue(setting).toString();
-  const auto fidx = ffSelector->findText(fontfamily, Qt::MatchContains);
+void Preferences::updateGUIFontFamily (QFontComboBox *ffSelector, const QString &setting) {
+  const auto fontfamily = getValue (setting).toString ();
+  const auto fidx = ffSelector->findText (fontfamily, Qt::MatchContains);
   if (fidx >= 0) {
-    BlockSignals<QFontComboBox *>(ffSelector)->setCurrentIndex(fidx);
+    BlockSignals<QFontComboBox *> (ffSelector)->setCurrentIndex (fidx);
   }
 }
 
-void Preferences::updateGUIFontSize(QComboBox *fsSelector, const QString& setting)
-{
-  const auto fontsize = getValue(setting).toString();
-  const auto sidx = fsSelector->findText(fontsize);
+void Preferences::updateGUIFontSize (QComboBox *fsSelector, const QString &setting) {
+  const auto fontsize = getValue (setting).toString ();
+  const auto sidx = fsSelector->findText (fontsize);
   if (sidx >= 0) {
-    BlockSignals<QComboBox *>(fsSelector)->setCurrentIndex(sidx);
+    BlockSignals<QComboBox *> (fsSelector)->setCurrentIndex (sidx);
   } else {
-    BlockSignals<QComboBox *>(fsSelector)->setEditText(fontsize);
+    BlockSignals<QComboBox *> (fsSelector)->setEditText (fontsize);
   }
 }
 
-Preferences *GlobalPreferences::inst()
-{
-  static auto *instance = new Preferences();
+Preferences *GlobalPreferences::inst () {
+  static auto *instance = new Preferences ();
   return instance;
 }
diff --git a/src/gui/Preferences.h b/src/gui/Preferences.h
index bf70d6088..950b65a59 100644
--- a/src/gui/Preferences.h
+++ b/src/gui/Preferences.h
@@ -29,180 +29,179 @@ class Preferences : public QMainWindow, public Ui::Preferences, public InitConfi
   Q_OBJECT;
 
 public:
-  ~Preferences() override;
+  ~Preferences () override;
 
-  QVariant getValue(const QString& key) const;
-  void init();
-  void update();
-  void apply_win() const;
-  void updateGUI();
-  void fireEditorConfigChanged() const;
-  void insertListItem(QListWidget *listBox, QListWidgetItem *listItem);
+  QVariant getValue (const QString &key) const;
+  void init ();
+  void update ();
+  void apply_win () const;
+  void updateGUI ();
+  void fireEditorConfigChanged () const;
+  void insertListItem (QListWidget *listBox, QListWidgetItem *listItem);
 
   // Returns true if there is an higlightling color scheme configured.
-  bool hasHighlightingColorScheme() const;
+  bool hasHighlightingColorScheme () const;
 
   // Set a new colorScheme.
-  void setHighlightingColorSchemes(const QStringList& colorSchemes);
+  void setHighlightingColorSchemes (const QStringList &colorSchemes);
 
 public slots:
-  void actionTriggered(class QAction *);
-  void featuresCheckBoxToggled(bool);
-  void on_stackedWidget_currentChanged(int);
-  void on_colorSchemeChooser_itemSelectionChanged();
-  void on_fontChooser_currentFontChanged(const QFont&);
-  void on_fontSize_currentIndexChanged(int);
-  void on_syntaxHighlight_currentTextChanged(const QString&);
-  void on_openCSGWarningBox_toggled(bool);
-  void on_cgalCacheSizeMBEdit_textChanged(const QString&);
-  void on_polysetCacheSizeMBEdit_textChanged(const QString&);
-  void on_opencsgLimitEdit_textChanged(const QString&);
-  void on_forceGoldfeatherBox_toggled(bool);
-  void on_mouseWheelZoomBox_toggled(bool);
-  void on_localizationCheckBox_toggled(bool);
-  void on_autoReloadRaiseCheckBox_toggled(bool);
-  void on_updateCheckBox_toggled(bool);
-  void on_snapshotCheckBox_toggled(bool);
-  void on_reorderCheckBox_toggled(bool);
-  void on_undockCheckBox_toggled(bool);
-  void on_checkNowButton_clicked();
-  void on_launcherBox_toggled(bool);
-  void on_enableSoundOnRenderCompleteCheckBox_toggled(bool);
-  void on_enableHardwarningsCheckBox_toggled(bool);
-  void on_traceDepthEdit_textChanged(const QString&);
-  void on_enableTraceUsermoduleParametersCheckBox_toggled(bool);
-  void on_enableParameterCheckBox_toggled(bool);
-  void on_enableRangeCheckBox_toggled(bool);
-  void on_comboBoxRenderBackend3D_activated(int);
-  void on_comboBoxToolbarExport3D_activated(int);
-  void on_comboBoxToolbarExport2D_activated(int);
-  void on_checkBoxSummaryCamera_toggled(bool);
-  void on_checkBoxSummaryArea_toggled(bool);
-  void on_checkBoxSummaryBoundingBox_toggled(bool);
-  void on_enableHidapiTraceCheckBox_toggled(bool);
-  void on_checkBoxShowWarningsIn3dView_toggled(bool);
-  void on_checkBoxMouseCentricZoom_toggled(bool);
-  void on_checkBoxMouseSwapButtons_toggled(bool);
-  void on_timeThresholdOnRenderCompleteSoundEdit_textChanged(const QString&);
-  void on_enableClearConsoleCheckBox_toggled(bool);
-  void on_consoleMaxLinesEdit_textChanged(const QString&);
-  void on_consoleFontChooser_currentFontChanged(const QFont&);
-  void on_consoleFontSize_currentIndexChanged(int);
-  void on_customizerFontChooser_currentFontChanged(const QFont&);
-  void on_customizerFontSize_currentIndexChanged(int);
-  void on_checkBoxEnableAutocomplete_toggled(bool);
-  void on_lineEditCharacterThreshold_textChanged(const QString&);
+  void actionTriggered (class QAction *);
+  void featuresCheckBoxToggled (bool);
+  void on_stackedWidget_currentChanged (int);
+  void on_colorSchemeChooser_itemSelectionChanged ();
+  void on_fontChooser_currentFontChanged (const QFont &);
+  void on_fontSize_currentIndexChanged (int);
+  void on_syntaxHighlight_currentTextChanged (const QString &);
+  void on_openCSGWarningBox_toggled (bool);
+  void on_cgalCacheSizeMBEdit_textChanged (const QString &);
+  void on_polysetCacheSizeMBEdit_textChanged (const QString &);
+  void on_opencsgLimitEdit_textChanged (const QString &);
+  void on_forceGoldfeatherBox_toggled (bool);
+  void on_mouseWheelZoomBox_toggled (bool);
+  void on_localizationCheckBox_toggled (bool);
+  void on_autoReloadRaiseCheckBox_toggled (bool);
+  void on_updateCheckBox_toggled (bool);
+  void on_snapshotCheckBox_toggled (bool);
+  void on_reorderCheckBox_toggled (bool);
+  void on_undockCheckBox_toggled (bool);
+  void on_checkNowButton_clicked ();
+  void on_launcherBox_toggled (bool);
+  void on_enableSoundOnRenderCompleteCheckBox_toggled (bool);
+  void on_enableHardwarningsCheckBox_toggled (bool);
+  void on_traceDepthEdit_textChanged (const QString &);
+  void on_enableTraceUsermoduleParametersCheckBox_toggled (bool);
+  void on_enableParameterCheckBox_toggled (bool);
+  void on_enableRangeCheckBox_toggled (bool);
+  void on_comboBoxRenderBackend3D_activated (int);
+  void on_comboBoxToolbarExport3D_activated (int);
+  void on_comboBoxToolbarExport2D_activated (int);
+  void on_checkBoxSummaryCamera_toggled (bool);
+  void on_checkBoxSummaryArea_toggled (bool);
+  void on_checkBoxSummaryBoundingBox_toggled (bool);
+  void on_enableHidapiTraceCheckBox_toggled (bool);
+  void on_checkBoxShowWarningsIn3dView_toggled (bool);
+  void on_checkBoxMouseCentricZoom_toggled (bool);
+  void on_checkBoxMouseSwapButtons_toggled (bool);
+  void on_timeThresholdOnRenderCompleteSoundEdit_textChanged (const QString &);
+  void on_enableClearConsoleCheckBox_toggled (bool);
+  void on_consoleMaxLinesEdit_textChanged (const QString &);
+  void on_consoleFontChooser_currentFontChanged (const QFont &);
+  void on_consoleFontSize_currentIndexChanged (int);
+  void on_customizerFontChooser_currentFontChanged (const QFont &);
+  void on_customizerFontSize_currentIndexChanged (int);
+  void on_checkBoxEnableAutocomplete_toggled (bool);
+  void on_lineEditCharacterThreshold_textChanged (const QString &);
   //
   // editor settings
   //
 
   // Indentation
-  void on_checkBoxAutoIndent_toggled(bool);
-  void on_checkBoxBackspaceUnindents_toggled(bool);
-  void on_comboBoxIndentUsing_activated(int);
-  void on_spinBoxIndentationWidth_valueChanged(int);
-  void on_spinBoxTabWidth_valueChanged(int);
-  void on_comboBoxTabKeyFunction_activated(int);
-  void on_comboBoxShowWhitespace_activated(int);
-  void on_spinBoxShowWhitespaceSize_valueChanged(int);
+  void on_checkBoxAutoIndent_toggled (bool);
+  void on_checkBoxBackspaceUnindents_toggled (bool);
+  void on_comboBoxIndentUsing_activated (int);
+  void on_spinBoxIndentationWidth_valueChanged (int);
+  void on_spinBoxTabWidth_valueChanged (int);
+  void on_comboBoxTabKeyFunction_activated (int);
+  void on_comboBoxShowWhitespace_activated (int);
+  void on_spinBoxShowWhitespaceSize_valueChanged (int);
 
   // Line wrap
-  void on_comboBoxLineWrap_activated(int);
-  void on_comboBoxLineWrapIndentationStyle_activated(int);
-  void on_spinBoxLineWrapIndentationIndent_valueChanged(int);
-  void on_comboBoxLineWrapVisualizationStart_activated(int);
-  void on_comboBoxLineWrapVisualizationEnd_activated(int);
-  void on_comboBoxModifierNumberScrollWheel_activated(int);
-
+  void on_comboBoxLineWrap_activated (int);
+  void on_comboBoxLineWrapIndentationStyle_activated (int);
+  void on_spinBoxLineWrapIndentationIndent_valueChanged (int);
+  void on_comboBoxLineWrapVisualizationStart_activated (int);
+  void on_comboBoxLineWrapVisualizationEnd_activated (int);
+  void on_comboBoxModifierNumberScrollWheel_activated (int);
 
   // Display
-  void on_checkBoxHighlightCurrentLine_toggled(bool);
-  void on_checkBoxEnableBraceMatching_toggled(bool);
-  void on_checkBoxEnableLineNumbers_toggled(bool);
+  void on_checkBoxHighlightCurrentLine_toggled (bool);
+  void on_checkBoxEnableBraceMatching_toggled (bool);
+  void on_checkBoxEnableLineNumbers_toggled (bool);
 
   // Print
-  void on_checkBoxEnableRemotePrintServices_toggled(bool);
-  void on_comboBoxDefaultPrintService_activated(int);
-  void on_pushButtonOctoPrintCheckConnection_clicked();
-  void on_pushButtonOctoPrintSlicingEngine_clicked();
-  void on_comboBoxOctoPrintSlicingEngine_activated(int);
-  void on_pushButtonOctoPrintSlicingProfile_clicked();
-  void on_comboBoxOctoPrintSlicingProfile_activated(int);
-  void on_comboBoxOctoPrintAction_activated(int);
-  void on_comboBoxOctoPrintFileFormat_activated(int);
-  void on_lineEditOctoPrintURL_editingFinished();
-  void on_lineEditOctoPrintApiKey_editingFinished();
-  void on_pushButtonOctoPrintApiKey_clicked();
-  void on_pushButtonOctoPrintRequestApiKey_clicked();
-  void on_lineEditLocalAppExecutable_editingFinished();
-  void on_toolButtonLocalAppSelectExecutable_clicked();
-  void on_lineEditLocalAppTempDir_editingFinished();
-  void on_toolButtonLocalAppSelectTempDir_clicked();
-  void on_comboBoxLocalAppFileFormat_activated(int);
-  void on_toolButtonLocalAppParameterRemove_clicked();
-  void on_toolButtonLocalAppParameterAdd_clicked();
-  void on_toolButtonLocalAppParameterUp_clicked();
-  void on_toolButtonLocalAppParameterDown_clicked();
-  void on_toolButtonLocalAppParameterAddFile_clicked();
-  void on_listWidgetLocalAppParams_itemSelectionChanged();
-  void on_listWidgetLocalAppParams_itemChanged(QListWidgetItem *);
-  void on_actionLocalAppParameterFile_triggered();
-  void on_actionLocalAppParameterDir_triggered();
-  void on_actionLocalAppParameterExtension_triggered();
-  void on_actionLocalAppParameterSource_triggered();
-  void on_actionLocalAppParameterSourceDir_triggered();
-  void listWidgetLocalAppParamsModelDataChanged();
+  void on_checkBoxEnableRemotePrintServices_toggled (bool);
+  void on_comboBoxDefaultPrintService_activated (int);
+  void on_pushButtonOctoPrintCheckConnection_clicked ();
+  void on_pushButtonOctoPrintSlicingEngine_clicked ();
+  void on_comboBoxOctoPrintSlicingEngine_activated (int);
+  void on_pushButtonOctoPrintSlicingProfile_clicked ();
+  void on_comboBoxOctoPrintSlicingProfile_activated (int);
+  void on_comboBoxOctoPrintAction_activated (int);
+  void on_comboBoxOctoPrintFileFormat_activated (int);
+  void on_lineEditOctoPrintURL_editingFinished ();
+  void on_lineEditOctoPrintApiKey_editingFinished ();
+  void on_pushButtonOctoPrintApiKey_clicked ();
+  void on_pushButtonOctoPrintRequestApiKey_clicked ();
+  void on_lineEditLocalAppExecutable_editingFinished ();
+  void on_toolButtonLocalAppSelectExecutable_clicked ();
+  void on_lineEditLocalAppTempDir_editingFinished ();
+  void on_toolButtonLocalAppSelectTempDir_clicked ();
+  void on_comboBoxLocalAppFileFormat_activated (int);
+  void on_toolButtonLocalAppParameterRemove_clicked ();
+  void on_toolButtonLocalAppParameterAdd_clicked ();
+  void on_toolButtonLocalAppParameterUp_clicked ();
+  void on_toolButtonLocalAppParameterDown_clicked ();
+  void on_toolButtonLocalAppParameterAddFile_clicked ();
+  void on_listWidgetLocalAppParams_itemSelectionChanged ();
+  void on_listWidgetLocalAppParams_itemChanged (QListWidgetItem *);
+  void on_actionLocalAppParameterFile_triggered ();
+  void on_actionLocalAppParameterDir_triggered ();
+  void on_actionLocalAppParameterExtension_triggered ();
+  void on_actionLocalAppParameterSource_triggered ();
+  void on_actionLocalAppParameterSourceDir_triggered ();
+  void listWidgetLocalAppParamsModelDataChanged ();
 
   // Dialogs
-  void on_checkBoxAlwaysShowExportPdfDialog_toggled(bool);
-  void on_checkBoxAlwaysShowExport3mfDialog_toggled(bool);
-  void on_checkBoxAlwaysShowPrintServiceDialog_toggled(bool);
+  void on_checkBoxAlwaysShowExportPdfDialog_toggled (bool);
+  void on_checkBoxAlwaysShowExport3mfDialog_toggled (bool);
+  void on_checkBoxAlwaysShowPrintServiceDialog_toggled (bool);
 
 signals:
-  void requestRedraw() const;
-  void updateUndockMode(bool undockMode) const;
-  void updateReorderMode(bool undockMode) const;
-  void fontChanged(const QString& family, uint size) const;
-  void consoleFontChanged(const QString& family, uint size) const;
-  void customizerFontChanged(const QString& family, uint size) const;
-  void colorSchemeChanged(const QString& scheme) const;
-  void openCSGSettingsChanged() const;
-  void syntaxHighlightChanged(const QString& s) const;
-  void editorConfigChanged() const;
-  void ExperimentalChanged() const;
-  void updateMouseCentricZoom(bool state) const;
-  void updateMouseSwapButtons(bool state) const;
-  void autocompleteChanged(bool status) const;
-  void characterThresholdChanged(int val) const;
-  void stepSizeChanged(int val) const;
-  void toolbarExportChanged() const;
+  void requestRedraw () const;
+  void updateUndockMode (bool undockMode) const;
+  void updateReorderMode (bool undockMode) const;
+  void fontChanged (const QString &family, uint size) const;
+  void consoleFontChanged (const QString &family, uint size) const;
+  void customizerFontChanged (const QString &family, uint size) const;
+  void colorSchemeChanged (const QString &scheme) const;
+  void openCSGSettingsChanged () const;
+  void syntaxHighlightChanged (const QString &s) const;
+  void editorConfigChanged () const;
+  void ExperimentalChanged () const;
+  void updateMouseCentricZoom (bool state) const;
+  void updateMouseSwapButtons (bool state) const;
+  void autocompleteChanged (bool status) const;
+  void characterThresholdChanged (int val) const;
+  void stepSizeChanged (int val) const;
+  void toolbarExportChanged () const;
 
 private slots:
-  void on_lineEditStepSize_textChanged(const QString& arg1);
+  void on_lineEditStepSize_textChanged (const QString &arg1);
 
-  void on_checkBoxEnableNumberScrollWheel_toggled(bool checked);
+  void on_checkBoxEnableNumberScrollWheel_toggled (bool checked);
 
 private:
   friend GlobalPreferences;
-  Preferences(QWidget *parent = nullptr);
-  void keyPressEvent(QKeyEvent *e) override;
-  void showEvent(QShowEvent *e) override;
-  void closeEvent(QCloseEvent *e) override;
-  void removeDefaultSettings();
-  void setupFeaturesPage();
-  void setup3DPrintPage();
-  void writeSettings();
-  void hidePasswords();
-  void addPrefPage(QActionGroup *group, QAction *action, QWidget *widget);
-  void createFontSizeMenu(QComboBox *box, const QString& setting);
-  void updateGUIFontFamily(QFontComboBox *fontSelector, const QString& setting);
-  void updateGUIFontSize(QComboBox *fsSelector, const QString& setting);
-  void updateLocalAppParams();
-  void addLocalAppParameter(const Settings::LocalAppParameterType&);
-  void moveListBoxRow(QListWidget *listBox, int offset);
+  Preferences (QWidget *parent = nullptr);
+  void keyPressEvent (QKeyEvent *e) override;
+  void showEvent (QShowEvent *e) override;
+  void closeEvent (QCloseEvent *e) override;
+  void removeDefaultSettings ();
+  void setupFeaturesPage ();
+  void setup3DPrintPage ();
+  void writeSettings ();
+  void hidePasswords ();
+  void addPrefPage (QActionGroup *group, QAction *action, QWidget *widget);
+  void createFontSizeMenu (QComboBox *box, const QString &setting);
+  void updateGUIFontFamily (QFontComboBox *fontSelector, const QString &setting);
+  void updateGUIFontSize (QComboBox *fsSelector, const QString &setting);
+  void updateLocalAppParams ();
+  void addLocalAppParameter (const Settings::LocalAppParameterType &);
+  void moveListBoxRow (QListWidget *listBox, int offset);
 
   /** Set value from combobox to settings */
-  void applyComboBox(QComboBox *comboBox, int val, Settings::SettingsEntryEnum<std::string>& entry);
+  void applyComboBox (QComboBox *comboBox, int val, Settings::SettingsEntryEnum<std::string> &entry);
 
   QSettings::SettingsMap defaultmap;
   QHash<const QAction *, QWidget *> prefPages;
@@ -211,5 +210,5 @@ private:
 class GlobalPreferences
 {
 public:
-  static Preferences *inst();
+  static Preferences *inst ();
 };
diff --git a/src/gui/PrintInitDialog.cc b/src/gui/PrintInitDialog.cc
index 197b8273b..81afb817d 100644
--- a/src/gui/PrintInitDialog.cc
+++ b/src/gui/PrintInitDialog.cc
@@ -41,7 +41,7 @@ using S = Settings::Settings;
 
 namespace {
 
-QString toString(print_service_t printServiceType) {
+QString toString (print_service_t printServiceType) {
   switch (printServiceType) {
   case print_service_t::PRINT_SERVICE:
     return "PRINT_SERVICE";
@@ -54,72 +54,70 @@ QString toString(print_service_t printServiceType) {
   }
 }
 
-print_service_t fromString(const std::string& printServiceType) {
+print_service_t fromString (const std::string &printServiceType) {
   if (printServiceType == "PRINT_SERVICE") {
     return print_service_t::PRINT_SERVICE;
   } else if (printServiceType == "OCTOPRINT") {
     return print_service_t::OCTOPRINT;
   } else if (printServiceType == "LOCAL_APPLICATION") {
     return print_service_t::LOCAL_APPLICATION;
-  } else return print_service_t::NONE;
+  } else
+    return print_service_t::NONE;
 }
 
 } // namespace
 
-void PrintInitDialog::populateFileFormatComboBox(
-  const std::vector<FileFormat>& fileFormats, FileFormat currentFormat) {
-  this->comboBoxFileFormat->clear();
-  for (const auto& fileFormat : fileFormats) {
-    const FileFormatInfo& info = fileformat::info(fileFormat);
-    this->comboBoxFileFormat->addItem(QString::fromStdString(info.description),
-                                      QString::fromStdString(info.identifier));
+void PrintInitDialog::populateFileFormatComboBox (
+  const std::vector<FileFormat> &fileFormats, FileFormat currentFormat) {
+  this->comboBoxFileFormat->clear ();
+  for (const auto &fileFormat : fileFormats) {
+    const FileFormatInfo &info = fileformat::info (fileFormat);
+    this->comboBoxFileFormat->addItem (QString::fromStdString (info.description),
+                                       QString::fromStdString (info.identifier));
     if (fileFormat == currentFormat) {
-      this->comboBoxFileFormat->setCurrentIndex(
-        this->comboBoxFileFormat->count() - 1);
+      this->comboBoxFileFormat->setCurrentIndex (
+        this->comboBoxFileFormat->count () - 1);
     }
   }
 }
 
-PrintInitDialog::PrintInitDialog()
-{
-  setupUi(this);
+PrintInitDialog::PrintInitDialog () {
+  setupUi (this);
 
-  resetSelection();
+  resetSelection ();
 
-  this->checkBoxAlwaysShowDialog->setChecked(S::printServiceAlwaysShowDialog.value());
+  this->checkBoxAlwaysShowDialog->setChecked (S::printServiceAlwaysShowDialog.value ());
 
   // triggers addRemotePrintServiceButtons() if config value is "true"
-  const auto remoteServicesEnabled = S::enableRemotePrintServices.value();
-  this->checkBoxEnableRemotePrintServices->setChecked(remoteServicesEnabled);
+  const auto remoteServicesEnabled = S::enableRemotePrintServices.value ();
+  this->checkBoxEnableRemotePrintServices->setChecked (remoteServicesEnabled);
 
-  if (remoteServicesEnabled && PrintService::getPrintServices().empty()) {
-    LOG(message_group::UI_Warning, "No external print services found");
+  if (remoteServicesEnabled && PrintService::getPrintServices ().empty ()) {
+    LOG (message_group::UI_Warning, "No external print services found");
   }
 
-  const auto& service = S::defaultPrintService.value();
-  const print_service_t printService = fromString(service);
+  const auto &service = S::defaultPrintService.value ();
+  const print_service_t printService = fromString (service);
   if (printService != print_service_t::NONE) {
     this->selectedPrintService = printService;
-    const auto& printServiceName = S::printServiceName.value();
-    this->selectedServiceName = QString::fromStdString(printServiceName);
+    const auto &printServiceName = S::printServiceName.value ();
+    this->selectedServiceName = QString::fromStdString (printServiceName);
 
     switch (printService) {
-    case print_service_t::PRINT_SERVICE:
-    {
-      for (const auto& button : this->buttonGroup->buttons()) {
-        const auto& name = button->property(PROPERTY_NAME);
-        if (this->selectedServiceName == name.toString()) {
-          button->click();
+    case print_service_t::PRINT_SERVICE: {
+      for (const auto &button : this->buttonGroup->buttons ()) {
+        const auto &name = button->property (PROPERTY_NAME);
+        if (this->selectedServiceName == name.toString ()) {
+          button->click ();
           break;
         }
       }
-    }
-    break;
+    } break;
     case print_service_t::OCTOPRINT:
-      on_pushButtonOctoPrint_clicked();
+      on_pushButtonOctoPrint_clicked ();
       break;
     case print_service_t::LOCAL_APPLICATION:
-      on_pushButtonLocalApplication_clicked();
+      on_pushButtonLocalApplication_clicked ();
       break;
     default:
       break;
@@ -127,175 +125,162 @@ PrintInitDialog::PrintInitDialog()
   }
 }
 
-void PrintInitDialog::resetSelection()
-{
-  this->textBrowser->setSource(QUrl{urlDialog});
-  this->pushButtonOk->setEnabled(false);
-  this->comboBoxFileFormat->setEnabled(false);
-  this->comboBoxFileFormat->setCurrentIndex(-1);
-  this->buttonGroup->setExclusive(false);
-  for (auto button : this->buttonGroup->buttons()) {
-    button->setChecked(false);
+void PrintInitDialog::resetSelection () {
+  this->textBrowser->setSource (QUrl{urlDialog});
+  this->pushButtonOk->setEnabled (false);
+  this->comboBoxFileFormat->setEnabled (false);
+  this->comboBoxFileFormat->setCurrentIndex (-1);
+  this->buttonGroup->setExclusive (false);
+  for (auto button : this->buttonGroup->buttons ()) {
+    button->setChecked (false);
   }
-  this->buttonGroup->setExclusive(true);
+  this->buttonGroup->setExclusive (true);
 }
 
-void PrintInitDialog::addRemotePrintServiceButtons()
-{
-  for (const auto& printServiceItem : PrintService::getPrintServices()) {
-    const auto& key = printServiceItem.first;
-    const auto& printService = printServiceItem.second;
-    auto button = new QPushButton(printService->getDisplayName(), this);
-    remoteServiceButtons.push_back(button);
-    button->setCheckable(true);
-    button->setAutoDefault(false);
-    button->setFocusPolicy(Qt::FocusPolicy::TabFocus);
-    button->setProperty(PROPERTY_NAME, QVariant(QString::fromStdString(key)));
-    buttonGroup->addButton(button);
-    this->printServiceLayout->insertWidget(this->printServiceLayout->count(), button);
-    connect(button, &QPushButton::clicked, this, [&]() {
+void PrintInitDialog::addRemotePrintServiceButtons () {
+  for (const auto &printServiceItem : PrintService::getPrintServices ()) {
+    const auto &key = printServiceItem.first;
+    const auto &printService = printServiceItem.second;
+    auto button = new QPushButton (printService->getDisplayName (), this);
+    remoteServiceButtons.push_back (button);
+    button->setCheckable (true);
+    button->setAutoDefault (false);
+    button->setFocusPolicy (Qt::FocusPolicy::TabFocus);
+    button->setProperty (PROPERTY_NAME, QVariant (QString::fromStdString (key)));
+    buttonGroup->addButton (button);
+    this->printServiceLayout->insertWidget (this->printServiceLayout->count (), button);
+    connect (button, &QPushButton::clicked, this, [&] () {
       FileFormat currentFormat = FileFormat::ASCII_STL;
-      fileformat::fromIdentifier(S::printServiceFileFormat.value(), currentFormat);
-      this->textBrowser->setHtml(printService->getInfoHtml());
-      this->populateFileFormatComboBox(printService->getFileFormats(), currentFormat);
+      fileformat::fromIdentifier (S::printServiceFileFormat.value (), currentFormat);
+      this->textBrowser->setHtml (printService->getInfoHtml ());
+      this->populateFileFormatComboBox (printService->getFileFormats (), currentFormat);
       this->selectedPrintService = print_service_t::PRINT_SERVICE;
-      this->selectedServiceName = QString::fromStdString(key);
-      this->comboBoxFileFormat->setEnabled(true);
-      this->pushButtonOk->setEnabled(true);
+      this->selectedServiceName = QString::fromStdString (key);
+      this->comboBoxFileFormat->setEnabled (true);
+      this->pushButtonOk->setEnabled (true);
     });
   }
 }
 
-void PrintInitDialog::on_checkBoxEnableRemotePrintServices_toggled(bool checked)
-{
-  S::enableRemotePrintServices.setValue(checked);
-  writeSettings();
+void PrintInitDialog::on_checkBoxEnableRemotePrintServices_toggled (bool checked) {
+  S::enableRemotePrintServices.setValue (checked);
+  writeSettings ();
 
   if (checked) {
-    if (remoteServiceButtons.empty()) {
-      addRemotePrintServiceButtons();
+    if (remoteServiceButtons.empty ()) {
+      addRemotePrintServiceButtons ();
     }
   } else {
     for (const auto button : remoteServiceButtons) {
-      this->buttonGroup->removeButton(button);
-      this->printServiceLayout->removeWidget(button);
-      button->deleteLater();
+      this->buttonGroup->removeButton (button);
+      this->printServiceLayout->removeWidget (button);
+      button->deleteLater ();
     }
-    remoteServiceButtons.clear();
+    remoteServiceButtons.clear ();
   }
 
-  resetSelection();
+  resetSelection ();
 }
 
-void PrintInitDialog::on_pushButtonOctoPrint_clicked()
-{
-  this->textBrowser->setSource(QUrl{urlOctoPrint});
-  initComboBox(this->comboBoxFileFormat, S::octoPrintFileFormat);
-  this->on_comboBoxFileFormat_currentIndexChanged(this->comboBoxFileFormat->currentIndex());
+void PrintInitDialog::on_pushButtonOctoPrint_clicked () {
+  this->textBrowser->setSource (QUrl{urlOctoPrint});
+  initComboBox (this->comboBoxFileFormat, S::octoPrintFileFormat);
+  this->on_comboBoxFileFormat_currentIndexChanged (this->comboBoxFileFormat->currentIndex ());
 
   this->selectedPrintService = print_service_t::OCTOPRINT;
   this->selectedServiceName = "";
 
-  this->comboBoxFileFormat->setEnabled(true);
-  this->pushButtonOk->setEnabled(true);
-  const auto fileFormatIdentifier = fileformat::info(this->getFileFormat()).identifier;
-  PRINTDB("OCTOPRINT: %s", fileFormatIdentifier);
+  this->comboBoxFileFormat->setEnabled (true);
+  this->pushButtonOk->setEnabled (true);
+  const auto fileFormatIdentifier = fileformat::info (this->getFileFormat ()).identifier;
+  PRINTDB ("OCTOPRINT: %s", fileFormatIdentifier);
 }
 
-void PrintInitDialog::on_pushButtonLocalApplication_clicked()
-{
+void PrintInitDialog::on_pushButtonLocalApplication_clicked () {
   // TODO: Instead of forcing people to use Preferences, we should add UI here
   // to select external program.
-  this->textBrowser->setSource(QUrl{urlLocalApp});
+  this->textBrowser->setSource (QUrl{urlLocalApp});
 
-  initComboBox(this->comboBoxFileFormat, S::localAppFileFormat);
-  this->on_comboBoxFileFormat_currentIndexChanged(this->comboBoxFileFormat->currentIndex());
+  initComboBox (this->comboBoxFileFormat, S::localAppFileFormat);
+  this->on_comboBoxFileFormat_currentIndexChanged (this->comboBoxFileFormat->currentIndex ());
   this->selectedPrintService = print_service_t::LOCAL_APPLICATION;
   this->selectedServiceName = "";
 
-  this->comboBoxFileFormat->setEnabled(true);
-  this->pushButtonOk->setEnabled(true);
-  const auto fileFormatIdentifier = fileformat::info(this->getFileFormat()).identifier;
-  PRINTDB("LOCAL_APPLICATION: %s", fileFormatIdentifier);
+  this->comboBoxFileFormat->setEnabled (true);
+  this->pushButtonOk->setEnabled (true);
+  const auto fileFormatIdentifier = fileformat::info (this->getFileFormat ()).identifier;
+  PRINTDB ("LOCAL_APPLICATION: %s", fileFormatIdentifier);
 }
 
-void PrintInitDialog::setFileFormat(const std::string& id)
-{
+void PrintInitDialog::setFileFormat (const std::string &id) {
   FileFormat fileFormat = FileFormat::ASCII_STL;
-  if (!fileformat::fromIdentifier(id, fileFormat)) {
+  if (!fileformat::fromIdentifier (id, fileFormat)) {
     // FIXME: When would this error happen? Do we need to handle it?
-    LOG("fileformat::fromIdentifier error: id '%1$s' not recognized", id);
+    LOG ("fileformat::fromIdentifier error: id '%1$s' not recognized", id);
   }
   this->selectedFileFormat = fileFormat;
 }
 
-void PrintInitDialog::on_comboBoxFileFormat_currentIndexChanged(int index)
-{
+void PrintInitDialog::on_comboBoxFileFormat_currentIndexChanged (int index) {
   if (index >= 0) {
-    const auto id = this->comboBoxFileFormat->currentData().toString().toStdString();
-    this->setFileFormat(id);
+    const auto id = this->comboBoxFileFormat->currentData ().toString ().toStdString ();
+    this->setFileFormat (id);
   }
 }
 
-void PrintInitDialog::on_pushButtonOk_clicked()
-{
-  const QString defaultPrintServiceString = toString(this->selectedPrintService);
-  S::defaultPrintService.setValue(defaultPrintServiceString.toStdString());
-  S::printServiceName.setValue(this->selectedServiceName.toStdString());
+void PrintInitDialog::on_pushButtonOk_clicked () {
+  const QString defaultPrintServiceString = toString (this->selectedPrintService);
+  S::defaultPrintService.setValue (defaultPrintServiceString.toStdString ());
+  S::printServiceName.setValue (this->selectedServiceName.toStdString ());
 
-  const auto fileFormatIdentifier = fileformat::info(this->getFileFormat()).identifier;
+  const auto fileFormatIdentifier = fileformat::info (this->getFileFormat ()).identifier;
   switch (this->selectedPrintService) {
   case print_service_t::PRINT_SERVICE:
-    S::printServiceFileFormat.setValue(fileFormatIdentifier);
+    S::printServiceFileFormat.setValue (fileFormatIdentifier);
     break;
   case print_service_t::OCTOPRINT:
-    S::octoPrintFileFormat.setValue(fileFormatIdentifier);
+    S::octoPrintFileFormat.setValue (fileFormatIdentifier);
     break;
   case print_service_t::LOCAL_APPLICATION:
-    S::localAppFileFormat.setValue(fileFormatIdentifier);
+    S::localAppFileFormat.setValue (fileFormatIdentifier);
     break;
   default:
     break;
   }
   // FIXME: Add support for executable selection
-  writeSettings();
-  accept();
+  writeSettings ();
+  accept ();
 }
 
-void PrintInitDialog::on_pushButtonCancel_clicked()
-{
-  reject();
+void PrintInitDialog::on_pushButtonCancel_clicked () {
+  reject ();
 }
 
-int PrintInitDialog::exec()
-{
-  bool showDialog = this->checkBoxAlwaysShowDialog->isChecked();
-  if ((QApplication::keyboardModifiers() & Qt::ShiftModifier) != 0 ||
+int PrintInitDialog::exec () {
+  bool showDialog = this->checkBoxAlwaysShowDialog->isChecked ();
+  if ((QApplication::keyboardModifiers () & Qt::ShiftModifier) != 0 ||
       this->selectedPrintService == print_service_t::NONE) {
     showDialog = true;
   }
 
-  const auto result = showDialog ? QDialog::exec() : QDialog::Accepted;
+  const auto result = showDialog ? QDialog::exec () : QDialog::Accepted;
 
   if (showDialog && result == QDialog::Accepted) {
-    S::printServiceAlwaysShowDialog.setValue(this->checkBoxAlwaysShowDialog->isChecked());
-    writeSettings();
+    S::printServiceAlwaysShowDialog.setValue (this->checkBoxAlwaysShowDialog->isChecked ());
+    writeSettings ();
   }
 
   return result;
 }
 
-print_service_t PrintInitDialog::getServiceType() const
-{
+print_service_t PrintInitDialog::getServiceType () const {
   return this->selectedPrintService;
 }
 
-QString PrintInitDialog::getServiceName() const
-{
+QString PrintInitDialog::getServiceName () const {
   return this->selectedServiceName;
 }
 
-FileFormat PrintInitDialog::getFileFormat() const
-{
+FileFormat PrintInitDialog::getFileFormat () const {
   return this->selectedFileFormat;
 }
diff --git a/src/gui/PrintInitDialog.h b/src/gui/PrintInitDialog.h
index 34e0c722c..bbe2da41d 100644
--- a/src/gui/PrintInitDialog.h
+++ b/src/gui/PrintInitDialog.h
@@ -41,7 +41,10 @@
 // Property name for remote print servive buttons
 constexpr inline auto PROPERTY_NAME = "printServiceName";
 
-enum class print_service_t : std::uint8_t { NONE, PRINT_SERVICE, OCTOPRINT, LOCAL_APPLICATION };
+enum class print_service_t : std::uint8_t { NONE,
+                                            PRINT_SERVICE,
+                                            OCTOPRINT,
+                                            LOCAL_APPLICATION };
 
 class PrintInitDialog : public QDialog, public Ui::PrintInitDialog, public InitConfigurator
 {
@@ -50,27 +53,29 @@ class PrintInitDialog : public QDialog, public Ui::PrintInitDialog, public InitC
   constexpr static auto urlLocalApp = "qrc:/html/LocalApplicationInfo.html";
 
   Q_OBJECT;
+
 public:
-  PrintInitDialog();
-  int exec() override;
+  PrintInitDialog ();
+  int exec () override;
 
-  print_service_t getServiceType() const;
-  QString getServiceName() const;
-  FileFormat getFileFormat() const;
+  print_service_t getServiceType () const;
+  QString getServiceName () const;
+  FileFormat getFileFormat () const;
 
 public slots:
-  void on_pushButtonOctoPrint_clicked();
-  void on_pushButtonLocalApplication_clicked();
-  void on_comboBoxFileFormat_currentIndexChanged(int);
-  void on_checkBoxEnableRemotePrintServices_toggled(bool);
-  void on_pushButtonOk_clicked();
-  void on_pushButtonCancel_clicked();
+  void on_pushButtonOctoPrint_clicked ();
+  void on_pushButtonLocalApplication_clicked ();
+  void on_comboBoxFileFormat_currentIndexChanged (int);
+  void on_checkBoxEnableRemotePrintServices_toggled (bool);
+  void on_pushButtonOk_clicked ();
+  void on_pushButtonCancel_clicked ();
+
 private:
-  void resetSelection();
-  void addRemotePrintServiceButtons();
-  void populateFileFormatComboBox(const std::vector<FileFormat>& fileFormats,
-                                  FileFormat currentFormat);
-  void setFileFormat(const std::string& identifier);
+  void resetSelection ();
+  void addRemotePrintServiceButtons ();
+  void populateFileFormatComboBox (const std::vector<FileFormat> &fileFormats,
+                                   FileFormat currentFormat);
+  void setFileFormat (const std::string &identifier);
 
   QString htmlTemplate;
   print_service_t selectedPrintService = print_service_t::NONE;
diff --git a/src/gui/PrintService.cc b/src/gui/PrintService.cc
index b9f703538..117873b64 100644
--- a/src/gui/PrintService.cc
+++ b/src/gui/PrintService.cc
@@ -50,45 +50,46 @@ PrintServices PrintService::printServices;
 namespace {
 
 std::unique_ptr<PrintService>
-createPrintService(const QJsonObject& serviceObject) {
-  auto service = std::make_unique<PrintService>();
-  if (service->init(serviceObject))return service;
+createPrintService (const QJsonObject &serviceObject) {
+  auto service = std::make_unique<PrintService> ();
+  if (service->init (serviceObject))
+    return service;
   return nullptr;
 }
 
-PrintServices createPrintServices() {
+PrintServices createPrintServices () {
   PrintServices printServices;
   try {
     auto networkRequest = NetworkRequest<void>{
       QUrl{"https://app.openscad.org/print-service.json"}, {200}, 30};
-    networkRequest.execute(
-      [](QNetworkRequest& request) {
-        request.setHeader(QNetworkRequest::ContentTypeHeader,
-                          "application/json");
+    networkRequest.execute (
+      [] (QNetworkRequest &request) {
+        request.setHeader (QNetworkRequest::ContentTypeHeader,
+                           "application/json");
       },
-      [](QNetworkAccessManager& nam, QNetworkRequest& request) {
-        return nam.get(request);
+      [] (QNetworkAccessManager &nam, QNetworkRequest &request) {
+        return nam.get (request);
       },
-      [&](QNetworkReply *reply) {
-        const auto doc = QJsonDocument::fromJson(reply->readAll());
-        PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
-        const QStringList services = doc.object().keys();
-        for (const auto& serviceName : services) {
+      [&] (QNetworkReply *reply) {
+        const auto doc = QJsonDocument::fromJson (reply->readAll ());
+        PRINTDB ("Response: %s", QString{doc.toJson ()}.toStdString ());
+        const QStringList services = doc.object ().keys ();
+        for (const auto &serviceName : services) {
           auto printService =
-            createPrintService(doc.object().value(serviceName).toObject());
+            createPrintService (doc.object ().value (serviceName).toObject ());
           if (printService) {
-            printServices[serviceName.toStdString()] =
-              std::move(printService);
+            printServices[serviceName.toStdString ()] =
+              std::move (printService);
           }
         }
       });
-  } catch (const NetworkException& e) {
-    LOG(message_group::Error, "%1$s", e.getErrorMessage());
+  } catch (const NetworkException &e) {
+    LOG (message_group::Error, "%1$s", e.getErrorMessage ());
   }
-  for (const auto& printService : printServices) {
-    const auto& name = printService.second->getDisplayName().toStdString();
-    const auto& limit = printService.second->getFileSizeLimitMB();
-    PRINTDB("External print service available: %1$s (upload limit = %2$d MB)", name % limit);
+  for (const auto &printService : printServices) {
+    const auto &name = printService.second->getDisplayName ().toStdString ();
+    const auto &limit = printService.second->getFileSizeLimitMB ();
+    PRINTDB ("External print service available: %1$s (upload limit = %2$d MB)", name % limit);
     // TODO: Log if wanted
   }
 
@@ -97,50 +98,50 @@ PrintServices createPrintServices() {
 
 } // namespace
 
-const PrintServices& PrintService::getPrintServices() {
+const PrintServices &PrintService::getPrintServices () {
   static PrintServices noPrintServices;
 
-  std::lock_guard<std::mutex> guard(printServiceMutex);
+  std::lock_guard<std::mutex> guard (printServiceMutex);
 
-  if (!S::enableRemotePrintServices.value()) {
+  if (!S::enableRemotePrintServices.value ()) {
     return noPrintServices;
   }
 
-  if (printServices.empty()) {
-    printServices = createPrintServices();
+  if (printServices.empty ()) {
+    printServices = createPrintServices ();
   }
 
   return printServices;
 }
 
-const PrintService *PrintService::getPrintService(const std::string& name) {
-  const auto& printServices = getPrintServices();
-  if (const auto it = printServices.find(name); it != printServices.end()) {
-    return it->second.get();
+const PrintService *PrintService::getPrintService (const std::string &name) {
+  const auto &printServices = getPrintServices ();
+  if (const auto it = printServices.find (name); it != printServices.end ()) {
+    return it->second.get ();
   }
   return nullptr;
 }
 
-bool PrintService::init(const QJsonObject& serviceObject) {
-  displayName = serviceObject.value("displayName").toString();
-  apiUrl = serviceObject.value("apiUrl").toString();
-  fileSizeLimitMB = serviceObject.value("fileSizeLimitMB").toInt();
-  infoHtml = serviceObject.value("infoHtml").toString();
-  infoUrl = serviceObject.value("infoUrl").toString();
-  for (const auto& variant : serviceObject.value("fileFormats").toArray().toVariantList()) {
+bool PrintService::init (const QJsonObject &serviceObject) {
+  displayName = serviceObject.value ("displayName").toString ();
+  apiUrl = serviceObject.value ("apiUrl").toString ();
+  fileSizeLimitMB = serviceObject.value ("fileSizeLimitMB").toInt ();
+  infoHtml = serviceObject.value ("infoHtml").toString ();
+  infoUrl = serviceObject.value ("infoUrl").toString ();
+  for (const auto &variant : serviceObject.value ("fileFormats").toArray ().toVariantList ()) {
     FileFormat fileFormat;
-    if (fileformat::fromIdentifier(variant.toString().toStdString(), fileFormat)) {
-      fileFormats.push_back(fileFormat);
+    if (fileformat::fromIdentifier (variant.toString ().toStdString (), fileFormat)) {
+      fileFormats.push_back (fileFormat);
     }
     // TODO: else print warning?
   }
   // For legacy reasons; default to STL
-  if (fileFormats.empty()) {
-    fileFormats.push_back(FileFormat::ASCII_STL);
-    fileFormats.push_back(FileFormat::BINARY_STL);
+  if (fileFormats.empty ()) {
+    fileFormats.push_back (FileFormat::ASCII_STL);
+    fileFormats.push_back (FileFormat::BINARY_STL);
   }
-  return !displayName.isEmpty() && !apiUrl.isEmpty() && !infoHtml.isEmpty() &&
-         !infoUrl.isEmpty() && fileSizeLimitMB != 0;
+  return !displayName.isEmpty () && !apiUrl.isEmpty () && !infoHtml.isEmpty () &&
+         !infoUrl.isEmpty () && fileSizeLimitMB != 0;
 }
 
 /**
@@ -156,49 +157,49 @@ bool PrintService::init(const QJsonObject& serviceObject) {
  *    The resulting url to go to next to continue the order process.
  */
 const QString
-PrintService::upload(const QString& fileName, const QString& contentBase64,
-                     const network_progress_func_t& progress_func) const {
+PrintService::upload (const QString &fileName, const QString &contentBase64,
+                      const network_progress_func_t &progress_func) const {
   QJsonObject jsonInput;
-  jsonInput.insert("fileName", fileName);
-  jsonInput.insert("file", contentBase64);
+  jsonInput.insert ("fileName", fileName);
+  jsonInput.insert ("file", contentBase64);
 
   // Safe guard against QJson silently dropping the file content if it's
   // too big. This seems to be configured at MaxSize = (1<<27) - 1 in Qt
   // via qtbase/src/corelib/json/qjson_p.h
   // Due to the base64 encoding having 33% overhead, that should allow for
   // about 96MB data.
-  if (jsonInput.value("file") == QJsonValue::Undefined) {
+  if (jsonInput.value ("file") == QJsonValue::Undefined) {
     const QString msg =
       "Could not encode STL into JSON. Perhaps it is too large of a file? "
       "Maybe try reducing the model resolution.";
-    throw NetworkException(QNetworkReply::ProtocolFailure, msg);
+    throw NetworkException (QNetworkReply::ProtocolFailure, msg);
   }
 
   auto networkRequest =
     NetworkRequest<const QString>{QUrl{apiUrl}, {200, 201}, 180};
-  networkRequest.set_progress_func(progress_func);
-  return networkRequest.execute(
-    [](QNetworkRequest& request) {
-    request.setHeader(QNetworkRequest::ContentTypeHeader,
-                      "application/json");
-  },
-    [&](QNetworkAccessManager& nam, QNetworkRequest& request) {
-    return nam.post(request, QJsonDocument(jsonInput).toJson());
-  },
-    [](QNetworkReply *reply) {
-    const auto doc = QJsonDocument::fromJson(reply->readAll());
-    PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
-
-    // Extract cartUrl which gives the page to open in a webbrowser to view
-    // uploaded part
-    auto cartUrlValue =
-      doc.object().value("data").toObject().value("cartUrl");
-    auto cartUrl = cartUrlValue.toString();
-    if ((cartUrlValue == QJsonValue::Undefined) || (cartUrl.isEmpty())) {
-      const QString msg = "Could not get data.cartUrl field from response.";
-      throw NetworkException(QNetworkReply::ProtocolFailure, msg);
-    }
-    LOG("Upload finished, opening URL %1$s.", cartUrl.toStdString());
-    return cartUrl;
-  });
+  networkRequest.set_progress_func (progress_func);
+  return networkRequest.execute (
+    [] (QNetworkRequest &request) {
+      request.setHeader (QNetworkRequest::ContentTypeHeader,
+                         "application/json");
+    },
+    [&] (QNetworkAccessManager &nam, QNetworkRequest &request) {
+      return nam.post (request, QJsonDocument (jsonInput).toJson ());
+    },
+    [] (QNetworkReply *reply) {
+      const auto doc = QJsonDocument::fromJson (reply->readAll ());
+      PRINTDB ("Response: %s", QString{doc.toJson ()}.toStdString ());
+
+      // Extract cartUrl which gives the page to open in a webbrowser to view
+      // uploaded part
+      auto cartUrlValue =
+        doc.object ().value ("data").toObject ().value ("cartUrl");
+      auto cartUrl = cartUrlValue.toString ();
+      if ((cartUrlValue == QJsonValue::Undefined) || (cartUrl.isEmpty ())) {
+        const QString msg = "Could not get data.cartUrl field from response.";
+        throw NetworkException (QNetworkReply::ProtocolFailure, msg);
+      }
+      LOG ("Upload finished, opening URL %1$s.", cartUrl.toStdString ());
+      return cartUrl;
+    });
 }
diff --git a/src/gui/PrintService.h b/src/gui/PrintService.h
index 28f408c3b..95c909a14 100644
--- a/src/gui/PrintService.h
+++ b/src/gui/PrintService.h
@@ -45,24 +45,39 @@ using PrintServices = std::unordered_map<std::string, std::unique_ptr<class Prin
 class PrintService
 {
 public:
-  const QString getService() const { return service; }
-  const QString getDisplayName() const { return displayName; }
-  const QString getApiUrl() const { return apiUrl; }
-  long getFileSizeLimit() const { return fileSizeLimitMB * 1024ul * 1024ul; }
-  long getFileSizeLimitMB() const { return fileSizeLimitMB; }
-  const QString getInfoHtml() const { return infoHtml; }
-  const QString getInfoUrl() const { return infoUrl; }
-  const std::vector<FileFormat> getFileFormats() const { return fileFormats; }
+  const QString getService () const {
+    return service;
+  }
+  const QString getDisplayName () const {
+    return displayName;
+  }
+  const QString getApiUrl () const {
+    return apiUrl;
+  }
+  long getFileSizeLimit () const {
+    return fileSizeLimitMB * 1024ul * 1024ul;
+  }
+  long getFileSizeLimitMB () const {
+    return fileSizeLimitMB;
+  }
+  const QString getInfoHtml () const {
+    return infoHtml;
+  }
+  const QString getInfoUrl () const {
+    return infoUrl;
+  }
+  const std::vector<FileFormat> getFileFormats () const {
+    return fileFormats;
+  }
 
-  const QString upload(const QString& exportFileName, const QString& fileName, const network_progress_func_t& progress_func) const;
+  const QString upload (const QString &exportFileName, const QString &fileName, const network_progress_func_t &progress_func) const;
 
-  bool init(const QJsonObject& serviceObject);
+  bool init (const QJsonObject &serviceObject);
 
-  static const PrintService *getPrintService(const std::string& name);
-  static const PrintServices& getPrintServices();
+  static const PrintService *getPrintService (const std::string &name);
+  static const PrintServices &getPrintServices ();
 
 private:
-
   QString service;
   QString displayName;
   QString apiUrl;
diff --git a/src/gui/ProgressWidget.cc b/src/gui/ProgressWidget.cc
index 24229f9b6..f16870fab 100644
--- a/src/gui/ProgressWidget.cc
+++ b/src/gui/ProgressWidget.cc
@@ -2,48 +2,41 @@
 #include <QWidget>
 #include <QTimer>
 
-ProgressWidget::ProgressWidget(QWidget *parent)
-  : QWidget(parent)
-{
-  setupUi(this);
-  setRange(0, 1000);
-  setValue(0);
+ProgressWidget::ProgressWidget (QWidget *parent)
+  : QWidget (parent) {
+  setupUi (this);
+  setRange (0, 1000);
+  setValue (0);
   this->wascanceled = false;
-  this->starttime.start();
+  this->starttime.start ();
 
-  connect(this->stopButton, &QPushButton::clicked, this, &ProgressWidget::cancel);
-  QTimer::singleShot(1000, this, &ProgressWidget::requestShow);
+  connect (this->stopButton, &QPushButton::clicked, this, &ProgressWidget::cancel);
+  QTimer::singleShot (1000, this, &ProgressWidget::requestShow);
 }
 
-bool ProgressWidget::wasCanceled() const
-{
+bool ProgressWidget::wasCanceled () const {
   return this->wascanceled;
 }
 
 /*!
    Returns milliseconds since this widget was created
  */
-int ProgressWidget::elapsedTime() const
-{
-  return this->starttime.elapsed();
+int ProgressWidget::elapsedTime () const {
+  return this->starttime.elapsed ();
 }
 
-void ProgressWidget::cancel()
-{
+void ProgressWidget::cancel () {
   this->wascanceled = true;
 }
 
-void ProgressWidget::setRange(int minimum, int maximum)
-{
-  this->progressBar->setRange(minimum, maximum);
+void ProgressWidget::setRange (int minimum, int maximum) {
+  this->progressBar->setRange (minimum, maximum);
 }
 
-void ProgressWidget::setValue(int progress)
-{
-  this->progressBar->setValue(progress);
+void ProgressWidget::setValue (int progress) {
+  this->progressBar->setValue (progress);
 }
 
-int ProgressWidget::value() const
-{
-  return this->progressBar->value();
+int ProgressWidget::value () const {
+  return this->progressBar->value ();
 }
diff --git a/src/gui/ProgressWidget.h b/src/gui/ProgressWidget.h
index 6f0723325..584c0d91a 100644
--- a/src/gui/ProgressWidget.h
+++ b/src/gui/ProgressWidget.h
@@ -8,21 +8,21 @@
 class ProgressWidget : public QWidget, public Ui::ProgressWidget
 {
   Q_OBJECT;
-  Q_PROPERTY(bool wasCanceled READ wasCanceled);
+  Q_PROPERTY (bool wasCanceled READ wasCanceled);
 
 public:
-  ProgressWidget(QWidget *parent = nullptr);
-  bool wasCanceled() const;
-  int elapsedTime() const;
+  ProgressWidget (QWidget *parent = nullptr);
+  bool wasCanceled () const;
+  int elapsedTime () const;
 
 public slots:
-  void setRange(int minimum, int maximum);
-  void setValue(int progress);
-  int value() const;
-  void cancel();
+  void setRange (int minimum, int maximum);
+  void setValue (int progress);
+  int value () const;
+  void cancel ();
 
 signals:
-  void requestShow();
+  void requestShow ();
 
 private:
   bool wascanceled;
diff --git a/src/gui/QGLView.cc b/src/gui/QGLView.cc
index d8da76924..4cb58ac2d 100644
--- a/src/gui/QGLView.cc
+++ b/src/gui/QGLView.cc
@@ -63,151 +63,142 @@
 #include <vector>
 
 #ifdef ENABLE_OPENCSG
-#  include <opencsg.h>
+#include <opencsg.h>
 #endif
 
 #include "gui/qt-obsolete.h"
 #include "gui/Measurement.h"
 
-QGLView::QGLView(QWidget *parent) : QOpenGLWidget(parent)
-{
-  init();
+QGLView::QGLView (QWidget *parent)
+  : QOpenGLWidget (parent) {
+  init ();
 }
 
-QGLView::~QGLView()
-{
+QGLView::~QGLView () {
   // Just to make sure we can call GL functions in the supertype destructor
-  makeCurrent();
+  makeCurrent ();
 }
 
-void QGLView::init()
-{
-  resetView();
+void QGLView::init () {
+  resetView ();
 
   this->mouse_drag_active = false;
   this->statusLabel = nullptr;
 
-  setMouseTracking(true);
+  setMouseTracking (true);
 }
 
-void QGLView::resetView()
-{
-  cam.resetView();
+void QGLView::resetView () {
+  cam.resetView ();
 }
 
-void QGLView::viewAll()
-{
-  if (auto renderer = this->getRenderer()) {
-    auto bbox = renderer->getBoundingBox();
+void QGLView::viewAll () {
+  if (auto renderer = this->getRenderer ()) {
+    auto bbox = renderer->getBoundingBox ();
     cam.autocenter = true;
-    cam.viewAll(renderer->getBoundingBox());
+    cam.viewAll (renderer->getBoundingBox ());
   }
 }
 
-void QGLView::initializeGL()
-{
+void QGLView::initializeGL () {
 #if defined(USE_GLEW) || defined(OPENCSG_GLEW)
   // Since OpenCSG requires glew, we need to initialize it.
   // ..in a separate compilation unit to avoid duplicate symbols with x.
-  initializeGlew();
+  initializeGlew ();
 #endif
 #ifdef USE_GLAD
   // We could ask for gladLoadGLES2UserPtr() here if we want to use GLES2+
-  const auto version = gladLoadGLUserPtr([](void *ctx, const char *name) -> GLADapiproc {
-    return reinterpret_cast<QOpenGLContext *>(ctx)->getProcAddress(name);
-  }, this->context());
+  const auto version = gladLoadGLUserPtr ([] (void *ctx, const char *name) -> GLADapiproc {
+    return reinterpret_cast<QOpenGLContext *> (ctx)->getProcAddress (name);
+  },
+                                          this->context ());
   if (version == 0) {
     std::cerr << "Unable to init GLAD" << std::endl;
     return;
   }
-  PRINTDB("GLAD: Loaded OpenGL %d.%d", GLAD_VERSION_MAJOR(version) % GLAD_VERSION_MINOR(version));
+  PRINTDB ("GLAD: Loaded OpenGL %d.%d", GLAD_VERSION_MAJOR (version) % GLAD_VERSION_MINOR (version));
 #endif // ifdef USE_GLAD
-  GLView::initializeGL();
+  GLView::initializeGL ();
 
-  this->selector = std::make_unique<MouseSelector>(this);
+  this->selector = std::make_unique<MouseSelector> (this);
 }
 
-std::string QGLView::getRendererInfo() const
-{
+std::string QGLView::getRendererInfo () const {
   std::ostringstream info;
-  info << gl_dump();
+  info << gl_dump ();
   // Don't translate as translated text in the Library Info dialog is not wanted
   info << "\nQt graphics widget: QOpenGLWidget";
-  auto qsf = this->format();
-  auto rbits = qsf.redBufferSize();
-  auto gbits = qsf.greenBufferSize();
-  auto bbits = qsf.blueBufferSize();
-  auto abits = qsf.alphaBufferSize();
-  auto dbits = qsf.depthBufferSize();
-  auto sbits = qsf.stencilBufferSize();
-  info << boost::format("\nQSurfaceFormat: RGBA(%d%d%d%d), depth(%d), stencil(%d)\n\n") %
-    rbits % gbits % bbits % abits % dbits % sbits;
-  info << gl_extensions_dump();
-  return info.str();
+  auto qsf = this->format ();
+  auto rbits = qsf.redBufferSize ();
+  auto gbits = qsf.greenBufferSize ();
+  auto bbits = qsf.blueBufferSize ();
+  auto abits = qsf.alphaBufferSize ();
+  auto dbits = qsf.depthBufferSize ();
+  auto sbits = qsf.stencilBufferSize ();
+  info << boost::format ("\nQSurfaceFormat: RGBA(%d%d%d%d), depth(%d), stencil(%d)\n\n") %
+            rbits % gbits % bbits % abits % dbits % sbits;
+  info << gl_extensions_dump ();
+  return info.str ();
 }
 
 #ifdef ENABLE_OPENCSG
-void QGLView::display_opencsg_warning()
-{
-  if (GlobalPreferences::inst()->getValue("advanced/opencsg_show_warning").toBool()) {
-    QTimer::singleShot(0, this, &QGLView::display_opencsg_warning_dialog);
+void QGLView::display_opencsg_warning () {
+  if (GlobalPreferences::inst ()->getValue ("advanced/opencsg_show_warning").toBool ()) {
+    QTimer::singleShot (0, this, &QGLView::display_opencsg_warning_dialog);
   }
 }
 
-void QGLView::display_opencsg_warning_dialog()
-{
-  auto dialog = new OpenCSGWarningDialog(this);
+void QGLView::display_opencsg_warning_dialog () {
+  auto dialog = new OpenCSGWarningDialog (this);
 
-  QString message = _("Warning: Missing OpenGL capabilities for OpenCSG - OpenCSG has been disabled.\n\n");
-  message += _("It is highly recommended to use OpenSCAD on a system with "
-               "OpenGL 2.0 or later.\n"
-               "Your renderer information is as follows:\n");
+  QString message = _ ("Warning: Missing OpenGL capabilities for OpenCSG - OpenCSG has been disabled.\n\n");
+  message += _ (
+    "It is highly recommended to use OpenSCAD on a system with "
+    "OpenGL 2.0 or later.\n"
+    "Your renderer information is as follows:\n");
 #if defined(USE_GLEW) || defined(OPENCSG_GLEW)
-  QString rendererinfo(_("GLEW version %1\n%2 (%3)\nOpenGL version %4\n"));
-  message += rendererinfo.arg((const char *)glewGetString(GLEW_VERSION),
-                              (const char *)glGetString(GL_RENDERER),
-                              (const char *)glGetString(GL_VENDOR),
-                              (const char *)glGetString(GL_VERSION));
+  QString rendererinfo (_ ("GLEW version %1\n%2 (%3)\nOpenGL version %4\n"));
+  message += rendererinfo.arg ((const char *)glewGetString (GLEW_VERSION),
+                               (const char *)glGetString (GL_RENDERER),
+                               (const char *)glGetString (GL_VENDOR),
+                               (const char *)glGetString (GL_VERSION));
 #endif
 #ifdef USE_GLAD
-  QString rendererinfo(_("GLAD version %1\n%2 (%3)\nOpenGL version %4\n"));
-  message += rendererinfo.arg(GLAD_GENERATOR_VERSION,
-                              (const char *)glGetString(GL_RENDERER),
-                              (const char *)glGetString(GL_VENDOR),
-                              (const char *)glGetString(GL_VERSION));
+  QString rendererinfo (_ ("GLAD version %1\n%2 (%3)\nOpenGL version %4\n"));
+  message += rendererinfo.arg (GLAD_GENERATOR_VERSION,
+                               (const char *)glGetString (GL_RENDERER),
+                               (const char *)glGetString (GL_VENDOR),
+                               (const char *)glGetString (GL_VERSION));
 #endif
-  dialog->setText(message);
-  dialog->exec();
+  dialog->setText (message);
+  dialog->exec ();
 }
 #endif // ifdef ENABLE_OPENCSG
 
-void QGLView::resizeGL(int w, int h)
-{
-  GLView::resizeGL(w, h);
-  emit resized();
+void QGLView::resizeGL (int w, int h) {
+  GLView::resizeGL (w, h);
+  emit resized ();
 }
 
-void QGLView::paintGL()
-{
-  GLView::paintGL();
+void QGLView::paintGL () {
+  GLView::paintGL ();
 
   if (statusLabel) {
-    auto status = QString("%1 (%2x%3)")
-      .arg(QString::fromStdString(cam.statusText()))
-      .arg(size().rwidth())
-      .arg(size().rheight());
-    statusLabel->setText(status);
+    auto status = QString ("%1 (%2x%3)")
+                    .arg (QString::fromStdString (cam.statusText ()))
+                    .arg (size ().rwidth ())
+                    .arg (size ().rheight ());
+    statusLabel->setText (status);
   }
 }
 
-void QGLView::mousePressEvent(QMouseEvent *event)
-{
+void QGLView::mousePressEvent (QMouseEvent *event) {
   if (!mouse_drag_active) {
     mouse_drag_moved = false;
   }
 
   mouse_drag_active = true;
-  last_mouse = event->globalPos();
+  last_mouse = event->globalPos ();
 }
 
 /*
@@ -249,99 +240,99 @@ void QGLView::mousePressEvent(QMouseEvent *event)
  * - This function should probably only react to left double clicks.  Right double clicks
  *   should probably be ignored.
  */
-void QGLView::mouseDoubleClickEvent(QMouseEvent *event) {
-  QOpenGLContext *oldContext = getGLContext();
-  this->makeCurrent();
-  setupCamera();
+void QGLView::mouseDoubleClickEvent (QMouseEvent *event) {
+  QOpenGLContext *oldContext = getGLContext ();
+  this->makeCurrent ();
+  setupCamera ();
 
   int viewport[4];
   GLdouble modelview[16];
   GLdouble projection[16];
 
-  glGetIntegerv(GL_VIEWPORT, viewport);
-  glGetDoublev(GL_MODELVIEW_MATRIX, modelview);
-  glGetDoublev(GL_PROJECTION_MATRIX, projection);
+  glGetIntegerv (GL_VIEWPORT, viewport);
+  glGetDoublev (GL_MODELVIEW_MATRIX, modelview);
+  glGetDoublev (GL_PROJECTION_MATRIX, projection);
 
-  const double dpi = this->getDPI();
-  const double x = event->pos().x() * dpi;
-  const double y = viewport[3] - event->pos().y() * dpi;
+  const double dpi = this->getDPI ();
+  const double x = event->pos ().x () * dpi;
+  const double y = viewport[3] - event->pos ().y () * dpi;
   GLfloat z = 0;
 
-  glGetError(); // clear error state so we don't pick up previous errors
-  glReadPixels(x, y, 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, &z);
-  if (const auto glError = glGetError(); glError != GL_NO_ERROR) {
+  glGetError (); // clear error state so we don't pick up previous errors
+  glReadPixels (x, y, 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, &z);
+  if (const auto glError = glGetError (); glError != GL_NO_ERROR) {
     if (statusLabel) {
-      auto status = QString("Center View: OpenGL Error reading Pixel: %s")
-        .arg(QString::fromLocal8Bit((const char *)gluErrorString(glError)));
-      statusLabel->setText(status);
+      auto status = QString ("Center View: OpenGL Error reading Pixel: %s")
+                      .arg (QString::fromLocal8Bit ((const char *)gluErrorString (glError)));
+      statusLabel->setText (status);
     }
-    setGLContext(oldContext);
+    setGLContext (oldContext);
     return;
   }
 
   if (z == 1) {
-    setGLContext(oldContext);
+    setGLContext (oldContext);
     return; // outside object
   }
 
   GLdouble px, py, pz;
 
-  auto success = gluUnProject(x, y, z, modelview, projection, viewport, &px, &py, &pz);
+  auto success = gluUnProject (x, y, z, modelview, projection, viewport, &px, &py, &pz);
 
   if (success == GL_TRUE) {
-    cam.object_trans -= Vector3d(px, py, pz);
-    update();
-    emit cameraChanged();
+    cam.object_trans -= Vector3d (px, py, pz);
+    update ();
+    emit cameraChanged ();
   }
-  setGLContext(oldContext);
+  setGLContext (oldContext);
 }
 
-void QGLView::normalizeAngle(GLdouble& angle)
-{
-  while (angle < 0) angle += 360;
-  while (angle > 360) angle -= 360;
+void QGLView::normalizeAngle (GLdouble &angle) {
+  while (angle < 0)
+    angle += 360;
+  while (angle > 360)
+    angle -= 360;
 }
 
-void QGLView::mouseMoveEvent(QMouseEvent *event)
-{
-  auto this_mouse = event->globalPos();
+void QGLView::mouseMoveEvent (QMouseEvent *event) {
+  auto this_mouse = event->globalPos ();
   if (measure_state != MEASURE_IDLE) {
-    QPoint pt = event->pos();
-    this->shown_obj = findObject(pt.x(), pt.y());
-    update();
+    QPoint pt = event->pos ();
+    this->shown_obj = findObject (pt.x (), pt.y ());
+    update ();
   }
-  double dx = (this_mouse.x() - last_mouse.x()) * 0.7;
-  double dy = (this_mouse.y() - last_mouse.y()) * 0.7;
+  double dx = (this_mouse.x () - last_mouse.x ()) * 0.7;
+  double dy = (this_mouse.y () - last_mouse.y ()) * 0.7;
   if (mouse_drag_active) {
     mouse_drag_moved = true;
-    auto button_compare = this->mouseSwapButtons?Qt::RightButton : Qt::LeftButton;
-    if (event->buttons() & button_compare
+    auto button_compare = this->mouseSwapButtons ? Qt::RightButton : Qt::LeftButton;
+    if (event->buttons () & button_compare
 #ifdef Q_OS_MACOS
-        && !(event->modifiers() & Qt::MetaModifier)
+        && !(event->modifiers () & Qt::MetaModifier)
 #endif
-        ) {
+    ) {
       // Left button rotates in xz, Shift-left rotates in xy
       // On Mac, Ctrl-Left is handled as right button on other platforms
-      if ((QApplication::keyboardModifiers() & Qt::ShiftModifier) != 0) {
-        rotate(dy, dx, 0.0, true);
+      if ((QApplication::keyboardModifiers () & Qt::ShiftModifier) != 0) {
+        rotate (dy, dx, 0.0, true);
       } else {
-        rotate(dy, 0.0, dx, true);
+        rotate (dy, 0.0, dx, true);
       }
 
-      normalizeAngle(cam.object_rot.x());
-      normalizeAngle(cam.object_rot.y());
-      normalizeAngle(cam.object_rot.z());
+      normalizeAngle (cam.object_rot.x ());
+      normalizeAngle (cam.object_rot.y ());
+      normalizeAngle (cam.object_rot.z ());
     } else {
       // Right button pans in the xz plane
       // Middle button pans in the xy plane
       // Shift-right and Shift-middle zooms
-      if ((QApplication::keyboardModifiers() & Qt::ShiftModifier) != 0) {
-        zoom(-12.0 * dy, true);
+      if ((QApplication::keyboardModifiers () & Qt::ShiftModifier) != 0) {
+        zoom (-12.0 * dy, true);
       } else {
-        double mx = +(dx) * 3.0 * cam.zoomValue() / QWidget::width();
-        double mz = -(dy) * 3.0 * cam.zoomValue() / QWidget::height();
+        double mx = +(dx) * 3.0 * cam.zoomValue () / QWidget::width ();
+        double mz = -(dy) * 3.0 * cam.zoomValue () / QWidget::height ();
         double my = 0;
-        if (event->buttons() & Qt::MiddleButton) {
+        if (event->buttons () & Qt::MiddleButton) {
           my = mz;
           mz = 0;
           // actually lock the x-position
@@ -349,244 +340,230 @@ void QGLView::mouseMoveEvent(QMouseEvent *event)
           mx = 0;
         }
 
-        translate(mx, my, mz, true);
+        translate (mx, my, mz, true);
       }
     }
   }
   last_mouse = this_mouse;
 }
 
-void QGLView::mouseReleaseEvent(QMouseEvent *event)
-{
+void QGLView::mouseReleaseEvent (QMouseEvent *event) {
   mouse_drag_active = false;
-  releaseMouse();
+  releaseMouse ();
 
-  auto button_right = this->mouseSwapButtons?Qt::LeftButton : Qt::RightButton;
-  auto button_left = this->mouseSwapButtons?Qt::RightButton : Qt::LeftButton;
+  auto button_right = this->mouseSwapButtons ? Qt::LeftButton : Qt::RightButton;
+  auto button_left = this->mouseSwapButtons ? Qt::RightButton : Qt::LeftButton;
   if (!mouse_drag_moved) {
-    if (event->button() == button_right) {
-      QPoint point = event->pos();
-      emit doRightClick(point);
+    if (event->button () == button_right) {
+      QPoint point = event->pos ();
+      emit doRightClick (point);
     }
-    if (event->button() == button_left) {
-      QPoint point = event->pos();
-      emit doLeftClick(point);
+    if (event->button () == button_left) {
+      QPoint point = event->pos ();
+      emit doLeftClick (point);
     }
   }
   mouse_drag_moved = false;
 }
 
-const QImage& QGLView::grabFrame()
-{
+const QImage &QGLView::grabFrame () {
   // Force reading from front buffer. Some configurations will read from the back buffer here.
-  glReadBuffer(GL_FRONT);
-  this->frame = grabFramebuffer();
+  glReadBuffer (GL_FRONT);
+  this->frame = grabFramebuffer ();
   return this->frame;
 }
 
-bool QGLView::save(const char *filename) const
-{
-  return this->frame.save(filename, "PNG");
+bool QGLView::save (const char *filename) const {
+  return this->frame.save (filename, "PNG");
 }
 
-void QGLView::wheelEvent(QWheelEvent *event)
-{
-  const auto pos = Q_WHEEL_EVENT_POSITION(event);
-  const int v = event->angleDelta().y();
-  if (QApplication::keyboardModifiers() & Qt::ShiftModifier) {
-    zoomFov(v);
+void QGLView::wheelEvent (QWheelEvent *event) {
+  const auto pos = Q_WHEEL_EVENT_POSITION (event);
+  const int v = event->angleDelta ().y ();
+  if (QApplication::keyboardModifiers () & Qt::ShiftModifier) {
+    zoomFov (v);
   } else if (this->mouseCentricZoom) {
-    zoomCursor(pos.x(), pos.y(), v);
+    zoomCursor (pos.x (), pos.y (), v);
   } else {
-    zoom(v, true);
+    zoom (v, true);
   }
 }
 
-void QGLView::ZoomIn()
-{
-  zoom(120, true);
+void QGLView::ZoomIn () {
+  zoom (120, true);
 }
 
-void QGLView::ZoomOut()
-{
-  zoom(-120, true);
+void QGLView::ZoomOut () {
+  zoom (-120, true);
 }
 
-void QGLView::zoom(double v, bool relative)
-{
-  this->cam.zoom(v, relative);
-  update();
-  emit cameraChanged();
+void QGLView::zoom (double v, bool relative) {
+  this->cam.zoom (v, relative);
+  update ();
+  emit cameraChanged ();
 }
 
-void QGLView::zoomFov(double v)
-{
-  this->cam.setVpf(this->cam.fovValue() * pow(0.9, v / 120.0));
-  update();
-  emit cameraChanged();
+void QGLView::zoomFov (double v) {
+  this->cam.setVpf (this->cam.fovValue () * pow (0.9, v / 120.0));
+  update ();
+  emit cameraChanged ();
 }
 
-void QGLView::zoomCursor(int x, int y, int zoom)
-{
-  const auto old_dist = cam.zoomValue();
-  this->cam.zoom(zoom, true);
-  const auto dist = cam.zoomValue();
+void QGLView::zoomCursor (int x, int y, int zoom) {
+  const auto old_dist = cam.zoomValue ();
+  this->cam.zoom (zoom, true);
+  const auto dist = cam.zoomValue ();
   const auto ratio = old_dist / dist - 1.0;
   // screen coordinates from -1 to 1
   const auto screen_x = 2.0 * (x + 0.5) / this->cam.pixel_width - 1.0;
   const auto screen_y = 1.0 - 2.0 * (y + 0.5) / this->cam.pixel_height;
-  const auto height = dist * tan_degrees(cam.fov / 2);
+  const auto height = dist * tan_degrees (cam.fov / 2);
   const auto mx = ratio * screen_x * (aspectratio * height);
   const auto mz = ratio * screen_y * height;
-  translate(-mx, 0, -mz, true);
+  translate (-mx, 0, -mz, true);
 }
 
-void QGLView::setOrthoMode(bool enabled)
-{
-  if (enabled) this->cam.setProjection(Camera::ProjectionType::ORTHOGONAL);
-  else this->cam.setProjection(Camera::ProjectionType::PERSPECTIVE);
+void QGLView::setOrthoMode (bool enabled) {
+  if (enabled)
+    this->cam.setProjection (Camera::ProjectionType::ORTHOGONAL);
+  else
+    this->cam.setProjection (Camera::ProjectionType::PERSPECTIVE);
 }
 
-void QGLView::translate(double x, double y, double z, bool relative, bool viewPortRelative)
-{
+void QGLView::translate (double x, double y, double z, bool relative, bool viewPortRelative) {
   Matrix3d aax, aay, aaz;
-  aax = angle_axis_degrees(-cam.object_rot.x(), Vector3d::UnitX());
-  aay = angle_axis_degrees(-cam.object_rot.y(), Vector3d::UnitY());
-  aaz = angle_axis_degrees(-cam.object_rot.z(), Vector3d::UnitZ());
+  aax = angle_axis_degrees (-cam.object_rot.x (), Vector3d::UnitX ());
+  aay = angle_axis_degrees (-cam.object_rot.y (), Vector3d::UnitY ());
+  aaz = angle_axis_degrees (-cam.object_rot.z (), Vector3d::UnitZ ());
   Matrix3d tm3 = aaz * aay * aax;
 
-  Matrix4d tm = Matrix4d::Identity();
+  Matrix4d tm = Matrix4d::Identity ();
   if (viewPortRelative) {
     for (int i = 0; i < 3; ++i) {
       for (int j = 0; j < 3; ++j) {
-        tm(j, i) = tm3(j, i);
+        tm (j, i) = tm3 (j, i);
       }
     }
   }
 
   Matrix4d vec;
-  vec <<
-    0, 0, 0, x,
+  vec << 0, 0, 0, x,
     0, 0, 0, y,
     0, 0, 0, z,
-    0, 0, 0, 1
-  ;
+    0, 0, 0, 1;
   tm = tm * vec;
   double f = relative ? 1 : 0;
-  cam.object_trans.x() = f * cam.object_trans.x() + tm(0, 3);
-  cam.object_trans.y() = f * cam.object_trans.y() + tm(1, 3);
-  cam.object_trans.z() = f * cam.object_trans.z() + tm(2, 3);
-  update();
-  emit cameraChanged();
+  cam.object_trans.x () = f * cam.object_trans.x () + tm (0, 3);
+  cam.object_trans.y () = f * cam.object_trans.y () + tm (1, 3);
+  cam.object_trans.z () = f * cam.object_trans.z () + tm (2, 3);
+  update ();
+  emit cameraChanged ();
 }
 
-void QGLView::rotate(double x, double y, double z, bool relative)
-{
+void QGLView::rotate (double x, double y, double z, bool relative) {
   double f = relative ? 1 : 0;
-  cam.object_rot.x() = f * cam.object_rot.x() + x;
-  cam.object_rot.y() = f * cam.object_rot.y() + y;
-  cam.object_rot.z() = f * cam.object_rot.z() + z;
-  normalizeAngle(cam.object_rot.x());
-  normalizeAngle(cam.object_rot.y());
-  normalizeAngle(cam.object_rot.z());
-  update();
-  emit cameraChanged();
+  cam.object_rot.x () = f * cam.object_rot.x () + x;
+  cam.object_rot.y () = f * cam.object_rot.y () + y;
+  cam.object_rot.z () = f * cam.object_rot.z () + z;
+  normalizeAngle (cam.object_rot.x ());
+  normalizeAngle (cam.object_rot.y ());
+  normalizeAngle (cam.object_rot.z ());
+  update ();
+  emit cameraChanged ();
 }
 
-void QGLView::rotate2(double x, double y, double z)
-{
+void QGLView::rotate2 (double x, double y, double z) {
   // This vector describes the rotation.
   // The direction of the vector is the angle around which to rotate, and
   // the length of the vector is the angle by which to rotate
-  Vector3d rot = Vector3d(-x, -y, -z);
+  Vector3d rot = Vector3d (-x, -y, -z);
 
   // get current rotation matrix
   Matrix3d aax, aay, aaz, rmx;
-  aax = angle_axis_degrees(-cam.object_rot.x(), Vector3d::UnitX());
-  aay = angle_axis_degrees(-cam.object_rot.y(), Vector3d::UnitY());
-  aaz = angle_axis_degrees(-cam.object_rot.z(), Vector3d::UnitZ());
+  aax = angle_axis_degrees (-cam.object_rot.x (), Vector3d::UnitX ());
+  aay = angle_axis_degrees (-cam.object_rot.y (), Vector3d::UnitY ());
+  aaz = angle_axis_degrees (-cam.object_rot.z (), Vector3d::UnitZ ());
   rmx = aaz * (aay * aax);
 
   // rotate
-  rmx = rmx * angle_axis_degrees(rot.norm(), rot.normalized());
+  rmx = rmx * angle_axis_degrees (rot.norm (), rot.normalized ());
 
   // back to euler
   // see: http://staff.city.ac.uk/~sbbh653/publications/euler.pdf
   double theta, psi, phi;
-  if (abs(rmx(2, 0)) != 1) {
-    theta = -asin_degrees(rmx(2, 0));
-    psi = atan2_degrees(rmx(2, 1) / cos_degrees(theta), rmx(2, 2) / cos_degrees(theta));
-    phi = atan2_degrees(rmx(1, 0) / cos_degrees(theta), rmx(0, 0) / cos_degrees(theta));
+  if (abs (rmx (2, 0)) != 1) {
+    theta = -asin_degrees (rmx (2, 0));
+    psi = atan2_degrees (rmx (2, 1) / cos_degrees (theta), rmx (2, 2) / cos_degrees (theta));
+    phi = atan2_degrees (rmx (1, 0) / cos_degrees (theta), rmx (0, 0) / cos_degrees (theta));
   } else {
     phi = 0;
-    if (rmx(2, 0) == -1) {
+    if (rmx (2, 0) == -1) {
       theta = 90;
-      psi = phi + atan2_degrees(rmx(0, 1), rmx(0, 2));
+      psi = phi + atan2_degrees (rmx (0, 1), rmx (0, 2));
     } else {
       theta = -90;
-      psi = -phi + atan2_degrees(-rmx(0, 1), -rmx(0, 2));
+      psi = -phi + atan2_degrees (-rmx (0, 1), -rmx (0, 2));
     }
   }
 
-  cam.object_rot.x() = -psi;
-  cam.object_rot.y() = -theta;
-  cam.object_rot.z() = -phi;
+  cam.object_rot.x () = -psi;
+  cam.object_rot.y () = -theta;
+  cam.object_rot.z () = -phi;
 
-  normalizeAngle(cam.object_rot.x());
-  normalizeAngle(cam.object_rot.y());
-  normalizeAngle(cam.object_rot.z());
+  normalizeAngle (cam.object_rot.x ());
+  normalizeAngle (cam.object_rot.y ());
+  normalizeAngle (cam.object_rot.z ());
 
-  update();
-  emit cameraChanged();
+  update ();
+  emit cameraChanged ();
 }
 
-std::vector<SelectedObject> QGLView::findObject(int mouse_x, int mouse_y)
-{
+std::vector<SelectedObject> QGLView::findObject (int mouse_x, int mouse_y) {
   int viewport[4] = {0, 0, 0, 0};
   double posXF, posYF, posZF;
   double posXN, posYN, posZN;
-  viewport[2] = size().rwidth();
-  viewport[3] = size().rheight();
+  viewport[2] = size ().rwidth ();
+  viewport[3] = size ().rheight ();
 
   GLdouble winX = mouse_x;
   GLdouble winY = viewport[3] - mouse_y;
 
-  gluUnProject(winX, winY, 1, this->modelview, this->projection, viewport, &posXF, &posYF, &posZF);
-  gluUnProject(winX, winY, -1, this->modelview, this->projection, viewport, &posXN, &posYN, &posZN);
-  Vector3d far_pt(posXF, posYF, posZF);
-  Vector3d near_pt(posXN, posYN, posZN);
+  gluUnProject (winX, winY, 1, this->modelview, this->projection, viewport, &posXF, &posYF, &posZF);
+  gluUnProject (winX, winY, -1, this->modelview, this->projection, viewport, &posXN, &posYN, &posZN);
+  Vector3d far_pt (posXF, posYF, posZF);
+  Vector3d near_pt (posXN, posYN, posZN);
 
-  Vector3d testpt(0, 0, 0);
+  Vector3d testpt (0, 0, 0);
   std::vector<SelectedObject> result;
-  auto renderer = this->getRenderer();
-  if (renderer == nullptr)return result;
-  result = renderer->findModelObject(near_pt, far_pt, mouse_x, mouse_y, cam.zoomValue() / 300);
+  auto renderer = this->getRenderer ();
+  if (renderer == nullptr)
+    return result;
+  result = renderer->findModelObject (near_pt, far_pt, mouse_x, mouse_y, cam.zoomValue () / 300);
   return result;
 }
 
-void QGLView::selectPoint(int mouse_x, int mouse_y)
-{
-  std::vector<SelectedObject> obj = findObject(mouse_x, mouse_y);
-  if (obj.size() == 1) {
-    this->selected_obj.push_back(obj[0]);
-    update();
+void QGLView::selectPoint (int mouse_x, int mouse_y) {
+  std::vector<SelectedObject> obj = findObject (mouse_x, mouse_y);
+  if (obj.size () == 1) {
+    this->selected_obj.push_back (obj[0]);
+    update ();
   }
 }
 
-int QGLView::pickObject(QPoint position)
-{
-  if (!isValid()) return -1;
+int QGLView::pickObject (QPoint position) {
+  if (!isValid ())
+    return -1;
 
-  if (this->getRenderer()) {
-    this->makeCurrent();
-    auto guard = sg::make_scope_guard([this]() {
-      this->doneCurrent();
+  if (this->getRenderer ()) {
+    this->makeCurrent ();
+    auto guard = sg::make_scope_guard ([this] () {
+      this->doneCurrent ();
     });
 
     // Update the selector with the right image size
-    this->selector->reset(this);
+    this->selector->reset (this);
 
-    return this->selector->select(this->getRenderer(), position.x(), position.y());
+    return this->selector->select (this->getRenderer (), position.x (), position.y ());
   }
   return -1;
 }
diff --git a/src/gui/QGLView.h b/src/gui/QGLView.h
index df118f067..ab13548f9 100644
--- a/src/gui/QGLView.h
+++ b/src/gui/QGLView.h
@@ -21,58 +21,68 @@
 class QGLView : public QOpenGLWidget, public GLView
 {
   Q_OBJECT
-  Q_PROPERTY(bool showEdges READ showEdges WRITE setShowEdges);
-  Q_PROPERTY(bool showAxes READ showAxes WRITE setShowAxes);
-  Q_PROPERTY(bool showCrosshairs READ showCrosshairs WRITE setShowCrosshairs);
-  Q_PROPERTY(bool orthoMode READ orthoMode WRITE setOrthoMode);
-  Q_PROPERTY(double showScaleProportional READ showScaleProportional WRITE setShowScaleProportional);
+  Q_PROPERTY (bool showEdges READ showEdges WRITE setShowEdges);
+  Q_PROPERTY (bool showAxes READ showAxes WRITE setShowAxes);
+  Q_PROPERTY (bool showCrosshairs READ showCrosshairs WRITE setShowCrosshairs);
+  Q_PROPERTY (bool orthoMode READ orthoMode WRITE setOrthoMode);
+  Q_PROPERTY (double showScaleProportional READ showScaleProportional WRITE setShowScaleProportional);
 
 public:
-  QGLView(QWidget *parent = nullptr);
-  ~QGLView() override;
+  QGLView (QWidget *parent = nullptr);
+  ~QGLView () override;
 #ifdef ENABLE_OPENCSG
-  bool hasOpenCSGSupport() { return this->is_opencsg_capable; }
+  bool hasOpenCSGSupport () {
+    return this->is_opencsg_capable;
+  }
 #endif
   // Properties
-  bool orthoMode() const { return (this->cam.projection == Camera::ProjectionType::ORTHOGONAL); }
-  void setOrthoMode(bool enabled);
-  bool showScaleProportional() const { return this->showscale; }
-  void setShowScaleProportional(bool enabled) { this->showscale = enabled; }
-  std::string getRendererInfo() const override;
-  float getDPI() override { return this->devicePixelRatio(); }
-
-  const QImage& grabFrame();
-  bool save(const char *filename) const override;
-  void resetView();
-  void viewAll();
-  void selectPoint(int x, int y);
-  std::vector<SelectedObject> findObject(int x, int y);
+  bool orthoMode () const {
+    return (this->cam.projection == Camera::ProjectionType::ORTHOGONAL);
+  }
+  void setOrthoMode (bool enabled);
+  bool showScaleProportional () const {
+    return this->showscale;
+  }
+  void setShowScaleProportional (bool enabled) {
+    this->showscale = enabled;
+  }
+  std::string getRendererInfo () const override;
+  float getDPI () override {
+    return this->devicePixelRatio ();
+  }
+
+  const QImage &grabFrame ();
+  bool save (const char *filename) const override;
+  void resetView ();
+  void viewAll ();
+  void selectPoint (int x, int y);
+  std::vector<SelectedObject> findObject (int x, int y);
   int measure_state;
 
-  int pickObject(QPoint position);
+  int pickObject (QPoint position);
 
 public slots:
-  void ZoomIn();
-  void ZoomOut();
-  void setMouseCentricZoom(bool var){
+  void ZoomIn ();
+  void ZoomOut ();
+  void setMouseCentricZoom (bool var) {
     this->mouseCentricZoom = var;
   }
-  void setMouseSwapButtons(bool var){
+  void setMouseSwapButtons (bool var) {
     this->mouseSwapButtons = var;
   }
 
 public:
   QLabel *statusLabel;
 
-  void zoom(double v, bool relative);
-  void zoomFov(double v);
-  void zoomCursor(int x, int y, int zoom);
-  void rotate(double x, double y, double z, bool relative);
-  void rotate2(double x, double y, double z);
-  void translate(double x, double y, double z, bool relative, bool viewPortRelative = true);
+  void zoom (double v, bool relative);
+  void zoomFov (double v);
+  void zoomCursor (int x, int y, int zoom);
+  void rotate (double x, double y, double z, bool relative);
+  void rotate2 (double x, double y, double z);
+  void translate (double x, double y, double z, bool relative, bool viewPortRelative = true);
 
 private:
-  void init();
+  void init ();
 
   bool mouse_drag_active;
   bool mouse_drag_moved = true;
@@ -81,34 +91,34 @@ private:
   QPoint last_mouse;
   QImage frame; // Used by grabFrame() and save()
 
-  void wheelEvent(QWheelEvent *event) override;
-  void mousePressEvent(QMouseEvent *event) override;
-  void mouseMoveEvent(QMouseEvent *event) override;
-  void mouseReleaseEvent(QMouseEvent *event) override;
-  void mouseDoubleClickEvent(QMouseEvent *event) override;
+  void wheelEvent (QWheelEvent *event) override;
+  void mousePressEvent (QMouseEvent *event) override;
+  void mouseMoveEvent (QMouseEvent *event) override;
+  void mouseReleaseEvent (QMouseEvent *event) override;
+  void mouseDoubleClickEvent (QMouseEvent *event) override;
 
-  void initializeGL() override;
-  void resizeGL(int w, int h) override;
+  void initializeGL () override;
+  void resizeGL (int w, int h) override;
 
-  void paintGL() override;
-  void normalizeAngle(GLdouble& angle);
+  void paintGL () override;
+  void normalizeAngle (GLdouble &angle);
 
 #ifdef ENABLE_OPENCSG
-  void display_opencsg_warning() override;
+  void display_opencsg_warning () override;
   std::unique_ptr<MouseSelector> selector;
 private slots:
-  void display_opencsg_warning_dialog();
+  void display_opencsg_warning_dialog ();
 #endif
 
 signals:
-  void cameraChanged();
-  void resized();
-  void doRightClick(QPoint screen_coordinate);
-  void doLeftClick(QPoint screen_coordinate);
+  void cameraChanged ();
+  void resized ();
+  void doRightClick (QPoint screen_coordinate);
+  void doLeftClick (QPoint screen_coordinate);
 };
 
 /* These are defined in QLGView2.cc.  See the commentary there. */
 // Can't include <QOpenGLContext>, as it will clash with glew. Forward declare.
 class QOpenGLContext;
-QOpenGLContext *getGLContext();
-void setGLContext(QOpenGLContext *);
+QOpenGLContext *getGLContext ();
+void setGLContext (QOpenGLContext *);
diff --git a/src/gui/QGLView2.cc b/src/gui/QGLView2.cc
index d3ba9f488..5cdb6e56f 100644
--- a/src/gui/QGLView2.cc
+++ b/src/gui/QGLView2.cc
@@ -35,19 +35,16 @@
 #include <QOpenGLContext>
 
 QOpenGLContext *
-getGLContext()
-{
-  return (QOpenGLContext::currentContext());
+getGLContext () {
+  return (QOpenGLContext::currentContext ());
 }
 
-void
-setGLContext(QOpenGLContext *ctx)
-{
+void setGLContext (QOpenGLContext *ctx) {
   /*
    * This seems like the simplest way to select QOpenGLContext.
    *
    * Why isn't there a QOpenGLContext::makeCurrent() that uses the context's assigned
    * surface?
    */
-  ctx->makeCurrent(ctx->surface());
+  ctx->makeCurrent (ctx->surface ());
 }
diff --git a/src/gui/QSettingsCached.h b/src/gui/QSettingsCached.h
index f9f8b3cf0..773791095 100644
--- a/src/gui/QSettingsCached.h
+++ b/src/gui/QSettingsCached.h
@@ -11,44 +11,41 @@
 class QSettingsCached
 {
 public:
-
-  QSettingsCached() {
-    if (qsettingsPointer.get() == nullptr) {
+  QSettingsCached () {
+    if (qsettingsPointer.get () == nullptr) {
       std::lock_guard<std::mutex> lock{ctor_mutex};
-      if (qsettingsPointer.get() == nullptr) {
-        qsettingsPointer = std::make_unique<QSettings>();
+      if (qsettingsPointer.get () == nullptr) {
+        qsettingsPointer = std::make_unique<QSettings> ();
       }
     }
   }
 
-  inline void setValue(const QString& key, const QVariant& value) {
-    PRINTDB("QSettings::setValue(): %s = '%s'", key.toStdString() % value.toString().toStdString());
-    qsettingsPointer->setValue(key, value); // It is safe to access qsettings from Multiple sources. it is thread safe
+  inline void setValue (const QString &key, const QVariant &value) {
+    PRINTDB ("QSettings::setValue(): %s = '%s'", key.toStdString () % value.toString ().toStdString ());
+    qsettingsPointer->setValue (key, value); // It is safe to access qsettings from Multiple sources. it is thread safe
     // Disabling forced sync to persisted storage on write. Will rely on automatic behavior of QSettings
     // qsettingsPointer->sync(); // force write to file system on each modification of open scad settings
   }
 
-  inline QVariant value(const QString& key, const QVariant& defaultValue = QVariant()) const {
-    return qsettingsPointer->value(key, defaultValue);
+  inline QVariant value (const QString &key, const QVariant &defaultValue = QVariant ()) const {
+    return qsettingsPointer->value (key, defaultValue);
   }
 
-  inline void remove(const QString& key) {
-    qsettingsPointer->remove(key);
+  inline void remove (const QString &key) {
+    qsettingsPointer->remove (key);
     // Disabling forced sync to persisted storage on write. Will rely on automatic behavior of QSettings
     // qsettingsPointer->sync();
   }
 
-  inline bool contains(const QString& key) const {
-    return qsettingsPointer->contains(key);
+  inline bool contains (const QString &key) const {
+    return qsettingsPointer->contains (key);
   }
 
-  void release() {
-    delete qsettingsPointer.release();
+  void release () {
+    delete qsettingsPointer.release ();
   }
 
-
 private:
   static std::unique_ptr<QSettings> qsettingsPointer;
   static std::mutex ctor_mutex;
-
 };
diff --git a/src/gui/QWordSearchField.cc b/src/gui/QWordSearchField.cc
index a7439538c..da2d3c7ab 100644
--- a/src/gui/QWordSearchField.cc
+++ b/src/gui/QWordSearchField.cc
@@ -6,56 +6,51 @@
 #include <QString>
 #include <QStyle>
 
-QWordSearchField::QWordSearchField(QFrame *parent) : QLineEdit(parent)
-{
+QWordSearchField::QWordSearchField (QFrame *parent)
+  : QLineEdit (parent) {
   findcount = 0;
-  fieldLabel = new QLabel(this);
-  fieldLabel->setTextFormat(Qt::PlainText);
-  fieldLabel->setText(QString("00"));
-  fieldLabel->setCursor(Qt::ArrowCursor);
-  fieldLabel->setStyleSheet("QLabel { border: none; padding: 0px; }");
-  fieldLabel->hide();
-  connect(this, &QWordSearchField::findCountChanged, this, &QWordSearchField::updateFieldLabel);
-  auto frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);
-  setStyleSheet(QString("QLineEdit { padding-right: %1px; } ").arg(fieldLabel->sizeHint().width() + frameWidth + 1));
-  auto minsize = minimumSizeHint();
-  setMinimumSize(qMax(minsize.width(), fieldLabel->sizeHint().height() + frameWidth * 2 + 2),
-                 qMax(minsize.height(), fieldLabel->sizeHint().height() + frameWidth * 2 + 2));
-  fieldLabel->setAlignment(Qt::AlignRight);
+  fieldLabel = new QLabel (this);
+  fieldLabel->setTextFormat (Qt::PlainText);
+  fieldLabel->setText (QString ("00"));
+  fieldLabel->setCursor (Qt::ArrowCursor);
+  fieldLabel->setStyleSheet ("QLabel { border: none; padding: 0px; }");
+  fieldLabel->hide ();
+  connect (this, &QWordSearchField::findCountChanged, this, &QWordSearchField::updateFieldLabel);
+  auto frameWidth = style ()->pixelMetric (QStyle::PM_DefaultFrameWidth);
+  setStyleSheet (QString ("QLineEdit { padding-right: %1px; } ").arg (fieldLabel->sizeHint ().width () + frameWidth + 1));
+  auto minsize = minimumSizeHint ();
+  setMinimumSize (qMax (minsize.width (), fieldLabel->sizeHint ().height () + frameWidth * 2 + 2),
+                  qMax (minsize.height (), fieldLabel->sizeHint ().height () + frameWidth * 2 + 2));
+  fieldLabel->setAlignment (Qt::AlignRight);
 }
 
-void QWordSearchField::resizeEvent(QResizeEvent *)
-{
-  resizeSearchField();
+void QWordSearchField::resizeEvent (QResizeEvent *) {
+  resizeSearchField ();
 }
 
-void QWordSearchField::resizeSearchField()
-{
-  auto size = fieldLabel->sizeHint();
-  auto frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);
-  fieldLabel->move(rect().right() - frameWidth - size.width(), (rect().bottom() + 1 - size.height()) / 2);
+void QWordSearchField::resizeSearchField () {
+  auto size = fieldLabel->sizeHint ();
+  auto frameWidth = style ()->pixelMetric (QStyle::PM_DefaultFrameWidth);
+  fieldLabel->move (rect ().right () - frameWidth - size.width (), (rect ().bottom () + 1 - size.height ()) / 2);
 }
 
-
-void QWordSearchField::updateFieldLabel()
-{
+void QWordSearchField::updateFieldLabel () {
   if (findcount > 0) {
-    fieldLabel->setText(QString::number(findcount));
+    fieldLabel->setText (QString::number (findcount));
     //Fixes issue #2962 : Due to that fieldLabel->setText above does not seem to change the size of the field correct (seems to always be to short field to accommodate all digits)
     //when the field changes many times during several searches, we need to work around that by setting minimum size.
-    fieldLabel->setMinimumSize(fieldLabel->minimumSizeHint());
-    fieldLabel->setVisible(true);
+    fieldLabel->setMinimumSize (fieldLabel->minimumSizeHint ());
+    fieldLabel->setVisible (true);
   } else {
-    fieldLabel->setText(QString(""));
-    fieldLabel->setVisible(false);
+    fieldLabel->setText (QString (""));
+    fieldLabel->setVisible (false);
   }
-  resizeSearchField();
+  resizeSearchField ();
 }
 
-void QWordSearchField::setFindCount(int value)
-{
+void QWordSearchField::setFindCount (int value) {
   if (value != findcount) {
     findcount = value;
-    emit findCountChanged();
+    emit findCountChanged ();
   }
 }
diff --git a/src/gui/QWordSearchField.h b/src/gui/QWordSearchField.h
index ea4ba90f9..ffea4f1c8 100644
--- a/src/gui/QWordSearchField.h
+++ b/src/gui/QWordSearchField.h
@@ -11,21 +11,23 @@ class QWordSearchField : public QLineEdit
   Q_OBJECT
 
 public:
-  QWordSearchField(QFrame *parent = nullptr);
-  int findCount() const { return findcount; }
+  QWordSearchField (QFrame *parent = nullptr);
+  int findCount () const {
+    return findcount;
+  }
 
 protected:
-  void resizeEvent(QResizeEvent *) override;
-  void resizeSearchField();
+  void resizeEvent (QResizeEvent *) override;
+  void resizeSearchField ();
 
 private slots:
-  void updateFieldLabel();
+  void updateFieldLabel ();
 
 public slots:
-  void setFindCount(int value);
+  void setFindCount (int value);
 
 signals:
-  void findCountChanged();
+  void findCountChanged ();
 
 private:
   QLabel *fieldLabel;
@@ -33,4 +35,3 @@ private:
 };
 
 #endif /* QWORDSEARCHFIELD_H */
-
diff --git a/src/gui/RubberBandManager.cc b/src/gui/RubberBandManager.cc
index 2bcd4eba2..a01d2bf1c 100644
--- a/src/gui/RubberBandManager.cc
+++ b/src/gui/RubberBandManager.cc
@@ -3,29 +3,28 @@
 #include "MainWindow.h"
 #include "Dock.h"
 
-RubberBandManager::RubberBandManager(MainWindow *w) :
-  rubberBand(QRubberBand::Rectangle)
-{
-  setParent(w);
+RubberBandManager::RubberBandManager (MainWindow *w)
+  : rubberBand (QRubberBand::Rectangle) {
+  setParent (w);
   emphasizedDock = nullptr;
 }
 
-void RubberBandManager::hide(){
-  rubberBand.hide();
+void RubberBandManager::hide () {
+  rubberBand.hide ();
   emphasizedDock = nullptr;
 }
 
-bool RubberBandManager::isEmphasized(Dock *dock){
-  return rubberBand.isVisible() && emphasizedDock == dock;
+bool RubberBandManager::isEmphasized (Dock *dock) {
+  return rubberBand.isVisible () && emphasizedDock == dock;
 }
 
-bool RubberBandManager::isVisible(){
-  return rubberBand.isVisible();
+bool RubberBandManager::isVisible () {
+  return rubberBand.isVisible ();
 }
 
-void RubberBandManager::emphasize(Dock *dock){
-  rubberBand.setParent(dock);
-  rubberBand.setGeometry(dock->widget()->geometry());
-  rubberBand.show();
+void RubberBandManager::emphasize (Dock *dock) {
+  rubberBand.setParent (dock);
+  rubberBand.setGeometry (dock->widget ()->geometry ());
+  rubberBand.show ();
   emphasizedDock = dock;
 }
diff --git a/src/gui/RubberBandManager.h b/src/gui/RubberBandManager.h
index 21dec6f48..7ebd5e252 100644
--- a/src/gui/RubberBandManager.h
+++ b/src/gui/RubberBandManager.h
@@ -14,12 +14,12 @@ class RubberBandManager : QObject
   Q_OBJECT
 
 public:
-  RubberBandManager(MainWindow *w);
+  RubberBandManager (MainWindow *w);
 
-  void hide();
-  void emphasize(Dock *w);
-  bool isEmphasized(Dock *w);
-  bool isVisible();
+  void hide ();
+  void emphasize (Dock *w);
+  bool isEmphasized (Dock *w);
+  bool isVisible ();
 
 private:
   QRubberBand rubberBand;
diff --git a/src/gui/ScadApi.cc b/src/gui/ScadApi.cc
index a9d80644f..d5b772f00 100644
--- a/src/gui/ScadApi.cc
+++ b/src/gui/ScadApi.cc
@@ -14,134 +14,130 @@
 
 namespace {
 
-bool isInString(const std::u32string& text, const int col)
-{
+bool isInString (const std::u32string &text, const int col) {
   //first see if we are in a string literal. if so, don't allow auto complete
   bool lastWasEscape = false;
   bool inString = false;
   int dx = 0;
   int count = col;
   while (count-- > 0) {
-    const char32_t ch = text.at(dx++);
-    if (ch == '\\') lastWasEscape = true; //next character will be literal handle \"
-    else if (lastWasEscape) lastWasEscape = false;
+    const char32_t ch = text.at (dx++);
+    if (ch == '\\')
+      lastWasEscape = true; //next character will be literal handle \"
+    else if (lastWasEscape)
+      lastWasEscape = false;
     else if (ch == '"') //string toggle
       inString = !inString;
   }
   return inString;
 }
 
-bool isUseOrInclude(const QString& text, const int col)
-{
-  const QRegularExpression re("\\s*(use|include)\\s*<[^>]*$");
-  const QRegularExpressionMatch match = re.match(text.left(col));
-  return match.hasMatch();
+bool isUseOrInclude (const QString &text, const int col) {
+  const QRegularExpression re ("\\s*(use|include)\\s*<[^>]*$");
+  const QRegularExpressionMatch match = re.match (text.left (col));
+  return match.hasMatch ();
 }
 
 template <typename C>
-QStringList getSorted(const QFileInfoList& list, C cond) {
+QStringList getSorted (const QFileInfoList &list, C cond) {
   QStringList result;
-  for (const auto& info : list) {
-    if (cond(info)) {
-      result << info.fileName();
+  for (const auto &info : list) {
+    if (cond (info)) {
+      result << info.fileName ();
     }
   }
-  result.sort();
+  result.sort ();
   return result;
 }
 
 } // namespace
 
-ScadApi::ScadApi(ScintillaEditor *editor, QsciLexer *lexer) : QsciAbstractAPIs(lexer), editor(editor)
-{
-  for (const auto& iter : Builtins::keywordList) {
+ScadApi::ScadApi (ScintillaEditor *editor, QsciLexer *lexer)
+  : QsciAbstractAPIs (lexer)
+  , editor (editor) {
+  for (const auto &iter : Builtins::keywordList) {
     QStringList calltipList;
-    for (const auto& it : iter.second)
-      calltipList.append(QString::fromStdString(it));
+    for (const auto &it : iter.second)
+      calltipList.append (QString::fromStdString (it));
 
-    funcs.append(ApiFunc(QString::fromStdString(iter.first), calltipList));
+    funcs.append (ApiFunc (QString::fromStdString (iter.first), calltipList));
   }
 }
 
-void ScadApi::updateAutoCompletionList(const QStringList& context, QStringList& list)
-{
+void ScadApi::updateAutoCompletionList (const QStringList &context, QStringList &list) {
   int line, col;
-  editor->qsci->getCursorPosition(&line, &col);
-  const auto& text = editor->qsci->text(line);
+  editor->qsci->getCursorPosition (&line, &col);
+  const auto &text = editor->qsci->text (line);
 
-  if (isInString(text.toStdU32String(), col)) {
+  if (isInString (text.toStdU32String (), col)) {
     return;
-  } else if (isUseOrInclude(text, col)) {
-    autoCompleteFolder(context, text, col, list);
+  } else if (isUseOrInclude (text, col)) {
+    autoCompleteFolder (context, text, col, list);
   } else {
-    autoCompleteFunctions(context, list);
+    autoCompleteFunctions (context, list);
   }
 }
 
-void ScadApi::autoCompleteFolder(const QStringList& context, const QString& text, const int col, QStringList& list)
-{
-  const QRegularExpression re(R"(\s*(use|include)\s*<\s*)");
-  const auto useDir = QFileInfo{text.left(col).replace(re, "")}.dir().path();
+void ScadApi::autoCompleteFolder (const QStringList &context, const QString &text, const int col, QStringList &list) {
+  const QRegularExpression re (R"(\s*(use|include)\s*<\s*)");
+  const auto useDir = QFileInfo{text.left (col).replace (re, "")}.dir ().path ();
 
   QFileInfoList dirs;
-  dirs << QFileInfo(editor->filepath);
-  for (const auto& path : get_library_path()) {
-    dirs << QFileInfo(QString::fromStdString(path) + "/");
+  dirs << QFileInfo (editor->filepath);
+  for (const auto &path : get_library_path ()) {
+    dirs << QFileInfo (QString::fromStdString (path) + "/");
   }
 
-  for (const auto& info : dirs) {
-    const auto dir = QDir{info.dir().filePath(useDir)};
-    if (!dir.exists()) {
+  for (const auto &info : dirs) {
+    const auto dir = QDir{info.dir ().filePath (useDir)};
+    if (!dir.exists ()) {
       continue;
     }
 
     QFileInfoList result;
-    const auto& prefix = context.last();
-    const auto& infoList = dir.entryInfoList(QDir::Dirs | QDir::Files | QDir::Readable | QDir::NoDotAndDotDot);
-    for (const auto& info : infoList) {
-      if (info.fileName().startsWith(prefix) && (info.isDir() || info.suffix().toLower() == "scad")) {
+    const auto &prefix = context.last ();
+    const auto &infoList = dir.entryInfoList (QDir::Dirs | QDir::Files | QDir::Readable | QDir::NoDotAndDotDot);
+    for (const auto &info : infoList) {
+      if (info.fileName ().startsWith (prefix) && (info.isDir () || info.suffix ().toLower () == "scad")) {
         result << info;
       }
     }
 
-    list << getSorted(result, [](const QFileInfo& i){
-      return i.isDir();
+    list << getSorted (result, [] (const QFileInfo &i) {
+      return i.isDir ();
     });
-    list << getSorted(result, [](const QFileInfo& i){
-      return i.isFile();
+    list << getSorted (result, [] (const QFileInfo &i) {
+      return i.isFile ();
     });
-    list.removeDuplicates();
+    list.removeDuplicates ();
   }
 }
 
-void ScadApi::autoCompleteFunctions(const QStringList& context, QStringList& list)
-{
-  const QString& c = context.last();
+void ScadApi::autoCompleteFunctions (const QStringList &context, QStringList &list) {
+  const QString &c = context.last ();
   // for now we only auto-complete functions and modules
-  if (c.isEmpty()) {
+  if (c.isEmpty ()) {
     return;
   }
 
-  for (const auto& func : funcs) {
-    const QString& name = func.get_name();
-    if (name.startsWith(c)) {
-      if (!list.contains(name)) {
+  for (const auto &func : funcs) {
+    const QString &name = func.get_name ();
+    if (name.startsWith (c)) {
+      if (!list.contains (name)) {
         list << name;
       }
     }
   }
 }
 
-void ScadApi::autoCompletionSelected(const QString& /*selection*/)
-{
+void ScadApi::autoCompletionSelected (const QString & /*selection*/) {
 }
 
-QStringList ScadApi::callTips(const QStringList& context, int /*commas*/, QsciScintilla::CallTipsStyle /*style*/, QList<int>& /*shifts*/)
-{
+QStringList ScadApi::callTips (const QStringList &context, int /*commas*/, QsciScintilla::CallTipsStyle /*style*/, QList<int> & /*shifts*/) {
   QStringList callTips;
-  for (const auto& func : funcs) {
-    if (func.get_name() == context.at(context.size() - 2)) {
-      callTips = func.get_params();
+  for (const auto &func : funcs) {
+    if (func.get_name () == context.at (context.size () - 2)) {
+      callTips = func.get_params ();
       break;
     }
   }
diff --git a/src/gui/ScadApi.h b/src/gui/ScadApi.h
index 412a7b51a..1b8164d77 100644
--- a/src/gui/ScadApi.h
+++ b/src/gui/ScadApi.h
@@ -15,22 +15,25 @@ private:
   QStringList params;
 
 public:
-  ApiFunc(QString name, QString param) : name(std::move(name)), params{std::move(param)} { }
-  ApiFunc(QString name, QString param1, QString param2) : name(std::move(name)), params{std::move(param1), std::move(param2)} { }
-  ApiFunc(QString name, QStringList params) : name(std::move(name)), params(std::move(params)) { }
-
-  const QString& get_name() const
-  {
+  ApiFunc (QString name, QString param)
+    : name (std::move (name))
+    , params{std::move (param)} {}
+  ApiFunc (QString name, QString param1, QString param2)
+    : name (std::move (name))
+    , params{std::move (param1), std::move (param2)} {}
+  ApiFunc (QString name, QStringList params)
+    : name (std::move (name))
+    , params (std::move (params)) {}
+
+  const QString &get_name () const {
     return name;
   }
 
-  const QStringList& get_params() const
-  {
+  const QStringList &get_params () const {
     return params;
   }
 
-  ApiFunc& operator=(const ApiFunc& other)
-  {
+  ApiFunc &operator= (const ApiFunc &other) {
     if (this != &other) {
       this->name = other.name;
       this->params = other.params;
@@ -44,15 +47,22 @@ class ScadTemplate
 private:
   QString text;
   int cursor_offset;
-public:
 
-  ScadTemplate() : text(""), cursor_offset(0) { }
-  ScadTemplate(QString text, int cursor_offset) : text(std::move(text)), cursor_offset(cursor_offset) { }
-  const QString& get_text() const { return text; }
-  int get_cursor_offset() const { return cursor_offset; }
+public:
+  ScadTemplate ()
+    : text ("")
+    , cursor_offset (0) {}
+  ScadTemplate (QString text, int cursor_offset)
+    : text (std::move (text))
+    , cursor_offset (cursor_offset) {}
+  const QString &get_text () const {
+    return text;
+  }
+  int get_cursor_offset () const {
+    return cursor_offset;
+  }
 
-  ScadTemplate& operator=(const ScadTemplate& other)
-  {
+  ScadTemplate &operator= (const ScadTemplate &other) {
     if (this != &other) {
       this->text = other.text;
       this->cursor_offset = other.cursor_offset;
@@ -72,13 +82,13 @@ private:
   QList<ApiFunc> funcs;
 
 protected:
-  void autoCompleteFolder(const QStringList& context, const QString& text, const int col, QStringList& list);
-  void autoCompleteFunctions(const QStringList& context, QStringList& list);
+  void autoCompleteFolder (const QStringList &context, const QString &text, const int col, QStringList &list);
+  void autoCompleteFunctions (const QStringList &context, QStringList &list);
 
 public:
-  ScadApi(ScintillaEditor *editor, QsciLexer *lexer);
+  ScadApi (ScintillaEditor *editor, QsciLexer *lexer);
 
-  void updateAutoCompletionList(const QStringList& context, QStringList& list) override;
-  void autoCompletionSelected(const QString& selection) override;
-  QStringList callTips(const QStringList& context, int commas, QsciScintilla::CallTipsStyle style, QList<int>& shifts) override;
+  void updateAutoCompletionList (const QStringList &context, QStringList &list) override;
+  void autoCompletionSelected (const QString &selection) override;
+  QStringList callTips (const QStringList &context, int commas, QsciScintilla::CallTipsStyle style, QList<int> &shifts) override;
 };
diff --git a/src/gui/ScadLexer.cc b/src/gui/ScadLexer.cc
index f78caff91..a47ede69a 100644
--- a/src/gui/ScadLexer.cc
+++ b/src/gui/ScadLexer.cc
@@ -11,11 +11,10 @@
 #include <boost/algorithm/string.hpp>
 #include <boost/algorithm/string/split.hpp>
 
-
 #if !ENABLE_LEXERTL
 
-ScadLexer::ScadLexer(QObject *parent) : QsciLexerCPP(parent)
-{
+ScadLexer::ScadLexer (QObject *parent)
+  : QsciLexerCPP (parent) {
   // -> Style: Keyword (lexer.l)
   keywordSet[0] =
     "if else let for each module function true false undef "
@@ -42,40 +41,36 @@ ScadLexer::ScadLexer(QObject *parent) : QsciLexerCPP(parent)
     "projection render surface scale rotate mirror translate "
     "multmatrix color offset intersection_for roof fill";
 
-  setFoldComments(true);
-  setFoldAtElse(true);
+  setFoldComments (true);
+  setFoldAtElse (true);
 }
 
-const char *ScadLexer::language() const
-{
+const char *ScadLexer::language () const {
   return "SCAD";
 }
 
-void ScadLexer::setKeywords(int set, const std::string& keywords)
-{
+void ScadLexer::setKeywords (int set, const std::string &keywords) {
   if ((set < 1) || (set > 4)) {
     return;
   }
 
-  std::string trimmedKeywords(keywords);
-  boost::algorithm::trim(trimmedKeywords);
-  if (trimmedKeywords.empty()) {
+  std::string trimmedKeywords (keywords);
+  boost::algorithm::trim (trimmedKeywords);
+  if (trimmedKeywords.empty ()) {
     return;
   }
 
   keywordSet[set - 1] = trimmedKeywords;
 }
 
-const char *ScadLexer::keywords(int set) const
-{
+const char *ScadLexer::keywords (int set) const {
   if ((set < 1) || (set > 4)) {
     return nullptr;
   }
-  return keywordSet[set - 1].c_str();
+  return keywordSet[set - 1].c_str ();
 }
 
-QStringList ScadLexer::autoCompletionWordSeparators() const
-{
+QStringList ScadLexer::autoCompletionWordSeparators () const {
   QStringList wl;
   wl << "."; // dot notation, not used yet, but preparation for object support
   wl << "<"; // for include/use auto complete
@@ -107,184 +102,183 @@ QStringList ScadLexer::autoCompletionWordSeparators() const
 
 /// See original attempt at https://github.com/openscad/openscad/tree/lexertl/src
 
-void Lex::default_rules()
-{
-  rules_.push_state("PATH");
-  rules_.push_state("COMMENT");
+void Lex::default_rules () {
+  rules_.push_state ("PATH");
+  rules_.push_state ("COMMENT");
 
-  std::string keywords("module function echo import projection render "
-                       "return if else let for each assert");
-  defineRules(keywords, ekeyword);
+  std::string keywords (
+    "module function echo import projection render "
+    "return if else let for each assert");
+  defineRules (keywords, ekeyword);
 
   //include and use have a unique syntax
-  rules_.push("INITIAL", "use", ekeyword, "PATH");
-  rules_.push("INITIAL", "include", ekeyword, "PATH");
-  rules_.push("PATH", ".|\n", etext, "INITIAL"); //leave this state; "use" and "include" can also be used as variable names
-  rules_.push("PATH", "[ \t\r\n]*<[^>]*>", eQuotedString, "INITIAL");
-
-  std::string transformations("translate rotate scale linear_extrude "
-                              "rotate_extrude resize mirror multmatrix color "
-                              "offset hull minkowski children");
-  defineRules(transformations, etransformation);
-
-  std::string booleans("union difference intersection intersection_for");
-  defineRules(booleans, eboolean);
-
-  std::string functions("abs sign rands min max sin cos asin acos tan atan atan2 round "
-                        "ceil floor pow sqrt exp len log ln str chr ord concat lookup "
-                        "search version version_num norm cross parent_module dxf_dim "
-                        "dxf_cross is_undef is_list is_num is_bool is_string "
-                        "is_function is_object");
-  defineRules(functions, efunction);
-
-  std::string models("sphere cube cylinder polyhedron square polygon text circle surface roof");
-  defineRules(models, emodel);
+  rules_.push ("INITIAL", "use", ekeyword, "PATH");
+  rules_.push ("INITIAL", "include", ekeyword, "PATH");
+  rules_.push ("PATH", ".|\n", etext, "INITIAL"); //leave this state; "use" and "include" can also be used as variable names
+  rules_.push ("PATH", "[ \t\r\n]*<[^>]*>", eQuotedString, "INITIAL");
+
+  std::string transformations (
+    "translate rotate scale linear_extrude "
+    "rotate_extrude resize mirror multmatrix color "
+    "offset hull minkowski children");
+  defineRules (transformations, etransformation);
+
+  std::string booleans ("union difference intersection intersection_for");
+  defineRules (booleans, eboolean);
+
+  std::string functions (
+    "abs sign rands min max sin cos asin acos tan atan atan2 round "
+    "ceil floor pow sqrt exp len log ln str chr ord concat lookup "
+    "search version version_num norm cross parent_module dxf_dim "
+    "dxf_cross is_undef is_list is_num is_bool is_string "
+    "is_function is_object");
+  defineRules (functions, efunction);
+
+  std::string models ("sphere cube cylinder polyhedron square polygon text circle surface roof");
+  defineRules (models, emodel);
 
   // Operators and Modifier Characters
-  std::string operators(R"(\+ - \* \/ % \^ < <= >= == != >= > && \|\| ! = #)");
-  defineRules(operators, eoperator);
+  std::string operators (R"(\+ - \* \/ % \^ < <= >= == != >= > && \|\| ! = #)");
+  defineRules (operators, eoperator);
 
-  rules_.push(R"(["](([\\]["])|[^"])*["])", eQuotedString);
+  rules_.push (R"(["](([\\]["])|[^"])*["])", eQuotedString);
 
-  std::string values("true false undef PI");
-  defineRules(values, enumber);
-  rules_.push("([-+]?((([0-9]+[.]?|([0-9]*[.][0-9]+))([eE][-+]?[0-9]+)?)))", enumber);
+  std::string values ("true false undef PI");
+  defineRules (values, enumber);
+  rules_.push ("([-+]?((([0-9]+[.]?|([0-9]*[.][0-9]+))([eE][-+]?[0-9]+)?)))", enumber);
 
   // comments and variables come later, after any custom keywords are added
 }
 
-void Lex::defineRules(const std::string& keyword_list, int id)
-{
-  std::string trimmedKeywords(keyword_list);
-  boost::algorithm::trim(trimmedKeywords);
-  if (trimmedKeywords.empty()) return;
+void Lex::defineRules (const std::string &keyword_list, int id) {
+  std::string trimmedKeywords (keyword_list);
+  boost::algorithm::trim (trimmedKeywords);
+  if (trimmedKeywords.empty ())
+    return;
 
   std::vector<std::string> words;
-  boost::split(words, trimmedKeywords, boost::is_any_of(" "));
-  for (const auto& keyword : words) {
-    rules_.push(keyword, id);
+  boost::split (words, trimmedKeywords, boost::is_any_of (" "));
+  for (const auto &keyword : words) {
+    rules_.push (keyword, id);
   }
 }
 
 // default and custom rules must be set before this
-void Lex::finalize_rules()
-{
+void Lex::finalize_rules () {
   // These need to come after keywords, so they don't accidentally match.
   // Sadly, order of definition matters, as well as enum.
-  rules_.push("[a-zA-Z0-9_]+", evariable);
-  rules_.push("[$][a-zA-Z0-9_]+", especialVariable);
+  rules_.push ("[a-zA-Z0-9_]+", evariable);
+  rules_.push ("[$][a-zA-Z0-9_]+", especialVariable);
 
-  rules_.push("INITIAL", "\"/*\"",  ecomment, "COMMENT");
-  rules_.push("COMMENT", "[^*]+|.", ecomment,  "COMMENT");
-  rules_.push("COMMENT", "\"*/\"", ecomment, "INITIAL");
-  rules_.push("[/][/].*$", ecomment);
+  rules_.push ("INITIAL", "\"/*\"", ecomment, "COMMENT");
+  rules_.push ("COMMENT", "[^*]+|.", ecomment, "COMMENT");
+  rules_.push ("COMMENT", "\"*/\"", ecomment, "INITIAL");
+  rules_.push ("[/][/].*$", ecomment);
 
-  rules_.push(".|\n", etext);
+  rules_.push (".|\n", etext);
 
   // build our lexer
-  lexertl::generator::build(rules_, sm);
+  lexertl::generator::build (rules_, sm);
 
 #if DEBUG_LEXERTL
-  std::ofstream fout("file1.txt", std::fstream::trunc);
-  lexertl::debug::dump(sm, fout);
+  std::ofstream fout ("file1.txt", std::fstream::trunc);
+  lexertl::debug::dump (sm, fout);
 #endif
 }
 
-void Lex::lex_results(const std::string& input, int start, LexInterface *const obj)
-{
+void Lex::lex_results (const std::string &input, int start, LexInterface *const obj) {
 #if DEBUG_LEXERTL
   std::cout << "called lexer" << std::endl;
 #endif
-  lexertl::smatch results(input.begin(), input.end());
+  lexertl::smatch results (input.begin (), input.end ());
 
   //The editor can ask to only lex from a starting point.
   //This can be faster the lexing the whole text,
   //but requires the lexer to try to restore the lexer state.
   //We currently handle comments (COMMENT State) pretty well.
   //We currently do not handle include/use (PATH State).
-  int isstyle = obj->getStyleAt(start - 1);
-  if (isstyle == ecomment) results.state = rules_.state("COMMENT");
+  int isstyle = obj->getStyleAt (start - 1);
+  if (isstyle == ecomment)
+    results.state = rules_.state ("COMMENT");
 
-  char *styles = new char[input.size()];
-  lexertl::lookup(sm, results);
+  char *styles = new char[input.size ()];
+  lexertl::lookup (sm, results);
   while (results.id != eEOF) {
-    size_t s = std::distance(input.begin(), results.first);
-    size_t len = std::distance(results.first, results.second);
-    memset(styles + s, results.id, len);
-    lexertl::lookup(sm, results);
+    size_t s = std::distance (input.begin (), results.first);
+    size_t len = std::distance (results.first, results.second);
+    memset (styles + s, results.id, len);
+    lexertl::lookup (sm, results);
   }
-  obj->highlightingMultiple(start, input.size(), styles);
-  delete [] styles;
+  obj->highlightingMultiple (start, input.size (), styles);
+  delete[] styles;
 }
 
 /***************************************************************/
 
-ScadLexer2::ScadLexer2(QObject *parent) : QsciLexerCustom(parent), LexInterface()
-{
-  my_lexer = new Lex();
-  my_lexer->default_rules();
+ScadLexer2::ScadLexer2 (QObject *parent)
+  : QsciLexerCustom (parent)
+  , LexInterface () {
+  my_lexer = new Lex ();
+  my_lexer->default_rules ();
 }
 
-ScadLexer2::~ScadLexer2()
-{
+ScadLexer2::~ScadLexer2 () {
   delete my_lexer;
 }
 
-void ScadLexer2::styleText(int start, int end)
-{
+void ScadLexer2::styleText (int start, int end) {
 #if DEBUG_LEXERTL
   std::cout << "start: " << start << std::endl;
 #endif
-  if (!editor()) return;
+  if (!editor ())
+    return;
 
   char *data = new char[end - start + 1];
-  editor()->SendScintilla(QsciScintilla::SCI_GETTEXTRANGE, start, end, data);
-  QString source(data);
-  const std::string input(source.toStdString());
+  editor ()->SendScintilla (QsciScintilla::SCI_GETTEXTRANGE, start, end, data);
+  QString source (data);
+  const std::string input (source.toStdString ());
 
 #if DEBUG_LEXERTL
-  auto pos = editor()->SendScintilla(QsciScintilla::SCI_GETCURRENTPOS);
+  auto pos = editor ()->SendScintilla (QsciScintilla::SCI_GETCURRENTPOS);
   std::cout << "its being called" << std::endl;
 #endif
 
-  my_lexer->lex_results(input, start, this);
-  this->fold(start, end);
+  my_lexer->lex_results (input, start, this);
+  this->fold (start, end);
 
-  delete [] data;
-  if (source.isEmpty()) return;
+  delete[] data;
+  if (source.isEmpty ())
+    return;
 }
 
-void ScadLexer2::autoScroll(int error_pos)
-{
-  editor()->SendScintilla(QsciScintilla::SCI_GOTOPOS, error_pos);
-  editor()->SendScintilla(QsciScintilla::SCI_SCROLLCARET);
+void ScadLexer2::autoScroll (int error_pos) {
+  editor ()->SendScintilla (QsciScintilla::SCI_GOTOPOS, error_pos);
+  editor ()->SendScintilla (QsciScintilla::SCI_SCROLLCARET);
 }
 
-void ScadLexer2::fold(int start, int end)
-{
-  char chNext = editor()->SendScintilla(QsciScintilla::SCI_GETCHARAT, start);
-  int lineCurrent = editor()->SendScintilla(QsciScintilla::SCI_LINEFROMPOSITION, start);
-  int levelPrev = editor()->SendScintilla(QsciScintilla::SCI_GETFOLDLEVEL, lineCurrent) & QsciScintilla::SC_FOLDLEVELNUMBERMASK;
+void ScadLexer2::fold (int start, int end) {
+  char chNext = editor ()->SendScintilla (QsciScintilla::SCI_GETCHARAT, start);
+  int lineCurrent = editor ()->SendScintilla (QsciScintilla::SCI_LINEFROMPOSITION, start);
+  int levelPrev = editor ()->SendScintilla (QsciScintilla::SCI_GETFOLDLEVEL, lineCurrent) & QsciScintilla::SC_FOLDLEVELNUMBERMASK;
   int levelCurrent = levelPrev;
   for (int i = start; i < end; i++) {
     char ch = chNext;
-    chNext = editor()->SendScintilla(QsciScintilla::SCI_GETCHARAT, i + 1);
+    chNext = editor ()->SendScintilla (QsciScintilla::SCI_GETCHARAT, i + 1);
 
     bool atEOL = ((ch == '\r' && chNext != '\n') || (ch == '\n'));
 
-    int prevStyle = editor()->SendScintilla(QsciScintilla::SCI_GETSTYLEAT, i - 1);
-    int currStyle = editor()->SendScintilla(QsciScintilla::SCI_GETSTYLEAT, i);
+    int prevStyle = editor ()->SendScintilla (QsciScintilla::SCI_GETSTYLEAT, i - 1);
+    int currStyle = editor ()->SendScintilla (QsciScintilla::SCI_GETSTYLEAT, i);
 
     bool currStyleIsOtherText = (currStyle == OtherText);
     if (currStyleIsOtherText) {
-      if ((ch == '{') || (ch == '[') ) {
+      if ((ch == '{') || (ch == '[')) {
         levelCurrent++;
-      } else if ((ch == '}') || (ch == ']') ) {
+      } else if ((ch == '}') || (ch == ']')) {
         levelCurrent--;
       }
     }
 
-
     bool prevStyleIsComment = (prevStyle == Comment);
     bool currStyleIsComment = (currStyle == Comment);
     bool isStartOfComment = (!prevStyleIsComment) && (currStyleIsComment);
@@ -304,8 +298,8 @@ void ScadLexer2::fold(int start, int end)
         lev |= QsciScintilla::SC_FOLDLEVELHEADERFLAG;
       }
 
-      if (lev != editor()->SendScintilla(QsciScintilla::SCI_GETFOLDLEVEL, lineCurrent)) {
-        editor()->SendScintilla(QsciScintilla::SCI_SETFOLDLEVEL, lineCurrent, lev);
+      if (lev != editor ()->SendScintilla (QsciScintilla::SCI_GETFOLDLEVEL, lineCurrent)) {
+        editor ()->SendScintilla (QsciScintilla::SCI_SETFOLDLEVEL, lineCurrent, lev);
       }
 
       lineCurrent++;
@@ -313,24 +307,21 @@ void ScadLexer2::fold(int start, int end)
     }
   }
 
-  int flagsNext = editor()->SendScintilla(QsciScintilla::SCI_GETFOLDLEVEL, lineCurrent) & QsciScintilla::SC_FOLDLEVELNUMBERMASK;
-  editor()->SendScintilla(QsciScintilla::SCI_SETFOLDLEVEL, lineCurrent, levelPrev | flagsNext);
+  int flagsNext = editor ()->SendScintilla (QsciScintilla::SCI_GETFOLDLEVEL, lineCurrent) & QsciScintilla::SC_FOLDLEVELNUMBERMASK;
+  editor ()->SendScintilla (QsciScintilla::SCI_SETFOLDLEVEL, lineCurrent, levelPrev | flagsNext);
 }
 
-
-int ScadLexer2::getStyleAt(int pos)
-{
-  int sstyle = editor()->SendScintilla(QsciScintilla::SCI_GETSTYLEAT, pos);
+int ScadLexer2::getStyleAt (int pos) {
+  int sstyle = editor ()->SendScintilla (QsciScintilla::SCI_GETSTYLEAT, pos);
   return sstyle;
 }
 
-void ScadLexer2::highlightingMultiple(int start, int length, char *styles) {
-  editor()->SendScintilla(QsciScintilla::SCI_STARTSTYLING, start);
-  editor()->SendScintilla(QsciScintilla::SCI_SETSTYLINGEX, length, styles);
+void ScadLexer2::highlightingMultiple (int start, int length, char *styles) {
+  editor ()->SendScintilla (QsciScintilla::SCI_STARTSTYLING, start);
+  editor ()->SendScintilla (QsciScintilla::SCI_SETSTYLINGEX, length, styles);
 }
 
-QColor ScadLexer2::defaultColor(int style) const
-{
+QColor ScadLexer2::defaultColor (int style) const {
   switch (style) {
   case Keyword:
     return Qt::blue;
@@ -352,8 +343,7 @@ QColor ScadLexer2::defaultColor(int style) const
   return Qt::black;
 }
 
-QString ScadLexer2::description(int style) const
-{
+QString ScadLexer2::description (int style) const {
   switch (style) {
   case Default:
     return "Default";
@@ -400,16 +390,14 @@ QString ScadLexer2::description(int style) const
   case Comment:
     return "Comment";
   }
-  return {QString::number(style)};
+  return {QString::number (style)};
 }
 
-const char *ScadLexer2::language() const
-{
+const char *ScadLexer2::language () const {
   return "SCAD";
 }
 
-QStringList ScadLexer2::autoCompletionWordSeparators() const
-{
+QStringList ScadLexer2::autoCompletionWordSeparators () const {
   QStringList wl;
   wl << "."; // dot notation, not used yet, but preparation for object support
   wl << "<"; // for include/use auto complete
diff --git a/src/gui/ScadLexer.h b/src/gui/ScadLexer.h
index f39504740..f7b67b0a1 100644
--- a/src/gui/ScadLexer.h
+++ b/src/gui/ScadLexer.h
@@ -5,7 +5,7 @@
 #include <Qsci/qsciglobal.h>
 #include <string>
 
-#define ENABLE_LEXERTL  1
+#define ENABLE_LEXERTL 1
 
 /***************************************************************/
 
@@ -16,18 +16,18 @@
 class ScadLexer : public QsciLexerCPP
 {
 public:
-  ScadLexer(QObject *parent);
-  virtual ~ScadLexer() = default;
-  const char *language() const override;
-  const char *keywords(int set) const override;
+  ScadLexer (QObject *parent);
+  virtual ~ScadLexer () = default;
+  const char *language () const override;
+  const char *keywords (int set) const override;
 
-  void setKeywords(int set, const std::string& keywords);
+  void setKeywords (int set, const std::string &keywords);
 
 private:
   std::string keywordSet[4];
-  ScadLexer(const ScadLexer&);
-  ScadLexer& operator=(const ScadLexer&);
-  QStringList autoCompletionWordSeparators() const override;
+  ScadLexer (const ScadLexer &);
+  ScadLexer &operator= (const ScadLexer &);
+  QStringList autoCompletionWordSeparators () const override;
 };
 
 #endif // if !ENABLE_LEXERTL
@@ -50,8 +50,8 @@ private:
 class LexInterface
 {
 public:
-  virtual void highlightingMultiple(int start, int length, char *styles) = 0;
-  virtual int getStyleAt(int position) = 0;
+  virtual void highlightingMultiple (int start, int length, char *styles) = 0;
+  virtual int getStyleAt (int position) = 0;
 };
 
 class Lex
@@ -60,17 +60,37 @@ public:
   lexertl::state_machine sm;
   lexertl::rules rules_;
 
-  enum { eEOF, ekeyword, etransformation, eboolean, efunction, emodel, eoperator, eQuotedString, enumber,
-         ecustom1, ecustom2, ecustom3, ecustom4, ecustom5, ecustom6, ecustom7, ecustom8, ecustom9, ecustom10,
-         evariable, especialVariable, ecomment, etext };
-
-  Lex() = default;
-
-  void default_rules();
-  void defineRules(const std::string& keyword_list, int id);
-  void finalize_rules();
-
-  void lex_results(const std::string& input, int start, LexInterface *const obj);
+  enum { eEOF,
+         ekeyword,
+         etransformation,
+         eboolean,
+         efunction,
+         emodel,
+         eoperator,
+         eQuotedString,
+         enumber,
+         ecustom1,
+         ecustom2,
+         ecustom3,
+         ecustom4,
+         ecustom5,
+         ecustom6,
+         ecustom7,
+         ecustom8,
+         ecustom9,
+         ecustom10,
+         evariable,
+         especialVariable,
+         ecomment,
+         etext };
+
+  Lex () = default;
+
+  void default_rules ();
+  void defineRules (const std::string &keyword_list, int id);
+  void finalize_rules ();
+
+  void lex_results (const std::string &input, int start, LexInterface *const obj);
 };
 
 class ScadLexer2 : public QsciLexerCustom, public LexInterface
@@ -104,31 +124,30 @@ public:
 
   Lex *my_lexer;
 
-  ScadLexer2(QObject *parent);
-  ScadLexer2(const ScadLexer2&) = delete;
-  ScadLexer2& operator=(const ScadLexer2&) = delete;
-  ~ScadLexer2() override;
+  ScadLexer2 (QObject *parent);
+  ScadLexer2 (const ScadLexer2 &) = delete;
+  ScadLexer2 &operator= (const ScadLexer2 &) = delete;
+  ~ScadLexer2 () override;
 
-  const char *language() const override;
+  const char *language () const override;
 
-  void styleText(int start, int end) override;
-  void autoScroll(int error_pos);
-  int getStyleAt(int pos) override;
-  void fold(int start, int end);
+  void styleText (int start, int end) override;
+  void autoScroll (int error_pos);
+  int getStyleAt (int pos) override;
+  void fold (int start, int end);
 
-  QColor defaultColor(int style) const override;
+  QColor defaultColor (int style) const override;
 
-  void highlightingMultiple(int start, int length, char *styles) override;
-  QString description(int style) const override;
-  QStringList autoCompletionWordSeparators() const override;
+  void highlightingMultiple (int start, int length, char *styles) override;
+  QString description (int style) const override;
+  QStringList autoCompletionWordSeparators () const override;
 
-  void addKeywords(const std::string& keywords, int id) {
-    my_lexer->defineRules(keywords, id);
+  void addKeywords (const std::string &keywords, int id) {
+    my_lexer->defineRules (keywords, id);
   }
-  void finalizeLexer() {
-    my_lexer->finalize_rules();
+  void finalizeLexer () {
+    my_lexer->finalize_rules ();
   }
-
 };
 
 #endif // if ENABLE_LEXERTL
diff --git a/src/gui/ScintillaEditor.cc b/src/gui/ScintillaEditor.cc
index 83616c816..787ba26e9 100644
--- a/src/gui/ScintillaEditor.cc
+++ b/src/gui/ScintillaEditor.cc
@@ -41,18 +41,16 @@ const QString ScintillaEditor::cursorPlaceHolder = "^~^";
 // In setCursorPosition, how many lines should be visible above and below the cursor
 const int setCursorPositionVisibleLines = 3;
 
-
 class SettingsConverter
 {
 public:
-  QsciScintilla::WrapMode toWrapMode(const std::string& val);
-  QsciScintilla::WrapVisualFlag toLineWrapVisualization(const std::string& val);
-  QsciScintilla::WrapIndentMode toLineWrapIndentationStyle(const std::string& val);
-  QsciScintilla::WhitespaceVisibility toShowWhitespaces(const std::string& val);
+  QsciScintilla::WrapMode toWrapMode (const std::string &val);
+  QsciScintilla::WrapVisualFlag toLineWrapVisualization (const std::string &val);
+  QsciScintilla::WrapIndentMode toLineWrapIndentationStyle (const std::string &val);
+  QsciScintilla::WhitespaceVisibility toShowWhitespaces (const std::string &val);
 };
 
-QsciScintilla::WrapMode SettingsConverter::toWrapMode(const std::string& val)
-{
+QsciScintilla::WrapMode SettingsConverter::toWrapMode (const std::string &val) {
   if (val == "Char") {
     return QsciScintilla::WrapCharacter;
   } else if (val == "Word") {
@@ -62,8 +60,7 @@ QsciScintilla::WrapMode SettingsConverter::toWrapMode(const std::string& val)
   }
 }
 
-QsciScintilla::WrapVisualFlag SettingsConverter::toLineWrapVisualization(const std::string& val)
-{
+QsciScintilla::WrapVisualFlag SettingsConverter::toLineWrapVisualization (const std::string &val) {
   if (val == "Text") {
     return QsciScintilla::WrapFlagByText;
   } else if (val == "Border") {
@@ -77,8 +74,7 @@ QsciScintilla::WrapVisualFlag SettingsConverter::toLineWrapVisualization(const s
   }
 }
 
-QsciScintilla::WrapIndentMode SettingsConverter::toLineWrapIndentationStyle(const std::string& val)
-{
+QsciScintilla::WrapIndentMode SettingsConverter::toLineWrapIndentationStyle (const std::string &val) {
   if (val == "Same") {
     return QsciScintilla::WrapIndentSame;
   } else if (val == "Indented") {
@@ -88,8 +84,7 @@ QsciScintilla::WrapIndentMode SettingsConverter::toLineWrapIndentationStyle(cons
   }
 }
 
-QsciScintilla::WhitespaceVisibility SettingsConverter::toShowWhitespaces(const std::string& val)
-{
+QsciScintilla::WhitespaceVisibility SettingsConverter::toShowWhitespaces (const std::string &val) {
   if (val == "Always") {
     return QsciScintilla::WsVisible;
   } else if (val == "AfterIndentation") {
@@ -99,52 +94,48 @@ QsciScintilla::WhitespaceVisibility SettingsConverter::toShowWhitespaces(const s
   }
 }
 
-EditorColorScheme::EditorColorScheme(const fs::path& path) : path(path)
-{
+EditorColorScheme::EditorColorScheme (const fs::path &path)
+  : path (path) {
   try {
-    boost::property_tree::read_json(path.generic_string(), pt);
-    _name = QString::fromStdString(pt.get<std::string>("name"));
-    _index = pt.get<int>("index");
-  } catch (const std::exception& e) {
-    LOG("Error reading color scheme file '%1$s': %2$s", path.generic_string(), e.what());
+    boost::property_tree::read_json (path.generic_string (), pt);
+    _name = QString::fromStdString (pt.get<std::string> ("name"));
+    _index = pt.get<int> ("index");
+  } catch (const std::exception &e) {
+    LOG ("Error reading color scheme file '%1$s': %2$s", path.generic_string (), e.what ());
     _name = "";
     _index = 0;
   }
 }
 
-bool EditorColorScheme::valid() const
-{
-  return !_name.isEmpty();
+bool EditorColorScheme::valid () const {
+  return !_name.isEmpty ();
 }
 
-const QString& EditorColorScheme::name() const
-{
+const QString &EditorColorScheme::name () const {
   return _name;
 }
 
-int EditorColorScheme::index() const
-{
+int EditorColorScheme::index () const {
   return _index;
 }
 
-const boost::property_tree::ptree& EditorColorScheme::propertyTree() const
-{
+const boost::property_tree::ptree &EditorColorScheme::propertyTree () const {
   return pt;
 }
 
-ScintillaEditor::ScintillaEditor(QWidget *parent) : EditorInterface(parent)
-{
+ScintillaEditor::ScintillaEditor (QWidget *parent)
+  : EditorInterface (parent) {
   api = nullptr;
   lexer = nullptr;
-  scintillaLayout = new QVBoxLayout(this);
-  qsci = new QsciScintilla(this);
+  scintillaLayout = new QVBoxLayout (this);
+  qsci = new QsciScintilla (this);
 
   contentsRendered = false;
   findState = 0; //FIND_HIDDEN
   filepath = "";
 
   // Force EOL mode to Unix, since QTextStream will manage local EOL modes.
-  qsci->setEolMode(QsciScintilla::EolUnix);
+  qsci->setEolMode (QsciScintilla::EolUnix);
 
   //
   // Remapping some scintilla key binding which conflict with OpenSCAD global
@@ -154,19 +145,19 @@ ScintillaEditor::ScintillaEditor(QWidget *parent) : EditorInterface(parent)
   // NOLINTBEGIN(bugprone-suspicious-enum-usage)
 #ifdef Q_OS_MACOS
   // Alt-Backspace should delete left word (Alt-Delete already deletes right word)
-  c = qsci->standardCommands()->find(QsciCommand::DeleteWordLeft);
-  c->setKey(Qt::Key_Backspace | Qt::ALT);
+  c = qsci->standardCommands ()->find (QsciCommand::DeleteWordLeft);
+  c->setKey (Qt::Key_Backspace | Qt::ALT);
 #endif
   // Cmd/Ctrl-T is handled by the menu
-  c = qsci->standardCommands()->boundTo(Qt::Key_T | Qt::CTRL);
-  c->setKey(0);
+  c = qsci->standardCommands ()->boundTo (Qt::Key_T | Qt::CTRL);
+  c->setKey (0);
   // Cmd/Ctrl-D is handled by the menu
-  c = qsci->standardCommands()->boundTo(Qt::Key_D | Qt::CTRL);
-  c->setKey(0);
+  c = qsci->standardCommands ()->boundTo (Qt::Key_D | Qt::CTRL);
+  c->setKey (0);
   // Ctrl-Shift-Z should redo on all platforms
-  c = qsci->standardCommands()->find(QsciCommand::Redo);
-  c->setKey(Qt::Key_Z | Qt::CTRL | Qt::SHIFT);
-  c->setAlternateKey(Qt::Key_Y | Qt::CTRL);
+  c = qsci->standardCommands ()->find (QsciCommand::Redo);
+  c->setKey (Qt::Key_Z | Qt::CTRL | Qt::SHIFT);
+  c->setAlternateKey (Qt::Key_Y | Qt::CTRL);
 
 #ifdef Q_OS_MACOS
   const unsigned long modifier = Qt::META;
@@ -175,880 +166,833 @@ ScintillaEditor::ScintillaEditor(QWidget *parent) : EditorInterface(parent)
 #endif
 
   QShortcut *shortcutCalltip;
-  shortcutCalltip = new QShortcut(modifier | Qt::SHIFT | Qt::Key_Space, this);
-  connect(shortcutCalltip, &QShortcut::activated, [ = ]() {
-    qsci->callTip();
+  shortcutCalltip = new QShortcut (modifier | Qt::SHIFT | Qt::Key_Space, this);
+  connect (shortcutCalltip, &QShortcut::activated, [=] () {
+    qsci->callTip ();
   });
 
   QShortcut *shortcutAutocomplete;
-  shortcutAutocomplete = new QShortcut(modifier | Qt::Key_Space, this);
-  connect(shortcutAutocomplete, &QShortcut::activated, [ = ]() {
-    qsci->autoCompleteFromAPIs();
+  shortcutAutocomplete = new QShortcut (modifier | Qt::Key_Space, this);
+  connect (shortcutAutocomplete, &QShortcut::activated, [=] () {
+    qsci->autoCompleteFromAPIs ();
   });
   // NOLINTEND(bugprone-suspicious-enum-usage)
 
-  scintillaLayout->setContentsMargins(0, 0, 0, 0);
-  scintillaLayout->addWidget(qsci);
-
-  qsci->setUtf8(true);
-  qsci->setFolding(QsciScintilla::BoxedTreeFoldStyle, 4);
-  qsci->setCaretLineVisible(true);
+  scintillaLayout->setContentsMargins (0, 0, 0, 0);
+  scintillaLayout->addWidget (qsci);
 
-  qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator, errorIndicatorNumber);
-  qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator, findIndicatorNumber);
-  qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator, selectionIndicatorIsActiveNumber);
-  qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator, selectionIndicatorIsActiveNumber + 1);
-  qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator, selectionIndicatorIsImpactedNumber);
-  qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator, selectionIndicatorIsImpactedNumber + 1);
-  qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator, selectionIndicatorIsImpactedNumber + 2);
+  qsci->setUtf8 (true);
+  qsci->setFolding (QsciScintilla::BoxedTreeFoldStyle, 4);
+  qsci->setCaretLineVisible (true);
 
-  qsci->markerDefine(QsciScintilla::Circle, errMarkerNumber);
-  qsci->markerDefine(QsciScintilla::Bookmark, bmMarkerNumber);
+  qsci->indicatorDefine (QsciScintilla::RoundBoxIndicator, errorIndicatorNumber);
+  qsci->indicatorDefine (QsciScintilla::RoundBoxIndicator, findIndicatorNumber);
+  qsci->indicatorDefine (QsciScintilla::RoundBoxIndicator, selectionIndicatorIsActiveNumber);
+  qsci->indicatorDefine (QsciScintilla::RoundBoxIndicator, selectionIndicatorIsActiveNumber + 1);
+  qsci->indicatorDefine (QsciScintilla::RoundBoxIndicator, selectionIndicatorIsImpactedNumber);
+  qsci->indicatorDefine (QsciScintilla::RoundBoxIndicator, selectionIndicatorIsImpactedNumber + 1);
+  qsci->indicatorDefine (QsciScintilla::RoundBoxIndicator, selectionIndicatorIsImpactedNumber + 2);
 
-  qsci->markerDefine('1', selectionMarkerLevelNumber);
-  qsci->markerDefine('2', selectionMarkerLevelNumber + 1);
-  qsci->markerDefine('3', selectionMarkerLevelNumber + 2);
-  qsci->markerDefine('4', selectionMarkerLevelNumber + 3);
-  qsci->markerDefine('5', selectionMarkerLevelNumber + 4);
-  qsci->markerDefine('+', selectionMarkerLevelNumber + 5);
+  qsci->markerDefine (QsciScintilla::Circle, errMarkerNumber);
+  qsci->markerDefine (QsciScintilla::Bookmark, bmMarkerNumber);
 
+  qsci->markerDefine ('1', selectionMarkerLevelNumber);
+  qsci->markerDefine ('2', selectionMarkerLevelNumber + 1);
+  qsci->markerDefine ('3', selectionMarkerLevelNumber + 2);
+  qsci->markerDefine ('4', selectionMarkerLevelNumber + 3);
+  qsci->markerDefine ('5', selectionMarkerLevelNumber + 4);
+  qsci->markerDefine ('+', selectionMarkerLevelNumber + 5);
 
-  qsci->setMarginType(numberMargin, QsciScintilla::NumberMargin);
-  qsci->setMarginLineNumbers(numberMargin, true);
-  qsci->setMarginMarkerMask(numberMargin, 0);
+  qsci->setMarginType (numberMargin, QsciScintilla::NumberMargin);
+  qsci->setMarginLineNumbers (numberMargin, true);
+  qsci->setMarginMarkerMask (numberMargin, 0);
 
-  qsci->setMarginType(symbolMargin, QsciScintilla::SymbolMargin);
-  qsci->setMarginLineNumbers(symbolMargin, false);
-  qsci->setMarginWidth(symbolMargin, 0);
-  qsci->setMarginMarkerMask(symbolMargin, 1 << errMarkerNumber | 1 << bmMarkerNumber | 1 << selectionMarkerLevelNumber | 1 << (selectionMarkerLevelNumber + 1) | 1 << (selectionMarkerLevelNumber + 2) | 1 << (selectionMarkerLevelNumber + 3) | 1 << (selectionMarkerLevelNumber + 4) | 1 << (selectionMarkerLevelNumber + 5));
+  qsci->setMarginType (symbolMargin, QsciScintilla::SymbolMargin);
+  qsci->setMarginLineNumbers (symbolMargin, false);
+  qsci->setMarginWidth (symbolMargin, 0);
+  qsci->setMarginMarkerMask (symbolMargin, 1 << errMarkerNumber | 1 << bmMarkerNumber | 1 << selectionMarkerLevelNumber | 1 << (selectionMarkerLevelNumber + 1) | 1 << (selectionMarkerLevelNumber + 2) | 1 << (selectionMarkerLevelNumber + 3) | 1 << (selectionMarkerLevelNumber + 4) | 1 << (selectionMarkerLevelNumber + 5));
 
 #if ENABLE_LEXERTL
-  auto newLexer = new ScadLexer2(this);
-  newLexer->finalizeLexer();
-  setLexer(newLexer);
+  auto newLexer = new ScadLexer2 (this);
+  newLexer->finalizeLexer ();
+  setLexer (newLexer);
 #else
-  setLexer(new ScadLexer(this));
+  setLexer (new ScadLexer (this));
 #endif
 
-  initMargin();
+  initMargin ();
 
-  connect(qsci, &QsciScintilla::textChanged, this, &ScintillaEditor::contentsChanged);
-  connect(qsci, &QsciScintilla::modificationChanged, this, &ScintillaEditor::fireModificationChanged);
-  connect(qsci, &QsciScintilla::userListActivated, this, &ScintillaEditor::onUserListSelected);
-  qsci->installEventFilter(this);
-  qsci->viewport()->installEventFilter(this);
+  connect (qsci, &QsciScintilla::textChanged, this, &ScintillaEditor::contentsChanged);
+  connect (qsci, &QsciScintilla::modificationChanged, this, &ScintillaEditor::fireModificationChanged);
+  connect (qsci, &QsciScintilla::userListActivated, this, &ScintillaEditor::onUserListSelected);
+  qsci->installEventFilter (this);
+  qsci->viewport ()->installEventFilter (this);
 
-  qsci->setContextMenuPolicy(Qt::CustomContextMenu);
-  connect(qsci, &QsciScintilla::customContextMenuRequested, this, &ScintillaEditor::showContextMenuEvent);
+  qsci->setContextMenuPolicy (Qt::CustomContextMenu);
+  connect (qsci, &QsciScintilla::customContextMenuRequested, this, &ScintillaEditor::showContextMenuEvent);
 
-  qsci->indicatorDefine(QsciScintilla::ThinCompositionIndicator, hyperlinkIndicatorNumber);
-  qsci->SendScintilla(QsciScintilla::SCI_INDICSETSTYLE, hyperlinkIndicatorNumber, QsciScintilla::INDIC_HIDDEN);
-  connect(qsci, &QsciScintilla::indicatorClicked, this, &ScintillaEditor::onIndicatorClicked);
-  connect(qsci, &QsciScintilla::indicatorReleased, this, &ScintillaEditor::onIndicatorReleased);
+  qsci->indicatorDefine (QsciScintilla::ThinCompositionIndicator, hyperlinkIndicatorNumber);
+  qsci->SendScintilla (QsciScintilla::SCI_INDICSETSTYLE, hyperlinkIndicatorNumber, QsciScintilla::INDIC_HIDDEN);
+  connect (qsci, &QsciScintilla::indicatorClicked, this, &ScintillaEditor::onIndicatorClicked);
+  connect (qsci, &QsciScintilla::indicatorReleased, this, &ScintillaEditor::onIndicatorReleased);
 
 #if QSCINTILLA_VERSION >= 0x020b00
-  connect(qsci, &QsciScintilla::SCN_URIDROPPED, this, &ScintillaEditor::uriDropped);
+  connect (qsci, &QsciScintilla::SCN_URIDROPPED, this, &ScintillaEditor::uriDropped);
 #endif
-  connect(qsci, &QsciScintilla::SCN_FOCUSIN, this, &ScintillaEditor::focusIn);
+  connect (qsci, &QsciScintilla::SCN_FOCUSIN, this, &ScintillaEditor::focusIn);
 
   // Disabling buffered drawing resolves non-integer HiDPI scaling.
-  qsci->SendScintilla(QsciScintillaBase::SCI_SETBUFFEREDDRAW, false);
+  qsci->SendScintilla (QsciScintillaBase::SCI_SETBUFFEREDDRAW, false);
 }
 
-QPoint ScintillaEditor::mapToGlobal(const QPoint& pos)
-{
-  return qsci->mapToGlobal(pos);
+QPoint ScintillaEditor::mapToGlobal (const QPoint &pos) {
+  return qsci->mapToGlobal (pos);
 }
 
-QMenu *ScintillaEditor::createStandardContextMenu()
-{
-  return qsci->createStandardContextMenu();
+QMenu *ScintillaEditor::createStandardContextMenu () {
+  return qsci->createStandardContextMenu ();
 }
 
-void ScintillaEditor::addTemplate()
-{
-  addTemplate(PlatformUtils::resourceBasePath());
-  addTemplate(PlatformUtils::userConfigPath());
-  for (const auto& key: templateMap.keys()) {
-    userList.append(key);
+void ScintillaEditor::addTemplate () {
+  addTemplate (PlatformUtils::resourceBasePath ());
+  addTemplate (PlatformUtils::userConfigPath ());
+  for (const auto &key : templateMap.keys ()) {
+    userList.append (key);
   }
 }
 
-void ScintillaEditor::addTemplate(const fs::path& path)
-{
+void ScintillaEditor::addTemplate (const fs::path &path) {
   const auto template_path = path / "templates";
 
-  if (fs::exists(template_path) && fs::is_directory(template_path)) {
-    for (const auto& dirEntry : boost::make_iterator_range(fs::directory_iterator{template_path}, {})) {
-      if (!fs::is_regular_file(dirEntry.status())) continue;
+  if (fs::exists (template_path) && fs::is_directory (template_path)) {
+    for (const auto &dirEntry : boost::make_iterator_range (fs::directory_iterator{template_path}, {})) {
+      if (!fs::is_regular_file (dirEntry.status ()))
+        continue;
 
-      const auto& path = dirEntry.path();
-      if (!(path.extension() == ".json")) continue;
+      const auto &path = dirEntry.path ();
+      if (!(path.extension () == ".json"))
+        continue;
 
       boost::property_tree::ptree pt;
       try {
-        boost::property_tree::read_json(path.generic_string().c_str(), pt);
-        const QString key = QString::fromStdString(pt.get<std::string>("key"));
-        const QString content = QString::fromStdString(pt.get<std::string>("content"));
-        const int cursor_offset = pt.get<int>("offset", -1);
-
-        templateMap.insert(key, ScadTemplate(content, cursor_offset));
-      } catch (const std::exception& e) {
-        LOG("Error reading template file '%1$s': %2$s", path.generic_string(), e.what());
+        boost::property_tree::read_json (path.generic_string ().c_str (), pt);
+        const QString key = QString::fromStdString (pt.get<std::string> ("key"));
+        const QString content = QString::fromStdString (pt.get<std::string> ("content"));
+        const int cursor_offset = pt.get<int> ("offset", -1);
+
+        templateMap.insert (key, ScadTemplate (content, cursor_offset));
+      } catch (const std::exception &e) {
+        LOG ("Error reading template file '%1$s': %2$s", path.generic_string (), e.what ());
       }
     }
   }
 }
 
-void ScintillaEditor::displayTemplates()
-{
-  qsci->showUserList(1, userList);
+void ScintillaEditor::displayTemplates () {
+  qsci->showUserList (1, userList);
 }
 
-void ScintillaEditor::foldUnfold()
-{
-  qsci->foldAll();
+void ScintillaEditor::foldUnfold () {
+  qsci->foldAll ();
 }
 
 /**
  * Apply the settings that are changeable in the preferences. This is also
  * called in the event handler from the preferences.
  */
-void ScintillaEditor::applySettings()
-{
+void ScintillaEditor::applySettings () {
   SettingsConverter conv;
 
-  qsci->setIndentationWidth(Settings::Settings::indentationWidth.value());
-  qsci->setTabWidth(Settings::Settings::tabWidth.value());
-  qsci->setWrapMode(conv.toWrapMode(Settings::Settings::lineWrap.value()));
-  qsci->setWrapIndentMode(conv.toLineWrapIndentationStyle(Settings::Settings::lineWrapIndentationStyle.value()));
-  qsci->setWrapVisualFlags(conv.toLineWrapVisualization(Settings::Settings::lineWrapVisualizationEnd.value()),
-                           conv.toLineWrapVisualization(Settings::Settings::lineWrapVisualizationBegin.value()),
-                           Settings::Settings::lineWrapIndentation.value());
-  qsci->setWhitespaceVisibility(conv.toShowWhitespaces(Settings::Settings::showWhitespace.value()));
-  qsci->setWhitespaceSize(Settings::Settings::showWhitespaceSize.value());
-  qsci->setAutoIndent(Settings::Settings::autoIndent.value());
-  qsci->setBackspaceUnindents(Settings::Settings::backspaceUnindents.value());
+  qsci->setIndentationWidth (Settings::Settings::indentationWidth.value ());
+  qsci->setTabWidth (Settings::Settings::tabWidth.value ());
+  qsci->setWrapMode (conv.toWrapMode (Settings::Settings::lineWrap.value ()));
+  qsci->setWrapIndentMode (conv.toLineWrapIndentationStyle (Settings::Settings::lineWrapIndentationStyle.value ()));
+  qsci->setWrapVisualFlags (conv.toLineWrapVisualization (Settings::Settings::lineWrapVisualizationEnd.value ()),
+                            conv.toLineWrapVisualization (Settings::Settings::lineWrapVisualizationBegin.value ()),
+                            Settings::Settings::lineWrapIndentation.value ());
+  qsci->setWhitespaceVisibility (conv.toShowWhitespaces (Settings::Settings::showWhitespace.value ()));
+  qsci->setWhitespaceSize (Settings::Settings::showWhitespaceSize.value ());
+  qsci->setAutoIndent (Settings::Settings::autoIndent.value ());
+  qsci->setBackspaceUnindents (Settings::Settings::backspaceUnindents.value ());
 
-  const auto& indentStyle = Settings::Settings::indentStyle.value();
-  qsci->setIndentationsUseTabs(indentStyle == "Tabs");
-  const auto& tabKeyFunction = Settings::Settings::tabKeyFunction.value();
-  qsci->setTabIndents(tabKeyFunction == "Indent");
+  const auto &indentStyle = Settings::Settings::indentStyle.value ();
+  qsci->setIndentationsUseTabs (indentStyle == "Tabs");
+  const auto &tabKeyFunction = Settings::Settings::tabKeyFunction.value ();
+  qsci->setTabIndents (tabKeyFunction == "Indent");
 
-  qsci->setBraceMatching(Settings::Settings::enableBraceMatching.value() ? QsciScintilla::SloppyBraceMatch : QsciScintilla::NoBraceMatch);
-  qsci->setCaretLineVisible(Settings::Settings::highlightCurrentLine.value());
-  onTextChanged();
+  qsci->setBraceMatching (Settings::Settings::enableBraceMatching.value () ? QsciScintilla::SloppyBraceMatch : QsciScintilla::NoBraceMatch);
+  qsci->setCaretLineVisible (Settings::Settings::highlightCurrentLine.value ());
+  onTextChanged ();
 
-  setupAutoComplete(false);
+  setupAutoComplete (false);
 }
 
-void ScintillaEditor::setupAutoComplete(const bool forceOff)
-{
-  if (qsci->isListActive()) {
-    qsci->cancelList();
+void ScintillaEditor::setupAutoComplete (const bool forceOff) {
+  if (qsci->isListActive ()) {
+    qsci->cancelList ();
   }
 
-  if (qsci->isCallTipActive()) {
-    qsci->SendScintilla(QsciScintilla::SCI_CALLTIPCANCEL);
+  if (qsci->isCallTipActive ()) {
+    qsci->SendScintilla (QsciScintilla::SCI_CALLTIPCANCEL);
   }
 
-  const bool configValue = GlobalPreferences::inst()->getValue("editor/enableAutocomplete").toBool();
+  const bool configValue = GlobalPreferences::inst ()->getValue ("editor/enableAutocomplete").toBool ();
   const bool enable = configValue && !forceOff;
 
   if (enable) {
-    qsci->setAutoCompletionSource(QsciScintilla::AcsAPIs);
-    qsci->setAutoCompletionFillupsEnabled(false);
-    qsci->setAutoCompletionFillups("(");
-    qsci->setCallTipsVisible(10);
-    qsci->setCallTipsStyle(QsciScintilla::CallTipsContext);
+    qsci->setAutoCompletionSource (QsciScintilla::AcsAPIs);
+    qsci->setAutoCompletionFillupsEnabled (false);
+    qsci->setAutoCompletionFillups ("(");
+    qsci->setCallTipsVisible (10);
+    qsci->setCallTipsStyle (QsciScintilla::CallTipsContext);
   } else {
-    qsci->setAutoCompletionSource(QsciScintilla::AcsNone);
-    qsci->setAutoCompletionFillupsEnabled(false);
-    qsci->setCallTipsStyle(QsciScintilla::CallTipsNone);
+    qsci->setAutoCompletionSource (QsciScintilla::AcsNone);
+    qsci->setAutoCompletionFillupsEnabled (false);
+    qsci->setCallTipsStyle (QsciScintilla::CallTipsNone);
   }
 
-  int val = GlobalPreferences::inst()->getValue("editor/characterThreshold").toInt();
-  qsci->setAutoCompletionThreshold(val <= 0 ? 1 : val);
+  int val = GlobalPreferences::inst ()->getValue ("editor/characterThreshold").toInt ();
+  qsci->setAutoCompletionThreshold (val <= 0 ? 1 : val);
 }
 
-void ScintillaEditor::fireModificationChanged()
-{
-  emit modificationChanged(this);
+void ScintillaEditor::fireModificationChanged () {
+  emit modificationChanged (this);
 }
 
-void ScintillaEditor::setPlainText(const QString& text)
-{
-  qsci->setText(text);
-  setContentModified(false);
+void ScintillaEditor::setPlainText (const QString &text) {
+  qsci->setText (text);
+  setContentModified (false);
 }
 
-QString ScintillaEditor::toPlainText()
-{
-  return qsci->text();
+QString ScintillaEditor::toPlainText () {
+  return qsci->text ();
 }
 
-void ScintillaEditor::setContentModified(bool modified)
-{
+void ScintillaEditor::setContentModified (bool modified) {
   // FIXME: Due to an issue with QScintilla, we need to do this on the document itself.
-  qsci->SCN_SAVEPOINTLEFT();
-  qsci->setModified(modified);
+  qsci->SCN_SAVEPOINTLEFT ();
+  qsci->setModified (modified);
 }
 
-bool ScintillaEditor::isContentModified()
-{
-  return qsci->isModified();
+bool ScintillaEditor::isContentModified () {
+  return qsci->isModified ();
 }
 
-void ScintillaEditor::highlightError(int error_pos)
-{
+void ScintillaEditor::highlightError (int error_pos) {
   int line, index;
-  qsci->lineIndexFromPosition(error_pos, &line, &index);
-  qsci->fillIndicatorRange(line, index, line, index + 1, errorIndicatorNumber);
-  qsci->markerAdd(line, errMarkerNumber);
-  updateSymbolMarginVisibility();
+  qsci->lineIndexFromPosition (error_pos, &line, &index);
+  qsci->fillIndicatorRange (line, index, line, index + 1, errorIndicatorNumber);
+  qsci->markerAdd (line, errMarkerNumber);
+  updateSymbolMarginVisibility ();
 }
 
-void ScintillaEditor::unhighlightLastError()
-{
-  auto totalLength = qsci->length();
+void ScintillaEditor::unhighlightLastError () {
+  auto totalLength = qsci->length ();
   int line, index;
-  qsci->lineIndexFromPosition(totalLength, &line, &index);
-  qsci->clearIndicatorRange(0, 0, line, index, errorIndicatorNumber);
-  qsci->markerDeleteAll(errMarkerNumber);
-  updateSymbolMarginVisibility();
+  qsci->lineIndexFromPosition (totalLength, &line, &index);
+  qsci->clearIndicatorRange (0, 0, line, index, errorIndicatorNumber);
+  qsci->markerDeleteAll (errMarkerNumber);
+  updateSymbolMarginVisibility ();
 }
 
-QColor ScintillaEditor::readColor(const boost::property_tree::ptree& pt, const std::string& name, const QColor& defaultColor)
-{
+QColor ScintillaEditor::readColor (const boost::property_tree::ptree &pt, const std::string &name, const QColor &defaultColor) {
   try {
-    const auto val = pt.get<std::string>(name);
-    return {val.c_str()};
-  } catch (const std::exception& e) {
+    const auto val = pt.get<std::string> (name);
+    return {val.c_str ()};
+  } catch (const std::exception &e) {
     return defaultColor;
   }
 }
 
-std::string ScintillaEditor::readString(const boost::property_tree::ptree& pt, const std::string& name, const std::string& defaultValue)
-{
+std::string ScintillaEditor::readString (const boost::property_tree::ptree &pt, const std::string &name, const std::string &defaultValue) {
   try {
-    return pt.get<std::string>(name);
-  } catch (const std::exception& e) {
+    return pt.get<std::string> (name);
+  } catch (const std::exception &e) {
     return defaultValue;
   }
 }
 
-int ScintillaEditor::readInt(const boost::property_tree::ptree& pt, const std::string& name, const int defaultValue)
-{
+int ScintillaEditor::readInt (const boost::property_tree::ptree &pt, const std::string &name, const int defaultValue) {
   try {
-    const auto val = pt.get<int>(name);
+    const auto val = pt.get<int> (name);
     return val;
-  } catch (const std::exception& e) {
+  } catch (const std::exception &e) {
     return defaultValue;
   }
 }
 
 #if ENABLE_LEXERTL
-void ScintillaEditor::setLexer(ScadLexer2 *newLexer)
-{
+void ScintillaEditor::setLexer (ScadLexer2 *newLexer) {
   delete this->api;
-  this->qsci->setLexer(newLexer);
-  this->api = new ScadApi(this, newLexer);
+  this->qsci->setLexer (newLexer);
+  this->api = new ScadApi (this, newLexer);
   delete this->lexer;
   this->lexer = newLexer;
 }
 #else
-void ScintillaEditor::setLexer(ScadLexer *newLexer)
-{
+void ScintillaEditor::setLexer (ScadLexer *newLexer) {
   delete this->api;
-  this->qsci->setLexer(newLexer);
-  this->api = new ScadApi(this, newLexer);
+  this->qsci->setLexer (newLexer);
+  this->api = new ScadApi (this, newLexer);
   delete this->lexer;
   this->lexer = newLexer;
 }
 #endif // if ENABLE_LEXERTL
 
-void ScintillaEditor::setColormap(const EditorColorScheme *colorScheme)
-{
-  const auto& pt = colorScheme->propertyTree();
+void ScintillaEditor::setColormap (const EditorColorScheme *colorScheme) {
+  const auto &pt = colorScheme->propertyTree ();
 
   try {
-    auto font = this->lexer->font(this->lexer->defaultStyle());
-    const QColor textColor(pt.get<std::string>("text").c_str());
-    const QColor paperColor(pt.get<std::string>("paper").c_str());
+    auto font = this->lexer->font (this->lexer->defaultStyle ());
+    const QColor textColor (pt.get<std::string> ("text").c_str ());
+    const QColor paperColor (pt.get<std::string> ("paper").c_str ());
 
 #if ENABLE_LEXERTL
 
-/// See original attempt at https://github.com/openscad/openscad/tree/lexertl/src
+    /// See original attempt at https://github.com/openscad/openscad/tree/lexertl/src
 
-    auto *newLexer = new ScadLexer2(this);
+    auto *newLexer = new ScadLexer2 (this);
 
     // Custom keywords must be set before the lexer is constructed/finalized
-    boost::optional<const boost::property_tree::ptree&> keywords = pt.get_child_optional("keywords");
-    if (keywords.is_initialized()) {
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom1", ""), ScadLexer2::Custom1);
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom2", ""), ScadLexer2::Custom2);
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom3", ""), ScadLexer2::Custom3);
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom4", ""), ScadLexer2::Custom4);
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom5", ""), ScadLexer2::Custom5);
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom6", ""), ScadLexer2::Custom6);
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom7", ""), ScadLexer2::Custom7);
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom8", ""), ScadLexer2::Custom8);
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom9", ""), ScadLexer2::Custom9);
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom10", ""), ScadLexer2::Custom10);
+    boost::optional<const boost::property_tree::ptree &> keywords = pt.get_child_optional ("keywords");
+    if (keywords.is_initialized ()) {
+      newLexer->addKeywords (readString (keywords.get (), "keyword-custom1", ""), ScadLexer2::Custom1);
+      newLexer->addKeywords (readString (keywords.get (), "keyword-custom2", ""), ScadLexer2::Custom2);
+      newLexer->addKeywords (readString (keywords.get (), "keyword-custom3", ""), ScadLexer2::Custom3);
+      newLexer->addKeywords (readString (keywords.get (), "keyword-custom4", ""), ScadLexer2::Custom4);
+      newLexer->addKeywords (readString (keywords.get (), "keyword-custom5", ""), ScadLexer2::Custom5);
+      newLexer->addKeywords (readString (keywords.get (), "keyword-custom6", ""), ScadLexer2::Custom6);
+      newLexer->addKeywords (readString (keywords.get (), "keyword-custom7", ""), ScadLexer2::Custom7);
+      newLexer->addKeywords (readString (keywords.get (), "keyword-custom8", ""), ScadLexer2::Custom8);
+      newLexer->addKeywords (readString (keywords.get (), "keyword-custom9", ""), ScadLexer2::Custom9);
+      newLexer->addKeywords (readString (keywords.get (), "keyword-custom10", ""), ScadLexer2::Custom10);
     }
 
-    newLexer->finalizeLexer();
-    setLexer(newLexer);
+    newLexer->finalizeLexer ();
+    setLexer (newLexer);
 
     // All other properties must be set after attaching to QSCintilla so
     // the editor gets the change events and updates itself to match
-    newLexer->setFont(font);
-    newLexer->setColor(textColor);
-    newLexer->setPaper(paperColor);
-
-    const auto& colors = pt.get_child("colors");
-
-    newLexer->setColor(readColor(colors, "operator", textColor), ScadLexer2::Operator);
-    newLexer->setColor(readColor(colors, "comment", textColor), ScadLexer2::Comment);
-    newLexer->setColor(readColor(colors, "number", textColor), ScadLexer2::Number);
-    newLexer->setColor(readColor(colors, "string", textColor), ScadLexer2::String);
-    newLexer->setColor(readColor(colors, "variables", textColor), ScadLexer2::Variable);
-    newLexer->setColor(readColor(colors, "keywords", textColor), ScadLexer2::Keyword); // formerly keyword1
-    newLexer->setColor(readColor(colors, "transformations", textColor), ScadLexer2::Transformation); // formerly keyword3
-    newLexer->setColor(readColor(colors, "booleans", textColor), ScadLexer2::Boolean); // formerly keyword3
-    newLexer->setColor(readColor(colors, "functions", textColor), ScadLexer2::Function); // formerly keyword2
-    newLexer->setColor(readColor(colors, "models", textColor), ScadLexer2::Model); // formerly keyword3
-    newLexer->setColor(readColor(colors, "special-variables", textColor), ScadLexer2::SpecialVariable); // formerly keyword1
-
-    newLexer->setColor(readColor(colors, "keyword-custom1", textColor), ScadLexer2::Custom1);
-    newLexer->setColor(readColor(colors, "keyword-custom2", textColor), ScadLexer2::Custom2);
-    newLexer->setColor(readColor(colors, "keyword-custom3", textColor), ScadLexer2::Custom3);
-    newLexer->setColor(readColor(colors, "keyword-custom4", textColor), ScadLexer2::Custom4);
-    newLexer->setColor(readColor(colors, "keyword-custom5", textColor), ScadLexer2::Custom5);
-    newLexer->setColor(readColor(colors, "keyword-custom6", textColor), ScadLexer2::Custom6);
-    newLexer->setColor(readColor(colors, "keyword-custom7", textColor), ScadLexer2::Custom7);
-    newLexer->setColor(readColor(colors, "keyword-custom8", textColor), ScadLexer2::Custom8);
-    newLexer->setColor(readColor(colors, "keyword-custom9", textColor), ScadLexer2::Custom9);
-    newLexer->setColor(readColor(colors, "keyword-custom10", textColor), ScadLexer2::Custom10);
+    newLexer->setFont (font);
+    newLexer->setColor (textColor);
+    newLexer->setPaper (paperColor);
+
+    const auto &colors = pt.get_child ("colors");
+
+    newLexer->setColor (readColor (colors, "operator", textColor), ScadLexer2::Operator);
+    newLexer->setColor (readColor (colors, "comment", textColor), ScadLexer2::Comment);
+    newLexer->setColor (readColor (colors, "number", textColor), ScadLexer2::Number);
+    newLexer->setColor (readColor (colors, "string", textColor), ScadLexer2::String);
+    newLexer->setColor (readColor (colors, "variables", textColor), ScadLexer2::Variable);
+    newLexer->setColor (readColor (colors, "keywords", textColor), ScadLexer2::Keyword); // formerly keyword1
+    newLexer->setColor (readColor (colors, "transformations", textColor), ScadLexer2::Transformation); // formerly keyword3
+    newLexer->setColor (readColor (colors, "booleans", textColor), ScadLexer2::Boolean); // formerly keyword3
+    newLexer->setColor (readColor (colors, "functions", textColor), ScadLexer2::Function); // formerly keyword2
+    newLexer->setColor (readColor (colors, "models", textColor), ScadLexer2::Model); // formerly keyword3
+    newLexer->setColor (readColor (colors, "special-variables", textColor), ScadLexer2::SpecialVariable); // formerly keyword1
+
+    newLexer->setColor (readColor (colors, "keyword-custom1", textColor), ScadLexer2::Custom1);
+    newLexer->setColor (readColor (colors, "keyword-custom2", textColor), ScadLexer2::Custom2);
+    newLexer->setColor (readColor (colors, "keyword-custom3", textColor), ScadLexer2::Custom3);
+    newLexer->setColor (readColor (colors, "keyword-custom4", textColor), ScadLexer2::Custom4);
+    newLexer->setColor (readColor (colors, "keyword-custom5", textColor), ScadLexer2::Custom5);
+    newLexer->setColor (readColor (colors, "keyword-custom6", textColor), ScadLexer2::Custom6);
+    newLexer->setColor (readColor (colors, "keyword-custom7", textColor), ScadLexer2::Custom7);
+    newLexer->setColor (readColor (colors, "keyword-custom8", textColor), ScadLexer2::Custom8);
+    newLexer->setColor (readColor (colors, "keyword-custom9", textColor), ScadLexer2::Custom9);
+    newLexer->setColor (readColor (colors, "keyword-custom10", textColor), ScadLexer2::Custom10);
 
 #else
-    auto *newLexer = new ScadLexer(this);
+    auto *newLexer = new ScadLexer (this);
 
     // Keywords must be set before the lexer is attached to QScintilla
     // as they seem to be read and cached at attach time.
-    boost::optional<const boost::property_tree::ptree&> keywords = pt.get_child_optional("keywords");
-    if (keywords.is_initialized()) {
-      newLexer->setKeywords(1, readString(keywords.get(), "keyword-set1", ""));
-      newLexer->setKeywords(2, readString(keywords.get(), "keyword-set2", ""));
-      newLexer->setKeywords(3, readString(keywords.get(), "keyword-set-doc", ""));
-      newLexer->setKeywords(4, readString(keywords.get(), "keyword-set3", ""));
+    boost::optional<const boost::property_tree::ptree &> keywords = pt.get_child_optional ("keywords");
+    if (keywords.is_initialized ()) {
+      newLexer->setKeywords (1, readString (keywords.get (), "keyword-set1", ""));
+      newLexer->setKeywords (2, readString (keywords.get (), "keyword-set2", ""));
+      newLexer->setKeywords (3, readString (keywords.get (), "keyword-set-doc", ""));
+      newLexer->setKeywords (4, readString (keywords.get (), "keyword-set3", ""));
     }
 
     // See https://github.com/openscad/openscad/issues/1172 for details about why we can't do syntax coloring with # lines
-    newLexer->setStylePreprocessor(true); // does not work on first word, but allows remaining words to be syntax colored
+    newLexer->setStylePreprocessor (true); // does not work on first word, but allows remaining words to be syntax colored
 
-    setLexer(newLexer);
+    setLexer (newLexer);
 
     // All other properties must be set after attaching to QSCintilla so
     // the editor gets the change events and updates itself to match
-    newLexer->setFont(font);
-    newLexer->setColor(textColor);
-    newLexer->setPaper(paperColor);
-
-    const auto& colors = pt.get_child("colors");
-    newLexer->setColor(readColor(colors, "keyword1", textColor), QsciLexerCPP::Keyword);
-    newLexer->setColor(readColor(colors, "keyword2", textColor), QsciLexerCPP::KeywordSet2);
-    newLexer->setColor(readColor(colors, "keyword3", textColor), QsciLexerCPP::GlobalClass);
-    newLexer->setColor(readColor(colors, "number", textColor), QsciLexerCPP::Number);
-    newLexer->setColor(readColor(colors, "string", textColor), QsciLexerCPP::DoubleQuotedString);
-    newLexer->setColor(readColor(colors, "operator", textColor), QsciLexerCPP::Operator);
-    newLexer->setColor(readColor(colors, "comment", textColor), QsciLexerCPP::Comment);
-    newLexer->setColor(readColor(colors, "commentline", textColor), QsciLexerCPP::CommentLine);
-    newLexer->setColor(readColor(colors, "commentdoc", textColor), QsciLexerCPP::CommentDoc);
-    newLexer->setColor(readColor(colors, "commentdoc", textColor), QsciLexerCPP::CommentLineDoc);
-    newLexer->setColor(readColor(colors, "commentdockeyword", textColor), QsciLexerCPP::CommentDocKeyword);
-
-#endif  // ENABLE_LEXERTL
+    newLexer->setFont (font);
+    newLexer->setColor (textColor);
+    newLexer->setPaper (paperColor);
+
+    const auto &colors = pt.get_child ("colors");
+    newLexer->setColor (readColor (colors, "keyword1", textColor), QsciLexerCPP::Keyword);
+    newLexer->setColor (readColor (colors, "keyword2", textColor), QsciLexerCPP::KeywordSet2);
+    newLexer->setColor (readColor (colors, "keyword3", textColor), QsciLexerCPP::GlobalClass);
+    newLexer->setColor (readColor (colors, "number", textColor), QsciLexerCPP::Number);
+    newLexer->setColor (readColor (colors, "string", textColor), QsciLexerCPP::DoubleQuotedString);
+    newLexer->setColor (readColor (colors, "operator", textColor), QsciLexerCPP::Operator);
+    newLexer->setColor (readColor (colors, "comment", textColor), QsciLexerCPP::Comment);
+    newLexer->setColor (readColor (colors, "commentline", textColor), QsciLexerCPP::CommentLine);
+    newLexer->setColor (readColor (colors, "commentdoc", textColor), QsciLexerCPP::CommentDoc);
+    newLexer->setColor (readColor (colors, "commentdoc", textColor), QsciLexerCPP::CommentLineDoc);
+    newLexer->setColor (readColor (colors, "commentdockeyword", textColor), QsciLexerCPP::CommentDocKeyword);
+
+#endif // ENABLE_LEXERTL
 
     // Somehow, the margin font got lost when we deleted the old lexer
-    qsci->setMarginsFont(font);
-
-    const auto& caret = pt.get_child("caret");
-    qsci->setCaretWidth(readInt(caret, "width", 1));
-    qsci->setCaretForegroundColor(readColor(caret, "foreground", textColor));
-    qsci->setCaretLineBackgroundColor(readColor(caret, "line-background", paperColor));
-
-    qsci->setMarkerBackgroundColor(readColor(colors, "error-marker", QColor(255, 0, 0, 100)), errMarkerNumber);
-    qsci->setMarkerBackgroundColor(readColor(colors, "bookmark-marker", QColor(150, 200, 255, 100)), bmMarkerNumber); // light blue
-    qsci->setMarkerBackgroundColor(readColor(colors, "reference-marker1", QColor(11, 156, 49, 100)), selectionMarkerLevelNumber);
-    qsci->setMarkerBackgroundColor(readColor(colors, "reference-marker2", QColor(11, 156, 49, 50)), selectionMarkerLevelNumber + 1);
-    qsci->setMarkerBackgroundColor(readColor(colors, "reference-marker3", QColor(11, 156, 49, 50)), selectionMarkerLevelNumber + 2);
-    qsci->setMarkerBackgroundColor(readColor(colors, "reference-marker4", QColor(11, 156, 49, 50)), selectionMarkerLevelNumber + 3);
-    qsci->setMarkerBackgroundColor(readColor(colors, "reference-marker5", QColor(11, 156, 49, 50)), selectionMarkerLevelNumber + 4);
-    qsci->setMarkerBackgroundColor(readColor(colors, "reference-marker6", QColor(11, 156, 49, 50)), selectionMarkerLevelNumber + 5);
-    qsci->setMarkerBackgroundColor(readColor(colors, "bookmark-marker", QColor(150, 200, 255, 50)), bmMarkerNumber); // light blue
-    qsci->setIndicatorForegroundColor(readColor(colors, "selected-highlight-indicator", QColor(11, 156, 49, 100)), selectionIndicatorIsActiveNumber); //light green
-    qsci->setIndicatorOutlineColor(readColor(colors, "selected-highlight-indicator-outline", QColor(11, 156, 49, 100)), selectionIndicatorIsActiveNumber); //light green
-    qsci->setIndicatorForegroundColor(readColor(colors, "selected-highlight1-indicator", QColor(11, 156, 49, 50)), selectionIndicatorIsActiveNumber + 1); //light green
-    qsci->setIndicatorOutlineColor(readColor(colors, "selected-highlight1-indicator-outline", QColor(11, 156, 49, 50)), selectionIndicatorIsActiveNumber + 1); //light green
-    qsci->setIndicatorForegroundColor(readColor(colors, "referenced-highlight0-indicator", QColor(255, 128, 128, 100)), selectionIndicatorIsImpactedNumber); //light green
-    qsci->setIndicatorOutlineColor(readColor(colors, "referenced-highlight0-indicator-outline", QColor(255, 128, 128, 100)), selectionIndicatorIsImpactedNumber); //light green
-    qsci->setIndicatorForegroundColor(readColor(colors, "referenced-highlight1-indicator", QColor(255, 128, 128, 100)), selectionIndicatorIsImpactedNumber + 1); //light green
-    qsci->setIndicatorOutlineColor(readColor(colors, "referenced-highlight1-indicator-outline", QColor(255, 128, 128, 80)), selectionIndicatorIsImpactedNumber + 1); //light green
-    qsci->setIndicatorForegroundColor(readColor(colors, "referenced-highlight2-indicator", QColor(255, 128, 128, 100)), selectionIndicatorIsImpactedNumber + 2); //light green
-    qsci->setIndicatorOutlineColor(readColor(colors, "referenced-highlight2-indicator-outline", QColor(255, 128, 128, 60)), selectionIndicatorIsImpactedNumber + 2); //light green
-    qsci->setIndicatorForegroundColor(readColor(colors, "error-indicator", QColor(255, 0, 0, 100)), errorIndicatorNumber); //red
-    qsci->setIndicatorOutlineColor(readColor(colors, "error-indicator-outline", QColor(255, 0, 0, 100)), errorIndicatorNumber); //red
-    qsci->setIndicatorForegroundColor(readColor(colors, "find-indicator", QColor(255, 255, 0, 100)), findIndicatorNumber); //yellow
-    qsci->setIndicatorOutlineColor(readColor(colors, "find-indicator-outline", QColor(255, 255, 0, 100)), findIndicatorNumber); //yellow
-    qsci->setIndicatorForegroundColor(readColor(colors, "hyperlink-indicator", QColor(139, 24, 168, 100)), hyperlinkIndicatorNumber); //violet
-    qsci->setIndicatorOutlineColor(readColor(colors, "hyperlink-indicator-outline", QColor(139, 24, 168, 100)), hyperlinkIndicatorNumber); //violet
-    qsci->setIndicatorHoverForegroundColor(readColor(colors, "hyperlink-indicator-hover", QColor(139, 24, 168, 100)), hyperlinkIndicatorNumber); //violet
-    qsci->setWhitespaceForegroundColor(readColor(colors, "whitespace-foreground", textColor));
-    qsci->setMarginsBackgroundColor(readColor(colors, "margin-background", paperColor));
-    qsci->setMarginsForegroundColor(readColor(colors, "margin-foreground", textColor));
-    qsci->setFoldMarginColors(readColor(colors, "margin-background", paperColor),
-                              readColor(colors, "margin-background", paperColor));
-    qsci->setMatchedBraceBackgroundColor(readColor(colors, "matched-brace-background", paperColor));
-    qsci->setMatchedBraceForegroundColor(readColor(colors, "matched-brace-foreground", textColor));
-    qsci->setUnmatchedBraceBackgroundColor(readColor(colors, "unmatched-brace-background", paperColor));
-    qsci->setUnmatchedBraceForegroundColor(readColor(colors, "unmatched-brace-foreground", textColor));
-    qsci->setSelectionForegroundColor(readColor(colors, "selection-foreground", paperColor));
-    qsci->setSelectionBackgroundColor(readColor(colors, "selection-background", textColor));
-    qsci->setEdgeColor(readColor(colors, "edge", textColor));
-  } catch (const std::exception& e) {
-    noColor();
-  }
-}
-
-void ScintillaEditor::noColor()
-{
-  this->lexer->setPaper(Qt::white);
-  this->lexer->setColor(Qt::black);
-  qsci->setCaretWidth(2);
-  qsci->setCaretForegroundColor(Qt::black);
-  qsci->setMarkerBackgroundColor(QColor(255, 0, 0, 100), errMarkerNumber);
-  qsci->setMarkerBackgroundColor(QColor(150, 200, 255, 100), bmMarkerNumber); // light blue
-  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 100), selectionMarkerLevelNumber);
-  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 50), selectionMarkerLevelNumber + 1);
-  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 50), selectionMarkerLevelNumber + 2);
-  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 50), selectionMarkerLevelNumber + 3);
-  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 50), selectionMarkerLevelNumber + 4);
-  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 50), selectionMarkerLevelNumber + 5);
-  qsci->setMarkerBackgroundColor(QColor(150, 200, 255, 100), bmMarkerNumber); // light blue
-  qsci->setIndicatorForegroundColor(QColor(11, 156, 49, 100), selectionIndicatorIsActiveNumber);
-  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255), selectionIndicatorIsActiveNumber);
-  qsci->setIndicatorForegroundColor(QColor(11, 156, 49, 50), selectionIndicatorIsActiveNumber + 1);
-  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255), selectionIndicatorIsActiveNumber + 1);
-  qsci->setIndicatorForegroundColor(QColor(255, 128, 128, 100), selectionIndicatorIsImpactedNumber);
-  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255), selectionIndicatorIsImpactedNumber);
-  qsci->setIndicatorForegroundColor(QColor(255, 128, 128, 80), selectionIndicatorIsImpactedNumber + 1);
-  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255), selectionIndicatorIsImpactedNumber + 1);
-  qsci->setIndicatorForegroundColor(QColor(255, 128, 128, 60), selectionIndicatorIsImpactedNumber + 2);
-  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255), selectionIndicatorIsImpactedNumber + 2);
-
-  qsci->setIndicatorForegroundColor(QColor(255, 0, 0, 128), errorIndicatorNumber); //red
-  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255), errorIndicatorNumber); // only alpha part is used
-  qsci->setIndicatorForegroundColor(QColor(255, 255, 0, 128), findIndicatorNumber); //yellow
-  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255), findIndicatorNumber); // only alpha part is used
-  qsci->setIndicatorForegroundColor(QColor(139, 24, 168, 128), hyperlinkIndicatorNumber); //violet
-  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255), hyperlinkIndicatorNumber); // only alpha part is used
-  qsci->setIndicatorHoverForegroundColor(QColor(139, 24, 168, 128), hyperlinkIndicatorNumber); //violet
-  qsci->setCaretLineBackgroundColor(Qt::white);
-  qsci->setWhitespaceForegroundColor(Qt::black);
-  qsci->setSelectionForegroundColor(Qt::black);
-  qsci->setSelectionBackgroundColor(QColor("LightSkyBlue"));
-  qsci->setMatchedBraceBackgroundColor(QColor("LightBlue"));
-  qsci->setMatchedBraceForegroundColor(Qt::black);
-  qsci->setUnmatchedBraceBackgroundColor(QColor("pink"));
-  qsci->setUnmatchedBraceForegroundColor(Qt::black);
-  qsci->setMarginsBackgroundColor(QColor("whiteSmoke"));
-  qsci->setMarginsForegroundColor(QColor("gray"));
-  qsci->setFoldMarginColors(QColor("whiteSmoke"), QColor("whiteSmoke"));
-  qsci->setEdgeColor(Qt::black);
-}
-
-void ScintillaEditor::enumerateColorSchemesInPath(ScintillaEditor::colorscheme_set_t& result_set, const fs::path& path)
-{
+    qsci->setMarginsFont (font);
+
+    const auto &caret = pt.get_child ("caret");
+    qsci->setCaretWidth (readInt (caret, "width", 1));
+    qsci->setCaretForegroundColor (readColor (caret, "foreground", textColor));
+    qsci->setCaretLineBackgroundColor (readColor (caret, "line-background", paperColor));
+
+    qsci->setMarkerBackgroundColor (readColor (colors, "error-marker", QColor (255, 0, 0, 100)), errMarkerNumber);
+    qsci->setMarkerBackgroundColor (readColor (colors, "bookmark-marker", QColor (150, 200, 255, 100)), bmMarkerNumber); // light blue
+    qsci->setMarkerBackgroundColor (readColor (colors, "reference-marker1", QColor (11, 156, 49, 100)), selectionMarkerLevelNumber);
+    qsci->setMarkerBackgroundColor (readColor (colors, "reference-marker2", QColor (11, 156, 49, 50)), selectionMarkerLevelNumber + 1);
+    qsci->setMarkerBackgroundColor (readColor (colors, "reference-marker3", QColor (11, 156, 49, 50)), selectionMarkerLevelNumber + 2);
+    qsci->setMarkerBackgroundColor (readColor (colors, "reference-marker4", QColor (11, 156, 49, 50)), selectionMarkerLevelNumber + 3);
+    qsci->setMarkerBackgroundColor (readColor (colors, "reference-marker5", QColor (11, 156, 49, 50)), selectionMarkerLevelNumber + 4);
+    qsci->setMarkerBackgroundColor (readColor (colors, "reference-marker6", QColor (11, 156, 49, 50)), selectionMarkerLevelNumber + 5);
+    qsci->setMarkerBackgroundColor (readColor (colors, "bookmark-marker", QColor (150, 200, 255, 50)), bmMarkerNumber); // light blue
+    qsci->setIndicatorForegroundColor (readColor (colors, "selected-highlight-indicator", QColor (11, 156, 49, 100)), selectionIndicatorIsActiveNumber); //light green
+    qsci->setIndicatorOutlineColor (readColor (colors, "selected-highlight-indicator-outline", QColor (11, 156, 49, 100)), selectionIndicatorIsActiveNumber); //light green
+    qsci->setIndicatorForegroundColor (readColor (colors, "selected-highlight1-indicator", QColor (11, 156, 49, 50)), selectionIndicatorIsActiveNumber + 1); //light green
+    qsci->setIndicatorOutlineColor (readColor (colors, "selected-highlight1-indicator-outline", QColor (11, 156, 49, 50)), selectionIndicatorIsActiveNumber + 1); //light green
+    qsci->setIndicatorForegroundColor (readColor (colors, "referenced-highlight0-indicator", QColor (255, 128, 128, 100)), selectionIndicatorIsImpactedNumber); //light green
+    qsci->setIndicatorOutlineColor (readColor (colors, "referenced-highlight0-indicator-outline", QColor (255, 128, 128, 100)), selectionIndicatorIsImpactedNumber); //light green
+    qsci->setIndicatorForegroundColor (readColor (colors, "referenced-highlight1-indicator", QColor (255, 128, 128, 100)), selectionIndicatorIsImpactedNumber + 1); //light green
+    qsci->setIndicatorOutlineColor (readColor (colors, "referenced-highlight1-indicator-outline", QColor (255, 128, 128, 80)), selectionIndicatorIsImpactedNumber + 1); //light green
+    qsci->setIndicatorForegroundColor (readColor (colors, "referenced-highlight2-indicator", QColor (255, 128, 128, 100)), selectionIndicatorIsImpactedNumber + 2); //light green
+    qsci->setIndicatorOutlineColor (readColor (colors, "referenced-highlight2-indicator-outline", QColor (255, 128, 128, 60)), selectionIndicatorIsImpactedNumber + 2); //light green
+    qsci->setIndicatorForegroundColor (readColor (colors, "error-indicator", QColor (255, 0, 0, 100)), errorIndicatorNumber); //red
+    qsci->setIndicatorOutlineColor (readColor (colors, "error-indicator-outline", QColor (255, 0, 0, 100)), errorIndicatorNumber); //red
+    qsci->setIndicatorForegroundColor (readColor (colors, "find-indicator", QColor (255, 255, 0, 100)), findIndicatorNumber); //yellow
+    qsci->setIndicatorOutlineColor (readColor (colors, "find-indicator-outline", QColor (255, 255, 0, 100)), findIndicatorNumber); //yellow
+    qsci->setIndicatorForegroundColor (readColor (colors, "hyperlink-indicator", QColor (139, 24, 168, 100)), hyperlinkIndicatorNumber); //violet
+    qsci->setIndicatorOutlineColor (readColor (colors, "hyperlink-indicator-outline", QColor (139, 24, 168, 100)), hyperlinkIndicatorNumber); //violet
+    qsci->setIndicatorHoverForegroundColor (readColor (colors, "hyperlink-indicator-hover", QColor (139, 24, 168, 100)), hyperlinkIndicatorNumber); //violet
+    qsci->setWhitespaceForegroundColor (readColor (colors, "whitespace-foreground", textColor));
+    qsci->setMarginsBackgroundColor (readColor (colors, "margin-background", paperColor));
+    qsci->setMarginsForegroundColor (readColor (colors, "margin-foreground", textColor));
+    qsci->setFoldMarginColors (readColor (colors, "margin-background", paperColor),
+                               readColor (colors, "margin-background", paperColor));
+    qsci->setMatchedBraceBackgroundColor (readColor (colors, "matched-brace-background", paperColor));
+    qsci->setMatchedBraceForegroundColor (readColor (colors, "matched-brace-foreground", textColor));
+    qsci->setUnmatchedBraceBackgroundColor (readColor (colors, "unmatched-brace-background", paperColor));
+    qsci->setUnmatchedBraceForegroundColor (readColor (colors, "unmatched-brace-foreground", textColor));
+    qsci->setSelectionForegroundColor (readColor (colors, "selection-foreground", paperColor));
+    qsci->setSelectionBackgroundColor (readColor (colors, "selection-background", textColor));
+    qsci->setEdgeColor (readColor (colors, "edge", textColor));
+  } catch (const std::exception &e) {
+    noColor ();
+  }
+}
+
+void ScintillaEditor::noColor () {
+  this->lexer->setPaper (Qt::white);
+  this->lexer->setColor (Qt::black);
+  qsci->setCaretWidth (2);
+  qsci->setCaretForegroundColor (Qt::black);
+  qsci->setMarkerBackgroundColor (QColor (255, 0, 0, 100), errMarkerNumber);
+  qsci->setMarkerBackgroundColor (QColor (150, 200, 255, 100), bmMarkerNumber); // light blue
+  qsci->setMarkerBackgroundColor (QColor (11, 156, 49, 100), selectionMarkerLevelNumber);
+  qsci->setMarkerBackgroundColor (QColor (11, 156, 49, 50), selectionMarkerLevelNumber + 1);
+  qsci->setMarkerBackgroundColor (QColor (11, 156, 49, 50), selectionMarkerLevelNumber + 2);
+  qsci->setMarkerBackgroundColor (QColor (11, 156, 49, 50), selectionMarkerLevelNumber + 3);
+  qsci->setMarkerBackgroundColor (QColor (11, 156, 49, 50), selectionMarkerLevelNumber + 4);
+  qsci->setMarkerBackgroundColor (QColor (11, 156, 49, 50), selectionMarkerLevelNumber + 5);
+  qsci->setMarkerBackgroundColor (QColor (150, 200, 255, 100), bmMarkerNumber); // light blue
+  qsci->setIndicatorForegroundColor (QColor (11, 156, 49, 100), selectionIndicatorIsActiveNumber);
+  qsci->setIndicatorOutlineColor (QColor (0, 0, 0, 255), selectionIndicatorIsActiveNumber);
+  qsci->setIndicatorForegroundColor (QColor (11, 156, 49, 50), selectionIndicatorIsActiveNumber + 1);
+  qsci->setIndicatorOutlineColor (QColor (0, 0, 0, 255), selectionIndicatorIsActiveNumber + 1);
+  qsci->setIndicatorForegroundColor (QColor (255, 128, 128, 100), selectionIndicatorIsImpactedNumber);
+  qsci->setIndicatorOutlineColor (QColor (0, 0, 0, 255), selectionIndicatorIsImpactedNumber);
+  qsci->setIndicatorForegroundColor (QColor (255, 128, 128, 80), selectionIndicatorIsImpactedNumber + 1);
+  qsci->setIndicatorOutlineColor (QColor (0, 0, 0, 255), selectionIndicatorIsImpactedNumber + 1);
+  qsci->setIndicatorForegroundColor (QColor (255, 128, 128, 60), selectionIndicatorIsImpactedNumber + 2);
+  qsci->setIndicatorOutlineColor (QColor (0, 0, 0, 255), selectionIndicatorIsImpactedNumber + 2);
+
+  qsci->setIndicatorForegroundColor (QColor (255, 0, 0, 128), errorIndicatorNumber); //red
+  qsci->setIndicatorOutlineColor (QColor (0, 0, 0, 255), errorIndicatorNumber); // only alpha part is used
+  qsci->setIndicatorForegroundColor (QColor (255, 255, 0, 128), findIndicatorNumber); //yellow
+  qsci->setIndicatorOutlineColor (QColor (0, 0, 0, 255), findIndicatorNumber); // only alpha part is used
+  qsci->setIndicatorForegroundColor (QColor (139, 24, 168, 128), hyperlinkIndicatorNumber); //violet
+  qsci->setIndicatorOutlineColor (QColor (0, 0, 0, 255), hyperlinkIndicatorNumber); // only alpha part is used
+  qsci->setIndicatorHoverForegroundColor (QColor (139, 24, 168, 128), hyperlinkIndicatorNumber); //violet
+  qsci->setCaretLineBackgroundColor (Qt::white);
+  qsci->setWhitespaceForegroundColor (Qt::black);
+  qsci->setSelectionForegroundColor (Qt::black);
+  qsci->setSelectionBackgroundColor (QColor ("LightSkyBlue"));
+  qsci->setMatchedBraceBackgroundColor (QColor ("LightBlue"));
+  qsci->setMatchedBraceForegroundColor (Qt::black);
+  qsci->setUnmatchedBraceBackgroundColor (QColor ("pink"));
+  qsci->setUnmatchedBraceForegroundColor (Qt::black);
+  qsci->setMarginsBackgroundColor (QColor ("whiteSmoke"));
+  qsci->setMarginsForegroundColor (QColor ("gray"));
+  qsci->setFoldMarginColors (QColor ("whiteSmoke"), QColor ("whiteSmoke"));
+  qsci->setEdgeColor (Qt::black);
+}
+
+void ScintillaEditor::enumerateColorSchemesInPath (ScintillaEditor::colorscheme_set_t &result_set, const fs::path &path) {
   const auto color_schemes = path / "color-schemes" / "editor";
 
-  if (fs::exists(color_schemes) && fs::is_directory(color_schemes)) {
-    for (const auto& dirEntry : boost::make_iterator_range(fs::directory_iterator{color_schemes}, {})) {
-      if (!fs::is_regular_file(dirEntry.status())) continue;
+  if (fs::exists (color_schemes) && fs::is_directory (color_schemes)) {
+    for (const auto &dirEntry : boost::make_iterator_range (fs::directory_iterator{color_schemes}, {})) {
+      if (!fs::is_regular_file (dirEntry.status ()))
+        continue;
 
-      const auto& path = dirEntry.path();
-      if (!(path.extension() == ".json")) continue;
+      const auto &path = dirEntry.path ();
+      if (!(path.extension () == ".json"))
+        continue;
 
-      auto colorScheme = std::make_shared<EditorColorScheme>(path);
-      if (colorScheme->valid()) {
-        result_set.emplace(colorScheme->index(), colorScheme);
+      auto colorScheme = std::make_shared<EditorColorScheme> (path);
+      if (colorScheme->valid ()) {
+        result_set.emplace (colorScheme->index (), colorScheme);
       }
     }
   }
 }
 
-ScintillaEditor::colorscheme_set_t ScintillaEditor::enumerateColorSchemes()
-{
+ScintillaEditor::colorscheme_set_t ScintillaEditor::enumerateColorSchemes () {
   colorscheme_set_t result_set;
 
-  enumerateColorSchemesInPath(result_set, PlatformUtils::resourceBasePath());
-  enumerateColorSchemesInPath(result_set, PlatformUtils::userConfigPath());
+  enumerateColorSchemesInPath (result_set, PlatformUtils::resourceBasePath ());
+  enumerateColorSchemesInPath (result_set, PlatformUtils::userConfigPath ());
 
   return result_set;
 }
 
-QStringList ScintillaEditor::colorSchemes()
-{
+QStringList ScintillaEditor::colorSchemes () {
   QStringList colorSchemes;
-  for (const auto& colorSchemeEntry : enumerateColorSchemes()) {
-    colorSchemes << colorSchemeEntry.second.get()->name();
+  for (const auto &colorSchemeEntry : enumerateColorSchemes ()) {
+    colorSchemes << colorSchemeEntry.second.get ()->name ();
   }
   colorSchemes << "Off";
 
   return colorSchemes;
 }
 
-bool ScintillaEditor::canUndo()
-{
-  return qsci->isUndoAvailable();
+bool ScintillaEditor::canUndo () {
+  return qsci->isUndoAvailable ();
 }
 
-void ScintillaEditor::setHighlightScheme(const QString& name)
-{
-  for (const auto& colorSchemeEntry : enumerateColorSchemes()) {
-    const auto colorScheme = colorSchemeEntry.second.get();
-    if (colorScheme->name() == name) {
-      setColormap(colorScheme);
+void ScintillaEditor::setHighlightScheme (const QString &name) {
+  for (const auto &colorSchemeEntry : enumerateColorSchemes ()) {
+    const auto colorScheme = colorSchemeEntry.second.get ();
+    if (colorScheme->name () == name) {
+      setColormap (colorScheme);
       return;
     }
   }
 
-  noColor();
+  noColor ();
 }
 
-void ScintillaEditor::insert(const QString& text)
-{
-  qsci->insert(text);
+void ScintillaEditor::insert (const QString &text) {
+  qsci->insert (text);
 }
 
-void ScintillaEditor::setText(const QString& text)
-{
-  qsci->selectAll(true);
-  qsci->replaceSelectedText(text);
+void ScintillaEditor::setText (const QString &text) {
+  qsci->selectAll (true);
+  qsci->replaceSelectedText (text);
 }
 
-void ScintillaEditor::undo()
-{
-  qsci->undo();
+void ScintillaEditor::undo () {
+  qsci->undo ();
 }
 
-void ScintillaEditor::redo()
-{
-  qsci->redo();
+void ScintillaEditor::redo () {
+  qsci->redo ();
 }
 
-void ScintillaEditor::cut()
-{
-  qsci->cut();
+void ScintillaEditor::cut () {
+  qsci->cut ();
 }
 
-void ScintillaEditor::copy()
-{
-  qsci->copy();
+void ScintillaEditor::copy () {
+  qsci->copy ();
 }
 
-void ScintillaEditor::paste()
-{
-  qsci->paste();
+void ScintillaEditor::paste () {
+  qsci->paste ();
 }
 
-void ScintillaEditor::zoomIn()
-{
-  qsci->zoomIn();
+void ScintillaEditor::zoomIn () {
+  qsci->zoomIn ();
 }
 
-void ScintillaEditor::zoomOut()
-{
-  qsci->zoomOut();
+void ScintillaEditor::zoomOut () {
+  qsci->zoomOut ();
 }
 
-void ScintillaEditor::initFont(const QString& fontName, uint size)
-{
-  this->currentFont = QFont(fontName, size);
-  this->currentFont.setFixedPitch(true);
-  this->lexer->setFont(this->currentFont);
-  qsci->setMarginsFont(this->currentFont);
-  onTextChanged(); // Update margin width
+void ScintillaEditor::initFont (const QString &fontName, uint size) {
+  this->currentFont = QFont (fontName, size);
+  this->currentFont.setFixedPitch (true);
+  this->lexer->setFont (this->currentFont);
+  qsci->setMarginsFont (this->currentFont);
+  onTextChanged (); // Update margin width
 }
 
-void ScintillaEditor::initMargin()
-{
-  connect(qsci, &QsciScintilla::textChanged, this, &ScintillaEditor::onTextChanged);
+void ScintillaEditor::initMargin () {
+  connect (qsci, &QsciScintilla::textChanged, this, &ScintillaEditor::onTextChanged);
 }
 
-void ScintillaEditor::onTextChanged()
-{
-  auto enableLineNumbers = Settings::Settings::enableLineNumbers.value();
+void ScintillaEditor::onTextChanged () {
+  auto enableLineNumbers = Settings::Settings::enableLineNumbers.value ();
   if (enableLineNumbers) {
-    qsci->setMarginWidth(numberMargin, QString(trunc(log10(qsci->lines()) + 2), '0'));
+    qsci->setMarginWidth (numberMargin, QString (trunc (log10 (qsci->lines ()) + 2), '0'));
   } else {
-    qsci->setMarginWidth(numberMargin, 6);
+    qsci->setMarginWidth (numberMargin, 6);
   }
-  qsci->setMarginLineNumbers(numberMargin, enableLineNumbers);
+  qsci->setMarginLineNumbers (numberMargin, enableLineNumbers);
 }
 
-int ScintillaEditor::updateFindIndicators(const QString& findText, bool visibility)
-{
+int ScintillaEditor::updateFindIndicators (const QString &findText, bool visibility) {
   int findwordcount{0};
 
-  qsci->SendScintilla(QsciScintilla::SCI_SETINDICATORCURRENT, findIndicatorNumber);
-  qsci->SendScintilla(qsci->SCI_INDICATORCLEARRANGE, 0, qsci->length());
+  qsci->SendScintilla (QsciScintilla::SCI_SETINDICATORCURRENT, findIndicatorNumber);
+  qsci->SendScintilla (qsci->SCI_INDICATORCLEARRANGE, 0, qsci->length ());
 
-  const auto txt = qsci->text().toUtf8();
-  const auto findTextUtf8 = findText.toUtf8();
-  auto pos = txt.indexOf(findTextUtf8);
-  auto len = findTextUtf8.length();
+  const auto txt = qsci->text ().toUtf8 ();
+  const auto findTextUtf8 = findText.toUtf8 ();
+  auto pos = txt.indexOf (findTextUtf8);
+  auto len = findTextUtf8.length ();
   if (visibility && len > 0) {
     while (pos != -1) {
       findwordcount++;
-      qsci->SendScintilla(qsci->SCI_SETINDICATORCURRENT, findIndicatorNumber);
-      qsci->SendScintilla(qsci->SCI_INDICATORFILLRANGE, pos, len);
-      pos = txt.indexOf(findTextUtf8, pos + len);
+      qsci->SendScintilla (qsci->SCI_SETINDICATORCURRENT, findIndicatorNumber);
+      qsci->SendScintilla (qsci->SCI_INDICATORFILLRANGE, pos, len);
+      pos = txt.indexOf (findTextUtf8, pos + len);
     }
   }
   return findwordcount;
 }
 
-bool ScintillaEditor::find(const QString& expr, bool findNext, bool findBackwards)
-{
+bool ScintillaEditor::find (const QString &expr, bool findNext, bool findBackwards) {
   int startline = -1, startindex = -1;
 
   // If findNext, start from the end of the current selection
-  if (qsci->hasSelectedText()) {
+  if (qsci->hasSelectedText ()) {
     int lineFrom, indexFrom, lineTo, indexTo;
-    qsci->getSelection(&lineFrom, &indexFrom, &lineTo, &indexTo);
+    qsci->getSelection (&lineFrom, &indexFrom, &lineTo, &indexTo);
 
-    startline = !(findBackwards xor findNext) ? std::min(lineFrom, lineTo) : std::max(lineFrom, lineTo);
-    startindex = !(findBackwards xor findNext) ? std::min(indexFrom, indexTo) : std::max(indexFrom, indexTo);
+    startline = !(findBackwards xor findNext) ? std::min (lineFrom, lineTo) : std::max (lineFrom, lineTo);
+    startindex = !(findBackwards xor findNext) ? std::min (indexFrom, indexTo) : std::max (indexFrom, indexTo);
   }
 
-  return qsci->findFirst(expr, false, false, false, true,
-                         !findBackwards, startline, startindex);
+  return qsci->findFirst (expr, false, false, false, true,
+                          !findBackwards, startline, startindex);
 }
 
-void ScintillaEditor::replaceSelectedText(const QString& newText)
-{
-  if ((qsci->selectedText() != newText)&&(qsci->hasSelectedText())) qsci->replaceSelectedText(newText);
+void ScintillaEditor::replaceSelectedText (const QString &newText) {
+  if ((qsci->selectedText () != newText) && (qsci->hasSelectedText ()))
+    qsci->replaceSelectedText (newText);
 }
 
-void ScintillaEditor::replaceAll(const QString& findText, const QString& replaceText)
-{
+void ScintillaEditor::replaceAll (const QString &findText, const QString &replaceText) {
   // We need to issue a Select All first due to a bug in QScintilla:
   // It doesn't update the find range when just doing findFirst() + findNext() causing the search
   // to end prematurely if the replaced string is larger than the selected string.
 #if QSCINTILLA_VERSION >= 0x020903
   // QScintilla bug seems to be fixed in 2.9.3
-  if (qsci->findFirst(findText,
-                      false /*re*/, false /*cs*/, false /*wo*/,
-                      false /*wrap*/, true /*forward*/, 0, 0)) {
+  if (qsci->findFirst (findText,
+                       false /*re*/, false /*cs*/, false /*wo*/,
+                       false /*wrap*/, true /*forward*/, 0, 0)) {
 #elif QSCINTILLA_VERSION >= 0x020700
-  qsci->selectAll();
-  if (qsci->findFirstInSelection(findText,
-                                 false /*re*/, false /*cs*/, false /*wo*/,
-                                 false /*wrap*/, true /*forward*/)) {
+  qsci->selectAll ();
+  if (qsci->findFirstInSelection (findText,
+                                  false /*re*/, false /*cs*/, false /*wo*/,
+                                  false /*wrap*/, true /*forward*/)) {
 #else
   // findFirstInSelection() was introduced in QScintilla 2.7
-  if (qsci->findFirst(findText,
-                      false /*re*/, false /*cs*/, false /*wo*/,
-                      false /*wrap*/, true /*forward*/, 0, 0)) {
+  if (qsci->findFirst (findText,
+                       false /*re*/, false /*cs*/, false /*wo*/,
+                       false /*wrap*/, true /*forward*/, 0, 0)) {
 #endif // if QSCINTILLA_VERSION >= 0x020903
-    qsci->replace(replaceText);
-    while (qsci->findNext()) {
-      qsci->replace(replaceText);
+    qsci->replace (replaceText);
+    while (qsci->findNext ()) {
+      qsci->replace (replaceText);
     }
   }
 }
 
-
-void ScintillaEditor::getRange(int *lineFrom, int *lineTo)
-{
+void ScintillaEditor::getRange (int *lineFrom, int *lineTo) {
   int indexFrom, indexTo;
-  if (qsci->hasSelectedText()) {
-    qsci->getSelection(lineFrom, &indexFrom, lineTo, &indexTo);
+  if (qsci->hasSelectedText ()) {
+    qsci->getSelection (lineFrom, &indexFrom, lineTo, &indexTo);
     if (indexTo == 0) {
       *lineTo = *lineTo - 1;
     }
   } else {
-    qsci->getCursorPosition(lineFrom, &indexFrom);
+    qsci->getCursorPosition (lineFrom, &indexFrom);
     *lineTo = *lineFrom;
   }
 }
 
-void ScintillaEditor::indentSelection()
-{
+void ScintillaEditor::indentSelection () {
   int lineFrom, lineTo;
-  qsci->beginUndoAction();
-  getRange(&lineFrom, &lineTo);
+  qsci->beginUndoAction ();
+  getRange (&lineFrom, &lineTo);
   for (int line = lineFrom; line <= lineTo; ++line) {
-    if (qsci->SendScintilla(QsciScintilla::SCI_GETLINEENDPOSITION, line) - qsci->SendScintilla(QsciScintilla::SCI_POSITIONFROMLINE, line) == 0) {
+    if (qsci->SendScintilla (QsciScintilla::SCI_GETLINEENDPOSITION, line) - qsci->SendScintilla (QsciScintilla::SCI_POSITIONFROMLINE, line) == 0) {
       continue;
     }
-    qsci->indent(line);
+    qsci->indent (line);
   }
   int nextLine = lineTo + 1;
-  while (qsci->SendScintilla(QsciScintilla::SCI_GETLINEVISIBLE, nextLine) == 0) {
-    if (qsci->SendScintilla(QsciScintilla::SCI_GETLINEENDPOSITION, nextLine) - qsci->SendScintilla(QsciScintilla::SCI_POSITIONFROMLINE, nextLine) == 0) {
+  while (qsci->SendScintilla (QsciScintilla::SCI_GETLINEVISIBLE, nextLine) == 0) {
+    if (qsci->SendScintilla (QsciScintilla::SCI_GETLINEENDPOSITION, nextLine) - qsci->SendScintilla (QsciScintilla::SCI_POSITIONFROMLINE, nextLine) == 0) {
       nextLine++;
       continue;
     }
-    qsci->indent(nextLine);
+    qsci->indent (nextLine);
     nextLine++;
   }
-  qsci->endUndoAction();
+  qsci->endUndoAction ();
 }
 
-void ScintillaEditor::unindentSelection()
-{
+void ScintillaEditor::unindentSelection () {
   int lineFrom, lineTo;
-  qsci->beginUndoAction();
-  getRange(&lineFrom, &lineTo);
+  qsci->beginUndoAction ();
+  getRange (&lineFrom, &lineTo);
   for (int line = lineFrom; line <= lineTo; ++line) {
-    if (qsci->SendScintilla(QsciScintilla::SCI_GETLINEENDPOSITION, line) - qsci->SendScintilla(QsciScintilla::SCI_POSITIONFROMLINE, line) == 0) {
+    if (qsci->SendScintilla (QsciScintilla::SCI_GETLINEENDPOSITION, line) - qsci->SendScintilla (QsciScintilla::SCI_POSITIONFROMLINE, line) == 0) {
       continue;
     }
-    qsci->unindent(line);
+    qsci->unindent (line);
   }
   int nextLine = lineTo + 1;
-  while (qsci->SendScintilla(QsciScintilla::SCI_GETLINEVISIBLE, nextLine) == 0) {
-    if (qsci->SendScintilla(QsciScintilla::SCI_GETLINEENDPOSITION, nextLine) - qsci->SendScintilla(QsciScintilla::SCI_POSITIONFROMLINE, nextLine) == 0) {
+  while (qsci->SendScintilla (QsciScintilla::SCI_GETLINEVISIBLE, nextLine) == 0) {
+    if (qsci->SendScintilla (QsciScintilla::SCI_GETLINEENDPOSITION, nextLine) - qsci->SendScintilla (QsciScintilla::SCI_POSITIONFROMLINE, nextLine) == 0) {
       nextLine++;
       continue;
     }
-    qsci->unindent(nextLine);
+    qsci->unindent (nextLine);
     nextLine++;
   }
-  qsci->endUndoAction();
+  qsci->endUndoAction ();
 }
 
-void ScintillaEditor::commentSelection()
-{
-  auto hasSelection = qsci->hasSelectedText();
+void ScintillaEditor::commentSelection () {
+  auto hasSelection = qsci->hasSelectedText ();
 
   int lineFrom, lineTo;
-  getRange(&lineFrom, &lineTo);
+  getRange (&lineFrom, &lineTo);
   for (int line = lineFrom; line <= lineTo; ++line) {
-    qsci->insertAt("//", line, 0);
+    qsci->insertAt ("//", line, 0);
   }
 
   if (hasSelection) {
-    qsci->setSelection(lineFrom, 0, lineTo, std::max(0, qsci->lineLength(lineTo) - 1));
+    qsci->setSelection (lineFrom, 0, lineTo, std::max (0, qsci->lineLength (lineTo) - 1));
   }
 }
 
-void ScintillaEditor::uncommentSelection()
-{
-  auto hasSelection = qsci->hasSelectedText();
+void ScintillaEditor::uncommentSelection () {
+  auto hasSelection = qsci->hasSelectedText ();
 
   int lineFrom, lineTo;
-  getRange(&lineFrom, &lineTo);
+  getRange (&lineFrom, &lineTo);
   for (int line = lineFrom; line <= lineTo; ++line) {
-    QString lineText = qsci->text(line);
-    if (lineText.startsWith("//")) {
-      qsci->setSelection(line, 0, line, 2);
-      qsci->removeSelectedText();
+    QString lineText = qsci->text (line);
+    if (lineText.startsWith ("//")) {
+      qsci->setSelection (line, 0, line, 2);
+      qsci->removeSelectedText ();
     }
   }
   if (hasSelection) {
-    qsci->setSelection(lineFrom, 0, lineTo, std::max(0, qsci->lineLength(lineTo) - 1));
+    qsci->setSelection (lineFrom, 0, lineTo, std::max (0, qsci->lineLength (lineTo) - 1));
   }
 }
 
-QString ScintillaEditor::selectedText()
-{
-  return qsci->selectedText();
+QString ScintillaEditor::selectedText () {
+  return qsci->selectedText ();
 }
 
-bool ScintillaEditor::eventFilter(QObject *obj, QEvent *e)
-{
-  if (e->type() == QEvent::KeyPress) {
-    auto keyEvent = static_cast<QKeyEvent *>(e);
-    if (keyEvent->key() == Qt::Key_Escape) {
-      emit escapePressed();
+bool ScintillaEditor::eventFilter (QObject *obj, QEvent *e) {
+  if (e->type () == QEvent::KeyPress) {
+    auto keyEvent = static_cast<QKeyEvent *> (e);
+    if (keyEvent->key () == Qt::Key_Escape) {
+      emit escapePressed ();
     }
   }
-  if (QGuiApplication::keyboardModifiers().testFlag(Qt::ControlModifier) || QGuiApplication::keyboardModifiers().testFlag(Qt::AltModifier)) {
+  if (QGuiApplication::keyboardModifiers ().testFlag (Qt::ControlModifier) || QGuiApplication::keyboardModifiers ().testFlag (Qt::AltModifier)) {
     if (!this->indicatorsActive) {
       this->indicatorsActive = true;
-      qsci->setIndicatorHoverStyle(QsciScintilla::PlainIndicator, hyperlinkIndicatorNumber);
+      qsci->setIndicatorHoverStyle (QsciScintilla::PlainIndicator, hyperlinkIndicatorNumber);
     }
   } else {
     if (this->indicatorsActive) {
       this->indicatorsActive = false;
-      qsci->setIndicatorHoverStyle(QsciScintilla::HiddenIndicator, hyperlinkIndicatorNumber);
+      qsci->setIndicatorHoverStyle (QsciScintilla::HiddenIndicator, hyperlinkIndicatorNumber);
     }
   }
 
-  bool enableNumberScrollWheel = Settings::Settings::enableNumberScrollWheel.value();
+  bool enableNumberScrollWheel = Settings::Settings::enableNumberScrollWheel.value ();
 
-  if (obj == qsci->viewport() && enableNumberScrollWheel) {
-    if (e->type() == QEvent::Wheel) {
-      auto *wheelEvent = static_cast<QWheelEvent *>(e);
-      PRINTDB("%s - modifier: %s", (e->type() == QEvent::Wheel?"Wheel Event":"") % (wheelEvent->modifiers() & Qt::AltModifier?"Alt":"Other Button"));
-      if (handleWheelEventNavigateNumber(wheelEvent)) {
-        qsci->SendScintilla(QsciScintilla::SCI_SETCARETWIDTH, 1);
+  if (obj == qsci->viewport () && enableNumberScrollWheel) {
+    if (e->type () == QEvent::Wheel) {
+      auto *wheelEvent = static_cast<QWheelEvent *> (e);
+      PRINTDB ("%s - modifier: %s", (e->type () == QEvent::Wheel ? "Wheel Event" : "") % (wheelEvent->modifiers () & Qt::AltModifier ? "Alt" : "Other Button"));
+      if (handleWheelEventNavigateNumber (wheelEvent)) {
+        qsci->SendScintilla (QsciScintilla::SCI_SETCARETWIDTH, 1);
         return true;
       }
     }
     return false;
   } else if (obj == qsci) {
-    if (e->type() == QEvent::KeyPress || e->type() == QEvent::KeyRelease) {
-      auto *keyEvent = static_cast<QKeyEvent *>(e);
-
-      PRINTDB("%10s - modifiers: %s %s %s %s %s %s",
-              (e->type() == QEvent::KeyPress ? "KeyPress" : "KeyRelease") %
-              (keyEvent->modifiers() & Qt::ShiftModifier ? "SHIFT" : "shift") %
-              (keyEvent->modifiers() & Qt::ControlModifier ? "CTRL" : "ctrl") %
-              (keyEvent->modifiers() & Qt::AltModifier ? "ALT" : "alt") %
-              (keyEvent->modifiers() & Qt::MetaModifier ? "META" : "meta") %
-              (keyEvent->modifiers() & Qt::KeypadModifier ? "KEYPAD" : "keypad") %
-              (keyEvent->modifiers() & Qt::GroupSwitchModifier ? "GROUP" : "group"));
-
-      if (handleKeyEventNavigateNumber(keyEvent)) {
+    if (e->type () == QEvent::KeyPress || e->type () == QEvent::KeyRelease) {
+      auto *keyEvent = static_cast<QKeyEvent *> (e);
+
+      PRINTDB ("%10s - modifiers: %s %s %s %s %s %s",
+               (e->type () == QEvent::KeyPress ? "KeyPress" : "KeyRelease") %
+                 (keyEvent->modifiers () & Qt::ShiftModifier ? "SHIFT" : "shift") %
+                 (keyEvent->modifiers () & Qt::ControlModifier ? "CTRL" : "ctrl") %
+                 (keyEvent->modifiers () & Qt::AltModifier ? "ALT" : "alt") %
+                 (keyEvent->modifiers () & Qt::MetaModifier ? "META" : "meta") %
+                 (keyEvent->modifiers () & Qt::KeypadModifier ? "KEYPAD" : "keypad") %
+                 (keyEvent->modifiers () & Qt::GroupSwitchModifier ? "GROUP" : "group"));
+
+      if (handleKeyEventNavigateNumber (keyEvent)) {
         return true;
       }
-      if (handleKeyEventBlockCopy(keyEvent)) {
+      if (handleKeyEventBlockCopy (keyEvent)) {
         return true;
       }
-      if (handleKeyEventBlockMove(keyEvent)) {
+      if (handleKeyEventBlockMove (keyEvent)) {
         return true;
       }
     }
     return false;
-  } else return EditorInterface::eventFilter(obj, e);
+  } else
+    return EditorInterface::eventFilter (obj, e);
 
   return false;
 }
 
-bool ScintillaEditor::handleKeyEventBlockMove(QKeyEvent *keyEvent)
-{
+bool ScintillaEditor::handleKeyEventBlockMove (QKeyEvent *keyEvent) {
   unsigned int modifiers = Qt::ControlModifier | Qt::GroupSwitchModifier;
 
-  if (keyEvent->type() != QEvent::KeyRelease) {
+  if (keyEvent->type () != QEvent::KeyRelease) {
     return false;
   }
 
-  if (keyEvent->modifiers() != modifiers) {
+  if (keyEvent->modifiers () != modifiers) {
     return false;
   }
 
-  if (keyEvent->key() != Qt::Key_Up && keyEvent->key() != Qt::Key_Down) {
+  if (keyEvent->key () != Qt::Key_Up && keyEvent->key () != Qt::Key_Down) {
     return false;
   }
 
   int line, index;
-  qsci->getCursorPosition(&line, &index);
+  qsci->getCursorPosition (&line, &index);
   int lineFrom, indexFrom, lineTo, indexTo;
-  qsci->getSelection(&lineFrom, &indexFrom, &lineTo, &indexTo);
+  qsci->getSelection (&lineFrom, &indexFrom, &lineTo, &indexTo);
   if (lineFrom < 0) {
     lineTo = lineFrom = line;
     indexFrom = indexTo = 0;
@@ -1058,57 +1002,56 @@ bool ScintillaEditor::handleKeyEventBlockMove(QKeyEvent *keyEvent)
     lineTo--;
   }
 
-  bool up = keyEvent->key() == Qt::Key_Up;
+  bool up = keyEvent->key () == Qt::Key_Up;
   int directionOffset = up ? -1 : 1;
   int lineToMove = up ? lineFrom - 1 : lineTo + 1;
   if (lineToMove < 0) {
     return false;
   }
 
-  qsci->beginUndoAction();
-  QString textToMove = qsci->text(lineToMove);
+  qsci->beginUndoAction ();
+  QString textToMove = qsci->text (lineToMove);
   QString text;
   for (int idx = lineFrom; idx <= lineTo; ++idx) {
-    text.append(qsci->text(idx));
+    text.append (qsci->text (idx));
   }
-  if (lineToMove >= qsci->lines() - 1) {
-    textToMove.append('\n');
+  if (lineToMove >= qsci->lines () - 1) {
+    textToMove.append ('\n');
   }
-  text.insert(up ? text.length() : 0, textToMove);
-  qsci->setSelection(std::min(lineToMove, lineFrom), 0, std::max(lineToMove, lineTo) + 1, 0);
-  qsci->replaceSelectedText(text);
-  qsci->setCursorPosition(line + directionOffset, index);
-  qsci->setSelection(lineFrom + directionOffset, indexFrom, selectionLineTo + directionOffset, indexTo);
-  qsci->endUndoAction();
+  text.insert (up ? text.length () : 0, textToMove);
+  qsci->setSelection (std::min (lineToMove, lineFrom), 0, std::max (lineToMove, lineTo) + 1, 0);
+  qsci->replaceSelectedText (text);
+  qsci->setCursorPosition (line + directionOffset, index);
+  qsci->setSelection (lineFrom + directionOffset, indexFrom, selectionLineTo + directionOffset, indexTo);
+  qsci->endUndoAction ();
   return true;
 }
 
-bool ScintillaEditor::handleKeyEventBlockCopy(QKeyEvent *keyEvent)
-{
+bool ScintillaEditor::handleKeyEventBlockCopy (QKeyEvent *keyEvent) {
   unsigned int modifiers = Qt::ControlModifier | Qt::ShiftModifier;
 
-  if (keyEvent->type() != QEvent::KeyRelease) {
+  if (keyEvent->type () != QEvent::KeyRelease) {
     return false;
   }
 
-  if (keyEvent->modifiers() != modifiers) {
+  if (keyEvent->modifiers () != modifiers) {
     return false;
   }
 
-  if (keyEvent->key() != Qt::Key_Up && keyEvent->key() != Qt::Key_Down) {
+  if (keyEvent->key () != Qt::Key_Up && keyEvent->key () != Qt::Key_Down) {
     return false;
   }
 
   int line, index;
-  qsci->getCursorPosition(&line, &index);
+  qsci->getCursorPosition (&line, &index);
   int lineFrom, indexFrom, lineTo, indexTo;
-  qsci->getSelection(&lineFrom, &indexFrom, &lineTo, &indexTo);
+  qsci->getSelection (&lineFrom, &indexFrom, &lineTo, &indexTo);
   if (lineFrom < 0) {
     lineTo = lineFrom = line;
     indexFrom = indexTo = 0;
   }
 
-  bool up = keyEvent->key() == Qt::Key_Up;
+  bool up = keyEvent->key () == Qt::Key_Up;
   int selectionLineTo = 0;
   if (lineTo > lineFrom && indexTo == 0) {
     lineTo--;
@@ -1118,23 +1061,22 @@ bool ScintillaEditor::handleKeyEventBlockCopy(QKeyEvent *keyEvent)
   int selectionLineFrom = up ? lineFrom : lineTo + 1;
   selectionLineTo += up ? lineTo : 2 * lineTo - lineFrom + 1;
 
-  qsci->beginUndoAction();
+  qsci->beginUndoAction ();
   QString text;
   for (int line = lineFrom; line <= lineTo; ++line) {
-    text += qsci->text(line);
+    text += qsci->text (line);
   }
-  if (lineTo + 1 >= qsci->lines()) {
-    text.insert(0, '\n');
+  if (lineTo + 1 >= qsci->lines ()) {
+    text.insert (0, '\n');
   }
-  qsci->insertAt(text, lineTo + 1, 0);
-  qsci->setCursorPosition(cursorLine, index);
-  qsci->setSelection(selectionLineFrom, indexFrom, selectionLineTo, indexTo);
-  qsci->endUndoAction();
+  qsci->insertAt (text, lineTo + 1, 0);
+  qsci->setCursorPosition (cursorLine, index);
+  qsci->setSelection (selectionLineFrom, indexFrom, selectionLineTo, indexTo);
+  qsci->endUndoAction ();
   return true;
 }
 
-bool ScintillaEditor::handleKeyEventNavigateNumber(QKeyEvent *keyEvent)
-{
+bool ScintillaEditor::handleKeyEventNavigateNumber (QKeyEvent *keyEvent) {
   static bool previewAfterUndo = false;
 
 #ifdef Q_OS_MACOS
@@ -1142,30 +1084,31 @@ bool ScintillaEditor::handleKeyEventNavigateNumber(QKeyEvent *keyEvent)
 #else
   unsigned int navigateOnNumberModifiers = Qt::AltModifier;
 #endif
-  if (keyEvent->modifiers() == navigateOnNumberModifiers) {
-    switch (keyEvent->key()) {
+  if (keyEvent->modifiers () == navigateOnNumberModifiers) {
+    switch (keyEvent->key ()) {
     case Qt::Key_Left:
     case Qt::Key_Right:
-      if (keyEvent->type() == QEvent::KeyPress) {
-        navigateOnNumber(keyEvent->key());
+      if (keyEvent->type () == QEvent::KeyPress) {
+        navigateOnNumber (keyEvent->key ());
       }
       return true;
 
     case Qt::Key_Up:
     case Qt::Key_Down:
-      if (keyEvent->type() == QEvent::KeyPress) {
-        if (modifyNumber(keyEvent->key())) {
+      if (keyEvent->type () == QEvent::KeyPress) {
+        if (modifyNumber (keyEvent->key ())) {
           previewAfterUndo = true;
         }
       }
       return true;
     }
   }
-  if (previewAfterUndo && keyEvent->type() == QEvent::KeyPress) {
-    int k = keyEvent->key() | keyEvent->modifiers();
-    auto *cmd = qsci->standardCommands()->boundTo(k);
-    if (cmd && (cmd->command() == QsciCommand::Undo || cmd->command() == QsciCommand::Redo)) QTimer::singleShot(0, this, &ScintillaEditor::previewRequest);
-    else if (cmd || !keyEvent->text().isEmpty()) {
+  if (previewAfterUndo && keyEvent->type () == QEvent::KeyPress) {
+    int k = keyEvent->key () | keyEvent->modifiers ();
+    auto *cmd = qsci->standardCommands ()->boundTo (k);
+    if (cmd && (cmd->command () == QsciCommand::Undo || cmd->command () == QsciCommand::Redo))
+      QTimer::singleShot (0, this, &ScintillaEditor::previewRequest);
+    else if (cmd || !keyEvent->text ().isEmpty ()) {
       // any insert or command (but not undo/redo) cancels the preview after undo
       previewAfterUndo = false;
     }
@@ -1173,32 +1116,31 @@ bool ScintillaEditor::handleKeyEventNavigateNumber(QKeyEvent *keyEvent)
   return false;
 }
 
-bool ScintillaEditor::handleWheelEventNavigateNumber(QWheelEvent *wheelEvent)
-{
-  const auto& modifierNumberScrollWheel = Settings::Settings::modifierNumberScrollWheel.value();
+bool ScintillaEditor::handleWheelEventNavigateNumber (QWheelEvent *wheelEvent) {
+  const auto &modifierNumberScrollWheel = Settings::Settings::modifierNumberScrollWheel.value ();
   bool modifier;
   static bool previewAfterUndo = false;
 
   if (modifierNumberScrollWheel == "Alt") {
-    modifier = wheelEvent->modifiers() & Qt::AltModifier;
+    modifier = wheelEvent->modifiers () & Qt::AltModifier;
   } else if (modifierNumberScrollWheel == "Left Mouse Button") {
-    modifier = wheelEvent->buttons() & Qt::LeftButton;
+    modifier = wheelEvent->buttons () & Qt::LeftButton;
   } else {
-    modifier = (wheelEvent->buttons() & Qt::LeftButton) | (wheelEvent->modifiers() & Qt::AltModifier);
+    modifier = (wheelEvent->buttons () & Qt::LeftButton) | (wheelEvent->modifiers () & Qt::AltModifier);
   }
 
   if (modifier) {
-    int delta = wheelEvent->angleDelta().y() != 0
-      ? wheelEvent->angleDelta().y()
-      : wheelEvent->angleDelta().x();
+    int delta = wheelEvent->angleDelta ().y () != 0
+                  ? wheelEvent->angleDelta ().y ()
+                  : wheelEvent->angleDelta ().x ();
 
     if (delta < 0) {
-      if (modifyNumber(Qt::Key_Down)) {
+      if (modifyNumber (Qt::Key_Down)) {
         previewAfterUndo = true;
       }
     } else {
       // delta > 0
-      if (modifyNumber(Qt::Key_Up)) {
+      if (modifyNumber (Qt::Key_Up)) {
         previewAfterUndo = true;
       }
     }
@@ -1207,10 +1149,11 @@ bool ScintillaEditor::handleWheelEventNavigateNumber(QWheelEvent *wheelEvent)
   }
 
   if (previewAfterUndo) {
-    int k = wheelEvent->buttons() & Qt::LeftButton;
-    auto *cmd = qsci->standardCommands()->boundTo(k);
-    if (cmd && (cmd->command() == QsciCommand::Undo || cmd->command() == QsciCommand::Redo)) QTimer::singleShot(0, this, &ScintillaEditor::previewRequest);
-    else if (cmd || wheelEvent->angleDelta().y()) {
+    int k = wheelEvent->buttons () & Qt::LeftButton;
+    auto *cmd = qsci->standardCommands ()->boundTo (k);
+    if (cmd && (cmd->command () == QsciCommand::Undo || cmd->command () == QsciCommand::Redo))
+      QTimer::singleShot (0, this, &ScintillaEditor::previewRequest);
+    else if (cmd || wheelEvent->angleDelta ().y ()) {
       // any insert or command (but not undo/redo) cancels the preview after undo
       previewAfterUndo = false;
     }
@@ -1218,370 +1161,372 @@ bool ScintillaEditor::handleWheelEventNavigateNumber(QWheelEvent *wheelEvent)
   return false;
 }
 
-void ScintillaEditor::navigateOnNumber(int key)
-{
+void ScintillaEditor::navigateOnNumber (int key) {
   int line, index;
-  qsci->getCursorPosition(&line, &index);
-  auto text = qsci->text(line);
-  auto left = text.left(index);
-  auto dotOnLeft = left.contains(QRegularExpression("\\.\\d*$"));
+  qsci->getCursorPosition (&line, &index);
+  auto text = qsci->text (line);
+  auto left = text.left (index);
+  auto dotOnLeft = left.contains (QRegularExpression ("\\.\\d*$"));
   auto dotJustLeft = index > 1 && text[index - 2] == '.';
   auto dotJustRight = text[index] == '.';
-  auto numOnLeft = left.contains(QRegularExpression("\\d\\.?$")) || left.endsWith("-.");
-  auto numOnRight = text.indexOf(QRegularExpression("\\.?\\d"), index) == index;
+  auto numOnLeft = left.contains (QRegularExpression ("\\d\\.?$")) || left.endsWith ("-.");
+  auto numOnRight = text.indexOf (QRegularExpression ("\\.?\\d"), index) == index;
 
   switch (key) {
   case Qt::Key_Left:
-    if (numOnLeft) qsci->setCursorPosition(line, index - (dotJustLeft?2:1));
+    if (numOnLeft)
+      qsci->setCursorPosition (line, index - (dotJustLeft ? 2 : 1));
     break;
 
   case Qt::Key_Right:
-    if (numOnRight) qsci->setCursorPosition(line, index + (dotJustRight?2:1));
+    if (numOnRight)
+      qsci->setCursorPosition (line, index + (dotJustRight ? 2 : 1));
     else if (numOnLeft) {
       // add trailing zero
       if (!dotOnLeft) {
-        qsci->insert(".0");
+        qsci->insert (".0");
         index++;
       } else {
-        qsci->insert("0");
+        qsci->insert ("0");
       }
-      qsci->setCursorPosition(line, index + 1);
+      qsci->setCursorPosition (line, index + 1);
     }
     break;
   }
 }
 
-bool ScintillaEditor::modifyNumber(int key)
-{
+bool ScintillaEditor::modifyNumber (int key) {
   int line, index;
-  qsci->getCursorPosition(&line, &index);
-  auto text = qsci->text(line);
+  qsci->getCursorPosition (&line, &index);
+  auto text = qsci->text (line);
   int lineFrom, indexFrom, lineTo, indexTo;
-  qsci->getSelection(&lineFrom, &indexFrom, &lineTo, &indexTo);
-  auto hadSelection = qsci->hasSelectedText();
-  qsci->SendScintilla(QsciScintilla::SCI_SETEMPTYSELECTION);
-  qsci->setCursorPosition(line, index);
-
-  auto begin = text.left(index).indexOf(QRegularExpression(R"([-+]?\d*\.?\d*$)"));
-
-  QRegularExpression rx(QRegularExpression::anchoredPattern(QString("[_a-zA-Z]")));
-  auto check = text.mid(begin - 1, 1);
-  if (rx.match(check).hasMatch()) return false;
-
-  auto end = text.indexOf(QRegularExpression("[^0-9.]"), index);
-  if (end < 0) end = text.length();
-  auto nr = text.mid(begin, end - begin);
-  if (!(nr.contains(QRegularExpression(R"(^[-+]?\d*\.?\d+$)")) && nr.contains(QRegularExpression("\\d"))) ) return false;
-  auto sign = nr[0] == '+'||nr[0] == '-';
-  if (nr.endsWith('.')) nr = nr.left(nr.length() - 1);
+  qsci->getSelection (&lineFrom, &indexFrom, &lineTo, &indexTo);
+  auto hadSelection = qsci->hasSelectedText ();
+  qsci->SendScintilla (QsciScintilla::SCI_SETEMPTYSELECTION);
+  qsci->setCursorPosition (line, index);
+
+  auto begin = text.left (index).indexOf (QRegularExpression (R"([-+]?\d*\.?\d*$)"));
+
+  QRegularExpression rx (QRegularExpression::anchoredPattern (QString ("[_a-zA-Z]")));
+  auto check = text.mid (begin - 1, 1);
+  if (rx.match (check).hasMatch ())
+    return false;
+
+  auto end = text.indexOf (QRegularExpression ("[^0-9.]"), index);
+  if (end < 0)
+    end = text.length ();
+  auto nr = text.mid (begin, end - begin);
+  if (!(nr.contains (QRegularExpression (R"(^[-+]?\d*\.?\d+$)")) && nr.contains (QRegularExpression ("\\d"))))
+    return false;
+  auto sign = nr[0] == '+' || nr[0] == '-';
+  if (nr.endsWith ('.'))
+    nr = nr.left (nr.length () - 1);
   auto curpos = index - begin;
-  if (curpos == 0 || (curpos == 1 && (nr[0] == '+' || nr[0] == '-'))) return false;
-  auto dotpos = nr.indexOf('.');
-  auto decimals = dotpos < 0?0:nr.length() - dotpos - 1;
-  auto number = (dotpos < 0)?nr.toLongLong():(nr.left(dotpos) + nr.mid(dotpos + 1)).toLongLong();
-  auto tail = nr.length() - curpos;
-  auto exponent = tail - ((dotpos >= curpos)?1:0);
-  long long int step = GlobalPreferences::inst()->getValue("editor/stepSize").toInt();
-  for (int i = exponent; i > 0; i--) step *= 10;
+  if (curpos == 0 || (curpos == 1 && (nr[0] == '+' || nr[0] == '-')))
+    return false;
+  auto dotpos = nr.indexOf ('.');
+  auto decimals = dotpos < 0 ? 0 : nr.length () - dotpos - 1;
+  auto number = (dotpos < 0) ? nr.toLongLong () : (nr.left (dotpos) + nr.mid (dotpos + 1)).toLongLong ();
+  auto tail = nr.length () - curpos;
+  auto exponent = tail - ((dotpos >= curpos) ? 1 : 0);
+  long long int step = GlobalPreferences::inst ()->getValue ("editor/stepSize").toInt ();
+  for (int i = exponent; i > 0; i--)
+    step *= 10;
 
   switch (key) {
-  case Qt::Key_Up:   number += step; break;
-  case Qt::Key_Down: number -= step; break;
+  case Qt::Key_Up:
+    number += step;
+    break;
+  case Qt::Key_Down:
+    number -= step;
+    break;
   }
   auto negative = number < 0;
-  if (negative) number = -number;
-  auto newnr = QString::number(number);
+  if (negative)
+    number = -number;
+  auto newnr = QString::number (number);
   if (decimals) {
-    if (newnr.length() <= decimals) newnr.prepend(QString(decimals - newnr.length() + 1, '0'));
-    newnr = newnr.left(newnr.length() - decimals) + "." + newnr.right(decimals);
-  }
-  if (tail > newnr.length()) {
-    newnr.prepend(QString(tail - newnr.length(), '0'));
-  }
-  if (negative) newnr.prepend('-');
-  else if (sign) newnr.prepend('+');
-  qsci->beginUndoAction();
-  qsci->setSelection(line, begin, line, end);
-  qsci->replaceSelectedText(newnr);
-
-  qsci->selectAll(false);
+    if (newnr.length () <= decimals)
+      newnr.prepend (QString (decimals - newnr.length () + 1, '0'));
+    newnr = newnr.left (newnr.length () - decimals) + "." + newnr.right (decimals);
+  }
+  if (tail > newnr.length ()) {
+    newnr.prepend (QString (tail - newnr.length (), '0'));
+  }
+  if (negative)
+    newnr.prepend ('-');
+  else if (sign)
+    newnr.prepend ('+');
+  qsci->beginUndoAction ();
+  qsci->setSelection (line, begin, line, end);
+  qsci->replaceSelectedText (newnr);
+
+  qsci->selectAll (false);
   if (hadSelection) {
-    qsci->setSelection(lineFrom, indexFrom, lineTo, indexTo);
+    qsci->setSelection (lineFrom, indexFrom, lineTo, indexTo);
   }
-  qsci->setCursorPosition(line, begin + newnr.length() - tail);
-  qsci->endUndoAction();
-  emit previewRequest();
+  qsci->setCursorPosition (line, begin + newnr.length () - tail);
+  qsci->endUndoAction ();
+  emit previewRequest ();
   return true;
 }
 
-void ScintillaEditor::onUserListSelected(const int, const QString& text)
-{
-  if (!templateMap.contains(text)) {
+void ScintillaEditor::onUserListSelected (const int, const QString &text) {
+  if (!templateMap.contains (text)) {
     return;
   }
 
   QString tabReplace = "";
-  if (Settings::Settings::indentStyle.value() == "Spaces") {
-    auto spCount = Settings::Settings::indentationWidth.value();
-    tabReplace = QString(spCount, ' ');
+  if (Settings::Settings::indentStyle.value () == "Spaces") {
+    auto spCount = Settings::Settings::indentationWidth.value ();
+    tabReplace = QString (spCount, ' ');
   }
 
-  ScadTemplate& t = templateMap[text];
-  QString content = t.get_text();
-  int cursor_offset = t.get_cursor_offset();
+  ScadTemplate &t = templateMap[text];
+  QString content = t.get_text ();
+  int cursor_offset = t.get_cursor_offset ();
 
   if (cursor_offset < 0) {
-    if (tabReplace.size() != 0) content.replace("\t", tabReplace);
+    if (tabReplace.size () != 0)
+      content.replace ("\t", tabReplace);
 
-    cursor_offset = content.indexOf(ScintillaEditor::cursorPlaceHolder);
-    content.remove(cursorPlaceHolder);
+    cursor_offset = content.indexOf (ScintillaEditor::cursorPlaceHolder);
+    content.remove (cursorPlaceHolder);
 
-    if (cursor_offset == -1) cursor_offset = content.size();
+    if (cursor_offset == -1)
+      cursor_offset = content.size ();
   } else {
-    if (tabReplace.size() != 0) {
-      int tbCount = content.left(cursor_offset).count("\t");
-      cursor_offset += tbCount * (tabReplace.size() - 1);
-      content.replace("\t", tabReplace);
+    if (tabReplace.size () != 0) {
+      int tbCount = content.left (cursor_offset).count ("\t");
+      cursor_offset += tbCount * (tabReplace.size () - 1);
+      content.replace ("\t", tabReplace);
     }
   }
 
-  qsci->insert(content);
+  qsci->insert (content);
 
   int line, index;
-  qsci->getCursorPosition(&line, &index);
-  int pos = qsci->positionFromLineIndex(line, index);
+  qsci->getCursorPosition (&line, &index);
+  int pos = qsci->positionFromLineIndex (line, index);
 
   pos += cursor_offset;
   int indent_line = line;
   int indent_width = index;
-  qsci->lineIndexFromPosition(pos, &line, &index);
-  qsci->setCursorPosition(line, index);
+  qsci->lineIndexFromPosition (pos, &line, &index);
+  qsci->setCursorPosition (line, index);
 
-  int lines = t.get_text().count("\n");
+  int lines = t.get_text ().count ("\n");
   QString indent_char = " ";
-  if (Settings::Settings::indentStyle.value() == "Tabs") indent_char = "\t";
+  if (Settings::Settings::indentStyle.value () == "Tabs")
+    indent_char = "\t";
 
   for (int a = 0; a < lines; ++a) {
-    qsci->insertAt(indent_char.repeated(indent_width), indent_line + a + 1, 0);
+    qsci->insertAt (indent_char.repeated (indent_width), indent_line + a + 1, 0);
   }
 }
 
-void ScintillaEditor::onAutocompleteChanged(bool state)
-{
+void ScintillaEditor::onAutocompleteChanged (bool state) {
   if (state) {
-    qsci->setAutoCompletionSource(QsciScintilla::AcsAPIs);
-    qsci->setAutoCompletionFillupsEnabled(true);
-    qsci->setCallTipsVisible(10);
-    qsci->setCallTipsStyle(QsciScintilla::CallTipsContext);
+    qsci->setAutoCompletionSource (QsciScintilla::AcsAPIs);
+    qsci->setAutoCompletionFillupsEnabled (true);
+    qsci->setCallTipsVisible (10);
+    qsci->setCallTipsStyle (QsciScintilla::CallTipsContext);
   } else {
-    qsci->setAutoCompletionSource(QsciScintilla::AcsNone);
-    qsci->setAutoCompletionFillupsEnabled(false);
-    qsci->setCallTipsStyle(QsciScintilla::CallTipsNone);
+    qsci->setAutoCompletionSource (QsciScintilla::AcsNone);
+    qsci->setAutoCompletionFillupsEnabled (false);
+    qsci->setCallTipsStyle (QsciScintilla::CallTipsNone);
   }
 }
 
-void ScintillaEditor::onCharacterThresholdChanged(int val)
-{
-  qsci->setAutoCompletionThreshold(val <= 0 ? 1 : val);
+void ScintillaEditor::onCharacterThresholdChanged (int val) {
+  qsci->setAutoCompletionThreshold (val <= 0 ? 1 : val);
 }
 
-void ScintillaEditor::resetHighlighting(){
-  qsci->recolor(); //lex and restyle the whole text
+void ScintillaEditor::resetHighlighting () {
+  qsci->recolor (); //lex and restyle the whole text
 
   //remove all indicators
-  qsci->SendScintilla(QsciScintilla::SCI_SETINDICATORCURRENT, hyperlinkIndicatorNumber);
-  qsci->SendScintilla(QsciScintilla::SCI_INDICATORCLEARRANGE, 0, qsci->length());
+  qsci->SendScintilla (QsciScintilla::SCI_SETINDICATORCURRENT, hyperlinkIndicatorNumber);
+  qsci->SendScintilla (QsciScintilla::SCI_INDICATORCLEARRANGE, 0, qsci->length ());
 }
 
-void ScintillaEditor::setIndicator(const std::vector<IndicatorData>& indicatorData)
-{
+void ScintillaEditor::setIndicator (const std::vector<IndicatorData> &indicatorData) {
   this->indicatorData = indicatorData;
 
   int idx = 0;
-  for (const auto& data : indicatorData) {
-    int startPos = qsci->positionFromLineIndex(data.first_line - 1, data.first_col - 1);
-    int stopPos = qsci->positionFromLineIndex(data.last_line - 1, data.last_col - 1);
+  for (const auto &data : indicatorData) {
+    int startPos = qsci->positionFromLineIndex (data.first_line - 1, data.first_col - 1);
+    int stopPos = qsci->positionFromLineIndex (data.last_line - 1, data.last_col - 1);
 
     int nrOfChars = stopPos - startPos;
-    qsci->SendScintilla(QsciScintilla::SCI_SETINDICATORVALUE, idx + hyperlinkIndicatorOffset);
+    qsci->SendScintilla (QsciScintilla::SCI_SETINDICATORVALUE, idx + hyperlinkIndicatorOffset);
 
-    qsci->SendScintilla(QsciScintilla::SCI_INDICATORFILLRANGE, startPos, nrOfChars);
+    qsci->SendScintilla (QsciScintilla::SCI_INDICATORFILLRANGE, startPos, nrOfChars);
 
     idx++;
   }
 }
 
-void ScintillaEditor::onIndicatorClicked(int line, int col, Qt::KeyboardModifiers /*state*/)
-{
-  qsci->SendScintilla(QsciScintilla::SCI_SETINDICATORCURRENT, hyperlinkIndicatorNumber);
+void ScintillaEditor::onIndicatorClicked (int line, int col, Qt::KeyboardModifiers /*state*/) {
+  qsci->SendScintilla (QsciScintilla::SCI_SETINDICATORCURRENT, hyperlinkIndicatorNumber);
 
-  int pos = qsci->positionFromLineIndex(line, col);
-  int val = qsci->SendScintilla(QsciScintilla::SCI_INDICATORVALUEAT, ScintillaEditor::hyperlinkIndicatorNumber, pos);
+  int pos = qsci->positionFromLineIndex (line, col);
+  int val = qsci->SendScintilla (QsciScintilla::SCI_INDICATORVALUEAT, ScintillaEditor::hyperlinkIndicatorNumber, pos);
 
   // checking if indicator clicked is hyperlinkIndicator
-  if (val >= hyperlinkIndicatorOffset && val <= hyperlinkIndicatorOffset + static_cast<int>(indicatorData.size())) {
+  if (val >= hyperlinkIndicatorOffset && val <= hyperlinkIndicatorOffset + static_cast<int> (indicatorData.size ())) {
     if (indicatorsActive) {
-      emit hyperlinkIndicatorClicked(val - hyperlinkIndicatorOffset);
+      emit hyperlinkIndicatorClicked (val - hyperlinkIndicatorOffset);
     }
   }
 }
 
-void ScintillaEditor::onIndicatorReleased(int line, int col, Qt::KeyboardModifiers /*state*/)
-{
-  qsci->SendScintilla(QsciScintilla::SCI_SETINDICATORCURRENT, hyperlinkIndicatorNumber);
+void ScintillaEditor::onIndicatorReleased (int line, int col, Qt::KeyboardModifiers /*state*/) {
+  qsci->SendScintilla (QsciScintilla::SCI_SETINDICATORCURRENT, hyperlinkIndicatorNumber);
 
-  int pos = qsci->positionFromLineIndex(line, col);
-  int val = qsci->SendScintilla(QsciScintilla::SCI_INDICATORVALUEAT, ScintillaEditor::hyperlinkIndicatorNumber, pos);
+  int pos = qsci->positionFromLineIndex (line, col);
+  int val = qsci->SendScintilla (QsciScintilla::SCI_INDICATORVALUEAT, ScintillaEditor::hyperlinkIndicatorNumber, pos);
 
   // checking if indicator clicked is hyperlinkIndicator
-  if (val >= hyperlinkIndicatorOffset && val <= hyperlinkIndicatorOffset + static_cast<int>(indicatorData.size())) {
+  if (val >= hyperlinkIndicatorOffset && val <= hyperlinkIndicatorOffset + static_cast<int> (indicatorData.size ())) {
     if (!indicatorsActive) {
-      QTimer::singleShot(0, this, [this] {
-        QToolTip::showText(QCursor::pos(), "Use <b>CTRL + Click</b> to open the file", this, rect(), toolTipDuration());
+      QTimer::singleShot (0, this, [this] {
+        QToolTip::showText (QCursor::pos (), "Use <b>CTRL + Click</b> to open the file", this, rect (), toolTipDuration ());
       });
     }
   }
 }
 
-void ScintillaEditor::setCursorPosition(int line, int col)
-{
-  qsci->ensureLineVisible(std::max(line - setCursorPositionVisibleLines, 0));
-  qsci->ensureLineVisible(std::min(line + setCursorPositionVisibleLines, qsci->lines() - 1));
+void ScintillaEditor::setCursorPosition (int line, int col) {
+  qsci->ensureLineVisible (std::max (line - setCursorPositionVisibleLines, 0));
+  qsci->ensureLineVisible (std::min (line + setCursorPositionVisibleLines, qsci->lines () - 1));
 
-  qsci->setCursorPosition(line, col);
+  qsci->setCursorPosition (line, col);
 }
 
-void ScintillaEditor::updateSymbolMarginVisibility()
-{
-  if (qsci->markerFindNext(0, 1 << bmMarkerNumber | 1 << errMarkerNumber | 1 << selectionMarkerLevelNumber |
-                           1 << (selectionMarkerLevelNumber + 1) | 1 << (selectionMarkerLevelNumber + 2) |
-                           1 << (selectionMarkerLevelNumber + 3) | 1 << (selectionMarkerLevelNumber + 4) |
-                           1 << (selectionMarkerLevelNumber + 5)) < 0) {
-    qsci->setMarginWidth(symbolMargin, 0);
+void ScintillaEditor::updateSymbolMarginVisibility () {
+  if (qsci->markerFindNext (0, 1 << bmMarkerNumber | 1 << errMarkerNumber | 1 << selectionMarkerLevelNumber |
+                                 1 << (selectionMarkerLevelNumber + 1) | 1 << (selectionMarkerLevelNumber + 2) |
+                                 1 << (selectionMarkerLevelNumber + 3) | 1 << (selectionMarkerLevelNumber + 4) |
+                                 1 << (selectionMarkerLevelNumber + 5)) < 0) {
+    qsci->setMarginWidth (symbolMargin, 0);
   } else {
-    qsci->setMarginWidth(symbolMargin, "0");
+    qsci->setMarginWidth (symbolMargin, "0");
   }
 }
 
-void ScintillaEditor::toggleBookmark()
-{
+void ScintillaEditor::toggleBookmark () {
   int line, index;
-  qsci->getCursorPosition(&line, &index);
+  qsci->getCursorPosition (&line, &index);
 
-  unsigned int state = qsci->markersAtLine(line);
+  unsigned int state = qsci->markersAtLine (line);
 
-  if ((state & (1 << bmMarkerNumber)) == 0) qsci->markerAdd(line, bmMarkerNumber);
-  else qsci->markerDelete(line, bmMarkerNumber);
+  if ((state & (1 << bmMarkerNumber)) == 0)
+    qsci->markerAdd (line, bmMarkerNumber);
+  else
+    qsci->markerDelete (line, bmMarkerNumber);
 
-  updateSymbolMarginVisibility();
+  updateSymbolMarginVisibility ();
 }
 
-void ScintillaEditor::findMarker(int findStartOffset, int wrapStart, const std::function<int(int)>& findMarkerFunc)
-{
+void ScintillaEditor::findMarker (int findStartOffset, int wrapStart, const std::function<int (int)> &findMarkerFunc) {
   int line, index;
-  qsci->getCursorPosition(&line, &index);
-  line = findMarkerFunc(line + findStartOffset);
+  qsci->getCursorPosition (&line, &index);
+  line = findMarkerFunc (line + findStartOffset);
   if (line == -1) {
-    line = findMarkerFunc(wrapStart); // wrap around
+    line = findMarkerFunc (wrapStart); // wrap around
   }
   if (line != -1) {
     // make sure we don't wrap into new line
-    int len = qsci->text(line).remove(QRegularExpression("[\n\r]$")).length();
-    int col = std::min(index, len);
-    qsci->setCursorPosition(line, col);
+    int len = qsci->text (line).remove (QRegularExpression ("[\n\r]$")).length ();
+    int col = std::min (index, len);
+    qsci->setCursorPosition (line, col);
   }
 }
 
-void ScintillaEditor::nextBookmark()
-{
-  findMarker(1, 0, [this](int line){
-    return qsci->markerFindNext(line, 1 << bmMarkerNumber);
+void ScintillaEditor::nextBookmark () {
+  findMarker (1, 0, [this] (int line) {
+    return qsci->markerFindNext (line, 1 << bmMarkerNumber);
   });
 }
 
-void ScintillaEditor::prevBookmark()
-{
-  findMarker(-1, qsci->lines() - 1, [this](int line){
-    return qsci->markerFindPrevious(line, 1 << bmMarkerNumber);
+void ScintillaEditor::prevBookmark () {
+  findMarker (-1, qsci->lines () - 1, [this] (int line) {
+    return qsci->markerFindPrevious (line, 1 << bmMarkerNumber);
   });
 }
 
-void ScintillaEditor::jumpToNextError()
-{
-  findMarker(1, 0, [this](int line){
-    return qsci->markerFindNext(line, 1 << errMarkerNumber);
+void ScintillaEditor::jumpToNextError () {
+  findMarker (1, 0, [this] (int line) {
+    return qsci->markerFindNext (line, 1 << errMarkerNumber);
   });
 }
 
-void ScintillaEditor::setFocus()
-{
-  qsci->setFocus();
-  qsci->SendScintilla(QsciScintilla::SCI_SETFOCUS, true);
+void ScintillaEditor::setFocus () {
+  qsci->setFocus ();
+  qsci->SendScintilla (QsciScintilla::SCI_SETFOCUS, true);
 }
 
 /**
  * @brief Highlights a part of the text according to the limits described in the parameters
  */
-void ScintillaEditor::setSelectionIndicatorStatus(EditorSelectionIndicatorStatus status, int level, int lineFrom, int colFrom, int lineTo, int colTo)
-{
+void ScintillaEditor::setSelectionIndicatorStatus (EditorSelectionIndicatorStatus status, int level, int lineFrom, int colFrom, int lineTo, int colTo) {
   // replace all the indicators at given lines/column with the new one
-  clearSelectionIndicators(lineFrom, colFrom, lineTo, colTo);
+  clearSelectionIndicators (lineFrom, colFrom, lineTo, colTo);
 
   int indicator_base_index = 0;
   int indicator_level = 0;
   int mark_level = 0;
   if (status == EditorSelectionIndicatorStatus::SELECTED) {
     indicator_base_index = selectionIndicatorIsActiveNumber;
-    mark_level = (level > 5)?5:level;
-    indicator_level = (level > 1)?1:level;
+    mark_level = (level > 5) ? 5 : level;
+    indicator_level = (level > 1) ? 1 : level;
   } else {
     indicator_base_index = selectionIndicatorIsImpactedNumber;
-    indicator_level = (level > 2)?2:level;
+    indicator_level = (level > 2) ? 2 : level;
   }
 
-  clearSelectionIndicators(lineFrom, colFrom, lineTo, colTo);
-  qsci->fillIndicatorRange(lineFrom, colFrom, lineTo, colTo,  indicator_base_index + indicator_level);
+  clearSelectionIndicators (lineFrom, colFrom, lineTo, colTo);
+  qsci->fillIndicatorRange (lineFrom, colFrom, lineTo, colTo, indicator_base_index + indicator_level);
 
   if (status == EditorSelectionIndicatorStatus::SELECTED) {
-    qsci->ensureLineVisible(std::max(lineFrom - setCursorPositionVisibleLines, 0));
-    qsci->ensureLineVisible(std::min(lineFrom + setCursorPositionVisibleLines, qsci->lines() - 1));
+    qsci->ensureLineVisible (std::max (lineFrom - setCursorPositionVisibleLines, 0));
+    qsci->ensureLineVisible (std::min (lineFrom + setCursorPositionVisibleLines, qsci->lines () - 1));
 
     // replace the marker at provide line with a new one.
-    qsci->markerDelete(lineFrom);
+    qsci->markerDelete (lineFrom);
 
-    qsci->markerAdd(lineFrom, selectionMarkerLevelNumber + mark_level);
-    updateSymbolMarginVisibility();
+    qsci->markerAdd (lineFrom, selectionMarkerLevelNumber + mark_level);
+    updateSymbolMarginVisibility ();
   }
 }
 
 /**
  * @brief Unhighlight all the selection indicators.
  */
-void ScintillaEditor::clearAllSelectionIndicators()
-{
+void ScintillaEditor::clearAllSelectionIndicators () {
   // remove all the indicator in the document.
   int line, column;
-  qsci->lineIndexFromPosition(qsci->length(), &line, &column);
-  clearSelectionIndicators(0, 0, line, column);
+  qsci->lineIndexFromPosition (qsci->length (), &line, &column);
+  clearSelectionIndicators (0, 0, line, column);
 
   // remove all the markers
-  qsci->markerDeleteAll(selectionMarkerLevelNumber);
-  qsci->markerDeleteAll(selectionMarkerLevelNumber + 1);
-  qsci->markerDeleteAll(selectionMarkerLevelNumber + 2);
-  qsci->markerDeleteAll(selectionMarkerLevelNumber + 3);
-  qsci->markerDeleteAll(selectionMarkerLevelNumber + 4);
-  qsci->markerDeleteAll(selectionMarkerLevelNumber + 5);
+  qsci->markerDeleteAll (selectionMarkerLevelNumber);
+  qsci->markerDeleteAll (selectionMarkerLevelNumber + 1);
+  qsci->markerDeleteAll (selectionMarkerLevelNumber + 2);
+  qsci->markerDeleteAll (selectionMarkerLevelNumber + 3);
+  qsci->markerDeleteAll (selectionMarkerLevelNumber + 4);
+  qsci->markerDeleteAll (selectionMarkerLevelNumber + 5);
 }
 
 /**
  * @brief Unhighlight all the texts for DM
  */
-void ScintillaEditor::clearSelectionIndicators(int lineFrom, int colFrom, int lineTo, int colTo)
-{
-  qsci->clearIndicatorRange(lineFrom, colFrom, lineTo, colTo, selectionIndicatorIsImpactedNumber);
-  qsci->clearIndicatorRange(lineFrom, colFrom, lineTo, colTo, selectionIndicatorIsImpactedNumber + 1);
-  qsci->clearIndicatorRange(lineFrom, colFrom, lineTo, colTo, selectionIndicatorIsImpactedNumber + 2);
+void ScintillaEditor::clearSelectionIndicators (int lineFrom, int colFrom, int lineTo, int colTo) {
+  qsci->clearIndicatorRange (lineFrom, colFrom, lineTo, colTo, selectionIndicatorIsImpactedNumber);
+  qsci->clearIndicatorRange (lineFrom, colFrom, lineTo, colTo, selectionIndicatorIsImpactedNumber + 1);
+  qsci->clearIndicatorRange (lineFrom, colFrom, lineTo, colTo, selectionIndicatorIsImpactedNumber + 2);
 
-  qsci->clearIndicatorRange(lineFrom, colFrom, lineTo, colTo, selectionIndicatorIsActiveNumber);
-  qsci->clearIndicatorRange(lineFrom, colFrom, lineTo, colTo, selectionIndicatorIsActiveNumber + 1);
+  qsci->clearIndicatorRange (lineFrom, colFrom, lineTo, colTo, selectionIndicatorIsActiveNumber);
+  qsci->clearIndicatorRange (lineFrom, colFrom, lineTo, colTo, selectionIndicatorIsActiveNumber + 1);
 }
diff --git a/src/gui/ScintillaEditor.h b/src/gui/ScintillaEditor.h
index 1dde96618..8516d58a6 100644
--- a/src/gui/ScintillaEditor.h
+++ b/src/gui/ScintillaEditor.h
@@ -26,8 +26,7 @@
 class ScadLexer;
 class ScadLexer2;
 
-#define ENABLE_LEXERTL  1
-
+#define ENABLE_LEXERTL 1
 
 class EditorColorScheme
 {
@@ -39,13 +38,13 @@ private:
   int _index;
 
 public:
-  EditorColorScheme(const fs::path& path);
-  virtual ~EditorColorScheme() = default;
+  EditorColorScheme (const fs::path &path);
+  virtual ~EditorColorScheme () = default;
 
-  const QString& name() const;
-  int index() const;
-  bool valid() const;
-  const boost::property_tree::ptree& propertyTree() const;
+  const QString &name () const;
+  int index () const;
+  bool valid () const;
+  const boost::property_tree::ptree &propertyTree () const;
 };
 
 class ScintillaEditor : public EditorInterface
@@ -55,106 +54,106 @@ class ScintillaEditor : public EditorInterface
   using colorscheme_set_t = std::multimap<int, std::shared_ptr<EditorColorScheme>, std::less<>>;
 
 public:
-  ScintillaEditor(QWidget *parent);
+  ScintillaEditor (QWidget *parent);
   QsciScintilla *qsci;
-  QString toPlainText() override;
-  void initMargin();
-  void initLexer();
-
-  QString selectedText() override;
-  int updateFindIndicators(const QString& findText, bool visibility = true) override;
-  bool find(const QString&, bool findNext = false, bool findBackwards = false) override;
-  void replaceSelectedText(const QString&) override;
-  void replaceAll(const QString& findText, const QString& replaceText) override;
-  QStringList colorSchemes() override;
-  bool canUndo() override;
-  void addTemplate() override;
-  void resetHighlighting() override;
-  void setIndicator(const std::vector<IndicatorData>& indicatorData) override;
-  QMenu *createStandardContextMenu() override;
-  QPoint mapToGlobal(const QPoint&) override;
-
-  void setCursorPosition(int line, int col) override;
-  void setSelectionIndicatorStatus(EditorSelectionIndicatorStatus satuts, int level, int lineFrom, int colFrom, int lineTo, int colTo) override;
-  void clearAllSelectionIndicators() override;
-  void clearSelectionIndicators(int lineFrom, int colFrom, int lineTo, int colTo);
-
-  void setFocus() override;
-  void setupAutoComplete(const bool forceOff = false);
+  QString toPlainText () override;
+  void initMargin ();
+  void initLexer ();
+
+  QString selectedText () override;
+  int updateFindIndicators (const QString &findText, bool visibility = true) override;
+  bool find (const QString &, bool findNext = false, bool findBackwards = false) override;
+  void replaceSelectedText (const QString &) override;
+  void replaceAll (const QString &findText, const QString &replaceText) override;
+  QStringList colorSchemes () override;
+  bool canUndo () override;
+  void addTemplate () override;
+  void resetHighlighting () override;
+  void setIndicator (const std::vector<IndicatorData> &indicatorData) override;
+  QMenu *createStandardContextMenu () override;
+  QPoint mapToGlobal (const QPoint &) override;
+
+  void setCursorPosition (int line, int col) override;
+  void setSelectionIndicatorStatus (EditorSelectionIndicatorStatus satuts, int level, int lineFrom, int colFrom, int lineTo, int colTo) override;
+  void clearAllSelectionIndicators () override;
+  void clearSelectionIndicators (int lineFrom, int colFrom, int lineTo, int colTo);
+
+  void setFocus () override;
+  void setupAutoComplete (const bool forceOff = false);
 
 private:
-  void getRange(int *lineFrom, int *lineTo);
-  void setColormap(const EditorColorScheme *colorScheme);
-  int readInt(const boost::property_tree::ptree& pt, const std::string& name,
-              const int defaultValue);
-  std::string readString(const boost::property_tree::ptree& pt, const std::string& name,
-                         const std::string& defaultValue);
-  QColor readColor(const boost::property_tree::ptree& pt, const std::string& name,
-                   const QColor& defaultColor);
-  void enumerateColorSchemesInPath(colorscheme_set_t& result_set, const fs::path& path);
-  colorscheme_set_t enumerateColorSchemes();
-
-  bool eventFilter(QObject *obj, QEvent *event) override;
-  bool handleKeyEventNavigateNumber(QKeyEvent *);
-  bool handleWheelEventNavigateNumber(QWheelEvent *);
-  bool handleKeyEventBlockCopy(QKeyEvent *);
-  bool handleKeyEventBlockMove(QKeyEvent *);
-  void navigateOnNumber(int key);
-  bool modifyNumber(int key);
-  void noColor();
+  void getRange (int *lineFrom, int *lineTo);
+  void setColormap (const EditorColorScheme *colorScheme);
+  int readInt (const boost::property_tree::ptree &pt, const std::string &name,
+               const int defaultValue);
+  std::string readString (const boost::property_tree::ptree &pt, const std::string &name,
+                          const std::string &defaultValue);
+  QColor readColor (const boost::property_tree::ptree &pt, const std::string &name,
+                    const QColor &defaultColor);
+  void enumerateColorSchemesInPath (colorscheme_set_t &result_set, const fs::path &path);
+  colorscheme_set_t enumerateColorSchemes ();
+
+  bool eventFilter (QObject *obj, QEvent *event) override;
+  bool handleKeyEventNavigateNumber (QKeyEvent *);
+  bool handleWheelEventNavigateNumber (QWheelEvent *);
+  bool handleKeyEventBlockCopy (QKeyEvent *);
+  bool handleKeyEventBlockMove (QKeyEvent *);
+  void navigateOnNumber (int key);
+  bool modifyNumber (int key);
+  void noColor ();
 
 #if ENABLE_LEXERTL
-  void setLexer(ScadLexer2 *lexer);
+  void setLexer (ScadLexer2 *lexer);
 #else
-  void setLexer(ScadLexer *lexer);
+  void setLexer (ScadLexer *lexer);
 #endif
-  void replaceSelectedText(QString&);
-  void addTemplate(const fs::path& path);
-  void updateSymbolMarginVisibility();
-  void findMarker(int, int, const std::function<int(int)>&);
+  void replaceSelectedText (QString &);
+  void addTemplate (const fs::path &path);
+  void updateSymbolMarginVisibility ();
+  void findMarker (int, int, const std::function<int (int)> &);
 
 signals:
-  void previewRequest();
-  void hyperlinkIndicatorClicked(int val);
-  void uriDropped(const QUrl&);
+  void previewRequest ();
+  void hyperlinkIndicatorClicked (int val);
+  void uriDropped (const QUrl &);
 
 public slots:
-  void zoomIn() override;
-  void zoomOut() override;
-  void setPlainText(const QString&) override;
-  void setContentModified(bool) override;
-  bool isContentModified() override;
-  void highlightError(int) override;
-  void unhighlightLastError() override;
-  void setHighlightScheme(const QString&) override;
-  void indentSelection() override;
-  void unindentSelection() override;
-  void commentSelection() override;
-  void uncommentSelection() override;
-  void insert(const QString&) override;
-  void setText(const QString&) override;
-  void undo() override;
-  void redo() override;
-  void cut() override;
-  void copy() override;
-  void paste() override;
-  void initFont(const QString&, uint) override;
-  void displayTemplates() override;
-  void foldUnfold() override;
-  void toggleBookmark() override;
-  void nextBookmark() override;
-  void prevBookmark() override;
-  void jumpToNextError() override;
-  void applySettings();
-  void onAutocompleteChanged(bool state);
-  void onCharacterThresholdChanged(int val);
+  void zoomIn () override;
+  void zoomOut () override;
+  void setPlainText (const QString &) override;
+  void setContentModified (bool) override;
+  bool isContentModified () override;
+  void highlightError (int) override;
+  void unhighlightLastError () override;
+  void setHighlightScheme (const QString &) override;
+  void indentSelection () override;
+  void unindentSelection () override;
+  void commentSelection () override;
+  void uncommentSelection () override;
+  void insert (const QString &) override;
+  void setText (const QString &) override;
+  void undo () override;
+  void redo () override;
+  void cut () override;
+  void copy () override;
+  void paste () override;
+  void initFont (const QString &, uint) override;
+  void displayTemplates () override;
+  void foldUnfold () override;
+  void toggleBookmark () override;
+  void nextBookmark () override;
+  void prevBookmark () override;
+  void jumpToNextError () override;
+  void applySettings ();
+  void onAutocompleteChanged (bool state);
+  void onCharacterThresholdChanged (int val);
 
 private slots:
-  void onTextChanged();
-  void onUserListSelected(const int id, const QString& text);
-  void fireModificationChanged();
-  void onIndicatorClicked(int line, int col, Qt::KeyboardModifiers state);
-  void onIndicatorReleased(int line, int col, Qt::KeyboardModifiers state);
+  void onTextChanged ();
+  void onUserListSelected (const int id, const QString &text);
+  void fireModificationChanged ();
+  void onIndicatorClicked (int line, int col, Qt::KeyboardModifiers state);
+  void onIndicatorReleased (int line, int col, Qt::KeyboardModifiers state);
 
 private:
   QVBoxLayout *scintillaLayout;
diff --git a/src/gui/SettingsWriter.cc b/src/gui/SettingsWriter.cc
index 4b7f3e9bd..ef0dd65f6 100644
--- a/src/gui/SettingsWriter.cc
+++ b/src/gui/SettingsWriter.cc
@@ -30,15 +30,15 @@
 #include <QString>
 #include <string>
 
-void SettingsWriter::handle(Settings::SettingsEntryBase& entry) const {
+void SettingsWriter::handle (Settings::SettingsEntryBase &entry) const {
   QSettingsCached settings;
-  std::string key = entry.category() + "/" + entry.name();
-  if (entry.isDefault()) {
-    settings.remove(QString::fromStdString(key));
-    PRINTDB("SettingsWriter D: %s", key.c_str());
+  std::string key = entry.category () + "/" + entry.name ();
+  if (entry.isDefault ()) {
+    settings.remove (QString::fromStdString (key));
+    PRINTDB ("SettingsWriter D: %s", key.c_str ());
   } else {
-    const auto encoded = entry.encode();
-    settings.setValue(QString::fromStdString(key), QString::fromStdString(encoded));
-    PRINTDB("SettingsWriter W: %s = '%s'", key.c_str() % encoded.c_str());
+    const auto encoded = entry.encode ();
+    settings.setValue (QString::fromStdString (key), QString::fromStdString (encoded));
+    PRINTDB ("SettingsWriter W: %s = '%s'", key.c_str () % encoded.c_str ());
   }
 }
diff --git a/src/gui/SettingsWriter.h b/src/gui/SettingsWriter.h
index 25e7e3d99..c3b5890d1 100644
--- a/src/gui/SettingsWriter.h
+++ b/src/gui/SettingsWriter.h
@@ -30,5 +30,5 @@
 class SettingsWriter : public Settings::SettingsVisitor
 {
 public:
-  void handle(Settings::SettingsEntryBase& entry) const override;
+  void handle (Settings::SettingsEntryBase &entry) const override;
 };
diff --git a/src/gui/SparkleAutoUpdater.h b/src/gui/SparkleAutoUpdater.h
index 297621bdb..240d6c7a7 100644
--- a/src/gui/SparkleAutoUpdater.h
+++ b/src/gui/SparkleAutoUpdater.h
@@ -11,19 +11,20 @@
 class SparkleAutoUpdater : public AutoUpdater
 {
   Q_OBJECT;
+
 public:
-  SparkleAutoUpdater();
-  ~SparkleAutoUpdater();
+  SparkleAutoUpdater ();
+  ~SparkleAutoUpdater ();
 
-  void checkForUpdates();
-  void setAutomaticallyChecksForUpdates(bool on);
-  bool automaticallyChecksForUpdates();
-  void setEnableSnapshots(bool on);
-  bool enableSnapshots();
-  QString lastUpdateCheckDate();
+  void checkForUpdates ();
+  void setAutomaticallyChecksForUpdates (bool on);
+  bool automaticallyChecksForUpdates ();
+  void setEnableSnapshots (bool on);
+  bool enableSnapshots ();
+  QString lastUpdateCheckDate ();
 
 private:
-  void updateFeed();
+  void updateFeed ();
 
   class Private;
   Private *d;
diff --git a/src/gui/TabManager.cc b/src/gui/TabManager.cc
index d262057ed..cd0d71288 100644
--- a/src/gui/TabManager.cc
+++ b/src/gui/TabManager.cc
@@ -28,471 +28,439 @@
 
 #include <cstddef>
 
-TabManager::TabManager(MainWindow *o, const QString& filename)
-{
+TabManager::TabManager (MainWindow *o, const QString &filename) {
   par = o;
 
-  tabWidget = new QTabWidget();
-  tabWidget->setTabsClosable(true);
-  tabWidget->setMovable(true);
-  tabWidget->setContextMenuPolicy(Qt::CustomContextMenu);
+  tabWidget = new QTabWidget ();
+  tabWidget->setTabsClosable (true);
+  tabWidget->setMovable (true);
+  tabWidget->setContextMenuPolicy (Qt::CustomContextMenu);
 
-  connect(tabWidget, &QTabWidget::tabCloseRequested, this, &TabManager::closeTabRequested);
-  connect(tabWidget, &QTabWidget::customContextMenuRequested, this, &TabManager::showTabHeaderContextMenu);
+  connect (tabWidget, &QTabWidget::tabCloseRequested, this, &TabManager::closeTabRequested);
+  connect (tabWidget, &QTabWidget::customContextMenuRequested, this, &TabManager::showTabHeaderContextMenu);
 
-  connect(tabWidget, &QTabWidget::currentChanged, this, &TabManager::stopAnimation);
-  connect(tabWidget, &QTabWidget::currentChanged, this, &TabManager::updateFindState);
-  connect(tabWidget, &QTabWidget::currentChanged, this, &TabManager::tabSwitched);
+  connect (tabWidget, &QTabWidget::currentChanged, this, &TabManager::stopAnimation);
+  connect (tabWidget, &QTabWidget::currentChanged, this, &TabManager::updateFindState);
+  connect (tabWidget, &QTabWidget::currentChanged, this, &TabManager::tabSwitched);
 
-  createTab(filename);
+  createTab (filename);
 
   // Disable the closing button for the first tabbar
-  setTabsCloseButtonVisibility(0, false);
+  setTabsCloseButtonVisibility (0, false);
 }
 
-QTabBar::ButtonPosition TabManager::getClosingButtonPosition()
-{
-  auto bar = tabWidget->tabBar();
-  return (QTabBar::ButtonPosition)bar->style()->styleHint(QStyle::SH_TabBar_CloseButtonPosition, nullptr, bar);
+QTabBar::ButtonPosition TabManager::getClosingButtonPosition () {
+  auto bar = tabWidget->tabBar ();
+  return (QTabBar::ButtonPosition)bar->style ()->styleHint (QStyle::SH_TabBar_CloseButtonPosition, nullptr, bar);
 }
 
-void TabManager::setTabsCloseButtonVisibility(int indice, bool isVisible)
-{
+void TabManager::setTabsCloseButtonVisibility (int indice, bool isVisible) {
   // Depending on the system the closing button can be on the right or left side
   // of the tab header.
-  auto button = tabWidget->tabBar()->tabButton(indice, getClosingButtonPosition());
-  if (button) button->setVisible(isVisible);
+  auto button = tabWidget->tabBar ()->tabButton (indice, getClosingButtonPosition ());
+  if (button)
+    button->setVisible (isVisible);
 }
 
-QWidget *TabManager::getTabContent()
-{
-  assert(tabWidget != nullptr);
+QWidget *TabManager::getTabContent () {
+  assert (tabWidget != nullptr);
   return tabWidget;
 }
 
-void TabManager::tabSwitched(int x)
-{
-  assert(tabWidget != nullptr);
+void TabManager::tabSwitched (int x) {
+  assert (tabWidget != nullptr);
 
-  editor = (EditorInterface *)tabWidget->widget(x);
+  editor = (EditorInterface *)tabWidget->widget (x);
 
-  auto numberOfOpenTabs = tabWidget->count();
+  auto numberOfOpenTabs = tabWidget->count ();
   // Hides all the closing button except the one on the currently focused editor
   for (int idx = 0; idx < numberOfOpenTabs; ++idx) {
     bool isVisible = idx == x && numberOfOpenTabs > 1;
-    setTabsCloseButtonVisibility(idx, isVisible);
+    setTabsCloseButtonVisibility (idx, isVisible);
   }
 
-  emit currentEditorChanged(editor);
+  emit currentEditorChanged (editor);
 }
 
-void TabManager::closeTabRequested(int x)
-{
-  assert(tabWidget != nullptr);
-  if (!maybeSave(x)) return;
+void TabManager::closeTabRequested (int x) {
+  assert (tabWidget != nullptr);
+  if (!maybeSave (x))
+    return;
 
-  auto *closingEditor = qobject_cast<EditorInterface *>(tabWidget->widget(x));
-  assert(closingEditor != nullptr);
+  auto *closingEditor = qobject_cast<EditorInterface *> (tabWidget->widget (x));
+  assert (closingEditor != nullptr);
 
-  emit editorAboutToClose(closingEditor);
+  emit editorAboutToClose (closingEditor);
 
-  editorList.remove(closingEditor);
-  tabWidget->removeTab(x);
-  emit tabCountChanged(editorList.size());
+  editorList.remove (closingEditor);
+  tabWidget->removeTab (x);
+  emit tabCountChanged (editorList.size ());
 
   delete closingEditor->parameterWidget;
   delete closingEditor;
 }
 
-void TabManager::closeCurrentTab()
-{
-  assert(tabWidget != nullptr);
+void TabManager::closeCurrentTab () {
+  assert (tabWidget != nullptr);
 
   /* Close tab or close the current window if only one tab is open. */
-  if (tabWidget->count() > 1) this->closeTabRequested(tabWidget->currentIndex());
-  else par->close();
+  if (tabWidget->count () > 1)
+    this->closeTabRequested (tabWidget->currentIndex ());
+  else
+    par->close ();
 }
 
-void TabManager::nextTab()
-{
-  assert(tabWidget != nullptr);
-  tabWidget->setCurrentIndex((tabWidget->currentIndex() + 1) % tabWidget->count());
+void TabManager::nextTab () {
+  assert (tabWidget != nullptr);
+  tabWidget->setCurrentIndex ((tabWidget->currentIndex () + 1) % tabWidget->count ());
 }
 
-void TabManager::prevTab()
-{
-  assert(tabWidget != nullptr);
-  tabWidget->setCurrentIndex((tabWidget->currentIndex() + tabWidget->count() - 1) % tabWidget->count());
+void TabManager::prevTab () {
+  assert (tabWidget != nullptr);
+  tabWidget->setCurrentIndex ((tabWidget->currentIndex () + tabWidget->count () - 1) % tabWidget->count ());
 }
 
-void TabManager::actionNew()
-{
-  if (!par->editorDock->isVisible()) par->editorDock->setVisible(true);   //if editor hidden, make it visible
-  createTab("");
+void TabManager::actionNew () {
+  if (!par->editorDock->isVisible ())
+    par->editorDock->setVisible (true); //if editor hidden, make it visible
+  createTab ("");
 }
 
-void TabManager::open(const QString& filename)
-{
-  assert(!filename.isEmpty());
+void TabManager::open (const QString &filename) {
+  assert (!filename.isEmpty ());
 
-  for (auto edt: editorList) {
+  for (auto edt : editorList) {
     if (filename == edt->filepath) {
-      tabWidget->setCurrentWidget(edt);
+      tabWidget->setCurrentWidget (edt);
       return;
     }
   }
 
-  if (editor->filepath.isEmpty() && !editor->isContentModified() && !editor->parameterWidget->isModified()) {
-    openTabFile(filename);
+  if (editor->filepath.isEmpty () && !editor->isContentModified () && !editor->parameterWidget->isModified ()) {
+    openTabFile (filename);
   } else {
-    createTab(filename);
+    createTab (filename);
   }
 }
 
-void TabManager::createTab(const QString& filename)
-{
-  assert(par != nullptr);
+void TabManager::createTab (const QString &filename) {
+  assert (par != nullptr);
 
-  auto scintillaEditor = new ScintillaEditor(tabWidget);
+  auto scintillaEditor = new ScintillaEditor (tabWidget);
   editor = scintillaEditor;
   par->activeEditor = editor;
-  editor->parameterWidget = new ParameterWidget(par->parameterDock);
-  connect(editor->parameterWidget, &ParameterWidget::parametersChanged, par, &MainWindow::actionRenderPreview);
-  par->parameterDock->setWidget(editor->parameterWidget);
+  editor->parameterWidget = new ParameterWidget (par->parameterDock);
+  connect (editor->parameterWidget, &ParameterWidget::parametersChanged, par, &MainWindow::actionRenderPreview);
+  par->parameterDock->setWidget (editor->parameterWidget);
 
   // clearing default mapping of keyboard shortcut for font size
-  QsciCommandSet *qcmdset = scintillaEditor->qsci->standardCommands();
-  QsciCommand *qcmd = qcmdset->boundTo(Qt::ControlModifier | Qt::Key_Plus);
-  qcmd->setKey(0);
-  qcmd = qcmdset->boundTo(Qt::ControlModifier | Qt::Key_Minus);
-  qcmd->setKey(0);
-
-  connect(scintillaEditor, &ScintillaEditor::uriDropped, par, &MainWindow::handleFileDrop);
-  connect(scintillaEditor, &ScintillaEditor::previewRequest, par, &MainWindow::actionRenderPreview);
-  connect(editor, &EditorInterface::showContextMenuEvent, this, &TabManager::showContextMenuEvent);
-  connect(editor, &EditorInterface::focusIn, this, [ this ]() {
-    par->setLastFocus(editor);
+  QsciCommandSet *qcmdset = scintillaEditor->qsci->standardCommands ();
+  QsciCommand *qcmd = qcmdset->boundTo (Qt::ControlModifier | Qt::Key_Plus);
+  qcmd->setKey (0);
+  qcmd = qcmdset->boundTo (Qt::ControlModifier | Qt::Key_Minus);
+  qcmd->setKey (0);
+
+  connect (scintillaEditor, &ScintillaEditor::uriDropped, par, &MainWindow::handleFileDrop);
+  connect (scintillaEditor, &ScintillaEditor::previewRequest, par, &MainWindow::actionRenderPreview);
+  connect (editor, &EditorInterface::showContextMenuEvent, this, &TabManager::showContextMenuEvent);
+  connect (editor, &EditorInterface::focusIn, this, [this] () {
+    par->setLastFocus (editor);
   });
 
-  connect(GlobalPreferences::inst(), &Preferences::editorConfigChanged, scintillaEditor, &ScintillaEditor::applySettings);
-  connect(GlobalPreferences::inst(), &Preferences::autocompleteChanged, scintillaEditor, &ScintillaEditor::onAutocompleteChanged);
-  connect(GlobalPreferences::inst(), &Preferences::characterThresholdChanged, scintillaEditor, &ScintillaEditor::onCharacterThresholdChanged);
-  scintillaEditor->applySettings();
-  editor->addTemplate();
-
-  connect(par->editActionZoomTextIn, &QAction::triggered, editor, &EditorInterface::zoomIn);
-  connect(par->editActionZoomTextOut, &QAction::triggered, editor, &EditorInterface::zoomOut);
-
-  connect(editor, &EditorInterface::contentsChanged, this, &TabManager::updateActionUndoState);
-  connect(editor, &EditorInterface::contentsChanged, par,  &MainWindow::editorContentChanged);
-  connect(editor, &EditorInterface::contentsChanged, this, &TabManager::setContentRenderState);
-  connect(editor, &EditorInterface::modificationChanged, this, &TabManager::onTabModified);
-  connect(editor->parameterWidget, &ParameterWidget::modificationChanged, [editor = this->editor, this] {
-    onTabModified(editor);
+  connect (GlobalPreferences::inst (), &Preferences::editorConfigChanged, scintillaEditor, &ScintillaEditor::applySettings);
+  connect (GlobalPreferences::inst (), &Preferences::autocompleteChanged, scintillaEditor, &ScintillaEditor::onAutocompleteChanged);
+  connect (GlobalPreferences::inst (), &Preferences::characterThresholdChanged, scintillaEditor, &ScintillaEditor::onCharacterThresholdChanged);
+  scintillaEditor->applySettings ();
+  editor->addTemplate ();
+
+  connect (par->editActionZoomTextIn, &QAction::triggered, editor, &EditorInterface::zoomIn);
+  connect (par->editActionZoomTextOut, &QAction::triggered, editor, &EditorInterface::zoomOut);
+
+  connect (editor, &EditorInterface::contentsChanged, this, &TabManager::updateActionUndoState);
+  connect (editor, &EditorInterface::contentsChanged, par, &MainWindow::editorContentChanged);
+  connect (editor, &EditorInterface::contentsChanged, this, &TabManager::setContentRenderState);
+  connect (editor, &EditorInterface::modificationChanged, this, &TabManager::onTabModified);
+  connect (editor->parameterWidget, &ParameterWidget::modificationChanged, [editor = this->editor, this] {
+    onTabModified (editor);
   });
 
-  connect(GlobalPreferences::inst(), &Preferences::fontChanged, editor, &EditorInterface::initFont);
-  connect(GlobalPreferences::inst(), &Preferences::syntaxHighlightChanged, editor, &EditorInterface::setHighlightScheme);
-  editor->initFont(GlobalPreferences::inst()->getValue("editor/fontfamily").toString(), GlobalPreferences::inst()->getValue("editor/fontsize").toUInt());
-  editor->setHighlightScheme(GlobalPreferences::inst()->getValue("editor/syntaxhighlight").toString());
+  connect (GlobalPreferences::inst (), &Preferences::fontChanged, editor, &EditorInterface::initFont);
+  connect (GlobalPreferences::inst (), &Preferences::syntaxHighlightChanged, editor, &EditorInterface::setHighlightScheme);
+  editor->initFont (GlobalPreferences::inst ()->getValue ("editor/fontfamily").toString (), GlobalPreferences::inst ()->getValue ("editor/fontsize").toUInt ());
+  editor->setHighlightScheme (GlobalPreferences::inst ()->getValue ("editor/syntaxhighlight").toString ());
 
-  connect(scintillaEditor, &ScintillaEditor::hyperlinkIndicatorClicked, this, &TabManager::onHyperlinkIndicatorClicked);
+  connect (scintillaEditor, &ScintillaEditor::hyperlinkIndicatorClicked, this, &TabManager::onHyperlinkIndicatorClicked);
 
   // Fill the editor with the content of the file
-  if (filename.isEmpty()) {
+  if (filename.isEmpty ()) {
     editor->filepath = "";
   } else {
-    openTabFile(filename);
+    openTabFile (filename);
   }
-  editorList.insert(editor);
+  editorList.insert (editor);
 
   // Get the name of the tab in editor
-  auto [fname, fpath] = getEditorTabNameWithModifier(editor);
-  tabWidget->addTab(editor, fname);
-  if (tabWidget->currentWidget() != editor) {
-    tabWidget->setCurrentWidget(editor);
+  auto [fname, fpath] = getEditorTabNameWithModifier (editor);
+  tabWidget->addTab (editor, fname);
+  if (tabWidget->currentWidget () != editor) {
+    tabWidget->setCurrentWidget (editor);
   }
-  emit tabCountChanged(editorList.size());
+  emit tabCountChanged (editorList.size ());
 }
 
-size_t TabManager::count()
-{
-  return tabWidget->count();
+size_t TabManager::count () {
+  return tabWidget->count ();
 }
 
-void TabManager::highlightError(int i)
-{
-  editor->highlightError(i);
+void TabManager::highlightError (int i) {
+  editor->highlightError (i);
 }
 
-void TabManager::unhighlightLastError()
-{
-  editor->unhighlightLastError();
+void TabManager::unhighlightLastError () {
+  editor->unhighlightLastError ();
 }
 
-void TabManager::undo()
-{
-  editor->undo();
+void TabManager::undo () {
+  editor->undo ();
 }
 
-void TabManager::redo()
-{
-  editor->redo();
+void TabManager::redo () {
+  editor->redo ();
 }
 
-void TabManager::cut()
-{
-  editor->cut();
+void TabManager::cut () {
+  editor->cut ();
 }
 
-void TabManager::copy()
-{
-  editor->copy();
+void TabManager::copy () {
+  editor->copy ();
 }
 
-void TabManager::paste()
-{
-  editor->paste();
+void TabManager::paste () {
+  editor->paste ();
 }
 
-void TabManager::indentSelection()
-{
-  editor->indentSelection();
+void TabManager::indentSelection () {
+  editor->indentSelection ();
 }
 
-void TabManager::unindentSelection()
-{
-  editor->unindentSelection();
+void TabManager::unindentSelection () {
+  editor->unindentSelection ();
 }
 
-void TabManager::commentSelection()
-{
-  editor->commentSelection();
+void TabManager::commentSelection () {
+  editor->commentSelection ();
 }
 
-void TabManager::uncommentSelection()
-{
-  editor->uncommentSelection();
+void TabManager::uncommentSelection () {
+  editor->uncommentSelection ();
 }
 
-void TabManager::toggleBookmark()
-{
-  editor->toggleBookmark();
+void TabManager::toggleBookmark () {
+  editor->toggleBookmark ();
 }
 
-void TabManager::nextBookmark()
-{
-  editor->nextBookmark();
+void TabManager::nextBookmark () {
+  editor->nextBookmark ();
 }
 
-void TabManager::prevBookmark()
-{
-  editor->prevBookmark();
+void TabManager::prevBookmark () {
+  editor->prevBookmark ();
 }
 
-void TabManager::jumpToNextError()
-{
-  editor->jumpToNextError();
+void TabManager::jumpToNextError () {
+  editor->jumpToNextError ();
 }
 
-void TabManager::setFocus()
-{
-  editor->setFocus();
+void TabManager::setFocus () {
+  editor->setFocus ();
 }
 
-void TabManager::updateActionUndoState()
-{
-  par->editActionUndo->setEnabled(editor->canUndo());
+void TabManager::updateActionUndoState () {
+  par->editActionUndo->setEnabled (editor->canUndo ());
 }
 
-void TabManager::onHyperlinkIndicatorClicked(int val)
-{
-  const QString filename = QString::fromStdString(editor->indicatorData[val].path);
-  this->open(filename);
+void TabManager::onHyperlinkIndicatorClicked (int val) {
+  const QString filename = QString::fromStdString (editor->indicatorData[val].path);
+  this->open (filename);
 }
 
-void TabManager::applyAction(QObject *object, const std::function<void(int, EditorInterface *)>& func)
-{
-  auto *action = dynamic_cast<QAction *>(object);
+void TabManager::applyAction (QObject *object, const std::function<void (int, EditorInterface *)> &func) {
+  auto *action = dynamic_cast<QAction *> (object);
   if (action == nullptr) {
     return;
   }
   bool ok;
-  int idx = action->data().toInt(&ok);
+  int idx = action->data ().toInt (&ok);
   if (!ok) {
     return;
   }
 
-  auto *edt = (EditorInterface *)tabWidget->widget(idx);
+  auto *edt = (EditorInterface *)tabWidget->widget (idx);
   if (edt == nullptr) {
     return;
   }
 
-  func(idx, edt);
+  func (idx, edt);
 }
 
-void TabManager::copyFileName()
-{
-  applyAction(QObject::sender(), [](int, EditorInterface *edt){
-    QClipboard *clipboard = QApplication::clipboard();
-    clipboard->setText(QFileInfo(edt->filepath).fileName());
+void TabManager::copyFileName () {
+  applyAction (QObject::sender (), [] (int, EditorInterface *edt) {
+    QClipboard *clipboard = QApplication::clipboard ();
+    clipboard->setText (QFileInfo (edt->filepath).fileName ());
   });
 }
 
-void TabManager::copyFilePath()
-{
-  applyAction(QObject::sender(), [](int, EditorInterface *edt){
-    QClipboard *clipboard = QApplication::clipboard();
-    clipboard->setText(edt->filepath);
+void TabManager::copyFilePath () {
+  applyAction (QObject::sender (), [] (int, EditorInterface *edt) {
+    QClipboard *clipboard = QApplication::clipboard ();
+    clipboard->setText (edt->filepath);
   });
 }
 
-void TabManager::openFolder()
-{
-  applyAction(QObject::sender(), [](int, EditorInterface *edt){
-    auto dir = QFileInfo(edt->filepath).dir();
-    if (dir.exists()) {
-      QDesktopServices::openUrl(QUrl::fromLocalFile(dir.absolutePath()));
+void TabManager::openFolder () {
+  applyAction (QObject::sender (), [] (int, EditorInterface *edt) {
+    auto dir = QFileInfo (edt->filepath).dir ();
+    if (dir.exists ()) {
+      QDesktopServices::openUrl (QUrl::fromLocalFile (dir.absolutePath ()));
     }
   });
 }
 
-void TabManager::closeTab()
-{
-  applyAction(QObject::sender(), [this](int idx, EditorInterface *){
-    closeTabRequested(idx);
+void TabManager::closeTab () {
+  applyAction (QObject::sender (), [this] (int idx, EditorInterface *) {
+    closeTabRequested (idx);
   });
 }
 
-void TabManager::showContextMenuEvent(const QPoint& pos)
-{
-  auto menu = editor->createStandardContextMenu();
+void TabManager::showContextMenuEvent (const QPoint &pos) {
+  auto menu = editor->createStandardContextMenu ();
 
-  menu->addSeparator();
-  menu->addAction(par->editActionFind);
-  menu->addAction(par->editActionFindNext);
-  menu->addAction(par->editActionFindPrevious);
-  menu->addSeparator();
-  menu->addAction(par->editActionInsertTemplate);
-  menu->addAction(par->editActionFoldAll);
-  menu->exec(editor->mapToGlobal(pos));
+  menu->addSeparator ();
+  menu->addAction (par->editActionFind);
+  menu->addAction (par->editActionFindNext);
+  menu->addAction (par->editActionFindPrevious);
+  menu->addSeparator ();
+  menu->addAction (par->editActionInsertTemplate);
+  menu->addAction (par->editActionFoldAll);
+  menu->exec (editor->mapToGlobal (pos));
 
   delete menu;
 }
 
-void TabManager::showTabHeaderContextMenu(const QPoint& pos)
-{
-  int idx = tabWidget->tabBar()->tabAt(pos);
-  if (idx < 0) return;
+void TabManager::showTabHeaderContextMenu (const QPoint &pos) {
+  int idx = tabWidget->tabBar ()->tabAt (pos);
+  if (idx < 0)
+    return;
 
   QMenu menu;
-  auto *edt = (EditorInterface *)tabWidget->widget(idx);
-
-  auto *copyFileNameAction = new QAction(tabWidget);
-  copyFileNameAction->setData(idx);
-  copyFileNameAction->setEnabled(!edt->filepath.isEmpty());
-  copyFileNameAction->setText(_("Copy file name"));
-  connect(copyFileNameAction, &QAction::triggered, this, &TabManager::copyFileName);
-
-  auto *copyFilePathAction = new QAction(tabWidget);
-  copyFilePathAction->setData(idx);
-  copyFilePathAction->setEnabled(!edt->filepath.isEmpty());
-  copyFilePathAction->setText(_("Copy full path"));
-  connect(copyFilePathAction, &QAction::triggered, this, &TabManager::copyFilePath);
-
-  auto *openFolderAction = new QAction(tabWidget);
-  openFolderAction->setData(idx);
-  openFolderAction->setEnabled(!edt->filepath.isEmpty());
-  openFolderAction->setText(_("Open Folder"));
-  connect(openFolderAction, &QAction::triggered, this, &TabManager::openFolder);
-
-  auto *closeAction = new QAction(tabWidget);
-  closeAction->setData(idx);
-  closeAction->setText(_("Close Tab"));
-  connect(closeAction, &QAction::triggered, this, &TabManager::closeTab);
+  auto *edt = (EditorInterface *)tabWidget->widget (idx);
+
+  auto *copyFileNameAction = new QAction (tabWidget);
+  copyFileNameAction->setData (idx);
+  copyFileNameAction->setEnabled (!edt->filepath.isEmpty ());
+  copyFileNameAction->setText (_ ("Copy file name"));
+  connect (copyFileNameAction, &QAction::triggered, this, &TabManager::copyFileName);
+
+  auto *copyFilePathAction = new QAction (tabWidget);
+  copyFilePathAction->setData (idx);
+  copyFilePathAction->setEnabled (!edt->filepath.isEmpty ());
+  copyFilePathAction->setText (_ ("Copy full path"));
+  connect (copyFilePathAction, &QAction::triggered, this, &TabManager::copyFilePath);
+
+  auto *openFolderAction = new QAction (tabWidget);
+  openFolderAction->setData (idx);
+  openFolderAction->setEnabled (!edt->filepath.isEmpty ());
+  openFolderAction->setText (_ ("Open Folder"));
+  connect (openFolderAction, &QAction::triggered, this, &TabManager::openFolder);
+
+  auto *closeAction = new QAction (tabWidget);
+  closeAction->setData (idx);
+  closeAction->setText (_ ("Close Tab"));
+  connect (closeAction, &QAction::triggered, this, &TabManager::closeTab);
 
   // Don't allow to close the last tab.
-  if (tabWidget->count() <= 1) closeAction->setDisabled(true);
+  if (tabWidget->count () <= 1)
+    closeAction->setDisabled (true);
 
-  menu.addAction(copyFileNameAction);
-  menu.addAction(copyFilePathAction);
-  menu.addSeparator();
-  menu.addAction(openFolderAction);
-  menu.addSeparator();
-  menu.addAction(closeAction);
+  menu.addAction (copyFileNameAction);
+  menu.addAction (copyFilePathAction);
+  menu.addSeparator ();
+  menu.addAction (openFolderAction);
+  menu.addSeparator ();
+  menu.addAction (closeAction);
 
-  QPoint globalCursorPos = QCursor::pos();
-  menu.exec(globalCursorPos);
+  QPoint globalCursorPos = QCursor::pos ();
+  menu.exec (globalCursorPos);
 }
 
-void TabManager::setContentRenderState() //since last render
+void TabManager::setContentRenderState () //since last render
 {
-  editor->contentsRendered = false;   //since last render
-  editor->parameterWidget->setEnabled(false);
+  editor->contentsRendered = false; //since last render
+  editor->parameterWidget->setEnabled (false);
 }
 
-void TabManager::stopAnimation()
-{
-  par->animateWidget->pauseAnimation();
-  par->animateWidget->e_tval->setText("");
+void TabManager::stopAnimation () {
+  par->animateWidget->pauseAnimation ();
+  par->animateWidget->e_tval->setText ("");
 }
 
-void TabManager::updateFindState()
-{
-  if (editor->findState == TabManager::FIND_REPLACE_VISIBLE) par->showFind(true);
-  else if (editor->findState == TabManager::FIND_VISIBLE) par->showFind(false);
-  else par->hideFind();
+void TabManager::updateFindState () {
+  if (editor->findState == TabManager::FIND_REPLACE_VISIBLE)
+    par->showFind (true);
+  else if (editor->findState == TabManager::FIND_VISIBLE)
+    par->showFind (false);
+  else
+    par->hideFind ();
 }
 
-void TabManager::onTabModified(EditorInterface *edt)
-{
+void TabManager::onTabModified (EditorInterface *edt) {
   // Get the name of the editor and its filepath with the status modifier
-  auto [fname, fpath] = getEditorTabNameWithModifier(edt);
+  auto [fname, fpath] = getEditorTabNameWithModifier (edt);
 
   // and set the tab bar widget.
-  setEditorTabName(fname, fpath, edt);
+  setEditorTabName (fname, fpath, edt);
 }
 
-void TabManager::openTabFile(const QString& filename)
-{
+void TabManager::openTabFile (const QString &filename) {
 #ifdef ENABLE_PYTHON
-  if (boost::algorithm::ends_with(filename, ".py")) {
+  if (boost::algorithm::ends_with (filename, ".py")) {
     std::string templ = "from openscad import *\n";
   } else
 #endif
-  editor->setPlainText("");
+    editor->setPlainText ("");
 
-  QFileInfo fileinfo(filename);
-  const auto suffix = fileinfo.suffix().toLower();
-  const auto knownFileType = Importer::knownFileExtensions.contains(suffix);
-  if (!knownFileType)return;
+  QFileInfo fileinfo (filename);
+  const auto suffix = fileinfo.suffix ().toLower ();
+  const auto knownFileType = Importer::knownFileExtensions.contains (suffix);
+  if (!knownFileType)
+    return;
 
   const auto cmd = Importer::knownFileExtensions[suffix];
-  if (cmd.isEmpty()) {
-    editor->filepath = fileinfo.absoluteFilePath();
-    editor->parameterWidget->readFile(fileinfo.absoluteFilePath());
-    par->updateRecentFiles(filename);
+  if (cmd.isEmpty ()) {
+    editor->filepath = fileinfo.absoluteFilePath ();
+    editor->parameterWidget->readFile (fileinfo.absoluteFilePath ());
+    par->updateRecentFiles (filename);
   } else {
     editor->filepath = "";
-    editor->setPlainText(cmd.arg(filename));
+    editor->setPlainText (cmd.arg (filename));
   }
-  refreshDocument();
+  refreshDocument ();
 
-  auto [fname, fpath] = getEditorTabNameWithModifier(editor);
-  setEditorTabName(fname, fpath, editor);
-  par->setWindowTitle(fname);
+  auto [fname, fpath] = getEditorTabNameWithModifier (editor);
+  setEditorTabName (fname, fpath, editor);
+  par->setWindowTitle (fname);
 
-  emit editorContentReloaded(editor);
+  emit editorContentReloaded (editor);
 }
 
-std::tuple<QString, QString> TabManager::getEditorTabName(EditorInterface *edt)
-{
+std::tuple<QString, QString> TabManager::getEditorTabName (EditorInterface *edt) {
   QString fname = edt->filepath;
   QString fpath = edt->filepath;
-  QFileInfo fileinfo(edt->filepath);
-  if (!edt->filepath.isEmpty()) {
-    fname = fileinfo.fileName().replace("&", "&&");
-    fpath = fileinfo.filePath();
+  QFileInfo fileinfo (edt->filepath);
+  if (!edt->filepath.isEmpty ()) {
+    fname = fileinfo.fileName ().replace ("&", "&&");
+    fpath = fileinfo.filePath ();
   } else {
     fname = "Untitled.scad";
     fpath = "Untitled.scad";
@@ -500,45 +468,42 @@ std::tuple<QString, QString> TabManager::getEditorTabName(EditorInterface *edt)
   return {fname, fpath};
 }
 
-std::tuple<QString, QString> TabManager::getEditorTabNameWithModifier(EditorInterface *edt)
-{
-  auto [fname, fpath] = getEditorTabName(edt);
+std::tuple<QString, QString> TabManager::getEditorTabNameWithModifier (EditorInterface *edt) {
+  auto [fname, fpath] = getEditorTabName (edt);
 
   // Add the "modification" star if it was changed.
-  bool isDirty = edt->isContentModified()
-    || edt->parameterWidget->isModified();
+  bool isDirty = edt->isContentModified () || edt->parameterWidget->isModified ();
 
-  if (isDirty) fname += "*";
+  if (isDirty)
+    fname += "*";
 
   return {fname, fpath};
 }
 
-void TabManager::setEditorTabName(const QString& tabName, const QString& tabToolTip,
-                                  EditorInterface *edt)
-{
-  int index = tabWidget->indexOf(edt);
-  tabWidget->setTabText(index, QString(tabName).replace("&", "&&"));
-  tabWidget->setTabToolTip(index, tabToolTip);
+void TabManager::setEditorTabName (const QString &tabName, const QString &tabToolTip,
+                                   EditorInterface *edt) {
+  int index = tabWidget->indexOf (edt);
+  tabWidget->setTabText (index, QString (tabName).replace ("&", "&&"));
+  tabWidget->setTabToolTip (index, tabToolTip);
 }
 
-bool TabManager::refreshDocument()
-{
+bool TabManager::refreshDocument () {
   bool file_opened = false;
-  if (!editor->filepath.isEmpty()) {
-    QFile file(editor->filepath);
-    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
-      LOG("Failed to open file %1$s: %2$s",
-          editor->filepath.toLocal8Bit().constData(), file.errorString().toLocal8Bit().constData());
+  if (!editor->filepath.isEmpty ()) {
+    QFile file (editor->filepath);
+    if (!file.open (QIODevice::ReadOnly | QIODevice::Text)) {
+      LOG ("Failed to open file %1$s: %2$s",
+           editor->filepath.toLocal8Bit ().constData (), file.errorString ().toLocal8Bit ().constData ());
     } else {
-      QTextStream reader(&file);
+      QTextStream reader (&file);
 #if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
-      reader.setCodec("UTF-8");
+      reader.setCodec ("UTF-8");
 #endif
-      auto text = reader.readAll();
-      LOG("Loaded design '%1$s'.", editor->filepath.toLocal8Bit().constData());
-      if (editor->toPlainText() != text) {
-        editor->setPlainText(text);
-        setContentRenderState();         // since last render
+      auto text = reader.readAll ();
+      LOG ("Loaded design '%1$s'.", editor->filepath.toLocal8Bit ().constData ());
+      if (editor->toPlainText () != text) {
+        editor->setPlainText (text);
+        setContentRenderState (); // since last render
       }
       file_opened = true;
     }
@@ -546,26 +511,25 @@ bool TabManager::refreshDocument()
   return file_opened;
 }
 
-bool TabManager::maybeSave(int x)
-{
-  auto *edt = (EditorInterface *) tabWidget->widget(x);
-  if (edt->isContentModified() || edt->parameterWidget->isModified()) {
-    QMessageBox box(par);
-    box.setText(_("The document has been modified."));
-    box.setInformativeText(_("Do you want to save your changes?"));
-    box.setStandardButtons(QMessageBox::Save | QMessageBox::Discard | QMessageBox::Cancel);
-    box.setDefaultButton(QMessageBox::Save);
-    box.setIcon(QMessageBox::Warning);
-    box.setWindowModality(Qt::ApplicationModal);
+bool TabManager::maybeSave (int x) {
+  auto *edt = (EditorInterface *)tabWidget->widget (x);
+  if (edt->isContentModified () || edt->parameterWidget->isModified ()) {
+    QMessageBox box (par);
+    box.setText (_ ("The document has been modified."));
+    box.setInformativeText (_ ("Do you want to save your changes?"));
+    box.setStandardButtons (QMessageBox::Save | QMessageBox::Discard | QMessageBox::Cancel);
+    box.setDefaultButton (QMessageBox::Save);
+    box.setIcon (QMessageBox::Warning);
+    box.setWindowModality (Qt::ApplicationModal);
 #ifdef Q_OS_MACOS
     // Cmd-D is the standard shortcut for this button on Mac
-    box.button(QMessageBox::Discard)->setShortcut(QKeySequence("Ctrl+D"));
-    box.button(QMessageBox::Discard)->setShortcutEnabled(true);
+    box.button (QMessageBox::Discard)->setShortcut (QKeySequence ("Ctrl+D"));
+    box.button (QMessageBox::Discard)->setShortcutEnabled (true);
 #endif
-    auto ret = (QMessageBox::StandardButton) box.exec();
+    auto ret = (QMessageBox::StandardButton)box.exec ();
 
     if (ret == QMessageBox::Save) {
-      return save(edt);
+      return save (edt);
     } else if (ret == QMessageBox::Cancel) {
       return false;
     }
@@ -577,44 +541,43 @@ bool TabManager::maybeSave(int x)
  * Called for whole window close, returning false will abort the close
  * operation.
  */
-bool TabManager::shouldClose()
-{
-  foreach(EditorInterface * edt, editorList) {
-    if (!(edt->isContentModified() || edt->parameterWidget->isModified())) continue;
-
-    QMessageBox box(par);
-    box.setText(_("Some tabs have unsaved changes."));
-    box.setInformativeText(_("Do you want to save all your changes?"));
-    box.setStandardButtons(QMessageBox::SaveAll | QMessageBox::Discard | QMessageBox::Cancel);
-    box.setDefaultButton(QMessageBox::SaveAll);
-    box.setIcon(QMessageBox::Warning);
-    box.setWindowModality(Qt::ApplicationModal);
+bool TabManager::shouldClose () {
+  foreach (EditorInterface *edt, editorList) {
+    if (!(edt->isContentModified () || edt->parameterWidget->isModified ()))
+      continue;
+
+    QMessageBox box (par);
+    box.setText (_ ("Some tabs have unsaved changes."));
+    box.setInformativeText (_ ("Do you want to save all your changes?"));
+    box.setStandardButtons (QMessageBox::SaveAll | QMessageBox::Discard | QMessageBox::Cancel);
+    box.setDefaultButton (QMessageBox::SaveAll);
+    box.setIcon (QMessageBox::Warning);
+    box.setWindowModality (Qt::ApplicationModal);
 #ifdef Q_OS_MACOS
     // Cmd-D is the standard shortcut for this button on Mac
-    box.button(QMessageBox::Discard)->setShortcut(QKeySequence("Ctrl+D"));
-    box.button(QMessageBox::Discard)->setShortcutEnabled(true);
+    box.button (QMessageBox::Discard)->setShortcut (QKeySequence ("Ctrl+D"));
+    box.button (QMessageBox::Discard)->setShortcutEnabled (true);
 #endif
-    auto ret = (QMessageBox::StandardButton) box.exec();
+    auto ret = (QMessageBox::StandardButton)box.exec ();
 
     if (ret == QMessageBox::Cancel) {
       return false;
     } else if (ret == QMessageBox::Discard) {
       return true;
     } else if (ret == QMessageBox::SaveAll) {
-      return saveAll();
+      return saveAll ();
     }
   }
   return true;
 }
 
-void TabManager::saveError(const QIODevice& file, const std::string& msg, const QString& filepath)
-{
-  const std::string fileName = filepath.toStdString();
-  LOG("%1$s %2$s (%3$s)", msg.c_str(), fileName, file.errorString().toStdString());
+void TabManager::saveError (const QIODevice &file, const std::string &msg, const QString &filepath) {
+  const std::string fileName = filepath.toStdString ();
+  LOG ("%1$s %2$s (%3$s)", msg.c_str (), fileName, file.errorString ().toStdString ());
 
   const std::string dialogFormatStr = msg + "\n\"%1\"\n(%2)";
-  const QString dialogFormat(dialogFormatStr.c_str());
-  QMessageBox::warning(par, par->windowTitle(), dialogFormat.arg(filepath).arg(file.errorString()));
+  const QString dialogFormat (dialogFormatStr.c_str ());
+  QMessageBox::warning (par, par->windowTitle (), dialogFormat.arg (filepath).arg (file.errorString ()));
 }
 
 /*!
@@ -622,20 +585,18 @@ void TabManager::saveError(const QIODevice& file, const std::string& msg, const
  * Should _always_ write to disk, since this is called by SaveAs - i.e. don't
  * try to be smart and check for document modification here.
  */
-bool TabManager::save(EditorInterface *edt)
-{
-  assert(edt != nullptr);
+bool TabManager::save (EditorInterface *edt) {
+  assert (edt != nullptr);
 
-  if (edt->filepath.isEmpty()) {
-    return saveAs(edt);
+  if (edt->filepath.isEmpty ()) {
+    return saveAs (edt);
   } else {
-    return save(edt, edt->filepath);
+    return save (edt, edt->filepath);
   }
 }
 
-bool TabManager::save(EditorInterface *edt, const QString& path)
-{
-  par->setCurrentOutput();
+bool TabManager::save (EditorInterface *edt, const QString &path) {
+  par->setCurrentOutput ();
 
   // If available (>= Qt 5.1), use QSaveFile to ensure the file is not
   // destroyed if the device is full. Unfortunately this is not working
@@ -643,97 +604,93 @@ bool TabManager::save(EditorInterface *edt, const QString& path)
   // full properly and happily commits a 0 byte file.
   // Checking the QTextStream status flag after flush() seems to catch
   // this condition.
-  QSaveFile file(path);
-  if (!file.open(QIODevice::WriteOnly | QIODevice::Truncate | QIODevice::Text)) {
-    saveError(file, _("Failed to open file for writing"), path);
+  QSaveFile file (path);
+  if (!file.open (QIODevice::WriteOnly | QIODevice::Truncate | QIODevice::Text)) {
+    saveError (file, _ ("Failed to open file for writing"), path);
     return false;
   }
 
-  QTextStream writer(&file);
+  QTextStream writer (&file);
 #if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
-  writer.setCodec("UTF-8");
+  writer.setCodec ("UTF-8");
 #endif
-  writer << edt->toPlainText();
-  writer.flush();
-  bool saveOk = writer.status() == QTextStream::Ok;
+  writer << edt->toPlainText ();
+  writer.flush ();
+  bool saveOk = writer.status () == QTextStream::Ok;
   if (saveOk) {
-    saveOk = file.commit();
+    saveOk = file.commit ();
   } else {
-    file.cancelWriting();
+    file.cancelWriting ();
   }
   if (saveOk) {
-    LOG("Saved design '%1$s'.", path.toLocal8Bit().constData());
-    edt->parameterWidget->saveFile(path);
-    edt->setContentModified(false);
-    edt->parameterWidget->setModified(false);
-    par->updateRecentFiles(path);
+    LOG ("Saved design '%1$s'.", path.toLocal8Bit ().constData ());
+    edt->parameterWidget->saveFile (path);
+    edt->setContentModified (false);
+    edt->parameterWidget->setModified (false);
+    par->updateRecentFiles (path);
     edt->filepath = path;
   } else {
-    saveError(file, _("Error saving design"), path);
+    saveError (file, _ ("Error saving design"), path);
   }
   return saveOk;
 }
 
-bool TabManager::saveAs(EditorInterface *edt)
-{
-  assert(edt != nullptr);
+bool TabManager::saveAs (EditorInterface *edt) {
+  assert (edt != nullptr);
 
-  const auto dir = edt->filepath.isEmpty() ? _("Untitled.scad") : edt->filepath;
-  auto filename = QFileDialog::getSaveFileName(par, _("Save File"), dir, _("OpenSCAD Designs (*.scad)"));
-  if (filename.isEmpty()) {
+  const auto dir = edt->filepath.isEmpty () ? _ ("Untitled.scad") : edt->filepath;
+  auto filename = QFileDialog::getSaveFileName (par, _ ("Save File"), dir, _ ("OpenSCAD Designs (*.scad)"));
+  if (filename.isEmpty ()) {
     return false;
   }
 
-  if (QFileInfo(filename).suffix().isEmpty()) {
-    filename.append(".scad");
+  if (QFileInfo (filename).suffix ().isEmpty ()) {
+    filename.append (".scad");
 
     // Manual overwrite check since Qt doesn't do it, when using the
     // defaultSuffix property
-    const QFileInfo info(filename);
-    if (info.exists()) {
-      const auto text = QString(_("%1 already exists.\nDo you want to replace it?")).arg(info.fileName());
-      if (QMessageBox::warning(par, par->windowTitle(), text, QMessageBox::Yes | QMessageBox::No, QMessageBox::No) != QMessageBox::Yes) {
+    const QFileInfo info (filename);
+    if (info.exists ()) {
+      const auto text = QString (_ ("%1 already exists.\nDo you want to replace it?")).arg (info.fileName ());
+      if (QMessageBox::warning (par, par->windowTitle (), text, QMessageBox::Yes | QMessageBox::No, QMessageBox::No) != QMessageBox::Yes) {
         return false;
       }
     }
   }
 
-  return saveAs(edt, filename);
+  return saveAs (edt, filename);
 }
 
-bool TabManager::saveAs(EditorInterface *edt, const QString& filepath)
-{
-  bool saveOk = save(edt, filepath);
+bool TabManager::saveAs (EditorInterface *edt, const QString &filepath) {
+  bool saveOk = save (edt, filepath);
   if (saveOk) {
-    auto [fname, fpath] = getEditorTabNameWithModifier(edt);
-    setEditorTabName(fname, fpath, edt);
-    par->setWindowTitle(fname);
+    auto [fname, fpath] = getEditorTabNameWithModifier (edt);
+    setEditorTabName (fname, fpath, edt);
+    par->setWindowTitle (fname);
   }
   return saveOk;
 }
 
-bool TabManager::saveACopy(EditorInterface *edt)
-{
-  assert(edt != nullptr);
+bool TabManager::saveACopy (EditorInterface *edt) {
+  assert (edt != nullptr);
 
-  const auto dir = edt->filepath.isEmpty() ? _("Untitled.scad") : edt->filepath;
-  auto filename = QFileDialog::getSaveFileName(par, _("Save a Copy"), dir, _("OpenSCAD Designs (*.scad)"));
-  if (filename.isEmpty()) {
+  const auto dir = edt->filepath.isEmpty () ? _ ("Untitled.scad") : edt->filepath;
+  auto filename = QFileDialog::getSaveFileName (par, _ ("Save a Copy"), dir, _ ("OpenSCAD Designs (*.scad)"));
+  if (filename.isEmpty ()) {
     return false;
   }
 
-  if (QFileInfo(filename).suffix().isEmpty()) {
-    filename.append(".scad");
+  if (QFileInfo (filename).suffix ().isEmpty ()) {
+    filename.append (".scad");
   }
 
-  return save(edt, filename);
+  return save (edt, filename);
 }
 
-bool TabManager::saveAll()
-{
-  foreach(EditorInterface * edt, editorList) {
-    if (edt->isContentModified() || edt->parameterWidget->isModified()) {
-      if (!save(edt)) {
+bool TabManager::saveAll () {
+  foreach (EditorInterface *edt, editorList) {
+    if (edt->isContentModified () || edt->parameterWidget->isModified ()) {
+      if (!save (edt)) {
         return false;
       }
     }
diff --git a/src/gui/TabManager.h b/src/gui/TabManager.h
index 3447829b7..f26e8d50a 100644
--- a/src/gui/TabManager.h
+++ b/src/gui/TabManager.h
@@ -14,34 +14,34 @@ class TabManager : public QObject
   Q_OBJECT
 
 public:
-  TabManager(MainWindow *o, const QString& filename);
-  QWidget *getTabContent();
+  TabManager (MainWindow *o, const QString &filename);
+  QWidget *getTabContent ();
   EditorInterface *editor;
   QSet<EditorInterface *> editorList;
 
-  void createTab(const QString& filename);
-  void openTabFile(const QString& filename);
+  void createTab (const QString &filename);
+  void openTabFile (const QString &filename);
 
   // returns the name and tooltip of the tab for the given provided editor
   // if there is a path associated with an editor this is the filepath
   // otherwise Untitled.scad
-  std::tuple<QString, QString> getEditorTabName(EditorInterface *edt);
+  std::tuple<QString, QString> getEditorTabName (EditorInterface *edt);
 
   // returns the name and tooltip of the tab for the given provided editor with
   // the extra symbols used to indicate the file has changed.
-  std::tuple<QString, QString> getEditorTabNameWithModifier(EditorInterface *edt);
-
-  void setEditorTabName(const QString& tabName,
-                        const QString& tabTooltip,
-                        EditorInterface *edt = nullptr);
-  bool refreshDocument(); // returns false if the file could not be opened
-  bool shouldClose();
-  bool save(EditorInterface *edt);
-  bool saveAs(EditorInterface *edt);
-  bool saveAs(EditorInterface *edt, const QString& filepath);
-  bool saveACopy(EditorInterface *edt);
-  void open(const QString& filename);
-  size_t count();
+  std::tuple<QString, QString> getEditorTabNameWithModifier (EditorInterface *edt);
+
+  void setEditorTabName (const QString &tabName,
+                         const QString &tabTooltip,
+                         EditorInterface *edt = nullptr);
+  bool refreshDocument (); // returns false if the file could not be opened
+  bool shouldClose ();
+  bool save (EditorInterface *edt);
+  bool saveAs (EditorInterface *edt);
+  bool saveAs (EditorInterface *edt, const QString &filepath);
+  bool saveACopy (EditorInterface *edt);
+  void open (const QString &filename);
+  size_t count ();
 
 public:
   static constexpr const int FIND_HIDDEN = 0;
@@ -52,65 +52,65 @@ signals:
   // emitted when the currently displayed editor is changed and a new one is one focus.
   // the passed parameter can be nullptr, when the editor changed because of closing of the last
   // opened on.
-  void currentEditorChanged(EditorInterface *editor);
-  void editorAboutToClose(EditorInterface *editor);
+  void currentEditorChanged (EditorInterface *editor);
+  void editorAboutToClose (EditorInterface *editor);
 
-  void tabCountChanged(int);
+  void tabCountChanged (int);
 
   // emitted when the content of an editor is reloaded
-  void editorContentReloaded(EditorInterface *editor);
+  void editorContentReloaded (EditorInterface *editor);
 
 private:
   MainWindow *par;
   QTabWidget *tabWidget;
 
-  bool maybeSave(int);
-  bool save(EditorInterface *edt, const QString& path);
-  void saveError(const QIODevice& file, const std::string& msg, const QString& filepath);
-  void applyAction(QObject *object, const std::function<void(int, EditorInterface *)>& func);
-  void setTabsCloseButtonVisibility(int tabIndice, bool isVisible);
+  bool maybeSave (int);
+  bool save (EditorInterface *edt, const QString &path);
+  void saveError (const QIODevice &file, const std::string &msg, const QString &filepath);
+  void applyAction (QObject *object, const std::function<void (int, EditorInterface *)> &func);
+  void setTabsCloseButtonVisibility (int tabIndice, bool isVisible);
 
-  QTabBar::ButtonPosition getClosingButtonPosition();
+  QTabBar::ButtonPosition getClosingButtonPosition ();
 
 private slots:
-  void tabSwitched(int);
-  void closeTabRequested(int);
-  void updateActionUndoState();
-  void copyFileName();
-  void copyFilePath();
-  void openFolder();
-  void closeTab();
+  void tabSwitched (int);
+  void closeTabRequested (int);
+  void updateActionUndoState ();
+  void copyFileName ();
+  void copyFilePath ();
+  void openFolder ();
+  void closeTab ();
 
-  void showContextMenuEvent(const QPoint&);
-  void showTabHeaderContextMenu(const QPoint&);
+  void showContextMenuEvent (const QPoint &);
+  void showTabHeaderContextMenu (const QPoint &);
 
-  void stopAnimation();
-  void updateFindState();
+  void stopAnimation ();
+  void updateFindState ();
 
-  void onHyperlinkIndicatorClicked(int pos);
+  void onHyperlinkIndicatorClicked (int pos);
 
 public slots:
-  void actionNew();
-  void copy();
-  void setContentRenderState(); // since last render
-  void onTabModified(EditorInterface *);
-  bool saveAll();
-  void closeCurrentTab();
-  void nextTab();
-  void prevTab();
-  void setFocus();
-  void highlightError(int);
-  void unhighlightLastError();
-  void undo();
-  void redo();
-  void cut();
-  void paste();
-  void indentSelection();
-  void unindentSelection();
-  void commentSelection();
-  void uncommentSelection();
-  void toggleBookmark();
-  void nextBookmark();
-  void prevBookmark();
-  void jumpToNextError();
+  void actionNew ();
+  void copy ();
+  void setContentRenderState (); // since last render
+  void onTabModified (EditorInterface *);
+  bool saveAll ();
+  void closeCurrentTab ();
+  void nextTab ();
+  void prevTab ();
+  void setFocus ();
+  void highlightError (int);
+  void unhighlightLastError ();
+  void undo ();
+  void redo ();
+  void cut ();
+  void paste ();
+  void indentSelection ();
+  void unindentSelection ();
+  void commentSelection ();
+  void uncommentSelection ();
+  void toggleBookmark ();
+  void nextBookmark ();
+  void prevBookmark ();
+  void jumpToNextError ();
 };
diff --git a/src/gui/UIUtils.cc b/src/gui/UIUtils.cc
index e9fa41827..781bc86f3 100644
--- a/src/gui/UIUtils.cc
+++ b/src/gui/UIUtils.cc
@@ -52,24 +52,22 @@
 
 namespace {
 
-QString fileOpenFilter(const QString& pattern, QStringList extensions)
-{
-  if (extensions.isEmpty()) {
+QString fileOpenFilter (const QString &pattern, QStringList extensions) {
+  if (extensions.isEmpty ()) {
     extensions << "scad" << "csg";
 #ifdef ENABLE_PYTHON
     extensions << "py";
 #endif
   }
-  extensions.replaceInStrings(QRegularExpression("^"), "*.");
-  return pattern.arg(extensions.join(" "));
+  extensions.replaceInStrings (QRegularExpression ("^"), "*.");
+  return pattern.arg (extensions.join (" "));
 }
 
 QList<UIUtils::ExampleCategory> _exampleCategories;
 QMap<QString, QList<UIUtils::ExampleEntry>> _examples;
 
-bool hasCategory(const QString& name)
-{
-  for (const auto& category : _exampleCategories) {
+bool hasCategory (const QString &name) {
+  for (const auto &category : _exampleCategories) {
     if (category.name == name) {
       return true;
     }
@@ -77,240 +75,219 @@ bool hasCategory(const QString& name)
   return false;
 }
 
-void readExamplesDir(const QJsonObject& obj, const fs::path& dir)
-{
-  QString name = obj["name"].toString(QString::fromStdString(dir.filename().generic_string()));
+void readExamplesDir (const QJsonObject &obj, const fs::path &dir) {
+  QString name = obj["name"].toString (QString::fromStdString (dir.filename ().generic_string ()));
 
-  if (!hasCategory(name)) {
-    _exampleCategories.append(UIUtils::ExampleCategory{
-        .sort = obj["sort"].toInt(UIUtils::ExampleCategory::DEFAULT_SORT),
-        .name = name,
-        .tooltip = obj["tooltip"].toString()});
+  if (!hasCategory (name)) {
+    _exampleCategories.append (UIUtils::ExampleCategory{
+      .sort = obj["sort"].toInt (UIUtils::ExampleCategory::DEFAULT_SORT),
+      .name = name,
+      .tooltip = obj["tooltip"].toString ()});
   }
 
-  auto& examples = _examples[name];
-  for (const auto& entry : fs::directory_iterator{dir}) {
-    if (!entry.is_regular_file()) {
+  auto &examples = _examples[name];
+  for (const auto &entry : fs::directory_iterator{dir}) {
+    if (!entry.is_regular_file ()) {
       continue;
     }
-    const auto& path = entry.path();
-    if (path.extension() != ".scad") {
+    const auto &path = entry.path ();
+    if (path.extension () != ".scad") {
       continue;
     }
-    examples.append(UIUtils::ExampleEntry{
-        .name = QString::fromStdString(path.filename().generic_string()),
-        .fileInfo = QFileInfo(QString::fromStdString(path.generic_string()))
-      });
+    examples.append (UIUtils::ExampleEntry{
+      .name = QString::fromStdString (path.filename ().generic_string ()),
+      .fileInfo = QFileInfo (QString::fromStdString (path.generic_string ()))});
   }
-  std::sort(examples.begin(), examples.end(), [](const UIUtils::ExampleEntry& e1, const UIUtils::ExampleEntry& e2) -> bool {
-      return e1.name < e2.name;
-    });
+  std::sort (examples.begin (), examples.end (), [] (const UIUtils::ExampleEntry &e1, const UIUtils::ExampleEntry &e2) -> bool {
+    return e1.name < e2.name;
+  });
 }
 
-void enumerateExamples(const fs::path& dir)
-{
-  if (!fs::is_directory(dir)) {
+void enumerateExamples (const fs::path &dir) {
+  if (!fs::is_directory (dir)) {
     return;
   }
-  for (const auto& entry : fs::directory_iterator{dir}) {
-    if (!entry.is_directory()) {
+  for (const auto &entry : fs::directory_iterator{dir}) {
+    if (!entry.is_directory ()) {
       continue;
     }
-    auto fileInfo = QFileInfo{QDir{QString::fromStdString(entry.path().generic_string())}, "example-dir.json"};
+    auto fileInfo = QFileInfo{QDir{QString::fromStdString (entry.path ().generic_string ())}, "example-dir.json"};
     QJsonObject obj;
-    if (fileInfo.isReadable()) {
+    if (fileInfo.isReadable ()) {
       QFile file;
-      file.setFileName(fileInfo.filePath());
-      file.open(QIODevice::ReadOnly);
-      obj = QJsonDocument::fromJson(file.readAll()).object();
+      file.setFileName (fileInfo.filePath ());
+      file.open (QIODevice::ReadOnly);
+      obj = QJsonDocument::fromJson (file.readAll ()).object ();
     }
-    readExamplesDir(obj, entry.path());
+    readExamplesDir (obj, entry.path ());
   }
-  std::sort(_exampleCategories.begin(), _exampleCategories.end(), [](const UIUtils::ExampleCategory& c1, const UIUtils::ExampleCategory& c2) -> bool {
-      return c2.sort > c1.sort;
-    });
+  std::sort (_exampleCategories.begin (), _exampleCategories.end (), [] (const UIUtils::ExampleCategory &c1, const UIUtils::ExampleCategory &c2) -> bool {
+    return c2.sort > c1.sort;
+  });
 }
 
-const QList<UIUtils::ExampleCategory>& readExamples()
-{
-  if (_exampleCategories.empty()) {
-    enumerateExamples(fs::path{PlatformUtils::resourceBasePath()} / "examples");
-    enumerateExamples(PlatformUtils::userExamplesPath());
+const QList<UIUtils::ExampleCategory> &readExamples () {
+  if (_exampleCategories.empty ()) {
+    enumerateExamples (fs::path{PlatformUtils::resourceBasePath ()} / "examples");
+    enumerateExamples (PlatformUtils::userExamplesPath ());
   }
   return _exampleCategories;
 }
 
 } // namespace
 
-QFileInfo UIUtils::openFile(QWidget *parent, QStringList extensions)
-{
+QFileInfo UIUtils::openFile (QWidget *parent, QStringList extensions) {
   QSettingsCached settings;
-  const auto last_dirname = settings.value("lastOpenDirName").toString();
-  const auto filter = fileOpenFilter("OpenSCAD Designs (%1)", std::move(extensions));
-  const auto filename = QFileDialog::getOpenFileName(parent, "Open File",
-                                                     last_dirname, filter);
+  const auto last_dirname = settings.value ("lastOpenDirName").toString ();
+  const auto filter = fileOpenFilter ("OpenSCAD Designs (%1)", std::move (extensions));
+  const auto filename = QFileDialog::getOpenFileName (parent, "Open File",
+                                                      last_dirname, filter);
 
-  if (filename.isEmpty()) {
+  if (filename.isEmpty ()) {
     return {};
   }
 
-  QFileInfo fileInfo(filename);
-  settings.setValue("lastOpenDirName", fileInfo.dir().path());
+  QFileInfo fileInfo (filename);
+  settings.setValue ("lastOpenDirName", fileInfo.dir ().path ());
   return fileInfo;
 }
 
-QFileInfoList UIUtils::openFiles(QWidget *parent, QStringList extensions)
-{
+QFileInfoList UIUtils::openFiles (QWidget *parent, QStringList extensions) {
   QSettingsCached settings;
-  const auto last_dirname = settings.value("lastOpenDirName").toString();
-  const auto filter = fileOpenFilter("OpenSCAD Designs (%1)", std::move(extensions));
-  const auto filenames = QFileDialog::getOpenFileNames(parent, "Open File",
-                                                       last_dirname, filter);
+  const auto last_dirname = settings.value ("lastOpenDirName").toString ();
+  const auto filter = fileOpenFilter ("OpenSCAD Designs (%1)", std::move (extensions));
+  const auto filenames = QFileDialog::getOpenFileNames (parent, "Open File",
+                                                        last_dirname, filter);
 
   QFileInfoList fileInfoList;
-  for (const QString& filename: filenames) {
-    if (filename.isEmpty()) {
+  for (const QString &filename : filenames) {
+    if (filename.isEmpty ()) {
       continue;
     }
-    fileInfoList.append(QFileInfo(filename));
+    fileInfoList.append (QFileInfo (filename));
   }
 
-  if (!fileInfoList.isEmpty()) {
+  if (!fileInfoList.isEmpty ()) {
     // last_dir is set to directory of last chosen valid file
-    settings.setValue("lastOpenDirName", fileInfoList.back().dir().path());
+    settings.setValue ("lastOpenDirName", fileInfoList.back ().dir ().path ());
   }
 
   return fileInfoList;
 }
 
-QStringList UIUtils::recentFiles()
-{
+QStringList UIUtils::recentFiles () {
   QSettingsCached settings; // set up project and program properly in main.cpp
-  QStringList files = settings.value("recentFileList").toStringList();
+  QStringList files = settings.value ("recentFileList").toStringList ();
 
   // Remove any duplicate or empty entries from the list
-  files.removeDuplicates();
-  files.removeAll(QString());
+  files.removeDuplicates ();
+  files.removeAll (QString ());
   // Now remove any entries which do not exist
-  for (int i = files.size() - 1; i >= 0; --i) {
-    QFileInfo fileInfo(files[i]);
-    if (!QFile(fileInfo.absoluteFilePath()).exists()) files.removeAt(i);
+  for (int i = files.size () - 1; i >= 0; --i) {
+    QFileInfo fileInfo (files[i]);
+    if (!QFile (fileInfo.absoluteFilePath ()).exists ())
+      files.removeAt (i);
   }
 
-  while (files.size() > UIUtils::maxRecentFiles) {
-    files.removeAt(files.size() - 1);
+  while (files.size () > UIUtils::maxRecentFiles) {
+    files.removeAt (files.size () - 1);
   }
 
-  settings.setValue("recentFileList", files);
+  settings.setValue ("recentFileList", files);
   return files;
 }
 
-const QList<UIUtils::ExampleCategory>& UIUtils::exampleCategories()
-{
-  return readExamples();
+const QList<UIUtils::ExampleCategory> &UIUtils::exampleCategories () {
+  return readExamples ();
 }
 
-QFileInfoList UIUtils::exampleFiles(const QString& category)
-{
+QFileInfoList UIUtils::exampleFiles (const QString &category) {
   QFileInfoList examples;
-  if (!_examples.contains(category)) {
+  if (!_examples.contains (category)) {
     return examples;
   }
-  for (const auto& e : _examples[category]) {
+  for (const auto &e : _examples[category]) {
     examples << e.fileInfo;
   }
   return examples;
 }
 
-void UIUtils::openURL(const QString& url)
-{
-  QDesktopServices::openUrl(QUrl(url));
+void UIUtils::openURL (const QString &url) {
+  QDesktopServices::openUrl (QUrl (url));
 }
 
-void UIUtils::openHomepageURL()
-{
-  QDesktopServices::openUrl(QUrl("https://www.openscad.org/"));
+void UIUtils::openHomepageURL () {
+  QDesktopServices::openUrl (QUrl ("https://www.openscad.org/"));
 }
 
-static void openVersionedURL(const QString& url)
-{
-  QDesktopServices::openUrl(QUrl(url.arg(openscad_shortversionnumber.c_str())));
+static void openVersionedURL (const QString &url) {
+  QDesktopServices::openUrl (QUrl (url.arg (openscad_shortversionnumber.c_str ())));
 }
 
-void UIUtils::openUserManualURL()
-{
-  openVersionedURL("https://www.openscad.org/documentation.html?version=%1");
+void UIUtils::openUserManualURL () {
+  openVersionedURL ("https://www.openscad.org/documentation.html?version=%1");
 }
 
-fs::path UIUtils::returnOfflineUserManualPath()
-{
-  fs::path resPath = PlatformUtils::resourcePath("resources");
+fs::path UIUtils::returnOfflineUserManualPath () {
+  fs::path resPath = PlatformUtils::resourcePath ("resources");
   fs::path fullPath = resPath / "docs" / "OpenSCADUserDocs" / "openscad_docs" / "OpenSCAD_User_Manual.html";
   return fullPath;
 }
 
-bool UIUtils::hasOfflineUserManual()
-{
-  fs::path fullPath = returnOfflineUserManualPath();
-  if (fs::exists(fullPath) && fs::is_regular_file(fullPath)) {
+bool UIUtils::hasOfflineUserManual () {
+  fs::path fullPath = returnOfflineUserManualPath ();
+  if (fs::exists (fullPath) && fs::is_regular_file (fullPath)) {
     return true;
   }
   return false;
 }
 
-void UIUtils::openOfflineUserManual()
-{
-  fs::path fullPath = returnOfflineUserManualPath();
-  if (UIUtils::hasOfflineUserManual()) {
-    QString docPath = QString::fromStdString(fullPath.string());
-    QDesktopServices::openUrl(QUrl(docPath));
+void UIUtils::openOfflineUserManual () {
+  fs::path fullPath = returnOfflineUserManualPath ();
+  if (UIUtils::hasOfflineUserManual ()) {
+    QString docPath = QString::fromStdString (fullPath.string ());
+    QDesktopServices::openUrl (QUrl (docPath));
   }
 }
 
-void UIUtils::openCheatSheetURL()
-{
+void UIUtils::openCheatSheetURL () {
 #ifdef OPENSCAD_SNAPSHOT
-  openVersionedURL("https://www.openscad.org/cheatsheet/snapshot.html?version=%1");
+  openVersionedURL ("https://www.openscad.org/cheatsheet/snapshot.html?version=%1");
 #else
-  openVersionedURL("https://www.openscad.org/cheatsheet/index.html?version=%1");
+  openVersionedURL ("https://www.openscad.org/cheatsheet/index.html?version=%1");
 #endif
 }
 
-fs::path UIUtils::returnOfflineCheatSheetPath()
-{
-  fs::path resPath = PlatformUtils::resourcePath("resources");
+fs::path UIUtils::returnOfflineCheatSheetPath () {
+  fs::path resPath = PlatformUtils::resourcePath ("resources");
   fs::path fullPath = resPath / "docs" / "OpenSCADUserDocs" / "openscad_docs" / "CheatSheet.html";
   return fullPath;
 }
 
-bool UIUtils::hasOfflineCheatSheet()
-{
-  fs::path fullPath = returnOfflineCheatSheetPath();
-  if (fs::exists(fullPath) && fs::is_regular_file(fullPath)) {
+bool UIUtils::hasOfflineCheatSheet () {
+  fs::path fullPath = returnOfflineCheatSheetPath ();
+  if (fs::exists (fullPath) && fs::is_regular_file (fullPath)) {
     return true;
   }
   return false;
 }
 
-void UIUtils::openOfflineCheatSheet()
-{
-  fs::path fullPath = returnOfflineCheatSheetPath();
-  if (UIUtils::hasOfflineCheatSheet()) {
-    QString docPath = QString::fromStdString(fullPath.string());
-    QDesktopServices::openUrl(QUrl(docPath));
+void UIUtils::openOfflineCheatSheet () {
+  fs::path fullPath = returnOfflineCheatSheetPath ();
+  if (UIUtils::hasOfflineCheatSheet ()) {
+    QString docPath = QString::fromStdString (fullPath.string ());
+    QDesktopServices::openUrl (QUrl (docPath));
   }
 }
 
-QString UIUtils::getBackgroundColorStyleSheet(const QColor& color)
-{
-  return QString("background-color:%1;").arg(color.toRgb().name());
+QString UIUtils::getBackgroundColorStyleSheet (const QColor &color) {
+  return QString ("background-color:%1;").arg (color.toRgb ().name ());
 }
 
-QString UIUtils::blendForBackgroundColorStyleSheet(const QColor& input, const QColor& blend, float transparency)
-{
-  const auto result = QColor(
-    255.0 * (transparency * blend.redF() + (1 - transparency) * input.redF()),
-    255.0 * (transparency * blend.greenF() + (1 - transparency) * input.greenF()),
-    255.0 * (transparency * blend.blueF() + (1 - transparency) * input.blueF()));
-  return getBackgroundColorStyleSheet(result);
+QString UIUtils::blendForBackgroundColorStyleSheet (const QColor &input, const QColor &blend, float transparency) {
+  const auto result = QColor (
+    255.0 * (transparency * blend.redF () + (1 - transparency) * input.redF ()),
+    255.0 * (transparency * blend.greenF () + (1 - transparency) * input.greenF ()),
+    255.0 * (transparency * blend.blueF () + (1 - transparency) * input.blueF ()));
+  return getBackgroundColorStyleSheet (result);
 }
diff --git a/src/gui/UIUtils.h b/src/gui/UIUtils.h
index bb59eba5a..3d9ffaa41 100644
--- a/src/gui/UIUtils.h
+++ b/src/gui/UIUtils.h
@@ -36,8 +36,7 @@ namespace fs = std::filesystem;
 
 namespace UIUtils {
 
-struct ExampleCategory
-{
+struct ExampleCategory {
   constexpr static int DEFAULT_SORT = 10000;
 
   int sort = DEFAULT_SORT;
@@ -45,8 +44,7 @@ struct ExampleCategory
   QString tooltip;
 };
 
-struct ExampleEntry
-{
+struct ExampleEntry {
   constexpr static int DEFAULT_SORT = 10000;
 
   int sort = DEFAULT_SORT;
@@ -56,38 +54,38 @@ struct ExampleEntry
 
 static const int maxRecentFiles = 10;
 
-QFileInfo openFile(QWidget *parent = nullptr, QStringList extensions = {});
+QFileInfo openFile (QWidget *parent = nullptr, QStringList extensions = {});
 
-QFileInfoList openFiles(QWidget *parent = nullptr, QStringList extensions = {});
+QFileInfoList openFiles (QWidget *parent = nullptr, QStringList extensions = {});
 
-QStringList recentFiles();
+QStringList recentFiles ();
 
-const QList<UIUtils::ExampleCategory>& exampleCategories();
+const QList<UIUtils::ExampleCategory> &exampleCategories ();
 
-QFileInfoList exampleFiles(const QString& category);
+QFileInfoList exampleFiles (const QString &category);
 
-void openURL(const QString& url);
+void openURL (const QString &url);
 
-void openHomepageURL();
+void openHomepageURL ();
 
-void openUserManualURL();
+void openUserManualURL ();
 
-fs::path returnOfflineUserManualPath();
+fs::path returnOfflineUserManualPath ();
 
-bool hasOfflineUserManual();
+bool hasOfflineUserManual ();
 
-void openOfflineUserManual();
+void openOfflineUserManual ();
 
-void openCheatSheetURL();
+void openCheatSheetURL ();
 
-fs::path returnOfflineCheatSheetPath();
+fs::path returnOfflineCheatSheetPath ();
 
-bool hasOfflineCheatSheet();
+bool hasOfflineCheatSheet ();
 
-void openOfflineCheatSheet();
+void openOfflineCheatSheet ();
 
-QString getBackgroundColorStyleSheet(const QColor& color);
+QString getBackgroundColorStyleSheet (const QColor &color);
 
-QString blendForBackgroundColorStyleSheet(const QColor& input, const QColor& blend, float transparency = 0.2);
+QString blendForBackgroundColorStyleSheet (const QColor &input, const QColor &blend, float transparency = 0.2);
 
 } // namespace UIUtils
diff --git a/src/gui/ViewportControl.cc b/src/gui/ViewportControl.cc
index b985b31c2..79fd828c6 100644
--- a/src/gui/ViewportControl.cc
+++ b/src/gui/ViewportControl.cc
@@ -16,244 +16,240 @@
 #include "gui/QGLView.h"
 #include "openscad_gui.h"
 
-ViewportControl::ViewportControl(QWidget *parent) : QWidget(parent)
-{
-  setupUi(this);
-  initGUI();
-  const auto width = scrollAreaWidgetContents->minimumSizeHint().width();
-  const auto margins = layout()->contentsMargins();
-  const auto scrollMargins = scrollAreaWidgetContents->layout()->contentsMargins();
-  initMinWidth = width + margins.left() + margins.right() + scrollMargins.left() + scrollMargins.right();
+ViewportControl::ViewportControl (QWidget *parent)
+  : QWidget (parent) {
+  setupUi (this);
+  initGUI ();
+  const auto width = scrollAreaWidgetContents->minimumSizeHint ().width ();
+  const auto margins = layout ()->contentsMargins ();
+  const auto scrollMargins = scrollAreaWidgetContents->layout ()->contentsMargins ();
+  initMinWidth = width + margins.left () + margins.right () + scrollMargins.left () + scrollMargins.right ();
 }
 
-void ViewportControl::initGUI()
-{
-  auto spinDoubleBoxes = this->groupBoxAbsoluteCamera->findChildren<QDoubleSpinBox *>();
+void ViewportControl::initGUI () {
+  auto spinDoubleBoxes = this->groupBoxAbsoluteCamera->findChildren<QDoubleSpinBox *> ();
   for (auto spinDoubleBox : spinDoubleBoxes) {
-    spinDoubleBox->setMinimum(-DBL_MAX);
-    spinDoubleBox->setMaximum(+DBL_MAX);
-    connect(spinDoubleBox, QOverload<double>::of(&QDoubleSpinBox::valueChanged), this, &ViewportControl::updateCamera);
+    spinDoubleBox->setMinimum (-DBL_MAX);
+    spinDoubleBox->setMaximum (+DBL_MAX);
+    connect (spinDoubleBox, QOverload<double>::of (&QDoubleSpinBox::valueChanged), this, &ViewportControl::updateCamera);
   }
 
-  spinBoxWidth->setMinimum(1);
-  spinBoxHeight->setMinimum(1);
-  spinBoxWidth->setMaximum(8192);
-  spinBoxHeight->setMaximum(8192);
-  connect(spinBoxWidth, QOverload<int>::of(&QSpinBox::valueChanged), this, &ViewportControl::requestResize);
-  connect(spinBoxHeight, QOverload<int>::of(&QSpinBox::valueChanged), this, &ViewportControl::requestResize);
+  spinBoxWidth->setMinimum (1);
+  spinBoxHeight->setMinimum (1);
+  spinBoxWidth->setMaximum (8192);
+  spinBoxHeight->setMaximum (8192);
+  connect (spinBoxWidth, QOverload<int>::of (&QSpinBox::valueChanged), this, &ViewportControl::requestResize);
+  connect (spinBoxHeight, QOverload<int>::of (&QSpinBox::valueChanged), this, &ViewportControl::requestResize);
 }
 
-void ViewportControl::setMainWindow(MainWindow *mainWindow)
-{
+void ViewportControl::setMainWindow (MainWindow *mainWindow) {
   this->mainWindow = mainWindow;
   this->qglview = mainWindow->qglview;
 }
 
-QString ViewportControl::yellowHintBackground()
-{
+QString ViewportControl::yellowHintBackground () {
   QPalette defaultPalette;
-  const auto bgColor = defaultPalette.base().color().toRgb();
-  QString styleSheet = UIUtils::blendForBackgroundColorStyleSheet(bgColor, warnBlendColor);
+  const auto bgColor = defaultPalette.base ().color ().toRgb ();
+  QString styleSheet = UIUtils::blendForBackgroundColorStyleSheet (bgColor, warnBlendColor);
   return styleSheet;
 }
 
-QString ViewportControl::redHintBackground()
-{
+QString ViewportControl::redHintBackground () {
   QPalette defaultPalette;
-  const auto bgColor = defaultPalette.base().color().toRgb();
-  QString styleSheet = UIUtils::blendForBackgroundColorStyleSheet(bgColor, errorBlendColor);
+  const auto bgColor = defaultPalette.base ().color ().toRgb ();
+  QString styleSheet = UIUtils::blendForBackgroundColorStyleSheet (bgColor, errorBlendColor);
   return styleSheet;
 }
 
-void ViewportControl::resizeEvent(QResizeEvent *event)
-{
-  auto layoutAspectRatio = dynamic_cast<QBoxLayout *>(groupBoxAspectRatio->layout());
-  auto gridLayout = dynamic_cast<QGridLayout *>(groupBoxAbsoluteCamera->layout());
+void ViewportControl::resizeEvent (QResizeEvent *event) {
+  auto layoutAspectRatio = dynamic_cast<QBoxLayout *> (groupBoxAspectRatio->layout ());
+  auto gridLayout = dynamic_cast<QGridLayout *> (groupBoxAbsoluteCamera->layout ());
 
   QLayoutItem *child;
   if (layoutAspectRatio && gridLayout) {
-    if (layoutAspectRatio->direction() == QBoxLayout::LeftToRight) {
-      if (event->size().width() < initMinWidth) {
-        layoutAspectRatio->setDirection(QBoxLayout::TopToBottom);
-        while ((child = gridLayout->takeAt(0)) != nullptr) {
+    if (layoutAspectRatio->direction () == QBoxLayout::LeftToRight) {
+      if (event->size ().width () < initMinWidth) {
+        layoutAspectRatio->setDirection (QBoxLayout::TopToBottom);
+        while ((child = gridLayout->takeAt (0)) != nullptr) {
           delete child;
         }
-        gridLayout->addWidget(labelTranslation, 0, 0, 1, 1);
-        gridLayout->addWidget(doubleSpinBox_tx, 1, 0, 1, 1);
-        gridLayout->addWidget(doubleSpinBox_ty, 2, 0, 1, 1);
-        gridLayout->addWidget(doubleSpinBox_tz, 3, 0, 1, 1);
-        gridLayout->addWidget(labelRotation, 4, 0, 1, 1);
-        gridLayout->addWidget(doubleSpinBox_rx, 5, 0, 1, 1);
-        gridLayout->addWidget(doubleSpinBox_ry, 6, 0, 1, 1);
-        gridLayout->addWidget(doubleSpinBox_rz, 7, 0, 1, 1);
-        gridLayout->addWidget(labelDistance, 8, 0, 1, 1);
-        gridLayout->addWidget(doubleSpinBox_d, 9, 0, 1, 1);
-        gridLayout->addWidget(labelFOV, 10, 0, 1, 1);
-        gridLayout->addWidget(doubleSpinBox_fov, 11, 0, 1, 1);
-        scrollAreaWidgetContents->layout()->invalidate();
+        gridLayout->addWidget (labelTranslation, 0, 0, 1, 1);
+        gridLayout->addWidget (doubleSpinBox_tx, 1, 0, 1, 1);
+        gridLayout->addWidget (doubleSpinBox_ty, 2, 0, 1, 1);
+        gridLayout->addWidget (doubleSpinBox_tz, 3, 0, 1, 1);
+        gridLayout->addWidget (labelRotation, 4, 0, 1, 1);
+        gridLayout->addWidget (doubleSpinBox_rx, 5, 0, 1, 1);
+        gridLayout->addWidget (doubleSpinBox_ry, 6, 0, 1, 1);
+        gridLayout->addWidget (doubleSpinBox_rz, 7, 0, 1, 1);
+        gridLayout->addWidget (labelDistance, 8, 0, 1, 1);
+        gridLayout->addWidget (doubleSpinBox_d, 9, 0, 1, 1);
+        gridLayout->addWidget (labelFOV, 10, 0, 1, 1);
+        gridLayout->addWidget (doubleSpinBox_fov, 11, 0, 1, 1);
+        scrollAreaWidgetContents->layout ()->invalidate ();
       }
     } else {
-      if (event->size().width() > initMinWidth) {
-        layoutAspectRatio->setDirection(QBoxLayout::LeftToRight);
-        while ((child = gridLayout->takeAt(0)) != nullptr) {
+      if (event->size ().width () > initMinWidth) {
+        layoutAspectRatio->setDirection (QBoxLayout::LeftToRight);
+        while ((child = gridLayout->takeAt (0)) != nullptr) {
           delete child;
         }
-        gridLayout->addWidget(labelTranslation, 0, 0, 1, 1);
-        gridLayout->addWidget(doubleSpinBox_tx, 0, 1, 1, 1);
-        gridLayout->addWidget(doubleSpinBox_ty, 0, 2, 1, 1);
-        gridLayout->addWidget(doubleSpinBox_tz, 0, 3, 1, 1);
-        gridLayout->addWidget(labelRotation, 1, 0, 1, 1);
-        gridLayout->addWidget(doubleSpinBox_rx, 1, 1, 1, 1);
-        gridLayout->addWidget(doubleSpinBox_ry, 1, 2, 1, 1);
-        gridLayout->addWidget(doubleSpinBox_rz, 1, 3, 1, 1);
-        gridLayout->addWidget(labelDistance, 2, 0, 1, 1);
-        gridLayout->addWidget(doubleSpinBox_d, 2, 1, 1, 1);
-        gridLayout->addWidget(labelFOV, 3, 0, 1, 1);
-        gridLayout->addWidget(doubleSpinBox_fov, 3, 1, 1, 1);
-        scrollAreaWidgetContents->layout()->invalidate();
+        gridLayout->addWidget (labelTranslation, 0, 0, 1, 1);
+        gridLayout->addWidget (doubleSpinBox_tx, 0, 1, 1, 1);
+        gridLayout->addWidget (doubleSpinBox_ty, 0, 2, 1, 1);
+        gridLayout->addWidget (doubleSpinBox_tz, 0, 3, 1, 1);
+        gridLayout->addWidget (labelRotation, 1, 0, 1, 1);
+        gridLayout->addWidget (doubleSpinBox_rx, 1, 1, 1, 1);
+        gridLayout->addWidget (doubleSpinBox_ry, 1, 2, 1, 1);
+        gridLayout->addWidget (doubleSpinBox_rz, 1, 3, 1, 1);
+        gridLayout->addWidget (labelDistance, 2, 0, 1, 1);
+        gridLayout->addWidget (doubleSpinBox_d, 2, 1, 1, 1);
+        gridLayout->addWidget (labelFOV, 3, 0, 1, 1);
+        gridLayout->addWidget (doubleSpinBox_fov, 3, 1, 1, 1);
+        scrollAreaWidgetContents->layout ()->invalidate ();
       } else {
-        const auto width = scrollAreaWidgetContents->minimumSizeHint().width();
-        if (scrollArea->minimumSize().width() != width) {
-          scrollArea->setMinimumSize(QSize(width, 0));
+        const auto width = scrollAreaWidgetContents->minimumSizeHint ().width ();
+        if (scrollArea->minimumSize ().width () != width) {
+          scrollArea->setMinimumSize (QSize (width, 0));
         }
       }
     }
   }
-  QWidget::resizeEvent(event);
+  QWidget::resizeEvent (event);
 }
 
-void ViewportControl::cameraChanged(){
-  if (!inputMutex.try_lock()) return;
+void ViewportControl::cameraChanged () {
+  if (!inputMutex.try_lock ())
+    return;
 
-  const auto vpt = qglview->cam.getVpt();
-  doubleSpinBox_tx->setValue(vpt.x());
-  doubleSpinBox_ty->setValue(vpt.y());
-  doubleSpinBox_tz->setValue(vpt.z());
+  const auto vpt = qglview->cam.getVpt ();
+  doubleSpinBox_tx->setValue (vpt.x ());
+  doubleSpinBox_ty->setValue (vpt.y ());
+  doubleSpinBox_tz->setValue (vpt.z ());
 
-  const auto vpr = qglview->cam.getVpr();
-  doubleSpinBox_rx->setValue(vpr.x());
-  doubleSpinBox_ry->setValue(vpr.y());
-  doubleSpinBox_rz->setValue(vpr.z());
+  const auto vpr = qglview->cam.getVpr ();
+  doubleSpinBox_rx->setValue (vpr.x ());
+  doubleSpinBox_ry->setValue (vpr.y ());
+  doubleSpinBox_rz->setValue (vpr.z ());
 
-  doubleSpinBox_d->setValue(qglview->cam.zoomValue());
+  doubleSpinBox_d->setValue (qglview->cam.zoomValue ());
 
-  doubleSpinBox_fov->setValue(qglview->cam.fov);
-  updateViewportControlHints();
-  inputMutex.unlock();
+  doubleSpinBox_fov->setValue (qglview->cam.fov);
+  updateViewportControlHints ();
+  inputMutex.unlock ();
 }
 
-void ViewportControl::updateCamera(){
-  if (!inputMutex.try_lock()) return;
+void ViewportControl::updateCamera () {
+  if (!inputMutex.try_lock ())
+    return;
 
   //viewport translation
-  qglview->cam.setVpt(
-    doubleSpinBox_tx->value(),
-    doubleSpinBox_ty->value(),
-    doubleSpinBox_tz->value()
-    );
+  qglview->cam.setVpt (
+    doubleSpinBox_tx->value (),
+    doubleSpinBox_ty->value (),
+    doubleSpinBox_tz->value ());
 
   //viewport rotation angles in degrees
-  qglview->cam.setVpr(
-    doubleSpinBox_rx->value(),
-    doubleSpinBox_ry->value(),
-    doubleSpinBox_rz->value()
-    );
+  qglview->cam.setVpr (
+    doubleSpinBox_rx->value (),
+    doubleSpinBox_ry->value (),
+    doubleSpinBox_rz->value ());
 
   //viewport camera field of view
-  double fov = doubleSpinBox_fov->value();
-  qglview->cam.setVpf(fov);
+  double fov = doubleSpinBox_fov->value ();
+  qglview->cam.setVpf (fov);
 
   //camera distance
-  double d = doubleSpinBox_d->value();
-  qglview->cam.setVpd(d);
+  double d = doubleSpinBox_d->value ();
+  qglview->cam.setVpd (d);
 
-  qglview->update();
-  updateViewportControlHints();
-  inputMutex.unlock();
+  qglview->update ();
+  updateViewportControlHints ();
+  inputMutex.unlock ();
 }
 
-void ViewportControl::updateViewportControlHints(){
+void ViewportControl::updateViewportControlHints () {
   //viewport camera field of view
-  double fov = doubleSpinBox_fov->value();
+  double fov = doubleSpinBox_fov->value ();
   if (fov < 0 || fov > 180) {
-    doubleSpinBox_fov->setToolTip(_("extreme values might may lead to strange behavior"));
-    doubleSpinBox_fov->setStyleSheet(redHintBackground());
+    doubleSpinBox_fov->setToolTip (_ ("extreme values might may lead to strange behavior"));
+    doubleSpinBox_fov->setStyleSheet (redHintBackground ());
   } else if (fov < 5 || fov > 175) {
-    doubleSpinBox_fov->setToolTip(_("extreme values might may lead to strange behavior"));
-    doubleSpinBox_fov->setStyleSheet(yellowHintBackground());
+    doubleSpinBox_fov->setToolTip (_ ("extreme values might may lead to strange behavior"));
+    doubleSpinBox_fov->setStyleSheet (yellowHintBackground ());
   } else {
-    doubleSpinBox_fov->setToolTip("");
-    doubleSpinBox_fov->setStyleSheet("");
+    doubleSpinBox_fov->setToolTip ("");
+    doubleSpinBox_fov->setStyleSheet ("");
   }
 
   //camera distance
-  double d = doubleSpinBox_d->value();
+  double d = doubleSpinBox_d->value ();
   if (d < 0) {
-    doubleSpinBox_d->setToolTip(_("negative distances are not supported"));
-    doubleSpinBox_d->setStyleSheet(redHintBackground());
+    doubleSpinBox_d->setToolTip (_ ("negative distances are not supported"));
+    doubleSpinBox_d->setStyleSheet (redHintBackground ());
   } else if (d < 5) {
-    doubleSpinBox_d->setToolTip(_("extreme values might may lead to strange behavior"));
-    doubleSpinBox_d->setStyleSheet(yellowHintBackground());
+    doubleSpinBox_d->setToolTip (_ ("extreme values might may lead to strange behavior"));
+    doubleSpinBox_d->setStyleSheet (yellowHintBackground ());
   } else {
-    doubleSpinBox_d->setToolTip("");
-    doubleSpinBox_d->setStyleSheet("");
+    doubleSpinBox_d->setToolTip ("");
+    doubleSpinBox_d->setStyleSheet ("");
   }
-
 }
 
-void ViewportControl::resizeToRatio(){
-  int w0 = spinBoxWidth->value();
-  int h0 = spinBoxHeight->value();
+void ViewportControl::resizeToRatio () {
+  int w0 = spinBoxWidth->value ();
+  int h0 = spinBoxHeight->value ();
 
   int w1 = this->maxW;
   int h1 = this->maxW * h0 / w0;
   int w2 = this->maxH * w0 / h0;
   int h2 = this->maxH;
   if (h1 <= this->maxH) {
-    qglview->resize(w1, h1);
+    qglview->resize (w1, h1);
   } else {
-    qglview->resize(w2, h2);
+    qglview->resize (w2, h2);
   }
 }
 
-void ViewportControl::viewResized(){
-  if (!resizeMutex.try_lock()) return;
+void ViewportControl::viewResized () {
+  if (!resizeMutex.try_lock ())
+    return;
 
-  this->maxW = qglview->size().rwidth();
-  this->maxH = qglview->size().rheight();
+  this->maxW = qglview->size ().rwidth ();
+  this->maxH = qglview->size ().rheight ();
 
-  if (checkBoxAspecRatioLock->checkState() == Qt::Checked) {
-    resizeToRatio();
+  if (checkBoxAspecRatioLock->checkState () == Qt::Checked) {
+    resizeToRatio ();
   } else {
-    spinBoxWidth->setValue(this->maxW);
-    spinBoxHeight->setValue(this->maxH);
+    spinBoxWidth->setValue (this->maxW);
+    spinBoxHeight->setValue (this->maxH);
   }
-  resizeMutex.unlock();
+  resizeMutex.unlock ();
 }
 
-void ViewportControl::requestResize(){
-  if (!resizeMutex.try_lock()) return;
+void ViewportControl::requestResize () {
+  if (!resizeMutex.try_lock ())
+    return;
 
-  resizeToRatio();
+  resizeToRatio ();
 
-  resizeMutex.unlock();
+  resizeMutex.unlock ();
 }
 
-bool ViewportControl::focusNextPrevChild(bool next){
-  QWidget::focusNextPrevChild(next);   //tab order is set in the UI File
+bool ViewportControl::focusNextPrevChild (bool next) {
+  QWidget::focusNextPrevChild (next); //tab order is set in the UI File
 
   bool bChildHasFocus = false;
-  for (auto child : QObject::findChildren<QWidget *>()) {
-    if (child->hasFocus()) {
+  for (auto child : QObject::findChildren<QWidget *> ()) {
+    if (child->hasFocus ()) {
       bChildHasFocus = true;
     }
   }
   //do not let the focus leave this widget
   if (!bChildHasFocus) {
     if (next) {
-      spinBoxWidth->setFocus();
+      spinBoxWidth->setFocus ();
     } else {
-      doubleSpinBox_fov->setFocus();
+      doubleSpinBox_fov->setFocus ();
     }
   }
   return true;
diff --git a/src/gui/ViewportControl.h b/src/gui/ViewportControl.h
index f2a758e97..c38f648c7 100644
--- a/src/gui/ViewportControl.h
+++ b/src/gui/ViewportControl.h
@@ -15,43 +15,43 @@ class ViewportControl : public QWidget, public Ui::ViewportControlWidget
   Q_OBJECT
 
 public:
-  ViewportControl(QWidget *parent = nullptr);
-  ViewportControl(const ViewportControl& source) = delete;
-  ViewportControl(ViewportControl&& source) = delete;
-  ViewportControl& operator=(const ViewportControl& source) = delete;
-  ViewportControl& operator=(ViewportControl&& source) = delete;
-  ~ViewportControl() override = default;
-  void initGUI();
-  void setMainWindow(MainWindow *mainWindow);
+  ViewportControl (QWidget *parent = nullptr);
+  ViewportControl (const ViewportControl &source) = delete;
+  ViewportControl (ViewportControl &&source) = delete;
+  ViewportControl &operator= (const ViewportControl &source) = delete;
+  ViewportControl &operator= (ViewportControl &&source) = delete;
+  ~ViewportControl () override = default;
+  void initGUI ();
+  void setMainWindow (MainWindow *mainWindow);
 
 public slots:
-  void cameraChanged();
-  void viewResized();
+  void cameraChanged ();
+  void viewResized ();
 
 private slots:
-  void updateCamera();
-  void updateViewportControlHints();
-  void requestResize();
+  void updateCamera ();
+  void updateViewportControlHints ();
+  void requestResize ();
 
 protected:
-  void resizeEvent(QResizeEvent *event) override;
-  bool focusNextPrevChild(bool next) override;
+  void resizeEvent (QResizeEvent *event) override;
+  bool focusNextPrevChild (bool next) override;
 
 private:
   MainWindow *mainWindow;
   QGLView *qglview;
   std::mutex inputMutex;
   std::mutex resizeMutex;
-  QString yellowHintBackground();
-  QString redHintBackground();
+  QString yellowHintBackground ();
+  QString redHintBackground ();
   QColor warnBlendColor{"yellow"};
   QColor errorBlendColor{"red"};
 
 signals:
-  void openFile(const QString, int);
+  void openFile (const QString, int);
 
 private:
-  void resizeToRatio();
+  void resizeToRatio ();
   int maxH;
   int maxW;
   int initMinWidth;
diff --git a/src/gui/WindowManager.cc b/src/gui/WindowManager.cc
index 4f13c8d67..fc674df2d 100644
--- a/src/gui/WindowManager.cc
+++ b/src/gui/WindowManager.cc
@@ -2,17 +2,14 @@
 #include <QSet>
 #include "gui/MainWindow.h"
 
-void WindowManager::add(MainWindow *mainwin)
-{
-  this->windows.insert(mainwin);
+void WindowManager::add (MainWindow *mainwin) {
+  this->windows.insert (mainwin);
 }
 
-void WindowManager::remove(MainWindow *mainwin)
-{
-  this->windows.remove(mainwin);
+void WindowManager::remove (MainWindow *mainwin) {
+  this->windows.remove (mainwin);
 }
 
-const QSet<MainWindow *>& WindowManager::getWindows() const
-{
+const QSet<MainWindow *> &WindowManager::getWindows () const {
   return this->windows;
 }
diff --git a/src/gui/WindowManager.h b/src/gui/WindowManager.h
index 2e7da614d..297cb2d0c 100644
--- a/src/gui/WindowManager.h
+++ b/src/gui/WindowManager.h
@@ -8,11 +8,12 @@ class WindowManager : public QObject
   Q_OBJECT
 
 public:
-  WindowManager() = default;
+  WindowManager () = default;
+
+  void add (class MainWindow *mainwin);
+  void remove (class MainWindow *mainwin);
+  const QSet<MainWindow *> &getWindows () const;
 
-  void add(class MainWindow *mainwin);
-  void remove(class MainWindow *mainwin);
-  const QSet<MainWindow *>& getWindows() const;
 private:
   QSet<MainWindow *> windows;
 };
diff --git a/src/gui/input/AxisConfigWidget.cc b/src/gui/input/AxisConfigWidget.cc
index b234af46b..bd515da4e 100644
--- a/src/gui/input/AxisConfigWidget.cc
+++ b/src/gui/input/AxisConfigWidget.cc
@@ -35,7 +35,6 @@
 #include <cstddef>
 #include <string>
 
-
 #include "core/Settings.h"
 #include "gui/input/InputDriverManager.h"
 #include "gui/SettingsWriter.h"
@@ -43,493 +42,448 @@
 #include "gui/InitConfigurator.h"
 #include "gui/input/InputEventMapper.h"
 
-AxisConfigWidget::AxisConfigWidget(QWidget *parent) : QWidget(parent)
-{
-  setupUi(this);
+AxisConfigWidget::AxisConfigWidget (QWidget *parent)
+  : QWidget (parent) {
+  setupUi (this);
 }
 
-void AxisConfigWidget::AxesChanged(int nr, double val) const {
-  auto *progressBar = this->findChild<QProgressBar *>(QString("progressBarAxis%1").arg(nr));
-  if (progressBar == nullptr) return;
+void AxisConfigWidget::AxesChanged (int nr, double val) const {
+  auto *progressBar = this->findChild<QProgressBar *> (QString ("progressBarAxis%1").arg (nr));
+  if (progressBar == nullptr)
+    return;
 
   int value = val * 100;
-  progressBar->setValue(value); //set where the bar is
+  progressBar->setValue (value); //set where the bar is
 
   //QProgressBar generates the shown string from the format string.
   //By setting a format string without a place holder,
   //we can set arbitrary text, like a custom formatted double.
   //(Note: QProgressBar internally works on int, so has no formatting for double values)
   //(Note: The text of a QProgressBar can not be set directly)
-  QString s = QString::number(val, 'f', 2);
-  progressBar->setFormat(s);
+  QString s = QString::number (val, 'f', 2);
+  progressBar->setFormat (s);
 
-  auto *deadzone = this->findChild<QDoubleSpinBox *>(QString("doubleSpinBoxDeadzone%1").arg(nr));
+  auto *deadzone = this->findChild<QDoubleSpinBox *> (QString ("doubleSpinBoxDeadzone%1").arg (nr));
   if (deadzone) {
-    bool active = deadzone->value() < std::abs(val);
+    bool active = deadzone->value () < std::abs (val);
     QString style;
     if (this->darkModeDetected) {
       style = active ? ProgressbarStyleDarkActive : ProgressbarStyleDark;
     } else {
       style = active ? ProgressbarStyleLightActive : ProgressbarStyleLight;
     }
-    progressBar->setStyleSheet(style);
+    progressBar->setStyleSheet (style);
   }
 }
 
-void AxisConfigWidget::init() {
-  connect(this->pushButtonAxisTrim, &QPushButton::clicked, this, &AxisConfigWidget::on_AxisTrim);
-  connect(this->pushButtonAxisTrimReset, &QPushButton::clicked, this, &AxisConfigWidget::on_AxisTrimReset);
-  connect(this->pushButtonUpdate, &QPushButton::clicked, this, &AxisConfigWidget::updateStates);
-
-  initComboBox(this->comboBoxTranslationX, Settings::Settings::inputTranslationX);
-  initComboBox(this->comboBoxTranslationY, Settings::Settings::inputTranslationY);
-  initComboBox(this->comboBoxTranslationZ, Settings::Settings::inputTranslationZ);
-  initComboBox(this->comboBoxTranslationXVPRel, Settings::Settings::inputTranslationXVPRel);
-  initComboBox(this->comboBoxTranslationYVPRel, Settings::Settings::inputTranslationYVPRel);
-  initComboBox(this->comboBoxTranslationZVPRel, Settings::Settings::inputTranslationZVPRel);
-  initComboBox(this->comboBoxRotationX, Settings::Settings::inputRotateX);
-  initComboBox(this->comboBoxRotationY, Settings::Settings::inputRotateY);
-  initComboBox(this->comboBoxRotationZ, Settings::Settings::inputRotateZ);
-  initComboBox(this->comboBoxRotationXVPRel, Settings::Settings::inputRotateXVPRel);
-  initComboBox(this->comboBoxRotationYVPRel, Settings::Settings::inputRotateYVPRel);
-  initComboBox(this->comboBoxRotationZVPRel, Settings::Settings::inputRotateZVPRel);
-  initComboBox(this->comboBoxZoom, Settings::Settings::inputZoom);
-  initComboBox(this->comboBoxZoom2, Settings::Settings::inputZoom2);
+void AxisConfigWidget::init () {
+  connect (this->pushButtonAxisTrim, &QPushButton::clicked, this, &AxisConfigWidget::on_AxisTrim);
+  connect (this->pushButtonAxisTrimReset, &QPushButton::clicked, this, &AxisConfigWidget::on_AxisTrimReset);
+  connect (this->pushButtonUpdate, &QPushButton::clicked, this, &AxisConfigWidget::updateStates);
+
+  initComboBox (this->comboBoxTranslationX, Settings::Settings::inputTranslationX);
+  initComboBox (this->comboBoxTranslationY, Settings::Settings::inputTranslationY);
+  initComboBox (this->comboBoxTranslationZ, Settings::Settings::inputTranslationZ);
+  initComboBox (this->comboBoxTranslationXVPRel, Settings::Settings::inputTranslationXVPRel);
+  initComboBox (this->comboBoxTranslationYVPRel, Settings::Settings::inputTranslationYVPRel);
+  initComboBox (this->comboBoxTranslationZVPRel, Settings::Settings::inputTranslationZVPRel);
+  initComboBox (this->comboBoxRotationX, Settings::Settings::inputRotateX);
+  initComboBox (this->comboBoxRotationY, Settings::Settings::inputRotateY);
+  initComboBox (this->comboBoxRotationZ, Settings::Settings::inputRotateZ);
+  initComboBox (this->comboBoxRotationXVPRel, Settings::Settings::inputRotateXVPRel);
+  initComboBox (this->comboBoxRotationYVPRel, Settings::Settings::inputRotateYVPRel);
+  initComboBox (this->comboBoxRotationZVPRel, Settings::Settings::inputRotateZVPRel);
+  initComboBox (this->comboBoxZoom, Settings::Settings::inputZoom);
+  initComboBox (this->comboBoxZoom2, Settings::Settings::inputZoom2);
 
 #ifdef ENABLE_HIDAPI
-  this->checkBoxHIDAPI->setEnabled(true);
-  this->checkBoxHIDAPI->setToolTip(HidApiInputDriverDescription);
+  this->checkBoxHIDAPI->setEnabled (true);
+  this->checkBoxHIDAPI->setToolTip (HidApiInputDriverDescription);
 #else
-  this->checkBoxHIDAPI->setToolTip(HidApiInputDriverDescription + "\n\r" + NotEnabledDuringBuild);
+  this->checkBoxHIDAPI->setToolTip (HidApiInputDriverDescription + "\n\r" + NotEnabledDuringBuild);
 #endif
 
 #ifdef ENABLE_SPNAV
-  this->checkBoxSpaceNav->setEnabled(true);
-  this->checkBoxSpaceNav->setToolTip(SpaceNavInputDriverDescription);
+  this->checkBoxSpaceNav->setEnabled (true);
+  this->checkBoxSpaceNav->setToolTip (SpaceNavInputDriverDescription);
 #else
-  this->checkBoxSpaceNav->setToolTip(SpaceNavInputDriverDescription + "\n\r" + NotEnabledDuringBuild);
+  this->checkBoxSpaceNav->setToolTip (SpaceNavInputDriverDescription + "\n\r" + NotEnabledDuringBuild);
 #endif
 
 #ifdef ENABLE_JOYSTICK
-  this->checkBoxJoystick->setEnabled(true);
-  this->checkBoxJoystick->setToolTip(JoystickInputDriverDescription);
+  this->checkBoxJoystick->setEnabled (true);
+  this->checkBoxJoystick->setToolTip (JoystickInputDriverDescription);
 #else
-  this->checkBoxJoystick->setToolTip(JoystickInputDriverDescription + "\n\r" + NotEnabledDuringBuild);
+  this->checkBoxJoystick->setToolTip (JoystickInputDriverDescription + "\n\r" + NotEnabledDuringBuild);
 #endif
 
 #ifdef ENABLE_QGAMEPAD
-  this->checkBoxQGamepad->setEnabled(true);
-  this->checkBoxQGamepad->setToolTip(QGamepadInputDriverDescription);
+  this->checkBoxQGamepad->setEnabled (true);
+  this->checkBoxQGamepad->setToolTip (QGamepadInputDriverDescription);
 #else
-  this->checkBoxQGamepad->setToolTip(QGamepadInputDriverDescription + "\n\r" + NotEnabledDuringBuild);
+  this->checkBoxQGamepad->setToolTip (QGamepadInputDriverDescription + "\n\r" + NotEnabledDuringBuild);
 #endif
 
 #ifdef ENABLE_DBUS
-  this->checkBoxDBus->setEnabled(true);
-  this->checkBoxDBus->setToolTip(DBusInputDriverDescription);
+  this->checkBoxDBus->setEnabled (true);
+  this->checkBoxDBus->setToolTip (DBusInputDriverDescription);
 #else
-  this->checkBoxDBus->setToolTip(DBusInputDriverDescription + "\n\r" + NotEnabledDuringBuild);
+  this->checkBoxDBus->setToolTip (DBusInputDriverDescription + "\n\r" + NotEnabledDuringBuild);
 #endif
 
-  initUpdateCheckBox(this->checkBoxHIDAPI,   Settings::Settings::inputEnableDriverHIDAPI);
-  initUpdateCheckBox(this->checkBoxSpaceNav, Settings::Settings::inputEnableDriverSPNAV);
-  initUpdateCheckBox(this->checkBoxJoystick, Settings::Settings::inputEnableDriverJOYSTICK);
-  initUpdateCheckBox(this->checkBoxQGamepad, Settings::Settings::inputEnableDriverQGAMEPAD);
-  initUpdateCheckBox(this->checkBoxDBus,     Settings::Settings::inputEnableDriverDBUS);
+  initUpdateCheckBox (this->checkBoxHIDAPI, Settings::Settings::inputEnableDriverHIDAPI);
+  initUpdateCheckBox (this->checkBoxSpaceNav, Settings::Settings::inputEnableDriverSPNAV);
+  initUpdateCheckBox (this->checkBoxJoystick, Settings::Settings::inputEnableDriverJOYSTICK);
+  initUpdateCheckBox (this->checkBoxQGamepad, Settings::Settings::inputEnableDriverQGAMEPAD);
+  initUpdateCheckBox (this->checkBoxDBus, Settings::Settings::inputEnableDriverDBUS);
 
-  installIgnoreWheelWhenNotFocused(this);
+  installIgnoreWheelWhenNotFocused (this);
 
-  for (size_t i = 0; i < InputEventMapper::getMaxAxis(); ++i) {
-    auto spinTrim = this->findChild<QDoubleSpinBox *>(QString("doubleSpinBoxTrim%1").arg(i));
+  for (size_t i = 0; i < InputEventMapper::getMaxAxis (); ++i) {
+    auto spinTrim = this->findChild<QDoubleSpinBox *> (QString ("doubleSpinBoxTrim%1").arg (i));
     if (spinTrim) {
-      initUpdateDoubleSpinBox(spinTrim, InputEventMapper::axisTrimSettings(i));
+      initUpdateDoubleSpinBox (spinTrim, InputEventMapper::axisTrimSettings (i));
     }
-    auto spinDeadZone = this->findChild<QDoubleSpinBox *>(QString("doubleSpinBoxDeadzone%1").arg(i));
+    auto spinDeadZone = this->findChild<QDoubleSpinBox *> (QString ("doubleSpinBoxDeadzone%1").arg (i));
     if (spinDeadZone) {
-      initUpdateDoubleSpinBox(spinDeadZone, InputEventMapper::axisDeadzoneSettings(i));
+      initUpdateDoubleSpinBox (spinDeadZone, InputEventMapper::axisDeadzoneSettings (i));
     }
   }
 
-  initUpdateDoubleSpinBox(this->doubleSpinBoxTranslationGain, Settings::Settings::inputTranslationGain);
-  initUpdateDoubleSpinBox(this->doubleSpinBoxTranslationVPRelGain, Settings::Settings::inputTranslationVPRelGain);
-  initUpdateDoubleSpinBox(this->doubleSpinBoxRotateGain, Settings::Settings::inputRotateGain);
-  initUpdateDoubleSpinBox(this->doubleSpinBoxRotateVPRelGain, Settings::Settings::inputRotateVPRelGain);
-  initUpdateDoubleSpinBox(this->doubleSpinBoxZoomGain, Settings::Settings::inputZoomGain);
+  initUpdateDoubleSpinBox (this->doubleSpinBoxTranslationGain, Settings::Settings::inputTranslationGain);
+  initUpdateDoubleSpinBox (this->doubleSpinBoxTranslationVPRelGain, Settings::Settings::inputTranslationVPRelGain);
+  initUpdateDoubleSpinBox (this->doubleSpinBoxRotateGain, Settings::Settings::inputRotateGain);
+  initUpdateDoubleSpinBox (this->doubleSpinBoxRotateVPRelGain, Settings::Settings::inputRotateVPRelGain);
+  initUpdateDoubleSpinBox (this->doubleSpinBoxZoomGain, Settings::Settings::inputZoomGain);
 
   //use a custom style for the axis indicators,
   //to prevent getting operating system specific
   //(potentially animated) ProgressBars
-  int textLightness = this->progressBarAxis0->palette().text().color().lightness();
+  int textLightness = this->progressBarAxis0->palette ().text ().color ().lightness ();
   this->darkModeDetected = textLightness > 165;
   QString style = (this->darkModeDetected) ? ProgressbarStyleDark : ProgressbarStyleLight;
 
-  auto progressbars = this->findChildren<QProgressBar *>();
+  auto progressbars = this->findChildren<QProgressBar *> ();
   for (auto progressbar : progressbars) {
-    progressbar->setStyleSheet(style);
-    progressbar->setAlignment(Qt::AlignCenter);
+    progressbar->setStyleSheet (style);
+    progressbar->setAlignment (Qt::AlignCenter);
   }
 
   initialized = true;
 }
 
-void AxisConfigWidget::on_comboBoxTranslationX_activated(int val)
-{
-  applyComboBox(comboBoxTranslationX, val, Settings::Settings::inputTranslationX);
-  emit inputMappingChanged();
+void AxisConfigWidget::on_comboBoxTranslationX_activated (int val) {
+  applyComboBox (comboBoxTranslationX, val, Settings::Settings::inputTranslationX);
+  emit inputMappingChanged ();
 }
 
-void AxisConfigWidget::on_comboBoxTranslationY_activated(int val)
-{
-  applyComboBox(comboBoxTranslationY, val, Settings::Settings::inputTranslationY);
-  emit inputMappingChanged();
+void AxisConfigWidget::on_comboBoxTranslationY_activated (int val) {
+  applyComboBox (comboBoxTranslationY, val, Settings::Settings::inputTranslationY);
+  emit inputMappingChanged ();
 }
 
-void AxisConfigWidget::on_comboBoxTranslationZ_activated(int val)
-{
-  applyComboBox(comboBoxTranslationZ, val, Settings::Settings::inputTranslationZ);
-  emit inputMappingChanged();
+void AxisConfigWidget::on_comboBoxTranslationZ_activated (int val) {
+  applyComboBox (comboBoxTranslationZ, val, Settings::Settings::inputTranslationZ);
+  emit inputMappingChanged ();
 }
 
-void AxisConfigWidget::on_comboBoxTranslationXVPRel_activated(int val)
-{
-  applyComboBox(comboBoxTranslationXVPRel, val, Settings::Settings::inputTranslationXVPRel);
-  emit inputMappingChanged();
+void AxisConfigWidget::on_comboBoxTranslationXVPRel_activated (int val) {
+  applyComboBox (comboBoxTranslationXVPRel, val, Settings::Settings::inputTranslationXVPRel);
+  emit inputMappingChanged ();
 }
 
-void AxisConfigWidget::on_comboBoxTranslationYVPRel_activated(int val)
-{
-  applyComboBox(comboBoxTranslationYVPRel, val, Settings::Settings::inputTranslationYVPRel);
-  emit inputMappingChanged();
+void AxisConfigWidget::on_comboBoxTranslationYVPRel_activated (int val) {
+  applyComboBox (comboBoxTranslationYVPRel, val, Settings::Settings::inputTranslationYVPRel);
+  emit inputMappingChanged ();
 }
 
-void AxisConfigWidget::on_comboBoxTranslationZVPRel_activated(int val)
-{
-  applyComboBox(comboBoxTranslationZVPRel, val, Settings::Settings::inputTranslationZVPRel);
-  emit inputMappingChanged();
+void AxisConfigWidget::on_comboBoxTranslationZVPRel_activated (int val) {
+  applyComboBox (comboBoxTranslationZVPRel, val, Settings::Settings::inputTranslationZVPRel);
+  emit inputMappingChanged ();
 }
-void AxisConfigWidget::on_comboBoxRotationX_activated(int val)
-{
-  applyComboBox(comboBoxRotationX, val, Settings::Settings::inputRotateX);
-  emit inputMappingChanged();
+void AxisConfigWidget::on_comboBoxRotationX_activated (int val) {
+  applyComboBox (comboBoxRotationX, val, Settings::Settings::inputRotateX);
+  emit inputMappingChanged ();
 }
 
-void AxisConfigWidget::on_comboBoxRotationY_activated(int val)
-{
-  applyComboBox(comboBoxRotationY, val, Settings::Settings::inputRotateY);
-  emit inputMappingChanged();
+void AxisConfigWidget::on_comboBoxRotationY_activated (int val) {
+  applyComboBox (comboBoxRotationY, val, Settings::Settings::inputRotateY);
+  emit inputMappingChanged ();
 }
 
-void AxisConfigWidget::on_comboBoxRotationZ_activated(int val)
-{
-  applyComboBox(comboBoxRotationZ, val, Settings::Settings::inputRotateZ);
-  emit inputMappingChanged();
+void AxisConfigWidget::on_comboBoxRotationZ_activated (int val) {
+  applyComboBox (comboBoxRotationZ, val, Settings::Settings::inputRotateZ);
+  emit inputMappingChanged ();
 }
 
-void AxisConfigWidget::on_comboBoxRotationXVPRel_activated(int val)
-{
-  applyComboBox(comboBoxRotationXVPRel, val, Settings::Settings::inputRotateXVPRel);
-  emit inputMappingChanged();
+void AxisConfigWidget::on_comboBoxRotationXVPRel_activated (int val) {
+  applyComboBox (comboBoxRotationXVPRel, val, Settings::Settings::inputRotateXVPRel);
+  emit inputMappingChanged ();
 }
 
-void AxisConfigWidget::on_comboBoxRotationYVPRel_activated(int val)
-{
-  applyComboBox(comboBoxRotationYVPRel, val, Settings::Settings::inputRotateYVPRel);
-  emit inputMappingChanged();
+void AxisConfigWidget::on_comboBoxRotationYVPRel_activated (int val) {
+  applyComboBox (comboBoxRotationYVPRel, val, Settings::Settings::inputRotateYVPRel);
+  emit inputMappingChanged ();
 }
 
-void AxisConfigWidget::on_comboBoxRotationZVPRel_activated(int val)
-{
-  applyComboBox(comboBoxRotationZVPRel, val, Settings::Settings::inputRotateZVPRel);
-  emit inputMappingChanged();
+void AxisConfigWidget::on_comboBoxRotationZVPRel_activated (int val) {
+  applyComboBox (comboBoxRotationZVPRel, val, Settings::Settings::inputRotateZVPRel);
+  emit inputMappingChanged ();
 }
 
-void AxisConfigWidget::on_comboBoxZoom_activated(int val)
-{
-  applyComboBox(comboBoxZoom, val, Settings::Settings::inputZoom);
-  emit inputMappingChanged();
+void AxisConfigWidget::on_comboBoxZoom_activated (int val) {
+  applyComboBox (comboBoxZoom, val, Settings::Settings::inputZoom);
+  emit inputMappingChanged ();
 }
 
-void AxisConfigWidget::on_comboBoxZoom2_activated(int val)
-{
-  applyComboBox(comboBoxZoom2, val, Settings::Settings::inputZoom2);
-  emit inputMappingChanged();
+void AxisConfigWidget::on_comboBoxZoom2_activated (int val) {
+  applyComboBox (comboBoxZoom2, val, Settings::Settings::inputZoom2);
+  emit inputMappingChanged ();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTrim0_valueChanged(double val)
-{
-  Settings::Settings::axisTrim0.setValue(val);
-  emit inputCalibrationChanged();
-  writeSettings();
+void AxisConfigWidget::on_doubleSpinBoxTrim0_valueChanged (double val) {
+  Settings::Settings::axisTrim0.setValue (val);
+  emit inputCalibrationChanged ();
+  writeSettings ();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTrim1_valueChanged(double val)
-{
-  Settings::Settings::axisTrim1.setValue(val);
-  emit inputCalibrationChanged();
-  writeSettings();
+void AxisConfigWidget::on_doubleSpinBoxTrim1_valueChanged (double val) {
+  Settings::Settings::axisTrim1.setValue (val);
+  emit inputCalibrationChanged ();
+  writeSettings ();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTrim2_valueChanged(double val)
-{
-  Settings::Settings::axisTrim2.setValue(val);
-  emit inputCalibrationChanged();
-  writeSettings();
+void AxisConfigWidget::on_doubleSpinBoxTrim2_valueChanged (double val) {
+  Settings::Settings::axisTrim2.setValue (val);
+  emit inputCalibrationChanged ();
+  writeSettings ();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTrim3_valueChanged(double val)
-{
-  Settings::Settings::axisTrim3.setValue(val);
-  emit inputCalibrationChanged();
-  writeSettings();
+void AxisConfigWidget::on_doubleSpinBoxTrim3_valueChanged (double val) {
+  Settings::Settings::axisTrim3.setValue (val);
+  emit inputCalibrationChanged ();
+  writeSettings ();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTrim4_valueChanged(double val)
-{
-  Settings::Settings::axisTrim4.setValue(val);
-  emit inputCalibrationChanged();
-  writeSettings();
+void AxisConfigWidget::on_doubleSpinBoxTrim4_valueChanged (double val) {
+  Settings::Settings::axisTrim4.setValue (val);
+  emit inputCalibrationChanged ();
+  writeSettings ();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTrim5_valueChanged(double val)
-{
-  Settings::Settings::axisTrim5.setValue(val);
-  emit inputCalibrationChanged();
-  writeSettings();
+void AxisConfigWidget::on_doubleSpinBoxTrim5_valueChanged (double val) {
+  Settings::Settings::axisTrim5.setValue (val);
+  emit inputCalibrationChanged ();
+  writeSettings ();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTrim6_valueChanged(double val)
-{
-  Settings::Settings::axisTrim6.setValue(val);
-  emit inputCalibrationChanged();
-  writeSettings();
+void AxisConfigWidget::on_doubleSpinBoxTrim6_valueChanged (double val) {
+  Settings::Settings::axisTrim6.setValue (val);
+  emit inputCalibrationChanged ();
+  writeSettings ();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTrim7_valueChanged(double val)
-{
-  Settings::Settings::axisTrim7.setValue(val);
-  emit inputCalibrationChanged();
-  writeSettings();
+void AxisConfigWidget::on_doubleSpinBoxTrim7_valueChanged (double val) {
+  Settings::Settings::axisTrim7.setValue (val);
+  emit inputCalibrationChanged ();
+  writeSettings ();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTrim8_valueChanged(double val)
-{
-  Settings::Settings::axisTrim8.setValue(val);
-  emit inputCalibrationChanged();
-  writeSettings();
+void AxisConfigWidget::on_doubleSpinBoxTrim8_valueChanged (double val) {
+  Settings::Settings::axisTrim8.setValue (val);
+  emit inputCalibrationChanged ();
+  writeSettings ();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxDeadzone0_valueChanged(double val)
-{
-  Settings::Settings::axisDeadzone0.setValue(val);
-  emit inputCalibrationChanged();
-  writeSettings();
+void AxisConfigWidget::on_doubleSpinBoxDeadzone0_valueChanged (double val) {
+  Settings::Settings::axisDeadzone0.setValue (val);
+  emit inputCalibrationChanged ();
+  writeSettings ();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxDeadzone1_valueChanged(double val)
-{
-  Settings::Settings::axisDeadzone1.setValue(val);
-  emit inputCalibrationChanged();
-  writeSettings();
+void AxisConfigWidget::on_doubleSpinBoxDeadzone1_valueChanged (double val) {
+  Settings::Settings::axisDeadzone1.setValue (val);
+  emit inputCalibrationChanged ();
+  writeSettings ();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxDeadzone2_valueChanged(double val)
-{
-  Settings::Settings::axisDeadzone2.setValue(val);
-  emit inputCalibrationChanged();
-  writeSettings();
+void AxisConfigWidget::on_doubleSpinBoxDeadzone2_valueChanged (double val) {
+  Settings::Settings::axisDeadzone2.setValue (val);
+  emit inputCalibrationChanged ();
+  writeSettings ();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxDeadzone3_valueChanged(double val)
-{
-  Settings::Settings::axisDeadzone3.setValue(val);
-  emit inputCalibrationChanged();
-  writeSettings();
+void AxisConfigWidget::on_doubleSpinBoxDeadzone3_valueChanged (double val) {
+  Settings::Settings::axisDeadzone3.setValue (val);
+  emit inputCalibrationChanged ();
+  writeSettings ();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxDeadzone4_valueChanged(double val)
-{
-  Settings::Settings::axisDeadzone4.setValue(val);
-  emit inputCalibrationChanged();
-  writeSettings();
+void AxisConfigWidget::on_doubleSpinBoxDeadzone4_valueChanged (double val) {
+  Settings::Settings::axisDeadzone4.setValue (val);
+  emit inputCalibrationChanged ();
+  writeSettings ();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxDeadzone5_valueChanged(double val)
-{
-  Settings::Settings::axisDeadzone5.setValue(val);
-  emit inputCalibrationChanged();
-  writeSettings();
+void AxisConfigWidget::on_doubleSpinBoxDeadzone5_valueChanged (double val) {
+  Settings::Settings::axisDeadzone5.setValue (val);
+  emit inputCalibrationChanged ();
+  writeSettings ();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxDeadzone6_valueChanged(double val)
-{
-  Settings::Settings::axisDeadzone6.setValue(val);
-  emit inputCalibrationChanged();
-  writeSettings();
+void AxisConfigWidget::on_doubleSpinBoxDeadzone6_valueChanged (double val) {
+  Settings::Settings::axisDeadzone6.setValue (val);
+  emit inputCalibrationChanged ();
+  writeSettings ();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxDeadzone7_valueChanged(double val)
-{
-  Settings::Settings::axisDeadzone7.setValue(val);
-  emit inputCalibrationChanged();
-  writeSettings();
+void AxisConfigWidget::on_doubleSpinBoxDeadzone7_valueChanged (double val) {
+  Settings::Settings::axisDeadzone7.setValue (val);
+  emit inputCalibrationChanged ();
+  writeSettings ();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxDeadzone8_valueChanged(double val)
-{
-  Settings::Settings::axisDeadzone8.setValue(val);
-  emit inputCalibrationChanged();
-  writeSettings();
+void AxisConfigWidget::on_doubleSpinBoxDeadzone8_valueChanged (double val) {
+  Settings::Settings::axisDeadzone8.setValue (val);
+  emit inputCalibrationChanged ();
+  writeSettings ();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxRotateGain_valueChanged(double val)
-{
-  Settings::Settings::inputRotateGain.setValue(val);
-  emit inputGainChanged();
-  writeSettings();
+void AxisConfigWidget::on_doubleSpinBoxRotateGain_valueChanged (double val) {
+  Settings::Settings::inputRotateGain.setValue (val);
+  emit inputGainChanged ();
+  writeSettings ();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxRotateVPRelGain_valueChanged(double val)
-{
-  Settings::Settings::inputRotateVPRelGain.setValue(val);
-  emit inputGainChanged();
-  writeSettings();
+void AxisConfigWidget::on_doubleSpinBoxRotateVPRelGain_valueChanged (double val) {
+  Settings::Settings::inputRotateVPRelGain.setValue (val);
+  emit inputGainChanged ();
+  writeSettings ();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTranslationGain_valueChanged(double val)
-{
-  Settings::Settings::inputTranslationGain.setValue(val);
-  emit inputGainChanged();
-  writeSettings();
+void AxisConfigWidget::on_doubleSpinBoxTranslationGain_valueChanged (double val) {
+  Settings::Settings::inputTranslationGain.setValue (val);
+  emit inputGainChanged ();
+  writeSettings ();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTranslationVPRelGain_valueChanged(double val)
-{
-  Settings::Settings::inputTranslationVPRelGain.setValue(val);
-  emit inputGainChanged();
-  writeSettings();
+void AxisConfigWidget::on_doubleSpinBoxTranslationVPRelGain_valueChanged (double val) {
+  Settings::Settings::inputTranslationVPRelGain.setValue (val);
+  emit inputGainChanged ();
+  writeSettings ();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxZoomGain_valueChanged(double val)
-{
-  Settings::Settings::inputZoomGain.setValue(val);
-  emit inputGainChanged();
-  writeSettings();
+void AxisConfigWidget::on_doubleSpinBoxZoomGain_valueChanged (double val) {
+  Settings::Settings::inputZoomGain.setValue (val);
+  emit inputGainChanged ();
+  writeSettings ();
 }
 
-void AxisConfigWidget::on_AxisTrim()
-{
-  InputEventMapper::instance()->onAxisAutoTrim();
+void AxisConfigWidget::on_AxisTrim () {
+  InputEventMapper::instance ()->onAxisAutoTrim ();
 
-  for (size_t i = 0; i < InputEventMapper::getMaxAxis(); ++i) {
-    auto spin = this->findChild<QDoubleSpinBox *>(QString("doubleSpinBoxTrim%1").arg(i));
+  for (size_t i = 0; i < InputEventMapper::getMaxAxis (); ++i) {
+    auto spin = this->findChild<QDoubleSpinBox *> (QString ("doubleSpinBoxTrim%1").arg (i));
     if (spin) {
-      spin->setValue(InputEventMapper::axisTrimSettings(i).value());
+      spin->setValue (InputEventMapper::axisTrimSettings (i).value ());
     }
   }
-  emit inputCalibrationChanged();
-  writeSettings();
+  emit inputCalibrationChanged ();
+  writeSettings ();
 }
 
-void AxisConfigWidget::on_AxisTrimReset()
-{
-  InputEventMapper::instance()->onAxisTrimReset();
-  for (size_t i = 0; i < InputEventMapper::getMaxAxis(); ++i) {
-    auto spin = this->findChild<QDoubleSpinBox *>(QString("doubleSpinBoxTrim%1").arg(i));
+void AxisConfigWidget::on_AxisTrimReset () {
+  InputEventMapper::instance ()->onAxisTrimReset ();
+  for (size_t i = 0; i < InputEventMapper::getMaxAxis (); ++i) {
+    auto spin = this->findChild<QDoubleSpinBox *> (QString ("doubleSpinBoxTrim%1").arg (i));
     if (spin) {
-      InputEventMapper::axisTrimSettings(i).setValue(0.00);
-      spin->setValue(0.00);
+      InputEventMapper::axisTrimSettings (i).setValue (0.00);
+      spin->setValue (0.00);
     }
   }
-  emit inputCalibrationChanged();
-  writeSettings();
+  emit inputCalibrationChanged ();
+  writeSettings ();
 }
 
-void AxisConfigWidget::on_checkBoxHIDAPI_toggled(bool val)
-{
+void AxisConfigWidget::on_checkBoxHIDAPI_toggled (bool val) {
   if (initialized) {
-    Settings::Settings::inputEnableDriverHIDAPI.setValue(val);
-    writeSettings();
+    Settings::Settings::inputEnableDriverHIDAPI.setValue (val);
+    writeSettings ();
 
     QFont font;
-    font.setItalic(true);
-    checkBoxHIDAPI->setFont(font);
+    font.setItalic (true);
+    checkBoxHIDAPI->setFont (font);
   }
 }
 
-void AxisConfigWidget::on_checkBoxSpaceNav_toggled(bool val)
-{
+void AxisConfigWidget::on_checkBoxSpaceNav_toggled (bool val) {
   if (initialized) {
-    Settings::Settings::inputEnableDriverSPNAV.setValue(val);
-    writeSettings();
+    Settings::Settings::inputEnableDriverSPNAV.setValue (val);
+    writeSettings ();
     QFont font;
-    font.setItalic(true);
-    checkBoxSpaceNav->setFont(font);
+    font.setItalic (true);
+    checkBoxSpaceNav->setFont (font);
   }
 }
 
-void AxisConfigWidget::on_checkBoxJoystick_toggled(bool val)
-{
+void AxisConfigWidget::on_checkBoxJoystick_toggled (bool val) {
   if (initialized) {
-    Settings::Settings::inputEnableDriverJOYSTICK.setValue(val);
-    writeSettings();
+    Settings::Settings::inputEnableDriverJOYSTICK.setValue (val);
+    writeSettings ();
     QFont font;
-    font.setItalic(true);
-    checkBoxJoystick->setFont(font);
+    font.setItalic (true);
+    checkBoxJoystick->setFont (font);
   }
 }
 
-void AxisConfigWidget::on_checkBoxQGamepad_toggled(bool val)
-{
+void AxisConfigWidget::on_checkBoxQGamepad_toggled (bool val) {
   if (initialized) {
-    Settings::Settings::inputEnableDriverQGAMEPAD.setValue(val);
-    writeSettings();
+    Settings::Settings::inputEnableDriverQGAMEPAD.setValue (val);
+    writeSettings ();
     QFont font;
-    font.setItalic(true);
-    checkBoxQGamepad->setFont(font);
+    font.setItalic (true);
+    checkBoxQGamepad->setFont (font);
   }
 }
 
-void AxisConfigWidget::on_checkBoxDBus_toggled(bool val)
-{
+void AxisConfigWidget::on_checkBoxDBus_toggled (bool val) {
   if (initialized) {
-    Settings::Settings::inputEnableDriverDBUS.setValue(val);
-    writeSettings();
+    Settings::Settings::inputEnableDriverDBUS.setValue (val);
+    writeSettings ();
     QFont font;
-    font.setItalic(true);
-    checkBoxDBus->setFont(font);
+    font.setItalic (true);
+    checkBoxDBus->setFont (font);
   }
 }
 
-void AxisConfigWidget::applyComboBox(QComboBox * /*comboBox*/, int val, Settings::SettingsEntryEnum<std::string>& entry)
-{
-  entry.setIndex(val);
-  writeSettings();
+void AxisConfigWidget::applyComboBox (QComboBox * /*comboBox*/, int val, Settings::SettingsEntryEnum<std::string> &entry) {
+  entry.setIndex (val);
+  writeSettings ();
 }
 
-void AxisConfigWidget::writeSettings()
-{
-  Settings::Settings::visit(SettingsWriter());
+void AxisConfigWidget::writeSettings () {
+  Settings::Settings::visit (SettingsWriter ());
 }
 
+void AxisConfigWidget::updateStates () {
+  if (!initialized)
+    return;
 
-void AxisConfigWidget::updateStates(){
-  if (!initialized) return;
-
-  size_t cnt = InputDriverManager::instance()->getAxisCount();
-  for (size_t i = 0; i < InputEventMapper::getMaxAxis(); ++i) {
-    auto progressbar = this->findChild<QProgressBar *>(QString("progressBarAxis%1").arg(i));
+  size_t cnt = InputDriverManager::instance ()->getAxisCount ();
+  for (size_t i = 0; i < InputEventMapper::getMaxAxis (); ++i) {
+    auto progressbar = this->findChild<QProgressBar *> (QString ("progressBarAxis%1").arg (i));
     if (progressbar) {
       if (cnt <= i) {
-        progressbar->setEnabled(false);
-        progressbar->setMinimum(0);
+        progressbar->setEnabled (false);
+        progressbar->setMinimum (0);
       } else {
-        progressbar->setEnabled(true);
-        progressbar->setMinimum(-100);
+        progressbar->setEnabled (true);
+        progressbar->setMinimum (-100);
       }
     }
   }
 
-  auto manager = InputDriverManager::instance();
-  std::string infos = manager->listDriverInfos();
-  label_driverInfo->setText(QString::fromStdString(infos));
+  auto manager = InputDriverManager::instance ();
+  std::string infos = manager->listDriverInfos ();
+  label_driverInfo->setText (QString::fromStdString (infos));
 }
diff --git a/src/gui/input/AxisConfigWidget.h b/src/gui/input/AxisConfigWidget.h
index 428293721..8d17a7b16 100644
--- a/src/gui/input/AxisConfigWidget.h
+++ b/src/gui/input/AxisConfigWidget.h
@@ -13,83 +13,83 @@ class AxisConfigWidget : public QWidget, public Ui::Axis, public InitConfigurato
   Q_OBJECT
 
 public:
-  AxisConfigWidget(QWidget *parent = nullptr);
-  void updateButtonState(int, bool) const;
-  void AxesChanged(int nr, double val) const;
-  void init();
+  AxisConfigWidget (QWidget *parent = nullptr);
+  void updateButtonState (int, bool) const;
+  void AxesChanged (int nr, double val) const;
+  void init ();
 
 public slots:
   // Input Driver
-  void on_AxisTrim();
-  void on_AxisTrimReset();
-  void on_comboBoxTranslationX_activated(int val);
-  void on_comboBoxTranslationY_activated(int val);
-  void on_comboBoxTranslationZ_activated(int val);
-  void on_comboBoxTranslationXVPRel_activated(int val);
-  void on_comboBoxTranslationYVPRel_activated(int val);
-  void on_comboBoxTranslationZVPRel_activated(int val);
-  void on_comboBoxRotationX_activated(int val);
-  void on_comboBoxRotationY_activated(int val);
-  void on_comboBoxRotationZ_activated(int val);
-  void on_comboBoxRotationXVPRel_activated(int val);
-  void on_comboBoxRotationYVPRel_activated(int val);
-  void on_comboBoxRotationZVPRel_activated(int val);
-  void on_comboBoxZoom_activated(int val);
-  void on_comboBoxZoom2_activated(int val);
-
-  void on_doubleSpinBoxRotateGain_valueChanged(double val);
-  void on_doubleSpinBoxRotateVPRelGain_valueChanged(double val);
-  void on_doubleSpinBoxTranslationGain_valueChanged(double val);
-  void on_doubleSpinBoxTranslationVPRelGain_valueChanged(double val);
-  void on_doubleSpinBoxZoomGain_valueChanged(double val);
-
-  void on_doubleSpinBoxDeadzone0_valueChanged(double);
-  void on_doubleSpinBoxDeadzone1_valueChanged(double);
-  void on_doubleSpinBoxDeadzone2_valueChanged(double);
-  void on_doubleSpinBoxDeadzone3_valueChanged(double);
-  void on_doubleSpinBoxDeadzone4_valueChanged(double);
-  void on_doubleSpinBoxDeadzone5_valueChanged(double);
-  void on_doubleSpinBoxDeadzone6_valueChanged(double);
-  void on_doubleSpinBoxDeadzone7_valueChanged(double);
-  void on_doubleSpinBoxDeadzone8_valueChanged(double);
-
-  void on_doubleSpinBoxTrim0_valueChanged(double);
-  void on_doubleSpinBoxTrim1_valueChanged(double);
-  void on_doubleSpinBoxTrim2_valueChanged(double);
-  void on_doubleSpinBoxTrim3_valueChanged(double);
-  void on_doubleSpinBoxTrim4_valueChanged(double);
-  void on_doubleSpinBoxTrim5_valueChanged(double);
-  void on_doubleSpinBoxTrim6_valueChanged(double);
-  void on_doubleSpinBoxTrim7_valueChanged(double);
-  void on_doubleSpinBoxTrim8_valueChanged(double);
-
-  void on_checkBoxHIDAPI_toggled(bool);
-  void on_checkBoxSpaceNav_toggled(bool);
-  void on_checkBoxJoystick_toggled(bool);
-  void on_checkBoxQGamepad_toggled(bool);
-  void on_checkBoxDBus_toggled(bool);
-
-  void updateStates();
+  void on_AxisTrim ();
+  void on_AxisTrimReset ();
+  void on_comboBoxTranslationX_activated (int val);
+  void on_comboBoxTranslationY_activated (int val);
+  void on_comboBoxTranslationZ_activated (int val);
+  void on_comboBoxTranslationXVPRel_activated (int val);
+  void on_comboBoxTranslationYVPRel_activated (int val);
+  void on_comboBoxTranslationZVPRel_activated (int val);
+  void on_comboBoxRotationX_activated (int val);
+  void on_comboBoxRotationY_activated (int val);
+  void on_comboBoxRotationZ_activated (int val);
+  void on_comboBoxRotationXVPRel_activated (int val);
+  void on_comboBoxRotationYVPRel_activated (int val);
+  void on_comboBoxRotationZVPRel_activated (int val);
+  void on_comboBoxZoom_activated (int val);
+  void on_comboBoxZoom2_activated (int val);
+
+  void on_doubleSpinBoxRotateGain_valueChanged (double val);
+  void on_doubleSpinBoxRotateVPRelGain_valueChanged (double val);
+  void on_doubleSpinBoxTranslationGain_valueChanged (double val);
+  void on_doubleSpinBoxTranslationVPRelGain_valueChanged (double val);
+  void on_doubleSpinBoxZoomGain_valueChanged (double val);
+
+  void on_doubleSpinBoxDeadzone0_valueChanged (double);
+  void on_doubleSpinBoxDeadzone1_valueChanged (double);
+  void on_doubleSpinBoxDeadzone2_valueChanged (double);
+  void on_doubleSpinBoxDeadzone3_valueChanged (double);
+  void on_doubleSpinBoxDeadzone4_valueChanged (double);
+  void on_doubleSpinBoxDeadzone5_valueChanged (double);
+  void on_doubleSpinBoxDeadzone6_valueChanged (double);
+  void on_doubleSpinBoxDeadzone7_valueChanged (double);
+  void on_doubleSpinBoxDeadzone8_valueChanged (double);
+
+  void on_doubleSpinBoxTrim0_valueChanged (double);
+  void on_doubleSpinBoxTrim1_valueChanged (double);
+  void on_doubleSpinBoxTrim2_valueChanged (double);
+  void on_doubleSpinBoxTrim3_valueChanged (double);
+  void on_doubleSpinBoxTrim4_valueChanged (double);
+  void on_doubleSpinBoxTrim5_valueChanged (double);
+  void on_doubleSpinBoxTrim6_valueChanged (double);
+  void on_doubleSpinBoxTrim7_valueChanged (double);
+  void on_doubleSpinBoxTrim8_valueChanged (double);
+
+  void on_checkBoxHIDAPI_toggled (bool);
+  void on_checkBoxSpaceNav_toggled (bool);
+  void on_checkBoxJoystick_toggled (bool);
+  void on_checkBoxQGamepad_toggled (bool);
+  void on_checkBoxDBus_toggled (bool);
+
+  void updateStates ();
 
 signals:
-  void inputMappingChanged() const;
-  void inputCalibrationChanged() const;
-  void inputGainChanged() const;
+  void inputMappingChanged () const;
+  void inputCalibrationChanged () const;
+  void inputGainChanged () const;
 
 private:
   /** Set value from combobox to settings */
-  void applyComboBox(QComboBox *comboBox, int val, Settings::SettingsEntryEnum<std::string>& entry);
-  void writeSettings();
+  void applyComboBox (QComboBox *comboBox, int val, Settings::SettingsEntryEnum<std::string> &entry);
+  void writeSettings ();
 
   bool initialized = false;
 
-  QString NotEnabledDuringBuild = _("This driver was not enabled during build time and is thus not available.");
+  QString NotEnabledDuringBuild = _ ("This driver was not enabled during build time and is thus not available.");
 
-  QString DBusInputDriverDescription = _("The DBUS driver is not for actual devices but for remote control, Linux only.");
-  QString HidApiInputDriverDescription = _("The HIDAPI driver communicates directly with the 3D mice, Windows and macOS.");
-  QString SpaceNavInputDriverDescription = _("The SpaceNav driver enables 3D-input-devices using the spacenavd daemon, Linux only.");
-  QString JoystickInputDriverDescription = _("The Joystick driver uses the Linux joystick device (fixed to /dev/input/js0), Linux only.");
-  QString QGamepadInputDriverDescription = _("The QGAMEPAD driver is for multiplattform Gamepad Support.");
+  QString DBusInputDriverDescription = _ ("The DBUS driver is not for actual devices but for remote control, Linux only.");
+  QString HidApiInputDriverDescription = _ ("The HIDAPI driver communicates directly with the 3D mice, Windows and macOS.");
+  QString SpaceNavInputDriverDescription = _ ("The SpaceNav driver enables 3D-input-devices using the spacenavd daemon, Linux only.");
+  QString JoystickInputDriverDescription = _ ("The Joystick driver uses the Linux joystick device (fixed to /dev/input/js0), Linux only.");
+  QString QGamepadInputDriverDescription = _ ("The QGAMEPAD driver is for multiplattform Gamepad Support.");
 
   bool darkModeDetected = false;
 
diff --git a/src/gui/input/ButtonConfigWidget.cc b/src/gui/input/ButtonConfigWidget.cc
index c4b51af08..50f26d1f9 100644
--- a/src/gui/input/ButtonConfigWidget.cc
+++ b/src/gui/input/ButtonConfigWidget.cc
@@ -38,230 +38,204 @@
 #include "gui/IgnoreWheelWhenNotFocused.h"
 #include "gui/input/InputEventMapper.h"
 
-ButtonConfigWidget::ButtonConfigWidget(QWidget *parent) : QWidget(parent)
-{
-  setupUi(this);
+ButtonConfigWidget::ButtonConfigWidget (QWidget *parent)
+  : QWidget (parent) {
+  setupUi (this);
 }
 
-void ButtonConfigWidget::updateButtonState(int nr, bool pressed) const {
+void ButtonConfigWidget::updateButtonState (int nr, bool pressed) const {
   QString style = pressed ? ButtonConfigWidget::ActiveStyleString : ButtonConfigWidget::EmptyString;
 
-  auto label = this->findChild<QLabel *>(QString("labelInputButton%1").arg(nr));
-  if (label == nullptr) return;
-  label->setStyleSheet(style);
+  auto label = this->findChild<QLabel *> (QString ("labelInputButton%1").arg (nr));
+  if (label == nullptr)
+    return;
+  label->setStyleSheet (style);
 }
 
-void ButtonConfigWidget::init() {
-  for (size_t i = 0; i < InputEventMapper::getMaxButtons(); ++i) {
-    auto box = this->findChild<QComboBox *>(QString("comboBoxButton%1").arg(i));
+void ButtonConfigWidget::init () {
+  for (size_t i = 0; i < InputEventMapper::getMaxButtons (); ++i) {
+    auto box = this->findChild<QComboBox *> (QString ("comboBoxButton%1").arg (i));
     if (box) {
-      initActionComboBox(box, InputEventMapper::inputButtonSettings(i));
+      initActionComboBox (box, InputEventMapper::inputButtonSettings (i));
     }
   }
 
-  installIgnoreWheelWhenNotFocused(this);
+  installIgnoreWheelWhenNotFocused (this);
 
   initialized = true;
 }
 
-void ButtonConfigWidget::on_comboBoxButton0_activated(int val)
-{
-  applyComboBox(comboBoxButton0, val, Settings::Settings::inputButton0);
-  emit inputMappingChanged();
+void ButtonConfigWidget::on_comboBoxButton0_activated (int val) {
+  applyComboBox (comboBoxButton0, val, Settings::Settings::inputButton0);
+  emit inputMappingChanged ();
 }
 
-void ButtonConfigWidget::on_comboBoxButton1_activated(int val)
-{
-  applyComboBox(comboBoxButton1, val, Settings::Settings::inputButton1);
-  emit inputMappingChanged();
+void ButtonConfigWidget::on_comboBoxButton1_activated (int val) {
+  applyComboBox (comboBoxButton1, val, Settings::Settings::inputButton1);
+  emit inputMappingChanged ();
 }
 
-void ButtonConfigWidget::on_comboBoxButton2_activated(int val)
-{
-  applyComboBox(comboBoxButton2, val, Settings::Settings::inputButton2);
-  emit inputMappingChanged();
+void ButtonConfigWidget::on_comboBoxButton2_activated (int val) {
+  applyComboBox (comboBoxButton2, val, Settings::Settings::inputButton2);
+  emit inputMappingChanged ();
 }
 
-void ButtonConfigWidget::on_comboBoxButton3_activated(int val)
-{
-  applyComboBox(comboBoxButton3, val, Settings::Settings::inputButton3);
-  emit inputMappingChanged();
+void ButtonConfigWidget::on_comboBoxButton3_activated (int val) {
+  applyComboBox (comboBoxButton3, val, Settings::Settings::inputButton3);
+  emit inputMappingChanged ();
 }
 
-void ButtonConfigWidget::on_comboBoxButton4_activated(int val)
-{
-  applyComboBox(comboBoxButton4, val, Settings::Settings::inputButton4);
-  emit inputMappingChanged();
+void ButtonConfigWidget::on_comboBoxButton4_activated (int val) {
+  applyComboBox (comboBoxButton4, val, Settings::Settings::inputButton4);
+  emit inputMappingChanged ();
 }
 
-void ButtonConfigWidget::on_comboBoxButton5_activated(int val)
-{
-  applyComboBox(comboBoxButton5, val, Settings::Settings::inputButton5);
-  emit inputMappingChanged();
+void ButtonConfigWidget::on_comboBoxButton5_activated (int val) {
+  applyComboBox (comboBoxButton5, val, Settings::Settings::inputButton5);
+  emit inputMappingChanged ();
 }
 
-void ButtonConfigWidget::on_comboBoxButton6_activated(int val)
-{
-  applyComboBox(comboBoxButton6, val, Settings::Settings::inputButton6);
-  emit inputMappingChanged();
+void ButtonConfigWidget::on_comboBoxButton6_activated (int val) {
+  applyComboBox (comboBoxButton6, val, Settings::Settings::inputButton6);
+  emit inputMappingChanged ();
 }
 
-void ButtonConfigWidget::on_comboBoxButton7_activated(int val)
-{
-  applyComboBox(comboBoxButton7, val, Settings::Settings::inputButton7);
-  emit inputMappingChanged();
+void ButtonConfigWidget::on_comboBoxButton7_activated (int val) {
+  applyComboBox (comboBoxButton7, val, Settings::Settings::inputButton7);
+  emit inputMappingChanged ();
 }
 
-void ButtonConfigWidget::on_comboBoxButton8_activated(int val)
-{
-  applyComboBox(comboBoxButton8, val, Settings::Settings::inputButton8);
-  emit inputMappingChanged();
+void ButtonConfigWidget::on_comboBoxButton8_activated (int val) {
+  applyComboBox (comboBoxButton8, val, Settings::Settings::inputButton8);
+  emit inputMappingChanged ();
 }
 
-void ButtonConfigWidget::on_comboBoxButton9_activated(int val)
-{
-  applyComboBox(comboBoxButton9, val, Settings::Settings::inputButton9);
-  emit inputMappingChanged();
+void ButtonConfigWidget::on_comboBoxButton9_activated (int val) {
+  applyComboBox (comboBoxButton9, val, Settings::Settings::inputButton9);
+  emit inputMappingChanged ();
 }
 
-void ButtonConfigWidget::on_comboBoxButton10_activated(int val)
-{
-  applyComboBox(comboBoxButton10, val, Settings::Settings::inputButton10);
-  emit inputMappingChanged();
+void ButtonConfigWidget::on_comboBoxButton10_activated (int val) {
+  applyComboBox (comboBoxButton10, val, Settings::Settings::inputButton10);
+  emit inputMappingChanged ();
 }
 
-void ButtonConfigWidget::on_comboBoxButton11_activated(int val)
-{
-  applyComboBox(comboBoxButton11, val, Settings::Settings::inputButton11);
-  emit inputMappingChanged();
+void ButtonConfigWidget::on_comboBoxButton11_activated (int val) {
+  applyComboBox (comboBoxButton11, val, Settings::Settings::inputButton11);
+  emit inputMappingChanged ();
 }
 
-void ButtonConfigWidget::on_comboBoxButton12_activated(int val)
-{
-  applyComboBox(comboBoxButton12, val, Settings::Settings::inputButton12);
-  emit inputMappingChanged();
+void ButtonConfigWidget::on_comboBoxButton12_activated (int val) {
+  applyComboBox (comboBoxButton12, val, Settings::Settings::inputButton12);
+  emit inputMappingChanged ();
 }
 
-void ButtonConfigWidget::on_comboBoxButton13_activated(int val)
-{
-  applyComboBox(comboBoxButton13, val, Settings::Settings::inputButton13);
-  emit inputMappingChanged();
+void ButtonConfigWidget::on_comboBoxButton13_activated (int val) {
+  applyComboBox (comboBoxButton13, val, Settings::Settings::inputButton13);
+  emit inputMappingChanged ();
 }
 
-void ButtonConfigWidget::on_comboBoxButton14_activated(int val)
-{
-  applyComboBox(comboBoxButton14, val, Settings::Settings::inputButton14);
-  emit inputMappingChanged();
+void ButtonConfigWidget::on_comboBoxButton14_activated (int val) {
+  applyComboBox (comboBoxButton14, val, Settings::Settings::inputButton14);
+  emit inputMappingChanged ();
 }
 
-void ButtonConfigWidget::on_comboBoxButton15_activated(int val)
-{
-  applyComboBox(comboBoxButton15, val, Settings::Settings::inputButton15);
-  emit inputMappingChanged();
+void ButtonConfigWidget::on_comboBoxButton15_activated (int val) {
+  applyComboBox (comboBoxButton15, val, Settings::Settings::inputButton15);
+  emit inputMappingChanged ();
 }
 
-void ButtonConfigWidget::on_comboBoxButton16_activated(int val)
-{
-  applyComboBox(comboBoxButton16, val, Settings::Settings::inputButton16);
-  emit inputMappingChanged();
+void ButtonConfigWidget::on_comboBoxButton16_activated (int val) {
+  applyComboBox (comboBoxButton16, val, Settings::Settings::inputButton16);
+  emit inputMappingChanged ();
 }
 
-void ButtonConfigWidget::on_comboBoxButton17_activated(int val)
-{
-  applyComboBox(comboBoxButton17, val, Settings::Settings::inputButton17);
-  emit inputMappingChanged();
+void ButtonConfigWidget::on_comboBoxButton17_activated (int val) {
+  applyComboBox (comboBoxButton17, val, Settings::Settings::inputButton17);
+  emit inputMappingChanged ();
 }
 
-void ButtonConfigWidget::on_comboBoxButton18_activated(int val)
-{
-  applyComboBox(comboBoxButton18, val, Settings::Settings::inputButton18);
-  emit inputMappingChanged();
+void ButtonConfigWidget::on_comboBoxButton18_activated (int val) {
+  applyComboBox (comboBoxButton18, val, Settings::Settings::inputButton18);
+  emit inputMappingChanged ();
 }
 
-void ButtonConfigWidget::on_comboBoxButton19_activated(int val)
-{
-  applyComboBox(comboBoxButton19, val, Settings::Settings::inputButton19);
-  emit inputMappingChanged();
+void ButtonConfigWidget::on_comboBoxButton19_activated (int val) {
+  applyComboBox (comboBoxButton19, val, Settings::Settings::inputButton19);
+  emit inputMappingChanged ();
 }
 
-void ButtonConfigWidget::on_comboBoxButton20_activated(int val)
-{
-  applyComboBox(comboBoxButton20, val, Settings::Settings::inputButton20);
-  emit inputMappingChanged();
+void ButtonConfigWidget::on_comboBoxButton20_activated (int val) {
+  applyComboBox (comboBoxButton20, val, Settings::Settings::inputButton20);
+  emit inputMappingChanged ();
 }
 
-void ButtonConfigWidget::on_comboBoxButton21_activated(int val)
-{
-  applyComboBox(comboBoxButton21, val, Settings::Settings::inputButton21);
-  emit inputMappingChanged();
+void ButtonConfigWidget::on_comboBoxButton21_activated (int val) {
+  applyComboBox (comboBoxButton21, val, Settings::Settings::inputButton21);
+  emit inputMappingChanged ();
 }
 
-void ButtonConfigWidget::on_comboBoxButton22_activated(int val)
-{
-  applyComboBox(comboBoxButton22, val, Settings::Settings::inputButton22);
-  emit inputMappingChanged();
+void ButtonConfigWidget::on_comboBoxButton22_activated (int val) {
+  applyComboBox (comboBoxButton22, val, Settings::Settings::inputButton22);
+  emit inputMappingChanged ();
 }
 
-void ButtonConfigWidget::on_comboBoxButton23_activated(int val)
-{
-  applyComboBox(comboBoxButton23, val, Settings::Settings::inputButton23);
-  emit inputMappingChanged();
+void ButtonConfigWidget::on_comboBoxButton23_activated (int val) {
+  applyComboBox (comboBoxButton23, val, Settings::Settings::inputButton23);
+  emit inputMappingChanged ();
 }
 
-void ButtonConfigWidget::applyComboBox(QComboBox *comboBox, int val, Settings::SettingsEntryString& entry)
-{
-  entry.setValue(comboBox->itemData(val).toString().toStdString());
-  writeSettings();
+void ButtonConfigWidget::applyComboBox (QComboBox *comboBox, int val, Settings::SettingsEntryString &entry) {
+  entry.setValue (comboBox->itemData (val).toString ().toStdString ());
+  writeSettings ();
 }
 
-void ButtonConfigWidget::updateComboBox(QComboBox *comboBox, const Settings::SettingsEntryString& entry)
-{
-  QString value = QString::fromStdString(entry.value());
-  int index = comboBox->findData(value);
+void ButtonConfigWidget::updateComboBox (QComboBox *comboBox, const Settings::SettingsEntryString &entry) {
+  QString value = QString::fromStdString (entry.value ());
+  int index = comboBox->findData (value);
   if (index >= 0) {
-    comboBox->setCurrentIndex(index);
+    comboBox->setCurrentIndex (index);
   } else {
-    comboBox->addItem(QIcon::fromTheme("emblem-unreadable"), value + " " + ("(not supported)"), value);
-    comboBox->setCurrentIndex(comboBox->count() - 1);
+    comboBox->addItem (QIcon::fromTheme ("emblem-unreadable"), value + " " + ("(not supported)"), value);
+    comboBox->setCurrentIndex (comboBox->count () - 1);
   }
 }
 
-void ButtonConfigWidget::writeSettings()
-{
-  Settings::Settings::visit(SettingsWriter());
+void ButtonConfigWidget::writeSettings () {
+  Settings::Settings::visit (SettingsWriter ());
 }
 
-void ButtonConfigWidget::initActionComboBox(QComboBox *comboBox, const Settings::SettingsEntryString& entry)
-{
-  comboBox->clear();
+void ButtonConfigWidget::initActionComboBox (QComboBox *comboBox, const Settings::SettingsEntryString &entry) {
+  comboBox->clear ();
 
   // Create an empty icon, so that all comboboxes have the same alignment
-  QPixmap map = QPixmap(16, 16);
-  map.fill(Qt::transparent);
-  const QIcon emptyIcon = QIcon(map);
+  QPixmap map = QPixmap (16, 16);
+  map.fill (Qt::transparent);
+  const QIcon emptyIcon = QIcon (map);
 
-  comboBox->addItem(emptyIcon, QString::fromStdString(_("None")), "");
-  comboBox->addItem(emptyIcon, QString::fromStdString(_("Toggle Perspective")), "viewActionTogglePerspective");
+  comboBox->addItem (emptyIcon, QString::fromStdString (_ ("None")), "");
+  comboBox->addItem (emptyIcon, QString::fromStdString (_ ("Toggle Perspective")), "viewActionTogglePerspective");
 
-  for (const auto& action : InputDriverManager::instance()->getActions()) {
+  for (const auto &action : InputDriverManager::instance ()->getActions ()) {
     const auto icon = action.icon;
-    const auto effectiveIcon = icon.isNull() ? emptyIcon : icon;
-    const auto desc = QString(action.description).remove(QChar('&'));
-    comboBox->addItem(effectiveIcon, desc, action.name);
+    const auto effectiveIcon = icon.isNull () ? emptyIcon : icon;
+    const auto desc = QString (action.description).remove (QChar ('&'));
+    comboBox->addItem (effectiveIcon, desc, action.name);
   }
 
-  updateComboBox(comboBox, entry);
+  updateComboBox (comboBox, entry);
 }
 
-void ButtonConfigWidget::updateStates(){
-  if (!initialized) return;
+void ButtonConfigWidget::updateStates () {
+  if (!initialized)
+    return;
 
-  size_t cnt = InputDriverManager::instance()->getButtonCount();
-  for (size_t i = 0; i < InputEventMapper::getMaxButtons(); ++i) {
-    auto label = this->findChild<QLabel *>(QString("labelInputButton%1").arg(i));
+  size_t cnt = InputDriverManager::instance ()->getButtonCount ();
+  for (size_t i = 0; i < InputEventMapper::getMaxButtons (); ++i) {
+    auto label = this->findChild<QLabel *> (QString ("labelInputButton%1").arg (i));
     if (label) {
       QString style = (cnt <= i) ? ButtonConfigWidget::DisabledStyleString : ButtonConfigWidget::EmptyString;
-      label->setStyleSheet(style);
+      label->setStyleSheet (style);
     }
   }
 }
diff --git a/src/gui/input/ButtonConfigWidget.h b/src/gui/input/ButtonConfigWidget.h
index d811b2b6b..df4921a8d 100644
--- a/src/gui/input/ButtonConfigWidget.h
+++ b/src/gui/input/ButtonConfigWidget.h
@@ -11,52 +11,52 @@ class ButtonConfigWidget : public QWidget, public Ui::Button
   Q_OBJECT
 
 public:
-  ButtonConfigWidget(QWidget *parent = nullptr);
-  void updateButtonState(int, bool) const;
-  void init();
-  void updateStates();
+  ButtonConfigWidget (QWidget *parent = nullptr);
+  void updateButtonState (int, bool) const;
+  void init ();
+  void updateStates ();
 
 public slots:
-  void on_comboBoxButton0_activated(int val);
-  void on_comboBoxButton1_activated(int val);
-  void on_comboBoxButton2_activated(int val);
-  void on_comboBoxButton3_activated(int val);
-  void on_comboBoxButton4_activated(int val);
-  void on_comboBoxButton5_activated(int val);
-  void on_comboBoxButton6_activated(int val);
-  void on_comboBoxButton7_activated(int val);
-  void on_comboBoxButton8_activated(int val);
-  void on_comboBoxButton9_activated(int val);
-  void on_comboBoxButton10_activated(int val);
-  void on_comboBoxButton11_activated(int val);
-  void on_comboBoxButton12_activated(int val);
-  void on_comboBoxButton13_activated(int val);
-  void on_comboBoxButton14_activated(int val);
-  void on_comboBoxButton15_activated(int val);
-  void on_comboBoxButton16_activated(int val);
-  void on_comboBoxButton17_activated(int val);
-  void on_comboBoxButton18_activated(int val);
-  void on_comboBoxButton19_activated(int val);
-  void on_comboBoxButton20_activated(int val);
-  void on_comboBoxButton21_activated(int val);
-  void on_comboBoxButton22_activated(int val);
-  void on_comboBoxButton23_activated(int val);
+  void on_comboBoxButton0_activated (int val);
+  void on_comboBoxButton1_activated (int val);
+  void on_comboBoxButton2_activated (int val);
+  void on_comboBoxButton3_activated (int val);
+  void on_comboBoxButton4_activated (int val);
+  void on_comboBoxButton5_activated (int val);
+  void on_comboBoxButton6_activated (int val);
+  void on_comboBoxButton7_activated (int val);
+  void on_comboBoxButton8_activated (int val);
+  void on_comboBoxButton9_activated (int val);
+  void on_comboBoxButton10_activated (int val);
+  void on_comboBoxButton11_activated (int val);
+  void on_comboBoxButton12_activated (int val);
+  void on_comboBoxButton13_activated (int val);
+  void on_comboBoxButton14_activated (int val);
+  void on_comboBoxButton15_activated (int val);
+  void on_comboBoxButton16_activated (int val);
+  void on_comboBoxButton17_activated (int val);
+  void on_comboBoxButton18_activated (int val);
+  void on_comboBoxButton19_activated (int val);
+  void on_comboBoxButton20_activated (int val);
+  void on_comboBoxButton21_activated (int val);
+  void on_comboBoxButton22_activated (int val);
+  void on_comboBoxButton23_activated (int val);
 
 signals:
-  void inputMappingChanged() const;
+  void inputMappingChanged () const;
 
 private:
   /** Initialize combobox list values from the settings range values */
-  void initActionComboBox(QComboBox *comboBox, const Settings::SettingsEntryString& entry);
+  void initActionComboBox (QComboBox *comboBox, const Settings::SettingsEntryString &entry);
   /** Update combobox from current settings */
-  void updateComboBox(QComboBox *comboBox, const Settings::SettingsEntryString& entry);
+  void updateComboBox (QComboBox *comboBox, const Settings::SettingsEntryString &entry);
   /** Set value from combobox to settings */
-  void applyComboBox(QComboBox *comboBox, int val, Settings::SettingsEntryString& entry);
-  void writeSettings();
+  void applyComboBox (QComboBox *comboBox, int val, Settings::SettingsEntryString &entry);
+  void writeSettings ();
 
-  const QString EmptyString = QString("");
-  const QString ActiveStyleString = QString("font-weight: bold; color: red");
-  const QString DisabledStyleString = QString("color: gray");
+  const QString EmptyString = QString ("");
+  const QString ActiveStyleString = QString ("font-weight: bold; color: red");
+  const QString DisabledStyleString = QString ("color: gray");
 
   bool initialized = false;
 };
diff --git a/src/gui/input/DBusInputDriver.cc b/src/gui/input/DBusInputDriver.cc
index b547ffd9d..239850b31 100644
--- a/src/gui/input/DBusInputDriver.cc
+++ b/src/gui/input/DBusInputDriver.cc
@@ -32,124 +32,102 @@
 #include "openscad_adaptor.h"
 #include "openscad_interface.h"
 
-void DBusInputDriver::run()
-{
-
+void DBusInputDriver::run () {
 }
 
-DBusInputDriver::DBusInputDriver()
-{
+DBusInputDriver::DBusInputDriver () {
   name = "DBusInputDriver";
 }
 
-bool DBusInputDriver::openOnce() const
-{
+bool DBusInputDriver::openOnce () const {
   return true;
 }
 
-bool DBusInputDriver::isOpen() const
-{
+bool DBusInputDriver::isOpen () const {
   return is_open;
 }
 
-bool DBusInputDriver::open()
-{
+bool DBusInputDriver::open () {
   if (is_open) {
     return true;
   }
 
-  QDBusConnection connection = QDBusConnection::sessionBus();
-  if (!connection.isConnected()) {
+  QDBusConnection connection = QDBusConnection::sessionBus ();
+  if (!connection.isConnected ()) {
     return false;
   }
 
-  new OpenSCADAdaptor(this);
-  connection.registerObject("/org/openscad/OpenSCAD/Application", this);
-  connection.registerService("org.openscad.OpenSCAD");
-  new org::openscad::OpenSCAD(QString(), QString(), connection, this);
+  new OpenSCADAdaptor (this);
+  connection.registerObject ("/org/openscad/OpenSCAD/Application", this);
+  connection.registerService ("org.openscad.OpenSCAD");
+  new org::openscad::OpenSCAD (QString (), QString (), connection, this);
 
-  name = "DBusInputDriver (" + connection.baseService().toStdString() + ")";
+  name = "DBusInputDriver (" + connection.baseService ().toStdString () + ")";
 
   is_open = true;
   return true;
 }
 
-void DBusInputDriver::close()
-{
-
+void DBusInputDriver::close () {
 }
 
-void DBusInputDriver::zoom(double zoom) const
-{
-  InputDriverManager::instance()->sendEvent(new InputEventZoom(zoom, true, false));
+void DBusInputDriver::zoom (double zoom) const {
+  InputDriverManager::instance ()->sendEvent (new InputEventZoom (zoom, true, false));
 }
 
-void DBusInputDriver::zoomTo(double zoom) const
-{
-  InputDriverManager::instance()->sendEvent(new InputEventZoom(zoom, false, false));
+void DBusInputDriver::zoomTo (double zoom) const {
+  InputDriverManager::instance ()->sendEvent (new InputEventZoom (zoom, false, false));
 }
 
-void DBusInputDriver::rotate(double x, double y, double z) const
-{
-  InputDriverManager::instance()->sendEvent(new InputEventRotate(x, y, z, true, false));
+void DBusInputDriver::rotate (double x, double y, double z) const {
+  InputDriverManager::instance ()->sendEvent (new InputEventRotate (x, y, z, true, false));
 }
 
-void DBusInputDriver::rotateTo(double x, double y, double z) const
-{
-  InputDriverManager::instance()->sendEvent(new InputEventRotate(x, y, z, false, false));
+void DBusInputDriver::rotateTo (double x, double y, double z) const {
+  InputDriverManager::instance ()->sendEvent (new InputEventRotate (x, y, z, false, false));
 }
 
-void DBusInputDriver::rotateByVector(double x, double y, double z) const
-{
-  InputDriverManager::instance()->sendEvent(new InputEventRotate2(x, y, z, false));
+void DBusInputDriver::rotateByVector (double x, double y, double z) const {
+  InputDriverManager::instance ()->sendEvent (new InputEventRotate2 (x, y, z, false));
 }
 
-void DBusInputDriver::translate(double x, double y, double z) const
-{
-  InputDriverManager::instance()->sendEvent(new InputEventTranslate(x, y, z, true, false, false));
+void DBusInputDriver::translate (double x, double y, double z) const {
+  InputDriverManager::instance ()->sendEvent (new InputEventTranslate (x, y, z, true, false, false));
 }
 
-void DBusInputDriver::translateTo(double x, double y, double z) const
-{
-  InputDriverManager::instance()->sendEvent(new InputEventTranslate(x, y, z, false, false, false));
+void DBusInputDriver::translateTo (double x, double y, double z) const {
+  InputDriverManager::instance ()->sendEvent (new InputEventTranslate (x, y, z, false, false, false));
 }
 
-void DBusInputDriver::action(const QString& name) const
-{
-  InputDriverManager::instance()->sendEvent(new InputEventAction(name.toStdString(), false));
+void DBusInputDriver::action (const QString &name) const {
+  InputDriverManager::instance ()->sendEvent (new InputEventAction (name.toStdString (), false));
 }
 
-const QStringList DBusInputDriver::getActions() const
-{
+const QStringList DBusInputDriver::getActions () const {
   QStringList ret;
-  for (const auto& action : InputDriverManager::instance()->getActions()) {
+  for (const auto &action : InputDriverManager::instance ()->getActions ()) {
     ret << action.name;
   }
   return ret;
 }
 
-void DBusInputDriver::buttonPress(uint idx) const
-{
-  InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(idx, true, false));
-  InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(idx, false, false));
+void DBusInputDriver::buttonPress (uint idx) const {
+  InputDriverManager::instance ()->sendEvent (new InputEventButtonChanged (idx, true, false));
+  InputDriverManager::instance ()->sendEvent (new InputEventButtonChanged (idx, false, false));
 }
 
-const QList<double> DBusInputDriver::getRotation() const
-{
-  return InputDriverManager::instance()->getRotation();
+const QList<double> DBusInputDriver::getRotation () const {
+  return InputDriverManager::instance ()->getRotation ();
 }
 
-const QList<double> DBusInputDriver::getTranslation() const
-{
-  return InputDriverManager::instance()->getTranslation();
+const QList<double> DBusInputDriver::getTranslation () const {
+  return InputDriverManager::instance ()->getTranslation ();
 }
 
-const std::string& DBusInputDriver::get_name() const
-{
+const std::string &DBusInputDriver::get_name () const {
   return this->name;
 }
 
-std::string DBusInputDriver::get_info() const
-{
-  return STR(get_name(), " ", (isOpen() ? "open" : "not open"));
+std::string DBusInputDriver::get_info () const {
+  return STR (get_name (), " ", (isOpen () ? "open" : "not open"));
 }
diff --git a/src/gui/input/DBusInputDriver.h b/src/gui/input/DBusInputDriver.h
index e4cc2fd0a..9d7336e42 100644
--- a/src/gui/input/DBusInputDriver.h
+++ b/src/gui/input/DBusInputDriver.h
@@ -40,27 +40,27 @@ class DBusInputDriver : public InputDriver
   std::string name;
 
 public:
-  DBusInputDriver();
-  void run() override;
-  bool open() override;
-  void close() override;
-  bool isOpen() const override;
-  bool openOnce() const override;
+  DBusInputDriver ();
+  void run () override;
+  bool open () override;
+  void close () override;
+  bool isOpen () const override;
+  bool openOnce () const override;
 
-  const std::string& get_name() const override;
-  std::string get_info() const override;
+  const std::string &get_name () const override;
+  std::string get_info () const override;
 
 public slots:
-  void zoom(double zoom) const;
-  void zoomTo(double zoom) const;
-  void rotate(double x, double y, double z) const;
-  void rotateTo(double x, double y, double z) const;
-  void rotateByVector(double x, double y, double z) const;
-  void translate(double x, double y, double z) const;
-  void translateTo(double x, double y, double z) const;
-  void action(const QString& action) const;
-  void buttonPress(uint idx) const;
-  const QList<double> getRotation() const;
-  const QList<double> getTranslation() const;
-  const QStringList getActions() const;
+  void zoom (double zoom) const;
+  void zoomTo (double zoom) const;
+  void rotate (double x, double y, double z) const;
+  void rotateTo (double x, double y, double z) const;
+  void rotateByVector (double x, double y, double z) const;
+  void translate (double x, double y, double z) const;
+  void translateTo (double x, double y, double z) const;
+  void action (const QString &action) const;
+  void buttonPress (uint idx) const;
+  const QList<double> getRotation () const;
+  const QList<double> getTranslation () const;
+  const QStringList getActions () const;
 };
diff --git a/src/gui/input/HidApiInputDriver.cc b/src/gui/input/HidApiInputDriver.cc
index b978568e6..7254b56ae 100644
--- a/src/gui/input/HidApiInputDriver.cc
+++ b/src/gui/input/HidApiInputDriver.cc
@@ -60,66 +60,63 @@ static ch::system_clock::time_point logtime;
 // http://www.linux-usb.org/usb.ids
 // http://www.3dconnexion.eu/nc/service/faq/show_faq/7ece50ed-0b39-b57e-d3b2-4afd9420604e.html
 static const struct device_id device_ids[] = {
-  { 0x046d, 0xc603, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Spacemouse Plus XT"},
-  { 0x046d, 0xc605, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion CADman"},
-  { 0x046d, 0xc606, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Spacemouse Classic"},
-  { 0x046d, 0xc621, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Spaceball 5000"},
-  { 0x046d, 0xc623, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Traveller 3D Mouse"},
-  { 0x046d, 0xc625, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Pilot 3D Mouse"},
-  { 0x046d, 0xc626, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Navigator 3D Mouse"},
-  { 0x046d, 0xc627, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Explorer 3D Mouse"},
-  { 0x046d, 0xc628, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Navigator for Notebooks"},
-  { 0x046d, 0xc629, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion SpacePilot Pro 3D Mouse"},
-  { 0x046d, 0xc62b, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Pro"},
-  { 0x256f, 0xc62e, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Wireless (cabled)"},
-  { 0x256f, 0xc62f, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Wireless"},
-  { 0x256f, 0xc631, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Pro Wireless (cabled)"},
-  { 0x256f, 0xc632, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Pro Wireless"},
-  { 0x256f, 0xc635, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Compact"},
-  { 0x256f, 0xc63a, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Wireless BT"},
+  {0x046d, 0xc603, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Spacemouse Plus XT"},
+  {0x046d, 0xc605, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion CADman"},
+  {0x046d, 0xc606, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Spacemouse Classic"},
+  {0x046d, 0xc621, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Spaceball 5000"},
+  {0x046d, 0xc623, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Traveller 3D Mouse"},
+  {0x046d, 0xc625, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Pilot 3D Mouse"},
+  {0x046d, 0xc626, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Navigator 3D Mouse"},
+  {0x046d, 0xc627, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Explorer 3D Mouse"},
+  {0x046d, 0xc628, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Navigator for Notebooks"},
+  {0x046d, 0xc629, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion SpacePilot Pro 3D Mouse"},
+  {0x046d, 0xc62b, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Pro"},
+  {0x256f, 0xc62e, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Wireless (cabled)"},
+  {0x256f, 0xc62f, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Wireless"},
+  {0x256f, 0xc631, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Pro Wireless (cabled)"},
+  {0x256f, 0xc632, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Pro Wireless"},
+  {0x256f, 0xc635, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Compact"},
+  {0x256f, 0xc63a, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Wireless BT"},
   // This is reported to be used with a 3Dconnexion Space Mouse Wireless 256f:c62e
-  { 0x256f, 0xc652, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Universal Receiver"},
-  { -1, -1, nullptr, nullptr, nullptr},
+  {0x256f, 0xc652, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Universal Receiver"},
+  {-1, -1, nullptr, nullptr, nullptr},
 };
 
-#define HIDAPI_LOG(f) hidapi_log(boost::format(f))
+#define HIDAPI_LOG(f) hidapi_log (boost::format (f))
 // NOLINTNEXTLINE(*macro-parentheses)
-#define HIDAPI_LOGP(f, a) hidapi_log(boost::format(f) % a)
-static void hidapi_log(const boost::format& format) {
+#define HIDAPI_LOGP(f, a) hidapi_log (boost::format (f) % a)
+static void hidapi_log (const boost::format &format) {
   if (logstream) {
-    const ch::system_clock::duration time = ch::system_clock::now() - logtime;
+    const ch::system_clock::duration time = ch::system_clock::now () - logtime;
 
-    logstream << ch::duration_cast<ch::milliseconds>(time).count() << ": " << format.str() << std::endl;
-    if (logstream.tellp() > MAX_LOG_SIZE) {
-      logstream.close();
+    logstream << ch::duration_cast<ch::milliseconds> (time).count () << ": " << format.str () << std::endl;
+    if (logstream.tellp () > MAX_LOG_SIZE) {
+      logstream.close ();
     }
   }
 }
 
-static void hidapi_log_input(unsigned char *buf, int len)
-{
+static void hidapi_log_input (unsigned char *buf, int len) {
   if (logstream) {
     std::ostringstream s;
 
-    s << (boost::format("R: %1$2d/%1$02x:") % len).str();
+    s << (boost::format ("R: %1$2d/%1$02x:") % len).str ();
     for (int idx = 0; idx < len; ++idx) {
-      s << (boost::format(" %1$02x") % (int)buf[idx]).str();
+      s << (boost::format (" %1$02x") % (int)buf[idx]).str ();
     }
-    HIDAPI_LOG(s.str());
+    HIDAPI_LOG (s.str ());
   }
 }
 
-static std::string to_string(const wchar_t *wstr)
-{
+static std::string to_string (const wchar_t *wstr) {
   if (wstr) {
     std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> conv;
-    return conv.to_bytes(wstr);
+    return conv.to_bytes (wstr);
   }
   return "<null>";
 }
 
-static const device_id *match_device(const struct hid_device_info *info)
-{
+static const device_id *match_device (const struct hid_device_info *info) {
   for (int idx = 0; device_ids[idx].name != nullptr; ++idx) {
     if ((device_ids[idx].vendor_id == info->vendor_id) && (device_ids[idx].product_id == info->product_id)) {
       return &device_ids[idx];
@@ -128,18 +125,15 @@ static const device_id *match_device(const struct hid_device_info *info)
   return nullptr;
 }
 
-HidApiInputDriver::HidApiInputDriver()
-{
+HidApiInputDriver::HidApiInputDriver () {
   name = "HidApiInputDriver";
 }
 
-void HidApiInputDriver::run()
-{
-  hidapi_input(hid_dev);
+void HidApiInputDriver::run () {
+  hidapi_input (hid_dev);
 }
 
-void HidApiInputDriver::hidapi_decode_axis(const unsigned char *buf, unsigned int len)
-{
+void HidApiInputDriver::hidapi_decode_axis (const unsigned char *buf, unsigned int len) {
   if ((buf[0] == 1 || buf[0] == 2) && len == 7) {
     // Values are in the range -10..10 at min. speed and -2595..2595
     // at max. speed.
@@ -153,41 +147,40 @@ void HidApiInputDriver::hidapi_decode_axis(const unsigned char *buf, unsigned in
     const double y = y_value / 350.0;
     const double z = z_value / 350.0;
     if (buf[0] == 1) {
-      InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(0, x));
-      InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(1, y));
-      InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(2, z));
+      InputDriverManager::instance ()->sendEvent (new InputEventAxisChanged (0, x));
+      InputDriverManager::instance ()->sendEvent (new InputEventAxisChanged (1, y));
+      InputDriverManager::instance ()->sendEvent (new InputEventAxisChanged (2, z));
     } else {
-      InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(3, x));
-      InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(4, y));
-      InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(5, z));
+      InputDriverManager::instance ()->sendEvent (new InputEventAxisChanged (3, x));
+      InputDriverManager::instance ()->sendEvent (new InputEventAxisChanged (4, y));
+      InputDriverManager::instance ()->sendEvent (new InputEventAxisChanged (5, z));
     }
   } else if (buf[0] == 1 && len == 13) {
     // Same as above, but all 6 axis is a single 13 byte HID message.
     for (int a = 0; a < 6; ++a) {
       const int16_t i = buf[2 * a + 1] | (buf[2 * a + 2] << 8);
       double val = (double)i / 350.0;
-      if (std::fabs(val) > 0.01) {
-        InputEvent *event = new InputEventAxisChanged(a, val);
-        InputDriverManager::instance()->sendEvent(event);
+      if (std::fabs (val) > 0.01) {
+        InputEvent *event = new InputEventAxisChanged (a, val);
+        InputDriverManager::instance ()->sendEvent (event);
       }
     }
   }
 }
 
-void HidApiInputDriver::hidapi_decode_button(const unsigned char *buf, unsigned int len)
-{
+void HidApiInputDriver::hidapi_decode_button (const unsigned char *buf, unsigned int len) {
   if (buf[0] == 3 && len >= 3) {
     // Handle button events, on Linux the packet has a length of 3 but
     // on Windows the length is 13.
     const uint16_t current = buf[1] | buf[2] << 8;
 
     const std::bitset<16> bits_curr{current};
-    const std::bitset<16> bits_last{buttons};  // NOLINT
+    const std::bitset<16> bits_last{buttons}; // NOLINT
 
     for (int i = 0; i < 16; ++i) {
-      if (bits_curr.test(i) != bits_last.test(i)) {
-        InputEvent *event = new InputEventButtonChanged(i, bits_curr.test(i));
-        InputDriverManager::instance()->sendEvent(event);
+      if (bits_curr.test (i) != bits_last.test (i)) {
+        InputEvent *event = new InputEventButtonChanged (i, bits_curr.test (i));
+        InputDriverManager::instance ()->sendEvent (event);
       }
     }
 
@@ -195,57 +188,52 @@ void HidApiInputDriver::hidapi_decode_button(const unsigned char *buf, unsigned
   }
 }
 
-void HidApiInputDriver::hidapi_input(hid_device *hid_dev)
-{
+void HidApiInputDriver::hidapi_input (hid_device *hid_dev) {
   unsigned char buf[BUFLEN];
   unsigned int len;
-  while ((len = hid_read(hid_dev, buf, BUFLEN)) > 0) {
-    hidapi_log_input(buf, len);
-    (this->*(dev->axis_decoder))(buf, len);
-    (this->*(dev->button_decoder))(buf, len);
+  while ((len = hid_read (hid_dev, buf, BUFLEN)) > 0) {
+    hidapi_log_input (buf, len);
+    (this->*(dev->axis_decoder)) (buf, len);
+    (this->*(dev->button_decoder)) (buf, len);
   }
-  hid_close(hid_dev);
+  hid_close (hid_dev);
 }
 
-std::pair<hid_device *, const struct device_id *> HidApiInputDriver::enumerate() const
-{
+std::pair<hid_device *, const struct device_id *> HidApiInputDriver::enumerate () const {
   hid_device *ret_hid_dev = nullptr;
   const struct device_id *ret_dev = nullptr;
 
-  HIDAPI_LOG("Enumerating HID devices...");
-  struct hid_device_info *info = hid_enumerate(0, 0);
+  HIDAPI_LOG ("Enumerating HID devices...");
+  struct hid_device_info *info = hid_enumerate (0, 0);
   for (; info != nullptr; info = info->next) {
-    HIDAPI_LOGP("D: %04x:%04x | path = %s, serial = %s, manufacturer = %s, product = %s",
-                info->vendor_id % info->product_id % info->path
-                % to_string(info->serial_number)
-                % to_string(info->manufacturer_string)
-                % to_string(info->product_string));
-    const device_id *dev = match_device(info);
+    HIDAPI_LOGP ("D: %04x:%04x | path = %s, serial = %s, manufacturer = %s, product = %s",
+                 info->vendor_id % info->product_id % info->path % to_string (info->serial_number) % to_string (info->manufacturer_string) % to_string (info->product_string));
+    const device_id *dev = match_device (info);
     if (!dev) {
       continue;
     }
 
     hid_device *hid_dev;
 
-    HIDAPI_LOGP("P: %04x:%04x | %s", info->vendor_id % info->product_id % info->path);
-    hid_dev = hid_open_path(info->path);
+    HIDAPI_LOGP ("P: %04x:%04x | %s", info->vendor_id % info->product_id % info->path);
+    hid_dev = hid_open_path (info->path);
 
     if (!hid_dev) {
-      HIDAPI_LOGP("O: %04x:%04x | %s", info->vendor_id % info->product_id % to_string(info->serial_number));
-      hid_dev = hid_open(info->vendor_id, info->product_id, info->serial_number);
+      HIDAPI_LOGP ("O: %04x:%04x | %s", info->vendor_id % info->product_id % to_string (info->serial_number));
+      hid_dev = hid_open (info->vendor_id, info->product_id, info->serial_number);
       if (!hid_dev) {
         continue;
       }
     }
 
-    HIDAPI_LOGP("R: %04x:%04x | %s", info->vendor_id % info->product_id % to_string(info->serial_number));
+    HIDAPI_LOGP ("R: %04x:%04x | %s", info->vendor_id % info->product_id % to_string (info->serial_number));
     unsigned char buf[BUFLEN];
-    const int len = hid_read_timeout(hid_dev, buf, BUFLEN, 100);
-    HIDAPI_LOGP("?: %d", len);
+    const int len = hid_read_timeout (hid_dev, buf, BUFLEN, 100);
+    HIDAPI_LOGP ("?: %d", len);
 
     if (len < 0) {
-      HIDAPI_LOGP("E: %s", to_string(hid_error(hid_dev)));
-      hid_close(hid_dev);
+      HIDAPI_LOGP ("E: %s", to_string (hid_error (hid_dev)));
+      hid_close (hid_dev);
       continue;
     }
 
@@ -253,58 +241,54 @@ std::pair<hid_device *, const struct device_id *> HidApiInputDriver::enumerate()
     ret_hid_dev = hid_dev;
     break;
   }
-  hid_free_enumeration(info);
-  HIDAPI_LOGP("Done enumerating (status = %s).", (ret_hid_dev != nullptr ? "ok" : "failed"));
+  hid_free_enumeration (info);
+  HIDAPI_LOGP ("Done enumerating (status = %s).", (ret_hid_dev != nullptr ? "ok" : "failed"));
   return {ret_hid_dev, ret_dev};
 }
 
-bool HidApiInputDriver::open()
-{
-  if (Settings::Settings::inputEnableDriverHIDAPILog.value()) {
-    logtime = ch::system_clock::now();
-    logstream.open(PlatformUtils::backupPath() + "/hidapi.log");
+bool HidApiInputDriver::open () {
+  if (Settings::Settings::inputEnableDriverHIDAPILog.value ()) {
+    logtime = ch::system_clock::now ();
+    logstream.open (PlatformUtils::backupPath () + "/hidapi.log");
   }
 
-  HIDAPI_LOG("HidApiInputDriver::open()");
-  if (hid_init() < 0) {
-    HIDAPI_LOG("hid_init() failed");
-    PRINTD("Can't hid_init().\n");
+  HIDAPI_LOG ("HidApiInputDriver::open()");
+  if (hid_init () < 0) {
+    HIDAPI_LOG ("hid_init() failed");
+    PRINTD ("Can't hid_init().\n");
     return false;
   }
 
-  std::tie(this->hid_dev, this->dev) = enumerate();
+  std::tie (this->hid_dev, this->dev) = enumerate ();
   if (this->dev) {
-    name = STR(std::setfill('0'), std::setw(4), std::hex,
-               "HidApiInputDriver (", dev->vendor_id, ":", dev->product_id,
-               " - ", dev->name, ")");
-    start();
-    HIDAPI_LOGP("HidApiInputDriver::open(): %s", name);
+    name = STR (std::setfill ('0'), std::setw (4), std::hex,
+                "HidApiInputDriver (", dev->vendor_id, ":", dev->product_id,
+                " - ", dev->name, ")");
+    start ();
+    HIDAPI_LOGP ("HidApiInputDriver::open(): %s", name);
     return true;
   }
 
-  HIDAPI_LOG("HidApiInputDriver::open(): No matching device found.");
+  HIDAPI_LOG ("HidApiInputDriver::open(): No matching device found.");
   return false;
 }
 
-void HidApiInputDriver::close()
-{
+void HidApiInputDriver::close () {
   this->dev = nullptr;
   this->hid_dev = nullptr;
   this->name = "HidApiInputDriver";
-  HIDAPI_LOG("HidApiInputDriver::close()");
-  logstream.close();
+  HIDAPI_LOG ("HidApiInputDriver::close()");
+  logstream.close ();
 }
 
-const std::string& HidApiInputDriver::get_name() const
-{
+const std::string &HidApiInputDriver::get_name () const {
   return name;
 }
 
-std::string HidApiInputDriver::get_info() const
-{
+std::string HidApiInputDriver::get_info () const {
   std::ostringstream stream;
-  stream << get_name() << " ";
-  if (isOpen()) {
+  stream << get_name () << " ";
+  if (isOpen ()) {
     stream << "open" << " ";
     if (dev) {
       stream << "Vendor ID: " << dev->vendor_id << " ";
@@ -313,5 +297,5 @@ std::string HidApiInputDriver::get_info() const
   } else {
     stream << "not open";
   }
-  return stream.str();
+  return stream.str ();
 }
diff --git a/src/gui/input/HidApiInputDriver.h b/src/gui/input/HidApiInputDriver.h
index 7bb8171c2..138c26319 100644
--- a/src/gui/input/HidApiInputDriver.h
+++ b/src/gui/input/HidApiInputDriver.h
@@ -40,36 +40,36 @@ class HidApiInputDriver : public InputDriver
   std::string name;
   unsigned int buttons{0};
   hid_device *hid_dev{nullptr};
-  const struct device_id *dev {nullptr};
+  const struct device_id *dev{nullptr};
 
 public:
-  HidApiInputDriver();
-  void run() override;
-  bool open() override;
-  void close() override;
+  HidApiInputDriver ();
+  void run () override;
+  bool open () override;
+  void close () override;
 
-  const std::string& get_name() const override;
-  std::string get_info() const override;
+  const std::string &get_name () const override;
+  std::string get_info () const override;
 
-  void hidapi_decode_axis(const unsigned char *buf, unsigned int len);
-  void hidapi_decode_button(const unsigned char *buf, unsigned int len);
+  void hidapi_decode_axis (const unsigned char *buf, unsigned int len);
+  void hidapi_decode_button (const unsigned char *buf, unsigned int len);
 
-  size_t getButtonCount() const override {
+  size_t getButtonCount () const override {
     return Settings::max_buttons;
   }
-  size_t getAxisCount() const override {
+  size_t getAxisCount () const override {
     return Settings::max_axis;
   }
 
 private:
-  std::pair<hid_device *, const struct device_id *> enumerate() const;
-  void hidapi_input(hid_device *hid_dev);
+  std::pair<hid_device *, const struct device_id *> enumerate () const;
+  void hidapi_input (hid_device *hid_dev);
 };
 
 struct device_id {
   int vendor_id;
   int product_id;
-  void (HidApiInputDriver::*axis_decoder)(const unsigned char *buf, unsigned int len);
-  void (HidApiInputDriver::*button_decoder)(const unsigned char *buf, unsigned int len);
+  void (HidApiInputDriver::*axis_decoder) (const unsigned char *buf, unsigned int len);
+  void (HidApiInputDriver::*button_decoder) (const unsigned char *buf, unsigned int len);
   const char *name;
 };
diff --git a/src/gui/input/InputDriver.cc b/src/gui/input/InputDriver.cc
index 976e71585..65fa173e3 100644
--- a/src/gui/input/InputDriver.cc
+++ b/src/gui/input/InputDriver.cc
@@ -27,19 +27,17 @@
 #include <QEvent>
 #include "gui/input/InputDriverEvent.h"
 
-const QEvent::Type InputEvent::eventType = static_cast<QEvent::Type>(QEvent::registerEventType());
-
-InputEvent::InputEvent(const bool activeOnly) : QEvent(eventType), activeOnly(activeOnly)
-{
+const QEvent::Type InputEvent::eventType = static_cast<QEvent::Type> (QEvent::registerEventType ());
 
+InputEvent::InputEvent (const bool activeOnly)
+  : QEvent (eventType)
+  , activeOnly (activeOnly) {
 }
 
-bool InputDriver::isOpen() const
-{
-  return isRunning();
+bool InputDriver::isOpen () const {
+  return isRunning ();
 }
 
-bool InputDriver::openOnce() const
-{
+bool InputDriver::openOnce () const {
   return false;
 }
diff --git a/src/gui/input/InputDriver.h b/src/gui/input/InputDriver.h
index cccde19d3..8dac64d67 100644
--- a/src/gui/input/InputDriver.h
+++ b/src/gui/input/InputDriver.h
@@ -32,26 +32,30 @@
 class InputDriver : public QThread
 {
 public:
-  InputDriver() = default;
+  InputDriver () = default;
 
-  virtual const std::string& get_name() const = 0;
-  virtual std::string get_info() const = 0;
+  virtual const std::string &get_name () const = 0;
+  virtual std::string get_info () const = 0;
 
-  virtual bool open() = 0;
-  virtual void close() = 0;
+  virtual bool open () = 0;
+  virtual void close () = 0;
 
   /*
    * Return if the driver is currently opened. The default implementation
    * simply returns the {@link #isRunning()} status of the thread.
    */
-  virtual bool isOpen() const;
+  virtual bool isOpen () const;
 
   /*
    * Drivers that are not connected to a device and can be opened on
    * application start. No attempt to re-open is made.
    */
-  virtual bool openOnce() const;
+  virtual bool openOnce () const;
 
-  virtual size_t getButtonCount() const {return 0;}
-  virtual size_t getAxisCount() const {return 0;}
+  virtual size_t getButtonCount () const {
+    return 0;
+  }
+  virtual size_t getAxisCount () const {
+    return 0;
+  }
 };
diff --git a/src/gui/input/InputDriverEvent.h b/src/gui/input/InputDriverEvent.h
index db88c1d98..7f0bdd938 100644
--- a/src/gui/input/InputDriverEvent.h
+++ b/src/gui/input/InputDriverEvent.h
@@ -32,17 +32,16 @@
 class InputEventHandler
 {
 public:
+  virtual ~InputEventHandler () = default;
 
-  virtual ~InputEventHandler() = default;
+  virtual void onAxisChanged (class InputEventAxisChanged *event) = 0;
+  virtual void onButtonChanged (class InputEventButtonChanged *event) = 0;
 
-  virtual void onAxisChanged(class InputEventAxisChanged *event) = 0;
-  virtual void onButtonChanged(class InputEventButtonChanged *event) = 0;
-
-  virtual void onTranslateEvent(class InputEventTranslate *event) = 0;
-  virtual void onRotateEvent(class InputEventRotate *event) = 0;
-  virtual void onRotate2Event(class InputEventRotate2 *event) = 0;
-  virtual void onActionEvent(class InputEventAction *event) = 0;
-  virtual void onZoomEvent(class InputEventZoom *event) = 0;
+  virtual void onTranslateEvent (class InputEventTranslate *event) = 0;
+  virtual void onRotateEvent (class InputEventRotate *event) = 0;
+  virtual void onRotate2Event (class InputEventRotate2 *event) = 0;
+  virtual void onActionEvent (class InputEventAction *event) = 0;
+  virtual void onZoomEvent (class InputEventZoom *event) = 0;
 };
 
 class InputEvent : public QEvent
@@ -50,9 +49,9 @@ class InputEvent : public QEvent
 public:
   const bool activeOnly;
 
-  InputEvent(const bool activeOnly = true);
+  InputEvent (const bool activeOnly = true);
 
-  virtual void deliver(InputEventHandler *receiver) = 0;
+  virtual void deliver (InputEventHandler *receiver) = 0;
 
   static const QEvent::Type eventType;
 };
@@ -60,7 +59,8 @@ public:
 class GenericInputEvent : public InputEvent
 {
 public:
-  GenericInputEvent(const bool activeOnly = true) : InputEvent(activeOnly) { }
+  GenericInputEvent (const bool activeOnly = true)
+    : InputEvent (activeOnly) {}
 };
 
 /**
@@ -74,11 +74,13 @@ public:
   const unsigned int axis;
   const double value;
 
-  InputEventAxisChanged(const unsigned int axis, const double value, const bool activeOnly = true) : GenericInputEvent(activeOnly), axis(axis), value(value) { }
+  InputEventAxisChanged (const unsigned int axis, const double value, const bool activeOnly = true)
+    : GenericInputEvent (activeOnly)
+    , axis (axis)
+    , value (value) {}
 
-  void deliver(InputEventHandler *receiver) override
-  {
-    receiver->onAxisChanged(this);
+  void deliver (InputEventHandler *receiver) override {
+    receiver->onAxisChanged (this);
   }
 };
 
@@ -92,11 +94,13 @@ public:
   const unsigned int button;
   const bool down;
 
-  InputEventButtonChanged(const unsigned int button, const bool down, const bool activeOnly = true) : GenericInputEvent(activeOnly), button(button), down(down) { }
+  InputEventButtonChanged (const unsigned int button, const bool down, const bool activeOnly = true)
+    : GenericInputEvent (activeOnly)
+    , button (button)
+    , down (down) {}
 
-  void deliver(InputEventHandler *receiver) override
-  {
-    receiver->onButtonChanged(this);
+  void deliver (InputEventHandler *receiver) override {
+    receiver->onButtonChanged (this);
   }
 };
 
@@ -115,11 +119,16 @@ public:
   const double z;
   const bool relative;
   const bool viewPortRelative;
-  InputEventTranslate(const double x, const double y, const double z, const bool relative = true, const bool viewPortRelative = false, const bool activeOnly = true) : InputEvent(activeOnly), x(x), y(y), z(z), relative(relative), viewPortRelative(viewPortRelative) { }
-
-  void deliver(InputEventHandler *receiver) override
-  {
-    receiver->onTranslateEvent(this);
+  InputEventTranslate (const double x, const double y, const double z, const bool relative = true, const bool viewPortRelative = false, const bool activeOnly = true)
+    : InputEvent (activeOnly)
+    , x (x)
+    , y (y)
+    , z (z)
+    , relative (relative)
+    , viewPortRelative (viewPortRelative) {}
+
+  void deliver (InputEventHandler *receiver) override {
+    receiver->onTranslateEvent (this);
   }
 };
 
@@ -131,11 +140,15 @@ public:
   const double z;
   const bool relative;
 
-  InputEventRotate(const double x, const double y, const double z, const bool relative = true, const bool activeOnly = true) : InputEvent(activeOnly), x(x), y(y), z(z), relative(relative) { }
+  InputEventRotate (const double x, const double y, const double z, const bool relative = true, const bool activeOnly = true)
+    : InputEvent (activeOnly)
+    , x (x)
+    , y (y)
+    , z (z)
+    , relative (relative) {}
 
-  void deliver(InputEventHandler *receiver) override
-  {
-    receiver->onRotateEvent(this);
+  void deliver (InputEventHandler *receiver) override {
+    receiver->onRotateEvent (this);
   }
 };
 
@@ -146,11 +159,14 @@ public:
   const double y;
   const double z;
 
-  InputEventRotate2(const double x, const double y, const double z, const bool activeOnly = true) : InputEvent(activeOnly), x(x), y(y), z(z) { }
+  InputEventRotate2 (const double x, const double y, const double z, const bool activeOnly = true)
+    : InputEvent (activeOnly)
+    , x (x)
+    , y (y)
+    , z (z) {}
 
-  void deliver(InputEventHandler *receiver) override
-  {
-    receiver->onRotate2Event(this);
+  void deliver (InputEventHandler *receiver) override {
+    receiver->onRotate2Event (this);
   }
 };
 
@@ -160,11 +176,13 @@ public:
   const double zoom;
   const bool relative;
 
-  InputEventZoom(const double zoom, const bool relative = true, const bool activeOnly = true) : InputEvent(activeOnly), zoom(zoom), relative(relative) { }
+  InputEventZoom (const double zoom, const bool relative = true, const bool activeOnly = true)
+    : InputEvent (activeOnly)
+    , zoom (zoom)
+    , relative (relative) {}
 
-  void deliver(InputEventHandler *receiver) override
-  {
-    receiver->onZoomEvent(this);
+  void deliver (InputEventHandler *receiver) override {
+    receiver->onZoomEvent (this);
   }
 };
 
@@ -173,10 +191,11 @@ class InputEventAction : public InputEvent
 public:
   const std::string action;
 
-  InputEventAction(std::string action, const bool activeOnly = true) : InputEvent(activeOnly), action(std::move(action)) { }
+  InputEventAction (std::string action, const bool activeOnly = true)
+    : InputEvent (activeOnly)
+    , action (std::move (action)) {}
 
-  void deliver(InputEventHandler *receiver) override
-  {
-    receiver->onActionEvent(this);
+  void deliver (InputEventHandler *receiver) override {
+    receiver->onActionEvent (this);
   }
 };
diff --git a/src/gui/input/InputDriverManager.cc b/src/gui/input/InputDriverManager.cc
index 7d4d855bd..5e70a881d 100644
--- a/src/gui/input/InputDriverManager.cc
+++ b/src/gui/input/InputDriverManager.cc
@@ -46,195 +46,176 @@ InputDriverManager *InputDriverManager::self = nullptr;
  * This can be called from non-GUI context, so no Qt initialization is done
  * at this point.
  */
-InputDriverManager *InputDriverManager::instance()
-{
+InputDriverManager *InputDriverManager::instance () {
   if (!self) {
-    self = new InputDriverManager();
+    self = new InputDriverManager ();
   }
   return self;
 }
 
-void InputDriverManager::registerDriver(InputDriver *driver)
-{
-  this->drivers.push_back(driver);
+void InputDriverManager::registerDriver (InputDriver *driver) {
+  this->drivers.push_back (driver);
 }
 
-void InputDriverManager::unregisterDriver(InputDriver *driver)
-{
-  this->drivers.remove(driver);
+void InputDriverManager::unregisterDriver (InputDriver *driver) {
+  this->drivers.remove (driver);
 }
 
-void InputDriverManager::registerActions(const QList<QAction *>& actions, const QString& parent, const QString& target)
-{
-  const QString emptyQString("");
+void InputDriverManager::registerActions (const QList<QAction *> &actions, const QString &parent, const QString &target) {
+  const QString emptyQString ("");
   for (const auto action : actions) {
-    const auto description = ((parent == emptyQString) ? emptyQString : (parent + QString::fromUtf8(u8" \u2192 "))) + action->text();
-    if (!action->objectName().isEmpty()) {
-      QString actionName = action->objectName();
+    const auto description = ((parent == emptyQString) ? emptyQString : (parent + QString::fromUtf8 (u8" \u2192 "))) + action->text ();
+    if (!action->objectName ().isEmpty ()) {
+      QString actionName = action->objectName ();
       if ("" != target) {
         actionName = target + "::" + actionName;
       }
-      this->actions.push_back({actionName, description, action->icon()});
+      this->actions.push_back ({actionName, description, action->icon ()});
     }
-    if (action->menu()) {
-      registerActions(action->menu()->actions(), description);
+    if (action->menu ()) {
+      registerActions (action->menu ()->actions (), description);
     }
   }
 }
 
-void InputDriverManager::init()
-{
-  timer = new QTimer(this);
-  connect(qApp, &QApplication::focusChanged, this, &InputDriverManager::onFocusChanged);
+void InputDriverManager::init () {
+  timer = new QTimer (this);
+  connect (qApp, &QApplication::focusChanged, this, &InputDriverManager::onFocusChanged);
 
-  doOpen(true);
-  connect(timer, &QTimer::timeout, this, &InputDriverManager::onTimeout);
-  timer->start(10 * 1000);
+  doOpen (true);
+  connect (timer, &QTimer::timeout, this, &InputDriverManager::onTimeout);
+  timer->start (10 * 1000);
 }
 
-void InputDriverManager::onTimeout()
-{
+void InputDriverManager::onTimeout () {
   for (auto driver : drivers) {
-    if (driver->openOnce()) {
+    if (driver->openOnce ()) {
       continue;
     }
-    if (driver->isOpen()) {
+    if (driver->isOpen ()) {
       return;
     }
   }
-  doOpen(false);
+  doOpen (false);
 }
 
-void InputDriverManager::doOpen(bool firstOpen)
-{
+void InputDriverManager::doOpen (bool firstOpen) {
   for (auto driver : drivers) {
-    if (driver->openOnce()) {
+    if (driver->openOnce ()) {
       continue;
     }
-    if (driver->open()) {
+    if (driver->open ()) {
       break;
     }
   }
 
   if (firstOpen) {
     for (auto driver : drivers) {
-      if (driver->openOnce()) {
-        driver->open();
+      if (driver->openOnce ()) {
+        driver->open ();
       }
     }
   }
 }
 
-std::string InputDriverManager::listDrivers() const
-{
+std::string InputDriverManager::listDrivers () const {
   std::ostringstream stream;
   const char *sep = "";
   for (auto driver : drivers) {
-    stream << sep << driver->get_name();
-    if (driver->isOpen()) {
+    stream << sep << driver->get_name ();
+    if (driver->isOpen ()) {
       stream << "*";
     }
     sep = ", ";
   }
-  return stream.str();
+  return stream.str ();
 }
 
-std::string InputDriverManager::listDriverInfos() const
-{
+std::string InputDriverManager::listDriverInfos () const {
   std::ostringstream stream;
   const char *sep = "";
   for (auto driver : drivers) {
-    stream << sep << driver->get_info();
+    stream << sep << driver->get_info ();
     sep = "\n";
   }
-  return stream.str();
+  return stream.str ();
 }
 
-void InputDriverManager::closeDrivers()
-{
+void InputDriverManager::closeDrivers () {
   if (timer != nullptr) {
-    timer->stop();
+    timer->stop ();
   }
-  InputEventMapper::instance()->stop();
+  InputEventMapper::instance ()->stop ();
 
   for (auto driver : drivers) {
-    driver->close();
+    driver->close ();
   }
 }
 
-void InputDriverManager::sendEvent(InputEvent *event)
-{
-  event->deliver(&mapper);
+void InputDriverManager::sendEvent (InputEvent *event) {
+  event->deliver (&mapper);
 }
 
-void InputDriverManager::postEvent(InputEvent *event)
-{
-  QWidget *window = event->activeOnly ? QApplication::activeWindow() : currentWindow;
+void InputDriverManager::postEvent (InputEvent *event) {
+  QWidget *window = event->activeOnly ? QApplication::activeWindow () : currentWindow;
   if (window) {
-    QCoreApplication::postEvent(window, event);
+    QCoreApplication::postEvent (window, event);
   }
 }
 
-const std::list<ActionStruct>& InputDriverManager::getActions() const
-{
+const std::list<ActionStruct> &InputDriverManager::getActions () const {
   return actions;
 }
 
-QList<double> InputDriverManager::getTranslation() const
-{
+QList<double> InputDriverManager::getTranslation () const {
   const MainWindow *window = currentWindow;
   if (window) {
-    return window->getTranslation();
+    return window->getTranslation ();
   }
-  return QList<double>({0.0, 0.0, 0.0});
+  return QList<double> ({0.0, 0.0, 0.0});
 }
 
-QList<double> InputDriverManager::getRotation() const
-{
+QList<double> InputDriverManager::getRotation () const {
   const MainWindow *window = currentWindow;
   if (window) {
-    return window->getRotation();
+    return window->getRotation ();
   }
-  return QList<double>({0.0, 0.0, 0.0});
+  return QList<double> ({0.0, 0.0, 0.0});
 }
 
-void InputDriverManager::onFocusChanged(QWidget *, QWidget *current)
-{
+void InputDriverManager::onFocusChanged (QWidget *, QWidget *current) {
   if (current) {
-    currentWindow = dynamic_cast<MainWindow *>(current->window());
+    currentWindow = dynamic_cast<MainWindow *> (current->window ());
   }
 }
 
-void InputDriverManager::onInputMappingUpdated()
-{
-  mapper.onInputMappingUpdated();
+void InputDriverManager::onInputMappingUpdated () {
+  mapper.onInputMappingUpdated ();
 }
 
-void InputDriverManager::onInputCalibrationUpdated()
-{
-  mapper.onInputCalibrationUpdated();
+void InputDriverManager::onInputCalibrationUpdated () {
+  mapper.onInputCalibrationUpdated ();
 }
 
-void InputDriverManager::onInputGainUpdated()
-{
-  mapper.onInputGainUpdated();
+void InputDriverManager::onInputGainUpdated () {
+  mapper.onInputGainUpdated ();
 }
 
-size_t InputDriverManager::getButtonCount() const {
+size_t InputDriverManager::getButtonCount () const {
   size_t max = 0;
   for (auto driver : drivers) {
-    if (driver->isOpen()) {
-      max = std::max(max, driver->getButtonCount());
+    if (driver->isOpen ()) {
+      max = std::max (max, driver->getButtonCount ());
     }
   }
   return max;
 }
 
-size_t InputDriverManager::getAxisCount() const {
+size_t InputDriverManager::getAxisCount () const {
   size_t max = 0;
   for (auto driver : drivers) {
-    if (driver->isOpen()) {
-      max = std::max(max, driver->getAxisCount());
+    if (driver->isOpen ()) {
+      max = std::max (max, driver->getAxisCount ());
     }
   }
   return max;
diff --git a/src/gui/input/InputDriverManager.h b/src/gui/input/InputDriverManager.h
index 6e7f42d6d..6b1123a68 100644
--- a/src/gui/input/InputDriverManager.h
+++ b/src/gui/input/InputDriverManager.h
@@ -66,39 +66,39 @@ private:
 
   static InputDriverManager *self;
 
-  void postEvent(InputEvent *event);
+  void postEvent (InputEvent *event);
 
 public:
-  InputDriverManager() = default;
+  InputDriverManager () = default;
 
-  void sendEvent(InputEvent *event);
+  void sendEvent (InputEvent *event);
 
-  void init();
-  std::string listDrivers() const;
-  std::string listDriverInfos() const;
-  void registerDriver(InputDriver *driver);
-  void unregisterDriver(InputDriver *driver);
-  void closeDrivers();
-  void registerActions(const QList<QAction *>& actions, const QString& parent = QString(""), const QString& target = QString(""));
+  void init ();
+  std::string listDrivers () const;
+  std::string listDriverInfos () const;
+  void registerDriver (InputDriver *driver);
+  void unregisterDriver (InputDriver *driver);
+  void closeDrivers ();
+  void registerActions (const QList<QAction *> &actions, const QString &parent = QString (""), const QString &target = QString (""));
 
-  static InputDriverManager *instance();
+  static InputDriverManager *instance ();
 
-  const std::list<ActionStruct>& getActions() const;
-  QList<double> getTranslation() const;
-  QList<double> getRotation() const;
+  const std::list<ActionStruct> &getActions () const;
+  QList<double> getTranslation () const;
+  QList<double> getRotation () const;
 
-  size_t getButtonCount() const;
-  size_t getAxisCount() const;
+  size_t getButtonCount () const;
+  size_t getAxisCount () const;
 
 public slots:
-  void onInputMappingUpdated();
-  void onInputCalibrationUpdated();
-  void onInputGainUpdated();
+  void onInputMappingUpdated ();
+  void onInputCalibrationUpdated ();
+  void onInputGainUpdated ();
 
 private slots:
-  void onTimeout();
-  void doOpen(bool firstOpen);
-  void onFocusChanged(QWidget *, QWidget *);
+  void onTimeout ();
+  void doOpen (bool firstOpen);
+  void onFocusChanged (QWidget *, QWidget *);
 
   friend class InputEventMapper;
 };
diff --git a/src/gui/input/InputEventMapper.cc b/src/gui/input/InputEventMapper.cc
index ecc0a99e6..8cfb8d387 100644
--- a/src/gui/input/InputEventMapper.cc
+++ b/src/gui/input/InputEventMapper.cc
@@ -41,16 +41,15 @@ using S = Settings::Settings;
 
 InputEventMapper *InputEventMapper::self = nullptr;
 
-InputEventMapper::InputEventMapper()
-{
+InputEventMapper::InputEventMapper () {
   stopRequest = false;
 
-  for (size_t a = 0; a < getMaxAxis(); ++a) {
+  for (size_t a = 0; a < getMaxAxis (); ++a) {
     axisRawValue[a] = 0.0;
     axisTrimValue[a] = 0.0;
     axisDeadzone[a] = 0.1;
   }
-  for (size_t a = 0; a < getMaxButtons(); ++a) {
+  for (size_t a = 0; a < getMaxButtons (); ++a) {
     button_state[a] = false;
     button_state_last[a] = false;
   }
@@ -61,21 +60,20 @@ InputEventMapper::InputEventMapper()
   rotateVPRelGain = 1.00;
   zoomGain = 1.00;
 
-  timer = new QTimer(this);
-  connect(timer, &QTimer::timeout, this, &InputEventMapper::onTimer);
-  timer->start(30);
+  timer = new QTimer (this);
+  connect (timer, &QTimer::timeout, this, &InputEventMapper::onTimer);
+  timer->start (30);
 
-  onInputMappingUpdated();
-  onInputCalibrationUpdated();
-  onInputGainUpdated();
+  onInputMappingUpdated ();
+  onInputCalibrationUpdated ();
+  onInputGainUpdated ();
 
   self = this;
 }
 
-InputEventMapper *InputEventMapper::instance()
-{
+InputEventMapper *InputEventMapper::instance () {
   if (!self) {
-    self = new InputEventMapper();
+    self = new InputEventMapper ();
   }
   return self;
 }
@@ -85,122 +83,115 @@ InputEventMapper *InputEventMapper::instance()
     0 -> 0
     1 ->  10.72
  */
-double InputEventMapper::scale(double val)
-{
+double InputEventMapper::scale (double val) {
   double x = 4 * val;
-  double xx = x < 0 ? -exp(-x) + 1 : exp(x) - 1;
+  double xx = x < 0 ? -exp (-x) + 1 : exp (x) - 1;
   return xx / 5.0;
 }
 
-double InputEventMapper::getAxisValue(int config)
-{
-  if (config == 0)    // avoid indexing by -1 when using default settings (and causing bizarre behavior)
-    return scale(0);
+double InputEventMapper::getAxisValue (int config) {
+  if (config == 0) // avoid indexing by -1 when using default settings (and causing bizarre behavior)
+    return scale (0);
 
-  int idx = abs(config) - 1;
-  if (idx > 8)        // avoid reading over end of arrays (and causing segfaults)
-    return scale(0);
+  int idx = abs (config) - 1;
+  if (idx > 8) // avoid reading over end of arrays (and causing segfaults)
+    return scale (0);
 
   bool neg = config < 0;
   double trimmedVal = axisRawValue[idx] + axisTrimValue[idx];
   double val = neg ? -trimmedVal : trimmedVal;
-  if (val < axisDeadzone[idx] and - val < axisDeadzone[idx]) {
+  if (val < axisDeadzone[idx] and -val < axisDeadzone[idx]) {
     val = 0;
   }
-  return scale(val);
+  return scale (val);
 }
 
-bool InputEventMapper::generateDeferredEvents()
-{
+bool InputEventMapper::generateDeferredEvents () {
   bool any = false;
   const double threshold = 0.01;
 
-  double tx = getAxisValue(translate[0]) * translationGain;
-  double ty = getAxisValue(translate[1]) * translationGain;
-  double tz = getAxisValue(translate[2]) * translationGain;
-  if ((fabs(tx) > threshold) || (fabs(ty) > threshold) || (fabs(tz) > threshold)) {
-    InputEvent *inputEvent = new InputEventTranslate(tx, ty, tz);
-    InputDriverManager::instance()->postEvent(inputEvent);
+  double tx = getAxisValue (translate[0]) * translationGain;
+  double ty = getAxisValue (translate[1]) * translationGain;
+  double tz = getAxisValue (translate[2]) * translationGain;
+  if ((fabs (tx) > threshold) || (fabs (ty) > threshold) || (fabs (tz) > threshold)) {
+    InputEvent *inputEvent = new InputEventTranslate (tx, ty, tz);
+    InputDriverManager::instance ()->postEvent (inputEvent);
     any = true;
   }
 
-  double txVPRel = getAxisValue(translate[3]) * translationVPRelGain;
-  double tyVPRel = getAxisValue(translate[4]) * translationVPRelGain;
-  double tzVPRel = getAxisValue(translate[5]) * translationVPRelGain;
-  if ((fabs(txVPRel) > threshold) || (fabs(tyVPRel) > threshold) || (fabs(tzVPRel) > threshold)) {
-    InputEvent *inputEvent = new InputEventTranslate(txVPRel, tyVPRel, tzVPRel, true, true, false);
-    InputDriverManager::instance()->postEvent(inputEvent);
+  double txVPRel = getAxisValue (translate[3]) * translationVPRelGain;
+  double tyVPRel = getAxisValue (translate[4]) * translationVPRelGain;
+  double tzVPRel = getAxisValue (translate[5]) * translationVPRelGain;
+  if ((fabs (txVPRel) > threshold) || (fabs (tyVPRel) > threshold) || (fabs (tzVPRel) > threshold)) {
+    InputEvent *inputEvent = new InputEventTranslate (txVPRel, tyVPRel, tzVPRel, true, true, false);
+    InputDriverManager::instance ()->postEvent (inputEvent);
     any = true;
   }
 
-  double rx = getAxisValue(rotate[0]) * rotateGain;
-  double ry = getAxisValue(rotate[1]) * rotateGain;
-  double rz = getAxisValue(rotate[2]) * rotateGain;
-  if ((fabs(rx) > threshold) || (fabs(ry) > threshold) || (fabs(rz) > threshold)) {
-    InputEvent *inputEvent = new InputEventRotate(rx, ry, rz);
-    InputDriverManager::instance()->postEvent(inputEvent);
+  double rx = getAxisValue (rotate[0]) * rotateGain;
+  double ry = getAxisValue (rotate[1]) * rotateGain;
+  double rz = getAxisValue (rotate[2]) * rotateGain;
+  if ((fabs (rx) > threshold) || (fabs (ry) > threshold) || (fabs (rz) > threshold)) {
+    InputEvent *inputEvent = new InputEventRotate (rx, ry, rz);
+    InputDriverManager::instance ()->postEvent (inputEvent);
     any = true;
   }
 
-  double rxVPRel = getAxisValue(rotate[3]) * rotateVPRelGain;
-  double ryVPRel = getAxisValue(rotate[4]) * rotateVPRelGain;
-  double rzVPRel = getAxisValue(rotate[5]) * rotateVPRelGain;
-  if ((fabs(rxVPRel) > threshold) || (fabs(ryVPRel) > threshold) || (fabs(rzVPRel) > threshold)) {
-    InputEvent *inputEvent = new InputEventRotate2(rxVPRel, ryVPRel, rzVPRel);
-    InputDriverManager::instance()->postEvent(inputEvent);
+  double rxVPRel = getAxisValue (rotate[3]) * rotateVPRelGain;
+  double ryVPRel = getAxisValue (rotate[4]) * rotateVPRelGain;
+  double rzVPRel = getAxisValue (rotate[5]) * rotateVPRelGain;
+  if ((fabs (rxVPRel) > threshold) || (fabs (ryVPRel) > threshold) || (fabs (rzVPRel) > threshold)) {
+    InputEvent *inputEvent = new InputEventRotate2 (rxVPRel, ryVPRel, rzVPRel);
+    InputDriverManager::instance ()->postEvent (inputEvent);
     any = true;
   }
 
-  double z = (getAxisValue(zoom) + getAxisValue(zoom2)) * zoomGain;
-  if (fabs(z) > threshold) {
-    InputEvent *inputEvent = new InputEventZoom(z);
-    InputDriverManager::instance()->postEvent(inputEvent);
+  double z = (getAxisValue (zoom) + getAxisValue (zoom2)) * zoomGain;
+  if (fabs (z) > threshold) {
+    InputEvent *inputEvent = new InputEventZoom (z);
+    InputDriverManager::instance ()->postEvent (inputEvent);
     any = true;
   }
 
   return any;
 }
 
-void InputEventMapper::considerGeneratingDeferredEvents()
-{
-  if (!timer->isActive()) {
-    QMetaObject::invokeMethod(timer, "start", Qt::QueuedConnection, Q_ARG(int, 30));
+void InputEventMapper::considerGeneratingDeferredEvents () {
+  if (!timer->isActive ()) {
+    QMetaObject::invokeMethod (timer, "start", Qt::QueuedConnection, Q_ARG (int, 30));
   }
 }
 
-void InputEventMapper::onTimer()
-{
-  bool generated_any_events = generateDeferredEvents();
+void InputEventMapper::onTimer () {
+  bool generated_any_events = generateDeferredEvents ();
 
   //update the UI on time, NOT on event as a joystick can fire a high rate of events
-  for (size_t i = 0; i < getMaxButtons(); ++i) {
+  for (size_t i = 0; i < getMaxButtons (); ++i) {
     if (button_state[i] != button_state_last[i]) {
       button_state_last[i] = button_state[i];
-      GlobalPreferences::inst()->ButtonConfig->updateButtonState(i, button_state[i]);
+      GlobalPreferences::inst ()->ButtonConfig->updateButtonState (i, button_state[i]);
     }
   }
-  for (size_t i = 0; i < getMaxAxis(); ++i) {
-    GlobalPreferences::inst()->AxisConfig->AxesChanged(i, axisRawValue[i] + axisTrimValue[i]);
+  for (size_t i = 0; i < getMaxAxis (); ++i) {
+    GlobalPreferences::inst ()->AxisConfig->AxesChanged (i, axisRawValue[i] + axisTrimValue[i]);
   }
 
   if (!generated_any_events) {
     // the current axis positions do not generate input events,
     // so we can stop the polling which is used to to generate them
-    timer->stop();
+    timer->stop ();
   }
 }
 
-void InputEventMapper::onAxisChanged(InputEventAxisChanged *event)
-{
+void InputEventMapper::onAxisChanged (InputEventAxisChanged *event) {
   axisRawValue[event->axis] = event->value;
-  considerGeneratingDeferredEvents();
+  considerGeneratingDeferredEvents ();
 }
 
-void InputEventMapper::onButtonChanged(InputEventButtonChanged *event)
-{
+void InputEventMapper::onButtonChanged (InputEventButtonChanged *event) {
   unsigned int button = event->button;
 
-  if (button < getMaxButtons()) {
+  if (button < getMaxButtons ()) {
     if (event->down) {
       this->button_state[button] = true;
     } else {
@@ -211,147 +202,129 @@ void InputEventMapper::onButtonChanged(InputEventButtonChanged *event)
       return;
     }
 
-    std::string action = actions[event->button].toStdString();
-    if (!action.empty()) {
-      InputEvent *inputEvent = new InputEventAction(action, false);
-      InputDriverManager::instance()->postEvent(inputEvent);
+    std::string action = actions[event->button].toStdString ();
+    if (!action.empty ()) {
+      InputEvent *inputEvent = new InputEventAction (action, false);
+      InputDriverManager::instance ()->postEvent (inputEvent);
     }
   }
-  considerGeneratingDeferredEvents();
+  considerGeneratingDeferredEvents ();
 }
 
-void InputEventMapper::onTranslateEvent(InputEventTranslate *event)
-{
-  InputDriverManager::instance()->postEvent(event);
+void InputEventMapper::onTranslateEvent (InputEventTranslate *event) {
+  InputDriverManager::instance ()->postEvent (event);
 }
 
-void InputEventMapper::onRotateEvent(InputEventRotate *event)
-{
-  InputDriverManager::instance()->postEvent(event);
+void InputEventMapper::onRotateEvent (InputEventRotate *event) {
+  InputDriverManager::instance ()->postEvent (event);
 }
 
-void InputEventMapper::onRotate2Event(InputEventRotate2 *event)
-{
-  InputDriverManager::instance()->postEvent(event);
+void InputEventMapper::onRotate2Event (InputEventRotate2 *event) {
+  InputDriverManager::instance ()->postEvent (event);
 }
 
-void InputEventMapper::onActionEvent(InputEventAction *event)
-{
-  InputDriverManager::instance()->postEvent(event);
+void InputEventMapper::onActionEvent (InputEventAction *event) {
+  InputDriverManager::instance ()->postEvent (event);
 }
 
-void InputEventMapper::onZoomEvent(InputEventZoom *event)
-{
-  InputDriverManager::instance()->postEvent(event);
+void InputEventMapper::onZoomEvent (InputEventZoom *event) {
+  InputDriverManager::instance ()->postEvent (event);
 }
 
-int InputEventMapper::parseSettingValue(const std::string& val)
-{
-  if (val.length() != 2) {
+int InputEventMapper::parseSettingValue (const std::string &val) {
+  if (val.length () != 2) {
     return 0;
   }
-  return atoi(val.c_str());
+  return atoi (val.c_str ());
 }
 
-void InputEventMapper::onInputMappingUpdated()
-{
-  for (size_t i = 0; i < getMaxButtons(); ++i) {
-    actions[i] = QString::fromStdString(inputButtonSettings(i).value());
+void InputEventMapper::onInputMappingUpdated () {
+  for (size_t i = 0; i < getMaxButtons (); ++i) {
+    actions[i] = QString::fromStdString (inputButtonSettings (i).value ());
   }
 
-  translate[0] = parseSettingValue(Settings::Settings::inputTranslationX.value());
-  translate[1] = parseSettingValue(Settings::Settings::inputTranslationY.value());
-  translate[2] = parseSettingValue(Settings::Settings::inputTranslationZ.value());
-  translate[3] = parseSettingValue(Settings::Settings::inputTranslationXVPRel.value());
-  translate[4] = parseSettingValue(Settings::Settings::inputTranslationYVPRel.value());
-  translate[5] = parseSettingValue(Settings::Settings::inputTranslationZVPRel.value());
-  rotate[0] = parseSettingValue(Settings::Settings::inputRotateX.value());
-  rotate[1] = parseSettingValue(Settings::Settings::inputRotateY.value());
-  rotate[2] = parseSettingValue(Settings::Settings::inputRotateZ.value());
-  rotate[3] = parseSettingValue(Settings::Settings::inputRotateXVPRel.value());
-  rotate[4] = parseSettingValue(Settings::Settings::inputRotateYVPRel.value());
-  rotate[5] = parseSettingValue(Settings::Settings::inputRotateZVPRel.value());
-  zoom = parseSettingValue(Settings::Settings::inputZoom.value());
-  zoom2 = parseSettingValue(Settings::Settings::inputZoom2.value());
-  considerGeneratingDeferredEvents();
+  translate[0] = parseSettingValue (Settings::Settings::inputTranslationX.value ());
+  translate[1] = parseSettingValue (Settings::Settings::inputTranslationY.value ());
+  translate[2] = parseSettingValue (Settings::Settings::inputTranslationZ.value ());
+  translate[3] = parseSettingValue (Settings::Settings::inputTranslationXVPRel.value ());
+  translate[4] = parseSettingValue (Settings::Settings::inputTranslationYVPRel.value ());
+  translate[5] = parseSettingValue (Settings::Settings::inputTranslationZVPRel.value ());
+  rotate[0] = parseSettingValue (Settings::Settings::inputRotateX.value ());
+  rotate[1] = parseSettingValue (Settings::Settings::inputRotateY.value ());
+  rotate[2] = parseSettingValue (Settings::Settings::inputRotateZ.value ());
+  rotate[3] = parseSettingValue (Settings::Settings::inputRotateXVPRel.value ());
+  rotate[4] = parseSettingValue (Settings::Settings::inputRotateYVPRel.value ());
+  rotate[5] = parseSettingValue (Settings::Settings::inputRotateZVPRel.value ());
+  zoom = parseSettingValue (Settings::Settings::inputZoom.value ());
+  zoom2 = parseSettingValue (Settings::Settings::inputZoom2.value ());
+  considerGeneratingDeferredEvents ();
 }
 
-void InputEventMapper::onInputGainUpdated()
-{
-  translationGain = Settings::Settings::inputTranslationGain.value();
-  translationVPRelGain = Settings::Settings::inputTranslationVPRelGain.value();
-  rotateGain = Settings::Settings::inputRotateGain.value();
-  rotateVPRelGain = Settings::Settings::inputRotateVPRelGain.value();
-  zoomGain = Settings::Settings::inputZoomGain.value();
+void InputEventMapper::onInputGainUpdated () {
+  translationGain = Settings::Settings::inputTranslationGain.value ();
+  translationVPRelGain = Settings::Settings::inputTranslationVPRelGain.value ();
+  rotateGain = Settings::Settings::inputRotateGain.value ();
+  rotateVPRelGain = Settings::Settings::inputRotateVPRelGain.value ();
+  zoomGain = Settings::Settings::inputZoomGain.value ();
 
-  considerGeneratingDeferredEvents();
+  considerGeneratingDeferredEvents ();
 }
 
-void InputEventMapper::onInputCalibrationUpdated()
-{
-  for (size_t i = 0; i < getMaxAxis(); ++i) {
-    axisTrimValue[i] = axisTrimSettings(i).value();
-    axisDeadzone[i] = axisDeadzoneSettings(i).value();
+void InputEventMapper::onInputCalibrationUpdated () {
+  for (size_t i = 0; i < getMaxAxis (); ++i) {
+    axisTrimValue[i] = axisTrimSettings (i).value ();
+    axisDeadzone[i] = axisDeadzoneSettings (i).value ();
   }
-  considerGeneratingDeferredEvents();
+  considerGeneratingDeferredEvents ();
 }
 
-void InputEventMapper::onAxisAutoTrim()
-{
-  for (size_t i = 0; i < getMaxAxis(); ++i) {
+void InputEventMapper::onAxisAutoTrim () {
+  for (size_t i = 0; i < getMaxAxis (); ++i) {
     axisTrimValue[i] = -axisRawValue[i];
-    axisTrimSettings(i).setValue(axisTrimValue[i]);
+    axisTrimSettings (i).setValue (axisTrimValue[i]);
   }
-  considerGeneratingDeferredEvents();
+  considerGeneratingDeferredEvents ();
 }
 
-void InputEventMapper::onAxisTrimReset()
-{
-  for (size_t i = 0; i < getMaxAxis(); ++i) {
+void InputEventMapper::onAxisTrimReset () {
+  for (size_t i = 0; i < getMaxAxis (); ++i) {
     axisTrimValue[i] = 0.00;
-    axisTrimSettings(i).setValue(axisTrimValue[i]);
+    axisTrimSettings (i).setValue (axisTrimValue[i]);
   }
-  considerGeneratingDeferredEvents();
+  considerGeneratingDeferredEvents ();
 }
 
-void InputEventMapper::stop(){
+void InputEventMapper::stop () {
   stopRequest = true;
-  timer->stop();
+  timer->stop ();
 }
 
-Settings::SettingsEntryString& InputEventMapper::inputButtonSettings(size_t id)
-{
-  const std::array<Settings::SettingsEntryString *, getMaxButtons()> entries {
-    &S::inputButton0,  &S::inputButton1,  &S::inputButton2,  &S::inputButton3,
-    &S::inputButton4,  &S::inputButton5,  &S::inputButton6,  &S::inputButton7,
-    &S::inputButton8,  &S::inputButton9,  &S::inputButton10, &S::inputButton11,
+Settings::SettingsEntryString &InputEventMapper::inputButtonSettings (size_t id) {
+  const std::array<Settings::SettingsEntryString *, getMaxButtons ()> entries{
+    &S::inputButton0, &S::inputButton1, &S::inputButton2, &S::inputButton3,
+    &S::inputButton4, &S::inputButton5, &S::inputButton6, &S::inputButton7,
+    &S::inputButton8, &S::inputButton9, &S::inputButton10, &S::inputButton11,
     &S::inputButton12, &S::inputButton13, &S::inputButton14, &S::inputButton15,
     &S::inputButton16, &S::inputButton17, &S::inputButton18, &S::inputButton19,
-    &S::inputButton20, &S::inputButton21, &S::inputButton22, &S::inputButton23
-  };
-  assert(id >= 0 && id < entries.size());
+    &S::inputButton20, &S::inputButton21, &S::inputButton22, &S::inputButton23};
+  assert (id >= 0 && id < entries.size ());
   return *entries[id];
 }
 
-Settings::SettingsEntryDouble& InputEventMapper::axisTrimSettings(size_t id)
-{
-  const std::array<Settings::SettingsEntryDouble *, getMaxAxis()> entries {
+Settings::SettingsEntryDouble &InputEventMapper::axisTrimSettings (size_t id) {
+  const std::array<Settings::SettingsEntryDouble *, getMaxAxis ()> entries{
     &S::axisTrim0, &S::axisTrim1, &S::axisTrim2,
     &S::axisTrim3, &S::axisTrim4, &S::axisTrim5,
-    &S::axisTrim6, &S::axisTrim7, &S::axisTrim8
-  };
-  assert(id >= 0 && id < entries.size());
+    &S::axisTrim6, &S::axisTrim7, &S::axisTrim8};
+  assert (id >= 0 && id < entries.size ());
   return *entries[id];
 }
 
-Settings::SettingsEntryDouble& InputEventMapper::axisDeadzoneSettings(size_t id)
-{
-  const std::array<Settings::SettingsEntryDouble *, getMaxAxis()> entries {
+Settings::SettingsEntryDouble &InputEventMapper::axisDeadzoneSettings (size_t id) {
+  const std::array<Settings::SettingsEntryDouble *, getMaxAxis ()> entries{
     &S::axisDeadzone0, &S::axisDeadzone1, &S::axisDeadzone2,
     &S::axisDeadzone3, &S::axisDeadzone4, &S::axisDeadzone5,
-    &S::axisDeadzone6, &S::axisDeadzone7, &S::axisDeadzone8
-  };
-  assert(id >= 0 && id < entries.size());
+    &S::axisDeadzone6, &S::axisDeadzone7, &S::axisDeadzone8};
+  assert (id >= 0 && id < entries.size ());
   return *entries[id];
 }
-
diff --git a/src/gui/input/InputEventMapper.h b/src/gui/input/InputEventMapper.h
index 6d53613a5..f42eda92f 100644
--- a/src/gui/input/InputEventMapper.h
+++ b/src/gui/input/InputEventMapper.h
@@ -38,8 +38,12 @@ class InputEventMapper : public QObject, public InputEventHandler
   Q_OBJECT
 
 public:
-  constexpr static inline size_t getMaxButtons() { return Settings::max_buttons; }
-  constexpr static inline size_t getMaxAxis() { return Settings::max_axis; }
+  constexpr static inline size_t getMaxButtons () {
+    return Settings::max_buttons;
+  }
+  constexpr static inline size_t getMaxAxis () {
+    return Settings::max_axis;
+  }
 
 private:
   QTimer *timer;
@@ -53,11 +57,11 @@ private:
   int zoom2;
   volatile bool stopRequest;
 
-  double scale(double val);
-  double getAxisValue(int config);
-  int parseSettingValue(const std::string& val);
-  bool generateDeferredEvents();
-  void considerGeneratingDeferredEvents();
+  double scale (double val);
+  double getAxisValue (int config);
+  int parseSettingValue (const std::string &val);
+  bool generateDeferredEvents ();
+  void considerGeneratingDeferredEvents ();
   bool button_state[Settings::max_buttons];
   bool button_state_last[Settings::max_buttons];
 
@@ -70,32 +74,32 @@ private:
   double zoomGain;
 
 public:
-  InputEventMapper();
+  InputEventMapper ();
 
-  void stop();
+  void stop ();
 
-  void onAxisChanged(class InputEventAxisChanged *event) override;
-  void onButtonChanged(class InputEventButtonChanged *event) override;
+  void onAxisChanged (class InputEventAxisChanged *event) override;
+  void onButtonChanged (class InputEventButtonChanged *event) override;
 
-  void onTranslateEvent(class InputEventTranslate *event) override;
-  void onRotateEvent(class InputEventRotate *event) override;
-  void onRotate2Event(class InputEventRotate2 *event) override;
-  void onActionEvent(class InputEventAction *event) override;
-  void onZoomEvent(class InputEventZoom *event) override;
+  void onTranslateEvent (class InputEventTranslate *event) override;
+  void onRotateEvent (class InputEventRotate *event) override;
+  void onRotate2Event (class InputEventRotate2 *event) override;
+  void onActionEvent (class InputEventAction *event) override;
+  void onZoomEvent (class InputEventZoom *event) override;
 
-  void onInputMappingUpdated();
-  void onInputCalibrationUpdated();
-  void onInputGainUpdated();
+  void onInputMappingUpdated ();
+  void onInputCalibrationUpdated ();
+  void onInputGainUpdated ();
 
-  void onAxisAutoTrim();
-  void onAxisTrimReset();
+  void onAxisAutoTrim ();
+  void onAxisTrimReset ();
 
-  static InputEventMapper *instance();
+  static InputEventMapper *instance ();
 
-  static Settings::SettingsEntryString& inputButtonSettings(size_t id);
-  static Settings::SettingsEntryDouble& axisTrimSettings(size_t id);
-  static Settings::SettingsEntryDouble& axisDeadzoneSettings(size_t id);
+  static Settings::SettingsEntryString &inputButtonSettings (size_t id);
+  static Settings::SettingsEntryDouble &axisTrimSettings (size_t id);
+  static Settings::SettingsEntryDouble &axisDeadzoneSettings (size_t id);
 
 private slots:
-  void onTimer();
+  void onTimer ();
 };
diff --git a/src/gui/input/JoystickInputDriver.cc b/src/gui/input/JoystickInputDriver.cc
index 99b081567..7087b8dd1 100644
--- a/src/gui/input/JoystickInputDriver.cc
+++ b/src/gui/input/JoystickInputDriver.cc
@@ -39,77 +39,70 @@
 #include <linux/input.h>
 #include <linux/joystick.h>
 
-void JoystickInputDriver::run()
-{
+void JoystickInputDriver::run () {
   struct js_event js;
 
   while (!stopRequest) {
-    ssize_t len = read(fd, &js, sizeof(struct js_event));
+    ssize_t len = read (fd, &js, sizeof (struct js_event));
     if (len < 0) {
       break;
     }
-    if (len != sizeof(struct js_event)) {
+    if (len != sizeof (struct js_event)) {
       continue;
     }
     switch (js.type & ~JS_EVENT_INIT) {
     case JS_EVENT_BUTTON:
-      InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(js.number, js.value != 0));
+      InputDriverManager::instance ()->sendEvent (new InputEventButtonChanged (js.number, js.value != 0));
       break;
     case JS_EVENT_AXIS:
-      InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(js.number, js.value / 32767.0));
+      InputDriverManager::instance ()->sendEvent (new InputEventAxisChanged (js.number, js.value / 32767.0));
       break;
     }
   }
-  ::close(fd);
+  ::close (fd);
 }
 
-bool JoystickInputDriver::open()
-{
+bool JoystickInputDriver::open () {
   stopRequest = false;
 
-  auto path = boost::format("/dev/input/js%d") % this->nr;
-  this->fd = ::open(path.str().c_str(), O_RDONLY);
+  auto path = boost::format ("/dev/input/js%d") % this->nr;
+  this->fd = ::open (path.str ().c_str (), O_RDONLY);
 
   if (fd < 0) {
     return false;
   }
 
   version = 0;
-  ioctl(fd, JSIOCGVERSION, &version);
+  ioctl (fd, JSIOCGVERSION, &version);
   if (version < 0x010000) {
     return false;
   }
 
-  ioctl(fd, JSIOCGAXES, &axes);
-  ioctl(fd, JSIOCGBUTTONS, &buttons);
-  ioctl(fd, JSIOCGNAME(sizeof(name)), name);
+  ioctl (fd, JSIOCGAXES, &axes);
+  ioctl (fd, JSIOCGBUTTONS, &buttons);
+  ioctl (fd, JSIOCGNAME (sizeof (name)), name);
 
-  start();
+  start ();
   return true;
 }
 
-void JoystickInputDriver::close()
-{
+void JoystickInputDriver::close () {
   stopRequest = true;
 }
 
-const std::string& JoystickInputDriver::get_name() const
-{
+const std::string &JoystickInputDriver::get_name () const {
   static std::string name = "JoystickInputDriver";
   return name;
 }
 
-std::string JoystickInputDriver::get_info() const
-{
-  return STR(
-    get_name(), " ", (isOpen() ? "open" : "not open"), " ",
+std::string JoystickInputDriver::get_info () const {
+  return STR (
+    get_name (), " ", (isOpen () ? "open" : "not open"), " ",
     "Name: ", name, " ",
-    "Axis: ", (int) axes, " ",
-    "Buttons: ", (int) buttons, " "
-    );
+    "Axis: ", (int)axes, " ",
+    "Buttons: ", (int)buttons, " ");
 }
 
-void JoystickInputDriver::setJoystickNr(std::string jnr)
-{
-  this->nr = std::move(jnr);
+void JoystickInputDriver::setJoystickNr (std::string jnr) {
+  this->nr = std::move (jnr);
 }
diff --git a/src/gui/input/JoystickInputDriver.h b/src/gui/input/JoystickInputDriver.h
index ebe97ce84..a760dc4d9 100644
--- a/src/gui/input/JoystickInputDriver.h
+++ b/src/gui/input/JoystickInputDriver.h
@@ -33,18 +33,18 @@
 class JoystickInputDriver : public InputDriver
 {
 public:
-  JoystickInputDriver() = default;
-  void run() override;
-  bool open() override;
-  void close() override;
-  const std::string& get_name() const override;
-  std::string get_info() const override;
-  void setJoystickNr(std::string jnr);
+  JoystickInputDriver () = default;
+  void run () override;
+  bool open () override;
+  void close () override;
+  const std::string &get_name () const override;
+  std::string get_info () const override;
+  void setJoystickNr (std::string jnr);
 
-  size_t getButtonCount() const override {
+  size_t getButtonCount () const override {
     return buttons;
   }
-  size_t getAxisCount() const override {
+  size_t getAxisCount () const override {
     return axes;
   }
 
diff --git a/src/gui/input/QGamepadInputDriver.cc b/src/gui/input/QGamepadInputDriver.cc
index d2c27a7d2..591446605 100644
--- a/src/gui/input/QGamepadInputDriver.cc
+++ b/src/gui/input/QGamepadInputDriver.cc
@@ -30,120 +30,114 @@
 
 #include <string>
 
-void QGamepadInputDriver::run()
-{
+void QGamepadInputDriver::run () {
 }
 
-QGamepadInputDriver::QGamepadInputDriver() : gamepad(nullptr)
-{
+QGamepadInputDriver::QGamepadInputDriver ()
+  : gamepad (nullptr) {
 }
 
-bool QGamepadInputDriver::open()
-{
+bool QGamepadInputDriver::open () {
   if (gamepad) {
     return false;
   }
 
-  auto gamepads = QGamepadManager::instance()->connectedGamepads();
-  if (gamepads.isEmpty()) {
+  auto gamepads = QGamepadManager::instance ()->connectedGamepads ();
+  if (gamepads.isEmpty ()) {
     return false;
   }
 
-  this->gamepad.reset(new QGamepad(*gamepads.begin(), this));
+  this->gamepad.reset (new QGamepad (*gamepads.begin (), this));
 
-  connect(this->gamepad.get(), &QGamepad::axisLeftXChanged, this, [](double value){
-    InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(0, value));
+  connect (this->gamepad.get (), &QGamepad::axisLeftXChanged, this, [] (double value) {
+    InputDriverManager::instance ()->sendEvent (new InputEventAxisChanged (0, value));
   });
-  connect(this->gamepad.get(), &QGamepad::axisLeftYChanged, this, [](double value){
-    InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(1, value));
+  connect (this->gamepad.get (), &QGamepad::axisLeftYChanged, this, [] (double value) {
+    InputDriverManager::instance ()->sendEvent (new InputEventAxisChanged (1, value));
   });
-  connect(this->gamepad.get(), &QGamepad::axisRightXChanged, this, [](double value){
-    InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(2, value));
+  connect (this->gamepad.get (), &QGamepad::axisRightXChanged, this, [] (double value) {
+    InputDriverManager::instance ()->sendEvent (new InputEventAxisChanged (2, value));
   });
-  connect(this->gamepad.get(), &QGamepad::axisRightYChanged, this, [](double value){
-    InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(3, value));
+  connect (this->gamepad.get (), &QGamepad::axisRightYChanged, this, [] (double value) {
+    InputDriverManager::instance ()->sendEvent (new InputEventAxisChanged (3, value));
   });
-  connect(this->gamepad.get(), &QGamepad::buttonL2Changed, this, [](double value){
-    InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(4, value));
+  connect (this->gamepad.get (), &QGamepad::buttonL2Changed, this, [] (double value) {
+    InputDriverManager::instance ()->sendEvent (new InputEventAxisChanged (4, value));
   });
-  connect(this->gamepad.get(), &QGamepad::buttonR2Changed, this, [](double value){
-    InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(5, value));
+  connect (this->gamepad.get (), &QGamepad::buttonR2Changed, this, [] (double value) {
+    InputDriverManager::instance ()->sendEvent (new InputEventAxisChanged (5, value));
   });
 
-  connect(this->gamepad.get(), &QGamepad::buttonAChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(0, pressed));
+  connect (this->gamepad.get (), &QGamepad::buttonAChanged, this, [] (bool pressed) {
+    InputDriverManager::instance ()->sendEvent (new InputEventButtonChanged (0, pressed));
   });
-  connect(this->gamepad.get(), &QGamepad::buttonBChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(1, pressed));
+  connect (this->gamepad.get (), &QGamepad::buttonBChanged, this, [] (bool pressed) {
+    InputDriverManager::instance ()->sendEvent (new InputEventButtonChanged (1, pressed));
   });
-  connect(this->gamepad.get(), &QGamepad::buttonXChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(2, pressed));
+  connect (this->gamepad.get (), &QGamepad::buttonXChanged, this, [] (bool pressed) {
+    InputDriverManager::instance ()->sendEvent (new InputEventButtonChanged (2, pressed));
   });
-  connect(this->gamepad.get(), &QGamepad::buttonYChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(3, pressed));
+  connect (this->gamepad.get (), &QGamepad::buttonYChanged, this, [] (bool pressed) {
+    InputDriverManager::instance ()->sendEvent (new InputEventButtonChanged (3, pressed));
   });
-  connect(this->gamepad.get(), &QGamepad::buttonL1Changed, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(4, pressed));
+  connect (this->gamepad.get (), &QGamepad::buttonL1Changed, this, [] (bool pressed) {
+    InputDriverManager::instance ()->sendEvent (new InputEventButtonChanged (4, pressed));
   });
-  connect(this->gamepad.get(), &QGamepad::buttonR1Changed, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(5, pressed));
+  connect (this->gamepad.get (), &QGamepad::buttonR1Changed, this, [] (bool pressed) {
+    InputDriverManager::instance ()->sendEvent (new InputEventButtonChanged (5, pressed));
   });
-  connect(this->gamepad.get(), &QGamepad::buttonSelectChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(6, pressed));
+  connect (this->gamepad.get (), &QGamepad::buttonSelectChanged, this, [] (bool pressed) {
+    InputDriverManager::instance ()->sendEvent (new InputEventButtonChanged (6, pressed));
   });
-  connect(this->gamepad.get(), &QGamepad::buttonStartChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(7, pressed));
+  connect (this->gamepad.get (), &QGamepad::buttonStartChanged, this, [] (bool pressed) {
+    InputDriverManager::instance ()->sendEvent (new InputEventButtonChanged (7, pressed));
   });
 
-  connect(this->gamepad.get(), &QGamepad::buttonL3Changed, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(8, pressed));
+  connect (this->gamepad.get (), &QGamepad::buttonL3Changed, this, [] (bool pressed) {
+    InputDriverManager::instance ()->sendEvent (new InputEventButtonChanged (8, pressed));
   });
-  connect(this->gamepad.get(), &QGamepad::buttonR3Changed, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(9, pressed));
+  connect (this->gamepad.get (), &QGamepad::buttonR3Changed, this, [] (bool pressed) {
+    InputDriverManager::instance ()->sendEvent (new InputEventButtonChanged (9, pressed));
   });
-  connect(this->gamepad.get(), &QGamepad::buttonCenterChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(10, pressed));
+  connect (this->gamepad.get (), &QGamepad::buttonCenterChanged, this, [] (bool pressed) {
+    InputDriverManager::instance ()->sendEvent (new InputEventButtonChanged (10, pressed));
   });
-  connect(this->gamepad.get(), &QGamepad::buttonUpChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(11, pressed));
+  connect (this->gamepad.get (), &QGamepad::buttonUpChanged, this, [] (bool pressed) {
+    InputDriverManager::instance ()->sendEvent (new InputEventButtonChanged (11, pressed));
   });
-  connect(this->gamepad.get(), &QGamepad::buttonDownChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(12, pressed));
+  connect (this->gamepad.get (), &QGamepad::buttonDownChanged, this, [] (bool pressed) {
+    InputDriverManager::instance ()->sendEvent (new InputEventButtonChanged (12, pressed));
   });
-  connect(this->gamepad.get(), &QGamepad::buttonLeftChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(13, pressed));
+  connect (this->gamepad.get (), &QGamepad::buttonLeftChanged, this, [] (bool pressed) {
+    InputDriverManager::instance ()->sendEvent (new InputEventButtonChanged (13, pressed));
   });
-  connect(this->gamepad.get(), &QGamepad::buttonRightChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(14, pressed));
+  connect (this->gamepad.get (), &QGamepad::buttonRightChanged, this, [] (bool pressed) {
+    InputDriverManager::instance ()->sendEvent (new InputEventButtonChanged (14, pressed));
   });
-  connect(this->gamepad.get(), &QGamepad::buttonGuideChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(15, pressed));
+  connect (this->gamepad.get (), &QGamepad::buttonGuideChanged, this, [] (bool pressed) {
+    InputDriverManager::instance ()->sendEvent (new InputEventButtonChanged (15, pressed));
   });
 
   return true;
 }
 
-void QGamepadInputDriver::close()
-{
-  gamepad.reset();
+void QGamepadInputDriver::close () {
+  gamepad.reset ();
 }
 
-const std::string& QGamepadInputDriver::get_name() const
-{
+const std::string &QGamepadInputDriver::get_name () const {
   static std::string name = "QGamepadInputDriver";
   return name;
 }
 
-bool QGamepadInputDriver::isOpen() const
-{
-  return this->gamepad ? this->gamepad->isConnected() : false;
+bool QGamepadInputDriver::isOpen () const {
+  return this->gamepad ? this->gamepad->isConnected () : false;
 }
 
-std::string QGamepadInputDriver::get_info() const
-{
-  const auto status = isOpen()
-      ? std::string{"connected: "} + this->gamepad->name().toUtf8().constData()
-      : std::string{"not connected"};
+std::string QGamepadInputDriver::get_info () const {
+  const auto status = isOpen ()
+                        ? std::string{"connected: "} + this->gamepad->name ().toUtf8 ().constData ()
+                        : std::string{"not connected"};
 
-  return get_name() + " " + status;
+  return get_name () + " " + status;
 }
diff --git a/src/gui/input/QGamepadInputDriver.h b/src/gui/input/QGamepadInputDriver.h
index a41fd425f..758dbc073 100644
--- a/src/gui/input/QGamepadInputDriver.h
+++ b/src/gui/input/QGamepadInputDriver.h
@@ -35,19 +35,19 @@
 class QGamepadInputDriver : public InputDriver
 {
 public:
-  QGamepadInputDriver();
-  void run() override;
-  bool open() override;
-  void close() override;
-  bool isOpen() const override;
+  QGamepadInputDriver ();
+  void run () override;
+  bool open () override;
+  void close () override;
+  bool isOpen () const override;
 
-  const std::string& get_name() const override;
-  std::string get_info() const override;
+  const std::string &get_name () const override;
+  std::string get_info () const override;
 
-  size_t getButtonCount() const override {
+  size_t getButtonCount () const override {
     return Settings::max_buttons;
   }
-  size_t getAxisCount() const override {
+  size_t getAxisCount () const override {
     return Settings::max_axis;
   }
 
diff --git a/src/gui/input/SpaceNavInputDriver.cc b/src/gui/input/SpaceNavInputDriver.cc
index c55959c24..9511a7c5e 100644
--- a/src/gui/input/SpaceNavInputDriver.cc
+++ b/src/gui/input/SpaceNavInputDriver.cc
@@ -38,11 +38,10 @@
 #include <unistd.h>
 #include <string>
 
-void SpaceNavInputDriver::run()
-{
-  while (spnav_input()) {
-    QThread::msleep(20);
-    spnav_remove_events(SPNAV_EVENT_MOTION);
+void SpaceNavInputDriver::run () {
+  while (spnav_input ()) {
+    QThread::msleep (20);
+    spnav_remove_events (SPNAV_EVENT_MOTION);
   }
 }
 
@@ -51,30 +50,29 @@ void SpaceNavInputDriver::run()
  * one event is available and then processes all events until the queue is
  * empty.
  */
-bool SpaceNavInputDriver::spnav_input()
-{
+bool SpaceNavInputDriver::spnav_input () {
   spnav_event ev;
 
   // The low level driver seems to inhibit events in the dead zone, so if we
   // enter that case, make sure to zero out our axis values.
   bool have_event = false;
   for (int a = 0; a < 3; ++a) {
-    if (spnav_poll_event(&ev) != 0) {
+    if (spnav_poll_event (&ev) != 0) {
       have_event = true;
       break;
     }
-    QThread::msleep(20);
+    QThread::msleep (20);
   }
 
   if (!have_event) {
-    InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(0, 0));
-    InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(1, 0));
-    InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(2, 0));
-    InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(3, 0));
-    InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(4, 0));
-    InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(5, 0));
-
-    if (spnav_wait_event(&ev) == 0) {
+    InputDriverManager::instance ()->sendEvent (new InputEventAxisChanged (0, 0));
+    InputDriverManager::instance ()->sendEvent (new InputEventAxisChanged (1, 0));
+    InputDriverManager::instance ()->sendEvent (new InputEventAxisChanged (2, 0));
+    InputDriverManager::instance ()->sendEvent (new InputEventAxisChanged (3, 0));
+    InputDriverManager::instance ()->sendEvent (new InputEventAxisChanged (4, 0));
+    InputDriverManager::instance ()->sendEvent (new InputEventAxisChanged (5, 0));
+
+    if (spnav_wait_event (&ev) == 0) {
       return false;
     }
   }
@@ -83,95 +81,119 @@ bool SpaceNavInputDriver::spnav_input()
     if (ev.type == SPNAV_EVENT_MOTION) {
 #ifdef DEBUG
       if ((ev.motion.x != 0) || (ev.motion.y != 0) || (ev.motion.z != 0)) {
-        PRINTDB("Translate Event: x = %d, y = %d, z = %d", ev.motion.x % ev.motion.y % ev.motion.z);
+        PRINTDB ("Translate Event: x = %d, y = %d, z = %d", ev.motion.x % ev.motion.y % ev.motion.z);
       }
       if ((ev.motion.rx != 0) || (ev.motion.ry != 0) || (ev.motion.rz != 0)) {
-        PRINTDB("Rotate Event: rx = %d, ry = %d, rz = %d", ev.motion.rx % ev.motion.ry % ev.motion.rz);
+        PRINTDB ("Rotate Event: rx = %d, ry = %d, rz = %d", ev.motion.rx % ev.motion.ry % ev.motion.rz);
       }
 #endif
 
       if (this->dominantAxisOnly) {
         // dominant axis only
         int m = ev.motion.x;
-        if (abs(m) < abs(ev.motion.y)) m = ev.motion.y;
-        if (abs(m) < abs(ev.motion.z)) m = ev.motion.z;
-        if (abs(m) < abs(ev.motion.rx)) m = ev.motion.rx;
-        if (abs(m) < abs(ev.motion.ry)) m = ev.motion.ry;
-        if (abs(m) < abs(ev.motion.rz)) m = ev.motion.rz;
+        if (abs (m) < abs (ev.motion.y))
+          m = ev.motion.y;
+        if (abs (m) < abs (ev.motion.z))
+          m = ev.motion.z;
+        if (abs (m) < abs (ev.motion.rx))
+          m = ev.motion.rx;
+        if (abs (m) < abs (ev.motion.ry))
+          m = ev.motion.ry;
+        if (abs (m) < abs (ev.motion.rz))
+          m = ev.motion.rz;
 
         if (ev.motion.x == m) {
-          ev.motion.y = 0; ev.motion.z = 0; ev.motion.rx = 0; ev.motion.ry = 0; ev.motion.rz = 0;
+          ev.motion.y = 0;
+          ev.motion.z = 0;
+          ev.motion.rx = 0;
+          ev.motion.ry = 0;
+          ev.motion.rz = 0;
         }
         if (ev.motion.y == m) {
-          ev.motion.x = 0;                ev.motion.z = 0; ev.motion.rx = 0; ev.motion.ry = 0; ev.motion.rz = 0;
+          ev.motion.x = 0;
+          ev.motion.z = 0;
+          ev.motion.rx = 0;
+          ev.motion.ry = 0;
+          ev.motion.rz = 0;
         }
         if (ev.motion.z == m) {
-          ev.motion.x = 0; ev.motion.y = 0;                ev.motion.rx = 0; ev.motion.ry = 0; ev.motion.rz = 0;
+          ev.motion.x = 0;
+          ev.motion.y = 0;
+          ev.motion.rx = 0;
+          ev.motion.ry = 0;
+          ev.motion.rz = 0;
         }
         if (ev.motion.rx == m) {
-          ev.motion.x = 0; ev.motion.y = 0; ev.motion.z = 0;                 ev.motion.ry = 0; ev.motion.rz = 0;
+          ev.motion.x = 0;
+          ev.motion.y = 0;
+          ev.motion.z = 0;
+          ev.motion.ry = 0;
+          ev.motion.rz = 0;
         }
         if (ev.motion.ry == m) {
-          ev.motion.x = 0; ev.motion.y = 0; ev.motion.z = 0; ev.motion.rx = 0;                 ev.motion.rz = 0;
+          ev.motion.x = 0;
+          ev.motion.y = 0;
+          ev.motion.z = 0;
+          ev.motion.rx = 0;
+          ev.motion.rz = 0;
         }
         if (ev.motion.rz == m) {
-          ev.motion.x = 0; ev.motion.y = 0; ev.motion.z = 0; ev.motion.rx = 0; ev.motion.ry = 0;
+          ev.motion.x = 0;
+          ev.motion.y = 0;
+          ev.motion.z = 0;
+          ev.motion.rx = 0;
+          ev.motion.ry = 0;
         }
       }
 
       if (ev.motion.x != 0) {
-        InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(0, ev.motion.x / 500.0));
+        InputDriverManager::instance ()->sendEvent (new InputEventAxisChanged (0, ev.motion.x / 500.0));
       }
       if (ev.motion.y != 0) {
-        InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(1, ev.motion.y / 500.0));
+        InputDriverManager::instance ()->sendEvent (new InputEventAxisChanged (1, ev.motion.y / 500.0));
       }
       if (ev.motion.z != 0) {
-        InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(2, ev.motion.z / 500.0));
+        InputDriverManager::instance ()->sendEvent (new InputEventAxisChanged (2, ev.motion.z / 500.0));
       }
       if (ev.motion.rx != 0) {
-        InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(3, ev.motion.rx / 500.0));
+        InputDriverManager::instance ()->sendEvent (new InputEventAxisChanged (3, ev.motion.rx / 500.0));
       }
       if (ev.motion.ry != 0) {
-        InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(4, ev.motion.ry / 500.0));
+        InputDriverManager::instance ()->sendEvent (new InputEventAxisChanged (4, ev.motion.ry / 500.0));
       }
       if (ev.motion.rz != 0) {
-        InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(5, ev.motion.rz / 500.0));
+        InputDriverManager::instance ()->sendEvent (new InputEventAxisChanged (5, ev.motion.rz / 500.0));
       }
     } else if (ev.type == SPNAV_EVENT_BUTTON) {
-      PRINTDB("Button Event: num = %d, %s", ev.button.bnum % (ev.button.press ? "pressed" : "released"));
-      InputEvent *event = new InputEventButtonChanged(ev.button.bnum, ev.button.press);
-      InputDriverManager::instance()->sendEvent(event);
+      PRINTDB ("Button Event: num = %d, %s", ev.button.bnum % (ev.button.press ? "pressed" : "released"));
+      InputEvent *event = new InputEventButtonChanged (ev.button.bnum, ev.button.press);
+      InputDriverManager::instance ()->sendEvent (event);
     }
-  } while (spnav_poll_event(&ev));
+  } while (spnav_poll_event (&ev));
 
   return true;
 }
 
-bool SpaceNavInputDriver::open()
-{
-  if (spnav_open() < 0) {
+bool SpaceNavInputDriver::open () {
+  if (spnav_open () < 0) {
     return false;
   }
-  start();
+  start ();
   return true;
 }
 
-void SpaceNavInputDriver::close()
-{
-
+void SpaceNavInputDriver::close () {
 }
 
-void SpaceNavInputDriver::setDominantAxisOnly(bool var){
+void SpaceNavInputDriver::setDominantAxisOnly (bool var) {
   this->dominantAxisOnly = var;
 }
 
-const std::string& SpaceNavInputDriver::get_name() const
-{
+const std::string &SpaceNavInputDriver::get_name () const {
   static std::string name = "SpaceNavInputDriver";
   return name;
 }
 
-std::string SpaceNavInputDriver::get_info() const
-{
-  return STR(get_name(), " ", (isOpen() ? "open" : "not open"), " ");
+std::string SpaceNavInputDriver::get_info () const {
+  return STR (get_name (), " ", (isOpen () ? "open" : "not open"), " ");
 }
diff --git a/src/gui/input/SpaceNavInputDriver.h b/src/gui/input/SpaceNavInputDriver.h
index 58eca0585..10f339934 100644
--- a/src/gui/input/SpaceNavInputDriver.h
+++ b/src/gui/input/SpaceNavInputDriver.h
@@ -36,23 +36,23 @@ class SpaceNavInputDriver : public InputDriver
   Q_OBJECT
 
 public:
-  SpaceNavInputDriver() = default;
-  void run() override;
-  bool open() override;
-  void close() override;
-  void setDominantAxisOnly(bool var);
+  SpaceNavInputDriver () = default;
+  void run () override;
+  bool open () override;
+  void close () override;
+  void setDominantAxisOnly (bool var);
 
-  const std::string& get_name() const override;
-  std::string get_info() const override;
+  const std::string &get_name () const override;
+  std::string get_info () const override;
 
-  size_t getButtonCount() const override {
+  size_t getButtonCount () const override {
     return Settings::max_buttons;
   }
-  size_t getAxisCount() const override {
+  size_t getAxisCount () const override {
     return Settings::max_axis;
   }
 
 private:
-  bool spnav_input();
+  bool spnav_input ();
   bool dominantAxisOnly{true};
 };
diff --git a/src/gui/parameter/GroupWidget.cc b/src/gui/parameter/GroupWidget.cc
index 042167e9d..35d3ee005 100644
--- a/src/gui/parameter/GroupWidget.cc
+++ b/src/gui/parameter/GroupWidget.cc
@@ -6,43 +6,41 @@
 #include <QWidget>
 #include <QLineEdit>
 
-GroupWidget::GroupWidget(const QString& title, QWidget *parent) : QWidget(parent)
-{
-  this->toggleButton.setText(title);
-  this->toggleButton.setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Maximum);
-  this->toggleButton.setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
-  this->toggleButton.setCheckable(true);
-  setExpanded(false);
+GroupWidget::GroupWidget (const QString &title, QWidget *parent)
+  : QWidget (parent) {
+  this->toggleButton.setText (title);
+  this->toggleButton.setSizePolicy (QSizePolicy::Minimum, QSizePolicy::Maximum);
+  this->toggleButton.setToolButtonStyle (Qt::ToolButtonTextBesideIcon);
+  this->toggleButton.setCheckable (true);
+  setExpanded (false);
 
   // don't waste space
-  this->mainLayout.setVerticalSpacing(0);
-  this->mainLayout.setContentsMargins(0, 0, 0, 0);
-  this->contentArea.setContentsMargins(0, 0, 0, 0);
-  this->contentLayout.setSpacing(0);
-  this->contentLayout.setContentsMargins(0, 0, 0, 0);
+  this->mainLayout.setVerticalSpacing (0);
+  this->mainLayout.setContentsMargins (0, 0, 0, 0);
+  this->contentArea.setContentsMargins (0, 0, 0, 0);
+  this->contentLayout.setSpacing (0);
+  this->contentLayout.setContentsMargins (0, 0, 0, 0);
 
-  this->contentArea.setLayout(&contentLayout);
-  this->contentArea.hide();
-  this->mainLayout.addWidget(&toggleButton, 0, 0);
-  this->mainLayout.addWidget(&contentArea, 1, 0);
-  setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Maximum);
-  setLayout(&mainLayout);
+  this->contentArea.setLayout (&contentLayout);
+  this->contentArea.hide ();
+  this->mainLayout.addWidget (&toggleButton, 0, 0);
+  this->mainLayout.addWidget (&contentArea, 1, 0);
+  setSizePolicy (QSizePolicy::Minimum, QSizePolicy::Maximum);
+  setLayout (&mainLayout);
 
-  QObject::connect(&toggleButton, &QToolButton::toggled, this, &GroupWidget::setExpanded);
+  QObject::connect (&toggleButton, &QToolButton::toggled, this, &GroupWidget::setExpanded);
 }
 
-void GroupWidget::addWidget(QWidget *widget)
-{
-  contentLayout.addWidget(widget);
+void GroupWidget::addWidget (QWidget *widget) {
+  contentLayout.addWidget (widget);
 }
 
-void GroupWidget::setExpanded(bool expanded)
-{
-  toggleButton.setChecked(expanded);
-  toggleButton.setArrowType(expanded ? Qt::DownArrow : Qt::RightArrow);
+void GroupWidget::setExpanded (bool expanded) {
+  toggleButton.setChecked (expanded);
+  toggleButton.setArrowType (expanded ? Qt::DownArrow : Qt::RightArrow);
   if (expanded) {
-    contentArea.show();
+    contentArea.show ();
   } else {
-    contentArea.hide();
+    contentArea.hide ();
   }
 }
diff --git a/src/gui/parameter/GroupWidget.h b/src/gui/parameter/GroupWidget.h
index 86cba49e1..1dba1ef1f 100644
--- a/src/gui/parameter/GroupWidget.h
+++ b/src/gui/parameter/GroupWidget.h
@@ -16,12 +16,16 @@ private:
   QVBoxLayout contentLayout;
 
 public:
-  GroupWidget(const QString& title, QWidget *parent = nullptr);
-  void addWidget(QWidget *widget);
+  GroupWidget (const QString &title, QWidget *parent = nullptr);
+  void addWidget (QWidget *widget);
 
-  bool isExpanded() const { return toggleButton.isChecked(); }
-  QString title() const { return toggleButton.text(); }
+  bool isExpanded () const {
+    return toggleButton.isChecked ();
+  }
+  QString title () const {
+    return toggleButton.text ();
+  }
 
 public slots:
-  void setExpanded(bool expanded);
+  void setExpanded (bool expanded);
 };
diff --git a/src/gui/parameter/ParameterCheckBox.cc b/src/gui/parameter/ParameterCheckBox.cc
index 6f11edad2..6458c568d 100644
--- a/src/gui/parameter/ParameterCheckBox.cc
+++ b/src/gui/parameter/ParameterCheckBox.cc
@@ -1,29 +1,26 @@
 #include <QWidget>
 #include "gui/parameter/ParameterCheckBox.h"
 
-ParameterCheckBox::ParameterCheckBox(QWidget *parent, BoolParameter *parameter, DescriptionStyle descriptionStyle) :
-  ParameterVirtualWidget(parent, parameter),
-  parameter(parameter)
-{
-  setupUi(this);
-  descriptionWidget->setDescription(parameter, descriptionStyle);
+ParameterCheckBox::ParameterCheckBox (QWidget *parent, BoolParameter *parameter, DescriptionStyle descriptionStyle)
+  : ParameterVirtualWidget (parent, parameter)
+  , parameter (parameter) {
+  setupUi (this);
+  descriptionWidget->setDescription (parameter, descriptionStyle);
 
   if (descriptionStyle == DescriptionStyle::ShowDetails) {
     //large checkbox, when we have the space
-    checkBox->setStyleSheet("QCheckBox::indicator { width: 20px; height: 20px; } QCheckBox { spacing: 0px; }");
+    checkBox->setStyleSheet ("QCheckBox::indicator { width: 20px; height: 20px; } QCheckBox { spacing: 0px; }");
   }
 
-  connect(checkBox, &QCheckBox::clicked, this, &ParameterCheckBox::onChanged);
-  ParameterCheckBox::setValue();
+  connect (checkBox, &QCheckBox::clicked, this, &ParameterCheckBox::onChanged);
+  ParameterCheckBox::setValue ();
 }
 
-void ParameterCheckBox::onChanged()
-{
-  parameter->value = checkBox->isChecked();
-  emit changed(true);
+void ParameterCheckBox::onChanged () {
+  parameter->value = checkBox->isChecked ();
+  emit changed (true);
 }
 
-void ParameterCheckBox::setValue()
-{
-  checkBox->setChecked(parameter->value);
+void ParameterCheckBox::setValue () {
+  checkBox->setChecked (parameter->value);
 }
diff --git a/src/gui/parameter/ParameterCheckBox.h b/src/gui/parameter/ParameterCheckBox.h
index 55c8078d3..cd63922bc 100644
--- a/src/gui/parameter/ParameterCheckBox.h
+++ b/src/gui/parameter/ParameterCheckBox.h
@@ -9,11 +9,11 @@ class ParameterCheckBox : public ParameterVirtualWidget, Ui::ParameterCheckBox
   Q_OBJECT
 
 public:
-  ParameterCheckBox(QWidget *parent, BoolParameter *parameter, DescriptionStyle descriptionStyle);
-  void setValue() override;
+  ParameterCheckBox (QWidget *parent, BoolParameter *parameter, DescriptionStyle descriptionStyle);
+  void setValue () override;
 
 protected slots:
-  void onChanged();
+  void onChanged ();
 
 private:
   BoolParameter *parameter;
diff --git a/src/gui/parameter/ParameterComboBox.cc b/src/gui/parameter/ParameterComboBox.cc
index 9d6fc286a..c8a50d7b1 100644
--- a/src/gui/parameter/ParameterComboBox.cc
+++ b/src/gui/parameter/ParameterComboBox.cc
@@ -3,33 +3,30 @@
 #include <QWidget>
 #include "gui/IgnoreWheelWhenNotFocused.h"
 
-ParameterComboBox::ParameterComboBox(QWidget *parent, EnumParameter *parameter, DescriptionStyle descriptionStyle) :
-  ParameterVirtualWidget(parent, parameter),
-  parameter(parameter)
-{
-  setupUi(this);
-  descriptionWidget->setDescription(parameter, descriptionStyle);
+ParameterComboBox::ParameterComboBox (QWidget *parent, EnumParameter *parameter, DescriptionStyle descriptionStyle)
+  : ParameterVirtualWidget (parent, parameter)
+  , parameter (parameter) {
+  setupUi (this);
+  descriptionWidget->setDescription (parameter, descriptionStyle);
 
-  auto *ignoreWheelWhenNotFocused = new IgnoreWheelWhenNotFocused(this);
-  comboBox->installEventFilter(ignoreWheelWhenNotFocused);
+  auto *ignoreWheelWhenNotFocused = new IgnoreWheelWhenNotFocused (this);
+  comboBox->installEventFilter (ignoreWheelWhenNotFocused);
 
-  for (const auto& item : parameter->items) {
-    comboBox->addItem(QString::fromStdString(item.key));
+  for (const auto &item : parameter->items) {
+    comboBox->addItem (QString::fromStdString (item.key));
   }
 
-  connect(comboBox, QOverload<int>::of(&QComboBox::activated), this, &ParameterComboBox::onChanged);
-  ParameterComboBox::setValue();
+  connect (comboBox, QOverload<int>::of (&QComboBox::activated), this, &ParameterComboBox::onChanged);
+  ParameterComboBox::setValue ();
 }
 
-void ParameterComboBox::onChanged(int index)
-{
+void ParameterComboBox::onChanged (int index) {
   if (parameter->valueIndex != index) {
     parameter->valueIndex = index;
-    emit changed(true);
+    emit changed (true);
   }
 }
 
-void ParameterComboBox::setValue()
-{
-  comboBox->setCurrentIndex(parameter->valueIndex);
+void ParameterComboBox::setValue () {
+  comboBox->setCurrentIndex (parameter->valueIndex);
 }
diff --git a/src/gui/parameter/ParameterComboBox.h b/src/gui/parameter/ParameterComboBox.h
index 387f8f4af..4fc78d849 100644
--- a/src/gui/parameter/ParameterComboBox.h
+++ b/src/gui/parameter/ParameterComboBox.h
@@ -9,11 +9,11 @@ class ParameterComboBox : public ParameterVirtualWidget, Ui::ParameterComboBox
   Q_OBJECT
 
 public:
-  ParameterComboBox(QWidget *parent, EnumParameter *parameter, DescriptionStyle descriptionStyle);
-  void setValue() override;
+  ParameterComboBox (QWidget *parent, EnumParameter *parameter, DescriptionStyle descriptionStyle);
+  void setValue () override;
 
 protected slots:
-  void onChanged(int index);
+  void onChanged (int index);
 
 private:
   EnumParameter *parameter;
diff --git a/src/gui/parameter/ParameterSlider.cc b/src/gui/parameter/ParameterSlider.cc
index 46d26604c..bfdf280fd 100644
--- a/src/gui/parameter/ParameterSlider.cc
+++ b/src/gui/parameter/ParameterSlider.cc
@@ -5,143 +5,129 @@
 #include <limits>
 #include "gui/IgnoreWheelWhenNotFocused.h"
 
-ParameterSlider::ParameterSlider(QWidget *parent, NumberParameter *parameter, DescriptionStyle descriptionStyle) :
-  ParameterVirtualWidget(parent, parameter),
-  parameter(parameter)
-{
-  setupUi(this);
-  descriptionWidget->setDescription(parameter, descriptionStyle);
+ParameterSlider::ParameterSlider (QWidget *parent, NumberParameter *parameter, DescriptionStyle descriptionStyle)
+  : ParameterVirtualWidget (parent, parameter)
+  , parameter (parameter) {
+  setupUi (this);
+  descriptionWidget->setDescription (parameter, descriptionStyle);
 
-  auto *ignoreWheelWhenNotFocused = new IgnoreWheelWhenNotFocused(this);
-  slider->installEventFilter(ignoreWheelWhenNotFocused);
-  doubleSpinBox->installEventFilter(ignoreWheelWhenNotFocused);
-  doubleSpinBox->setKeyboardTracking(true);
+  auto *ignoreWheelWhenNotFocused = new IgnoreWheelWhenNotFocused (this);
+  slider->installEventFilter (ignoreWheelWhenNotFocused);
+  doubleSpinBox->installEventFilter (ignoreWheelWhenNotFocused);
+  doubleSpinBox->setKeyboardTracking (true);
 
-  assert(parameter->minimum);
-  assert(parameter->maximum);
+  assert (parameter->minimum);
+  assert (parameter->maximum);
 
   int decimals;
   this->minimum = *parameter->minimum;
   if (parameter->step) {
     this->step = *parameter->step;
-    decimals = decimalsRequired({
-      this->minimum,
-      parameter->defaultValue,
-      this->step
-    });
+    decimals = decimalsRequired ({this->minimum,
+                                  parameter->defaultValue,
+                                  this->step});
   } else {
-    decimals = decimalsRequired({
-      this->minimum,
-      parameter->defaultValue
-    });
-    this->step = pow(0.1, decimals);
+    decimals = decimalsRequired ({this->minimum,
+                                  parameter->defaultValue});
+    this->step = pow (0.1, decimals);
   }
 
-  static constexpr auto maxSteps = static_cast<double>(std::numeric_limits<int>::max());
+  static constexpr auto maxSteps = static_cast<double> (std::numeric_limits<int>::max ());
   // Use nextafter to compensate for possible floating point inaccurary where result is just below a whole number.
-  double tempSteps = std::nextafter((*parameter->maximum - this->minimum) / this->step, maxSteps) + 1.0;
-  int numSteps = tempSteps >= maxSteps ? std::numeric_limits<int>::max() : static_cast<int>(tempSteps);
+  double tempSteps = std::nextafter ((*parameter->maximum - this->minimum) / this->step, maxSteps) + 1.0;
+  int numSteps = tempSteps >= maxSteps ? std::numeric_limits<int>::max () : static_cast<int> (tempSteps);
   // Truncate end value to full steps, same as Thingiverse customizer.
   // This also makes sure the step size of the spin box does not go to
   // invalid values.
-  double maximumValue = parameterValue(numSteps - 1);
+  double maximumValue = parameterValue (numSteps - 1);
 
-  slider->setRange(0, numSteps - 1);
-  slider->setPageStep(std::ceil(0.1 * numSteps));
-  doubleSpinBox->setDecimals(decimals);
-  doubleSpinBox->setRange(this->minimum, maximumValue);
-  doubleSpinBox->setSingleStep(this->step);
+  slider->setRange (0, numSteps - 1);
+  slider->setPageStep (std::ceil (0.1 * numSteps));
+  doubleSpinBox->setDecimals (decimals);
+  doubleSpinBox->setRange (this->minimum, maximumValue);
+  doubleSpinBox->setSingleStep (this->step);
 
   //connect(slider, &QSlider::sliderPressed, this, &ParameterSlider::onSliderPressed);
-  connect(slider, &QSlider::sliderReleased, this, &ParameterSlider::onSliderReleased);
-  connect(slider, &QSlider::sliderMoved, this, &ParameterSlider::onSliderMoved);
-  connect(slider, &QSlider::valueChanged, this, &ParameterSlider::onSliderChanged);
+  connect (slider, &QSlider::sliderReleased, this, &ParameterSlider::onSliderReleased);
+  connect (slider, &QSlider::sliderMoved, this, &ParameterSlider::onSliderMoved);
+  connect (slider, &QSlider::valueChanged, this, &ParameterSlider::onSliderChanged);
 
-  connect(doubleSpinBox, QOverload<double>::of(&QDoubleSpinBox::valueChanged), this, &ParameterSlider::onSpinBoxChanged);
-  connect(doubleSpinBox, &QDoubleSpinBox::editingFinished, this, &ParameterSlider::onSpinBoxEditingFinished);
+  connect (doubleSpinBox, QOverload<double>::of (&QDoubleSpinBox::valueChanged), this, &ParameterSlider::onSpinBoxChanged);
+  connect (doubleSpinBox, &QDoubleSpinBox::editingFinished, this, &ParameterSlider::onSpinBoxEditingFinished);
 
-  ParameterSlider::setValue();
+  ParameterSlider::setValue ();
 }
 
-void ParameterSlider::valueApplied() {
+void ParameterSlider::valueApplied () {
   lastApplied = lastSent;
 }
 
 // slider handle grabbed
-void ParameterSlider::onSliderPressed()
-{
+void ParameterSlider::onSliderPressed () {
 }
 
 // slider handle released
-void ParameterSlider::onSliderReleased()
-{
-  this->commitChange(true);
+void ParameterSlider::onSliderReleased () {
+  this->commitChange (true);
 }
 
 // slider handle dragged
-void ParameterSlider::onSliderMoved(int position)
-{
-  double value = parameterValue(position);
-  doubleSpinBox->blockSignals(true);
-  doubleSpinBox->setValue(value);
-  doubleSpinBox->blockSignals(false);
+void ParameterSlider::onSliderMoved (int position) {
+  double value = parameterValue (position);
+  doubleSpinBox->blockSignals (true);
+  doubleSpinBox->setValue (value);
+  doubleSpinBox->blockSignals (false);
 }
 
 // slider track clicked
 // changes by pageStep or sets absolute position, depending on platform or specific mouse button
-void ParameterSlider::onSliderChanged(int position)
-{
-  double value = parameterValue(position);
-  doubleSpinBox->blockSignals(true);
-  doubleSpinBox->setValue(value);
-  doubleSpinBox->blockSignals(false);
-  commitChange(false);
+void ParameterSlider::onSliderChanged (int position) {
+  double value = parameterValue (position);
+  doubleSpinBox->blockSignals (true);
+  doubleSpinBox->setValue (value);
+  doubleSpinBox->blockSignals (false);
+  commitChange (false);
 }
 
 // spin button click or arrow keypress
-void ParameterSlider::onSpinBoxChanged(double value)
-{
-  int position = sliderPosition(value);
-  slider->blockSignals(true);
-  slider->setValue(position);
-  slider->blockSignals(false);
-  commitChange(false);
+void ParameterSlider::onSpinBoxChanged (double value) {
+  int position = sliderPosition (value);
+  slider->blockSignals (true);
+  slider->setValue (position);
+  slider->blockSignals (false);
+  commitChange (false);
 }
 
 // Enter key pressed or spinbox focus lost
-void ParameterSlider::onSpinBoxEditingFinished()
-{
-  commitChange(true);
+void ParameterSlider::onSpinBoxEditingFinished () {
+  commitChange (true);
 }
 
-void ParameterSlider::commitChange(bool immediate) {
-  double value = parameterValue(slider->sliderPosition());
+void ParameterSlider::commitChange (bool immediate) {
+  double value = parameterValue (slider->sliderPosition ());
 #ifdef DEBUG
-  PRINTD(STR("[commit] value=", value, ", parameter->value=", parameter->value, ", lastSent=", lastSent, ", lastApplied=", lastApplied));
+  PRINTD (STR ("[commit] value=", value, ", parameter->value=", parameter->value, ", lastSent=", lastSent, ", lastApplied=", lastApplied));
 #endif
-  if ((immediate && lastApplied != value) || (!immediate && lastSent != value) ) {
+  if ((immediate && lastApplied != value) || (!immediate && lastSent != value)) {
     lastSent = parameter->value = value;
-    emit changed(immediate);
+    emit changed (immediate);
   }
 }
 
 // Called when populating parameter presets
-void ParameterSlider::setValue()
-{
+void ParameterSlider::setValue () {
 #ifdef DEBUG
-  PRINTD(STR("[setValue] parameter->value=", parameter->value, ", lastSent=", lastSent, ", lastApplied=", lastApplied));
+  PRINTD (STR ("[setValue] parameter->value=", parameter->value, ", lastSent=", lastSent, ", lastApplied=", lastApplied));
 #endif
-  int position = sliderPosition(parameter->value);
+  int position = sliderPosition (parameter->value);
   lastApplied = lastSent = parameter->value;
-  slider->setValue(position);
+  slider->setValue (position);
 }
 
-int ParameterSlider::sliderPosition(double value)
-{
-  return static_cast<int>(std::round((value - this->minimum) / this->step));
+int ParameterSlider::sliderPosition (double value) {
+  return static_cast<int> (std::round ((value - this->minimum) / this->step));
 }
 
-double ParameterSlider::parameterValue(int sliderPosition)
-{
+double ParameterSlider::parameterValue (int sliderPosition) {
   return this->minimum + sliderPosition * this->step;
 }
diff --git a/src/gui/parameter/ParameterSlider.h b/src/gui/parameter/ParameterSlider.h
index a92e5ed48..fecee6240 100644
--- a/src/gui/parameter/ParameterSlider.h
+++ b/src/gui/parameter/ParameterSlider.h
@@ -9,18 +9,18 @@ class ParameterSlider : public ParameterVirtualWidget, Ui::ParameterSlider
   Q_OBJECT
 
 public:
-  ParameterSlider(QWidget *parent, NumberParameter *parameter, DescriptionStyle descriptionStyle);
-  void setValue() override;
-  void valueApplied() override;
+  ParameterSlider (QWidget *parent, NumberParameter *parameter, DescriptionStyle descriptionStyle);
+  void setValue () override;
+  void valueApplied () override;
 
 protected slots:
-  void onSliderPressed();
-  void onSliderReleased();
-  void onSliderMoved(int position);
-  void onSliderChanged(int position);
+  void onSliderPressed ();
+  void onSliderReleased ();
+  void onSliderMoved (int position);
+  void onSliderChanged (int position);
 
-  void onSpinBoxChanged(double value);
-  void onSpinBoxEditingFinished();
+  void onSpinBoxChanged (double value);
+  void onSpinBoxEditingFinished ();
 
 private:
   NumberParameter *parameter;
@@ -29,7 +29,7 @@ private:
   double minimum;
   double step;
 
-  int sliderPosition(double value);
-  double parameterValue(int sliderPosition);
-  void commitChange(bool immediate);
+  int sliderPosition (double value);
+  double parameterValue (int sliderPosition);
+  void commitChange (bool immediate);
 };
diff --git a/src/gui/parameter/ParameterSpinBox.cc b/src/gui/parameter/ParameterSpinBox.cc
index 61edc37d9..27cca3980 100644
--- a/src/gui/parameter/ParameterSpinBox.cc
+++ b/src/gui/parameter/ParameterSpinBox.cc
@@ -4,81 +4,77 @@
 #include <limits>
 #include "gui/IgnoreWheelWhenNotFocused.h"
 
-ParameterSpinBox::ParameterSpinBox(QWidget *parent, NumberParameter *parameter, DescriptionStyle descriptionStyle) :
-  ParameterVirtualWidget(parent, parameter),
-  parameter(parameter)
-{
-  setupUi(this);
-  descriptionWidget->setDescription(parameter, descriptionStyle);
+ParameterSpinBox::ParameterSpinBox (QWidget *parent, NumberParameter *parameter, DescriptionStyle descriptionStyle)
+  : ParameterVirtualWidget (parent, parameter)
+  , parameter (parameter) {
+  setupUi (this);
+  descriptionWidget->setDescription (parameter, descriptionStyle);
 
-  auto *ignoreWheelWhenNotFocused = new IgnoreWheelWhenNotFocused(this);
-  doubleSpinBox->installEventFilter(ignoreWheelWhenNotFocused);
-  doubleSpinBox->setKeyboardTracking(true);
+  auto *ignoreWheelWhenNotFocused = new IgnoreWheelWhenNotFocused (this);
+  doubleSpinBox->installEventFilter (ignoreWheelWhenNotFocused);
+  doubleSpinBox->setKeyboardTracking (true);
 
-  int decimals = decimalsRequired(parameter->defaultValue);
+  int decimals = decimalsRequired (parameter->defaultValue);
   double minimum;
   if (parameter->minimum) {
     minimum = *parameter->minimum;
-    decimals = std::max(decimals, decimalsRequired(minimum));
+    decimals = std::max (decimals, decimalsRequired (minimum));
   } else if (parameter->maximum && *parameter->maximum > 0) {
     minimum = 0;
   } else {
-    minimum = std::numeric_limits<double>::lowest();
+    minimum = std::numeric_limits<double>::lowest ();
   }
   double maximum;
   if (parameter->maximum) {
     maximum = *parameter->maximum;
-    decimals = std::max(decimals, decimalsRequired(maximum));
+    decimals = std::max (decimals, decimalsRequired (maximum));
   } else if (parameter->minimum && *parameter->minimum < 0) {
     maximum = 0;
   } else {
-    maximum = std::numeric_limits<double>::max();
+    maximum = std::numeric_limits<double>::max ();
   }
   double step;
   if (parameter->step) {
     step = *parameter->step;
-    decimals = std::max(decimals, decimalsRequired(step));
+    decimals = std::max (decimals, decimalsRequired (step));
   } else {
-    step = pow(0.1, decimals);
+    step = pow (0.1, decimals);
   }
-  doubleSpinBox->setDecimals(decimals);
-  doubleSpinBox->setRange(minimum, maximum);
-  doubleSpinBox->setSingleStep(step);
+  doubleSpinBox->setDecimals (decimals);
+  doubleSpinBox->setRange (minimum, maximum);
+  doubleSpinBox->setSingleStep (step);
 
-  connect(doubleSpinBox, QOverload<double>::of(&QDoubleSpinBox::valueChanged), this, &ParameterSpinBox::onChanged);
-  connect(doubleSpinBox, &QDoubleSpinBox::editingFinished, this, &ParameterSpinBox::onEditingFinished);
-  ParameterSpinBox::setValue();
+  connect (doubleSpinBox, QOverload<double>::of (&QDoubleSpinBox::valueChanged), this, &ParameterSpinBox::onChanged);
+  connect (doubleSpinBox, &QDoubleSpinBox::editingFinished, this, &ParameterSpinBox::onEditingFinished);
+  ParameterSpinBox::setValue ();
 }
 
-void ParameterSpinBox::valueApplied() {
+void ParameterSpinBox::valueApplied () {
   lastApplied = lastSent;
 }
 
-void ParameterSpinBox::onChanged(double value)
-{
+void ParameterSpinBox::onChanged (double value) {
 #ifdef DEBUG
-  PRINTD(STR("[changed] value=", value, ", parameter->value=", parameter->value, ", lastSent=", lastSent, ", lastApplied=", lastApplied));
+  PRINTD (STR ("[changed] value=", value, ", parameter->value=", parameter->value, ", lastSent=", lastSent, ", lastApplied=", lastApplied));
 #endif
   parameter->value = value;
   if (lastSent != value) {
     lastSent = value;
-    emit changed(false);
+    emit changed (false);
   }
 }
 
-void ParameterSpinBox::onEditingFinished()
-{
+void ParameterSpinBox::onEditingFinished () {
 #ifdef DEBUG
-  PRINTD(STR("[finished] parameter->value=", parameter->value, ", lastSent=", lastSent, ", lastApplied=", lastApplied));
+  PRINTD (STR ("[finished] parameter->value=", parameter->value, ", lastSent=", lastSent, ", lastApplied=", lastApplied));
 #endif
   if (lastApplied != parameter->value) {
     lastSent = parameter->value;
-    emit changed(true);
+    emit changed (true);
   }
 }
 
-void ParameterSpinBox::setValue()
-{
+void ParameterSpinBox::setValue () {
   lastApplied = lastSent = parameter->value;
-  doubleSpinBox->setValue(parameter->value);
+  doubleSpinBox->setValue (parameter->value);
 }
diff --git a/src/gui/parameter/ParameterSpinBox.h b/src/gui/parameter/ParameterSpinBox.h
index 5a39dc80c..4f473799e 100644
--- a/src/gui/parameter/ParameterSpinBox.h
+++ b/src/gui/parameter/ParameterSpinBox.h
@@ -9,17 +9,16 @@ class ParameterSpinBox : public ParameterVirtualWidget, Ui::ParameterSpinBox
   Q_OBJECT
 
 public:
-  ParameterSpinBox(QWidget *parent, NumberParameter *parameter, DescriptionStyle descriptionStyle);
-  void setValue() override;
-  void valueApplied() override;
+  ParameterSpinBox (QWidget *parent, NumberParameter *parameter, DescriptionStyle descriptionStyle);
+  void setValue () override;
+  void valueApplied () override;
 
 protected slots:
-  void onChanged(double);
-  void onEditingFinished();
+  void onChanged (double);
+  void onEditingFinished ();
 
 private:
   NumberParameter *parameter;
   boost::optional<double> lastSent;
   boost::optional<double> lastApplied;
-
 };
diff --git a/src/gui/parameter/ParameterText.cc b/src/gui/parameter/ParameterText.cc
index 65c731c8b..f5042edfb 100644
--- a/src/gui/parameter/ParameterText.cc
+++ b/src/gui/parameter/ParameterText.cc
@@ -4,50 +4,47 @@
 #include <QWidget>
 #include <string>
 
-ParameterText::ParameterText(QWidget *parent, StringParameter *parameter, DescriptionStyle descriptionStyle) :
-  ParameterVirtualWidget(parent, parameter),
-  parameter(parameter)
-{
-  setupUi(this);
-  descriptionWidget->setDescription(parameter, descriptionStyle);
+ParameterText::ParameterText (QWidget *parent, StringParameter *parameter, DescriptionStyle descriptionStyle)
+  : ParameterVirtualWidget (parent, parameter)
+  , parameter (parameter) {
+  setupUi (this);
+  descriptionWidget->setDescription (parameter, descriptionStyle);
 
   if (parameter->maximumSize) {
-    lineEdit->setMaxLength(*parameter->maximumSize);
+    lineEdit->setMaxLength (*parameter->maximumSize);
   }
 
-  connect(lineEdit, &QLineEdit::textEdited, this, &ParameterText::onEdit);
-  connect(lineEdit, &QLineEdit::editingFinished, this, &ParameterText::onEditingFinished);
-  ParameterText::setValue();
+  connect (lineEdit, &QLineEdit::textEdited, this, &ParameterText::onEdit);
+  connect (lineEdit, &QLineEdit::editingFinished, this, &ParameterText::onEditingFinished);
+  ParameterText::setValue ();
 }
 
-void ParameterText::valueApplied() {
+void ParameterText::valueApplied () {
   lastApplied = lastSent;
 }
 
-void ParameterText::onEdit(const QString& text)
-{
+void ParameterText::onEdit (const QString &text) {
 #ifdef DEBUG
-  PRINTD("edit");
+  PRINTD ("edit");
 #endif
-  std::string value = text.toStdString();
+  std::string value = text.toStdString ();
   if (lastSent != value) {
     lastSent = parameter->value = value;
-    emit changed(false);
+    emit changed (false);
   }
 }
 
-void ParameterText::onEditingFinished() {
+void ParameterText::onEditingFinished () {
 #ifdef DEBUG
-  PRINTD("editing finished");
+  PRINTD ("editing finished");
 #endif
   if (lastApplied != parameter->value) {
-    lastSent = parameter->value = lineEdit->text().toStdString();
-    emit changed(true);
+    lastSent = parameter->value = lineEdit->text ().toStdString ();
+    emit changed (true);
   }
 }
 
-void ParameterText::setValue()
-{
+void ParameterText::setValue () {
   lastApplied = lastSent = parameter->value;
-  lineEdit->setText(QString::fromStdString(parameter->value));
+  lineEdit->setText (QString::fromStdString (parameter->value));
 }
diff --git a/src/gui/parameter/ParameterText.h b/src/gui/parameter/ParameterText.h
index 729a04ef0..41e19c5cd 100644
--- a/src/gui/parameter/ParameterText.h
+++ b/src/gui/parameter/ParameterText.h
@@ -12,13 +12,13 @@ class ParameterText : public ParameterVirtualWidget, Ui::ParameterText
   Q_OBJECT
 
 public:
-  ParameterText(QWidget *parent, StringParameter *parameter, DescriptionStyle descriptionStyle);
-  void setValue() override;
-  void valueApplied() override;
+  ParameterText (QWidget *parent, StringParameter *parameter, DescriptionStyle descriptionStyle);
+  void setValue () override;
+  void valueApplied () override;
 
 protected slots:
-  void onEdit(const QString& text);
-  void onEditingFinished();
+  void onEdit (const QString &text);
+  void onEditingFinished ();
 
 private:
   StringParameter *parameter;
diff --git a/src/gui/parameter/ParameterVector.cc b/src/gui/parameter/ParameterVector.cc
index 8e390fbb3..b9ac12b27 100644
--- a/src/gui/parameter/ParameterVector.cc
+++ b/src/gui/parameter/ParameterVector.cc
@@ -7,119 +7,115 @@
 #include <cstddef>
 #include "gui/IgnoreWheelWhenNotFocused.h"
 
-ParameterVector::ParameterVector(QWidget *parent, VectorParameter *parameter, DescriptionStyle descriptionStyle) :
-  ParameterVirtualWidget(parent, parameter),
-  parameter(parameter)
-{
-  setupUi(this);
-  descriptionWidget->setDescription(parameter, descriptionStyle);
+ParameterVector::ParameterVector (QWidget *parent, VectorParameter *parameter, DescriptionStyle descriptionStyle)
+  : ParameterVirtualWidget (parent, parameter)
+  , parameter (parameter) {
+  setupUi (this);
+  descriptionWidget->setDescription (parameter, descriptionStyle);
 
-  assert(parameter->defaultValue.size() >= 1);
-  assert(parameter->defaultValue.size() <= 4);
+  assert (parameter->defaultValue.size () >= 1);
+  assert (parameter->defaultValue.size () <= 4);
 
-  if (parameter->defaultValue.size() >= 1) {
-    spinboxes.push_back(doubleSpinBox1);
+  if (parameter->defaultValue.size () >= 1) {
+    spinboxes.push_back (doubleSpinBox1);
   } else {
-    doubleSpinBox1->hide();
+    doubleSpinBox1->hide ();
   }
-  if (parameter->defaultValue.size() >= 2) {
-    spinboxes.push_back(doubleSpinBox2);
+  if (parameter->defaultValue.size () >= 2) {
+    spinboxes.push_back (doubleSpinBox2);
   } else {
-    doubleSpinBox2->hide();
+    doubleSpinBox2->hide ();
   }
-  if (parameter->defaultValue.size() >= 3) {
-    spinboxes.push_back(doubleSpinBox3);
+  if (parameter->defaultValue.size () >= 3) {
+    spinboxes.push_back (doubleSpinBox3);
   } else {
-    doubleSpinBox3->hide();
+    doubleSpinBox3->hide ();
   }
-  if (parameter->defaultValue.size() >= 4) {
-    spinboxes.push_back(doubleSpinBox4);
+  if (parameter->defaultValue.size () >= 4) {
+    spinboxes.push_back (doubleSpinBox4);
   } else {
-    doubleSpinBox4->hide();
+    doubleSpinBox4->hide ();
   }
 
   // clang generates a bogus warning that ignoreWheelWhenNotFocused may be leaked
   // NOLINTBEGIN(*NewDeleteLeaks)
-  if (spinboxes.size() > 0) { // only allocate if there are spinboxes to use the function
+  if (spinboxes.size () > 0) { // only allocate if there are spinboxes to use the function
     // The parent (this) takes ownership of the object
-    auto *ignoreWheelWhenNotFocused = new IgnoreWheelWhenNotFocused(this);
+    auto *ignoreWheelWhenNotFocused = new IgnoreWheelWhenNotFocused (this);
     for (auto spinbox : spinboxes) {
-      spinbox->installEventFilter(ignoreWheelWhenNotFocused);
+      spinbox->installEventFilter (ignoreWheelWhenNotFocused);
     }
   }
 
-  int decimals = decimalsRequired(parameter->defaultValue);
+  int decimals = decimalsRequired (parameter->defaultValue);
   double minimum;
   // NOLINTEND(*NewDeleteLeaks)
   if (parameter->minimum) {
     minimum = *parameter->minimum;
-    decimals = std::max(decimals, decimalsRequired(minimum));
+    decimals = std::max (decimals, decimalsRequired (minimum));
   } else if (parameter->maximum && *parameter->maximum > 0) {
     minimum = 0;
   } else {
-    minimum = std::numeric_limits<double>::lowest();
+    minimum = std::numeric_limits<double>::lowest ();
   }
   double maximum;
   if (parameter->maximum) {
     maximum = *parameter->maximum;
-    decimals = std::max(decimals, decimalsRequired(maximum));
+    decimals = std::max (decimals, decimalsRequired (maximum));
   } else if (parameter->minimum && *parameter->minimum < 0) {
     maximum = 0;
   } else {
-    maximum = std::numeric_limits<double>::max();
+    maximum = std::numeric_limits<double>::max ();
   }
   double step;
   if (parameter->step) {
     step = *parameter->step;
-    decimals = std::max(decimals, decimalsRequired(step));
+    decimals = std::max (decimals, decimalsRequired (step));
   } else {
-    step = pow(0.1, decimals);
+    step = pow (0.1, decimals);
   }
   for (auto spinbox : spinboxes) {
-    spinbox->setDecimals(decimals);
-    spinbox->setRange(minimum, maximum);
-    spinbox->setSingleStep(step);
-    spinbox->show();
-    connect(spinbox, QOverload<double>::of(&QDoubleSpinBox::valueChanged), this, &ParameterVector::onChanged);
-    connect(spinbox, &QDoubleSpinBox::editingFinished, this, &ParameterVector::onEditingFinished);
+    spinbox->setDecimals (decimals);
+    spinbox->setRange (minimum, maximum);
+    spinbox->setSingleStep (step);
+    spinbox->show ();
+    connect (spinbox, QOverload<double>::of (&QDoubleSpinBox::valueChanged), this, &ParameterVector::onChanged);
+    connect (spinbox, &QDoubleSpinBox::editingFinished, this, &ParameterVector::onEditingFinished);
   }
 
-  ParameterVector::setValue();
+  ParameterVector::setValue ();
 }
 
-void ParameterVector::valueApplied() {
+void ParameterVector::valueApplied () {
   lastApplied = lastSent;
 }
 
-void ParameterVector::onChanged()
-{
-  for (size_t i = 0; i < spinboxes.size(); i++) {
-    parameter->value[i] = spinboxes[i]->value();
+void ParameterVector::onChanged () {
+  for (size_t i = 0; i < spinboxes.size (); i++) {
+    parameter->value[i] = spinboxes[i]->value ();
   }
   if (parameter->value != lastSent) {
     lastSent = parameter->value;
-    emit changed(false);
+    emit changed (false);
   }
 }
 
-void ParameterVector::onEditingFinished()
-{
+void ParameterVector::onEditingFinished () {
   if (lastApplied != parameter->value) {
     lastSent = parameter->value;
-    emit changed(true);
+    emit changed (true);
   }
 }
 
-void ParameterVector::setValue()
-{
+void ParameterVector::setValue () {
 #ifdef DEBUG
-  PRINTD("setValue");
+  PRINTD ("setValue");
 #endif
   lastApplied = lastSent = parameter->value;
-  for (size_t i = 0; i < spinboxes.size(); i++) {
+  for (size_t i = 0; i < spinboxes.size (); i++) {
     // don't emit valueChanged signal for initial setup
-    spinboxes[i]->blockSignals(true);
-    spinboxes[i]->setValue(parameter->value[i]);
-    spinboxes[i]->blockSignals(false);
+    spinboxes[i]->blockSignals (true);
+    spinboxes[i]->setValue (parameter->value[i]);
+    spinboxes[i]->blockSignals (false);
   }
 }
diff --git a/src/gui/parameter/ParameterVector.h b/src/gui/parameter/ParameterVector.h
index b24372aad..bc15d8d82 100644
--- a/src/gui/parameter/ParameterVector.h
+++ b/src/gui/parameter/ParameterVector.h
@@ -12,13 +12,13 @@ class ParameterVector : public ParameterVirtualWidget, Ui::ParameterVector
   Q_OBJECT
 
 public:
-  ParameterVector(QWidget *parent, VectorParameter *parameter, DescriptionStyle descriptionStyle);
-  void setValue() override;
-  void valueApplied() override;
+  ParameterVector (QWidget *parent, VectorParameter *parameter, DescriptionStyle descriptionStyle);
+  void setValue () override;
+  void valueApplied () override;
 
 protected slots:
-  void onChanged();
-  void onEditingFinished();
+  void onChanged ();
+  void onEditingFinished ();
 
 private:
   VectorParameter *parameter;
diff --git a/src/gui/parameter/ParameterVirtualWidget.cc b/src/gui/parameter/ParameterVirtualWidget.cc
index 0f38e6607..d75fc5cd0 100644
--- a/src/gui/parameter/ParameterVirtualWidget.cc
+++ b/src/gui/parameter/ParameterVirtualWidget.cc
@@ -8,68 +8,63 @@
 #include <QRegularExpression>
 #include <vector>
 
-ParameterDescriptionWidget::ParameterDescriptionWidget(QWidget *parent) :
-  QWidget(parent)
-{
-  setupUi(this);
+ParameterDescriptionWidget::ParameterDescriptionWidget (QWidget *parent)
+  : QWidget (parent) {
+  setupUi (this);
 }
 
-void ParameterDescriptionWidget::setDescription(ParameterObject *parameter, DescriptionStyle descriptionStyle)
-{
-  labelParameter->setText(QString::fromStdString(parameter->name()).replace(QRegularExpression("([_]+)"), " "));
-  if (parameter->description().empty()) {
-    labelDescription->hide();
-    labelInline->setText("");
+void ParameterDescriptionWidget::setDescription (ParameterObject *parameter, DescriptionStyle descriptionStyle) {
+  labelParameter->setText (QString::fromStdString (parameter->name ()).replace (QRegularExpression ("([_]+)"), " "));
+  if (parameter->description ().empty ()) {
+    labelDescription->hide ();
+    labelInline->setText ("");
   } else if (descriptionStyle == DescriptionStyle::ShowDetails) {
-    labelDescription->setText(QString::fromStdString(parameter->description()));
-    labelInline->setText("");
+    labelDescription->setText (QString::fromStdString (parameter->description ()));
+    labelInline->setText ("");
   } else if (descriptionStyle == DescriptionStyle::Inline) {
-    labelDescription->hide();
-    labelInline->setText(QString(" - ") + QString::fromStdString(parameter->description()));
+    labelDescription->hide ();
+    labelInline->setText (QString (" - ") + QString::fromStdString (parameter->description ()));
   } else if (descriptionStyle == DescriptionStyle::HideDetails) {
-    labelDescription->hide();
-    labelInline->setText("");
-    this->setToolTip(QString::fromStdString(parameter->description()));
+    labelDescription->hide ();
+    labelInline->setText ("");
+    this->setToolTip (QString::fromStdString (parameter->description ()));
   } else if (descriptionStyle == DescriptionStyle::DescriptionOnly) {
-    labelParameter->hide();
-    labelDescription->setText(QString::fromStdString(parameter->description()));
-    labelInline->hide();
+    labelParameter->hide ();
+    labelDescription->setText (QString::fromStdString (parameter->description ()));
+    labelInline->hide ();
   } else {
-    assert(false);
+    assert (false);
   }
 }
 
-ParameterVirtualWidget::ParameterVirtualWidget(QWidget *parent, ParameterObject *parameter) :
-  QWidget(parent),
-  parameter(parameter)
-{
+ParameterVirtualWidget::ParameterVirtualWidget (QWidget *parent, ParameterObject *parameter)
+  : QWidget (parent)
+  , parameter (parameter) {
   QSizePolicy policy;
-  policy.setHorizontalPolicy(QSizePolicy::Ignored);
-  policy.setVerticalPolicy(QSizePolicy::Maximum);
-  policy.setHorizontalStretch(0);
-  policy.setVerticalStretch(0);
-  this->setSizePolicy(policy);
+  policy.setHorizontalPolicy (QSizePolicy::Ignored);
+  policy.setVerticalPolicy (QSizePolicy::Maximum);
+  policy.setHorizontalStretch (0);
+  policy.setVerticalStretch (0);
+  this->setSizePolicy (policy);
 
-  setContentsMargins(4, 0, 4, 0);
+  setContentsMargins (4, 0, 4, 0);
 }
 
-int ParameterVirtualWidget::decimalsRequired(double value)
-{
+int ParameterVirtualWidget::decimalsRequired (double value) {
   int decimals = 0;
-  value = std::abs(value);
-  while (std::floor(value) < std::ceil(value) && decimals < 7) {
+  value = std::abs (value);
+  while (std::floor (value) < std::ceil (value) && decimals < 7) {
     decimals++;
     value *= 10.0;
   }
   return decimals;
 }
 
-int ParameterVirtualWidget::decimalsRequired(const std::vector<double>& values)
-{
-  assert(!values.empty());
+int ParameterVirtualWidget::decimalsRequired (const std::vector<double> &values) {
+  assert (!values.empty ());
   int decimals = 0;
   for (double value : values) {
-    decimals = std::max(decimals, decimalsRequired(value));
+    decimals = std::max (decimals, decimalsRequired (value));
   }
   return decimals;
 }
diff --git a/src/gui/parameter/ParameterVirtualWidget.h b/src/gui/parameter/ParameterVirtualWidget.h
index b1c9b2457..947b1d3fb 100644
--- a/src/gui/parameter/ParameterVirtualWidget.h
+++ b/src/gui/parameter/ParameterVirtualWidget.h
@@ -8,16 +8,18 @@
 #include "ui_ParameterDescriptionWidget.h"
 #include "core/customizer/ParameterObject.h"
 
-enum class DescriptionStyle { ShowDetails, Inline, HideDetails, DescriptionOnly };
+enum class DescriptionStyle { ShowDetails,
+                              Inline,
+                              HideDetails,
+                              DescriptionOnly };
 
 class ParameterDescriptionWidget : public QWidget, public Ui::ParameterDescriptionWidget
 {
   Q_OBJECT
 
 public:
-
-  ParameterDescriptionWidget(QWidget *parent);
-  void setDescription(ParameterObject *parameter, DescriptionStyle descriptionStyle);
+  ParameterDescriptionWidget (QWidget *parent);
+  void setDescription (ParameterObject *parameter, DescriptionStyle descriptionStyle);
 };
 
 class ParameterVirtualWidget : public QWidget
@@ -25,23 +27,25 @@ class ParameterVirtualWidget : public QWidget
   Q_OBJECT
 
 public:
-  ParameterVirtualWidget(QWidget *parent, ParameterObject *parameter);
-  ParameterObject *getParameter() const { return parameter; }
-  virtual void setValue() = 0;
+  ParameterVirtualWidget (QWidget *parent, ParameterObject *parameter);
+  ParameterObject *getParameter () const {
+    return parameter;
+  }
+  virtual void setValue () = 0;
   // Parent container (ParameterWidget) notifies when preview is updated,
   // so that widgets with immediate AND delayed changes can keep track
   // and avoid emitting excess changed() signals.
-  virtual void valueApplied() { }
+  virtual void valueApplied () {}
   // Widgets which are immediate only (combobox and checkbox) don't need to keep track.
 
 signals:
   // immediate tells customizer auto preview to skip timeout
-  void changed(bool immediate);
+  void changed (bool immediate);
 
 private:
   ParameterObject *parameter;
 
 protected:
-  static int decimalsRequired(double value);
-  static int decimalsRequired(const std::vector<double>& values);
+  static int decimalsRequired (double value);
+  static int decimalsRequired (const std::vector<double> &values);
 };
diff --git a/src/gui/parameter/ParameterWidget.cc b/src/gui/parameter/ParameterWidget.cc
index 65ba4609a..405e43009 100644
--- a/src/gui/parameter/ParameterWidget.cc
+++ b/src/gui/parameter/ParameterWidget.cc
@@ -34,7 +34,6 @@
 #include <memory>
 #include <QWidget>
 
-
 #include "gui/parameter/GroupWidget.h"
 #include "gui/parameter/ParameterSpinBox.h"
 #include "gui/parameter/ParameterComboBox.h"
@@ -53,394 +52,371 @@
 #include <utility>
 #include <vector>
 
-ParameterWidget::ParameterWidget(QWidget *parent) : QWidget(parent)
-{
-  setupUi(this);
-  scrollAreaWidgetContents->layout()->setAlignment(Qt::AlignTop);
+ParameterWidget::ParameterWidget (QWidget *parent)
+  : QWidget (parent) {
+  setupUi (this);
+  scrollAreaWidgetContents->layout ()->setAlignment (Qt::AlignTop);
 
-  autoPreviewTimer.setInterval(1000);
-  autoPreviewTimer.setSingleShot(true);
+  autoPreviewTimer.setInterval (1000);
+  autoPreviewTimer.setSingleShot (true);
 
-  connect(&autoPreviewTimer, &QTimer::timeout, this, &ParameterWidget::emitParametersChanged);
-  connect(checkBoxAutoPreview, &QCheckBox::toggled, [this]() {
-    this->autoPreview(true);
+  connect (&autoPreviewTimer, &QTimer::timeout, this, &ParameterWidget::emitParametersChanged);
+  connect (checkBoxAutoPreview, &QCheckBox::toggled, [this] () {
+    this->autoPreview (true);
   });
-  connect(comboBoxDetails, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &ParameterWidget::rebuildWidgets);
-  connect(comboBoxPreset, QOverload<int>::of(&QComboBox::activated), this, &ParameterWidget::onSetChanged);
+  connect (comboBoxDetails, QOverload<int>::of (&QComboBox::currentIndexChanged), this, &ParameterWidget::rebuildWidgets);
+  connect (comboBoxPreset, QOverload<int>::of (&QComboBox::activated), this, &ParameterWidget::onSetChanged);
   //connect(comboBoxPreset, &QComboBox::editTextChanged, this, &ParameterWidget::onSetNameChanged);
-  connect(addButton, &QPushButton::clicked, this, &ParameterWidget::onSetAdd);
-  connect(deleteButton, &QPushButton::clicked, this, &ParameterWidget::onSetDelete);
+  connect (addButton, &QPushButton::clicked, this, &ParameterWidget::onSetAdd);
+  connect (deleteButton, &QPushButton::clicked, this, &ParameterWidget::onSetDelete);
 
-  QString fontfamily = GlobalPreferences::inst()->getValue("advanced/customizerFontFamily").toString();
-  uint fontsize = GlobalPreferences::inst()->getValue("advanced/customizerFontSize").toUInt();
-  setFontFamilySize(fontfamily, fontsize);
+  QString fontfamily = GlobalPreferences::inst ()->getValue ("advanced/customizerFontFamily").toString ();
+  uint fontsize = GlobalPreferences::inst ()->getValue ("advanced/customizerFontSize").toUInt ();
+  setFontFamilySize (fontfamily, fontsize);
 
-  connect(GlobalPreferences::inst(), &Preferences::customizerFontChanged, this, &ParameterWidget::setFontFamilySize);
+  connect (GlobalPreferences::inst (), &Preferences::customizerFontChanged, this, &ParameterWidget::setFontFamilySize);
 }
 
 // Can only be called before the initial setParameters().
-void ParameterWidget::readFile(const QString& scadFile)
-{
-  assert(sets.empty());
-  assert(parameters.empty());
-  assert(widgets.empty());
-
-  QString jsonFile = getJsonFile(scadFile);
-  if (!std::filesystem::exists(jsonFile.toStdString()) || this->sets.readFile(jsonFile.toStdString())) {
-    this->invalidJsonFile = QString();
+void ParameterWidget::readFile (const QString &scadFile) {
+  assert (sets.empty ());
+  assert (parameters.empty ());
+  assert (widgets.empty ());
+
+  QString jsonFile = getJsonFile (scadFile);
+  if (!std::filesystem::exists (jsonFile.toStdString ()) || this->sets.readFile (jsonFile.toStdString ())) {
+    this->invalidJsonFile = QString ();
   } else {
     this->invalidJsonFile = jsonFile;
   }
 
-  for (const auto& set : this->sets) {
-    comboBoxPreset->addItem(QString::fromStdString(set.name()));
+  for (const auto &set : this->sets) {
+    comboBoxPreset->addItem (QString::fromStdString (set.name ()));
   }
 }
 
 // Write the json file if the parameter sets are not empty.
 // This prevents creating unnecessary json files.
-void ParameterWidget::saveFile(const QString& scadFile)
-{
-  if (sets.empty()) {
+void ParameterWidget::saveFile (const QString &scadFile) {
+  if (sets.empty ()) {
     return;
   }
 
-  QString jsonFile = getJsonFile(scadFile);
+  QString jsonFile = getJsonFile (scadFile);
   if (jsonFile == this->invalidJsonFile) {
     QMessageBox msgBox;
-    msgBox.setWindowTitle(_("Saving presets"));
-    msgBox.setText(QString(_("%1 was found, but was unreadable. Do you want to overwrite %1?")).arg(this->invalidJsonFile));
-    msgBox.setStandardButtons(QMessageBox::Save | QMessageBox::Cancel);
-    msgBox.setDefaultButton(QMessageBox::Cancel);
-    if (msgBox.exec() == QMessageBox::Cancel) {
+    msgBox.setWindowTitle (_ ("Saving presets"));
+    msgBox.setText (QString (_ ("%1 was found, but was unreadable. Do you want to overwrite %1?")).arg (this->invalidJsonFile));
+    msgBox.setStandardButtons (QMessageBox::Save | QMessageBox::Cancel);
+    msgBox.setDefaultButton (QMessageBox::Cancel);
+    if (msgBox.exec () == QMessageBox::Cancel) {
       return;
     }
   }
 
-  cleanSets();
-  sets.writeFile(jsonFile.toStdString());
+  cleanSets ();
+  sets.writeFile (jsonFile.toStdString ());
 }
 
-void ParameterWidget::saveBackupFile(const QString& scadFile)
-{
-  if (sets.empty()) {
+void ParameterWidget::saveBackupFile (const QString &scadFile) {
+  if (sets.empty ()) {
     return;
   }
 
-  sets.writeFile(getJsonFile(scadFile).toStdString());
+  sets.writeFile (getJsonFile (scadFile).toStdString ());
 }
 
-void ParameterWidget::setParameters(const SourceFile *sourceFile, const std::string& source)
-{
+void ParameterWidget::setParameters (const SourceFile *sourceFile, const std::string &source) {
   if (this->source == source) {
     return;
   }
   this->source = source;
 
-  this->parameters = ParameterObjects::fromSourceFile(sourceFile);
-  rebuildWidgets();
-  loadSet(comboBoxPreset->currentIndex());
+  this->parameters = ParameterObjects::fromSourceFile (sourceFile);
+  rebuildWidgets ();
+  loadSet (comboBoxPreset->currentIndex ());
 }
 
-void ParameterWidget::applyParameters(SourceFile *sourceFile)
-{
-  this->parameters.apply(sourceFile);
+void ParameterWidget::applyParameters (SourceFile *sourceFile) {
+  this->parameters.apply (sourceFile);
 }
 
-bool ParameterWidget::childHasFocus()
-{
-  if (this->hasFocus()) {
+bool ParameterWidget::childHasFocus () {
+  if (this->hasFocus ()) {
     return true;
   }
-  auto children = this->findChildren<QWidget *>();
+  auto children = this->findChildren<QWidget *> ();
   for (auto child : children) {
-    if (child->hasFocus()) {
+    if (child->hasFocus ()) {
       return true;
     }
   }
   return false;
 }
 
-void ParameterWidget::setModified(bool modified)
-{
+void ParameterWidget::setModified (bool modified) {
   if (this->modified != modified) {
     this->modified = modified;
-    emit modificationChanged();
+    emit modificationChanged ();
   }
 }
 
-void ParameterWidget::emitParametersChanged() {
-  for (const auto& kvp : widgets) {
+void ParameterWidget::emitParametersChanged () {
+  for (const auto &kvp : widgets) {
     for (ParameterVirtualWidget *widget : kvp.second) {
-      widget->valueApplied();
+      widget->valueApplied ();
     }
   }
-  emit parametersChanged();
+  emit parametersChanged ();
 }
 
-void ParameterWidget::autoPreview(bool immediate)
-{
-  autoPreviewTimer.stop();
-  if (checkBoxAutoPreview->isChecked()) {
+void ParameterWidget::autoPreview (bool immediate) {
+  autoPreviewTimer.stop ();
+  if (checkBoxAutoPreview->isChecked ()) {
     if (immediate) {
-      emitParametersChanged();
+      emitParametersChanged ();
     } else {
-      autoPreviewTimer.start();
+      autoPreviewTimer.start ();
     }
   }
 }
 
-void ParameterWidget::onSetChanged(int index)
-{
-  loadSet(index);
-  autoPreview(true);
+void ParameterWidget::onSetChanged (int index) {
+  loadSet (index);
+  autoPreview (true);
 }
 
-void ParameterWidget::onSetNameChanged()
-{
-  assert(static_cast<size_t>(comboBoxPreset->count()) == sets.size() + 1);
-  comboBoxPreset->setItemText(comboBoxPreset->currentIndex(), comboBoxPreset->lineEdit()->text());
-  sets[comboBoxPreset->currentIndex() - 1].setName(comboBoxPreset->currentText().toStdString());
-  setModified();
+void ParameterWidget::onSetNameChanged () {
+  assert (static_cast<size_t> (comboBoxPreset->count ()) == sets.size () + 1);
+  comboBoxPreset->setItemText (comboBoxPreset->currentIndex (), comboBoxPreset->lineEdit ()->text ());
+  sets[comboBoxPreset->currentIndex () - 1].setName (comboBoxPreset->currentText ().toStdString ());
+  setModified ();
 }
 
-void ParameterWidget::onSetAdd()
-{
+void ParameterWidget::onSetAdd () {
   bool ok = true;
-  QString result = QInputDialog::getText(
+  QString result = QInputDialog::getText (
     this,
-    _("Create new set of parameter"),
-    _("Enter name of the parameter set"),
+    _ ("Create new set of parameter"),
+    _ ("Enter name of the parameter set"),
     QLineEdit::Normal,
     "",
-    &ok
-    );
+    &ok);
 
   if (ok) {
-    createSet(result.trimmed());
+    createSet (result.trimmed ());
   }
-  setModified();
+  setModified ();
 }
 
-void ParameterWidget::onSetDelete()
-{
-  int index = comboBoxPreset->currentIndex();
-  assert(index > 0);
+void ParameterWidget::onSetDelete () {
+  int index = comboBoxPreset->currentIndex ();
+  assert (index > 0);
   int newIndex;
-  if (index + 1 == comboBoxPreset->count()) {
+  if (index + 1 == comboBoxPreset->count ()) {
     newIndex = index - 1;
   } else {
     newIndex = index + 1;
   }
-  comboBoxPreset->setCurrentIndex(newIndex);
-  loadSet(newIndex);
+  comboBoxPreset->setCurrentIndex (newIndex);
+  loadSet (newIndex);
 
-  comboBoxPreset->removeItem(index);
-  sets.erase(sets.begin() + (index - 1));
-  setModified();
-  autoPreview(true);
+  comboBoxPreset->removeItem (index);
+  sets.erase (sets.begin () + (index - 1));
+  setModified ();
+  autoPreview (true);
 }
 
-void ParameterWidget::parameterModified(bool immediate)
-{
-  auto *widget = (ParameterVirtualWidget *)sender();
-  ParameterObject *parameter = widget->getParameter();
+void ParameterWidget::parameterModified (bool immediate) {
+  auto *widget = (ParameterVirtualWidget *)sender ();
+  ParameterObject *parameter = widget->getParameter ();
 
   // When attempting to modify the design default, create a new set to edit.
-  if (comboBoxPreset->currentIndex() == 0) {
+  if (comboBoxPreset->currentIndex () == 0) {
     std::set<std::string> setNames;
-    for (const auto& set : this->sets) {
-      setNames.insert(set.name());
+    for (const auto &set : this->sets) {
+      setNames.insert (set.name ());
     }
 
     QString name;
-    for (int i = 1; ; i++) {
-      name = _("New set ") + QString::number(i);
-      if (setNames.count(name.toStdString()) == 0) {
+    for (int i = 1;; i++) {
+      name = _ ("New set ") + QString::number (i);
+      if (setNames.count (name.toStdString ()) == 0) {
         break;
       }
     }
-    createSet(name);
+    createSet (name);
   }
 
-  size_t setIndex = comboBoxPreset->currentIndex() - 1;
-  assert(setIndex < sets.size());
-  sets[setIndex][parameter->name()] = parameter->exportValue();
+  size_t setIndex = comboBoxPreset->currentIndex () - 1;
+  assert (setIndex < sets.size ());
+  sets[setIndex][parameter->name ()] = parameter->exportValue ();
 
-  assert(widgets.count(parameter) == 1);
+  assert (widgets.count (parameter) == 1);
   for (ParameterVirtualWidget *otherWidget : widgets[parameter]) {
     if (otherWidget != widget) {
-      otherWidget->setValue();
+      otherWidget->setValue ();
     }
   }
 
-  setModified();
-  autoPreview(immediate);
+  setModified ();
+  autoPreview (immediate);
 }
 
-void ParameterWidget::loadSet(size_t index)
-{
-  assert(index <= sets.size());
+void ParameterWidget::loadSet (size_t index) {
+  assert (index <= sets.size ());
   if (index == 0) {
-    parameters.reset();
+    parameters.reset ();
   } else {
-    parameters.importValues(sets[index - 1]);
+    parameters.importValues (sets[index - 1]);
   }
 
-  updateSetEditability();
+  updateSetEditability ();
 
-  for (const auto& pair : widgets) {
+  for (const auto &pair : widgets) {
     for (ParameterVirtualWidget *widget : pair.second) {
-      widget->setValue();
+      widget->setValue ();
     }
   }
 }
 
-void ParameterWidget::createSet(const QString& name)
-{
-  sets.push_back(parameters.exportValues(name.toStdString()));
-  comboBoxPreset->addItem(name);
-  comboBoxPreset->setCurrentIndex(comboBoxPreset->count() - 1);
-  updateSetEditability();
+void ParameterWidget::createSet (const QString &name) {
+  sets.push_back (parameters.exportValues (name.toStdString ()));
+  comboBoxPreset->addItem (name);
+  comboBoxPreset->setCurrentIndex (comboBoxPreset->count () - 1);
+  updateSetEditability ();
 }
 
-void ParameterWidget::updateSetEditability()
-{
-  if (comboBoxPreset->currentIndex() == 0) {
-    comboBoxPreset->setEditable(false);
-    deleteButton->setEnabled(false);
+void ParameterWidget::updateSetEditability () {
+  if (comboBoxPreset->currentIndex () == 0) {
+    comboBoxPreset->setEditable (false);
+    deleteButton->setEnabled (false);
   } else {
-    if (!comboBoxPreset->isEditable()) {
-      comboBoxPreset->setEditable(true);
-      connect(comboBoxPreset->lineEdit(), &QLineEdit::textEdited, this, &ParameterWidget::onSetNameChanged);
+    if (!comboBoxPreset->isEditable ()) {
+      comboBoxPreset->setEditable (true);
+      connect (comboBoxPreset->lineEdit (), &QLineEdit::textEdited, this, &ParameterWidget::onSetNameChanged);
     }
-    deleteButton->setEnabled(true);
+    deleteButton->setEnabled (true);
   }
 }
 
-void ParameterWidget::rebuildWidgets()
-{
+void ParameterWidget::rebuildWidgets () {
   std::map<QString, bool> expandedGroups;
-  for (GroupWidget *groupWidget : this->findChildren<GroupWidget *>()) {
-    expandedGroups.emplace(groupWidget->title(), groupWidget->isExpanded());
+  for (GroupWidget *groupWidget : this->findChildren<GroupWidget *> ()) {
+    expandedGroups.emplace (groupWidget->title (), groupWidget->isExpanded ());
   }
 
-  widgets.clear();
-  QLayout *layout = this->scrollAreaWidgetContents->layout();
-  while (layout->count() > 0) {
-    QLayoutItem *child = layout->takeAt(0);
-    delete child->widget();
+  widgets.clear ();
+  QLayout *layout = this->scrollAreaWidgetContents->layout ();
+  while (layout->count () > 0) {
+    QLayoutItem *child = layout->takeAt (0);
+    delete child->widget ();
     delete child;
   }
 
-  auto descriptionStyle = static_cast<DescriptionStyle>(comboBoxDetails->currentIndex());
-  std::vector<ParameterGroup> parameterGroups = getParameterGroups();
-  for (const auto& group : parameterGroups) {
-    auto *groupWidget = new GroupWidget(group.name);
+  auto descriptionStyle = static_cast<DescriptionStyle> (comboBoxDetails->currentIndex ());
+  std::vector<ParameterGroup> parameterGroups = getParameterGroups ();
+  for (const auto &group : parameterGroups) {
+    auto *groupWidget = new GroupWidget (group.name);
     for (ParameterObject *parameter : group.parameters) {
-      ParameterVirtualWidget *parameterWidget = createParameterWidget(parameter, descriptionStyle);
-      connect(parameterWidget, &ParameterVirtualWidget::changed, this, &ParameterWidget::parameterModified);
-      if (!widgets.count(parameter)) {
+      ParameterVirtualWidget *parameterWidget = createParameterWidget (parameter, descriptionStyle);
+      connect (parameterWidget, &ParameterVirtualWidget::changed, this, &ParameterWidget::parameterModified);
+      if (!widgets.count (parameter)) {
         widgets[parameter] = {};
       }
-      widgets[parameter].push_back(parameterWidget);
-      groupWidget->addWidget(parameterWidget);
+      widgets[parameter].push_back (parameterWidget);
+      groupWidget->addWidget (parameterWidget);
     }
-    auto it = expandedGroups.find(group.name);
-    groupWidget->setExpanded(it == expandedGroups.end() || it->second);
-    layout->addWidget(groupWidget);
+    auto it = expandedGroups.find (group.name);
+    groupWidget->setExpanded (it == expandedGroups.end () || it->second);
+    layout->addWidget (groupWidget);
   }
 }
 
-std::vector<ParameterWidget::ParameterGroup> ParameterWidget::getParameterGroups()
-{
+std::vector<ParameterWidget::ParameterGroup> ParameterWidget::getParameterGroups () {
   std::vector<ParameterWidget::ParameterGroup> output;
   std::map<std::string, size_t> groupIndices;
   std::vector<ParameterObject *> globalParameters;
 
-  for (const std::unique_ptr<ParameterObject>& parameter : parameters) {
-    std::string group = parameter->group();
+  for (const std::unique_ptr<ParameterObject> &parameter : parameters) {
+    std::string group = parameter->group ();
     if (group == "Global") {
-      globalParameters.push_back(parameter.get());
+      globalParameters.push_back (parameter.get ());
     } else if (group == "Hidden") {
       continue;
     } else {
-      if (!groupIndices.count(group)) {
-        groupIndices[group] = output.size();
-        output.push_back({QString::fromStdString(group)});
+      if (!groupIndices.count (group)) {
+        groupIndices[group] = output.size ();
+        output.push_back ({QString::fromStdString (group)});
       }
-      output[groupIndices[group]].parameters.push_back(parameter.get());
+      output[groupIndices[group]].parameters.push_back (parameter.get ());
     }
   }
 
-  if (output.size() == 0 && globalParameters.size() > 0) {
+  if (output.size () == 0 && globalParameters.size () > 0) {
     ParameterGroup global;
     global.name = "Global";
-    global.parameters = std::move(globalParameters);
-    output.push_back(std::move(global));
+    global.parameters = std::move (globalParameters);
+    output.push_back (std::move (global));
   } else {
-    for (auto& group : output) {
-      group.parameters.insert(group.parameters.end(), globalParameters.begin(), globalParameters.end());
+    for (auto &group : output) {
+      group.parameters.insert (group.parameters.end (), globalParameters.begin (), globalParameters.end ());
     }
   }
 
   return output;
 }
 
-ParameterVirtualWidget *ParameterWidget::createParameterWidget(ParameterObject *parameter, DescriptionStyle descriptionStyle)
-{
-  if (parameter->type() == ParameterObject::ParameterType::Bool) {
-    return new ParameterCheckBox(this, static_cast<BoolParameter *>(parameter), descriptionStyle);
-  } else if (parameter->type() == ParameterObject::ParameterType::String) {
-    return new ParameterText(this, static_cast<StringParameter *>(parameter), descriptionStyle);
-  } else if (parameter->type() == ParameterObject::ParameterType::Number) {
-    auto *numberParameter = static_cast<NumberParameter *>(parameter);
+ParameterVirtualWidget *ParameterWidget::createParameterWidget (ParameterObject *parameter, DescriptionStyle descriptionStyle) {
+  if (parameter->type () == ParameterObject::ParameterType::Bool) {
+    return new ParameterCheckBox (this, static_cast<BoolParameter *> (parameter), descriptionStyle);
+  } else if (parameter->type () == ParameterObject::ParameterType::String) {
+    return new ParameterText (this, static_cast<StringParameter *> (parameter), descriptionStyle);
+  } else if (parameter->type () == ParameterObject::ParameterType::Number) {
+    auto *numberParameter = static_cast<NumberParameter *> (parameter);
     if (numberParameter->minimum && numberParameter->maximum) {
-      return new ParameterSlider(this, numberParameter, descriptionStyle);
+      return new ParameterSlider (this, numberParameter, descriptionStyle);
     } else {
-      return new ParameterSpinBox(this, numberParameter, descriptionStyle);
+      return new ParameterSpinBox (this, numberParameter, descriptionStyle);
     }
-  } else if (parameter->type() == ParameterObject::ParameterType::Vector) {
-    return new ParameterVector(this, static_cast<VectorParameter *>(parameter), descriptionStyle);
-  } else if (parameter->type() == ParameterObject::ParameterType::Enum) {
-    return new ParameterComboBox(this, static_cast<EnumParameter *>(parameter), descriptionStyle);
+  } else if (parameter->type () == ParameterObject::ParameterType::Vector) {
+    return new ParameterVector (this, static_cast<VectorParameter *> (parameter), descriptionStyle);
+  } else if (parameter->type () == ParameterObject::ParameterType::Enum) {
+    return new ParameterComboBox (this, static_cast<EnumParameter *> (parameter), descriptionStyle);
   } else {
-    assert(false);
-    throw std::runtime_error("Unsupported parameter widget type");
+    assert (false);
+    throw std::runtime_error ("Unsupported parameter widget type");
   }
 }
 
-QString ParameterWidget::getJsonFile(const QString& scadFile)
-{
-  std::filesystem::path p = scadFile.toStdString();
-  return QString::fromStdString(p.replace_extension(".json").string());
+QString ParameterWidget::getJsonFile (const QString &scadFile) {
+  std::filesystem::path p = scadFile.toStdString ();
+  return QString::fromStdString (p.replace_extension (".json").string ());
 }
 
 // Remove set values that do not correspond to a parameter,
 // or that cannot be parsed as such.
-void ParameterWidget::cleanSets()
-{
+void ParameterWidget::cleanSets () {
   std::map<std::string, ParameterObject *> namedParameters;
-  for (const auto& parameter : parameters) {
-    namedParameters[parameter->name()] = parameter.get();
+  for (const auto &parameter : parameters) {
+    namedParameters[parameter->name ()] = parameter.get ();
   }
 
-  for (ParameterSet& set : sets) {
-    for (auto it = set.begin(); it != set.end();) {
-      if (!namedParameters.count(it->first)) {
-        it = set.erase(it);
+  for (ParameterSet &set : sets) {
+    for (auto it = set.begin (); it != set.end ();) {
+      if (!namedParameters.count (it->first)) {
+        it = set.erase (it);
       } else {
-        if (namedParameters[it->first]->importValue(it->second, false)) {
+        if (namedParameters[it->first]->importValue (it->second, false)) {
           ++it;
         } else {
-          it = set.erase(it);
+          it = set.erase (it);
         }
       }
     }
   }
 }
 
-void ParameterWidget::setFontFamilySize(const QString& fontFamily, uint fontSize)
-{
-  scrollArea->setStyleSheet(QString("font-family: \"%1\"; font-size: %2pt;").arg(fontFamily).arg(fontSize));
+void ParameterWidget::setFontFamilySize (const QString &fontFamily, uint fontSize) {
+  scrollArea->setStyleSheet (QString ("font-family: \"%1\"; font-size: %2pt;").arg (fontFamily).arg (fontSize));
 }
diff --git a/src/gui/parameter/ParameterWidget.h b/src/gui/parameter/ParameterWidget.h
index 7e12786da..fe0451676 100644
--- a/src/gui/parameter/ParameterWidget.h
+++ b/src/gui/parameter/ParameterWidget.h
@@ -53,48 +53,49 @@ private:
   bool modified = false;
 
 public:
-  ParameterWidget(QWidget *parent = nullptr);
-  void readFile(const QString& scadFile);
-  void saveFile(const QString& scadFile);
-  void saveBackupFile(const QString& scadFile);
-  void setParameters(const SourceFile *sourceFile, const std::string& source);
-  void applyParameters(SourceFile *sourceFile);
-  bool childHasFocus();
-  bool isModified() const { return modified; }
+  ParameterWidget (QWidget *parent = nullptr);
+  void readFile (const QString &scadFile);
+  void saveFile (const QString &scadFile);
+  void saveBackupFile (const QString &scadFile);
+  void setParameters (const SourceFile *sourceFile, const std::string &source);
+  void applyParameters (SourceFile *sourceFile);
+  bool childHasFocus ();
+  bool isModified () const {
+    return modified;
+  }
 
 public slots:
-  void setModified(bool modified = true);
-  void setFontFamilySize(const QString& fontfamily, uint fontsize);
+  void setModified (bool modified = true);
+  void setFontFamilySize (const QString &fontfamily, uint fontsize);
 
 protected slots:
-  void autoPreview(bool immediate = false);
-  void emitParametersChanged();
-  void onSetChanged(int index);
-  void onSetNameChanged();
-  void onSetAdd();
-  void onSetDelete();
-  void parameterModified(bool immediate);
-  void loadSet(size_t index);
-  void createSet(const QString& name);
-  void updateSetEditability();
-  void rebuildWidgets();
+  void autoPreview (bool immediate = false);
+  void emitParametersChanged ();
+  void onSetChanged (int index);
+  void onSetNameChanged ();
+  void onSetAdd ();
+  void onSetDelete ();
+  void parameterModified (bool immediate);
+  void loadSet (size_t index);
+  void createSet (const QString &name);
+  void updateSetEditability ();
+  void rebuildWidgets ();
 
 signals:
   // emitted when the effective values of the parameters have changed,
   // and the model view can be updated
-  void parametersChanged();
+  void parametersChanged ();
   // emitted when the sets that would be saved to the json file have changed,
   // and the parameter sets should be saved before closing
-  void modificationChanged();
+  void modificationChanged ();
 
 protected:
-  struct ParameterGroup
-  {
+  struct ParameterGroup {
     QString name;
     std::vector<ParameterObject *> parameters;
   };
-  std::vector<ParameterGroup> getParameterGroups();
-  ParameterVirtualWidget *createParameterWidget(ParameterObject *parameter, DescriptionStyle descriptionStyle);
-  QString getJsonFile(const QString& scadFile);
-  void cleanSets();
+  std::vector<ParameterGroup> getParameterGroups ();
+  ParameterVirtualWidget *createParameterWidget (ParameterObject *parameter, DescriptionStyle descriptionStyle);
+  QString getJsonFile (const QString &scadFile);
+  void cleanSets ();
 };
diff --git a/src/gui/qt-obsolete.h b/src/gui/qt-obsolete.h
index ccda5d70c..0e3209192 100644
--- a/src/gui/qt-obsolete.h
+++ b/src/gui/qt-obsolete.h
@@ -1,17 +1,18 @@
 #pragma once
 
 #if (QT_VERSION < QT_VERSION_CHECK(5, 14, 0))
-#define Q_WHEEL_EVENT_POSITION(e) ((e)->pos())
+#define Q_WHEEL_EVENT_POSITION(e) ((e)->pos ())
 #else
-#define Q_WHEEL_EVENT_POSITION(e) ((e)->position())
+#define Q_WHEEL_EVENT_POSITION(e) ((e)->position ())
 #endif
 
 #if (QT_VERSION < QT_VERSION_CHECK(5, 15, 0))
 namespace std {
-template <> struct hash<QString> {
-  std::size_t operator()(const QString& s) const noexcept {
-    return (size_t) qHash(s);
+template <>
+struct hash<QString> {
+  std::size_t operator() (const QString &s) const noexcept {
+    return (size_t)qHash (s);
   }
 };
-}
+} // namespace std
 #endif
diff --git a/src/gui/qtgettext.h b/src/gui/qtgettext.h
index 6671ac674..751c49537 100644
--- a/src/gui/qtgettext.h
+++ b/src/gui/qtgettext.h
@@ -13,10 +13,6 @@
 #include <QString>
 #include "utils/printutils.h"
 
-inline QString q_(const char *msgid, const char *msgctxt)
-{
-  return QString::fromUtf8(msgctxt ?
-                           _(msgid, msgctxt):
-                           _(msgid)
-                           );
+inline QString q_ (const char *msgid, const char *msgctxt) {
+  return QString::fromUtf8 (msgctxt ? _ (msgid, msgctxt) : _ (msgid));
 }
diff --git a/src/guitests/TestMainWindow.cc b/src/guitests/TestMainWindow.cc
index 1dd34d187..6b805be27 100644
--- a/src/guitests/TestMainWindow.cc
+++ b/src/guitests/TestMainWindow.cc
@@ -3,38 +3,36 @@
 #include "TestMainWindow.h"
 #include "platform/PlatformUtils.h"
 
-void TestMainWindow::checkOpenTabPropagateToWindow()
-{
-  restoreWindowInitialState();
+void TestMainWindow::checkOpenTabPropagateToWindow () {
+  restoreWindowInitialState ();
 
-  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) + "/tests/basic-ux/empty.scad";
+  QString filename = QString::fromStdString (PlatformUtils::resourceBasePath ()) + "/tests/basic-ux/empty.scad";
 
   // When we open a new file,
-  window->tabManager->open(filename);
+  window->tabManager->open (filename);
 
   // The window title must also have the name of open file
-  QCOMPARE(window->windowTitle(), QFileInfo(filename).fileName());
+  QCOMPARE (window->windowTitle (), QFileInfo (filename).fileName ());
 
-  filename = QString::fromStdString(PlatformUtils::resourceBasePath()) + "/tests/basic-ux/empty2.scad";
+  filename = QString::fromStdString (PlatformUtils::resourceBasePath ()) + "/tests/basic-ux/empty2.scad";
 
   // When we open a new file,
-  window->tabManager->open(filename);
+  window->tabManager->open (filename);
 
   // The window title must also have the name of open file
-  QCOMPARE(window->windowTitle(), QFileInfo(filename).fileName());
+  QCOMPARE (window->windowTitle (), QFileInfo (filename).fileName ());
 }
 
-void TestMainWindow::checkSaveToShouldUpdateWindowTitle()
-{
-  restoreWindowInitialState();
+void TestMainWindow::checkSaveToShouldUpdateWindowTitle () {
+  restoreWindowInitialState ();
 
-  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) + "/tests/basic-ux/empty.scad";
+  QString filename = QString::fromStdString (PlatformUtils::resourceBasePath ()) + "/tests/basic-ux/empty.scad";
 
   // When we open a new file,
-  window->tabManager->open(filename);
+  window->tabManager->open (filename);
 
-  window->tabManager->saveAs(window->activeEditor, "test-tmp.scad");
+  window->tabManager->saveAs (window->activeEditor, "test-tmp.scad");
 
   // The window title must also have the name of open file
-  QCOMPARE(window->windowTitle(), "test-tmp.scad");
+  QCOMPARE (window->windowTitle (), "test-tmp.scad");
 }
diff --git a/src/guitests/TestMainWindow.h b/src/guitests/TestMainWindow.h
index fb4cc7265..877bfd0d1 100644
--- a/src/guitests/TestMainWindow.h
+++ b/src/guitests/TestMainWindow.h
@@ -6,6 +6,6 @@ class TestMainWindow : public UXTest
 {
   Q_OBJECT;
 private slots:
-  void checkOpenTabPropagateToWindow();
-  void checkSaveToShouldUpdateWindowTitle();
+  void checkOpenTabPropagateToWindow ();
+  void checkSaveToShouldUpdateWindowTitle ();
 };
diff --git a/src/guitests/TestModuleCache.cc b/src/guitests/TestModuleCache.cc
index 1b307acd0..f6aa9f1bb 100644
--- a/src/guitests/TestModuleCache.cc
+++ b/src/guitests/TestModuleCache.cc
@@ -3,65 +3,61 @@
 #include "TestModuleCache.h"
 #include "platform/PlatformUtils.h"
 
-void touchFile(const QString& filename)
-{
-  auto timeStamp = QDateTime::currentDateTime();
-
-  QFileInfo fileInfo(filename);
-  QFile file(filename);
-  file.open(QIODevice::WriteOnly);
-  if (file.isOpen()){
-    file.setFileTime(timeStamp, QFileDevice::FileModificationTime);
-    file.setFileTime(timeStamp, QFileDevice::FileAccessTime);
+void touchFile (const QString &filename) {
+  auto timeStamp = QDateTime::currentDateTime ();
+
+  QFileInfo fileInfo (filename);
+  QFile file (filename);
+  file.open (QIODevice::WriteOnly);
+  if (file.isOpen ()) {
+    file.setFileTime (timeStamp, QFileDevice::FileModificationTime);
+    file.setFileTime (timeStamp, QFileDevice::FileAccessTime);
   }
 }
 
-void TestModuleCache::testBasicCache()
-{
-  restoreWindowInitialState();
+void TestModuleCache::testBasicCache () {
+  restoreWindowInitialState ();
 
-  QString filename = QString::fromStdString("test-tmp.scad");
+  QString filename = QString::fromStdString ("test-tmp.scad");
   SourceFile *previousFile{nullptr};
   SourceFile *currentFile{nullptr};
-  connect(window, &MainWindow::compilationDone, [&currentFile](SourceFile *file){
+  connect (window, &MainWindow::compilationDone, [&currentFile] (SourceFile *file) {
     currentFile = file;
   });
 
-  window->designActionAutoReload->setChecked(false);   // Disable auto-reload  & preview
-  window->tabManager->open(filename);                  // Open use.scad
-  window->actionReloadRenderPreview();                 // F5
+  window->designActionAutoReload->setChecked (false); // Disable auto-reload  & preview
+  window->tabManager->open (filename); // Open use.scad
+  window->actionReloadRenderPreview (); // F5
 
-  QVERIFY2(currentFile != nullptr, "The file 'test-tmp.scad' should be loaded.");
-  previousFile = currentFile;                          // save the loaded Source from the
+  QVERIFY2 (currentFile != nullptr, "The file 'test-tmp.scad' should be loaded.");
+  previousFile = currentFile; // save the loaded Source from the
 
-  window->actionReloadRenderPreview();
-  QVERIFY2(previousFile == currentFile, "The file should be the same as the file cache should have done its work.");
-  sleep(1);
+  window->actionReloadRenderPreview ();
+  QVERIFY2 (previousFile == currentFile, "The file should be the same as the file cache should have done its work.");
+  sleep (1);
 
-  touchFile(filename);
-  window->actionReloadRenderPreview();
-  QVERIFY2(previousFile != currentFile, "The file should *not* be the same as the file cache should have detected the timestamp change.");
+  touchFile (filename);
+  window->actionReloadRenderPreview ();
+  QVERIFY2 (previousFile != currentFile, "The file should *not* be the same as the file cache should have detected the timestamp change.");
 }
 
-std::vector<std::string>& findNode(std::shared_ptr<AbstractNode> node, std::vector<std::string>& path)
-{
-  path.push_back(node->verbose_name());
-  for (auto child : node->getChildren())
-    return findNode(child, path);
+std::vector<std::string> &findNode (std::shared_ptr<AbstractNode> node, std::vector<std::string> &path) {
+  path.push_back (node->verbose_name ());
+  for (auto child : node->getChildren ())
+    return findNode (child, path);
   return path;
 }
 
-void TestModuleCache::testMCAD()
-{
-  restoreWindowInitialState();
+void TestModuleCache::testMCAD () {
+  restoreWindowInitialState ();
 
-  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) + "/tests/modulecache-tests/use-mcad.scad";
-  window->tabManager->open(filename);             // Open use-mcad.scad
-  window->actionReloadRenderPreview();            // F5
+  QString filename = QString::fromStdString (PlatformUtils::resourceBasePath ()) + "/tests/modulecache-tests/use-mcad.scad";
+  window->tabManager->open (filename); // Open use-mcad.scad
+  window->actionReloadRenderPreview (); // F5
 
-  auto node = window->instantiateRootFromSource(window->rootFile);
-  QVERIFY2(node->verbose_name().empty(), "Root node name must be empty");
-  QVERIFY2(node->getChildren().size() != 0, "There must have at least a node");
-  QCOMPARE(QString::fromStdString(node->getChildren()[0]->verbose_name()),
-           QString::fromStdString("module roundedBox"));
+  auto node = window->instantiateRootFromSource (window->rootFile);
+  QVERIFY2 (node->verbose_name ().empty (), "Root node name must be empty");
+  QVERIFY2 (node->getChildren ().size () != 0, "There must have at least a node");
+  QCOMPARE (QString::fromStdString (node->getChildren ()[0]->verbose_name ()),
+            QString::fromStdString ("module roundedBox"));
 }
diff --git a/src/guitests/TestModuleCache.h b/src/guitests/TestModuleCache.h
index 056b9577b..304681060 100644
--- a/src/guitests/TestModuleCache.h
+++ b/src/guitests/TestModuleCache.h
@@ -7,8 +7,8 @@ class TestModuleCache : public UXTest
   Q_OBJECT;
 
 private slots:
-  void testBasicCache();
-  void testMCAD();
+  void testBasicCache ();
+  void testMCAD ();
 
 private:
   QStringList files;
diff --git a/src/guitests/TestTabManager.cc b/src/guitests/TestTabManager.cc
index 5833a0ac3..21f6fefa7 100644
--- a/src/guitests/TestTabManager.cc
+++ b/src/guitests/TestTabManager.cc
@@ -3,51 +3,48 @@
 #include "platform/PlatformUtils.h"
 #include "TestTabManager.h"
 
-void TestTabManager::initTestCase()
-{
+void TestTabManager::initTestCase () {
 }
 
-void TestTabManager::checkOpenClose()
-{
+void TestTabManager::checkOpenClose () {
   // The window has only one editor with file default.scad
-  restoreWindowInitialState();
+  restoreWindowInitialState ();
 
-  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) + "/tests/basic-ux/empty.scad";
-  QString filename2 = QString::fromStdString(PlatformUtils::resourceBasePath()) + "/tests/basic-ux/empty2.scad";
+  QString filename = QString::fromStdString (PlatformUtils::resourceBasePath ()) + "/tests/basic-ux/empty.scad";
+  QString filename2 = QString::fromStdString (PlatformUtils::resourceBasePath ()) + "/tests/basic-ux/empty2.scad";
 
-  window->tabManager->open(filename);
+  window->tabManager->open (filename);
   // The active editor must have a filepath equal to the loaded file
-  QCOMPARE(window->activeEditor->filepath, filename);
+  QCOMPARE (window->activeEditor->filepath, filename);
 
-  window->tabManager->open(filename2);
+  window->tabManager->open (filename2);
   // The active editor must have a filepath equal to the loaded file
-  QCOMPARE(window->activeEditor->filepath, filename2);
+  QCOMPARE (window->activeEditor->filepath, filename2);
 
   // Close empty2.scad
-  window->tabManager->closeCurrentTab();
+  window->tabManager->closeCurrentTab ();
 
   // Close empty.scad
-  window->tabManager->closeCurrentTab();
+  window->tabManager->closeCurrentTab ();
 
   // Only default.scad remain.
-  QCOMPARE(window->tabManager->count(), 1);
+  QCOMPARE (window->tabManager->count (), 1);
 }
 
-void TestTabManager::checkReOpen()
-{
-  restoreWindowInitialState();
+void TestTabManager::checkReOpen () {
+  restoreWindowInitialState ();
 
-  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) + "/tests/basic-ux/empty.scad";
-  auto numPanel = window->tabManager->count();
+  QString filename = QString::fromStdString (PlatformUtils::resourceBasePath ()) + "/tests/basic-ux/empty.scad";
+  auto numPanel = window->tabManager->count ();
 
   // When we open a new file,
-  window->tabManager->open(filename);
-  QCOMPARE(numPanel + 1, window->tabManager->count());
+  window->tabManager->open (filename);
+  QCOMPARE (numPanel + 1, window->tabManager->count ());
 
   // When we re-open a new file, nothing should happens as the file is already there
-  window->tabManager->open(filename);
-  QCOMPARE(numPanel + 1, window->tabManager->count());
+  window->tabManager->open (filename);
+  QCOMPARE (numPanel + 1, window->tabManager->count ());
 
   // After the tests we close the current tab.
-  window->tabManager->closeCurrentTab();
+  window->tabManager->closeCurrentTab ();
 }
diff --git a/src/guitests/TestTabManager.h b/src/guitests/TestTabManager.h
index 194024062..64ba4874f 100644
--- a/src/guitests/TestTabManager.h
+++ b/src/guitests/TestTabManager.h
@@ -5,7 +5,7 @@ class TestTabManager : public UXTest
 {
   Q_OBJECT;
 private slots:
-  void initTestCase();
-  void checkOpenClose();
-  void checkReOpen();
+  void initTestCase ();
+  void checkOpenClose ();
+  void checkReOpen ();
 };
diff --git a/src/guitests/UXTest.cc b/src/guitests/UXTest.cc
index 5e67bf9f0..cfa60f92c 100644
--- a/src/guitests/UXTest.cc
+++ b/src/guitests/UXTest.cc
@@ -1,15 +1,17 @@
 #include "UXTest.h"
 #include "platform/PlatformUtils.h"
 
-void UXTest::setWindow(MainWindow *window_){ window = window_; }
+void UXTest::setWindow (MainWindow *window_) {
+  window = window_;
+}
 
-void UXTest::restoreWindowInitialState(){
-  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) + "/tests/basic-ux/default.scad";
-  window->tabManager->open(filename);
+void UXTest::restoreWindowInitialState () {
+  QString filename = QString::fromStdString (PlatformUtils::resourceBasePath ()) + "/tests/basic-ux/default.scad";
+  window->tabManager->open (filename);
 
-  while (window->tabCount > 1){
-    window->tabManager->closeCurrentTab();
+  while (window->tabCount > 1) {
+    window->tabManager->closeCurrentTab ();
   }
 
-  window->designActionAutoReload->setChecked(true);   // Enable auto-reload  & preview
+  window->designActionAutoReload->setChecked (true); // Enable auto-reload  & preview
 }
diff --git a/src/guitests/UXTest.h b/src/guitests/UXTest.h
index 88282efa8..9cf80132a 100644
--- a/src/guitests/UXTest.h
+++ b/src/guitests/UXTest.h
@@ -8,10 +8,10 @@ class UXTest : public QObject
   Q_OBJECT;
 
 public:
-  void setWindow(MainWindow *window);
+  void setWindow (MainWindow *window);
 
 protected:
-  void restoreWindowInitialState();
+  void restoreWindowInitialState ();
 
   MainWindow *window;
 };
diff --git a/src/guitests/guitests.cc b/src/guitests/guitests.cc
index 7399bbc01..bb3cdcebf 100644
--- a/src/guitests/guitests.cc
+++ b/src/guitests/guitests.cc
@@ -5,24 +5,20 @@
 #include <QTest>
 
 template <typename TestClass>
-int runTests(MainWindow *window)
-{
+int runTests (MainWindow *window) {
   TestClass tc;
-  tc.setWindow(window);
-  return QTest::qExec(&tc);
+  tc.setWindow (window);
+  return QTest::qExec (&tc);
   return 0;
 }
 
-int runAllTest(MainWindow *window)
-{
+int runAllTest (MainWindow *window) {
   int totalTestFailures = 0;
   std::cout << "******************************* RUN UX TESTS ********************************" << std::endl;
-  totalTestFailures += runTests<TestTabManager>(window);
-  totalTestFailures += runTests<TestMainWindow>(window);
-  totalTestFailures += runTests<TestModuleCache>(window);
+  totalTestFailures += runTests<TestTabManager> (window);
+  totalTestFailures += runTests<TestMainWindow> (window);
+  totalTestFailures += runTests<TestModuleCache> (window);
   std::cout << "********************************** RESULTS *********************************" << std::endl;
   std::cout << "Failures: " << totalTestFailures << std::endl;
   return totalTestFailures;
 }
-
-
diff --git a/src/guitests/guitests.h b/src/guitests/guitests.h
index 21b9d0491..6cae31d70 100644
--- a/src/guitests/guitests.h
+++ b/src/guitests/guitests.h
@@ -1,4 +1,4 @@
 #pragma once
 
 #include "gui/MainWindow.h"
-int runAllTest(MainWindow *window);
+int runAllTest (MainWindow *window);
diff --git a/src/handle_dep.cc b/src/handle_dep.cc
index b3cf27679..6bba0a380 100644
--- a/src/handle_dep.cc
+++ b/src/handle_dep.cc
@@ -24,23 +24,22 @@ namespace {
 
 std::unordered_set<std::string> dependencies;
 
-}  // namespace
+} // namespace
 
-void handle_dep(const std::string& filename)
-{
-  const fs::path filepath(filename);
-  const std::string dep = boost::regex_replace(filepath.generic_string(), boost::regex("\\ "), "\\\\ ");
-  if (dependencies.find(dep) != dependencies.end()) {
+void handle_dep (const std::string &filename) {
+  const fs::path filepath (filename);
+  const std::string dep = boost::regex_replace (filepath.generic_string (), boost::regex ("\\ "), "\\\\ ");
+  if (dependencies.find (dep) != dependencies.end ()) {
     return; // included and used files are very likely to be added many times by the parser
   }
-  dependencies.insert(dep);
+  dependencies.insert (dep);
 
-  if (make_command && !fs::exists(filepath)) {
+  if (make_command && !fs::exists (filepath)) {
     // This should only happen from command-line execution.
     // If changed, add an alternate error-reporting process.
-    auto cmd = STR(make_command, " '", boost::regex_replace(filename, boost::regex("'"), "'\\''"), "'");
+    auto cmd = STR (make_command, " '", boost::regex_replace (filename, boost::regex ("'"), "'\\''"), "'");
     errno = 0;
-    int res = system(cmd.c_str());
+    int res = system (cmd.c_str ());
 
     // Could not launch system() correctly
 #ifdef _WIN32
@@ -48,13 +47,13 @@ void handle_dep(const std::string& filename)
 #else // NOT _WIN32
     if (res == -1 && errno != 0) {
 #endif // _WIN32 / NOT _WIN32
-      perror("ERROR: system(make_cmd) failed");
+      perror ("ERROR: system(make_cmd) failed");
     }
 
 #ifndef _WIN32 // NOT _WIN32
     // Abnormal process failure (e.g., segfault, killed, etc)
-    else if (!WIFEXITED(res)) {
-      std::cerr << "ERROR: " << cmd.c_str()
+    else if (!WIFEXITED (res)) {
+      std::cerr << "ERROR: " << cmd.c_str ()
                 << ": Process terminated abnormally!" << std::endl;
     }
 #endif // NOT _WIN32
@@ -63,9 +62,9 @@ void handle_dep(const std::string& filename)
 #ifdef _WIN32
     else if (0 != res) {
 #else // NOT _WIN32
-    else if (0 != (res = WEXITSTATUS(res))) {
+    else if (0 != (res = WEXITSTATUS (res))) {
 #endif // _WIN32 / NOT _WIN32
-      std::cerr << "ERROR: " << cmd.c_str() << ": Exit status "
+      std::cerr << "ERROR: " << cmd.c_str () << ": Exit status "
                 << res << std::endl;
     }
 
@@ -73,23 +72,22 @@ void handle_dep(const std::string& filename)
   }
 }
 
-bool write_deps(const std::string& filename, const std::vector<std::string>& output_files)
-{
-  FILE *fp = fopen(filename.c_str(), "wt");
+bool write_deps (const std::string &filename, const std::vector<std::string> &output_files) {
+  FILE *fp = fopen (filename.c_str (), "wt");
   if (!fp) {
-    fprintf(stderr, "Can't open dependencies file `%s' for writing!\n", filename.c_str());
+    fprintf (stderr, "Can't open dependencies file `%s' for writing!\n", filename.c_str ());
     return false;
   }
-  for (const auto& output_file : output_files) {
-    fprintf(fp, "%s ", output_file.c_str());
+  for (const auto &output_file : output_files) {
+    fprintf (fp, "%s ", output_file.c_str ());
   }
-  fseek(fp, -1, SEEK_CUR);
-  fprintf(fp, ":");
+  fseek (fp, -1, SEEK_CUR);
+  fprintf (fp, ":");
 
-  for (const auto& str : dependencies) {
-    fprintf(fp, " \\\n\t%s", str.c_str());
+  for (const auto &str : dependencies) {
+    fprintf (fp, " \\\n\t%s", str.c_str ());
   }
-  fprintf(fp, "\n");
-  fclose(fp);
+  fprintf (fp, "\n");
+  fclose (fp);
   return true;
 }
diff --git a/src/handle_dep.h b/src/handle_dep.h
index da426173c..34ae37d35 100644
--- a/src/handle_dep.h
+++ b/src/handle_dep.h
@@ -4,5 +4,5 @@
 #include <vector>
 
 extern const char *make_command;
-void handle_dep(const std::string& filename);
-bool write_deps(const std::string& filename, const std::vector<std::string>& output_files);
+void handle_dep (const std::string &filename);
+bool write_deps (const std::string &filename, const std::vector<std::string> &output_files);
diff --git a/src/io/DxfData.cc b/src/io/DxfData.cc
index a90944a5b..81fab335d 100644
--- a/src/io/DxfData.cc
+++ b/src/io/DxfData.cc
@@ -71,49 +71,50 @@ namespace fs = std::filesystem;
 struct Line {
   int idx[2] = {-1, -1}; // indices into DxfData::points
   bool disabled{false};
-  Line() = default;
-  Line(int i1, int i2) : idx{i1, i2} { }
+  Line () = default;
+  Line (int i1, int i2)
+    : idx{i1, i2} {}
 };
 
 /*!
    Reads a layer from the given file, or all layers if layername.empty()
  */
-DxfData::DxfData(double fn, double fs, double fa,
-                 const std::string& filename, const std::string& layername,
-                 double xorigin, double yorigin, double scale)
-{
-  std::ifstream stream(filename.c_str());
-  if (!stream.good()) {
-    LOG(message_group::Warning, "Can't open DXF file '%1$s'.", filename);
+DxfData::DxfData (double fn, double fs, double fa,
+                  const std::string &filename, const std::string &layername,
+                  double xorigin, double yorigin, double scale) {
+  std::ifstream stream (filename.c_str ());
+  if (!stream.good ()) {
+    LOG (message_group::Warning, "Can't open DXF file '%1$s'.", filename);
     return;
   }
 
-  Grid2d<std::vector<int>> grid(GRID_COARSE);
-  std::vector<Line> lines;                 // Global lines
+  Grid2d<std::vector<int>> grid (GRID_COARSE);
+  std::vector<Line> lines; // Global lines
   std::unordered_map<std::string, std::vector<Line>> blockdata; // Lines in blocks
 
   auto in_entities_section = false;
   auto in_blocks_section = false;
   std::string current_block;
 
-#define ADD_LINE(_x1, _y1, _x2, _y2) do {                   \
-          double _p1x = (_x1), _p1y = (_y1), _p2x = (_x2), _p2y = (_y2); \
-          if (!in_entities_section && !in_blocks_section)         \
-          break;                                                \
-          if (in_entities_section &&                              \
-              !(layername.empty() || layername == layer))         \
-          break;                                                \
-          grid.align(_p1x, _p1y);                                 \
-          grid.align(_p2x, _p2y);                                 \
-          grid.data(_p1x, _p1y).push_back(lines.size());          \
-          grid.data(_p2x, _p2y).push_back(lines.size());          \
-          if (in_entities_section)                                \
-          lines.emplace_back(                                   \
-            addPoint(_p1x, _p1y), addPoint(_p2x, _p2y));        \
-          if (in_blocks_section && !current_block.empty())        \
-          blockdata[current_block].emplace_back(                \
-            addPoint(_p1x, _p1y), addPoint(_p2x, _p2y));        \
-} while (0)
+#define ADD_LINE(_x1, _y1, _x2, _y2)                               \
+  do {                                                             \
+    double _p1x = (_x1), _p1y = (_y1), _p2x = (_x2), _p2y = (_y2); \
+    if (!in_entities_section && !in_blocks_section)                \
+      break;                                                       \
+    if (in_entities_section &&                                     \
+        !(layername.empty () || layername == layer))               \
+      break;                                                       \
+    grid.align (_p1x, _p1y);                                       \
+    grid.align (_p2x, _p2y);                                       \
+    grid.data (_p1x, _p1y).push_back (lines.size ());              \
+    grid.data (_p2x, _p2y).push_back (lines.size ());              \
+    if (in_entities_section)                                       \
+      lines.emplace_back (                                         \
+        addPoint (_p1x, _p1y), addPoint (_p2x, _p2y));             \
+    if (in_blocks_section && !current_block.empty ())              \
+      blockdata[current_block].emplace_back (                      \
+        addPoint (_p1x, _p1y), addPoint (_p2x, _p2y));             \
+  } while (0)
 
   std::string mode, layer, name, iddata;
   int dimtype = 0;
@@ -124,8 +125,8 @@ DxfData::DxfData(double fn, double fs, double fa,
   double arc_start_angle = 0, arc_stop_angle = 0;
   double ellipse_start_angle = 0, ellipse_stop_angle = 0;
 
-  for (auto& coord : coords) {
-    for (double& j : coord) {
+  for (auto &coord : coords) {
+    for (double &j : coord) {
       j = 0;
     }
   }
@@ -136,40 +137,40 @@ DxfData::DxfData(double fn, double fs, double fa,
   //
   // Parse DXF file. Will populate this->points, this->dims, lines and blockdata
   //
-  while (!stream.eof()) {
+  while (!stream.eof ()) {
     std::string id_str, data;
-    std::getline(stream, id_str);
-    boost::trim(id_str);
-    std::getline(stream, data);
-    boost::trim(data);
+    std::getline (stream, id_str);
+    boost::trim (id_str);
+    std::getline (stream, data);
+    boost::trim (data);
 
     int id;
     try {
-      id = boost::lexical_cast<int>(id_str);
-    } catch (const boost::bad_lexical_cast& blc) {
-      if (!stream.eof()) {
-        LOG(message_group::Warning, "Illegal ID '%1$s' in `%2$s'", id_str, filename);
+      id = boost::lexical_cast<int> (id_str);
+    } catch (const boost::bad_lexical_cast &blc) {
+      if (!stream.eof ()) {
+        LOG (message_group::Warning, "Illegal ID '%1$s' in `%2$s'", id_str, filename);
       }
       break;
     }
     try {
       if (id >= 10 && id <= 16) {
         if (in_blocks_section) {
-          coords[id - 10][0] = boost::lexical_cast<double>(data);
+          coords[id - 10][0] = boost::lexical_cast<double> (data);
         } else if (id == 11 || id == 12 || id == 16) {
-          coords[id - 10][0] = boost::lexical_cast<double>(data) * scale;
+          coords[id - 10][0] = boost::lexical_cast<double> (data) * scale;
         } else {
-          coords[id - 10][0] = (boost::lexical_cast<double>(data) - xorigin) * scale;
+          coords[id - 10][0] = (boost::lexical_cast<double> (data) - xorigin) * scale;
         }
       }
 
       if (id >= 20 && id <= 26) {
         if (in_blocks_section) {
-          coords[id - 20][1] = boost::lexical_cast<double>(data);
+          coords[id - 20][1] = boost::lexical_cast<double> (data);
         } else if (id == 21 || id == 22 || id == 26) {
-          coords[id - 20][1] = boost::lexical_cast<double>(data) * scale;
+          coords[id - 20][1] = boost::lexical_cast<double> (data) * scale;
         } else {
-          coords[id - 20][1] = (boost::lexical_cast<double>(data) - yorigin) * scale;
+          coords[id - 20][1] = (boost::lexical_cast<double> (data) - yorigin) * scale;
         }
       }
 
@@ -179,136 +180,140 @@ DxfData::DxfData(double fn, double fs, double fa,
           in_entities_section = iddata == "ENTITIES";
           in_blocks_section = iddata == "BLOCKS";
         } else if (mode == "LINE") {
-          ADD_LINE(xverts.at(0), yverts.at(0), xverts.at(1), yverts.at(1));
+          ADD_LINE (xverts.at (0), yverts.at (0), xverts.at (1), yverts.at (1));
         } else if (mode == "LWPOLYLINE") {
           // assert(xverts.size() == yverts.size());
           // Get maximum to enforce managed exception if xverts.size() != yverts.size()
-          const int numverts = std::max(xverts.size(), yverts.size());
+          const int numverts = std::max (xverts.size (), yverts.size ());
           for (int i = 1; i < numverts; ++i) {
-            ADD_LINE(xverts.at(i - 1), yverts.at(i - 1), xverts.at(i % numverts), yverts.at(i % numverts));
+            ADD_LINE (xverts.at (i - 1), yverts.at (i - 1), xverts.at (i % numverts), yverts.at (i % numverts));
           }
           // polyline flag is stored in 'dimtype'
           if (dimtype & 0x01) { // closed polyline
-            ADD_LINE(xverts.at(numverts - 1), yverts.at(numverts - 1), xverts.at(0), yverts.at(0));
+            ADD_LINE (xverts.at (numverts - 1), yverts.at (numverts - 1), xverts.at (0), yverts.at (0));
           }
         } else if (mode == "CIRCLE") {
-          const int n = Calc::get_fragments_from_r(radius, fn, fs, fa);
-          Vector2d center(xverts.at(0), yverts.at(0));
+          const int n = Calc::get_fragments_from_r (radius, fn, fs, fa);
+          Vector2d center (xverts.at (0), yverts.at (0));
           for (int i = 0; i < n; ++i) {
             const double a1 = (360.0 * i) / n;
             const double a2 = (360.0 * (i + 1)) / n;
-            ADD_LINE(cos_degrees(a1) * radius + center[0], sin_degrees(a1) * radius + center[1],
-                     cos_degrees(a2) * radius + center[0], sin_degrees(a2) * radius + center[1]);
+            ADD_LINE (cos_degrees (a1) * radius + center[0], sin_degrees (a1) * radius + center[1],
+                      cos_degrees (a2) * radius + center[0], sin_degrees (a2) * radius + center[1]);
           }
         } else if (mode == "ARC") {
-          Vector2d center(xverts.at(0), yverts.at(0));
-          int n = Calc::get_fragments_from_r(radius, fn, fs, fa);
+          Vector2d center (xverts.at (0), yverts.at (0));
+          int n = Calc::get_fragments_from_r (radius, fn, fs, fa);
           while (arc_start_angle > arc_stop_angle) {
             arc_stop_angle += 360.0;
           }
           const double arc_angle = arc_stop_angle - arc_start_angle;
-          n = static_cast<int>(ceil(n * arc_angle / 360));
+          n = static_cast<int> (ceil (n * arc_angle / 360));
           for (int i = 0; i < n; ++i) {
             const double a1 = arc_start_angle + arc_angle * i / n;
             const double a2 = arc_start_angle + arc_angle * (i + 1) / n;
-            ADD_LINE(cos_degrees(a1) * radius + center[0], sin_degrees(a1) * radius + center[1],
-                     cos_degrees(a2) * radius + center[0], sin_degrees(a2) * radius + center[1]);
+            ADD_LINE (cos_degrees (a1) * radius + center[0], sin_degrees (a1) * radius + center[1],
+                      cos_degrees (a2) * radius + center[0], sin_degrees (a2) * radius + center[1]);
           }
         } else if (mode == "ELLIPSE") {
           // Commented code is meant as documentation of vector math
-          while (ellipse_start_angle > ellipse_stop_angle) ellipse_stop_angle += 2 * M_PI;
-//				Vector2d center(xverts[0], yverts[0]);
-          Vector2d center(xverts.at(0), yverts.at(0));
-//				Vector2d ce(xverts[1], yverts[1]);
-          Vector2d ce(xverts.at(1), yverts.at(1));
-//				double r_major = ce.length();
-          const double r_major = sqrt(ce[0] * ce[0] + ce[1] * ce[1]);
-//				double rot_angle = ce.angle();
+          while (ellipse_start_angle > ellipse_stop_angle)
+            ellipse_stop_angle += 2 * M_PI;
+          //				Vector2d center(xverts[0], yverts[0]);
+          Vector2d center (xverts.at (0), yverts.at (0));
+          //				Vector2d ce(xverts[1], yverts[1]);
+          Vector2d ce (xverts.at (1), yverts.at (1));
+          //				double r_major = ce.length();
+          const double r_major = sqrt (ce[0] * ce[0] + ce[1] * ce[1]);
+          //				double rot_angle = ce.angle();
           double rot_angle;
           {
-//					double dot = ce.dot(Vector2d(1.0, 0.0));
+            //					double dot = ce.dot(Vector2d(1.0, 0.0));
             const double dot = ce[0];
             double cosval = dot / r_major;
-            if (cosval > 1.0) cosval = 1.0;
-            if (cosval < -1.0) cosval = -1.0;
-            rot_angle = acos(cosval);
-            if (ce[1] < 0.0) rot_angle = 2 * M_PI - rot_angle;
+            if (cosval > 1.0)
+              cosval = 1.0;
+            if (cosval < -1.0)
+              cosval = -1.0;
+            rot_angle = acos (cosval);
+            if (ce[1] < 0.0)
+              rot_angle = 2 * M_PI - rot_angle;
           }
 
           // the ratio stored in 'radius; due to the parser code not checking entity type
           const double r_minor = r_major * radius;
           const double sweep_angle = ellipse_stop_angle - ellipse_start_angle;
-          int n = Calc::get_fragments_from_r(r_major, fn, fs, fa);
-          n = static_cast<int>(ceil(n * sweep_angle / (2 * M_PI)));
-//				Vector2d p1;
+          int n = Calc::get_fragments_from_r (r_major, fn, fs, fa);
+          n = static_cast<int> (ceil (n * sweep_angle / (2 * M_PI)));
+          //				Vector2d p1;
           Vector2d p1{0.0, 0.0};
           for (int i = 0; i <= n; ++i) {
             const double a = (ellipse_start_angle + sweep_angle * i / n);
-//					Vector2d p2(cos(a)*r_major, sin(a)*r_minor);
-            Vector2d p2(cos(a) * r_major, sin(a) * r_minor);
-//					p2.rotate(rot_angle);
-            Vector2d p2_rot(cos(rot_angle) * p2[0] - sin(rot_angle) * p2[1],
-                            sin(rot_angle) * p2[0] + cos(rot_angle) * p2[1]);
-//					p2 += center;
+            //					Vector2d p2(cos(a)*r_major, sin(a)*r_minor);
+            Vector2d p2 (cos (a) * r_major, sin (a) * r_minor);
+            //					p2.rotate(rot_angle);
+            Vector2d p2_rot (cos (rot_angle) * p2[0] - sin (rot_angle) * p2[1],
+                             sin (rot_angle) * p2[0] + cos (rot_angle) * p2[1]);
+            //					p2 += center;
             p2_rot[0] += center[0];
             p2_rot[1] += center[1];
             if (i > 0) {
-//            ADD_LINE(p1[0], p1[1], p2[0], p2[1]);
-              ADD_LINE(p1[0], p1[1], p2_rot[0], p2_rot[1]);
+              //            ADD_LINE(p1[0], p1[1], p2[0], p2[1]);
+              ADD_LINE (p1[0], p1[1], p2_rot[0], p2_rot[1]);
             }
-//					p1 = p2;
+            //					p1 = p2;
             p1[0] = p2_rot[0];
             p1[1] = p2_rot[1];
           }
         } else if (mode == "INSERT") {
           // scale is stored in ellipse_start|stop_angle, rotation in arc_start_angle;
           // due to the parser code not checking entity type
-          const int n = blockdata[iddata].size();
+          const int n = blockdata[iddata].size ();
           for (int i = 0; i < n; ++i) {
             const double a = arc_start_angle;
             const double lx1 = this->points[blockdata[iddata][i].idx[0]][0] * ellipse_start_angle;
             const double ly1 = this->points[blockdata[iddata][i].idx[0]][1] * ellipse_stop_angle;
             const double lx2 = this->points[blockdata[iddata][i].idx[1]][0] * ellipse_start_angle;
             const double ly2 = this->points[blockdata[iddata][i].idx[1]][1] * ellipse_stop_angle;
-            const double px1 = (cos_degrees(a) * lx1 - sin_degrees(a) * ly1) * scale + xverts.at(0);
-            const double py1 = (sin_degrees(a) * lx1 + cos_degrees(a) * ly1) * scale + yverts.at(0);
-            const double px2 = (cos_degrees(a) * lx2 - sin_degrees(a) * ly2) * scale + xverts.at(0);
-            const double py2 = (sin_degrees(a) * lx2 + cos_degrees(a) * ly2) * scale + yverts.at(0);
-            ADD_LINE(px1, py1, px2, py2);
+            const double px1 = (cos_degrees (a) * lx1 - sin_degrees (a) * ly1) * scale + xverts.at (0);
+            const double py1 = (sin_degrees (a) * lx1 + cos_degrees (a) * ly1) * scale + yverts.at (0);
+            const double px2 = (cos_degrees (a) * lx2 - sin_degrees (a) * ly2) * scale + xverts.at (0);
+            const double py2 = (sin_degrees (a) * lx2 + cos_degrees (a) * ly2) * scale + yverts.at (0);
+            ADD_LINE (px1, py1, px2, py2);
           }
         } else if (mode == "DIMENSION" &&
-                   (layername.empty() || layername == layer)) {
-          this->dims.emplace_back();
-          this->dims.back().type = dimtype;
+                   (layername.empty () || layername == layer)) {
+          this->dims.emplace_back ();
+          this->dims.back ().type = dimtype;
           for (int i = 0; i < 7; ++i) {
             for (int j = 0; j < 2; ++j) {
-              this->dims.back().coords[i][j] = coords[i][j];
+              this->dims.back ().coords[i][j] = coords[i][j];
             }
           }
-          this->dims.back().angle = arc_start_angle;
-          this->dims.back().length = radius;
-          this->dims.back().name = name;
+          this->dims.back ().angle = arc_start_angle;
+          this->dims.back ().length = radius;
+          this->dims.back ().name = name;
         } else if (mode == "BLOCK") {
           current_block = iddata;
         } else if (mode == "ENDBLK") {
-          current_block.erase();
+          current_block.erase ();
         } else if (mode == "ENDSEC") {
         } else if (in_blocks_section || (in_entities_section &&
-                                         (layername.empty() || layername == layer))) {
+                                         (layername.empty () || layername == layer))) {
           unsupported_entities_list[mode]++;
         }
         mode = data;
-        layer.erase();
-        name.erase();
-        iddata.erase();
+        layer.erase ();
+        name.erase ();
+        iddata.erase ();
         dimtype = 0;
-        for (auto& coord : coords) {
-          for (double& j : coord) {
+        for (auto &coord : coords) {
+          for (double &j : coord) {
             j = 0;
           }
         }
-        xverts.clear();
-        yverts.clear();
+        xverts.clear ();
+        yverts.clear ();
         radius = arc_start_angle = arc_stop_angle = 0;
         ellipse_start_angle = ellipse_stop_angle = 0;
         if (mode == "INSERT") {
@@ -324,68 +329,71 @@ DxfData::DxfData(double fn, double fs, double fa,
       case 8:
         layer = data;
         break;
-      case 10: [[fallthrough]];
+      case 10:
+        [[fallthrough]];
       case 11:
         if (in_blocks_section) {
-          xverts.push_back((boost::lexical_cast<double>(data)));
+          xverts.push_back ((boost::lexical_cast<double> (data)));
         } else {
-          xverts.push_back((boost::lexical_cast<double>(data) - xorigin) * scale);
+          xverts.push_back ((boost::lexical_cast<double> (data) - xorigin) * scale);
         }
         break;
-      case 20: [[fallthrough]];
+      case 20:
+        [[fallthrough]];
       case 21:
         if (in_blocks_section) {
-          yverts.push_back((boost::lexical_cast<double>(data)));
+          yverts.push_back ((boost::lexical_cast<double> (data)));
         } else {
-          yverts.push_back((boost::lexical_cast<double>(data) - yorigin) * scale);
+          yverts.push_back ((boost::lexical_cast<double> (data) - yorigin) * scale);
         }
         break;
       case 40:
         // CIRCLE, ARC: radius
         // ELLIPSE: minor to major ratio
         // DIMENSION (radial, diameter): Leader length
-        radius = boost::lexical_cast<double>(data);
-        if (!in_blocks_section) radius *= scale;
+        radius = boost::lexical_cast<double> (data);
+        if (!in_blocks_section)
+          radius *= scale;
         break;
       case 41:
         // ELLIPSE: start_angle
         // INSERT: X scale
-        ellipse_start_angle = boost::lexical_cast<double>(data);
+        ellipse_start_angle = boost::lexical_cast<double> (data);
         break;
       case 50:
         // ARC: start_angle
         // INSERT: rot angle
         // DIMENSION: linear and rotated: angle
-        arc_start_angle = boost::lexical_cast<double>(data);
+        arc_start_angle = boost::lexical_cast<double> (data);
         break;
       case 42:
         // ELLIPSE: stop_angle
         // INSERT: Y scale
-        ellipse_stop_angle = boost::lexical_cast<double>(data);
+        ellipse_stop_angle = boost::lexical_cast<double> (data);
         break;
       case 51: // ARC
-        arc_stop_angle = boost::lexical_cast<double>(data);
+        arc_stop_angle = boost::lexical_cast<double> (data);
         break;
       case 70:
         // LWPOLYLINE: polyline flag
         // DIMENSION: dimension type
-        dimtype = boost::lexical_cast<int>(data);
+        dimtype = boost::lexical_cast<int> (data);
         break;
       }
-    } catch (boost::bad_lexical_cast& blc) {
-      LOG(message_group::Warning, "Illegal value '%1$s'in `%2$s'", data, filename);
-    } catch (const std::out_of_range& oor) {
-      LOG(message_group::Warning, "Not enough input values for %1$s. in '%2$s'", data, filename);
+    } catch (boost::bad_lexical_cast &blc) {
+      LOG (message_group::Warning, "Illegal value '%1$s'in `%2$s'", data, filename);
+    } catch (const std::out_of_range &oor) {
+      LOG (message_group::Warning, "Not enough input values for %1$s. in '%2$s'", data, filename);
     }
   }
 
-  for (const auto& i : unsupported_entities_list) {
-    if (layername.empty()) {
-      LOG(message_group::Warning,
-          "Unsupported DXF Entity '%1$s' (%2$x) in %3$s.", i.first, i.second, QuotedString(fs_uncomplete(filename, fs::current_path()).generic_string()));
+  for (const auto &i : unsupported_entities_list) {
+    if (layername.empty ()) {
+      LOG (message_group::Warning,
+           "Unsupported DXF Entity '%1$s' (%2$x) in %3$s.", i.first, i.second, QuotedString (fs_uncomplete (filename, fs::current_path ()).generic_string ()));
     } else {
-      LOG(message_group::Warning,
-          "Unsupported DXF Entity '%1$s' (%2$x) in layer '%3$s' of %4$s", i.first, i.second, layername, fs_uncomplete(filename, fs::current_path()).generic_string());
+      LOG (message_group::Warning,
+           "Unsupported DXF Entity '%1$s' (%2$x) in layer '%3$s' of %4$s", i.first, i.second, layername, fs_uncomplete (filename, fs::current_path ()).generic_string ());
     }
   }
 
@@ -393,114 +401,117 @@ DxfData::DxfData(double fn, double fs, double fa,
 
   using LineMap = std::map<int, int>;
   LineMap enabled_lines;
-  for (size_t i = 0; i < lines.size(); ++i) {
+  for (size_t i = 0; i < lines.size (); ++i) {
     enabled_lines[i] = i;
   }
 
   // extract all open paths
-  while (enabled_lines.size() > 0) {
+  while (enabled_lines.size () > 0) {
     int current_line, current_point;
 
-    for (const auto& l : enabled_lines) {
+    for (const auto &l : enabled_lines) {
       const int idx = l.second;
       for (int j = 0; j < 2; ++j) {
-        auto lv = grid.data(this->points[lines[idx].idx[j]][0], this->points[lines[idx].idx[j]][1]);
+        auto lv = grid.data (this->points[lines[idx].idx[j]][0], this->points[lines[idx].idx[j]][1]);
         for (const int k : lv) {
-          if (k < 0 || static_cast<unsigned int>(k) >= lines.size()) {
-            LOG(message_group::Warning,
-                "Bad DXF line index in %1$s.", QuotedString(fs_uncomplete(filename, fs::current_path()).generic_string()));
+          if (k < 0 || static_cast<unsigned int> (k) >= lines.size ()) {
+            LOG (message_group::Warning,
+                 "Bad DXF line index in %1$s.", QuotedString (fs_uncomplete (filename, fs::current_path ()).generic_string ()));
             continue;
           }
-          if (k == idx || lines[k].disabled) continue;
+          if (k == idx || lines[k].disabled)
+            continue;
           goto next_open_path_j;
         }
         current_line = idx;
         current_point = j;
         goto create_open_path;
-next_open_path_j:;
+      next_open_path_j:;
       }
     }
 
     break;
 
-create_open_path:
-    this->paths.emplace_back();
-    Path *this_path = &this->paths.back();
+  create_open_path:
+    this->paths.emplace_back ();
+    Path *this_path = &this->paths.back ();
 
-    this_path->indices.push_back(lines[current_line].idx[current_point]);
+    this_path->indices.push_back (lines[current_line].idx[current_point]);
     while (true) {
-      this_path->indices.push_back(lines[current_line].idx[!current_point]);
-      const auto& ref_point = this->points[lines[current_line].idx[!current_point]];
+      this_path->indices.push_back (lines[current_line].idx[!current_point]);
+      const auto &ref_point = this->points[lines[current_line].idx[!current_point]];
       lines[current_line].disabled = true;
-      enabled_lines.erase(current_line);
-      auto lv = grid.data(ref_point[0], ref_point[1]);
+      enabled_lines.erase (current_line);
+      auto lv = grid.data (ref_point[0], ref_point[1]);
       for (const int k : lv) {
-        if (k < 0 || static_cast<unsigned int>(k) >= lines.size()) {
-          LOG(message_group::Warning,
-              "Bad DXF line index in %1$s.", QuotedString(fs_uncomplete(filename, fs::current_path()).generic_string()));
+        if (k < 0 || static_cast<unsigned int> (k) >= lines.size ()) {
+          LOG (message_group::Warning,
+               "Bad DXF line index in %1$s.", QuotedString (fs_uncomplete (filename, fs::current_path ()).generic_string ()));
           continue;
         }
-        if (lines[k].disabled) continue;
+        if (lines[k].disabled)
+          continue;
         auto idk0 = lines[k].idx[0]; // make it easier to read and debug
         auto idk1 = lines[k].idx[1];
-        if (grid.eq(ref_point[0], ref_point[1], this->points[idk0][0], this->points[idk0][1])) {
+        if (grid.eq (ref_point[0], ref_point[1], this->points[idk0][0], this->points[idk0][1])) {
           current_line = k;
           current_point = 0;
           goto found_next_line_in_open_path;
         }
-        if (grid.eq(ref_point[0], ref_point[1], this->points[idk1][0], this->points[idk1][1])) {
+        if (grid.eq (ref_point[0], ref_point[1], this->points[idk1][0], this->points[idk1][1])) {
           current_line = k;
           current_point = 1;
           goto found_next_line_in_open_path;
         }
       }
       break;
-found_next_line_in_open_path:;
+    found_next_line_in_open_path:;
     }
   }
 
   // extract all closed paths
-  while (enabled_lines.size() > 0) {
-    int current_line = enabled_lines.begin()->second;
+  while (enabled_lines.size () > 0) {
+    int current_line = enabled_lines.begin ()->second;
     int current_point = 0;
 
-    this->paths.emplace_back();
-    auto& this_path = this->paths.back();
+    this->paths.emplace_back ();
+    auto &this_path = this->paths.back ();
     this_path.is_closed = true;
 
-    this_path.indices.push_back(lines[current_line].idx[current_point]);
+    this_path.indices.push_back (lines[current_line].idx[current_point]);
     while (true) {
-      this_path.indices.push_back(lines[current_line].idx[!current_point]);
-      const auto& ref_point = this->points[lines[current_line].idx[!current_point]];
+      this_path.indices.push_back (lines[current_line].idx[!current_point]);
+      const auto &ref_point = this->points[lines[current_line].idx[!current_point]];
       lines[current_line].disabled = true;
-      enabled_lines.erase(current_line);
-      auto lv = grid.data(ref_point[0], ref_point[1]);
+      enabled_lines.erase (current_line);
+      auto lv = grid.data (ref_point[0], ref_point[1]);
       for (const int k : lv) {
-        if (k < 0 || static_cast<unsigned int>(k) >= lines.size()) {
-          LOG(message_group::Warning,
-              "Bad DXF line index in %1$s.", QuotedString(fs_uncomplete(filename, fs::current_path()).generic_string()));
+        if (k < 0 || static_cast<unsigned int> (k) >= lines.size ()) {
+          LOG (message_group::Warning,
+               "Bad DXF line index in %1$s.", QuotedString (fs_uncomplete (filename, fs::current_path ()).generic_string ()));
           continue;
         }
-        if (lines[k].disabled) continue;
+        if (lines[k].disabled)
+          continue;
         auto idk0 = lines[k].idx[0]; // make it easier to read and debug
         auto idk1 = lines[k].idx[1];
-        if (grid.eq(ref_point[0], ref_point[1], this->points[idk0][0], this->points[idk0][1])) {
+        if (grid.eq (ref_point[0], ref_point[1], this->points[idk0][0], this->points[idk0][1])) {
           current_line = k;
           current_point = 0;
           goto found_next_line_in_closed_path;
         }
-        if (grid.eq(ref_point[0], ref_point[1], this->points[idk1][0], this->points[idk1][1])) {
+        if (grid.eq (ref_point[0], ref_point[1], this->points[idk1][0], this->points[idk1][1])) {
           current_line = k;
           current_point = 1;
           goto found_next_line_in_closed_path;
         }
       }
       break;
-found_next_line_in_closed_path:;
+    found_next_line_in_closed_path:;
     }
   }
 
-  fixup_path_direction();
+  fixup_path_direction ();
 
 #if 0
   printf("----- DXF Data -----\n");
@@ -518,14 +529,14 @@ found_next_line_in_closed_path:;
    Ensures that all paths have the same vertex ordering.
    FIXME: CW or CCW?
  */
-void DxfData::fixup_path_direction()
-{
-  for (auto& path : this->paths) {
-    if (!path.is_closed) break;
+void DxfData::fixup_path_direction () {
+  for (auto &path : this->paths) {
+    if (!path.is_closed)
+      break;
     path.is_inner = true;
     double min_x = this->points[path.indices[0]][0];
     size_t min_x_point = 0;
-    for (size_t j = 1; j < path.indices.size(); ++j) {
+    for (size_t j = 1; j < path.indices.size (); ++j) {
       if (this->points[path.indices[j]][0] < min_x) {
         min_x = this->points[path.indices[j]][0];
         min_x_point = j;
@@ -533,8 +544,8 @@ void DxfData::fixup_path_direction()
     }
     // rotate points if the path is in non-standard rotation
     const size_t b = min_x_point;
-    const size_t a = b == 0 ? path.indices.size() - 2 : b - 1;
-    const size_t c = b == path.indices.size() - 1 ? 1 : b + 1;
+    const size_t a = b == 0 ? path.indices.size () - 2 : b - 1;
+    const size_t c = b == path.indices.size () - 1 ? 1 : b + 1;
     const double ax = this->points[path.indices[a]][0] - this->points[path.indices[b]][0];
     const double ay = this->points[path.indices[a]][1] - this->points[path.indices[b]][1];
     const double cx = this->points[path.indices[c]][0] - this->points[path.indices[b]][0];
@@ -546,8 +557,8 @@ void DxfData::fixup_path_direction()
     printf("  b->c vector = %f %f (%f)\n", cx, cy, atan2(cx, cy));
 #endif
     // FIXME: atan2() usually takes y,x. This variant probably makes the path clockwise..
-    if (atan2(ax, ay) < atan2(cx, cy)) {
-      std::reverse(path.indices.begin(), path.indices.end());
+    if (atan2 (ax, ay) < atan2 (cx, cy)) {
+      std::reverse (path.indices.begin (), path.indices.end ());
     }
   }
 }
@@ -555,52 +566,50 @@ void DxfData::fixup_path_direction()
 /*!
    Adds a vertex and returns the index into DxfData::points
  */
-int DxfData::addPoint(double x, double y)
-{
-  this->points.emplace_back(x, y);
-  return this->points.size() - 1;
+int DxfData::addPoint (double x, double y) {
+  this->points.emplace_back (x, y);
+  return this->points.size () - 1;
 }
 
-std::string DxfData::dump() const
-{
+std::string DxfData::dump () const {
   std::ostringstream out;
   out << "DxfData"
-      << "\n num points: " << points.size()
-      << "\n num paths: " << paths.size()
-      << "\n num dims: " << dims.size()
+      << "\n num points: " << points.size ()
+      << "\n num paths: " << paths.size ()
+      << "\n num dims: " << dims.size ()
       << "\n points: ";
-  for (const auto& point : points) {
-    out << "\n  x y: " << point.transpose();
+  for (const auto &point : points) {
+    out << "\n  x y: " << point.transpose ();
   }
   out << "\n paths: ";
-  for (size_t i = 0; i < paths.size(); ++i) {
+  for (size_t i = 0; i < paths.size (); ++i) {
     out << "\n  path:" << i
         << "\n  is_closed: " << paths[i].is_closed
         << "\n  is_inner: " << paths[i].is_inner;
     DxfData::Path path = paths[i];
-    for (size_t j = 0; j < path.indices.size(); ++j) {
+    for (size_t j = 0; j < path.indices.size (); ++j) {
       out << "\n  index[" << j << "]==" << path.indices[j];
     }
   }
   out << "\nDxfData end";
-  return out.str();
+  return out.str ();
 }
 
 /*
     May return an empty polygon, but will not return nullptr
  */
-std::unique_ptr<Polygon2d> DxfData::toPolygon2d() const
-{
-  auto poly = std::make_unique<Polygon2d>();
-  for (const auto& path : this->paths) {
+std::unique_ptr<Polygon2d> DxfData::toPolygon2d () const {
+  auto poly = std::make_unique<Polygon2d> ();
+  for (const auto &path : this->paths) {
     Outline2d outline;
-    size_t endidx = path.indices.size();
+    size_t endidx = path.indices.size ();
     // We don't support open paths; closing them to be compatible with existing behavior
-    if (!path.is_closed) endidx++;
+    if (!path.is_closed)
+      endidx++;
     for (size_t j = 1; j < endidx; ++j) {
-      outline.vertices.push_back(this->points[path.indices[path.indices.size() - j]]);
+      outline.vertices.push_back (this->points[path.indices[path.indices.size () - j]]);
     }
-    poly->addOutline(outline);
+    poly->addOutline (outline);
   }
   return poly;
 }
diff --git a/src/io/DxfData.h b/src/io/DxfData.h
index bf136ecd0..9b6e8aa47 100644
--- a/src/io/DxfData.h
+++ b/src/io/DxfData.h
@@ -12,7 +12,7 @@ public:
   struct Path {
     std::vector<int> indices; // indices into DxfData::points
     bool is_closed{false}, is_inner{false};
-    Path() = default;
+    Path () = default;
   };
   struct Dim {
     unsigned int type;
@@ -20,9 +20,9 @@ public:
     double angle;
     double length;
     std::string name;
-    Dim() {
-      for (auto& coord : coords) {
-        for (double& j : coord) {
+    Dim () {
+      for (auto &coord : coords) {
+        for (double &j : coord) {
           j = 0;
         }
       }
@@ -36,14 +36,14 @@ public:
   std::vector<Path> paths;
   std::vector<Dim> dims;
 
-  DxfData() = default;
-  DxfData(double fn, double fs, double fa,
-          const std::string& filename, const std::string& layername = "",
-          double xorigin = 0.0, double yorigin = 0.0, double scale = 1.0);
+  DxfData () = default;
+  DxfData (double fn, double fs, double fa,
+           const std::string &filename, const std::string &layername = "",
+           double xorigin = 0.0, double yorigin = 0.0, double scale = 1.0);
 
-  int addPoint(double x, double y);
+  int addPoint (double x, double y);
 
-  void fixup_path_direction();
-  [[nodiscard]] std::string dump() const;
-  [[nodiscard]] std::unique_ptr<class Polygon2d> toPolygon2d() const;
+  void fixup_path_direction ();
+  [[nodiscard]] std::string dump () const;
+  [[nodiscard]] std::unique_ptr<class Polygon2d> toPolygon2d () const;
 };
diff --git a/src/io/dxfdim.cc b/src/io/dxfdim.cc
index 91b876b7a..0ee7f4b5d 100644
--- a/src/io/dxfdim.cc
+++ b/src/io/dxfdim.cc
@@ -50,51 +50,52 @@ std::unordered_map<std::string, double> dxf_dim_cache;
 std::unordered_map<std::string, std::vector<double>> dxf_cross_cache;
 namespace fs = std::filesystem;
 
-static Value builtin_dxf_dim(Arguments arguments, const Location& loc)
-{
-  const Parameters parameters = Parameters::parse(std::move(arguments), loc, {}, {"file", "layer", "origin", "scale", "name"});
+static Value builtin_dxf_dim (Arguments arguments, const Location &loc) {
+  const Parameters parameters = Parameters::parse (std::move (arguments), loc, {}, {"file", "layer", "origin", "scale", "name"});
 
   std::string rawFilename;
   std::string filename;
-  if (parameters.contains("file")) {
-    rawFilename = parameters["file"].toString();
-    filename = lookup_file(rawFilename, loc.filePath().parent_path().string(), parameters.documentRoot());
+  if (parameters.contains ("file")) {
+    rawFilename = parameters["file"].toString ();
+    filename = lookup_file (rawFilename, loc.filePath ().parent_path ().string (), parameters.documentRoot ());
   }
   double xorigin = 0;
   double yorigin = 0;
-  if (parameters.contains("origin")) {
-    bool originOk = parameters["origin"].getVec2(xorigin, yorigin);
-    originOk &= std::isfinite(xorigin) && std::isfinite(yorigin);
+  if (parameters.contains ("origin")) {
+    bool originOk = parameters["origin"].getVec2 (xorigin, yorigin);
+    originOk &= std::isfinite (xorigin) && std::isfinite (yorigin);
     if (!originOk) {
-      LOG(message_group::Warning, loc, parameters.documentRoot(), "dxf_dim(..., origin=%1$s) could not be converted", parameters["origin"].toEchoString());
+      LOG (message_group::Warning, loc, parameters.documentRoot (), "dxf_dim(..., origin=%1$s) could not be converted", parameters["origin"].toEchoString ());
     }
   }
-  std::string layername = parameters.get("layer", "");
-  const double scale = parameters.get("scale", 1);
-  std::string name = parameters.get("name", "");
+  std::string layername = parameters.get ("layer", "");
+  const double scale = parameters.get ("scale", 1);
+  std::string name = parameters.get ("name", "");
 
-  const fs::path filepath(filename);
+  const fs::path filepath (filename);
   uintmax_t filesize = -1;
   int64_t lastwritetime = -1;
-  if (fs::exists(filepath)) {
-    if (fs::is_regular_file(filepath)) {
-      filesize = fs::file_size(filepath);
-      lastwritetime = fs_timestamp(filepath);
+  if (fs::exists (filepath)) {
+    if (fs::is_regular_file (filepath)) {
+      filesize = fs::file_size (filepath);
+      lastwritetime = fs_timestamp (filepath);
     }
   } else {
-    LOG(message_group::Warning, loc, parameters.documentRoot(), "Can't open DXF file '%1$s'!", rawFilename);
-    return Value::undefined.clone();
+    LOG (message_group::Warning, loc, parameters.documentRoot (), "Can't open DXF file '%1$s'!", rawFilename);
+    return Value::undefined.clone ();
   }
-  const std::string key = STR(filename, "|", layername, "|", name, "|", xorigin,
-                              "|", yorigin, "|", scale, "|", lastwritetime,
-                              "|", filesize);
-  auto result = dxf_dim_cache.find(key);
-  if (result != dxf_dim_cache.end()) return {result->second};
-  handle_dep(filepath.string());
-  DxfData dxf(36, 0, 0, filename, layername, xorigin, yorigin, scale);
-
-  for (auto& dim : dxf.dims) {
-    if (!name.empty() && dim.name != name) continue;
+  const std::string key = STR (filename, "|", layername, "|", name, "|", xorigin,
+                               "|", yorigin, "|", scale, "|", lastwritetime,
+                               "|", filesize);
+  auto result = dxf_dim_cache.find (key);
+  if (result != dxf_dim_cache.end ())
+    return {result->second};
+  handle_dep (filepath.string ());
+  DxfData dxf (36, 0, 0, filename, layername, xorigin, yorigin, scale);
+
+  for (auto &dim : dxf.dims) {
+    if (!name.empty () && dim.name != name)
+      continue;
 
     DxfData::Dim *d = &dim;
     const int type = d->type & 7;
@@ -104,104 +105,104 @@ static Value builtin_dxf_dim(Arguments arguments, const Location& loc)
       const double x = d->coords[4][0] - d->coords[3][0];
       const double y = d->coords[4][1] - d->coords[3][1];
       const double angle = d->angle;
-      const double distance_projected_on_line = std::fabs(x * cos_degrees(angle) + y * sin_degrees(angle));
-      dxf_dim_cache.emplace(key, distance_projected_on_line);
+      const double distance_projected_on_line = std::fabs (x * cos_degrees (angle) + y * sin_degrees (angle));
+      dxf_dim_cache.emplace (key, distance_projected_on_line);
       return {distance_projected_on_line};
     } else if (type == 1) {
       // Aligned
       const double x = d->coords[4][0] - d->coords[3][0];
       const double y = d->coords[4][1] - d->coords[3][1];
-      const double value = sqrt(x * x + y * y);
-      dxf_dim_cache.emplace(key, value);
+      const double value = sqrt (x * x + y * y);
+      dxf_dim_cache.emplace (key, value);
       return {value};
     } else if (type == 2) {
       // Angular
-      const double a1 = atan2_degrees(d->coords[0][0] - d->coords[5][0], d->coords[0][1] - d->coords[5][1]);
-      const double a2 = atan2_degrees(d->coords[4][0] - d->coords[3][0], d->coords[4][1] - d->coords[3][1]);
-      const double value = std::fabs(a1 - a2);
-      dxf_dim_cache.emplace(key, value);
+      const double a1 = atan2_degrees (d->coords[0][0] - d->coords[5][0], d->coords[0][1] - d->coords[5][1]);
+      const double a2 = atan2_degrees (d->coords[4][0] - d->coords[3][0], d->coords[4][1] - d->coords[3][1]);
+      const double value = std::fabs (a1 - a2);
+      dxf_dim_cache.emplace (key, value);
       return {value};
     } else if (type == 3 || type == 4) {
       // Diameter or Radius
       const double x = d->coords[5][0] - d->coords[0][0];
       const double y = d->coords[5][1] - d->coords[0][1];
-      const double value = sqrt(x * x + y * y);
-      dxf_dim_cache.emplace(key, value);
+      const double value = sqrt (x * x + y * y);
+      dxf_dim_cache.emplace (key, value);
       return {value};
     } else if (type == 5) {
       // Angular 3 Point
     } else if (type == 6) {
       // Ordinate
       const double value = (d->type & 64) ? d->coords[3][0] : d->coords[3][1];
-      dxf_dim_cache.emplace(key, value);
+      dxf_dim_cache.emplace (key, value);
       return {value};
     }
 
-    LOG(message_group::Warning, loc, parameters.documentRoot(), "Dimension '%1$s' in '%2$s', layer '%3$s' has unsupported type!", name, rawFilename, layername);
-    return Value::undefined.clone();
+    LOG (message_group::Warning, loc, parameters.documentRoot (), "Dimension '%1$s' in '%2$s', layer '%3$s' has unsupported type!", name, rawFilename, layername);
+    return Value::undefined.clone ();
   }
 
-  LOG(message_group::Warning, loc, parameters.documentRoot(), "Can't find dimension '%1$s' in '%2$s', layer '%3$s'!", name, rawFilename, layername);
+  LOG (message_group::Warning, loc, parameters.documentRoot (), "Can't find dimension '%1$s' in '%2$s', layer '%3$s'!", name, rawFilename, layername);
 
-  return Value::undefined.clone();
+  return Value::undefined.clone ();
 }
 
-static Value builtin_dxf_cross(Arguments arguments, const Location& loc)
-{
-  auto *session = arguments.session();
-  const Parameters parameters = Parameters::parse(std::move(arguments), loc, {}, {"file", "layer", "origin", "scale", "name"});
+static Value builtin_dxf_cross (Arguments arguments, const Location &loc) {
+  auto *session = arguments.session ();
+  const Parameters parameters = Parameters::parse (std::move (arguments), loc, {}, {"file", "layer", "origin", "scale", "name"});
 
   std::string rawFilename;
   std::string filename;
-  if (parameters.contains("file")) {
-    rawFilename = parameters["file"].toString();
-    filename = lookup_file(rawFilename, loc.filePath().parent_path().string(), parameters.documentRoot());
+  if (parameters.contains ("file")) {
+    rawFilename = parameters["file"].toString ();
+    filename = lookup_file (rawFilename, loc.filePath ().parent_path ().string (), parameters.documentRoot ());
   }
   double xorigin = 0;
   double yorigin = 0;
-  if (parameters.contains("origin")) {
-    bool originOk = parameters["origin"].getVec2(xorigin, yorigin);
-    originOk &= std::isfinite(xorigin) && std::isfinite(yorigin);
+  if (parameters.contains ("origin")) {
+    bool originOk = parameters["origin"].getVec2 (xorigin, yorigin);
+    originOk &= std::isfinite (xorigin) && std::isfinite (yorigin);
     if (!originOk) {
-      LOG(message_group::Warning, loc, parameters.documentRoot(), "dxf_cross(..., origin=%1$s) could not be converted", parameters["origin"].toEchoString());
+      LOG (message_group::Warning, loc, parameters.documentRoot (), "dxf_cross(..., origin=%1$s) could not be converted", parameters["origin"].toEchoString ());
     }
   }
-  std::string layername = parameters.get("layer", "");
-  const double scale = parameters.get("scale", 1);
+  std::string layername = parameters.get ("layer", "");
+  const double scale = parameters.get ("scale", 1);
 
-  const fs::path filepath(filename);
+  const fs::path filepath (filename);
   uintmax_t filesize = -1;
   int64_t lastwritetime = -1;
-  if (fs::exists(filepath)) {
-    if (fs::is_regular_file(filepath)) {
-      filesize = fs::file_size(filepath);
-      lastwritetime = fs_timestamp(filepath);
+  if (fs::exists (filepath)) {
+    if (fs::is_regular_file (filepath)) {
+      filesize = fs::file_size (filepath);
+      lastwritetime = fs_timestamp (filepath);
     }
   } else {
-    LOG(message_group::Warning, loc, parameters.documentRoot(), "Can't open DXF file '%1$s'!", rawFilename);
-    return Value::undefined.clone();
+    LOG (message_group::Warning, loc, parameters.documentRoot (), "Can't open DXF file '%1$s'!", rawFilename);
+    return Value::undefined.clone ();
   }
 
-  const std::string key = STR(filename, "|", layername, "|", xorigin, "|", yorigin,
-                              "|", scale, "|", lastwritetime,
-                              "|", filesize);
+  const std::string key = STR (filename, "|", layername, "|", xorigin, "|", yorigin,
+                               "|", scale, "|", lastwritetime,
+                               "|", filesize);
 
-  auto result = dxf_cross_cache.find(key);
-  if (result != dxf_cross_cache.end()) {
-    VectorType ret(session);
-    ret.reserve(result->second.size());
+  auto result = dxf_cross_cache.find (key);
+  if (result != dxf_cross_cache.end ()) {
+    VectorType ret (session);
+    ret.reserve (result->second.size ());
     for (auto v : result->second) {
-      ret.emplace_back(v);
+      ret.emplace_back (v);
     }
-    return {std::move(ret)};
+    return {std::move (ret)};
   }
-  handle_dep(filepath.string());
-  DxfData dxf(36, 0, 0, filename, layername, xorigin, yorigin, scale);
+  handle_dep (filepath.string ());
+  DxfData dxf (36, 0, 0, filename, layername, xorigin, yorigin, scale);
 
   double coords[4][2];
 
-  for (size_t i = 0, j = 0; i < dxf.paths.size(); ++i) {
-    if (dxf.paths[i].indices.size() != 2) continue;
+  for (size_t i = 0, j = 0; i < dxf.paths.size (); ++i) {
+    if (dxf.paths[i].indices.size () != 2)
+      continue;
     coords[j][0] = dxf.points[dxf.paths[i].indices[0]][0];
     coords[j++][1] = dxf.points[dxf.paths[i].indices[0]][1];
     coords[j][0] = dxf.points[dxf.paths[i].indices[1]][0];
@@ -213,35 +214,35 @@ static Value builtin_dxf_cross(Arguments arguments, const Location& loc)
       const double x3 = coords[2][0], y3 = coords[2][1];
       const double x4 = coords[3][0], y4 = coords[3][1];
       const double dem = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
-      if (dem == 0) break;
+      if (dem == 0)
+        break;
       const double ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / dem;
       // double ub = ((x2 - x1)*(y1 - y3) - (y2 - y1)*(x1 - x3)) / dem;
       const double x = x1 + ua * (x2 - x1);
       const double y = y1 + ua * (y2 - y1);
 
       const std::vector<double> value = {x, y};
-      dxf_cross_cache.emplace(key, value);
-      VectorType ret(session);
-      ret.reserve(2);
-      ret.emplace_back(x);
-      ret.emplace_back(y);
-      return {std::move(ret)};
+      dxf_cross_cache.emplace (key, value);
+      VectorType ret (session);
+      ret.reserve (2);
+      ret.emplace_back (x);
+      ret.emplace_back (y);
+      return {std::move (ret)};
     }
   }
 
-  LOG(message_group::Warning, loc, parameters.documentRoot(), "Can't find cross in '%1$s', layer '%2$s'!", rawFilename, layername);
-  return Value::undefined.clone();
+  LOG (message_group::Warning, loc, parameters.documentRoot (), "Can't find cross in '%1$s', layer '%2$s'!", rawFilename, layername);
+  return Value::undefined.clone ();
 }
 
-void initialize_builtin_dxf_dim()
-{
-  Builtins::init("dxf_dim", new BuiltinFunction(&builtin_dxf_dim),
-  {
-    "dxf_dim()",
-  });
-
-  Builtins::init("dxf_cross", new BuiltinFunction(&builtin_dxf_cross),
-  {
-    "dxf_cross()",
-  });
+void initialize_builtin_dxf_dim () {
+  Builtins::init ("dxf_dim", new BuiltinFunction (&builtin_dxf_dim),
+                  {
+                    "dxf_dim()",
+                  });
+
+  Builtins::init ("dxf_cross", new BuiltinFunction (&builtin_dxf_cross),
+                  {
+                    "dxf_cross()",
+                  });
 }
diff --git a/src/io/export.cc b/src/io/export.cc
index 9a3dfd14a..52a201590 100644
--- a/src/io/export.cc
+++ b/src/io/export.cc
@@ -57,9 +57,8 @@
 #include "glview/RenderSettings.h"
 #include "utils/printutils.h"
 
-
-#define QUOTE(x__) # x__
-#define QUOTED(x__) QUOTE(x__)
+#define QUOTE(x__) #x__
+#define QUOTED(x__) QUOTE (x__)
 
 namespace {
 
@@ -68,96 +67,91 @@ struct Containers {
   std::map<FileFormat, FileFormatInfo> fileFormatToInfo;
 };
 
-void add_item(Containers& containers, const FileFormatInfo& info) {
+void add_item (Containers &containers, const FileFormatInfo &info) {
   containers.identifierToInfo[info.identifier] = info;
   containers.fileFormatToInfo[info.format] = info;
 }
 
-Containers& containers() {
-  static std::unique_ptr<Containers> containers = [](){
-      auto containers = std::make_unique<Containers>();
-
-      add_item(*containers, {FileFormat::ASCII_STL, "asciistl", "stl", "STL (ascii)"});
-      add_item(*containers, {FileFormat::BINARY_STL, "binstl", "stl", "STL (binary)"});
-      add_item(*containers, {FileFormat::OBJ, "obj", "obj", "OBJ"});
-      add_item(*containers, {FileFormat::OFF, "off", "off", "OFF"});
-      add_item(*containers, {FileFormat::WRL, "wrl", "wrl", "VRML"});
-      add_item(*containers, {FileFormat::AMF, "amf", "amf", "AMF"});
-      add_item(*containers, {FileFormat::_3MF, "3mf", "3mf", "3MF"});
-      add_item(*containers, {FileFormat::DXF, "dxf", "dxf", "DXF"});
-      add_item(*containers, {FileFormat::SVG, "svg", "svg", "SVG"});
-      add_item(*containers, {FileFormat::NEFDBG, "nefdbg", "nefdbg", "nefdbg"});
-      add_item(*containers, {FileFormat::NEF3, "nef3", "nef3", "nef3"});
-      add_item(*containers, {FileFormat::CSG, "csg", "csg", "CSG"});
-      add_item(*containers, {FileFormat::PARAM, "param", "param", "param"});
-      add_item(*containers, {FileFormat::AST, "ast", "ast", "AST"});
-      add_item(*containers, {FileFormat::TERM, "term", "term", "term"});
-      add_item(*containers, {FileFormat::ECHO, "echo", "echo", "echo"});
-      add_item(*containers, {FileFormat::PNG, "png", "png", "PNG"});
-      add_item(*containers, {FileFormat::PDF, "pdf", "pdf", "PDF"});
-      add_item(*containers, {FileFormat::POV, "pov", "pov", "POV"});
-
-      // Alias
-      containers->identifierToInfo["stl"] = containers->identifierToInfo["asciistl"];
-      return containers;
-    }();
+Containers &containers () {
+  static std::unique_ptr<Containers> containers = [] () {
+    auto containers = std::make_unique<Containers> ();
+
+    add_item (*containers, {FileFormat::ASCII_STL, "asciistl", "stl", "STL (ascii)"});
+    add_item (*containers, {FileFormat::BINARY_STL, "binstl", "stl", "STL (binary)"});
+    add_item (*containers, {FileFormat::OBJ, "obj", "obj", "OBJ"});
+    add_item (*containers, {FileFormat::OFF, "off", "off", "OFF"});
+    add_item (*containers, {FileFormat::WRL, "wrl", "wrl", "VRML"});
+    add_item (*containers, {FileFormat::AMF, "amf", "amf", "AMF"});
+    add_item (*containers, {FileFormat::_3MF, "3mf", "3mf", "3MF"});
+    add_item (*containers, {FileFormat::DXF, "dxf", "dxf", "DXF"});
+    add_item (*containers, {FileFormat::SVG, "svg", "svg", "SVG"});
+    add_item (*containers, {FileFormat::NEFDBG, "nefdbg", "nefdbg", "nefdbg"});
+    add_item (*containers, {FileFormat::NEF3, "nef3", "nef3", "nef3"});
+    add_item (*containers, {FileFormat::CSG, "csg", "csg", "CSG"});
+    add_item (*containers, {FileFormat::PARAM, "param", "param", "param"});
+    add_item (*containers, {FileFormat::AST, "ast", "ast", "AST"});
+    add_item (*containers, {FileFormat::TERM, "term", "term", "term"});
+    add_item (*containers, {FileFormat::ECHO, "echo", "echo", "echo"});
+    add_item (*containers, {FileFormat::PNG, "png", "png", "PNG"});
+    add_item (*containers, {FileFormat::PDF, "pdf", "pdf", "PDF"});
+    add_item (*containers, {FileFormat::POV, "pov", "pov", "POV"});
+
+    // Alias
+    containers->identifierToInfo["stl"] = containers->identifierToInfo["asciistl"];
+    return containers;
+  }();
   return *containers;
 }
 
-}  // namespace
+} // namespace
 
 namespace fileformat {
 
-std::vector<FileFormat> all()
-{
+std::vector<FileFormat> all () {
   std::vector<FileFormat> allFileFormats;
-  for (const auto& item : containers().fileFormatToInfo) {
-    allFileFormats.push_back(item.first);
+  for (const auto &item : containers ().fileFormatToInfo) {
+    allFileFormats.push_back (item.first);
   }
   return allFileFormats;
 }
 
-std::vector<FileFormat> all2D()
-{
+std::vector<FileFormat> all2D () {
   std::vector<FileFormat> all2DFormats;
-  for (const auto& item : containers().fileFormatToInfo) {
-    if (is2D(item.first)) {
-      all2DFormats.push_back(item.first);
+  for (const auto &item : containers ().fileFormatToInfo) {
+    if (is2D (item.first)) {
+      all2DFormats.push_back (item.first);
     }
   }
   return all2DFormats;
 }
 
-std::vector<FileFormat> all3D()
-{
+std::vector<FileFormat> all3D () {
   std::vector<FileFormat> all3DFormats;
-  for (const auto& item : containers().fileFormatToInfo) {
-    if (is3D(item.first)) {
-      all3DFormats.push_back(item.first);
+  for (const auto &item : containers ().fileFormatToInfo) {
+    if (is3D (item.first)) {
+      all3DFormats.push_back (item.first);
     }
   }
   return all3DFormats;
 }
 
-const FileFormatInfo& info(FileFormat fileFormat)
-{
-  return containers().fileFormatToInfo[fileFormat];
+const FileFormatInfo &info (FileFormat fileFormat) {
+  return containers ().fileFormatToInfo[fileFormat];
 }
 
-bool fromIdentifier(const std::string& identifier, FileFormat& format)
-{
-  auto it = containers().identifierToInfo.find(identifier);
-  if (it == containers().identifierToInfo.end()) return false;
+bool fromIdentifier (const std::string &identifier, FileFormat &format) {
+  auto it = containers ().identifierToInfo.find (identifier);
+  if (it == containers ().identifierToInfo.end ())
+    return false;
   format = it->second.format;
   return true;
 }
 
-const std::string& toSuffix(FileFormat format)
-{
-  return containers().fileFormatToInfo[format].suffix;
+const std::string &toSuffix (FileFormat format) {
+  return containers ().fileFormatToInfo[format].suffix;
 }
 
-bool canPreview(FileFormat format) {
+bool canPreview (FileFormat format) {
   return (format == FileFormat::AST ||
           format == FileFormat::CSG ||
           format == FileFormat::PARAM ||
@@ -166,7 +160,7 @@ bool canPreview(FileFormat format) {
           format == FileFormat::PNG);
 }
 
-bool is3D(FileFormat format) {
+bool is3D (FileFormat format) {
   return format == FileFormat::ASCII_STL ||
          format == FileFormat::BINARY_STL ||
          format == FileFormat::OBJ ||
@@ -179,120 +173,116 @@ bool is3D(FileFormat format) {
          format == FileFormat::POV;
 }
 
-bool is2D(FileFormat format) {
+bool is2D (FileFormat format) {
   return format == FileFormat::DXF ||
          format == FileFormat::SVG ||
          format == FileFormat::PDF;
 }
 
-}  // namespace FileFormat
+} // namespace fileformat
 
-ExportInfo createExportInfo(const FileFormat& format, const FileFormatInfo& info, const std::string& filepath, const Camera *camera, const CmdLineExportOptions& cmdLineOptions)
-{
-  const auto colorScheme = ColorMap::inst()->findColorScheme(RenderSettings::inst()->colorscheme);
+ExportInfo createExportInfo (const FileFormat &format, const FileFormatInfo &info, const std::string &filepath, const Camera *camera, const CmdLineExportOptions &cmdLineOptions) {
+  const auto colorScheme = ColorMap::inst ()->findColorScheme (RenderSettings::inst ()->colorscheme);
   auto exportInfo = ExportInfo{
     .format = format,
     .info = info,
-    .title = std::filesystem::path(filepath).filename().string(),
+    .title = std::filesystem::path (filepath).filename ().string (),
     .sourceFilePath = filepath,
     .camera = camera,
-    .defaultColor = ColorMap::getColor(*colorScheme, RenderColor::CGAL_FACE_FRONT_COLOR),
+    .defaultColor = ColorMap::getColor (*colorScheme, RenderColor::CGAL_FACE_FRONT_COLOR),
     .colorScheme = colorScheme,
   };
 
   if (format == FileFormat::_3MF) {
-    exportInfo.options3mf = Export3mfOptions::withOptions(cmdLineOptions);
+    exportInfo.options3mf = Export3mfOptions::withOptions (cmdLineOptions);
   } else if (format == FileFormat::PDF) {
-    exportInfo.optionsPdf = ExportPdfOptions::withOptions(cmdLineOptions);
+    exportInfo.optionsPdf = ExportPdfOptions::withOptions (cmdLineOptions);
   }
 
   return exportInfo;
 }
 
-static void exportFile(const std::shared_ptr<const Geometry>& root_geom, std::ostream& output, const ExportInfo& exportInfo)
-{
+static void exportFile (const std::shared_ptr<const Geometry> &root_geom, std::ostream &output, const ExportInfo &exportInfo) {
   switch (exportInfo.format) {
   case FileFormat::ASCII_STL:
-    export_stl(root_geom, output, false);
+    export_stl (root_geom, output, false);
     break;
   case FileFormat::BINARY_STL:
-    export_stl(root_geom, output, true);
+    export_stl (root_geom, output, true);
     break;
   case FileFormat::OBJ:
-    export_obj(root_geom, output);
+    export_obj (root_geom, output);
     break;
   case FileFormat::OFF:
-    export_off(root_geom, output);
+    export_off (root_geom, output);
     break;
   case FileFormat::WRL:
-    export_wrl(root_geom, output);
+    export_wrl (root_geom, output);
     break;
   case FileFormat::AMF:
-    export_amf(root_geom, output);
+    export_amf (root_geom, output);
     break;
   case FileFormat::_3MF:
-    export_3mf(root_geom, output, exportInfo);
+    export_3mf (root_geom, output, exportInfo);
     break;
   case FileFormat::DXF:
-    export_dxf(root_geom, output);
+    export_dxf (root_geom, output);
     break;
   case FileFormat::SVG:
-    export_svg(root_geom, output);
+    export_svg (root_geom, output);
     break;
   case FileFormat::PDF:
-    export_pdf(root_geom, output, exportInfo);
+    export_pdf (root_geom, output, exportInfo);
     break;
   case FileFormat::POV:
-    export_pov(root_geom, output, exportInfo);
+    export_pov (root_geom, output, exportInfo);
     break;
 #ifdef ENABLE_CGAL
   case FileFormat::NEFDBG:
-    export_nefdbg(root_geom, output);
+    export_nefdbg (root_geom, output);
     break;
   case FileFormat::NEF3:
-    export_nef3(root_geom, output);
+    export_nef3 (root_geom, output);
     break;
 #endif
   default:
-    assert(false && "Unknown file format");
+    assert (false && "Unknown file format");
   }
 }
 
-bool exportFileStdOut(const std::shared_ptr<const Geometry>& root_geom, const ExportInfo& exportInfo)
-{
+bool exportFileStdOut (const std::shared_ptr<const Geometry> &root_geom, const ExportInfo &exportInfo) {
 #ifdef _WIN32
-  _setmode(_fileno(stdout), _O_BINARY);
+  _setmode (_fileno (stdout), _O_BINARY);
 #endif
-  exportFile(root_geom, std::cout, exportInfo);
+  exportFile (root_geom, std::cout, exportInfo);
   return true;
 }
 
-bool exportFileByName(const std::shared_ptr<const Geometry>& root_geom, const std::string& filename, const ExportInfo& exportInfo)
-{
+bool exportFileByName (const std::shared_ptr<const Geometry> &root_geom, const std::string &filename, const ExportInfo &exportInfo) {
   std::ios::openmode mode = std::ios::out | std::ios::trunc;
   if (exportInfo.format == FileFormat::_3MF || exportInfo.format == FileFormat::BINARY_STL || exportInfo.format == FileFormat::PDF) {
     mode |= std::ios::binary;
   }
-  const std::filesystem::path path(filename);
-  std::ofstream fstream(path, mode);
-  if (!fstream.is_open()) {
-    LOG(_("Can't open file \"%1$s\" for export"), filename);
+  const std::filesystem::path path (filename);
+  std::ofstream fstream (path, mode);
+  if (!fstream.is_open ()) {
+    LOG (_ ("Can't open file \"%1$s\" for export"), filename);
     return false;
   } else {
     bool onerror = false;
-    fstream.exceptions(std::ios::badbit | std::ios::failbit);
+    fstream.exceptions (std::ios::badbit | std::ios::failbit);
     try {
-      exportFile(root_geom, fstream, exportInfo);
-    } catch (std::ios::failure&) {
+      exportFile (root_geom, fstream, exportInfo);
+    } catch (std::ios::failure &) {
       onerror = true;
     }
     try { // make sure file closed - resources released
-      fstream.close();
-    } catch (std::ios::failure&) {
+      fstream.close ();
+    } catch (std::ios::failure &) {
       onerror = true;
     }
     if (onerror) {
-      LOG(message_group::Error, _("\"%1$s\" write error. (Disk full?)"), filename);
+      LOG (message_group::Error, _ ("\"%1$s\" write error. (Disk full?)"), filename);
     }
     return !onerror;
   }
@@ -300,15 +290,15 @@ bool exportFileByName(const std::shared_ptr<const Geometry>& root_geom, const st
 
 namespace {
 
-double remove_negative_zero(double x) {
+double remove_negative_zero (double x) {
   return x == -0 ? 0 : x;
 }
 
-Vector3d remove_negative_zero(const Vector3d& pt) {
+Vector3d remove_negative_zero (const Vector3d &pt) {
   return {
-    remove_negative_zero(pt[0]),
-    remove_negative_zero(pt[1]),
-    remove_negative_zero(pt[2]),
+    remove_negative_zero (pt[0]),
+    remove_negative_zero (pt[1]),
+    remove_negative_zero (pt[2]),
   };
 }
 
@@ -316,79 +306,78 @@ Vector3d remove_negative_zero(const Vector3d& pt) {
 // Eigen 3.4.0 added begin()/end()
 struct LexographicLess {
   template <class T>
-  bool operator()(T const& lhs, T const& rhs) const {
-    return std::lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end(), std::less{});
+  bool operator() (T const &lhs, T const &rhs) const {
+    return std::lexicographical_compare (lhs.begin (), lhs.end (), rhs.begin (), rhs.end (), std::less{});
   }
 };
 #else
 struct LexographicLess {
   template <class T>
-  bool operator()(T const& lhs, T const& rhs) const {
-    return std::lexicographical_compare(lhs.data(), lhs.data() + lhs.size(), rhs.data(), rhs.data() + rhs.size(), std::less{});
+  bool operator() (T const &lhs, T const &rhs) const {
+    return std::lexicographical_compare (lhs.data (), lhs.data () + lhs.size (), rhs.data (), rhs.data () + rhs.size (), std::less{});
   }
 };
 #endif // if EIGEN_VERSION_AT_LEAST(3, 4, 0)
 
 } // namespace
 
-std::string get_current_iso8601_date_time_utc() {
-  auto now = std::chrono::system_clock::now();
-  auto time = std::chrono::system_clock::to_time_t(now);
-  return STR(std::put_time(gmtime(&time), "%Y-%m-%dT%H:%M:%SZ")); // %F/%T not fully supported everywhere
+std::string get_current_iso8601_date_time_utc () {
+  auto now = std::chrono::system_clock::now ();
+  auto time = std::chrono::system_clock::to_time_t (now);
+  return STR (std::put_time (gmtime (&time), "%Y-%m-%dT%H:%M:%SZ")); // %F/%T not fully supported everywhere
 }
 
-std::unique_ptr<PolySet> createSortedPolySet(const PolySet& ps)
-{
-  auto out = std::make_unique<PolySet>(ps.getDimension(), ps.convexValue());
-  out->setTriangular(ps.isTriangular());
-  out->setConvexity(ps.getConvexity());
+std::unique_ptr<PolySet> createSortedPolySet (const PolySet &ps) {
+  auto out = std::make_unique<PolySet> (ps.getDimension (), ps.convexValue ());
+  out->setTriangular (ps.isTriangular ());
+  out->setConvexity (ps.getConvexity ());
 
   std::map<Vector3d, int, LexographicLess> vertexMap;
 
-  for (const auto& poly : ps.indices) {
+  for (const auto &poly : ps.indices) {
     IndexedFace face;
     for (const auto idx : poly) {
-      auto pos = vertexMap.emplace(remove_negative_zero(ps.vertices[idx]), vertexMap.size());
-      face.push_back(pos.first->second);
+      auto pos = vertexMap.emplace (remove_negative_zero (ps.vertices[idx]), vertexMap.size ());
+      face.push_back (pos.first->second);
     }
-    out->indices.push_back(face);
+    out->indices.push_back (face);
   }
   out->color_indices = ps.color_indices;
   out->colors = ps.colors;
 
-  std::vector<int> indexTranslationMap(vertexMap.size());
-  out->vertices.reserve(vertexMap.size());
+  std::vector<int> indexTranslationMap (vertexMap.size ());
+  out->vertices.reserve (vertexMap.size ());
 
-  for (const auto& [v, i] : vertexMap) {
-    indexTranslationMap[i] = out->vertices.size();
-    out->vertices.push_back(v);
+  for (const auto &[v, i] : vertexMap) {
+    indexTranslationMap[i] = out->vertices.size ();
+    out->vertices.push_back (v);
   }
 
-  for (auto& poly : out->indices) {
+  for (auto &poly : out->indices) {
     IndexedFace polygon;
     for (const auto idx : poly) {
-      polygon.push_back(indexTranslationMap[idx]);
+      polygon.push_back (indexTranslationMap[idx]);
     }
-    std::rotate(polygon.begin(), std::min_element(polygon.begin(), polygon.end()), polygon.end());
+    std::rotate (polygon.begin (), std::min_element (polygon.begin (), polygon.end ()), polygon.end ());
     poly = polygon;
   }
-  if (ps.color_indices.empty()) {
-    std::sort(out->indices.begin(), out->indices.end());
+  if (ps.color_indices.empty ()) {
+    std::sort (out->indices.begin (), out->indices.end ());
   } else {
     struct ColoredFace {
       IndexedFace face;
       int32_t color_index;
     };
     std::vector<ColoredFace> faces;
-    faces.reserve(ps.indices.size());
-    for (size_t i = 0, n = ps.indices.size(); i < n; i++) {
-      faces.push_back({out->indices[i], out->color_indices[i]});
+    faces.reserve (ps.indices.size ());
+    for (size_t i = 0, n = ps.indices.size (); i < n; i++) {
+      faces.push_back ({out->indices[i], out->color_indices[i]});
     }
-    std::sort(faces.begin(), faces.end(), [](const ColoredFace& a, const ColoredFace& b) {
+    std::sort (faces.begin (), faces.end (), [] (const ColoredFace &a, const ColoredFace &b) {
       return a.face < b.face;
     });
-    for (size_t i = 0, n = faces.size(); i < n; i++) {
-      auto& face = faces[i];
+    for (size_t i = 0, n = faces.size (); i < n; i++) {
+      auto &face = faces[i];
       out->indices[i] = face.face;
       out->color_indices[i] = face.color_index;
     }
diff --git a/src/io/export.h b/src/io/export.h
index 7b4086e92..5ff323975 100644
--- a/src/io/export.h
+++ b/src/io/export.h
@@ -59,34 +59,33 @@ constexpr inline auto EXPORT_CREATOR = "OpenSCAD (https://www.openscad.org/)";
 
 namespace fileformat {
 
-std::vector<FileFormat> all();
-std::vector<FileFormat> all2D();
-std::vector<FileFormat> all3D();
+std::vector<FileFormat> all ();
+std::vector<FileFormat> all2D ();
+std::vector<FileFormat> all3D ();
 
-const FileFormatInfo& info(FileFormat fileFormat);
-bool fromIdentifier(const std::string& identifier, FileFormat& format);
-const std::string& toSuffix(FileFormat format);
-bool canPreview(FileFormat format);
-bool is3D(FileFormat format);
-bool is2D(FileFormat format);
+const FileFormatInfo &info (FileFormat fileFormat);
+bool fromIdentifier (const std::string &identifier, FileFormat &format);
+const std::string &toSuffix (FileFormat format);
+bool canPreview (FileFormat format);
+bool is3D (FileFormat format);
+bool is2D (FileFormat format);
 
-}  // namespace FileFormat
+} // namespace fileformat
 
 using CmdLineExportOptions = std::unordered_map<std::string, std::unordered_map<std::string, std::string>>;
 
 template <typename settings_entry_type>
-auto set_cmd_line_option(const CmdLineExportOptions& cmdLineOptions, const std::string& section, const settings_entry_type& se)
-{
-  if (cmdLineOptions.count(section) == 0) {
-    return se.defaultValue();
+auto set_cmd_line_option (const CmdLineExportOptions &cmdLineOptions, const std::string &section, const settings_entry_type &se) {
+  if (cmdLineOptions.count (section) == 0) {
+    return se.defaultValue ();
   }
 
-  const auto& o = cmdLineOptions.at(section);
-  if (o.count(se.name()) == 0) {
-    return se.defaultValue();
+  const auto &o = cmdLineOptions.at (section);
+  if (o.count (se.name ()) == 0) {
+    return se.defaultValue ();
   }
 
-  return se.decode(o.at(se.name()));
+  return se.decode (o.at (se.name ()));
 }
 
 // include defaults to use without dialog or direction.
@@ -99,7 +98,7 @@ struct ExportPdfOptions {
   bool showDesignFilename = false;
   ExportPdfPaperOrientation orientation = ExportPdfPaperOrientation::PORTRAIT;
   ExportPdfPaperSize paperSize = ExportPdfPaperSize::A4;
-  bool addMetaData = SPDF::exportPdfAddMetaData.defaultValue();
+  bool addMetaData = SPDF::exportPdfAddMetaData.defaultValue ();
   std::string metaDataTitle;
   std::string metaDataAuthor;
   std::string metaDataSubject;
@@ -110,47 +109,47 @@ struct ExportPdfOptions {
   std::string strokeColor = "black";
   double strokeWidth = 1;
 
-  static std::shared_ptr<const ExportPdfOptions> withOptions(const CmdLineExportOptions& cmdLineOptions) {
-    return std::make_shared<const ExportPdfOptions>(ExportPdfOptions{
-      .showScale = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfShowScale),
-      .showScaleMsg = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfShowScaleMessage),
-      .showGrid = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfShowGrid),
-      .gridSize = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfGridSize),
-      .showDesignFilename = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfShowFilename),
-      .orientation = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfOrientation),
-      .paperSize = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfPaperSize),
-      .addMetaData = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfAddMetaData),
-      .metaDataTitle = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfMetaDataTitle),
-      .metaDataAuthor = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfMetaDataAuthor),
-      .metaDataSubject = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfMetaDataSubject),
-      .metaDataKeywords = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfMetaDataKeywords),
-      .fill = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfFill),
-      .fillColor = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfFillColor),
-      .stroke = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfStroke),
-      .strokeColor = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfStrokeColor),
-      .strokeWidth = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfStrokeWidth),
+  static std::shared_ptr<const ExportPdfOptions> withOptions (const CmdLineExportOptions &cmdLineOptions) {
+    return std::make_shared<const ExportPdfOptions> (ExportPdfOptions{
+      .showScale = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfShowScale),
+      .showScaleMsg = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfShowScaleMessage),
+      .showGrid = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfShowGrid),
+      .gridSize = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfGridSize),
+      .showDesignFilename = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfShowFilename),
+      .orientation = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfOrientation),
+      .paperSize = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfPaperSize),
+      .addMetaData = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfAddMetaData),
+      .metaDataTitle = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfMetaDataTitle),
+      .metaDataAuthor = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfMetaDataAuthor),
+      .metaDataSubject = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfMetaDataSubject),
+      .metaDataKeywords = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfMetaDataKeywords),
+      .fill = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfFill),
+      .fillColor = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfFillColor),
+      .stroke = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfStroke),
+      .strokeColor = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfStrokeColor),
+      .strokeWidth = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfStrokeWidth),
     });
   }
 
-  static const std::shared_ptr<const ExportPdfOptions> fromSettings() {
-    return std::make_shared<const ExportPdfOptions>(ExportPdfOptions{
-      .showScale = SPDF::exportPdfShowScale.value(),
-      .showScaleMsg = SPDF::exportPdfShowScaleMessage.value(),
-      .showGrid = SPDF::exportPdfShowGrid.value(),
-      .gridSize = SPDF::exportPdfGridSize.value(),
-      .showDesignFilename = SPDF::exportPdfShowFilename.value(),
-      .orientation = SPDF::exportPdfOrientation.value(),
-      .paperSize = SPDF::exportPdfPaperSize.value(),
-      .addMetaData = SPDF::exportPdfAddMetaData.value(),
-      .metaDataTitle = SPDF::exportPdfMetaDataTitle.value(),
-      .metaDataAuthor = SPDF::exportPdfAddMetaDataAuthor.value() ? SPDF::exportPdfMetaDataAuthor.value() : "",
-      .metaDataSubject = SPDF::exportPdfAddMetaDataSubject.value() ? SPDF::exportPdfMetaDataSubject.value() : "",
-      .metaDataKeywords = SPDF::exportPdfAddMetaDataKeywords.value() ? SPDF::exportPdfMetaDataKeywords.value() : "",
-      .fill = SPDF::exportPdfFill.value(),
-      .fillColor = SPDF::exportPdfFillColor.value(),
-      .stroke = SPDF::exportPdfStroke.value(),
-      .strokeColor = SPDF::exportPdfStrokeColor.value(),
-      .strokeWidth = SPDF::exportPdfStrokeWidth.value(),
+  static const std::shared_ptr<const ExportPdfOptions> fromSettings () {
+    return std::make_shared<const ExportPdfOptions> (ExportPdfOptions{
+      .showScale = SPDF::exportPdfShowScale.value (),
+      .showScaleMsg = SPDF::exportPdfShowScaleMessage.value (),
+      .showGrid = SPDF::exportPdfShowGrid.value (),
+      .gridSize = SPDF::exportPdfGridSize.value (),
+      .showDesignFilename = SPDF::exportPdfShowFilename.value (),
+      .orientation = SPDF::exportPdfOrientation.value (),
+      .paperSize = SPDF::exportPdfPaperSize.value (),
+      .addMetaData = SPDF::exportPdfAddMetaData.value (),
+      .metaDataTitle = SPDF::exportPdfMetaDataTitle.value (),
+      .metaDataAuthor = SPDF::exportPdfAddMetaDataAuthor.value () ? SPDF::exportPdfMetaDataAuthor.value () : "",
+      .metaDataSubject = SPDF::exportPdfAddMetaDataSubject.value () ? SPDF::exportPdfMetaDataSubject.value () : "",
+      .metaDataKeywords = SPDF::exportPdfAddMetaDataKeywords.value () ? SPDF::exportPdfMetaDataKeywords.value () : "",
+      .fill = SPDF::exportPdfFill.value (),
+      .fillColor = SPDF::exportPdfFillColor.value (),
+      .stroke = SPDF::exportPdfStroke.value (),
+      .strokeColor = SPDF::exportPdfStrokeColor.value (),
+      .strokeWidth = SPDF::exportPdfStrokeWidth.value (),
     });
   }
 };
@@ -169,37 +168,37 @@ struct Export3mfOptions {
   std::string metaDataLicenseTerms;
   std::string metaDataRating;
 
-  static const std::shared_ptr<const Export3mfOptions> withOptions(const CmdLineExportOptions& cmdLineOptions) {
-    return std::make_shared<const Export3mfOptions>(Export3mfOptions{
-      .colorMode = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfColorMode),
-      .unit = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfUnit),
-      .color = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfColor),
-      .materialType = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfMaterialType),
-      .decimalPrecision = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfDecimalPrecision),
-      .addMetaData = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfAddMetaData),
-      .metaDataTitle = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfMetaDataTitle),
-      .metaDataDesigner = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfMetaDataDesigner),
-      .metaDataDescription = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfMetaDataDescription),
-      .metaDataCopyright = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfMetaDataCopyright),
-      .metaDataLicenseTerms = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfMetaDataLicenseTerms),
-      .metaDataRating = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfMetaDataRating),
+  static const std::shared_ptr<const Export3mfOptions> withOptions (const CmdLineExportOptions &cmdLineOptions) {
+    return std::make_shared<const Export3mfOptions> (Export3mfOptions{
+      .colorMode = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfColorMode),
+      .unit = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfUnit),
+      .color = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfColor),
+      .materialType = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfMaterialType),
+      .decimalPrecision = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfDecimalPrecision),
+      .addMetaData = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfAddMetaData),
+      .metaDataTitle = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfMetaDataTitle),
+      .metaDataDesigner = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfMetaDataDesigner),
+      .metaDataDescription = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfMetaDataDescription),
+      .metaDataCopyright = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfMetaDataCopyright),
+      .metaDataLicenseTerms = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfMetaDataLicenseTerms),
+      .metaDataRating = set_cmd_line_option (cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfMetaDataRating),
     });
   }
 
-  static const std::shared_ptr<const Export3mfOptions> fromSettings() {
-    return std::make_shared<const Export3mfOptions>(Export3mfOptions{
-      .colorMode = S3MF::export3mfColorMode.value(),
-      .unit = S3MF::export3mfUnit.value(),
-      .color = S3MF::export3mfColor.value(),
-      .materialType = S3MF::export3mfMaterialType.value(),
-      .decimalPrecision = S3MF::export3mfDecimalPrecision.value(),
-      .addMetaData = S3MF::export3mfAddMetaData.value(),
-      .metaDataTitle = S3MF::export3mfMetaDataTitle.value(),
-      .metaDataDesigner = S3MF::export3mfAddMetaDataDesigner.value() ? S3MF::export3mfMetaDataDesigner.value() : "",
-      .metaDataDescription = S3MF::export3mfAddMetaDataDescription.value() ? S3MF::export3mfMetaDataDescription.value() : "",
-      .metaDataCopyright = S3MF::export3mfAddMetaDataCopyright.value() ? S3MF::export3mfMetaDataCopyright.value() : "",
-      .metaDataLicenseTerms = S3MF::export3mfAddMetaDataLicenseTerms.value() ? S3MF::export3mfMetaDataLicenseTerms.value() : "",
-      .metaDataRating = S3MF::export3mfAddMetaDataRating.value() ? S3MF::export3mfMetaDataRating.value() : "",
+  static const std::shared_ptr<const Export3mfOptions> fromSettings () {
+    return std::make_shared<const Export3mfOptions> (Export3mfOptions{
+      .colorMode = S3MF::export3mfColorMode.value (),
+      .unit = S3MF::export3mfUnit.value (),
+      .color = S3MF::export3mfColor.value (),
+      .materialType = S3MF::export3mfMaterialType.value (),
+      .decimalPrecision = S3MF::export3mfDecimalPrecision.value (),
+      .addMetaData = S3MF::export3mfAddMetaData.value (),
+      .metaDataTitle = S3MF::export3mfMetaDataTitle.value (),
+      .metaDataDesigner = S3MF::export3mfAddMetaDataDesigner.value () ? S3MF::export3mfMetaDataDesigner.value () : "",
+      .metaDataDescription = S3MF::export3mfAddMetaDataDescription.value () ? S3MF::export3mfMetaDataDescription.value () : "",
+      .metaDataCopyright = S3MF::export3mfAddMetaDataCopyright.value () ? S3MF::export3mfMetaDataCopyright.value () : "",
+      .metaDataLicenseTerms = S3MF::export3mfAddMetaDataLicenseTerms.value () ? S3MF::export3mfMetaDataLicenseTerms.value () : "",
+      .metaDataRating = S3MF::export3mfAddMetaDataRating.value () ? S3MF::export3mfMetaDataRating.value () : "",
     });
   }
 };
@@ -217,32 +216,35 @@ struct ExportInfo {
   std::shared_ptr<const Export3mfOptions> options3mf;
 };
 
-ExportInfo createExportInfo(const FileFormat& format, const FileFormatInfo& info, const std::string& filepath, const Camera *camera, const CmdLineExportOptions& cmdLineOptions);
-
-bool exportFileByName(const std::shared_ptr<const class Geometry>& root_geom, const std::string& filename, const ExportInfo& exportInfo);
-bool exportFileStdOut(const std::shared_ptr<const class Geometry>& root_geom, const ExportInfo& exportInfo);
-
-void export_stl(const std::shared_ptr<const Geometry>& geom, std::ostream& output,
-                bool binary = true);
-void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& output, const ExportInfo& exportInfo);
-void export_obj(const std::shared_ptr<const Geometry>& geom, std::ostream& output);
-void export_off(const std::shared_ptr<const Geometry>& geom, std::ostream& output);
-void export_wrl(const std::shared_ptr<const Geometry>& geom, std::ostream& output);
-void export_amf(const std::shared_ptr<const Geometry>& geom, std::ostream& output);
-void export_dxf(const std::shared_ptr<const Geometry>& geom, std::ostream& output);
-void export_svg(const std::shared_ptr<const Geometry>& geom, std::ostream& output);
-void export_pov(const std::shared_ptr<const Geometry>& geom, std::ostream& output, const ExportInfo& exportInfo);
-void export_pdf(const std::shared_ptr<const Geometry>& geom, std::ostream& output, const ExportInfo& exportInfo);
-void export_nefdbg(const std::shared_ptr<const Geometry>& geom, std::ostream& output);
-void export_nef3(const std::shared_ptr<const Geometry>& geom, std::ostream& output);
-
-
-enum class Previewer { OPENCSG, THROWNTOGETHER };
-enum class RenderType { GEOMETRY, BACKEND_SPECIFIC, OPENCSG, THROWNTOGETHER };
+ExportInfo createExportInfo (const FileFormat &format, const FileFormatInfo &info, const std::string &filepath, const Camera *camera, const CmdLineExportOptions &cmdLineOptions);
+
+bool exportFileByName (const std::shared_ptr<const class Geometry> &root_geom, const std::string &filename, const ExportInfo &exportInfo);
+bool exportFileStdOut (const std::shared_ptr<const class Geometry> &root_geom, const ExportInfo &exportInfo);
+
+void export_stl (const std::shared_ptr<const Geometry> &geom, std::ostream &output,
+                 bool binary = true);
+void export_3mf (const std::shared_ptr<const Geometry> &geom, std::ostream &output, const ExportInfo &exportInfo);
+void export_obj (const std::shared_ptr<const Geometry> &geom, std::ostream &output);
+void export_off (const std::shared_ptr<const Geometry> &geom, std::ostream &output);
+void export_wrl (const std::shared_ptr<const Geometry> &geom, std::ostream &output);
+void export_amf (const std::shared_ptr<const Geometry> &geom, std::ostream &output);
+void export_dxf (const std::shared_ptr<const Geometry> &geom, std::ostream &output);
+void export_svg (const std::shared_ptr<const Geometry> &geom, std::ostream &output);
+void export_pov (const std::shared_ptr<const Geometry> &geom, std::ostream &output, const ExportInfo &exportInfo);
+void export_pdf (const std::shared_ptr<const Geometry> &geom, std::ostream &output, const ExportInfo &exportInfo);
+void export_nefdbg (const std::shared_ptr<const Geometry> &geom, std::ostream &output);
+void export_nef3 (const std::shared_ptr<const Geometry> &geom, std::ostream &output);
+
+enum class Previewer { OPENCSG,
+                       THROWNTOGETHER };
+enum class RenderType { GEOMETRY,
+                        BACKEND_SPECIFIC,
+                        OPENCSG,
+                        THROWNTOGETHER };
 
 struct ViewOption {
   const std::string name;
-  bool& value;
+  bool &value;
 };
 
 struct ViewOptions {
@@ -256,29 +258,28 @@ struct ViewOptions {
     {"crosshairs", false},
   };
 
-  const std::vector<std::string> names() {
+  const std::vector<std::string> names () {
     std::vector<std::string> names;
-    boost::copy(flags | boost::adaptors::map_keys, std::back_inserter(names));
+    boost::copy (flags | boost::adaptors::map_keys, std::back_inserter (names));
     return names;
   }
 
-  bool& operator[](const std::string& name) {
-    return flags.at(name);
+  bool &operator[] (const std::string &name) {
+    return flags.at (name);
   }
 
-  bool operator[](const std::string& name) const {
-    return flags.at(name);
+  bool operator[] (const std::string &name) const {
+    return flags.at (name);
   }
-
 };
 
 class OffscreenView;
 
-std::string get_current_iso8601_date_time_utc();
+std::string get_current_iso8601_date_time_utc ();
 
-std::unique_ptr<OffscreenView> prepare_preview(Tree& tree, const ViewOptions& options, Camera& camera);
-bool export_png(const std::shared_ptr<const class Geometry>& root_geom, const ViewOptions& options, Camera& camera, std::ostream& output);
-bool export_png(const OffscreenView& glview, std::ostream& output);
-bool export_param(SourceFile *root, const fs::path& path, std::ostream& output);
+std::unique_ptr<OffscreenView> prepare_preview (Tree &tree, const ViewOptions &options, Camera &camera);
+bool export_png (const std::shared_ptr<const class Geometry> &root_geom, const ViewOptions &options, Camera &camera, std::ostream &output);
+bool export_png (const OffscreenView &glview, std::ostream &output);
+bool export_param (SourceFile *root, const fs::path &path, std::ostream &output);
 
-std::unique_ptr<PolySet> createSortedPolySet(const PolySet& ps);
+std::unique_ptr<PolySet> createSortedPolySet (const PolySet &ps);
diff --git a/src/io/export_3mf_dummy.cc b/src/io/export_3mf_dummy.cc
index 50580be45..a467f9d53 100644
--- a/src/io/export_3mf_dummy.cc
+++ b/src/io/export_3mf_dummy.cc
@@ -30,7 +30,6 @@
 #include "geometry/Geometry.h"
 #include "utils/printutils.h"
 
-void export_3mf(const std::shared_ptr<const class Geometry>&, std::ostream&, const ExportInfo&)
-{
-  LOG("Export to 3MF format was not enabled when building the application.");
+void export_3mf (const std::shared_ptr<const class Geometry> &, std::ostream &, const ExportInfo &) {
+  LOG ("Export to 3MF format was not enabled when building the application.");
 }
diff --git a/src/io/export_3mf_v1.cc b/src/io/export_3mf_v1.cc
index 94191757b..dcef22231 100644
--- a/src/io/export_3mf_v1.cc
+++ b/src/io/export_3mf_v1.cc
@@ -69,41 +69,38 @@ struct ExportContext {
   Color4f defaultColor;
   DWORD defaultColorId = 0;
   std::vector<DWORD> materialids;
-  const ExportInfo& info;
+  const ExportInfo &info;
   const std::shared_ptr<const Export3mfOptions> options;
 };
 
-uint32_t lib3mf_write_callback(const char *data, uint32_t bytes, std::ostream *stream)
-{
-  stream->write(data, bytes);
+uint32_t lib3mf_write_callback (const char *data, uint32_t bytes, std::ostream *stream) {
+  stream->write (data, bytes);
   return !(*stream);
 }
 
-uint32_t lib3mf_seek_callback(uint64_t pos, std::ostream *stream)
-{
-  stream->seekp(pos);
+uint32_t lib3mf_seek_callback (uint64_t pos, std::ostream *stream) {
+  stream->seekp (pos);
   return !(*stream);
 }
 
-void export_3mf_error(std::string msg, PLib3MFModel *& model)
-{
-  LOG(message_group::Export_Error, std::move(msg));
+void export_3mf_error (std::string msg, PLib3MFModel *&model) {
+  LOG (message_group::Export_Error, std::move (msg));
   if (model) {
-    lib3mf_release(model);
+    lib3mf_release (model);
     model = nullptr;
   }
 }
 
-int count_mesh_objects(PLib3MFModel *& model) {
+int count_mesh_objects (PLib3MFModel *&model) {
   PLib3MFModelResourceIterator *it;
-  if (lib3mf_model_getmeshobjects(model, &it) != LIB3MF_OK) {
+  if (lib3mf_model_getmeshobjects (model, &it) != LIB3MF_OK) {
     return 0;
   }
 
   BOOL hasNext;
   int count = 0;
   while (true) {
-    if (lib3mf_resourceiterator_movenext(it, &hasNext) != LIB3MF_OK) {
+    if (lib3mf_resourceiterator_movenext (it, &hasNext) != LIB3MF_OK) {
       return 0;
     }
     if (!hasNext) {
@@ -115,12 +112,11 @@ int count_mesh_objects(PLib3MFModel *& model) {
   return count;
 }
 
-bool handle_triangle_color(PLib3MFPropertyHandler *propertyhandler, const std::unique_ptr<PolySet>& ps, int triangle_index, int color_index, ExportContext& ctx)
-{
+bool handle_triangle_color (PLib3MFPropertyHandler *propertyhandler, const std::unique_ptr<PolySet> &ps, int triangle_index, int color_index, ExportContext &ctx) {
   if (color_index < 0) {
     return true;
   }
-  if (ps->colors.empty()) {
+  if (ps->colors.empty ()) {
     return true;
   }
   if (!ctx.basematerial && !ctx.usecolors) {
@@ -131,14 +127,14 @@ bool handle_triangle_color(PLib3MFPropertyHandler *propertyhandler, const std::u
   }
 
   if (ctx.basematerial) {
-    if (lib3mf_propertyhandler_setbasematerial(propertyhandler, triangle_index, ctx.basematerialid, ctx.materialids[color_index]) != LIB3MF_OK) {
-      export_3mf_error("Can't set triangle base material.", ctx.model);
+    if (lib3mf_propertyhandler_setbasematerial (propertyhandler, triangle_index, ctx.basematerialid, ctx.materialids[color_index]) != LIB3MF_OK) {
+      export_3mf_error ("Can't set triangle base material.", ctx.model);
       return false;
     }
   } else if (ctx.usecolors) {
-    const auto& col = ps->colors[color_index];
-    if (lib3mf_propertyhandler_setsinglecolorfloatrgba(propertyhandler, triangle_index, col.r(), col.g(), col.b(), col.a()) != LIB3MF_OK) {
-      export_3mf_error("Can't set triangle color.", ctx.model);
+    const auto &col = ps->colors[color_index];
+    if (lib3mf_propertyhandler_setsinglecolorfloatrgba (propertyhandler, triangle_index, col.r (), col.g (), col.b (), col.a ()) != LIB3MF_OK) {
+      export_3mf_error ("Can't set triangle color.", ctx.model);
       return false;
     }
   }
@@ -146,15 +142,13 @@ bool handle_triangle_color(PLib3MFPropertyHandler *propertyhandler, const std::u
   return true;
 }
 
-
 /*
  * PolySet must be triangulated.
  */
-bool append_polyset(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx)
-{
+bool append_polyset (const std::shared_ptr<const PolySet> &ps, ExportContext &ctx) {
   PLib3MFModelMeshObject *mesh = nullptr;
-  if (lib3mf_model_addmeshobject(ctx.model, &mesh) != LIB3MF_OK) {
-    export_3mf_error("Can't add mesh to 3MF model.", ctx.model);
+  if (lib3mf_model_addmeshobject (ctx.model, &mesh) != LIB3MF_OK) {
+    export_3mf_error ("Can't add mesh to 3MF model.", ctx.model);
     return false;
   }
 
@@ -162,53 +156,53 @@ bool append_polyset(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx
   std::string partname = "";
 
   if (ctx.modelcount > 1) {
-    int mesh_count = count_mesh_objects(ctx.model);
-    name += " " + std::to_string(mesh_count);
-    partname += "Part " + std::to_string(mesh_count);
+    int mesh_count = count_mesh_objects (ctx.model);
+    name += " " + std::to_string (mesh_count);
+    partname += "Part " + std::to_string (mesh_count);
   }
-  if (lib3mf_object_setnameutf8(mesh, name.c_str()) != LIB3MF_OK) {
-    export_3mf_error("Can't set name for 3MF model.", ctx.model);
+  if (lib3mf_object_setnameutf8 (mesh, name.c_str ()) != LIB3MF_OK) {
+    export_3mf_error ("Can't set name for 3MF model.", ctx.model);
     return false;
   }
 
-  auto vertexFunc = [&](const Vector3d& coords) -> bool {
-      const auto f = coords.cast<float>();
-      MODELMESHVERTEX v{f[0], f[1], f[2]};
-      return lib3mf_meshobject_addvertex(mesh, &v, nullptr) == LIB3MF_OK;
-    };
+  auto vertexFunc = [&] (const Vector3d &coords) -> bool {
+    const auto f = coords.cast<float> ();
+    MODELMESHVERTEX v{f[0], f[1], f[2]};
+    return lib3mf_meshobject_addvertex (mesh, &v, nullptr) == LIB3MF_OK;
+  };
 
-  auto triangleFunc = [&](const IndexedFace& indices) -> bool {
-      MODELMESHTRIANGLE t{(DWORD)indices[0], (DWORD)indices[1], (DWORD)indices[2]};
-      return lib3mf_meshobject_addtriangle(mesh, &t, nullptr) == LIB3MF_OK;
-    };
+  auto triangleFunc = [&] (const IndexedFace &indices) -> bool {
+    MODELMESHTRIANGLE t{(DWORD)indices[0], (DWORD)indices[1], (DWORD)indices[2]};
+    return lib3mf_meshobject_addtriangle (mesh, &t, nullptr) == LIB3MF_OK;
+  };
 
-  auto materialFunc = [&](int idx, const Color4f& col) -> DWORD {
-      const auto colname = "Color " + std::to_string(idx);
+  auto materialFunc = [&] (int idx, const Color4f &col) -> DWORD {
+    const auto colname = "Color " + std::to_string (idx);
 
-      DWORD id = 0;
-      uint8_t r, g, b, a;
-      if (!col.getRgba(r, g, b, a)) {
-        LOG(message_group::Warning, "Invalid color in 3MF export");
-      }
-      lib3mf_basematerial_addmaterialutf8(ctx.basematerial,
-                                          colname.c_str(),
-                                          r, g, b,
-                                          &id);
-      return id;
-    };
-
-  auto sorted_ps = createSortedPolySet(*ps);
-
-  for (const auto& v : sorted_ps->vertices) {
-    if (!vertexFunc(v)) {
-      export_3mf_error("Can't add vertex to 3MF model.", ctx.model);
+    DWORD id = 0;
+    uint8_t r, g, b, a;
+    if (!col.getRgba (r, g, b, a)) {
+      LOG (message_group::Warning, "Invalid color in 3MF export");
+    }
+    lib3mf_basematerial_addmaterialutf8 (ctx.basematerial,
+                                         colname.c_str (),
+                                         r, g, b,
+                                         &id);
+    return id;
+  };
+
+  auto sorted_ps = createSortedPolySet (*ps);
+
+  for (const auto &v : sorted_ps->vertices) {
+    if (!vertexFunc (v)) {
+      export_3mf_error ("Can't add vertex to 3MF model.", ctx.model);
       return false;
     }
   }
 
-  for (const auto& poly : sorted_ps->indices) {
-    if (!triangleFunc(poly)) {
-      export_3mf_error("Can't add triangle to 3MF model.", ctx.model);
+  for (const auto &poly : sorted_ps->indices) {
+    if (!triangleFunc (poly)) {
+      export_3mf_error ("Can't add triangle to 3MF model.", ctx.model);
       return false;
     }
   }
@@ -216,11 +210,11 @@ bool append_polyset(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx
   DWORD materials = 0;
   if (ctx.basematerial) {
     PLib3MFModelResourceIterator *it;
-    if (lib3mf_model_getbasematerials(ctx.model, &it) == LIB3MF_OK) {
+    if (lib3mf_model_getbasematerials (ctx.model, &it) == LIB3MF_OK) {
       while (true) {
         BOOL hasNext = false;
-        if (lib3mf_resourceiterator_movenext(it, &hasNext) != LIB3MF_OK) {
-          export_3mf_error("Can't move to next base material iterator value.", ctx.model);
+        if (lib3mf_resourceiterator_movenext (it, &hasNext) != LIB3MF_OK) {
+          export_3mf_error ("Can't move to next base material iterator value.", ctx.model);
           return false;
         }
         if (!hasNext) {
@@ -228,127 +222,125 @@ bool append_polyset(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx
         }
 
         PLib3MFModelResource *resource = nullptr;
-        if (lib3mf_resourceiterator_getcurrent(it, &resource) != LIB3MF_OK) {
-          export_3mf_error("Can't get current value from base material iterator.", ctx.model);
+        if (lib3mf_resourceiterator_getcurrent (it, &resource) != LIB3MF_OK) {
+          export_3mf_error ("Can't get current value from base material iterator.", ctx.model);
           return false;
         } else {
           DWORD count = 0;
-          lib3mf_basematerial_getcount(resource, &count);
+          lib3mf_basematerial_getcount (resource, &count);
           materials = count;
         }
       }
     }
 
-    ctx.materialids.reserve(sorted_ps->colors.size());
-    for (int i = 0; i < sorted_ps->colors.size(); i++) {
-      ctx.materialids.push_back(materialFunc(materials + i, sorted_ps->colors[i]));
+    ctx.materialids.reserve (sorted_ps->colors.size ());
+    for (int i = 0; i < sorted_ps->colors.size (); i++) {
+      ctx.materialids.push_back (materialFunc (materials + i, sorted_ps->colors[i]));
     }
   }
 
   PLib3MFPropertyHandler *propertyhandler = nullptr;
-  if (lib3mf_meshobject_createpropertyhandler(mesh, &propertyhandler) != LIB3MF_OK) {
-    export_3mf_error("Can't create property handler for 3MF model.", ctx.model);
+  if (lib3mf_meshobject_createpropertyhandler (mesh, &propertyhandler) != LIB3MF_OK) {
+    export_3mf_error ("Can't create property handler for 3MF model.", ctx.model);
     return false;
   }
 
-  for (int i = 0; i < sorted_ps->color_indices.size(); ++i) {
+  for (int i = 0; i < sorted_ps->color_indices.size (); ++i) {
     const int32_t idx = sorted_ps->color_indices[i];
-    if (!handle_triangle_color(propertyhandler, sorted_ps, i, idx, ctx)) {
+    if (!handle_triangle_color (propertyhandler, sorted_ps, i, idx, ctx)) {
       return false;
     }
   }
 
-  lib3mf_release(propertyhandler);
+  lib3mf_release (propertyhandler);
 
   PLib3MFPropertyHandler *defaultpropertyhandler = nullptr;
-  if (lib3mf_object_createdefaultpropertyhandler(mesh, &defaultpropertyhandler) != LIB3MF_OK) {
-    export_3mf_error("Can't create default property handler for 3MF model.", ctx.model);
+  if (lib3mf_object_createdefaultpropertyhandler (mesh, &defaultpropertyhandler) != LIB3MF_OK) {
+    export_3mf_error ("Can't create default property handler for 3MF model.", ctx.model);
     return false;
   }
 
   if (ctx.basematerial) {
-    lib3mf_defaultpropertyhandler_setbasematerial(defaultpropertyhandler, ctx.basematerialid, ctx.defaultColorId);
+    lib3mf_defaultpropertyhandler_setbasematerial (defaultpropertyhandler, ctx.basematerialid, ctx.defaultColorId);
   } else if (ctx.usecolors) {
     uint8_t r, g, b, a;
-    if (!ctx.defaultColor.getRgba(r, g, b, a)) {
-      LOG(message_group::Warning, "Invalid color in 3MF export");
+    if (!ctx.defaultColor.getRgba (r, g, b, a)) {
+      LOG (message_group::Warning, "Invalid color in 3MF export");
     }
-    lib3mf_defaultpropertyhandler_setcolorrgba(defaultpropertyhandler, r, g, b, a);
+    lib3mf_defaultpropertyhandler_setcolorrgba (defaultpropertyhandler, r, g, b, a);
   }
 
-  lib3mf_release(defaultpropertyhandler);
+  lib3mf_release (defaultpropertyhandler);
 
   PLib3MFModelBuildItem *builditem = nullptr;
-  if (lib3mf_model_addbuilditem(ctx.model, mesh, nullptr, &builditem) != LIB3MF_OK) {
-    export_3mf_error("Can't add build item to 3MF model.", ctx.model);
+  if (lib3mf_model_addbuilditem (ctx.model, mesh, nullptr, &builditem) != LIB3MF_OK) {
+    export_3mf_error ("Can't add build item to 3MF model.", ctx.model);
     return false;
   }
-  if (!partname.empty() && lib3mf_builditem_setpartnumberutf8(builditem, partname.c_str()) != LIB3MF_OK) {
-    export_3mf_error("Can't set part name of build item.", ctx.model);
+  if (!partname.empty () && lib3mf_builditem_setpartnumberutf8 (builditem, partname.c_str ()) != LIB3MF_OK) {
+    export_3mf_error ("Can't set part name of build item.", ctx.model);
     return false;
   }
 
-  lib3mf_release(mesh);
-  lib3mf_release(builditem);
+  lib3mf_release (mesh);
+  lib3mf_release (builditem);
 
   return true;
 }
 
 #ifdef ENABLE_CGAL
-bool append_nef(const CGALNefGeometry& root_N, ExportContext& ctx)
-{
+bool append_nef (const CGALNefGeometry &root_N, ExportContext &ctx) {
   if (!root_N.p3) {
-    LOG(message_group::Export_Error, "Export failed, empty geometry.");
+    LOG (message_group::Export_Error, "Export failed, empty geometry.");
     return false;
   }
 
-  if (!root_N.p3->is_simple()) {
-    LOG(message_group::Export_Warning, "Exported object may not be a valid 2-manifold and may need repair");
+  if (!root_N.p3->is_simple ()) {
+    LOG (message_group::Export_Warning, "Exported object may not be a valid 2-manifold and may need repair");
   }
 
-
-  if (std::shared_ptr<PolySet> ps = CGALUtils::createPolySetFromNefPolyhedron3(*root_N.p3)) {
-    return append_polyset(ps, ctx);
+  if (std::shared_ptr<PolySet> ps = CGALUtils::createPolySetFromNefPolyhedron3 (*root_N.p3)) {
+    return append_polyset (ps, ctx);
   }
 
-  export_3mf_error("Error converting NEF Polyhedron.", ctx.model);
+  export_3mf_error ("Error converting NEF Polyhedron.", ctx.model);
   return false;
 }
 #endif // ifdef ENABLE_CGAL
 
-static bool append_3mf(const std::shared_ptr<const Geometry>& geom, ExportContext& ctx)
-{
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
-    ctx.modelcount = geomlist->getChildren().size();
-    for (const auto& item : geomlist->getChildren()) {
-      if (!append_3mf(item.second, ctx)) return false;
+static bool append_3mf (const std::shared_ptr<const Geometry> &geom, ExportContext &ctx) {
+  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList> (geom)) {
+    ctx.modelcount = geomlist->getChildren ().size ();
+    for (const auto &item : geomlist->getChildren ()) {
+      if (!append_3mf (item.second, ctx))
+        return false;
     }
 #ifdef ENABLE_CGAL
-  } else if (const auto N = std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
-    return append_nef(*N, ctx);
+  } else if (const auto N = std::dynamic_pointer_cast<const CGALNefGeometry> (geom)) {
+    return append_nef (*N, ctx);
 #endif
 #ifdef ENABLE_MANIFOLD
-  } else if (const auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
-    return append_polyset(mani->toPolySet(), ctx);
+  } else if (const auto mani = std::dynamic_pointer_cast<const ManifoldGeometry> (geom)) {
+    return append_polyset (mani->toPolySet (), ctx);
 #endif
-  } else if (const auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
-    return append_polyset(PolySetUtils::tessellate_faces(*ps), ctx);
-  } else if (std::dynamic_pointer_cast<const Polygon2d>(geom)) { // NOLINT(bugprone-branch-clone)
-    assert(false && "Unsupported file format");
+  } else if (const auto ps = std::dynamic_pointer_cast<const PolySet> (geom)) {
+    return append_polyset (PolySetUtils::tessellate_faces (*ps), ctx);
+  } else if (std::dynamic_pointer_cast<const Polygon2d> (geom)) { // NOLINT(bugprone-branch-clone)
+    assert (false && "Unsupported file format");
   } else { // NOLINT(bugprone-branch-clone)
-    assert(false && "Not implemented");
+    assert (false && "Not implemented");
   }
 
   return true;
 }
 
-void add_meta_data(PLib3MFModelMeshObject *& model, const std::string& name, const std::string& value, const std::string& value2 = "") {
-  const std::string v = value.empty() ? value2 : value;
-  if (v.empty()) {
+void add_meta_data (PLib3MFModelMeshObject *&model, const std::string &name, const std::string &value, const std::string &value2 = "") {
+  const std::string v = value.empty () ? value2 : value;
+  if (v.empty ()) {
     return;
   }
 
-  lib3mf_model_addmetadatautf8(model, name.c_str(), v.c_str());
+  lib3mf_model_addmetadatautf8 (model, name.c_str (), v.c_str ());
 }
 
 } // namespace
@@ -357,46 +349,45 @@ void add_meta_data(PLib3MFModelMeshObject *& model, const std::string& name, con
     Saves the current 3D Geometry as 3MF to the given file.
     The file must be open.
  */
-void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& output, const ExportInfo& exportInfo)
-{
+void export_3mf (const std::shared_ptr<const Geometry> &geom, std::ostream &output, const ExportInfo &exportInfo) {
   DWORD interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro;
-  HRESULT result = lib3mf_getinterfaceversion(&interfaceVersionMajor, &interfaceVersionMinor, &interfaceVersionMicro);
+  HRESULT result = lib3mf_getinterfaceversion (&interfaceVersionMajor, &interfaceVersionMinor, &interfaceVersionMicro);
   if (result != LIB3MF_OK) {
-    LOG(message_group::Export_Error, "Error reading 3MF library version");
+    LOG (message_group::Export_Error, "Error reading 3MF library version");
     return;
   }
 
   if ((interfaceVersionMajor != NMR_APIVERSION_INTERFACE_MAJOR)) {
-    LOG(message_group::Export_Error, "Invalid 3MF library major version %1$d.%2$d.%3$d, expected %4$d.%5$d.%6$d", interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro, NMR_APIVERSION_INTERFACE_MAJOR, NMR_APIVERSION_INTERFACE_MINOR, NMR_APIVERSION_INTERFACE_MICRO);
+    LOG (message_group::Export_Error, "Invalid 3MF library major version %1$d.%2$d.%3$d, expected %4$d.%5$d.%6$d", interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro, NMR_APIVERSION_INTERFACE_MAJOR, NMR_APIVERSION_INTERFACE_MINOR, NMR_APIVERSION_INTERFACE_MICRO);
     return;
   }
 
   PLib3MFModel *model;
-  result = lib3mf_createmodel(&model);
+  result = lib3mf_createmodel (&model);
   if (result != LIB3MF_OK) {
-    LOG(message_group::Export_Error, "Can't create 3MF model.");
+    LOG (message_group::Export_Error, "Can't create 3MF model.");
     return;
   }
 
-  const auto& options3mf = exportInfo.options3mf ? exportInfo.options3mf : std::make_shared<Export3mfOptions>();
+  const auto &options3mf = exportInfo.options3mf ? exportInfo.options3mf : std::make_shared<Export3mfOptions> ();
   switch (options3mf->unit) {
   case Export3mfUnit::micron:
-    lib3mf_model_setunit(model, eModelUnit::MODELUNIT_MICROMETER);
+    lib3mf_model_setunit (model, eModelUnit::MODELUNIT_MICROMETER);
     break;
   case Export3mfUnit::centimeter:
-    lib3mf_model_setunit(model, eModelUnit::MODELUNIT_CENTIMETER);
+    lib3mf_model_setunit (model, eModelUnit::MODELUNIT_CENTIMETER);
     break;
   case Export3mfUnit::meter:
-    lib3mf_model_setunit(model, eModelUnit::MODELUNIT_METER);
+    lib3mf_model_setunit (model, eModelUnit::MODELUNIT_METER);
     break;
   case Export3mfUnit::inch:
-    lib3mf_model_setunit(model, eModelUnit::MODELUNIT_INCH);
+    lib3mf_model_setunit (model, eModelUnit::MODELUNIT_INCH);
     break;
   case Export3mfUnit::foot:
-    lib3mf_model_setunit(model, eModelUnit::MODELUNIT_FOOT);
+    lib3mf_model_setunit (model, eModelUnit::MODELUNIT_FOOT);
     break;
   default:
-    lib3mf_model_setunit(model, eModelUnit::MODELUNIT_MILLIMETER);
+    lib3mf_model_setunit (model, eModelUnit::MODELUNIT_MILLIMETER);
     break;
   }
 
@@ -411,25 +402,25 @@ void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
       // use default color that ultimately should come from the color scheme
       defaultColor = exportInfo.defaultColor;
     } else {
-      defaultColor = OpenSCAD::getColor(options3mf->color, exportInfo.defaultColor);
+      defaultColor = OpenSCAD::getColor (options3mf->color, exportInfo.defaultColor);
     }
     if (options3mf->materialType == Export3mfMaterialType::basematerial) {
-      if (lib3mf_model_addbasematerialgroup(model, &basematerial) != LIB3MF_OK) {
-        export_3mf_error("Can't create base material group.", model);
+      if (lib3mf_model_addbasematerialgroup (model, &basematerial) != LIB3MF_OK) {
+        export_3mf_error ("Can't create base material group.", model);
         return;
       }
-      if (lib3mf_resource_getresourceid(basematerial, &basematerialid) != LIB3MF_OK) {
-        export_3mf_error("Can't get base material resource id.", model);
+      if (lib3mf_resource_getresourceid (basematerial, &basematerialid) != LIB3MF_OK) {
+        export_3mf_error ("Can't get base material resource id.", model);
         return;
       }
       uint8_t r, g, b, a;
-      if (!defaultColor.getRgba(r, g, b, a)) {
-        LOG(message_group::Warning, "Invalid color in 3MF export");
+      if (!defaultColor.getRgba (r, g, b, a)) {
+        LOG (message_group::Warning, "Invalid color in 3MF export");
       }
-      if (lib3mf_basematerial_addmaterialutf8(basematerial, "Default",
-                                              r, g, b,
-                                              &defaultColorId) != LIB3MF_OK) {
-        export_3mf_error("Can't add default material color.", model);
+      if (lib3mf_basematerial_addmaterialutf8 (basematerial, "Default",
+                                               r, g, b,
+                                               &defaultColorId) != LIB3MF_OK) {
+        export_3mf_error ("Can't add default material color.", model);
         return;
       }
     } else if (options3mf->materialType == Export3mfMaterialType::color) {
@@ -438,14 +429,14 @@ void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
   }
 
   if (options3mf->addMetaData) {
-    add_meta_data(model, "Title", options3mf->metaDataTitle, exportInfo.title);
-    add_meta_data(model, "Application", EXPORT_CREATOR);
-    add_meta_data(model, "CreationDate", get_current_iso8601_date_time_utc());
-    add_meta_data(model, "Designer", options3mf->metaDataDesigner);
-    add_meta_data(model, "Description", options3mf->metaDataDescription);
-    add_meta_data(model, "Copyright", options3mf->metaDataCopyright);
-    add_meta_data(model, "LicenseTerms", options3mf->metaDataLicenseTerms);
-    add_meta_data(model, "Rating", options3mf->metaDataRating);
+    add_meta_data (model, "Title", options3mf->metaDataTitle, exportInfo.title);
+    add_meta_data (model, "Application", EXPORT_CREATOR);
+    add_meta_data (model, "CreationDate", get_current_iso8601_date_time_utc ());
+    add_meta_data (model, "Designer", options3mf->metaDataDesigner);
+    add_meta_data (model, "Description", options3mf->metaDataDescription);
+    add_meta_data (model, "Copyright", options3mf->metaDataCopyright);
+    add_meta_data (model, "LicenseTerms", options3mf->metaDataLicenseTerms);
+    add_meta_data (model, "Rating", options3mf->metaDataRating);
   }
 
   ExportContext ctx{
@@ -457,27 +448,25 @@ void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
     .defaultColor = defaultColor,
     .defaultColorId = defaultColorId,
     .info = exportInfo,
-    .options = options3mf
-  };
+    .options = options3mf};
 
-  if (!append_3mf(geom, ctx)) {
-    if (model) lib3mf_release(model);
+  if (!append_3mf (geom, ctx)) {
+    if (model)
+      lib3mf_release (model);
     return;
   }
 
   PLib3MFModelWriter *writer;
-  if (lib3mf_model_querywriter(model, "3mf", &writer) != LIB3MF_OK) {
-    export_3mf_error("Can't get writer for 3MF model.", model);
+  if (lib3mf_model_querywriter (model, "3mf", &writer) != LIB3MF_OK) {
+    export_3mf_error ("Can't get writer for 3MF model.", model);
     return;
   }
 
-  result = lib3mf_writer_writetocallback(writer, (void *)lib3mf_write_callback, (void *)lib3mf_seek_callback, &output);
-  output.flush();
-  lib3mf_release(writer);
-  lib3mf_release(model);
+  result = lib3mf_writer_writetocallback (writer, (void *)lib3mf_write_callback, (void *)lib3mf_seek_callback, &output);
+  output.flush ();
+  lib3mf_release (writer);
+  lib3mf_release (model);
   if (result != LIB3MF_OK) {
-    LOG(message_group::Export_Error, "Error writing 3MF model.");
+    LOG (message_group::Export_Error, "Error writing 3MF model.");
   }
-
-
 }
diff --git a/src/io/export_3mf_v2.cc b/src/io/export_3mf_v2.cc
index cdbe65c0b..e11787b70 100644
--- a/src/io/export_3mf_v2.cc
+++ b/src/io/export_3mf_v2.cc
@@ -67,39 +67,37 @@ struct ExportContext {
   int modelcount;
   ExportColorMap colors;
   Color4f selectedColor;
-  const ExportInfo& info;
+  const ExportInfo &info;
   const std::shared_ptr<const Export3mfOptions> options;
 };
 
-uint32_t lib3mf_write_callback(const char *data, uint32_t bytes, std::ostream *stream)
-{
-  stream->write(data, bytes);
+uint32_t lib3mf_write_callback (const char *data, uint32_t bytes, std::ostream *stream) {
+  stream->write (data, bytes);
   return !(*stream);
 }
 
-uint32_t lib3mf_seek_callback(uint64_t pos, std::ostream *stream)
-{
-  stream->seekp(pos);
+uint32_t lib3mf_seek_callback (uint64_t pos, std::ostream *stream) {
+  stream->seekp (pos);
   return !(*stream);
 }
 
-void export_3mf_error(std::string msg)
-{
-  LOG(message_group::Export_Error, std::move(msg));
+void export_3mf_error (std::string msg) {
+  LOG (message_group::Export_Error, std::move (msg));
 }
 
-int count_mesh_objects(const Lib3MF::PModel& model) {
-  const auto mesh_object_it = model->GetMeshObjects();
+int count_mesh_objects (const Lib3MF::PModel &model) {
+  const auto mesh_object_it = model->GetMeshObjects ();
   int count = 0;
-  while (mesh_object_it->MoveNext()) ++count;
+  while (mesh_object_it->MoveNext ())
+    ++count;
   return count;
 }
 
-void handle_triangle_color(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx, Lib3MF::PMeshObject& mesh, Lib3MF_uint32 triangle, int color_index) {
+void handle_triangle_color (const std::shared_ptr<const PolySet> &ps, ExportContext &ctx, Lib3MF::PMeshObject &mesh, Lib3MF_uint32 triangle, int color_index) {
   if (color_index < 0) {
     return;
   }
-  if (ps->colors.empty()) {
+  if (ps->colors.empty ()) {
     return;
   }
   if (!ctx.basematerialgroup && !ctx.colorgroup) {
@@ -110,18 +108,18 @@ void handle_triangle_color(const std::shared_ptr<const PolySet>& ps, ExportConte
   }
 
   const Color4f col = ps->colors[color_index];
-  const auto col_it = ctx.colors.find(col);
+  const auto col_it = ctx.colors.find (col);
 
   Lib3MF_uint32 col_idx = 0;
-  if (col_it == ctx.colors.end()) {
+  if (col_it == ctx.colors.end ()) {
     Lib3MF::sColor materialcolor;
-    if (!col.getRgba(materialcolor.m_Red, materialcolor.m_Green, materialcolor.m_Blue, materialcolor.m_Alpha)) {
-      LOG(message_group::Warning, "Invalid color in 3MF export");
+    if (!col.getRgba (materialcolor.m_Red, materialcolor.m_Green, materialcolor.m_Blue, materialcolor.m_Alpha)) {
+      LOG (message_group::Warning, "Invalid color in 3MF export");
     }
     if (ctx.basematerialgroup) {
-      col_idx = ctx.basematerialgroup->AddMaterial("Color " + std::to_string(ctx.basematerialgroup->GetCount()), materialcolor);
+      col_idx = ctx.basematerialgroup->AddMaterial ("Color " + std::to_string (ctx.basematerialgroup->GetCount ()), materialcolor);
     } else if (ctx.colorgroup) {
-      col_idx = ctx.colorgroup->AddColor(materialcolor);
+      col_idx = ctx.colorgroup->AddColor (materialcolor);
     }
     ctx.colors[col] = col_idx;
   } else {
@@ -130,158 +128,151 @@ void handle_triangle_color(const std::shared_ptr<const PolySet>& ps, ExportConte
 
   Lib3MF_uint32 res_id = 0;
   if (ctx.basematerialgroup) {
-    res_id = ctx.basematerialgroup->GetUniqueResourceID();
+    res_id = ctx.basematerialgroup->GetUniqueResourceID ();
   } else if (ctx.colorgroup) {
-    res_id = ctx.colorgroup->GetUniqueResourceID();
+    res_id = ctx.colorgroup->GetUniqueResourceID ();
   }
 
   if (res_id > 0) {
-    mesh->SetTriangleProperties(triangle, {
-        res_id,
-        {
-          col_idx,
-          col_idx,
-          col_idx
-        }
-      });
+    mesh->SetTriangleProperties (triangle, {res_id,
+                                            {col_idx,
+                                             col_idx,
+                                             col_idx}});
   }
 }
 
 /*
  * PolySet must be triangulated.
  */
-bool append_polyset(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx)
-{
+bool append_polyset (const std::shared_ptr<const PolySet> &ps, ExportContext &ctx) {
   try {
-    auto mesh = ctx.model->AddMeshObject();
-    if (!mesh) return false;
-
-    const int mesh_count = count_mesh_objects(ctx.model);
-    const auto modelname = ctx.modelcount == 1 ? "OpenSCAD Model" : "OpenSCAD Model " + std::to_string(mesh_count);
-    const auto partname = ctx.modelcount == 1 ? "" : "Part " + std::to_string(mesh_count);
-    mesh->SetName(modelname);
+    auto mesh = ctx.model->AddMeshObject ();
+    if (!mesh)
+      return false;
+
+    const int mesh_count = count_mesh_objects (ctx.model);
+    const auto modelname = ctx.modelcount == 1 ? "OpenSCAD Model" : "OpenSCAD Model " + std::to_string (mesh_count);
+    const auto partname = ctx.modelcount == 1 ? "" : "Part " + std::to_string (mesh_count);
+    mesh->SetName (modelname);
     if (ctx.basematerialgroup) {
-      mesh->SetObjectLevelProperty(ctx.basematerialgroup->GetUniqueResourceID(), 1);
+      mesh->SetObjectLevelProperty (ctx.basematerialgroup->GetUniqueResourceID (), 1);
     } else if (ctx.colorgroup) {
-      mesh->SetObjectLevelProperty(ctx.colorgroup->GetUniqueResourceID(), 1);
+      mesh->SetObjectLevelProperty (ctx.colorgroup->GetUniqueResourceID (), 1);
     }
 
-    auto vertexFunc = [&](const Vector3d& coords) -> bool {
-        const auto f = coords.cast<float>();
-        try {
-          const Lib3MF::sPosition v{f[0], f[1], f[2]};
-          mesh->AddVertex(v);
-        } catch (Lib3MF::ELib3MFException& e) {
-          export_3mf_error(e.what());
-          return false;
-        }
-        return true;
-      };
-
-    auto triangleFunc = [&](const IndexedFace& indices, int color_index) -> bool {
-        try {
-          const auto triangle = mesh->AddTriangle({
-            static_cast<Lib3MF_uint32>(indices[0]),
-            static_cast<Lib3MF_uint32>(indices[1]),
-            static_cast<Lib3MF_uint32>(indices[2])
-          });
-
-          handle_triangle_color(ps, ctx, mesh, triangle, color_index);
-        } catch (Lib3MF::ELib3MFException& e) {
-          export_3mf_error(e.what());
-          return false;
-        }
-        return true;
-      };
+    auto vertexFunc = [&] (const Vector3d &coords) -> bool {
+      const auto f = coords.cast<float> ();
+      try {
+        const Lib3MF::sPosition v{f[0], f[1], f[2]};
+        mesh->AddVertex (v);
+      } catch (Lib3MF::ELib3MFException &e) {
+        export_3mf_error (e.what ());
+        return false;
+      }
+      return true;
+    };
+
+    auto triangleFunc = [&] (const IndexedFace &indices, int color_index) -> bool {
+      try {
+        const auto triangle = mesh->AddTriangle ({static_cast<Lib3MF_uint32> (indices[0]),
+                                                  static_cast<Lib3MF_uint32> (indices[1]),
+                                                  static_cast<Lib3MF_uint32> (indices[2])});
+
+        handle_triangle_color (ps, ctx, mesh, triangle, color_index);
+      } catch (Lib3MF::ELib3MFException &e) {
+        export_3mf_error (e.what ());
+        return false;
+      }
+      return true;
+    };
 
     std::shared_ptr<const PolySet> out_ps = ps;
-    if (Feature::ExperimentalPredictibleOutput.is_enabled()) {
-      out_ps = createSortedPolySet(*ps);
+    if (Feature::ExperimentalPredictibleOutput.is_enabled ()) {
+      out_ps = createSortedPolySet (*ps);
     }
 
-    for (const auto& v : out_ps->vertices) {
-      if (!vertexFunc(v)) {
-        export_3mf_error("Can't add vertex to 3MF model.");
+    for (const auto &v : out_ps->vertices) {
+      if (!vertexFunc (v)) {
+        export_3mf_error ("Can't add vertex to 3MF model.");
         return false;
       }
     }
 
-    for (size_t i = 0; i < out_ps->indices.size(); i++) {
-      auto color_index = i < out_ps->color_indices.size() ? out_ps->color_indices[i] : -1;
-      if (!triangleFunc(out_ps->indices[i], color_index)) {
-        export_3mf_error("Can't add triangle to 3MF model.");
+    for (size_t i = 0; i < out_ps->indices.size (); i++) {
+      auto color_index = i < out_ps->color_indices.size () ? out_ps->color_indices[i] : -1;
+      if (!triangleFunc (out_ps->indices[i], color_index)) {
+        export_3mf_error ("Can't add triangle to 3MF model.");
         return false;
       }
     }
 
     try {
-      auto builditem = ctx.model->AddBuildItem(mesh.get(), ctx.wrapper->GetIdentityTransform());
-      if (!partname.empty()) {
-        builditem->SetPartNumber(partname);
+      auto builditem = ctx.model->AddBuildItem (mesh.get (), ctx.wrapper->GetIdentityTransform ());
+      if (!partname.empty ()) {
+        builditem->SetPartNumber (partname);
       }
-    } catch (Lib3MF::ELib3MFException& e) {
-      export_3mf_error(e.what());
+    } catch (Lib3MF::ELib3MFException &e) {
+      export_3mf_error (e.what ());
     }
-  } catch (Lib3MF::ELib3MFException& e) {
-    export_3mf_error(e.what());
+  } catch (Lib3MF::ELib3MFException &e) {
+    export_3mf_error (e.what ());
     return false;
   }
   return true;
 }
 
 #ifdef ENABLE_CGAL
-bool append_nef(const CGALNefGeometry& root_N, ExportContext& ctx)
-{
+bool append_nef (const CGALNefGeometry &root_N, ExportContext &ctx) {
   if (!root_N.p3) {
-    LOG(message_group::Export_Error, "Export failed, empty geometry.");
+    LOG (message_group::Export_Error, "Export failed, empty geometry.");
     return false;
   }
 
-  if (!root_N.p3->is_simple()) {
-    LOG(message_group::Export_Warning, "Exported object may not be a valid 2-manifold and may need repair");
+  if (!root_N.p3->is_simple ()) {
+    LOG (message_group::Export_Warning, "Exported object may not be a valid 2-manifold and may need repair");
   }
 
-  if (const std::shared_ptr<const PolySet> ps = CGALUtils::createPolySetFromNefPolyhedron3(*root_N.p3)) {
-    return append_polyset(ps, ctx);
+  if (const std::shared_ptr<const PolySet> ps = CGALUtils::createPolySetFromNefPolyhedron3 (*root_N.p3)) {
+    return append_polyset (ps, ctx);
   }
-  export_3mf_error("Error converting NEF Polyhedron.");
+  export_3mf_error ("Error converting NEF Polyhedron.");
   return false;
 }
 #endif // ifdef ENABLE_CGAL
 
-bool append_3mf(const std::shared_ptr<const Geometry>& geom, ExportContext& ctx)
-{
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
-    ctx.modelcount = geomlist->getChildren().size();
-    for (const auto& item : geomlist->getChildren()) {
-      if (!append_3mf(item.second, ctx)) return false;
+bool append_3mf (const std::shared_ptr<const Geometry> &geom, ExportContext &ctx) {
+  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList> (geom)) {
+    ctx.modelcount = geomlist->getChildren ().size ();
+    for (const auto &item : geomlist->getChildren ()) {
+      if (!append_3mf (item.second, ctx))
+        return false;
     }
 #ifdef ENABLE_CGAL
-  } else if (const auto N = std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
-    return append_nef(*N, ctx);
+  } else if (const auto N = std::dynamic_pointer_cast<const CGALNefGeometry> (geom)) {
+    return append_nef (*N, ctx);
 #endif
 #ifdef ENABLE_MANIFOLD
-  } else if (const auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
-    return append_polyset(mani->toPolySet(), ctx);
+  } else if (const auto mani = std::dynamic_pointer_cast<const ManifoldGeometry> (geom)) {
+    return append_polyset (mani->toPolySet (), ctx);
 #endif
-  } else if (const auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
-    return append_polyset(PolySetUtils::tessellate_faces(*ps), ctx);
-  } else if (std::dynamic_pointer_cast<const Polygon2d>(geom)) {
-    assert(false && "Unsupported file format");
+  } else if (const auto ps = std::dynamic_pointer_cast<const PolySet> (geom)) {
+    return append_polyset (PolySetUtils::tessellate_faces (*ps), ctx);
+  } else if (std::dynamic_pointer_cast<const Polygon2d> (geom)) {
+    assert (false && "Unsupported file format");
   } else {
-    assert(false && "Not implemented");
+    assert (false && "Not implemented");
   }
 
   return true;
 }
 
-void add_meta_data(Lib3MF::PMetaDataGroup& metadatagroup, const std::string& name, const std::string& value, const std::string& value2 = "") {
-  const std::string v = value.empty() ? value2 : value;
-  if (v.empty()) {
+void add_meta_data (Lib3MF::PMetaDataGroup &metadatagroup, const std::string &name, const std::string &value, const std::string &value2 = "") {
+  const std::string v = value.empty () ? value2 : value;
+  if (v.empty ()) {
     return;
   }
 
-  metadatagroup->AddMetaData("", name, v, "xs:string", true);
+  metadatagroup->AddMetaData ("", name, v, "xs:string", true);
 }
 
 } // namespace
@@ -290,61 +281,60 @@ void add_meta_data(Lib3MF::PMetaDataGroup& metadatagroup, const std::string& nam
     Saves the current 3D Geometry as 3MF to the given file.
     The file must be open.
  */
-void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& output, const ExportInfo& exportInfo)
-{
+void export_3mf (const std::shared_ptr<const Geometry> &geom, std::ostream &output, const ExportInfo &exportInfo) {
   Lib3MF_uint32 interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro;
   Lib3MF::PWrapper wrapper;
 
   try {
-    wrapper = Lib3MF::CWrapper::loadLibrary();
-    wrapper->GetLibraryVersion(interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro);
+    wrapper = Lib3MF::CWrapper::loadLibrary ();
+    wrapper->GetLibraryVersion (interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro);
     if (interfaceVersionMajor != LIB3MF_VERSION_MAJOR) {
-      LOG(message_group::Error, "Invalid 3MF library major version %1$d.%2$d.%3$d, expected %4$d.%5$d.%6$d",
-          interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro,
-          LIB3MF_VERSION_MAJOR, LIB3MF_VERSION_MINOR, LIB3MF_VERSION_MICRO);
+      LOG (message_group::Error, "Invalid 3MF library major version %1$d.%2$d.%3$d, expected %4$d.%5$d.%6$d",
+           interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro,
+           LIB3MF_VERSION_MAJOR, LIB3MF_VERSION_MINOR, LIB3MF_VERSION_MICRO);
       return;
     }
-  } catch (Lib3MF::ELib3MFException& e) {
-    LOG(message_group::Export_Error, e.what());
+  } catch (Lib3MF::ELib3MFException &e) {
+    LOG (message_group::Export_Error, e.what ());
     return;
   }
 
   if ((interfaceVersionMajor != LIB3MF_VERSION_MAJOR)) {
-    LOG(message_group::Export_Error, "Invalid 3MF library major version %1$d.%2$d.%3$d, expected %4$d.%5$d.%6$d", interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro, LIB3MF_VERSION_MAJOR, LIB3MF_VERSION_MINOR, LIB3MF_VERSION_MICRO);
+    LOG (message_group::Export_Error, "Invalid 3MF library major version %1$d.%2$d.%3$d, expected %4$d.%5$d.%6$d", interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro, LIB3MF_VERSION_MAJOR, LIB3MF_VERSION_MINOR, LIB3MF_VERSION_MICRO);
     return;
   }
 
   Lib3MF::PModel model;
   try {
-    model = wrapper->CreateModel();
+    model = wrapper->CreateModel ();
     if (!model) {
-      LOG(message_group::Export_Error, "Can't create 3MF model.");
+      LOG (message_group::Export_Error, "Can't create 3MF model.");
       return;
     }
-  } catch (Lib3MF::ELib3MFException& e) {
-    LOG(message_group::Export_Error, e.what());
+  } catch (Lib3MF::ELib3MFException &e) {
+    LOG (message_group::Export_Error, e.what ());
     return;
   }
 
-  const auto& options3mf = exportInfo.options3mf ? exportInfo.options3mf : std::make_shared<Export3mfOptions>();
+  const auto &options3mf = exportInfo.options3mf ? exportInfo.options3mf : std::make_shared<Export3mfOptions> ();
   switch (options3mf->unit) {
   case Export3mfUnit::micron:
-    model->SetUnit(Lib3MF::eModelUnit::MicroMeter);
+    model->SetUnit (Lib3MF::eModelUnit::MicroMeter);
     break;
   case Export3mfUnit::centimeter:
-    model->SetUnit(Lib3MF::eModelUnit::CentiMeter);
+    model->SetUnit (Lib3MF::eModelUnit::CentiMeter);
     break;
   case Export3mfUnit::meter:
-    model->SetUnit(Lib3MF::eModelUnit::Meter);
+    model->SetUnit (Lib3MF::eModelUnit::Meter);
     break;
   case Export3mfUnit::inch:
-    model->SetUnit(Lib3MF::eModelUnit::Inch);
+    model->SetUnit (Lib3MF::eModelUnit::Inch);
     break;
   case Export3mfUnit::foot:
-    model->SetUnit(Lib3MF::eModelUnit::Foot);
+    model->SetUnit (Lib3MF::eModelUnit::Foot);
     break;
   default:
-    model->SetUnit(Lib3MF::eModelUnit::MilliMeter);
+    model->SetUnit (Lib3MF::eModelUnit::MilliMeter);
     break;
   }
 
@@ -356,36 +346,36 @@ void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
   if (options3mf->colorMode != Export3mfColorMode::none) {
     if (options3mf->colorMode != Export3mfColorMode::model) {
       // use color selected in the export dialog and stored in settings (if valid)
-      color = OpenSCAD::getColor(options3mf->color, exportInfo.defaultColor);
+      color = OpenSCAD::getColor (options3mf->color, exportInfo.defaultColor);
     }
     if (options3mf->materialType == Export3mfMaterialType::basematerial) {
-      basematerialgroup = model->AddBaseMaterialGroup();
+      basematerialgroup = model->AddBaseMaterialGroup ();
       Lib3MF::sColor materialcolor;
-      if (!color.getRgba(materialcolor.m_Red, materialcolor.m_Green, materialcolor.m_Blue, materialcolor.m_Alpha)) {
-        LOG(message_group::Warning, "Invalid color in 3MF export");
+      if (!color.getRgba (materialcolor.m_Red, materialcolor.m_Green, materialcolor.m_Blue, materialcolor.m_Alpha)) {
+        LOG (message_group::Warning, "Invalid color in 3MF export");
       }
       materialcolor.m_Alpha = 0xff;
-      basematerialgroup->AddMaterial("Default", materialcolor);
+      basematerialgroup->AddMaterial ("Default", materialcolor);
     } else if (options3mf->materialType == Export3mfMaterialType::color) {
-      colorgroup = model->AddColorGroup();
+      colorgroup = model->AddColorGroup ();
       Lib3MF::sColor groupcolor;
-      if (!color.getRgba(groupcolor.m_Red, groupcolor.m_Green, groupcolor.m_Blue, groupcolor.m_Alpha)) {
-        LOG(message_group::Warning, "Invalid color in 3MF export");
+      if (!color.getRgba (groupcolor.m_Red, groupcolor.m_Green, groupcolor.m_Blue, groupcolor.m_Alpha)) {
+        LOG (message_group::Warning, "Invalid color in 3MF export");
       }
-      colorgroup->AddColor(groupcolor);
+      colorgroup->AddColor (groupcolor);
     }
   }
 
   if (options3mf->addMetaData) {
-    auto metadatagroup = model->GetMetaDataGroup();
-    add_meta_data(metadatagroup, "Title", options3mf->metaDataTitle, exportInfo.title);
-    add_meta_data(metadatagroup, "Application", EXPORT_CREATOR);
-    add_meta_data(metadatagroup, "CreationDate", get_current_iso8601_date_time_utc());
-    add_meta_data(metadatagroup, "Designer", options3mf->metaDataDesigner);
-    add_meta_data(metadatagroup, "Description", options3mf->metaDataDescription);
-    add_meta_data(metadatagroup, "Copyright", options3mf->metaDataCopyright);
-    add_meta_data(metadatagroup, "LicenseTerms", options3mf->metaDataLicenseTerms);
-    add_meta_data(metadatagroup, "Rating", options3mf->metaDataRating);
+    auto metadatagroup = model->GetMetaDataGroup ();
+    add_meta_data (metadatagroup, "Title", options3mf->metaDataTitle, exportInfo.title);
+    add_meta_data (metadatagroup, "Application", EXPORT_CREATOR);
+    add_meta_data (metadatagroup, "CreationDate", get_current_iso8601_date_time_utc ());
+    add_meta_data (metadatagroup, "Designer", options3mf->metaDataDesigner);
+    add_meta_data (metadatagroup, "Description", options3mf->metaDataDescription);
+    add_meta_data (metadatagroup, "Copyright", options3mf->metaDataCopyright);
+    add_meta_data (metadatagroup, "LicenseTerms", options3mf->metaDataLicenseTerms);
+    add_meta_data (metadatagroup, "Rating", options3mf->metaDataRating);
   }
 
   ExportContext ctx{
@@ -396,35 +386,34 @@ void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
     .modelcount = 1,
     .selectedColor = color,
     .info = exportInfo,
-    .options = options3mf
-  };
+    .options = options3mf};
 
-  if (!append_3mf(geom, ctx)) {
+  if (!append_3mf (geom, ctx)) {
     return;
   }
 
   Lib3MF::PWriter writer;
   try {
-    writer = model->QueryWriter("3mf");
+    writer = model->QueryWriter ("3mf");
     if (!writer) {
-      export_3mf_error("Can't get writer for 3MF model.");
+      export_3mf_error ("Can't get writer for 3MF model.");
       return;
     }
-  } catch (Lib3MF::ELib3MFException& e) {
-    export_3mf_error("Can't get writer for 3MF model.");
+  } catch (Lib3MF::ELib3MFException &e) {
+    export_3mf_error ("Can't get writer for 3MF model.");
     return;
   }
 
   try {
-    writer->SetDecimalPrecision(ctx.options->decimalPrecision);
-  } catch (Lib3MF::ELib3MFException& e) {
-    LOG(message_group::Export_Error, "Error setting decimal precision for export: %1$s", e.what());
+    writer->SetDecimalPrecision (ctx.options->decimalPrecision);
+  } catch (Lib3MF::ELib3MFException &e) {
+    LOG (message_group::Export_Error, "Error setting decimal precision for export: %1$s", e.what ());
   }
 
   try {
-    writer->WriteToCallback((Lib3MF::WriteCallback)lib3mf_write_callback, (Lib3MF::SeekCallback)lib3mf_seek_callback, &output);
-  } catch (Lib3MF::ELib3MFException& e) {
-    LOG(message_group::Export_Error, e.what());
+    writer->WriteToCallback ((Lib3MF::WriteCallback)lib3mf_write_callback, (Lib3MF::SeekCallback)lib3mf_seek_callback, &output);
+  } catch (Lib3MF::ELib3MFException &e) {
+    LOG (message_group::Export_Error, e.what ());
   }
-  output.flush();
+  output.flush ();
 }
diff --git a/src/io/export_amf.cc b/src/io/export_amf.cc
index 891fd308a..21a519a76 100644
--- a/src/io/export_amf.cc
+++ b/src/io/export_amf.cc
@@ -44,12 +44,12 @@
 #include <string>
 #include <vector>
 
-#define QUOTE(x__) # x__
-#define QUOTED(x__) QUOTE(x__)
+#define QUOTE(x__) #x__
+#define QUOTED(x__) QUOTE (x__)
 
 struct vertex_str {
   std::string x, y, z;
-  bool operator==(const vertex_str& rhs) {
+  bool operator== (const vertex_str &rhs) {
     return x == rhs.x && y == rhs.y && z == rhs.z;
   }
 };
@@ -70,17 +70,17 @@ struct triangle {
 static int objectid;
 
 #ifdef ENABLE_CGAL
-static size_t add_vertex(std::vector<vertex_str>& vertices, const Point& p) {
-  double x = CGAL::to_double(p.x());
-  double y = CGAL::to_double(p.y());
-  double z = CGAL::to_double(p.z());
-  vertex_str vs{STR(x), STR(y), STR(z)};
-  auto vi = std::find(vertices.begin(), vertices.end(), vs);
-  if (vi == vertices.end()) {
-    vertices.push_back(vs);
-    return vertices.size() - 1;
+static size_t add_vertex (std::vector<vertex_str> &vertices, const Point &p) {
+  double x = CGAL::to_double (p.x ());
+  double y = CGAL::to_double (p.y ());
+  double z = CGAL::to_double (p.z ());
+  vertex_str vs{STR (x), STR (y), STR (z)};
+  auto vi = std::find (vertices.begin (), vertices.end (), vs);
+  if (vi == vertices.end ()) {
+    vertices.push_back (vs);
+    return vertices.size () - 1;
   } else {
-    return std::distance(vertices.begin(), vi);
+    return std::distance (vertices.begin (), vi);
   }
 }
 
@@ -88,38 +88,37 @@ static size_t add_vertex(std::vector<vertex_str>& vertices, const Point& p) {
     Saves the current 3D CGAL Nef polyhedron as AMF to the given file.
     The file must be open.
  */
-static void append_amf(const CGALNefGeometry& root_N, std::ostream& output)
-{
-  if (!root_N.p3->is_simple()) {
-    LOG(message_group::Export_Warning, "Export failed, the object isn't a valid 2-manifold.");
+static void append_amf (const CGALNefGeometry &root_N, std::ostream &output) {
+  if (!root_N.p3->is_simple ()) {
+    LOG (message_group::Export_Warning, "Export failed, the object isn't a valid 2-manifold.");
     return;
   }
   try {
     CGAL_Polyhedron P;
-    CGALUtils::convertNefToPolyhedron(*root_N.p3, P);
+    CGALUtils::convertNefToPolyhedron (*root_N.p3, P);
 
     vertex_vec vertices;
     std::vector<triangle> triangles;
 
-    for (FCI fi = P.facets_begin(); fi != P.facets_end(); ++fi) {
-      HFCC hc = fi->facet_begin();
+    for (FCI fi = P.facets_begin (); fi != P.facets_end (); ++fi) {
+      HFCC hc = fi->facet_begin ();
       HFCC hc_end = hc;
       Vertex v1, v2, v3;
-      v1 = *VCI((hc++)->vertex());
-      v3 = *VCI((hc++)->vertex());
+      v1 = *VCI ((hc++)->vertex ());
+      v3 = *VCI ((hc++)->vertex ());
       do {
         v2 = v3;
-        v3 = *VCI((hc++)->vertex());
-        auto vi1 = add_vertex(vertices, v1.point());
-        auto vi2 = add_vertex(vertices, v2.point());
-        auto vi3 = add_vertex(vertices, v3.point());
+        v3 = *VCI ((hc++)->vertex ());
+        auto vi1 = add_vertex (vertices, v1.point ());
+        auto vi2 = add_vertex (vertices, v2.point ());
+        auto vi3 = add_vertex (vertices, v3.point ());
         if (vi1 != vi2 && vi1 != vi3 && vi2 != vi3) {
           // The above condition ensures that there are 3 distinct vertices, but
           // they may be collinear. If they are, the unit normal is meaningless
           // so the default value of "1 0 0" can be used. If the vertices are not
           // collinear then the unit normal must be calculated from the
           // components.
-          triangles.push_back({vi1, vi2, vi3});
+          triangles.push_back ({vi1, vi2, vi3});
         }
       } while (hc != hc_end);
     }
@@ -127,7 +126,7 @@ static void append_amf(const CGALNefGeometry& root_N, std::ostream& output)
     output << " <object id=\"" << objectid++ << "\">\r\n"
            << "  <mesh>\r\n";
     output << "   <vertices>\r\n";
-    for (const auto& s : vertices) {
+    for (const auto &s : vertices) {
       output << "    <vertex><coordinates>\r\n";
       output << "     <x>" << s.x << "</x>\r\n";
       output << "     <y>" << s.y << "</y>\r\n";
@@ -146,46 +145,45 @@ static void append_amf(const CGALNefGeometry& root_N, std::ostream& output)
     output << "   </volume>\r\n";
     output << "  </mesh>\r\n"
            << " </object>\r\n";
-  } catch (std::exception& e) {
-    LOG(message_group::Export_Error, "CGAL error in CGAL_Nef_polyhedron3::convert_to_polyhedron(): %1$s", e.what());
+  } catch (std::exception &e) {
+    LOG (message_group::Export_Error, "CGAL error in CGAL_Nef_polyhedron3::convert_to_polyhedron(): %1$s", e.what ());
   }
 }
 #endif // ifdef ENABLE_CGAL
 
-static void append_amf(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
-    for (const auto& item : geomlist->getChildren()) {
-      append_amf(item.second, output);
+static void append_amf (const std::shared_ptr<const Geometry> &geom, std::ostream &output) {
+  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList> (geom)) {
+    for (const auto &item : geomlist->getChildren ()) {
+      append_amf (item.second, output);
     }
 #ifdef ENABLE_CGAL
-  } else if (auto N = CGALUtils::getNefPolyhedronFromGeometry(geom)) {
+  } else if (auto N = CGALUtils::getNefPolyhedronFromGeometry (geom)) {
     // FIXME: Implement this without creating a Nef polyhedron
-    if (!N->isEmpty()) append_amf(*N, output);
+    if (!N->isEmpty ())
+      append_amf (*N, output);
 #endif
-  } else if (geom->getDimension() != 3) { // NOLINT(bugprone-branch-clone)
-    assert(false && "Unsupported file format");
+  } else if (geom->getDimension () != 3) { // NOLINT(bugprone-branch-clone)
+    assert (false && "Unsupported file format");
   } else { // NOLINT(bugprone-branch-clone)
-    assert(false && "Not implemented");
+    assert (false && "Not implemented");
   }
 }
 
-void export_amf(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
-  LOG(message_group::Deprecated, "AMF export is deprecated. Please use 3MF instead.");
-  setlocale(LC_NUMERIC, "C"); // Ensure radix is . (not ,) in output
+void export_amf (const std::shared_ptr<const Geometry> &geom, std::ostream &output) {
+  LOG (message_group::Deprecated, "AMF export is deprecated. Please use 3MF instead.");
+  setlocale (LC_NUMERIC, "C"); // Ensure radix is . (not ,) in output
 
   output << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n"
          << "<amf unit=\"millimeter\">\r\n"
-         << " <metadata type=\"producer\">OpenSCAD " << QUOTED(OPENSCAD_VERSION)
+         << " <metadata type=\"producer\">OpenSCAD " << QUOTED (OPENSCAD_VERSION)
 #ifdef OPENSCAD_COMMIT
-    << " (git " << QUOTED(OPENSCAD_COMMIT) << ")"
+         << " (git " << QUOTED (OPENSCAD_COMMIT) << ")"
 #endif
-    << "</metadata>\r\n";
+         << "</metadata>\r\n";
 
   objectid = 0;
-  append_amf(geom, output);
+  append_amf (geom, output);
 
   output << "</amf>\r\n";
-  setlocale(LC_NUMERIC, ""); // Set default locale
+  setlocale (LC_NUMERIC, ""); // Set default locale
 }
diff --git a/src/io/export_dxf.cc b/src/io/export_dxf.cc
index 3f7b4c002..23be6946e 100644
--- a/src/io/export_dxf.cc
+++ b/src/io/export_dxf.cc
@@ -40,7 +40,7 @@
     Saves the current Polygon2d as DXF to the given absolute filename.
  */
 
-static void export_dxf_header(std::ostream& output, double xMin, double yMin, double xMax, double yMax) {
+static void export_dxf_header (std::ostream &output, double xMin, double yMin, double xMax, double yMax) {
 
   // https://dxfwrite.readthedocs.io/en/latest/headervars.html
   // http://paulbourke.net/dataformats/dxf/min3d.html
@@ -57,7 +57,8 @@ static void export_dxf_header(std::ostream& output, double xMin, double yMin, do
   // - generic cutters
 
   output
-    << "999\n" << "DXF from OpenSCAD\n";
+    << "999\n"
+    << "DXF from OpenSCAD\n";
 
   //
   // SECTION 1
@@ -66,119 +67,171 @@ static void export_dxf_header(std::ostream& output, double xMin, double yMin, do
   /* --- START --- */
 
   output
-    << "  0\n" << "SECTION\n"
-    << "  2\n" << "HEADER\n"
-    << "  9\n" << "$ACADVER\n"
-    << "  1\n" << "AC1006\n"
-    << "  9\n" << "$INSBASE\n"
-    << " 10\n" << "0.0\n"
-    << " 20\n" << "0.0\n"
-    << " 30\n" << "0.0\n"
-  ;
+    << "  0\n"
+    << "SECTION\n"
+    << "  2\n"
+    << "HEADER\n"
+    << "  9\n"
+    << "$ACADVER\n"
+    << "  1\n"
+    << "AC1006\n"
+    << "  9\n"
+    << "$INSBASE\n"
+    << " 10\n"
+    << "0.0\n"
+    << " 20\n"
+    << "0.0\n"
+    << " 30\n"
+    << "0.0\n";
 
   /* --- LIMITS --- */
 
   output
-    << "  9\n" << "$EXTMIN\n"
-    << " 10\n" << xMin << "\n"
-    << " 20\n" << yMin << "\n"
-    << "  9\n" << "$EXTMAX\n"
-    << " 10\n" << xMax << "\n"
-    << " 20\n" << yMax << "\n";
+    << "  9\n"
+    << "$EXTMIN\n"
+    << " 10\n"
+    << xMin << "\n"
+    << " 20\n"
+    << yMin << "\n"
+    << "  9\n"
+    << "$EXTMAX\n"
+    << " 10\n"
+    << xMax << "\n"
+    << " 20\n"
+    << yMax << "\n";
 
   output
-    << "  9\n" << "$LINMIN\n"
-    << " 10\n" << xMin << "\n"
-    << " 20\n" << yMin << "\n"
-    << "  9\n" << "$LINMAX\n"
-    << " 10\n" << xMax << "\n"
-    << " 20\n" << yMax << "\n";
+    << "  9\n"
+    << "$LINMIN\n"
+    << " 10\n"
+    << xMin << "\n"
+    << " 20\n"
+    << yMin << "\n"
+    << "  9\n"
+    << "$LINMAX\n"
+    << " 10\n"
+    << xMax << "\n"
+    << " 20\n"
+    << yMax << "\n";
 
   output
-    << "  0\n" << "ENDSEC\n";
+    << "  0\n"
+    << "ENDSEC\n";
 
   //
   // SECTION 2
   //
 
   output
-    << "  0\n" << "SECTION\n";
+    << "  0\n"
+    << "SECTION\n";
 
   output
-    << "  2\n" << "TABLES\n";
+    << "  2\n"
+    << "TABLES\n";
 
   /* --- LINETYPE --- */
 
   output
-    << "  0\n" << "TABLE\n"
-    << "  2\n" << "LTYPE\n"
-    << " 70\n" << "1\n"
-
-    << "  0\n" << "LTYPE\n"
-    << "  2\n" << "CONTINUOUS\n"       // linetype name
-    << " 70\n" << "64\n"
-    << "  3\n" << "Solid line\n"       // descriptive text
-    << " 72\n" << "65\n"       // always 65
-    << " 73\n" << "0\n"        // number of linetype elements
-    << " 40\n" << "0.000000\n"       // total pattern length
-
-    << "  0\n" << "ENDTAB\n";
+    << "  0\n"
+    << "TABLE\n"
+    << "  2\n"
+    << "LTYPE\n"
+    << " 70\n"
+    << "1\n"
+
+    << "  0\n"
+    << "LTYPE\n"
+    << "  2\n"
+    << "CONTINUOUS\n" // linetype name
+    << " 70\n"
+    << "64\n"
+    << "  3\n"
+    << "Solid line\n" // descriptive text
+    << " 72\n"
+    << "65\n" // always 65
+    << " 73\n"
+    << "0\n" // number of linetype elements
+    << " 40\n"
+    << "0.000000\n" // total pattern length
+
+    << "  0\n"
+    << "ENDTAB\n";
 
   /* --- LAYERS --- */
 
   output
-    << "  0\n" << "TABLE\n"
-    << "  2\n" << "LAYER\n"
-    << " 70\n" << "6\n"
-
-    << "  0\n" << "LAYER\n"
-    << "  2\n" << "0\n"         // layer name
-    << " 70\n" << "64\n"
-    << " 62\n" << "7\n"         // color
-    << "  6\n" << "CONTINUOUS\n"
-
-    << "  0\n" << "ENDTAB\n";
+    << "  0\n"
+    << "TABLE\n"
+    << "  2\n"
+    << "LAYER\n"
+    << " 70\n"
+    << "6\n"
+
+    << "  0\n"
+    << "LAYER\n"
+    << "  2\n"
+    << "0\n" // layer name
+    << " 70\n"
+    << "64\n"
+    << " 62\n"
+    << "7\n" // color
+    << "  6\n"
+    << "CONTINUOUS\n"
+
+    << "  0\n"
+    << "ENDTAB\n";
 
   /* --- STYLE --- */
 
   output
-    << "  0\n" << "TABLE\n"
-    << "  2\n" << "STYLE\n"
-    << " 70\n" << "0\n"
-    << "  0\n" << "ENDTAB\n";
+    << "  0\n"
+    << "TABLE\n"
+    << "  2\n"
+    << "STYLE\n"
+    << " 70\n"
+    << "0\n"
+    << "  0\n"
+    << "ENDTAB\n";
 
   output
-    << "  0\n" << "ENDSEC\n";
+    << "  0\n"
+    << "ENDSEC\n";
 
   //
   // SECTION 3
   //
 
   output
-    << "  0\n" << "SECTION\n"
-    << "  2\n" << "BLOCKS\n"
-    << "  0\n" << "ENDSEC\n";
-
+    << "  0\n"
+    << "SECTION\n"
+    << "  2\n"
+    << "BLOCKS\n"
+    << "  0\n"
+    << "ENDSEC\n";
 }
 
-static void export_dxf(const Polygon2d& poly, std::ostream& output)
-{
-  setlocale(LC_NUMERIC, "C"); // Ensure radix is . (not ,) in output
+static void export_dxf (const Polygon2d &poly, std::ostream &output) {
+  setlocale (LC_NUMERIC, "C"); // Ensure radix is . (not ,) in output
 
   // find limits
   double xMin, yMin, xMax, yMax;
-  xMin = yMin = std::numeric_limits<double>::max(),
-  xMax = yMax = std::numeric_limits<double>::min();
-  for (const auto& o : poly.outlines()) {
-    for (const auto& p : o.vertices) {
-      if (xMin > p[0]) xMin = p[0];
-      if (xMax < p[0]) xMax = p[0];
-      if (yMin > p[1]) yMin = p[1];
-      if (yMax < p[1]) yMax = p[1];
+  xMin = yMin = std::numeric_limits<double>::max (),
+  xMax = yMax = std::numeric_limits<double>::min ();
+  for (const auto &o : poly.outlines ()) {
+    for (const auto &p : o.vertices) {
+      if (xMin > p[0])
+        xMin = p[0];
+      if (xMax < p[0])
+        xMax = p[0];
+      if (yMin > p[1])
+        yMin = p[1];
+      if (yMax < p[1])
+        yMax = p[1];
     }
   }
 
-  export_dxf_header(output, xMin, yMin, xMax, yMax);
+  export_dxf_header (output, xMin, yMin, xMax, yMax);
 
   // REFERENCE:
   // DXF (AutoCAD Drawing Interchange Format) Family, ASCII variant
@@ -190,69 +243,94 @@ static void export_dxf(const Polygon2d& poly, std::ostream& output)
   // DXF Format
   //    https://documentation.help/AutoCAD-DXF/WSfacf1429558a55de185c428100849a0ab7-5f35.htm
 
-  output << "  0\n" << "SECTION\n"
-         << "  2\n" << "ENTITIES\n";
+  output << "  0\n"
+         << "SECTION\n"
+         << "  2\n"
+         << "ENTITIES\n";
 
-  for (const auto& o : poly.outlines()) {
-    switch (o.vertices.size() ) {
+  for (const auto &o : poly.outlines ()) {
+    switch (o.vertices.size ()) {
     case 1: {
       // POINT: just in case it's supported in the future
-      const Vector2d& p = o.vertices[0];
-      output << "  0\n" << "POINT\n"
-             << "100\n" << "AcDbEntity\n"
-             << "  8\n" << "0\n" // layer 0
-             << "100\n" << "AcDbPoint\n"
-             << " 10\n" << p[0] << "\n" // x
-             << " 20\n" << p[1] << "\n"; // y
+      const Vector2d &p = o.vertices[0];
+      output << "  0\n"
+             << "POINT\n"
+             << "100\n"
+             << "AcDbEntity\n"
+             << "  8\n"
+             << "0\n" // layer 0
+             << "100\n"
+             << "AcDbPoint\n"
+             << " 10\n"
+             << p[0] << "\n" // x
+             << " 20\n"
+             << p[1] << "\n"; // y
     } break;
     case 2: {
       // LINE: just in case it's supported in the future
       // The [X1 Y1 X2 Y2] order is the most common and can be parsed linearly.
       // Some libraries, like the python libraries dxfgrabber and ezdxf, cannot open [X1 X2 Y1 Y2] order.
-      const Vector2d& p1 = o.vertices[0];
-      const Vector2d& p2 = o.vertices[1];
-      output << "  0\n" << "LINE\n"
-             << "100\n" << "AcDbEntity\n"
-             << "  8\n" << "0\n" // layer 0
-             << "100\n" << "AcDbLine\n"
-             << " 10\n" << p1[0] << "\n" // x1
-             << " 20\n" << p1[1] << "\n" // y1
-             << " 11\n" << p2[0] << "\n" // x2
-             << " 21\n" << p2[1] << "\n"; // y2
+      const Vector2d &p1 = o.vertices[0];
+      const Vector2d &p2 = o.vertices[1];
+      output << "  0\n"
+             << "LINE\n"
+             << "100\n"
+             << "AcDbEntity\n"
+             << "  8\n"
+             << "0\n" // layer 0
+             << "100\n"
+             << "AcDbLine\n"
+             << " 10\n"
+             << p1[0] << "\n" // x1
+             << " 20\n"
+             << p1[1] << "\n" // y1
+             << " 11\n"
+             << p2[0] << "\n" // x2
+             << " 21\n"
+             << p2[1] << "\n"; // y2
     } break;
     default:
       // LWPOLYLINE
-      output << "  0\n" << "LWPOLYLINE\n"
-             << "100\n" << "AcDbEntity\n"
-             << "  8\n" << "0\n"      // layer 0
-             << "100\n" << "AcDbPolyline\n"
-             << " 90\n" << o.vertices.size() << "\n" // number of vertices
-             << " 70\n" << "1\n";         // closed = 1
-      for (const auto& p : o.vertices) {
-        output << " 10\n" << p[0] << "\n"
-               << " 20\n" << p[1] << "\n";
+      output << "  0\n"
+             << "LWPOLYLINE\n"
+             << "100\n"
+             << "AcDbEntity\n"
+             << "  8\n"
+             << "0\n" // layer 0
+             << "100\n"
+             << "AcDbPolyline\n"
+             << " 90\n"
+             << o.vertices.size () << "\n" // number of vertices
+             << " 70\n"
+             << "1\n"; // closed = 1
+      for (const auto &p : o.vertices) {
+        output << " 10\n"
+               << p[0] << "\n"
+               << " 20\n"
+               << p[1] << "\n";
       }
       break;
     }
   }
 
-  output << "  0\n" << "ENDSEC\n";
-  output << "  0\n" << "EOF\n";
+  output << "  0\n"
+         << "ENDSEC\n";
+  output << "  0\n"
+         << "EOF\n";
 
-  setlocale(LC_NUMERIC, ""); // set default locale
+  setlocale (LC_NUMERIC, ""); // set default locale
 }
 
-void export_dxf(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
-    for (const auto& item : geomlist->getChildren()) {
-      export_dxf(item.second, output);
+void export_dxf (const std::shared_ptr<const Geometry> &geom, std::ostream &output) {
+  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList> (geom)) {
+    for (const auto &item : geomlist->getChildren ()) {
+      export_dxf (item.second, output);
     }
-  } else if (const auto poly = std::dynamic_pointer_cast<const Polygon2d>(geom)) {
-    export_dxf(*poly, output);
-  } else if (std::dynamic_pointer_cast<const PolySet>(geom)) { // NOLINT(bugprone-branch-clone)
-    assert(false && "Unsupported file format");
+  } else if (const auto poly = std::dynamic_pointer_cast<const Polygon2d> (geom)) {
+    export_dxf (*poly, output);
+  } else if (std::dynamic_pointer_cast<const PolySet> (geom)) { // NOLINT(bugprone-branch-clone)
+    assert (false && "Unsupported file format");
   } else { // NOLINT(bugprone-branch-clone)
-    assert(false && "Export as DXF for this geometry type is not supported");
+    assert (false && "Export as DXF for this geometry type is not supported");
   }
 }
diff --git a/src/io/export_nef.cc b/src/io/export_nef.cc
index 71aee7d06..6caedd230 100644
--- a/src/io/export_nef.cc
+++ b/src/io/export_nef.cc
@@ -36,21 +36,19 @@
 #include "geometry/cgal/cgal.h"
 #include "geometry/cgal/cgalutils.h"
 
-void export_nefdbg(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
-  if (auto N = CGALUtils::getNefPolyhedronFromGeometry(geom)) {
-    output << N->dump();
+void export_nefdbg (const std::shared_ptr<const Geometry> &geom, std::ostream &output) {
+  if (auto N = CGALUtils::getNefPolyhedronFromGeometry (geom)) {
+    output << N->dump ();
   } else {
-    LOG("Not a CGALNefPoly. Add some CSG ops?");
+    LOG ("Not a CGALNefPoly. Add some CSG ops?");
   }
 }
 
-void export_nef3(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
-  if (auto N = CGALUtils::getNefPolyhedronFromGeometry(geom)) {
-    output << const_cast<CGAL_Nef_polyhedron3&>(*N->p3); // NOLINT(clang-analyzer-cplusplus.NewDeleteLeaks)
+void export_nef3 (const std::shared_ptr<const Geometry> &geom, std::ostream &output) {
+  if (auto N = CGALUtils::getNefPolyhedronFromGeometry (geom)) {
+    output << const_cast<CGAL_Nef_polyhedron3 &> (*N->p3); // NOLINT(clang-analyzer-cplusplus.NewDeleteLeaks)
   } else {
-    LOG("Not a CGALNefPoly. Add some CSG ops?");
+    LOG ("Not a CGALNefPoly. Add some CSG ops?");
   }
 }
 #endif // ifdef ENABLE_CGAL
diff --git a/src/io/export_obj.cc b/src/io/export_obj.cc
index 27e25d848..ab48705dc 100644
--- a/src/io/export_obj.cc
+++ b/src/io/export_obj.cc
@@ -34,31 +34,30 @@
 #include "geometry/PolySetUtils.h"
 #include "geometry/PolySet.h"
 
-void export_obj(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
+void export_obj (const std::shared_ptr<const Geometry> &geom, std::ostream &output) {
   // FIXME: In lazy union mode, should we export multiple objects?
 
-  std::shared_ptr<const PolySet> out = PolySetUtils::getGeometryAsPolySet(geom);
-  if (!out->isTriangular()) {
+  std::shared_ptr<const PolySet> out = PolySetUtils::getGeometryAsPolySet (geom);
+  if (!out->isTriangular ()) {
     // While the OBJ format allows for faces to have more than 3
     // vertices, this seems to confuse a number of applications
     // we care about, so for now this will just always tesselate
     // faces to be composed of triangles only.
     //
     // See: https://github.com/openscad/openscad/issues/5993
-    out = PolySetUtils::tessellate_faces(*out);
+    out = PolySetUtils::tessellate_faces (*out);
   }
-  if (Feature::ExperimentalPredictibleOutput.is_enabled()) {
-    out = createSortedPolySet(*out);
+  if (Feature::ExperimentalPredictibleOutput.is_enabled ()) {
+    out = createSortedPolySet (*out);
   }
 
   output << "# OpenSCAD obj exporter\n";
 
-  for (const auto& v : out->vertices) {
+  for (const auto &v : out->vertices) {
     output << "v " << v[0] << " " << v[1] << " " << v[2] << "\n";
   }
 
-  for (const auto& poly : out->indices) {
+  for (const auto &poly : out->indices) {
     output << "f ";
     for (const auto idx : poly) {
       output << " " << idx + 1;
diff --git a/src/io/export_off.cc b/src/io/export_off.cc
index e39c01f7a..465d3e658 100644
--- a/src/io/export_off.cc
+++ b/src/io/export_off.cc
@@ -37,38 +37,38 @@
 #include "geometry/PolySet.h"
 #include "geometry/PolySetUtils.h"
 
-void export_off(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
-  auto ps = PolySetUtils::getGeometryAsPolySet(geom);
-  if (Feature::ExperimentalPredictibleOutput.is_enabled()) {
-    ps = createSortedPolySet(*ps);
+void export_off (const std::shared_ptr<const Geometry> &geom, std::ostream &output) {
+  auto ps = PolySetUtils::getGeometryAsPolySet (geom);
+  if (Feature::ExperimentalPredictibleOutput.is_enabled ()) {
+    ps = createSortedPolySet (*ps);
   }
-  const auto& v = ps->vertices;
-  const size_t numverts = v.size();
+  const auto &v = ps->vertices;
+  const size_t numverts = v.size ();
 
-
-  output << "OFF " << numverts << " " << ps->indices.size() << " 0\n";
+  output << "OFF " << numverts << " " << ps->indices.size () << " 0\n";
   for (size_t i = 0; i < numverts; ++i) {
     output << v[i][0] << " " << v[i][1] << " " << v[i][2] << " " << "\n";
   }
 
-  auto has_color = !ps->color_indices.empty();
+  auto has_color = !ps->color_indices.empty ();
 
-  for (size_t i = 0; i < ps->indices.size(); ++i) {
-    const size_t nverts = ps->indices[i].size();
+  for (size_t i = 0; i < ps->indices.size (); ++i) {
+    const size_t nverts = ps->indices[i].size ();
     output << nverts;
-    for (size_t n = 0; n < nverts; ++n) output << " " << ps->indices[i][n];
+    for (size_t n = 0; n < nverts; ++n)
+      output << " " << ps->indices[i][n];
     if (has_color) {
       auto color_index = ps->color_indices[i];
       if (color_index >= 0) {
         auto color = ps->colors[color_index];
         int r, g, b, a;
-        if (!color.getRgba(r, g, b, a)) {
-          LOG(message_group::Warning, "Invalid color in OFF export");
+        if (!color.getRgba (r, g, b, a)) {
+          LOG (message_group::Warning, "Invalid color in OFF export");
         }
         output << " " << r << " " << g << " " << b;
         // Alpha channel is read by apps like MeshLab.
-        if (a != 255) output << " " << a;
+        if (a != 255)
+          output << " " << a;
       }
     }
     output << "\n";
diff --git a/src/io/export_param.cc b/src/io/export_param.cc
index 3561e8660..3b1dd76a2 100644
--- a/src/io/export_param.cc
+++ b/src/io/export_param.cc
@@ -35,30 +35,29 @@
 
 using json = nlohmann::json;
 
-bool export_param(SourceFile *sourceFile, const fs::path& path, std::ostream& output)
-{
-  const ParameterObjects parameters = ParameterObjects::fromSourceFile(sourceFile);
+bool export_param (SourceFile *sourceFile, const fs::path &path, std::ostream &output) {
+  const ParameterObjects parameters = ParameterObjects::fromSourceFile (sourceFile);
 
   json params;
-  for (auto& param : parameters) {
-    const std::string description = param->description();
-    const std::string group = param->group();
+  for (auto &param : parameters) {
+    const std::string description = param->description ();
+    const std::string group = param->group ();
 
     json o;
-    o["name"] = param->name();
-    if (!description.empty()) {
+    o["name"] = param->name ();
+    if (!description.empty ()) {
       o["caption"] = description;
     }
-    if (!group.empty()) {
+    if (!group.empty ()) {
       o["group"] = group;
     }
-    o.merge_patch(param->jsonValue());
-    params.push_back(o);
+    o.merge_patch (param->jsonValue ());
+    params.push_back (o);
   }
 
   json paramFile;
-  paramFile["title"] = path.has_stem() ? path.stem().generic_string() : "Unnamed";
-  if (params.size() > 0) {
+  paramFile["title"] = path.has_stem () ? path.stem ().generic_string () : "Unnamed";
+  if (params.size () > 0) {
     paramFile["parameters"] = params;
   }
   output << paramFile;
diff --git a/src/io/export_pdf.cc b/src/io/export_pdf.cc
index 1da26cd7a..4843849a9 100644
--- a/src/io/export_pdf.cc
+++ b/src/io/export_pdf.cc
@@ -26,9 +26,8 @@ constexpr inline auto FONT = "Liberation Sans";
 constexpr double MARGIN = 30.0;
 constexpr double PTS_IN_MM = 2.834645656693;
 
-std::string get_cairo_version()
-{
-  return OpenSCAD::get_version(CAIRO_VERSION_STRING, cairo_version_string());
+std::string get_cairo_version () {
+  return OpenSCAD::get_version (CAIRO_VERSION_STRING, cairo_version_string ());
 }
 
 namespace {
@@ -38,188 +37,185 @@ namespace {
 // rows map to paperSizes enums
 // columns are Width, Height
 const int paperDimensions[7][2] = {
-  {298, 420},   // A6
-  {420, 595},   // A5
-  {595, 842},   // A4
-  {842, 1190},  // A3
-  {612, 792},   // Letter
-  {612, 1008},  // Legal
-  {792, 1224},  // Tabloid
+  {298, 420}, // A6
+  {420, 595}, // A5
+  {595, 842}, // A4
+  {842, 1190}, // A3
+  {612, 792}, // Letter
+  {612, 1008}, // Legal
+  {792, 1224}, // Tabloid
 };
 
-void draw_text(const char *text, cairo_t *cr, double x, double y, double fontSize)
-{
-  cairo_select_font_face(cr, FONT, CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
-  cairo_set_font_size(cr, fontSize);
-  cairo_move_to(cr, x, y);
-  cairo_show_text(cr, text);
+void draw_text (const char *text, cairo_t *cr, double x, double y, double fontSize) {
+  cairo_select_font_face (cr, FONT, CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
+  cairo_set_font_size (cr, fontSize);
+  cairo_move_to (cr, x, y);
+  cairo_show_text (cr, text);
 }
 
-double mm_to_points(double mm) { return mm * PTS_IN_MM; }
+double mm_to_points (double mm) {
+  return mm * PTS_IN_MM;
+}
 
-double points_to_mm(double pts) { return pts / PTS_IN_MM; }
+double points_to_mm (double pts) {
+  return pts / PTS_IN_MM;
+}
 
-void draw_grid(cairo_t *cr, double left, double right, double bottom, double top, double gridSize)
-{
-  if (gridSize < 1.) gridSize = 2.0;
+void draw_grid (cairo_t *cr, double left, double right, double bottom, double top, double gridSize) {
+  if (gridSize < 1.)
+    gridSize = 2.0;
   const double darkerLine = 0.36;
   const double lightLine = 0.24;
-  const int major = (gridSize > 10.0 ? gridSize : int(10.0 / gridSize));
+  const int major = (gridSize > 10.0 ? gridSize : int (10.0 / gridSize));
 
   double pts = 0.0; // for iteration across page
 
   // Bounds are margins in points.
   // Compute Xrange in units of gridSize
-  const int Xstart = ceil(points_to_mm(left) / gridSize);
-  const int Xstop = floor(points_to_mm(right) / gridSize);
+  const int Xstart = ceil (points_to_mm (left) / gridSize);
+  const int Xstop = floor (points_to_mm (right) / gridSize);
   // Draw Horizontal lines
   for (int i = Xstart; i < Xstop + 1; i++) {
     if (i % major) {
-      cairo_set_line_width(cr, lightLine);
-      cairo_set_source_rgba(cr, 0., 0., 0., 0.48);
+      cairo_set_line_width (cr, lightLine);
+      cairo_set_source_rgba (cr, 0., 0., 0., 0.48);
     } else {
-      cairo_set_line_width(cr, darkerLine);
-      cairo_set_source_rgba(cr, 0., 0., 0., 0.6);
+      cairo_set_line_width (cr, darkerLine);
+      cairo_set_source_rgba (cr, 0., 0., 0., 0.6);
     }
-    pts = mm_to_points(i * gridSize);
-    cairo_move_to(cr, pts, top);
-    cairo_line_to(cr, pts, bottom);
-    cairo_stroke(cr);
+    pts = mm_to_points (i * gridSize);
+    cairo_move_to (cr, pts, top);
+    cairo_line_to (cr, pts, bottom);
+    cairo_stroke (cr);
   }
   // Compute Yrange in units of gridSize
-  const int Ystart = ceil(points_to_mm(top) / gridSize);
-  const int Ystop = floor(points_to_mm(bottom) / gridSize);
+  const int Ystart = ceil (points_to_mm (top) / gridSize);
+  const int Ystop = floor (points_to_mm (bottom) / gridSize);
   // Draw vertical lines
   for (int i = Ystart; i < Ystop + 1; i++) {
     if (i % major) {
-      cairo_set_line_width(cr, lightLine);
-      cairo_set_source_rgba(cr, 0., 0., 0., 0.4);
+      cairo_set_line_width (cr, lightLine);
+      cairo_set_source_rgba (cr, 0., 0., 0., 0.4);
     } else {
-      cairo_set_line_width(cr, darkerLine);
-      cairo_set_source_rgba(cr, 0., 0., 0., 0.6);
+      cairo_set_line_width (cr, darkerLine);
+      cairo_set_source_rgba (cr, 0., 0., 0., 0.6);
     }
-    pts = mm_to_points(i * gridSize);
-    cairo_move_to(cr, left, pts);
-    cairo_line_to(cr, right, pts);
-    cairo_stroke(cr);
+    pts = mm_to_points (i * gridSize);
+    cairo_move_to (cr, left, pts);
+    cairo_line_to (cr, right, pts);
+    cairo_stroke (cr);
   }
 }
 
 // New draw_axes (renamed from axis since it draws both).
-void draw_axes(cairo_t *cr, double left, double right, double bottom, double top)
-{
+void draw_axes (cairo_t *cr, double left, double right, double bottom, double top) {
   const double darkerLine = 0.36;
-  const double offset = mm_to_points(5.);
-  double pts = 0.;  // for iteration across page
+  const double offset = mm_to_points (5.);
+  double pts = 0.; // for iteration across page
 
-  cairo_set_line_width(cr, darkerLine);
-  cairo_set_source_rgba(cr, 0., 0., 0., 0.6);
+  cairo_set_line_width (cr, darkerLine);
+  cairo_set_source_rgba (cr, 0., 0., 0., 0.6);
 
   // Axes proper
   // Left axis
-  cairo_move_to(cr, left, top);
-  cairo_line_to(cr, left, bottom);
-  cairo_stroke(cr);
+  cairo_move_to (cr, left, top);
+  cairo_line_to (cr, left, bottom);
+  cairo_stroke (cr);
   // Bottom axis
-  cairo_move_to(cr, left, bottom);
-  cairo_line_to(cr, right, bottom);
-  cairo_stroke(cr);
+  cairo_move_to (cr, left, bottom);
+  cairo_line_to (cr, right, bottom);
+  cairo_stroke (cr);
 
   // tics and labels
   // bounds are margins in points.
   // compute Xrange in 10mm
-  const int Xstart = ceil(points_to_mm(left) / 10.0);
-  const int Xstop = floor(points_to_mm(right) / 10.0);
+  const int Xstart = ceil (points_to_mm (left) / 10.0);
+  const int Xstop = floor (points_to_mm (right) / 10.0);
   for (int i = Xstart; i < Xstop + 1; i++) {
-    pts = mm_to_points(i * 10.0);
-    cairo_move_to(cr, pts, bottom);
-    cairo_line_to(cr, pts, bottom + offset);
-    cairo_stroke(cr);
+    pts = mm_to_points (i * 10.0);
+    cairo_move_to (cr, pts, bottom);
+    cairo_line_to (cr, pts, bottom + offset);
+    cairo_stroke (cr);
     if (i % 2 == 0) {
-      const std::string num = std::to_string(i * 10);
-      draw_text(num.c_str(), cr, pts + 1, bottom + offset - 2, 6.0);
+      const std::string num = std::to_string (i * 10);
+      draw_text (num.c_str (), cr, pts + 1, bottom + offset - 2, 6.0);
     }
   }
   // compute Yrange in 10mm
-  const int Ystart = ceil(points_to_mm(top) / 10.0);
-  const int Ystop = floor(points_to_mm(bottom) / 10.0);
+  const int Ystart = ceil (points_to_mm (top) / 10.0);
+  const int Ystop = floor (points_to_mm (bottom) / 10.0);
   for (int i = Ystart; i < Ystop + 1; i++) {
-    pts = mm_to_points(i * 10.0);
-    cairo_move_to(cr, left, pts);
-    cairo_line_to(cr, left - offset, pts);
-    cairo_stroke(cr);
+    pts = mm_to_points (i * 10.0);
+    cairo_move_to (cr, left, pts);
+    cairo_line_to (cr, left - offset, pts);
+    cairo_stroke (cr);
     if (i % 2 == 0) {
-      const std::string num = std::to_string(-i * 10);
-      draw_text(num.c_str(), cr, left - offset, pts - 3, 6.0);
+      const std::string num = std::to_string (-i * 10);
+      draw_text (num.c_str (), cr, left - offset, pts - 3, 6.0);
     }
   }
 }
 
 // Draws a single 2D polygon.
-void draw_geom(const Polygon2d& poly, cairo_t *cr)
-{
-  for (const auto& o : poly.outlines()) {
-    if (o.vertices.empty()) {
+void draw_geom (const Polygon2d &poly, cairo_t *cr) {
+  for (const auto &o : poly.outlines ()) {
+    if (o.vertices.empty ()) {
       continue;
     }
-    const Eigen::Vector2d& p0 = o.vertices[0];
+    const Eigen::Vector2d &p0 = o.vertices[0];
     // Move to the first vertice.  Note Y is inverted in Cairo.
-    cairo_move_to(cr, mm_to_points(p0.x()), mm_to_points(-p0.y()));
-    for (unsigned int idx = 1; idx < o.vertices.size(); idx++) {
-      const Eigen::Vector2d& p = o.vertices[idx];
-      cairo_line_to(cr, mm_to_points(p.x()), mm_to_points(-p.y()));
+    cairo_move_to (cr, mm_to_points (p0.x ()), mm_to_points (-p0.y ()));
+    for (unsigned int idx = 1; idx < o.vertices.size (); idx++) {
+      const Eigen::Vector2d &p = o.vertices[idx];
+      cairo_line_to (cr, mm_to_points (p.x ()), mm_to_points (-p.y ()));
     }
     // Draw a line from the last vertice to the first vertice.
-    cairo_line_to(cr, mm_to_points(p0.x()), mm_to_points(-p0.y()));
+    cairo_line_to (cr, mm_to_points (p0.x ()), mm_to_points (-p0.y ()));
   }
 }
 
 // Main entry:  draw geometry that consists of 2D polygons.  Walks the tree...
-void draw_geom(const std::shared_ptr<const Geometry>& geom, cairo_t *cr)
-{
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
-    for (const auto& item : geomlist->getChildren()) {
-      draw_geom(item.second, cr);
+void draw_geom (const std::shared_ptr<const Geometry> &geom, cairo_t *cr) {
+  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList> (geom)) {
+    for (const auto &item : geomlist->getChildren ()) {
+      draw_geom (item.second, cr);
     }
-  } else if (std::dynamic_pointer_cast<const PolySet>(geom)) {
-    assert(false && "Unsupported file format");
-  } else if (const auto poly = std::dynamic_pointer_cast<const Polygon2d>(geom)) {
-    draw_geom(*poly, cr);
+  } else if (std::dynamic_pointer_cast<const PolySet> (geom)) {
+    assert (false && "Unsupported file format");
+  } else if (const auto poly = std::dynamic_pointer_cast<const Polygon2d> (geom)) {
+    draw_geom (*poly, cr);
   } else {
-    assert(false && "Export as PDF for this geometry type is not supported");
+    assert (false && "Export as PDF for this geometry type is not supported");
   }
 }
 
-cairo_status_t export_pdf_write(void *closure, const unsigned char *data, unsigned int length)
-{
-  auto *stream = static_cast<std::ostream *>(closure);
-  stream->write(reinterpret_cast<const char *>(data), length);
+cairo_status_t export_pdf_write (void *closure, const unsigned char *data, unsigned int length) {
+  auto *stream = static_cast<std::ostream *> (closure);
+  stream->write (reinterpret_cast<const char *> (data), length);
   return !(*stream) ? CAIRO_STATUS_WRITE_ERROR : CAIRO_STATUS_SUCCESS;
 }
 
-void add_meta_data(cairo_surface_t *surface, const cairo_pdf_metadata_t metadata,
-                   const std::string& value, const std::string& value2 = "")
-{
-  const std::string v = value.empty() ? value2 : value;
-  if (v.empty()) {
+void add_meta_data (cairo_surface_t *surface, const cairo_pdf_metadata_t metadata,
+                    const std::string &value, const std::string &value2 = "") {
+  const std::string v = value.empty () ? value2 : value;
+  if (v.empty ()) {
     return;
   }
 
-  cairo_pdf_surface_set_metadata(surface, metadata, v.c_str());
+  cairo_pdf_surface_set_metadata (surface, metadata, v.c_str ());
 }
 
-}  // namespace
+} // namespace
 
-void export_pdf(const std::shared_ptr<const Geometry>& geom, std::ostream& output,
-                const ExportInfo& exportInfo)
-{
+void export_pdf (const std::shared_ptr<const Geometry> &geom, std::ostream &output,
+                 const ExportInfo &exportInfo) {
   // Extract the options.  This will change when options becomes a variant.
   const ExportPdfOptions *options;
   const ExportPdfOptions defaultPdfOptions;
 
   // Could use short-circuit short-form, but will need to grow.
   if (exportInfo.optionsPdf) {
-    options = exportInfo.optionsPdf.get();
+    options = exportInfo.optionsPdf.get ();
   } else {
     options = &defaultPdfOptions;
   }
@@ -228,122 +224,123 @@ void export_pdf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
   int pdfX, pdfY;
 
   // Fit geometry to page, get dims in mm.
-  BoundingBox bbox = geom->getBoundingBox();
-  const int minx = (int)floor(bbox.min().x());
-  const int maxy = (int)floor(bbox.max().y());
-  const int maxx = (int)ceil(bbox.max().x());
-  const int miny = (int)ceil(bbox.min().y());
+  BoundingBox bbox = geom->getBoundingBox ();
+  const int minx = (int)floor (bbox.min ().x ());
+  const int maxy = (int)floor (bbox.max ().y ());
+  const int maxx = (int)ceil (bbox.max ().x ());
+  const int miny = (int)ceil (bbox.min ().y ());
 
   // Compute page attributes in points.
-  const int spanX = mm_to_points(maxx - minx);
-  const int spanY = mm_to_points(maxy - miny);
-  const int centerX = mm_to_points(minx) + spanX / 2.0;
-  const int centerY = mm_to_points(miny) + spanY / 2.0;
+  const int spanX = mm_to_points (maxx - minx);
+  const int spanY = mm_to_points (maxy - miny);
+  const int centerX = mm_to_points (minx) + spanX / 2.0;
+  const int centerY = mm_to_points (miny) + spanY / 2.0;
 
   // Set orientation and paper size.
   if ((options->orientation == ExportPdfPaperOrientation::AUTO && spanX > spanY) ||
       (options->orientation == ExportPdfPaperOrientation::LANDSCAPE)) {
-    pdfX = paperDimensions[static_cast<int>(options->paperSize)][1];
-    pdfY = paperDimensions[static_cast<int>(options->paperSize)][0];
+    pdfX = paperDimensions[static_cast<int> (options->paperSize)][1];
+    pdfY = paperDimensions[static_cast<int> (options->paperSize)][0];
   } else {
-    pdfX = paperDimensions[static_cast<int>(options->paperSize)][0];
-    pdfY = paperDimensions[static_cast<int>(options->paperSize)][1];
+    pdfX = paperDimensions[static_cast<int> (options->paperSize)][0];
+    pdfY = paperDimensions[static_cast<int> (options->paperSize)][1];
   }
 
   // Does it fit? (in points)
   const bool inpaper = (spanX <= pdfX - MARGIN) && (spanY <= pdfY - MARGIN);
   if (!inpaper) {
-    LOG(message_group::Export_Warning, "Geometry is too large to fit into selected size.");
+    LOG (message_group::Export_Warning, "Geometry is too large to fit into selected size.");
   }
 
   //  Center on page.  Still in points.
   // Note Cairo inverts the Y axis, with zero at the top, positive going down.
   // Compute translation and auxiliary numbers in lieu of transform matrices.
   const double tcX = pdfX / 2.0 - centerX;
-  const double tcY = (pdfY / 2.0 + centerY);  // Note Geometry Y will still need to be inverted.
+  const double tcY = (pdfY / 2.0 + centerY); // Note Geometry Y will still need to be inverted.
   // Shifted exact margins
-  const double Mlx = centerX - pdfX / 2.0 + MARGIN;     // Left margin, X axis
-  const double Mrx = centerX + pdfX / 2.0 - MARGIN;     // Right margin, X axis
-  const double Mty = -(centerY - pdfY / 2.0 + MARGIN);  // INVERTED Top margin, Y axis
-  const double Mby = -(centerY + pdfY / 2.0 - MARGIN);  // INVERTED Bottom margin, Y axis
+  const double Mlx = centerX - pdfX / 2.0 + MARGIN; // Left margin, X axis
+  const double Mrx = centerX + pdfX / 2.0 - MARGIN; // Right margin, X axis
+  const double Mty = -(centerY - pdfY / 2.0 + MARGIN); // INVERTED Top margin, Y axis
+  const double Mby = -(centerY + pdfY / 2.0 - MARGIN); // INVERTED Bottom margin, Y axis
 
   // Initialize Cairo Surface and PDF
-  cairo_surface_t *surface = cairo_pdf_surface_create_for_stream(export_pdf_write, &output, pdfX, pdfY);
-  if (cairo_surface_status(surface) == cairo_status_t::CAIRO_STATUS_NULL_POINTER) {
-    cairo_surface_destroy(surface);
+  cairo_surface_t *surface = cairo_pdf_surface_create_for_stream (export_pdf_write, &output, pdfX, pdfY);
+  if (cairo_surface_status (surface) == cairo_status_t::CAIRO_STATUS_NULL_POINTER) {
+    cairo_surface_destroy (surface);
     return;
   }
 
 #if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 16, 0)
   if (options->addMetaData) {
-    add_meta_data(surface, CAIRO_PDF_METADATA_TITLE, options->metaDataTitle, exportInfo.title);
-    add_meta_data(surface, CAIRO_PDF_METADATA_CREATOR, EXPORT_CREATOR);
-    add_meta_data(surface, CAIRO_PDF_METADATA_CREATE_DATE, get_current_iso8601_date_time_utc());
-    add_meta_data(surface, CAIRO_PDF_METADATA_MOD_DATE, "");
-    add_meta_data(surface, CAIRO_PDF_METADATA_AUTHOR, options->metaDataAuthor);
-    add_meta_data(surface, CAIRO_PDF_METADATA_SUBJECT, options->metaDataSubject);
-    add_meta_data(surface, CAIRO_PDF_METADATA_KEYWORDS, options->metaDataKeywords);
+    add_meta_data (surface, CAIRO_PDF_METADATA_TITLE, options->metaDataTitle, exportInfo.title);
+    add_meta_data (surface, CAIRO_PDF_METADATA_CREATOR, EXPORT_CREATOR);
+    add_meta_data (surface, CAIRO_PDF_METADATA_CREATE_DATE, get_current_iso8601_date_time_utc ());
+    add_meta_data (surface, CAIRO_PDF_METADATA_MOD_DATE, "");
+    add_meta_data (surface, CAIRO_PDF_METADATA_AUTHOR, options->metaDataAuthor);
+    add_meta_data (surface, CAIRO_PDF_METADATA_SUBJECT, options->metaDataSubject);
+    add_meta_data (surface, CAIRO_PDF_METADATA_KEYWORDS, options->metaDataKeywords);
   }
 #endif
 
-  cairo_t *cr = cairo_create(surface);
+  cairo_t *cr = cairo_create (surface);
 
   // Note Y axis + is DOWN.  Drawings have to invert Y, but these translations account for that.
-  cairo_translate(cr, tcX, tcY);  // Center page on geometry;
+  cairo_translate (cr, tcX, tcY); // Center page on geometry;
 
-  const Color4f black = Color4f(0.0f, 0.0f, 0.0f);
+  const Color4f black = Color4f (0.0f, 0.0f, 0.0f);
 
   // create path
-  draw_geom(geom, cr);
+  draw_geom (geom, cr);
 
   if (options->fill) {
-    Color4f fillColor = OpenSCAD::getColor(options->fillColor, black);
-    cairo_set_source_rgba(cr, fillColor.r(), fillColor.g(), fillColor.b(), fillColor.a());
-    cairo_fill_preserve(cr);
+    Color4f fillColor = OpenSCAD::getColor (options->fillColor, black);
+    cairo_set_source_rgba (cr, fillColor.r (), fillColor.g (), fillColor.b (), fillColor.a ());
+    cairo_fill_preserve (cr);
   }
 
   if (options->stroke) {
-    Color4f strokeColor = OpenSCAD::getColor(options->strokeColor, black);
-    cairo_set_source_rgba(cr, strokeColor.r(), strokeColor.g(), strokeColor.b(), strokeColor.a());
-    cairo_set_line_width(cr, mm_to_points(options->strokeWidth));
-    cairo_stroke_preserve(cr);
+    Color4f strokeColor = OpenSCAD::getColor (options->strokeColor, black);
+    cairo_set_source_rgba (cr, strokeColor.r (), strokeColor.g (), strokeColor.b (), strokeColor.a ());
+    cairo_set_line_width (cr, mm_to_points (options->strokeWidth));
+    cairo_stroke_preserve (cr);
   }
 
   // clear path
-  cairo_new_path(cr);
+  cairo_new_path (cr);
 
   // Set Annotations
   const std::string about =
     "Scale is to calibrate actual printed dimension. Check both X and Y. "
     "Measure between tick 0 and last tick";
-  cairo_set_source_rgba(cr, 0.0, 0.0, 0.0, 0.48);
+  cairo_set_source_rgba (cr, 0.0, 0.0, 0.0, 0.48);
   // Design Filename
-  if (options->showDesignFilename) draw_text(exportInfo.sourceFilePath.c_str(), cr, Mlx, Mby, 10.0);
+  if (options->showDesignFilename)
+    draw_text (exportInfo.sourceFilePath.c_str (), cr, Mlx, Mby, 10.0);
   // Scale
   if (options->showScale) {
-    draw_axes(cr, Mlx, Mrx, Mty, Mby);
+    draw_axes (cr, Mlx, Mrx, Mty, Mby);
     // Scale Message
-    if (options->showScaleMsg) draw_text(about.c_str(), cr, Mlx + 1, Mty - 1, 5.0);
+    if (options->showScaleMsg)
+      draw_text (about.c_str (), cr, Mlx + 1, Mty - 1, 5.0);
     // Grid
-    if (options->showGrid) draw_grid(cr, Mlx, Mrx, Mty, Mby, options->gridSize);
+    if (options->showGrid)
+      draw_grid (cr, Mlx, Mrx, Mty, Mby, options->gridSize);
   }
 
-  cairo_show_page(cr);
-  cairo_surface_destroy(surface);
-  cairo_destroy(cr);
+  cairo_show_page (cr);
+  cairo_surface_destroy (surface);
+  cairo_destroy (cr);
 }
 
-#else  // ENABLE_CAIRO
+#else // ENABLE_CAIRO
 
-const std::string get_cairo_version()
-{
+const std::string get_cairo_version () {
   const std::string cairo_version = "(not enabled)";
   return cairo_version;
 }
 
-void export_pdf(const std::shared_ptr<const Geometry>&, std::ostream&, const ExportInfo&)
-{
-  LOG(message_group::Error, "Export to PDF format was not enabled when building the application.");
+void export_pdf (const std::shared_ptr<const Geometry> &, std::ostream &, const ExportInfo &) {
+  LOG (message_group::Error, "Export to PDF format was not enabled when building the application.");
 }
 
-#endif  // ENABLE_CAIRO
+#endif // ENABLE_CAIRO
diff --git a/src/io/export_png.cc b/src/io/export_png.cc
index b12e4380b..f33d1b467 100644
--- a/src/io/export_png.cc
+++ b/src/io/export_png.cc
@@ -21,113 +21,115 @@
 #ifdef ENABLE_OPENCSG
 #include "glview/preview/OpenCSGRenderer.h"
 #include <opencsg.h>
-#endif  // ENABLE_OPENCSG
+#endif // ENABLE_OPENCSG
 
 #include "glview/preview/ThrownTogetherRenderer.h"
 
 namespace {
 
-void setupCamera(Camera& cam, const BoundingBox& bbox)
-{
-  if (cam.viewall) cam.viewAll(bbox);
+void setupCamera (Camera &cam, const BoundingBox &bbox) {
+  if (cam.viewall)
+    cam.viewAll (bbox);
 }
 
-}  // namespace
+} // namespace
 
-bool export_png(const std::shared_ptr<const Geometry>& root_geom, const ViewOptions& options, Camera& camera, std::ostream& output)
-{
-  assert(root_geom != nullptr);
-  PRINTD("export_png geom");
+bool export_png (const std::shared_ptr<const Geometry> &root_geom, const ViewOptions &options, Camera &camera, std::ostream &output) {
+  assert (root_geom != nullptr);
+  PRINTD ("export_png geom");
   std::unique_ptr<OffscreenView> glview;
   try {
-    glview = std::make_unique<OffscreenView>(camera.pixel_width, camera.pixel_height);
-  } catch (const OffscreenViewException& ex) {
-    fprintf(stderr, "Can't create OffscreenView: %s.\n", ex.what());
+    glview = std::make_unique<OffscreenView> (camera.pixel_width, camera.pixel_height);
+  } catch (const OffscreenViewException &ex) {
+    fprintf (stderr, "Can't create OffscreenView: %s.\n", ex.what ());
     return false;
   }
   std::shared_ptr<Renderer> geomRenderer;
   // Choose PolySetRenderer for PolySet and Polygon2d, and for Manifold since we
   // know that all geometries are convertible to PolySet.
-  if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend ||
-      std::dynamic_pointer_cast<const PolySet>(root_geom) ||
-      std::dynamic_pointer_cast<const Polygon2d>(root_geom)){
-    geomRenderer = std::make_shared<PolySetRenderer>(root_geom);
+  if (RenderSettings::inst ()->backend3D == RenderBackend3D::ManifoldBackend ||
+      std::dynamic_pointer_cast<const PolySet> (root_geom) ||
+      std::dynamic_pointer_cast<const Polygon2d> (root_geom)) {
+    geomRenderer = std::make_shared<PolySetRenderer> (root_geom);
   } else {
-    geomRenderer = std::make_shared<CGALRenderer>(root_geom);
+    geomRenderer = std::make_shared<CGALRenderer> (root_geom);
   }
-  const BoundingBox bbox = geomRenderer->getBoundingBox();
-  setupCamera(camera, bbox);
-
-  glview->setCamera(camera);
-  glview->setRenderer(geomRenderer);
-  glview->setColorScheme(RenderSettings::inst()->colorscheme);
-  glview->setShowCrosshairs(options["crosshairs"]);
-  glview->setShowAxes(options["axes"]);
-  glview->setShowScaleProportional(options["scales"]);
-  glview->setShowEdges(options["edges"]);
-  glview->paintGL();
-  glview->save(output);
+  const BoundingBox bbox = geomRenderer->getBoundingBox ();
+  setupCamera (camera, bbox);
+
+  glview->setCamera (camera);
+  glview->setRenderer (geomRenderer);
+  glview->setColorScheme (RenderSettings::inst ()->colorscheme);
+  glview->setShowCrosshairs (options["crosshairs"]);
+  glview->setShowAxes (options["axes"]);
+  glview->setShowScaleProportional (options["scales"]);
+  glview->setShowEdges (options["edges"]);
+  glview->paintGL ();
+  glview->save (output);
   return true;
 }
 
-std::unique_ptr<OffscreenView> prepare_preview(Tree& tree, const ViewOptions& options, Camera& camera)
-{
-  PRINTD("prepare_preview_common");
-  CsgInfo csgInfo = CsgInfo();
-  csgInfo.compile_products(tree);
+std::unique_ptr<OffscreenView> prepare_preview (Tree &tree, const ViewOptions &options, Camera &camera) {
+  PRINTD ("prepare_preview_common");
+  CsgInfo csgInfo = CsgInfo ();
+  csgInfo.compile_products (tree);
 
   std::unique_ptr<OffscreenView> glview;
   try {
-    glview = std::make_unique<OffscreenView>(camera.pixel_width, camera.pixel_height);
-  } catch (const OffscreenViewException& ex) {
-    LOG("Can't create OffscreenView: %1$s.", ex.what());
+    glview = std::make_unique<OffscreenView> (camera.pixel_width, camera.pixel_height);
+  } catch (const OffscreenViewException &ex) {
+    LOG ("Can't create OffscreenView: %1$s.", ex.what ());
     return nullptr;
   }
 
   std::shared_ptr<Renderer> renderer;
   if (options.previewer == Previewer::OPENCSG) {
 #ifdef ENABLE_OPENCSG
-    PRINTD("Initializing OpenCSGRenderer");
-    renderer = std::make_shared<OpenCSGRenderer>(csgInfo.root_products, csgInfo.highlights_products, csgInfo.background_products);
+    PRINTD ("Initializing OpenCSGRenderer");
+    renderer = std::make_shared<OpenCSGRenderer> (csgInfo.root_products, csgInfo.highlights_products, csgInfo.background_products);
 #else
-    fprintf(stderr, "This openscad was built without OpenCSG support\n");
+    fprintf (stderr, "This openscad was built without OpenCSG support\n");
     return 0;
 #endif
   } else {
-    PRINTD("Initializing ThrownTogetherRenderer");
-    renderer = std::make_shared<ThrownTogetherRenderer>(csgInfo.root_products, csgInfo.highlights_products, csgInfo.background_products);
+    PRINTD ("Initializing ThrownTogetherRenderer");
+    renderer = std::make_shared<ThrownTogetherRenderer> (csgInfo.root_products, csgInfo.highlights_products, csgInfo.background_products);
   }
 
-  glview->setRenderer(renderer);
-
+  glview->setRenderer (renderer);
 
 #ifdef ENABLE_OPENCSG
-  const BoundingBox bbox = glview->getRenderer()->getBoundingBox();
-  setupCamera(camera, bbox);
+  const BoundingBox bbox = glview->getRenderer ()->getBoundingBox ();
+  setupCamera (camera, bbox);
 
-  glview->setCamera(camera);
-  OpenCSG::setContext(0);
-  OpenCSG::setOption(OpenCSG::OffscreenSetting, OpenCSG::FrameBufferObject);
+  glview->setCamera (camera);
+  OpenCSG::setContext (0);
+  OpenCSG::setOption (OpenCSG::OffscreenSetting, OpenCSG::FrameBufferObject);
 #endif
-  glview->setColorScheme(RenderSettings::inst()->colorscheme);
-  glview->setShowAxes(options["axes"]);
-  glview->setShowScaleProportional(options["scales"]);
-  glview->setShowEdges(options["edges"]);
-  glview->paintGL();
+  glview->setColorScheme (RenderSettings::inst ()->colorscheme);
+  glview->setShowAxes (options["axes"]);
+  glview->setShowScaleProportional (options["scales"]);
+  glview->setShowEdges (options["edges"]);
+  glview->paintGL ();
   return glview;
 }
 
-bool export_png(const OffscreenView& glview, std::ostream& output)
-{
-  PRINTD("export_png_preview_common");
-  glview.save(output);
+bool export_png (const OffscreenView &glview, std::ostream &output) {
+  PRINTD ("export_png_preview_common");
+  glview.save (output);
   return true;
 }
 
 #else // NULLGL
 
-bool export_png(const std::shared_ptr<const Geometry>& root_geom, const ViewOptions& options, Camera& camera, std::ostream& output) { return false; }
-std::unique_ptr<OffscreenView> prepare_preview(Tree& tree, const ViewOptions& options, Camera& camera) { return nullptr; }
-bool export_png(const OffscreenView& glview, std::ostream& output) { return false; }
+bool export_png (const std::shared_ptr<const Geometry> &root_geom, const ViewOptions &options, Camera &camera, std::ostream &output) {
+  return false;
+}
+std::unique_ptr<OffscreenView> prepare_preview (Tree &tree, const ViewOptions &options, Camera &camera) {
+  return nullptr;
+}
+bool export_png (const OffscreenView &glview, std::ostream &output) {
+  return false;
+}
 
 #endif // NULLGL
diff --git a/src/io/export_pov.cc b/src/io/export_pov.cc
index 176a9e661..5cb35b660 100644
--- a/src/io/export_pov.cc
+++ b/src/io/export_pov.cc
@@ -36,12 +36,10 @@
 #include "geometry/PolySetUtils.h"
 #include "geometry/linalg.h"
 
-
-void export_pov(const std::shared_ptr<const Geometry>& geom, std::ostream& output, const ExportInfo& exportInfo)
-{
-  std::shared_ptr<const PolySet> ps = PolySetUtils::getGeometryAsPolySet(geom);
-  if (Feature::ExperimentalPredictibleOutput.is_enabled()) {
-    ps = createSortedPolySet(*ps);
+void export_pov (const std::shared_ptr<const Geometry> &geom, std::ostream &output, const ExportInfo &exportInfo) {
+  std::shared_ptr<const PolySet> ps = PolySetUtils::getGeometryAsPolySet (geom);
+  if (Feature::ExperimentalPredictibleOutput.is_enabled ()) {
+    ps = createSortedPolySet (*ps);
   }
 
   output << "// Generated by " << EXPORT_CREATOR << "\n";
@@ -53,31 +51,32 @@ void export_pov(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
   output << "#declare MATERIAL=finish { specular 0.5 roughness 0.001 reflection{0 0.63 fresnel} ambient 0 diffuse 0.6 conserve_energy }\n";
   output << "#declare MATERIAL_INT=interior{ior 1.32}\n";
 
-  auto has_color = !ps->color_indices.empty();
-
-  for (size_t polygon_index = 0; polygon_index < ps->indices.size(); polygon_index++) {
-    const auto& polygon = ps->indices[polygon_index];
-    output << "polygon { " << polygon.size() + 1 << ", \n";
-    for (size_t i = 0; i < polygon.size(); i++) {
-      if (i)output << ", ";
-      const auto& x = ps->vertices[polygon[i]].x();
-      const auto& y = ps->vertices[polygon[i]].y();
-      const auto& z = ps->vertices[polygon[i]].z();
+  auto has_color = !ps->color_indices.empty ();
+
+  for (size_t polygon_index = 0; polygon_index < ps->indices.size (); polygon_index++) {
+    const auto &polygon = ps->indices[polygon_index];
+    output << "polygon { " << polygon.size () + 1 << ", \n";
+    for (size_t i = 0; i < polygon.size (); i++) {
+      if (i)
+        output << ", ";
+      const auto &x = ps->vertices[polygon[i]].x ();
+      const auto &y = ps->vertices[polygon[i]].y ();
+      const auto &z = ps->vertices[polygon[i]].z ();
       output << "<" << x << ", " << y << ", " << z << ">";
     }
-    output << ", <" << ps->vertices[polygon[0]].x() << ", " << ps->vertices[polygon[0]].y() << ", " << ps->vertices[polygon[0]].z() << ">";
-    float r = exportInfo.defaultColor.r();
-    float g = exportInfo.defaultColor.g();
-    float b = exportInfo.defaultColor.b();
+    output << ", <" << ps->vertices[polygon[0]].x () << ", " << ps->vertices[polygon[0]].y () << ", " << ps->vertices[polygon[0]].z () << ">";
+    float r = exportInfo.defaultColor.r ();
+    float g = exportInfo.defaultColor.g ();
+    float b = exportInfo.defaultColor.b ();
     float f = 0.;
     if (has_color) {
       auto color_index = ps->color_indices[polygon_index];
       if (color_index >= 0) {
         auto color = ps->colors[color_index];
-        r = color.r();
-        g = color.g();
-        b = color.b();
-        f = 1.0 - color.a();
+        r = color.r ();
+        g = color.g ();
+        b = color.b ();
+        f = 1.0 - color.a ();
       }
     }
     output << "\n";
@@ -86,52 +85,57 @@ void export_pov(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
     output << "}\n";
   }
 
-  BoundingBox bbox = geom->getBoundingBox();
+  BoundingBox bbox = geom->getBoundingBox ();
 
-  auto& min_x = bbox.min().x();
-  auto& min_y = bbox.min().y();
-  auto& min_z = bbox.min().z();
+  auto &min_x = bbox.min ().x ();
+  auto &min_y = bbox.min ().y ();
+  auto &min_z = bbox.min ().z ();
 
-  auto& max_x = bbox.max().x();
-  auto& max_y = bbox.max().y();
-  auto& max_z = bbox.max().z();
+  auto &max_x = bbox.max ().x ();
+  auto &max_y = bbox.max ().y ();
+  auto &max_z = bbox.max ().z ();
 
   const double dx = max_x - min_x;
   const double dy = max_y - min_y;
   const double dz = max_z - min_z;
 
   constexpr double move_away_factor = 2.;
-  const std::vector<double> lx { min_x - dx * move_away_factor, bbox.center().x(), max_x + dx * move_away_factor };
-  const std::vector<double> ly { min_y - dy * move_away_factor, bbox.center().y(), max_y + dy * move_away_factor };
-  const std::vector<double> lz { min_z - dz * move_away_factor, bbox.center().z(), max_z + dz * move_away_factor };
+  const std::vector<double> lx{min_x - dx * move_away_factor, bbox.center ().x (), max_x + dx * move_away_factor};
+  const std::vector<double> ly{min_y - dy * move_away_factor, bbox.center ().y (), max_y + dy * move_away_factor};
+  const std::vector<double> lz{min_z - dz * move_away_factor, bbox.center ().z (), max_z + dz * move_away_factor};
 
-  constexpr float brightness = 0.2;  // 1.0 is way too bright
+  constexpr float brightness = 0.2; // 1.0 is way too bright
 
-  for (auto cur_lx: lx) {
-    for (auto cur_ly: ly) {
-      for (auto cur_lz: lz)
+  for (auto cur_lx : lx) {
+    for (auto cur_ly : ly) {
+      for (auto cur_lz : lz)
         output << "light_source { <" << cur_lx << ", " << cur_ly << ", " << cur_lz << "> color rgb <" << brightness << ", " << brightness << ", " << brightness << "> }\n";
     }
   }
 
   if (exportInfo.camera) {
-    auto vpt = exportInfo.camera->getVpt();
-    auto vpr = exportInfo.camera->getVpr();
+    auto vpt = exportInfo.camera->getVpt ();
+    auto vpr = exportInfo.camera->getVpr ();
 
-    auto pitch = vpr.x();
-    auto yaw = vpr.y();
-    auto roll = vpr.z();
+    auto pitch = vpr.x ();
+    auto yaw = vpr.y ();
+    auto roll = vpr.z ();
 
     output << "camera { look_at <" << 0 << ", " << 0 << ", " << 0 << ">\n "
-      "location <" << 0 << ", " << 0 << ", " << exportInfo.camera->viewer_distance << ">\n "
-      "angle " << exportInfo.camera->fov << " up <0, 1, 0> right <1, 0, 0> sky <0, 1, 0> right -x*image_width/image_height\n"
-      "translate <" << vpt.x() << ", " << vpt.y() << ", " << vpt.z() << ">\n"
-      "rotate <" << pitch << ", " << yaw << " + clock * 3, " << roll << " + clock>\n"
-      "}\n";
+                                                                     "location <"
+           << 0 << ", " << 0 << ", " << exportInfo.camera->viewer_distance << ">\n "
+                                                                              "angle "
+           << exportInfo.camera->fov << " up <0, 1, 0> right <1, 0, 0> sky <0, 1, 0> right -x*image_width/image_height\n"
+                                        "translate <"
+           << vpt.x () << ", " << vpt.y () << ", " << vpt.z () << ">\n"
+                                                                  "rotate <"
+           << pitch << ", " << yaw << " + clock * 3, " << roll << " + clock>\n"
+                                                                  "}\n";
   } else {
-    output << "camera { look_at <" << bbox.center().x() << ", " << bbox.center().y() << ", " << bbox.center().z() << "> "
-      "location <" << min_x + dx * move_away_factor << ", " << min_y - dy * move_away_factor << ", " << min_z + dz * move_away_factor << "> "
-      "up <0, 0, 1> right <1, 0, 0> sky <0, 0, 1> rotate <-55, clock * 3, clock + 25> right x*image_width/image_height }\n";
+    output << "camera { look_at <" << bbox.center ().x () << ", " << bbox.center ().y () << ", " << bbox.center ().z () << "> "
+                                                                                                                           "location <"
+           << min_x + dx * move_away_factor << ", " << min_y - dy * move_away_factor << ", " << min_z + dz * move_away_factor << "> "
+                                                                                                                                 "up <0, 0, 1> right <1, 0, 0> sky <0, 0, 1> rotate <-55, clock * 3, clock + 25> right x*image_width/image_height }\n";
   }
 
   output << "#include \"rad_def.inc\"\n";
diff --git a/src/io/export_stl.cc b/src/io/export_stl.cc
index cda164f78..702fd379c 100644
--- a/src/io/export_stl.cc
+++ b/src/io/export_stl.cc
@@ -67,62 +67,57 @@ namespace {
 #define DC_MAX_LEADING_ZEROES (5)
 #define DC_MAX_TRAILING_ZEROES (0)
 
-std::string toString(const Vector3d& v)
-{
-  const double_conversion::DoubleToStringConverter dc(
+std::string toString (const Vector3d &v) {
+  const double_conversion::DoubleToStringConverter dc (
     DC_FLAGS, DC_INF, DC_NAN, DC_EXP,
-    DC_DECIMAL_LOW_EXP, DC_DECIMAL_HIGH_EXP, DC_MAX_LEADING_ZEROES, DC_MAX_TRAILING_ZEROES
-    );
+    DC_DECIMAL_LOW_EXP, DC_DECIMAL_HIGH_EXP, DC_MAX_LEADING_ZEROES, DC_MAX_TRAILING_ZEROES);
 
   char buffer[DC_BUFFER_SIZE];
 
-  double_conversion::StringBuilder builder(buffer, DC_BUFFER_SIZE);
-  dc.ToShortest(v[0], &builder);
-  builder.AddCharacter(' ');
-  dc.ToShortest(v[1], &builder);
-  builder.AddCharacter(' ');
-  dc.ToShortest(v[2], &builder);
-  builder.Finalize();
+  double_conversion::StringBuilder builder (buffer, DC_BUFFER_SIZE);
+  dc.ToShortest (v[0], &builder);
+  builder.AddCharacter (' ');
+  dc.ToShortest (v[1], &builder);
+  builder.AddCharacter (' ');
+  dc.ToShortest (v[2], &builder);
+  builder.Finalize ();
 
   return buffer;
 }
 
-int32_t flipEndianness(int32_t x) {
-  return
-    ((x << 24) & 0xff000000) | ((x >> 24) & 0xff) |
-    ((x << 8) & 0xff0000) | ((x >> 8) & 0xff00);
+int32_t flipEndianness (int32_t x) {
+  return ((x << 24) & 0xff000000) | ((x >> 24) & 0xff) |
+         ((x << 8) & 0xff0000) | ((x >> 8) & 0xff00);
 }
 
 template <size_t N>
-void write_floats(std::ostream& output, const std::array<float, N>& data) {
+void write_floats (std::ostream &output, const std::array<float, N> &data) {
   static constexpr uint16_t test = 0x0001;
-  static const bool isLittleEndian = *reinterpret_cast<const char *>(&test) == 1;
+  static const bool isLittleEndian = *reinterpret_cast<const char *> (&test) == 1;
 
   if (isLittleEndian) {
-    output.write(reinterpret_cast<char *>(const_cast<float *>(&data[0])), N * sizeof(float));
+    output.write (reinterpret_cast<char *> (const_cast<float *> (&data[0])), N * sizeof (float));
   } else {
-    std::array<float, N> copy(data);
+    std::array<float, N> copy (data);
 
-    auto *ints = reinterpret_cast<int32_t *>(&copy[0]);
+    auto *ints = reinterpret_cast<int32_t *> (&copy[0]);
     for (size_t i = 0; i < N; i++) {
-      ints[i] = flipEndianness(ints[i]);
+      ints[i] = flipEndianness (ints[i]);
     }
 
-    output.write(reinterpret_cast<char *>(&copy[0]), N * sizeof(float));
+    output.write (reinterpret_cast<char *> (&copy[0]), N * sizeof (float));
   }
 }
 
-
-uint64_t append_stl(const std::shared_ptr<const PolySet>& polyset, std::ostream& output, bool binary)
-{
-  static_assert(sizeof(float) == 4, "Need 32 bit float");
+uint64_t append_stl (const std::shared_ptr<const PolySet> &polyset, std::ostream &output, bool binary) {
+  static_assert (sizeof (float) == 4, "Need 32 bit float");
 
   std::shared_ptr<const PolySet> ps = polyset;
-  if (!ps->isTriangular()) {
-    ps = PolySetUtils::tessellate_faces(*ps);
+  if (!ps->isTriangular ()) {
+    ps = PolySetUtils::tessellate_faces (*ps);
   }
-  if (Feature::ExperimentalPredictibleOutput.is_enabled()) {
-    ps = createSortedPolySet(*ps);
+  if (Feature::ExperimentalPredictibleOutput.is_enabled ()) {
+    ps = createSortedPolySet (*ps);
   }
 
   uint64_t triangle_count = 0;
@@ -130,55 +125,55 @@ uint64_t append_stl(const std::shared_ptr<const PolySet>& polyset, std::ostream&
   // In ASCII mode only, convert each vertex to string.
   std::vector<std::string> vertexStrings;
   if (!binary) {
-    vertexStrings.resize(ps->vertices.size());
-    std::transform(ps->vertices.begin(), ps->vertices.end(), vertexStrings.begin(),
-                   [](const auto& p) {
-        return toString(p);
-      });
+    vertexStrings.resize (ps->vertices.size ());
+    std::transform (ps->vertices.begin (), ps->vertices.end (), vertexStrings.begin (),
+                    [] (const auto &p) {
+                      return toString (p);
+                    });
   }
 
   // Used for binary mode only
   std::array<float, 4lu * 3> coords;
 
-  for (const auto& t : ps->indices) {
-    const auto& p0 = ps->vertices[t[0]];
-    const auto& p1 = ps->vertices[t[1]];
-    const auto& p2 = ps->vertices[t[2]];
+  for (const auto &t : ps->indices) {
+    const auto &p0 = ps->vertices[t[0]];
+    const auto &p1 = ps->vertices[t[1]];
+    const auto &p2 = ps->vertices[t[2]];
 
     // Tessellation already eliminated these cases.
-    assert(p0 != p1 && p0 != p2 && p1 != p2);
+    assert (p0 != p1 && p0 != p2 && p1 != p2);
 
-    auto normal = (p1 - p0).cross(p2 - p0);
-    if (!normal.isZero(0)) {
-      normal.normalize();
+    auto normal = (p1 - p0).cross (p2 - p0);
+    if (!normal.isZero (0)) {
+      normal.normalize ();
     }
 
     if (binary) {
       auto coords_offset = 0;
-      auto addCoords = [&](const auto& v) {
-          for (auto i : {0, 1, 2})
-            coords[coords_offset++] = v[i];
-        };
-      addCoords(normal);
-      addCoords(p0);
-      addCoords(p1);
-      addCoords(p2);
-      assert(coords_offset == 4 * 3);
-      write_floats(output, coords);
+      auto addCoords = [&] (const auto &v) {
+        for (auto i : {0, 1, 2})
+          coords[coords_offset++] = v[i];
+      };
+      addCoords (normal);
+      addCoords (p0);
+      addCoords (p1);
+      addCoords (p2);
+      assert (coords_offset == 4 * 3);
+      write_floats (output, coords);
       char attrib[2] = {0, 0};
-      output.write(attrib, 2);
+      output.write (attrib, 2);
     } else {
-      const auto& s0 = vertexStrings[t[0]];
-      const auto& s1 = vertexStrings[t[1]];
-      const auto& s2 = vertexStrings[t[2]];
+      const auto &s0 = vertexStrings[t[0]];
+      const auto &s1 = vertexStrings[t[1]];
+      const auto &s2 = vertexStrings[t[2]];
 
       // Since the points are different, the precision we use to
       // format them to string should guarantee the strings are
       // different too.
-      assert(s0 != s1 && s0 != s2 && s1 != s2);
+      assert (s0 != s1 && s0 != s2 && s1 != s2);
 
       output << "  facet normal ";
-      output << toString(normal) << "\n";
+      output << toString (normal) << "\n";
       output << "    outer loop\n";
       output << "      vertex " << s0 << "\n";
       output << "      vertex " << s1 << "\n";
@@ -197,72 +192,68 @@ uint64_t append_stl(const std::shared_ptr<const PolySet>& polyset, std::ostream&
     Saves the current 3D CGAL Nef polyhedron as STL to the given file.
     The file must be open.
  */
-uint64_t append_stl(const CGALNefGeometry& root_N, std::ostream& output,
-                    bool binary)
-{
+uint64_t append_stl (const CGALNefGeometry &root_N, std::ostream &output,
+                     bool binary) {
   uint64_t triangle_count = 0;
-  if (!root_N.p3->is_simple()) {
-    LOG(message_group::Export_Warning, "Exported object may not be a valid 2-manifold and may need repair");
+  if (!root_N.p3->is_simple ()) {
+    LOG (message_group::Export_Warning, "Exported object may not be a valid 2-manifold and may need repair");
   }
 
-  if (const std::shared_ptr<PolySet> ps = CGALUtils::createPolySetFromNefPolyhedron3(*(root_N.p3))) {
-    triangle_count += append_stl(ps, output, binary);
+  if (const std::shared_ptr<PolySet> ps = CGALUtils::createPolySetFromNefPolyhedron3 (*(root_N.p3))) {
+    triangle_count += append_stl (ps, output, binary);
   } else {
-    LOG(message_group::Export_Error, "Nef->PolySet failed");
+    LOG (message_group::Export_Error, "Nef->PolySet failed");
   }
 
   return triangle_count;
 }
 
-#endif  // ENABLE_CGAL
+#endif // ENABLE_CGAL
 
 #ifdef ENABLE_MANIFOLD
 /*!
    Saves the current 3D Manifold geometry as STL to the given file.
    The file must be open.
  */
-uint64_t append_stl(const ManifoldGeometry& mani, std::ostream& output,
-                    bool binary)
-{
+uint64_t append_stl (const ManifoldGeometry &mani, std::ostream &output,
+                     bool binary) {
   uint64_t triangle_count = 0;
-  if (!mani.isManifold()) {
-    LOG(message_group::Export_Warning, "Exported object may not be a valid 2-manifold and may need repair");
+  if (!mani.isManifold ()) {
+    LOG (message_group::Export_Warning, "Exported object may not be a valid 2-manifold and may need repair");
   }
 
-  const auto ps = mani.toPolySet();
+  const auto ps = mani.toPolySet ();
   if (ps) {
-    triangle_count += append_stl(ps, output, binary);
+    triangle_count += append_stl (ps, output, binary);
   } else {
-    LOG(message_group::Export_Error, "Manifold->PolySet failed");
+    LOG (message_group::Export_Error, "Manifold->PolySet failed");
   }
 
   return triangle_count;
 }
-#endif  // ENABLE_MANIFOLD
-
+#endif // ENABLE_MANIFOLD
 
-uint64_t append_stl(const std::shared_ptr<const Geometry>& geom, std::ostream& output,
-                    bool binary)
-{
+uint64_t append_stl (const std::shared_ptr<const Geometry> &geom, std::ostream &output,
+                     bool binary) {
   uint64_t triangle_count = 0;
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
-    for (const Geometry::GeometryItem& item : geomlist->getChildren()) {
-      triangle_count += append_stl(item.second, output, binary);
+  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList> (geom)) {
+    for (const Geometry::GeometryItem &item : geomlist->getChildren ()) {
+      triangle_count += append_stl (item.second, output, binary);
     }
-  } else if (const auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
-    triangle_count += append_stl(ps, output, binary);
+  } else if (const auto ps = std::dynamic_pointer_cast<const PolySet> (geom)) {
+    triangle_count += append_stl (ps, output, binary);
 #ifdef ENABLE_CGAL
-  } else if (const auto N = std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
-    triangle_count += append_stl(*N, output, binary);
+  } else if (const auto N = std::dynamic_pointer_cast<const CGALNefGeometry> (geom)) {
+    triangle_count += append_stl (*N, output, binary);
 #endif
 #ifdef ENABLE_MANIFOLD
-  } else if (const auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
-    triangle_count += append_stl(*mani, output, binary);
+  } else if (const auto mani = std::dynamic_pointer_cast<const ManifoldGeometry> (geom)) {
+    triangle_count += append_stl (*mani, output, binary);
 #endif
-  } else if (std::dynamic_pointer_cast<const Polygon2d>(geom)) { //NOLINT(bugprone-branch-clone)
-    assert(false && "Unsupported file format");
+  } else if (std::dynamic_pointer_cast<const Polygon2d> (geom)) { //NOLINT(bugprone-branch-clone)
+    assert (false && "Unsupported file format");
   } else { //NOLINT(bugprone-branch-clone)
-    assert(false && "Not implemented");
+    assert (false && "Not implemented");
   }
 
   return triangle_count;
@@ -270,45 +261,44 @@ uint64_t append_stl(const std::shared_ptr<const Geometry>& geom, std::ostream& o
 
 } // namespace
 
-void export_stl(const std::shared_ptr<const Geometry>& geom, std::ostream& output,
-                bool binary)
-{
+void export_stl (const std::shared_ptr<const Geometry> &geom, std::ostream &output,
+                 bool binary) {
   // FIXME: In lazy union mode, should we export multiple solids?
   if (binary) {
     std::ostringstream buffer; // Using a memory buffer
     char header[80] = "OpenSCAD Model\n";
-    buffer.write(header, sizeof(header));
+    buffer.write (header, sizeof (header));
 
     // Placeholder for triangle count
     uint32_t triangle_count = 0;
     char tmp_triangle_count[4] = {0, 0, 0, 0};
-    buffer.write(tmp_triangle_count, 4);
+    buffer.write (tmp_triangle_count, 4);
 
     // Writing triangles and counting them
-    triangle_count = append_stl(geom, buffer, binary);
+    triangle_count = append_stl (geom, buffer, binary);
 
     if (triangle_count > 4294967295) {
-      LOG(message_group::Export_Error, "Triangle count exceeded 4294967295, so the STL file is not valid");
+      LOG (message_group::Export_Error, "Triangle count exceeded 4294967295, so the STL file is not valid");
     }
 
     // Updating the triangle count in the buffer
     char triangle_count_bytes[4] = {
-      static_cast<char>(triangle_count & 0xff),
-      static_cast<char>((triangle_count >> 8) & 0xff),
-      static_cast<char>((triangle_count >> 16) & 0xff),
-      static_cast<char>((triangle_count >> 24) & 0xff)};
-    buffer.seekp(80, std::ios_base::beg);
-    buffer.write(triangle_count_bytes, 4);
+      static_cast<char> (triangle_count & 0xff),
+      static_cast<char> ((triangle_count >> 8) & 0xff),
+      static_cast<char> ((triangle_count >> 16) & 0xff),
+      static_cast<char> ((triangle_count >> 24) & 0xff)};
+    buffer.seekp (80, std::ios_base::beg);
+    buffer.write (triangle_count_bytes, 4);
 
     // Flushing the buffer to the output stream
-    output << buffer.str();
+    output << buffer.str ();
 
   } else {
     // ASCII mode: Write directly to the output stream
-    setlocale(LC_NUMERIC, "C"); // Ensure radix is . (not ,) in output
+    setlocale (LC_NUMERIC, "C"); // Ensure radix is . (not ,) in output
     output << "solid OpenSCAD_Model\n";
-    append_stl(geom, output, binary);
+    append_stl (geom, output, binary);
     output << "endsolid OpenSCAD_Model\n";
-    setlocale(LC_NUMERIC, ""); // Restore default locale
+    setlocale (LC_NUMERIC, ""); // Restore default locale
   }
 }
diff --git a/src/io/export_svg.cc b/src/io/export_svg.cc
index f4ec111cf..d1947ee61 100644
--- a/src/io/export_svg.cc
+++ b/src/io/export_svg.cc
@@ -36,19 +36,18 @@
 #include "geometry/Polygon2d.h"
 #include "geometry/PolySet.h"
 
-static void append_svg(const Polygon2d& poly, std::ostream& output)
-{
+static void append_svg (const Polygon2d &poly, std::ostream &output) {
   output << "<path d=\"\n";
-  for (const auto& o : poly.outlines()) {
-    if (o.vertices.empty()) {
+  for (const auto &o : poly.outlines ()) {
+    if (o.vertices.empty ()) {
       continue;
     }
 
-    const Eigen::Vector2d& p0 = o.vertices[0];
-    output << "M " << p0.x() << "," << -p0.y();
-    for (unsigned int idx = 1; idx < o.vertices.size(); ++idx) {
-      const Eigen::Vector2d& p = o.vertices[idx];
-      output << " L " << p.x() << "," << -p.y();
+    const Eigen::Vector2d &p0 = o.vertices[0];
+    output << "M " << p0.x () << "," << -p0.y ();
+    for (unsigned int idx = 1; idx < o.vertices.size (); ++idx) {
+      const Eigen::Vector2d &p = o.vertices[idx];
+      output << " L " << p.x () << "," << -p.y ();
       if ((idx % 6) == 5) {
         output << "\n";
       }
@@ -56,33 +55,30 @@ static void append_svg(const Polygon2d& poly, std::ostream& output)
     output << " z\n";
   }
   output << "\" stroke=\"black\" fill=\"lightgray\" stroke-width=\"0.5\"/>\n";
-
 }
 
-static void append_svg(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
-    for (const auto& item : geomlist->getChildren()) {
-      append_svg(item.second, output);
+static void append_svg (const std::shared_ptr<const Geometry> &geom, std::ostream &output) {
+  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList> (geom)) {
+    for (const auto &item : geomlist->getChildren ()) {
+      append_svg (item.second, output);
     }
-  } else if (const auto poly = std::dynamic_pointer_cast<const Polygon2d>(geom)) {
-    append_svg(*poly, output);
-  } else if (std::dynamic_pointer_cast<const PolySet>(geom)) { // NOLINT(bugprone-branch-clone)
-    assert(false && "Unsupported file format");
+  } else if (const auto poly = std::dynamic_pointer_cast<const Polygon2d> (geom)) {
+    append_svg (*poly, output);
+  } else if (std::dynamic_pointer_cast<const PolySet> (geom)) { // NOLINT(bugprone-branch-clone)
+    assert (false && "Unsupported file format");
   } else { // NOLINT(bugprone-branch-clone)
-    assert(false && "Export as SVG for this geometry type is not supported");
+    assert (false && "Export as SVG for this geometry type is not supported");
   }
 }
 
-void export_svg(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
-  setlocale(LC_NUMERIC, "C"); // Ensure radix is . (not ,) in output
+void export_svg (const std::shared_ptr<const Geometry> &geom, std::ostream &output) {
+  setlocale (LC_NUMERIC, "C"); // Ensure radix is . (not ,) in output
 
-  BoundingBox bbox = geom->getBoundingBox();
-  const int minx = (int)floor(bbox.min().x());
-  const int miny = (int)floor(-bbox.max().y());
-  const int maxx = (int)ceil(bbox.max().x());
-  const int maxy = (int)ceil(-bbox.min().y());
+  BoundingBox bbox = geom->getBoundingBox ();
+  const int minx = (int)floor (bbox.min ().x ());
+  const int miny = (int)floor (-bbox.max ().y ());
+  const int maxx = (int)ceil (bbox.max ().x ());
+  const int maxy = (int)ceil (-bbox.min ().y ());
   const int width = maxx - minx;
   const int height = maxy - miny;
 
@@ -94,8 +90,8 @@ void export_svg(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
     << "\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">\n"
     << "<title>OpenSCAD Model</title>\n";
 
-  append_svg(geom, output);
+  append_svg (geom, output);
 
   output << "</svg>\n";
-  setlocale(LC_NUMERIC, ""); // Set default locale
+  setlocale (LC_NUMERIC, ""); // Set default locale
 }
diff --git a/src/io/export_wrl.cc b/src/io/export_wrl.cc
index 2e747340c..1b6ff3003 100644
--- a/src/io/export_wrl.cc
+++ b/src/io/export_wrl.cc
@@ -33,12 +33,11 @@
 #include "geometry/PolySet.h"
 #include "geometry/PolySetUtils.h"
 
-void export_wrl(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
+void export_wrl (const std::shared_ptr<const Geometry> &geom, std::ostream &output) {
   // FIXME: In lazy union mode, should we export multiple IndexedFaceSets?
-  auto ps = PolySetUtils::getGeometryAsPolySet(geom);
-  if (Feature::ExperimentalPredictibleOutput.is_enabled()) {
-    ps = createSortedPolySet(*ps);
+  auto ps = PolySetUtils::getGeometryAsPolySet (geom);
+  if (Feature::ExperimentalPredictibleOutput.is_enabled ()) {
+    ps = createSortedPolySet (*ps);
   }
 
   output << "#VRML V2.0 utf8\n\n";
@@ -57,8 +56,8 @@ void export_wrl(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
   output << "creaseAngle 0.5\n\n";
 
   output << "coord Coordinate { point [\n";
-  const auto& v = ps->vertices;
-  const size_t numverts = v.size();
+  const auto &v = ps->vertices;
+  const size_t numverts = v.size ();
   for (size_t i = 0; i < numverts; ++i) {
     output << v[i][0] << " " << v[i][1] << " " << v[i][2];
     if (i < numverts - 1) {
@@ -69,10 +68,10 @@ void export_wrl(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
   output << "] }\n\n";
 
   output << "coordIndex [\n";
-  const size_t numindices = ps->indices.size();
+  const size_t numindices = ps->indices.size ();
   for (size_t i = 0; i < numindices; ++i) {
-    const auto& poly = ps->indices[i];
-    for (size_t j = 0; j < poly.size(); j++) {
+    const auto &poly = ps->indices[i];
+    for (size_t j = 0; j < poly.size (); j++) {
       output << poly[j];
       output << ",";
     }
@@ -80,14 +79,14 @@ void export_wrl(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
   }
   output << "]\n\n";
 
-  if (!ps->color_indices.empty()) {
+  if (!ps->color_indices.empty ()) {
     output << "colorPerVertex FALSE\n\n";
     output << "color Color { color [\n";
-    for (size_t i = 0; i < ps->colors.size(); ++i) {
+    for (size_t i = 0; i < ps->colors.size (); ++i) {
       auto color = ps->colors[i];
       float r, g, b, a;
-      if (!color.getRgba(r, g, b, a)) {
-        LOG(message_group::Warning, "Invalid color in WRL export");
+      if (!color.getRgba (r, g, b, a)) {
+        LOG (message_group::Warning, "Invalid color in WRL export");
       }
       // Alpha channel ignored as WRL colours are RGB not RGBA
       output << " " << r << " " << g << " " << b << ",\n";
@@ -95,9 +94,9 @@ void export_wrl(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
     output << " 0.976471 0.843137 0.172549, # default colour\n";
     output << "] }\n\n";
     output << "colorIndex [\n";
-    for (size_t i = 0; i < ps->indices.size(); ++i) {
+    for (size_t i = 0; i < ps->indices.size (); ++i) {
       auto color_index = ps->color_indices[i];
-      output << ((color_index >= 0) ? color_index : ps->colors.size()) << " ";
+      output << ((color_index >= 0) ? color_index : ps->colors.size ()) << " ";
     }
     output << "]\n\n";
   }
diff --git a/src/io/fileutils.cc b/src/io/fileutils.cc
index 97fc25b03..b82c5b235 100644
--- a/src/io/fileutils.cc
+++ b/src/io/fileutils.cc
@@ -14,21 +14,22 @@ namespace fs = std::filesystem;
    If the file isn't found in the given path, the fallback path will be
    used to be backwards compatible with <= 2013.01 (see issue #217).
  */
-std::string lookup_file(const std::string& filename,
-                        const std::string& path, const std::string& fallbackpath)
-{
+std::string lookup_file (const std::string &filename,
+                         const std::string &path, const std::string &fallbackpath) {
   std::string resultfile;
-  if (!filename.empty() && !fs::path(filename).is_absolute()) {
+  if (!filename.empty () && !fs::path (filename).is_absolute ()) {
     fs::path absfile;
-    if (!path.empty()) absfile = fs::absolute(fs::path(path) / filename);
+    if (!path.empty ())
+      absfile = fs::absolute (fs::path (path) / filename);
     fs::path absfile_fallback;
-    if (!fallbackpath.empty()) absfile_fallback = fs::absolute(fs::path(fallbackpath) / filename);
+    if (!fallbackpath.empty ())
+      absfile_fallback = fs::absolute (fs::path (fallbackpath) / filename);
 
-    if (!fs::exists(absfile) && fs::exists(absfile_fallback)) {
-      resultfile = absfile_fallback.string();
-      LOG(message_group::Deprecated, "Imported file (%1$s) found in document root instead of relative to the importing module. This behavior is deprecated", std::string(filename));
+    if (!fs::exists (absfile) && fs::exists (absfile_fallback)) {
+      resultfile = absfile_fallback.string ();
+      LOG (message_group::Deprecated, "Imported file (%1$s) found in document root instead of relative to the importing module. This behavior is deprecated", std::string (filename));
     } else {
-      resultfile = absfile.string();
+      resultfile = absfile.string ();
     }
   } else {
     resultfile = filename;
@@ -36,22 +37,22 @@ std::string lookup_file(const std::string& filename,
   return resultfile;
 }
 
-fs::path fs_uncomplete(fs::path const& p, fs::path const& base)
-{
-  if (p == fs::path{}) return p;
+fs::path fs_uncomplete (fs::path const &p, fs::path const &base) {
+  if (p == fs::path{})
+    return p;
 #ifndef __EMSCRIPTEN__
-  return fs::relative(p, base == fs::path{} ? fs::path{"."} : base);
+  return fs::relative (p, base == fs::path{} ? fs::path{"."} : base);
 #else
   return p;
 #endif
 }
 
-int64_t fs_timestamp(fs::path const& path) {
+int64_t fs_timestamp (fs::path const &path) {
   int64_t seconds = 0;
-  if (fs::exists(path)) {
-    const auto t = fs::last_write_time(path);
-    const auto duration = t.time_since_epoch();
-    seconds = std::chrono::duration_cast<std::chrono::seconds>(duration).count();
+  if (fs::exists (path)) {
+    const auto t = fs::last_write_time (path);
+    const auto duration = t.time_since_epoch ();
+    seconds = std::chrono::duration_cast<std::chrono::seconds> (duration).count ();
   }
   return seconds;
 }
\ No newline at end of file
diff --git a/src/io/fileutils.h b/src/io/fileutils.h
index 1419fd69c..1d58623cd 100644
--- a/src/io/fileutils.h
+++ b/src/io/fileutils.h
@@ -6,9 +6,8 @@
 
 namespace fs = std::filesystem;
 
-std::string lookup_file(const std::string& filename,
-                        const std::string& path, const std::string& fallbackpath);
+std::string lookup_file (const std::string &filename,
+                         const std::string &path, const std::string &fallbackpath);
 
-
-fs::path fs_uncomplete(fs::path const& p, fs::path const& base);
-int64_t fs_timestamp(fs::path const& path);
\ No newline at end of file
+fs::path fs_uncomplete (fs::path const &p, fs::path const &base);
+int64_t fs_timestamp (fs::path const &path);
\ No newline at end of file
diff --git a/src/io/imageutils-lodepng.cc b/src/io/imageutils-lodepng.cc
index 61803dce2..38030b654 100644
--- a/src/io/imageutils-lodepng.cc
+++ b/src/io/imageutils-lodepng.cc
@@ -5,17 +5,18 @@
 
 #include "lodepng/lodepng.h"
 
-bool write_png(std::ostream& output, unsigned char *pixels, int width, int height)
-{
+bool write_png (std::ostream &output, unsigned char *pixels, int width, int height) {
   std::vector<unsigned char> dataout;
   lodepng::State state;
   state.encoder.auto_convert = false;
   // some png renderers have different interpretations of alpha, so don't use it
   state.info_png.color.colortype = LCT_RGB;
   state.info_png.color.bitdepth = 8;
-  const auto err = lodepng::encode(dataout, pixels, width, height, state);
-  if (err) return false;
-  output.write(reinterpret_cast<const char *>(&dataout[0]), dataout.size());
-  if (output.bad() ) std::cerr << "Error writing to ostream\n";
-  return output.good();
+  const auto err = lodepng::encode (dataout, pixels, width, height, state);
+  if (err)
+    return false;
+  output.write (reinterpret_cast<const char *> (&dataout[0]), dataout.size ());
+  if (output.bad ())
+    std::cerr << "Error writing to ostream\n";
+  return output.good ();
 }
diff --git a/src/io/imageutils-macosx.cc b/src/io/imageutils-macosx.cc
index daaa78f19..007e6a050 100644
--- a/src/io/imageutils-macosx.cc
+++ b/src/io/imageutils-macosx.cc
@@ -8,54 +8,51 @@
 
 static CGDataConsumerCallbacks dc_callbacks;
 
-static size_t write_bytes_to_ostream(void *info, const void *buffer, size_t count)
-{
-  assert(info && buffer);
+static size_t write_bytes_to_ostream (void *info, const void *buffer, size_t count) {
+  assert (info && buffer);
   auto *output = (std::ostream *)info;
-  const size_t startpos = output->tellp();
+  const size_t startpos = output->tellp ();
   size_t endpos = startpos;
   try {
-    output->write((const char *)buffer, count);
-    endpos = output->tellp();
-  } catch (const std::ios_base::failure& e) {
-    std::cerr << "Error writing to ostream:" << e.what() << "\n";
+    output->write ((const char *)buffer, count);
+    endpos = output->tellp ();
+  } catch (const std::ios_base::failure &e) {
+    std::cerr << "Error writing to ostream:" << e.what () << "\n";
   }
   return (endpos - startpos);
 }
 
-static CGDataConsumerRef CGDataConsumerCreateWithOstream(std::ostream& output)
-{
+static CGDataConsumerRef CGDataConsumerCreateWithOstream (std::ostream &output) {
   dc_callbacks.putBytes = write_bytes_to_ostream;
   dc_callbacks.releaseConsumer = nullptr; // ostream closed by caller of write_png
-  CGDataConsumerRef dc = CGDataConsumerCreate( (void *)(&output), &dc_callbacks);
+  CGDataConsumerRef dc = CGDataConsumerCreate ((void *)(&output), &dc_callbacks);
   return dc;
 }
 
-bool write_png(std::ostream& output, unsigned char *pixels, int width, int height)
-{
-  const size_t rowBytes = static_cast<size_t>(width) * 4;
-//  CGColorSpaceRef colorSpace = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);
-  CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
+bool write_png (std::ostream &output, unsigned char *pixels, int width, int height) {
+  const size_t rowBytes = static_cast<size_t> (width) * 4;
+  //  CGColorSpaceRef colorSpace = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);
+  CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB ();
   const CGBitmapInfo bitmapInfo = kCGImageAlphaNoneSkipLast | kCGBitmapByteOrder32Big; // BGRA
   const int bitsPerComponent = 8;
-  CGContextRef contextRef = CGBitmapContextCreate(pixels, width, height,
-                                                  bitsPerComponent, rowBytes,
-                                                  colorSpace, bitmapInfo);
+  CGContextRef contextRef = CGBitmapContextCreate (pixels, width, height,
+                                                   bitsPerComponent, rowBytes,
+                                                   colorSpace, bitmapInfo);
   if (!contextRef) {
     std::cerr << "Unable to create CGContextRef.";
-    CGColorSpaceRelease(colorSpace);
+    CGColorSpaceRelease (colorSpace);
     return false;
   }
 
-  CGImageRef imageRef = CGBitmapContextCreateImage(contextRef);
+  CGImageRef imageRef = CGBitmapContextCreateImage (contextRef);
   if (!imageRef) {
     std::cerr << "Unable to create CGImageRef.";
-    CFRelease(contextRef);
-    CGColorSpaceRelease(colorSpace);
+    CFRelease (contextRef);
+    CGColorSpaceRelease (colorSpace);
     return false;
   }
 
-  CGDataConsumerRef dataconsumer = CGDataConsumerCreateWithOstream(output);
+  CGDataConsumerRef dataconsumer = CGDataConsumerCreateWithOstream (output);
   /*
      CFStringRef fname = CFStringCreateWithCString(kCFAllocatorDefault, filename, kCFStringEncodingUTF8);
      CFURLRef fileURL = CFURLCreateWithFileSystemPath(kCFAllocatorDefault,
@@ -72,35 +69,35 @@ bool write_png(std::ostream& output, unsigned char *pixels, int width, int heigh
   CFMutableDictionaryRef fileDict = nullptr;
   CFStringRef fileUTType = kUTTypePNG;
   // Create an image destination opaque reference for authoring an image file
-  CGImageDestinationRef imageDest = CGImageDestinationCreateWithDataConsumer(dataconsumer,
-                                                                             fileUTType,
-                                                                             fileImageIndex,
-                                                                             fileDict);
+  CGImageDestinationRef imageDest = CGImageDestinationCreateWithDataConsumer (dataconsumer,
+                                                                              fileUTType,
+                                                                              fileImageIndex,
+                                                                              fileDict);
   if (!imageDest) {
     std::cerr << "Unable to create CGImageDestinationRef.";
-    CFRelease(dataconsumer);
-    CGImageRelease(imageRef);
-    CFRelease(contextRef);
-    CGColorSpaceRelease(colorSpace);
+    CFRelease (dataconsumer);
+    CGImageRelease (imageRef);
+    CFRelease (contextRef);
+    CGColorSpaceRelease (colorSpace);
     return false;
   }
 
   const CFIndex capacity = 1;
   CFMutableDictionaryRef imageProps =
-    CFDictionaryCreateMutable(kCFAllocatorDefault,
-                              capacity,
-                              &kCFTypeDictionaryKeyCallBacks,
-                              &kCFTypeDictionaryValueCallBacks);
-  CGImageDestinationAddImage(imageDest, imageRef, imageProps);
-  CGImageDestinationFinalize(imageDest);
+    CFDictionaryCreateMutable (kCFAllocatorDefault,
+                               capacity,
+                               &kCFTypeDictionaryKeyCallBacks,
+                               &kCFTypeDictionaryValueCallBacks);
+  CGImageDestinationAddImage (imageDest, imageRef, imageProps);
+  CGImageDestinationFinalize (imageDest);
 
-  CFRelease(imageDest);
-  CFRelease(dataconsumer);
+  CFRelease (imageDest);
+  CFRelease (dataconsumer);
   //CFRelease(fileURL);
   //CFRelease(fname);
-  CFRelease(imageProps);
-  CGImageRelease(imageRef);
-  CFRelease(contextRef);
-  CGColorSpaceRelease(colorSpace);
+  CFRelease (imageProps);
+  CGImageRelease (imageRef);
+  CFRelease (contextRef);
+  CGColorSpaceRelease (colorSpace);
   return true;
 }
diff --git a/src/io/imageutils.cc b/src/io/imageutils.cc
index abcd320b0..be01edfd0 100644
--- a/src/io/imageutils.cc
+++ b/src/io/imageutils.cc
@@ -5,22 +5,20 @@
 #include <cstring>
 #include <fstream>
 
-void flip_image(const unsigned char *src, unsigned char *dst, size_t pixelsize, size_t width, size_t height)
-{
-  assert(src && dst);
+void flip_image (const unsigned char *src, unsigned char *dst, size_t pixelsize, size_t width, size_t height) {
+  assert (src && dst);
   auto rowBytes = pixelsize * width;
   for (auto i = 0ul; i < height; ++i) {
-    memmove(dst + (height - i - 1) * rowBytes, src + i * rowBytes, rowBytes);
+    memmove (dst + (height - i - 1) * rowBytes, src + i * rowBytes, rowBytes);
   }
 }
 
-bool write_png(const char *filename, unsigned char *pixels, int width, int height)
-{
-  assert(filename && pixels);
-  std::ofstream fstream(filename, std::ios::binary);
-  if (fstream.is_open()) {
-    write_png(fstream, pixels, width, height);
-    fstream.close();
+bool write_png (const char *filename, unsigned char *pixels, int width, int height) {
+  assert (filename && pixels);
+  std::ofstream fstream (filename, std::ios::binary);
+  if (fstream.is_open ()) {
+    write_png (fstream, pixels, width, height);
+    fstream.close ();
     return true;
   } else {
     std::cerr << "Can't open file " << filename << " for export.";
diff --git a/src/io/imageutils.h b/src/io/imageutils.h
index b799e6441..8f3bb73fc 100644
--- a/src/io/imageutils.h
+++ b/src/io/imageutils.h
@@ -3,6 +3,6 @@
 #include <cstdlib>
 #include <iostream>
 
-bool write_png(const char *filename, unsigned char *pixels, int width, int height);
-bool write_png(std::ostream& output, unsigned char *pixels, int width, int height);
-void flip_image(const unsigned char *src, unsigned char *dst, size_t pixelsize, size_t width, size_t height);
+bool write_png (const char *filename, unsigned char *pixels, int width, int height);
+bool write_png (std::ostream &output, unsigned char *pixels, int width, int height);
+void flip_image (const unsigned char *src, unsigned char *dst, size_t pixelsize, size_t width, size_t height);
diff --git a/src/io/import.h b/src/io/import.h
index 6e7f823bb..ec9e4aa88 100644
--- a/src/io/import.h
+++ b/src/io/import.h
@@ -7,19 +7,19 @@
 
 #include "core/AST.h"
 
-std::unique_ptr<class PolySet> import_stl(const std::string& filename, const Location& loc);
-std::unique_ptr<class PolySet> import_obj(const std::string& filename, const Location& loc);
-std::unique_ptr<class PolySet> import_off(const std::string& filename, const Location& loc);
-std::unique_ptr<class PolySet> import_amf(const std::string&, const Location& loc);
-std::unique_ptr<class PolySet> import_3mf(const std::string&, const Location& loc);
+std::unique_ptr<class PolySet> import_stl (const std::string &filename, const Location &loc);
+std::unique_ptr<class PolySet> import_obj (const std::string &filename, const Location &loc);
+std::unique_ptr<class PolySet> import_off (const std::string &filename, const Location &loc);
+std::unique_ptr<class PolySet> import_amf (const std::string &, const Location &loc);
+std::unique_ptr<class PolySet> import_3mf (const std::string &, const Location &loc);
 
-std::unique_ptr<class Polygon2d> import_svg(double fn, double fs, double fa,
-                                            const std::string& filename,
-                                            const boost::optional<std::string>& id, const boost::optional<std::string>& layer,
-                                            const double dpi, const bool center, const Location& loc);
+std::unique_ptr<class Polygon2d> import_svg (double fn, double fs, double fa,
+                                             const std::string &filename,
+                                             const boost::optional<std::string> &id, const boost::optional<std::string> &layer,
+                                             const double dpi, const bool center, const Location &loc);
 
 #ifdef ENABLE_CGAL
-std::unique_ptr<class CGALNefGeometry> import_nef3(const std::string& filename, const Location& loc);
+std::unique_ptr<class CGALNefGeometry> import_nef3 (const std::string &filename, const Location &loc);
 #endif
 
-class Value import_json(const std::string& filename, class EvaluationSession *session, const Location& loc);
+class Value import_json (const std::string &filename, class EvaluationSession *session, const Location &loc);
diff --git a/src/io/import_3mf_dummy.cc b/src/io/import_3mf_dummy.cc
index fba8fc1fc..f21c6411a 100644
--- a/src/io/import_3mf_dummy.cc
+++ b/src/io/import_3mf_dummy.cc
@@ -32,12 +32,11 @@
 #include "geometry/PolySet.h"
 #include "io/lib3mf_utils.h"
 
-std::string get_lib3mf_version() {
+std::string get_lib3mf_version () {
   return "(not enabled)";
 }
 
-std::unique_ptr<class PolySet> import_3mf(const std::string&, const Location& loc)
-{
-  LOG(message_group::Warning, "Import from 3MF format was not enabled when building the application, import() at line %1$d", loc.firstLine());
-  return PolySet::createEmpty();
+std::unique_ptr<class PolySet> import_3mf (const std::string &, const Location &loc) {
+  LOG (message_group::Warning, "Import from 3MF format was not enabled when building the application, import() at line %1$d", loc.firstLine ());
+  return PolySet::createEmpty ();
 }
diff --git a/src/io/import_3mf_v1.cc b/src/io/import_3mf_v1.cc
index 9fe76d045..3eabc104b 100644
--- a/src/io/import_3mf_v1.cc
+++ b/src/io/import_3mf_v1.cc
@@ -56,25 +56,23 @@
 #undef BOOL
 using namespace NMR;
 
-std::string get_lib3mf_version() {
+std::string get_lib3mf_version () {
   DWORD major, minor, micro;
-  NMR::lib3mf_getinterfaceversion(&major, &minor, &micro);
+  NMR::lib3mf_getinterfaceversion (&major, &minor, &micro);
 
   const OpenSCAD::library_version_number header_version{NMR_APIVERSION_INTERFACE_MAJOR, NMR_APIVERSION_INTERFACE_MINOR, NMR_APIVERSION_INTERFACE_MICRO};
   const OpenSCAD::library_version_number runtime_version{major, minor, micro};
-  return OpenSCAD::get_version_string(header_version, runtime_version);
+  return OpenSCAD::get_version_string (header_version, runtime_version);
 }
 
 namespace {
 
-struct MeshObject
-{
+struct MeshObject {
   PLib3MFModelObjectResource *obj;
   Matrix4d transform;
 };
 
-struct ModelMetadata
-{
+struct ModelMetadata {
   std::string title;
   std::string designer;
   std::string description;
@@ -90,8 +88,7 @@ using MeshObjectList = std::list<std::unique_ptr<MeshObject>>;
 
 // lib3mf_propertyhandler_getcolor states:
 // (#00000000) means no property or a different kind of property!
-Color4f get_color(const MODELMESHCOLOR_SRGB& color)
-{
+Color4f get_color (const MODELMESHCOLOR_SRGB &color) {
   if (color.m_Red == 0 && color.m_Green == 0 && color.m_Blue == 0 && color.m_Alpha == 0) {
     return {}; // invalid color
   }
@@ -99,121 +96,128 @@ Color4f get_color(const MODELMESHCOLOR_SRGB& color)
   return c;
 }
 
-Color4f get_color(const MODELMESH_TRIANGLECOLOR_SRGB& color, int idx)
-{
-  return get_color(color.m_Colors[idx]);
+Color4f get_color (const MODELMESH_TRIANGLECOLOR_SRGB &color, int idx) {
+  return get_color (color.m_Colors[idx]);
 }
 
-Matrix4d get_matrix(MODELTRANSFORM& transform)
-{
+Matrix4d get_matrix (MODELTRANSFORM &transform) {
   Matrix4d tm;
   tm << transform.m_fFields[0][0], transform.m_fFields[0][1], transform.m_fFields[0][2], transform.m_fFields[0][3],
     transform.m_fFields[1][0], transform.m_fFields[1][1], transform.m_fFields[1][2], transform.m_fFields[1][3],
     transform.m_fFields[2][0], transform.m_fFields[2][1], transform.m_fFields[2][2], transform.m_fFields[2][3],
-    0,                         0,                         0,                         1;
+    0, 0, 0, 1;
   return tm;
 }
 
-std::string get_object_type_name(DWORD objecttype)
-{
+std::string get_object_type_name (DWORD objecttype) {
   switch (objecttype) {
-  case MODELOBJECTTYPE_OTHER: return "Other";
-  case MODELOBJECTTYPE_MODEL: return "Model";
-  case MODELOBJECTTYPE_SUPPORT: return "Support";
-  case MODELOBJECTTYPE_SOLIDSUPPORT: return "Solid Support";
-  case MODELOBJECTTYPE_SURFACE: return "Surface";
-  default: return "<Unknown>";
+  case MODELOBJECTTYPE_OTHER:
+    return "Other";
+  case MODELOBJECTTYPE_MODEL:
+    return "Model";
+  case MODELOBJECTTYPE_SUPPORT:
+    return "Support";
+  case MODELOBJECTTYPE_SOLIDSUPPORT:
+    return "Solid Support";
+  case MODELOBJECTTYPE_SURFACE:
+    return "Surface";
+  default:
+    return "<Unknown>";
   }
 }
 
-std::unique_ptr<PolySet> import_3mf_error(PLib3MFModel *model = nullptr, const std::string& errmsg = "", PLib3MFModelBuildItemIterator *it = nullptr)
-{
-  if (!errmsg.empty()) {
-    LOG(message_group::Error, "%1$s", errmsg);
+std::unique_ptr<PolySet> import_3mf_error (PLib3MFModel *model = nullptr, const std::string &errmsg = "", PLib3MFModelBuildItemIterator *it = nullptr) {
+  if (!errmsg.empty ()) {
+    LOG (message_group::Error, "%1$s", errmsg);
   }
 
   if (model) {
-    lib3mf_release(model);
+    lib3mf_release (model);
   }
   if (it) {
-    lib3mf_release(it);
+    lib3mf_release (it);
   }
 
-  return PolySet::createEmpty();
+  return PolySet::createEmpty ();
 }
 
-std::string collect_mesh_objects(MeshObjectList& object_list, PLib3MFModelObjectResource *object, const Matrix4d& m, const Location& loc, int level = 1)
-{
+std::string collect_mesh_objects (MeshObjectList &object_list, PLib3MFModelObjectResource *object, const Matrix4d &m, const Location &loc, int level = 1) {
   BOOL is_mesh_object = false;
-  if (lib3mf_object_ismeshobject(object, &is_mesh_object) != LIB3MF_OK) {
+  if (lib3mf_object_ismeshobject (object, &is_mesh_object) != LIB3MF_OK) {
     return "Could not check for mesh object type";
   }
   BOOL is_components_object = false;
-  if (lib3mf_object_iscomponentsobject(object, &is_components_object) != LIB3MF_OK) {
+  if (lib3mf_object_iscomponentsobject (object, &is_components_object) != LIB3MF_OK) {
     return "Could not check for component object type";
   }
   DWORD objecttype;
-  if (lib3mf_object_gettype(object, &objecttype) != LIB3MF_OK) {
+  if (lib3mf_object_gettype (object, &objecttype) != LIB3MF_OK) {
     return "Could not read object type";
   }
-  char number[4096] = {0, };
+  char number[4096] = {
+    0,
+  };
   ULONG numberlen;
-  if (lib3mf_object_getpartnumberutf8(object, &number[0], sizeof(number), &numberlen) != LIB3MF_OK) {
+  if (lib3mf_object_getpartnumberutf8 (object, &number[0], sizeof (number), &numberlen) != LIB3MF_OK) {
     return "Could not read part number of object";
   }
-  char name[4096] = {0, };
+  char name[4096] = {
+    0,
+  };
   ULONG namelen;
-  if (lib3mf_object_getnameutf8(object, &name[0], sizeof(name), &namelen) != LIB3MF_OK) {
+  if (lib3mf_object_getnameutf8 (object, &name[0], sizeof (name), &namelen) != LIB3MF_OK) {
     return "Could not read name of object";
   }
   BOOL hasuuid = false;
-  char uuid[40] = {0, };
-  if (lib3mf_object_getuuidutf8(object, &hasuuid, &uuid[0]) != LIB3MF_OK) {
+  char uuid[40] = {
+    0,
+  };
+  if (lib3mf_object_getuuidutf8 (object, &hasuuid, &uuid[0]) != LIB3MF_OK) {
     return "Could not read UUID of object";
   }
 
   BOOL is_valid_object = false;
-  if (lib3mf_object_isvalidobject(object, &is_valid_object) != LIB3MF_OK) {
+  if (lib3mf_object_isvalidobject (object, &is_valid_object) != LIB3MF_OK) {
     return "Could not check object validity";
   }
   if (!is_valid_object) {
-    LOG(message_group::Warning, "Object '%1$s' with UUID '%2$s' is not valid, import() at line %3$d", name, uuid, loc.firstLine());
+    LOG (message_group::Warning, "Object '%1$s' with UUID '%2$s' is not valid, import() at line %3$d", name, uuid, loc.firstLine ());
   }
 
   if (is_mesh_object) {
-    PRINTDB("%smesh type = %s, number = '%s', name = '%s' (%s)", boost::io::group(std::setw(2 * level), "") % get_object_type_name(objecttype) % number % name % (hasuuid ? uuid : "<no uuid>"));
-    object_list.push_back(std::make_unique<MeshObject>(MeshObject{object, m}));
+    PRINTDB ("%smesh type = %s, number = '%s', name = '%s' (%s)", boost::io::group (std::setw (2 * level), "") % get_object_type_name (objecttype) % number % name % (hasuuid ? uuid : "<no uuid>"));
+    object_list.push_back (std::make_unique<MeshObject> (MeshObject{object, m}));
     return "";
   }
   if (is_components_object) {
     DWORD componentcount;
-    if (lib3mf_componentsobject_getcomponentcount(object, &componentcount) != LIB3MF_OK) {
+    if (lib3mf_componentsobject_getcomponentcount (object, &componentcount) != LIB3MF_OK) {
       return "Could not get object component count";
     }
-    PRINTDB("%sobject (%d components) type = %s, number = '%s', name = '%s' (%s)", boost::io::group(std::setw(2 * level), "") % componentcount % get_object_type_name(objecttype) % number % name % (hasuuid ? uuid : "<no uuid>"));
+    PRINTDB ("%sobject (%d components) type = %s, number = '%s', name = '%s' (%s)", boost::io::group (std::setw (2 * level), "") % componentcount % get_object_type_name (objecttype) % number % name % (hasuuid ? uuid : "<no uuid>"));
     for (DWORD idx = 0; idx < componentcount; ++idx) {
       PLib3MFModelComponent *component = nullptr;
-      if (lib3mf_componentsobject_getcomponent(object, idx, &component) != LIB3MF_OK) {
+      if (lib3mf_componentsobject_getcomponent (object, idx, &component) != LIB3MF_OK) {
         return "Could not get object component";
       }
       BOOL has_transform = false;
-      if (lib3mf_component_hastransform(component, &has_transform) != LIB3MF_OK) {
+      if (lib3mf_component_hastransform (component, &has_transform) != LIB3MF_OK) {
         return "Could not check for component transform";
       }
-      MODELTRANSFORM transform{ .m_fFields = {{ 1, 0, 0, 0 }, { 0, 1, 0, 0 }, { 0, 0, 1, 0 } } };
-      if (has_transform && lib3mf_component_gettransform(component, &transform) != LIB3MF_OK) {
+      MODELTRANSFORM transform{.m_fFields = {{1, 0, 0, 0}, {0, 1, 0, 0}, {0, 0, 1, 0}}};
+      if (has_transform && lib3mf_component_gettransform (component, &transform) != LIB3MF_OK) {
         return "Could not read transform of component";
       }
       PLib3MFModelObjectResource *componentobject = nullptr;
-      if (lib3mf_component_getobjectresource(component, &componentobject) != LIB3MF_OK) {
+      if (lib3mf_component_getobjectresource (component, &componentobject) != LIB3MF_OK) {
         return "Could not read object resource of component";
       }
-      const Matrix4d cm = get_matrix(transform);
+      const Matrix4d cm = get_matrix (transform);
       if (has_transform) {
-        PRINTDB("%scomponent transform matrix\n%s", boost::io::group(std::setw(2 * level), "") % cm);
+        PRINTDB ("%scomponent transform matrix\n%s", boost::io::group (std::setw (2 * level), "") % cm);
       }
-      auto errmsg = collect_mesh_objects(object_list, componentobject, cm * m, loc, level + 1);
-      if (!errmsg.empty()) {
+      auto errmsg = collect_mesh_objects (object_list, componentobject, cm * m, loc, level + 1);
+      if (!errmsg.empty ()) {
         return errmsg;
       }
     }
@@ -222,12 +226,11 @@ std::string collect_mesh_objects(MeshObjectList& object_list, PLib3MFModelObject
   return "Unhandled object type, expected one of: mesh, component";
 }
 
-Color4f get_triangle_color_from_basematerial(PLib3MFModel *model, PLib3MFPropertyHandler *propertyhandler, int idx)
-{
+Color4f get_triangle_color_from_basematerial (PLib3MFModel *model, PLib3MFPropertyHandler *propertyhandler, int idx) {
   DWORD materialIndex = 0;
   DWORD materialGroupID = 0;
 
-  if (lib3mf_propertyhandler_getbasematerial(propertyhandler, idx, &materialGroupID, &materialIndex) != LIB3MF_OK) {
+  if (lib3mf_propertyhandler_getbasematerial (propertyhandler, idx, &materialGroupID, &materialIndex) != LIB3MF_OK) {
     return {};
   }
   if (materialGroupID == 0) {
@@ -235,12 +238,12 @@ Color4f get_triangle_color_from_basematerial(PLib3MFModel *model, PLib3MFPropert
   }
 
   PLib3MFModelBaseMaterial *basematerial;
-  if (lib3mf_model_getbasematerialbyid(model, materialGroupID, &basematerial) != LIB3MF_OK) {
+  if (lib3mf_model_getbasematerialbyid (model, materialGroupID, &basematerial) != LIB3MF_OK) {
     return {};
   }
 
   BYTE r = 0, g = 0, b = 0, a = 0;
-  if (lib3mf_basematerial_getdisplaycolor(basematerial, materialIndex, &r, &g, &b, &a) != LIB3MF_OK) {
+  if (lib3mf_basematerial_getdisplaycolor (basematerial, materialIndex, &r, &g, &b, &a) != LIB3MF_OK) {
     return {};
   }
 
@@ -248,132 +251,130 @@ Color4f get_triangle_color_from_basematerial(PLib3MFModel *model, PLib3MFPropert
   return col;
 }
 
-Color4f get_triangle_color(PLib3MFPropertyHandler *propertyhandler, int idx)
-{
-  MODELMESH_TRIANGLECOLOR_SRGB color = { .m_Colors = {
-                                           { 0, 0, 0 },
-                                           { 0, 0, 0 },
-                                           { 0, 0, 0 }
-                                         } };
-  if (lib3mf_propertyhandler_getcolor(propertyhandler, idx, &color) == LIB3MF_OK) {
-    const Color4f col0 = get_color(color, 0);
-    const Color4f col1 = get_color(color, 1);
-    const Color4f col2 = get_color(color, 2);
-    if (col0.isValid() && col1.isValid() && col2.isValid()) {
+Color4f get_triangle_color (PLib3MFPropertyHandler *propertyhandler, int idx) {
+  MODELMESH_TRIANGLECOLOR_SRGB color = {.m_Colors = {
+                                          {0, 0, 0},
+                                          {0, 0, 0},
+                                          {0, 0, 0}}};
+  if (lib3mf_propertyhandler_getcolor (propertyhandler, idx, &color) == LIB3MF_OK) {
+    const Color4f col0 = get_color (color, 0);
+    const Color4f col1 = get_color (color, 1);
+    const Color4f col2 = get_color (color, 2);
+    if (col0.isValid () && col1.isValid () && col2.isValid ()) {
       return {
-        std::clamp((col0.r() + col1.r() + col2.r()) / 3, 0.0f, 1.0f),
-        std::clamp((col0.g() + col1.g() + col2.g()) / 3, 0.0f, 1.0f),
-        std::clamp((col0.b() + col1.b() + col2.b()) / 3, 0.0f, 1.0f),
-        std::clamp((col0.a() + col1.a() + col2.a()) / 3, 0.0f, 1.0f)
-      };
+        std::clamp ((col0.r () + col1.r () + col2.r ()) / 3, 0.0f, 1.0f),
+        std::clamp ((col0.g () + col1.g () + col2.g ()) / 3, 0.0f, 1.0f),
+        std::clamp ((col0.b () + col1.b () + col2.b ()) / 3, 0.0f, 1.0f),
+        std::clamp ((col0.a () + col1.a () + col2.a ()) / 3, 0.0f, 1.0f)};
     }
   }
   return {};
 }
 
-Color4f get_triangle_color(PLib3MFModel *model, PLib3MFPropertyHandler *propertyhandler, int idx)
-{
+Color4f get_triangle_color (PLib3MFModel *model, PLib3MFPropertyHandler *propertyhandler, int idx) {
   eModelPropertyType propertytype = MODELPROPERTYTYPE_NONE;
-  lib3mf_propertyhandler_getpropertytype(propertyhandler, idx, &propertytype);
+  lib3mf_propertyhandler_getpropertytype (propertyhandler, idx, &propertytype);
   if (propertytype == MODELPROPERTYTYPE_BASEMATERIALS) {
-    return get_triangle_color_from_basematerial(model, propertyhandler, idx);
+    return get_triangle_color_from_basematerial (model, propertyhandler, idx);
   }
   if (propertytype == MODELPROPERTYTYPE_COLOR) {
-    return get_triangle_color(propertyhandler, idx);
+    return get_triangle_color (propertyhandler, idx);
   }
   return {};
 }
 
-std::string import_3mf_mesh(const std::string& filename, unsigned int mesh_idx, PLib3MFModel *model, std::unique_ptr<MeshObject>& mo, std::unique_ptr<PolySet>& ps)
-{
+std::string import_3mf_mesh (const std::string &filename, unsigned int mesh_idx, PLib3MFModel *model, std::unique_ptr<MeshObject> &mo, std::unique_ptr<PolySet> &ps) {
   DWORD vertex_count = 0;
-  if (lib3mf_meshobject_getvertexcount(mo->obj, &vertex_count) != LIB3MF_OK) {
+  if (lib3mf_meshobject_getvertexcount (mo->obj, &vertex_count) != LIB3MF_OK) {
     return "Could not read vertex count";
   }
   DWORD triangle_count = 0;
-  if (lib3mf_meshobject_gettrianglecount(mo->obj, &triangle_count) != LIB3MF_OK) {
+  if (lib3mf_meshobject_gettrianglecount (mo->obj, &triangle_count) != LIB3MF_OK) {
     return "Could not read triangle count";
   }
   DWORD object_type = 0;
-  if (lib3mf_object_gettype(mo->obj, &object_type) != LIB3MF_OK) {
+  if (lib3mf_object_gettype (mo->obj, &object_type) != LIB3MF_OK) {
     return "Could not read object type";
   }
-  PRINTDB("%s: mesh %d, type: %s, vertex count: %lu, triangle count: %lu", filename.c_str() % mesh_idx % get_object_type_name(object_type) % vertex_count % triangle_count);
+  PRINTDB ("%s: mesh %d, type: %s, vertex count: %lu, triangle count: %lu", filename.c_str () % mesh_idx % get_object_type_name (object_type) % vertex_count % triangle_count);
 
   PLib3MFPropertyHandler *propertyhandler = nullptr;
-  if (lib3mf_meshobject_createpropertyhandler(mo->obj, &propertyhandler) != LIB3MF_OK) {
+  if (lib3mf_meshobject_createpropertyhandler (mo->obj, &propertyhandler) != LIB3MF_OK) {
     return "Could not create property handler";
   }
 
-  ps->vertices.reserve(vertex_count);
-  ps->indices.reserve(triangle_count);
-  ps->color_indices.reserve(triangle_count);
+  ps->vertices.reserve (vertex_count);
+  ps->indices.reserve (triangle_count);
+  ps->color_indices.reserve (triangle_count);
 
   for (DWORD idx = 0; idx < vertex_count; ++idx) {
     MODELMESHVERTEX vertex;
-    if (lib3mf_meshobject_getvertex(mo->obj, idx, &vertex) != LIB3MF_OK) {
+    if (lib3mf_meshobject_getvertex (mo->obj, idx, &vertex) != LIB3MF_OK) {
       return "Could not read vertex from object";
     }
-    const Vector4d v = mo->transform * Vector4d(vertex.m_fPosition[0], vertex.m_fPosition[1], vertex.m_fPosition[2], 1);
-    ps->vertices.push_back(v.head(3));
+    const Vector4d v = mo->transform * Vector4d (vertex.m_fPosition[0], vertex.m_fPosition[1], vertex.m_fPosition[2], 1);
+    ps->vertices.push_back (v.head (3));
   }
 
   std::unordered_map<Color4f, int32_t> color_indices;
   for (DWORD idx = 0; idx < triangle_count; ++idx) {
     MODELMESHTRIANGLE triangle;
-    if (lib3mf_meshobject_gettriangle(mo->obj, idx, &triangle) != LIB3MF_OK) {
+    if (lib3mf_meshobject_gettriangle (mo->obj, idx, &triangle) != LIB3MF_OK) {
       return "Could not read triangle from object";
     }
-    ps->indices.emplace_back();
+    ps->indices.emplace_back ();
     for (DWORD vertex_idx : triangle.m_nIndices) {
-      ps->indices.back().push_back(vertex_idx);
+      ps->indices.back ().push_back (vertex_idx);
     }
 
-    const Color4f col = get_triangle_color(model, propertyhandler, idx);
-    if (col.isValid()) {
-      const auto it = color_indices.find(col);
+    const Color4f col = get_triangle_color (model, propertyhandler, idx);
+    if (col.isValid ()) {
+      const auto it = color_indices.find (col);
       int32_t cidx;
-      if (it == color_indices.end()) {
-        cidx = ps->colors.size();
-        ps->colors.push_back(col);
+      if (it == color_indices.end ()) {
+        cidx = ps->colors.size ();
+        ps->colors.push_back (col);
         color_indices[col] = cidx;
       } else {
         cidx = it->second;
       }
-      ps->color_indices.push_back(cidx);
+      ps->color_indices.push_back (cidx);
     } else {
-      ps->color_indices.push_back(-1);
+      ps->color_indices.push_back (-1);
     }
   }
-  if (ps->colors.empty()) {
-    ps->color_indices.clear();
+  if (ps->colors.empty ()) {
+    ps->color_indices.clear ();
   }
-  ps->setTriangular(true);
+  ps->setTriangular (true);
 
-  lib3mf_release(propertyhandler);
+  lib3mf_release (propertyhandler);
   return "";
 }
 
-std::string read_metadata(PLib3MFModel *model)
-{
+std::string read_metadata (PLib3MFModel *model) {
   DWORD metadatacount;
-  if (lib3mf_model_getmetadatacount(model, &metadatacount) != LIB3MF_OK) {
+  if (lib3mf_model_getmetadatacount (model, &metadatacount) != LIB3MF_OK) {
     return "Could not retrieve metadata";
   }
 
   ModelMetadata mmd;
   for (DWORD idx = 0; idx < metadatacount; ++idx) {
-    char key[4096] = { 0, };
+    char key[4096] = {
+      0,
+    };
     ULONG keylen = 0;
-    if (lib3mf_model_getmetadatakeyutf8(model, idx, &key[0], sizeof(key), &keylen) != LIB3MF_OK) {
+    if (lib3mf_model_getmetadatakeyutf8 (model, idx, &key[0], sizeof (key), &keylen) != LIB3MF_OK) {
       return "Could not retrieve metadata key";
     }
-    char value[4096] = { 0, };
+    char value[4096] = {
+      0,
+    };
     ULONG valuelen = 0;
-    if (lib3mf_model_getmetadatavalueutf8(model, idx, &value[0], sizeof(value), &valuelen) != LIB3MF_OK) {
+    if (lib3mf_model_getmetadatavalueutf8 (model, idx, &value[0], sizeof (value), &valuelen) != LIB3MF_OK) {
       return "Could not retrieve metadata value";
     }
-    PRINTDB("METADATA[%d]: %s = '%s'", idx % key % value);
+    PRINTDB ("METADATA[%d]: %s = '%s'", idx % key % value);
 
     const std::string name = key;
     if (name == "Title") {
@@ -397,8 +398,8 @@ std::string read_metadata(PLib3MFModel *model)
     }
   }
 
-  if (!mmd.title.empty()) {
-    LOG("Reading 3MF with title '%1$s'", mmd.title);
+  if (!mmd.title.empty ()) {
+    LOG ("Reading 3MF with title '%1$s'", mmd.title);
   }
 
   return "";
@@ -406,151 +407,154 @@ std::string read_metadata(PLib3MFModel *model)
 
 } // namespace
 
-std::unique_ptr<PolySet> import_3mf(const std::string& filename, const Location& loc)
-{
+std::unique_ptr<PolySet> import_3mf (const std::string &filename, const Location &loc) {
   DWORD interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro;
-  HRESULT result = lib3mf_getinterfaceversion(&interfaceVersionMajor, &interfaceVersionMinor, &interfaceVersionMicro);
+  HRESULT result = lib3mf_getinterfaceversion (&interfaceVersionMajor, &interfaceVersionMinor, &interfaceVersionMicro);
   if (result != LIB3MF_OK) {
-    LOG(message_group::Error, "Error reading 3MF library version");
-    return PolySet::createEmpty();
+    LOG (message_group::Error, "Error reading 3MF library version");
+    return PolySet::createEmpty ();
   }
 
   if ((interfaceVersionMajor != NMR_APIVERSION_INTERFACE_MAJOR)) {
-    LOG(message_group::Error, "Invalid 3MF library major version %1$d.%2$d.%3$d, expected %4$d.%5$d.%6$d",
-        interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro,
-        NMR_APIVERSION_INTERFACE_MAJOR, NMR_APIVERSION_INTERFACE_MINOR, NMR_APIVERSION_INTERFACE_MICRO);
-    return PolySet::createEmpty();
+    LOG (message_group::Error, "Invalid 3MF library major version %1$d.%2$d.%3$d, expected %4$d.%5$d.%6$d",
+         interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro,
+         NMR_APIVERSION_INTERFACE_MAJOR, NMR_APIVERSION_INTERFACE_MINOR, NMR_APIVERSION_INTERFACE_MICRO);
+    return PolySet::createEmpty ();
   }
 
   PLib3MFModel *model;
-  result = lib3mf_createmodel(&model);
+  result = lib3mf_createmodel (&model);
   if (result != LIB3MF_OK) {
-    LOG(message_group::Error, "Could not create model: %1$08lx", result);
-    return import_3mf_error();
+    LOG (message_group::Error, "Could not create model: %1$08lx", result);
+    return import_3mf_error ();
   }
 
   PLib3MFModelReader *reader;
-  result = lib3mf_model_queryreader(model, "3mf", &reader);
+  result = lib3mf_model_queryreader (model, "3mf", &reader);
   if (result != LIB3MF_OK) {
-    LOG(message_group::Error, "Could not create 3MF reader: %1$08lx", result);
-    return import_3mf_error(model);
+    LOG (message_group::Error, "Could not create 3MF reader: %1$08lx", result);
+    return import_3mf_error (model);
   }
 
-  result = lib3mf_reader_readfromfileutf8(reader, filename.c_str());
-  lib3mf_release(reader);
+  result = lib3mf_reader_readfromfileutf8 (reader, filename.c_str ());
+  lib3mf_release (reader);
   if (result != LIB3MF_OK) {
-    LOG(message_group::Warning, "Could not read file '%1$s', import() at line %2$d", filename.c_str(), loc.firstLine());
-    return import_3mf_error(model);
+    LOG (message_group::Warning, "Could not read file '%1$s', import() at line %2$d", filename.c_str (), loc.firstLine ());
+    return import_3mf_error (model);
   }
 
-  read_metadata(model);
+  read_metadata (model);
 
   PLib3MFModelBuildItemIterator *builditem_it = nullptr;
-  if (lib3mf_model_getbuilditems(model, &builditem_it) != LIB3MF_OK) {
-    return import_3mf_error(model, "Could not retrieve build items");
+  if (lib3mf_model_getbuilditems (model, &builditem_it) != LIB3MF_OK) {
+    return import_3mf_error (model, "Could not retrieve build items");
   }
 
   std::list<std::unique_ptr<PolySet>> meshes;
   while (true) {
     BOOL has_next = false;
-    if (lib3mf_builditemiterator_movenext(builditem_it, &has_next) != LIB3MF_OK) {
-      return import_3mf_error(model, "Error iterating over build items", builditem_it);
+    if (lib3mf_builditemiterator_movenext (builditem_it, &has_next) != LIB3MF_OK) {
+      return import_3mf_error (model, "Error iterating over build items", builditem_it);
     }
     if (!has_next) {
       break;
     }
 
     PLib3MFModelBuildItem *builditem = nullptr;
-    if (lib3mf_builditemiterator_getcurrent(builditem_it, &builditem) != LIB3MF_OK) {
-      return import_3mf_error(model, "Could not read build item", builditem_it);
+    if (lib3mf_builditemiterator_getcurrent (builditem_it, &builditem) != LIB3MF_OK) {
+      return import_3mf_error (model, "Could not read build item", builditem_it);
     }
     DWORD builditemhandle;
-    if (lib3mf_builditem_gethandle(builditem, &builditemhandle) != LIB3MF_OK) {
-      return import_3mf_error(model, "Could not get handle of build item", builditem_it);
+    if (lib3mf_builditem_gethandle (builditem, &builditemhandle) != LIB3MF_OK) {
+      return import_3mf_error (model, "Could not get handle of build item", builditem_it);
     }
-    char partnumber[4096] = {0, };
+    char partnumber[4096] = {
+      0,
+    };
     ULONG partnumberlen = 0;
-    if (lib3mf_builditem_getpartnumberutf8(builditem, &partnumber[0], sizeof(partnumber), &partnumberlen) != LIB3MF_OK) {
-      return import_3mf_error(model, "Could not get part number of build item", builditem_it);
+    if (lib3mf_builditem_getpartnumberutf8 (builditem, &partnumber[0], sizeof (partnumber), &partnumberlen) != LIB3MF_OK) {
+      return import_3mf_error (model, "Could not get part number of build item", builditem_it);
     }
     BOOL hasuuid = false;
-    char uuid[40] = {0, };
-    if (lib3mf_builditem_getuuidutf8(builditem, &hasuuid, &uuid[0]) != LIB3MF_OK) {
-      return import_3mf_error(model, "Could not get uuid of build item", builditem_it);
+    char uuid[40] = {
+      0,
+    };
+    if (lib3mf_builditem_getuuidutf8 (builditem, &hasuuid, &uuid[0]) != LIB3MF_OK) {
+      return import_3mf_error (model, "Could not get uuid of build item", builditem_it);
     }
     PLib3MFModelObjectResource *object = nullptr;
-    if (lib3mf_builditem_getobjectresource(builditem, &object) != LIB3MF_OK) {
-      return import_3mf_error(model, "Could not read object resource of build item", builditem_it);
+    if (lib3mf_builditem_getobjectresource (builditem, &object) != LIB3MF_OK) {
+      return import_3mf_error (model, "Could not read object resource of build item", builditem_it);
     }
 
     BOOL has_transform = false;
-    if (lib3mf_builditem_hasobjecttransform(builditem, &has_transform) != LIB3MF_OK) {
-      return import_3mf_error(model, "Could not check for build item transform", builditem_it);
+    if (lib3mf_builditem_hasobjecttransform (builditem, &has_transform) != LIB3MF_OK) {
+      return import_3mf_error (model, "Could not check for build item transform", builditem_it);
     }
-    MODELTRANSFORM transform{ .m_fFields = {{ 1, 0, 0, 0 }, { 0, 1, 0, 0 }, { 0, 0, 1, 0 } } };
-    if (has_transform && lib3mf_builditem_getobjecttransform(builditem, &transform) != LIB3MF_OK) {
-      return import_3mf_error(model, "Could not read build item transform", builditem_it);
+    MODELTRANSFORM transform{.m_fFields = {{1, 0, 0, 0}, {0, 1, 0, 0}, {0, 0, 1, 0}}};
+    if (has_transform && lib3mf_builditem_getobjecttransform (builditem, &transform) != LIB3MF_OK) {
+      return import_3mf_error (model, "Could not read build item transform", builditem_it);
     }
-    const Matrix4d m = get_matrix(transform);
+    const Matrix4d m = get_matrix (transform);
 
-    PRINTDB("build item %d, part number = '%s' (%s)", builditemhandle % partnumber % (hasuuid ? uuid : "<no uuid>"));
+    PRINTDB ("build item %d, part number = '%s' (%s)", builditemhandle % partnumber % (hasuuid ? uuid : "<no uuid>"));
     if (has_transform) {
-      PRINTDB("build item transform matrix\n%s", m);
+      PRINTDB ("build item transform matrix\n%s", m);
     }
 
     MeshObjectList object_list;
-    std::string errmsg = collect_mesh_objects(object_list, object, m, loc);
-    if (!errmsg.empty()) {
-      return import_3mf_error(model, "Error collecting meshes: " + errmsg, builditem_it);
+    std::string errmsg = collect_mesh_objects (object_list, object, m, loc);
+    if (!errmsg.empty ()) {
+      return import_3mf_error (model, "Error collecting meshes: " + errmsg, builditem_it);
     }
 
-    for (auto& mo : object_list) {
-      auto ps = PolySet::createEmpty();
-      std::string errmsg = import_3mf_mesh(filename, meshes.size(), model, mo, ps);
-      if (errmsg.empty()) {
-        if (ps->isEmpty()) {
+    for (auto &mo : object_list) {
+      auto ps = PolySet::createEmpty ();
+      std::string errmsg = import_3mf_mesh (filename, meshes.size (), model, mo, ps);
+      if (errmsg.empty ()) {
+        if (ps->isEmpty ()) {
           continue;
         }
       } else {
-        return import_3mf_error(model, errmsg, builditem_it);
+        return import_3mf_error (model, errmsg, builditem_it);
       }
 
-      meshes.push_back(std::move(ps));
+      meshes.push_back (std::move (ps));
     }
   }
 
-  lib3mf_release(builditem_it);
-  lib3mf_release(model);
+  lib3mf_release (builditem_it);
+  lib3mf_release (model);
 
-  if (meshes.empty()) {
-    return PolySet::createEmpty();
-  } else if (meshes.size() == 1) {
-    return std::move(meshes.front());
+  if (meshes.empty ()) {
+    return PolySet::createEmpty ();
+  } else if (meshes.size () == 1) {
+    return std::move (meshes.front ());
   } else {
     std::unique_ptr<PolySet> p;
     Geometry::Geometries children;
-    while (!meshes.empty()) {
-      children.emplace_back(std::shared_ptr<AbstractNode>(), std::shared_ptr<const Geometry>(std::move(meshes.front())));
-      meshes.pop_front();
+    while (!meshes.empty ()) {
+      children.emplace_back (std::shared_ptr<AbstractNode> (), std::shared_ptr<const Geometry> (std::move (meshes.front ())));
+      meshes.pop_front ();
     }
 #ifdef ENABLE_MANIFOLD
-    if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
-      if (auto ps = PolySetUtils::getGeometryAsPolySet(ManifoldUtils::applyOperator3DManifold(children, OpenSCADOperator::UNION))) {
-        p = std::make_unique<PolySet>(*ps);
+    if (RenderSettings::inst ()->backend3D == RenderBackend3D::ManifoldBackend) {
+      if (auto ps = PolySetUtils::getGeometryAsPolySet (ManifoldUtils::applyOperator3DManifold (children, OpenSCADOperator::UNION))) {
+        p = std::make_unique<PolySet> (*ps);
       } else {
-        p = PolySet::createEmpty();
+        p = PolySet::createEmpty ();
       }
     } else
 #endif // ifdef ENABLE_MANIFOLD
     {
 #ifdef ENABLE_CGAL
-      if (auto ps = PolySetUtils::getGeometryAsPolySet(CGALUtils::applyUnion3D(children.begin(), children.end()))) {
-        p = std::make_unique<PolySet>(*ps);
+      if (auto ps = PolySetUtils::getGeometryAsPolySet (CGALUtils::applyUnion3D (children.begin (), children.end ()))) {
+        p = std::make_unique<PolySet> (*ps);
       } else {
-        p = PolySet::createEmpty();
+        p = PolySet::createEmpty ();
       }
 #else
-      p = PolySet::createEmpty();
+      p = PolySet::createEmpty ();
 #endif // ifdef ENABLE_CGAL
     }
     return p;
diff --git a/src/io/import_3mf_v2.cc b/src/io/import_3mf_v2.cc
index 6b62538a8..1ba80a692 100644
--- a/src/io/import_3mf_v2.cc
+++ b/src/io/import_3mf_v2.cc
@@ -48,14 +48,12 @@
 
 namespace {
 
-struct MeshObject
-{
+struct MeshObject {
   const Lib3MF::PMeshObject obj;
   const Matrix4d transform;
 };
 
-struct ModelMetadata
-{
+struct ModelMetadata {
   std::string title;
   std::string designer;
   std::string description;
@@ -69,36 +67,38 @@ struct ModelMetadata
 
 using MeshObjectList = std::list<std::unique_ptr<MeshObject>>;
 
-std::string get_object_type_name(const Lib3MF::eObjectType objecttype)
-{
+std::string get_object_type_name (const Lib3MF::eObjectType objecttype) {
   switch (objecttype) {
-  case Lib3MF::eObjectType::Other: return "Other";
-  case Lib3MF::eObjectType::Model: return "Model";
-  case Lib3MF::eObjectType::Support: return "Support";
-  case Lib3MF::eObjectType::SolidSupport: return "Solid Support";
-  default: return "<Unknown>";
+  case Lib3MF::eObjectType::Other:
+    return "Other";
+  case Lib3MF::eObjectType::Model:
+    return "Model";
+  case Lib3MF::eObjectType::Support:
+    return "Support";
+  case Lib3MF::eObjectType::SolidSupport:
+    return "Solid Support";
+  default:
+    return "<Unknown>";
   }
 }
 
-Matrix4d get_matrix(Lib3MF::sTransform& transform)
-{
+Matrix4d get_matrix (Lib3MF::sTransform &transform) {
   Matrix4d tm;
   tm << transform.m_Fields[0][0], transform.m_Fields[1][0], transform.m_Fields[2][0], transform.m_Fields[3][0],
     transform.m_Fields[0][1], transform.m_Fields[1][1], transform.m_Fields[2][1], transform.m_Fields[3][1],
     transform.m_Fields[0][2], transform.m_Fields[1][2], transform.m_Fields[2][2], transform.m_Fields[3][2],
-    0,                        0,                        0,                        1;
+    0, 0, 0, 1;
   return tm;
 }
 
-std::string collect_mesh_objects(const Lib3MF::PModel& model, MeshObjectList& object_list, const Lib3MF::PObject& object, const Matrix4d& m, const Location& loc, int level = 1)
-{
-  const bool is_mesh_object = object->IsMeshObject();
-  const bool is_components_object = object->IsComponentsObject();
-  const auto objecttype = object->GetType();
-  const auto partnumber = object->GetPartNumber();
-  const auto name = object->GetName();
+std::string collect_mesh_objects (const Lib3MF::PModel &model, MeshObjectList &object_list, const Lib3MF::PObject &object, const Matrix4d &m, const Location &loc, int level = 1) {
+  const bool is_mesh_object = object->IsMeshObject ();
+  const bool is_components_object = object->IsComponentsObject ();
+  const auto objecttype = object->GetType ();
+  const auto partnumber = object->GetPartNumber ();
+  const auto name = object->GetName ();
   bool hasuuid = false;
-  const auto uuid = object->GetUUID(hasuuid);
+  const auto uuid = object->GetUUID (hasuuid);
 
 #if 0
   // Validation disabled for now, this crashes in some cases. One example
@@ -111,30 +111,30 @@ std::string collect_mesh_objects(const Lib3MF::PModel& model, MeshObjectList& ob
 #endif
 
   if (is_mesh_object) {
-    const auto meshobject = model->GetMeshObjectByID(object->GetUniqueResourceID());
-    PRINTDB("%smesh type = %s, number = '%s', name = '%s' (%s)", boost::io::group(std::setw(2 * level), "") % get_object_type_name(objecttype) % partnumber % name % (hasuuid ? uuid : "<no uuid>"));
-    object_list.push_back(std::make_unique<MeshObject>(MeshObject{meshobject, m}));
+    const auto meshobject = model->GetMeshObjectByID (object->GetUniqueResourceID ());
+    PRINTDB ("%smesh type = %s, number = '%s', name = '%s' (%s)", boost::io::group (std::setw (2 * level), "") % get_object_type_name (objecttype) % partnumber % name % (hasuuid ? uuid : "<no uuid>"));
+    object_list.push_back (std::make_unique<MeshObject> (MeshObject{meshobject, m}));
     return "";
   }
   if (is_components_object) {
-    const auto componentsobject = model->GetComponentsObjectByID(object->GetUniqueResourceID());
-    const int componentcount = componentsobject->GetComponentCount();
-    PRINTDB("%sobject (%d components) type = %s, number = '%s', name = '%s' (%s)", boost::io::group(std::setw(2 * level), "") % componentcount % get_object_type_name(objecttype) % partnumber % name % (hasuuid ? uuid : "<no uuid>"));
+    const auto componentsobject = model->GetComponentsObjectByID (object->GetUniqueResourceID ());
+    const int componentcount = componentsobject->GetComponentCount ();
+    PRINTDB ("%sobject (%d components) type = %s, number = '%s', name = '%s' (%s)", boost::io::group (std::setw (2 * level), "") % componentcount % get_object_type_name (objecttype) % partnumber % name % (hasuuid ? uuid : "<no uuid>"));
 
     for (int idx = 0; idx < componentcount; ++idx) {
-      const auto component = componentsobject->GetComponent(idx);
-      const bool has_transform = component->HasTransform();
-      Lib3MF::sTransform transform{ .m_Fields = {{ 1, 0, 0 }, { 0, 1, 0 }, { 0, 0, 1 }, { 0, 0, 1 } } };
+      const auto component = componentsobject->GetComponent (idx);
+      const bool has_transform = component->HasTransform ();
+      Lib3MF::sTransform transform{.m_Fields = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}, {0, 0, 1}}};
       if (has_transform) {
-        transform = component->GetTransform();
+        transform = component->GetTransform ();
       }
-      const auto componentobject = component->GetObjectResource();
-      const Matrix4d cm = get_matrix(transform);
+      const auto componentobject = component->GetObjectResource ();
+      const Matrix4d cm = get_matrix (transform);
       if (has_transform) {
-        PRINTDB("%scomponent transform matrix\n%s", boost::io::group(std::setw(2 * level), "") % cm);
+        PRINTDB ("%scomponent transform matrix\n%s", boost::io::group (std::setw (2 * level), "") % cm);
       }
-      auto errmsg = collect_mesh_objects(model, object_list, componentobject, cm * m, loc, level + 1);
-      if (!errmsg.empty()) {
+      auto errmsg = collect_mesh_objects (model, object_list, componentobject, cm * m, loc, level + 1);
+      if (!errmsg.empty ()) {
         return errmsg;
       }
     }
@@ -145,9 +145,8 @@ std::string collect_mesh_objects(const Lib3MF::PModel& model, MeshObjectList& ob
 
 // lib3mf_propertyhandler_getcolor states:
 // (#00000000) means no property or a different kind of property!
-Color4f get_color(const Lib3MF::PColorGroup& colorgroup, const Lib3MF_uint32 propertyid)
-{
-  const auto color = colorgroup->GetColor(propertyid);
+Color4f get_color (const Lib3MF::PColorGroup &colorgroup, const Lib3MF_uint32 propertyid) {
+  const auto color = colorgroup->GetColor (propertyid);
   if (color.m_Red == 0 && color.m_Green == 0 && color.m_Blue == 0 && color.m_Alpha == 0) {
     return {}; // invalid color
   }
@@ -155,119 +154,113 @@ Color4f get_color(const Lib3MF::PColorGroup& colorgroup, const Lib3MF_uint32 pro
   return c;
 }
 
-Color4f get_triangle_color(const Lib3MF::PModel& model, const Lib3MF::sTriangleProperties triangle_properties)
-{
-  const auto colorgroup = model->GetColorGroupByID(triangle_properties.m_ResourceID);
-  const Color4f col0 = get_color(colorgroup, triangle_properties.m_PropertyIDs[0]);
-  const Color4f col1 = get_color(colorgroup, triangle_properties.m_PropertyIDs[1]);
-  const Color4f col2 = get_color(colorgroup, triangle_properties.m_PropertyIDs[2]);
-  if (col0.isValid() && col1.isValid() && col2.isValid()) {
+Color4f get_triangle_color (const Lib3MF::PModel &model, const Lib3MF::sTriangleProperties triangle_properties) {
+  const auto colorgroup = model->GetColorGroupByID (triangle_properties.m_ResourceID);
+  const Color4f col0 = get_color (colorgroup, triangle_properties.m_PropertyIDs[0]);
+  const Color4f col1 = get_color (colorgroup, triangle_properties.m_PropertyIDs[1]);
+  const Color4f col2 = get_color (colorgroup, triangle_properties.m_PropertyIDs[2]);
+  if (col0.isValid () && col1.isValid () && col2.isValid ()) {
     return {
-      std::clamp((col0.r() + col1.r() + col2.r()) / 3, 0.0f, 1.0f),
-      std::clamp((col0.g() + col1.g() + col2.g()) / 3, 0.0f, 1.0f),
-      std::clamp((col0.b() + col1.b() + col2.b()) / 3, 0.0f, 1.0f),
-      std::clamp((col0.a() + col1.a() + col2.a()) / 3, 0.0f, 1.0f)
-    };
+      std::clamp ((col0.r () + col1.r () + col2.r ()) / 3, 0.0f, 1.0f),
+      std::clamp ((col0.g () + col1.g () + col2.g ()) / 3, 0.0f, 1.0f),
+      std::clamp ((col0.b () + col1.b () + col2.b ()) / 3, 0.0f, 1.0f),
+      std::clamp ((col0.a () + col1.a () + col2.a ()) / 3, 0.0f, 1.0f)};
   }
   return {};
 }
 
-Color4f get_triangle_color_from_basematerial(const Lib3MF::PModel& model, const Lib3MF::sTriangleProperties triangle_properties)
-{
-  const auto basematerialgroup = model->GetBaseMaterialGroupByID(triangle_properties.m_ResourceID);
-  const auto displaycolor = basematerialgroup->GetDisplayColor(triangle_properties.m_PropertyIDs[0]);
+Color4f get_triangle_color_from_basematerial (const Lib3MF::PModel &model, const Lib3MF::sTriangleProperties triangle_properties) {
+  const auto basematerialgroup = model->GetBaseMaterialGroupByID (triangle_properties.m_ResourceID);
+  const auto displaycolor = basematerialgroup->GetDisplayColor (triangle_properties.m_PropertyIDs[0]);
   Color4f col{displaycolor.m_Red, displaycolor.m_Green, displaycolor.m_Blue, 255};
   return col;
 }
 
-Color4f get_triangle_color(const Lib3MF::PModel& model, const Lib3MF::PMeshObject& object, int idx)
-{
+Color4f get_triangle_color (const Lib3MF::PModel &model, const Lib3MF::PMeshObject &object, int idx) {
   Lib3MF::sTriangleProperties triangle_properties;
-  object->GetTriangleProperties(idx, triangle_properties);
+  object->GetTriangleProperties (idx, triangle_properties);
   if (triangle_properties.m_ResourceID == 0) {
     return {};
   }
 
-  const auto propertytype = model->GetPropertyTypeByID(triangle_properties.m_ResourceID);
+  const auto propertytype = model->GetPropertyTypeByID (triangle_properties.m_ResourceID);
   switch (propertytype) {
   case Lib3MF::ePropertyType::BaseMaterial:
-    return get_triangle_color_from_basematerial(model, triangle_properties);
+    return get_triangle_color_from_basematerial (model, triangle_properties);
   case Lib3MF::ePropertyType::Colors:
-    return get_triangle_color(model, triangle_properties);
+    return get_triangle_color (model, triangle_properties);
   default:
     return {};
   }
 }
 
-std::string import_3mf_mesh(const std::string& filename, unsigned int mesh_idx, const Lib3MF::PModel& model, const std::unique_ptr<MeshObject>& mo, std::unique_ptr<PolySet>& ps)
-{
+std::string import_3mf_mesh (const std::string &filename, unsigned int mesh_idx, const Lib3MF::PModel &model, const std::unique_ptr<MeshObject> &mo, std::unique_ptr<PolySet> &ps) {
   const auto object = mo->obj;
-  const auto vertex_count = object->GetVertexCount();
-  const auto triangle_count = object->GetTriangleCount();
+  const auto vertex_count = object->GetVertexCount ();
+  const auto triangle_count = object->GetTriangleCount ();
   if (!vertex_count || !triangle_count) {
     return "Empty mesh";
   }
 
-  const auto object_type = get_object_type_name(object->GetType());
+  const auto object_type = get_object_type_name (object->GetType ());
 
-  PRINTDB("%s: mesh %d, type: %s, vertex count: %lu, triangle count: %lu", filename.c_str() % mesh_idx % object_type % vertex_count % triangle_count);
+  PRINTDB ("%s: mesh %d, type: %s, vertex count: %lu, triangle count: %lu", filename.c_str () % mesh_idx % object_type % vertex_count % triangle_count);
 
-  ps->vertices.reserve(vertex_count);
-  ps->indices.reserve(triangle_count);
-  ps->color_indices.reserve(triangle_count);
+  ps->vertices.reserve (vertex_count);
+  ps->indices.reserve (triangle_count);
+  ps->color_indices.reserve (triangle_count);
 
   std::vector<Lib3MF::sPosition> all_vertices;
-  object->GetVertices(all_vertices);
-  for (const auto& vertex : all_vertices) {
-    const Vector4d v = mo->transform * Vector4d(vertex.m_Coordinates[0], vertex.m_Coordinates[1], vertex.m_Coordinates[2], 1);
-    ps->vertices.push_back(v.head(3));
+  object->GetVertices (all_vertices);
+  for (const auto &vertex : all_vertices) {
+    const Vector4d v = mo->transform * Vector4d (vertex.m_Coordinates[0], vertex.m_Coordinates[1], vertex.m_Coordinates[2], 1);
+    ps->vertices.push_back (v.head (3));
   }
 
   std::unordered_map<Color4f, int32_t> color_indices;
   for (Lib3MF_uint32 idx = 0; idx < triangle_count; ++idx) {
-    const auto triangle = object->GetTriangle(idx);
-    ps->indices.emplace_back();
-    for (const auto& idx : triangle.m_Indices) {
-      ps->indices.back().push_back(idx);
+    const auto triangle = object->GetTriangle (idx);
+    ps->indices.emplace_back ();
+    for (const auto &idx : triangle.m_Indices) {
+      ps->indices.back ().push_back (idx);
     }
 
-    const Color4f col = get_triangle_color(model, object, idx);
-    if (col.isValid()) {
-      const auto it = color_indices.find(col);
+    const Color4f col = get_triangle_color (model, object, idx);
+    if (col.isValid ()) {
+      const auto it = color_indices.find (col);
       int32_t cidx;
-      if (it == color_indices.end()) {
-        cidx = ps->colors.size();
-        ps->colors.push_back(col);
+      if (it == color_indices.end ()) {
+        cidx = ps->colors.size ();
+        ps->colors.push_back (col);
         color_indices[col] = cidx;
       } else {
         cidx = it->second;
       }
-      ps->color_indices.push_back(cidx);
+      ps->color_indices.push_back (cidx);
     } else {
-      ps->color_indices.push_back(-1);
+      ps->color_indices.push_back (-1);
     }
   }
-  if (ps->colors.empty()) {
-    ps->color_indices.clear();
+  if (ps->colors.empty ()) {
+    ps->color_indices.clear ();
   }
-  ps->setTriangular(true);
+  ps->setTriangular (true);
 
   return "";
 }
 
-std::string read_metadata(const Lib3MF::PModel& model)
-{
-  const auto metadatagroup = model->GetMetaDataGroup();
-  const auto metadatacount = metadatagroup->GetMetaDataCount();
+std::string read_metadata (const Lib3MF::PModel &model) {
+  const auto metadatagroup = model->GetMetaDataGroup ();
+  const auto metadatacount = metadatagroup->GetMetaDataCount ();
 
   ModelMetadata mmd;
   for (Lib3MF_uint32 idx = 0; idx < metadatacount; ++idx) {
-    const auto metadata = metadatagroup->GetMetaData(idx);
-    const auto key = metadata->GetKey();
-    const auto value = metadata->GetValue();
-    PRINTDB("METADATA[%d]: %s = '%s'", idx % key % value);
+    const auto metadata = metadatagroup->GetMetaData (idx);
+    const auto key = metadata->GetKey ();
+    const auto value = metadata->GetValue ();
+    PRINTDB ("METADATA[%d]: %s = '%s'", idx % key % value);
 
-    const std::string& name = key;
+    const std::string &name = key;
     if (name == "Title") {
       mmd.title = value;
     } else if (name == "Designer") {
@@ -289,8 +282,8 @@ std::string read_metadata(const Lib3MF::PModel& model)
     }
   }
 
-  if (!mmd.title.empty()) {
-    LOG("Reading 3MF with title '%1$s'", mmd.title);
+  if (!mmd.title.empty ()) {
+    LOG ("Reading 3MF with title '%1$s'", mmd.title);
   }
 
   return "";
@@ -298,20 +291,20 @@ std::string read_metadata(const Lib3MF::PModel& model)
 
 } // namespace
 
-std::string get_lib3mf_version() {
+std::string get_lib3mf_version () {
   Lib3MF_uint32 interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro;
   Lib3MF::PWrapper wrapper;
 
   try {
-    wrapper = Lib3MF::CWrapper::loadLibrary();
-    wrapper->GetLibraryVersion(interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro);
-  } catch (const Lib3MF::ELib3MFException& e) {
-    LOG(message_group::Export_Error, e.what());
+    wrapper = Lib3MF::CWrapper::loadLibrary ();
+    wrapper->GetLibraryVersion (interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro);
+  } catch (const Lib3MF::ELib3MFException &e) {
+    LOG (message_group::Export_Error, e.what ());
   }
 
   const OpenSCAD::library_version_number header_version{LIB3MF_VERSION_MAJOR, LIB3MF_VERSION_MINOR, LIB3MF_VERSION_MICRO};
   const OpenSCAD::library_version_number runtime_version{interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro};
-  return OpenSCAD::get_version_string(header_version, runtime_version);
+  return OpenSCAD::get_version_string (header_version, runtime_version);
 }
 
 #ifdef ENABLE_CGAL
@@ -321,142 +314,141 @@ std::string get_lib3mf_version() {
 #include "geometry/manifold/manifoldutils.h"
 #endif
 
-std::unique_ptr<PolySet> import_3mf(const std::string& filename, const Location& loc)
-{
+std::unique_ptr<PolySet> import_3mf (const std::string &filename, const Location &loc) {
   Lib3MF::PWrapper wrapper;
 
   try {
-    wrapper = Lib3MF::CWrapper::loadLibrary();
+    wrapper = Lib3MF::CWrapper::loadLibrary ();
     Lib3MF_uint32 interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro;
-    wrapper->GetLibraryVersion(interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro);
+    wrapper->GetLibraryVersion (interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro);
     if (interfaceVersionMajor != LIB3MF_VERSION_MAJOR) {
-      LOG(message_group::Error, "Invalid 3MF library major version %1$d.%2$d.%3$d, expected %4$d.%5$d.%6$d",
-          interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro,
-          LIB3MF_VERSION_MAJOR, LIB3MF_VERSION_MINOR, LIB3MF_VERSION_MICRO);
-      return PolySet::createEmpty();
+      LOG (message_group::Error, "Invalid 3MF library major version %1$d.%2$d.%3$d, expected %4$d.%5$d.%6$d",
+           interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro,
+           LIB3MF_VERSION_MAJOR, LIB3MF_VERSION_MINOR, LIB3MF_VERSION_MICRO);
+      return PolySet::createEmpty ();
     }
-  } catch (const Lib3MF::ELib3MFException& e) {
-    LOG(message_group::Export_Error, e.what());
-    return PolySet::createEmpty();
+  } catch (const Lib3MF::ELib3MFException &e) {
+    LOG (message_group::Export_Error, e.what ());
+    return PolySet::createEmpty ();
   }
 
   Lib3MF::PModel model;
   try {
-    model = wrapper->CreateModel();
+    model = wrapper->CreateModel ();
     if (!model) {
-      LOG(message_group::Error, "Could not create model");
-      return PolySet::createEmpty();
+      LOG (message_group::Error, "Could not create model");
+      return PolySet::createEmpty ();
     }
-  } catch (const Lib3MF::ELib3MFException& e) {
-    LOG(message_group::Export_Error, e.what());
-    return PolySet::createEmpty();
+  } catch (const Lib3MF::ELib3MFException &e) {
+    LOG (message_group::Export_Error, e.what ());
+    return PolySet::createEmpty ();
   }
 
   Lib3MF::PReader reader;
   try {
-    reader = model->QueryReader("3mf");
+    reader = model->QueryReader ("3mf");
     if (!reader) {
-      LOG(message_group::Error, "Could not create 3MF reader");
-      return PolySet::createEmpty();
+      LOG (message_group::Error, "Could not create 3MF reader");
+      return PolySet::createEmpty ();
     }
-  } catch (const Lib3MF::ELib3MFException& e) {
-    LOG(message_group::Export_Error, "Could create 3MF reader, import() at line %1$d: %2$s", loc.firstLine(), e.what());
-    return PolySet::createEmpty();
+  } catch (const Lib3MF::ELib3MFException &e) {
+    LOG (message_group::Export_Error, "Could create 3MF reader, import() at line %1$d: %2$s", loc.firstLine (), e.what ());
+    return PolySet::createEmpty ();
   }
 
   try {
-    reader->ReadFromFile(filename);
-  } catch (const Lib3MF::ELib3MFException& e) {
-    LOG(message_group::Warning, "Could not read file '%1$s', import() at line %2$d: %3$s", filename.c_str(), loc.firstLine(), e.what());
-    return PolySet::createEmpty();
+    reader->ReadFromFile (filename);
+  } catch (const Lib3MF::ELib3MFException &e) {
+    LOG (message_group::Warning, "Could not read file '%1$s', import() at line %2$d: %3$s", filename.c_str (), loc.firstLine (), e.what ());
+    return PolySet::createEmpty ();
   }
 
-  read_metadata(model);
+  read_metadata (model);
 
   try {
-    Lib3MF::PBuildItemIterator builditem_it = model->GetBuildItems();
+    Lib3MF::PBuildItemIterator builditem_it = model->GetBuildItems ();
     if (!builditem_it) {
-      LOG(message_group::Warning, "Could not retrieve build items, import() at line %2$d", filename.c_str(), loc.firstLine());
-      return PolySet::createEmpty();
+      LOG (message_group::Warning, "Could not retrieve build items, import() at line %2$d", filename.c_str (), loc.firstLine ());
+      return PolySet::createEmpty ();
     }
 
     std::list<std::unique_ptr<PolySet>> meshes;
-    while (builditem_it->MoveNext()) {
-      const auto builditem = builditem_it->GetCurrent();
-      const auto builditemhandle = builditem->GetObjectResourceID();
-      const auto partnumber = builditem->GetPartNumber();
+    while (builditem_it->MoveNext ()) {
+      const auto builditem = builditem_it->GetCurrent ();
+      const auto builditemhandle = builditem->GetObjectResourceID ();
+      const auto partnumber = builditem->GetPartNumber ();
       bool hasuuid = false;
-      const auto uuid = builditem->GetUUID(hasuuid);
-      Lib3MF::sTransform transform{ .m_Fields = {{ 1, 0, 0 }, { 0, 1, 0 }, { 0, 0, 1 }, { 0, 0, 0 } } };
-      if (builditem->HasObjectTransform()) {
-        transform = builditem->GetObjectTransform();
+      const auto uuid = builditem->GetUUID (hasuuid);
+      Lib3MF::sTransform transform{.m_Fields = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}, {0, 0, 0}}};
+      if (builditem->HasObjectTransform ()) {
+        transform = builditem->GetObjectTransform ();
       }
-      const auto object = builditem->GetObjectResource();
-      const Matrix4d m = get_matrix(transform);
+      const auto object = builditem->GetObjectResource ();
+      const Matrix4d m = get_matrix (transform);
 
-      PRINTDB("build item %d, part number = '%s' (%s)", builditemhandle % partnumber % (hasuuid ? uuid : "<no uuid>"));
-      if (builditem->HasObjectTransform()) {
-        PRINTDB("build item transform matrix\n%s", m);
+      PRINTDB ("build item %d, part number = '%s' (%s)", builditemhandle % partnumber % (hasuuid ? uuid : "<no uuid>"));
+      if (builditem->HasObjectTransform ()) {
+        PRINTDB ("build item transform matrix\n%s", m);
       }
 
       MeshObjectList object_list;
-      std::string errmsg = collect_mesh_objects(model, object_list, object, m, loc);
-      if (!errmsg.empty()) {
-        LOG(message_group::Warning, "Error collecting meshes, import() at line %2$d", filename.c_str(), loc.firstLine());
-        return PolySet::createEmpty();
+      std::string errmsg = collect_mesh_objects (model, object_list, object, m, loc);
+      if (!errmsg.empty ()) {
+        LOG (message_group::Warning, "Error collecting meshes, import() at line %2$d", filename.c_str (), loc.firstLine ());
+        return PolySet::createEmpty ();
       }
 
-      for (const auto& mo : object_list) {
-        auto ps = PolySet::createEmpty();
-        std::string errmsg = import_3mf_mesh(filename, meshes.size(), model, mo, ps);
-        if (errmsg.empty()) {
-          if (ps->isEmpty()) {
+      for (const auto &mo : object_list) {
+        auto ps = PolySet::createEmpty ();
+        std::string errmsg = import_3mf_mesh (filename, meshes.size (), model, mo, ps);
+        if (errmsg.empty ()) {
+          if (ps->isEmpty ()) {
             continue;
           }
         } else {
-          LOG(message_group::Warning, "%1$s, import() at line %2$d", errmsg, loc.firstLine());
-          return PolySet::createEmpty();
+          LOG (message_group::Warning, "%1$s, import() at line %2$d", errmsg, loc.firstLine ());
+          return PolySet::createEmpty ();
         }
 
-        meshes.push_back(std::move(ps));
+        meshes.push_back (std::move (ps));
       }
     }
 
-    if (meshes.empty()) {
-      return PolySet::createEmpty();
-    } else if (meshes.size() == 1) {
-      return std::move(meshes.front());
+    if (meshes.empty ()) {
+      return PolySet::createEmpty ();
+    } else if (meshes.size () == 1) {
+      return std::move (meshes.front ());
     } else {
       std::unique_ptr<PolySet> p;
       Geometry::Geometries children;
-      while (!meshes.empty()) {
-        children.emplace_back(std::shared_ptr<AbstractNode>(), std::shared_ptr<const Geometry>(std::move(meshes.front())));
-        meshes.pop_front();
+      while (!meshes.empty ()) {
+        children.emplace_back (std::shared_ptr<AbstractNode> (), std::shared_ptr<const Geometry> (std::move (meshes.front ())));
+        meshes.pop_front ();
       }
-  #ifdef ENABLE_MANIFOLD
-      if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
-        if (auto ps = PolySetUtils::getGeometryAsPolySet(ManifoldUtils::applyOperator3DManifold(children, OpenSCADOperator::UNION))) {
-          p = std::make_unique<PolySet>(*ps);
+#ifdef ENABLE_MANIFOLD
+      if (RenderSettings::inst ()->backend3D == RenderBackend3D::ManifoldBackend) {
+        if (auto ps = PolySetUtils::getGeometryAsPolySet (ManifoldUtils::applyOperator3DManifold (children, OpenSCADOperator::UNION))) {
+          p = std::make_unique<PolySet> (*ps);
         } else {
-          p = PolySet::createEmpty();
+          p = PolySet::createEmpty ();
         }
       } else
-  #endif // ifdef ENABLE_MANIFOLD
+#endif // ifdef ENABLE_MANIFOLD
       {
-  #ifdef ENABLE_CGAL
-        if (auto ps = PolySetUtils::getGeometryAsPolySet(CGALUtils::applyUnion3D(children.begin(), children.end()))) {
-          p = std::make_unique<PolySet>(*ps);
+#ifdef ENABLE_CGAL
+        if (auto ps = PolySetUtils::getGeometryAsPolySet (CGALUtils::applyUnion3D (children.begin (), children.end ()))) {
+          p = std::make_unique<PolySet> (*ps);
         } else {
-          p = PolySet::createEmpty();
+          p = PolySet::createEmpty ();
         }
-  #else
-        p = PolySet::createEmpty();
-  #endif // ifdef ENABLE_CGAL
+#else
+        p = PolySet::createEmpty ();
+#endif // ifdef ENABLE_CGAL
       }
       return p;
     }
-  } catch (const Lib3MF::ELib3MFException& e) {
-    LOG(message_group::Error, e.what());
+  } catch (const Lib3MF::ELib3MFException &e) {
+    LOG (message_group::Error, e.what ());
     return nullptr;
   }
 }
diff --git a/src/io/import_amf.cc b/src/io/import_amf.cc
index 63c0ef261..ba39903e3 100644
--- a/src/io/import_amf.cc
+++ b/src/io/import_amf.cc
@@ -50,13 +50,13 @@
 #include <filesystem>
 #include <boost/lexical_cast.hpp>
 
-static const std::string text_node("#text");
-static const std::string object("/amf/object");
-static const std::string coordinates("/amf/object/mesh/vertices/vertex/coordinates");
+static const std::string text_node ("#text");
+static const std::string object ("/amf/object");
+static const std::string coordinates ("/amf/object/mesh/vertices/vertex/coordinates");
 static const std::string coordinates_x = coordinates + "/x";
 static const std::string coordinates_y = coordinates + "/y";
 static const std::string coordinates_z = coordinates + "/z";
-static const std::string triangle("/amf/object/mesh/volume/triangle");
+static const std::string triangle ("/amf/object/mesh/volume/triangle");
 static const std::string triangle_v1 = triangle + "/v1";
 static const std::string triangle_v2 = triangle + "/v2";
 static const std::string triangle_v3 = triangle + "/v3";
@@ -66,7 +66,7 @@ class AmfImporter
 private:
   std::string xpath; // element nesting stack
 
-  using cb_func = void (*)(AmfImporter *, const xmlChar *);
+  using cb_func = void (*) (AmfImporter *, const xmlChar *);
 
   std::unique_ptr<PolySetBuilder> builder;
   std::vector<std::unique_ptr<PolySet>> polySets;
@@ -79,175 +79,157 @@ private:
   std::map<const std::string, cb_func> start_funcs;
   std::map<const std::string, cb_func> end_funcs;
 
-  static void set_x(AmfImporter *importer, const xmlChar *value);
-  static void set_y(AmfImporter *importer, const xmlChar *value);
-  static void set_z(AmfImporter *importer, const xmlChar *value);
-  static void set_v1(AmfImporter *importer, const xmlChar *value);
-  static void set_v2(AmfImporter *importer, const xmlChar *value);
-  static void set_v3(AmfImporter *importer, const xmlChar *value);
-  static void start_object(AmfImporter *importer, const xmlChar *value);
-  static void end_object(AmfImporter *importer, const xmlChar *value);
-  static void end_triangle(AmfImporter *importer, const xmlChar *vlue);
-  static void end_vertex(AmfImporter *importer, const xmlChar *value);
+  static void set_x (AmfImporter *importer, const xmlChar *value);
+  static void set_y (AmfImporter *importer, const xmlChar *value);
+  static void set_z (AmfImporter *importer, const xmlChar *value);
+  static void set_v1 (AmfImporter *importer, const xmlChar *value);
+  static void set_v2 (AmfImporter *importer, const xmlChar *value);
+  static void set_v3 (AmfImporter *importer, const xmlChar *value);
+  static void start_object (AmfImporter *importer, const xmlChar *value);
+  static void end_object (AmfImporter *importer, const xmlChar *value);
+  static void end_triangle (AmfImporter *importer, const xmlChar *vlue);
+  static void end_vertex (AmfImporter *importer, const xmlChar *value);
 
-  int streamFile(const char *filename);
-  void processNode(xmlTextReaderPtr reader);
+  int streamFile (const char *filename);
+  void processNode (xmlTextReaderPtr reader);
 
 protected:
-  const Location& loc;
+  const Location &loc;
 
 public:
-  AmfImporter(const Location& loc);
-  virtual ~AmfImporter() = default;
-  std::unique_ptr<PolySet> read(const std::string& filename);
+  AmfImporter (const Location &loc);
+  virtual ~AmfImporter () = default;
+  std::unique_ptr<PolySet> read (const std::string &filename);
 
-  virtual xmlTextReaderPtr createXmlReader(const char *filename);
+  virtual xmlTextReaderPtr createXmlReader (const char *filename);
 };
 
-AmfImporter::AmfImporter(const Location& loc) : loc(loc)
-{
+AmfImporter::AmfImporter (const Location &loc)
+  : loc (loc) {
 }
 
-void AmfImporter::set_x(AmfImporter *importer, const xmlChar *value)
-{
-  importer->x = boost::lexical_cast<double>(std::string((const char *)value));
+void AmfImporter::set_x (AmfImporter *importer, const xmlChar *value) {
+  importer->x = boost::lexical_cast<double> (std::string ((const char *)value));
 }
 
-void AmfImporter::set_y(AmfImporter *importer, const xmlChar *value)
-{
-  importer->y = boost::lexical_cast<double>(std::string((const char *)value));
+void AmfImporter::set_y (AmfImporter *importer, const xmlChar *value) {
+  importer->y = boost::lexical_cast<double> (std::string ((const char *)value));
 }
 
-void AmfImporter::set_z(AmfImporter *importer, const xmlChar *value)
-{
-  importer->z = boost::lexical_cast<double>(std::string((const char *)value));
+void AmfImporter::set_z (AmfImporter *importer, const xmlChar *value) {
+  importer->z = boost::lexical_cast<double> (std::string ((const char *)value));
 }
 
-void AmfImporter::set_v1(AmfImporter *importer, const xmlChar *value)
-{
-  importer->idx_v1 = boost::lexical_cast<int>(std::string((const char *)value));
+void AmfImporter::set_v1 (AmfImporter *importer, const xmlChar *value) {
+  importer->idx_v1 = boost::lexical_cast<int> (std::string ((const char *)value));
 }
 
-void AmfImporter::set_v2(AmfImporter *importer, const xmlChar *value)
-{
-  importer->idx_v2 = boost::lexical_cast<int>(std::string((const char *)value));
+void AmfImporter::set_v2 (AmfImporter *importer, const xmlChar *value) {
+  importer->idx_v2 = boost::lexical_cast<int> (std::string ((const char *)value));
 }
 
-void AmfImporter::set_v3(AmfImporter *importer, const xmlChar *value)
-{
-  importer->idx_v3 = boost::lexical_cast<int>(std::string((const char *)value));
+void AmfImporter::set_v3 (AmfImporter *importer, const xmlChar *value) {
+  importer->idx_v3 = boost::lexical_cast<int> (std::string ((const char *)value));
 }
 
-void AmfImporter::start_object(AmfImporter *importer, const xmlChar *)
-{
-  importer->builder = std::make_unique<PolySetBuilder>(0, 0);
+void AmfImporter::start_object (AmfImporter *importer, const xmlChar *) {
+  importer->builder = std::make_unique<PolySetBuilder> (0, 0);
 }
 
-void AmfImporter::end_object(AmfImporter *importer, const xmlChar *)
-{
-  PRINTDB("AMF: add object %d", importer->polySets.size());
-  importer->polySets.push_back(importer->builder->build());
-  importer->vertex_list.clear();
-  importer->builder.reset(nullptr);
+void AmfImporter::end_object (AmfImporter *importer, const xmlChar *) {
+  PRINTDB ("AMF: add object %d", importer->polySets.size ());
+  importer->polySets.push_back (importer->builder->build ());
+  importer->vertex_list.clear ();
+  importer->builder.reset (nullptr);
 }
 
-void AmfImporter::end_vertex(AmfImporter *importer, const xmlChar *)
-{
-  PRINTDB("AMF: add vertex %d - (%.2f, %.2f, %.2f)", importer->vertex_list.size() % importer->x % importer->y % importer->z);
-  importer->vertex_list.emplace_back(importer->x, importer->y, importer->z);
+void AmfImporter::end_vertex (AmfImporter *importer, const xmlChar *) {
+  PRINTDB ("AMF: add vertex %d - (%.2f, %.2f, %.2f)", importer->vertex_list.size () % importer->x % importer->y % importer->z);
+  importer->vertex_list.emplace_back (importer->x, importer->y, importer->z);
 }
 
-void AmfImporter::end_triangle(AmfImporter *importer, const xmlChar *)
-{
+void AmfImporter::end_triangle (AmfImporter *importer, const xmlChar *) {
   int idx[3] = {importer->idx_v1, importer->idx_v2, importer->idx_v3};
-  PRINTDB("AMF: add triangle %d - (%.2f, %.2f, %.2f)", importer->vertex_list.size() % idx[0] % idx[1] % idx[2]);
+  PRINTDB ("AMF: add triangle %d - (%.2f, %.2f, %.2f)", importer->vertex_list.size () % idx[0] % idx[1] % idx[2]);
 
-  std::vector<Eigen::Vector3d>& v = importer->vertex_list;
+  std::vector<Eigen::Vector3d> &v = importer->vertex_list;
 
-  importer->builder->beginPolygon(3);
-  for (auto i : idx)// TODO set vertex array first
-    importer->builder->addVertex(Vector3d(v[i].x(), v[i].y(), v[i].z()));
+  importer->builder->beginPolygon (3);
+  for (auto i : idx) // TODO set vertex array first
+    importer->builder->addVertex (Vector3d (v[i].x (), v[i].y (), v[i].z ()));
 }
 
-void AmfImporter::processNode(xmlTextReaderPtr reader)
-{
-  const char *name = reinterpret_cast<const char *>(xmlTextReaderName(reader));
-  if (name == nullptr) name = reinterpret_cast<const char *>(xmlStrdup(BAD_CAST "--"));
-  xmlChar *value = xmlTextReaderValue(reader);
-  int node_type = xmlTextReaderNodeType(reader);
+void AmfImporter::processNode (xmlTextReaderPtr reader) {
+  const char *name = reinterpret_cast<const char *> (xmlTextReaderName (reader));
+  if (name == nullptr)
+    name = reinterpret_cast<const char *> (xmlStrdup (BAD_CAST "--"));
+  xmlChar *value = xmlTextReaderValue (reader);
+  int node_type = xmlTextReaderNodeType (reader);
   switch (node_type) {
-  case XML_READER_TYPE_ELEMENT:
-  {
+  case XML_READER_TYPE_ELEMENT: {
     xpath += '/';
     xpath += name;
     cb_func startFunc = start_funcs[xpath];
     if (startFunc) {
-      PRINTDB("AMF: start %s", xpath);
-      startFunc(this, nullptr);
+      PRINTDB ("AMF: start %s", xpath);
+      startFunc (this, nullptr);
     }
-  }
-  break;
-  case XML_READER_TYPE_END_ELEMENT:
-  {
+  } break;
+  case XML_READER_TYPE_END_ELEMENT: {
     cb_func endFunc = end_funcs[xpath];
     if (endFunc) {
-      PRINTDB("AMF: end   %s", xpath);
-      endFunc(this, value);
+      PRINTDB ("AMF: end   %s", xpath);
+      endFunc (this, value);
     }
-    size_t pos = xpath.find_last_of('/');
-    if (pos != std::string::npos) xpath.erase(pos);
-  }
-  break;
-  case XML_READER_TYPE_TEXT:
-  {
+    size_t pos = xpath.find_last_of ('/');
+    if (pos != std::string::npos)
+      xpath.erase (pos);
+  } break;
+  case XML_READER_TYPE_TEXT: {
     cb_func textFunc = funcs[xpath];
     if (textFunc) {
-      PRINTDB("AMF: text  %s - '%s'", xpath % value);
-      textFunc(this, value);
+      PRINTDB ("AMF: text  %s - '%s'", xpath % value);
+      textFunc (this, value);
     }
-  }
-  break;
+  } break;
   }
 
-  xmlFree(value);
-  xmlFree((void *) (name));
+  xmlFree (value);
+  xmlFree ((void *)(name));
 }
 
-xmlTextReaderPtr AmfImporter::createXmlReader(const char *filename)
-{
-  return xmlReaderForFile(filename, nullptr, XML_PARSE_NOENT | XML_PARSE_NOERROR | XML_PARSE_NOWARNING);
+xmlTextReaderPtr AmfImporter::createXmlReader (const char *filename) {
+  return xmlReaderForFile (filename, nullptr, XML_PARSE_NOENT | XML_PARSE_NOERROR | XML_PARSE_NOWARNING);
 }
 
-int AmfImporter::streamFile(const char *filename)
-{
+int AmfImporter::streamFile (const char *filename) {
   int ret;
 
-  xmlTextReaderPtr reader = createXmlReader(filename);
+  xmlTextReaderPtr reader = createXmlReader (filename);
 
   if (reader == nullptr) {
-    LOG(message_group::Warning, "Can't open import file '%1$s', import() at line %2$d", filename, this->loc.firstLine());
+    LOG (message_group::Warning, "Can't open import file '%1$s', import() at line %2$d", filename, this->loc.firstLine ());
     return 1;
   }
 
   try {
-    xmlTextReaderSetParserProp(reader, XML_PARSER_SUBST_ENTITIES, 1);
-    ret = xmlTextReaderRead(reader);
+    xmlTextReaderSetParserProp (reader, XML_PARSER_SUBST_ENTITIES, 1);
+    ret = xmlTextReaderRead (reader);
     while (ret == 1) {
-      processNode(reader);
-      ret = xmlTextReaderRead(reader);
+      processNode (reader);
+      ret = xmlTextReaderRead (reader);
     }
-    xmlFreeTextReader(reader);
-  } catch (boost::bad_lexical_cast&) {
+    xmlFreeTextReader (reader);
+  } catch (boost::bad_lexical_cast &) {
     ret = -1;
   }
   if (ret != 0) {
-    LOG(message_group::Warning, "Failed to parse file '%1$s', import() at line %2$d", filename, this->loc.firstLine());
+    LOG (message_group::Warning, "Failed to parse file '%1$s', import() at line %2$d", filename, this->loc.firstLine ());
   }
   return ret;
 }
 
-std::unique_ptr<PolySet> AmfImporter::read(const std::string& filename)
-{
+std::unique_ptr<PolySet> AmfImporter::read (const std::string &filename) {
   funcs[coordinates_x] = set_x;
   funcs[coordinates_y] = set_y;
   funcs[coordinates_z] = set_z;
@@ -258,31 +240,31 @@ std::unique_ptr<PolySet> AmfImporter::read(const std::string& filename)
   end_funcs[coordinates] = end_vertex;
   end_funcs[triangle] = end_triangle;
   end_funcs[object] = end_object;
-  streamFile(filename.c_str());
-  vertex_list.clear();
+  streamFile (filename.c_str ());
+  vertex_list.clear ();
 
-  if (polySets.empty()) {
-    return PolySet::createEmpty();
+  if (polySets.empty ()) {
+    return PolySet::createEmpty ();
   }
-  if (polySets.size() == 1) {
-    return std::move(polySets[0]);
+  if (polySets.size () == 1) {
+    return std::move (polySets[0]);
   }
-  if (polySets.size() > 1) {
+  if (polySets.size () > 1) {
     Geometry::Geometries children;
-    for (auto& polySet : polySets) {
-      children.push_back(std::make_pair(std::shared_ptr<AbstractNode>(), std::move(polySet)));
+    for (auto &polySet : polySets) {
+      children.push_back (std::make_pair (std::shared_ptr<AbstractNode> (), std::move (polySet)));
     }
 
 #ifdef ENABLE_CGAL
-    std::unique_ptr<const Geometry> geom = CGALUtils::applyUnion3D(children.begin(), children.end());
-    if (auto ps = PolySetUtils::getGeometryAsPolySet(std::move(geom))) {
+    std::unique_ptr<const Geometry> geom = CGALUtils::applyUnion3D (children.begin (), children.end ());
+    if (auto ps = PolySetUtils::getGeometryAsPolySet (std::move (geom))) {
       // FIXME: Unnecessary copy
-      return std::make_unique<PolySet>(*ps);
+      return std::make_unique<PolySet> (*ps);
     } else
 #endif // ENABLE_CGAL
-    LOG(message_group::Error, "Error importing multi-object AMF file '%1$s', import() at line %2$d", filename, this->loc.firstLine());
+      LOG (message_group::Error, "Error importing multi-object AMF file '%1$s', import() at line %2$d", filename, this->loc.firstLine ());
   }
-  return PolySet::createEmpty();
+  return PolySet::createEmpty ();
 }
 
 #ifdef ENABLE_LIBZIP
@@ -292,76 +274,74 @@ std::unique_ptr<PolySet> AmfImporter::read(const std::string& filename)
 class AmfImporterZIP : public AmfImporter
 {
 private:
-  struct zip *archive {nullptr};
-  struct zip_file *zipfile {nullptr};
+  struct zip *archive{nullptr};
+  struct zip_file *zipfile{nullptr};
 
-  static int read_callback(void *context, char *buffer, int len);
-  static int close_callback(void *context);
+  static int read_callback (void *context, char *buffer, int len);
+  static int close_callback (void *context);
 
 public:
-  AmfImporterZIP(const Location& loc);
+  AmfImporterZIP (const Location &loc);
 
-  xmlTextReaderPtr createXmlReader(const char *filename) override;
+  xmlTextReaderPtr createXmlReader (const char *filename) override;
 };
 
-AmfImporterZIP::AmfImporterZIP(const Location& loc) : AmfImporter(loc)
-{
+AmfImporterZIP::AmfImporterZIP (const Location &loc)
+  : AmfImporter (loc) {
 }
 
-int AmfImporterZIP::read_callback(void *context, char *buffer, int len)
-{
+int AmfImporterZIP::read_callback (void *context, char *buffer, int len) {
   auto *importer = (AmfImporterZIP *)context;
-  return zip_fread(importer->zipfile, buffer, len);
+  return zip_fread (importer->zipfile, buffer, len);
 }
 
-int AmfImporterZIP::close_callback(void *context)
-{
+int AmfImporterZIP::close_callback (void *context) {
   auto *importer = (AmfImporterZIP *)context;
-  return zip_fclose(importer->zipfile);
+  return zip_fclose (importer->zipfile);
 }
 
-xmlTextReaderPtr AmfImporterZIP::createXmlReader(const char *filepath)
-{
-  archive = zip_open(filepath, 0, nullptr);
+xmlTextReaderPtr AmfImporterZIP::createXmlReader (const char *filepath) {
+  archive = zip_open (filepath, 0, nullptr);
   if (archive) {
     // Separate the filename without using filesystem::path because that gives wide result on Windows TM
-    const char *last_slash = strrchr(filepath, '/');
-    const char *last_bslash = strrchr(filepath, '\\');
-    if (last_bslash > last_slash) last_slash = last_bslash;
+    const char *last_slash = strrchr (filepath, '/');
+    const char *last_bslash = strrchr (filepath, '\\');
+    if (last_bslash > last_slash)
+      last_slash = last_bslash;
     const char *filename = last_slash ? last_slash + 1 : filepath;
-    zipfile = zip_fopen(archive, filename, ZIP_FL_NODIR);
+    zipfile = zip_fopen (archive, filename, ZIP_FL_NODIR);
     if (zipfile == nullptr) {
-      LOG(message_group::Warning, "Can't read file '%1$s' from zipped AMF '%2$s', import() at line %3$d", filename, filepath, this->loc.firstLine());
+      LOG (message_group::Warning, "Can't read file '%1$s' from zipped AMF '%2$s', import() at line %3$d", filename, filepath, this->loc.firstLine ());
     }
-    if ((zipfile == nullptr) && (zip_get_num_entries(archive, 0) == 1)) {
-      LOG(message_group::Warning, "Trying to read single entry '%1$s'", zip_get_name(archive, 0, 0));
-      zipfile = zip_fopen_index(archive, 0, 0);
+    if ((zipfile == nullptr) && (zip_get_num_entries (archive, 0) == 1)) {
+      LOG (message_group::Warning, "Trying to read single entry '%1$s'", zip_get_name (archive, 0, 0));
+      zipfile = zip_fopen_index (archive, 0, 0);
     }
     if (zipfile) {
-      return xmlReaderForIO(read_callback, close_callback, this, filename, nullptr,
-                            XML_PARSE_NOENT | XML_PARSE_NOERROR | XML_PARSE_NOWARNING);
+      return xmlReaderForIO (read_callback, close_callback, this, filename, nullptr,
+                             XML_PARSE_NOENT | XML_PARSE_NOERROR | XML_PARSE_NOWARNING);
     } else {
-      zip_close(archive);
+      zip_close (archive);
       zipfile = nullptr;
       return nullptr;
     }
   } else {
-    return AmfImporter::createXmlReader(filepath);
+    return AmfImporter::createXmlReader (filepath);
   }
 }
 
-std::unique_ptr<PolySet> import_amf(const std::string& filename, const Location& loc) {
-  LOG(message_group::Deprecated, "AMF import is deprecated. Please use 3MF instead.");
-  AmfImporterZIP importer(loc);
-  return importer.read(filename);
+std::unique_ptr<PolySet> import_amf (const std::string &filename, const Location &loc) {
+  LOG (message_group::Deprecated, "AMF import is deprecated. Please use 3MF instead.");
+  AmfImporterZIP importer (loc);
+  return importer.read (filename);
 }
 
 #else
 
-std::unique_ptr<PolySet> import_amf(const std::string& filename, const Location& loc) {
-  LOG(message_group::Deprecated, "AMF import is deprecated. Please use 3MF instead.");
-  AmfImporter importer(loc);
-  return importer.read(filename);
+std::unique_ptr<PolySet> import_amf (const std::string &filename, const Location &loc) {
+  LOG (message_group::Deprecated, "AMF import is deprecated. Please use 3MF instead.");
+  AmfImporter importer (loc);
+  return importer.read (filename);
 }
 
 #endif // ifdef ENABLE_LIBZIP
diff --git a/src/io/import_json.cc b/src/io/import_json.cc
index e0e0e4460..872d2aa06 100644
--- a/src/io/import_json.cc
+++ b/src/io/import_json.cc
@@ -41,54 +41,51 @@ using json = nlohmann::json;
 
 namespace {
 
-ObjectType to_obj(const json& j, EvaluationSession *session);
+ObjectType to_obj (const json &j, EvaluationSession *session);
 
-Value to_value(const json& j, EvaluationSession *session)
-{
-  if (j.is_string()) {
-    return Value{j.get<std::string>()};
-  } else if (j.is_number()) {
-    return Value{j.get<double>()};
-  } else if (j.is_boolean()) {
-    return Value{j.get<bool>()};
-  } else if (j.is_object()) {
-    return Value{to_obj(j, session)};
-  } else if (j.is_array()) {
+Value to_value (const json &j, EvaluationSession *session) {
+  if (j.is_string ()) {
+    return Value{j.get<std::string> ()};
+  } else if (j.is_number ()) {
+    return Value{j.get<double> ()};
+  } else if (j.is_boolean ()) {
+    return Value{j.get<bool> ()};
+  } else if (j.is_object ()) {
+    return Value{to_obj (j, session)};
+  } else if (j.is_array ()) {
     Value::VectorType vec{session};
-    for (const auto& elem : j) {
-      vec.emplace_back(to_value(elem, session));
+    for (const auto &elem : j) {
+      vec.emplace_back (to_value (elem, session));
     }
-    return std::move(vec);
+    return std::move (vec);
   }
-  return Value::undefined.clone();
+  return Value::undefined.clone ();
 }
 
-ObjectType to_obj(const json& j, EvaluationSession *session)
-{
+ObjectType to_obj (const json &j, EvaluationSession *session) {
   ObjectType obj{session};
-  for (const auto& item : j.items()) {
-    obj.set(item.key(), to_value(item.value(), session));
+  for (const auto &item : j.items ()) {
+    obj.set (item.key (), to_value (item.value (), session));
   }
   return obj;
 }
 
 } // namespace
 
-Value import_json(const std::string& filename, EvaluationSession *session, const Location& loc)
-{
-  std::ifstream i(filename);
+Value import_json (const std::string &filename, EvaluationSession *session, const Location &loc) {
+  std::ifstream i (filename);
 
   try {
     if (i) {
       json j;
       i >> j;
-      return Value{to_value(j, session)};
+      return Value{to_value (j, session)};
     } else {
-      LOG(message_group::Warning, loc, "", "Could not read file '%1$s'", filename);
+      LOG (message_group::Warning, loc, "", "Could not read file '%1$s'", filename);
     }
-  } catch (const std::exception& e) {
-    LOG(message_group::Warning, loc, "", "Failed to parse file '%1$s': %s", filename, e.what());
+  } catch (const std::exception &e) {
+    LOG (message_group::Warning, loc, "", "Failed to parse file '%1$s': %s", filename, e.what ());
   }
 
-  return Value::undefined.clone();
+  return Value::undefined.clone ();
 }
diff --git a/src/io/import_nef.cc b/src/io/import_nef.cc
index de4c41e35..72a689dda 100644
--- a/src/io/import_nef.cc
+++ b/src/io/import_nef.cc
@@ -13,23 +13,22 @@
 #include "geometry/cgal/CGALNefGeometry.h"
 #include <CGAL/IO/Nef_polyhedron_iostream_3.h>
 
-std::unique_ptr<CGALNefGeometry> import_nef3(const std::string& filename, const Location& loc)
-{
+std::unique_ptr<CGALNefGeometry> import_nef3 (const std::string &filename, const Location &loc) {
   // Open file and position at the end
-  std::ifstream f(filename.c_str(), std::ios::in | std::ios::binary);
-  if (!f.good()) {
-    LOG(message_group::Warning, "Can't open import file '%1$s', import() at line %2$d", filename, loc.firstLine());
-    return std::make_unique<CGALNefGeometry>();
+  std::ifstream f (filename.c_str (), std::ios::in | std::ios::binary);
+  if (!f.good ()) {
+    LOG (message_group::Warning, "Can't open import file '%1$s', import() at line %2$d", filename, loc.firstLine ());
+    return std::make_unique<CGALNefGeometry> ();
   }
 
   try {
-    auto nef = std::make_shared<CGAL_Nef_polyhedron3>();
+    auto nef = std::make_shared<CGAL_Nef_polyhedron3> ();
     f >> *nef;
-    return std::make_unique<CGALNefGeometry>(nef);
-  } catch (const CGAL::Failure_exception& e) {
-    LOG(message_group::Warning, "Failure trying to import '%1$s', import() at line %2$d", filename, loc.firstLine());
-    LOG(e.what());
-    return std::make_unique<CGALNefGeometry>();
+    return std::make_unique<CGALNefGeometry> (nef);
+  } catch (const CGAL::Failure_exception &e) {
+    LOG (message_group::Warning, "Failure trying to import '%1$s', import() at line %2$d", filename, loc.firstLine ());
+    LOG (e.what ());
+    return std::make_unique<CGALNefGeometry> ();
   }
 }
 
diff --git a/src/io/import_obj.cc b/src/io/import_obj.cc
index 1e2ecb993..2a8e30381 100644
--- a/src/io/import_obj.cc
+++ b/src/io/import_obj.cc
@@ -18,83 +18,84 @@
 #include "geometry/PolySetBuilder.h"
 #include "utils/printutils.h"
 
-std::unique_ptr<PolySet> import_obj(const std::string& filename, const Location& loc) {
+std::unique_ptr<PolySet> import_obj (const std::string &filename, const Location &loc) {
   PolySetBuilder builder;
 
-  std::ifstream f(filename.c_str(), std::ios::in | std::ios::binary);
-  if (!f.good()) {
-    LOG(message_group::Warning,
-        "Can't open import file '%1$s', import() at line %2$d",
-        filename, loc.firstLine());
-    return PolySet::createEmpty();
+  std::ifstream f (filename.c_str (), std::ios::in | std::ios::binary);
+  if (!f.good ()) {
+    LOG (message_group::Warning,
+         "Can't open import file '%1$s', import() at line %2$d",
+         filename, loc.firstLine ());
+    return PolySet::createEmpty ();
   }
-  const boost::regex ex_comment(R"(^\s*#)");
-  const boost::regex ex_v(R"(^\s*v\s+([^\s]+)\s+([^\s]+)\s+([^\s]+)\s*$)");
-  const boost::regex ex_f(R"(^\s*f\s+(.*)$)");
-  const boost::regex ex_vt(R"(^\s*vt)");
-  const boost::regex ex_vn(R"(^\s*vn)");
-  const boost::regex ex_mtllib(R"(^\s*mtllib)");
-  const boost::regex ex_usemtl(R"(^\s*usemtl)");
-  const boost::regex ex_o(R"(^\s*o)");
-  const boost::regex ex_s(R"(^\s*s)");
-  const boost::regex ex_g(R"(^\s*g)");
+  const boost::regex ex_comment (R"(^\s*#)");
+  const boost::regex ex_v (R"(^\s*v\s+([^\s]+)\s+([^\s]+)\s+([^\s]+)\s*$)");
+  const boost::regex ex_f (R"(^\s*f\s+(.*)$)");
+  const boost::regex ex_vt (R"(^\s*vt)");
+  const boost::regex ex_vn (R"(^\s*vn)");
+  const boost::regex ex_mtllib (R"(^\s*mtllib)");
+  const boost::regex ex_usemtl (R"(^\s*usemtl)");
+  const boost::regex ex_o (R"(^\s*o)");
+  const boost::regex ex_s (R"(^\s*s)");
+  const boost::regex ex_g (R"(^\s*g)");
   int lineno = 1;
   std::string line;
 
-  auto AsciiError = [&](const auto& errstr){
-      LOG(message_group::Error, loc, "",
-          "OBJ File line %1$s, %2$s line '%3$s' importing file '%4$s'",
-          lineno, errstr, line, filename);
-    };
+  auto AsciiError = [&] (const auto &errstr) {
+    LOG (message_group::Error, loc, "",
+         "OBJ File line %1$s, %2$s line '%3$s' importing file '%4$s'",
+         lineno, errstr, line, filename);
+  };
   std::vector<int> vertex_map;
 
-  while (!f.eof()) {
+  while (!f.eof ()) {
     lineno++;
-    std::getline(f, line);
-    boost::trim(line);
+    std::getline (f, line);
+    boost::trim (line);
 
     boost::smatch results;
-    if (line.length() == 0 || boost::regex_search(line, ex_comment)) {
+    if (line.length () == 0 || boost::regex_search (line, ex_comment)) {
       continue;
-    } else if (boost::regex_search(line, results, ex_v) && results.size() >= 4) {
+    } else if (boost::regex_search (line, results, ex_v) && results.size () >= 4) {
       try {
         Vector3d v;
         for (int i = 0; i < 3; i++) {
-          v[i] = boost::lexical_cast<double>(results[i + 1]);
+          v[i] = boost::lexical_cast<double> (results[i + 1]);
         }
-        vertex_map.push_back(builder.vertexIndex(v));
-      } catch (const boost::bad_lexical_cast& blc) {
-        AsciiError("can't parse vertex");
-        return PolySet::createEmpty();
+        vertex_map.push_back (builder.vertexIndex (v));
+      } catch (const boost::bad_lexical_cast &blc) {
+        AsciiError ("can't parse vertex");
+        return PolySet::createEmpty ();
       }
-    } else if (boost::regex_search(line, results, ex_f) && results.size() >= 2) {
+    } else if (boost::regex_search (line, results, ex_f) && results.size () >= 2) {
       std::vector<std::string> words;
-      boost::split(words, results[1], boost::is_any_of(" \t"));
-      builder.beginPolygon(words.size());
-      for (const std::string& word : words) {
+      boost::split (words, results[1], boost::is_any_of (" \t"));
+      builder.beginPolygon (words.size ());
+      for (const std::string &word : words) {
         std::vector<std::string> wordindex;
-        boost::split(wordindex, word, boost::is_any_of("/"));
-        if (wordindex.size() < 1)LOG(message_group::Warning, "Invalid Face index in File %1$s in Line %2$d", filename, lineno);
+        boost::split (wordindex, word, boost::is_any_of ("/"));
+        if (wordindex.size () < 1)
+          LOG (message_group::Warning, "Invalid Face index in File %1$s in Line %2$d", filename, lineno);
         else {
-          const size_t ind = boost::lexical_cast<int>(wordindex[0]);
-          if (ind >= 1 && ind <= vertex_map.size()) {
-            builder.addVertex(vertex_map[ind - 1]);
+          const size_t ind = boost::lexical_cast<int> (wordindex[0]);
+          if (ind >= 1 && ind <= vertex_map.size ()) {
+            builder.addVertex (vertex_map[ind - 1]);
           } else {
-            LOG(message_group::Warning, "Index %1$d out of range in Line %2$d", filename, lineno);
+            LOG (message_group::Warning, "Index %1$d out of range in Line %2$d", filename, lineno);
           }
         }
       }
 
-    } else if (boost::regex_search(line, results, ex_vt)) { // ignore texture coords
-    } else if (boost::regex_search(line, results, ex_vn)) { // ignore normal coords
-    } else if (boost::regex_search(line, results, ex_mtllib)) { // ignore material lib
-    } else if (boost::regex_search(line, results, ex_usemtl)) { // ignore usemtl
-    } else if (boost::regex_search(line, results, ex_o)) { // ignore object name
-    } else if (boost::regex_search(line, results, ex_s)) { // ignore smooting
-    } else if (boost::regex_search(line, results, ex_g)) { // ignore group name
+    } else if (boost::regex_search (line, results, ex_vt)) { // ignore texture coords
+    } else if (boost::regex_search (line, results, ex_vn)) { // ignore normal coords
+    } else if (boost::regex_search (line, results, ex_mtllib)) { // ignore material lib
+    } else if (boost::regex_search (line, results, ex_usemtl)) { // ignore usemtl
+    } else if (boost::regex_search (line, results, ex_o)) { // ignore object name
+    } else if (boost::regex_search (line, results, ex_s)) { // ignore smooting
+    } else if (boost::regex_search (line, results, ex_g)) { // ignore group name
     } else {
-      LOG(message_group::Warning, "Unrecognized Line  %1$s in line Line %2$d", line, lineno);
+      LOG (message_group::Warning, "Unrecognized Line  %1$s in line Line %2$d", line, lineno);
     }
   }
-  return builder.build();
+  return builder.build ();
 }
diff --git a/src/io/import_off.cc b/src/io/import_off.cc
index d57435c14..7fe7ec15e 100644
--- a/src/io/import_off.cc
+++ b/src/io/import_off.cc
@@ -26,78 +26,76 @@
 // References:
 // http://www.geomview.org/docs/html/OFF.html
 
-std::unique_ptr<PolySet> import_off(const std::string& filename, const Location& loc)
-{
-  const boost::regex ex_magic(R"(^(ST)?(C)?(N)?(4)?(n)?OFF( BINARY)? *)");
+std::unique_ptr<PolySet> import_off (const std::string &filename, const Location &loc) {
+  const boost::regex ex_magic (R"(^(ST)?(C)?(N)?(4)?(n)?OFF( BINARY)? *)");
   // XXX: are ST C N always in order?
-  const boost::regex ex_cr(R"(\r$)");
-  const boost::regex ex_comment(R"(\s*#.*$)");
+  const boost::regex ex_cr (R"(\r$)");
+  const boost::regex ex_comment (R"(\s*#.*$)");
   boost::smatch results;
 
-  std::ifstream f(filename.c_str(), std::ios::in | std::ios::binary);
+  std::ifstream f (filename.c_str (), std::ios::in | std::ios::binary);
 
   int lineno = 0;
   std::string line;
 
-  auto AsciiError = [&](const auto& errstr){
-      LOG(message_group::Error, loc, "",
-          "OFF File line %1$s, %2$s line '%3$s' importing file '%4$s'",
-          lineno, errstr, line, filename);
-    };
-
-  auto getline_clean = [&](const auto& errstr){
-      do {
-        lineno++;
-        std::getline(f, line);
-        if (line.empty() && f.eof()) {
-          AsciiError(errstr);
-          return false;
-        }
-        // strip DOS line endings
-        if (boost::regex_search(line, results, ex_cr)) {
-          line = line.erase(results.position(), results[0].length());
-        }
-        // strip comments
-        if (boost::regex_search(line, results, ex_comment)) {
-          line = line.erase(results.position(), results[0].length());
-        }
-        boost::trim(line);
-      } while (line.empty());
+  auto AsciiError = [&] (const auto &errstr) {
+    LOG (message_group::Error, loc, "",
+         "OFF File line %1$s, %2$s line '%3$s' importing file '%4$s'",
+         lineno, errstr, line, filename);
+  };
+
+  auto getline_clean = [&] (const auto &errstr) {
+    do {
+      lineno++;
+      std::getline (f, line);
+      if (line.empty () && f.eof ()) {
+        AsciiError (errstr);
+        return false;
+      }
+      // strip DOS line endings
+      if (boost::regex_search (line, results, ex_cr)) {
+        line = line.erase (results.position (), results[0].length ());
+      }
+      // strip comments
+      if (boost::regex_search (line, results, ex_comment)) {
+        line = line.erase (results.position (), results[0].length ());
+      }
+      boost::trim (line);
+    } while (line.empty ());
 
-      return true;
-    };
+    return true;
+  };
 
-  auto getcolor = [&](const auto& word){
-      int c;
-      if (boost::contains(word, ".")) {
-        float f;
+  auto getcolor = [&] (const auto &word) {
+    int c;
+    if (boost::contains (word, ".")) {
+      float f;
 #ifdef __cpp_lib_to_chars
-        auto result = std::from_chars(word.data(), word.data() + word.length(), f);
-        if (result.ec != std::errc{}) {
-          AsciiError("Parse error");
-          return 0;
-        }
+      auto result = std::from_chars (word.data (), word.data () + word.length (), f);
+      if (result.ec != std::errc{}) {
+        AsciiError ("Parse error");
+        return 0;
+      }
 #else
-        // fall back for pre C++17
-        std::istringstream istr(word);
-        istr.imbue(std::locale("C"));
-        istr >> f;
-        if (istr.peek() != EOF) {
-          AsciiError("Parse error");
-          return 0;
-        }
-#endif // ifdef __cpp_lib_to_chars
-        c = (int)(f * 255);
-      } else {
-        c = boost::lexical_cast<int>(word);
+      // fall back for pre C++17
+      std::istringstream istr (word);
+      istr.imbue (std::locale ("C"));
+      istr >> f;
+      if (istr.peek () != EOF) {
+        AsciiError ("Parse error");
+        return 0;
       }
-      return c;
-    };
-
+#endif // ifdef __cpp_lib_to_chars
+      c = (int)(f * 255);
+    } else {
+      c = boost::lexical_cast<int> (word);
+    }
+    return c;
+  };
 
-  if (!f.good()) {
-    AsciiError("File error");
-    return PolySet::createEmpty();
+  if (!f.good ()) {
+    AsciiError ("File error");
+    return PolySet::createEmpty ();
   }
 
   // defaults
@@ -108,62 +106,63 @@ std::unique_ptr<PolySet> import_off(const std::string& filename, const Location&
   bool is_binary = false;
   unsigned int dimension = 3;
 
-  if (line.empty() && !getline_clean("bad header: end of file")) {
-    return PolySet::createEmpty();
+  if (line.empty () && !getline_clean ("bad header: end of file")) {
+    return PolySet::createEmpty ();
   }
 
-  if (boost::regex_search(line, results, ex_magic) > 0) {
+  if (boost::regex_search (line, results, ex_magic) > 0) {
     // Remove the matched part, we might have numbers next.
-    line = line.erase(0, results[0].length());
+    line = line.erase (0, results[0].length ());
     has_normals = results[3].matched;
     has_color = results[2].matched;
     has_textures = results[1].matched;
     is_binary = results[6].matched;
-    if (results[4].matched)dimension = 4;
+    if (results[4].matched)
+      dimension = 4;
     has_ndim = results[5].matched;
   }
 
   // TODO: handle binary format
   if (is_binary) {
-    AsciiError("binary OFF format not supported");
-    return PolySet::createEmpty();
+    AsciiError ("binary OFF format not supported");
+    return PolySet::createEmpty ();
   }
 
   std::vector<std::string> words;
 
   if (has_ndim) {
-    if (line.empty() && !getline_clean("bad header: end of file")) {
-      return PolySet::createEmpty();
+    if (line.empty () && !getline_clean ("bad header: end of file")) {
+      return PolySet::createEmpty ();
     }
-    boost::split(words, line, boost::is_any_of(" \t"), boost::token_compress_on);
-    if (f.eof() || words.size() < 1) {
-      AsciiError("bad header: missing Ndim");
-      return PolySet::createEmpty();
+    boost::split (words, line, boost::is_any_of (" \t"), boost::token_compress_on);
+    if (f.eof () || words.size () < 1) {
+      AsciiError ("bad header: missing Ndim");
+      return PolySet::createEmpty ();
     }
-    line = line.erase(0, words[0].length() + ((words.size() > 1) ? 1 : 0));
+    line = line.erase (0, words[0].length () + ((words.size () > 1) ? 1 : 0));
     try {
-      dimension = boost::lexical_cast<unsigned int>(words[0]) + dimension - 3;
-    } catch (const boost::bad_lexical_cast& blc) {
-      AsciiError("bad header: bad data for Ndim");
-      return PolySet::createEmpty();
+      dimension = boost::lexical_cast<unsigned int> (words[0]) + dimension - 3;
+    } catch (const boost::bad_lexical_cast &blc) {
+      AsciiError ("bad header: bad data for Ndim");
+      return PolySet::createEmpty ();
     }
   }
 
-  PRINTDB("Header flags: N:%d C:%d ST:%d Ndim:%d B:%d", has_normals % has_color % has_textures % dimension % is_binary);
+  PRINTDB ("Header flags: N:%d C:%d ST:%d Ndim:%d B:%d", has_normals % has_color % has_textures % dimension % is_binary);
 
   if (dimension != 3) {
-    AsciiError((boost::format("unhandled vertex dimensions (%d)") % dimension).str().c_str());
-    return PolySet::createEmpty();
+    AsciiError ((boost::format ("unhandled vertex dimensions (%d)") % dimension).str ().c_str ());
+    return PolySet::createEmpty ();
   }
 
-  if (line.empty() && !getline_clean("bad header: end of file")) {
-    return PolySet::createEmpty();
+  if (line.empty () && !getline_clean ("bad header: end of file")) {
+    return PolySet::createEmpty ();
   }
 
-  boost::split(words, line, boost::is_any_of(" \t"), boost::token_compress_on);
-  if (f.eof() || words.size() < 3) {
-    AsciiError("bad header: missing data");
-    return PolySet::createEmpty();
+  boost::split (words, line, boost::is_any_of (" \t"), boost::token_compress_on);
+  if (f.eof () || words.size () < 3) {
+    AsciiError ("bad header: missing data");
+    return PolySet::createEmpty ();
   }
 
   unsigned long vertices_count;
@@ -172,42 +171,42 @@ std::unique_ptr<PolySet> import_off(const std::string& filename, const Location&
   unsigned long vertex = 0;
   unsigned long face = 0;
   try {
-    vertices_count = boost::lexical_cast<unsigned long>(words[0]);
-    faces_count = boost::lexical_cast<unsigned long>(words[1]);
-    edges_count = boost::lexical_cast<unsigned long>(words[2]);
+    vertices_count = boost::lexical_cast<unsigned long> (words[0]);
+    faces_count = boost::lexical_cast<unsigned long> (words[1]);
+    edges_count = boost::lexical_cast<unsigned long> (words[2]);
     (void)edges_count; // ignored
-  } catch (const boost::bad_lexical_cast& blc) {
-    AsciiError("bad header: bad data");
-    return PolySet::createEmpty();
+  } catch (const boost::bad_lexical_cast &blc) {
+    AsciiError ("bad header: bad data");
+    return PolySet::createEmpty ();
   }
 
-  if (f.eof() || vertices_count < 1 || faces_count < 1) {
-    AsciiError("bad header: not enough data");
-    return PolySet::createEmpty();
+  if (f.eof () || vertices_count < 1 || faces_count < 1) {
+    AsciiError ("bad header: not enough data");
+    return PolySet::createEmpty ();
   }
 
-  PRINTDB("%d vertices, %d faces, %d edges.", vertices_count % faces_count % edges_count);
+  PRINTDB ("%d vertices, %d faces, %d edges.", vertices_count % faces_count % edges_count);
 
-  auto ps = PolySet::createEmpty();
-  ps->vertices.reserve(vertices_count);
-  ps->indices.reserve(faces_count);
+  auto ps = PolySet::createEmpty ();
+  ps->vertices.reserve (vertices_count);
+  ps->indices.reserve (faces_count);
 
-  while ((!f.eof()) && (vertex++ < vertices_count)) {
-    if (!getline_clean("reading vertices: end of file")) {
-      return PolySet::createEmpty();
+  while ((!f.eof ()) && (vertex++ < vertices_count)) {
+    if (!getline_clean ("reading vertices: end of file")) {
+      return PolySet::createEmpty ();
     }
 
-    boost::split(words, line, boost::is_any_of(" \t"), boost::token_compress_on);
-    if (words.size() < 3) {
-      AsciiError("can't parse vertex: not enough data");
-      return PolySet::createEmpty();
+    boost::split (words, line, boost::is_any_of (" \t"), boost::token_compress_on);
+    if (words.size () < 3) {
+      AsciiError ("can't parse vertex: not enough data");
+      return PolySet::createEmpty ();
     }
 
     try {
       Vector3d v = {0, 0, 0};
       int i;
       for (i = 0; i < dimension; i++) {
-        v[i] = boost::lexical_cast<double>(words[i]);
+        v[i] = boost::lexical_cast<double> (words[i]);
       }
       //PRINTDB("Vertex[%ld] = { %f, %f, %f }", vertex % v[0] % v[1] % v[2]);
       if (has_normals) {
@@ -221,68 +220,69 @@ std::unique_ptr<PolySet> import_off(const std::string& filename, const Location&
       if (has_textures) {
         // TODO words[i++]
       }
-      ps->vertices.push_back(v);
-    } catch (const boost::bad_lexical_cast& blc) {
-      AsciiError("can't parse vertex: bad data");
-      return PolySet::createEmpty();
+      ps->vertices.push_back (v);
+    } catch (const boost::bad_lexical_cast &blc) {
+      AsciiError ("can't parse vertex: bad data");
+      return PolySet::createEmpty ();
     }
   }
 
   auto logged_color_warning = false;
 
-  while (!f.eof() && (face++ < faces_count)) {
-    if (!getline_clean("reading faces: end of file")) {
-      return PolySet::createEmpty();
+  while (!f.eof () && (face++ < faces_count)) {
+    if (!getline_clean ("reading faces: end of file")) {
+      return PolySet::createEmpty ();
     }
 
-    boost::split(words, line, boost::is_any_of(" \t"), boost::token_compress_on);
-    if (words.size() < 1) {
-      AsciiError("can't parse face: not enough data");
-      return PolySet::createEmpty();
+    boost::split (words, line, boost::is_any_of (" \t"), boost::token_compress_on);
+    if (words.size () < 1) {
+      AsciiError ("can't parse face: not enough data");
+      return PolySet::createEmpty ();
     }
 
     std::map<Color4f, int32_t> color_indices;
     try {
-      const auto face_size = boost::lexical_cast<unsigned long>(words[0]);
+      const auto face_size = boost::lexical_cast<unsigned long> (words[0]);
       unsigned long i;
-      if (words.size() - 1 < face_size) {
-        AsciiError("can't parse face: missing indices");
-        return PolySet::createEmpty();
+      if (words.size () - 1 < face_size) {
+        AsciiError ("can't parse face: missing indices");
+        return PolySet::createEmpty ();
       }
-      const size_t face_idx = ps->indices.size();
-      ps->indices.emplace_back().reserve(face_size);
+      const size_t face_idx = ps->indices.size ();
+      ps->indices.emplace_back ().reserve (face_size);
       //PRINTDB("Index[%d] [%d] = { ", face % n);
       for (i = 0; i < face_size; i++) {
-        int ind = boost::lexical_cast<int>(words[i + 1]);
+        int ind = boost::lexical_cast<int> (words[i + 1]);
         //PRINTDB("%d, ", ind);
         if (ind >= 0 && ind < vertices_count) {
-          ps->indices.back().push_back(ind);
+          ps->indices.back ().push_back (ind);
         } else {
-          AsciiError((boost::format("ignored bad face vertex index: %d") % ind).str().c_str());
+          AsciiError ((boost::format ("ignored bad face vertex index: %d") % ind).str ().c_str ());
         }
       }
       //PRINTD("}");
-      if (words.size() >= face_size + 4) {
+      if (words.size () >= face_size + 4) {
         i = face_size + 1;
         // handle optional color info (r g b [a])
-        const int r = getcolor(words[i++]);
-        const int g = getcolor(words[i++]);
-        const int b = getcolor(words[i++]);
-        const int a = i < words.size() ? getcolor(words[i++]) : 255;
-        const Color4f color(r, g, b, a);
-
-        auto iter_pair = color_indices.insert_or_assign(color, ps->colors.size());
-        if (iter_pair.second) ps->colors.push_back(color); // inserted
-        ps->color_indices.resize(face_idx, -1);
-        ps->color_indices.push_back(iter_pair.first->second);
+        const int r = getcolor (words[i++]);
+        const int g = getcolor (words[i++]);
+        const int b = getcolor (words[i++]);
+        const int a = i < words.size () ? getcolor (words[i++]) : 255;
+        const Color4f color (r, g, b, a);
+
+        auto iter_pair = color_indices.insert_or_assign (color, ps->colors.size ());
+        if (iter_pair.second)
+          ps->colors.push_back (color); // inserted
+        ps->color_indices.resize (face_idx, -1);
+        ps->color_indices.push_back (iter_pair.first->second);
       }
-    } catch (const boost::bad_lexical_cast& blc) {
-      AsciiError("can't parse face: bad data");
-      return PolySet::createEmpty();
+    } catch (const boost::bad_lexical_cast &blc) {
+      AsciiError ("can't parse face: bad data");
+      return PolySet::createEmpty ();
     }
   }
-  if (!ps->color_indices.empty()) {
-    ps->color_indices.resize(ps->indices.size(), -1);
+  if (!ps->color_indices.empty ()) {
+    ps->color_indices.resize (ps->indices.size (), -1);
   }
 
   //PRINTDB("PS: %ld vertices, %ld indices", ps->vertices.size() % ps->indices.size());
diff --git a/src/io/import_stl.cc b/src/io/import_stl.cc
index 8ef70aea0..64f33651d 100644
--- a/src/io/import_stl.cc
+++ b/src/io/import_stl.cc
@@ -26,8 +26,8 @@ inline constexpr size_t STL_FACET_NUMBYTES = 4ul * 3ul * 4ul + 2ul;
 // as there is no 'float32_t' standard, we assume the systems 'float'
 // is a 'binary32' aka 'single' standard IEEE 32-bit floating point type
 union stl_facet {
-  static_assert(sizeof(unsigned char) == sizeof(uint8_t), "existence check");
-  unsigned char data8[ STL_FACET_NUMBYTES ];
+  static_assert (sizeof (unsigned char) == sizeof (uint8_t), "existence check");
+  unsigned char data8[STL_FACET_NUMBYTES];
   struct facet_data {
     float i, j, k;
     float x1, y1, z1;
@@ -37,170 +37,172 @@ union stl_facet {
   } data;
 };
 
-static_assert(offsetof(stl_facet::facet_data, attribute_byte_count) == 4ul * 3ul * 4ul,
-              "Invalid padding in stl_facet");
+static_assert (offsetof (stl_facet::facet_data, attribute_byte_count) == 4ul * 3ul * 4ul,
+               "Invalid padding in stl_facet");
 
 #if BOOST_ENDIAN_BIG_BYTE
-static void uint32_byte_swap(unsigned char *p) {
-# if (__GNUC__ >= 4 && __GNUC_MINOR__ >= 3) || defined(__clang__)
-  uint32_t& x = *reinterpret_cast<uint32_t *>(p);
-  x = __builtin_bswap32(x);
-# elif defined(_MSC_VER)
-  uint32_t& x = *reinterpret_cast<uint32_t *>(p);
-  x = _byteswap_ulong(x);
-# else
-  std::swap(*p, *(p + 3));
-  std::swap(*(p + 1), *(p + 2));
-# endif
+static void uint32_byte_swap (unsigned char *p) {
+#if (__GNUC__ >= 4 && __GNUC_MINOR__ >= 3) || defined(__clang__)
+  uint32_t &x = *reinterpret_cast<uint32_t *> (p);
+  x = __builtin_bswap32 (x);
+#elif defined(_MSC_VER)
+  uint32_t &x = *reinterpret_cast<uint32_t *> (p);
+  x = _byteswap_ulong (x);
+#else
+  std::swap (*p, *(p + 3));
+  std::swap (*(p + 1), *(p + 2));
+#endif
 }
 
-static void uint32_byte_swap(uint32_t& x) {
-  uint32_byte_swap(reinterpret_cast<unsigned char *>(&x));
+static void uint32_byte_swap (uint32_t &x) {
+  uint32_byte_swap (reinterpret_cast<unsigned char *> (&x));
 }
 #endif // if BOOST_ENDIAN_BIG_BYTE
 
-static void read_stl_facet(std::ifstream& f, stl_facet& facet) {
-  f.read((char *)facet.data8, STL_FACET_NUMBYTES);
-  if (static_cast<size_t>(f.gcount()) < STL_FACET_NUMBYTES) {
-    throw std::ios_base::failure("facet data truncated");
+static void read_stl_facet (std::ifstream &f, stl_facet &facet) {
+  f.read ((char *)facet.data8, STL_FACET_NUMBYTES);
+  if (static_cast<size_t> (f.gcount ()) < STL_FACET_NUMBYTES) {
+    throw std::ios_base::failure ("facet data truncated");
   }
 #if BOOST_ENDIAN_BIG_BYTE
   for (int i = 0; i < 12; ++i) {
-    uint32_byte_swap(facet.data8 + i * 4);
+    uint32_byte_swap (facet.data8 + i * 4);
   }
   // we ignore attribute byte count
 #endif
 }
 
-std::unique_ptr<PolySet> import_stl(const std::string& filename, const Location& loc) {
+std::unique_ptr<PolySet> import_stl (const std::string &filename, const Location &loc) {
   // Open file and position at the end
-  std::ifstream f(filename.c_str(), std::ios::in | std::ios::binary | std::ios::ate);
-  if (!f.good()) {
-    LOG(message_group::Warning,
-        "Can't open import file '%1$s', import() at line %2$d",
-        filename, loc.firstLine());
-    return PolySet::createEmpty();
+  std::ifstream f (filename.c_str (), std::ios::in | std::ios::binary | std::ios::ate);
+  if (!f.good ()) {
+    LOG (message_group::Warning,
+         "Can't open import file '%1$s', import() at line %2$d",
+         filename, loc.firstLine ());
+    return PolySet::createEmpty ();
   }
 
   uint32_t facenum = 0;
-  const boost::regex ex_sfe(R"(^\s*solid|^\s*facet|^\s*endfacet)");
-  const boost::regex ex_outer("^\\s*outer loop$");
-  const boost::regex ex_loopend("^\\s*endloop$");
-  const boost::regex ex_vertex("^\\s*vertex");
-  const boost::regex ex_vertices(
+  const boost::regex ex_sfe (R"(^\s*solid|^\s*facet|^\s*endfacet)");
+  const boost::regex ex_outer ("^\\s*outer loop$");
+  const boost::regex ex_loopend ("^\\s*endloop$");
+  const boost::regex ex_vertex ("^\\s*vertex");
+  const boost::regex ex_vertices (
     R"(^\s*vertex\s+([^\s]+)\s+([^\s]+)\s+([^\s]+)\s*$)");
-  const boost::regex ex_endsolid("^\\s*endsolid");
+  const boost::regex ex_endsolid ("^\\s*endsolid");
 
   bool binary = false;
-  const std::streampos file_size = f.tellg();
-  f.seekg(80);
-  if (f.good() && !f.eof()) {
-    f.read((char *)&facenum, sizeof(uint32_t));
+  const std::streampos file_size = f.tellg ();
+  f.seekg (80);
+  if (f.good () && !f.eof ()) {
+    f.read ((char *)&facenum, sizeof (uint32_t));
 #if BOOST_ENDIAN_BIG_BYTE
-    uint32_byte_swap(facenum);
+    uint32_byte_swap (facenum);
 #endif
-    if (file_size == static_cast<std::streamoff>(80ul + 4ul + 50ul * facenum)) {
+    if (file_size == static_cast<std::streamoff> (80ul + 4ul + 50ul * facenum)) {
       binary = true;
     }
   }
-  if (!binary)facenum = 0;
-  PolySetBuilder builder(0, facenum);
-  f.seekg(0);
+  if (!binary)
+    facenum = 0;
+  PolySetBuilder builder (0, facenum);
+  f.seekg (0);
 
   char data[5];
-  f.read(data, 5);
-  if (!binary && !f.eof() && f.good() && !memcmp(data, "solid", 5)) {
+  f.read (data, 5);
+  if (!binary && !f.eof () && f.good () && !memcmp (data, "solid", 5)) {
     int i = 0;
     int lineno = 1;
     std::array<std::array<double, 3>, 3> vdata;
     std::string line;
 
-    auto AsciiError = [&](const auto& errstr){
-        LOG(message_group::Error, loc, "",
-            "STL line %1$s, %2$s line '%3$s' importing file '%4$s'",
-            lineno, errstr, line, filename);
-      };
+    auto AsciiError = [&] (const auto &errstr) {
+      LOG (message_group::Error, loc, "",
+           "STL line %1$s, %2$s line '%3$s' importing file '%4$s'",
+           lineno, errstr, line, filename);
+    };
 
-    std::getline(f, line);
+    std::getline (f, line);
     bool reached_end = false;
-    while (!f.eof()) {
+    while (!f.eof ()) {
       lineno++;
-      std::getline(f, line);
-      boost::trim(line);
+      std::getline (f, line);
+      boost::trim (line);
       boost::smatch results;
 
-      if (line.length() == 0 || boost::regex_search(line, ex_sfe)) {
+      if (line.length () == 0 || boost::regex_search (line, ex_sfe)) {
         continue;
-      } else if (boost::regex_search(line, ex_outer)) {
+      } else if (boost::regex_search (line, ex_outer)) {
         i = 0;
         continue;
-      } else if (boost::regex_search(line, ex_loopend)) {
+      } else if (boost::regex_search (line, ex_loopend)) {
         if (i < 3) {
-          AsciiError("missing vertex");
+          AsciiError ("missing vertex");
         }
         continue;
-      } else if (boost::regex_search(line, ex_endsolid)) {
+      } else if (boost::regex_search (line, ex_endsolid)) {
         reached_end = true;
         break;
       } else if (i >= 3) {
-        AsciiError("extra vertex");
-        return PolySet::createEmpty();
-      } else if (boost::regex_search(line, results, ex_vertices) &&
-                 results.size() >= 4) {
+        AsciiError ("extra vertex");
+        return PolySet::createEmpty ();
+      } else if (boost::regex_search (line, results, ex_vertices) &&
+                 results.size () >= 4) {
         try {
           for (int v = 0; v < 3; ++v) {
-            vdata.at(i).at(v) = boost::lexical_cast<double>(results[v + 1]);
+            vdata.at (i).at (v) = boost::lexical_cast<double> (results[v + 1]);
           }
           if (++i == 3) {
-            builder.beginPolygon(3);
+            builder.beginPolygon (3);
             for (int j = 0; j < 3; j++) {
-              builder.addVertex(Vector3d(vdata[j][0], vdata[j][1], vdata[j][2]));
+              builder.addVertex (Vector3d (vdata[j][0], vdata[j][1], vdata[j][2]));
             }
           }
-        } catch (const boost::bad_lexical_cast& blc) {
-          AsciiError("can't parse vertex");
-          return PolySet::createEmpty();
+        } catch (const boost::bad_lexical_cast &blc) {
+          AsciiError ("can't parse vertex");
+          return PolySet::createEmpty ();
         }
       }
     }
     if (!reached_end) {
-      AsciiError("file incomplete");
+      AsciiError ("file incomplete");
     }
-  } else if (binary && !f.eof() && f.good()) {
+  } else if (binary && !f.eof () && f.good ()) {
     try {
-      f.ignore(80 - 5 + 4);
-      while (!f.eof() ) {
+      f.ignore (80 - 5 + 4);
+      while (!f.eof ()) {
         stl_facet facet;
         try {
-          read_stl_facet(f, facet);
-        } catch (const std::ios_base::failure& ex) {
-          if (f.eof()) break;
+          read_stl_facet (f, facet);
+        } catch (const std::ios_base::failure &ex) {
+          if (f.eof ())
+            break;
           throw;
         }
-        builder.appendPolygon({
-          Vector3d(facet.data.x1, facet.data.y1, facet.data.z1),
-          Vector3d(facet.data.x2, facet.data.y2, facet.data.z2),
-          Vector3d(facet.data.x3, facet.data.y3, facet.data.z3)
-        });
+        builder.appendPolygon ({Vector3d (facet.data.x1, facet.data.y1, facet.data.z1),
+                                Vector3d (facet.data.x2, facet.data.y2, facet.data.z2),
+                                Vector3d (facet.data.x3, facet.data.y3, facet.data.z3)});
       }
-    } catch (const std::ios_base::failure& ex) {
+    } catch (const std::ios_base::failure &ex) {
       int64_t offset = -1;
-      try { offset = f.tellg(); } catch (...) {}
+      try {
+        offset = f.tellg ();
+      } catch (...) {}
       if (offset < 0) {
-        LOG(message_group::Error, loc, "",
-            "Binary STL '%1$s' error: %3$s",
-            filename, ex.what());
+        LOG (message_group::Error, loc, "",
+             "Binary STL '%1$s' error: %3$s",
+             filename, ex.what ());
       } else {
-        LOG(message_group::Error, loc, "",
-            "Binary STL '%1$s' error at byte %2$s: %3$s",
-            filename, offset, ex.what());
+        LOG (message_group::Error, loc, "",
+             "Binary STL '%1$s' error at byte %2$s: %3$s",
+             filename, offset, ex.what ());
       }
-      return PolySet::createEmpty();
+      return PolySet::createEmpty ();
     }
   } else {
-    LOG(message_group::Error, loc, "",
-        "STL format not recognized in '%1$s'.", filename);
-    return PolySet::createEmpty();
+    LOG (message_group::Error, loc, "",
+         "STL format not recognized in '%1$s'.", filename);
+    return PolySet::createEmpty ();
   }
-  return builder.build();
+  return builder.build ();
 }
diff --git a/src/io/import_svg.cc b/src/io/import_svg.cc
index 8862db569..09188a628 100644
--- a/src/io/import_svg.cc
+++ b/src/io/import_svg.cc
@@ -48,8 +48,7 @@ namespace {
 
 constexpr double INCH_TO_MM = 25.4;
 
-double to_mm(const libsvg::length_t& length, const double viewbox, const bool viewbox_valid, const double dpi)
-{
+double to_mm (const libsvg::length_t &length, const double viewbox, const bool viewbox_valid, const double dpi) {
   switch (length.unit) {
   case libsvg::unit_t::NONE:
     return INCH_TO_MM * length.number / dpi;
@@ -77,8 +76,7 @@ double to_mm(const libsvg::length_t& length, const double viewbox, const bool vi
   }
 }
 
-double calc_alignment(const libsvg::align_t alignment, double page_mm, double scale, double viewbox)
-{
+double calc_alignment (const libsvg::align_t alignment, double page_mm, double scale, double viewbox) {
   switch (alignment) {
   case libsvg::align_t::MID:
     return page_mm / 2.0 - scale * viewbox / 2.0;
@@ -91,51 +89,50 @@ double calc_alignment(const libsvg::align_t alignment, double page_mm, double sc
 
 } // namespace
 
-
-std::unique_ptr<Polygon2d> import_svg(double fn, double fs, double fa,
-                                      const std::string& filename,
-                                      const boost::optional<std::string>& id, const boost::optional<std::string>& layer,
-                                      const double dpi, const bool center, const Location& loc)
-{
+std::unique_ptr<Polygon2d> import_svg (double fn, double fs, double fa,
+                                       const std::string &filename,
+                                       const boost::optional<std::string> &id, const boost::optional<std::string> &layer,
+                                       const double dpi, const bool center, const Location &loc) {
   try {
-    fnContext scadContext(fn, fs, fa);
+    fnContext scadContext (fn, fs, fa);
     if (id) {
-      scadContext.selector = [&scadContext, id, layer](const libsvg::shape *s) {
-          bool layer_match = true;
-          if (layer) {
-            layer_match = false;
-            for (const libsvg::shape *shape = s; shape->get_parent() != nullptr; shape = shape->get_parent()) {
-              if (shape->has_layer() && shape->get_layer() == layer.get()) {
-                layer_match = true;
-                break;
-              }
+      scadContext.selector = [&scadContext, id, layer] (const libsvg::shape *s) {
+        bool layer_match = true;
+        if (layer) {
+          layer_match = false;
+          for (const libsvg::shape *shape = s; shape->get_parent () != nullptr; shape = shape->get_parent ()) {
+            if (shape->has_layer () && shape->get_layer () == layer.get ()) {
+              layer_match = true;
+              break;
             }
           }
-          return scadContext.match(layer_match && s->has_id() && s->get_id() == id.get());
-        };
+        }
+        return scadContext.match (layer_match && s->has_id () && s->get_id () == id.get ());
+      };
     } else if (layer) {
-      scadContext.selector = [&scadContext, layer](const libsvg::shape *s) {
-          return scadContext.match(s->has_layer() && s->get_layer() == layer.get());
-        };
+      scadContext.selector = [&scadContext, layer] (const libsvg::shape *s) {
+        return scadContext.match (s->has_layer () && s->get_layer () == layer.get ());
+      };
     } else {
       // no selection means selecting the root
-      scadContext.selector = [&scadContext](const libsvg::shape *s) {
-          return scadContext.match(s->get_parent() == nullptr);
-        };
+      scadContext.selector = [&scadContext] (const libsvg::shape *s) {
+        return scadContext.match (s->get_parent () == nullptr);
+      };
     }
 
     std::string match_args;
     if (id) {
-      match_args += "id = \"" + id.get() + "\"";
+      match_args += "id = \"" + id.get () + "\"";
     }
     if (layer) {
-      if (id) match_args += ", ";
-      match_args += "layer = \"" + layer.get() + "\"";
+      if (id)
+        match_args += ", ";
+      match_args += "layer = \"" + layer.get () + "\"";
     }
 
-    const auto shapes = libsvg::libsvg_read_file(filename.c_str(), (void *) &scadContext);
-    if (!match_args.empty() && !scadContext.has_matches()) {
-      LOG(message_group::Warning, loc, "", "import() filter %2$s did not match anything", filename, match_args);
+    const auto shapes = libsvg::libsvg_read_file (filename.c_str (), (void *)&scadContext);
+    if (!match_args.empty () && !scadContext.has_matches ()) {
+      LOG (message_group::Warning, loc, "", "import() filter %2$s did not match anything", filename, match_args);
     }
 
     double width_mm = 0.0;
@@ -147,78 +144,79 @@ std::unique_ptr<Polygon2d> import_svg(double fn, double fs, double fa,
     Eigen::Vector2d align{0.0, 0.0};
     Eigen::Vector2d viewbox{0.0, 0.0};
 
-    for (const auto& shape_ptr : *shapes) {
-      const auto page = dynamic_cast<libsvg::svgpage *>(shape_ptr.get());
+    for (const auto &shape_ptr : *shapes) {
+      const auto page = dynamic_cast<libsvg::svgpage *> (shape_ptr.get ());
       if (page) {
-        const auto w = page->get_width();
-        const auto h = page->get_height();
-        const auto alignment = page->get_alignment();
+        const auto w = page->get_width ();
+        const auto h = page->get_height ();
+        const auto alignment = page->get_alignment ();
 
-        const bool viewbox_valid = page->get_viewbox().is_valid;
-        width_mm = to_mm(w, page->get_viewbox().width, viewbox_valid, dpi);
-        height_mm = to_mm(h, page->get_viewbox().height, viewbox_valid, dpi);
+        const bool viewbox_valid = page->get_viewbox ().is_valid;
+        width_mm = to_mm (w, page->get_viewbox ().width, viewbox_valid, dpi);
+        height_mm = to_mm (h, page->get_viewbox ().height, viewbox_valid, dpi);
 
         if (viewbox_valid) {
           const double px = w.unit == libsvg::unit_t::PERCENT ? w.number / 100.0 : 1.0;
           const double py = h.unit == libsvg::unit_t::PERCENT ? h.number / 100.0 : 1.0;
-          viewbox << px * page->get_viewbox().x, py *page->get_viewbox().y;
+          viewbox << px * page->get_viewbox ().x, py * page->get_viewbox ().y;
 
-          scale << width_mm / page->get_viewbox().width,
-            height_mm / page->get_viewbox().height;
+          scale << width_mm / page->get_viewbox ().width,
+            height_mm / page->get_viewbox ().height;
 
           if (alignment.x != libsvg::align_t::NONE) {
             double scaling;
             if (alignment.meet) {
               // preserve aspect ratio and fit into viewport, so
               // select the smaller of the 2 scale factors
-              scaling = scale.x() < scale.y() ? scale.x() : scale.y();
+              scaling = scale.x () < scale.y () ? scale.x () : scale.y ();
             } else {
               // preserve aspect ratio and fill viewport, so select
               // the bigger of the 2 scale factors
-              scaling = scale.x() > scale.y() ? scale.x() : scale.y();
+              scaling = scale.x () > scale.y () ? scale.x () : scale.y ();
             }
             scale = Eigen::Vector2d{scaling, scaling};
 
-            align << calc_alignment(alignment.x, width_mm, scale.x(), page->get_viewbox().width),
-              calc_alignment(alignment.y, height_mm, scale.y(), page->get_viewbox().height);
+            align << calc_alignment (alignment.x, width_mm, scale.x (), page->get_viewbox ().width),
+              calc_alignment (alignment.y, height_mm, scale.y (), page->get_viewbox ().height);
           }
         }
       }
 
-      if (!shape_ptr->is_excluded()) {
-        const auto& s = *shape_ptr;
-        for (const auto& p : s.get_path_list()) {
-          for (const auto& v : p) {
-            bbox.extend(Eigen::Vector2d{scale.x() * v.x(), scale.y() * v.y()});
+      if (!shape_ptr->is_excluded ()) {
+        const auto &s = *shape_ptr;
+        for (const auto &p : s.get_path_list ()) {
+          for (const auto &v : p) {
+            bbox.extend (Eigen::Vector2d{scale.x () * v.x (), scale.y () * v.y ()});
           }
         }
       }
     }
-    const double cx = center ? bbox.center().x() : -align.x();
-    const double cy = center ? bbox.center().y() : height_mm - align.y();
+    const double cx = center ? bbox.center ().x () : -align.x ();
+    const double cy = center ? bbox.center ().y () : height_mm - align.y ();
 
     std::vector<std::shared_ptr<const Polygon2d>> polygons;
-    for (const auto& shape_ptr : *shapes) {
-      if (!shape_ptr->is_excluded()) {
-        auto poly = std::make_shared<Polygon2d>();
-        const auto& s = *shape_ptr;
-        for (const auto& p : s.get_path_list()) {
+    for (const auto &shape_ptr : *shapes) {
+      if (!shape_ptr->is_excluded ()) {
+        auto poly = std::make_shared<Polygon2d> ();
+        const auto &s = *shape_ptr;
+        for (const auto &p : s.get_path_list ()) {
           Outline2d outline;
-          for (const auto& v : p) {
-            const double x = scale.x() * (-viewbox.x() + v.x()) - cx;
-            const double y = scale.y() * (-viewbox.y() - v.y()) + cy;
-            outline.vertices.emplace_back(x, y);
+          for (const auto &v : p) {
+            const double x = scale.x () * (-viewbox.x () + v.x ()) - cx;
+            const double y = scale.y () * (-viewbox.y () - v.y ()) + cy;
+            outline.vertices.emplace_back (x, y);
             outline.positive = true;
           }
-          poly->addOutline(outline);
+          poly->addOutline (outline);
         }
-        if (!poly->isEmpty()) polygons.push_back(poly);
+        if (!poly->isEmpty ())
+          polygons.push_back (poly);
       }
     }
-    libsvg_free(shapes);
-    return ClipperUtils::apply(polygons, Clipper2Lib::ClipType::Union);
-  } catch (const std::exception& e) {
-    LOG(message_group::Error, "%1$s, import() at line %2$d", e.what(), loc.firstLine());
-    return std::make_unique<Polygon2d>();
+    libsvg_free (shapes);
+    return ClipperUtils::apply (polygons, Clipper2Lib::ClipType::Union);
+  } catch (const std::exception &e) {
+    LOG (message_group::Error, "%1$s, import() at line %2$d", e.what (), loc.firstLine ());
+    return std::make_unique<Polygon2d> ();
   }
 }
diff --git a/src/io/lib3mf_utils.h b/src/io/lib3mf_utils.h
index 6dc93ada5..e5822f48e 100644
--- a/src/io/lib3mf_utils.h
+++ b/src/io/lib3mf_utils.h
@@ -2,4 +2,4 @@
 
 #include <string>
 
-std::string get_lib3mf_version();
+std::string get_lib3mf_version ();
diff --git a/src/libsvg/circle.cc b/src/libsvg/circle.cc
index 7627c77d9..fe41e0b4a 100644
--- a/src/libsvg/circle.cc
+++ b/src/libsvg/circle.cc
@@ -30,30 +30,27 @@
 
 namespace libsvg {
 
-const std::string circle::name("circle");
+const std::string circle::name ("circle");
 
-void
-circle::set_attrs(attr_map_t& attrs, void *context)
-{
-  shape::set_attrs(attrs, context);
-  this->x = parse_double(attrs["cx"]);
-  this->y = parse_double(attrs["cy"]);
-  this->r = parse_double(attrs["r"]);
+void circle::set_attrs (attr_map_t &attrs, void *context) {
+  shape::set_attrs (attrs, context);
+  this->x = parse_double (attrs["cx"]);
+  this->y = parse_double (attrs["cy"]);
+  this->r = parse_double (attrs["r"]);
 
   path_t path;
-  draw_ellipse(path, get_x(), get_y(), get_radius(), get_radius(), context);
-  path_list.push_back(path);
+  draw_ellipse (path, get_x (), get_y (), get_radius (), get_radius (), context);
+  path_list.push_back (path);
 }
 
 const std::string
-circle::dump() const
-{
+circle::dump () const {
   std::stringstream s;
-  s << get_name()
+  s << get_name ()
     << ": x = " << this->x
     << ": y = " << this->y
     << ": r = " << this->r;
-  return s.str();
+  return s.str ();
 }
 
 } // namespace libsvg
diff --git a/src/libsvg/circle.h b/src/libsvg/circle.h
index f553e51e8..470415ab8 100644
--- a/src/libsvg/circle.h
+++ b/src/libsvg/circle.h
@@ -36,17 +36,23 @@ protected:
   double r{0};
 
 public:
-  circle() = default;
+  circle () = default;
 
-  [[nodiscard]] double get_radius() const { return r; }
+  [[nodiscard]] double get_radius () const {
+    return r;
+  }
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
-  [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return circle::name; }
+  void set_attrs (attr_map_t &attrs, void *context) override;
+  [[nodiscard]] const std::string dump () const override;
+  [[nodiscard]] const std::string &get_name () const override {
+    return circle::name;
+  }
 
   static const std::string name;
 
-  [[nodiscard]] shape *clone() const override { return new circle(*this); }
+  [[nodiscard]] shape *clone () const override {
+    return new circle (*this);
+  }
 };
 
-}
+} // namespace libsvg
diff --git a/src/libsvg/data.cc b/src/libsvg/data.cc
index 98531218b..2d25688cf 100644
--- a/src/libsvg/data.cc
+++ b/src/libsvg/data.cc
@@ -29,22 +29,19 @@
 
 namespace libsvg {
 
-const std::string data::name("data");
+const std::string data::name ("data");
 
-void
-data::set_attrs(attr_map_t& attrs, void *context)
-{
-  shape::set_attrs(attrs, context);
+void data::set_attrs (attr_map_t &attrs, void *context) {
+  shape::set_attrs (attrs, context);
   this->text = attrs["text"];
 }
 
 const std::string
-data::dump() const
-{
+data::dump () const {
   std::stringstream s;
-  s << get_name()
+  s << get_name ()
     << ": text = '" << this->text << "'";
-  return s.str();
+  return s.str ();
 }
 
-}
+} // namespace libsvg
diff --git a/src/libsvg/data.h b/src/libsvg/data.h
index 7b395ce68..9ad88bafb 100644
--- a/src/libsvg/data.h
+++ b/src/libsvg/data.h
@@ -36,17 +36,23 @@ private:
   std::string text;
 
 public:
-  data() = default;
+  data () = default;
 
-  [[nodiscard]] const std::string& get_text() const { return text; }
+  [[nodiscard]] const std::string &get_text () const {
+    return text;
+  }
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
-  [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return data::name; }
+  void set_attrs (attr_map_t &attrs, void *context) override;
+  [[nodiscard]] const std::string dump () const override;
+  [[nodiscard]] const std::string &get_name () const override {
+    return data::name;
+  }
 
   static const std::string name;
 
-  [[nodiscard]] shape *clone() const override { return new data(*this); }
+  [[nodiscard]] shape *clone () const override {
+    return new data (*this);
+  }
 };
 
-}
+} // namespace libsvg
diff --git a/src/libsvg/ellipse.cc b/src/libsvg/ellipse.cc
index e799f125c..5a5fd674b 100644
--- a/src/libsvg/ellipse.cc
+++ b/src/libsvg/ellipse.cc
@@ -33,32 +33,29 @@
 
 namespace libsvg {
 
-const std::string ellipse::name("ellipse");
+const std::string ellipse::name ("ellipse");
 
-void
-ellipse::set_attrs(attr_map_t& attrs, void *context)
-{
-  shape::set_attrs(attrs, context);
-  this->x = parse_double(attrs["cx"]);
-  this->y = parse_double(attrs["cy"]);
-  this->rx = parse_double(attrs["rx"]);
-  this->ry = parse_double(attrs["ry"]);
+void ellipse::set_attrs (attr_map_t &attrs, void *context) {
+  shape::set_attrs (attrs, context);
+  this->x = parse_double (attrs["cx"]);
+  this->y = parse_double (attrs["cy"]);
+  this->rx = parse_double (attrs["rx"]);
+  this->ry = parse_double (attrs["ry"]);
 
   path_t path;
-  draw_ellipse(path, get_x(), get_y(), get_radius_x(), get_radius_y(), context);
-  path_list.push_back(path);
+  draw_ellipse (path, get_x (), get_y (), get_radius_x (), get_radius_y (), context);
+  path_list.push_back (path);
 }
 
 const std::string
-ellipse::dump() const
-{
+ellipse::dump () const {
   std::stringstream s;
-  s << get_name()
+  s << get_name ()
     << ": x = " << this->x
     << ": y = " << this->y
     << ": rx = " << this->rx
     << ": ry = " << this->ry;
-  return s.str();
+  return s.str ();
 }
 
 } // namespace libsvg
diff --git a/src/libsvg/ellipse.h b/src/libsvg/ellipse.h
index 0cadda926..3c7a91898 100644
--- a/src/libsvg/ellipse.h
+++ b/src/libsvg/ellipse.h
@@ -37,18 +37,26 @@ protected:
   double ry{0};
 
 public:
-  ellipse() = default;
+  ellipse () = default;
 
-  [[nodiscard]] double get_radius_x() const { return rx; }
-  [[nodiscard]] double get_radius_y() const { return ry; }
+  [[nodiscard]] double get_radius_x () const {
+    return rx;
+  }
+  [[nodiscard]] double get_radius_y () const {
+    return ry;
+  }
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
-  [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return ellipse::name; }
+  void set_attrs (attr_map_t &attrs, void *context) override;
+  [[nodiscard]] const std::string dump () const override;
+  [[nodiscard]] const std::string &get_name () const override {
+    return ellipse::name;
+  }
 
   static const std::string name;
 
-  [[nodiscard]] shape *clone() const override { return new ellipse(*this); }
+  [[nodiscard]] shape *clone () const override {
+    return new ellipse (*this);
+  }
 };
 
-}
+} // namespace libsvg
diff --git a/src/libsvg/group.cc b/src/libsvg/group.cc
index 7afed16c3..1d21fe1e3 100644
--- a/src/libsvg/group.cc
+++ b/src/libsvg/group.cc
@@ -29,25 +29,21 @@
 #include <string>
 #include <iostream>
 
-
 namespace libsvg {
 
-const std::string group::name("g");
+const std::string group::name ("g");
 
-void
-group::set_attrs(attr_map_t& attrs, void *context)
-{
-  shape::set_attrs(attrs, context);
+void group::set_attrs (attr_map_t &attrs, void *context) {
+  shape::set_attrs (attrs, context);
 }
 
 const std::string
-group::dump() const
-{
+group::dump () const {
   std::stringstream s;
-  s << get_name()
+  s << get_name ()
     << ": x = " << this->x
     << ": y = " << this->y;
-  return s.str();
+  return s.str ();
 }
 
-}
+} // namespace libsvg
diff --git a/src/libsvg/group.h b/src/libsvg/group.h
index b5cd59e93..63a4d7f5f 100644
--- a/src/libsvg/group.h
+++ b/src/libsvg/group.h
@@ -33,19 +33,24 @@ namespace libsvg {
 class group : public shape
 {
 protected:
-
 public:
-  group() = default;
+  group () = default;
 
-  [[nodiscard]] bool is_container() const override { return true; }
+  [[nodiscard]] bool is_container () const override {
+    return true;
+  }
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
-  [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return group::name; }
+  void set_attrs (attr_map_t &attrs, void *context) override;
+  [[nodiscard]] const std::string dump () const override;
+  [[nodiscard]] const std::string &get_name () const override {
+    return group::name;
+  }
 
   static const std::string name;
 
-  [[nodiscard]] shape *clone() const override { return new group(*this); }
+  [[nodiscard]] shape *clone () const override {
+    return new group (*this);
+  }
 };
 
-}
+} // namespace libsvg
diff --git a/src/libsvg/libsvg.cc b/src/libsvg/libsvg.cc
index ffada68dc..a88613fdb 100644
--- a/src/libsvg/libsvg.cc
+++ b/src/libsvg/libsvg.cc
@@ -35,7 +35,6 @@
 #include <boost/format.hpp>
 #include <libxml/xmlreader.h>
 
-
 #include "libsvg/shape.h"
 #include "libsvg/use.h"
 
@@ -50,84 +49,83 @@ static shapes_list_t *shape_list;
 using shapes_defs_list_t = std::map<std::string, std::shared_ptr<shape>>;
 
 #if SVG_DEBUG
-static std::string dump_stack() {
+static std::string dump_stack () {
   bool first = true;
   std::stringstream s;
   s << "[";
-  for (const auto& shape : stack) {
-    s << (first ? "" : "|") << shape->get_name();
+  for (const auto &shape : stack) {
+    s << (first ? "" : "|") << shape->get_name ();
     first = false;
   }
-  return s.str() + "]";
+  return s.str () + "]";
 }
 #endif // if SVG_DEBUG
 
-attr_map_t read_attributes(xmlTextReaderPtr reader)
-{
+attr_map_t read_attributes (xmlTextReaderPtr reader) {
   attr_map_t attrs;
-  int attr_count = xmlTextReaderAttributeCount(reader);
+  int attr_count = xmlTextReaderAttributeCount (reader);
   for (int idx = 0; idx < attr_count; ++idx) {
-    xmlTextReaderMoveToAttributeNo(reader, idx);
-    const char *name = reinterpret_cast<const char *>(xmlTextReaderName(reader));
-    const char *value = reinterpret_cast<const char *>(xmlTextReaderValue(reader));
+    xmlTextReaderMoveToAttributeNo (reader, idx);
+    const char *name = reinterpret_cast<const char *> (xmlTextReaderName (reader));
+    const char *value = reinterpret_cast<const char *> (xmlTextReaderValue (reader));
     attrs[name] = value;
   }
   return attrs;
 }
 
-void processNode(xmlTextReaderPtr reader, shapes_defs_list_t *defs_lookup_list, shapes_list_t *temp_defs_storage, void *context)
-{
-  const char *name = reinterpret_cast<const char *>(xmlTextReaderName(reader));
-  if (name == nullptr) name = reinterpret_cast<const char *>(xmlStrdup(BAD_CAST "--"));
+void processNode (xmlTextReaderPtr reader, shapes_defs_list_t *defs_lookup_list, shapes_list_t *temp_defs_storage, void *context) {
+  const char *name = reinterpret_cast<const char *> (xmlTextReaderName (reader));
+  if (name == nullptr)
+    name = reinterpret_cast<const char *> (xmlStrdup (BAD_CAST "--"));
 
   bool isEmpty;
-  xmlChar *value = xmlTextReaderValue(reader);
-  int node_type = xmlTextReaderNodeType(reader);
+  xmlChar *value = xmlTextReaderValue (reader);
+  int node_type = xmlTextReaderNodeType (reader);
   switch (node_type) {
   case XML_READER_TYPE_ELEMENT:
-    isEmpty = xmlTextReaderIsEmptyElement(reader);
+    isEmpty = xmlTextReaderIsEmptyElement (reader);
     {
 #if SVG_DEBUG
-      printf("XML_READER_TYPE_ELEMENT (%s %s): %d %d %s\n",
-             dump_stack().c_str(), name,
-             xmlTextReaderDepth(reader),
-             xmlTextReaderNodeType(reader),
-             value);
+      printf ("XML_READER_TYPE_ELEMENT (%s %s): %d %d %s\n",
+              dump_stack ().c_str (), name,
+              xmlTextReaderDepth (reader),
+              xmlTextReaderNodeType (reader),
+              value);
 #endif
 
-      if (std::string("defs") == name) {
+      if (std::string ("defs") == name) {
         in_defs = true;
       }
 
-      auto s = std::shared_ptr<shape>(shape::create_from_name(name));
+      auto s = std::shared_ptr<shape> (shape::create_from_name (name));
       if (s) {
-        attr_map_t attrs = read_attributes(reader);
-        if (!stack.empty()) {
-          stack.back()->add_child(s.get());
+        attr_map_t attrs = read_attributes (reader);
+        if (!stack.empty ()) {
+          stack.back ()->add_child (s.get ());
         }
-        s->set_attrs(attrs, context);
-        if (s->is_container()) {
-          stack.push_back(s);
+        s->set_attrs (attrs, context);
+        if (s->is_container ()) {
+          stack.push_back (s);
         }
 
         //handle the "use" tag
-        if (use::name == s->get_name()) {
-          use *currentuse = dynamic_cast<use *>(s.get());
-          auto id = currentuse->get_href_id();
-          if (!id.empty() && defs_lookup_list->find(id) != defs_lookup_list->end()) {
+        if (use::name == s->get_name ()) {
+          use *currentuse = dynamic_cast<use *> (s.get ());
+          auto id = currentuse->get_href_id ();
+          if (!id.empty () && defs_lookup_list->find (id) != defs_lookup_list->end ()) {
             auto to_clone_child = (*defs_lookup_list)[id];
-            auto cloned_children = currentuse->set_clone_child(to_clone_child.get());
-            shape_list->insert(shape_list->end(), cloned_children.begin(), cloned_children.end());
+            auto cloned_children = currentuse->set_clone_child (to_clone_child.get ());
+            shape_list->insert (shape_list->end (), cloned_children.begin (), cloned_children.end ());
           }
         }
 
         if (!in_defs) {
-          shape_list->push_back(s);
+          shape_list->push_back (s);
         } else {
-          if (!s->get_id_or_default().empty()) {
-            defs_lookup_list->insert(std::make_pair(s->get_id(), s));
+          if (!s->get_id_or_default ().empty ()) {
+            defs_lookup_list->insert (std::make_pair (s->get_id (), s));
           }
-          temp_defs_storage->push_back(s);
+          temp_defs_storage->push_back (s);
         }
       }
     }
@@ -135,108 +133,100 @@ void processNode(xmlTextReaderPtr reader, shapes_defs_list_t *defs_lookup_list,
       break;
     }
   /* fall through */
-  case XML_READER_TYPE_END_ELEMENT:
-  {
-    if (std::string("defs") == name) {
+  case XML_READER_TYPE_END_ELEMENT: {
+    if (std::string ("defs") == name) {
       in_defs = false;
     }
 
-    if (std::string("g") == name ||
-        std::string("svg") == name ||
-        std::string("tspan") == name ||
-        std::string("text") == name) {
-      stack.pop_back();
+    if (std::string ("g") == name ||
+        std::string ("svg") == name ||
+        std::string ("tspan") == name ||
+        std::string ("text") == name) {
+      stack.pop_back ();
     }
 #if SVG_DEBUG
-    printf("XML_READER_TYPE_END_ELEMENT (%s %s): %d %d %s\n",
-           dump_stack().c_str(), name,
-           xmlTextReaderDepth(reader),
-           xmlTextReaderNodeType(reader),
-           value);
+    printf ("XML_READER_TYPE_END_ELEMENT (%s %s): %d %d %s\n",
+            dump_stack ().c_str (), name,
+            xmlTextReaderDepth (reader),
+            xmlTextReaderNodeType (reader),
+            value);
 #endif
-  }
-  break;
-  case XML_READER_TYPE_TEXT:
-  {
+  } break;
+  case XML_READER_TYPE_TEXT: {
     attr_map_t attrs;
-    attrs["text"] = reinterpret_cast<const char *>(value);
-    auto s = std::shared_ptr<shape>(shape::create_from_name("data"));
-    if (!stack.empty()) {
-      stack.back()->add_child(s.get());
+    attrs["text"] = reinterpret_cast<const char *> (value);
+    auto s = std::shared_ptr<shape> (shape::create_from_name ("data"));
+    if (!stack.empty ()) {
+      stack.back ()->add_child (s.get ());
     }
-    s->set_attrs(attrs, context);
+    s->set_attrs (attrs, context);
     if (!in_defs) {
-      shape_list->push_back(s);
+      shape_list->push_back (s);
     } else {
-      temp_defs_storage->push_back(s);
+      temp_defs_storage->push_back (s);
     }
-  }
-  break;
+  } break;
   }
 
-  xmlFree(value);
-  xmlFree((void *) (name));
+  xmlFree (value);
+  xmlFree ((void *)(name));
 }
 
-int streamFile(const char *filename, void *context)
-{
+int streamFile (const char *filename, void *context) {
   xmlTextReaderPtr reader;
   // The temp storage is needed for items in a def that don't have an id, but have a parent with an id
   shapes_list_t temp_defs_storage;
   shapes_defs_list_t defs_lookup_list;
 
   in_defs = false;
-  reader = xmlNewTextReaderFilename(filename);
-  xmlTextReaderSetParserProp(reader, XML_PARSER_SUBST_ENTITIES, 1);
+  reader = xmlNewTextReaderFilename (filename);
+  xmlTextReaderSetParserProp (reader, XML_PARSER_SUBST_ENTITIES, 1);
   if (reader != nullptr) {
-    int ret = xmlTextReaderRead(reader);
+    int ret = xmlTextReaderRead (reader);
     while (ret == 1) {
-      processNode(reader, &defs_lookup_list, &temp_defs_storage, context);
-      ret = xmlTextReaderRead(reader);
+      processNode (reader, &defs_lookup_list, &temp_defs_storage, context);
+      ret = xmlTextReaderRead (reader);
     }
-    xmlFreeTextReader(reader);
+    xmlFreeTextReader (reader);
     if (ret != 0) {
-      throw SvgException((boost::format("Error parsing file '%1%'") % filename).str());
+      throw SvgException ((boost::format ("Error parsing file '%1%'") % filename).str ());
     }
   } else {
-    throw SvgException((boost::format("Can't open file '%1%'") % filename).str());
+    throw SvgException ((boost::format ("Can't open file '%1%'") % filename).str ());
   }
 
-  for (const auto& shape : (*shape_list)) {
-    shape->apply_transform();
+  for (const auto &shape : (*shape_list)) {
+    shape->apply_transform ();
   }
 
   return 0;
 }
 
-void dump(int idx, shape *s) {
+void dump (int idx, shape *s) {
   for (int a = 0; a < idx; ++a) {
     std::cout << "  ";
   }
-  std::cout << "=> " << s->dump() << std::endl;
-  for (const auto& c : s->get_children()) {
-    dump(idx + 1, c);
+  std::cout << "=> " << s->dump () << std::endl;
+  for (const auto &c : s->get_children ()) {
+    dump (idx + 1, c);
   }
 }
 
 shapes_list_t *
-libsvg_read_file(const char *filename, void *context)
-{
-  shape_list = new shapes_list_t();
-  streamFile(filename, context);
+libsvg_read_file (const char *filename, void *context) {
+  shape_list = new shapes_list_t ();
+  streamFile (filename, context);
 
-//#ifdef DEBUG
-//	if (!shape_list->empty()) {
-//		dump(0, shape_list->front().get());
-//	}
-//#endif
+  //#ifdef DEBUG
+  //	if (!shape_list->empty()) {
+  //		dump(0, shape_list->front().get());
+  //	}
+  //#endif
 
   return shape_list;
 }
 
-void
-libsvg_free(shapes_list_t *shapes)
-{
+void libsvg_free (shapes_list_t *shapes) {
   delete shapes;
 }
 
diff --git a/src/libsvg/libsvg.h b/src/libsvg/libsvg.h
index 19910ae45..22f913e87 100644
--- a/src/libsvg/libsvg.h
+++ b/src/libsvg/libsvg.h
@@ -37,11 +37,11 @@ namespace libsvg {
 class SvgException : public std::exception
 {
 public:
-  SvgException(std::string message) : message(std::move(message)) { }
+  SvgException (std::string message)
+    : message (std::move (message)) {}
 
-  [[nodiscard]] const char *what() const noexcept override
-  {
-    return message.c_str();
+  [[nodiscard]] const char *what () const noexcept override {
+    return message.c_str ();
   }
 
 private:
@@ -51,9 +51,8 @@ private:
 using shapes_list_t = std::vector<std::shared_ptr<shape>>;
 
 shapes_list_t *
-libsvg_read_file(const char *filename, void *context);
+libsvg_read_file (const char *filename, void *context);
 
-void
-libsvg_free(shapes_list_t *shapes);
+void libsvg_free (shapes_list_t *shapes);
 
-}
+} // namespace libsvg
diff --git a/src/libsvg/line.cc b/src/libsvg/line.cc
index 0c95b18a4..9b7ef04ae 100644
--- a/src/libsvg/line.cc
+++ b/src/libsvg/line.cc
@@ -30,33 +30,30 @@
 
 namespace libsvg {
 
-const std::string line::name("line");
+const std::string line::name ("line");
 
-void
-line::set_attrs(attr_map_t& attrs, void *context)
-{
-  shape::set_attrs(attrs, context);
-  this->x = parse_double(attrs["x1"]);
-  this->y = parse_double(attrs["y1"]);
-  this->x2 = parse_double(attrs["x2"]);
-  this->y2 = parse_double(attrs["y2"]);
+void line::set_attrs (attr_map_t &attrs, void *context) {
+  shape::set_attrs (attrs, context);
+  this->x = parse_double (attrs["x1"]);
+  this->y = parse_double (attrs["y1"]);
+  this->x2 = parse_double (attrs["x2"]);
+  this->y2 = parse_double (attrs["y2"]);
 
   path_t path;
-  path.push_back(Eigen::Vector3d(x, y, 0));
-  path.push_back(Eigen::Vector3d(x2, y2, 0));
-  offset_path(path_list, path, get_stroke_width(), get_stroke_linecap());
+  path.push_back (Eigen::Vector3d (x, y, 0));
+  path.push_back (Eigen::Vector3d (x2, y2, 0));
+  offset_path (path_list, path, get_stroke_width (), get_stroke_linecap ());
 }
 
 const std::string
-line::dump() const
-{
+line::dump () const {
   std::stringstream s;
-  s << get_name()
+  s << get_name ()
     << ": x1 = " << this->x
     << ": y1 = " << this->y
     << ": x2 = " << this->x2
     << ": y2 = " << this->y2;
-  return s.str();
+  return s.str ();
 }
 
 } // namespace libsvg
diff --git a/src/libsvg/line.h b/src/libsvg/line.h
index c121864fd..56e859059 100644
--- a/src/libsvg/line.h
+++ b/src/libsvg/line.h
@@ -36,18 +36,26 @@ private:
   double y2{0};
 
 public:
-  line() = default;
+  line () = default;
 
-  [[nodiscard]] double get_x2() const { return x2; } // NOLINT(bugprone-virtual-near-miss)
-  [[nodiscard]] double get_y2() const { return y2; } // NOLINT(bugprone-virtual-near-miss)
+  [[nodiscard]] double get_x2 () const {
+    return x2;
+  } // NOLINT(bugprone-virtual-near-miss)
+  [[nodiscard]] double get_y2 () const {
+    return y2;
+  } // NOLINT(bugprone-virtual-near-miss)
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
-  [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return line::name; }
+  void set_attrs (attr_map_t &attrs, void *context) override;
+  [[nodiscard]] const std::string dump () const override;
+  [[nodiscard]] const std::string &get_name () const override {
+    return line::name;
+  }
 
   static const std::string name;
 
-  [[nodiscard]] shape *clone() const override { return new line(*this); }
+  [[nodiscard]] shape *clone () const override {
+    return new line (*this);
+  }
 };
 
-}
+} // namespace libsvg
diff --git a/src/libsvg/path.cc b/src/libsvg/path.cc
index f885c78ee..e093add4a 100644
--- a/src/libsvg/path.cc
+++ b/src/libsvg/path.cc
@@ -48,7 +48,7 @@ namespace libsvg {
 
 using tokenizer = boost::tokenizer<boost::char_separator<char>>;
 
-const std::string path::name("path");
+const std::string path::name ("path");
 
 /*
    PATHSEG_CLOSEPATH z
@@ -73,34 +73,31 @@ const std::string path::name("path");
  */
 
 static double
-vector_angle(double ux, double uy, double vx, double vy)
-{
-  double angle = atan2_degrees(vy, vx) - atan2_degrees(uy, ux);
+vector_angle (double ux, double uy, double vx, double vy) {
+  double angle = atan2_degrees (vy, vx) - atan2_degrees (uy, ux);
   if (angle < 0) {
     angle += 360;
   }
   return angle;
 }
 
-static inline
-unsigned long CalcFn(double fn, unsigned long minimum) {
+static inline unsigned long CalcFn (double fn, unsigned long minimum) {
   unsigned long result = 3;
-  if (fn > 3.0)     // > 0.0 && > 3
-    result = static_cast<unsigned long>(fn);
-  if (result < minimum) result = minimum;
+  if (fn > 3.0) // > 0.0 && > 3
+    result = static_cast<unsigned long> (fn);
+  if (result < minimum)
+    result = minimum;
   return result;
 }
 
-void
-path::arc_to(path_t& path, double x1, double y1, double rx, double ry, double x2, double y2, double angle, bool large, bool sweep, void *context)
-{
-  const auto *fValues = reinterpret_cast<const fnContext *>(context);
+void path::arc_to (path_t &path, double x1, double y1, double rx, double ry, double x2, double y2, double angle, bool large, bool sweep, void *context) {
+  const auto *fValues = reinterpret_cast<const fnContext *> (context);
 
   // http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
 
   // (F.6.5.1))
-  double cos_rad = cos_degrees(angle);
-  double sin_rad = sin_degrees(angle);
+  double cos_rad = cos_degrees (angle);
+  double sin_rad = sin_degrees (angle);
   double dx = (x1 - x2) / 2;
   double dy = (y1 - y2) / 2;
   double x1_ = cos_rad * dx + sin_rad * dy;
@@ -108,8 +105,8 @@ path::arc_to(path_t& path, double x1, double y1, double rx, double ry, double x2
 
   double d = (x1_ * x1_) / (rx * rx) + (y1_ * y1_) / (ry * ry);
   if (d > 1) {
-    rx = std::fabs(std::sqrt(d) * rx);
-    ry = std::fabs(std::sqrt(d) * ry);
+    rx = std::fabs (std::sqrt (d) * rx);
+    ry = std::fabs (std::sqrt (d) * ry);
   }
 
   // F.6.5.2
@@ -118,7 +115,7 @@ path::arc_to(path_t& path, double x1, double y1, double rx, double ry, double x2
   if (t1 < 0) {
     t1 = 0;
   }
-  double t3 = std::sqrt(t1 / t2);
+  double t3 = std::sqrt (t1 / t2);
   if (large == sweep) {
     t3 = -t3;
   }
@@ -136,54 +133,49 @@ path::arc_to(path_t& path, double x1, double y1, double rx, double ry, double x2
   double vx = (-x1_ - cx_) / rx;
   double vy = (-y1_ - cy_) / ry;
 
-  double theta = vector_angle(1, 0, ux, uy);
-  double delta = vector_angle(ux, uy, vx, vy);
+  double theta = vector_angle (1, 0, ux, uy);
+  double delta = vector_angle (ux, uy, vx, vy);
   if (!sweep) {
     delta -= 360;
   }
 
-  double rmax = fmax(rx, ry);
-  unsigned long fn = Calc::get_fragments_from_r(rmax, fValues->fn, fValues->fs, fValues->fa);
-  fn = (unsigned long) ceil(fn * fabs(delta) / 360.0); // because we are creating a section of an ellipse, not the full ellipse
-  unsigned int steps = (std::fabs(delta) * 10.0 / 180) + 4;
+  double rmax = fmax (rx, ry);
+  unsigned long fn = Calc::get_fragments_from_r (rmax, fValues->fn, fValues->fs, fValues->fa);
+  fn = (unsigned long)ceil (fn * fabs (delta) / 360.0); // because we are creating a section of an ellipse, not the full ellipse
+  unsigned int steps = (std::fabs (delta) * 10.0 / 180) + 4;
   if (steps < fn) // use the maximum of calculated steps and user specified steps
     steps = fn;
   for (unsigned int a = 0; a <= steps; ++a) {
     double phi = theta + delta * a / steps;
 
-    double xx = cos_rad * cos_degrees(phi) * rx - sin_rad * sin_degrees(phi) * ry;
-    double yy = sin_rad * cos_degrees(phi) * rx + cos_rad * sin_degrees(phi) * ry;
+    double xx = cos_rad * cos_degrees (phi) * rx - sin_rad * sin_degrees (phi) * ry;
+    double yy = sin_rad * cos_degrees (phi) * rx + cos_rad * sin_degrees (phi) * ry;
 
-    path.push_back(Eigen::Vector3d(xx + cx, yy + cy, 0));
+    path.push_back (Eigen::Vector3d (xx + cx, yy + cy, 0));
   }
 }
 
-
-void
-path::curve_to(path_t& path, double x, double y, double cx1, double cy1, double x2, double y2, void *context)
-{
+void path::curve_to (path_t &path, double x, double y, double cx1, double cy1, double x2, double y2, void *context) {
   // NOTE - this could be done better using a chord length iteration (uniform in space) to implement $fa (lot of work, little gain)
-  const auto *fValues = reinterpret_cast<const fnContext *>(context);
-  unsigned long fn = CalcFn(fValues->fn, 20); // preserve the old minimum
+  const auto *fValues = reinterpret_cast<const fnContext *> (context);
+  unsigned long fn = CalcFn (fValues->fn, 20); // preserve the old minimum
   for (unsigned long idx = 1; idx <= fn; ++idx) {
     const double a = idx * (1.0 / (double)fn);
-    const double xx = x * t(a, 2) + cx1 * 2 * t(a, 1) * a + x2 * a * a;
-    const double yy = y * t(a, 2) + cy1 * 2 * t(a, 1) * a + y2 * a * a;
-    path.push_back(Eigen::Vector3d(xx, yy, 0));
+    const double xx = x * t (a, 2) + cx1 * 2 * t (a, 1) * a + x2 * a * a;
+    const double yy = y * t (a, 2) + cy1 * 2 * t (a, 1) * a + y2 * a * a;
+    path.push_back (Eigen::Vector3d (xx, yy, 0));
   }
 }
 
-void
-path::curve_to(path_t& path, double x, double y, double cx1, double cy1, double cx2, double cy2, double x2, double y2, void *context)
-{
+void path::curve_to (path_t &path, double x, double y, double cx1, double cy1, double cx2, double cy2, double x2, double y2, void *context) {
   // NOTE - this could be done better using a chord length iteration (uniform in space) to implement $fa (lot of work, little gain)
-  const auto *fValues = reinterpret_cast<const fnContext *>(context);
-  unsigned long fn = CalcFn(fValues->fn, 20); // preserve the old minimum
+  const auto *fValues = reinterpret_cast<const fnContext *> (context);
+  unsigned long fn = CalcFn (fValues->fn, 20); // preserve the old minimum
   for (unsigned long idx = 1; idx <= fn; ++idx) {
     const double a = idx * (1.0 / (double)fn);
-    const double xx = x * t(a, 3) + cx1 * 3 * t(a, 2) * a + cx2 * 3 * t(a, 1) * a * a + x2 * a * a * a;
-    const double yy = y * t(a, 3) + cy1 * 3 * t(a, 2) * a + cy2 * 3 * t(a, 1) * a * a + y2 * a * a * a;
-    path.push_back(Eigen::Vector3d(xx, yy, 0));
+    const double xx = x * t (a, 3) + cx1 * 3 * t (a, 2) * a + cx2 * 3 * t (a, 1) * a * a + x2 * a * a * a;
+    const double yy = y * t (a, 3) + cy1 * 3 * t (a, 2) * a + cy2 * 3 * t (a, 1) * a * a + y2 * a * a * a;
+    path.push_back (Eigen::Vector3d (xx, yy, 0));
   }
 }
 
@@ -191,49 +183,46 @@ path::curve_to(path_t& path, double x, double y, double cx1, double cy1, double
  * Workaround for parsing ",1-23.16.88" where the number split
  * happens implicitly at the dot.
  */
-static std::vector<std::string> split_dots(const std::string& str)
-{
+static std::vector<std::string> split_dots (const std::string &str) {
   std::vector<std::string> result;
-  const size_t n = std::count(str.begin(), str.end(), '.');
+  const size_t n = std::count (str.begin (), str.end (), '.');
   if (n < 2) {
-    result.push_back(str);
+    result.push_back (str);
     return result;
   }
 
-  boost::char_separator<char> sep("", ".");
-  tokenizer tokens(str, sep);
+  boost::char_separator<char> sep ("", ".");
+  tokenizer tokens (str, sep);
 
   std::string text;
   bool dot_seen = false;
-  for (const auto& token : tokens) {
+  for (const auto &token : tokens) {
     text += token;
     if (token == ".") {
       dot_seen = true;
       continue;
     } else if (dot_seen == true) {
-      result.push_back(text);
-      text.clear();
+      result.push_back (text);
+      text.clear ();
     }
   }
 
   return result;
 }
 
-void
-path::set_attrs(attr_map_t& attrs, void *context)
-{
+void path::set_attrs (attr_map_t &attrs, void *context) {
   std::string commands = "-zmlcqahvstZMLCQAHVST";
 
-  shape::set_attrs(attrs, context);
+  shape::set_attrs (attrs, context);
   this->data = attrs["d"];
 
-  boost::char_separator<char> sep(" ,", commands.c_str());
-  tokenizer tokens(this->data, sep);
+  boost::char_separator<char> sep (" ,", commands.c_str ());
+  tokenizer tokens (this->data, sep);
 
   std::vector<std::string> path_tokens;
-  for (const auto& token : tokens) {
-    const std::vector<std::string> parts = split_dots(token);
-    path_tokens.insert(path_tokens.end(), parts.begin(), parts.end());
+  for (const auto &token : tokens) {
+    const std::vector<std::string> parts = split_dots (token);
+    path_tokens.insert (path_tokens.end (), parts.begin (), parts.end ());
   }
 
   double x = 0;
@@ -257,11 +246,11 @@ path::set_attrs(attr_map_t& attrs, void *context)
   bool negate = false;
   bool path_closed = false;
   std::string pre_exp;
-  path_list.push_back(path_t());
-  for (const auto& v : path_tokens) {
+  path_list.push_back (path_t ());
+  for (const auto &v : path_tokens) {
 
     double p = 0;
-    if ((v.length() == 1) && (commands.find(v) != std::string::npos)) {
+    if ((v.length () == 1) && (commands.find (v) != std::string::npos)) {
       if (v[0] == '-') {
         negate = true;
         continue;
@@ -269,16 +258,16 @@ path::set_attrs(attr_map_t& attrs, void *context)
       point = -1;
       cmd = v[0];
     } else {
-      if (std::tolower(*v.rbegin()) == 'e') {
-        pre_exp = negate ? std::string("-").append(v) : v;
+      if (std::tolower (*v.rbegin ()) == 'e') {
+        pre_exp = negate ? std::string ("-").append (v) : v;
         negate = false;
         continue;
       }
-      if (pre_exp.empty()) {
-        p = parse_double(v);
+      if (pre_exp.empty ()) {
+        p = parse_double (v);
         p = negate ? -p : p;
       } else {
-        p = parse_double(pre_exp.append(negate ? "-" : "").append(v));
+        p = parse_double (pre_exp.append (negate ? "-" : "").append (v));
         pre_exp = "";
       }
       negate = false;
@@ -290,10 +279,10 @@ path::set_attrs(attr_map_t& attrs, void *context)
       //(rx ry x-axis-rotation large-arc-flag sweep-flag x y)
       switch (point) {
       case 0:
-        rx = std::fabs(p);
+        rx = std::fabs (p);
         break;
       case 1:
-        ry = std::fabs(p);
+        ry = std::fabs (p);
         break;
       case 2:
         angle = p;
@@ -309,7 +298,7 @@ path::set_attrs(attr_map_t& attrs, void *context)
         break;
       case 6:
         yy = cmd == 'a' ? y + p : p;
-        arc_to(path_list.back(), x, y, rx, ry, xx, yy, angle, large, sweep, context);
+        arc_to (path_list.back (), x, y, rx, ry, xx, yy, angle, large, sweep, context);
         x = xx;
         y = yy;
         point = -1;
@@ -326,7 +315,7 @@ path::set_attrs(attr_map_t& attrs, void *context)
         break;
       case 1:
         yy = cmd == 'l' ? y + p : p;
-        path_list.back().push_back(Eigen::Vector3d(xx, yy, 0));
+        path_list.back ().push_back (Eigen::Vector3d (xx, yy, 0));
         x = xx;
         y = yy;
         point = -1;
@@ -359,7 +348,7 @@ path::set_attrs(attr_map_t& attrs, void *context)
         cy1 = cmd == 'c' ? y + cy1 : cy1;
         cx2 = cmd == 'c' ? x + cx2 : cx2;
         cy2 = cmd == 'c' ? y + cy2 : cy2;
-        curve_to(path_list.back(), x, y, cx1, cy1, cx2, cy2, xx, yy, context);
+        curve_to (path_list.back (), x, y, cx1, cy1, cx2, cy2, xx, yy, context);
         x = xx;
         y = yy;
         point = -1;
@@ -373,11 +362,11 @@ path::set_attrs(attr_map_t& attrs, void *context)
       switch (point) {
       case 0:
         if (last_cmd_cubic_bezier) {
-          Eigen::Vector2d old_control_point(cx2, cy2);
-          Eigen::Vector2d current_point(x, y);
+          Eigen::Vector2d old_control_point (cx2, cy2);
+          Eigen::Vector2d current_point (x, y);
           Eigen::Vector2d new_control_point = current_point + (current_point - old_control_point);
-          cx1 = new_control_point.x();
-          cy1 = new_control_point.y();
+          cx1 = new_control_point.x ();
+          cy1 = new_control_point.y ();
         } else {
           cx1 = x;
           cy1 = y;
@@ -394,7 +383,7 @@ path::set_attrs(attr_map_t& attrs, void *context)
         yy = cmd == 's' ? y + p : p;
         cx2 = cmd == 's' ? x + cx2 : cx2;
         cy2 = cmd == 's' ? y + cy2 : cy2;
-        curve_to(path_list.back(), x, y, cx1, cy1, cx2, cy2, xx, yy, context);
+        curve_to (path_list.back (), x, y, cx1, cy1, cx2, cy2, xx, yy, context);
         x = xx;
         y = yy;
         point = -1;
@@ -419,7 +408,7 @@ path::set_attrs(attr_map_t& attrs, void *context)
         yy = cmd == 'q' ? y + p : p;
         cx1 = cmd == 'q' ? x + cx1 : cx1;
         cy1 = cmd == 'q' ? y + cy1 : cy1;
-        curve_to(path_list.back(), x, y, cx1, cy1, xx, yy, context);
+        curve_to (path_list.back (), x, y, cx1, cy1, xx, yy, context);
         x = xx;
         y = yy;
         point = -1;
@@ -433,11 +422,11 @@ path::set_attrs(attr_map_t& attrs, void *context)
       switch (point) {
       case 0:
         if (last_cmd_quadratic_bezier) {
-          Eigen::Vector2d old_control_point(cx1, cy1);
-          Eigen::Vector2d current_point(x, y);
+          Eigen::Vector2d old_control_point (cx1, cy1);
+          Eigen::Vector2d current_point (x, y);
           Eigen::Vector2d new_control_point = current_point + (current_point - old_control_point);
-          cx1 = new_control_point.x();
-          cy1 = new_control_point.y();
+          cx1 = new_control_point.x ();
+          cy1 = new_control_point.y ();
         } else {
           cx1 = x;
           cy1 = y;
@@ -446,7 +435,7 @@ path::set_attrs(attr_map_t& attrs, void *context)
         break;
       case 1:
         yy = cmd == 't' ? y + p : p;
-        curve_to(path_list.back(), x, y, cx1, cy1, xx, yy, context);
+        curve_to (path_list.back (), x, y, cx1, cy1, xx, yy, context);
         x = xx;
         y = yy;
         point = -1;
@@ -465,16 +454,16 @@ path::set_attrs(attr_map_t& attrs, void *context)
         yy = cmd == 'm' ? y + p : p;
         cmd = cmd == 'm' ? 'l' : 'L';
 
-        path_t path = path_list.back();
-        if (!path_list.back().empty()) {
-          if (is_open_path(path)) {
-            path_list.pop_back();
-            offset_path(path_list, path, get_stroke_width(), get_stroke_linecap());
+        path_t path = path_list.back ();
+        if (!path_list.back ().empty ()) {
+          if (is_open_path (path)) {
+            path_list.pop_back ();
+            offset_path (path_list, path, get_stroke_width (), get_stroke_linecap ());
           }
-          path_list.push_back(path_t());
+          path_list.push_back (path_t ());
         }
 
-        path_list.back().push_back(Eigen::Vector3d(xx, yy, 0));
+        path_list.back ().push_back (Eigen::Vector3d (xx, yy, 0));
         x = xx;
         y = yy;
         point = -1;
@@ -487,7 +476,7 @@ path::set_attrs(attr_map_t& attrs, void *context)
       switch (point) {
       case 0:
         y = cmd == 'v' ? y + p : p;
-        path_list.back().push_back(Eigen::Vector3d(x, y, 0));
+        path_list.back ().push_back (Eigen::Vector3d (x, y, 0));
         point = -1;
         last_cmd_cubic_bezier = false;
         last_cmd_quadratic_bezier = false;
@@ -499,7 +488,7 @@ path::set_attrs(attr_map_t& attrs, void *context)
       switch (point) {
       case 0:
         x = cmd == 'h' ? x + p : p;
-        path_list.back().push_back(Eigen::Vector3d(x, y, 0));
+        path_list.back ().push_back (Eigen::Vector3d (x, y, 0));
         point = -1;
         last_cmd_cubic_bezier = false;
         last_cmd_quadratic_bezier = false;
@@ -508,13 +497,13 @@ path::set_attrs(attr_map_t& attrs, void *context)
       break;
     case 'z':
     case 'Z':
-      if (!path_list.back().empty()) {
-        Eigen::Vector3d p = path_list.back()[0];
-        path_list.back().push_back(p);
-        x = p.x();
-        y = p.y();
+      if (!path_list.back ().empty ()) {
+        Eigen::Vector3d p = path_list.back ()[0];
+        path_list.back ().push_back (p);
+        x = p.x ();
+        y = p.y ();
       }
-      path_list.push_back(path_t());
+      path_list.push_back (path_t ());
       path_closed = true;
       last_cmd_cubic_bezier = false;
       last_cmd_quadratic_bezier = false;
@@ -524,43 +513,40 @@ path::set_attrs(attr_map_t& attrs, void *context)
     point++;
   }
 
-  while (!path_list.empty() && path_list.back().empty()) {
-    path_list.pop_back();
+  while (!path_list.empty () && path_list.back ().empty ()) {
+    path_list.pop_back ();
   }
 
-  if (!path_closed && !path_list.empty()) {
-    path_t path = path_list.back();
-    if (is_open_path(path)) {
-      path_list.pop_back();
-      offset_path(path_list, path, get_stroke_width(), get_stroke_linecap());
+  if (!path_closed && !path_list.empty ()) {
+    path_t path = path_list.back ();
+    if (is_open_path (path)) {
+      path_list.pop_back ();
+      offset_path (path_list, path, get_stroke_width (), get_stroke_linecap ());
     }
   }
 }
 
-bool
-path::is_open_path(path_t& path) const
-{
-  const Eigen::Vector3d& p1 = path[0];
-  const Eigen::Vector3d& p2 = path.back();
-  double distance = pow(pow(p1.x() - p2.x(), 2) + pow(p1.y() - p2.y(), 2) + pow(p1.z() - p2.z(), 2), 0.5);
+bool path::is_open_path (path_t &path) const {
+  const Eigen::Vector3d &p1 = path[0];
+  const Eigen::Vector3d &p2 = path.back ();
+  double distance = pow (pow (p1.x () - p2.x (), 2) + pow (p1.y () - p2.y (), 2) + pow (p1.z () - p2.z (), 2), 0.5);
   return distance > 0.1;
 }
 
 const std::string
-path::dump() const
-{
+path::dump () const {
   std::stringstream s;
-  s << get_name()
+  s << get_name ()
     << ": x = " << this->x
     << ", y = " << this->y;
-  for (const auto& p : path_list) {
+  for (const auto &p : path_list) {
     s << "[";
-    for (const auto& v : p) {
-      s << " (" << v.x() << ", " << v.y() << ")";
+    for (const auto &v : p) {
+      s << " (" << v.x () << ", " << v.y () << ")";
     }
     s << "]";
   }
-  return s.str();
+  return s.str ();
 }
 
 } // namespace libsvg
diff --git a/src/libsvg/path.h b/src/libsvg/path.h
index 87afec19b..5a7a597b1 100644
--- a/src/libsvg/path.h
+++ b/src/libsvg/path.h
@@ -36,25 +36,29 @@ protected:
   std::string data;
 
 private:
-  [[nodiscard]] inline double t(double t, int exp) const {
-    return std::pow(1.0 - t, exp);
+  [[nodiscard]] inline double t (double t, int exp) const {
+    return std::pow (1.0 - t, exp);
   }
 
-  bool is_open_path(path_t& path) const;
-  void arc_to(path_t& path, double x, double y, double rx, double ry, double x2, double y2, double angle, bool large, bool sweep, void *context);
-  void curve_to(path_t& path, double x, double y, double cx1, double cy1, double x2, double y2, void *context);
-  void curve_to(path_t& path, double x, double y, double cx1, double cy1, double cx2, double cy2, double x2, double y2, void *context);
+  bool is_open_path (path_t &path) const;
+  void arc_to (path_t &path, double x, double y, double rx, double ry, double x2, double y2, double angle, bool large, bool sweep, void *context);
+  void curve_to (path_t &path, double x, double y, double cx1, double cy1, double x2, double y2, void *context);
+  void curve_to (path_t &path, double x, double y, double cx1, double cy1, double cx2, double cy2, double x2, double y2, void *context);
 
 public:
-  path() = default;
+  path () = default;
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
-  [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return path::name; }
+  void set_attrs (attr_map_t &attrs, void *context) override;
+  [[nodiscard]] const std::string dump () const override;
+  [[nodiscard]] const std::string &get_name () const override {
+    return path::name;
+  }
 
   static const std::string name;
 
-  [[nodiscard]] shape *clone() const override { return new path(*this); }
+  [[nodiscard]] shape *clone () const override {
+    return new path (*this);
+  }
 };
 
 } // namespace libsvg
diff --git a/src/libsvg/polygon.cc b/src/libsvg/polygon.cc
index 4dc8aee04..20d0d2980 100644
--- a/src/libsvg/polygon.cc
+++ b/src/libsvg/polygon.cc
@@ -32,35 +32,33 @@
 
 namespace libsvg {
 
-const std::string polygon::name("polygon");
+const std::string polygon::name ("polygon");
 
-void
-polygon::set_attrs(attr_map_t& attrs, void *context)
-{
-  shape::set_attrs(attrs, context);
+void polygon::set_attrs (attr_map_t &attrs, void *context) {
+  shape::set_attrs (attrs, context);
   this->points = attrs["points"];
 
   using tokenizer = boost::tokenizer<boost::char_separator<char>>;
-  boost::char_separator<char> sep(" ,");
-  tokenizer tokens(this->points, sep);
+  boost::char_separator<char> sep (" ,");
+  tokenizer tokens (this->points, sep);
 
   double x = 0.0;
   path_t path;
   bool first = true;
-  for (const auto& v : tokens) {
-    double p = parse_double(v);
+  for (const auto &v : tokens) {
+    double p = parse_double (v);
 
     if (first) {
       x = p;
     } else {
-      path.push_back(Eigen::Vector3d(x, p, 0));
+      path.push_back (Eigen::Vector3d (x, p, 0));
     }
     first = !first;
   }
-  if (!path.empty()) {
-    path.push_back(path[0]);
+  if (!path.empty ()) {
+    path.push_back (path[0]);
   }
-  path_list.push_back(path);
+  path_list.push_back (path);
 }
 
 } // namespace libsvg
diff --git a/src/libsvg/polygon.h b/src/libsvg/polygon.h
index c78299da3..0701c8b57 100644
--- a/src/libsvg/polygon.h
+++ b/src/libsvg/polygon.h
@@ -35,14 +35,18 @@ private:
   std::string points;
 
 public:
-  polygon() = default;
+  polygon () = default;
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
-  [[nodiscard]] const std::string& get_name() const override { return polygon::name; }
+  void set_attrs (attr_map_t &attrs, void *context) override;
+  [[nodiscard]] const std::string &get_name () const override {
+    return polygon::name;
+  }
 
   static const std::string name;
 
-  [[nodiscard]] shape *clone() const override { return new polygon(*this); }
+  [[nodiscard]] shape *clone () const override {
+    return new polygon (*this);
+  }
 };
 
-}
+} // namespace libsvg
diff --git a/src/libsvg/polyline.cc b/src/libsvg/polyline.cc
index 00e038448..ff142b555 100644
--- a/src/libsvg/polyline.cc
+++ b/src/libsvg/polyline.cc
@@ -31,33 +31,31 @@
 
 namespace libsvg {
 
-const std::string polyline::name("polyline");
+const std::string polyline::name ("polyline");
 
-void
-polyline::set_attrs(attr_map_t& attrs, void *context)
-{
-  shape::set_attrs(attrs, context);
+void polyline::set_attrs (attr_map_t &attrs, void *context) {
+  shape::set_attrs (attrs, context);
   this->points = attrs["points"];
 
   using tokenizer = boost::tokenizer<boost::char_separator<char>>;
-  boost::char_separator<char> sep(" ,");
-  tokenizer tokens(this->points, sep);
+  boost::char_separator<char> sep (" ,");
+  tokenizer tokens (this->points, sep);
 
   double x = 0.0;
   path_t path;
   bool first = true;
-  for (const auto& v : tokens) {
-    double p = parse_double(v);
+  for (const auto &v : tokens) {
+    double p = parse_double (v);
 
     if (first) {
       x = p;
     } else {
-      path.push_back(Eigen::Vector3d(x, p, 0));
+      path.push_back (Eigen::Vector3d (x, p, 0));
     }
     first = !first;
   }
 
-  offset_path(path_list, path, get_stroke_width(), get_stroke_linecap());
+  offset_path (path_list, path, get_stroke_width (), get_stroke_linecap ());
 }
 
 } // namespace libsvg
diff --git a/src/libsvg/polyline.h b/src/libsvg/polyline.h
index 56e47e694..825c9d271 100644
--- a/src/libsvg/polyline.h
+++ b/src/libsvg/polyline.h
@@ -35,14 +35,18 @@ private:
   std::string points;
 
 public:
-  polyline() = default;
+  polyline () = default;
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
-  [[nodiscard]] const std::string& get_name() const override { return polyline::name; }
+  void set_attrs (attr_map_t &attrs, void *context) override;
+  [[nodiscard]] const std::string &get_name () const override {
+    return polyline::name;
+  }
 
   static const std::string name;
 
-  [[nodiscard]] shape *clone() const override { return new polyline(*this); }
+  [[nodiscard]] shape *clone () const override {
+    return new polyline (*this);
+  }
 };
 
-}
+} // namespace libsvg
diff --git a/src/libsvg/rect.cc b/src/libsvg/rect.cc
index 4732d8907..8618ab588 100644
--- a/src/libsvg/rect.cc
+++ b/src/libsvg/rect.cc
@@ -36,7 +36,7 @@
 
 namespace libsvg {
 
-const std::string rect::name("rect");
+const std::string rect::name ("rect");
 
 /**
  * Let rx and ry be length values.
@@ -88,19 +88,17 @@ const std::string rect::name("rect");
  *
  * 9) perform an absolute elliptical arc operation to coordinate (x+rx,y)
  */
-void
-rect::set_attrs(attr_map_t& attrs, void *context)
-{
-  shape::set_attrs(attrs, context); // NOLINT(bugprone-parent-virtual-call)
-  this->x = parse_double(attrs["x"]);
-  this->y = parse_double(attrs["y"]);
-  this->width = parse_double(attrs["width"]);
-  this->height = parse_double(attrs["height"]);
-  this->rx = parse_double(attrs["rx"]);
-  this->ry = parse_double(attrs["ry"]);
+void rect::set_attrs (attr_map_t &attrs, void *context) {
+  shape::set_attrs (attrs, context); // NOLINT(bugprone-parent-virtual-call)
+  this->x = parse_double (attrs["x"]);
+  this->y = parse_double (attrs["y"]);
+  this->width = parse_double (attrs["width"]);
+  this->height = parse_double (attrs["height"]);
+  this->rx = parse_double (attrs["rx"]);
+  this->ry = parse_double (attrs["ry"]);
 
-  bool has_rx = !(std::fabs(rx) < 1e-8);
-  bool has_ry = !(std::fabs(ry) < 1e-8);
+  bool has_rx = !(std::fabs (rx) < 1e-8);
+  bool has_ry = !(std::fabs (ry) < 1e-8);
 
   if (has_rx || has_ry) {
     if (!has_rx) {
@@ -115,50 +113,40 @@ rect::set_attrs(attr_map_t& attrs, void *context)
       this->ry = this->height / 2;
     }
 
-    std::string path = boost::str(boost::format(""
-                                                "M %1%,%2% "
-                                                "H %3% "
-                                                "A %4%,%5% 0 0,1 %6%,%7% "
-                                                "V %8% "
-                                                "A %9%,%10% 0 0,1 %11%,%12% "
-                                                "H %13% "
-                                                "A %14%,%15% 0 0,1 %16%,%17% "
-                                                "V %18% "
-                                                "A %19%,%20% 0 0,1 %21%,%22% "
-                                                "z")
-                                  % (x + rx) % y
-                                  % (x + width - rx)
-                                  % rx % ry % (x + width) % (y + ry)
-                                  % (y + height - ry)
-                                  % rx % ry % (x + width - rx) % (y + height)
-                                  % (x + rx)
-                                  % rx % ry % x % (y + height - ry)
-                                  % (y + ry)
-                                  % rx % ry % (x + rx) % y
-                                  );
+    std::string path = boost::str (boost::format (""
+                                                  "M %1%,%2% "
+                                                  "H %3% "
+                                                  "A %4%,%5% 0 0,1 %6%,%7% "
+                                                  "V %8% "
+                                                  "A %9%,%10% 0 0,1 %11%,%12% "
+                                                  "H %13% "
+                                                  "A %14%,%15% 0 0,1 %16%,%17% "
+                                                  "V %18% "
+                                                  "A %19%,%20% 0 0,1 %21%,%22% "
+                                                  "z") %
+                                   (x + rx) % y % (x + width - rx) % rx % ry % (x + width) % (y + ry) % (y + height - ry) % rx % ry % (x + width - rx) % (y + height) % (x + rx) % rx % ry % x % (y + height - ry) % (y + ry) % rx % ry % (x + rx) % y);
     attrs["d"] = path;
-    path::set_attrs(attrs, context);
+    path::set_attrs (attrs, context);
   } else {
     path_t path;
-    path.push_back(Eigen::Vector3d(get_x(), get_y(), 0));
-    path.push_back(Eigen::Vector3d(get_x() + get_width(), get_y(), 0));
-    path.push_back(Eigen::Vector3d(get_x() + get_width(), get_y() + get_height(), 0));
-    path.push_back(Eigen::Vector3d(get_x(), get_y() + get_height(), 0));
-    path.push_back(Eigen::Vector3d(get_x(), get_y(), 0));
-    path_list.push_back(path);
+    path.push_back (Eigen::Vector3d (get_x (), get_y (), 0));
+    path.push_back (Eigen::Vector3d (get_x () + get_width (), get_y (), 0));
+    path.push_back (Eigen::Vector3d (get_x () + get_width (), get_y () + get_height (), 0));
+    path.push_back (Eigen::Vector3d (get_x (), get_y () + get_height (), 0));
+    path.push_back (Eigen::Vector3d (get_x (), get_y (), 0));
+    path_list.push_back (path);
   }
 }
 
 const std::string
-rect::dump() const
-{
+rect::dump () const {
   std::stringstream s;
-  s << get_name()
+  s << get_name ()
     << ": x = " << this->x
     << ": y = " << this->y
     << ": width = " << this->width
     << ": height = " << this->height;
-  return s.str();
+  return s.str ();
 }
 
 } // namespace libsvg
diff --git a/src/libsvg/rect.h b/src/libsvg/rect.h
index 7130ea178..0b6203538 100644
--- a/src/libsvg/rect.h
+++ b/src/libsvg/rect.h
@@ -38,18 +38,28 @@ protected:
   double ry{0};
 
 public:
-  rect() = default;
+  rect () = default;
 
-  [[nodiscard]] double get_width() const { return width; }
-  [[nodiscard]] double get_height() const { return height; }
-  [[nodiscard]] double get_rx() const { return rx; }
-  [[nodiscard]] double get_ry() const { return ry; }
+  [[nodiscard]] double get_width () const {
+    return width;
+  }
+  [[nodiscard]] double get_height () const {
+    return height;
+  }
+  [[nodiscard]] double get_rx () const {
+    return rx;
+  }
+  [[nodiscard]] double get_ry () const {
+    return ry;
+  }
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
-  [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return rect::name; }
+  void set_attrs (attr_map_t &attrs, void *context) override;
+  [[nodiscard]] const std::string dump () const override;
+  [[nodiscard]] const std::string &get_name () const override {
+    return rect::name;
+  }
 
   static const std::string name;
 };
 
-}
+} // namespace libsvg
diff --git a/src/libsvg/shape.cc b/src/libsvg/shape.cc
index 515aac3c5..5db823b05 100644
--- a/src/libsvg/shape.cc
+++ b/src/libsvg/shape.cc
@@ -59,43 +59,40 @@
 namespace libsvg {
 
 shape *
-shape::create_from_name(const char *name)
-{
+shape::create_from_name (const char *name) {
   if (circle::name == name) {
-    return new circle();
+    return new circle ();
   } else if (ellipse::name == name) {
-    return new ellipse();
+    return new ellipse ();
   } else if (line::name == name) {
-    return new line();
+    return new line ();
   } else if (text::name == name) {
-    return new text();
+    return new text ();
   } else if (tspan::name == name) {
-    return new tspan();
+    return new tspan ();
   } else if (data::name == name) {
-    return new data();
+    return new data ();
   } else if (polygon::name == name) {
-    return new polygon();
+    return new polygon ();
   } else if (polyline::name == name) {
-    return new polyline();
+    return new polyline ();
   } else if (rect::name == name) {
-    return new rect();
+    return new rect ();
   } else if (svgpage::name == name) {
-    return new svgpage();
+    return new svgpage ();
   } else if (path::name == name) {
-    return new path();
+    return new path ();
   } else if (group::name == name) {
-    return new group();
+    return new group ();
   } else if (use::name == name) {
-    return new use();
+    return new use ();
   } else {
     return nullptr;
   }
 }
 
-void
-shape::set_attrs(attr_map_t& attrs, void *context)
-{
-  if (attrs.find("id") != attrs.end()) {
+void shape::set_attrs (attr_map_t &attrs, void *context) {
+  if (attrs.find ("id") != attrs.end ()) {
     this->id = attrs["id"];
   }
   this->transform = attrs["transform"];
@@ -104,10 +101,10 @@ shape::set_attrs(attr_map_t& attrs, void *context)
   this->stroke_linejoin = attrs["stroke-linejoin"];
   this->style = attrs["style"];
 
-  std::string display = get_style("display");
-  if (display.empty()) {
-    const auto it = attrs.find("display");
-    if (it != attrs.end()) {
+  std::string display = get_style ("display");
+  if (display.empty ()) {
+    const auto it = attrs.find ("display");
+    if (it != attrs.end ()) {
       display = it->second;
     }
   }
@@ -116,53 +113,50 @@ shape::set_attrs(attr_map_t& attrs, void *context)
   }
 
   const std::string inkscape_groupmode = attrs["inkscape:groupmode"];
-  if (inkscape_groupmode == "layer" && attrs.find("inkscape:label") != attrs.end()) {
+  if (inkscape_groupmode == "layer" && attrs.find ("inkscape:label") != attrs.end ()) {
     this->layer = attrs["inkscape:label"];
   }
 
-  const auto *ctx = reinterpret_cast<const fnContext *>(context);
-  selected = (ctx->selector) ? ctx->selector(this) : false;
+  const auto *ctx = reinterpret_cast<const fnContext *> (context);
+  selected = (ctx->selector) ? ctx->selector (this) : false;
 }
 
 const std::string
-shape::get_style(const std::string& name) const
-{
+shape::get_style (const std::string &name) const {
   std::vector<std::string> styles;
-  boost::split(styles, this->style, boost::is_any_of(";"));
+  boost::split (styles, this->style, boost::is_any_of (";"));
 
-  for (const auto& style : styles) {
+  for (const auto &style : styles) {
     std::vector<std::string> values;
-    boost::split(values, style, boost::is_any_of(":"));
-    if (values.size() != 2) {
+    boost::split (values, style, boost::is_any_of (":"));
+    if (values.size () != 2) {
       continue;
     }
-    boost::trim(values[0]);
+    boost::trim (values[0]);
     if (name == values[0]) {
-      boost::trim(values[1]);
+      boost::trim (values[1]);
       return values[1];
     }
   }
-  return std::string();
+  return std::string ();
 }
 
 double
-shape::get_stroke_width() const
-{
+shape::get_stroke_width () const {
   double stroke_width;
-  if (this->stroke_width.empty()) {
-    stroke_width = parse_double(get_style("stroke-width"));
+  if (this->stroke_width.empty ()) {
+    stroke_width = parse_double (get_style ("stroke-width"));
   } else {
-    stroke_width = parse_double(this->stroke_width);
+    stroke_width = parse_double (this->stroke_width);
   }
   return stroke_width < 0.01 ? 1 : stroke_width;
 }
 
 Clipper2Lib::EndType
-shape::get_stroke_linecap() const
-{
+shape::get_stroke_linecap () const {
   std::string cap;
-  if (this->stroke_linecap.empty()) {
-    cap = get_style("stroke-linecap");
+  if (this->stroke_linecap.empty ()) {
+    cap = get_style ("stroke-linecap");
   } else {
     cap = this->stroke_linecap;
   }
@@ -178,11 +172,10 @@ shape::get_stroke_linecap() const
 }
 
 Clipper2Lib::JoinType
-shape::get_stroke_linejoin() const
-{
+shape::get_stroke_linejoin () const {
   std::string join;
-  if (this->stroke_linejoin.empty()) {
-    join = get_style("stroke-linejoin");
+  if (this->stroke_linejoin.empty ()) {
+    join = get_style ("stroke-linejoin");
   } else {
     join = this->stroke_linejoin;
   }
@@ -196,50 +189,48 @@ shape::get_stroke_linejoin() const
   return Clipper2Lib::JoinType::Miter;
 }
 
-void
-shape::collect_transform_matrices(std::vector<Eigen::Matrix3d>& matrices, shape *s)
-{
-  std::string transform_arg(s->transform);
+void shape::collect_transform_matrices (std::vector<Eigen::Matrix3d> &matrices, shape *s) {
+  std::string transform_arg (s->transform);
 
-  boost::replace_all(transform_arg, "matrix", "m");
-  boost::replace_all(transform_arg, "translate", "t");
-  boost::replace_all(transform_arg, "scale", "s");
-  boost::replace_all(transform_arg, "rotate", "r");
-  boost::replace_all(transform_arg, "skewX", "x");
-  boost::replace_all(transform_arg, "skewY", "y");
+  boost::replace_all (transform_arg, "matrix", "m");
+  boost::replace_all (transform_arg, "translate", "t");
+  boost::replace_all (transform_arg, "scale", "s");
+  boost::replace_all (transform_arg, "rotate", "r");
+  boost::replace_all (transform_arg, "skewX", "x");
+  boost::replace_all (transform_arg, "skewY", "y");
 
   std::string commands = "mtsrxy";
 
   using tokenizer = boost::tokenizer<boost::char_separator<char>>;
-  boost::char_separator<char> sep(" ,()", commands.c_str());
-  tokenizer tokens(transform_arg, sep);
+  boost::char_separator<char> sep (" ,()", commands.c_str ());
+  tokenizer tokens (transform_arg, sep);
 
   transformation *t = nullptr;
   std::vector<transformation *> transformations;
-  for (const auto& v : tokens) {
-    if ((v.length() == 1) && (commands.find(v) != std::string::npos)) {
+  for (const auto &v : tokens) {
+    if ((v.length () == 1) && (commands.find (v) != std::string::npos)) {
       if (t != nullptr) {
-        transformations.push_back(t);
+        transformations.push_back (t);
         t = nullptr;
       }
       switch (v[0]) {
       case 'm':
-        t = new matrix();
+        t = new matrix ();
         break;
       case 't':
-        t = new translate();
+        t = new translate ();
         break;
       case 's':
-        t = new scale();
+        t = new scale ();
         break;
       case 'r':
-        t = new rotate();
+        t = new rotate ();
         break;
       case 'x':
-        t = new skew_x();
+        t = new skew_x ();
         break;
       case 'y':
-        t = new skew_y();
+        t = new skew_y ();
         break;
       default:
         std::cout << "unknown transform op " << v << std::endl;
@@ -247,111 +238,107 @@ shape::collect_transform_matrices(std::vector<Eigen::Matrix3d>& matrices, shape
       }
     } else {
       if (t) {
-        t->add_arg(v);
+        t->add_arg (v);
       }
     }
   }
   if (t != nullptr) {
-    transformations.push_back(t);
+    transformations.push_back (t);
   }
 
-  for (auto it = transformations.rbegin(); it != transformations.rend(); ++it) {
+  for (auto it = transformations.rbegin (); it != transformations.rend (); ++it) {
     transformation *t = *it;
-    std::vector<Eigen::Matrix3d> m = t->get_matrices();
-    matrices.insert(matrices.begin(), m.rbegin(), m.rend());
+    std::vector<Eigen::Matrix3d> m = t->get_matrices ();
+    matrices.insert (matrices.begin (), m.rbegin (), m.rend ());
     delete t;
   }
 }
 
-bool
-shape::is_excluded() const
-{
-  for (const shape *s = this; s != nullptr; s = s->get_parent()) {
-    if (s->selected) return false;
-    if (s->excluded) return true;
+bool shape::is_excluded () const {
+  for (const shape *s = this; s != nullptr; s = s->get_parent ()) {
+    if (s->selected)
+      return false;
+    if (s->excluded)
+      return true;
   }
   return true;
 }
 
-void
-shape::apply_transform()
-{
+void shape::apply_transform () {
   std::vector<Eigen::Matrix3d> matrices;
-  for (shape *s = this; s->get_parent() != nullptr; s = s->get_parent()) {
-    collect_transform_matrices(matrices, s);
+  for (shape *s = this; s->get_parent () != nullptr; s = s->get_parent ()) {
+    collect_transform_matrices (matrices, s);
   }
 
   path_list_t result_list;
-  for (const auto& p : path_list) {
-    result_list.push_back(path_t());
-    for (const auto& v : p) {
-      Eigen::Vector3d result(v.x(), v.y(), 1);
-      for (auto it3 = matrices.rbegin(); it3 != matrices.rend(); ++it3) {
+  for (const auto &p : path_list) {
+    result_list.push_back (path_t ());
+    for (const auto &v : p) {
+      Eigen::Vector3d result (v.x (), v.y (), 1);
+      for (auto it3 = matrices.rbegin (); it3 != matrices.rend (); ++it3) {
         result = *it3 * result;
       }
 
-      result_list.back().push_back(result);
+      result_list.back ().push_back (result);
     }
   }
   path_list = result_list;
 }
 
-void
-shape::offset_path(path_list_t& path_list, path_t& path, double stroke_width, Clipper2Lib::EndType stroke_linecap) {
-  const int scale_bits = ClipperUtils::scaleBitsFromPrecision();
-  const double scale = std::ldexp(1.0, scale_bits);
+void shape::offset_path (path_list_t &path_list, path_t &path, double stroke_width, Clipper2Lib::EndType stroke_linecap) {
+  const int scale_bits = ClipperUtils::scaleBitsFromPrecision ();
+  const double scale = std::ldexp (1.0, scale_bits);
 
   Clipper2Lib::Path64 line;
-  for (const auto& v : path) {
-    line.emplace_back(v.x() * scale, v.y() * scale);
+  for (const auto &v : path) {
+    line.emplace_back (v.x () * scale, v.y () * scale);
   }
 
   Clipper2Lib::ClipperOffset co;
-  co.AddPath(line, get_stroke_linejoin(), stroke_linecap);
+  co.AddPath (line, get_stroke_linejoin (), stroke_linecap);
   Clipper2Lib::Paths64 result;
-  co.Execute(stroke_width * scale / 2, result);
+  co.Execute (stroke_width * scale / 2, result);
 
-  for (const auto& p : result) {
-    path_list.push_back(path_t());
-    for (const auto& point : p) {
-      path_list.back().push_back(Eigen::Vector3d(point.x / scale, point.y / scale, 0));
+  for (const auto &p : result) {
+    path_list.push_back (path_t ());
+    for (const auto &point : p) {
+      path_list.back ().push_back (Eigen::Vector3d (point.x / scale, point.y / scale, 0));
     }
-    path_list.back().push_back(Eigen::Vector3d(p[0].x / scale, p[0].y / scale, 0));
+    path_list.back ().push_back (Eigen::Vector3d (p[0].x / scale, p[0].y / scale, 0));
   }
 }
 
-void
-shape::draw_ellipse(path_t& path, double x, double y, double rx, double ry, void *context) {
-  const auto *fValues = reinterpret_cast<const fnContext *>(context);
-  double rmax = fmax(rx, ry);
-  unsigned long fn = Calc::get_fragments_from_r(rmax, fValues->fn, fValues->fs, fValues->fa);
-  if (fn < 40) fn = 40;   // preserve the old minimum value
+void shape::draw_ellipse (path_t &path, double x, double y, double rx, double ry, void *context) {
+  const auto *fValues = reinterpret_cast<const fnContext *> (context);
+  double rmax = fmax (rx, ry);
+  unsigned long fn = Calc::get_fragments_from_r (rmax, fValues->fn, fValues->fs, fValues->fa);
+  if (fn < 40)
+    fn = 40; // preserve the old minimum value
   for (unsigned long idx = 1; idx <= fn; ++idx) {
     const double a = idx * 360.0 / fn;
-    const double xx = rx * sin_degrees(a) + x;
-    const double yy = ry * cos_degrees(a) + y;
-    path.push_back(Eigen::Vector3d(xx, yy, 0));
+    const double xx = rx * sin_degrees (a) + x;
+    const double yy = ry * cos_degrees (a) + y;
+    path.push_back (Eigen::Vector3d (xx, yy, 0));
   }
 }
 
 std::vector<std::shared_ptr<shape>>
-shape::clone_children() {
+shape::clone_children () {
   std::vector<std::shared_ptr<shape>> ret_vector;
-  std::vector<shape *> children_backup = this->get_children();
-  this->children.clear();
-  for (const auto& c : children_backup) {
-    shape *clone = c->clone();
-    this->add_child(clone);
-    auto cloned_children = clone->clone_children();
-    ret_vector.push_back(std::shared_ptr<shape>(clone));
-    ret_vector.insert(ret_vector.end(), cloned_children.begin(), cloned_children.end());
+  std::vector<shape *> children_backup = this->get_children ();
+  this->children.clear ();
+  for (const auto &c : children_backup) {
+    shape *clone = c->clone ();
+    this->add_child (clone);
+    auto cloned_children = clone->clone_children ();
+    ret_vector.push_back (std::shared_ptr<shape> (clone));
+    ret_vector.insert (ret_vector.end (), cloned_children.begin (), cloned_children.end ());
   }
   return ret_vector;
 }
 
-std::ostream& operator<<(std::ostream& os, const shape& s)
-{
-  return os << s.dump() << " | id = '" << s.id.value_or("") << "', transform = '" << s.transform << "'";
+std::ostream &operator<< (std::ostream &os, const shape &s) {
+  return os << s.dump () << " | id = '" << s.id.value_or ("") << "', transform = '" << s.transform << "'";
 }
 
 } // namespace libsvg
diff --git a/src/libsvg/shape.h b/src/libsvg/shape.h
index 183bc49b0..38bc6ff52 100644
--- a/src/libsvg/shape.h
+++ b/src/libsvg/shape.h
@@ -47,15 +47,25 @@ class shape;
 // ccox - I don't like putting this here, but the svg library code did not plan ahead for app customization.
 // And this is one of the few sensible places to put it without adding new header files.
 struct fnContext {
-  fnContext(double fNN, double fSS, double fAA) : fn(fNN), fs(fSS), fa(fAA) {
+  fnContext (double fNN, double fSS, double fAA)
+    : fn (fNN)
+    , fs (fSS)
+    , fa (fAA) {
+  }
+  bool match (bool val) {
+    if (val)
+      matches++;
+    return val;
+  }
+  bool has_matches () {
+    return matches.load () > 0;
   }
-  bool match(bool val) { if (val) matches++; return val; }
-  bool has_matches() { return matches.load() > 0; }
 
   double fn;
   double fs;
   double fa;
   std::function<bool (const libsvg::shape *)> selector;
+
 private:
   std::atomic<int> matches{0};
 };
@@ -86,49 +96,78 @@ protected:
   bool excluded{false};
   bool selected{false};
 
-  [[nodiscard]] double get_stroke_width() const;
-  [[nodiscard]] Clipper2Lib::EndType get_stroke_linecap() const;
-  [[nodiscard]] Clipper2Lib::JoinType get_stroke_linejoin() const;
-  [[nodiscard]] const std::string get_style(const std::string& name) const;
-  void draw_ellipse(path_t& path, double x, double y, double rx, double ry, void *context);
-  void offset_path(path_list_t& path_list, path_t& path, double stroke_width, Clipper2Lib::EndType stroke_linecap);
-  void collect_transform_matrices(std::vector<Eigen::Matrix3d>& matrices, shape *s);
+  [[nodiscard]] double get_stroke_width () const;
+  [[nodiscard]] Clipper2Lib::EndType get_stroke_linecap () const;
+  [[nodiscard]] Clipper2Lib::JoinType get_stroke_linejoin () const;
+  [[nodiscard]] const std::string get_style (const std::string &name) const;
+  void draw_ellipse (path_t &path, double x, double y, double rx, double ry, void *context);
+  void offset_path (path_list_t &path_list, path_t &path, double stroke_width, Clipper2Lib::EndType stroke_linecap);
+  void collect_transform_matrices (std::vector<Eigen::Matrix3d> &matrices, shape *s);
 
 public:
-  shape() = default;
-  virtual ~shape() = default;
+  shape () = default;
+  virtual ~shape () = default;
 
-  [[nodiscard]] virtual shape *get_parent() const { return parent; }
-  virtual void set_parent(shape *s) { parent = s; }
-  virtual void add_child(shape *s) { children.push_back(s); s->set_parent(this); }
-  [[nodiscard]] virtual const std::vector<shape *>& get_children() const { return children; }
+  [[nodiscard]] virtual shape *get_parent () const {
+    return parent;
+  }
+  virtual void set_parent (shape *s) {
+    parent = s;
+  }
+  virtual void add_child (shape *s) {
+    children.push_back (s);
+    s->set_parent (this);
+  }
+  [[nodiscard]] virtual const std::vector<shape *> &get_children () const {
+    return children;
+  }
 
-  [[nodiscard]] virtual bool has_id() const { return id.is_initialized(); }
-  [[nodiscard]] virtual const std::string& get_id() const { return id.get(); }
-  [[nodiscard]] virtual const std::string get_id_or_default(const std::string& def = "") const { return id.get_value_or(def); }
-  [[nodiscard]] virtual bool has_layer() const { return layer.is_initialized(); }
-  [[nodiscard]] virtual const std::string& get_layer() const { return layer.get(); }
-  [[nodiscard]] virtual double get_x() const { return x; }
-  [[nodiscard]] virtual double get_y() const { return y; }
+  [[nodiscard]] virtual bool has_id () const {
+    return id.is_initialized ();
+  }
+  [[nodiscard]] virtual const std::string &get_id () const {
+    return id.get ();
+  }
+  [[nodiscard]] virtual const std::string get_id_or_default (const std::string &def = "") const {
+    return id.get_value_or (def);
+  }
+  [[nodiscard]] virtual bool has_layer () const {
+    return layer.is_initialized ();
+  }
+  [[nodiscard]] virtual const std::string &get_layer () const {
+    return layer.get ();
+  }
+  [[nodiscard]] virtual double get_x () const {
+    return x;
+  }
+  [[nodiscard]] virtual double get_y () const {
+    return y;
+  }
 
-  [[nodiscard]] virtual const path_list_t& get_path_list() const { return path_list; }
+  [[nodiscard]] virtual const path_list_t &get_path_list () const {
+    return path_list;
+  }
 
-  [[nodiscard]] virtual bool is_excluded() const;
-  [[nodiscard]] virtual bool is_container() const { return false; }
+  [[nodiscard]] virtual bool is_excluded () const;
+  [[nodiscard]] virtual bool is_container () const {
+    return false;
+  }
 
-  virtual void apply_transform();
+  virtual void apply_transform ();
 
-  [[nodiscard]] virtual const std::string& get_name() const = 0;
-  virtual void set_attrs(attr_map_t& attrs, void *context);
-  [[nodiscard]] virtual const std::string dump() const { return ""; }
+  [[nodiscard]] virtual const std::string &get_name () const = 0;
+  virtual void set_attrs (attr_map_t &attrs, void *context);
+  [[nodiscard]] virtual const std::string dump () const {
+    return "";
+  }
 
-  static shape *create_from_name(const char *name);
+  static shape *create_from_name (const char *name);
 
-  [[nodiscard]] virtual shape *clone() const = 0;
-  std::vector<std::shared_ptr<shape>> clone_children();
+  [[nodiscard]] virtual shape *clone () const = 0;
+  std::vector<std::shared_ptr<shape>> clone_children ();
 
 private:
-  friend std::ostream& operator<<(std::ostream& os, const shape& s);
+  friend std::ostream &operator<< (std::ostream &os, const shape &s);
 };
 
 } // namespace libsvg
diff --git a/src/libsvg/svgpage.cc b/src/libsvg/svgpage.cc
index 5401dd64a..a668e59b9 100644
--- a/src/libsvg/svgpage.cc
+++ b/src/libsvg/svgpage.cc
@@ -29,34 +29,31 @@
 #include <string>
 #include <iostream>
 
-
 namespace libsvg {
 
-const std::string svgpage::name("svg");
+const std::string svgpage::name ("svg");
 
-svgpage::svgpage() : width({0.0, unit_t::UNDEFINED}), height({0.0, unit_t::UNDEFINED})
-{
+svgpage::svgpage ()
+  : width ({0.0, unit_t::UNDEFINED})
+  , height ({0.0, unit_t::UNDEFINED}) {
 }
 
-void
-svgpage::set_attrs(attr_map_t& attrs, void *context)
-{
+void svgpage::set_attrs (attr_map_t &attrs, void *context) {
   this->x = 0;
   this->y = 0;
-  this->width = parse_length(attrs["width"]);
-  this->height = parse_length(attrs["height"]);
-  this->viewbox = parse_viewbox(attrs["viewBox"]);
-  this->alignment = parse_alignment(attrs["preserveAspectRatio"]);
+  this->width = parse_length (attrs["width"]);
+  this->height = parse_length (attrs["height"]);
+  this->viewbox = parse_viewbox (attrs["viewBox"]);
+  this->alignment = parse_alignment (attrs["preserveAspectRatio"]);
 
-  const auto *ctx = reinterpret_cast<const fnContext *>(context);
-  selected = (ctx->selector) ? ctx->selector(this) : false;
+  const auto *ctx = reinterpret_cast<const fnContext *> (context);
+  selected = (ctx->selector) ? ctx->selector (this) : false;
 }
 
 const std::string
-svgpage::dump() const
-{
+svgpage::dump () const {
   std::stringstream s;
-  s << get_name()
+  s << get_name ()
     << ": x = " << this->x
     << ": y = " << this->y
     << ": width = " << this->width
@@ -69,7 +66,7 @@ svgpage::dump() const
     << ": alignment = " << this->alignment.x
     << "," << this->alignment.y
     << (this->alignment.meet ? " meet" : " slice");
-  return s.str();
+  return s.str ();
 }
 
 } // namespace libsvg
diff --git a/src/libsvg/svgpage.h b/src/libsvg/svgpage.h
index 7f5f76637..a9380c038 100644
--- a/src/libsvg/svgpage.h
+++ b/src/libsvg/svgpage.h
@@ -39,21 +39,35 @@ protected:
   alignment_t alignment;
 
 public:
-  svgpage();
+  svgpage ();
 
-  [[nodiscard]] const length_t& get_width() const { return width; }
-  [[nodiscard]] const length_t& get_height() const { return height; }
-  [[nodiscard]] const viewbox_t& get_viewbox() const { return viewbox; }
-  [[nodiscard]] const alignment_t& get_alignment() const { return alignment; }
-  [[nodiscard]] bool is_container() const override { return true; }
+  [[nodiscard]] const length_t &get_width () const {
+    return width;
+  }
+  [[nodiscard]] const length_t &get_height () const {
+    return height;
+  }
+  [[nodiscard]] const viewbox_t &get_viewbox () const {
+    return viewbox;
+  }
+  [[nodiscard]] const alignment_t &get_alignment () const {
+    return alignment;
+  }
+  [[nodiscard]] bool is_container () const override {
+    return true;
+  }
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
-  [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return svgpage::name; }
+  void set_attrs (attr_map_t &attrs, void *context) override;
+  [[nodiscard]] const std::string dump () const override;
+  [[nodiscard]] const std::string &get_name () const override {
+    return svgpage::name;
+  }
 
   static const std::string name;
 
-  [[nodiscard]] shape *clone() const override { return new svgpage(*this); }
+  [[nodiscard]] shape *clone () const override {
+    return new svgpage (*this);
+  }
 };
 
-}
+} // namespace libsvg
diff --git a/src/libsvg/text.cc b/src/libsvg/text.cc
index 0ebad3c89..f3d553347 100644
--- a/src/libsvg/text.cc
+++ b/src/libsvg/text.cc
@@ -30,28 +30,25 @@
 
 namespace libsvg {
 
-const std::string text::name("text");
+const std::string text::name ("text");
 
-void
-text::set_attrs(attr_map_t& attrs, void *context)
-{
-  shape::set_attrs(attrs, context);
-  this->x = parse_double(attrs["x"]);
-  this->y = parse_double(attrs["y"]);
-  this->dx = parse_double(attrs["dx"]);
-  this->dy = parse_double(attrs["dy"]);
+void text::set_attrs (attr_map_t &attrs, void *context) {
+  shape::set_attrs (attrs, context);
+  this->x = parse_double (attrs["x"]);
+  this->y = parse_double (attrs["y"]);
+  this->dx = parse_double (attrs["dx"]);
+  this->dy = parse_double (attrs["dy"]);
 }
 
 const std::string
-text::dump() const
-{
+text::dump () const {
   std::stringstream s;
-  s << get_name()
+  s << get_name ()
     << ": x = " << this->x
     << ": y = " << this->y
     << ": dx = " << this->dx
     << ": dy = " << this->dy;
-  return s.str();
+  return s.str ();
 }
 
 } // namespace libsvg
diff --git a/src/libsvg/text.h b/src/libsvg/text.h
index ebf75ab3c..077ba8fc0 100644
--- a/src/libsvg/text.h
+++ b/src/libsvg/text.h
@@ -40,24 +40,42 @@ private:
   int font_size{0};
 
 public:
-  text() = default;
+  text () = default;
 
-  [[nodiscard]] bool is_container() const override { return true; }
+  [[nodiscard]] bool is_container () const override {
+    return true;
+  }
 
-  [[nodiscard]] double get_dx() const { return dx; } // NOLINT(bugprone-virtual-near-miss)
-  [[nodiscard]] double get_dy() const { return dy; } // NOLINT(bugprone-virtual-near-miss)
-  [[nodiscard]] double get_rotate() const { return rotate; }
-  [[nodiscard]] double get_text_length() const { return text_length; }
-  [[nodiscard]] const std::string& get_font_family() const { return font_family; }
-  [[nodiscard]] int get_font_size() const { return font_size; }
+  [[nodiscard]] double get_dx () const {
+    return dx;
+  } // NOLINT(bugprone-virtual-near-miss)
+  [[nodiscard]] double get_dy () const {
+    return dy;
+  } // NOLINT(bugprone-virtual-near-miss)
+  [[nodiscard]] double get_rotate () const {
+    return rotate;
+  }
+  [[nodiscard]] double get_text_length () const {
+    return text_length;
+  }
+  [[nodiscard]] const std::string &get_font_family () const {
+    return font_family;
+  }
+  [[nodiscard]] int get_font_size () const {
+    return font_size;
+  }
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
-  [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return text::name; }
+  void set_attrs (attr_map_t &attrs, void *context) override;
+  [[nodiscard]] const std::string dump () const override;
+  [[nodiscard]] const std::string &get_name () const override {
+    return text::name;
+  }
 
   static const std::string name;
 
-  [[nodiscard]] shape *clone() const override { return new text(*this); }
+  [[nodiscard]] shape *clone () const override {
+    return new text (*this);
+  }
 };
 
 } // namespace libsvg
diff --git a/src/libsvg/transformation.cc b/src/libsvg/transformation.cc
index 49821e063..3554e7029 100644
--- a/src/libsvg/transformation.cc
+++ b/src/libsvg/transformation.cc
@@ -34,25 +34,23 @@
 
 namespace libsvg {
 
-void
-transformation::add_arg(const std::string& arg)
-{
-  double d = parse_double(arg);
-  args.push_back(d);
+void transformation::add_arg (const std::string &arg) {
+  double d = parse_double (arg);
+  args.push_back (d);
 }
 
 const std::string
-transformation::get_args() const {
+transformation::get_args () const {
   std::ostringstream str;
-  for (unsigned int a = 0; a < args.size(); ++a) {
+  for (unsigned int a = 0; a < args.size (); ++a) {
     str << ((a == 0) ? "(" : ", ") << args[a];
   }
   str << ")";
-  return str.str();
+  return str.str ();
 }
 
-matrix::matrix() : transformation("m", "matrix")
-{
+matrix::matrix ()
+  : transformation ("m", "matrix") {
 }
 
 /**
@@ -61,26 +59,24 @@ matrix::matrix() : transformation("m", "matrix")
  * is equivalent to applying the transformation matrix [a b c d e f].
  */
 std::vector<Eigen::Matrix3d>
-matrix::get_matrices()
-{
-  if (args.size() != 6) {
+matrix::get_matrices () {
+  if (args.size () != 6) {
     std::cout << "invalid arguments for matrix" << std::endl;
     return {};
   }
 
   Eigen::Matrix3d m;
-  m <<
-    args[0], args[2], args[4],
+  m << args[0], args[2], args[4],
     args[1], args[3], args[5],
     0, 0, 1;
 
   std::vector<Eigen::Matrix3d> result;
-  result.push_back(m);
+  result.push_back (m);
   return result;
 }
 
-translate::translate() : transformation("t", "translate")
-{
+translate::translate ()
+  : transformation ("t", "translate") {
 }
 
 /**
@@ -88,29 +84,27 @@ translate::translate() : transformation("t", "translate")
  * If <ty> is not provided, it is assumed to be zero.
  */
 std::vector<Eigen::Matrix3d>
-translate::get_matrices()
-{
-  if ((args.size() < 1) || (args.size() > 2)) {
-    std::cout << "invalid arguments for " << get_name() << std::endl;
+translate::get_matrices () {
+  if ((args.size () < 1) || (args.size () > 2)) {
+    std::cout << "invalid arguments for " << get_name () << std::endl;
     return {};
   }
 
   double tx = args[0];
-  double ty = args.size() > 1 ? args[1] : 0;
+  double ty = args.size () > 1 ? args[1] : 0;
 
   Eigen::Matrix3d m;
-  m <<
-    1, 0, tx,
+  m << 1, 0, tx,
     0, 1, ty,
     0, 0, 1;
 
   std::vector<Eigen::Matrix3d> result;
-  result.push_back(m);
+  result.push_back (m);
   return result;
 }
 
-scale::scale() : transformation("s", "scale")
-{
+scale::scale ()
+  : transformation ("s", "scale") {
 }
 
 /**
@@ -118,29 +112,27 @@ scale::scale() : transformation("s", "scale")
  * If <sy> is not provided, it is assumed to be equal to <sx>.
  */
 std::vector<Eigen::Matrix3d>
-scale::get_matrices()
-{
-  if ((args.size() < 1) || (args.size() > 2)) {
-    std::cout << "invalid arguments for " << get_name() << std::endl;
+scale::get_matrices () {
+  if ((args.size () < 1) || (args.size () > 2)) {
+    std::cout << "invalid arguments for " << get_name () << std::endl;
     return {};
   }
 
   double sx = args[0];
-  double sy = args.size() > 1 ? args[1] : args[0];
+  double sy = args.size () > 1 ? args[1] : args[0];
 
   Eigen::Matrix3d m;
-  m <<
-    sx,  0, 0,
+  m << sx, 0, 0,
     0, sy, 0,
-    0,  0, 1;
+    0, 0, 1;
 
   std::vector<Eigen::Matrix3d> result;
-  result.push_back(m);
+  result.push_back (m);
   return result;
 }
 
-rotate::rotate() : transformation("r", "rotate")
-{
+rotate::rotate ()
+  : transformation ("r", "rotate") {
 }
 
 /**
@@ -155,14 +147,13 @@ rotate::rotate() : transformation("r", "rotate")
  * translate(-<cx>, -<cy>).
  */
 std::vector<Eigen::Matrix3d>
-rotate::get_matrices()
-{
-  if ((args.size() != 1) && (args.size() != 3)) {
-    std::cout << "invalid arguments for " << get_name() << std::endl;
+rotate::get_matrices () {
+  if ((args.size () != 1) && (args.size () != 3)) {
+    std::cout << "invalid arguments for " << get_name () << std::endl;
     return {};
   }
 
-  bool has_center = args.size() == 3;
+  bool has_center = args.size () == 3;
 
   double angle = args[0];
   double cx = has_center ? args[1] : 0;
@@ -172,80 +163,74 @@ rotate::get_matrices()
 
   if (has_center) {
     Eigen::Matrix3d t;
-    t <<
-      1, 0, -cx,
+    t << 1, 0, -cx,
       0, 1, -cy,
       0, 0, 1;
-    result.push_back(t);
+    result.push_back (t);
   }
 
-  result.push_back(rotate_degrees(angle));
+  result.push_back (rotate_degrees (angle));
 
   if (has_center) {
     Eigen::Matrix3d t;
-    t <<
-      1, 0, cx,
+    t << 1, 0, cx,
       0, 1, cy,
       0, 0, 1;
-    result.push_back(t);
+    result.push_back (t);
   }
 
   return result;
 }
 
-skew_x::skew_x() : transformation("x", "skew_x")
-{
+skew_x::skew_x ()
+  : transformation ("x", "skew_x") {
 }
 
 /**
  * skewX(<skew-angle>), which specifies a skew transformation along the x-axis.
  */
 std::vector<Eigen::Matrix3d>
-skew_x::get_matrices()
-{
-  if (args.size() != 1) {
-    std::cout << "invalid arguments for " << get_name() << std::endl;
+skew_x::get_matrices () {
+  if (args.size () != 1) {
+    std::cout << "invalid arguments for " << get_name () << std::endl;
     return {};
   }
 
   double angle = args[0];
 
   Eigen::Matrix3d m;
-  m <<
-    1, tan_degrees(angle), 0,
-    0, 1,                  0,
-    0, 0,                  1;
+  m << 1, tan_degrees (angle), 0,
+    0, 1, 0,
+    0, 0, 1;
 
   std::vector<Eigen::Matrix3d> result;
-  result.push_back(m);
+  result.push_back (m);
   return result;
 }
 
-skew_y::skew_y() : transformation("y", "skew_y")
-{
+skew_y::skew_y ()
+  : transformation ("y", "skew_y") {
 }
 
 /**
  * skewY(<skew-angle>), which specifies a skew transformation along the y-axis.
  */
 std::vector<Eigen::Matrix3d>
-skew_y::get_matrices()
-{
-  if (args.size() != 1) {
-    std::cout << "invalid arguments for " << get_name() << std::endl;
+skew_y::get_matrices () {
+  if (args.size () != 1) {
+    std::cout << "invalid arguments for " << get_name () << std::endl;
     return {};
   }
 
   double angle = args[0];
 
   Eigen::Matrix3d m;
-  m <<
-    1, 0, 0,
-    tan_degrees(angle), 1, 0,
+  m << 1, 0, 0,
+    tan_degrees (angle), 1, 0,
     0, 0, 1;
 
   std::vector<Eigen::Matrix3d> result;
-  result.push_back(m);
+  result.push_back (m);
   return result;
 }
 
diff --git a/src/libsvg/transformation.h b/src/libsvg/transformation.h
index d1c46a4e0..87d9fd8dd 100644
--- a/src/libsvg/transformation.h
+++ b/src/libsvg/transformation.h
@@ -38,67 +38,74 @@ class transformation
 private:
   const std::string op;
   const std::string name;
+
 protected:
   std::vector<double> args;
 
 public:
-  transformation(std::string op, std::string name) : op(std::move(op)), name(std::move(name)) { }
-  virtual ~transformation() = default;
-
-  [[nodiscard]] const std::string& get_op() const { return op; }
-  [[nodiscard]] const std::string& get_name() const { return name; }
-  [[nodiscard]] const std::string get_args() const;
-
-  void add_arg(const std::string& arg);
-  virtual std::vector<Eigen::Matrix3d> get_matrices() = 0;
+  transformation (std::string op, std::string name)
+    : op (std::move (op))
+    , name (std::move (name)) {}
+  virtual ~transformation () = default;
+
+  [[nodiscard]] const std::string &get_op () const {
+    return op;
+  }
+  [[nodiscard]] const std::string &get_name () const {
+    return name;
+  }
+  [[nodiscard]] const std::string get_args () const;
+
+  void add_arg (const std::string &arg);
+  virtual std::vector<Eigen::Matrix3d> get_matrices () = 0;
 };
 
 class matrix : public transformation
 {
 public:
-  matrix();
+  matrix ();
 
-  std::vector<Eigen::Matrix3d> get_matrices() override;
+  std::vector<Eigen::Matrix3d> get_matrices () override;
 };
 
 class translate : public transformation
 {
 public:
-  translate();
+  translate ();
 
-  std::vector<Eigen::Matrix3d> get_matrices() override;
+  std::vector<Eigen::Matrix3d> get_matrices () override;
 };
 
 class scale : public transformation
 {
 public:
-  scale();
+  scale ();
 
-  std::vector<Eigen::Matrix3d> get_matrices() override;
+  std::vector<Eigen::Matrix3d> get_matrices () override;
 };
 
 class rotate : public transformation
 {
 public:
-  rotate();
+  rotate ();
 
-  std::vector<Eigen::Matrix3d> get_matrices() override;
+  std::vector<Eigen::Matrix3d> get_matrices () override;
 };
 
 class skew_x : public transformation
 {
 public:
-  skew_x();
+  skew_x ();
 
-  std::vector<Eigen::Matrix3d> get_matrices() override;
+  std::vector<Eigen::Matrix3d> get_matrices () override;
 };
 
 class skew_y : public transformation
 {
 public:
-  skew_y();
+  skew_y ();
 
-  std::vector<Eigen::Matrix3d> get_matrices() override;
+  std::vector<Eigen::Matrix3d> get_matrices () override;
 };
 
 } // namespace libsvg
diff --git a/src/libsvg/tspan.cc b/src/libsvg/tspan.cc
index e54287b14..3d7ea5de9 100644
--- a/src/libsvg/tspan.cc
+++ b/src/libsvg/tspan.cc
@@ -31,28 +31,25 @@
 
 namespace libsvg {
 
-const std::string tspan::name("tspan");
+const std::string tspan::name ("tspan");
 
-void
-tspan::set_attrs(attr_map_t& attrs, void *context)
-{
-  shape::set_attrs(attrs, context);
-  this->x = parse_double(attrs["x"]);
-  this->y = parse_double(attrs["y"]);
-  this->dx = parse_double(attrs["dx"]);
-  this->dy = parse_double(attrs["dy"]);
+void tspan::set_attrs (attr_map_t &attrs, void *context) {
+  shape::set_attrs (attrs, context);
+  this->x = parse_double (attrs["x"]);
+  this->y = parse_double (attrs["y"]);
+  this->dx = parse_double (attrs["dx"]);
+  this->dy = parse_double (attrs["dy"]);
 }
 
 const std::string
-tspan::dump() const
-{
+tspan::dump () const {
   std::stringstream s;
-  s << get_name()
+  s << get_name ()
     << ": x = " << this->x
     << ": y = " << this->y
     << ": dx = " << this->dx
     << ": dy = " << this->dy;
-  return s.str();
+  return s.str ();
 }
 
 } // namespace libsvg
diff --git a/src/libsvg/tspan.h b/src/libsvg/tspan.h
index d6ea4a23e..ec54b4455 100644
--- a/src/libsvg/tspan.h
+++ b/src/libsvg/tspan.h
@@ -40,24 +40,42 @@ private:
   int font_size{0};
 
 public:
-  tspan() = default;
+  tspan () = default;
 
-  [[nodiscard]] bool is_container() const override { return true; }
+  [[nodiscard]] bool is_container () const override {
+    return true;
+  }
 
-  [[nodiscard]] double get_dx() const { return dx; } // NOLINT(bugprone-virtual-near-miss)
-  [[nodiscard]] double get_dy() const { return dy; } // NOLINT(bugprone-virtual-near-miss)
-  [[nodiscard]] double get_rotate() const { return rotate; }
-  [[nodiscard]] double get_text_length() const { return text_length; }
-  [[nodiscard]] const std::string& get_font_family() const { return font_family; }
-  [[nodiscard]] int get_font_size() const { return font_size; }
+  [[nodiscard]] double get_dx () const {
+    return dx;
+  } // NOLINT(bugprone-virtual-near-miss)
+  [[nodiscard]] double get_dy () const {
+    return dy;
+  } // NOLINT(bugprone-virtual-near-miss)
+  [[nodiscard]] double get_rotate () const {
+    return rotate;
+  }
+  [[nodiscard]] double get_text_length () const {
+    return text_length;
+  }
+  [[nodiscard]] const std::string &get_font_family () const {
+    return font_family;
+  }
+  [[nodiscard]] int get_font_size () const {
+    return font_size;
+  }
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
-  [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return tspan::name; }
+  void set_attrs (attr_map_t &attrs, void *context) override;
+  [[nodiscard]] const std::string dump () const override;
+  [[nodiscard]] const std::string &get_name () const override {
+    return tspan::name;
+  }
 
   static const std::string name;
 
-  [[nodiscard]] shape *clone() const override { return new tspan(*this); }
+  [[nodiscard]] shape *clone () const override {
+    return new tspan (*this);
+  }
 };
 
 } // namespace libsvg
diff --git a/src/libsvg/use.cc b/src/libsvg/use.cc
index 50f281f86..7b63406b1 100644
--- a/src/libsvg/use.cc
+++ b/src/libsvg/use.cc
@@ -35,65 +35,60 @@
 
 namespace libsvg {
 
-const std::string use::name("use");
+const std::string use::name ("use");
 
-void
-use::set_attrs(attr_map_t& attrs, void *context)
-{
-  shape::set_attrs(attrs, context);
-  this->x = parse_double(attrs["x"]);
-  this->y = parse_double(attrs["y"]);
+void use::set_attrs (attr_map_t &attrs, void *context) {
+  shape::set_attrs (attrs, context);
+  this->x = parse_double (attrs["x"]);
+  this->y = parse_double (attrs["y"]);
 
   //Note: width, and height have no effect on use elements, unless the element referenced has a viewbox - i.e. they only have an effect when use refers to a svg or symbol element.
   //Lets store them, but I am not going to use them.
-  this->width = parse_double(attrs["width"]);
-  this->height = parse_double(attrs["height"]);
+  this->width = parse_double (attrs["width"]);
+  this->height = parse_double (attrs["height"]);
 
   std::string temp_href = attrs["href"];
-  if (attrs["href"].empty() && !attrs["xlink:href"].empty()) {
+  if (attrs["href"].empty () && !attrs["xlink:href"].empty ()) {
     temp_href = attrs["xlink:href"];
   }
 
   if (this->href != temp_href) {
     this->href = temp_href;
-    if (href.rfind('#', 0) != 0) {
-      printf("<use> can only use references to ids in the href field (starting with #). Error in element type %s with id: %s\n", this->get_name().c_str(), this->get_id_or_default().c_str());
+    if (href.rfind ('#', 0) != 0) {
+      printf ("<use> can only use references to ids in the href field (starting with #). Error in element type %s with id: %s\n", this->get_name ().c_str (), this->get_id_or_default ().c_str ());
     }
   }
 
   //apply the x/y coordinates to all the children by using a transform
   std::stringstream s;
   s << this->transform << " translate(" << this->x << "," << this->y << ")";
-  this->transform = s.str();
+  this->transform = s.str ();
 }
 
 const std::string
-use::get_href_id() const
-{
-  if (href.rfind('#', 0) != 0) {
+use::get_href_id () const {
+  if (href.rfind ('#', 0) != 0) {
     return {};
   }
-  return href.substr(1); //remove the #
+  return href.substr (1); //remove the #
 }
 
 std::vector<std::shared_ptr<shape>>
-use::set_clone_child(shape *child)
-{
-  shape *copy = child->clone();
-  copy->set_parent(this);
-  auto cloned_objects = copy->clone_children();
-  cloned_objects.insert(cloned_objects.begin(), std::shared_ptr<shape>(copy));
+use::set_clone_child (shape *child) {
+  shape *copy = child->clone ();
+  copy->set_parent (this);
+  auto cloned_objects = copy->clone_children ();
+  cloned_objects.insert (cloned_objects.begin (), std::shared_ptr<shape> (copy));
   return cloned_objects;
 }
 
 const std::string
-use::dump() const
-{
+use::dump () const {
   std::stringstream s;
-  s << get_name()
+  s << get_name ()
     << ": x = " << this->x
     << ": y = " << this->y;
-  return s.str();
+  return s.str ();
 }
 
 } // namespace libsvg
diff --git a/src/libsvg/use.h b/src/libsvg/use.h
index 2e65b742a..f78eebce8 100644
--- a/src/libsvg/use.h
+++ b/src/libsvg/use.h
@@ -39,23 +39,31 @@ protected:
   double height;
 
 public:
-  use() = default;
+  use () = default;
 
-  [[nodiscard]] bool is_container() const override { return false; }
+  [[nodiscard]] bool is_container () const override {
+    return false;
+  }
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
-  [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return use::name; }
+  void set_attrs (attr_map_t &attrs, void *context) override;
+  [[nodiscard]] const std::string dump () const override;
+  [[nodiscard]] const std::string &get_name () const override {
+    return use::name;
+  }
 
   static const std::string name;
 
-  [[nodiscard]] const std::string get_href() const { return href; }
-  [[nodiscard]] const std::string get_href_id() const;
+  [[nodiscard]] const std::string get_href () const {
+    return href;
+  }
+  [[nodiscard]] const std::string get_href_id () const;
 
   // I'm hoping here something else can find the href for us.
-  std::vector<std::shared_ptr<shape>> set_clone_child(shape *child);
+  std::vector<std::shared_ptr<shape>> set_clone_child (shape *child);
 
-  [[nodiscard]] shape *clone() const override { return new use(*this); }
+  [[nodiscard]] shape *clone () const override {
+    return new use (*this);
+  }
 };
 
 } // namespace libsvg
diff --git a/src/libsvg/util.cc b/src/libsvg/util.cc
index d18db191e..6aa2a70d3 100644
--- a/src/libsvg/util.cc
+++ b/src/libsvg/util.cc
@@ -34,29 +34,26 @@
 #include <boost/fusion/adapted/struct/adapt_struct.hpp>
 #include <boost/fusion/include/adapt_struct.hpp>
 
-
-BOOST_FUSION_ADAPT_STRUCT(libsvg::length_struct, (double, number)(std::string, unit))
+BOOST_FUSION_ADAPT_STRUCT (libsvg::length_struct, (double, number) (std::string, unit))
 
 namespace libsvg {
 
 namespace qi = boost::spirit::qi;
 
 double
-parse_double(const std::string& number)
-{
-  std::string::const_iterator iter = number.begin(), end = number.end();
+parse_double (const std::string &number) {
+  std::string::const_iterator iter = number.begin (), end = number.end ();
 
   qi::real_parser<double, qi::real_policies<double>> double_parser;
 
   double d = 0.0;
-  const bool result = boost::spirit::qi::parse(iter, end, double_parser, d);
+  const bool result = boost::spirit::qi::parse (iter, end, double_parser, d);
 
   return result && iter == end ? d : 0;
 }
 
 static unit_t
-get_unit(const std::string& value)
-{
+get_unit (const std::string &value) {
   if (value == "em") {
     return unit_t::EM;
   } else if (value == "ex") {
@@ -81,48 +78,46 @@ get_unit(const std::string& value)
 }
 
 const length_t
-parse_length(const std::string& value)
-{
-  std::string::const_iterator it = value.begin(), end = value.end();
+parse_length (const std::string &value) {
+  std::string::const_iterator it = value.begin (), end = value.end ();
 
-  qi::rule<std::string::const_iterator, length_struct(), qi::space_type> length;
-  qi::rule<std::string::const_iterator, double()> number;
-  qi::rule<std::string::const_iterator, std::vector<char>()> unit;
+  qi::rule<std::string::const_iterator, length_struct (), qi::space_type> length;
+  qi::rule<std::string::const_iterator, double ()> number;
+  qi::rule<std::string::const_iterator, std::vector<char> ()> unit;
 
   length = number >> -unit;
   number = qi::double_;
-  unit = qi::string("em") | qi::string("ex") | qi::string("px") | qi::string("in") | qi::string("cm") | qi::string("mm") | qi::string("pt") | qi::string("pc") | qi::string("%");
+  unit = qi::string ("em") | qi::string ("ex") | qi::string ("px") | qi::string ("in") | qi::string ("cm") | qi::string ("mm") | qi::string ("pt") | qi::string ("pc") | qi::string ("%");
 
   libsvg::length_struct parsed;
-  qi::phrase_parse(it, end, length, qi::space, parsed);
+  qi::phrase_parse (it, end, length, qi::space, parsed);
 
   length_t result{0.0, unit_t::UNDEFINED};
-  if ((it != value.begin()) && (it == end)) {
+  if ((it != value.begin ()) && (it == end)) {
     result.number = parsed.number;
-    result.unit = get_unit(parsed.unit);
+    result.unit = get_unit (parsed.unit);
   }
 
   return result;
 }
 
 const viewbox_t
-parse_viewbox(const std::string& value)
-{
-  std::string::const_iterator it = value.begin(), end = value.end();
+parse_viewbox (const std::string &value) {
+  std::string::const_iterator it = value.begin (), end = value.end ();
 
-  qi::rule<std::string::const_iterator, std::vector<double>(), qi::space_type> viewbox;
-  qi::rule<std::string::const_iterator, double()> number;
+  qi::rule<std::string::const_iterator, std::vector<double> (), qi::space_type> viewbox;
+  qi::rule<std::string::const_iterator, double ()> number;
   qi::rule<std::string::const_iterator> sep;
 
   viewbox = number >> -sep >> number >> -sep >> number >> -sep >> number;
   number = qi::double_;
-  sep = qi::char_(',');
+  sep = qi::char_ (',');
 
   std::vector<double> parsed;
-  qi::phrase_parse(it, end, viewbox, qi::space, parsed);
+  qi::phrase_parse (it, end, viewbox, qi::space, parsed);
 
   viewbox_t result{0.0, 0.0, 0.0, 0.0, false};
-  if ((it != value.begin()) && (it == end) && (parsed.size() == 4) && (parsed[2] >= 0.0) && (parsed[3] >= 0.0)) {
+  if ((it != value.begin ()) && (it == end) && (parsed.size () == 4) && (parsed[2] >= 0.0) && (parsed[3] >= 0.0)) {
     result.x = parsed[0];
     result.y = parsed[1];
     result.width = parsed[2];
@@ -134,34 +129,30 @@ parse_viewbox(const std::string& value)
 }
 
 const alignment_t
-parse_alignment(const std::string& value)
-{
-  std::string::const_iterator it = value.begin(), end = value.end();
+parse_alignment (const std::string &value) {
+  std::string::const_iterator it = value.begin (), end = value.end ();
 
-  qi::rule<std::string::const_iterator, std::vector<std::string>(), qi::space_type> alignment;
-  qi::rule<std::string::const_iterator, std::vector<char>()> defer;
-  qi::rule<std::string::const_iterator, std::vector<char>()> align;
-  qi::rule<std::string::const_iterator, std::vector<char>()> meet_or_slice;
+  qi::rule<std::string::const_iterator, std::vector<std::string> (), qi::space_type> alignment;
+  qi::rule<std::string::const_iterator, std::vector<char> ()> defer;
+  qi::rule<std::string::const_iterator, std::vector<char> ()> align;
+  qi::rule<std::string::const_iterator, std::vector<char> ()> meet_or_slice;
 
   alignment = -qi::as_string[defer] >> qi::as_string[align] >> -qi::as_string[meet_or_slice];
-  defer = qi::string("defer");
-  align = qi::string("none")
-    | qi::string("xMinYMin") | qi::string("xMidYMin") | qi::string("xMaxYMin")
-    | qi::string("xMinYMid") | qi::string("xMidYMid") | qi::string("xMaxYMid")
-    | qi::string("xMinYMax") | qi::string("xMidYMax") | qi::string("xMaxYMax");
-  meet_or_slice = qi::string("meet") | qi::string("slice");
+  defer = qi::string ("defer");
+  align = qi::string ("none") | qi::string ("xMinYMin") | qi::string ("xMidYMin") | qi::string ("xMaxYMin") | qi::string ("xMinYMid") | qi::string ("xMidYMid") | qi::string ("xMaxYMid") | qi::string ("xMinYMax") | qi::string ("xMidYMax") | qi::string ("xMaxYMax");
+  meet_or_slice = qi::string ("meet") | qi::string ("slice");
 
   std::vector<std::string> parsed;
-  qi::phrase_parse(it, end, alignment, qi::space, parsed);
+  qi::phrase_parse (it, end, alignment, qi::space, parsed);
 
   alignment_t result{align_t::MID, align_t::MID, false, true};
-  if ((it != value.begin()) && (it == end) && parsed.size() > 0) {
+  if ((it != value.begin ()) && (it == end) && parsed.size () > 0) {
     unsigned int idx = 0;
     if (parsed[0] == "defer") {
       idx++;
       result.defer = true;
     }
-    if (parsed.size() > idx) {
+    if (parsed.size () > idx) {
       if (parsed[idx] == "none") {
         result.x = align_t::NONE;
         result.y = align_t::NONE;
@@ -195,15 +186,14 @@ parse_alignment(const std::string& value)
       }
     }
     idx++;
-    if (parsed.size() > idx) {
+    if (parsed.size () > idx) {
       result.meet = parsed[idx] == "meet";
     }
   }
   return result;
 }
 
-std::ostream& operator<<(std::ostream& stream, const unit_t& unit)
-{
+std::ostream &operator<< (std::ostream &stream, const unit_t &unit) {
   switch (unit) {
   case unit_t::EM:
     stream << "em";
@@ -241,14 +231,12 @@ std::ostream& operator<<(std::ostream& stream, const unit_t& unit)
   return stream;
 }
 
-std::ostream& operator<<(std::ostream& stream, const length_t& length)
-{
+std::ostream &operator<< (std::ostream &stream, const length_t &length) {
   stream << length.number << length.unit;
   return stream;
 }
 
-std::ostream& operator<<(std::ostream& stream, const align_t& align)
-{
+std::ostream &operator<< (std::ostream &stream, const align_t &align) {
   switch (align) {
   case align_t::MIN:
     stream << "min";
diff --git a/src/libsvg/util.h b/src/libsvg/util.h
index c8973fd2f..b7d1c2429 100644
--- a/src/libsvg/util.h
+++ b/src/libsvg/util.h
@@ -41,9 +41,23 @@ namespace libsvg {
 // 1pc = 16px or user units
 // 1pc = 1/6in
 //
-enum class unit_t { UNDEFINED, NONE, PERCENT, EM, EX, PX, IN, CM, MM, PT, PC };
+enum class unit_t { UNDEFINED,
+                    NONE,
+                    PERCENT,
+                    EM,
+                    EX,
+                    PX,
+                    IN,
+                    CM,
+                    MM,
+                    PT,
+                    PC };
 
-enum class align_t { UNDEFINED, NONE, MIN, MID, MAX };
+enum class align_t { UNDEFINED,
+                     NONE,
+                     MIN,
+                     MID,
+                     MAX };
 
 struct length_struct {
   double number;
@@ -70,13 +84,13 @@ struct alignment_t {
   bool meet;
 };
 
-double parse_double(const std::string& number);
-const length_t parse_length(const std::string& value);
-const viewbox_t parse_viewbox(const std::string& value);
-const alignment_t parse_alignment(const std::string& value);
+double parse_double (const std::string &number);
+const length_t parse_length (const std::string &value);
+const viewbox_t parse_viewbox (const std::string &value);
+const alignment_t parse_alignment (const std::string &value);
 
-std::ostream& operator<<(std::ostream& stream, const unit_t& unit);
-std::ostream& operator<<(std::ostream& stream, const length_t& length);
-std::ostream& operator<<(std::ostream& stream, const align_t& align);
+std::ostream &operator<< (std::ostream &stream, const unit_t &unit);
+std::ostream &operator<< (std::ostream &stream, const length_t &length);
+std::ostream &operator<< (std::ostream &stream, const align_t &align);
 
 } // namespace libsvg
diff --git a/src/openscad.cc b/src/openscad.cc
index b9be46a5b..bb98cacd5 100644
--- a/src/openscad.cc
+++ b/src/openscad.cc
@@ -123,31 +123,32 @@ namespace {
 
 bool arg_info = false;
 
-}  // namespace
+} // namespace
 
 class Echostream
 {
 public:
-  Echostream(std::ostream& stream) : stream(stream)
-  {
-    set_output_handler(&Echostream::output, nullptr, this);
+  Echostream (std::ostream &stream)
+    : stream (stream) {
+    set_output_handler (&Echostream::output, nullptr, this);
   }
-  Echostream(const std::string& filename) : fstream(filename), stream(fstream)
-  {
-    set_output_handler(&Echostream::output, nullptr, this);
+  Echostream (const std::string &filename)
+    : fstream (filename)
+    , stream (fstream) {
+    set_output_handler (&Echostream::output, nullptr, this);
   }
-  static void output(const Message& msgObj, void *userdata)
-  {
-    auto self = static_cast<Echostream *>(userdata);
-    self->stream << msgObj.str() << "\n";
+  static void output (const Message &msgObj, void *userdata) {
+    auto self = static_cast<Echostream *> (userdata);
+    self->stream << msgObj.str () << "\n";
   }
-  ~Echostream() {
-    if (fstream.is_open()) fstream.close();
+  ~Echostream () {
+    if (fstream.is_open ())
+      fstream.close ();
   }
 
 private:
   std::ofstream fstream;
-  std::ostream& stream;
+  std::ostream &stream;
 };
 
 struct AnimateArgs {
@@ -156,19 +157,18 @@ struct AnimateArgs {
   unsigned shard = 1;
 };
 
-struct CommandLine
-{
+struct CommandLine {
   const bool is_stdin;
-  const std::string& filename;
+  const std::string &filename;
   const bool is_stdout;
   std::string output_file;
-  const fs::path& original_path;
-  const std::string& parameterFile;
-  const std::string& setName;
-  const ViewOptions& viewOptions;
-  const Camera& camera;
+  const fs::path &original_path;
+  const std::string &parameterFile;
+  const std::string &setName;
+  const ViewOptions &viewOptions;
+  const Camera &camera;
   const boost::optional<FileFormat> export_format;
-  const CmdLineExportOptions& exportOptions;
+  const CmdLineExportOptions &exportOptions;
   const AnimateArgs animate;
   const std::vector<std::string> summaryOptions;
   const std::string summaryFile;
@@ -177,87 +177,81 @@ struct CommandLine
 namespace {
 
 #define STRINGIFY(x) #x
-#define TOSTRING(x) STRINGIFY(x)
+#define TOSTRING(x) STRINGIFY (x)
 
 #ifndef OPENSCAD_NOGUI
-bool useGUI()
-{
+bool useGUI () {
 #ifdef Q_OS_X11
   // see <http://qt.nokia.com/doc/4.5/qapplication.html#QApplication-2>:
   // On X11, the window system is initialized if GUIenabled is true. If GUIenabled
   // is false, the application does not connect to the X server. On Windows and
   // Macintosh, currently the window system is always initialized, regardless of the
   // value of GUIenabled. This may change in future versions of Qt.
-  return getenv("DISPLAY") != 0;
+  return getenv ("DISPLAY") != 0;
 #else
   return true;
 #endif
 }
 #endif // OPENSCAD_NOGUI
 
-bool checkAndExport(const std::shared_ptr<const Geometry>& root_geom, unsigned dimensions,
-                    ExportInfo& exportInfo, const bool is_stdout, const std::string& filename)
-{
-  if (root_geom->getDimension() != dimensions) {
-    LOG("Current top level object is not a %1$dD object.", dimensions);
+bool checkAndExport (const std::shared_ptr<const Geometry> &root_geom, unsigned dimensions,
+                     ExportInfo &exportInfo, const bool is_stdout, const std::string &filename) {
+  if (root_geom->getDimension () != dimensions) {
+    LOG ("Current top level object is not a %1$dD object.", dimensions);
     return false;
   }
-  if (root_geom->isEmpty()) {
-    LOG("Current top level object is empty.");
+  if (root_geom->isEmpty ()) {
+    LOG ("Current top level object is empty.");
     return false;
   }
 
   if (is_stdout) {
-    exportFileStdOut(root_geom, exportInfo);
+    exportFileStdOut (root_geom, exportInfo);
   } else {
-    exportFileByName(root_geom, filename, exportInfo);
+    exportFileByName (root_geom, filename, exportInfo);
   }
   return true;
 }
 
-void help(const char *arg0, const po::options_description& desc, bool failure = false)
-{
-  const fs::path progpath(arg0);
-  LOG("Usage: %1$s [options] file.scad\n%2$s", progpath.filename().string(), desc);
-  exit(failure ? 1 : 0);
+void help (const char *arg0, const po::options_description &desc, bool failure = false) {
+  const fs::path progpath (arg0);
+  LOG ("Usage: %1$s [options] file.scad\n%2$s", progpath.filename ().string (), desc);
+  exit (failure ? 1 : 0);
 }
 
 template <std::size_t size>
-void help_export(const std::array<const Settings::SettingsEntryBase *, size>& options) {
-  LOG("Section '%1$s':", options.at(0)->category());
+void help_export (const std::array<const Settings::SettingsEntryBase *, size> &options) {
+  LOG ("Section '%1$s':", options.at (0)->category ());
 
   for (const auto option : options) {
-    const auto [type, values] = option->help();
-    LOG("  - %1$s (%2$s): %3$s", option->name(), type, values);
+    const auto [type, values] = option->help ();
+    LOG ("  - %1$s (%2$s): %3$s", option->name (), type, values);
   }
 }
 
-void help_export()
-{
-  LOG("OpenSCAD version %1$s\n", TOSTRING(OPENSCAD_VERSION));
-  LOG("List of settings that can be given using the -O option using the");
-  LOG("format '<section>/<key>=value', e.g.:");
-  LOG("openscad -O export-pdf/paper-size=a6 -O export-pdf/show-grid=false\n");
-  help_export(Settings::SettingsExportPdf::cmdline);
-  help_export(Settings::SettingsExport3mf::cmdline);
-  exit(0);
+void help_export () {
+  LOG ("OpenSCAD version %1$s\n", TOSTRING (OPENSCAD_VERSION));
+  LOG ("List of settings that can be given using the -O option using the");
+  LOG ("format '<section>/<key>=value', e.g.:");
+  LOG ("openscad -O export-pdf/paper-size=a6 -O export-pdf/show-grid=false\n");
+  help_export (Settings::SettingsExportPdf::cmdline);
+  help_export (Settings::SettingsExport3mf::cmdline);
+  exit (0);
 }
 
-void version()
-{
-  LOG("OpenSCAD version %1$s", TOSTRING(OPENSCAD_VERSION));
-  exit(0);
+void version () {
+  LOG ("OpenSCAD version %1$s", TOSTRING (OPENSCAD_VERSION));
+  exit (0);
 }
 
-int info()
-{
-  std::cout << LibraryInfo::info() << "\n\n";
+int info () {
+  std::cout << LibraryInfo::info () << "\n\n";
 
   try {
-    OffscreenView const glview(512, 512);
-    std::cout << glview.getRendererInfo() << "\n";
-  } catch (const OffscreenViewException& ex) {
-    LOG("Can't create OpenGL OffscreenView: %1$s. Exiting.\n", ex.what());
+    OffscreenView const glview (512, 512);
+    std::cout << glview.getRendererInfo () << "\n";
+  } catch (const OffscreenViewException &ex) {
+    LOG ("Can't create OpenGL OffscreenView: %1$s. Exiting.\n", ex.what ());
     return 1;
   }
 
@@ -265,115 +259,113 @@ int info()
 }
 
 template <typename F>
-bool with_output(const bool is_stdout, const std::string& filename, const F& f, std::ios::openmode mode = std::ios::out)
-{
+bool with_output (const bool is_stdout, const std::string &filename, const F &f, std::ios::openmode mode = std::ios::out) {
   if (is_stdout) {
 #ifdef _WIN32
-    if ((mode& std::ios::binary) != 0) {
-      _setmode(_fileno(stdout), _O_BINARY);
+    if ((mode & std::ios::binary) != 0) {
+      _setmode (_fileno (stdout), _O_BINARY);
     }
 #endif
-    f(std::cout);
+    f (std::cout);
     return true;
   }
-  std::ofstream fstream(filename, mode);
-  if (!fstream.is_open()) {
-    LOG("Can't open file \"%1$s\" for export", filename);
+  std::ofstream fstream (filename, mode);
+  if (!fstream.is_open ()) {
+    LOG ("Can't open file \"%1$s\" for export", filename);
     return false;
   } else {
-    f(fstream);
+    f (fstream);
     return true;
   }
 }
 
-AnimateArgs get_animate(const po::variables_map& vm) {
+AnimateArgs get_animate (const po::variables_map &vm) {
   AnimateArgs animate;
-  if (vm.count("animate")) {
-    animate.frames = vm["animate"].as<unsigned>();
+  if (vm.count ("animate")) {
+    animate.frames = vm["animate"].as<unsigned> ();
   }
-  if (vm.count("animate_sharding")) {
+  if (vm.count ("animate_sharding")) {
     std::vector<std::string> strs;
-    boost::split(strs, vm["animate_sharding"].as<std::string>(),
-                 boost::is_any_of("/"));
-    if (strs.size() != 2) {
-      LOG("--animate_sharding requires <shard>/<num_shards>");
-      exit(1);
+    boost::split (strs, vm["animate_sharding"].as<std::string> (),
+                  boost::is_any_of ("/"));
+    if (strs.size () != 2) {
+      LOG ("--animate_sharding requires <shard>/<num_shards>");
+      exit (1);
     }
     try {
-      animate.shard = boost::lexical_cast<unsigned>(strs[0]);
-      animate.num_shards = boost::lexical_cast<unsigned>(strs[1]);
-    } catch (const boost::bad_lexical_cast&) {
-      LOG("--animate_sharding parameters need to be positive integers");
-      exit(1);
+      animate.shard = boost::lexical_cast<unsigned> (strs[0]);
+      animate.num_shards = boost::lexical_cast<unsigned> (strs[1]);
+    } catch (const boost::bad_lexical_cast &) {
+      LOG ("--animate_sharding parameters need to be positive integers");
+      exit (1);
     }
     if (animate.shard > animate.num_shards || animate.shard == 0) {
-      LOG("--animate_sharding: shard needs to be in range <1..num_shards>");
-      exit(1);
+      LOG ("--animate_sharding: shard needs to be in range <1..num_shards>");
+      exit (1);
     }
   }
   return animate;
 }
 
-Camera get_camera(const po::variables_map& vm)
-{
+Camera get_camera (const po::variables_map &vm) {
   Camera camera;
 
-  if (vm.count("camera")) {
+  if (vm.count ("camera")) {
     std::vector<std::string> strs;
     std::vector<double> cam_parameters;
-    boost::split(strs, vm["camera"].as<std::string>(), boost::is_any_of(","));
-    if (strs.size() == 6 || strs.size() == 7) {
+    boost::split (strs, vm["camera"].as<std::string> (), boost::is_any_of (","));
+    if (strs.size () == 6 || strs.size () == 7) {
       try {
-        for (const auto& s : strs) {
-          cam_parameters.push_back(boost::lexical_cast<double>(s));
+        for (const auto &s : strs) {
+          cam_parameters.push_back (boost::lexical_cast<double> (s));
         }
-        camera.setup(cam_parameters);
-      } catch (boost::bad_lexical_cast&) {
-        LOG("Camera setup requires numbers as parameters");
+        camera.setup (cam_parameters);
+      } catch (boost::bad_lexical_cast &) {
+        LOG ("Camera setup requires numbers as parameters");
       }
     } else {
-      LOG("Camera setup requires either 7 numbers for Gimbal Camera or 6 numbers for Vector Camera");
-      exit(1);
+      LOG ("Camera setup requires either 7 numbers for Gimbal Camera or 6 numbers for Vector Camera");
+      exit (1);
     }
   } else {
     camera.viewall = true;
     camera.autocenter = true;
   }
 
-  if (vm.count("viewall")) {
+  if (vm.count ("viewall")) {
     camera.viewall = true;
   }
 
-  if (vm.count("autocenter")) {
+  if (vm.count ("autocenter")) {
     camera.autocenter = true;
   }
 
-  if (vm.count("projection")) {
-    auto proj = vm["projection"].as<std::string>();
+  if (vm.count ("projection")) {
+    auto proj = vm["projection"].as<std::string> ();
     if (proj == "o" || proj == "ortho" || proj == "orthogonal") {
       camera.projection = Camera::ProjectionType::ORTHOGONAL;
     } else if (proj == "p" || proj == "perspective") {
       camera.projection = Camera::ProjectionType::PERSPECTIVE;
     } else {
-      LOG("projection needs to be 'o' or 'p' for ortho or perspective\n");
-      exit(1);
+      LOG ("projection needs to be 'o' or 'p' for ortho or perspective\n");
+      exit (1);
     }
   }
 
-  if (vm.count("imgsize")) {
+  if (vm.count ("imgsize")) {
     std::vector<std::string> strs;
-    boost::split(strs, vm["imgsize"].as<std::string>(), boost::is_any_of(","));
-    if (strs.size() != 2) {
-      LOG("Need 2 numbers for imgsize");
-      exit(1);
+    boost::split (strs, vm["imgsize"].as<std::string> (), boost::is_any_of (","));
+    if (strs.size () != 2) {
+      LOG ("Need 2 numbers for imgsize");
+      exit (1);
     } else {
       try {
-        int const w = boost::lexical_cast<int>(strs[0]);
-        int const h = boost::lexical_cast<int>(strs[1]);
+        int const w = boost::lexical_cast<int> (strs[0]);
+        int const h = boost::lexical_cast<int> (strs[1]);
         camera.pixel_width = w;
         camera.pixel_height = h;
-      } catch (boost::bad_lexical_cast&) {
-        LOG("Need 2 numbers for imgsize");
+      } catch (boost::bad_lexical_cast &) {
+        LOG ("Need 2 numbers for imgsize");
       }
     }
   }
@@ -381,25 +373,24 @@ Camera get_camera(const po::variables_map& vm)
   return camera;
 }
 
-int do_export(const CommandLine& cmd, const RenderVariables& render_variables, FileFormat export_format, SourceFile *root_file)
-{
-  auto filename_str = fs::path(cmd.output_file).generic_string();
+int do_export (const CommandLine &cmd, const RenderVariables &render_variables, FileFormat export_format, SourceFile *root_file) {
+  auto filename_str = fs::path (cmd.output_file).generic_string ();
   // Avoid possibility of fs::absolute throwing when passed an empty path
-  auto fpath = cmd.filename.empty() ? fs::current_path() : fs::absolute(fs::path(cmd.filename));
-  auto fparent = fpath.parent_path();
+  auto fpath = cmd.filename.empty () ? fs::current_path () : fs::absolute (fs::path (cmd.filename));
+  auto fparent = fpath.parent_path ();
 
   // set CWD relative to source file
-  fs::current_path(fparent);
+  fs::current_path (fparent);
 
-  EvaluationSession session{fparent.string()};
-  ContextHandle<BuiltinContext> builtin_context{Context::create<BuiltinContext>(&session)};
-  render_variables.applyToContext(builtin_context);
+  EvaluationSession session{fparent.string ()};
+  ContextHandle<BuiltinContext> builtin_context{Context::create<BuiltinContext> (&session)};
+  render_variables.applyToContext (builtin_context);
 
 #ifdef DEBUG
-  PRINTDB("BuiltinContext:\n%s", builtin_context->dump());
+  PRINTDB ("BuiltinContext:\n%s", builtin_context->dump ());
 #endif
 
-  AbstractNode::resetIndexCounter();
+  AbstractNode::resetIndexCounter ();
   std::shared_ptr<const FileContext> file_context;
   std::shared_ptr<AbstractNode> absolute_root_node;
 
@@ -408,29 +399,29 @@ int do_export(const CommandLine& cmd, const RenderVariables& render_variables, F
     absolute_root_node = python_result_node;
   } else {
 #endif
-  absolute_root_node = root_file->instantiate(*builtin_context, &file_context);
+    absolute_root_node = root_file->instantiate (*builtin_context, &file_context);
 #ifdef ENABLE_PYTHON
-}
+  }
 #endif
 
   Camera camera = cmd.camera;
   if (file_context) {
-    camera.updateView(file_context, true);
+    camera.updateView (file_context, true);
   }
 
   // restore CWD after module instantiation finished
-  fs::current_path(cmd.original_path);
+  fs::current_path (cmd.original_path);
 
   // Do we have an explicit root node (! modifier)?
   std::shared_ptr<const AbstractNode> root_node;
   const Location *nextLocation = nullptr;
-  if (!(root_node = find_root_tag(absolute_root_node, &nextLocation))) {
+  if (!(root_node = find_root_tag (absolute_root_node, &nextLocation))) {
     root_node = absolute_root_node;
   }
   if (nextLocation) {
-    LOG(message_group::Warning, *nextLocation, builtin_context->documentRoot(), "More than one Root Modifier (!)");
+    LOG (message_group::Warning, *nextLocation, builtin_context->documentRoot (), "More than one Root Modifier (!)");
   }
-  Tree tree(root_node, fparent.string());
+  Tree tree (root_node, fparent.string ());
 
   if (export_format == FileFormat::CSG) {
     // https://github.com/openscad/openscad/issues/128
@@ -438,225 +429,226 @@ int do_export(const CommandLine& cmd, const RenderVariables& render_variables, F
     // statements become relative. But unfortunately they become relative to
     // the current working dir and neither to the location of the input nor
     // the output.
-    fs::current_path(fparent); // Force exported filenames to be relative to document path
-    with_output(cmd.is_stdout, filename_str, [&tree, root_node](std::ostream& stream) {
-        stream << tree.getString(*root_node, "\t") << "\n";
-      });
-    fs::current_path(cmd.original_path);
+    fs::current_path (fparent); // Force exported filenames to be relative to document path
+    with_output (cmd.is_stdout, filename_str, [&tree, root_node] (std::ostream &stream) {
+      stream << tree.getString (*root_node, "\t") << "\n";
+    });
+    fs::current_path (cmd.original_path);
   } else if (export_format == FileFormat::AST) {
-    fs::current_path(fparent); // Force exported filenames to be relative to document path
-    with_output(cmd.is_stdout, filename_str, [root_file](std::ostream& stream) {
-        stream << root_file->dump("");
-      });
-    fs::current_path(cmd.original_path);
+    fs::current_path (fparent); // Force exported filenames to be relative to document path
+    with_output (cmd.is_stdout, filename_str, [root_file] (std::ostream &stream) {
+      stream << root_file->dump ("");
+    });
+    fs::current_path (cmd.original_path);
   } else if (export_format == FileFormat::PARAM) {
-    with_output(cmd.is_stdout, filename_str, [&root_file, &fpath](std::ostream& stream) {
-        export_param(root_file, fpath, stream);
-      });
+    with_output (cmd.is_stdout, filename_str, [&root_file, &fpath] (std::ostream &stream) {
+      export_param (root_file, fpath, stream);
+    });
   } else if (export_format == FileFormat::TERM) {
-    CSGTreeEvaluator csgRenderer(tree);
-    auto root_raw_term = csgRenderer.buildCSGTree(*root_node);
-    with_output(cmd.is_stdout, filename_str, [root_raw_term](std::ostream& stream) {
-        if (!root_raw_term || root_raw_term->isEmptySet()) {
-          stream << "No top-level CSG object\n";
-        } else {
-          stream << root_raw_term->dump() << "\n";
-        }
-      });
+    CSGTreeEvaluator csgRenderer (tree);
+    auto root_raw_term = csgRenderer.buildCSGTree (*root_node);
+    with_output (cmd.is_stdout, filename_str, [root_raw_term] (std::ostream &stream) {
+      if (!root_raw_term || root_raw_term->isEmptySet ()) {
+        stream << "No top-level CSG object\n";
+      } else {
+        stream << root_raw_term->dump () << "\n";
+      }
+    });
   } else if (export_format == FileFormat::ECHO) {
     // echo -> don't need to evaluate any geometry
   } else {
     // start measuring render time
     RenderStatistic renderStatistic;
-    GeometryEvaluator geomevaluator(tree);
+    GeometryEvaluator geomevaluator (tree);
     std::unique_ptr<OffscreenView> glview;
     std::shared_ptr<const Geometry> root_geom;
     if ((export_format == FileFormat::ECHO || export_format == FileFormat::PNG) && (cmd.viewOptions.renderer == RenderType::OPENCSG || cmd.viewOptions.renderer == RenderType::THROWNTOGETHER)) {
       // OpenCSG or throwntogether png -> just render a preview
-      glview = prepare_preview(tree, cmd.viewOptions, camera);
-      if (!glview) return 1;
+      glview = prepare_preview (tree, cmd.viewOptions, camera);
+      if (!glview)
+        return 1;
     } else {
       // Force creation of concrete geometry (mostly for testing)
       // FIXME: Consider adding MANIFOLD as a valid --render argument and ViewOption, to be able to distinguish from CGAL
 
       constexpr bool allownef = true;
-      root_geom = geomevaluator.evaluateGeometry(*tree.root(), allownef);
-      if (!root_geom) root_geom = std::make_shared<PolySet>(3);
-      if (cmd.viewOptions.renderer == RenderType::BACKEND_SPECIFIC && root_geom->getDimension() == 3) {
-        if (auto geomlist = std::dynamic_pointer_cast<const GeometryList>(root_geom)) {
-          auto flatlist = geomlist->flatten();
-          for (auto& child : flatlist) {
-            if (child.second->getDimension() == 3) {
-              child.second = GeometryUtils::getBackendSpecificGeometry(child.second);
+      root_geom = geomevaluator.evaluateGeometry (*tree.root (), allownef);
+      if (!root_geom)
+        root_geom = std::make_shared<PolySet> (3);
+      if (cmd.viewOptions.renderer == RenderType::BACKEND_SPECIFIC && root_geom->getDimension () == 3) {
+        if (auto geomlist = std::dynamic_pointer_cast<const GeometryList> (root_geom)) {
+          auto flatlist = geomlist->flatten ();
+          for (auto &child : flatlist) {
+            if (child.second->getDimension () == 3) {
+              child.second = GeometryUtils::getBackendSpecificGeometry (child.second);
             }
           }
-          root_geom = std::make_shared<GeometryList>(flatlist);
+          root_geom = std::make_shared<GeometryList> (flatlist);
         } else {
-          root_geom = GeometryUtils::getBackendSpecificGeometry(root_geom);
-          assert(root_geom != nullptr);
+          root_geom = GeometryUtils::getBackendSpecificGeometry (root_geom);
+          assert (root_geom != nullptr);
         }
-        LOG("Converted to backend-specific geometry");
+        LOG ("Converted to backend-specific geometry");
       }
     }
 
     const std::string input_filename = cmd.is_stdin ? "<stdin>" : cmd.filename;
-    const int dim = fileformat::is3D(export_format) ? 3 : fileformat::is2D(export_format) ? 2 : 0;
-    ExportInfo exportInfo = createExportInfo(export_format, fileformat::info(export_format), input_filename, &cmd.camera, cmd.exportOptions);
-    if (dim > 0 && !checkAndExport(root_geom, dim, exportInfo, cmd.is_stdout, filename_str)) {
+    const int dim = fileformat::is3D (export_format) ? 3 : fileformat::is2D (export_format) ? 2
+                                                                                            : 0;
+    ExportInfo exportInfo = createExportInfo (export_format, fileformat::info (export_format), input_filename, &cmd.camera, cmd.exportOptions);
+    if (dim > 0 && !checkAndExport (root_geom, dim, exportInfo, cmd.is_stdout, filename_str)) {
       return 1;
     }
 
     if (export_format == FileFormat::PNG) {
       bool success = true;
-      bool const wrote = with_output(cmd.is_stdout, filename_str, [&success, &root_geom, &cmd, &camera, &glview](std::ostream& stream) {
+      bool const wrote = with_output (cmd.is_stdout, filename_str, [&success, &root_geom, &cmd, &camera, &glview] (std::ostream &stream) {
           if (cmd.viewOptions.renderer == RenderType::BACKEND_SPECIFIC || cmd.viewOptions.renderer == RenderType::GEOMETRY) {
             success = export_png(root_geom, cmd.viewOptions, camera, stream);
           } else {
             success = export_png(*glview, stream);
-          }
-        }, std::ios::out | std::ios::binary);
+          } }, std::ios::out | std::ios::binary);
       if (!success || !wrote) {
         return 1;
       }
     }
 
-    renderStatistic.printAll(root_geom, camera, cmd.summaryOptions, cmd.summaryFile);
+    renderStatistic.printAll (root_geom, camera, cmd.summaryOptions, cmd.summaryFile);
   }
   return 0;
 }
 
-int cmdline(const CommandLine& cmd)
-{
+int cmdline (const CommandLine &cmd) {
   FileFormat export_format;
 
   // Determine output file format and assign it to formatName
-  if (cmd.export_format.is_initialized()) {
-    export_format = cmd.export_format.get();
+  if (cmd.export_format.is_initialized ()) {
+    export_format = cmd.export_format.get ();
   } else {
     // else extract format from file extension
-    const auto path = fs::path(cmd.output_file);
-    std::string suffix = path.has_extension() ? path.extension().generic_string().substr(1) : "";
-    boost::algorithm::to_lower(suffix);
+    const auto path = fs::path (cmd.output_file);
+    std::string suffix = path.has_extension () ? path.extension ().generic_string ().substr (1) : "";
+    boost::algorithm::to_lower (suffix);
 
-    if (!fileformat::fromIdentifier(suffix, export_format)) {
-      LOG("Invalid suffix %1$s. Either add a valid suffix or specify one using the --export-format option.", suffix);
+    if (!fileformat::fromIdentifier (suffix, export_format)) {
+      LOG ("Invalid suffix %1$s. Either add a valid suffix or specify one using the --export-format option.", suffix);
       return 1;
     }
   }
 
   // Do some minimal checking of output directory before rendering (issue #432)
-  auto output_dir = fs::path(cmd.output_file).parent_path();
-  if (output_dir.empty()) {
+  auto output_dir = fs::path (cmd.output_file).parent_path ();
+  if (output_dir.empty ()) {
     // If output_file_str has no directory prefix, set output directory to current directory.
-    output_dir = fs::current_path();
+    output_dir = fs::current_path ();
   }
-  if (!fs::is_directory(output_dir)) {
-    LOG("\n'%1$s' is not a directory for output file %2$s - Skipping\n", output_dir.generic_string(), cmd.output_file);
+  if (!fs::is_directory (output_dir)) {
+    LOG ("\n'%1$s' is not a directory for output file %2$s - Skipping\n", output_dir.generic_string (), cmd.output_file);
     return 1;
   }
 
-  set_render_color_scheme(arg_colorscheme, true);
+  set_render_color_scheme (arg_colorscheme, true);
 
   std::shared_ptr<Echostream> echostream;
   if (export_format == FileFormat::ECHO) {
-    echostream.reset(cmd.is_stdout ? new Echostream(std::cout) : new Echostream(cmd.output_file));
+    echostream.reset (cmd.is_stdout ? new Echostream (std::cout) : new Echostream (cmd.output_file));
   }
 
   std::string text;
   if (cmd.is_stdin) {
-    text = std::string((std::istreambuf_iterator<char>(std::cin)), std::istreambuf_iterator<char>());
+    text = std::string ((std::istreambuf_iterator<char> (std::cin)), std::istreambuf_iterator<char> ());
   } else {
-    std::ifstream ifs(cmd.filename);
-    if (!ifs.is_open()) {
-      LOG("Can't open input file '%1$s'!\n", cmd.filename);
+    std::ifstream ifs (cmd.filename);
+    if (!ifs.is_open ()) {
+      LOG ("Can't open input file '%1$s'!\n", cmd.filename);
       return 1;
     }
-    handle_dep(cmd.filename);
-    text = std::string((std::istreambuf_iterator<char>(ifs)), std::istreambuf_iterator<char>());
+    handle_dep (cmd.filename);
+    text = std::string ((std::istreambuf_iterator<char> (ifs)), std::istreambuf_iterator<char> ());
   }
 
 #ifdef ENABLE_PYTHON
   python_active = false;
-  if (cmd.filename.c_str() != NULL) {
-    if (boost::algorithm::ends_with(cmd.filename, ".py")) {
-      if (python_trusted == true) python_active = true;
-      else LOG("Python is not enabled");
+  if (cmd.filename.c_str () != NULL) {
+    if (boost::algorithm::ends_with (cmd.filename, ".py")) {
+      if (python_trusted == true)
+        python_active = true;
+      else
+        LOG ("Python is not enabled");
     }
   }
 
   if (python_active) {
     auto fulltext_py = text;
-    initPython(PlatformUtils::applicationPath(), 0.0);
-    auto error = evaluatePython(fulltext_py, false);
-    if (error.size() > 0)LOG(error.c_str());
+    initPython (PlatformUtils::applicationPath (), 0.0);
+    auto error = evaluatePython (fulltext_py, false);
+    if (error.size () > 0)
+      LOG (error.c_str ());
     text = "\n";
   }
 #endif // ifdef ENABLE_PYTHON
   text += "\n\x03\n" + commandline_commands;
 
   SourceFile *root_file = nullptr;
-  if (!parse(root_file, text, cmd.filename, cmd.filename, false)) {
+  if (!parse (root_file, text, cmd.filename, cmd.filename, false)) {
     delete root_file; // parse failed
     root_file = nullptr;
   }
   if (!root_file) {
-    LOG("Can't parse file '%1$s'!\n", cmd.filename);
+    LOG ("Can't parse file '%1$s'!\n", cmd.filename);
     return 1;
   }
 
   // add parameter to AST
-  CommentParser::collectParameters(text.c_str(), root_file);
-  if (!cmd.parameterFile.empty() && !cmd.setName.empty()) {
-    ParameterObjects parameters = ParameterObjects::fromSourceFile(root_file);
+  CommentParser::collectParameters (text.c_str (), root_file);
+  if (!cmd.parameterFile.empty () && !cmd.setName.empty ()) {
+    ParameterObjects parameters = ParameterObjects::fromSourceFile (root_file);
     ParameterSets sets;
-    sets.readFile(cmd.parameterFile);
-    for (const auto& set : sets) {
-      if (set.name() == cmd.setName) {
-        parameters.importValues(set);
-        parameters.apply(root_file);
+    sets.readFile (cmd.parameterFile);
+    for (const auto &set : sets) {
+      if (set.name () == cmd.setName) {
+        parameters.importValues (set);
+        parameters.apply (root_file);
         break;
       }
     }
   }
 
-  root_file->handleDependencies();
+  root_file->handleDependencies ();
 
   RenderVariables render_variables = {
-    .preview = fileformat::canPreview(export_format)
-      ? (cmd.viewOptions.renderer == RenderType::OPENCSG
-         || cmd.viewOptions.renderer == RenderType::THROWNTOGETHER)
-      : false,
+    .preview = fileformat::canPreview (export_format)
+                 ? (cmd.viewOptions.renderer == RenderType::OPENCSG || cmd.viewOptions.renderer == RenderType::THROWNTOGETHER)
+                 : false,
     .camera = cmd.camera,
   };
 
   if (cmd.animate.frames == 0) {
     render_variables.time = 0;
-    return do_export(cmd, render_variables, export_format, root_file);
+    return do_export (cmd, render_variables, export_format, root_file);
   } else {
     // export the requested number of animated frames
-    const unsigned start_frame = ((cmd.animate.shard - 1) * cmd.animate.frames)
-      / cmd.animate.num_shards;
-    const unsigned limit_frame = (cmd.animate.shard * cmd.animate.frames)
-      / cmd.animate.num_shards;
+    const unsigned start_frame = ((cmd.animate.shard - 1) * cmd.animate.frames) / cmd.animate.num_shards;
+    const unsigned limit_frame = (cmd.animate.shard * cmd.animate.frames) / cmd.animate.num_shards;
     for (unsigned frame = start_frame; frame < limit_frame; ++frame) {
       render_variables.time = frame * (1.0 / cmd.animate.frames);
 
       std::ostringstream oss;
-      oss << std::setw(5) << std::setfill('0') << frame;
+      oss << std::setw (5) << std::setfill ('0') << frame;
 
-      auto frame_file = fs::path(cmd.output_file);
-      auto extension = frame_file.extension();
-      frame_file.replace_extension();
-      frame_file += oss.str();
-      frame_file.replace_extension(extension);
-      std::string const frame_str = frame_file.generic_string();
+      auto frame_file = fs::path (cmd.output_file);
+      auto extension = frame_file.extension ();
+      frame_file.replace_extension ();
+      frame_file += oss.str ();
+      frame_file.replace_extension (extension);
+      std::string const frame_str = frame_file.generic_string ();
 
-      LOG("Exporting %1$s...", cmd.filename);
+      LOG ("Exporting %1$s...", cmd.filename);
 
       CommandLine frame_cmd = cmd;
       frame_cmd.output_file = frame_str;
 
-      int const r = do_export(frame_cmd, render_variables, export_format, root_file);
+      int const r = do_export (frame_cmd, render_variables, export_format, root_file);
       if (r != 0) {
         return r;
       }
@@ -667,42 +659,40 @@ int cmdline(const CommandLine& cmd)
 }
 
 template <class Seq, typename ToString>
-static std::string str_join(const Seq& seq, const std::string& sep, const ToString& toString)
-{
-  return boost::algorithm::join(boost::adaptors::transform(seq, toString), sep);
+static std::string str_join (const Seq &seq, const std::string &sep, const ToString &toString) {
+  return boost::algorithm::join (boost::adaptors::transform (seq, toString), sep);
 }
 
-static bool flagConvert(const std::string& str){
-  if (str == "1" || boost::iequals(str, "on") || boost::iequals(str, "true")) {
+static bool flagConvert (const std::string &str) {
+  if (str == "1" || boost::iequals (str, "on") || boost::iequals (str, "true")) {
     return true;
   }
-  if (str == "0" || boost::iequals(str, "off") || boost::iequals(str, "false")) {
+  if (str == "0" || boost::iequals (str, "off") || boost::iequals (str, "false")) {
     return false;
   }
-  throw std::runtime_error("");
+  throw std::runtime_error ("");
   return false;
 }
 
-static std::tuple<std::string, std::string> simple_split(const std::string& str, const char c)
-{
-  const auto idx = str.find_first_of(c);
-  if (idx == std::string::npos)return {};
-  const auto first = str.substr(0, idx);
-  const auto second = str.substr(idx + 1);
+static std::tuple<std::string, std::string> simple_split (const std::string &str, const char c) {
+  const auto idx = str.find_first_of (c);
+  if (idx == std::string::npos)
+    return {};
+  const auto first = str.substr (0, idx);
+  const auto second = str.substr (idx + 1);
   return {first, second};
 }
 
-static CmdLineExportOptions convert_export_options(const po::variables_map& vm)
-{
-  if (vm.count("O") == 0) {
+static CmdLineExportOptions convert_export_options (const po::variables_map &vm) {
+  if (vm.count ("O") == 0) {
     return {};
   }
 
   CmdLineExportOptions map;
-  const auto& options = vm["O"].as<std::vector<std::string>>();
-  for (const auto& option : options) {
-    const auto [key, value] = simple_split(option, '=');
-    const auto [section, name] = simple_split(key, '/');
+  const auto &options = vm["O"].as<std::vector<std::string>> ();
+  for (const auto &option : options) {
+    const auto [key, value] = simple_split (option, '=');
+    const auto [section, name] = simple_split (key, '/');
     map[section][name] = value;
   }
   return map;
@@ -710,23 +700,22 @@ static CmdLineExportOptions convert_export_options(const po::variables_map& vm)
 
 } // namespace
 
-void set_render_color_scheme(const std::string& color_scheme, const bool exit_if_not_found)
-{
-  if (color_scheme.empty()) {
+void set_render_color_scheme (const std::string &color_scheme, const bool exit_if_not_found) {
+  if (color_scheme.empty ()) {
     return;
   }
 
-  if (ColorMap::inst()->findColorScheme(color_scheme)) {
-    RenderSettings::inst()->colorscheme = color_scheme;
+  if (ColorMap::inst ()->findColorScheme (color_scheme)) {
+    RenderSettings::inst ()->colorscheme = color_scheme;
     return;
   }
 
   if (exit_if_not_found) {
-    LOG((boost::algorithm::join(ColorMap::inst()->colorSchemeNames(), "\n")));
+    LOG ((boost::algorithm::join (ColorMap::inst ()->colorSchemeNames (), "\n")));
 
-    exit(1);
+    exit (1);
   } else {
-    LOG("Unknown color scheme '%1$s', using default '%2$s'.", arg_colorscheme, ColorMap::inst()->defaultColorSchemeName());
+    LOG ("Unknown color scheme '%1$s', using default '%2$s'.", arg_colorscheme, ColorMap::inst ()->defaultColorSchemeName ());
   }
 }
 
@@ -735,29 +724,26 @@ void set_render_color_scheme(const std::string& color_scheme, const bool exit_if
  * determined so we can lookup the resource path for the language translation
  * files.
  */
-void localization_init() {
-  fs::path const po_dir(PlatformUtils::resourcePath("locale"));
-  const std::string& locale_path(po_dir.string());
-
-  if (fs::is_directory(locale_path)) {
-    setlocale(LC_ALL, "");
-    bindtextdomain("openscad", locale_path.c_str());
-    bind_textdomain_codeset("openscad", "UTF-8");
-    textdomain("openscad");
+void localization_init () {
+  fs::path const po_dir (PlatformUtils::resourcePath ("locale"));
+  const std::string &locale_path (po_dir.string ());
+
+  if (fs::is_directory (locale_path)) {
+    setlocale (LC_ALL, "");
+    bindtextdomain ("openscad", locale_path.c_str ());
+    bind_textdomain_codeset ("openscad", "UTF-8");
+    textdomain ("openscad");
   } else {
-    LOG("Could not initialize localization (application path is '%1$s').", PlatformUtils::applicationPath());
+    LOG ("Could not initialize localization (application path is '%1$s').", PlatformUtils::applicationPath ());
   }
 }
 
-
-
 #ifdef Q_OS_MACOS
-std::pair<std::string, std::string> customSyntax(const std::string& s)
-{
-  if (s.find("-psn_") == 0) return {"psn", s.substr(5)};
+std::pair<std::string, std::string> customSyntax (const std::string &s) {
+  if (s.find ("-psn_") == 0)
+    return {"psn", s.substr (5)};
 #else
-std::pair<std::string, std::string> customSyntax(const std::string&)
-{
+std::pair<std::string, std::string> customSyntax (const std::string &) {
 #endif
 
   return {};
@@ -765,212 +751,181 @@ std::pair<std::string, std::string> customSyntax(const std::string&)
 /*!
    This makes boost::program_option parse comma-separated values
  */
-struct CommaSeparatedVector
-{
+struct CommaSeparatedVector {
   std::vector<std::string> values;
 
-  friend std::istream& operator>>(std::istream& in, CommaSeparatedVector& value) {
+  friend std::istream &operator>> (std::istream &in, CommaSeparatedVector &value) {
     std::string token;
     in >> token;
     // NOLINTNEXTLINE(*NewDeleteLeaks) LLVM bug https://github.com/llvm/llvm-project/issues/40486
-    boost::split(value.values, token, boost::is_any_of(","));
+    boost::split (value.values, token, boost::is_any_of (","));
     return in;
   }
 };
 
 // OpenSCAD
-int main(int argc, char **argv)
-{
+int main (int argc, char **argv) {
 #if defined(ENABLE_CGAL) && defined(USE_MIMALLOC)
   // call init_mimalloc before any GMP variables are initialized. (defined in src/openscad_mimalloc.h)
-  init_mimalloc();
+  init_mimalloc ();
 #endif
 
   int rc = 0;
-  StackCheck::inst();
+  StackCheck::inst ();
 
 #ifdef Q_OS_MACOS
-  bool isGuiLaunched = getenv("GUI_LAUNCHED") != nullptr;
-  auto nslog = [](const Message& msg, void *userdata) {
-      CocoaUtils::nslog(msg.msg, userdata);
-    };
-  if (isGuiLaunched) set_output_handler(nslog, nullptr, nullptr);
+  bool isGuiLaunched = getenv ("GUI_LAUNCHED") != nullptr;
+  auto nslog = [] (const Message &msg, void *userdata) {
+    CocoaUtils::nslog (msg.msg, userdata);
+  };
+  if (isGuiLaunched)
+    set_output_handler (nslog, nullptr, nullptr);
 #else
-  PlatformUtils::ensureStdIO();
+  PlatformUtils::ensureStdIO ();
 #endif
 
 #ifndef __EMSCRIPTEN__
-  const auto applicationPath = weakly_canonical(boost::dll::program_location()).parent_path().generic_string();
+  const auto applicationPath = weakly_canonical (boost::dll::program_location ()).parent_path ().generic_string ();
 #else
-  const auto applicationPath = boost::dll::fs::current_path();
+  const auto applicationPath = boost::dll::fs::current_path ();
 #endif
-  PlatformUtils::registerApplicationPath(applicationPath);
+  PlatformUtils::registerApplicationPath (applicationPath);
 
 #ifdef ENABLE_PYTHON
   // The original name as called, not resolving links and so on. This will
   // just forward everything to the python main.
-  const auto applicationName = fs::path(argv[0]).filename().generic_string();
+  const auto applicationName = fs::path (argv[0]).filename ().generic_string ();
   if (applicationName == "openscad-python") {
-    return pythonRunArgs(argc, argv);
+    return pythonRunArgs (argc, argv);
   }
 #endif
 
 #ifdef ENABLE_CGAL
   // Always throw exceptions from CGAL, so we can catch instead of crashing on bad geometry.
-  CGAL::set_error_behaviour(CGAL::THROW_EXCEPTION);
-  CGAL::set_warning_behaviour(CGAL::THROW_EXCEPTION);
+  CGAL::set_error_behaviour (CGAL::THROW_EXCEPTION);
+  CGAL::set_warning_behaviour (CGAL::THROW_EXCEPTION);
 #endif
-  Builtins::instance()->initialize();
+  Builtins::instance ()->initialize ();
 
-  auto original_path = fs::current_path();
+  auto original_path = fs::current_path ();
 
   std::vector<std::string> output_files;
   const char *deps_output_file = nullptr;
   boost::optional<FileFormat> export_format;
 
   ViewOptions viewOptions{};
-  po::options_description desc("Allowed options");
-  desc.add_options()
-  ("export-format", po::value<std::string> (), "overrides format of exported scad file when using option '-o', arg can be any of its supported file extensions.  For ASCII stl export, specify 'asciistl', and for binary stl export, specify 'binstl'.  ASCII export is the current stl default, but binary stl is planned as the future default so asciistl should be explicitly specified in scripts when needed.\n")
-  ("o,o", po::value<std::vector<std::string>> (), "output specified file instead of running the GUI. The file extension specifies the type: stl, off, wrl, amf, 3mf, csg, dxf, svg, pdf, png, echo, ast, term, nef3, nefdbg, param, pov. May be used multiple times for different exports. Use '-' for stdout.\n")
-  ("O,O", po::value<std::vector<std::string>> (), "pass settings value to the file export using the format section/key=value, e.g export-pdf/paper-size=a3. Use --help-export to list all available settings.")
-  ("D,D", po::value<std::vector<std::string>> (), "var=val -pre-define variables")
-  ("p,p", po::value<std::string> (), "customizer parameter file")
-  ("P,P", po::value<std::string> (), "customizer parameter set")
+  po::options_description desc ("Allowed options");
+  desc.add_options () ("export-format", po::value<std::string> (), "overrides format of exported scad file when using option '-o', arg can be any of its supported file extensions.  For ASCII stl export, specify 'asciistl', and for binary stl export, specify 'binstl'.  ASCII export is the current stl default, but binary stl is planned as the future default so asciistl should be explicitly specified in scripts when needed.\n") ("o,o", po::value<std::vector<std::string>> (), "output specified file instead of running the GUI. The file extension specifies the type: stl, off, wrl, amf, 3mf, csg, dxf, svg, pdf, png, echo, ast, term, nef3, nefdbg, param, pov. May be used multiple times for different exports. Use '-' for stdout.\n") ("O,O", po::value<std::vector<std::string>> (), "pass settings value to the file export using the format section/key=value, e.g export-pdf/paper-size=a3. Use --help-export to list all available settings.") ("D,D", po::value<std::vector<std::string>> (), "var=val -pre-define variables") ("p,p", po::value<std::string> (), "customizer parameter file") ("P,P", po::value<std::string> (), "customizer parameter set")
 #ifdef ENABLE_EXPERIMENTAL
-  ("enable", po::value<std::vector<std::string>> (), ("enable experimental features (specify 'all' for enabling all available features): " +
-                                                      str_join(boost::make_iterator_range(Feature::begin(), Feature::end()), " | ",
-                                                               [](const Feature *feature) {
-    return feature->get_name();
-  }) +
-                                                               "\n").c_str())
+    ("enable", po::value<std::vector<std::string>> (), ("enable experimental features (specify 'all' for enabling all available features): " + str_join (boost::make_iterator_range (Feature::begin (), Feature::end ()), " | ", [] (const Feature *feature) {
+                                                          return feature->get_name ();
+                                                        }) +
+                                                        "\n")
+                                                         .c_str ())
 #endif
-  ("help,h", "print this help message and exit")
-    ("help-export", "print list of export parameters and values that can be set via -O")
-    ("version,v", "print the version")
-    ("info", "print information about the build process\n")
-
-    ("camera", po::value<std::string>(), "camera parameters when exporting png: =translate_x,y,z,rot_x,y,z,dist or =eye_x,y,z,center_x,y,z")
-    ("autocenter", "adjust camera to look at object's center")
-    ("viewall", "adjust camera to fit object")
-    ("backend", po::value<std::string>(), "3D rendering backend to use: 'CGAL' (old/slow) [default] or 'Manifold' (new/fast)")
-    ("imgsize", po::value<std::string>(), "=width,height of exported png")
-    ("render", po::value<std::string>()->implicit_value(""), "for full geometry evaluation when exporting png")
-    ("preview", po::value<std::string>()->implicit_value(""), "[=throwntogether] -for ThrownTogether preview png")
-    ("animate", po::value<unsigned>(), "export N animated frames")
-    ("animate_sharding", po::value<std::string>(), "Parameter <shard>/<num_shards> - Divide work into <num_shards> and only output frames for <shard>. E.g. 2/5 only outputs the second 1/5 of frames. Use to parallelize work on multiple cores or machines.")
-    ("view", po::value<CommaSeparatedVector>(), ("=view options: " + boost::algorithm::join(viewOptions.names(), " | ")).c_str())
-    ("projection", po::value<std::string>(), "=(o)rtho or (p)erspective when exporting png")
-    ("csglimit", po::value<unsigned int>(), "=n -stop rendering at n CSG elements when exporting png")
-    ("summary", po::value<std::vector<std::string>>(), "enable additional render summary and statistics: all | cache | time | camera | geometry | bounding-box | area")
-    ("summary-file", po::value<std::string>(), "output summary information in JSON format to the given file, using '-' outputs to stdout")
-    ("colorscheme", po::value<std::string>(), ("=colorscheme: " +
-                                               str_join(ColorMap::inst()->colorSchemeNames(), " | ",
-                                                        [](const std::string& colorScheme) {
-                                                        return (colorScheme == ColorMap::inst()->defaultColorSchemeName() ? "*" : "") + colorScheme;
-    }) +
-                                               "\n").c_str())
-    ("d,d", po::value<std::string>(), "deps_file -generate a dependency file for make")
-    ("m,m", po::value<std::string>(), "make_cmd -runs make_cmd file if file is missing")
-    ("quiet,q", "quiet mode (don't print anything *except* errors)")
-    ("hardwarnings", "Stop on the first warning")
-    ("trace-depth", po::value<unsigned int>(), "=n, maximum number of trace messages")
-    ("trace-usermodule-parameters", po::value<std::string>(), "=true/false, configure the output of user module parameters in a trace")
-    ("check-parameters", po::value<std::string>(), "=true/false, configure the parameter check for user modules and functions")
-    ("check-parameter-ranges", po::value<std::string>(), "=true/false, configure the parameter range check for builtin modules")
-    ("debug", po::value<std::string>(), "special debug info - specify 'all' or a set of source file names")
+      ("help,h", "print this help message and exit") ("help-export", "print list of export parameters and values that can be set via -O") ("version,v", "print the version") ("info", "print information about the build process\n")
+
+        ("camera", po::value<std::string> (), "camera parameters when exporting png: =translate_x,y,z,rot_x,y,z,dist or =eye_x,y,z,center_x,y,z") ("autocenter", "adjust camera to look at object's center") ("viewall", "adjust camera to fit object") ("backend", po::value<std::string> (), "3D rendering backend to use: 'CGAL' (old/slow) [default] or 'Manifold' (new/fast)") ("imgsize", po::value<std::string> (), "=width,height of exported png") ("render", po::value<std::string> ()->implicit_value (""), "for full geometry evaluation when exporting png") ("preview", po::value<std::string> ()->implicit_value (""), "[=throwntogether] -for ThrownTogether preview png") ("animate", po::value<unsigned> (), "export N animated frames") ("animate_sharding", po::value<std::string> (), "Parameter <shard>/<num_shards> - Divide work into <num_shards> and only output frames for <shard>. E.g. 2/5 only outputs the second 1/5 of frames. Use to parallelize work on multiple cores or machines.") ("view", po::value<CommaSeparatedVector> (), ("=view options: " + boost::algorithm::join (viewOptions.names (), " | ")).c_str ()) ("projection", po::value<std::string> (), "=(o)rtho or (p)erspective when exporting png") ("csglimit", po::value<unsigned int> (), "=n -stop rendering at n CSG elements when exporting png") ("summary", po::value<std::vector<std::string>> (), "enable additional render summary and statistics: all | cache | time | camera | geometry | bounding-box | area") ("summary-file", po::value<std::string> (), "output summary information in JSON format to the given file, using '-' outputs to stdout") ("colorscheme", po::value<std::string> (), ("=colorscheme: " + str_join (ColorMap::inst ()->colorSchemeNames (), " | ", [] (const std::string &colorScheme) {
+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   return (colorScheme == ColorMap::inst ()->defaultColorSchemeName () ? "*" : "") + colorScheme;
+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 }) +
+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 "\n")
+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .c_str ()) ("d,d", po::value<std::string> (), "deps_file -generate a dependency file for make") ("m,m", po::value<std::string> (), "make_cmd -runs make_cmd file if file is missing") ("quiet,q", "quiet mode (don't print anything *except* errors)") ("hardwarnings", "Stop on the first warning") ("trace-depth", po::value<unsigned int> (), "=n, maximum number of trace messages") ("trace-usermodule-parameters", po::value<std::string> (), "=true/false, configure the output of user module parameters in a trace") ("check-parameters", po::value<std::string> (), "=true/false, configure the parameter check for user modules and functions") ("check-parameter-ranges", po::value<std::string> (), "=true/false, configure the parameter range check for builtin modules") ("debug", po::value<std::string> (), "special debug info - specify 'all' or a set of source file names")
 #ifdef ENABLE_PYTHON
-  ("trust-python",  "Trust python")
-    ("python-module", po::value<std::string>(), "=module Call pip python module")
+          ("trust-python", "Trust python") ("python-module", po::value<std::string> (), "=module Call pip python module")
 #endif
-  ;
+    ;
 
 #ifdef ENABLE_GUI_TESTS
-  desc.add_options()("run-all-gui-tests", "special gui testing mode - run all the tests");
+  desc.add_options () ("run-all-gui-tests", "special gui testing mode - run all the tests");
 #endif
 
-  po::options_description hidden("Hidden options");
-  hidden.add_options()
+  po::options_description hidden ("Hidden options");
+  hidden.add_options ()
 #ifdef Q_OS_MACOS
-  ("psn", po::value<std::string>(), "process serial number")
+    ("psn", po::value<std::string> (), "process serial number")
 #endif
-  ("input-file", po::value<std::vector<std::string>>(), "input file");
+      ("input-file", po::value<std::vector<std::string>> (), "input file");
 
   po::positional_options_description p;
-  p.add("input-file", -1);
+  p.add ("input-file", -1);
 
   po::options_description all_options;
-  all_options.add(desc).add(hidden);
+  all_options.add (desc).add (hidden);
 
   po::variables_map vm;
   try {
-    po::store(po::command_line_parser(argc, argv).options(all_options).positional(p).extra_parser(customSyntax).run(), vm);
-  } catch (const std::exception& e) { // Catches e.g. unknown options
-    LOG("%1$s\n", e.what());
-    help(argv[0], desc, true);
+    po::store (po::command_line_parser (argc, argv).options (all_options).positional (p).extra_parser (customSyntax).run (), vm);
+  } catch (const std::exception &e) { // Catches e.g. unknown options
+    LOG ("%1$s\n", e.what ());
+    help (argv[0], desc, true);
   }
 
   OpenSCAD::debug = "";
-  if (vm.count("debug")) {
-    OpenSCAD::debug = vm["debug"].as<std::string>();
-    LOG("Debug on. --debug=%1$s", OpenSCAD::debug);
+  if (vm.count ("debug")) {
+    OpenSCAD::debug = vm["debug"].as<std::string> ();
+    LOG ("Debug on. --debug=%1$s", OpenSCAD::debug);
   }
 #ifdef ENABLE_PYTHON
-  if (vm.count("trust-python")) {
-    LOG("Python Engine enabled", OpenSCAD::debug);
+  if (vm.count ("trust-python")) {
+    LOG ("Python Engine enabled", OpenSCAD::debug);
     python_trusted = true;
   }
 
   const auto pymod = "python-module";
-  if (vm.count(pymod)) {
-    PRINTDB("Running Python Module %s", pymod);
+  if (vm.count (pymod)) {
+    PRINTDB ("Running Python Module %s", pymod);
     std::vector<std::string> args;
-    if (vm.count("input-file")) {
-      args = vm["input-file"].as<std::vector<std::string>>();
+    if (vm.count ("input-file")) {
+      args = vm["input-file"].as<std::vector<std::string>> ();
     }
-    return pythonRunModule(applicationPath, vm[pymod].as<std::string>(), args);
+    return pythonRunModule (applicationPath, vm[pymod].as<std::string> (), args);
   }
 #endif // ifdef ENABLE_PYTHON
-  if (vm.count("quiet")) {
+  if (vm.count ("quiet")) {
     OpenSCAD::quiet = true;
   }
 
-  if (vm.count("hardwarnings")) {
+  if (vm.count ("hardwarnings")) {
     OpenSCAD::hardwarnings = true;
   }
 
-  if (vm.count("traceDepth")) {
-    OpenSCAD::traceDepth = vm["traceDepth"].as<unsigned int>();
+  if (vm.count ("traceDepth")) {
+    OpenSCAD::traceDepth = vm["traceDepth"].as<unsigned int> ();
   }
   std::map<std::string, bool *> flags;
-  flags.insert(std::make_pair("trace-usermodule-parameters", &OpenSCAD::traceUsermoduleParameters));
-  flags.insert(std::make_pair("check-parameters", &OpenSCAD::parameterCheck));
-  flags.insert(std::make_pair("check-parameter-ranges", &OpenSCAD::rangeCheck));
-  for (const auto& flag : flags) {
+  flags.insert (std::make_pair ("trace-usermodule-parameters", &OpenSCAD::traceUsermoduleParameters));
+  flags.insert (std::make_pair ("check-parameters", &OpenSCAD::parameterCheck));
+  flags.insert (std::make_pair ("check-parameter-ranges", &OpenSCAD::rangeCheck));
+  for (const auto &flag : flags) {
     std::string name = flag.first;
-    if (vm.count(name)) {
-      std::string opt = vm[name].as<std::string>();
+    if (vm.count (name)) {
+      std::string opt = vm[name].as<std::string> ();
       try {
-        (*(flag.second) = flagConvert(opt));
-      } catch (const std::runtime_error& e) {
-        LOG("Could not parse '--%1$s %2$s' as flag", name, opt);
+        (*(flag.second) = flagConvert (opt));
+      } catch (const std::runtime_error &e) {
+        LOG ("Could not parse '--%1$s %2$s' as flag", name, opt);
       }
     }
   }
 
-  if (vm.count("help")) help(argv[0], desc);
-  if (vm.count("help-export")) help_export();
-  if (vm.count("version")) version();
-  if (vm.count("info")) arg_info = true;
-  if (vm.count("backend")) {
-    RenderSettings::inst()->backend3D = renderBackend3DFromString(vm["backend"].as<std::string>());
+  if (vm.count ("help"))
+    help (argv[0], desc);
+  if (vm.count ("help-export"))
+    help_export ();
+  if (vm.count ("version"))
+    version ();
+  if (vm.count ("info"))
+    arg_info = true;
+  if (vm.count ("backend")) {
+    RenderSettings::inst ()->backend3D = renderBackend3DFromString (vm["backend"].as<std::string> ());
   }
 
-  if (vm.count("preview")) {
-    if (vm["preview"].as<std::string>() == "throwntogether") viewOptions.renderer = RenderType::THROWNTOGETHER;
-  } else if (vm.count("render")) {
+  if (vm.count ("preview")) {
+    if (vm["preview"].as<std::string> () == "throwntogether")
+      viewOptions.renderer = RenderType::THROWNTOGETHER;
+  } else if (vm.count ("render")) {
     // Note: "cgal" is here for backwards compatibility, can probably be removed soon
-    if (vm["render"].as<std::string>() == "cgal" || vm["render"].as<std::string>() == "force") {
+    if (vm["render"].as<std::string> () == "cgal" || vm["render"].as<std::string> () == "force") {
       viewOptions.renderer = RenderType::BACKEND_SPECIFIC;
     } else {
       viewOptions.renderer = RenderType::GEOMETRY;
@@ -978,124 +933,128 @@ int main(int argc, char **argv)
   }
 
   viewOptions.previewer = (viewOptions.renderer == RenderType::THROWNTOGETHER) ? Previewer::THROWNTOGETHER : Previewer::OPENCSG;
-  if (vm.count("view")) {
-    const auto& viewOptionValues = vm["view"].as<CommaSeparatedVector>();
+  if (vm.count ("view")) {
+    const auto &viewOptionValues = vm["view"].as<CommaSeparatedVector> ();
 
-    for (const auto& option : viewOptionValues.values) {
+    for (const auto &option : viewOptionValues.values) {
       try {
         viewOptions[option] = true;
-      } catch (const std::out_of_range& e) {
-        LOG("Unknown --view option '%1$s' ignored. Use -h to list available options.", option);
+      } catch (const std::out_of_range &e) {
+        LOG ("Unknown --view option '%1$s' ignored. Use -h to list available options.", option);
       }
     }
   }
 
-  if (vm.count("csglimit")) {
-    RenderSettings::inst()->openCSGTermLimit = vm["csglimit"].as<unsigned int>();
+  if (vm.count ("csglimit")) {
+    RenderSettings::inst ()->openCSGTermLimit = vm["csglimit"].as<unsigned int> ();
   }
 
-  if (vm.count("o")) {
-    output_files = vm["o"].as<std::vector<std::string>>();
+  if (vm.count ("o")) {
+    output_files = vm["o"].as<std::vector<std::string>> ();
   }
-  if (vm.count("d")) {
-    if (deps_output_file) help(argv[0], desc, true);
-    deps_output_file = vm["d"].as<std::string>().c_str();
+  if (vm.count ("d")) {
+    if (deps_output_file)
+      help (argv[0], desc, true);
+    deps_output_file = vm["d"].as<std::string> ().c_str ();
   }
-  if (vm.count("m")) {
-    if (make_command) help(argv[0], desc, true);
-    make_command = vm["m"].as<std::string>().c_str();
+  if (vm.count ("m")) {
+    if (make_command)
+      help (argv[0], desc, true);
+    make_command = vm["m"].as<std::string> ().c_str ();
   }
 
-  if (vm.count("D")) {
-    for (const auto& cmd : vm["D"].as<std::vector<std::string>>()) {
+  if (vm.count ("D")) {
+    for (const auto &cmd : vm["D"].as<std::vector<std::string>> ()) {
       commandline_commands += cmd;
       commandline_commands += ";\n";
     }
   }
-  if (vm.count("enable")) {
-    for (const auto& feature : vm["enable"].as<std::vector<std::string>>()) {
+  if (vm.count ("enable")) {
+    for (const auto &feature : vm["enable"].as<std::vector<std::string>> ()) {
       if (feature == "all") {
-        Feature::enable_all();
+        Feature::enable_all ();
         break;
       }
-      Feature::enable_feature(feature);
+      Feature::enable_feature (feature);
     }
   }
 
   std::string parameterFile;
-  if (vm.count("p")) {
-    if (!parameterFile.empty()) {
-      help(argv[0], desc, true);
+  if (vm.count ("p")) {
+    if (!parameterFile.empty ()) {
+      help (argv[0], desc, true);
     }
-    parameterFile = vm["p"].as<std::string>().c_str();
+    parameterFile = vm["p"].as<std::string> ().c_str ();
   }
 
   std::string parameterSet;
-  if (vm.count("P")) {
-    if (!parameterSet.empty()) {
-      help(argv[0], desc, true);
+  if (vm.count ("P")) {
+    if (!parameterSet.empty ()) {
+      help (argv[0], desc, true);
     }
-    parameterSet = vm["P"].as<std::string>().c_str();
+    parameterSet = vm["P"].as<std::string> ().c_str ();
   }
 
   std::vector<std::string> inputFiles;
-  if (vm.count("input-file")) {
-    inputFiles = vm["input-file"].as<std::vector<std::string>>();
+  if (vm.count ("input-file")) {
+    inputFiles = vm["input-file"].as<std::vector<std::string>> ();
   }
 
-  if (vm.count("colorscheme")) {
-    arg_colorscheme = vm["colorscheme"].as<std::string>();
+  if (vm.count ("colorscheme")) {
+    arg_colorscheme = vm["colorscheme"].as<std::string> ();
   }
 
-  if (vm.count("export-format")) {
-    const auto format_str = vm["export-format"].as<std::string>();
+  if (vm.count ("export-format")) {
+    const auto format_str = vm["export-format"].as<std::string> ();
     FileFormat format;
-    if (fileformat::fromIdentifier(format_str, format)) {
-      export_format.emplace(format);
+    if (fileformat::fromIdentifier (format_str, format)) {
+      export_format.emplace (format);
 
     } else {
-      LOG("Unknown --export-format option '%1$s'.  Use -h to list available options.", format_str);
+      LOG ("Unknown --export-format option '%1$s'.  Use -h to list available options.", format_str);
       return 1;
     }
   }
 
-  AnimateArgs const animate = get_animate(vm);
-  const Camera camera = get_camera(vm);
+  AnimateArgs const animate = get_animate (vm);
+  const Camera camera = get_camera (vm);
 
   if (animate.frames) {
-    for (const auto& filename : output_files) {
+    for (const auto &filename : output_files) {
       if (filename == "-") {
-        LOG("Option --animate is not supported when exporting to stdout.");
+        LOG ("Option --animate is not supported when exporting to stdout.");
         return 1;
       }
     }
-    if (output_files.empty()) {
-      output_files.emplace_back("frame.png");
+    if (output_files.empty ()) {
+      output_files.emplace_back ("frame.png");
     }
   }
 
-  PRINTDB("Application location detected as %s", applicationPath);
+  PRINTDB ("Application location detected as %s", applicationPath);
 
   auto cmdlinemode = false;
-  if (!output_files.empty()) { // cmd-line mode
+  if (!output_files.empty ()) { // cmd-line mode
     cmdlinemode = true;
-    if (!inputFiles.size()) help(argv[0], desc, true);
+    if (!inputFiles.size ())
+      help (argv[0], desc, true);
   }
 
   if (arg_info || cmdlinemode) {
-    if (inputFiles.size() > 1) help(argv[0], desc, true);
+    if (inputFiles.size () > 1)
+      help (argv[0], desc, true);
     try {
-      parser_init();
-      localization_init();
+      parser_init ();
+      localization_init ();
       if (arg_info) {
-        rc = info();
+        rc = info ();
       } else {
-        for (const auto& filename : output_files) {
+        for (const auto &filename : output_files) {
           const bool is_stdin = inputFiles[0] == "-";
           const std::string input_file = is_stdin ? "<stdin>" : inputFiles[0];
           const bool is_stdout = filename == "-";
           const std::string output_file = is_stdout ? "<stdout>" : filename;
-          const auto export_options = convert_export_options(vm);
+          const auto export_options = convert_export_options (vm);
           const CommandLine cmd{
             is_stdin,
             input_file,
@@ -1109,41 +1068,40 @@ int main(int argc, char **argv)
             export_format,
             export_options,
             animate,
-            vm.count("summary") ? vm["summary"].as<std::vector<std::string>>() : std::vector<std::string>{},
-            vm.count("summary-file") ? vm["summary-file"].as<std::string>() : ""
-          };
-          rc |= cmdline(cmd);
+            vm.count ("summary") ? vm["summary"].as<std::vector<std::string>> () : std::vector<std::string>{},
+            vm.count ("summary-file") ? vm["summary-file"].as<std::string> () : ""};
+          rc |= cmdline (cmd);
         }
       }
-    } catch (const HardWarningException&) {
+    } catch (const HardWarningException &) {
       rc = 1;
     }
 
     if (deps_output_file) {
-      std::string const deps_out(deps_output_file);
-      const std::vector<std::string>& geom_out(output_files);
-      if (!write_deps(deps_out, geom_out)) {
-        LOG("Error writing deps");
+      std::string const deps_out (deps_output_file);
+      const std::vector<std::string> &geom_out (output_files);
+      if (!write_deps (deps_out, geom_out)) {
+        LOG ("Error writing deps");
         return 1;
       }
     }
 #ifndef OPENSCAD_NOGUI
-  } else if (useGUI()) {
-    if (vm.count("export-format")) {
-      LOG("Ignoring --export-format option");
+  } else if (useGUI ()) {
+    if (vm.count ("export-format")) {
+      LOG ("Ignoring --export-format option");
     }
     std::string gui_test = "none";
-    if (vm.count("run-all-gui-tests")){
+    if (vm.count ("run-all-gui-tests")) {
       gui_test = "all";
     }
-    rc = gui(inputFiles, original_path, argc, argv, gui_test);
+    rc = gui (inputFiles, original_path, argc, argv, gui_test);
 #endif
   } else {
-    LOG("Requested GUI mode but can't open display!\n");
+    LOG ("Requested GUI mode but can't open display!\n");
     return 1;
   }
 
-  Builtins::instance(true);
+  Builtins::instance (true);
 
   return rc;
 }
diff --git a/src/openscad.h b/src/openscad.h
index 44532c01c..83bb85aad 100644
--- a/src/openscad.h
+++ b/src/openscad.h
@@ -29,12 +29,12 @@
 #include <string>
 #include <utility>
 
-extern bool parse(class SourceFile *&file, const std::string& text, const std::string& filename, const std::string& mainFile, int debug);
+extern bool parse (class SourceFile *&file, const std::string &text, const std::string &filename, const std::string &mainFile, int debug);
 
 extern std::string commandline_commands;
 
 // Custom argument parser
-std::pair<std::string, std::string> customSyntax(const std::string& s);
+std::pair<std::string, std::string> customSyntax (const std::string &s);
 
-void localization_init();
-void set_render_color_scheme(const std::string& color_scheme, const bool exit_if_not_found);
+void localization_init ();
+void set_render_color_scheme (const std::string &color_scheme, const bool exit_if_not_found);
diff --git a/src/openscad_gui.cc b/src/openscad_gui.cc
index aab0cf49e..6035d52cb 100644
--- a/src/openscad_gui.cc
+++ b/src/openscad_gui.cc
@@ -77,13 +77,13 @@
 #include "guitests/guitests.h"
 #endif
 
-Q_DECLARE_METATYPE(Message);
-Q_DECLARE_METATYPE(std::shared_ptr<const Geometry>);
+Q_DECLARE_METATYPE (Message);
+Q_DECLARE_METATYPE (std::shared_ptr<const Geometry>);
 
 extern std::string arg_colorscheme;
 
 #define STRINGIFY(x) #x
-#define TOSTRING(x) STRINGIFY(x)
+#define TOSTRING(x) STRINGIFY (x)
 
 namespace {
 
@@ -94,74 +94,72 @@ namespace {
 // field, see:
 // UIUtils::blendForBackgroundColorStyleSheet(const QColor& input, const QColor& blend)
 
-bool isDarkMode() {
+bool isDarkMode () {
 #if QT_VERSION >= QT_VERSION_CHECK(6, 5, 0)
-  const auto scheme = QGuiApplication::styleHints()->colorScheme();
+  const auto scheme = QGuiApplication::styleHints ()->colorScheme ();
   return scheme == Qt::ColorScheme::Dark;
 #else
   const QPalette defaultPalette;
-  const auto& text = defaultPalette.color(QPalette::WindowText);
-  const auto& window = defaultPalette.color(QPalette::Window);
-  return text.lightness() > window.lightness();
+  const auto &text = defaultPalette.color (QPalette::WindowText);
+  const auto &window = defaultPalette.color (QPalette::Window);
+  return text.lightness () > window.lightness ();
 #endif // QT_VERSION
 }
 
-}
+} // namespace
 
 namespace {
 
 // Only if "fileName" is not absolute, prepend the "absoluteBase".
-QString assemblePath(const std::filesystem::path& absoluteBaseDir,
-                     const std::string& fileName) {
-  if (fileName.empty()) return "";
-  auto qsDir = QString::fromLocal8Bit(absoluteBaseDir.generic_string().c_str());
-  auto qsFile = QString::fromLocal8Bit(fileName.c_str());
+QString assemblePath (const std::filesystem::path &absoluteBaseDir,
+                      const std::string &fileName) {
+  if (fileName.empty ())
+    return "";
+  auto qsDir = QString::fromLocal8Bit (absoluteBaseDir.generic_string ().c_str ());
+  auto qsFile = QString::fromLocal8Bit (fileName.c_str ());
   // if qsfile is absolute, dir is ignored. (see documentation of QFileInfo)
-  const QFileInfo fileInfo(qsDir, qsFile);
-  return fileInfo.absoluteFilePath();
+  const QFileInfo fileInfo (qsDir, qsFile);
+  return fileInfo.absoluteFilePath ();
 }
 
-
-void dialogThreadFunc(FontCacheInitializer *initializer)
-{
-  initializer->run();
+void dialogThreadFunc (FontCacheInitializer *initializer) {
+  initializer->run ();
 }
 
-void dialogInitHandler(FontCacheInitializer *initializer, void *)
-{
+void dialogInitHandler (FontCacheInitializer *initializer, void *) {
   QFutureWatcher<void> futureWatcher;
-  QObject::connect(&futureWatcher, &QFutureWatcher<void>::finished, scadApp, &OpenSCADApp::hideFontCacheDialog);
+  QObject::connect (&futureWatcher, &QFutureWatcher<void>::finished, scadApp, &OpenSCADApp::hideFontCacheDialog);
 
-  auto future = QtConcurrent::run([initializer] {
-      return dialogThreadFunc(initializer);
-    });
-  futureWatcher.setFuture(future);
+  auto future = QtConcurrent::run ([initializer] {
+    return dialogThreadFunc (initializer);
+  });
+  futureWatcher.setFuture (future);
 
   // We don't always get the started() signal, so we start manually
-  QMetaObject::invokeMethod(scadApp, "showFontCacheDialog");
+  QMetaObject::invokeMethod (scadApp, "showFontCacheDialog");
 
   // Block, in case we're in a separate thread, or the dialog was closed by the user
-  futureWatcher.waitForFinished();
+  futureWatcher.waitForFinished ();
 
   // We don't always receive the finished signal. We still need the signal to break
   // out of the exec() though.
-  QMetaObject::invokeMethod(scadApp, "hideFontCacheDialog");
+  QMetaObject::invokeMethod (scadApp, "hideFontCacheDialog");
 }
 
 #ifdef Q_OS_WIN
-void registerDefaultIcon(QString applicationFilePath) {
+void registerDefaultIcon (QString applicationFilePath) {
   // Not using cached instance here, so this needs to be in a
   // separate scope to ensure the QSettings instance is released
   // directly after use.
-  QSettings reg_setting(QLatin1String("HKEY_CURRENT_USER"), QSettings::NativeFormat);
-  auto appPath = QDir::toNativeSeparators(applicationFilePath + QLatin1String(",1"));
-  reg_setting.setValue(QLatin1String("Software/Classes/OpenSCAD_File/DefaultIcon/Default"), QVariant(appPath));
+  QSettings reg_setting (QLatin1String ("HKEY_CURRENT_USER"), QSettings::NativeFormat);
+  auto appPath = QDir::toNativeSeparators (applicationFilePath + QLatin1String (",1"));
+  reg_setting.setValue (QLatin1String ("Software/Classes/OpenSCAD_File/DefaultIcon/Default"), QVariant (appPath));
 }
 #else
-void registerDefaultIcon(const QString&) { }
+void registerDefaultIcon (const QString &) {}
 #endif
 
-}  // namespace
+} // namespace
 
 #ifdef OPENSCAD_SUFFIX
 #define DESKTOP_FILENAME "openscad" OPENSCAD_SUFFIX
@@ -169,80 +167,79 @@ void registerDefaultIcon(const QString&) { }
 #define DESKTOP_FILENAME "openscad"
 #endif
 
-int gui(std::vector<std::string>& inputFiles, const std::filesystem::path& original_path, int argc, char **argv, const std::string& gui_test)
-{
-  OpenSCADApp app(argc, argv);
+int gui (std::vector<std::string> &inputFiles, const std::filesystem::path &original_path, int argc, char **argv, const std::string &gui_test) {
+  OpenSCADApp app (argc, argv);
   // remove ugly frames in the QStatusBar when using additional widgets
-  app.setStyleSheet(
+  app.setStyleSheet (
     "QStatusBar::item { border: 0px solid black; }"
-    "* { font-size: 9pt }"
-    );
-  QIcon::setThemeName(isDarkMode() ? "chokusen-dark" : "chokusen");
+    "* { font-size: 9pt }");
+  QIcon::setThemeName (isDarkMode () ? "chokusen-dark" : "chokusen");
 
   // set up groups for QSettings
-  QCoreApplication::setOrganizationName("OpenSCAD");
-  QCoreApplication::setOrganizationDomain("openscad.org");
-  QCoreApplication::setApplicationName("OpenSCAD");
-  QCoreApplication::setApplicationVersion(TOSTRING(OPENSCAD_VERSION));
-  QGuiApplication::setApplicationDisplayName("OpenSCAD");
-  QGuiApplication::setDesktopFileName(DESKTOP_FILENAME);
+  QCoreApplication::setOrganizationName ("OpenSCAD");
+  QCoreApplication::setOrganizationDomain ("openscad.org");
+  QCoreApplication::setApplicationName ("OpenSCAD");
+  QCoreApplication::setApplicationVersion (TOSTRING (OPENSCAD_VERSION));
+  QGuiApplication::setApplicationDisplayName ("OpenSCAD");
+  QGuiApplication::setDesktopFileName (DESKTOP_FILENAME);
 #if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
-  QCoreApplication::setAttribute(Qt::AA_UseHighDpiPixmaps);
+  QCoreApplication::setAttribute (Qt::AA_UseHighDpiPixmaps);
 #endif
 #ifdef Q_OS_MACOS
-  app.setWindowIcon(QIcon(":/icon-macos.png"));
+  app.setWindowIcon (QIcon (":/icon-macos.png"));
 #else
-  app.setWindowIcon(QIcon(":/logo.png"));
+  app.setWindowIcon (QIcon (":/logo.png"));
 #endif
 
   // Other global settings
-  qRegisterMetaType<Message>();
-  qRegisterMetaType<std::shared_ptr<const Geometry>>();
+  qRegisterMetaType<Message> ();
+  qRegisterMetaType<std::shared_ptr<const Geometry>> ();
 
-  FontCache::registerProgressHandler(dialogInitHandler);
+  FontCache::registerProgressHandler (dialogInitHandler);
 
-  parser_init();
+  parser_init ();
 
   QSettingsCached settings;
-  if (settings.value("advanced/localization", true).toBool()) {
-    localization_init();
+  if (settings.value ("advanced/localization", true).toBool ()) {
+    localization_init ();
   }
 
 #ifdef Q_OS_MACOS
-  installAppleEventHandlers();
+  installAppleEventHandlers ();
 #endif
 
-  registerDefaultIcon(app.applicationFilePath());
+  registerDefaultIcon (app.applicationFilePath ());
 
 #ifdef OPENSCAD_UPDATER
   AutoUpdater *updater = new SparkleAutoUpdater;
-  AutoUpdater::setUpdater(updater);
-  if (updater->automaticallyChecksForUpdates()) updater->checkForUpdates();
-  updater->init();
+  AutoUpdater::setUpdater (updater);
+  if (updater->automaticallyChecksForUpdates ())
+    updater->checkForUpdates ();
+  updater->init ();
 #endif
 
-  set_render_color_scheme(arg_colorscheme, false);
+  set_render_color_scheme (arg_colorscheme, false);
   auto noInputFiles = false;
 
-  if (!inputFiles.size()) {
+  if (!inputFiles.size ()) {
     noInputFiles = true;
-    inputFiles.emplace_back("");
+    inputFiles.emplace_back ("");
   }
 
-  auto showOnStartup = settings.value("launcher/showOnStartup");
-  if (noInputFiles && (showOnStartup.isNull() || showOnStartup.toBool())) {
+  auto showOnStartup = settings.value ("launcher/showOnStartup");
+  if (noInputFiles && (showOnStartup.isNull () || showOnStartup.toBool ())) {
     LaunchingScreen launcher;
-    if (launcher.exec() == QDialog::Accepted) {
-      if (launcher.isForceShowEditor()) {
-        settings.setValue("view/hideEditor", false);
+    if (launcher.exec () == QDialog::Accepted) {
+      if (launcher.isForceShowEditor ()) {
+        settings.setValue ("view/hideEditor", false);
       }
-      const QStringList files = launcher.selectedFiles();
+      const QStringList files = launcher.selectedFiles ();
       // If nothing is selected in the launching screen, leave
       // the "" dummy in inputFiles to open an empty MainWindow.
-      if (!files.empty()) {
-        inputFiles.clear();
-        for (const auto& f : files) {
-          inputFiles.push_back(f.toStdString());
+      if (!files.empty ()) {
+        inputFiles.clear ();
+        for (const auto &f : files) {
+          inputFiles.push_back (f.toStdString ());
         }
       }
     } else {
@@ -251,50 +248,50 @@ int gui(std::vector<std::string>& inputFiles, const std::filesystem::path& origi
   }
 
   QStringList inputFilesList;
-  for (const auto& infile: inputFiles) {
-    inputFilesList.append(assemblePath(original_path, infile));
+  for (const auto &infile : inputFiles) {
+    inputFilesList.append (assemblePath (original_path, infile));
   }
-  new MainWindow(inputFilesList);
-  QObject::connect(&app, &QCoreApplication::aboutToQuit, [](){
-    QSettingsCached{}.release();
+  new MainWindow (inputFilesList);
+  QObject::connect (&app, &QCoreApplication::aboutToQuit, [] () {
+    QSettingsCached{}.release ();
 #ifdef Q_OS_MACOS
-    CocoaUtils::endApplication();
+    CocoaUtils::endApplication ();
 #endif
   });
 
 #ifdef ENABLE_HIDAPI
-  if (Settings::Settings::inputEnableDriverHIDAPI.value()) {
-    auto hidApi = new HidApiInputDriver();
-    InputDriverManager::instance()->registerDriver(hidApi);
+  if (Settings::Settings::inputEnableDriverHIDAPI.value ()) {
+    auto hidApi = new HidApiInputDriver ();
+    InputDriverManager::instance ()->registerDriver (hidApi);
   }
 #endif
 #ifdef ENABLE_SPNAV
-  if (Settings::Settings::inputEnableDriverSPNAV.value()) {
-    auto spaceNavDriver = new SpaceNavInputDriver();
-    bool spaceNavDominantAxisOnly = Settings::Settings::inputEnableDriverHIDAPI.value();
-    spaceNavDriver->setDominantAxisOnly(spaceNavDominantAxisOnly);
-    InputDriverManager::instance()->registerDriver(spaceNavDriver);
+  if (Settings::Settings::inputEnableDriverSPNAV.value ()) {
+    auto spaceNavDriver = new SpaceNavInputDriver ();
+    bool spaceNavDominantAxisOnly = Settings::Settings::inputEnableDriverHIDAPI.value ();
+    spaceNavDriver->setDominantAxisOnly (spaceNavDominantAxisOnly);
+    InputDriverManager::instance ()->registerDriver (spaceNavDriver);
   }
 #endif
 #ifdef ENABLE_JOYSTICK
-  if (Settings::Settings::inputEnableDriverJOYSTICK.value()) {
-    std::string nr = STR(Settings::Settings::joystickNr.value());
-    auto joyDriver = new JoystickInputDriver();
-    joyDriver->setJoystickNr(nr);
-    InputDriverManager::instance()->registerDriver(joyDriver);
+  if (Settings::Settings::inputEnableDriverJOYSTICK.value ()) {
+    std::string nr = STR (Settings::Settings::joystickNr.value ());
+    auto joyDriver = new JoystickInputDriver ();
+    joyDriver->setJoystickNr (nr);
+    InputDriverManager::instance ()->registerDriver (joyDriver);
   }
 #endif
 #ifdef ENABLE_QGAMEPAD
-  if (Settings::Settings::inputEnableDriverQGAMEPAD.value()) {
-    auto qGamepadDriver = new QGamepadInputDriver();
-    InputDriverManager::instance()->registerDriver(qGamepadDriver);
+  if (Settings::Settings::inputEnableDriverQGAMEPAD.value ()) {
+    auto qGamepadDriver = new QGamepadInputDriver ();
+    InputDriverManager::instance ()->registerDriver (qGamepadDriver);
   }
 #endif
 #ifdef ENABLE_DBUS
-  if (Feature::ExperimentalInputDriverDBus.is_enabled()) {
-    if (Settings::Settings::inputEnableDriverDBUS.value()) {
-      auto dBusDriver = new DBusInputDriver();
-      InputDriverManager::instance()->registerDriver(dBusDriver);
+  if (Feature::ExperimentalInputDriverDBus.is_enabled ()) {
+    if (Settings::Settings::inputEnableDriverDBUS.value ()) {
+      auto dBusDriver = new DBusInputDriver ();
+      InputDriverManager::instance ()->registerDriver (dBusDriver);
     }
   }
 #endif
@@ -302,18 +299,17 @@ int gui(std::vector<std::string>& inputFiles, const std::filesystem::path& origi
 #ifdef ENABLE_GUI_TESTS
   // Adds a singleshot timer that will be executed when the application will be started.
   // the timer validates that each mainwindow respects the expected UX behavior.
-  if (gui_test != "none"){
-    QTimer::singleShot(0, [&]()
-    {
+  if (gui_test != "none") {
+    QTimer::singleShot (0, [&] () {
       int failureCount = 0;
-      for (auto w : app.windowManager.getWindows()){
-        failureCount += runAllTest(w);
+      for (auto w : app.windowManager.getWindows ()) {
+        failureCount += runAllTest (w);
       }
-      app.exit(failureCount);
+      app.exit (failureCount);
     });
   }
 #endif // ENABLE_GUI_TESTS
 
-  InputDriverManager::instance()->init();
-  return app.exec();
+  InputDriverManager::instance ()->init ();
+  return app.exec ();
 }
diff --git a/src/openscad_gui.h b/src/openscad_gui.h
index fec7c48d6..51a0c9a8b 100644
--- a/src/openscad_gui.h
+++ b/src/openscad_gui.h
@@ -31,4 +31,4 @@
 
 #include <filesystem>
 
-int gui(std::vector<std::string>& inputFiles, const std::filesystem::path& original_path, int argc, char **argv, const std::string&);
+int gui (std::vector<std::string> &inputFiles, const std::filesystem::path &original_path, int argc, char **argv, const std::string &);
diff --git a/src/openscad_mimalloc.h b/src/openscad_mimalloc.h
index 562157e26..5209e0aac 100644
--- a/src/openscad_mimalloc.h
+++ b/src/openscad_mimalloc.h
@@ -5,18 +5,24 @@
 #if 0 // defined(_WIN32) && defined(MI_LINK_SHARED)
 // mimalloc doesn't support static override of malloc on Windows.
 // This include causes crashes if mimalloc is statically linked.
-  #include <mimalloc-new-delete.h>
+#include <mimalloc-new-delete.h>
 #else
-  #include <mimalloc.h>
+#include <mimalloc.h>
 #endif
 
 #if defined(ENABLE_CGAL)
 #include <cstddef>
 // gmp requires function signature with extra oldsize parameters for some reason.
-inline void *gmp_realloc(void *ptr, size_t /*oldsize*/, size_t newsize) { return mi_realloc(ptr, newsize); }
-inline void gmp_free(void *ptr, size_t /*oldsize*/) { mi_free(ptr); }
-  #include <gmp.h>
-inline void init_mimalloc() { mp_set_memory_functions(mi_malloc, gmp_realloc, gmp_free); }
+inline void *gmp_realloc (void *ptr, size_t /*oldsize*/, size_t newsize) {
+  return mi_realloc (ptr, newsize);
+}
+inline void gmp_free (void *ptr, size_t /*oldsize*/) {
+  mi_free (ptr);
+}
+#include <gmp.h>
+inline void init_mimalloc () {
+  mp_set_memory_functions (mi_malloc, gmp_realloc, gmp_free);
+}
 #endif // ENABLE_CGAL
 
 #endif // USE_MIMALLOC
diff --git a/src/platform/CocoaUtils.h b/src/platform/CocoaUtils.h
index 234622ac7..bb3436282 100644
--- a/src/platform/CocoaUtils.h
+++ b/src/platform/CocoaUtils.h
@@ -5,6 +5,6 @@
 class CocoaUtils
 {
 public:
-  static void endApplication();
-  static void nslog(const std::string& str, void *userdata);
+  static void endApplication ();
+  static void nslog (const std::string &str, void *userdata);
 };
diff --git a/src/platform/PlatformUtils-posix.cc b/src/platform/PlatformUtils-posix.cc
index b7c32bb39..960226399 100644
--- a/src/platform/PlatformUtils-posix.cc
+++ b/src/platform/PlatformUtils-posix.cc
@@ -18,27 +18,25 @@ namespace fs = std::filesystem;
 
 static std::mutex user_agent_mutex;
 
-static std::string readText(const std::string& path)
-{
-  std::ifstream s{path.c_str()};
-  s.seekg(0, std::ios::end);
-  if (s.fail() || s.tellg() > 4096) {
+static std::string readText (const std::string &path) {
+  std::ifstream s{path.c_str ()};
+  s.seekg (0, std::ios::end);
+  if (s.fail () || s.tellg () > 4096) {
     return "";
   }
-  s.seekg(0, std::ios::beg);
+  s.seekg (0, std::ios::beg);
 
-  std::string text{(std::istreambuf_iterator<char>(s)), std::istreambuf_iterator<char>()};
+  std::string text{(std::istreambuf_iterator<char> (s)), std::istreambuf_iterator<char> ()};
   return text;
 }
 
 // see http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html
-static fs::path getXdgConfigDir()
-{
-  const char *xdg_env = getenv("XDG_CONFIG_HOME");
-  if (xdg_env && fs::exists(fs::path{xdg_env})) {
+static fs::path getXdgConfigDir () {
+  const char *xdg_env = getenv ("XDG_CONFIG_HOME");
+  if (xdg_env && fs::exists (fs::path{xdg_env})) {
     return fs::path{xdg_env};
   } else {
-    const char *home = getenv("HOME");
+    const char *home = getenv ("HOME");
     if (home) {
       return fs::path{home} / ".config";
     }
@@ -52,81 +50,75 @@ static fs::path getXdgConfigDir()
 // user-dirs.dirs file generated by the xdg-user-dirs-update tool. Missing
 // is any handling of shell style quotes so this may fail with unusual
 // setup.
-static std::string getXdgUserDir(const std::string& dir)
-{
-  const fs::path config_dir = getXdgConfigDir() / "user-dirs.dirs";
-  const std::string user_dirs{readText(config_dir.generic_string())};
+static std::string getXdgUserDir (const std::string &dir) {
+  const fs::path config_dir = getXdgConfigDir () / "user-dirs.dirs";
+  const std::string user_dirs{readText (config_dir.generic_string ())};
 
   boost::smatch results;
   boost::regex documents_dir{"^" + dir + "=\"[$]HOME/([^\"]+)\""};
-  if (boost::regex_search(user_dirs, results, documents_dir)) {
+  if (boost::regex_search (user_dirs, results, documents_dir)) {
     return results[1];
   }
 
   return "";
 }
 
-std::string PlatformUtils::pathSeparatorChar()
-{
+std::string PlatformUtils::pathSeparatorChar () {
   return ":";
 }
 
-std::string PlatformUtils::userDocumentsPath()
-{
+std::string PlatformUtils::userDocumentsPath () {
   fs::path user_documents_path;
 
-  const char *xdg_env = getenv("XDG_DOCUMENTS_DIR");
-  if (xdg_env && fs::exists(fs::path(xdg_env))) {
-    user_documents_path = fs::path(xdg_env);
+  const char *xdg_env = getenv ("XDG_DOCUMENTS_DIR");
+  if (xdg_env && fs::exists (fs::path (xdg_env))) {
+    user_documents_path = fs::path (xdg_env);
   } else {
-    const char *home = getenv("HOME");
+    const char *home = getenv ("HOME");
     if (home) {
       fs::path home_path{home};
-      const auto user_dirs = getXdgUserDir("XDG_DOCUMENTS_DIR");
-      if (!user_dirs.empty() && fs::exists(home_path / user_dirs)) {
+      const auto user_dirs = getXdgUserDir ("XDG_DOCUMENTS_DIR");
+      if (!user_dirs.empty () && fs::exists (home_path / user_dirs)) {
         user_documents_path = home_path / user_dirs;
-      } else if (fs::exists(fs::path(home))) {
-        user_documents_path = fs::path(home);
+      } else if (fs::exists (fs::path (home))) {
+        user_documents_path = fs::path (home);
       }
     }
   }
 
-  if (fs::is_directory(user_documents_path)) {
-    return fs::absolute(user_documents_path).generic_string();
+  if (fs::is_directory (user_documents_path)) {
+    return fs::absolute (user_documents_path).generic_string ();
   }
 
   return "";
 }
 
-std::string PlatformUtils::documentsPath()
-{
-  const char *home = getenv("HOME");
+std::string PlatformUtils::documentsPath () {
+  const char *home = getenv ("HOME");
   if (home) {
-    fs::path docpath(home);
+    fs::path docpath (home);
     docpath = docpath / ".local" / "share";
-    return docpath.generic_string();
+    return docpath.generic_string ();
   } else {
     return "";
   }
 }
 
-std::string PlatformUtils::userConfigPath()
-{
-  const fs::path config_path{getXdgConfigDir() / OPENSCAD_FOLDER_NAME};
+std::string PlatformUtils::userConfigPath () {
+  const fs::path config_path{getXdgConfigDir () / OPENSCAD_FOLDER_NAME};
 
-  if (fs::is_directory(config_path)) {
-    return fs::absolute(config_path).generic_string();
+  if (fs::is_directory (config_path)) {
+    return fs::absolute (config_path).generic_string ();
   }
 
   return "";
 }
 
-unsigned long PlatformUtils::stackLimit()
-{
+unsigned long PlatformUtils::stackLimit () {
 #ifndef __EMSCRIPTEN__
   struct rlimit limit;
 
-  int ret = getrlimit(RLIMIT_STACK, &limit);
+  int ret = getrlimit (RLIMIT_STACK, &limit);
   if (ret == 0) {
     if (limit.rlim_cur == RLIM_INFINITY) {
       return STACK_LIMIT_DEFAULT;
@@ -152,64 +144,59 @@ unsigned long PlatformUtils::stackLimit()
  * @see http://www.freedesktop.org/software/systemd/man/os-release.html
  * @return the PRETTY_NAME from the os-release file or an empty string.
  */
-static const std::string checkOsRelease()
-{
-  std::string os_release(readText("/etc/os-release"));
+static const std::string checkOsRelease () {
+  std::string os_release (readText ("/etc/os-release"));
 
   boost::smatch results;
-  boost::regex pretty_name("^PRETTY_NAME=\"([^\"]+)\"");
-  if (boost::regex_search(os_release, results, pretty_name)) {
+  boost::regex pretty_name ("^PRETTY_NAME=\"([^\"]+)\"");
+  if (boost::regex_search (os_release, results, pretty_name)) {
     return results[1];
   }
 
   return "";
 }
 
-static const std::string checkEtcIssue()
-{
-  std::string issue(readText("/etc/issue"));
+static const std::string checkEtcIssue () {
+  std::string issue (readText ("/etc/issue"));
 
-  boost::regex nl("\n.*$");
-  issue = boost::regex_replace(issue, nl, "");
-  boost::regex esc("\\\\.");
-  issue = boost::regex_replace(issue, esc, "");
-  boost::algorithm::trim(issue);
+  boost::regex nl ("\n.*$");
+  issue = boost::regex_replace (issue, nl, "");
+  boost::regex esc ("\\\\.");
+  issue = boost::regex_replace (issue, esc, "");
+  boost::algorithm::trim (issue);
 
   return issue;
 }
 
-static const std::string detectDistribution()
-{
-  std::string osrelease = checkOsRelease();
-  if (!osrelease.empty()) {
+static const std::string detectDistribution () {
+  std::string osrelease = checkOsRelease ();
+  if (!osrelease.empty ()) {
     return osrelease;
   }
 
-  std::string etcissue = checkEtcIssue();
-  if (!etcissue.empty()) {
+  std::string etcissue = checkEtcIssue ();
+  if (!etcissue.empty ()) {
     return etcissue;
   }
 
   return "";
 }
 
-static const std::string get_distribution(const std::string& separator)
-{
+static const std::string get_distribution (const std::string &separator) {
   std::string result;
-  std::string distribution = detectDistribution();
-  if (!distribution.empty()) {
+  std::string distribution = detectDistribution ();
+  if (!distribution.empty ()) {
     result += separator;
     result += distribution;
   }
   return result;
 }
 
-static const std::string get_system_info(bool extended = true)
-{
+static const std::string get_system_info (bool extended = true) {
   std::string result;
 
   struct utsname osinfo;
-  if (uname(&osinfo) == 0) {
+  if (uname (&osinfo) == 0) {
     result += osinfo.sysname;
     result += " ";
     if (extended) {
@@ -226,47 +213,45 @@ static const std::string get_system_info(bool extended = true)
   return result;
 }
 
-const std::string PlatformUtils::user_agent()
-{
+const std::string PlatformUtils::user_agent () {
   static std::string result;
 
-  std::lock_guard<std::mutex> lock(user_agent_mutex);
+  std::lock_guard<std::mutex> lock (user_agent_mutex);
 
-  if (result.empty()) {
+  if (result.empty ()) {
     result += "OpenSCAD/";
     result += openscad_detailedversionnumber;
     result += " (";
-    result += get_system_info(false);
-    result += get_distribution("; ");
+    result += get_system_info (false);
+    result += get_distribution ("; ");
     result += ")";
   }
 
   return result;
 }
 
-const std::string PlatformUtils::sysinfo(bool extended)
-{
+const std::string PlatformUtils::sysinfo (bool extended) {
   std::string result;
 
-  result += get_system_info(true);
-  result += get_distribution(" ");
+  result += get_system_info (true);
+  result += get_distribution (" ");
 
   if (extended) {
-    long numcpu = sysconf(_SC_NPROCESSORS_ONLN);
+    long numcpu = sysconf (_SC_NPROCESSORS_ONLN);
     if (numcpu > 0) {
       result += " ";
-      result += std::to_string(numcpu);
+      result += std::to_string (numcpu);
       result += " CPU";
       if (numcpu > 1) {
         result += "s";
       }
     }
 
-    long pages = sysconf(_SC_PHYS_PAGES);
-    long pagesize = sysconf(_SC_PAGE_SIZE);
+    long pages = sysconf (_SC_PHYS_PAGES);
+    long pagesize = sysconf (_SC_PAGE_SIZE);
     if ((pages > 0) && (pagesize > 0)) {
       result += " ";
-      result += PlatformUtils::toMemorySizeString(pages * pagesize, 2);
+      result += PlatformUtils::toMemorySizeString (pages * pagesize, 2);
       result += " RAM";
     }
   }
@@ -274,4 +259,4 @@ const std::string PlatformUtils::sysinfo(bool extended)
   return result;
 }
 
-void PlatformUtils::ensureStdIO() {}
+void PlatformUtils::ensureStdIO () {}
diff --git a/src/platform/PlatformUtils-win.cc b/src/platform/PlatformUtils-win.cc
index 0243ece1d..86777cd63 100644
--- a/src/platform/PlatformUtils-win.cc
+++ b/src/platform/PlatformUtils-win.cc
@@ -24,70 +24,66 @@
 
 #include "version.h"
 
-std::string PlatformUtils::pathSeparatorChar()
-{
+std::string PlatformUtils::pathSeparatorChar () {
   return ";";
 }
 
 // convert from windows api w_char strings (usually utf16) to utf8 std::string
-std::string winapi_wstr_to_utf8(std::wstring wstr)
-{
+std::string winapi_wstr_to_utf8 (std::wstring wstr) {
   UINT CodePage = CP_UTF8;
   DWORD dwFlags = 0;
   LPCWSTR lpWideCharStr = &wstr[0];
-  int cchWideChar = static_cast<int>(wstr.size());
+  int cchWideChar = static_cast<int> (wstr.size ());
   LPSTR lpMultiByteStr = nullptr;
   int cbMultiByte = 0;
   LPCSTR lpDefaultChar = nullptr;
   LPBOOL lpUsedDefaultChar = nullptr;
 
-  int numbytes = WideCharToMultiByte(CodePage, dwFlags, lpWideCharStr,
-                                     cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar);
+  int numbytes = WideCharToMultiByte (CodePage, dwFlags, lpWideCharStr,
+                                      cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar);
 
   // LOG(message_group::NONE,,"utf16 to utf8 conversion: numbytes %1$i",numbytes);
 
-  std::string utf8_str(numbytes, 0);
+  std::string utf8_str (numbytes, 0);
   lpMultiByteStr = &utf8_str[0];
   cbMultiByte = numbytes;
 
-  int result = WideCharToMultiByte(CodePage, dwFlags, lpWideCharStr,
-                                   cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar);
+  int result = WideCharToMultiByte (CodePage, dwFlags, lpWideCharStr,
+                                    cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar);
 
   if (result != numbytes) {
-    DWORD errcode = GetLastError();
-    LOG(message_group::Error, "Error converting w_char str to utf8 string");
-    LOG(message_group::Error, "error code %1$i", errcode);
+    DWORD errcode = GetLastError ();
+    LOG (message_group::Error, "Error converting w_char str to utf8 string");
+    LOG (message_group::Error, "error code %1$i", errcode);
   }
 
   return utf8_str;
 }
 
 // see http://msdn.microsoft.com/en-us/library/windows/desktop/bb762494%28v=vs.85%29.aspx
-static const std::string getFolderPath(int nFolder)
-{
-  std::wstring path(MAX_PATH, 0);
+static const std::string getFolderPath (int nFolder) {
+  std::wstring path (MAX_PATH, 0);
 
   HWND hwndOwner = 0;
   HANDLE hToken = nullptr;
   DWORD dwFlags = SHGFP_TYPE_CURRENT;
   LPWSTR pszPath = &path[0];
 
-  int result = SHGetFolderPathW(hwndOwner, nFolder, hToken, dwFlags, pszPath);
+  int result = SHGetFolderPathW (hwndOwner, nFolder, hToken, dwFlags, pszPath);
 
   if (result == S_OK) {
-    path = std::wstring(path.c_str() ); // strip extra nullptrs
+    path = std::wstring (path.c_str ()); // strip extra nullptrs
     // Use std::filesystem to decide how to convert from wstring
     // to string. Normally the path encoding is system local and
     // we don't want to force conversion to UTF-8.
-    fs::path p(path);
-    return p.string();
+    fs::path p (path);
+    return p.string ();
   }
   return "";
 }
 
-std::string PlatformUtils::userDocumentsPath()
-{
-  return documentsPath();
+std::string PlatformUtils::userDocumentsPath () {
+  return documentsPath ();
 }
 
 // retrieve the path to 'My Documents' for the current user under windows
@@ -95,69 +91,63 @@ std::string PlatformUtils::userDocumentsPath()
 // In Vista, 7, 8+ this is 'c:\users\username\documents'
 // This code may have problems with unusual dir types in Vista because
 // Mingw does not provide access to the updated SHGetKnownFolderPath
-std::string PlatformUtils::documentsPath()
-{
-  const std::string retval = getFolderPath(CSIDL_PERSONAL);
-  if (retval.empty()) {
-    LOG(message_group::Error, "Could not find My Documents location");
+std::string PlatformUtils::documentsPath () {
+  const std::string retval = getFolderPath (CSIDL_PERSONAL);
+  if (retval.empty ()) {
+    LOG (message_group::Error, "Could not find My Documents location");
   }
   return retval;
 }
 
-std::string PlatformUtils::userConfigPath()
-{
-  const std::string retval = getFolderPath(CSIDL_LOCAL_APPDATA);
-  if (retval.empty()) {
-    LOG(message_group::Error, "Could not find Local AppData location");
+std::string PlatformUtils::userConfigPath () {
+  const std::string retval = getFolderPath (CSIDL_LOCAL_APPDATA);
+  if (retval.empty ()) {
+    LOG (message_group::Error, "Could not find Local AppData location");
   }
-  return retval + std::string("/") + PlatformUtils::OPENSCAD_FOLDER_NAME;
+  return retval + std::string ("/") + PlatformUtils::OPENSCAD_FOLDER_NAME;
 }
 
-unsigned long PlatformUtils::stackLimit()
-{
+unsigned long PlatformUtils::stackLimit () {
   return STACK_LIMIT_DEFAULT;
 }
 
 // NOLINTNEXTLINE(modernize-use-using)
-typedef BOOL (WINAPI *LPFN_ISWOW64PROCESS)(HANDLE, PBOOL);
+typedef BOOL (WINAPI *LPFN_ISWOW64PROCESS) (HANDLE, PBOOL);
 
 // see http://msdn.microsoft.com/en-us/library/windows/desktop/ms684139%28v=vs.85%29.aspx
-static BOOL IsWow64()
-{
+static BOOL IsWow64 () {
   BOOL bIsWow64 = FALSE;
 
   //IsWow64Process is not available on all supported versions of Windows.
   //Use GetModuleHandle to get a handle to the DLL that contains the function
   //and GetProcAddress to get a pointer to the function if available.
-  LPFN_ISWOW64PROCESS fnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress(GetModuleHandle(TEXT("kernel32")), "IsWow64Process");
+  LPFN_ISWOW64PROCESS fnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress (GetModuleHandle (TEXT ("kernel32")), "IsWow64Process");
 
   if (nullptr != fnIsWow64Process) {
-    if (!fnIsWow64Process(GetCurrentProcess(), &bIsWow64)) {
+    if (!fnIsWow64Process (GetCurrentProcess (), &bIsWow64)) {
       return false;
     }
   }
   return bIsWow64;
 }
 
-const std::string PlatformUtils::user_agent()
-{
+const std::string PlatformUtils::user_agent () {
   std::string result;
 
   result += "OpenSCAD/";
   result += openscad_detailedversionnumber;
   result += " (";
-  result += sysinfo(false);
+  result += sysinfo (false);
   result += ")";
 
   return result;
 }
 
-const std::string PlatformUtils::sysinfo(bool extended)
-{
+const std::string PlatformUtils::sysinfo (bool extended) {
   std::string result;
 
   SYSTEM_INFO si;
-  GetSystemInfo(&si);
+  GetSystemInfo (&si);
   std::map<WORD, const char *> archs;
   archs[PROCESSOR_ARCHITECTURE_AMD64] = "x86_64";
   archs[PROCESSOR_ARCHITECTURE_ARM] = "arm";
@@ -167,39 +157,39 @@ const std::string PlatformUtils::sysinfo(bool extended)
   archs[PROCESSOR_ARCHITECTURE_UNKNOWN] = "unknown";
 
   OSVERSIONINFOEX osinfo;
-  osinfo.dwOSVersionInfoSize = sizeof(osinfo);
+  osinfo.dwOSVersionInfoSize = sizeof (osinfo);
 
-  if (GetVersionExEx(&osinfo) == 0) {
+  if (GetVersionExEx (&osinfo) == 0) {
     result += "Microsoft Windows Unknown Version";
   } else {
     int majorVersion = osinfo.dwMajorVersion;
     if (majorVersion == 10 && osinfo.dwBuildNumber >= 22000) {
       majorVersion = 11;
     }
-    boost::format fmt("Microsoft Windows %d (%d.%d.%d) %s");
+    boost::format fmt ("Microsoft Windows %d (%d.%d.%d) %s");
     fmt % majorVersion % osinfo.dwMajorVersion % osinfo.dwMinorVersion % osinfo.dwBuildNumber % archs[si.wProcessorArchitecture];
-    result += fmt.str();
+    result += fmt.str ();
   }
 
   SYSTEM_INFO systeminfo;
-  bool isWow64 = IsWow64();
+  bool isWow64 = IsWow64 ();
   if (isWow64) {
-    GetNativeSystemInfo(&systeminfo);
+    GetNativeSystemInfo (&systeminfo);
   } else {
-    GetSystemInfo(&systeminfo);
+    GetSystemInfo (&systeminfo);
   }
 
   if (extended) {
     int numcpu = systeminfo.dwNumberOfProcessors;
-    boost::format fmt(" %d CPU%s%s");
+    boost::format fmt (" %d CPU%s%s");
     fmt % numcpu % (numcpu > 1 ? "s" : "") % (isWow64 ? " WOW64" : "");
-    result += fmt.str();
+    result += fmt.str ();
 
     MEMORYSTATUSEX memoryinfo;
-    memoryinfo.dwLength = sizeof(memoryinfo);
-    if (GlobalMemoryStatusEx(&memoryinfo) != 0) {
+    memoryinfo.dwLength = sizeof (memoryinfo);
+    if (GlobalMemoryStatusEx (&memoryinfo) != 0) {
       result += " ";
-      result += PlatformUtils::toMemorySizeString(memoryinfo.ullTotalPhys, 2);
+      result += PlatformUtils::toMemorySizeString (memoryinfo.ullTotalPhys, 2);
       result += " RAM";
     }
   }
@@ -213,35 +203,36 @@ const std::string PlatformUtils::sysinfo(bool extended)
 #ifdef USE_MIMALLOC
 #include <mimalloc.h>
 // mimalloc needs an output handler that references stderr after we mess with it.
-static void mi_output(const char *msg, void *arg) {
-  fputs(msg, stderr);
+static void mi_output (const char *msg, void *arg) {
+  fputs (msg, stderr);
 }
 #endif
 
 // attach to parent console if standard IO handles not available
 // It may be good idea to redirect the output to file(s) here in some future.
-void PlatformUtils::ensureStdIO(void)
-{
+void PlatformUtils::ensureStdIO (void) {
   // Preserve existing handles whenever available.
   // HANDLE hRead = (HANDLE)_get_osfhandle(_fileno(stdin));
-  HANDLE hWrite = (HANDLE)_get_osfhandle(_fileno(stdout));
-  HANDLE hError = (HANDLE)_get_osfhandle(_fileno(stderr));
+  HANDLE hWrite = (HANDLE)_get_osfhandle (_fileno (stdout));
+  HANDLE hError = (HANDLE)_get_osfhandle (_fileno (stderr));
 
   if (/* INVALID_HANDLE_VALUE == hRead || */ INVALID_HANDLE_VALUE == hWrite || INVALID_HANDLE_VALUE == hError) {
 
     // I see nothing to do about error(s) here.
-    if (AttachConsole(ATTACH_PARENT_PROCESS)) {
+    if (AttachConsole (ATTACH_PARENT_PROCESS)) {
 
       // Let CRT machinery performs proper setup.
       // if (INVALID_HANDLE_VALUE == hRead) (void)_wfreopen(L"CONIN$",  L"rt", stdin);
-      if (INVALID_HANDLE_VALUE == hWrite) (void)_wfreopen(L"CONOUT$",  L"wt", stdout);
-      if (INVALID_HANDLE_VALUE == hError) (void)_wfreopen(L"CONOUT$",  L"wt", stderr);
+      if (INVALID_HANDLE_VALUE == hWrite)
+        (void)_wfreopen (L"CONOUT$", L"wt", stdout);
+      if (INVALID_HANDLE_VALUE == hError)
+        (void)_wfreopen (L"CONOUT$", L"wt", stderr);
 
-      std::ios_base::sync_with_stdio();
+      std::ios_base::sync_with_stdio ();
     }
   }
 
 #ifdef USE_MIMALLOC
-  mi_register_output(&mi_output, nullptr);
+  mi_register_output (&mi_output, nullptr);
 #endif
 }
diff --git a/src/platform/PlatformUtils.cc b/src/platform/PlatformUtils.cc
index ab43b267a..70c053a69 100644
--- a/src/platform/PlatformUtils.cc
+++ b/src/platform/PlatformUtils.cc
@@ -23,41 +23,37 @@ namespace {
 bool path_initialized = false;
 std::string applicationpath;
 std::string resourcespath;
-}
+} // namespace
 
 const char *PlatformUtils::OPENSCAD_FOLDER_NAME = "OpenSCAD";
 
-static std::string lookupResourcesPath()
-{
-  fs::path resourcedir(applicationpath);
-  PRINTDB("Looking up resource folder with application path '%s'", resourcedir.generic_string().c_str());
+static std::string lookupResourcesPath () {
+  fs::path resourcedir (applicationpath);
+  PRINTDB ("Looking up resource folder with application path '%s'", resourcedir.generic_string ().c_str ());
 
 #ifdef __APPLE__
   const char *searchpath[] = {
     "../Resources", // Resources can be bundled on Mac.
     "../../..", // Dev location
     "../../../..", // Test location (cmake)
-    "..",   // Test location
-    RESOURCE_FOLDER("../share/openscad"), // Unix mode
-    nullptr
-  };
+    "..", // Test location
+    RESOURCE_FOLDER ("../share/openscad"), // Unix mode
+    nullptr};
 #else
 #ifdef _WIN32
   const char *searchpath[] = {
     ".", // Release location
-    RESOURCE_FOLDER("../share/openscad"), // MSYS2 location
+    RESOURCE_FOLDER ("../share/openscad"), // MSYS2 location
     "..", // Dev location
-    nullptr
-  };
+    nullptr};
 #else
   const char *searchpath[] = {
-    RESOURCE_FOLDER("../share/openscad"),
-    RESOURCE_FOLDER("../../share/openscad"),
+    RESOURCE_FOLDER ("../share/openscad"),
+    RESOURCE_FOLDER ("../../share/openscad"),
     ".",
     "..",
     "../..",
-    nullptr
-  };
+    nullptr};
 #endif // ifdef _WIN32
 #endif // ifdef __APPLE__
 
@@ -68,171 +64,165 @@ static std::string lookupResourcesPath()
     // The resource folder is the folder which contains "color-schemes" (as well as
     // "examples" and "locale", and optionally "libraries" and "fonts")
     const fs::path checkdir = tmpdir / "color-schemes";
-    PRINTDB("Checking '%s'", checkdir.generic_string().c_str());
+    PRINTDB ("Checking '%s'", checkdir.generic_string ().c_str ());
 
-    if (is_directory(checkdir)) {
+    if (is_directory (checkdir)) {
       resourcedir = tmpdir;
-      PRINTDB("Found resource folder '%s'", tmpdir.generic_string().c_str());
+      PRINTDB ("Found resource folder '%s'", tmpdir.generic_string ().c_str ());
       break;
     }
   }
 
   // resourcedir defaults to applicationPath
 #ifndef __EMSCRIPTEN__
-  resourcedir = fs::canonical(resourcedir);
+  resourcedir = fs::canonical (resourcedir);
 #endif
-  std::string result = resourcedir.generic_string();
-  PRINTDB("Using resource folder '%s'", result);
+  std::string result = resourcedir.generic_string ();
+  PRINTDB ("Using resource folder '%s'", result);
   return result;
 }
 
-void PlatformUtils::registerApplicationPath(const std::string& apppath)
-{
+void PlatformUtils::registerApplicationPath (const std::string &apppath) {
   applicationpath = apppath;
-  resourcespath = lookupResourcesPath();
+  resourcespath = lookupResourcesPath ();
   path_initialized = true;
 }
 
-std::string PlatformUtils::applicationPath()
-{
+std::string PlatformUtils::applicationPath () {
   if (!path_initialized) {
-    throw std::runtime_error("PlatformUtils::applicationPath(): application path not initialized!");
+    throw std::runtime_error ("PlatformUtils::applicationPath(): application path not initialized!");
   }
   return applicationpath;
 }
 
-bool PlatformUtils::createUserLibraryPath()
-{
-  std::string path = PlatformUtils::userLibraryPath();
+bool PlatformUtils::createUserLibraryPath () {
+  std::string path = PlatformUtils::userLibraryPath ();
   bool OK = false;
   try {
-    if (!fs::exists(fs::path(path))) {
-      LOG("Creating library folder %1$s", path);
-      OK = fs::create_directories(path);
+    if (!fs::exists (fs::path (path))) {
+      LOG ("Creating library folder %1$s", path);
+      OK = fs::create_directories (path);
     }
     if (!OK) {
-      LOG(message_group::Error, "Cannot create %1$s", path);
+      LOG (message_group::Error, "Cannot create %1$s", path);
     }
-  } catch (const fs::filesystem_error& ex) {
-    LOG(message_group::Error, "%1$s", ex.what());
+  } catch (const fs::filesystem_error &ex) {
+    LOG (message_group::Error, "%1$s", ex.what ());
   }
   return OK;
 }
 
-std::string PlatformUtils::userPath(const std::string& name)
-{
+std::string PlatformUtils::userPath (const std::string &name) {
   fs::path path;
   try {
-    std::string pathstr = PlatformUtils::documentsPath();
-    if (pathstr == "") return "";
-    path = fs::path(pathstr);
-    if (!fs::exists(path)) return "";
+    std::string pathstr = PlatformUtils::documentsPath ();
+    if (pathstr == "")
+      return "";
+    path = fs::path (pathstr);
+    if (!fs::exists (path))
+      return "";
 #ifndef __EMSCRIPTEN__
-    path = fs::canonical(path);
+    path = fs::canonical (path);
 #endif
     // LOG(message_group::NONE,,"path size %1$i",fs::stringy(path).size());
     // LOG(message_group::NONE,,"lib path found: [%1$s]",path);
-    if (path.empty()) return "";
+    if (path.empty ())
+      return "";
     path /= OPENSCAD_FOLDER_NAME;
     path /= name;
     // LOG(message_group::NONE,,"Appended path %1$s",path);
     // LOG(message_group::NONE,,"Exists: %1$i",fs::exists(path));
-  } catch (const fs::filesystem_error& ex) {
-    LOG(message_group::Error, "%1$s", ex.what());
+  } catch (const fs::filesystem_error &ex) {
+    LOG (message_group::Error, "%1$s", ex.what ());
   }
-  return path.generic_string();
+  return path.generic_string ();
 }
 
-std::string PlatformUtils::userLibraryPath()
-{
-  return userPath("libraries");
+std::string PlatformUtils::userLibraryPath () {
+  return userPath ("libraries");
 }
 
-std::string PlatformUtils::userExamplesPath()
-{
-  return userPath("examples");
+std::string PlatformUtils::userExamplesPath () {
+  return userPath ("examples");
 }
 
-std::string PlatformUtils::backupPath()
-{
+std::string PlatformUtils::backupPath () {
   fs::path path;
   try {
-    std::string pathstr = PlatformUtils::documentsPath();
-    if (pathstr == "") return "";
-    path = fs::path(pathstr);
-    if (!fs::exists(path)) return "";
+    std::string pathstr = PlatformUtils::documentsPath ();
+    if (pathstr == "")
+      return "";
+    path = fs::path (pathstr);
+    if (!fs::exists (path))
+      return "";
 #ifndef __EMSCRIPTEN__
-    path = fs::canonical(path);
+    path = fs::canonical (path);
 #endif
-    if (path.empty()) return "";
+    if (path.empty ())
+      return "";
     path /= OPENSCAD_FOLDER_NAME;
     path /= "backups";
-  } catch (const fs::filesystem_error& ex) {
-    LOG(message_group::Error, "%1$s", ex.what());
+  } catch (const fs::filesystem_error &ex) {
+    LOG (message_group::Error, "%1$s", ex.what ());
   }
-  return path.generic_string();
+  return path.generic_string ();
 }
 
-bool PlatformUtils::createBackupPath()
-{
-  std::string path = PlatformUtils::backupPath();
+bool PlatformUtils::createBackupPath () {
+  std::string path = PlatformUtils::backupPath ();
   bool OK = false;
   try {
-    if (!fs::exists(fs::path(path))) {
-      OK = fs::create_directories(path);
+    if (!fs::exists (fs::path (path))) {
+      OK = fs::create_directories (path);
     }
     if (!OK) {
-      LOG(message_group::Error, "Cannot create %1$s", path);
+      LOG (message_group::Error, "Cannot create %1$s", path);
     }
-  } catch (const fs::filesystem_error& ex) {
-    LOG(message_group::Error, "%1$s", ex.what());
+  } catch (const fs::filesystem_error &ex) {
+    LOG (message_group::Error, "%1$s", ex.what ());
   }
   return OK;
 }
 
 // This is the built-in read-only resources path
-std::string PlatformUtils::resourceBasePath()
-{
+std::string PlatformUtils::resourceBasePath () {
   if (!path_initialized) {
-    throw std::runtime_error("PlatformUtils::resourcesPath(): application path not initialized!");
+    throw std::runtime_error ("PlatformUtils::resourcesPath(): application path not initialized!");
   }
   return resourcespath;
 }
 
-fs::path PlatformUtils::resourcePath(const std::string& resource)
-{
-  fs::path base(resourceBasePath());
-  if (!fs::is_directory(base)) {
+fs::path PlatformUtils::resourcePath (const std::string &resource) {
+  fs::path base (resourceBasePath ());
+  if (!fs::is_directory (base)) {
     return {};
   }
 
   fs::path resource_dir = base / resource;
-  if (!fs::is_directory(resource_dir)) {
+  if (!fs::is_directory (resource_dir)) {
     return {};
   }
 
   return resource_dir;
 }
 
-int PlatformUtils::setenv(const char *name, const char *value, int overwrite)
-{
+int PlatformUtils::setenv (const char *name, const char *value, int overwrite) {
 #if defined(_WIN32)
-  const char *ptr = getenv(name);
+  const char *ptr = getenv (name);
   if ((overwrite == 0) && (ptr != nullptr)) {
     return 0;
   }
 
   char buf[4096];
-  snprintf(buf, sizeof(buf), "%s=%s", name, value);
-  return _putenv(buf);
+  snprintf (buf, sizeof (buf), "%s=%s", name, value);
+  return _putenv (buf);
 #else
-  return ::setenv(name, value, overwrite);
+  return ::setenv (name, value, overwrite);
 #endif
 }
 
-std::string PlatformUtils::toMemorySizeString(uint64_t bytes, int digits)
-{
-  static const char *units[] = { "B", "kB", "MB", "GB", "TB", nullptr };
+std::string PlatformUtils::toMemorySizeString (uint64_t bytes, int digits) {
+  static const char *units[] = {"B", "kB", "MB", "GB", "TB", nullptr};
 
   int idx = 0;
   double val = bytes;
@@ -247,7 +237,7 @@ std::string PlatformUtils::toMemorySizeString(uint64_t bytes, int digits)
     val /= 1024.0;
   }
 
-  boost::format fmt("%f %s");
-  fmt % boost::io::group(std::setprecision(digits), val) % units[idx];
-  return fmt.str();
+  boost::format fmt ("%f %s");
+  fmt % boost::io::group (std::setprecision (digits), val) % units[idx];
+  return fmt.str ();
 }
diff --git a/src/platform/PlatformUtils.h b/src/platform/PlatformUtils.h
index 266624f91..fcaffdcd4 100644
--- a/src/platform/PlatformUtils.h
+++ b/src/platform/PlatformUtils.h
@@ -13,8 +13,8 @@ static constexpr size_t STACK_LIMIT_DEFAULT = size_t{STACKSIZE} - STACK_BUFFER_S
 namespace PlatformUtils {
 extern const char *OPENSCAD_FOLDER_NAME;
 
-void registerApplicationPath(const std::string& applicationpath);
-std::string applicationPath();
+void registerApplicationPath (const std::string &applicationpath);
+std::string applicationPath ();
 
 /**
  * The OpenSCAD document path which is used for searching user
@@ -25,7 +25,7 @@ std::string applicationPath();
  *
  * @return the application documents path
  */
-std::string documentsPath();
+std::string documentsPath ();
 /**
  * The user documents path where files are saved/exported to by
  * default. On Linux this is the $XDG_DOCUMENTS_DIR, if this is
@@ -34,12 +34,12 @@ std::string documentsPath();
  *
  * @return the path for saving user documents
  */
-std::string userPath(const std::string& name);
-std::string userDocumentsPath();
-std::string resourceBasePath();
-fs::path resourcePath(const std::string& resource);
-std::string userLibraryPath();
-std::string userExamplesPath();
+std::string userPath (const std::string &name);
+std::string userDocumentsPath ();
+std::string resourceBasePath ();
+fs::path resourcePath (const std::string &resource);
+std::string userLibraryPath ();
+std::string userExamplesPath ();
 
 /**
  * Base path where user configuration can be read and written to. On
@@ -51,11 +51,11 @@ std::string userExamplesPath();
  * @return absolute path to the writable configuration folder or
  * an empty string if the config path does not exist.
  */
-std::string userConfigPath();
+std::string userConfigPath ();
 
-bool createUserLibraryPath();
-std::string backupPath();
-bool createBackupPath();
+bool createUserLibraryPath ();
+std::string backupPath ();
+bool createBackupPath ();
 
 /**
  * Return a human readable text describing the operating system
@@ -70,7 +70,7 @@ bool createBackupPath();
  * Extended sysinfo will return more info, like CPUs and RAM
  * @return system information.
  */
-const std::string sysinfo(bool extended = true);
+const std::string sysinfo (bool extended = true);
 
 /**
  * Return short text describing the operating system usable as
@@ -80,7 +80,7 @@ const std::string sysinfo(bool extended = true);
  *
  * @return the short system info
  */
-const std::string user_agent();
+const std::string user_agent ();
 
 /**
  * Platform abstraction to set environment variables. Windows/MinGW
@@ -90,7 +90,7 @@ const std::string user_agent();
  * @param value the value to set for the environment variable.
  * @return 0 on success.
  */
-int setenv(const char *name, const char *value, int overwrite);
+int setenv (const char *name, const char *value, int overwrite);
 
 /**
  * Return system defined stack limit. If the system does not define
@@ -98,7 +98,7 @@ int setenv(const char *name, const char *value, int overwrite);
  *
  * @return maximum stack size in bytes.
  */
-unsigned long stackLimit();
+unsigned long stackLimit ();
 
 /**
  * Single character separating path specifications in a list
@@ -107,16 +107,16 @@ unsigned long stackLimit();
  *
  * @return the path separator
  */
-std::string pathSeparatorChar();
+std::string pathSeparatorChar ();
 
 /* Provide stdout/stderr if not available.
  * Currently limited to MS Windows GUI application console only.
  */
-void ensureStdIO();
+void ensureStdIO ();
 
 /**
  * Convert the number of bytes to a human readable string with
  * a given number of digits.
  */
-std::string toMemorySizeString(uint64_t bytes, int digits);
+std::string toMemorySizeString (uint64_t bytes, int digits);
 } // namespace PlatformUtils
diff --git a/src/python/pyfunctions.cc b/src/python/pyfunctions.cc
index db2742011..240ff2b9f 100644
--- a/src/python/pyfunctions.cc
+++ b/src/python/pyfunctions.cc
@@ -49,50 +49,48 @@
 #include "io/fileutils.h"
 #include "handle_dep.h"
 
-
-PyObject *python_cube(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_cube (PyObject *self, PyObject *args, PyObject *kwargs) {
   DECLARE_INSTANCE
-  auto node = std::make_shared<CubeNode>(instance);
+  auto node = std::make_shared<CubeNode> (instance);
 
   char *kwlist[] = {"size", "center", NULL};
   PyObject *size = NULL;
 
   PyObject *center = NULL;
 
-
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO", kwlist,
-                                   &size,
-                                   &center)){
-    PyErr_SetString(PyExc_TypeError, "Error during parsing cube(size)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "|OO", kwlist,
+                                    &size,
+                                    &center)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing cube(size)");
     return NULL;
   }
 
   if (size != NULL) {
-    if (python_vectorval(size, 3, 3, &(node->x), &(node->y), &(node->z))) {
-      PyErr_SetString(PyExc_TypeError, "Invalid Cube dimensions");
+    if (python_vectorval (size, 3, 3, &(node->x), &(node->y), &(node->z))) {
+      PyErr_SetString (PyExc_TypeError, "Invalid Cube dimensions");
       return NULL;
     }
   }
   if (node->x <= 0 || node->y <= 0 || node->z <= 0) {
-    PyErr_SetString(PyExc_TypeError, "Cube Dimensions must be positive");
+    PyErr_SetString (PyExc_TypeError, "Cube Dimensions must be positive");
     return NULL;
   }
   node->center = false;
-  if (center == Py_False || center == NULL)  ;
-  else if (center == Py_True){
-    for (int i = 0; i < 3; i++)node->center = true;
+  if (center == Py_False || center == NULL)
+    ;
+  else if (center == Py_True) {
+    for (int i = 0; i < 3; i++)
+      node->center = true;
   } else {
-    PyErr_SetString(PyExc_TypeError, "Unknown Value for center parameter");
+    PyErr_SetString (PyExc_TypeError, "Unknown Value for center parameter");
     return NULL;
   }
-  return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  return PyOpenSCADObjectFromNode (&PyOpenSCADType, node);
 }
 
-PyObject *python_sphere(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_sphere (PyObject *self, PyObject *args, PyObject *kwargs) {
   DECLARE_INSTANCE
-  auto node = std::make_shared<SphereNode>(instance);
+  auto node = std::make_shared<SphereNode> (instance);
 
   char *kwlist[] = {"r", "d", "fn", "fa", "fs", NULL};
   double r = NAN;
@@ -102,50 +100,51 @@ PyObject *python_sphere(PyObject *self, PyObject *args, PyObject *kwargs)
 
   double vr = 1;
 
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|Odddd", kwlist,
-                                   &rp, &d, &fn, &fa, &fs
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing sphere(r|d)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "|Odddd", kwlist,
+                                    &rp, &d, &fn, &fa, &fs)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing sphere(r|d)");
     return NULL;
   }
   if (rp != nullptr) {
-    python_numberval(rp, &r);
+    python_numberval (rp, &r);
   }
-  if (!isnan(r)) {
+  if (!isnan (r)) {
     if (r <= 0) {
-      PyErr_SetString(PyExc_TypeError, "Parameter r must be positive");
+      PyErr_SetString (PyExc_TypeError, "Parameter r must be positive");
       return NULL;
     }
     vr = r;
-    if (!isnan(d)) {
-      PyErr_SetString(PyExc_TypeError, "Cant specify r and d at the same time for sphere");
+    if (!isnan (d)) {
+      PyErr_SetString (PyExc_TypeError, "Cant specify r and d at the same time for sphere");
       return NULL;
     }
   }
-  if (!isnan(d)) {
+  if (!isnan (d)) {
     if (d <= 0) {
-      PyErr_SetString(PyExc_TypeError, "Parameter d must be positive");
+      PyErr_SetString (PyExc_TypeError, "Parameter d must be positive");
       return NULL;
     }
     vr = d / 2.0;
   }
 
-  get_fnas(node->fn, node->fa, node->fs);
-  if (!isnan(fn)) node->fn = fn;
-  if (!isnan(fa)) node->fa = fa;
-  if (!isnan(fs)) node->fs = fs;
+  get_fnas (node->fn, node->fa, node->fs);
+  if (!isnan (fn))
+    node->fn = fn;
+  if (!isnan (fa))
+    node->fa = fa;
+  if (!isnan (fs))
+    node->fs = fs;
 
   node->r = vr;
 
-  return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  return PyOpenSCADObjectFromNode (&PyOpenSCADType, node);
 }
 
-PyObject *python_cylinder(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_cylinder (PyObject *self, PyObject *args, PyObject *kwargs) {
   DECLARE_INSTANCE
-  auto node = std::make_shared<CylinderNode>(instance);
+  auto node = std::make_shared<CylinderNode> (instance);
 
-  char *kwlist[] = {"h", "r1", "r2", "center",  "r", "d", "d1", "d2",  "fn", "fa", "fs", NULL};
+  char *kwlist[] = {"h", "r1", "r2", "center", "r", "d", "d1", "d2", "fn", "fa", "fs", NULL};
   double h = NAN;
   double r = NAN;
   double r1 = NAN;
@@ -159,75 +158,83 @@ PyObject *python_cylinder(PyObject *self, PyObject *args, PyObject *kwargs)
   PyObject *center = NULL;
   double vr1 = 1, vr2 = 1, vh = 1;
 
-
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|dddOddddddd", kwlist, &h, &r1, &r2, &center, &r, &d, &d1, &d2, &fn, &fa, &fs)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing cylinder(h,r|r1+r2|d1+d2)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "|dddOddddddd", kwlist, &h, &r1, &r2, &center, &r, &d, &d1, &d2, &fn, &fa, &fs)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing cylinder(h,r|r1+r2|d1+d2)");
     return NULL;
   }
 
   if (h <= 0) {
-    PyErr_SetString(PyExc_TypeError, "Cylinder height must be positive");
+    PyErr_SetString (PyExc_TypeError, "Cylinder height must be positive");
     return NULL;
   }
   vh = h;
 
-  if (!isnan(d) && d <= 0) {
-    PyErr_SetString(PyExc_TypeError, "Cylinder d must be positive");
+  if (!isnan (d) && d <= 0) {
+    PyErr_SetString (PyExc_TypeError, "Cylinder d must be positive");
     return NULL;
   }
-  if (!isnan(r1) && r1 < 0) {
-    PyErr_SetString(PyExc_TypeError, "Cylinder r1 must not be negative");
+  if (!isnan (r1) && r1 < 0) {
+    PyErr_SetString (PyExc_TypeError, "Cylinder r1 must not be negative");
     return NULL;
   }
-  if (!isnan(r2) && r2 < 0) {
-    PyErr_SetString(PyExc_TypeError, "Cylinder r2 must not be negative");
+  if (!isnan (r2) && r2 < 0) {
+    PyErr_SetString (PyExc_TypeError, "Cylinder r2 must not be negative");
     return NULL;
   }
-  if (!isnan(d1) && d1 < 0) {
-    PyErr_SetString(PyExc_TypeError, "Cylinder d1 must not be negative");
+  if (!isnan (d1) && d1 < 0) {
+    PyErr_SetString (PyExc_TypeError, "Cylinder d1 must not be negative");
     return NULL;
   }
-  if (!isnan(d2) && d2 < 0) {
-    PyErr_SetString(PyExc_TypeError, "Cylinder d2 must not be negative");
+  if (!isnan (d2) && d2 < 0) {
+    PyErr_SetString (PyExc_TypeError, "Cylinder d2 must not be negative");
     return NULL;
   }
 
-  if (!isnan(r1) && !isnan(r2)) {
-    vr1 = r1; vr2 = r2;
-  } else if (!isnan(r1) && isnan(r2)) {
-    vr1 = r1; vr2 = r1;
-  } else if (!isnan(d1) && !isnan(d2)) {
-    vr1 = d1 / 2.0; vr2 = d2 / 2.0;
-  } else if (!isnan(r)) {
-    vr1 = r; vr2 = r;
-  } else if (!isnan(d)) {
-    vr1 = d / 2.0; vr2 = d / 2.0;
+  if (!isnan (r1) && !isnan (r2)) {
+    vr1 = r1;
+    vr2 = r2;
+  } else if (!isnan (r1) && isnan (r2)) {
+    vr1 = r1;
+    vr2 = r1;
+  } else if (!isnan (d1) && !isnan (d2)) {
+    vr1 = d1 / 2.0;
+    vr2 = d2 / 2.0;
+  } else if (!isnan (r)) {
+    vr1 = r;
+    vr2 = r;
+  } else if (!isnan (d)) {
+    vr1 = d / 2.0;
+    vr2 = d / 2.0;
   }
 
-  get_fnas(node->fn, node->fa, node->fs);
-  if (!isnan(fn)) node->fn = fn;
-  if (!isnan(fa)) node->fa = fa;
-  if (!isnan(fs)) node->fs = fs;
+  get_fnas (node->fn, node->fa, node->fs);
+  if (!isnan (fn))
+    node->fn = fn;
+  if (!isnan (fa))
+    node->fa = fa;
+  if (!isnan (fs))
+    node->fs = fs;
 
   node->r1 = vr1;
   node->r2 = vr2;
   node->h = vh;
 
-  if (center == Py_True) node->center = 1;
-  else if (center == Py_False || center == NULL)   node->center = 0;
+  if (center == Py_True)
+    node->center = 1;
+  else if (center == Py_False || center == NULL)
+    node->center = 0;
   else {
-    PyErr_SetString(PyExc_TypeError, "Unknown Value for center parameter");
+    PyErr_SetString (PyExc_TypeError, "Unknown Value for center parameter");
     return NULL;
   }
 
-  return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  return PyOpenSCADObjectFromNode (&PyOpenSCADType, node);
 }
 
-PyObject *python_polyhedron(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_polyhedron (PyObject *self, PyObject *args, PyObject *kwargs) {
   DECLARE_INSTANCE
   unsigned int i, j, pointIndex;
-  auto node = std::make_shared<PolyhedronNode>(instance);
+  auto node = std::make_shared<PolyhedronNode> (instance);
 
   char *kwlist[] = {"points", "faces", "convexity", "triangles", NULL};
   PyObject *points = NULL;
@@ -238,89 +245,86 @@ PyObject *python_polyhedron(PyObject *self, PyObject *args, PyObject *kwargs)
   PyObject *element;
   Vector3d point;
 
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!O!|iO!", kwlist,
-                                   &PyList_Type, &points,
-                                   &PyList_Type, &faces,
-                                   &convexity,
-                                   &PyList_Type, &triangles
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing polyhedron(points, faces)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O!O!|iO!", kwlist,
+                                    &PyList_Type, &points,
+                                    &PyList_Type, &faces,
+                                    &convexity,
+                                    &PyList_Type, &triangles)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing polyhedron(points, faces)");
     return NULL;
   }
 
-  if (points != NULL && PyList_Check(points)) {
-    if (PyList_Size(points) == 0) {
-      PyErr_SetString(PyExc_TypeError, "There must at least be one point in the polyhedron");
+  if (points != NULL && PyList_Check (points)) {
+    if (PyList_Size (points) == 0) {
+      PyErr_SetString (PyExc_TypeError, "There must at least be one point in the polyhedron");
       return NULL;
     }
-    for (i = 0; i < PyList_Size(points); i++) {
-      element = PyList_GetItem(points, i);
-      if (PyList_Check(element) && PyList_Size(element) == 3) {
-        point[0] = PyFloat_AsDouble(PyList_GetItem(element, 0));
-        point[1] = PyFloat_AsDouble(PyList_GetItem(element, 1));
-        point[2] = PyFloat_AsDouble(PyList_GetItem(element, 2));
-        node->points.push_back(point);
+    for (i = 0; i < PyList_Size (points); i++) {
+      element = PyList_GetItem (points, i);
+      if (PyList_Check (element) && PyList_Size (element) == 3) {
+        point[0] = PyFloat_AsDouble (PyList_GetItem (element, 0));
+        point[1] = PyFloat_AsDouble (PyList_GetItem (element, 1));
+        point[2] = PyFloat_AsDouble (PyList_GetItem (element, 2));
+        node->points.push_back (point);
       } else {
-        PyErr_SetString(PyExc_TypeError, "Coordinate must exactly contain 3 numbers");
+        PyErr_SetString (PyExc_TypeError, "Coordinate must exactly contain 3 numbers");
         return NULL;
       }
-
     }
   } else {
-    PyErr_SetString(PyExc_TypeError, "Polyhedron Points must be a list of coordinates");
+    PyErr_SetString (PyExc_TypeError, "Polyhedron Points must be a list of coordinates");
     return NULL;
   }
 
   if (triangles != NULL) {
     faces = triangles;
-//	LOG(message_group::Deprecated, inst->location(), parameters.documentRoot(), "polyhedron(triangles=[]) will be removed in future releases. Use polyhedron(faces=[]) instead.");
+    //	LOG(message_group::Deprecated, inst->location(), parameters.documentRoot(), "polyhedron(triangles=[]) will be removed in future releases. Use polyhedron(faces=[]) instead.");
   }
 
-  if (faces != NULL && PyList_Check(faces) ) {
-    if (PyList_Size(faces) == 0) {
-      PyErr_SetString(PyExc_TypeError, "must specify at least 1 face");
+  if (faces != NULL && PyList_Check (faces)) {
+    if (PyList_Size (faces) == 0) {
+      PyErr_SetString (PyExc_TypeError, "must specify at least 1 face");
       return NULL;
     }
-    for (i = 0; i < PyList_Size(faces); i++) {
-      element = PyList_GetItem(faces, i);
-      if (PyList_Check(element)) {
+    for (i = 0; i < PyList_Size (faces); i++) {
+      element = PyList_GetItem (faces, i);
+      if (PyList_Check (element)) {
         IndexedFace face;
-        for (j = 0; j < PyList_Size(element); j++) {
-          pointIndex = PyLong_AsLong(PyList_GetItem(element, j));
-          if (pointIndex < 0 || pointIndex >= node->points.size()) {
-            PyErr_SetString(PyExc_TypeError, "Polyhedron Point Index out of range");
+        for (j = 0; j < PyList_Size (element); j++) {
+          pointIndex = PyLong_AsLong (PyList_GetItem (element, j));
+          if (pointIndex < 0 || pointIndex >= node->points.size ()) {
+            PyErr_SetString (PyExc_TypeError, "Polyhedron Point Index out of range");
             return NULL;
           }
-          face.push_back(pointIndex);
+          face.push_back (pointIndex);
         }
-        if (face.size() >= 3) {
-          node->faces.push_back(std::move(face));
+        if (face.size () >= 3) {
+          node->faces.push_back (std::move (face));
         } else {
-          PyErr_SetString(PyExc_TypeError, "Polyhedron Face must sepcify at least 3 indices");
+          PyErr_SetString (PyExc_TypeError, "Polyhedron Face must sepcify at least 3 indices");
           return NULL;
         }
 
       } else {
-        PyErr_SetString(PyExc_TypeError, "Polyhedron Face must be a list of indices");
+        PyErr_SetString (PyExc_TypeError, "Polyhedron Face must be a list of indices");
         return NULL;
       }
     }
   } else {
-    PyErr_SetString(PyExc_TypeError, "Polyhedron faces must be a list of indices");
+    PyErr_SetString (PyExc_TypeError, "Polyhedron faces must be a list of indices");
     return NULL;
   }
 
-
   node->convexity = convexity;
-  if (node->convexity < 1) node->convexity = 1;
+  if (node->convexity < 1)
+    node->convexity = 1;
 
-  return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  return PyOpenSCADObjectFromNode (&PyOpenSCADType, node);
 }
 
-PyObject *python_square(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_square (PyObject *self, PyObject *args, PyObject *kwargs) {
   DECLARE_INSTANCE
-  auto node = std::make_shared<SquareNode>(instance);
+  auto node = std::make_shared<SquareNode> (instance);
 
   char *kwlist[] = {"dim", "center", NULL};
   PyObject *dim = NULL;
@@ -328,32 +332,32 @@ PyObject *python_square(PyObject *self, PyObject *args, PyObject *kwargs)
   PyObject *center = NULL;
   double z = NAN;
 
-
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO", kwlist,
-                                   &dim,
-                                   &center)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing square(dim)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "|OO", kwlist,
+                                    &dim,
+                                    &center)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing square(dim)");
     return NULL;
   }
   if (dim != NULL) {
-    if (python_vectorval(dim, 2, 2, &(node->x), &(node->y), &z)) {
-      PyErr_SetString(PyExc_TypeError, "Invalid Square dimensions");
+    if (python_vectorval (dim, 2, 2, &(node->x), &(node->y), &z)) {
+      PyErr_SetString (PyExc_TypeError, "Invalid Square dimensions");
       return NULL;
     }
   }
-  if (center == Py_True) node->center = 1;
-  else if (center == Py_False || center == NULL)   node->center = 0;
+  if (center == Py_True)
+    node->center = 1;
+  else if (center == Py_False || center == NULL)
+    node->center = 0;
   else {
-    PyErr_SetString(PyExc_TypeError, "Unknown Value for center parameter");
+    PyErr_SetString (PyExc_TypeError, "Unknown Value for center parameter");
     return NULL;
   }
 
-  return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  return PyOpenSCADObjectFromNode (&PyOpenSCADType, node);
 }
-PyObject *python_circle(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_circle (PyObject *self, PyObject *args, PyObject *kwargs) {
   DECLARE_INSTANCE
-  auto node = std::make_shared<CircleNode>(instance);
+  auto node = std::make_shared<CircleNode> (instance);
 
   char *kwlist[] = {"r", "d", "fn", "fa", "fs", NULL};
   double r = NAN;
@@ -362,46 +366,46 @@ PyObject *python_circle(PyObject *self, PyObject *args, PyObject *kwargs)
 
   double vr = 1;
 
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|ddddd", kwlist, &r, &d, &fn, &fa, &fs)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing circle(r|d)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "|ddddd", kwlist, &r, &d, &fn, &fa, &fs)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing circle(r|d)");
     return NULL;
   }
 
-  if (!isnan(r)) {
+  if (!isnan (r)) {
     if (r <= 0) {
-      PyErr_SetString(PyExc_TypeError, "Parameter r must be positive");
+      PyErr_SetString (PyExc_TypeError, "Parameter r must be positive");
       return NULL;
     }
     vr = r;
-    if (!isnan(d)) {
-      PyErr_SetString(PyExc_TypeError, "Cant specify r and d at the same time for circle");
+    if (!isnan (d)) {
+      PyErr_SetString (PyExc_TypeError, "Cant specify r and d at the same time for circle");
       return NULL;
     }
   }
-  if (!isnan(d)) {
+  if (!isnan (d)) {
     if (d <= 0) {
-      PyErr_SetString(PyExc_TypeError, "Parameter d must be positive");
+      PyErr_SetString (PyExc_TypeError, "Parameter d must be positive");
       return NULL;
     }
     vr = d / 2.0;
   }
 
-
-  get_fnas(node->fn, node->fa, node->fs);
-  if (!isnan(fn)) node->fn = fn;
-  if (!isnan(fa)) node->fa = fa;
-  if (!isnan(fs)) node->fs = fs;
+  get_fnas (node->fn, node->fa, node->fs);
+  if (!isnan (fn))
+    node->fn = fn;
+  if (!isnan (fa))
+    node->fa = fa;
+  if (!isnan (fs))
+    node->fs = fs;
 
   node->r = vr;
 
-
-  return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  return PyOpenSCADObjectFromNode (&PyOpenSCADType, node);
 }
-PyObject *python_polygon(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_polygon (PyObject *self, PyObject *args, PyObject *kwargs) {
   DECLARE_INSTANCE
   unsigned int i, j, pointIndex;
-  auto node = std::make_shared<PolygonNode>(instance);
+  auto node = std::make_shared<PolygonNode> (instance);
 
   char *kwlist[] = {"points", "paths", "convexity", NULL};
   PyObject *points = NULL;
@@ -411,364 +415,365 @@ PyObject *python_polygon(PyObject *self, PyObject *args, PyObject *kwargs)
   PyObject *element;
   Vector2d point;
 
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!|O!i", kwlist,
-                                   &PyList_Type, &points,
-                                   &PyList_Type, &paths,
-                                   &convexity
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing polygon(points,paths)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O!|O!i", kwlist,
+                                    &PyList_Type, &points,
+                                    &PyList_Type, &paths,
+                                    &convexity)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing polygon(points,paths)");
     return NULL;
   }
 
-  if (points != NULL && PyList_Check(points) ) {
-    if (PyList_Size(points) == 0) {
-      PyErr_SetString(PyExc_TypeError, "There must at least be one point in the polygon");
+  if (points != NULL && PyList_Check (points)) {
+    if (PyList_Size (points) == 0) {
+      PyErr_SetString (PyExc_TypeError, "There must at least be one point in the polygon");
       return NULL;
     }
-    for (i = 0; i < PyList_Size(points); i++) {
-      element = PyList_GetItem(points, i);
-      if (PyList_Check(element) && PyList_Size(element) == 2) {
-        point[0] = PyFloat_AsDouble(PyList_GetItem(element, 0));
-        point[1] = PyFloat_AsDouble(PyList_GetItem(element, 1));
-        node->points.push_back(point);
+    for (i = 0; i < PyList_Size (points); i++) {
+      element = PyList_GetItem (points, i);
+      if (PyList_Check (element) && PyList_Size (element) == 2) {
+        point[0] = PyFloat_AsDouble (PyList_GetItem (element, 0));
+        point[1] = PyFloat_AsDouble (PyList_GetItem (element, 1));
+        node->points.push_back (point);
       } else {
-        PyErr_SetString(PyExc_TypeError, "Coordinate must exactly contain 2 numbers");
+        PyErr_SetString (PyExc_TypeError, "Coordinate must exactly contain 2 numbers");
         return NULL;
       }
-
     }
   } else {
-    PyErr_SetString(PyExc_TypeError, "Polygon points must be a list of coordinates");
+    PyErr_SetString (PyExc_TypeError, "Polygon points must be a list of coordinates");
     return NULL;
   }
 
-  if (paths != NULL && PyList_Check(paths) ) {
-    if (PyList_Size(paths) == 0) {
-      PyErr_SetString(PyExc_TypeError, "must specify at least 1 path when specified");
+  if (paths != NULL && PyList_Check (paths)) {
+    if (PyList_Size (paths) == 0) {
+      PyErr_SetString (PyExc_TypeError, "must specify at least 1 path when specified");
       return NULL;
     }
-    for (i = 0; i < PyList_Size(paths); i++) {
-      element = PyList_GetItem(paths, i);
-      if (PyList_Check(element)) {
+    for (i = 0; i < PyList_Size (paths); i++) {
+      element = PyList_GetItem (paths, i);
+      if (PyList_Check (element)) {
         std::vector<size_t> path;
-        for (j = 0; j < PyList_Size(element); j++) {
-          pointIndex = PyLong_AsLong(PyList_GetItem(element, j));
-          if (pointIndex < 0 || pointIndex >= node->points.size()) {
-            PyErr_SetString(PyExc_TypeError, "Polyhedron Point Index out of range");
+        for (j = 0; j < PyList_Size (element); j++) {
+          pointIndex = PyLong_AsLong (PyList_GetItem (element, j));
+          if (pointIndex < 0 || pointIndex >= node->points.size ()) {
+            PyErr_SetString (PyExc_TypeError, "Polyhedron Point Index out of range");
             return NULL;
           }
-          path.push_back(pointIndex);
+          path.push_back (pointIndex);
         }
-        node->paths.push_back(std::move(path));
+        node->paths.push_back (std::move (path));
       } else {
-        PyErr_SetString(PyExc_TypeError, "Polygon path must be a list of indices");
+        PyErr_SetString (PyExc_TypeError, "Polygon path must be a list of indices");
         return NULL;
       }
     }
   }
 
   node->convexity = convexity;
-  if (node->convexity < 1) node->convexity = 1;
+  if (node->convexity < 1)
+    node->convexity = 1;
 
-  return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  return PyOpenSCADObjectFromNode (&PyOpenSCADType, node);
 }
 
-int python_tomatrix(PyObject *pyt, Matrix4d& mat)
-{
-  if (pyt == nullptr)return 1;
+int python_tomatrix (PyObject *pyt, Matrix4d &mat) {
+  if (pyt == nullptr)
+    return 1;
   PyObject *row, *cell;
   double val;
-  if (!PyList_Check(pyt))return 1; // TODO crash wenn pyt eine funktion ist
-  if (PyList_Size(pyt) != 4)return 1;
+  if (!PyList_Check (pyt))
+    return 1; // TODO crash wenn pyt eine funktion ist
+  if (PyList_Size (pyt) != 4)
+    return 1;
   for (int i = 0; i < 4; i++) {
-    row = PyList_GetItem(pyt, i);
-    if (!PyList_Check(row))return 1;
-    if (PyList_Size(row) != 4)return 1;
+    row = PyList_GetItem (pyt, i);
+    if (!PyList_Check (row))
+      return 1;
+    if (PyList_Size (row) != 4)
+      return 1;
     for (int j = 0; j < 4; j++) {
-      cell = PyList_GetItem(row, j);
-      if (python_numberval(cell, &val))return 1;
-      mat(i, j) = val;
+      cell = PyList_GetItem (row, j);
+      if (python_numberval (cell, &val))
+        return 1;
+      mat (i, j) = val;
     }
   }
   return 0;
 }
-PyObject *python_frommatrix(const Matrix4d& mat) {
-  PyObject *pyo = PyList_New(4);
+PyObject *python_frommatrix (const Matrix4d &mat) {
+  PyObject *pyo = PyList_New (4);
   PyObject *row;
   for (int i = 0; i < 4; i++) {
-    row = PyList_New(4);
+    row = PyList_New (4);
     for (int j = 0; j < 4; j++)
-      PyList_SetItem(row, j, PyFloat_FromDouble(mat(i, j)));
-    PyList_SetItem(pyo, i, row);
+      PyList_SetItem (row, j, PyFloat_FromDouble (mat (i, j)));
+    PyList_SetItem (pyo, i, row);
   }
   return pyo;
 }
 
-
-PyObject *python_matrix_scale(PyObject *mat, Vector3d scalevec)
-{
-  Transform3d matrix = Transform3d::Identity();
-  matrix.scale(scalevec);
+PyObject *python_matrix_scale (PyObject *mat, Vector3d scalevec) {
+  Transform3d matrix = Transform3d::Identity ();
+  matrix.scale (scalevec);
   Matrix4d raw;
-  if (python_tomatrix(mat, raw))return nullptr;
+  if (python_tomatrix (mat, raw))
+    return nullptr;
   Vector3d n;
   for (int i = 0; i < 3; i++) {
-    n = Vector3d(raw(0, i), raw(1, i), raw(2, i)); // TODO fix
+    n = Vector3d (raw (0, i), raw (1, i), raw (2, i)); // TODO fix
     n = matrix * n;
-    for (int j = 0; j < 3; j++)raw(j, i) = n[j];
+    for (int j = 0; j < 3; j++)
+      raw (j, i) = n[j];
   }
-  return python_frommatrix(raw);
+  return python_frommatrix (raw);
 }
 
-
-PyObject *python_scale_sub(PyObject *obj, Vector3d scalevec)
-{
-  PyObject *mat = python_matrix_scale(obj, scalevec);
-  if (mat != nullptr)return mat;
+PyObject *python_scale_sub (PyObject *obj, Vector3d scalevec) {
+  PyObject *mat = python_matrix_scale (obj, scalevec);
+  if (mat != nullptr)
+    return mat;
 
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
-  auto node = std::make_shared<TransformNode>(instance, "scale");
+  auto node = std::make_shared<TransformNode> (instance, "scale");
   PyObject *child_dict;
-  child = PyOpenSCADObjectToNodeMulti(obj, &child_dict);
+  child = PyOpenSCADObjectToNodeMulti (obj, &child_dict);
   if (child == NULL) {
-    PyErr_SetString(PyExc_TypeError, "Invalid type for Object in scale");
+    PyErr_SetString (PyExc_TypeError, "Invalid type for Object in scale");
     return NULL;
   }
-  node->matrix.scale(scalevec);
-  node->children.push_back(child);
-  PyObject *pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  node->matrix.scale (scalevec);
+  node->children.push_back (child);
+  PyObject *pyresult = PyOpenSCADObjectFromNode (&PyOpenSCADType, node);
   if (child_dict != nullptr) {
     PyObject *key, *value;
     Py_ssize_t pos = 0;
-    while (PyDict_Next(child_dict, &pos, &key, &value)) {
-      PyObject *value1 = python_matrix_scale(value, scalevec);
-      if (value1 != nullptr) PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value1);
-      else PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value);
+    while (PyDict_Next (child_dict, &pos, &key, &value)) {
+      PyObject *value1 = python_matrix_scale (value, scalevec);
+      if (value1 != nullptr)
+        PyDict_SetItem (((PyOpenSCADObject *)pyresult)->dict, key, value1);
+      else
+        PyDict_SetItem (((PyOpenSCADObject *)pyresult)->dict, key, value);
     }
   }
   return pyresult;
-
 }
 
-PyObject *python_scale_core(PyObject *obj, PyObject *val_v)
-{
+PyObject *python_scale_core (PyObject *obj, PyObject *val_v) {
 
   double x = 1, y = 1, z = 1;
-  if (python_vectorval(val_v, 2, 3, &x, &y, &z)) {
-    PyErr_SetString(PyExc_TypeError, "Invalid vector specifiaction in scale, use 1 to 3 ordinates.");
+  if (python_vectorval (val_v, 2, 3, &x, &y, &z)) {
+    PyErr_SetString (PyExc_TypeError, "Invalid vector specifiaction in scale, use 1 to 3 ordinates.");
     return NULL;
   }
-  Vector3d scalevec(x, y, z);
+  Vector3d scalevec (x, y, z);
 
   if (OpenSCAD::rangeCheck) {
-    if (scalevec[0] == 0 || scalevec[1] == 0 || scalevec[2] == 0 || !std::isfinite(scalevec[0])|| !std::isfinite(scalevec[1])|| !std::isfinite(scalevec[2])) {
-//      LOG(message_group::Warning, instance->location(), parameters.documentRoot(), "scale(%1$s)", parameters["v"].toEchoStringNoThrow());
+    if (scalevec[0] == 0 || scalevec[1] == 0 || scalevec[2] == 0 || !std::isfinite (scalevec[0]) || !std::isfinite (scalevec[1]) || !std::isfinite (scalevec[2])) {
+      //      LOG(message_group::Warning, instance->location(), parameters.documentRoot(), "scale(%1$s)", parameters["v"].toEchoStringNoThrow());
     }
   }
 
-  return python_scale_sub(obj, scalevec);
+  return python_scale_sub (obj, scalevec);
 }
 
-
-
-PyObject *python_scale(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_scale (PyObject *self, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"obj", "v", NULL};
   PyObject *obj = NULL;
   PyObject *val_v = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO", kwlist,
-                                   &obj,
-                                   &val_v)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing scale(object, scale)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "OO", kwlist,
+                                    &obj,
+                                    &val_v)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing scale(object, scale)");
     return NULL;
   }
-  return python_scale_core(obj, val_v);
+  return python_scale_core (obj, val_v);
 }
 
-PyObject *python_oo_scale(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_scale (PyObject *obj, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"v", NULL};
   PyObject *val_v = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O", kwlist,
-                                   &val_v)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing scale(object, scale)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O", kwlist,
+                                    &val_v)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing scale(object, scale)");
     return NULL;
   }
-  return python_scale_core(obj, val_v);
+  return python_scale_core (obj, val_v);
 }
-PyObject *python_matrix_rot(PyObject *mat, Matrix3d rotvec)
-{
-  Transform3d matrix = Transform3d::Identity();
-  matrix.rotate(rotvec);
+PyObject *python_matrix_rot (PyObject *mat, Matrix3d rotvec) {
+  Transform3d matrix = Transform3d::Identity ();
+  matrix.rotate (rotvec);
   Matrix4d raw;
-  if (python_tomatrix(mat, raw))return nullptr;
+  if (python_tomatrix (mat, raw))
+    return nullptr;
   Vector3d n;
   for (int i = 0; i < 4; i++) {
-    n = Vector3d(raw(0, i), raw(1, i), raw(2, i));
+    n = Vector3d (raw (0, i), raw (1, i), raw (2, i));
     n = matrix * n;
-    for (int j = 0; j < 3; j++)raw(j, i) = n[j];
+    for (int j = 0; j < 3; j++)
+      raw (j, i) = n[j];
   }
-  return python_frommatrix(raw);
+  return python_frommatrix (raw);
 }
 
-
-PyObject *python_rotate_sub(PyObject *obj, Vector3d vec3, double angle)
-{
+PyObject *python_rotate_sub (PyObject *obj, Vector3d vec3, double angle) {
   Matrix3d M;
-  if (isnan(angle)) {
+  if (isnan (angle)) {
     double sx = 0, sy = 0, sz = 0;
     double cx = 1, cy = 1, cz = 1;
     double a = 0.0;
     if (vec3[2] != 0) {
       a = vec3[2];
-      sz = sin_degrees(a);
-      cz = cos_degrees(a);
+      sz = sin_degrees (a);
+      cz = cos_degrees (a);
     }
     if (vec3[1] != 0) {
       a = vec3[1];
-      sy = sin_degrees(a);
-      cy = cos_degrees(a);
+      sy = sin_degrees (a);
+      cy = cos_degrees (a);
     }
     if (vec3[0] != 0) {
       a = vec3[0];
-      sx = sin_degrees(a);
-      cx = cos_degrees(a);
+      sx = sin_degrees (a);
+      cx = cos_degrees (a);
     }
 
-    M << cy * cz,  cz * sx * sy - cx * sz,   cx * cz * sy + sx * sz,
-      cy *sz,  cx *cz + sx * sy * sz,  -cz * sx + cx * sy * sz,
-      -sy,       cy *sx,                  cx *cy;
+    M << cy * cz, cz * sx * sy - cx * sz, cx * cz * sy + sx * sz,
+      cy * sz, cx * cz + sx * sy * sz, -cz * sx + cx * sy * sz,
+      -sy, cy * sx, cx * cy;
   } else {
-    M = angle_axis_degrees(angle, vec3);
+    M = angle_axis_degrees (angle, vec3);
   }
-  PyObject *mat = python_matrix_rot(obj, M);
-  if (mat != nullptr)return mat;
+  PyObject *mat = python_matrix_rot (obj, M);
+  if (mat != nullptr)
+    return mat;
 
   DECLARE_INSTANCE
-  auto node = std::make_shared<TransformNode>(instance, "rotate");
+  auto node = std::make_shared<TransformNode> (instance, "rotate");
 
   PyObject *child_dict;
-  std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNodeMulti(obj, &child_dict);
+  std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNodeMulti (obj, &child_dict);
   if (child == NULL) {
-    PyErr_SetString(PyExc_TypeError, "Invalid type for Object in rotate");
+    PyErr_SetString (PyExc_TypeError, "Invalid type for Object in rotate");
     return NULL;
   }
-  node->matrix.rotate(M);
+  node->matrix.rotate (M);
 
-  node->children.push_back(child);
-  PyObject *pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  node->children.push_back (child);
+  PyObject *pyresult = PyOpenSCADObjectFromNode (&PyOpenSCADType, node);
   if (child_dict != nullptr) {
     PyObject *key, *value;
     Py_ssize_t pos = 0;
-    while (PyDict_Next(child_dict, &pos, &key, &value)) {
-      PyObject *value1 = python_matrix_rot(value, M);
-      if (value1 != nullptr) PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value1);
-      else PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value);
+    while (PyDict_Next (child_dict, &pos, &key, &value)) {
+      PyObject *value1 = python_matrix_rot (value, M);
+      if (value1 != nullptr)
+        PyDict_SetItem (((PyOpenSCADObject *)pyresult)->dict, key, value1);
+      else
+        PyDict_SetItem (((PyOpenSCADObject *)pyresult)->dict, key, value);
     }
   }
   return pyresult;
 }
 
-PyObject *python_rotate_core(PyObject *obj, PyObject *val_a, PyObject *val_v)
-{
-  Vector3d vec3(0, 0, 0);
+PyObject *python_rotate_core (PyObject *obj, PyObject *val_a, PyObject *val_v) {
+  Vector3d vec3 (0, 0, 0);
   double angle;
-  if (val_a != nullptr && PyList_Check(val_a) && val_v == nullptr) {
-    if (PyList_Size(val_a) >= 1)vec3[0] = PyFloat_AsDouble(PyList_GetItem(val_a, 0));
-    if (PyList_Size(val_a) >= 2)vec3[1] = PyFloat_AsDouble(PyList_GetItem(val_a, 1));
-    if (PyList_Size(val_a) >= 3)vec3[2] = PyFloat_AsDouble(PyList_GetItem(val_a, 2));
-    return python_rotate_sub(obj, vec3, NAN);
-  } else if (val_a != nullptr && val_v != nullptr && !python_numberval(val_a, &angle) && PyList_Check(val_v) && PyList_Size(val_v) == 3) {
-    vec3[0] = PyFloat_AsDouble(PyList_GetItem(val_v, 0));
-    vec3[1] = PyFloat_AsDouble(PyList_GetItem(val_v, 1));
-    vec3[2] = PyFloat_AsDouble(PyList_GetItem(val_v, 2));
-    return python_rotate_sub(obj, vec3, angle);
-  }
-  PyErr_SetString(PyExc_TypeError, "Invalid arguments to rotate()");
+  if (val_a != nullptr && PyList_Check (val_a) && val_v == nullptr) {
+    if (PyList_Size (val_a) >= 1)
+      vec3[0] = PyFloat_AsDouble (PyList_GetItem (val_a, 0));
+    if (PyList_Size (val_a) >= 2)
+      vec3[1] = PyFloat_AsDouble (PyList_GetItem (val_a, 1));
+    if (PyList_Size (val_a) >= 3)
+      vec3[2] = PyFloat_AsDouble (PyList_GetItem (val_a, 2));
+    return python_rotate_sub (obj, vec3, NAN);
+  } else if (val_a != nullptr && val_v != nullptr && !python_numberval (val_a, &angle) && PyList_Check (val_v) && PyList_Size (val_v) == 3) {
+    vec3[0] = PyFloat_AsDouble (PyList_GetItem (val_v, 0));
+    vec3[1] = PyFloat_AsDouble (PyList_GetItem (val_v, 1));
+    vec3[2] = PyFloat_AsDouble (PyList_GetItem (val_v, 2));
+    return python_rotate_sub (obj, vec3, angle);
+  }
+  PyErr_SetString (PyExc_TypeError, "Invalid arguments to rotate()");
   return nullptr;
 }
 
-PyObject *python_rotate(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_rotate (PyObject *self, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"obj", "a", "v", nullptr};
   PyObject *val_a = nullptr;
   PyObject *val_v = nullptr;
   PyObject *obj = nullptr;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO|O", kwlist, &obj, &val_a, &val_v)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing rotate(object, vec3)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "OO|O", kwlist, &obj, &val_a, &val_v)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing rotate(object, vec3)");
     return NULL;
   }
-  return python_rotate_core(obj, val_a, val_v);
+  return python_rotate_core (obj, val_a, val_v);
 }
 
-PyObject *python_oo_rotate(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_rotate (PyObject *obj, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"a", "v", nullptr};
   PyObject *val_a = nullptr;
   PyObject *val_v = nullptr;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O", kwlist, &val_a, &val_v)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing rotate(object, vec3)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O|O", kwlist, &val_a, &val_v)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing rotate(object, vec3)");
     return NULL;
   }
-  return python_rotate_core(obj, val_a, val_v);
+  return python_rotate_core (obj, val_a, val_v);
 }
 
-
-PyObject *python_matrix_mirror(PyObject *mat, Matrix4d m)
-{
+PyObject *python_matrix_mirror (PyObject *mat, Matrix4d m) {
   Matrix4d raw;
-  if (python_tomatrix(mat, raw))return nullptr;
+  if (python_tomatrix (mat, raw))
+    return nullptr;
   Vector4d n;
   for (int i = 0; i < 3; i++) {
-    n = Vector4d(raw(0, i), raw(1, i), raw(2, i), 0);
+    n = Vector4d (raw (0, i), raw (1, i), raw (2, i), 0);
     n = m * n;
-    for (int j = 0; j < 3; j++)raw(j, i) = n[j];
+    for (int j = 0; j < 3; j++)
+      raw (j, i) = n[j];
   }
-  return python_frommatrix(raw);
+  return python_frommatrix (raw);
 }
 
-
-PyObject *python_mirror_sub(PyObject *obj, Matrix4d& m)
-{
-  PyObject *mat = python_matrix_mirror(obj, m);
-  if (mat != nullptr)return mat;
+PyObject *python_mirror_sub (PyObject *obj, Matrix4d &m) {
+  PyObject *mat = python_matrix_mirror (obj, m);
+  if (mat != nullptr)
+    return mat;
 
   DECLARE_INSTANCE
-  auto node = std::make_shared<TransformNode>(instance, "mirror");
+  auto node = std::make_shared<TransformNode> (instance, "mirror");
   node->matrix = m;
   PyObject *child_dict;
-  std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNodeMulti(obj, &child_dict);
+  std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNodeMulti (obj, &child_dict);
   if (child == NULL) {
-    PyErr_SetString(PyExc_TypeError, "Invalid type for Object in mirror");
+    PyErr_SetString (PyExc_TypeError, "Invalid type for Object in mirror");
     return NULL;
   }
-  node->children.push_back(child);
-  PyObject *pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  node->children.push_back (child);
+  PyObject *pyresult = PyOpenSCADObjectFromNode (&PyOpenSCADType, node);
   if (child_dict != nullptr) {
     PyObject *key, *value;
     Py_ssize_t pos = 0;
-    while (PyDict_Next(child_dict, &pos, &key, &value)) {
-      PyObject *value1 = python_matrix_mirror(value, m);
-      if (value1 != nullptr) PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value1);
-      else PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value);
+    while (PyDict_Next (child_dict, &pos, &key, &value)) {
+      PyObject *value1 = python_matrix_mirror (value, m);
+      if (value1 != nullptr)
+        PyDict_SetItem (((PyOpenSCADObject *)pyresult)->dict, key, value1);
+      else
+        PyDict_SetItem (((PyOpenSCADObject *)pyresult)->dict, key, value);
     }
   }
   return pyresult;
 }
 
-PyObject *python_mirror_core(PyObject *obj, PyObject *val_v)
-{
+PyObject *python_mirror_core (PyObject *obj, PyObject *val_v) {
   Vector3d mirrorvec;
   double x = 1.0, y = 0.0, z = 0.0;
-  if (python_vectorval(val_v, 2, 3, &x, &y, &z)) {
-    PyErr_SetString(PyExc_TypeError, "Invalid vector specifiaction in mirror");
+  if (python_vectorval (val_v, 2, 3, &x, &y, &z)) {
+    PyErr_SetString (PyExc_TypeError, "Invalid vector specifiaction in mirror");
     return NULL;
   }
   // x /= sqrt(x*x + y*y + z*z)
   // y /= sqrt(x*x + y*y + z*z)
   // z /= sqrt(x*x + y*y + z*z)
-  Matrix4d m = Matrix4d::Identity();
+  Matrix4d m = Matrix4d::Identity ();
   if (x != 0.0 || y != 0.0 || z != 0.0) {
     // skip using sqrt to normalize the vector since each element of matrix contributes it with two multiplied terms
     // instead just divide directly within each matrix element
@@ -780,444 +785,420 @@ PyObject *python_mirror_core(PyObject *obj, PyObject *val_v)
       -2 * x * z / a, -2 * y * z / a, 1 - 2 * z * z / a, 0,
       0, 0, 0, 1;
   }
-  return python_mirror_sub(obj, m);
+  return python_mirror_sub (obj, m);
 }
 
-PyObject *python_mirror(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_mirror (PyObject *self, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"obj", "v", NULL};
 
   PyObject *obj = NULL;
   PyObject *val_v = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO", kwlist,
-                                   &obj,
-                                   &val_v)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing mirror(object, vec3)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "OO", kwlist,
+                                    &obj,
+                                    &val_v)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing mirror(object, vec3)");
     return NULL;
   }
-  return python_mirror_core(obj, val_v);
+  return python_mirror_core (obj, val_v);
 }
 
-PyObject *python_oo_mirror(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_mirror (PyObject *obj, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"v", NULL};
 
   PyObject *val_v = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O", kwlist,
-                                   &val_v)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing mirror(object, vec3)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O", kwlist,
+                                    &val_v)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing mirror(object, vec3)");
     return NULL;
   }
-  return python_mirror_core(obj, val_v);
+  return python_mirror_core (obj, val_v);
 }
 
-PyObject *python_matrix_trans(PyObject *mat, Vector3d transvec)
-{
+PyObject *python_matrix_trans (PyObject *mat, Vector3d transvec) {
   Matrix4d raw;
-  if (python_tomatrix(mat, raw))return nullptr;
-  for (int i = 0; i < 3; i++)raw(i, 3) += transvec[i];
-  return python_frommatrix(raw);
+  if (python_tomatrix (mat, raw))
+    return nullptr;
+  for (int i = 0; i < 3; i++)
+    raw (i, 3) += transvec[i];
+  return python_frommatrix (raw);
 }
 
-PyObject *python_nb_sub_vec3(PyObject *arg1, PyObject *arg2, int mode);
-PyObject *python_translate_core(PyObject *obj, PyObject *v)
-{
-  if (v == nullptr)return obj;
-  return python_nb_sub_vec3(obj, v, 0);
+PyObject *python_nb_sub_vec3 (PyObject *arg1, PyObject *arg2, int mode);
+PyObject *python_translate_core (PyObject *obj, PyObject *v) {
+  if (v == nullptr)
+    return obj;
+  return python_nb_sub_vec3 (obj, v, 0);
 }
 
-PyObject *python_translate(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_translate (PyObject *self, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"obj", "v", NULL};
   PyObject *obj = NULL;
   PyObject *v = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O", kwlist, &obj, &v)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing translate(object,vec3)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O|O", kwlist, &obj, &v)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing translate(object,vec3)");
     return NULL;
   }
-  return python_translate_core(obj, v);
+  return python_translate_core (obj, v);
 }
 
-PyObject *python_oo_translate(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_translate (PyObject *obj, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"v", NULL};
   PyObject *v = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O", kwlist, &v)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing translate(object,vec3)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "|O", kwlist, &v)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing translate(object,vec3)");
     return NULL;
   }
-  return python_translate_core(obj, v);
+  return python_translate_core (obj, v);
 }
 
-PyObject *python_multmatrix_sub(PyObject *pyobj, PyObject *pymat, int div)
-{
+PyObject *python_multmatrix_sub (PyObject *pyobj, PyObject *pymat, int div) {
   Matrix4d mat;
-  if (!python_tomatrix(pymat, mat)) {
-    double w = mat(3, 3);
-    if (w != 1.0) mat = mat / w;
+  if (!python_tomatrix (pymat, mat)) {
+    double w = mat (3, 3);
+    if (w != 1.0)
+      mat = mat / w;
   } else {
-    PyErr_SetString(PyExc_TypeError, "Matrix vector should be 4x4 array");
+    PyErr_SetString (PyExc_TypeError, "Matrix vector should be 4x4 array");
     return NULL;
   }
-  if (div){
-    auto tmp = mat.inverse().eval();
+  if (div) {
+    auto tmp = mat.inverse ().eval ();
     mat = tmp;
   }
 
   Matrix4d objmat;
-  if (!python_tomatrix(pyobj, objmat)){
+  if (!python_tomatrix (pyobj, objmat)) {
     objmat = mat * objmat;
-    return python_frommatrix(objmat);
+    return python_frommatrix (objmat);
   }
 
   DECLARE_INSTANCE
-  auto node = std::make_shared<TransformNode>(instance, "multmatrix");
+  auto node = std::make_shared<TransformNode> (instance, "multmatrix");
   std::shared_ptr<AbstractNode> child;
   PyObject *child_dict;
-  child = PyOpenSCADObjectToNodeMulti(pyobj, &child_dict);
+  child = PyOpenSCADObjectToNodeMulti (pyobj, &child_dict);
   if (child == NULL) {
-    PyErr_SetString(PyExc_TypeError, "Invalid type for Object in multmatrix");
+    PyErr_SetString (PyExc_TypeError, "Invalid type for Object in multmatrix");
     return NULL;
   }
 
-
   node->matrix = mat;
-  node->children.push_back(child);
-  PyObject *pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  node->children.push_back (child);
+  PyObject *pyresult = PyOpenSCADObjectFromNode (&PyOpenSCADType, node);
   if (child_dict != nullptr) {
     PyObject *key, *value;
     Py_ssize_t pos = 0;
-    while (PyDict_Next(child_dict, &pos, &key, &value)) {
+    while (PyDict_Next (child_dict, &pos, &key, &value)) {
       Matrix4d raw;
-      if (python_tomatrix(value, raw))return nullptr;
-      PyObject *value1 = python_frommatrix(node->matrix * raw);
-      if (value1 != nullptr)PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value1);
-      else PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value);
+      if (python_tomatrix (value, raw))
+        return nullptr;
+      PyObject *value1 = python_frommatrix (node->matrix * raw);
+      if (value1 != nullptr)
+        PyDict_SetItem (((PyOpenSCADObject *)pyresult)->dict, key, value1);
+      else
+        PyDict_SetItem (((PyOpenSCADObject *)pyresult)->dict, key, value);
     }
   }
   return pyresult;
-
 }
 
-PyObject *python_multmatrix(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_multmatrix (PyObject *self, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"obj", "m", NULL};
   PyObject *obj = NULL;
   PyObject *mat = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO!", kwlist,
-                                   &obj,
-                                   &PyList_Type, &mat
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing multmatrix(object, vec16)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "OO!", kwlist,
+                                    &obj,
+                                    &PyList_Type, &mat)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing multmatrix(object, vec16)");
     return NULL;
   }
-  return python_multmatrix_sub(obj, mat, 0);
+  return python_multmatrix_sub (obj, mat, 0);
 }
 
-PyObject *python_oo_multmatrix(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_multmatrix (PyObject *obj, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"m", NULL};
   PyObject *mat = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!", kwlist,
-                                   &PyList_Type, &mat
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing multmatrix(object, vec16)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O!", kwlist,
+                                    &PyList_Type, &mat)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing multmatrix(object, vec16)");
     return NULL;
   }
-  return python_multmatrix_sub(obj, mat, 0);
+  return python_multmatrix_sub (obj, mat, 0);
 }
 
-PyObject *python_divmatrix(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_divmatrix (PyObject *self, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"obj", "m", NULL};
   PyObject *obj = NULL;
   PyObject *mat = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO!", kwlist,
-                                   &obj,
-                                   &PyList_Type, &mat
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing divmatrix(object, vec16)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "OO!", kwlist,
+                                    &obj,
+                                    &PyList_Type, &mat)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing divmatrix(object, vec16)");
     return NULL;
   }
-  return python_multmatrix_sub(obj, mat, 1);
+  return python_multmatrix_sub (obj, mat, 1);
 }
 
-PyObject *python_oo_divmatrix(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_divmatrix (PyObject *obj, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"m", NULL};
   PyObject *mat = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!", kwlist,
-                                   &PyList_Type, &mat
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing divmatrix(object, vec16)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O!", kwlist,
+                                    &PyList_Type, &mat)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing divmatrix(object, vec16)");
     return NULL;
   }
-  return python_multmatrix_sub(obj, mat, 1);
+  return python_multmatrix_sub (obj, mat, 1);
 }
 
-PyObject *python_show_core(PyObject *obj)
-{
+PyObject *python_show_core (PyObject *obj) {
   PyObject *child_dict;
-  std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNodeMulti(obj, &child_dict);
+  std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNodeMulti (obj, &child_dict);
   if (child == NULL) {
-    PyErr_SetString(PyExc_TypeError, "Invalid type for Object in show");
+    PyErr_SetString (PyExc_TypeError, "Invalid type for Object in show");
     return NULL;
   }
   python_result_node = child;
   return Py_None;
 }
 
-PyObject *python_show(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_show (PyObject *self, PyObject *args, PyObject *kwargs) {
   PyObject *obj = NULL;
   char *kwlist[] = {"obj", NULL};
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O", kwlist,
-                                   &obj
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing output(object)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O", kwlist,
+                                    &obj)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing output(object)");
     return NULL;
   }
-  return python_show_core(obj);
+  return python_show_core (obj);
 }
 
-PyObject *python_oo_show(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_show (PyObject *obj, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {NULL};
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "", kwlist
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing output(object)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "", kwlist)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing output(object)");
     return NULL;
   }
-  return python_show_core(obj);
+  return python_show_core (obj);
 }
 
-PyObject *python__getitem__(PyObject *obj, PyObject *key)
-{
-  PyOpenSCADObject *self = (PyOpenSCADObject *) obj;
+PyObject *python__getitem__ (PyObject *obj, PyObject *key) {
+  PyOpenSCADObject *self = (PyOpenSCADObject *)obj;
   if (self->dict == nullptr) {
     return nullptr;
   }
-  PyObject *result = PyDict_GetItem(self->dict, key);
-  if (result == NULL){
+  PyObject *result = PyDict_GetItem (self->dict, key);
+  if (result == NULL) {
     PyObject *dummy_dict;
-    std::shared_ptr<AbstractNode> node = PyOpenSCADObjectToNodeMulti(obj, &dummy_dict);
-    PyObject *keyname = PyUnicode_AsEncodedString(key, "utf-8", "~");
-    std::string keystr = PyBytes_AS_STRING(keyname);
+    std::shared_ptr<AbstractNode> node = PyOpenSCADObjectToNodeMulti (obj, &dummy_dict);
+    PyObject *keyname = PyUnicode_AsEncodedString (key, "utf-8", "~");
+    std::string keystr = PyBytes_AS_STRING (keyname);
     result = Py_None;
-  } else Py_INCREF(result);
+  } else
+    Py_INCREF (result);
   return result;
 }
 
-int python__setitem__(PyObject *dict, PyObject *key, PyObject *v)
-{
-  PyOpenSCADObject *self = (PyOpenSCADObject *) dict;
+int python__setitem__ (PyObject *dict, PyObject *key, PyObject *v) {
+  PyOpenSCADObject *self = (PyOpenSCADObject *)dict;
   if (self->dict == NULL) {
     return 0;
   }
-  Py_INCREF(v);
-  PyDict_SetItem(self->dict, key, v);
+  Py_INCREF (v);
+  PyDict_SetItem (self->dict, key, v);
   return 0;
 }
 
-
-PyObject *python_color_core(PyObject *obj, PyObject *color, double alpha)
-{
+PyObject *python_color_core (PyObject *obj, PyObject *color, double alpha) {
   PyObject *child_dict;
   std::shared_ptr<AbstractNode> child;
-  child = PyOpenSCADObjectToNodeMulti(obj, &child_dict);
+  child = PyOpenSCADObjectToNodeMulti (obj, &child_dict);
   if (child == NULL) {
-    PyErr_SetString(PyExc_TypeError, "Invalid type for Object in color");
+    PyErr_SetString (PyExc_TypeError, "Invalid type for Object in color");
     return NULL;
   }
   DECLARE_INSTANCE
-  auto node = std::make_shared<ColorNode>(instance);
-
-  Vector4d col(0, 0, 0, alpha);
-  if (!python_vectorval(color, 3, 4, &col[0], &col[1], &col[2], &col[3])) {
-    node->color.setRgba(float(col[0]), float(col[1]), float(col[2]), float(col[3]));
-  } else if (PyUnicode_Check(color)) {
-    PyObject *value = PyUnicode_AsEncodedString(color, "utf-8", "~");
-    char *colorname = PyBytes_AS_STRING(value);
-    const auto color = OpenSCAD::parse_color(colorname);
+  auto node = std::make_shared<ColorNode> (instance);
+
+  Vector4d col (0, 0, 0, alpha);
+  if (!python_vectorval (color, 3, 4, &col[0], &col[1], &col[2], &col[3])) {
+    node->color.setRgba (float (col[0]), float (col[1]), float (col[2]), float (col[3]));
+  } else if (PyUnicode_Check (color)) {
+    PyObject *value = PyUnicode_AsEncodedString (color, "utf-8", "~");
+    char *colorname = PyBytes_AS_STRING (value);
+    const auto color = OpenSCAD::parse_color (colorname);
     if (color) {
       node->color = *color;
-      node->color.setAlpha(alpha);
+      node->color.setAlpha (alpha);
     } else {
-      PyErr_SetString(PyExc_TypeError, "Cannot parse color");
+      PyErr_SetString (PyExc_TypeError, "Cannot parse color");
       return NULL;
     }
   } else {
-    PyErr_SetString(PyExc_TypeError, "Unknown color representation");
+    PyErr_SetString (PyExc_TypeError, "Unknown color representation");
     return nullptr;
   }
 
-  node->children.push_back(child);
+  node->children.push_back (child);
 
-  PyObject *pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  PyObject *pyresult = PyOpenSCADObjectFromNode (&PyOpenSCADType, node);
   if (child_dict != nullptr) {
     PyObject *key, *value;
     Py_ssize_t pos = 0;
-    while (PyDict_Next(child_dict, &pos, &key, &value)) {
-      PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value);
+    while (PyDict_Next (child_dict, &pos, &key, &value)) {
+      PyDict_SetItem (((PyOpenSCADObject *)pyresult)->dict, key, value);
     }
   }
   return pyresult;
-
 }
 
-PyObject *python_color(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_color (PyObject *self, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"obj", "c", "alpha", NULL};
   PyObject *obj = NULL;
   PyObject *color = NULL;
   double alpha = 1.0;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|Od", kwlist,
-                                   &obj,
-                                   &color, &alpha
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "error during parsing color");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O|Od", kwlist,
+                                    &obj,
+                                    &color, &alpha)) {
+    PyErr_SetString (PyExc_TypeError, "error during parsing color");
     return NULL;
   }
-  return python_color_core(obj, color, alpha);
+  return python_color_core (obj, color, alpha);
 }
 
-PyObject *python_oo_color(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_color (PyObject *obj, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"c", "alpha", NULL};
   PyObject *color = NULL;
   double alpha = 1.0;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|Od", kwlist,
-                                   &color, &alpha
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "error during parsing color");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "|Od", kwlist,
+                                    &color, &alpha)) {
+    PyErr_SetString (PyExc_TypeError, "error during parsing color");
     return NULL;
   }
-  return python_color_core(obj, color, alpha);
+  return python_color_core (obj, color, alpha);
 }
 
-PyObject *python_mesh_core(PyObject *obj, bool tessellate)
-{
+PyObject *python_mesh_core (PyObject *obj, bool tessellate) {
   PyObject *dummydict;
-  std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNodeMulti(obj, &dummydict);
+  std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNodeMulti (obj, &dummydict);
   if (child == NULL) {
-    PyErr_SetString(PyExc_TypeError, "Invalid type for  Object in mesh \n");
+    PyErr_SetString (PyExc_TypeError, "Invalid type for  Object in mesh \n");
     return NULL;
   }
-  Tree tree(child, "");
-  GeometryEvaluator geomevaluator(tree);
-  std::shared_ptr<const Geometry> geom = geomevaluator.evaluateGeometry(*tree.root(), true);
-  std::shared_ptr<const PolySet> ps = PolySetUtils::getGeometryAsPolySet(geom);
-
+  Tree tree (child, "");
+  GeometryEvaluator geomevaluator (tree);
+  std::shared_ptr<const Geometry> geom = geomevaluator.evaluateGeometry (*tree.root (), true);
+  std::shared_ptr<const PolySet> ps = PolySetUtils::getGeometryAsPolySet (geom);
 
-  if (ps != nullptr){
+  if (ps != nullptr) {
     if (tessellate == true) {
-      ps = PolySetUtils::tessellate_faces(*ps);
+      ps = PolySetUtils::tessellate_faces (*ps);
     }
     // Now create Python Point array
-    PyObject *ptarr = PyList_New(ps->vertices.size());
-    for (unsigned int i = 0; i < ps->vertices.size(); i++) {
-      PyObject *coord = PyList_New(3);
+    PyObject *ptarr = PyList_New (ps->vertices.size ());
+    for (unsigned int i = 0; i < ps->vertices.size (); i++) {
+      PyObject *coord = PyList_New (3);
       for (int j = 0; j < 3; j++)
-        PyList_SetItem(coord, j, PyFloat_FromDouble(ps->vertices[i][j]));
-      PyList_SetItem(ptarr, i, coord);
-      Py_XINCREF(coord);
+        PyList_SetItem (coord, j, PyFloat_FromDouble (ps->vertices[i][j]));
+      PyList_SetItem (ptarr, i, coord);
+      Py_XINCREF (coord);
     }
-    Py_XINCREF(ptarr);
+    Py_XINCREF (ptarr);
     // Now create Python Point array
-    PyObject *polarr = PyList_New(ps->indices.size());
-    for (unsigned int i = 0; i < ps->indices.size(); i++) {
-      PyObject *face = PyList_New(ps->indices[i].size());
-      for (unsigned int j = 0; j < ps->indices[i].size(); j++)
-        PyList_SetItem(face, j, PyLong_FromLong(ps->indices[i][j]));
-      PyList_SetItem(polarr, i, face);
-      Py_XINCREF(face);
+    PyObject *polarr = PyList_New (ps->indices.size ());
+    for (unsigned int i = 0; i < ps->indices.size (); i++) {
+      PyObject *face = PyList_New (ps->indices[i].size ());
+      for (unsigned int j = 0; j < ps->indices[i].size (); j++)
+        PyList_SetItem (face, j, PyLong_FromLong (ps->indices[i][j]));
+      PyList_SetItem (polarr, i, face);
+      Py_XINCREF (face);
     }
-    Py_XINCREF(polarr);
+    Py_XINCREF (polarr);
 
-    PyObject *result = PyTuple_New(2);
-    PyTuple_SetItem(result, 0, ptarr);
-    PyTuple_SetItem(result, 1, polarr);
+    PyObject *result = PyTuple_New (2);
+    PyTuple_SetItem (result, 0, ptarr);
+    PyTuple_SetItem (result, 1, polarr);
 
     return result;
   }
-  if (auto polygon2d = std::dynamic_pointer_cast<const Polygon2d>(geom)) {
-    const std::vector<Outline2d> outlines = polygon2d->outlines();
-    PyObject *pyth_outlines = PyList_New(outlines.size());
-    for (unsigned int i = 0; i < outlines.size(); i++) {
-      const Outline2d& outline = outlines[i];
-      PyObject *pyth_outline = PyList_New(outline.vertices.size());
-      for (unsigned int j = 0; j < outline.vertices.size(); j++) {
+  if (auto polygon2d = std::dynamic_pointer_cast<const Polygon2d> (geom)) {
+    const std::vector<Outline2d> outlines = polygon2d->outlines ();
+    PyObject *pyth_outlines = PyList_New (outlines.size ());
+    for (unsigned int i = 0; i < outlines.size (); i++) {
+      const Outline2d &outline = outlines[i];
+      PyObject *pyth_outline = PyList_New (outline.vertices.size ());
+      for (unsigned int j = 0; j < outline.vertices.size (); j++) {
         Vector2d pt = outline.vertices[j];
-        PyObject *pyth_pt = PyList_New(2);
+        PyObject *pyth_pt = PyList_New (2);
         for (int k = 0; k < 2; k++)
-          PyList_SetItem(pyth_pt, k, PyFloat_FromDouble(pt[k]));
-        PyList_SetItem(pyth_outline, j, pyth_pt);
+          PyList_SetItem (pyth_pt, k, PyFloat_FromDouble (pt[k]));
+        PyList_SetItem (pyth_outline, j, pyth_pt);
       }
-      PyList_SetItem(pyth_outlines, i, pyth_outline);
+      PyList_SetItem (pyth_outlines, i, pyth_outline);
     }
     return pyth_outlines;
   }
   return Py_None;
 }
 
-PyObject *python_mesh(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_mesh (PyObject *self, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"obj", "triangulate", NULL};
   PyObject *obj = NULL;
   PyObject *tess = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O", kwlist, &obj, &tess)) {
-    PyErr_SetString(PyExc_TypeError, "error during parsing\n");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O|O", kwlist, &obj, &tess)) {
+    PyErr_SetString (PyExc_TypeError, "error during parsing\n");
     return NULL;
   }
-  return python_mesh_core(obj, tess == Py_True);
+  return python_mesh_core (obj, tess == Py_True);
 }
 
-PyObject *python_oo_mesh(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = { "triangulate", NULL};
+PyObject *python_oo_mesh (PyObject *obj, PyObject *args, PyObject *kwargs) {
+  char *kwlist[] = {"triangulate", NULL};
   PyObject *tess = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O", kwlist, &tess)) {
-    PyErr_SetString(PyExc_TypeError, "error during parsing\n");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "|O", kwlist, &tess)) {
+    PyErr_SetString (PyExc_TypeError, "error during parsing\n");
     return NULL;
   }
-  return python_mesh_core(obj, tess == Py_True);
+  return python_mesh_core (obj, tess == Py_True);
 }
 
-PyObject *rotate_extrude_core(PyObject *obj,  int convexity, double scale, double angle, PyObject *twist, PyObject *origin, PyObject *offset, PyObject *vp, char *method, double fn, double fa, double fs)
-{
+PyObject *rotate_extrude_core (PyObject *obj, int convexity, double scale, double angle, PyObject *twist, PyObject *origin, PyObject *offset, PyObject *vp, char *method, double fn, double fa, double fs) {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
-  auto node = std::make_shared<RotateExtrudeNode>(instance);
-  if (1){
+  auto node = std::make_shared<RotateExtrudeNode> (instance);
+  if (1) {
     PyObject *dummydict;
-    child = PyOpenSCADObjectToNodeMulti(obj, &dummydict);
+    child = PyOpenSCADObjectToNodeMulti (obj, &dummydict);
     if (child == NULL) {
-      PyErr_SetString(PyExc_TypeError, "Invalid type for  Object in rotate_extrude\n");
+      PyErr_SetString (PyExc_TypeError, "Invalid type for  Object in rotate_extrude\n");
       return NULL;
     }
-    node->children.push_back(child);
+    node->children.push_back (child);
   }
 
-  get_fnas(node->fn, node->fa, node->fs);
-  if (!isnan(fn)) node->fn = fn;
-  if (!isnan(fa)) node->fa = fa;
-  if (!isnan(fs)) node->fs = fs;
+  get_fnas (node->fn, node->fa, node->fs);
+  if (!isnan (fn))
+    node->fn = fn;
+  if (!isnan (fa))
+    node->fa = fa;
+  if (!isnan (fs))
+    node->fs = fs;
 
   node->convexity = convexity;
 
   double dummy;
-  Vector3d v(0, 0, 0);
-  if (vp != nullptr && !python_vectorval(vp, 3, 3, &v[0], &v[1], &v[2], &dummy)){
+  Vector3d v (0, 0, 0);
+  if (vp != nullptr && !python_vectorval (vp, 3, 3, &v[0], &v[1], &v[2], &dummy)) {
   }
 
-  if (node->convexity <= 0) node->convexity = 2;
-  if (node->angle <= -360)  node->angle = 360;
+  if (node->convexity <= 0)
+    node->convexity = 2;
+  if (node->angle <= -360)
+    node->angle = 360;
 
-  return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  return PyOpenSCADObjectFromNode (&PyOpenSCADType, node);
 }
 
-PyObject *python_rotate_extrude(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_rotate_extrude (PyObject *self, PyObject *args, PyObject *kwargs) {
   PyObject *obj = NULL;
   int convexity = 1;
   double scale = 1.0;
@@ -1228,19 +1209,18 @@ PyObject *python_rotate_extrude(PyObject *self, PyObject *args, PyObject *kwargs
   PyObject *origin = NULL;
   PyObject *offset = NULL;
   double fn = NAN, fa = NAN, fs = NAN;
-  get_fnas(fn, fa, fs);
+  get_fnas (fn, fa, fs);
   char *kwlist[] = {"obj", "convexity", "scale", "angle", "twist", "origin", "offset", "v", "method", "fn", "fa", "fs", NULL};
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|iddOOOOsddd", kwlist,
-                                   &obj, &convexity, &scale, &angle, &twist, &origin, &offset, &v, &method, &fn, &fa, &fs)){
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O|iddOOOOsddd", kwlist,
+                                    &obj, &convexity, &scale, &angle, &twist, &origin, &offset, &v, &method, &fn, &fa, &fs)) {
 
-    PyErr_SetString(PyExc_TypeError, "Error during parsing rotate_extrude(object,...)");
+    PyErr_SetString (PyExc_TypeError, "Error during parsing rotate_extrude(object,...)");
     return NULL;
   }
-  return rotate_extrude_core(obj, convexity, scale, angle, twist, origin, offset, v, method, fn, fa, fs);
+  return rotate_extrude_core (obj, convexity, scale, angle, twist, origin, offset, v, method, fn, fa, fs);
 }
 
-PyObject *python_oo_rotate_extrude(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_rotate_extrude (PyObject *obj, PyObject *args, PyObject *kwargs) {
   int convexity = 1;
   double scale = 1.0;
   double angle = 360.0;
@@ -1248,79 +1228,83 @@ PyObject *python_oo_rotate_extrude(PyObject *obj, PyObject *args, PyObject *kwar
   PyObject *origin = NULL;
   PyObject *offset = NULL;
   double fn = NAN, fa = NAN, fs = NAN;
-  get_fnas(fn, fa, fs);
+  get_fnas (fn, fa, fs);
   PyObject *v = NULL;
   char *method = NULL;
   char *kwlist[] = {"convexity", "scale", "angle", "twist", "origin", "offset", "v", "method", "fn", "fa", "fs", NULL};
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|iddOOOOsddd", kwlist,
-                                   &convexity, &scale, &angle, &twist, &origin, &offset, &v, &method, &fn, &fa, &fs)){
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "|iddOOOOsddd", kwlist,
+                                    &convexity, &scale, &angle, &twist, &origin, &offset, &v, &method, &fn, &fa, &fs)) {
 
-    PyErr_SetString(PyExc_TypeError, "error during parsing\n");
+    PyErr_SetString (PyExc_TypeError, "error during parsing\n");
     return NULL;
   }
-  return rotate_extrude_core(obj, convexity, scale, angle, twist, origin, offset, v, method, fn, fa, fs);
+  return rotate_extrude_core (obj, convexity, scale, angle, twist, origin, offset, v, method, fn, fa, fs);
 }
 
-PyObject *linear_extrude_core(PyObject *obj, PyObject *height, int convexity, PyObject *origin, PyObject *scale, PyObject *center, int slices, int segments, PyObject *twist, double fn, double fa, double fs)
-{
+PyObject *linear_extrude_core (PyObject *obj, PyObject *height, int convexity, PyObject *origin, PyObject *scale, PyObject *center, int slices, int segments, PyObject *twist, double fn, double fa, double fs) {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
-  auto node = std::make_shared<LinearExtrudeNode>(instance);
+  auto node = std::make_shared<LinearExtrudeNode> (instance);
 
-  get_fnas(node->fn, node->fa, node->fs);
-  if (1){
+  get_fnas (node->fn, node->fa, node->fs);
+  if (1) {
     PyObject *dummydict;
-    child = PyOpenSCADObjectToNodeMulti(obj, &dummydict);
+    child = PyOpenSCADObjectToNodeMulti (obj, &dummydict);
     if (child == NULL) {
-      PyErr_SetString(PyExc_TypeError, "Invalid type for  Object in linear_extrude\n");
+      PyErr_SetString (PyExc_TypeError, "Invalid type for  Object in linear_extrude\n");
       return NULL;
     }
-    node->children.push_back(child);
+    node->children.push_back (child);
   }
 
+  if (!isnan (fn))
+    node->fn = fn;
+  if (!isnan (fa))
+    node->fa = fa;
+  if (!isnan (fs))
+    node->fs = fs;
 
-  if (!isnan(fn)) node->fn = fn;
-  if (!isnan(fa)) node->fa = fa;
-  if (!isnan(fs)) node->fs = fs;
-
-  Vector3d height_vec(0, 0, 0);
+  Vector3d height_vec (0, 0, 0);
   double dummy;
-  if (!python_numberval(height, &height_vec[2])) {
+  if (!python_numberval (height, &height_vec[2])) {
     node->height = height_vec;
-  } else if (!python_vectorval(height, 3, 3, &height_vec[0], &height_vec[1], &height_vec[2], &dummy)) {
+  } else if (!python_vectorval (height, 3, 3, &height_vec[0], &height_vec[1], &height_vec[2], &dummy)) {
     node->height = height_vec;
   }
 
   node->convexity = convexity;
 
-  node->scale_x = 1.0; node->scale_y = 1.0;
-  if (scale != NULL && PyList_Check(scale) && PyList_Size(scale) == 2) {
-    node->scale_x = PyFloat_AsDouble(PyList_GetItem(scale, 0));
-    node->scale_y = PyFloat_AsDouble(PyList_GetItem(scale, 1));
+  node->scale_x = 1.0;
+  node->scale_y = 1.0;
+  if (scale != NULL && PyList_Check (scale) && PyList_Size (scale) == 2) {
+    node->scale_x = PyFloat_AsDouble (PyList_GetItem (scale, 0));
+    node->scale_y = PyFloat_AsDouble (PyList_GetItem (scale, 1));
   }
 
-  if (center == Py_True) node->center = 1;
-  else if (center == Py_False || center == NULL)   node->center = 0;
+  if (center == Py_True)
+    node->center = 1;
+  else if (center == Py_False || center == NULL)
+    node->center = 0;
   else {
-    PyErr_SetString(PyExc_TypeError, "Unknown Value for center parameter");
+    PyErr_SetString (PyExc_TypeError, "Unknown Value for center parameter");
     return NULL;
   }
 
   node->slices = slices;
-  node->has_slices = slices != 1?1:0;
+  node->has_slices = slices != 1 ? 1 : 0;
 
   node->segments = segments;
-  node->has_segments = segments != 1?1:0;
+  node->has_segments = segments != 1 ? 1 : 0;
 
   if (twist != NULL) {
-    node->twist = PyFloat_AsDouble(twist);
+    node->twist = PyFloat_AsDouble (twist);
     node->has_twist = 1;
-  } else node->has_twist = 0;
-  return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  } else
+    node->has_twist = 0;
+  return PyOpenSCADObjectFromNode (&PyOpenSCADType, node);
 }
 
-PyObject *python_linear_extrude(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_linear_extrude (PyObject *self, PyObject *args, PyObject *kwargs) {
   PyObject *obj = NULL;
   PyObject *height = NULL;
   int convexity = 1;
@@ -1333,17 +1317,16 @@ PyObject *python_linear_extrude(PyObject *self, PyObject *args, PyObject *kwargs
   double fn = NAN, fa = NAN, fs = NAN;
 
   char *kwlist[] = {"obj", "height", "convexity", "origin", "scale", "center", "slices", "segments", "twist", "fn", "fa", "fs", NULL};
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|OiOOOiiOddd", kwlist,
-                                   &obj, &height, &convexity, &origin, &scale, &center, &slices, &segments, &twist, &fn, &fs, &fs)){
-    PyErr_SetString(PyExc_TypeError, "error during parsing\n");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O|OiOOOiiOddd", kwlist,
+                                    &obj, &height, &convexity, &origin, &scale, &center, &slices, &segments, &twist, &fn, &fs, &fs)) {
+    PyErr_SetString (PyExc_TypeError, "error during parsing\n");
     return NULL;
   }
 
-  return linear_extrude_core(obj, height, convexity, origin, scale, center, slices, segments, twist, fn, fa, fs);
+  return linear_extrude_core (obj, height, convexity, origin, scale, center, slices, segments, twist, fn, fa, fs);
 }
 
-PyObject *python_oo_linear_extrude(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_linear_extrude (PyObject *obj, PyObject *args, PyObject *kwargs) {
   PyObject *height = NULL;
   int convexity = 1;
   PyObject *origin = NULL;
@@ -1355,44 +1338,43 @@ PyObject *python_oo_linear_extrude(PyObject *obj, PyObject *args, PyObject *kwar
   double fn = NAN, fa = NAN, fs = NAN;
 
   char *kwlist[] = {"height", "convexity", "origin", "scale", "center", "slices", "segments", "twist", "fn", "fa", "fs", NULL};
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OiOOOiiOddd", kwlist,
-                                   &height, &convexity, &origin, &scale, &center, &slices, &segments, &twist, &fn, &fs, &fs)){
-    PyErr_SetString(PyExc_TypeError, "error during parsing\n");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "|OiOOOiiOddd", kwlist,
+                                    &height, &convexity, &origin, &scale, &center, &slices, &segments, &twist, &fn, &fs, &fs)) {
+    PyErr_SetString (PyExc_TypeError, "error during parsing\n");
     return NULL;
   }
 
-  return linear_extrude_core(obj, height, convexity, origin, scale, center, slices, segments, twist, fn, fa, fs);
+  return linear_extrude_core (obj, height, convexity, origin, scale, center, slices, segments, twist, fn, fa, fs);
 }
-PyObject *python_csg_sub(PyObject *self, PyObject *args, PyObject *kwargs, OpenSCADOperator mode)
-{
+PyObject *python_csg_sub (PyObject *self, PyObject *args, PyObject *kwargs, OpenSCADOperator mode) {
   DECLARE_INSTANCE
   int i;
 
-  auto node = std::make_shared<CsgOpNode>(instance, mode);
+  auto node = std::make_shared<CsgOpNode> (instance, mode);
   PyObject *obj;
   std::vector<PyObject *> child_dict;
   std::shared_ptr<AbstractNode> child;
-  for (i = 0; i < PyTuple_Size(args); i++) {
-    obj = PyTuple_GetItem(args, i);
+  for (i = 0; i < PyTuple_Size (args); i++) {
+    obj = PyTuple_GetItem (args, i);
     PyObject *dict = nullptr;
-    child = PyOpenSCADObjectToNodeMulti(obj, &dict);
+    child = PyOpenSCADObjectToNodeMulti (obj, &dict);
     if (dict != nullptr) {
-      child_dict.push_back(dict);
+      child_dict.push_back (dict);
     }
     if (child != NULL) {
-      node->children.push_back(child);
+      node->children.push_back (child);
     } else {
       switch (mode) {
       case OpenSCADOperator::UNION:
-        PyErr_SetString(PyExc_TypeError, "Error during parsing union. arguments must be solids or arrays.");
+        PyErr_SetString (PyExc_TypeError, "Error during parsing union. arguments must be solids or arrays.");
         return nullptr;
         break;
       case OpenSCADOperator::DIFFERENCE:
-        PyErr_SetString(PyExc_TypeError, "Error during parsing difference. arguments must be solids or arrays.");
+        PyErr_SetString (PyExc_TypeError, "Error during parsing difference. arguments must be solids or arrays.");
         return nullptr;
         break;
       case OpenSCADOperator::INTERSECTION:
-        PyErr_SetString(PyExc_TypeError, "Error during parsing intersection. arguments must be solids or arrays.");
+        PyErr_SetString (PyExc_TypeError, "Error during parsing intersection. arguments must be solids or arrays.");
         return nullptr;
         break;
       case OpenSCADOperator::MINKOWSKI:
@@ -1408,68 +1390,65 @@ PyObject *python_csg_sub(PyObject *self, PyObject *args, PyObject *kwargs, OpenS
     }
   }
 
-  PyObject *pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
-  for (int i = child_dict.size() - 1; i >= 0; i--){ // merge from back  to give 1st child most priority
-    auto& dict = child_dict[i];
+  PyObject *pyresult = PyOpenSCADObjectFromNode (&PyOpenSCADType, node);
+  for (int i = child_dict.size () - 1; i >= 0; i--) { // merge from back  to give 1st child most priority
+    auto &dict = child_dict[i];
     PyObject *key, *value;
     Py_ssize_t pos = 0;
-    while (PyDict_Next(dict, &pos, &key, &value)) {
-      PyObject *value1 = PyUnicode_AsEncodedString(key, "utf-8", "~");
-      const char *value_str = PyBytes_AS_STRING(value1);
-      PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value);
+    while (PyDict_Next (dict, &pos, &key, &value)) {
+      PyObject *value1 = PyUnicode_AsEncodedString (key, "utf-8", "~");
+      const char *value_str = PyBytes_AS_STRING (value1);
+      PyDict_SetItem (((PyOpenSCADObject *)pyresult)->dict, key, value);
     }
   }
   return pyresult;
 }
 
-PyObject *python_union(PyObject *self, PyObject *args, PyObject *kwargs)
-{
-  return python_csg_sub(self, args, kwargs, OpenSCADOperator::UNION);
+PyObject *python_union (PyObject *self, PyObject *args, PyObject *kwargs) {
+  return python_csg_sub (self, args, kwargs, OpenSCADOperator::UNION);
 }
 
-PyObject *python_difference(PyObject *self, PyObject *args, PyObject *kwargs)
-{
-  return python_csg_sub(self, args, kwargs, OpenSCADOperator::DIFFERENCE);
+PyObject *python_difference (PyObject *self, PyObject *args, PyObject *kwargs) {
+  return python_csg_sub (self, args, kwargs, OpenSCADOperator::DIFFERENCE);
 }
 
-PyObject *python_intersection(PyObject *self, PyObject *args, PyObject *kwargs)
-{
-  return python_csg_sub(self, args, kwargs, OpenSCADOperator::INTERSECTION);
+PyObject *python_intersection (PyObject *self, PyObject *args, PyObject *kwargs) {
+  return python_csg_sub (self, args, kwargs, OpenSCADOperator::INTERSECTION);
 }
 
-
-PyObject *python_oo_csg_sub(PyObject *self, PyObject *args, PyObject *kwargs, OpenSCADOperator mode)
-{
+PyObject *python_oo_csg_sub (PyObject *self, PyObject *args, PyObject *kwargs, OpenSCADOperator mode) {
   DECLARE_INSTANCE
   int i;
 
-  auto node = std::make_shared<CsgOpNode>(instance, mode);
-
+  auto node = std::make_shared<CsgOpNode> (instance, mode);
 
   PyObject *obj;
   PyObject *child_dict;
   PyObject *dummy_dict;
   std::shared_ptr<AbstractNode> child;
 
-  child = PyOpenSCADObjectToNodeMulti(self, &child_dict);
-  if (child != NULL)node->children.push_back(child);
+  child = PyOpenSCADObjectToNodeMulti (self, &child_dict);
+  if (child != NULL)
+    node->children.push_back (child);
 
-  for (i = 0; i < PyTuple_Size(args); i++) {
-    obj = PyTuple_GetItem(args, i);
-    if (i == 0)child = PyOpenSCADObjectToNodeMulti(obj, &child_dict);
-    else child = PyOpenSCADObjectToNodeMulti(obj, &dummy_dict);
+  for (i = 0; i < PyTuple_Size (args); i++) {
+    obj = PyTuple_GetItem (args, i);
+    if (i == 0)
+      child = PyOpenSCADObjectToNodeMulti (obj, &child_dict);
+    else
+      child = PyOpenSCADObjectToNodeMulti (obj, &dummy_dict);
     if (child != NULL) {
-      node->children.push_back(child);
+      node->children.push_back (child);
     } else {
       switch (mode) {
       case OpenSCADOperator::UNION:
-        PyErr_SetString(PyExc_TypeError, "Error during parsing union. arguments must be solids or arrays.");
+        PyErr_SetString (PyExc_TypeError, "Error during parsing union. arguments must be solids or arrays.");
         break;
       case OpenSCADOperator::DIFFERENCE:
-        PyErr_SetString(PyExc_TypeError, "Error during parsing difference. arguments must be solids or arrays.");
+        PyErr_SetString (PyExc_TypeError, "Error during parsing difference. arguments must be solids or arrays.");
         break;
       case OpenSCADOperator::INTERSECTION:
-        PyErr_SetString(PyExc_TypeError, "Error during parsing intersection. arguments must be solids or arrays.");
+        PyErr_SetString (PyExc_TypeError, "Error during parsing intersection. arguments must be solids or arrays.");
         break;
       case OpenSCADOperator::MINKOWSKI:
         break;
@@ -1484,147 +1463,157 @@ PyObject *python_oo_csg_sub(PyObject *self, PyObject *args, PyObject *kwargs, Op
     }
   }
 
-  PyObject *pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  PyObject *pyresult = PyOpenSCADObjectFromNode (&PyOpenSCADType, node);
   return pyresult;
 }
 
-PyObject *python_oo_union(PyObject *self, PyObject *args, PyObject *kwargs)
-{
-  return python_oo_csg_sub(self, args, kwargs, OpenSCADOperator::UNION);
+PyObject *python_oo_union (PyObject *self, PyObject *args, PyObject *kwargs) {
+  return python_oo_csg_sub (self, args, kwargs, OpenSCADOperator::UNION);
 }
 
-PyObject *python_oo_difference(PyObject *self, PyObject *args, PyObject *kwargs)
-{
-  return python_oo_csg_sub(self, args, kwargs, OpenSCADOperator::DIFFERENCE);
+PyObject *python_oo_difference (PyObject *self, PyObject *args, PyObject *kwargs) {
+  return python_oo_csg_sub (self, args, kwargs, OpenSCADOperator::DIFFERENCE);
 }
 
-PyObject *python_oo_intersection(PyObject *self, PyObject *args, PyObject *kwargs)
-{
-  return python_oo_csg_sub(self, args, kwargs, OpenSCADOperator::INTERSECTION);
+PyObject *python_oo_intersection (PyObject *self, PyObject *args, PyObject *kwargs) {
+  return python_oo_csg_sub (self, args, kwargs, OpenSCADOperator::INTERSECTION);
 }
 
-PyObject *python_nb_sub(PyObject *arg1, PyObject *arg2, OpenSCADOperator mode)
-{
+PyObject *python_nb_sub (PyObject *arg1, PyObject *arg2, OpenSCADOperator mode) {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child[2];
   PyObject *child_dict[2];
 
-  if (arg1 == Py_None && mode == OpenSCADOperator::UNION)return arg2;
-  if (arg2 == Py_None && mode == OpenSCADOperator::UNION)return arg1;
-  if (arg2 == Py_None && mode == OpenSCADOperator::DIFFERENCE)return arg1;
+  if (arg1 == Py_None && mode == OpenSCADOperator::UNION)
+    return arg2;
+  if (arg2 == Py_None && mode == OpenSCADOperator::UNION)
+    return arg1;
+  if (arg2 == Py_None && mode == OpenSCADOperator::DIFFERENCE)
+    return arg1;
 
-
-  child[0] = PyOpenSCADObjectToNodeMulti(arg1, &child_dict[0]);
+  child[0] = PyOpenSCADObjectToNodeMulti (arg1, &child_dict[0]);
   if (child[0] == NULL) {
-    PyErr_SetString(PyExc_TypeError, "invalid argument left to operator");
+    PyErr_SetString (PyExc_TypeError, "invalid argument left to operator");
     return NULL;
   }
-  child[1] = PyOpenSCADObjectToNodeMulti(arg2, &child_dict[1]);
+  child[1] = PyOpenSCADObjectToNodeMulti (arg2, &child_dict[1]);
   if (child[1] == NULL) {
-    PyErr_SetString(PyExc_TypeError, "invalid argument right to operator");
+    PyErr_SetString (PyExc_TypeError, "invalid argument right to operator");
     return NULL;
   }
-  auto node = std::make_shared<CsgOpNode>(instance, mode);
-  node->children.push_back(child[0]);
-  node->children.push_back(child[1]);
-  PyObject *pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  auto node = std::make_shared<CsgOpNode> (instance, mode);
+  node->children.push_back (child[0]);
+  node->children.push_back (child[1]);
+  PyObject *pyresult = PyOpenSCADObjectFromNode (&PyOpenSCADType, node);
   for (int i = 1; i >= 0; i--) {
     if (child_dict[i] != nullptr) {
       PyObject *key, *value;
       Py_ssize_t pos = 0;
-      while (PyDict_Next(child_dict[i], &pos, &key, &value)) {
-        PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value);
+      while (PyDict_Next (child_dict[i], &pos, &key, &value)) {
+        PyDict_SetItem (((PyOpenSCADObject *)pyresult)->dict, key, value);
       }
     }
   }
   return pyresult;
 }
 
-PyObject *python_nb_sub_vec3(PyObject *arg1, PyObject *arg2, int mode) // 0: translate, 1: scale, 2: translateneg, 3=translate-exp
+PyObject *python_nb_sub_vec3 (PyObject *arg1, PyObject *arg2, int mode) // 0: translate, 1: scale, 2: translateneg, 3=translate-exp
 {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
   PyObject *child_dict;
 
-  child = PyOpenSCADObjectToNodeMulti(arg1, &child_dict);
+  child = PyOpenSCADObjectToNodeMulti (arg1, &child_dict);
   std::vector<Vector3d> vecs;
 
-  vecs = python_vectors(arg2, 2, 3);
+  vecs = python_vectors (arg2, 2, 3);
 
-  if (mode == 0 && vecs.size() == 1) {
-    PyObject *mat = python_matrix_trans(arg1, vecs[0]);
-    if (mat != nullptr)return mat;
+  if (mode == 0 && vecs.size () == 1) {
+    PyObject *mat = python_matrix_trans (arg1, vecs[0]);
+    if (mat != nullptr)
+      return mat;
   }
 
-  if (vecs.size() > 0) {
+  if (vecs.size () > 0) {
     if (child == NULL) {
-      PyErr_SetString(PyExc_TypeError, "invalid argument left to operator");
+      PyErr_SetString (PyExc_TypeError, "invalid argument left to operator");
       return NULL;
     }
     std::vector<std::shared_ptr<TransformNode>> nodes;
-    for (size_t j = 0; j < vecs.size(); j++) {
-      auto node = std::make_shared<TransformNode>(instance, "transform");
-      if (mode == 0 || mode == 3)node->matrix.translate(vecs[j]);
-      if (mode == 1)node->matrix.scale(vecs[j]);
-      if (mode == 2)node->matrix.translate(-vecs[j]);
-      node->children.push_back(child);
-      nodes.push_back(node);
+    for (size_t j = 0; j < vecs.size (); j++) {
+      auto node = std::make_shared<TransformNode> (instance, "transform");
+      if (mode == 0 || mode == 3)
+        node->matrix.translate (vecs[j]);
+      if (mode == 1)
+        node->matrix.scale (vecs[j]);
+      if (mode == 2)
+        node->matrix.translate (-vecs[j]);
+      node->children.push_back (child);
+      nodes.push_back (node);
     }
-    if (nodes.size() == 1) {
-      PyObject *pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, nodes[0]);
+    if (nodes.size () == 1) {
+      PyObject *pyresult = PyOpenSCADObjectFromNode (&PyOpenSCADType, nodes[0]);
       if (child_dict != nullptr) {
         PyObject *key, *value;
         Py_ssize_t pos = 0;
-        while (PyDict_Next(child_dict, &pos, &key, &value)) {
-          PyObject *value1 = python_matrix_trans(value, vecs[0]);
-          if (value1 != nullptr) PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value1);
-          else PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value);
+        while (PyDict_Next (child_dict, &pos, &key, &value)) {
+          PyObject *value1 = python_matrix_trans (value, vecs[0]);
+          if (value1 != nullptr)
+            PyDict_SetItem (((PyOpenSCADObject *)pyresult)->dict, key, value1);
+          else
+            PyDict_SetItem (((PyOpenSCADObject *)pyresult)->dict, key, value);
         }
       }
       return pyresult;
     }
   }
-  PyErr_SetString(PyExc_TypeError, "invalid argument right to operator");
+  PyErr_SetString (PyExc_TypeError, "invalid argument right to operator");
   return NULL;
 }
 
-PyObject *python_nb_add(PyObject *arg1, PyObject *arg2) { return python_nb_sub_vec3(arg1, arg2, 0); }  // translate
-PyObject *python_nb_mul(PyObject *arg1, PyObject *arg2) { return python_nb_sub_vec3(arg1, arg2, 1); } // scale
-PyObject *python_nb_or(PyObject *arg1, PyObject *arg2) { return python_nb_sub(arg1, arg2,  OpenSCADOperator::UNION); }
-PyObject *python_nb_subtract(PyObject *arg1, PyObject *arg2)
-{
+PyObject *python_nb_add (PyObject *arg1, PyObject *arg2) {
+  return python_nb_sub_vec3 (arg1, arg2, 0);
+} // translate
+PyObject *python_nb_mul (PyObject *arg1, PyObject *arg2) {
+  return python_nb_sub_vec3 (arg1, arg2, 1);
+} // scale
+PyObject *python_nb_or (PyObject *arg1, PyObject *arg2) {
+  return python_nb_sub (arg1, arg2, OpenSCADOperator::UNION);
+}
+PyObject *python_nb_subtract (PyObject *arg1, PyObject *arg2) {
   double dmy;
-  if (PyList_Check(arg2) && PyList_Size(arg2) > 0) {
-    PyObject *sub = PyList_GetItem(arg2, 0);
-    if (!python_numberval(sub, &dmy) || PyList_Check(sub)){
-      return python_nb_sub_vec3(arg1, arg2, 2);
+  if (PyList_Check (arg2) && PyList_Size (arg2) > 0) {
+    PyObject *sub = PyList_GetItem (arg2, 0);
+    if (!python_numberval (sub, &dmy) || PyList_Check (sub)) {
+      return python_nb_sub_vec3 (arg1, arg2, 2);
     }
   }
-  return python_nb_sub(arg1, arg2,  OpenSCADOperator::DIFFERENCE); // if its solid
+  return python_nb_sub (arg1, arg2, OpenSCADOperator::DIFFERENCE); // if its solid
+}
+PyObject *python_nb_and (PyObject *arg1, PyObject *arg2) {
+  return python_nb_sub (arg1, arg2, OpenSCADOperator::INTERSECTION);
 }
-PyObject *python_nb_and(PyObject *arg1, PyObject *arg2) { return python_nb_sub(arg1, arg2,  OpenSCADOperator::INTERSECTION); }
 
-PyObject *python_csg_adv_sub(PyObject *self, PyObject *args, PyObject *kwargs, CgalAdvType mode)
-{
+PyObject *python_csg_adv_sub (PyObject *self, PyObject *args, PyObject *kwargs, CgalAdvType mode) {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
   int i;
   PyObject *dummydict;
 
-  auto node = std::make_shared<CgalAdvNode>(instance, mode);
+  auto node = std::make_shared<CgalAdvNode> (instance, mode);
   PyObject *obj;
-  for (i = 0; i < PyTuple_Size(args); i++) {
-    obj = PyTuple_GetItem(args, i);
-    child = PyOpenSCADObjectToNodeMulti(obj, &dummydict);
+  for (i = 0; i < PyTuple_Size (args); i++) {
+    obj = PyTuple_GetItem (args, i);
+    child = PyOpenSCADObjectToNodeMulti (obj, &dummydict);
     if (child != NULL) {
-      node->children.push_back(child);
+      node->children.push_back (child);
     } else {
       switch (mode) {
       case CgalAdvType::HULL:
-        PyErr_SetString(PyExc_TypeError, "Error during parsing hull. arguments must be solids or arrays.");
+        PyErr_SetString (PyExc_TypeError, "Error during parsing hull. arguments must be solids or arrays.");
         break;
       case CgalAdvType::FILL:
-        PyErr_SetString(PyExc_TypeError, "Error during parsing fill. arguments must be solids or arrays.");
+        PyErr_SetString (PyExc_TypeError, "Error during parsing fill. arguments must be solids or arrays.");
         break;
       case CgalAdvType::RESIZE:
         break;
@@ -1635,75 +1624,68 @@ PyObject *python_csg_adv_sub(PyObject *self, PyObject *args, PyObject *kwargs, C
     }
   }
 
-  return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  return PyOpenSCADObjectFromNode (&PyOpenSCADType, node);
 }
 
-PyObject *python_minkowski(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_minkowski (PyObject *self, PyObject *args, PyObject *kwargs) {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
   int i;
   int n;
   int convexity = 2;
 
-  auto node = std::make_shared<CgalAdvNode>(instance, CgalAdvType::MINKOWSKI);
-  char *kwlist[] = { "obj", "convexity", NULL };
+  auto node = std::make_shared<CgalAdvNode> (instance, CgalAdvType::MINKOWSKI);
+  char *kwlist[] = {"obj", "convexity", NULL};
   PyObject *objs = NULL;
   PyObject *obj;
   PyObject *dummydict;
 
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!|i", kwlist,
-                                   &PyList_Type, &objs,
-                                   &convexity
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing minkowski(object)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O!|i", kwlist,
+                                    &PyList_Type, &objs,
+                                    &convexity)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing minkowski(object)");
     return NULL;
   }
-  n = PyList_Size(objs);
+  n = PyList_Size (objs);
   for (i = 0; i < n; i++) {
-    obj = PyList_GetItem(objs, i);
-    if (Py_TYPE(obj) == &PyOpenSCADType) {
-      child = PyOpenSCADObjectToNode(obj, &dummydict);
-      node->children.push_back(child);
+    obj = PyList_GetItem (objs, i);
+    if (Py_TYPE (obj) == &PyOpenSCADType) {
+      child = PyOpenSCADObjectToNode (obj, &dummydict);
+      node->children.push_back (child);
     } else {
-      PyErr_SetString(PyExc_TypeError, "minkowski input data must be shapes");
+      PyErr_SetString (PyExc_TypeError, "minkowski input data must be shapes");
       return NULL;
     }
   }
   node->convexity = convexity;
 
-  return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  return PyOpenSCADObjectFromNode (&PyOpenSCADType, node);
 }
 
-
-
-PyObject *python_hull(PyObject *self, PyObject *args, PyObject *kwargs)
-{
-  return python_csg_adv_sub(self, args, kwargs, CgalAdvType::HULL);
+PyObject *python_hull (PyObject *self, PyObject *args, PyObject *kwargs) {
+  return python_csg_adv_sub (self, args, kwargs, CgalAdvType::HULL);
 }
 
-PyObject *python_fill(PyObject *self, PyObject *args, PyObject *kwargs)
-{
-  return python_csg_adv_sub(self, args, kwargs, CgalAdvType::FILL);
+PyObject *python_fill (PyObject *self, PyObject *args, PyObject *kwargs) {
+  return python_csg_adv_sub (self, args, kwargs, CgalAdvType::FILL);
 }
 
-PyObject *python_resize_core(PyObject *obj, PyObject *newsize, PyObject *autosize, int convexity)
-{
+PyObject *python_resize_core (PyObject *obj, PyObject *newsize, PyObject *autosize, int convexity) {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
 
-  auto node = std::make_shared<CgalAdvNode>(instance, CgalAdvType::RESIZE);
+  auto node = std::make_shared<CgalAdvNode> (instance, CgalAdvType::RESIZE);
   PyObject *dummydict;
-  child = PyOpenSCADObjectToNodeMulti(obj, &dummydict);
+  child = PyOpenSCADObjectToNodeMulti (obj, &dummydict);
   if (child == NULL) {
-    PyErr_SetString(PyExc_TypeError, "Invalid type for Object in resize");
+    PyErr_SetString (PyExc_TypeError, "Invalid type for Object in resize");
     return NULL;
   }
 
   if (newsize != NULL) {
     double x, y, z;
-    if (python_vectorval(newsize, 3, 3, &x, &y, &z)) {
-      PyErr_SetString(PyExc_TypeError, "Invalid resize dimensions");
+    if (python_vectorval (newsize, 3, 3, &x, &y, &z)) {
+      PyErr_SetString (PyExc_TypeError, "Invalid resize dimensions");
       return NULL;
     }
     node->newsize[0] = x;
@@ -1724,70 +1706,68 @@ PyObject *python_resize_core(PyObject *obj, PyObject *newsize, PyObject *autosiz
      }
    */
 
-  node->children.push_back(child);
+  node->children.push_back (child);
   node->convexity = convexity;
 
-  return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  return PyOpenSCADObjectFromNode (&PyOpenSCADType, node);
 }
 
-PyObject *python_resize(PyObject *self, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = { "obj", "newsize", "auto", "convexity", NULL };
+PyObject *python_resize (PyObject *self, PyObject *args, PyObject *kwargs) {
+  char *kwlist[] = {"obj", "newsize", "auto", "convexity", NULL};
   PyObject *obj;
   PyObject *newsize = NULL;
   PyObject *autosize = NULL;
   int convexity = 2;
 
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O!O!i", kwlist,
-                                   &obj,
-                                   &PyList_Type, &newsize,
-                                   &PyList_Type, &autosize,
-                                   &convexity
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing resize(object,vec3)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O|O!O!i", kwlist,
+                                    &obj,
+                                    &PyList_Type, &newsize,
+                                    &PyList_Type, &autosize,
+                                    &convexity)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing resize(object,vec3)");
     return NULL;
   }
-  return python_resize_core(obj, newsize, autosize, convexity);
+  return python_resize_core (obj, newsize, autosize, convexity);
 }
 
-PyObject *python_oo_resize(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = {"newsize", "auto", "convexity", NULL };
+PyObject *python_oo_resize (PyObject *obj, PyObject *args, PyObject *kwargs) {
+  char *kwlist[] = {"newsize", "auto", "convexity", NULL};
   PyObject *newsize = NULL;
   PyObject *autosize = NULL;
   int convexity = 2;
 
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O!O!i", kwlist,
-                                   &PyList_Type, &newsize,
-                                   &PyList_Type, &autosize,
-                                   &convexity
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing resize(object,vec3)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "|O!O!i", kwlist,
+                                    &PyList_Type, &newsize,
+                                    &PyList_Type, &autosize,
+                                    &convexity)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing resize(object,vec3)");
     return NULL;
   }
-  return python_resize_core(obj, newsize, autosize, convexity);
+  return python_resize_core (obj, newsize, autosize, convexity);
 }
 
 #if defined(ENABLE_EXPERIMENTAL) && defined(ENABLE_CGAL)
-PyObject *python_roof_core(PyObject *obj, const char *method, int convexity, double fn, double fa, double fs)
-{
+PyObject *python_roof_core (PyObject *obj, const char *method, int convexity, double fn, double fa, double fs) {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
-  auto node = std::make_shared<RoofNode>(instance);
+  auto node = std::make_shared<RoofNode> (instance);
   PyObject *dummydict;
-  child = PyOpenSCADObjectToNodeMulti(obj, &dummydict);
+  child = PyOpenSCADObjectToNodeMulti (obj, &dummydict);
   if (child == NULL) {
-    PyErr_SetString(PyExc_TypeError, "Invalid type for Object in roof");
+    PyErr_SetString (PyExc_TypeError, "Invalid type for Object in roof");
     return NULL;
   }
 
-  get_fnas(node->fn, node->fa, node->fs);
-  if (!isnan(fn)) node->fn = fn;
-  if (!isnan(fa)) node->fa = fa;
-  if (!isnan(fs)) node->fs = fs;
+  get_fnas (node->fn, node->fa, node->fs);
+  if (!isnan (fn))
+    node->fn = fn;
+  if (!isnan (fa))
+    node->fa = fa;
+  if (!isnan (fs))
+    node->fs = fs;
 
-  node->fa = std::max(node->fa, 0.01);
-  node->fs = std::max(node->fs, 0.01);
+  node->fa = std::max (node->fa, 0.01);
+  node->fs = std::max (node->fs, 0.01);
   if (node->fn > 0) {
     node->fa = 360.0 / node->fn;
     node->fs = 0.0;
@@ -1799,192 +1779,189 @@ PyObject *python_roof_core(PyObject *obj, const char *method, int convexity, dou
     node->method = method;
     // method can only be one of...
     if (node->method != "voronoi" && node->method != "straight") {
-//      LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
-//          "Unknown roof method '" + node->method + "'. Using 'voronoi'.");
+      //      LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+      //          "Unknown roof method '" + node->method + "'. Using 'voronoi'.");
       node->method = "voronoi";
     }
   }
 
   double tmp_convexity = convexity;
-  node->convexity = static_cast<int>(tmp_convexity);
-  if (node->convexity <= 0) node->convexity = 1;
+  node->convexity = static_cast<int> (tmp_convexity);
+  if (node->convexity <= 0)
+    node->convexity = 1;
 
-  node->children.push_back(child);
-  return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  node->children.push_back (child);
+  return PyOpenSCADObjectFromNode (&PyOpenSCADType, node);
 }
 
-PyObject *python_roof(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_roof (PyObject *self, PyObject *args, PyObject *kwargs) {
   double fn = NAN, fa = NAN, fs = NAN;
   char *kwlist[] = {"obj", "method", "convexity", "fn", "fa", "fs", NULL};
   PyObject *obj = NULL;
   const char *method = NULL;
   int convexity = 2;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|sdddd", kwlist,
-                                   &obj,
-                                   &method, convexity,
-                                   &fn, &fa, &fs
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing roof(object)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O|sdddd", kwlist,
+                                    &obj,
+                                    &method, convexity,
+                                    &fn, &fa, &fs)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing roof(object)");
     return NULL;
   }
-  return python_roof_core(obj, method, convexity, fn, fa, fs);
+  return python_roof_core (obj, method, convexity, fn, fa, fs);
 }
 
-PyObject *python_oo_roof(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_roof (PyObject *obj, PyObject *args, PyObject *kwargs) {
   double fn = NAN, fa = NAN, fs = NAN;
   char *kwlist[] = {"method", "convexity", "fn", "fa", "fs", NULL};
   const char *method = NULL;
   int convexity = 2;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|sdddd", kwlist,
-                                   &method, convexity,
-                                   &fn, &fa, &fs
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing roof(object)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "|sdddd", kwlist,
+                                    &method, convexity,
+                                    &fn, &fa, &fs)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing roof(object)");
     return NULL;
   }
-  return python_roof_core(obj, method, convexity, fn, fa, fs);
+  return python_roof_core (obj, method, convexity, fn, fa, fs);
 }
 #endif // if defined(ENABLE_EXPERIMENTAL) && defined(ENABLE_CGAL)
 
-PyObject *python_render_core(PyObject *obj, int convexity)
-{
+PyObject *python_render_core (PyObject *obj, int convexity) {
   DECLARE_INSTANCE
-  auto node = std::make_shared<RenderNode>(instance);
+  auto node = std::make_shared<RenderNode> (instance);
 
   PyObject *dummydict;
-  std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNode(obj, &dummydict);
+  std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNode (obj, &dummydict);
   node->convexity = convexity;
-  node->children.push_back(child);
-  return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  node->children.push_back (child);
+  return PyOpenSCADObjectFromNode (&PyOpenSCADType, node);
 }
 
-PyObject *python_render(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_render (PyObject *self, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"obj", "convexity", NULL};
   PyObject *obj = NULL;
   long convexity = 2;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!|i", kwlist,
-                                   &PyOpenSCADType, &obj,
-                                   &convexity
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing render(object)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O!|i", kwlist,
+                                    &PyOpenSCADType, &obj,
+                                    &convexity)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing render(object)");
     return NULL;
   }
-  return python_render_core(obj, convexity);
+  return python_render_core (obj, convexity);
 }
 
-PyObject *python_oo_render(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_render (PyObject *obj, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"convexity", NULL};
   long convexity = 2;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i", kwlist,
-                                   &convexity
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing render(object)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "|i", kwlist,
+                                    &convexity)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing render(object)");
     return NULL;
   }
-  return python_render_core(obj, convexity);
+  return python_render_core (obj, convexity);
 }
 
-PyObject *python_surface_core(const char *file, PyObject *center, PyObject *invert, int convexity)
-{
+PyObject *python_surface_core (const char *file, PyObject *center, PyObject *invert, int convexity) {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
 
-  auto node = std::make_shared<SurfaceNode>(instance);
+  auto node = std::make_shared<SurfaceNode> (instance);
 
   std::string fileval = file == NULL ? "" : file;
-  std::string filename = lookup_file(fileval, instance->location().filePath().parent_path().string(), "");
+  std::string filename = lookup_file (fileval, instance->location ().filePath ().parent_path ().string (), "");
   node->filename = filename;
-  handle_dep(fs::path(filename).generic_string());
+  handle_dep (fs::path (filename).generic_string ());
 
-  if (center == Py_True) node->center = 1;
-  else if (center == Py_False || center == NULL)   node->center = 0;
+  if (center == Py_True)
+    node->center = 1;
+  else if (center == Py_False || center == NULL)
+    node->center = 0;
   else {
-    PyErr_SetString(PyExc_TypeError, "Unknown Value for center parameter");
+    PyErr_SetString (PyExc_TypeError, "Unknown Value for center parameter");
     return NULL;
   }
   node->convexity = 2;
-  if (invert == Py_True)   node->invert = 1;
-  else if (center == Py_False || center == NULL)   node->center = 0;
+  if (invert == Py_True)
+    node->invert = 1;
+  else if (center == Py_False || center == NULL)
+    node->center = 0;
   else {
-    PyErr_SetString(PyExc_TypeError, "Unknown Value for invert parameter");
+    PyErr_SetString (PyExc_TypeError, "Unknown Value for invert parameter");
     return NULL;
   }
 
-  return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  return PyOpenSCADObjectFromNode (&PyOpenSCADType, node);
 }
 
-PyObject *python_surface(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_surface (PyObject *self, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"file", "center", "convexity", "invert", NULL};
   const char *file = NULL;
   PyObject *center = NULL;
   PyObject *invert = NULL;
   long convexity = 2;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s|OlO", kwlist,
-                                   &file, &center, &convexity
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing surface(object)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "s|OlO", kwlist,
+                                    &file, &center, &convexity)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing surface(object)");
     return NULL;
   }
 
-  return python_surface_core(file, center, invert, convexity);
+  return python_surface_core (file, center, invert, convexity);
 }
 
-PyObject *python_text(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_text (PyObject *self, PyObject *args, PyObject *kwargs) {
   DECLARE_INSTANCE
-  auto node = std::make_shared<TextNode>(instance);
+  auto node = std::make_shared<TextNode> (instance);
 
   char *kwlist[] = {"text", "size", "font", "spacing", "direction", "language", "script", "halign", "valign", "fn", "fa", "fs", NULL};
 
   double size = 1.0, spacing = 1.0;
   double fn = NAN, fa = NAN, fs = NAN;
 
-  get_fnas(fn, fa, fs);
+  get_fnas (fn, fa, fs);
 
   const char *text = "", *font = NULL, *direction = "ltr", *language = "en", *script = "latin", *valign = "baseline", *halign = "left";
 
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s|dsdsssssddd", kwlist,
-                                   &text, &size, &font,
-                                   &spacing, &direction, &language,
-                                   &script, &halign, &valign,
-                                   &fn, &fa, &fs
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing text(string, ...))");
-    return NULL;
-  }
-
-  node->params.set_fn(fn);
-  node->params.set_fa(fa);
-  node->params.set_fs(fs);
-  node->params.set_size(size);
-  if (text != NULL) node->params.set_text(text);
-  node->params.set_spacing(spacing);
-  if (font != NULL) node->params.set_font(font);
-  if (direction != NULL) node->params.set_direction(direction);
-  if (language != NULL) node->params.set_language(language);
-  if (script != NULL) node->params.set_script(script);
-  if (valign != NULL) node->params.set_halign(halign);
-  if (halign != NULL) node->params.set_valign(valign);
-  node->params.set_loc(instance->location());
-
-/*
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "s|dsdsssssddd", kwlist,
+                                    &text, &size, &font,
+                                    &spacing, &direction, &language,
+                                    &script, &halign, &valign,
+                                    &fn, &fa, &fs)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing text(string, ...))");
+    return NULL;
+  }
+
+  node->params.set_fn (fn);
+  node->params.set_fa (fa);
+  node->params.set_fs (fs);
+  node->params.set_size (size);
+  if (text != NULL)
+    node->params.set_text (text);
+  node->params.set_spacing (spacing);
+  if (font != NULL)
+    node->params.set_font (font);
+  if (direction != NULL)
+    node->params.set_direction (direction);
+  if (language != NULL)
+    node->params.set_language (language);
+  if (script != NULL)
+    node->params.set_script (script);
+  if (valign != NULL)
+    node->params.set_halign (halign);
+  if (halign != NULL)
+    node->params.set_valign (valign);
+  node->params.set_loc (instance->location ());
+
+  /*
    node->params.set_documentPath(session->documentRoot());
    }
  */
-  node->params.detect_properties();
+  node->params.detect_properties ();
 
-  return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  return PyOpenSCADObjectFromNode (&PyOpenSCADType, node);
 }
 
-PyObject *python_textmetrics(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_textmetrics (PyObject *self, PyObject *args, PyObject *kwargs) {
   DECLARE_INSTANCE
-  auto node = std::make_shared<TextNode>(instance);
+  auto node = std::make_shared<TextNode> (instance);
 
   char *kwlist[] = {"text", "size", "font", "spacing", "direction", "language", "script", "halign", "valign", NULL};
 
@@ -1992,405 +1969,396 @@ PyObject *python_textmetrics(PyObject *self, PyObject *args, PyObject *kwargs)
 
   const char *text = "", *font = NULL, *direction = "ltr", *language = "en", *script = "latin", *valign = "baseline", *halign = "left";
 
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s|dsdsssss", kwlist,
-                                   &text, &size, &font,
-                                   &spacing, &direction, &language,
-                                   &script, &valign, &halign
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing textmetrics");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "s|dsdsssss", kwlist,
+                                    &text, &size, &font,
+                                    &spacing, &direction, &language,
+                                    &script, &valign, &halign)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing textmetrics");
     return NULL;
   }
 
   FreetypeRenderer::Params ftparams;
 
-  ftparams.set_size(size);
-  if (text != NULL) ftparams.set_text(text);
-  ftparams.set_spacing(spacing);
-  if (font != NULL) ftparams.set_font(font);
-  if (direction != NULL) ftparams.set_direction(direction);
-  if (language != NULL) ftparams.set_language(language);
-  if (script != NULL) ftparams.set_script(script);
-  if (valign != NULL) ftparams.set_halign(halign);
-  if (halign != NULL) ftparams.set_valign(valign);
-  ftparams.set_loc(instance->location());
-
-  FreetypeRenderer::TextMetrics metrics(ftparams);
+  ftparams.set_size (size);
+  if (text != NULL)
+    ftparams.set_text (text);
+  ftparams.set_spacing (spacing);
+  if (font != NULL)
+    ftparams.set_font (font);
+  if (direction != NULL)
+    ftparams.set_direction (direction);
+  if (language != NULL)
+    ftparams.set_language (language);
+  if (script != NULL)
+    ftparams.set_script (script);
+  if (valign != NULL)
+    ftparams.set_halign (halign);
+  if (halign != NULL)
+    ftparams.set_valign (valign);
+  ftparams.set_loc (instance->location ());
+
+  FreetypeRenderer::TextMetrics metrics (ftparams);
   if (!metrics.ok) {
-    PyErr_SetString(PyExc_TypeError, "Invalid Metric");
+    PyErr_SetString (PyExc_TypeError, "Invalid Metric");
     return NULL;
   }
-  PyObject *offset = PyList_New(2);
-  PyList_SetItem(offset, 0, PyFloat_FromDouble(metrics.x_offset));
-  PyList_SetItem(offset, 1, PyFloat_FromDouble(metrics.y_offset));
+  PyObject *offset = PyList_New (2);
+  PyList_SetItem (offset, 0, PyFloat_FromDouble (metrics.x_offset));
+  PyList_SetItem (offset, 1, PyFloat_FromDouble (metrics.y_offset));
 
-  PyObject *advance = PyList_New(2);
-  PyList_SetItem(advance, 0, PyFloat_FromDouble(metrics.advance_x));
-  PyList_SetItem(advance, 1, PyFloat_FromDouble(metrics.advance_y));
+  PyObject *advance = PyList_New (2);
+  PyList_SetItem (advance, 0, PyFloat_FromDouble (metrics.advance_x));
+  PyList_SetItem (advance, 1, PyFloat_FromDouble (metrics.advance_y));
 
-  PyObject *position = PyList_New(2);
-  PyList_SetItem(position, 0, PyFloat_FromDouble(metrics.bbox_x));
-  PyList_SetItem(position, 1, PyFloat_FromDouble(metrics.bbox_y));
+  PyObject *position = PyList_New (2);
+  PyList_SetItem (position, 0, PyFloat_FromDouble (metrics.bbox_x));
+  PyList_SetItem (position, 1, PyFloat_FromDouble (metrics.bbox_y));
 
-  PyObject *dims = PyList_New(2);
-  PyList_SetItem(dims, 0, PyFloat_FromDouble(metrics.bbox_w));
-  PyList_SetItem(dims, 1, PyFloat_FromDouble(metrics.bbox_h));
+  PyObject *dims = PyList_New (2);
+  PyList_SetItem (dims, 0, PyFloat_FromDouble (metrics.bbox_w));
+  PyList_SetItem (dims, 1, PyFloat_FromDouble (metrics.bbox_h));
 
   PyObject *dict;
-  dict = PyDict_New();
-  PyDict_SetItemString(dict, "ascent", PyFloat_FromDouble(metrics.ascent));
-  PyDict_SetItemString(dict, "descent", PyFloat_FromDouble(metrics.descent));
-  PyDict_SetItemString(dict, "offset", offset);
-  PyDict_SetItemString(dict, "advance", advance);
-  PyDict_SetItemString(dict, "position", position);
-  PyDict_SetItemString(dict, "size", dims);
+  dict = PyDict_New ();
+  PyDict_SetItemString (dict, "ascent", PyFloat_FromDouble (metrics.ascent));
+  PyDict_SetItemString (dict, "descent", PyFloat_FromDouble (metrics.descent));
+  PyDict_SetItemString (dict, "offset", offset);
+  PyDict_SetItemString (dict, "advance", advance);
+  PyDict_SetItemString (dict, "position", position);
+  PyDict_SetItemString (dict, "size", dims);
   return (PyObject *)dict;
 }
 
-PyObject *python_offset_core(PyObject *obj, double r, double delta, PyObject *chamfer, double fn, double fa, double fs)
-{
+PyObject *python_offset_core (PyObject *obj, double r, double delta, PyObject *chamfer, double fn, double fa, double fs) {
   DECLARE_INSTANCE
-  auto node = std::make_shared<OffsetNode>(instance);
+  auto node = std::make_shared<OffsetNode> (instance);
 
   PyObject *dummydict;
-  std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNodeMulti(obj, &dummydict);
+  std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNodeMulti (obj, &dummydict);
   if (child == NULL) {
-    PyErr_SetString(PyExc_TypeError, "Invalid type for Object in offset");
+    PyErr_SetString (PyExc_TypeError, "Invalid type for Object in offset");
     return NULL;
   }
 
-  get_fnas(node->fn, node->fa, node->fs);
-  if (!isnan(fn)) node->fn = fn;
-  if (!isnan(fa)) node->fa = fa;
-  if (!isnan(fs)) node->fs = fs;
-
+  get_fnas (node->fn, node->fa, node->fs);
+  if (!isnan (fn))
+    node->fn = fn;
+  if (!isnan (fa))
+    node->fa = fa;
+  if (!isnan (fs))
+    node->fs = fs;
 
   node->delta = 1;
   node->chamfer = false;
   node->join_type = Clipper2Lib::JoinType::Round;
-  if (!isnan(r)) {
+  if (!isnan (r)) {
     node->delta = r;
-  } else if (!isnan(delta)) {
+  } else if (!isnan (delta)) {
     node->delta = delta;
     node->join_type = Clipper2Lib::JoinType::Miter;
     if (chamfer == Py_True) {
       node->chamfer = true;
       node->join_type = Clipper2Lib::JoinType::Square;
-    } else if (chamfer == Py_False || chamfer == NULL) node->chamfer = 0;
+    } else if (chamfer == Py_False || chamfer == NULL)
+      node->chamfer = 0;
     else {
-      PyErr_SetString(PyExc_TypeError, "Unknown Value for chamfer parameter");
+      PyErr_SetString (PyExc_TypeError, "Unknown Value for chamfer parameter");
       return NULL;
     }
   }
-  node->children.push_back(child);
-  return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  node->children.push_back (child);
+  return PyOpenSCADObjectFromNode (&PyOpenSCADType, node);
 }
 
-PyObject *python_offset(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_offset (PyObject *self, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"obj", "r", "delta", "chamfer", "fn", "fa", "fs", NULL};
   PyObject *obj = NULL;
   double r = NAN, delta = NAN;
   PyObject *chamfer = NULL;
   double fn = NAN, fa = NAN, fs = NAN;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|ddOddd", kwlist,
-                                   &obj,
-                                   &r, &delta, &chamfer,
-                                   &fn, &fa, &fs
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing offset(object,r,delta)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O|ddOddd", kwlist,
+                                    &obj,
+                                    &r, &delta, &chamfer,
+                                    &fn, &fa, &fs)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing offset(object,r,delta)");
     return NULL;
   }
-  return python_offset_core(obj, r, delta, chamfer, fn, fa, fs);
+  return python_offset_core (obj, r, delta, chamfer, fn, fa, fs);
 }
 
-PyObject *python_oo_offset(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_offset (PyObject *obj, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"r", "delta", "chamfer", "fn", "fa", "fs", NULL};
   double r = NAN, delta = NAN;
   PyObject *chamfer = NULL;
   double fn = NAN, fa = NAN, fs = NAN;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|ddOddd", kwlist,
-                                   &r, &delta, &chamfer,
-                                   &fn, &fa, &fs
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing offset(object,r,delta)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "|ddOddd", kwlist,
+                                    &r, &delta, &chamfer,
+                                    &fn, &fa, &fs)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing offset(object,r,delta)");
     return NULL;
   }
-  return python_offset_core(obj, r, delta, chamfer, fn, fa, fs);
+  return python_offset_core (obj, r, delta, chamfer, fn, fa, fs);
 }
 
-PyObject *python_projection_core(PyObject *obj, const char *cutmode, int convexity)
-{
+PyObject *python_projection_core (PyObject *obj, const char *cutmode, int convexity) {
   DECLARE_INSTANCE
-  auto node = std::make_shared<ProjectionNode>(instance);
+  auto node = std::make_shared<ProjectionNode> (instance);
   PyObject *dummydict;
-  std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNodeMulti(obj, &dummydict);
+  std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNodeMulti (obj, &dummydict);
   if (child == NULL) {
-    PyErr_SetString(PyExc_TypeError, "Invalid type for Object in projection");
+    PyErr_SetString (PyExc_TypeError, "Invalid type for Object in projection");
     return NULL;
   }
 
   node->convexity = convexity;
   node->cut_mode = 0;
-  if (cutmode != NULL && !strcasecmp(cutmode, "cut")) node->cut_mode = 1;
+  if (cutmode != NULL && !strcasecmp (cutmode, "cut"))
+    node->cut_mode = 1;
 
-  node->children.push_back(child);
-  return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  node->children.push_back (child);
+  return PyOpenSCADObjectFromNode (&PyOpenSCADType, node);
 }
 
-PyObject *python_projection(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_projection (PyObject *self, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"obj", "cut", "convexity", NULL};
   PyObject *obj = NULL;
   const char *cutmode = NULL;
   long convexity = 2;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|sl", kwlist,
-                                   &obj,
-                                   &cutmode, &convexity
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing projection(object)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O|sl", kwlist,
+                                    &obj,
+                                    &cutmode, &convexity)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing projection(object)");
     return NULL;
   }
-  return python_projection_core(obj, cutmode, convexity);
+  return python_projection_core (obj, cutmode, convexity);
 }
 
-PyObject *python_oo_projection(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_projection (PyObject *obj, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"cut", "convexity", NULL};
   const char *cutmode = NULL;
   long convexity = 2;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|sl", kwlist,
-                                   &cutmode, &convexity
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing projection(object)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "|sl", kwlist,
+                                    &cutmode, &convexity)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing projection(object)");
     return NULL;
   }
-  return python_projection_core(obj, cutmode, convexity);
+  return python_projection_core (obj, cutmode, convexity);
 }
 
-PyObject *python_group(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_group (PyObject *self, PyObject *args, PyObject *kwargs) {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
 
-  auto node = std::make_shared<GroupNode>(instance);
+  auto node = std::make_shared<GroupNode> (instance);
 
   char *kwlist[] = {"obj", NULL};
   PyObject *obj = NULL;
   PyObject *dummydict;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!", kwlist,
-                                   &PyOpenSCADType, &obj
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing group(group)");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O!", kwlist,
+                                    &PyOpenSCADType, &obj)) {
+    PyErr_SetString (PyExc_TypeError, "Error during parsing group(group)");
     return NULL;
   }
-  child = PyOpenSCADObjectToNode(obj, &dummydict);
+  child = PyOpenSCADObjectToNode (obj, &dummydict);
 
-  node->children.push_back(child);
-  return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
+  node->children.push_back (child);
+  return PyOpenSCADObjectFromNode (&PyOpenSCADType, node);
 }
 
-PyObject *python_align_core(PyObject *obj, PyObject *pyrefmat, PyObject *pydstmat)
-{
+PyObject *python_align_core (PyObject *obj, PyObject *pyrefmat, PyObject *pydstmat) {
   if (obj->ob_type != &PyOpenSCADType) {
-    PyErr_SetString(PyExc_TypeError, "Must specify Object as 1st parameter");
+    PyErr_SetString (PyExc_TypeError, "Must specify Object as 1st parameter");
     return nullptr;
   }
   PyObject *child_dict = nullptr;
-  std::shared_ptr<AbstractNode> dstnode = PyOpenSCADObjectToNode(obj, &child_dict);
+  std::shared_ptr<AbstractNode> dstnode = PyOpenSCADObjectToNode (obj, &child_dict);
   if (dstnode == nullptr) {
-    PyErr_SetString(PyExc_TypeError, "Invalid align object");
+    PyErr_SetString (PyExc_TypeError, "Invalid align object");
     return Py_None;
   }
   DECLARE_INSTANCE
-  auto multmatnode = std::make_shared<TransformNode>(instance, "align");
-  multmatnode->children.push_back(dstnode);
+  auto multmatnode = std::make_shared<TransformNode> (instance, "align");
+  multmatnode->children.push_back (dstnode);
   Matrix4d mat;
-  Matrix4d MT = Matrix4d::Identity();
+  Matrix4d MT = Matrix4d::Identity ();
 
-  if (!python_tomatrix(pyrefmat, mat))MT = MT * mat;
-  if (!python_tomatrix(pydstmat, mat))MT = MT * mat.inverse();
+  if (!python_tomatrix (pyrefmat, mat))
+    MT = MT * mat;
+  if (!python_tomatrix (pydstmat, mat))
+    MT = MT * mat.inverse ();
 
   multmatnode->matrix = MT;
 
-  PyObject *pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, multmatnode);
+  PyObject *pyresult = PyOpenSCADObjectFromNode (&PyOpenSCADType, multmatnode);
   if (child_dict != nullptr) {
     PyObject *key, *value;
     Py_ssize_t pos = 0;
-    while (PyDict_Next(child_dict, &pos, &key, &value)) {
-      if (!python_tomatrix(value, mat)){
+    while (PyDict_Next (child_dict, &pos, &key, &value)) {
+      if (!python_tomatrix (value, mat)) {
         mat = MT * mat;
-        PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, python_frommatrix(mat));
-      } else PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value);
+        PyDict_SetItem (((PyOpenSCADObject *)pyresult)->dict, key, python_frommatrix (mat));
+      } else
+        PyDict_SetItem (((PyOpenSCADObject *)pyresult)->dict, key, value);
     }
   }
   return pyresult;
 }
 
-PyObject *python_align(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_align (PyObject *self, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"obj", "refmat", "objmat", NULL};
   PyObject *obj = NULL;
   PyObject *pyrefmat = NULL;
   PyObject *pyobjmat = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO|O", kwlist,
-                                   &obj,
-                                   &pyrefmat,
-                                   &pyobjmat
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during align");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "OO|O", kwlist,
+                                    &obj,
+                                    &pyrefmat,
+                                    &pyobjmat)) {
+    PyErr_SetString (PyExc_TypeError, "Error during align");
     return NULL;
   }
-  return python_align_core(obj, pyrefmat, pyobjmat);
+  return python_align_core (obj, pyrefmat, pyobjmat);
 }
 
-PyObject *python_oo_align(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_align (PyObject *obj, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"refmat", "objmat", NULL};
   PyObject *pyrefmat = NULL;
   PyObject *pyobjmat = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O", kwlist,
-                                   &pyrefmat,
-                                   &pyobjmat
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during align");
+  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O|O", kwlist,
+                                    &pyrefmat,
+                                    &pyobjmat)) {
+    PyErr_SetString (PyExc_TypeError, "Error during align");
     return NULL;
   }
-  return python_align_core(obj, pyrefmat, pyobjmat);
+  return python_align_core (obj, pyrefmat, pyobjmat);
 }
 
-
-PyObject *python_str(PyObject *self) {
+PyObject *python_str (PyObject *self) {
   std::ostringstream stream;
   PyObject *dummydict;
-  std::shared_ptr<AbstractNode> node = PyOpenSCADObjectToNode(self, &dummydict);
-  if (node != nullptr)stream << "OpenSCAD (" << (int) node->index() << ")";
-  else stream << "Invalid OpenSCAD Object";
+  std::shared_ptr<AbstractNode> node = PyOpenSCADObjectToNode (self, &dummydict);
+  if (node != nullptr)
+    stream << "OpenSCAD (" << (int)node->index () << ")";
+  else
+    stream << "Invalid OpenSCAD Object";
 
-  return PyUnicode_FromStringAndSize(stream.str().c_str(), stream.str().size());
+  return PyUnicode_FromStringAndSize (stream.str ().c_str (), stream.str ().size ());
 }
 
 PyMethodDef PyOpenSCADFunctions[] = {
-  {"square", (PyCFunction) python_square, METH_VARARGS | METH_KEYWORDS, "Create Square."},
-  {"circle", (PyCFunction) python_circle, METH_VARARGS | METH_KEYWORDS, "Create Circle."},
-  {"polygon", (PyCFunction) python_polygon, METH_VARARGS | METH_KEYWORDS, "Create Polygon."},
-  {"text", (PyCFunction) python_text, METH_VARARGS | METH_KEYWORDS, "Create Text."},
-  {"textmetrics", (PyCFunction) python_textmetrics, METH_VARARGS | METH_KEYWORDS, "Get textmetrics."},
-  {"cube", (PyCFunction) python_cube, METH_VARARGS | METH_KEYWORDS, "Create Cube."},
-  {"cylinder", (PyCFunction) python_cylinder, METH_VARARGS | METH_KEYWORDS, "Create Cylinder."},
-  {"sphere", (PyCFunction) python_sphere, METH_VARARGS | METH_KEYWORDS, "Create Sphere."},
-  {"polyhedron", (PyCFunction) python_polyhedron, METH_VARARGS | METH_KEYWORDS, "Create Polyhedron."},
-  {"translate", (PyCFunction) python_translate, METH_VARARGS | METH_KEYWORDS, "Move  Object."},
-  {"rotate", (PyCFunction) python_rotate, METH_VARARGS | METH_KEYWORDS, "Rotate Object."},
-  {"scale", (PyCFunction) python_scale, METH_VARARGS | METH_KEYWORDS, "Scale Object."},
-  {"mirror", (PyCFunction) python_mirror, METH_VARARGS | METH_KEYWORDS, "Mirror Object."},
-  {"multmatrix", (PyCFunction) python_multmatrix, METH_VARARGS | METH_KEYWORDS, "Multmatrix Object."},
-  {"divmatrix", (PyCFunction) python_divmatrix, METH_VARARGS | METH_KEYWORDS, "Divmatrix Object."},
-  {"offset", (PyCFunction) python_offset, METH_VARARGS | METH_KEYWORDS, "Offset Object."},
+  {"square", (PyCFunction)python_square, METH_VARARGS | METH_KEYWORDS, "Create Square."},
+  {"circle", (PyCFunction)python_circle, METH_VARARGS | METH_KEYWORDS, "Create Circle."},
+  {"polygon", (PyCFunction)python_polygon, METH_VARARGS | METH_KEYWORDS, "Create Polygon."},
+  {"text", (PyCFunction)python_text, METH_VARARGS | METH_KEYWORDS, "Create Text."},
+  {"textmetrics", (PyCFunction)python_textmetrics, METH_VARARGS | METH_KEYWORDS, "Get textmetrics."},
+  {"cube", (PyCFunction)python_cube, METH_VARARGS | METH_KEYWORDS, "Create Cube."},
+  {"cylinder", (PyCFunction)python_cylinder, METH_VARARGS | METH_KEYWORDS, "Create Cylinder."},
+  {"sphere", (PyCFunction)python_sphere, METH_VARARGS | METH_KEYWORDS, "Create Sphere."},
+  {"polyhedron", (PyCFunction)python_polyhedron, METH_VARARGS | METH_KEYWORDS, "Create Polyhedron."},
+  {"translate", (PyCFunction)python_translate, METH_VARARGS | METH_KEYWORDS, "Move  Object."},
+  {"rotate", (PyCFunction)python_rotate, METH_VARARGS | METH_KEYWORDS, "Rotate Object."},
+  {"scale", (PyCFunction)python_scale, METH_VARARGS | METH_KEYWORDS, "Scale Object."},
+  {"mirror", (PyCFunction)python_mirror, METH_VARARGS | METH_KEYWORDS, "Mirror Object."},
+  {"multmatrix", (PyCFunction)python_multmatrix, METH_VARARGS | METH_KEYWORDS, "Multmatrix Object."},
+  {"divmatrix", (PyCFunction)python_divmatrix, METH_VARARGS | METH_KEYWORDS, "Divmatrix Object."},
+  {"offset", (PyCFunction)python_offset, METH_VARARGS | METH_KEYWORDS, "Offset Object."},
 #if defined(ENABLE_EXPERIMENTAL) && defined(ENABLE_CGAL)
-  {"roof", (PyCFunction) python_roof, METH_VARARGS | METH_KEYWORDS, "Roof Object."},
+  {"roof", (PyCFunction)python_roof, METH_VARARGS | METH_KEYWORDS, "Roof Object."},
 #endif
-  {"color", (PyCFunction) python_color, METH_VARARGS | METH_KEYWORDS, "Color Object."},
-  {"show", (PyCFunction) python_show, METH_VARARGS | METH_KEYWORDS, "Show the result."},
-  {"linear_extrude", (PyCFunction) python_linear_extrude, METH_VARARGS | METH_KEYWORDS, "Linear_extrude Object."},
-  {"rotate_extrude", (PyCFunction) python_rotate_extrude, METH_VARARGS | METH_KEYWORDS, "Rotate_extrude Object."},
-  {"union", (PyCFunction) python_union, METH_VARARGS | METH_KEYWORDS, "Union Object."},
-  {"difference", (PyCFunction) python_difference, METH_VARARGS | METH_KEYWORDS, "Difference Object."},
-  {"intersection", (PyCFunction) python_intersection, METH_VARARGS | METH_KEYWORDS, "Intersection Object."},
-  {"hull", (PyCFunction) python_hull, METH_VARARGS | METH_KEYWORDS, "Hull Object."},
-  {"minkowski", (PyCFunction) python_minkowski, METH_VARARGS | METH_KEYWORDS, "Minkowski Object."},
-  {"fill", (PyCFunction) python_fill, METH_VARARGS | METH_KEYWORDS, "Fill Object."},
-  {"resize", (PyCFunction) python_resize, METH_VARARGS | METH_KEYWORDS, "Resize Object."},
-  {"projection", (PyCFunction) python_projection, METH_VARARGS | METH_KEYWORDS, "Projection Object."},
-  {"surface", (PyCFunction) python_surface, METH_VARARGS | METH_KEYWORDS, "Surface Object."},
-  {"mesh", (PyCFunction) python_mesh, METH_VARARGS | METH_KEYWORDS, "exports mesh."},
-  {"render", (PyCFunction) python_render, METH_VARARGS | METH_KEYWORDS, "Render Object."},
-  {"align", (PyCFunction) python_align, METH_VARARGS | METH_KEYWORDS, "Align Object to another."},
-  {NULL, NULL, 0, NULL}
-};
+  {"color", (PyCFunction)python_color, METH_VARARGS | METH_KEYWORDS, "Color Object."},
+  {"show", (PyCFunction)python_show, METH_VARARGS | METH_KEYWORDS, "Show the result."},
+  {"linear_extrude", (PyCFunction)python_linear_extrude, METH_VARARGS | METH_KEYWORDS, "Linear_extrude Object."},
+  {"rotate_extrude", (PyCFunction)python_rotate_extrude, METH_VARARGS | METH_KEYWORDS, "Rotate_extrude Object."},
+  {"union", (PyCFunction)python_union, METH_VARARGS | METH_KEYWORDS, "Union Object."},
+  {"difference", (PyCFunction)python_difference, METH_VARARGS | METH_KEYWORDS, "Difference Object."},
+  {"intersection", (PyCFunction)python_intersection, METH_VARARGS | METH_KEYWORDS, "Intersection Object."},
+  {"hull", (PyCFunction)python_hull, METH_VARARGS | METH_KEYWORDS, "Hull Object."},
+  {"minkowski", (PyCFunction)python_minkowski, METH_VARARGS | METH_KEYWORDS, "Minkowski Object."},
+  {"fill", (PyCFunction)python_fill, METH_VARARGS | METH_KEYWORDS, "Fill Object."},
+  {"resize", (PyCFunction)python_resize, METH_VARARGS | METH_KEYWORDS, "Resize Object."},
+  {"projection", (PyCFunction)python_projection, METH_VARARGS | METH_KEYWORDS, "Projection Object."},
+  {"surface", (PyCFunction)python_surface, METH_VARARGS | METH_KEYWORDS, "Surface Object."},
+  {"mesh", (PyCFunction)python_mesh, METH_VARARGS | METH_KEYWORDS, "exports mesh."},
+  {"render", (PyCFunction)python_render, METH_VARARGS | METH_KEYWORDS, "Render Object."},
+  {"align", (PyCFunction)python_align, METH_VARARGS | METH_KEYWORDS, "Align Object to another."},
+  {NULL, NULL, 0, NULL}};
 
 #define OO_METHOD_ENTRY(name, desc) \
-        {#name, (PyCFunction) python_oo_ ## name, METH_VARARGS | METH_KEYWORDS, desc},
+  {#name, (PyCFunction)python_oo_##name, METH_VARARGS | METH_KEYWORDS, desc},
 
 PyMethodDef PyOpenSCADMethods[] = {
-  OO_METHOD_ENTRY(translate, "Move Object")
-  OO_METHOD_ENTRY(rotate, "Rotate Object")
-
-  OO_METHOD_ENTRY(union, "Union Object")
-  OO_METHOD_ENTRY(difference, "Difference Object")
-  OO_METHOD_ENTRY(intersection, "Intersection Object")
-  OO_METHOD_ENTRY(scale, "Scale Object")
-  OO_METHOD_ENTRY(mirror, "Mirror Object")
-  OO_METHOD_ENTRY(multmatrix, "Multmatrix Object")
-  OO_METHOD_ENTRY(divmatrix, "Divmatrix Object")
-  OO_METHOD_ENTRY(offset, "Offset Object")
+  OO_METHOD_ENTRY (translate, "Move Object")
+    OO_METHOD_ENTRY (rotate, "Rotate Object")
+
+      OO_METHOD_ENTRY (union, "Union Object")
+        OO_METHOD_ENTRY (difference, "Difference Object")
+          OO_METHOD_ENTRY (intersection, "Intersection Object")
+            OO_METHOD_ENTRY (scale, "Scale Object")
+              OO_METHOD_ENTRY (mirror, "Mirror Object")
+                OO_METHOD_ENTRY (multmatrix, "Multmatrix Object")
+                  OO_METHOD_ENTRY (divmatrix, "Divmatrix Object")
+                    OO_METHOD_ENTRY (offset, "Offset Object")
 #if defined(ENABLE_EXPERIMENTAL) && defined(ENABLE_CGAL)
-  OO_METHOD_ENTRY(roof, "Roof Object")
+                      OO_METHOD_ENTRY (roof, "Roof Object")
 #endif
-  OO_METHOD_ENTRY(color, "Color Object")
-  OO_METHOD_ENTRY(linear_extrude, "Linear_extrude Object")
-  OO_METHOD_ENTRY(rotate_extrude, "Rotate_extrude Object")
-  OO_METHOD_ENTRY(resize, "Resize Object")
+                        OO_METHOD_ENTRY (color, "Color Object")
+                          OO_METHOD_ENTRY (linear_extrude, "Linear_extrude Object")
+                            OO_METHOD_ENTRY (rotate_extrude, "Rotate_extrude Object")
+                              OO_METHOD_ENTRY (resize, "Resize Object")
 
-  OO_METHOD_ENTRY(mesh, "Mesh Object")
-  OO_METHOD_ENTRY(align, "Align Object to another")
+                                OO_METHOD_ENTRY (mesh, "Mesh Object")
+                                  OO_METHOD_ENTRY (align, "Align Object to another")
 
-  OO_METHOD_ENTRY(show, "Show Object")
-  OO_METHOD_ENTRY(projection, "Projection Object")
-  OO_METHOD_ENTRY(render, "Render Object")
-  {
-    NULL, NULL, 0, NULL
-  }
-};
+                                    OO_METHOD_ENTRY (show, "Show Object")
+                                      OO_METHOD_ENTRY (projection, "Projection Object")
+                                        OO_METHOD_ENTRY (render, "Render Object"){
+                                          NULL, NULL, 0, NULL}};
 
 PyNumberMethods PyOpenSCADNumbers =
-{
-  python_nb_add,    //binaryfunc nb_add
-  python_nb_subtract,   //binaryfunc nb_subtract
-  python_nb_mul,    //binaryfunc nb_multiply
-  0,        //binaryfunc nb_remainder
-  0,        //binaryfunc nb_divmod
-  0,        //ternaryfunc nb_power
-  0,        //unaryfunc nb_negative
-  0,        //unaryfunc nb_positive
-  0,        //unaryfunc nb_absolute
-  0,        //inquiry nb_bool
-  0,          //unaryfunc nb_invert
-  0,        //binaryfunc nb_lshift
-  0,        //binaryfunc nb_rshift
-  python_nb_and,    //binaryfunc nb_and
-  0,        //binaryfunc nb_xor
-  python_nb_or,     //binaryfunc nb_or
-  0,        //unaryfunc nb_int
-  0,        //void *nb_reserved
-  0,        //unaryfunc nb_float
-
-  0,        //binaryfunc nb_inplace_add
-  0,        //binaryfunc nb_inplace_subtract
-  0,        //binaryfunc nb_inplace_multiply
-  0,        //binaryfunc nb_inplace_remainder
-  0,        //ternaryfunc nb_inplace_power
-  0,        //binaryfunc nb_inplace_lshift
-  0,        //binaryfunc nb_inplace_rshift
-  0,        //binaryfunc nb_inplace_and
-  0,        //binaryfunc nb_inplace_xor
-  0,        //binaryfunc nb_inplace_or
-
-  0,        //binaryfunc nb_floor_divide
-  0,        //binaryfunc nb_true_divide
-  0,        //binaryfunc nb_inplace_floor_divide
-  0,        //binaryfunc nb_inplace_true_divide
-
-  0,        //unaryfunc nb_index
-
-  0,        //binaryfunc nb_matrix_multiply
-  0         //binaryfunc nb_inplace_matrix_multiply
+  {
+    python_nb_add, //binaryfunc nb_add
+    python_nb_subtract, //binaryfunc nb_subtract
+    python_nb_mul, //binaryfunc nb_multiply
+    0, //binaryfunc nb_remainder
+    0, //binaryfunc nb_divmod
+    0, //ternaryfunc nb_power
+    0, //unaryfunc nb_negative
+    0, //unaryfunc nb_positive
+    0, //unaryfunc nb_absolute
+    0, //inquiry nb_bool
+    0, //unaryfunc nb_invert
+    0, //binaryfunc nb_lshift
+    0, //binaryfunc nb_rshift
+    python_nb_and, //binaryfunc nb_and
+    0, //binaryfunc nb_xor
+    python_nb_or, //binaryfunc nb_or
+    0, //unaryfunc nb_int
+    0, //void *nb_reserved
+    0, //unaryfunc nb_float
+
+    0, //binaryfunc nb_inplace_add
+    0, //binaryfunc nb_inplace_subtract
+    0, //binaryfunc nb_inplace_multiply
+    0, //binaryfunc nb_inplace_remainder
+    0, //ternaryfunc nb_inplace_power
+    0, //binaryfunc nb_inplace_lshift
+    0, //binaryfunc nb_inplace_rshift
+    0, //binaryfunc nb_inplace_and
+    0, //binaryfunc nb_inplace_xor
+    0, //binaryfunc nb_inplace_or
+
+    0, //binaryfunc nb_floor_divide
+    0, //binaryfunc nb_true_divide
+    0, //binaryfunc nb_inplace_floor_divide
+    0, //binaryfunc nb_inplace_true_divide
+
+    0, //unaryfunc nb_index
+
+    0, //binaryfunc nb_matrix_multiply
+    0 //binaryfunc nb_inplace_matrix_multiply
 };
 
 PyMappingMethods PyOpenSCADMapping =
-{
-  0,
-  python__getitem__,
-  python__setitem__
-};
-
+  {
+    0,
+    python__getitem__,
+    python__setitem__};
diff --git a/src/python/pymod.cc b/src/python/pymod.cc
index 57fa81458..4ad14cd6b 100644
--- a/src/python/pymod.cc
+++ b/src/python/pymod.cc
@@ -39,46 +39,43 @@ namespace fs = std::filesystem;
 
 using SP = Settings::SettingsPython;
 
-std::string venvBinDirFromSettings()
-{
-  const auto& venv = fs::path(SP::pythonVirtualEnv.value()) / "bin";
-  if (fs::is_directory(venv)) {
-    return venv.generic_string();
+std::string venvBinDirFromSettings () {
+  const auto &venv = fs::path (SP::pythonVirtualEnv.value ()) / "bin";
+  if (fs::is_directory (venv)) {
+    return venv.generic_string ();
   }
   return "";
 }
 
-int pythonRunArgs(int argc, char **argv)
-{
+int pythonRunArgs (int argc, char **argv) {
   PyStatus status;
 
   PyConfig config;
-  PyConfig_InitPythonConfig(&config);
+  PyConfig_InitPythonConfig (&config);
 
-  status = PyConfig_SetBytesArgv(&config, argc, argv);
-  if (PyStatus_Exception(status)) {
+  status = PyConfig_SetBytesArgv (&config, argc, argv);
+  if (PyStatus_Exception (status)) {
     goto fail;
   }
 
-  status = Py_InitializeFromConfig(&config);
-  if (PyStatus_Exception(status)) {
+  status = Py_InitializeFromConfig (&config);
+  if (PyStatus_Exception (status)) {
     goto fail;
   }
-  PyConfig_Clear(&config);
+  PyConfig_Clear (&config);
 
-  return Py_RunMain();
+  return Py_RunMain ();
 
 fail:
-  PyConfig_Clear(&config);
-  if (PyStatus_IsExit(status)) {
+  PyConfig_Clear (&config);
+  if (PyStatus_IsExit (status)) {
     return status.exitcode;
   }
-  Py_ExitStatusException(status);
+  Py_ExitStatusException (status);
 }
 
-int pythonCreateVenv(const std::string& path)
-{
-  int result = pythonRunModule("", "venv", { path });
+int pythonCreateVenv (const std::string &path) {
+  int result = pythonRunModule ("", "venv", {path});
   if (result != 0) {
     return result;
   }
@@ -88,22 +85,22 @@ int pythonCreateVenv(const std::string& path)
   // no good for any later runs.
   // To fix that, we point the link to the magic /proc/self/exe
   // so it can always just call itself as the python interpreter.
-  const char *appdirenv = getenv("APPDIR");
-  if (getenv("APPIMAGE") != nullptr && appdirenv != nullptr) {
+  const char *appdirenv = getenv ("APPDIR");
+  if (getenv ("APPIMAGE") != nullptr && appdirenv != nullptr) {
     // Assume we are running as AppImage
     const std::string appdir = appdirenv;
     const auto vbin = fs::path{path} / "bin" / "openscad-python";
-    if (fs::exists(vbin) && fs::is_symlink(vbin)) {
-      const auto lbin = fs::read_symlink(vbin).generic_string();
-      if (lbin.rfind(appdir, 0) == 0) {
+    if (fs::exists (vbin) && fs::is_symlink (vbin)) {
+      const auto lbin = fs::read_symlink (vbin).generic_string ();
+      if (lbin.rfind (appdir, 0) == 0) {
         std::error_code ec;
-        fs::remove(vbin, ec);
-        if (ec.value() > 0) {
-          return ec.value();
+        fs::remove (vbin, ec);
+        if (ec.value () > 0) {
+          return ec.value ();
         }
-        fs::create_symlink("/proc/self/exe", vbin, ec);
-        if (ec.value() > 0) {
-          return ec.value();
+        fs::create_symlink ("/proc/self/exe", vbin, ec);
+        if (ec.value () > 0) {
+          return ec.value ();
         }
       }
     }
@@ -112,68 +109,67 @@ int pythonCreateVenv(const std::string& path)
   return 0;
 }
 
-int pythonRunModule(const std::string& appPath, const std::string& module,
-                    const std::vector<std::string>& args)
-{
+int pythonRunModule (const std::string &appPath, const std::string &module,
+                     const std::vector<std::string> &args) {
   PyStatus status;
   const auto name = "openscad-python";
-  const auto exe = PlatformUtils::applicationPath() + "/" + name;
+  const auto exe = PlatformUtils::applicationPath () + "/" + name;
 
   PyPreConfig preconfig;
-  PyPreConfig_InitPythonConfig(&preconfig);
+  PyPreConfig_InitPythonConfig (&preconfig);
 
-  status = Py_PreInitialize(&preconfig);
-  if (PyStatus_Exception(status)) {
-    Py_ExitStatusException(status);
+  status = Py_PreInitialize (&preconfig);
+  if (PyStatus_Exception (status)) {
+    Py_ExitStatusException (status);
   }
 
   PyConfig config;
-  PyConfig_InitPythonConfig(&config);
+  PyConfig_InitPythonConfig (&config);
 
-  status = PyConfig_SetBytesString(&config, &config.program_name, name);
-  if (PyStatus_Exception(status)) {
+  status = PyConfig_SetBytesString (&config, &config.program_name, name);
+  if (PyStatus_Exception (status)) {
     goto done;
   }
 
-  status = PyConfig_SetBytesString(&config, &config.executable, exe.c_str());
-  if (PyStatus_Exception(status)) {
+  status = PyConfig_SetBytesString (&config, &config.executable, exe.c_str ());
+  if (PyStatus_Exception (status)) {
     goto done;
   }
 
-  status = PyConfig_SetBytesString(&config, &config.run_module, module.c_str());
-  if (PyStatus_Exception(status)) {
+  status = PyConfig_SetBytesString (&config, &config.run_module, module.c_str ());
+  if (PyStatus_Exception (status)) {
     goto done;
   }
 
   /* Read all configuration at once */
-  status = PyConfig_Read(&config);
-  if (PyStatus_Exception(status)) {
+  status = PyConfig_Read (&config);
+  if (PyStatus_Exception (status)) {
     goto done;
   }
 
-  for (const auto& arg : args) {
-    std::wstring warg(arg.size(), L' ');
-    warg.resize(std::mbstowcs(&warg[0], arg.c_str(), arg.size()));
-    status = PyWideStringList_Append(&config.argv, warg.c_str());
-    if (PyStatus_Exception(status)) {
+  for (const auto &arg : args) {
+    std::wstring warg (arg.size (), L' ');
+    warg.resize (std::mbstowcs (&warg[0], arg.c_str (), arg.size ()));
+    status = PyWideStringList_Append (&config.argv, warg.c_str ());
+    if (PyStatus_Exception (status)) {
       goto done;
     }
   }
 
   /* Override executable computed by PyConfig_Read() */
-  status = PyConfig_SetBytesString(&config, &config.executable, exe.c_str());
-  if (PyStatus_Exception(status)) {
+  status = PyConfig_SetBytesString (&config, &config.executable, exe.c_str ());
+  if (PyStatus_Exception (status)) {
     goto done;
   }
 
-  status = Py_InitializeFromConfig(&config);
-  if (PyStatus_Exception(status)) {
+  status = Py_InitializeFromConfig (&config);
+  if (PyStatus_Exception (status)) {
     goto done;
   }
 
-  return Py_RunMain();
+  return Py_RunMain ();
 
 done:
-  PyConfig_Clear(&config);
+  PyConfig_Clear (&config);
   return status.exitcode;
 }
diff --git a/src/python/pyopenscad.cc b/src/python/pyopenscad.cc
index 71f522efb..beabc68b2 100644
--- a/src/python/pyopenscad.cc
+++ b/src/python/pyopenscad.cc
@@ -32,40 +32,40 @@
 
 namespace fs = std::filesystem;
 
-extern "C" PyObject *PyInit_openscad(void);
+extern "C" PyObject *PyInit_openscad (void);
 
 bool python_active;
 bool python_trusted;
 
-void PyObjectDeleter(PyObject *pObject) { Py_XDECREF(pObject); }
+void PyObjectDeleter (PyObject *pObject) {
+  Py_XDECREF (pObject);
+}
 
-PyObjectUniquePtr pythonInitDict(nullptr, PyObjectDeleter);
-PyObjectUniquePtr pythonMainModule(nullptr, PyObjectDeleter);
+PyObjectUniquePtr pythonInitDict (nullptr, PyObjectDeleter);
+PyObjectUniquePtr pythonMainModule (nullptr, PyObjectDeleter);
 std::list<std::string> pythonInventory;
 bool pythonDryRun = false;
 std::shared_ptr<AbstractNode> python_result_node = nullptr; /* global result veriable containing the python created result */
 PyObject *python_result_obj = nullptr;
 bool pythonMainModuleInitialized = false;
 
-void PyOpenSCADObject_dealloc(PyOpenSCADObject *self)
-{
-  Py_XDECREF(self->dict);
-  Py_TYPE(self)->tp_free((PyObject *)self);
+void PyOpenSCADObject_dealloc (PyOpenSCADObject *self) {
+  Py_XDECREF (self->dict);
+  Py_TYPE (self)->tp_free ((PyObject *)self);
 }
 
-PyObject *PyOpenSCADObject_alloc(PyTypeObject *cls, Py_ssize_t nitems)
-{
-  PyObject *self = PyType_GenericAlloc(cls, nitems);
-  ((PyOpenSCADObject *)self)->dict = PyDict_New();
-  PyObject *origin = PyList_New(4);
+PyObject *PyOpenSCADObject_alloc (PyTypeObject *cls, Py_ssize_t nitems) {
+  PyObject *self = PyType_GenericAlloc (cls, nitems);
+  ((PyOpenSCADObject *)self)->dict = PyDict_New ();
+  PyObject *origin = PyList_New (4);
   for (int i = 0; i < 4; i++) {
-    PyObject *row = PyList_New(4);
+    PyObject *row = PyList_New (4);
     for (int j = 0; j < 4; j++)
-      PyList_SetItem(row, j, PyFloat_FromDouble(i == j?1.0:0.0));
-    PyList_SetItem(origin, i, row);
+      PyList_SetItem (row, j, PyFloat_FromDouble (i == j ? 1.0 : 0.0));
+    PyList_SetItem (origin, i, row);
   }
-  PyDict_SetItemString(((PyOpenSCADObject *)self)->dict, "origin", origin);
-  Py_XDECREF(origin);
+  PyDict_SetItemString (((PyOpenSCADObject *)self)->dict, "origin", origin);
+  Py_XDECREF (origin);
   return self;
 }
 
@@ -73,21 +73,19 @@ PyObject *PyOpenSCADObject_alloc(PyTypeObject *cls, Py_ssize_t nitems)
  *  allocates a new PyOpenSCAD Object including its internal dictionary
  */
 
-static PyObject *PyOpenSCADObject_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
-{
-  return PyOpenSCADObject_alloc(&PyOpenSCADType, 0);
+static PyObject *PyOpenSCADObject_new (PyTypeObject *type, PyObject *args, PyObject *kwds) {
+  return PyOpenSCADObject_alloc (&PyOpenSCADType, 0);
 }
 
 /*
  *  allocates a new PyOpenSCAD to store an existing OpenSCAD Abstract Node
  */
 
-PyObject *PyOpenSCADObjectFromNode(PyTypeObject *type, const std::shared_ptr<AbstractNode>& node)
-{
+PyObject *PyOpenSCADObjectFromNode (PyTypeObject *type, const std::shared_ptr<AbstractNode> &node) {
   PyOpenSCADObject *self;
-  self = (PyOpenSCADObject *)  type->tp_alloc(type, 0);
+  self = (PyOpenSCADObject *)type->tp_alloc (type, 0);
   if (self != nullptr) {
-    Py_XINCREF(self);
+    Py_XINCREF (self);
     self->node = node;
     return (PyObject *)self;
   }
@@ -96,77 +94,80 @@ PyObject *PyOpenSCADObjectFromNode(PyTypeObject *type, const std::shared_ptr<Abs
 
 PyThreadState *tstate = nullptr;
 
-void python_lock(void){
-  if (tstate != nullptr && pythonInitDict != nullptr)PyEval_RestoreThread(tstate);
+void python_lock (void) {
+  if (tstate != nullptr && pythonInitDict != nullptr)
+    PyEval_RestoreThread (tstate);
 }
 
-void python_unlock(void) {
-  if (pythonInitDict != nullptr)tstate = PyEval_SaveThread();
+void python_unlock (void) {
+  if (pythonInitDict != nullptr)
+    tstate = PyEval_SaveThread ();
 }
 /*
  *  extracts Absrtract Node from PyOpenSCAD Object
  */
 
-std::shared_ptr<AbstractNode> PyOpenSCADObjectToNode(PyObject *obj, PyObject **dict)
-{
-  std::shared_ptr<AbstractNode> result = ((PyOpenSCADObject *) obj)->node;
-  if (result.use_count() > 2) {
-    result = result->clone();
+std::shared_ptr<AbstractNode> PyOpenSCADObjectToNode (PyObject *obj, PyObject **dict) {
+  std::shared_ptr<AbstractNode> result = ((PyOpenSCADObject *)obj)->node;
+  if (result.use_count () > 2) {
+    result = result->clone ();
   }
-  *dict = ((PyOpenSCADObject *) obj)->dict;
+  *dict = ((PyOpenSCADObject *)obj)->dict;
   return result;
 }
 
-std::string python_version(void)
-{
+std::string python_version (void) {
   std::ostringstream stream;
   stream << "Python " << PY_MAJOR_VERSION << "." << PY_MINOR_VERSION << "." << PY_MICRO_VERSION;
-  return stream.str();
+  return stream.str ();
 }
 
 /*
  * same as  python_more_obj but always returns only one AbstractNode by creating an UNION operation
  */
 
-std::shared_ptr<AbstractNode> PyOpenSCADObjectToNodeMulti(PyObject *objs, PyObject **dict)
-{
+std::shared_ptr<AbstractNode> PyOpenSCADObjectToNodeMulti (PyObject *objs, PyObject **dict) {
   std::shared_ptr<AbstractNode> result;
-  if (Py_TYPE(objs) == &PyOpenSCADType) {
-    result = ((PyOpenSCADObject *) objs)->node;
-    if (result.use_count() > 2) {
-      result = result->clone();
+  if (Py_TYPE (objs) == &PyOpenSCADType) {
+    result = ((PyOpenSCADObject *)objs)->node;
+    if (result.use_count () > 2) {
+      result = result->clone ();
     }
-    *dict = ((PyOpenSCADObject *) objs)->dict;
-  } else if (PyList_Check(objs)) {
+    *dict = ((PyOpenSCADObject *)objs)->dict;
+  } else if (PyList_Check (objs)) {
     DECLARE_INSTANCE
-    auto node = std::make_shared<CsgOpNode>(instance, OpenSCADOperator::UNION);
+    auto node = std::make_shared<CsgOpNode> (instance, OpenSCADOperator::UNION);
 
-    int n = PyList_Size(objs);
+    int n = PyList_Size (objs);
     for (int i = 0; i < n; i++) {
-      PyObject *obj = PyList_GetItem(objs, i);
-      if (Py_TYPE(obj) == &PyOpenSCADType) {
-        std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNode(obj, dict);
-        node->children.push_back(child);
-      } else return nullptr;
+      PyObject *obj = PyList_GetItem (objs, i);
+      if (Py_TYPE (obj) == &PyOpenSCADType) {
+        std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNode (obj, dict);
+        node->children.push_back (child);
+      } else
+        return nullptr;
     }
     result = node;
-  } else result = nullptr;
+  } else
+    result = nullptr;
   return result;
 }
 
-
-int python_numberval(PyObject *number, double *result)
-{
-  if (number == nullptr)return 1;
-  if (number == Py_False)return 1;
-  if (number == Py_True)return 1;
-  if (number == Py_None)return 1;
-  if (PyFloat_Check(number)) {
-    *result = PyFloat_AsDouble(number);
+int python_numberval (PyObject *number, double *result) {
+  if (number == nullptr)
+    return 1;
+  if (number == Py_False)
+    return 1;
+  if (number == Py_True)
+    return 1;
+  if (number == Py_None)
+    return 1;
+  if (PyFloat_Check (number)) {
+    *result = PyFloat_AsDouble (number);
     return 0;
   }
-  if (PyLong_Check(number)) {
-    *result = PyLong_AsLong(number);
+  if (PyLong_Check (number)) {
+    *result = PyLong_AsLong (number);
     return 0;
   }
   return 1;
@@ -176,75 +177,83 @@ int python_numberval(PyObject *number, double *result)
  * Tries to extract an 3D vector out of a python list
  */
 
-int python_vectorval(PyObject *vec, int minval, int maxval, double *x, double *y, double *z, double *w)
-{
-  if (w != NULL) *w = 0;
-  if (PyList_Check(vec)) {
-    if (PyList_Size(vec) < minval || PyList_Size(vec) > maxval)return 1;
+int python_vectorval (PyObject *vec, int minval, int maxval, double *x, double *y, double *z, double *w) {
+  if (w != NULL)
+    *w = 0;
+  if (PyList_Check (vec)) {
+    if (PyList_Size (vec) < minval || PyList_Size (vec) > maxval)
+      return 1;
 
-    if (PyList_Size(vec) >= 1) {
-      if (python_numberval(PyList_GetItem(vec, 0), x)) return 1;
+    if (PyList_Size (vec) >= 1) {
+      if (python_numberval (PyList_GetItem (vec, 0), x))
+        return 1;
     }
-    if (PyList_Size(vec) >= 2) {
-      if (python_numberval(PyList_GetItem(vec, 1), y)) return 1;
+    if (PyList_Size (vec) >= 2) {
+      if (python_numberval (PyList_GetItem (vec, 1), y))
+        return 1;
     }
-    if (PyList_Size(vec) >= 3) {
-      if (python_numberval(PyList_GetItem(vec, 2), z)) return 1;
+    if (PyList_Size (vec) >= 3) {
+      if (python_numberval (PyList_GetItem (vec, 2), z))
+        return 1;
     }
-    if (PyList_Size(vec) >= 4 && w != NULL) {
-      if (python_numberval(PyList_GetItem(vec, 3), w)) return 1;
+    if (PyList_Size (vec) >= 4 && w != NULL) {
+      if (python_numberval (PyList_GetItem (vec, 3), w))
+        return 1;
     }
     return 0;
   }
-  if (!python_numberval(vec, x)) {
+  if (!python_numberval (vec, x)) {
     *y = *x;
     *z = *x;
-    if (w != NULL)*w = *x;
+    if (w != NULL)
+      *w = *x;
     return 0;
   }
   return 1;
 }
 
-std::vector<Vector3d> python_vectors(PyObject *vec, int mindim, int maxdim)
-{
+std::vector<Vector3d> python_vectors (PyObject *vec, int mindim, int maxdim) {
   std::vector<Vector3d> results;
-  if (PyList_Check(vec)) {
+  if (PyList_Check (vec)) {
     // check if its a valid vec<Vector3d>
     int valid = 1;
-    for (int i = 0; valid && i < PyList_Size(vec); i++) {
-      PyObject *item = PyList_GetItem(vec, i);
-      if (!PyList_Check(item))valid = 0;
+    for (int i = 0; valid && i < PyList_Size (vec); i++) {
+      PyObject *item = PyList_GetItem (vec, i);
+      if (!PyList_Check (item))
+        valid = 0;
     }
     if (valid) {
-      for (int j = 0; valid && j < PyList_Size(vec); j++) {
-        Vector3d result(0, 0, 0);
-        PyObject *item = PyList_GetItem(vec, j);
-        if (PyList_Size(item) >= mindim && PyList_Size(item) <= maxdim) {
-          for (int i = 0; i < PyList_Size(item); i++) {
-            if (PyList_Size(item) > i) {
-              if (python_numberval(PyList_GetItem(item, i), &result[i])) return results; // Error
+      for (int j = 0; valid && j < PyList_Size (vec); j++) {
+        Vector3d result (0, 0, 0);
+        PyObject *item = PyList_GetItem (vec, j);
+        if (PyList_Size (item) >= mindim && PyList_Size (item) <= maxdim) {
+          for (int i = 0; i < PyList_Size (item); i++) {
+            if (PyList_Size (item) > i) {
+              if (python_numberval (PyList_GetItem (item, i), &result[i]))
+                return results; // Error
             }
           }
         }
-        results.push_back(result);
+        results.push_back (result);
       }
       return results;
     }
-    Vector3d result(0, 0, 0);
-    if (PyList_Size(vec) >= mindim && PyList_Size(vec) <= maxdim) {
-      for (int i = 0; i < PyList_Size(vec); i++) {
-        if (PyList_Size(vec) > i) {
-          if (python_numberval(PyList_GetItem(vec, i), &result[i])) return results; // Error
+    Vector3d result (0, 0, 0);
+    if (PyList_Size (vec) >= mindim && PyList_Size (vec) <= maxdim) {
+      for (int i = 0; i < PyList_Size (vec); i++) {
+        if (PyList_Size (vec) > i) {
+          if (python_numberval (PyList_GetItem (vec, i), &result[i]))
+            return results; // Error
         }
       }
     }
-    results.push_back(result);
+    results.push_back (result);
   }
-  Vector3d result(0, 0, 0);
-  if (!python_numberval(vec, &result[0])) {
+  Vector3d result (0, 0, 0);
+  if (!python_numberval (vec, &result[0])) {
     result[1] = result[0];
     result[2] = result[1];
-    results.push_back(result);
+    results.push_back (result);
   }
   return results; // Error
 }
@@ -253,31 +262,32 @@ std::vector<Vector3d> python_vectors(PyObject *vec, int mindim, int maxdim)
  * Helper function to extract actual values for fn, fa and fs
  */
 
-void get_fnas(double& fn, double& fa, double& fs) {
-  PyObject *mainModule = PyImport_AddModule("__main__");
-  if (mainModule == nullptr) return;
+void get_fnas (double &fn, double &fa, double &fs) {
+  PyObject *mainModule = PyImport_AddModule ("__main__");
+  if (mainModule == nullptr)
+    return;
   fn = 0;
   fa = 12;
   fs = 2;
 
-  if (PyObject_HasAttrString(mainModule, "fn")) {
-    PyObjectUniquePtr varFn(PyObject_GetAttrString(mainModule, "fn"), PyObjectDeleter);
-    if (varFn.get() != nullptr){
-      fn = PyFloat_AsDouble(varFn.get());
+  if (PyObject_HasAttrString (mainModule, "fn")) {
+    PyObjectUniquePtr varFn (PyObject_GetAttrString (mainModule, "fn"), PyObjectDeleter);
+    if (varFn.get () != nullptr) {
+      fn = PyFloat_AsDouble (varFn.get ());
     }
   }
 
-  if (PyObject_HasAttrString(mainModule, "fa")) {
-    PyObjectUniquePtr varFa(PyObject_GetAttrString(mainModule, "fa"), PyObjectDeleter);
-    if (varFa.get() != nullptr){
-      fa = PyFloat_AsDouble(varFa.get());
+  if (PyObject_HasAttrString (mainModule, "fa")) {
+    PyObjectUniquePtr varFa (PyObject_GetAttrString (mainModule, "fa"), PyObjectDeleter);
+    if (varFa.get () != nullptr) {
+      fa = PyFloat_AsDouble (varFa.get ());
     }
   }
 
-  PyObjectUniquePtr varFs(PyObject_GetAttrString(mainModule, "fs"), PyObjectDeleter);
-  if (PyObject_HasAttrString(mainModule, "fs")) {
-    if (varFs.get() != nullptr){
-      fs = PyFloat_AsDouble(varFs.get());
+  PyObjectUniquePtr varFs (PyObject_GetAttrString (mainModule, "fs"), PyObjectDeleter);
+  if (PyObject_HasAttrString (mainModule, "fs")) {
+    if (varFs.get () != nullptr) {
+      fs = PyFloat_AsDouble (varFs.get ());
     }
   }
 }
@@ -286,91 +296,103 @@ void get_fnas(double& fn, double& fa, double& fs) {
  * Type specific init function. nothing special here
  */
 
-static int PyOpenSCADInit(PyOpenSCADObject *self, PyObject *args, PyObject *kwds)
-{
+static int PyOpenSCADInit (PyOpenSCADObject *self, PyObject *args, PyObject *kwds) {
   (void)self;
   (void)args;
   (void)kwds;
   return 0;
 }
 
-void python_catch_error(std::string& errorstr)
-{
+void python_catch_error (std::string &errorstr) {
   PyObject *pyExcType;
   PyObject *pyExcValue;
   PyObject *pyExcTraceback;
-  PyErr_Fetch(&pyExcType, &pyExcValue, &pyExcTraceback);
-  PyErr_NormalizeException(&pyExcType, &pyExcValue, &pyExcTraceback);
-  if (pyExcType != nullptr) Py_XDECREF(pyExcType);
-
-  if (pyExcValue != nullptr){
-    PyObjectUniquePtr str_exc_value(PyObject_Repr(pyExcValue), PyObjectDeleter);
-    PyObjectUniquePtr pyExcValueStr(PyUnicode_AsEncodedString(str_exc_value.get(), "utf-8", "~"), PyObjectDeleter);
-    char *suberror = PyBytes_AS_STRING(pyExcValueStr.get());
-    if (suberror != nullptr) errorstr += suberror;
-    Py_XDECREF(pyExcValue);
+  PyErr_Fetch (&pyExcType, &pyExcValue, &pyExcTraceback);
+  PyErr_NormalizeException (&pyExcType, &pyExcValue, &pyExcTraceback);
+  if (pyExcType != nullptr)
+    Py_XDECREF (pyExcType);
+
+  if (pyExcValue != nullptr) {
+    PyObjectUniquePtr str_exc_value (PyObject_Repr (pyExcValue), PyObjectDeleter);
+    PyObjectUniquePtr pyExcValueStr (PyUnicode_AsEncodedString (str_exc_value.get (), "utf-8", "~"), PyObjectDeleter);
+    char *suberror = PyBytes_AS_STRING (pyExcValueStr.get ());
+    if (suberror != nullptr)
+      errorstr += suberror;
+    Py_XDECREF (pyExcValue);
   }
   if (pyExcTraceback != nullptr) {
     auto *tb_o = (PyTracebackObject *)pyExcTraceback;
     int line_num = tb_o->tb_lineno;
     errorstr += " in line ";
-    errorstr += std::to_string(line_num);
-    Py_XDECREF(pyExcTraceback);
+    errorstr += std::to_string (line_num);
+    Py_XDECREF (pyExcTraceback);
   }
 }
 
-void initPython(const std::string& binDir, double time)
-{
+void initPython (const std::string &binDir, double time) {
   const auto name = "openscad-python";
   const auto exe = binDir + "/" + name;
   if (pythonInitDict) { /* If already initialized, undo to reinitialize after */
     PyObject *key, *value;
     Py_ssize_t pos = 0;
-    PyObject *maindict = PyModule_GetDict(pythonMainModule.get());
-    while (PyDict_Next(maindict, &pos, &key, &value)) {
-      PyObjectUniquePtr key_(PyUnicode_AsEncodedString(key, "utf-8", "~"), PyObjectDeleter);
-      if (key_ == nullptr)continue;
-      const char *key_str = PyBytes_AS_STRING(key_.get());
-      if (key_str == nullptr)continue;
-      if (std::find(std::begin(pythonInventory), std::end(pythonInventory), key_str) == std::end(pythonInventory)){
-        if (strlen(key_str) < 4 || strncmp(key_str, "stat", 4) != 0){
-          PyDict_DelItemString(maindict, key_str);
+    PyObject *maindict = PyModule_GetDict (pythonMainModule.get ());
+    while (PyDict_Next (maindict, &pos, &key, &value)) {
+      PyObjectUniquePtr key_ (PyUnicode_AsEncodedString (key, "utf-8", "~"), PyObjectDeleter);
+      if (key_ == nullptr)
+        continue;
+      const char *key_str = PyBytes_AS_STRING (key_.get ());
+      if (key_str == nullptr)
+        continue;
+      if (std::find (std::begin (pythonInventory), std::end (pythonInventory), key_str) == std::end (pythonInventory)) {
+        if (strlen (key_str) < 4 || strncmp (key_str, "stat", 4) != 0) {
+          PyDict_DelItemString (maindict, key_str);
         }
       }
       // bug in  PyDict_GetItemString, thus iterating
-      if (strcmp(key_str, "sys") == 0) {
-        PyObject *sysdict = PyModule_GetDict(value);
-        if (sysdict == nullptr) continue;
+      if (strcmp (key_str, "sys") == 0) {
+        PyObject *sysdict = PyModule_GetDict (value);
+        if (sysdict == nullptr)
+          continue;
         // get builtin_module_names
         PyObject *key1, *value1;
         Py_ssize_t pos1 = 0;
-        while (PyDict_Next(sysdict, &pos1, &key1, &value1)) {
-          PyObjectUniquePtr key1_(PyUnicode_AsEncodedString(key1, "utf-8", "~"), PyObjectDeleter);
-          if (key1_ == nullptr)continue;
-          const char *key1_str = PyBytes_AS_STRING(key1_.get());
-          if (strcmp(key1_str, "modules") == 0) {
+        while (PyDict_Next (sysdict, &pos1, &key1, &value1)) {
+          PyObjectUniquePtr key1_ (PyUnicode_AsEncodedString (key1, "utf-8", "~"), PyObjectDeleter);
+          if (key1_ == nullptr)
+            continue;
+          const char *key1_str = PyBytes_AS_STRING (key1_.get ());
+          if (strcmp (key1_str, "modules") == 0) {
             PyObject *key2, *value2;
             Py_ssize_t pos2 = 0;
-            while (PyDict_Next(value1, &pos2, &key2, &value2)) {
-              PyObjectUniquePtr key2_(PyUnicode_AsEncodedString(key2, "utf-8", "~"), PyObjectDeleter);
-              if (key2_ == nullptr)continue;
-              const char *key2_str = PyBytes_AS_STRING(key2_.get());
-              if (key2_str == nullptr) continue;
-              if (!PyModule_Check(value2)) continue;
-
-              PyObject *modrepr = PyObject_Repr(value2);
-              PyObject *modreprobj = PyUnicode_AsEncodedString(modrepr, "utf-8", "~");
-              const char *modreprstr = PyBytes_AS_STRING(modreprobj);
-              if (modreprstr == nullptr) continue;
-              if (strstr(modreprstr, "(frozen)") != nullptr) continue;
-              if (strstr(modreprstr, "(built-in)") != nullptr) continue;
-              if (strstr(modreprstr, "/encodings/") != nullptr) continue;
-              if (strstr(modreprstr, "_frozen_") != nullptr) continue;
-              if (strstr(modreprstr, "site-packages") != nullptr) continue;
-              if (strstr(modreprstr, "usr/lib") != nullptr) continue;
-
-              PyDict_DelItem(value1, key2);
-
+            while (PyDict_Next (value1, &pos2, &key2, &value2)) {
+              PyObjectUniquePtr key2_ (PyUnicode_AsEncodedString (key2, "utf-8", "~"), PyObjectDeleter);
+              if (key2_ == nullptr)
+                continue;
+              const char *key2_str = PyBytes_AS_STRING (key2_.get ());
+              if (key2_str == nullptr)
+                continue;
+              if (!PyModule_Check (value2))
+                continue;
+
+              PyObject *modrepr = PyObject_Repr (value2);
+              PyObject *modreprobj = PyUnicode_AsEncodedString (modrepr, "utf-8", "~");
+              const char *modreprstr = PyBytes_AS_STRING (modreprobj);
+              if (modreprstr == nullptr)
+                continue;
+              if (strstr (modreprstr, "(frozen)") != nullptr)
+                continue;
+              if (strstr (modreprstr, "(built-in)") != nullptr)
+                continue;
+              if (strstr (modreprstr, "/encodings/") != nullptr)
+                continue;
+              if (strstr (modreprstr, "_frozen_") != nullptr)
+                continue;
+              if (strstr (modreprstr, "site-packages") != nullptr)
+                continue;
+              if (strstr (modreprstr, "usr/lib") != nullptr)
+                continue;
+
+              PyDict_DelItem (value1, key2);
             }
           }
         }
@@ -378,23 +400,23 @@ void initPython(const std::string& binDir, double time)
     }
   } else {
     PyPreConfig preconfig;
-    PyPreConfig_InitPythonConfig(&preconfig);
-    Py_PreInitialize(&preconfig);
-//    PyEval_InitThreads(); // https://stackoverflow.com/questions/47167251/pygilstate-ensure-causing-deadlock
+    PyPreConfig_InitPythonConfig (&preconfig);
+    Py_PreInitialize (&preconfig);
+    //    PyEval_InitThreads(); // https://stackoverflow.com/questions/47167251/pygilstate-ensure-causing-deadlock
 
-    PyImport_AppendInittab("openscad", &PyInit_openscad);
+    PyImport_AppendInittab ("openscad", &PyInit_openscad);
     PyConfig config;
-    PyConfig_InitPythonConfig(&config);
+    PyConfig_InitPythonConfig (&config);
 
     std::string sep = "";
     std::ostringstream stream;
 #ifdef _WIN32
     char sepchar = ':';
     sep = sepchar;
-    stream << PlatformUtils::applicationPath() << "\\..\\libraries\\python";
+    stream << PlatformUtils::applicationPath () << "\\..\\libraries\\python";
 #else
     char sepchar = ':';
-    const auto pythonXY = "python" + std::to_string(PY_MAJOR_VERSION) + "." + std::to_string(PY_MINOR_VERSION);
+    const auto pythonXY = "python" + std::to_string (PY_MAJOR_VERSION) + "." + std::to_string (PY_MINOR_VERSION);
     const std::array<std::string, 5> paths = {
       "../libraries/python",
       "../lib/" + pythonXY,
@@ -402,61 +424,61 @@ void initPython(const std::string& binDir, double time)
       "../Frameworks/" + pythonXY,
       "../Frameworks/" + pythonXY + "/site-packages",
     };
-    for (const auto& path : paths) {
-      const auto p = fs::path(PlatformUtils::applicationPath() + fs::path::preferred_separator + path);
-      if (fs::is_directory(p)) {
-        stream << sep << fs::absolute(p).generic_string();
+    for (const auto &path : paths) {
+      const auto p = fs::path (PlatformUtils::applicationPath () + fs::path::preferred_separator + path);
+      if (fs::is_directory (p)) {
+        stream << sep << fs::absolute (p).generic_string ();
         sep = sepchar;
       }
     }
 #endif // ifdef _WIN32
-    stream << sep << PlatformUtils::userLibraryPath();
+    stream << sep << PlatformUtils::userLibraryPath ();
     stream << sepchar << ".";
 
-    PyConfig_SetBytesString(&config, &config.program_name, name);
-    PyConfig_SetBytesString(&config, &config.executable, exe.c_str());
+    PyConfig_SetBytesString (&config, &config.program_name, name);
+    PyConfig_SetBytesString (&config, &config.executable, exe.c_str ());
 
-    PyStatus status = Py_InitializeFromConfig(&config);
-    if (PyStatus_Exception(status)) {
-      LOG(message_group::Error, "Python not found. Is it installed ?");
+    PyStatus status = Py_InitializeFromConfig (&config);
+    if (PyStatus_Exception (status)) {
+      LOG (message_group::Error, "Python not found. Is it installed ?");
       return;
     }
-    PyConfig_Clear(&config);
+    PyConfig_Clear (&config);
 
-    pythonMainModule.reset(PyImport_AddModule("__main__"));
+    pythonMainModule.reset (PyImport_AddModule ("__main__"));
     pythonMainModuleInitialized = pythonMainModule != nullptr;
-    pythonInitDict.reset(PyModule_GetDict(pythonMainModule.get()));
-    PyInit_PyOpenSCAD();
-    PyRun_String("from builtins import *\n", Py_file_input, pythonInitDict.get(), pythonInitDict.get());
+    pythonInitDict.reset (PyModule_GetDict (pythonMainModule.get ()));
+    PyInit_PyOpenSCAD ();
+    PyRun_String ("from builtins import *\n", Py_file_input, pythonInitDict.get (), pythonInitDict.get ());
     PyObject *key, *value;
     Py_ssize_t pos = 0;
-    PyObject *maindict = PyModule_GetDict(pythonMainModule.get());
-    while (PyDict_Next(maindict, &pos, &key, &value)) {
-      PyObjectUniquePtr key1(PyUnicode_AsEncodedString(key, "utf-8", "~"), PyObjectDeleter);
-      const char *key_str = PyBytes_AsString(key1.get());
-      if (key_str != NULL)pythonInventory.push_back(key_str);
+    PyObject *maindict = PyModule_GetDict (pythonMainModule.get ());
+    while (PyDict_Next (maindict, &pos, &key, &value)) {
+      PyObjectUniquePtr key1 (PyUnicode_AsEncodedString (key, "utf-8", "~"), PyObjectDeleter);
+      const char *key_str = PyBytes_AsString (key1.get ());
+      if (key_str != NULL)
+        pythonInventory.push_back (key_str);
     }
-
   }
   std::ostringstream stream;
   stream << "t=" << time;
-  PyRun_String(stream.str().c_str(), Py_file_input, pythonInitDict.get(), pythonInitDict.get());
+  PyRun_String (stream.str ().c_str (), Py_file_input, pythonInitDict.get (), pythonInitDict.get ());
 }
 
-void finishPython(void)
-{
+void finishPython (void) {
 }
 
-std::string evaluatePython(const std::string& code, bool dry_run)
-{
+std::string evaluatePython (const std::string &code, bool dry_run) {
   std::string error;
   python_result_node = nullptr;
-  PyObjectUniquePtr pyExcValue(nullptr, PyObjectDeleter);
-  PyObjectUniquePtr pyExcTraceback(nullptr, PyObjectDeleter);
+  PyObjectUniquePtr pyExcValue (nullptr, PyObjectDeleter);
+  PyObjectUniquePtr pyExcTraceback (nullptr, PyObjectDeleter);
   /* special python code to catch errors from stdout and stderr and make them available in OpenSCAD console */
   pythonDryRun = dry_run;
-  if (!pythonMainModuleInitialized)return "Python not initialized";
-  const char *python_init_code = "\
+  if (!pythonMainModuleInitialized)
+    return "Python not initialized";
+  const char *python_init_code =
+    "\
 import sys\n\
 class InputCatcher:\n\
    def __init__(self):\n\
@@ -484,128 +506,124 @@ sys.stdin = catcher_in\n\
 sys.stdout = catcher_out\n\
 sys.stderr = catcher_err\n\
 ";
-  const char *python_exit_code = "\
+  const char *python_exit_code =
+    "\
 sys.stdin = stdin_bak\n\
 sys.stdout = stdout_bak\n\
 sys.stderr = stderr_bak\n\
 ";
 
-  PyRun_SimpleString(python_init_code);
-  PyObjectUniquePtr result(nullptr, PyObjectDeleter);
-  result.reset(PyRun_String(code.c_str(), Py_file_input, pythonInitDict.get(), pythonInitDict.get()));   /* actual code is run here */
-
+  PyRun_SimpleString (python_init_code);
+  PyObjectUniquePtr result (nullptr, PyObjectDeleter);
+  result.reset (PyRun_String (code.c_str (), Py_file_input, pythonInitDict.get (), pythonInitDict.get ())); /* actual code is run here */
 
   if (result == nullptr) {
-    PyErr_Print();
+    PyErr_Print ();
     error = "";
-    python_catch_error(error);
+    python_catch_error (error);
   }
-  for (int i = 0; i < 2; i++){
-    PyObjectUniquePtr catcher(nullptr, PyObjectDeleter);
-    catcher.reset(PyObject_GetAttrString(pythonMainModule.get(), i == 1?"catcher_err":"catcher_out"));
-    if (catcher == nullptr) continue;
-    PyObjectUniquePtr command_output(nullptr, PyObjectDeleter);
-    command_output.reset(PyObject_GetAttrString(catcher.get(), "data"));
-
-    PyObjectUniquePtr command_output_value(nullptr,  PyObjectDeleter);
-    command_output_value.reset(PyUnicode_AsEncodedString(command_output.get(), "utf-8", "~"));
-    const char *command_output_bytes = PyBytes_AS_STRING(command_output_value.get());
-    if (command_output_bytes != nullptr && *command_output_bytes != '\0'){
-      if (i == 1) error += command_output_bytes; /* output to console */
-      else LOG(command_output_bytes);   /* error to LOG */
+  for (int i = 0; i < 2; i++) {
+    PyObjectUniquePtr catcher (nullptr, PyObjectDeleter);
+    catcher.reset (PyObject_GetAttrString (pythonMainModule.get (), i == 1 ? "catcher_err" : "catcher_out"));
+    if (catcher == nullptr)
+      continue;
+    PyObjectUniquePtr command_output (nullptr, PyObjectDeleter);
+    command_output.reset (PyObject_GetAttrString (catcher.get (), "data"));
+
+    PyObjectUniquePtr command_output_value (nullptr, PyObjectDeleter);
+    command_output_value.reset (PyUnicode_AsEncodedString (command_output.get (), "utf-8", "~"));
+    const char *command_output_bytes = PyBytes_AS_STRING (command_output_value.get ());
+    if (command_output_bytes != nullptr && *command_output_bytes != '\0') {
+      if (i == 1)
+        error += command_output_bytes; /* output to console */
+      else
+        LOG (command_output_bytes); /* error to LOG */
     }
   }
-  PyRun_SimpleString(python_exit_code);
+  PyRun_SimpleString (python_exit_code);
   return error;
 }
 /*
  * the magical Python Type descriptor for an OpenSCAD Object. Adding more fields makes the type more powerful
  */
 
+int python__setitem__ (PyObject *dict, PyObject *key, PyObject *v);
+PyObject *python__getitem__ (PyObject *dict, PyObject *key);
 
-int python__setitem__(PyObject *dict, PyObject *key, PyObject *v);
-PyObject *python__getitem__(PyObject *dict, PyObject *key);
-
-PyObject *python__getattro__(PyObject *dict, PyObject *key)
-{
-  PyObject *result = python__getitem__(dict, key);
-  if (result == Py_None || result == nullptr) result = PyObject_GenericGetAttr(dict, key);
+PyObject *python__getattro__ (PyObject *dict, PyObject *key) {
+  PyObject *result = python__getitem__ (dict, key);
+  if (result == Py_None || result == nullptr)
+    result = PyObject_GenericGetAttr (dict, key);
   return result;
 }
 
-int python__setattro__(PyObject *dict, PyObject *key, PyObject *v)
-{
-  return python__setitem__(dict, key, v);
+int python__setattro__ (PyObject *dict, PyObject *key, PyObject *v) {
+  return python__setitem__ (dict, key, v);
 }
 
-
 PyTypeObject PyOpenSCADType = {
-  PyVarObject_HEAD_INIT(nullptr, 0)
-  "PyOpenSCAD",                     /* tp_name */
-  sizeof(PyOpenSCADObject),         /* tp_basicsize */
-  0,                                /* tp_itemsize */
-  (destructor) PyOpenSCADObject_dealloc,    /* tp_dealloc */
-  0,                                /* vectorcall_offset */
-  0,                                /* tp_getattr */
-  0,                                /* tp_setattr */
-  0,                                /* tp_as_async */
-  python_str,                       /* tp_repr */
-  &PyOpenSCADNumbers,               /* tp_as_number */
-  0,                                /* tp_as_sequence */
-  &PyOpenSCADMapping,               /* tp_as_mapping */
-  0,                                /* tp_hash  */
-  0,                                /* tp_call */
-  python_str,                       /* tp_str */
-  python__getattro__,             /* tp_getattro */
-  python__setattro__,         /* tp_setattro */
-  0,                                /* tp_as_buffer */
-  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
-  "PyOpenSCAD Object",                /* tp_doc */
-  0,                                /* tp_traverse */
-  0,                                /* tp_clear */
-  0,                                /* tp_richcompare */
-  0,                                /* tp_weaklistoffset */
-  0,                                /* tp_iter */
-  0,                                /* tp_iternext */
-  PyOpenSCADMethods,                  /* tp_methods */
-  0,                      /* tp_members */
-  0,                                /* tp_getset */
-  0,                                /* tp_base */
-  0,                                /* tp_dict */
-  0,                                /* tp_descr_get */
-  0,                                /* tp_descr_set */
-  0,                                /* tp_dictoffset */
-  (initproc) PyOpenSCADInit,            /* tp_init */
-  PyOpenSCADObject_alloc,           /* tp_alloc */
-  PyOpenSCADObject_new,                   /* tp_new */
+  PyVarObject_HEAD_INIT (nullptr, 0) "PyOpenSCAD", /* tp_name */
+  sizeof (PyOpenSCADObject), /* tp_basicsize */
+  0, /* tp_itemsize */
+  (destructor)PyOpenSCADObject_dealloc, /* tp_dealloc */
+  0, /* vectorcall_offset */
+  0, /* tp_getattr */
+  0, /* tp_setattr */
+  0, /* tp_as_async */
+  python_str, /* tp_repr */
+  &PyOpenSCADNumbers, /* tp_as_number */
+  0, /* tp_as_sequence */
+  &PyOpenSCADMapping, /* tp_as_mapping */
+  0, /* tp_hash  */
+  0, /* tp_call */
+  python_str, /* tp_str */
+  python__getattro__, /* tp_getattro */
+  python__setattro__, /* tp_setattro */
+  0, /* tp_as_buffer */
+  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */
+  "PyOpenSCAD Object", /* tp_doc */
+  0, /* tp_traverse */
+  0, /* tp_clear */
+  0, /* tp_richcompare */
+  0, /* tp_weaklistoffset */
+  0, /* tp_iter */
+  0, /* tp_iternext */
+  PyOpenSCADMethods, /* tp_methods */
+  0, /* tp_members */
+  0, /* tp_getset */
+  0, /* tp_base */
+  0, /* tp_dict */
+  0, /* tp_descr_get */
+  0, /* tp_descr_set */
+  0, /* tp_dictoffset */
+  (initproc)PyOpenSCADInit, /* tp_init */
+  PyOpenSCADObject_alloc, /* tp_alloc */
+  PyOpenSCADObject_new, /* tp_new */
 };
 
-
-
 static PyModuleDef OpenSCADModule = {
   PyModuleDef_HEAD_INIT,
   "openscad",
   "OpenSCAD Python Module",
   -1,
   PyOpenSCADFunctions,
-  NULL, NULL, NULL, NULL
-};
+  NULL, NULL, NULL, NULL};
 
-extern "C" PyObject *PyInit_openscad(void)
-{
-  return PyModule_Create(&OpenSCADModule);
+extern "C" PyObject *PyInit_openscad (void) {
+  return PyModule_Create (&OpenSCADModule);
 }
 
-PyMODINIT_FUNC PyInit_PyOpenSCAD(void)
-{
+PyMODINIT_FUNC PyInit_PyOpenSCAD (void) {
   PyObject *m;
 
-  if (PyType_Ready(&PyOpenSCADType) < 0) return NULL;
+  if (PyType_Ready (&PyOpenSCADType) < 0)
+    return NULL;
 
-  m = PyInit_openscad();
-  if (m == NULL) return NULL;
+  m = PyInit_openscad ();
+  if (m == NULL)
+    return NULL;
 
-  Py_INCREF(&PyOpenSCADType);
-  PyModule_AddObject(m, "openscad", (PyObject *)&PyOpenSCADType);
+  Py_INCREF (&PyOpenSCADType);
+  PyModule_AddObject (m, "openscad", (PyObject *)&PyOpenSCADType);
   return m;
 }
diff --git a/src/python/pyopenscad.h b/src/python/pyopenscad.h
index 53e05507b..e55b63f30 100644
--- a/src/python/pyopenscad.h
+++ b/src/python/pyopenscad.h
@@ -9,37 +9,37 @@
 
 #pragma GCC diagnostic ignored "-Wwrite-strings"
 
-#define DECLARE_INSTANCE  std::string instance_name; \
-        AssignmentList inst_asslist; \
-        ModuleInstantiation *instance = new ModuleInstantiation(instance_name, inst_asslist, Location::NONE);
-
+#define DECLARE_INSTANCE       \
+  std::string instance_name;   \
+  AssignmentList inst_asslist; \
+  ModuleInstantiation *instance = new ModuleInstantiation (instance_name, inst_asslist, Location::NONE);
 
 typedef struct {
   PyObject_HEAD
-  std::shared_ptr<AbstractNode> node;
+    std::shared_ptr<AbstractNode>
+      node;
   PyObject *dict;
   /* Type-specific fields go here. */
 } PyOpenSCADObject;
 
-void PyObjectDeleter(PyObject *pObject);
-using PyObjectUniquePtr = std::unique_ptr<PyObject, decltype(PyObjectDeleter )&>;
-
-PyMODINIT_FUNC PyInit_PyOpenSCAD(void);
-int python_vectorval(PyObject *vec, int minarg, int maxarg, double *x, double *y, double *z, double *w = NULL);
-PyObject *PyOpenSCADObjectFromNode(PyTypeObject *type, const std::shared_ptr<AbstractNode>& node);
-std::shared_ptr<AbstractNode> PyOpenSCADObjectToNode(PyObject *object);
+void PyObjectDeleter (PyObject *pObject);
+using PyObjectUniquePtr = std::unique_ptr<PyObject, decltype (PyObjectDeleter) &>;
 
+PyMODINIT_FUNC PyInit_PyOpenSCAD (void);
+int python_vectorval (PyObject *vec, int minarg, int maxarg, double *x, double *y, double *z, double *w = NULL);
+PyObject *PyOpenSCADObjectFromNode (PyTypeObject *type, const std::shared_ptr<AbstractNode> &node);
+std::shared_ptr<AbstractNode> PyOpenSCADObjectToNode (PyObject *object);
 
 extern PyTypeObject PyOpenSCADType;
 extern std::shared_ptr<AbstractNode> python_result_node;
-std::shared_ptr<AbstractNode> PyOpenSCADObjectToNode(PyObject *object, PyObject **dict);
-std::shared_ptr<AbstractNode> PyOpenSCADObjectToNodeMulti(PyObject *object, PyObject **dict);
+std::shared_ptr<AbstractNode> PyOpenSCADObjectToNode (PyObject *object, PyObject **dict);
+std::shared_ptr<AbstractNode> PyOpenSCADObjectToNodeMulti (PyObject *object, PyObject **dict);
 extern std::string trusted_edit_document_name;
 extern std::string untrusted_edit_document_name;
-std::vector<Vector3d> python_vectors(PyObject *vec, int mindim, int maxdim);
-int python_numberval(PyObject *number, double *result);
-void get_fnas(double& fn, double& fa, double& fs);
-PyObject *python_str(PyObject *self);
+std::vector<Vector3d> python_vectors (PyObject *vec, int mindim, int maxdim);
+int python_numberval (PyObject *number, double *result);
+void get_fnas (double &fn, double &fa, double &fs);
+PyObject *python_str (PyObject *self);
 
 extern PyNumberMethods PyOpenSCADNumbers;
 extern PyMappingMethods PyOpenSCADMapping;
diff --git a/src/python/python_public.h b/src/python/python_public.h
index e7c8f8288..8f22e9381 100644
--- a/src/python/python_public.h
+++ b/src/python/python_public.h
@@ -3,17 +3,17 @@
 
 extern bool python_active;
 extern bool python_trusted;
-std::string python_version(void);
+std::string python_version (void);
 
-void initPython(const std::string& binDir, double time);
-std::string evaluatePython(const std::string& code, bool dry_run = 0);
-void finishPython();
-void python_lock(void);
-void python_unlock(void);
+void initPython (const std::string &binDir, double time);
+std::string evaluatePython (const std::string &code, bool dry_run = 0);
+void finishPython ();
+void python_lock (void);
+void python_unlock (void);
 
 extern std::shared_ptr<AbstractNode> python_result_node;
 
-int pythonRunArgs(int argc, char **argv);
-int pythonCreateVenv(const std::string& path);
-int pythonRunModule(const std::string& appPath, const std::string& module, const std::vector<std::string>& args);
-std::string venvBinDirFromSettings();
+int pythonRunArgs (int argc, char **argv);
+int pythonCreateVenv (const std::string &path);
+int pythonRunModule (const std::string &appPath, const std::string &module, const std::vector<std::string> &args);
+std::string venvBinDirFromSettings ();
diff --git a/src/utils/StackCheck.h b/src/utils/StackCheck.h
index 76be28b4f..ef89c8e28 100644
--- a/src/utils/StackCheck.h
+++ b/src/utils/StackCheck.h
@@ -6,22 +6,24 @@
 class StackCheck
 {
 public:
-  static StackCheck& inst()
-  {
+  static StackCheck &inst () {
     static StackCheck instance;
     return instance;
   }
 
-  inline bool check() { return size() >= limit; }
+  inline bool check () {
+    return size () >= limit;
+  }
 
 private:
-  StackCheck() : limit(PlatformUtils::stackLimit()) {
+  StackCheck ()
+    : limit (PlatformUtils::stackLimit ()) {
     unsigned char c;
     ptr = &c; // NOLINT(*StackAddressEscape)
   }
-  inline unsigned long size() {
+  inline unsigned long size () {
     unsigned char c;
-    return std::abs(ptr - &c);
+    return std::abs (ptr - &c);
   }
 
   unsigned long limit;
diff --git a/src/utils/boost-utils.h b/src/utils/boost-utils.h
index 04c24d50a..aa2d73351 100644
--- a/src/utils/boost-utils.h
+++ b/src/utils/boost-utils.h
@@ -8,7 +8,7 @@
 
 #include "utils/printutils.h"
 
-BOOST_TRIBOOL_THIRD_STATE(unknown)
+BOOST_TRIBOOL_THIRD_STATE (unknown)
 
 /* Convert number types but print WARNING for failures during
    conversion. This is useful for situations where it is important to not
@@ -17,29 +17,27 @@ BOOST_TRIBOOL_THIRD_STATE(unknown)
    For positive overflow, return max of Tout template type
    For negative overflow, return min of Tout template type
    On other conversion failures, return 0. */
-template <class Tout, class Tin> Tout boost_numeric_cast(Tin input)
-{
+template <class Tout, class Tin>
+Tout boost_numeric_cast (Tin input) {
   Tout result = 0;
   std::ostringstream status;
-  status.str("ok");
+  status.str ("ok");
   try {
-    result = boost::numeric_cast<Tout>(input);
-  } catch (boost::numeric::negative_overflow& e) {
-    status << e.what();
-    result = std::numeric_limits<Tout>::min();
-  } catch (boost::numeric::positive_overflow& e) {
-    status << e.what();
-    result = std::numeric_limits<Tout>::max();
-  } catch (boost::numeric::bad_numeric_cast& e) {
-    status << e.what();
+    result = boost::numeric_cast<Tout> (input);
+  } catch (boost::numeric::negative_overflow &e) {
+    status << e.what ();
+    result = std::numeric_limits<Tout>::min ();
+  } catch (boost::numeric::positive_overflow &e) {
+    status << e.what ();
+    result = std::numeric_limits<Tout>::max ();
+  } catch (boost::numeric::bad_numeric_cast &e) {
+    status << e.what ();
     result = 0;
   }
-  if (status.str() != "ok") {
-    LOG(message_group::Warning, "Problem converting this number: %1$s", std::to_string(input));
-    LOG(message_group::Warning, "%1$s", status.str());
-    LOG(message_group::Warning, "setting result to %1$u", result);
+  if (status.str () != "ok") {
+    LOG (message_group::Warning, "Problem converting this number: %1$s", std::to_string (input));
+    LOG (message_group::Warning, "%1$s", status.str ());
+    LOG (message_group::Warning, "setting result to %1$u", result);
   }
   return result;
 }
-
-
diff --git a/src/utils/calc.cc b/src/utils/calc.cc
index 3d4a50804..dfe007d6b 100644
--- a/src/utils/calc.cc
+++ b/src/utils/calc.cc
@@ -33,7 +33,7 @@
 #include "utils/degree_trig.h"
 
 // Linear interpolate.  Can replace with std::lerp in C++20
-double Calc::lerp(double a, double b, double t) {
+double Calc::lerp (double a, double b, double t) {
   return (1 - t) * a + t * b;
 }
 
@@ -41,13 +41,14 @@ double Calc::lerp(double a, double b, double t) {
    Returns the number of subdivision of a whole circle, given radius and
    the three special variables $fn, $fs and $fa
  */
-int Calc::get_fragments_from_r(double r, double fn, double fs, double fa)
-{
+int Calc::get_fragments_from_r (double r, double fn, double fs, double fa) {
   // FIXME: It would be better to refuse to create an object. Let's do more strict error handling
   // in future versions of OpenSCAD
-  if (r < GRID_FINE || std::isinf(fn) || std::isnan(fn)) return 3;
-  if (fn > 0.0) return static_cast<int>(fn >= 3 ? fn : 3);
-  return static_cast<int>(ceil(fmax(fmin(360.0 / fa, r * 2 * M_PI / fs), 5)));
+  if (r < GRID_FINE || std::isinf (fn) || std::isnan (fn))
+    return 3;
+  if (fn > 0.0)
+    return static_cast<int> (fn >= 3 ? fn : 3);
+  return static_cast<int> (ceil (fmax (fmin (360.0 / fa, r * 2 * M_PI / fs), 5)));
 }
 
 /*
@@ -59,30 +60,30 @@ int Calc::get_fragments_from_r(double r, double fn, double fs, double fa)
    Solving for c gives                c = height / (twist*PI/180)
    Where (twist*PI/180) is just twist in radians, aka "T"
  */
-static double helix_arc_length(double r_sqr, double height, double twist) {
+static double helix_arc_length (double r_sqr, double height, double twist) {
   const double T = twist * M_DEG2RAD;
   const double c = height / T;
-  return T * sqrt(r_sqr + c * c);
+  return T * sqrt (r_sqr + c * c);
 }
 
 /*!
    Returns the number of slices for a linear_extrude with twist.
    Given height, twist, and the three special variables $fn, $fs and $fa
  */
-int Calc::get_helix_slices(double r_sqr, double height, double twist, double fn, double fs, double fa)
-{
-  twist = fabs(twist);
+int Calc::get_helix_slices (double r_sqr, double height, double twist, double fn, double fs, double fa) {
+  twist = fabs (twist);
   // 180 twist per slice is worst case, guaranteed non-manifold.
   // Make sure we have at least 3 slices per 360 twist
-  const int min_slices = std::max(static_cast<int>(ceil(twist / 120.0)), 1);
-  if (sqrt(r_sqr) < GRID_FINE || std::isinf(fn) || std::isnan(fn)) return min_slices;
+  const int min_slices = std::max (static_cast<int> (ceil (twist / 120.0)), 1);
+  if (sqrt (r_sqr) < GRID_FINE || std::isinf (fn) || std::isnan (fn))
+    return min_slices;
   if (fn > 0.0) {
-    const int fn_slices = static_cast<int>(ceil(twist / 360.0 * fn));
-    return std::max(fn_slices, min_slices);
+    const int fn_slices = static_cast<int> (ceil (twist / 360.0 * fn));
+    return std::max (fn_slices, min_slices);
   }
-  const int fa_slices = static_cast<int>(ceil(twist / fa));
-  const int fs_slices = static_cast<int>(ceil(helix_arc_length(r_sqr, height, twist) / fs));
-  return std::max(std::min(fa_slices, fs_slices), min_slices);
+  const int fa_slices = static_cast<int> (ceil (twist / fa));
+  const int fs_slices = static_cast<int> (ceil (helix_arc_length (r_sqr, height, twist) / fs));
+  return std::max (std::min (fa_slices, fs_slices), min_slices);
 }
 
 /*
@@ -94,18 +95,19 @@ int Calc::get_helix_slices(double r_sqr, double height, double twist, double fn,
    Using the formula for its arc length, then pythagorean theorem with height
    should tell us the total distance a vertex covers.
  */
-static double archimedes_length(double a, double theta) {
-  return 0.5 * a * (theta * sqrt(1 + theta * theta) + asinh(theta));
+static double archimedes_length (double a, double theta) {
+  return 0.5 * a * (theta * sqrt (1 + theta * theta) + asinh (theta));
 }
 
-int Calc::get_conical_helix_slices(double r_sqr, double height, double twist, double scale, double fn, double fs, double fa) {
-  twist = fabs(twist);
-  const double r = sqrt(r_sqr);
-  const int min_slices = std::max(static_cast<int>(ceil(twist / 120.0)), 1);
-  if (r < GRID_FINE || std::isinf(fn) || std::isnan(fn)) return min_slices;
+int Calc::get_conical_helix_slices (double r_sqr, double height, double twist, double scale, double fn, double fs, double fa) {
+  twist = fabs (twist);
+  const double r = sqrt (r_sqr);
+  const int min_slices = std::max (static_cast<int> (ceil (twist / 120.0)), 1);
+  if (r < GRID_FINE || std::isinf (fn) || std::isnan (fn))
+    return min_slices;
   if (fn > 0.0) {
-    const int fn_slices = static_cast<int>(ceil(twist * fn / 360));
-    return std::max(fn_slices, min_slices);
+    const int fn_slices = static_cast<int> (ceil (twist * fn / 360));
+    return std::max (fn_slices, min_slices);
   }
   /*
      Spiral length equation assumes starting from theta=0
@@ -135,17 +137,17 @@ int Calc::get_conical_helix_slices(double r_sqr, double height, double twist, do
   } else if (scale < 1) {
     angle_end = rads / (1 - scale);
   } else {
-    assert(false && "Don't calculate conical slices on non-scaled extrude!");
+    assert (false && "Don't calculate conical slices on non-scaled extrude!");
   }
   const double angle_start = angle_end - rads;
   const double a = r / angle_end; // spiral scale coefficient
-  const double spiral_length = archimedes_length(a, angle_end) - archimedes_length(a, angle_start);
+  const double spiral_length = archimedes_length (a, angle_end) - archimedes_length (a, angle_start);
   // Treat (flat spiral_length,extrusion height) as (base,height) of a right triangle to get diagonal length.
-  const double total_length = sqrt(spiral_length * spiral_length + height * height);
+  const double total_length = sqrt (spiral_length * spiral_length + height * height);
 
-  const int fs_slices = static_cast<int>(ceil(total_length / fs));
-  const int fa_slices = static_cast<int>(ceil(twist / fa));
-  return std::max(std::min(fa_slices, fs_slices), min_slices);
+  const int fs_slices = static_cast<int> (ceil (total_length / fs));
+  const int fa_slices = static_cast<int> (ceil (twist / fa));
+  return std::max (std::min (fa_slices, fs_slices), min_slices);
 }
 
 /*
@@ -157,13 +159,14 @@ int Calc::get_conical_helix_slices(double r_sqr, double height, double twist, do
     note: $fa is not considered since no twist
           scale is not passed in since it was already used to calculate the largest delta.
  */
-int Calc::get_diagonal_slices(double delta_sqr, double height, double fn, double fs) {
+int Calc::get_diagonal_slices (double delta_sqr, double height, double fn, double fs) {
   constexpr int min_slices = 1;
-  if (sqrt(delta_sqr) < GRID_FINE || std::isinf(fn) || std::isnan(fn)) return min_slices;
+  if (sqrt (delta_sqr) < GRID_FINE || std::isinf (fn) || std::isnan (fn))
+    return min_slices;
   if (fn > 0.0) {
-    const int fn_slices = static_cast<int>(fn);
-    return std::max(fn_slices, min_slices);
+    const int fn_slices = static_cast<int> (fn);
+    return std::max (fn_slices, min_slices);
   }
-  const int fs_slices = static_cast<int>(ceil(sqrt(delta_sqr + height * height) / fs));
-  return std::max(fs_slices, min_slices);
+  const int fs_slices = static_cast<int> (ceil (sqrt (delta_sqr + height * height) / fs));
+  return std::max (fs_slices, min_slices);
 }
diff --git a/src/utils/calc.h b/src/utils/calc.h
index 7ab8c48c1..893668257 100644
--- a/src/utils/calc.h
+++ b/src/utils/calc.h
@@ -1,9 +1,9 @@
 #pragma once
 
 namespace Calc {
-double lerp(double a, double b, double t);
-int get_fragments_from_r(double r, double fn, double fs, double fa);
-int get_helix_slices(double r_sqr, double h, double twist, double fn, double fs, double fa);
-int get_conical_helix_slices(double r, double height, double twist, double scale, double fn, double fs, double fa);
-int get_diagonal_slices(double delta_sqr, double height, double fn, double fs);
-}
+double lerp (double a, double b, double t);
+int get_fragments_from_r (double r, double fn, double fs, double fa);
+int get_helix_slices (double r_sqr, double h, double twist, double fn, double fs, double fa);
+int get_conical_helix_slices (double r, double height, double twist, double scale, double fn, double fs, double fa);
+int get_diagonal_slices (double delta_sqr, double height, double fn, double fs);
+} // namespace Calc
diff --git a/src/utils/compiler_specific.h b/src/utils/compiler_specific.h
index 9a632bdac..8ec140d9d 100644
--- a/src/utils/compiler_specific.h
+++ b/src/utils/compiler_specific.h
@@ -25,7 +25,7 @@
 #pragma once
 
 #if defined(__clang__)
-#define NOINLINE __attribute__((noinline))
+#define NOINLINE __attribute__ ((noinline))
 #elif defined(COMPILER_GCC)
 #define NOINLINE [[gnu::noinline]]
 #else
diff --git a/src/utils/degree_trig.cc b/src/utils/degree_trig.cc
index ebee92b8b..730305305 100644
--- a/src/utils/degree_trig.cc
+++ b/src/utils/degree_trig.cc
@@ -36,13 +36,11 @@
 // Trigonometry function taking degrees, accurate for 30, 45, 60 and 90, etc.
 //
 
-static inline double rad2deg(double x)
-{
+static inline double rad2deg (double x) {
   return x * M_RAD2DEG;
 }
 
-static inline double deg2rad(double x)
-{
+static inline double deg2rad (double x) {
   return x * M_DEG2RAD;
 }
 
@@ -50,90 +48,94 @@ static inline double deg2rad(double x)
 // comment/undefine it to disable domain check
 #define TRIG_HUGE_VAL ((1L << 26) * 360.0 * (1L << 26))
 
-double sin_degrees(double x)
-{
+double sin_degrees (double x) {
   // use positive tests because of possible Inf/NaN
   if (x < 360.0 && x >= 0.0) {
     // Ok for now
   } else
 #ifdef TRIG_HUGE_VAL
-  if (x < TRIG_HUGE_VAL && x > -TRIG_HUGE_VAL)
+    if (x < TRIG_HUGE_VAL && x > -TRIG_HUGE_VAL)
 #endif
   {
-    const double revolutions = floor(x / 360.0);
+    const double revolutions = floor (x / 360.0);
     x -= 360.0 * revolutions;
   }
 #ifdef TRIG_HUGE_VAL
   else {
     // total loss of computational accuracy
     // the result would be meaningless
-    return std::numeric_limits<double>::quiet_NaN();
+    return std::numeric_limits<double>::quiet_NaN ();
   }
 #endif
   const bool oppose = x >= 180.0;
-  if (oppose) x -= 180.0;
-  if (x > 90.0) x = 180.0 - x;
+  if (oppose)
+    x -= 180.0;
+  if (x > 90.0)
+    x = 180.0 - x;
   if (x < 45.0) {
-    if (x == 30.0) x = 0.5;
-    else x = sin(deg2rad(x));
+    if (x == 30.0)
+      x = 0.5;
+    else
+      x = sin (deg2rad (x));
   } else if (x == 45.0) {
     x = M_SQRT1_2;
   } else if (x == 60.0) {
     x = M_SQRT3_4;
   } else { // Inf/Nan would fall here
-    x = cos(deg2rad(90.0 - x));
+    x = cos (deg2rad (90.0 - x));
   }
   return oppose ? -x : x;
 }
 
-double cos_degrees(double x)
-{
+double cos_degrees (double x) {
   // use positive tests because of possible Inf/NaN
   if (x < 360.0 && x >= 0.0) {
     // Ok for now
   } else
 #ifdef TRIG_HUGE_VAL
-  if (x < TRIG_HUGE_VAL && x > -TRIG_HUGE_VAL)
+    if (x < TRIG_HUGE_VAL && x > -TRIG_HUGE_VAL)
 #endif
   {
-    const double revolutions = floor(x / 360.0);
+    const double revolutions = floor (x / 360.0);
     x -= 360.0 * revolutions;
   }
 #ifdef TRIG_HUGE_VAL
   else {
     // total loss of computational accuracy
     // the result would be meaningless
-    return std::numeric_limits<double>::quiet_NaN();
+    return std::numeric_limits<double>::quiet_NaN ();
   }
 #endif
   bool oppose = x >= 180.0;
-  if (oppose) x -= 180.0;
+  if (oppose)
+    x -= 180.0;
   if (x > 90.0) {
     x = 180.0 - x;
     oppose = !oppose;
   }
   if (x > 45.0) {
-    if (x == 60.0) x = 0.5;
-    else x = sin(deg2rad(90.0 - x));
+    if (x == 60.0)
+      x = 0.5;
+    else
+      x = sin (deg2rad (90.0 - x));
   } else if (x == 45.0) {
     x = M_SQRT1_2;
   } else if (x == 30.0) {
     x = M_SQRT3_4;
   } else { // Inf/Nan would fall here
-    x = cos(deg2rad(x));
+    x = cos (deg2rad (x));
   }
   return oppose ? -x : x;
 }
 
-double tan_degrees(double x)
-{
-  const int cycles = floor((x) / 180.0);
+double tan_degrees (double x) {
+  const int cycles = floor ((x) / 180.0);
   // use positive tests because of possible Inf/NaN
   if (x < 180.0 && x >= 0.0) {
     // Ok for now
   } else
 #ifdef TRIG_HUGE_VAL
-  if (x < TRIG_HUGE_VAL && x > -TRIG_HUGE_VAL)
+    if (x < TRIG_HUGE_VAL && x > -TRIG_HUGE_VAL)
 #endif
   {
     x -= 180.0 * cycles;
@@ -142,11 +144,12 @@ double tan_degrees(double x)
   else {
     // total loss of computational accuracy
     // the result would be meaningless
-    return std::numeric_limits<double>::quiet_NaN();
+    return std::numeric_limits<double>::quiet_NaN ();
   }
 #endif
   const bool oppose = x > 90.0;
-  if (oppose) x = 180.0 - x;
+  if (oppose)
+    x = 180.0 - x;
   if (x == 0.0) {
     x = (cycles % 2) == 0 ? 0.0 : -0.0;
   } else if (x == 30.0) {
@@ -156,62 +159,59 @@ double tan_degrees(double x)
   } else if (x == 60.0) {
     x = M_SQRT3;
   } else if (x == 90.0) {
-    x = (cycles % 2) == 0 ?
-      std::numeric_limits<double>::infinity() :
-      -std::numeric_limits<double>::infinity();
+    x = (cycles % 2) == 0 ? std::numeric_limits<double>::infinity () : -std::numeric_limits<double>::infinity ();
   } else {
-    x = tan(deg2rad(x));
+    x = tan (deg2rad (x));
   }
   return oppose ? -x : x;
 }
 //
 // Inverse trig
 //
-double asin_degrees(double x)
-{
-  const auto degs = rad2deg(asin(x));
-  const auto whole = round(degs);
-  if (sin_degrees(whole) == x) return whole;
+double asin_degrees (double x) {
+  const auto degs = rad2deg (asin (x));
+  const auto whole = round (degs);
+  if (sin_degrees (whole) == x)
+    return whole;
   return degs;
 }
-double acos_degrees(double x)
-{
-  const auto degs = rad2deg(acos(x));
-  const auto whole = round(degs);
-  if (cos_degrees(whole) == x) return whole;
+double acos_degrees (double x) {
+  const auto degs = rad2deg (acos (x));
+  const auto whole = round (degs);
+  if (cos_degrees (whole) == x)
+    return whole;
   return degs;
 }
-double atan_degrees(double x)
-{
-  const auto degs = rad2deg(atan(x));
-  const auto whole = round(degs);
-  if (tan_degrees(whole) == x) return whole;
+double atan_degrees (double x) {
+  const auto degs = rad2deg (atan (x));
+  const auto whole = round (degs);
+  if (tan_degrees (whole) == x)
+    return whole;
   return degs;
 }
-double atan2_degrees(double y, double x)
-{
-  const auto degs = rad2deg(atan2(y, x));
-  const auto whole = round(degs);
-  if (fabs(degs - whole) < 3.0E-14) return whole;
+double atan2_degrees (double y, double x) {
+  const auto degs = rad2deg (atan2 (y, x));
+  const auto whole = round (degs);
+  if (fabs (degs - whole) < 3.0E-14)
+    return whole;
   return degs;
 }
 //
 // Rotation_matrix_from_axis_and_angle
 //
-Matrix3d angle_axis_degrees(double a, Vector3d v)
-{
-  Matrix3d M{Matrix3d::Identity()};
+Matrix3d angle_axis_degrees (double a, Vector3d v) {
+  Matrix3d M{Matrix3d::Identity ()};
   // Formula from https://en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle
   // We avoid dividing by the square root of the magnitude as much as possible
   // to minimise rounding errors.
-  const auto s = sin_degrees(a);
-  const auto c = cos_degrees(a);
-  const auto m = v.squaredNorm();
+  const auto s = sin_degrees (a);
+  const auto c = cos_degrees (a);
+  const auto m = v.squaredNorm ();
   if (m > 0) {
     const Vector3d Cv = v * ((1 - c) / m);
-    const Vector3d us = v.normalized() * s;
-    M << Cv[0] * v[0] + c,     Cv[1] * v[0] - us[2], Cv[2] * v[0] + us[1],
-      Cv[0] * v[1] + us[2], Cv[1] * v[1] + c,     Cv[2] * v[1] - us[0],
+    const Vector3d us = v.normalized () * s;
+    M << Cv[0] * v[0] + c, Cv[1] * v[0] - us[2], Cv[2] * v[0] + us[1],
+      Cv[0] * v[1] + us[2], Cv[1] * v[1] + c, Cv[2] * v[1] - us[0],
       Cv[0] * v[2] - us[1], Cv[1] * v[2] + us[0], Cv[2] * v[2] + c;
   }
   return M;
@@ -219,14 +219,12 @@ Matrix3d angle_axis_degrees(double a, Vector3d v)
 //
 // 2D rotation matrix from angle in degrees
 //
-Matrix3d rotate_degrees(double angle)
-{
+Matrix3d rotate_degrees (double angle) {
   Eigen::Matrix3d m;
-  const auto s = sin_degrees(angle);
-  const auto c = cos_degrees(angle);
-  m <<
-    c, -s,  0,
-    s,  c,  0,
-    0,  0,  1;
+  const auto s = sin_degrees (angle);
+  const auto c = cos_degrees (angle);
+  m << c, -s, 0,
+    s, c, 0,
+    0, 0, 1;
   return m;
 }
diff --git a/src/utils/degree_trig.h b/src/utils/degree_trig.h
index 35781b4df..2aaaa6151 100644
--- a/src/utils/degree_trig.h
+++ b/src/utils/degree_trig.h
@@ -29,19 +29,19 @@
 #pragma once
 #include "geometry/linalg.h"
 
-constexpr double M_SQRT3 = 1.73205080756887719318;    /* sqrt(3)   */
-constexpr double M_SQRT3_4 = 0.86602540378443859659;  /* sqrt(3/4) == sqrt(3)/2 */
-constexpr double M_SQRT1_3 = 0.57735026918962573106;  /* sqrt(1/3) == sqrt(3)/3 */
-constexpr double M_RAD2DEG = 57.2957795130823208767;  /* 180/PI */
+constexpr double M_SQRT3 = 1.73205080756887719318; /* sqrt(3)   */
+constexpr double M_SQRT3_4 = 0.86602540378443859659; /* sqrt(3/4) == sqrt(3)/2 */
+constexpr double M_SQRT1_3 = 0.57735026918962573106; /* sqrt(1/3) == sqrt(3)/3 */
+constexpr double M_RAD2DEG = 57.2957795130823208767; /* 180/PI */
 constexpr double M_DEG2RAD = 0.017453292519943295769; /* PI/180 */
 
-double sin_degrees(double x);
-double cos_degrees(double x);
-double tan_degrees(double x);
-double asin_degrees(double x);
-double acos_degrees(double x);
-double atan_degrees(double x);
-double atan2_degrees(double y, double x);
+double sin_degrees (double x);
+double cos_degrees (double x);
+double tan_degrees (double x);
+double asin_degrees (double x);
+double acos_degrees (double x);
+double atan_degrees (double x);
+double atan2_degrees (double y, double x);
 
-Matrix3d angle_axis_degrees(double a, Vector3d v);
-Matrix3d rotate_degrees(double angle);
+Matrix3d angle_axis_degrees (double a, Vector3d v);
+Matrix3d rotate_degrees (double angle);
diff --git a/src/utils/exceptions.h b/src/utils/exceptions.h
index 515d63c6e..4eb17affd 100644
--- a/src/utils/exceptions.h
+++ b/src/utils/exceptions.h
@@ -10,7 +10,9 @@
 class EvaluationException : public std::runtime_error
 {
 public:
-  EvaluationException(const std::string& what_arg) : std::runtime_error(what_arg), traceDepth(OpenSCAD::traceDepth) {}
+  EvaluationException (const std::string &what_arg)
+    : std::runtime_error (what_arg)
+    , traceDepth (OpenSCAD::traceDepth) {}
 
 public:
   int traceDepth = 0;
@@ -19,7 +21,9 @@ public:
 class AssertionFailedException : public EvaluationException
 {
 public:
-  AssertionFailedException(const std::string& what_arg, Location loc) : EvaluationException(what_arg), loc(std::move(loc)) {}
+  AssertionFailedException (const std::string &what_arg, Location loc)
+    : EvaluationException (what_arg)
+    , loc (std::move (loc)) {}
 
 public:
   Location loc;
@@ -28,44 +32,50 @@ public:
 class RecursionException : public EvaluationException
 {
 public:
-  static RecursionException create(const std::string& recursiontype, const std::string& name, const Location& loc) {
-    return RecursionException{STR("Recursion detected calling ", recursiontype, " '", name, "'"), loc};
+  static RecursionException create (const std::string &recursiontype, const std::string &name, const Location &loc) {
+    return RecursionException{STR ("Recursion detected calling ", recursiontype, " '", name, "'"), loc};
   }
 
 public:
   Location loc;
 
 private:
-  RecursionException(const std::string& what_arg, Location loc) : EvaluationException(what_arg), loc(std::move(loc)) {}
+  RecursionException (const std::string &what_arg, Location loc)
+    : EvaluationException (what_arg)
+    , loc (std::move (loc)) {}
 };
 
 class LoopCntException : public EvaluationException
 {
 public:
-  static LoopCntException create(const std::string& type, const Location& loc) {
-    return LoopCntException{STR(type, " loop counter exceeded limit"), loc};
+  static LoopCntException create (const std::string &type, const Location &loc) {
+    return LoopCntException{STR (type, " loop counter exceeded limit"), loc};
   }
 
 public:
   Location loc;
 
 private:
-  LoopCntException(const std::string& what_arg, Location loc) : EvaluationException(what_arg), loc(std::move(loc)) {}
+  LoopCntException (const std::string &what_arg, Location loc)
+    : EvaluationException (what_arg)
+    , loc (std::move (loc)) {}
 };
 
 class VectorEchoStringException : public EvaluationException
 {
 public:
-  static VectorEchoStringException create() {
+  static VectorEchoStringException create () {
     return VectorEchoStringException{"Stack exhausted while trying to convert a vector to EchoString"};
   }
 
 private:
-  VectorEchoStringException(const std::string& what_arg) : EvaluationException(what_arg) {}
+  VectorEchoStringException (const std::string &what_arg)
+    : EvaluationException (what_arg) {}
 };
 
 class HardWarningException : public EvaluationException
 {
 public:
-  HardWarningException(const std::string& what_arg) : EvaluationException(what_arg) {}
+  HardWarningException (const std::string &what_arg)
+    : EvaluationException (what_arg) {}
 };
diff --git a/src/utils/hash.cc b/src/utils/hash.cc
index eb41124a2..2e7eba68d 100644
--- a/src/utils/hash.cc
+++ b/src/utils/hash.cc
@@ -8,34 +8,37 @@
 #include "geometry/linalg.h"
 
 namespace std {
-std::size_t hash<Vector3f>::operator()(const Vector3f& s) const {
-  return Eigen::hash_value(s);
+std::size_t hash<Vector3f>::operator() (const Vector3f &s) const {
+  return Eigen::hash_value (s);
 }
-std::size_t hash<Vector3d>::operator()(const Vector3d& s) const {
-  return Eigen::hash_value(s);
-}
-std::size_t hash<Vector3l>::operator()(const Vector3l& s) const {
-  return Eigen::hash_value(s);
+std::size_t hash<Vector3d>::operator() (const Vector3d &s) const {
+  return Eigen::hash_value (s);
 }
+std::size_t hash<Vector3l>::operator() (const Vector3l &s) const {
+  return Eigen::hash_value (s);
 }
+} // namespace std
 
 namespace Eigen {
 
-size_t hash_value(Vector3f const& v) {
+size_t hash_value (Vector3f const &v) {
   size_t seed = 0;
-  for (int i = 0; i < 3; ++i) boost::hash_combine(seed, v[i]);
+  for (int i = 0; i < 3; ++i)
+    boost::hash_combine (seed, v[i]);
   return seed;
 }
 
-size_t hash_value(Vector3d const& v) {
+size_t hash_value (Vector3d const &v) {
   size_t seed = 0;
-  for (int i = 0; i < 3; ++i) boost::hash_combine(seed, v[i]);
+  for (int i = 0; i < 3; ++i)
+    boost::hash_combine (seed, v[i]);
   return seed;
 }
 
-size_t hash_value(Eigen::Matrix<int64_t, 3, 1> const& v) {
+size_t hash_value (Eigen::Matrix<int64_t, 3, 1> const &v) {
   size_t seed = 0;
-  for (int i = 0; i < 3; ++i) boost::hash_combine(seed, v[i]);
+  for (int i = 0; i < 3; ++i)
+    boost::hash_combine (seed, v[i]);
   return seed;
 }
-}
+} // namespace Eigen
diff --git a/src/utils/hash.h b/src/utils/hash.h
index cfd03d8eb..0d9e44a5b 100644
--- a/src/utils/hash.h
+++ b/src/utils/hash.h
@@ -10,13 +10,22 @@
 using Vector3l = Eigen::Matrix<int64_t, 3, 1>;
 
 namespace std {
-template <> struct hash<Vector3f> { std::size_t operator()(const Vector3f& s) const; };
-template <> struct hash<Vector3d> { std::size_t operator()(const Vector3d& s) const; };
-template <> struct hash<Vector3l> { std::size_t operator()(const Vector3l& s) const; };
-}
+template <>
+struct hash<Vector3f> {
+  std::size_t operator() (const Vector3f &s) const;
+};
+template <>
+struct hash<Vector3d> {
+  std::size_t operator() (const Vector3d &s) const;
+};
+template <>
+struct hash<Vector3l> {
+  std::size_t operator() (const Vector3l &s) const;
+};
+} // namespace std
 
 namespace Eigen {
-size_t hash_value(Vector3f const& v);
-size_t hash_value(Vector3d const& v);
-size_t hash_value(Vector3l const& v);
-}
+size_t hash_value (Vector3f const &v);
+size_t hash_value (Vector3d const &v);
+size_t hash_value (Vector3l const &v);
+} // namespace Eigen
diff --git a/src/utils/parallel.h b/src/utils/parallel.h
index 0b4e0ebb4..475ff9553 100644
--- a/src/utils/parallel.h
+++ b/src/utils/parallel.h
@@ -10,56 +10,57 @@
 #endif
 
 template <class InputIterator, class OutputIterator, class Operation>
-void parallelizable_transform(const InputIterator begin1,
-                              const InputIterator end1, OutputIterator out,
-                              const Operation& op) {
+void parallelizable_transform (const InputIterator begin1,
+                               const InputIterator end1, OutputIterator out,
+                               const Operation &op) {
 #if ENABLE_TBB
-  if (!getenv("OPENSCAD_NO_PARALLEL")) {
-    tbb::parallel_for(tbb::blocked_range(begin1, end1), [&](auto range) {
-      size_t start_index = std::distance(begin1, range.begin());
-      for (auto iter = range.begin(); iter != range.end(); iter++)
-        out[start_index++] = op(*iter);
+  if (!getenv ("OPENSCAD_NO_PARALLEL")) {
+    tbb::parallel_for (tbb::blocked_range (begin1, end1), [&] (auto range) {
+      size_t start_index = std::distance (begin1, range.begin ());
+      for (auto iter = range.begin (); iter != range.end (); iter++)
+        out[start_index++] = op (*iter);
     });
     return;
   }
 #endif
-  std::transform(begin1, end1, out, op);
+  std::transform (begin1, end1, out, op);
 }
 
 template <class Container1, class Container2, class OutputIterator,
           class Operation>
-void parallelizable_cross_product_transform(const Container1& cont1,
-                                            const Container2& cont2,
-                                            OutputIterator out,
-                                            const Operation& op) {
+void parallelizable_cross_product_transform (const Container1 &cont1,
+                                             const Container2 &cont2,
+                                             OutputIterator out,
+                                             const Operation &op) {
 #if ENABLE_TBB
-  if (!getenv("OPENSCAD_NO_PARALLEL")) {
+  if (!getenv ("OPENSCAD_NO_PARALLEL")) {
     struct ReferencePair {
-      decltype(*cont1.begin()) first;
-      decltype(*cont2.begin()) second;
-      ReferencePair(decltype(*cont1.begin()) first,
-                    decltype(*cont2.begin()) second)
-        : first(first), second(second) {
+      decltype (*cont1.begin ()) first;
+      decltype (*cont2.begin ()) second;
+      ReferencePair (decltype (*cont1.begin ()) first,
+                     decltype (*cont2.begin ()) second)
+        : first (first)
+        , second (second) {
       }
     };
     std::vector<ReferencePair> pairs;
-    pairs.reserve(cont1.size() * cont2.size());
-    for (const auto& v1 : cont1) {
-      for (const auto& v2 : cont2) {
-        pairs.emplace_back(v1, v2);
+    pairs.reserve (cont1.size () * cont2.size ());
+    for (const auto &v1 : cont1) {
+      for (const auto &v2 : cont2) {
+        pairs.emplace_back (v1, v2);
       }
     }
-    parallelizable_transform(
-      pairs.begin(), pairs.end(), out,
-      [&](const auto& pair) {
-      return op(pair.first, pair.second);
-    });
+    parallelizable_transform (
+      pairs.begin (), pairs.end (), out,
+      [&] (const auto &pair) {
+        return op (pair.first, pair.second);
+      });
     return;
   }
 #endif // if ENABLE_TBB
-  for (const auto& v1 : cont1) {
-    for (const auto& v2 : cont2) {
-      *(out++) = op(v1, v2);
+  for (const auto &v1 : cont1) {
+    for (const auto &v2 : cont2) {
+      *(out++) = op (v1, v2);
     }
   }
 }
diff --git a/src/utils/printutils.cc b/src/utils/printutils.cc
index 747cb906d..fd0676893 100644
--- a/src/utils/printutils.cc
+++ b/src/utils/printutils.cc
@@ -21,7 +21,7 @@ std::set<std::string> printedDeprecations;
 std::list<std::string> print_messages_stack;
 OutputHandlerFunc *outputhandler = nullptr;
 void *outputhandler_data = nullptr;
-std::string OpenSCAD::debug("");
+std::string OpenSCAD::debug ("");
 bool OpenSCAD::quiet = false;
 bool OpenSCAD::hardwarnings = false;
 int OpenSCAD::traceDepth = 12;
@@ -33,153 +33,148 @@ namespace {
 
 std::list<struct Message> log_messages_stack;
 OutputHandlerFunc2 *outputhandler2 = nullptr;
-boost::circular_buffer<std::string> lastmessages(5);
-boost::circular_buffer<struct Message> lastlogmessages(5);
+boost::circular_buffer<std::string> lastmessages (5);
+boost::circular_buffer<struct Message> lastlogmessages (5);
 
 int count = 0;
 bool no_throw;
 bool deferred;
 
-}  // namespace
+} // namespace
 
-void set_output_handler(OutputHandlerFunc *newhandler, OutputHandlerFunc2 *newhandler2, void *userdata)
-{
+void set_output_handler (OutputHandlerFunc *newhandler, OutputHandlerFunc2 *newhandler2, void *userdata) {
   outputhandler = newhandler;
   outputhandler2 = newhandler2;
   outputhandler_data = userdata;
 }
 
-void no_exceptions_for_warnings()
-{
+void no_exceptions_for_warnings () {
   no_throw = true;
   deferred = false;
 }
 
-bool would_have_thrown()
-{
+bool would_have_thrown () {
   const auto would_throw = deferred;
   no_throw = false;
   deferred = false;
   return would_throw;
 }
 
-void print_messages_push()
-{
-  print_messages_stack.emplace_back();
+void print_messages_push () {
+  print_messages_stack.emplace_back ();
 }
 
-void print_messages_pop()
-{
-  const std::string msg = print_messages_stack.back();
-  print_messages_stack.pop_back();
-  if (print_messages_stack.size() > 0 && !msg.empty()) {
-    if (!print_messages_stack.back().empty()) {
-      print_messages_stack.back() += "\n";
+void print_messages_pop () {
+  const std::string msg = print_messages_stack.back ();
+  print_messages_stack.pop_back ();
+  if (print_messages_stack.size () > 0 && !msg.empty ()) {
+    if (!print_messages_stack.back ().empty ()) {
+      print_messages_stack.back () += "\n";
     }
-    print_messages_stack.back() += msg;
+    print_messages_stack.back () += msg;
   }
 }
 
-void PRINT(const Message& msgObj)
-{
-  if (msgObj.msg.empty() && msgObj.group != message_group::Echo) return;
+void PRINT (const Message &msgObj) {
+  if (msgObj.msg.empty () && msgObj.group != message_group::Echo)
+    return;
 
-  if (print_messages_stack.size() > 0) {
-    if (!print_messages_stack.back().empty()) {
-      print_messages_stack.back() += "\n";
+  if (print_messages_stack.size () > 0) {
+    if (!print_messages_stack.back ().empty ()) {
+      print_messages_stack.back () += "\n";
     }
-    print_messages_stack.back() += msgObj.str();
+    print_messages_stack.back () += msgObj.str ();
   }
 
-  PRINT_NOCACHE(msgObj);
+  PRINT_NOCACHE (msgObj);
 
   //to error log
   if (outputhandler2 &&
       !(msgObj.group == message_group::NONE || msgObj.group == message_group::Echo || msgObj.group == message_group::Trace)) {
 
-    outputhandler2(msgObj, outputhandler_data);
+    outputhandler2 (msgObj, outputhandler_data);
   }
 }
 
-void PRINT_NOCACHE(const Message& msgObj)
-{
-  if (msgObj.msg.empty() && msgObj.group != message_group::Echo) return;
+void PRINT_NOCACHE (const Message &msgObj) {
+  if (msgObj.msg.empty () && msgObj.group != message_group::Echo)
+    return;
 
-  const auto msg = msgObj.str();
+  const auto msg = msgObj.str ();
 
   if (msgObj.group == message_group::Warning || msgObj.group == message_group::Error || msgObj.group == message_group::Trace) {
     size_t i;
-    for (i = 0; i < lastmessages.size(); ++i) {
-      if (lastmessages[i] != msg) break;
+    for (i = 0; i < lastmessages.size (); ++i) {
+      if (lastmessages[i] != msg)
+        break;
     }
-    if (i == 5) return; // Suppress output after 5 equal ERROR or WARNING outputs.
-    lastmessages.push_back(msg);
+    if (i == 5)
+      return; // Suppress output after 5 equal ERROR or WARNING outputs.
+    lastmessages.push_back (msg);
   }
   if (!deferred)
     if (!OpenSCAD::quiet || msgObj.group == message_group::Error) {
       if (!outputhandler) {
         std::cerr << msg << "\n";
       } else {
-        outputhandler(msgObj, outputhandler_data);
+        outputhandler (msgObj, outputhandler_data);
       }
     }
-  if (!std::current_exception()) {
+  if (!std::current_exception ()) {
     if ((OpenSCAD::hardwarnings && msgObj.group == message_group::Warning) || (no_throw && msgObj.group == message_group::Error)) {
-      if (no_throw) deferred = true;
-      else throw HardWarningException(msgObj.msg);
+      if (no_throw)
+        deferred = true;
+      else
+        throw HardWarningException (msgObj.msg);
     }
   }
 }
 
-void PRINTDEBUG(const std::string& filename, const std::string& msg)
-{
+void PRINTDEBUG (const std::string &filename, const std::string &msg) {
   // see printutils.h for usage instructions
-  if (OpenSCAD::debug == "") return;
-  const std::string shortfname = fs::path(filename).stem().generic_string();
-  std::string lowshortfname(shortfname);
-  boost::algorithm::to_lower(lowshortfname);
-  std::string lowdebug(OpenSCAD::debug);
-  boost::algorithm::to_lower(lowdebug);
+  if (OpenSCAD::debug == "")
+    return;
+  const std::string shortfname = fs::path (filename).stem ().generic_string ();
+  std::string lowshortfname (shortfname);
+  boost::algorithm::to_lower (lowshortfname);
+  std::string lowdebug (OpenSCAD::debug);
+  boost::algorithm::to_lower (lowdebug);
   if (OpenSCAD::debug == "all" ||
-      lowdebug.find(lowshortfname) != std::string::npos) {
+      lowdebug.find (lowshortfname) != std::string::npos) {
     const Message msgObj{shortfname + ": " + msg, message_group::NONE, Location::NONE, ""};
-    PRINT_NOCACHE(msgObj);
+    PRINT_NOCACHE (msgObj);
   }
 }
 
-const std::string& quoted_string(const std::string& str)
-{
+const std::string &quoted_string (const std::string &str) {
   static std::string buf;
   buf = str;
-  boost::replace_all(buf, "\n", "\\n");
+  boost::replace_all (buf, "\n", "\\n");
   return buf;
 }
 
-std::string two_digit_exp_format(std::string doublestr)
-{
+std::string two_digit_exp_format (std::string doublestr) {
 #ifdef _WIN32
-  size_t exppos = doublestr.find('e');
+  size_t exppos = doublestr.find ('e');
   if (exppos != std::string::npos) {
     exppos += 2;
-    if (doublestr[exppos] == '0') doublestr.erase(exppos, 1);
+    if (doublestr[exppos] == '0')
+      doublestr.erase (exppos, 1);
   }
 #endif
   return doublestr;
 }
 
-std::string two_digit_exp_format(double x)
-{
-  return two_digit_exp_format(std::to_string(x));
+std::string two_digit_exp_format (double x) {
+  return two_digit_exp_format (std::to_string (x));
 }
 
-void resetSuppressedMessages()
-{
-  printedDeprecations.clear();
-  lastmessages.clear();
+void resetSuppressedMessages () {
+  printedDeprecations.clear ();
+  lastmessages.clear ();
 }
 
-std::string getGroupName(const enum message_group& group)
-{
+std::string getGroupName (const enum message_group &group) {
   switch (group) {
   case message_group::NONE:
   case message_group::Warning:
@@ -203,13 +198,12 @@ std::string getGroupName(const enum message_group& group)
   case message_group::Echo:
     return "ECHO";
   default:
-    assert(false && "Unhandled message group name");
+    assert (false && "Unhandled message group name");
     return "";
   }
 }
 
-std::string getGroupColor(const enum message_group& group)
-{
+std::string getGroupColor (const enum message_group &group) {
   switch (group) {
   case message_group::Warning:
   case message_group::Deprecated:
@@ -228,13 +222,11 @@ std::string getGroupColor(const enum message_group& group)
   }
 }
 
-bool getGroupTextPlain(const enum message_group& group)
-{
+bool getGroupTextPlain (const enum message_group &group) {
   return group == message_group::NONE || group == message_group::Echo;
 }
 
 std::string
-quoteVar(const std::string& varname)
-{
+quoteVar (const std::string &varname) {
   return '"' + varname + '"';
 }
diff --git a/src/utils/printutils.h b/src/utils/printutils.h
index d46d9c113..544f44c19 100644
--- a/src/utils/printutils.h
+++ b/src/utils/printutils.h
@@ -30,33 +30,45 @@
 // Not wanting to risk breaking translations by changing every usage of this,
 // I've opted to just disable the check in this case. - Hans L
 // NOLINTBEGIN(bugprone-reserved-identifier)
-inline char *_(const char *msgid) { return gettext(msgid); }
-inline const char *_(const char *msgid, const char *msgctxt) {
+inline char *_ (const char *msgid) {
+  return gettext (msgid);
+}
+inline const char *_ (const char *msgid, const char *msgctxt) {
   /* The separator between msgctxt and msgid in a .mo file.  */
   const char *GETTEXT_CONTEXT_GLUE = "\004";
 
   std::string str = msgctxt;
   str += GETTEXT_CONTEXT_GLUE;
   str += msgid;
-  auto translation = dcgettext(nullptr, str.c_str(), LC_MESSAGES);
+  auto translation = dcgettext (nullptr, str.c_str (), LC_MESSAGES);
   if (translation == str) {
-    return gettext(msgid);
+    return gettext (msgid);
   } else {
     return translation;
   }
 }
 // NOLINTEND(bugprone-reserved-identifier)
 
-std::string quoteVar(const std::string& varname);
+std::string quoteVar (const std::string &varname);
 
 enum class message_group {
-  NONE, Error, Warning, UI_Warning, Font_Warning, Export_Warning, Export_Error, UI_Error, Parser_Error, Trace, Deprecated, Echo
+  NONE,
+  Error,
+  Warning,
+  UI_Warning,
+  Font_Warning,
+  Export_Warning,
+  Export_Error,
+  UI_Error,
+  Parser_Error,
+  Trace,
+  Deprecated,
+  Echo
 };
 
-
-std::string getGroupName(const enum message_group& group);
-std::string getGroupColor(const enum message_group& group);
-bool getGroupTextPlain(const enum message_group& group);
+std::string getGroupName (const enum message_group &group);
+std::string getGroupColor (const enum message_group &group);
+bool getGroupTextPlain (const enum message_group &group);
 
 struct Message {
   std::string msg;
@@ -64,25 +76,29 @@ struct Message {
   std::string docPath;
   enum message_group group;
 
-  Message()
-    : msg(""), loc(Location::NONE), docPath(""), group(message_group::NONE)
-  {
+  Message ()
+    : msg ("")
+    , loc (Location::NONE)
+    , docPath ("")
+    , group (message_group::NONE) {
   }
 
-  Message(std::string msg, message_group group = message_group::NONE, Location loc = Location::NONE, std::string docPath = "")
-    : msg(std::move(msg)), loc(std::move(loc)), docPath(std::move(docPath)), group(group)
-  {
+  Message (std::string msg, message_group group = message_group::NONE, Location loc = Location::NONE, std::string docPath = "")
+    : msg (std::move (msg))
+    , loc (std::move (loc))
+    , docPath (std::move (docPath))
+    , group (group) {
   }
 
-  [[nodiscard]] std::string str() const {
-    const auto g = group == message_group::NONE ? "" : getGroupName(group) + ": ";
-    const auto l = loc.isNone() ? "" : " " + loc.toRelativeString(docPath);
+  [[nodiscard]] std::string str () const {
+    const auto g = group == message_group::NONE ? "" : getGroupName (group) + ": ";
+    const auto l = loc.isNone () ? "" : " " + loc.toRelativeString (docPath);
     return g + msg + l;
   }
 };
 
-using OutputHandlerFunc = void (const Message&, void *);
-using OutputHandlerFunc2 = void (const Message&, void *);
+using OutputHandlerFunc = void (const Message &, void *);
+using OutputHandlerFunc2 = void (const Message &, void *);
 
 extern OutputHandlerFunc *outputhandler;
 extern void *outputhandler_data;
@@ -95,24 +111,25 @@ extern int traceDepth;
 extern bool traceUsermoduleParameters;
 extern bool parameterCheck;
 extern bool rangeCheck;
-}
+} // namespace OpenSCAD
 
-void set_output_handler(OutputHandlerFunc *newhandler, OutputHandlerFunc2 *newhandler2, void *userdata);
-void no_exceptions_for_warnings();
-bool would_have_thrown();
+void set_output_handler (OutputHandlerFunc *newhandler, OutputHandlerFunc2 *newhandler2, void *userdata);
+void no_exceptions_for_warnings ();
+bool would_have_thrown ();
 
 extern std::list<std::string> print_messages_stack;
-void print_messages_push();
-void print_messages_pop();
-void resetSuppressedMessages();
-
+void print_messages_push ();
+void print_messages_pop ();
+void resetSuppressedMessages ();
 
 /* PRINT statements come out in same window as ECHO.
    usage: PRINTB("Var1: %s Var2: %i", var1 % var2 ); */
-void PRINT(const Message& msgObj);
+void PRINT (const Message &msgObj);
 
-void PRINT_NOCACHE(const Message& msgObj);
-#define PRINTB_NOCACHE(_fmt, _arg) do { } while (0)
+void PRINT_NOCACHE (const Message &msgObj);
+#define PRINTB_NOCACHE(_fmt, _arg) \
+  do {                             \
+  } while (0)
 // #define PRINTB_NOCACHE(_fmt, _arg) do { PRINT_NOCACHE(str(boost::format(_fmt) % _arg)); } while (0)
 
 /*PRINTD: debugging/verbose output. Usage in code:
@@ -129,15 +146,25 @@ void PRINT_NOCACHE(const Message& msgObj);
    if (OpenSCAD::debug!="") PRINTDB("PolySet dump: %s",ps->dump());
  */
 
-void PRINTDEBUG(const std::string& filename, const std::string& msg);
+void PRINTDEBUG (const std::string &filename, const std::string &msg);
 // NOLINTBEGIN
-#define PRINTD(_arg) do { PRINTDEBUG(std::string(__FILE__), _arg); } while (0)
-#define PRINTDB(_fmt, _arg) do { try { PRINTDEBUG(std::string(__FILE__), str(boost::format(_fmt) % _arg)); } catch (const boost::io::format_error& e) { PRINTDEBUG(std::string(__FILE__), "bad PRINTDB usage"); } } while (0)
+#define PRINTD(_arg)                           \
+  do {                                         \
+    PRINTDEBUG (std::string (__FILE__), _arg); \
+  } while (0)
+#define PRINTDB(_fmt, _arg)                                                   \
+  do {                                                                        \
+    try {                                                                     \
+      PRINTDEBUG (std::string (__FILE__), str (boost::format (_fmt) % _arg)); \
+    } catch (const boost::io::format_error &e) {                              \
+      PRINTDEBUG (std::string (__FILE__), "bad PRINTDB usage");               \
+    }                                                                         \
+  } while (0)
 // NOLINTEND
 
-std::string two_digit_exp_format(std::string doublestr);
-std::string two_digit_exp_format(double x);
-const std::string& quoted_string(const std::string& str);
+std::string two_digit_exp_format (std::string doublestr);
+std::string two_digit_exp_format (double x);
+const std::string &quoted_string (const std::string &str);
 
 // extremely simple logging, eventually replace with something like boost.log
 // usage: logstream out(5); openscad_loglevel=6; out << "hi";
@@ -147,101 +174,100 @@ class logstream
 public:
   std::ostream *out;
   int loglevel;
-  logstream(int level = 0) {
+  logstream (int level = 0) {
     loglevel = level;
     out = &(std::cout);
   }
-  template <typename T> logstream& operator<<(T const& t) {
+  template <typename T>
+  logstream &operator<< (T const &t) {
     if (out && loglevel <= openscad_loglevel) {
       (*out) << t;
-      out->flush();
+      out->flush ();
     }
     return *this;
   }
 };
 
-inline std::string STR(std::ostringstream& oss) {
-  auto s = oss.str();
-  oss.str("");  // clear the string buffer for next STR call
-  oss.clear();  // reset stream error state for next STR call
+inline std::string STR (std::ostringstream &oss) {
+  auto s = oss.str ();
+  oss.str (""); // clear the string buffer for next STR call
+  oss.clear (); // reset stream error state for next STR call
   return s;
 }
 
-template <typename T, typename ... Args>
-std::string STR(std::ostringstream& oss, T&& t, Args&& ... args) {
+template <typename T, typename... Args>
+std::string STR (std::ostringstream &oss, T &&t, Args &&...args) {
   oss << t;
-  return STR(oss, std::forward<Args>(args)...);
+  return STR (oss, std::forward<Args> (args)...);
 }
 
-template <typename T, typename ... Args>
-std::string STR(T&& t, Args&& ... args) {
+template <typename T, typename... Args>
+std::string STR (T &&t, Args &&...args) {
   // using thread_local here so that recursive template does not instantiate excessive ostringstreams
   thread_local std::ostringstream oss;
   oss << t;
-  return STR(oss, std::forward<Args>(args)...);
+  return STR (oss, std::forward<Args> (args)...);
 }
 
-template <typename ... Ts>
+template <typename... Ts>
 class MessageClass
 {
 private:
   std::string fmt;
   std::tuple<Ts...> args;
   template <std::size_t... Is>
-  [[nodiscard]] std::string format(const std::index_sequence<Is...>) const
-  {
+  [[nodiscard]] std::string format (const std::index_sequence<Is...>) const {
 
     std::string s;
     for (int i = 0; fmt[i] != '\0'; i++) {
       if (fmt[i] == '%' && !('0' <= fmt[i + 1] && fmt[i + 1] <= '9')) {
-        s.append("%%");
+        s.append ("%%");
       } else {
-        s.push_back(fmt[i]);
+        s.push_back (fmt[i]);
       }
     }
 
-    boost::format f(s);
-    f.exceptions(boost::io::bad_format_string_bit);
-    static_cast<void>(std::initializer_list<char> {(static_cast<void>(f % std::get<Is>(args)), char{}) ...});
-    return boost::str(f);
+    boost::format f (s);
+    f.exceptions (boost::io::bad_format_string_bit);
+    static_cast<void> (std::initializer_list<char>{(static_cast<void> (f % std::get<Is> (args)), char{})...});
+    return boost::str (f);
   }
 
 public:
-  template <typename ... Args>
-  MessageClass(std::string&& fmt, Args&&... args) : fmt(fmt), args(std::forward<Args>(args)...)
-  {
+  template <typename... Args>
+  MessageClass (std::string &&fmt, Args &&...args)
+    : fmt (fmt)
+    , args (std::forward<Args> (args)...) {
   }
 
-  [[nodiscard]] std::string format() const
-  {
-    return format(std::index_sequence_for<Ts...>{});
+  [[nodiscard]] std::string format () const {
+    return format (std::index_sequence_for<Ts...>{});
   }
 };
 
 extern std::set<std::string> printedDeprecations;
 
-template <typename ... Args>
-void LOG(const message_group& msgGroup, Location loc, std::string docPath, std::string&& f, Args&&... args)
-{
-  auto formatted = MessageClass<Args...>{std::move(f), std::forward<Args>(args)...}.format();
+template <typename... Args>
+void LOG (const message_group &msgGroup, Location loc, std::string docPath, std::string &&f, Args &&...args) {
+  auto formatted = MessageClass<Args...>{std::move (f), std::forward<Args> (args)...}.format ();
 
   //check for deprecations
-  if (msgGroup == message_group::Deprecated && printedDeprecations.find(formatted + loc.toRelativeString(docPath)) != printedDeprecations.end()) return;
-  if (msgGroup == message_group::Deprecated) printedDeprecations.insert(formatted + loc.toRelativeString(docPath));
+  if (msgGroup == message_group::Deprecated && printedDeprecations.find (formatted + loc.toRelativeString (docPath)) != printedDeprecations.end ())
+    return;
+  if (msgGroup == message_group::Deprecated)
+    printedDeprecations.insert (formatted + loc.toRelativeString (docPath));
 
-  Message msgObj{std::move(formatted), msgGroup, std::move(loc), std::move(docPath)};
+  Message msgObj{std::move (formatted), msgGroup, std::move (loc), std::move (docPath)};
 
-  PRINT(msgObj);
+  PRINT (msgObj);
 }
 
-template <typename ... Args>
-void LOG(const message_group& msgGroup, std::string&& f, Args&&... args)
-{
-  LOG(msgGroup, Location::NONE, "", std::move(f), std::forward<Args>(args)...);
+template <typename... Args>
+void LOG (const message_group &msgGroup, std::string &&f, Args &&...args) {
+  LOG (msgGroup, Location::NONE, "", std::move (f), std::forward<Args> (args)...);
 }
 
-template <typename ... Args>
-void LOG(std::string&& f, Args&&... args)
-{
-  LOG(message_group::NONE, Location::NONE, "", std::move(f), std::forward<Args>(args)...);
+template <typename... Args>
+void LOG (std::string &&f, Args &&...args) {
+  LOG (message_group::NONE, Location::NONE, "", std::move (f), std::forward<Args> (args)...);
 }
diff --git a/src/utils/scope_guard.hpp b/src/utils/scope_guard.hpp
index a342287e5..a39e813ba 100644
--- a/src/utils/scope_guard.hpp
+++ b/src/utils/scope_guard.hpp
@@ -42,28 +42,23 @@
 #define SG_NODISCARD
 #endif
 
-namespace sg
-{
-namespace detail
-{
+namespace sg {
+namespace detail {
 /* --- Some custom type traits --- */
 
 // Type trait determining whether a type is callable with no arguments
 template <typename T, typename = void>
 struct is_noarg_callable_t
-  : public std::false_type
-{};     // in general, false
+  : public std::false_type {}; // in general, false
 
 template <typename T>
-struct is_noarg_callable_t<T, decltype(std::declval<T&&>()())>
-  : public std::true_type
-{};     // only true when call expression valid
+struct is_noarg_callable_t<T, decltype (std::declval<T &&> () ())>
+  : public std::true_type {}; // only true when call expression valid
 
 // Type trait determining whether a no-argument callable returns void
 template <typename T>
 struct returns_void_t
-  : public std::is_same<void, decltype(std::declval<T&&>()())>
-{};
+  : public std::is_same<void, decltype (std::declval<T &&> () ())> {};
 
 /* Type trait determining whether a no-arg callable is nothrow invocable if
    required. This is where SG_REQUIRE_NOEXCEPT logic is encapsulated. */
@@ -71,23 +66,22 @@ template <typename T>
 struct is_nothrow_invocable_if_required_t
   : public
 #ifdef SG_REQUIRE_NOEXCEPT
-  std::is_nothrow_invocable<T>         /* Note: _r variants not enough to
+    std::is_nothrow_invocable<T> /* Note: _r variants not enough to
                                           confirm void return: any return can be
                                           discarded so all returns are
                                           compatible with void */
 #else
-  std::true_type
+    std::true_type
 #endif
-{};
+{
+};
 
 // logic AND of two or more type traits
-template <typename A, typename B, typename ... C>
-struct and_t : public and_t<A, and_t<B, C...>>
-{};     // for more than two arguments
+template <typename A, typename B, typename... C>
+struct and_t : public and_t<A, and_t<B, C...>> {}; // for more than two arguments
 
 template <typename A, typename B>
-struct and_t<A, B> : public std::conditional<A::value, B, A>::type
-{};     // for two arguments
+struct and_t<A, B> : public std::conditional<A::value, B, A>::type {}; // for two arguments
 
 // Type trait determining whether a type is a proper scope_guard callback.
 template <typename T>
@@ -95,9 +89,7 @@ struct is_proper_sg_callback_t
   : public and_t<is_noarg_callable_t<T>,
                  returns_void_t<T>,
                  is_nothrow_invocable_if_required_t<T>,
-                 std::is_nothrow_destructible<T>>
-{};
-
+                 std::is_nothrow_destructible<T>> {};
 
 /* --- The actual scope_guard template --- */
 
@@ -106,17 +98,14 @@ template <typename Callback,
             is_proper_sg_callback_t<Callback>::value>::type>
 class scope_guard;
 
-
 /* --- Now the friend maker --- */
 
 template <typename Callback>
-detail::scope_guard<Callback> make_scope_guard(Callback&& callback)
-noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value);     /*
+detail::scope_guard<Callback> make_scope_guard (Callback &&callback) noexcept (std::is_nothrow_constructible<Callback, Callback &&>::value); /*
                                                                              we need this in the inner namespace due to MSVC bugs preventing
                                                                              sg::detail::scope_guard from befriending a sg::make_scope_guard
                                                                              template instance in the parent namespace (see https://is.gd/xFfFhE). */
 
-
 /* --- The template specialization that actually defines the class --- */
 
 template <typename Callback>
@@ -125,87 +114,76 @@ class SG_NODISCARD scope_guard<Callback> final
 public:
   using callback_type = Callback;
 
-  scope_guard(scope_guard&& other)
-  noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value);
+  scope_guard (scope_guard &&other) noexcept (std::is_nothrow_constructible<Callback, Callback &&>::value);
 
-  ~scope_guard() noexcept;     // highlight noexcept dtor
+  ~scope_guard () noexcept; // highlight noexcept dtor
 
-  void dismiss() noexcept;
+  void dismiss () noexcept;
 
 public:
-  scope_guard() = delete;
-  scope_guard(const scope_guard&) = delete;
-  scope_guard& operator=(const scope_guard&) = delete;
-  scope_guard& operator=(scope_guard&&) = delete;
+  scope_guard () = delete;
+  scope_guard (const scope_guard &) = delete;
+  scope_guard &operator= (const scope_guard &) = delete;
+  scope_guard &operator= (scope_guard &&) = delete;
 
 private:
-  explicit scope_guard(Callback&& callback)
-  noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value);     /*
+  explicit scope_guard (Callback &&callback) noexcept (std::is_nothrow_constructible<Callback, Callback &&>::value); /*
                                                                                meant for friends only */
 
-  friend scope_guard<Callback> make_scope_guard<Callback>(Callback&&)
-  noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value);     /*
+  friend scope_guard<Callback> make_scope_guard<Callback> (Callback &&) noexcept (std::is_nothrow_constructible<Callback, Callback &&>::value); /*
                                                                                only make_scope_guard can create scope_guards from scratch (i.e. non-move)
                                                                              */
 
 private:
   Callback m_callback;
   bool m_active;
-
 };
 
-}   // namespace detail
-
+} // namespace detail
 
 /* --- Now the single public maker function --- */
 
-using detail::make_scope_guard;   // see comment on declaration above
+using detail::make_scope_guard; // see comment on declaration above
 
 } // namespace sg
 
 ////////////////////////////////////////////////////////////////////////////////
 template <typename Callback>
-sg::detail::scope_guard<Callback>::scope_guard(Callback&& callback)
-noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value)
-  : m_callback(std::forward<Callback>(callback)) /* use () instead of {} because
+sg::detail::scope_guard<Callback>::scope_guard (Callback &&callback) noexcept (std::is_nothrow_constructible<Callback, Callback &&>::value)
+  : m_callback (std::forward<Callback> (callback)) /* use () instead of {} because
                                                     of DR 1467 (https://is.gd/WHmWuo), which still impacts older compilers
                                                     (e.g. GCC 4.x and clang <=3.6, see https://godbolt.org/g/TE9tPJ and
                                                     https://is.gd/Tsmh8G) */
-  , m_active{true}
-{}
+  , m_active{true} {}
 
 ////////////////////////////////////////////////////////////////////////////////
 template <typename Callback>
-sg::detail::scope_guard<Callback>::scope_guard::~scope_guard() noexcept  /*
+sg::detail::scope_guard<Callback>::scope_guard::~scope_guard () noexcept /*
                                                                             need the extra injected-class-name here to make different compilers happy */
 {
-  if (m_active)m_callback();
+  if (m_active)
+    m_callback ();
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 template <typename Callback>
-sg::detail::scope_guard<Callback>::scope_guard(scope_guard&& other)
-noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value)
-  : m_callback(std::forward<Callback>(other.m_callback)) // idem
-  , m_active{other.m_active}
-{
+sg::detail::scope_guard<Callback>::scope_guard (scope_guard &&other) noexcept (std::is_nothrow_constructible<Callback, Callback &&>::value)
+  : m_callback (std::forward<Callback> (other.m_callback)) // idem
+  , m_active{other.m_active} {
   other.m_active = false;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 template <typename Callback>
-inline void sg::detail::scope_guard<Callback>::dismiss() noexcept
-{
+inline void sg::detail::scope_guard<Callback>::dismiss () noexcept {
   m_active = false;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 template <typename Callback>
-inline auto sg::detail::make_scope_guard(Callback&& callback)
-noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value)
--> detail::scope_guard<Callback>
-{
-  return detail::scope_guard<Callback>{std::forward<Callback>(callback)};
+inline auto sg::detail::make_scope_guard (Callback &&callback) noexcept (std::is_nothrow_constructible<Callback, Callback &&>::value)
+  -> detail::scope_guard<Callback> {
+  return detail::scope_guard<Callback>{std::forward<Callback> (callback)};
 }
 
 #endif /* SCOPE_GUARD_HPP_ */
diff --git a/src/utils/svg.cc b/src/utils/svg.cc
index 2531ea2a3..c146ed89a 100644
--- a/src/utils/svg.cc
+++ b/src/utils/svg.cc
@@ -18,25 +18,22 @@ namespace OpenSCAD {
 int svg_px_width = SVG_PXW;
 int svg_px_height = SVG_PXH;
 
-std::string svg_header(int widthpx, int heightpx)
-{
+std::string svg_header (int widthpx, int heightpx) {
   std::ostringstream out;
   out << "<svg width='" << widthpx << "px' height='" << heightpx << "px'"
       << " xmlns='http://www.w3.org/2000/svg' version='1.1'>\n";
   out << "<!-- please do not write code depending on this format -->\n";
   out << "<!-- it is for debugging only and subject to change  -->\n";
-  return out.str();
+  return out.str ();
 }
 
-std::string svg_label(const std::string& s)
-{
+std::string svg_label (const std::string &s) {
   std::ostringstream out;
   out << "   <text fill='black' x='20' y='40' font-size='24'>" << s << "</text>";
-  return out.str();
+  return out.str ();
 }
 
-std::string svg_styleblock(const std::string& strokewidth)
-{
+std::string svg_styleblock (const std::string &strokewidth) {
   std::ostringstream out;
   // halfedge: f1/f0 = face mark, b1/b0 = body or hole, m1/m0 = halfedge mark
   out << "\
@@ -50,13 +47,12 @@ std::string svg_styleblock(const std::string& strokewidth)
 	.halfedge_f1_b0_m0 { stroke: green; stroke-width: __STROKEW__px } \n\
 	.halfedge_f1_b0_m1 { stroke: green; stroke-width: __STROKEW__px } \n\
 	</style>";
-  auto tmp = out.str();
-  boost::replace_all(tmp, "__STROKEW__", strokewidth);
+  auto tmp = out.str ();
+  boost::replace_all (tmp, "__STROKEW__", strokewidth);
   return tmp;
 }
 
-std::string svg_border()
-{
+std::string svg_border () {
   std::ostringstream out;
   out << " <!-- border -->\n";
   out << "  <polyline points='0,0 "
@@ -65,167 +61,159 @@ std::string svg_border()
       << " 0," << svg_px_height << "'"
       << " style='fill:none;stroke:black' />\n";
   out << " <!-- /border -->";
-  return out.str();
+  return out.str ();
 }
 
-std::string svg_axes()
-{
+std::string svg_axes () {
   std::ostringstream out;
   out << " <!-- axes -->\n";
   out << "  <polyline points='10,455 10,475 10,465 18,465 2,465 10,465 14,461 6,469 10,465'"
       << " style='fill:none;stroke:black;' />\n";
   out << " <!-- /axes -->";
-  return out.str();
+  return out.str ();
 }
 
-CGAL_Nef_polyhedron2::Explorer::Point project_svg_3to2(const CGAL_Point_3& p, const CGAL_Iso_cuboid_3& bbox)
-{
-  CGAL_Kernel3::FT screenw(svg_px_width);
-  CGAL_Kernel3::FT screenh(svg_px_height);
+CGAL_Nef_polyhedron2::Explorer::Point project_svg_3to2 (const CGAL_Point_3 &p, const CGAL_Iso_cuboid_3 &bbox) {
+  CGAL_Kernel3::FT screenw (svg_px_width);
+  CGAL_Kernel3::FT screenh (svg_px_height);
   CGAL_Kernel3::FT screenxc = screenw / 2;
   CGAL_Kernel3::FT screenyc = screenh / 2;
-  CGAL_Kernel3::FT bboxx = (bbox.xmax() - bbox.xmin() );
-  CGAL_Kernel3::FT bboxy = (bbox.ymax() - bbox.ymin() );
-  CGAL_Kernel3::FT bboxz = (bbox.zmax() - bbox.zmin() );
-  CGAL_Kernel3::FT largest_dim = CGAL::max(CGAL::max(bboxx, bboxy), bboxz);
-  CGAL_Kernel3::FT bboxxc = bboxx / 2 + bbox.xmin();
-  CGAL_Kernel3::FT bboxyc = bboxy / 2 + bbox.ymin();
-  CGAL_Kernel3::FT bboxzc = bboxz / 2 + bbox.zmin();
-  CGAL_Kernel3::FT xinbox = (p.x() - bboxxc) / largest_dim;
-  CGAL_Kernel3::FT yinbox = (p.y() - bboxyc) / largest_dim;
-  CGAL_Kernel3::FT zinbox = (p.z() - bboxzc) / largest_dim;
+  CGAL_Kernel3::FT bboxx = (bbox.xmax () - bbox.xmin ());
+  CGAL_Kernel3::FT bboxy = (bbox.ymax () - bbox.ymin ());
+  CGAL_Kernel3::FT bboxz = (bbox.zmax () - bbox.zmin ());
+  CGAL_Kernel3::FT largest_dim = CGAL::max (CGAL::max (bboxx, bboxy), bboxz);
+  CGAL_Kernel3::FT bboxxc = bboxx / 2 + bbox.xmin ();
+  CGAL_Kernel3::FT bboxyc = bboxy / 2 + bbox.ymin ();
+  CGAL_Kernel3::FT bboxzc = bboxz / 2 + bbox.zmin ();
+  CGAL_Kernel3::FT xinbox = (p.x () - bboxxc) / largest_dim;
+  CGAL_Kernel3::FT yinbox = (p.y () - bboxyc) / largest_dim;
+  CGAL_Kernel3::FT zinbox = (p.z () - bboxzc) / largest_dim;
   // do simple fake parallel projection
   CGAL_Kernel3::FT tx = screenxc + xinbox * screenw / 1.618 + yinbox * screenh / 3.2;
   CGAL_Kernel3::FT ty = screenyc - zinbox * screenh / 1.618 - yinbox * screenh / 3.2;
-  return {CGAL::to_double(tx), CGAL::to_double(ty)};
+  return {CGAL::to_double (tx), CGAL::to_double (ty)};
 }
 
-CGAL_Point_2e project_svg_2to2(const CGAL_Point_2e& p, const CGAL_Iso_rectangle_2e& bbox)
-{
+CGAL_Point_2e project_svg_2to2 (const CGAL_Point_2e &p, const CGAL_Iso_rectangle_2e &bbox) {
   double screenw = svg_px_width;
   double screenh = svg_px_height;
   double borderw = screenw * 0.1618;
   double borderh = screenh * 0.1618;
   double vizw = screenw - borderw * 2;
   double vizh = screenh - borderh * 2;
-  double bboxw = CGAL::to_double(bbox.xmax() - bbox.xmin() );
-  double bboxh = CGAL::to_double(bbox.ymax() - bbox.ymin() );
-  double xinbox = CGAL::to_double(p.x() ) - CGAL::to_double(bbox.xmin() );
-  double yinbox = CGAL::to_double(p.y() ) - CGAL::to_double(bbox.ymin() );
-  double tx = borderw + (xinbox / (bboxw == 0?1:bboxw) ) * (vizw);
-  double ty = screenh - borderh - (yinbox / (bboxh == 0?1:bboxh) ) * (vizh);
+  double bboxw = CGAL::to_double (bbox.xmax () - bbox.xmin ());
+  double bboxh = CGAL::to_double (bbox.ymax () - bbox.ymin ());
+  double xinbox = CGAL::to_double (p.x ()) - CGAL::to_double (bbox.xmin ());
+  double yinbox = CGAL::to_double (p.y ()) - CGAL::to_double (bbox.ymin ());
+  double tx = borderw + (xinbox / (bboxw == 0 ? 1 : bboxw)) * (vizw);
+  double ty = screenh - borderh - (yinbox / (bboxh == 0 ? 1 : bboxh)) * (vizh);
   return {tx, ty};
 }
 
-std::string dump_cgal_nef_polyhedron2_face_svg(
+std::string dump_cgal_nef_polyhedron2_face_svg (
   CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator c1,
   CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator c2,
-  const CGAL_Nef_polyhedron2::Explorer& explorer,
-  bool facemark, bool body)
-{
+  const CGAL_Nef_polyhedron2::Explorer &explorer,
+  bool facemark, bool body) {
   std::ostringstream style;
   style << "halfedge_f" << facemark << "_b" << body << "_m";
-  auto styleclass = style.str();
+  auto styleclass = style.str ();
 
   std::ostringstream out;
-  CGAL_For_all(c1, c2) {
-    if (explorer.is_standard(explorer.target(c1))) {
-      auto source = explorer.point(explorer.source(c1) );
-      auto target = explorer.point(explorer.target(c1) );
-      out << "    <!-- Halfedge. Mark: " << c1->mark() << " -->\n";
-      auto he_mark = boost::lexical_cast<std::string>(c1->mark());
+  CGAL_For_all (c1, c2) {
+    if (explorer.is_standard (explorer.target (c1))) {
+      auto source = explorer.point (explorer.source (c1));
+      auto target = explorer.point (explorer.target (c1));
+      out << "    <!-- Halfedge. Mark: " << c1->mark () << " -->\n";
+      auto he_mark = boost::lexical_cast<std::string> (c1->mark ());
       out << "     <line"
-          << " x1='" << CGAL::to_double(source.x()) << "'"
-          << " y1='" << CGAL::to_double(source.y()) << "'"
-          << " x2='" << CGAL::to_double(target.x()) << "'"
-          << " y2='" << CGAL::to_double(target.y()) << "'"
+          << " x1='" << CGAL::to_double (source.x ()) << "'"
+          << " y1='" << CGAL::to_double (source.y ()) << "'"
+          << " x2='" << CGAL::to_double (target.x ()) << "'"
+          << " y2='" << CGAL::to_double (target.y ()) << "'"
           << " class='" << styleclass + he_mark << "' />\n";
     } else {
       out << "     <!-- 2d Nef Rays - not implemented -->\n";
     }
   }
-  return out.str();
+  return out.str ();
 }
 
-static CGAL_Iso_rectangle_2e bounding_box(const CGAL_Nef_polyhedron2& N)
-{
-  auto explorer = N.explorer();
+static CGAL_Iso_rectangle_2e bounding_box (const CGAL_Nef_polyhedron2 &N) {
+  auto explorer = N.explorer ();
   std::vector<CGAL_Point_2e> points;
   // can be optimized by rewriting bounding_box to accept vertices
-  for (auto vi = explorer.vertices_begin(); vi != explorer.vertices_end(); ++vi) {
-    if (explorer.is_standard(vi)) points.push_back(explorer.point(vi));
+  for (auto vi = explorer.vertices_begin (); vi != explorer.vertices_end (); ++vi) {
+    if (explorer.is_standard (vi))
+      points.push_back (explorer.point (vi));
   }
-  if (points.size() > 0) return CGAL::bounding_box(points.begin(), points.end());
+  if (points.size () > 0)
+    return CGAL::bounding_box (points.begin (), points.end ());
   return {0, 0, 0, 0};
 }
 
-std::string dump_svg(const CGAL_Nef_polyhedron2& N)
-{
+std::string dump_svg (const CGAL_Nef_polyhedron2 &N) {
   std::ostringstream out;
-  auto explorer = N.explorer();
-  auto bbox = bounding_box(N);
+  auto explorer = N.explorer ();
+  auto bbox = bounding_box (N);
 
   std::string linewidth = "0.05";
 
   out << "<!--CGAL_Nef_polyhedron2 dump begin-->\n";
-  out << svg_header() << "\n" << svg_styleblock(linewidth) << "\n";
+  out << svg_header () << "\n"
+      << svg_styleblock (linewidth) << "\n";
 
-  for (auto i = explorer.faces_begin(); i != explorer.faces_end(); ++i) {
-    out << "  <!-- face begin. mark: " << i->mark() << "  -->\n";
+  for (auto i = explorer.faces_begin (); i != explorer.faces_end (); ++i) {
+    out << "  <!-- face begin. mark: " << i->mark () << "  -->\n";
     out << "   <!-- body begin -->\n";
-    auto c1(explorer.face_cycle(i));
-    auto c2(c1);
-    out << dump_cgal_nef_polyhedron2_face_svg(c1, c2, explorer, i->mark(), true);
+    auto c1 (explorer.face_cycle (i));
+    auto c2 (c1);
+    out << dump_cgal_nef_polyhedron2_face_svg (c1, c2, explorer, i->mark (), true);
     out << "   <!-- body end -->\n";
 
-    for (auto j = explorer.holes_begin(i); j != explorer.holes_end(i); ++j) {
-      out << "   <!-- hole begin. mark: " << j->mark() << " -->\n";
-      CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator c3(j), c4(c3);
-      out << dump_cgal_nef_polyhedron2_face_svg(c3, c4, explorer, j->mark(), false);
+    for (auto j = explorer.holes_begin (i); j != explorer.holes_end (i); ++j) {
+      out << "   <!-- hole begin. mark: " << j->mark () << " -->\n";
+      CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator c3 (j), c4 (c3);
+      out << dump_cgal_nef_polyhedron2_face_svg (c3, c4, explorer, j->mark (), false);
       out << "   <!-- hole end -->\n";
     }
     out << "  <!-- face end -->\n";
   }
   out << "</svg>";
-  auto tmp = out.str();
-  boost::replace_all(tmp, "'", "\"");
+  auto tmp = out.str ();
+  boost::replace_all (tmp, "'", "\"");
   return tmp;
 }
 
-std::string point_dump(const CGAL_Point_3& p)
-{
+std::string point_dump (const CGAL_Point_3 &p) {
   std::ostringstream out;
-  out << CGAL::to_double(p.x()) << ","
-      << CGAL::to_double(p.y()) << ","
-      << CGAL::to_double(p.z());
-  return out.str();
+  out << CGAL::to_double (p.x ()) << ","
+      << CGAL::to_double (p.y ()) << ","
+      << CGAL::to_double (p.z ());
+  return out.str ();
 }
 
-std::string point_dump(const CGAL::Sphere_point<CGAL_Kernel3>& p)
-{
+std::string point_dump (const CGAL::Sphere_point<CGAL_Kernel3> &p) {
   std::ostringstream out;
-  out << CGAL::to_double(p.x()) << ","
-      << CGAL::to_double(p.y()) << ","
-      << CGAL::to_double(p.z());
-  return out.str();
+  out << CGAL::to_double (p.x ()) << ","
+      << CGAL::to_double (p.y ()) << ","
+      << CGAL::to_double (p.z ());
+  return out.str ();
 }
 
-std::string vert_dump(CGAL_Nef_polyhedron3::Vertex_const_handle vch)
-{
-  return point_dump(vch->point() );
+std::string vert_dump (CGAL_Nef_polyhedron3::Vertex_const_handle vch) {
+  return point_dump (vch->point ());
 }
 
-std::string vert_dump(CGAL_Nef_polyhedron3::Nef_polyhedron_S2::SVertex_const_handle vch)
-{
-  return point_dump(vch->point() );
+std::string vert_dump (CGAL_Nef_polyhedron3::Nef_polyhedron_S2::SVertex_const_handle vch) {
+  return point_dump (vch->point ());
 }
 
 /*
    Dump the 'sphere map' of every vertex in a CGAL Nef Polyhedron3
    see http://doc.cgal.org/latest/Nef_3/index.html
  */
-std::string sphere_map_dump(const CGAL_Nef_polyhedron3& N)
-{
+std::string sphere_map_dump (const CGAL_Nef_polyhedron3 &N) {
   std::ostringstream out;
   using Vertex_const_iterator = CGAL_Nef_polyhedron3::Vertex_const_iterator;
   using Nef_polyhedron_S2 = CGAL_Nef_polyhedron3::Nef_polyhedron_S2;
@@ -237,43 +225,46 @@ std::string sphere_map_dump(const CGAL_Nef_polyhedron3& N)
   Vertex_const_iterator v;
   out << "<!-- sphere map begin -->\n";
   int counter = 0;
-  for (v = N.vertices_begin(); v != N.vertices_end(); ++v) {
+  for (v = N.vertices_begin (); v != N.vertices_end (); ++v) {
     counter++;
     out << "<!-- vertex sphere map begin. vertex counter is " << counter << "\n";
-    out << "     vertex coordinates: " << vert_dump(v) << "-->\n";
-    Nef_polyhedron_S2 S(N.get_sphere_map(v));
+    out << "     vertex coordinates: " << vert_dump (v) << "-->\n";
+    Nef_polyhedron_S2 S (N.get_sphere_map (v));
 
     out << "  vertex sphere map info\n";
-    out << "  number of svertices: " << S.number_of_svertices() << std::endl;
-    out << "  number of shalfedges: " << S.number_of_shalfedges() << std::endl;
-    out << "  number of shalfloops: " << S.number_of_shalfloops() << std::endl;
-    out << "  number of sfaces: " << S.number_of_sfaces() << std::endl;
-    out << "  number of sface cycles: " << S.number_of_sface_cycles() << std::endl;
-    out << "  connected_components: " << S.number_of_connected_components() << "\n";
+    out << "  number of svertices: " << S.number_of_svertices () << std::endl;
+    out << "  number of shalfedges: " << S.number_of_shalfedges () << std::endl;
+    out << "  number of shalfloops: " << S.number_of_shalfloops () << std::endl;
+    out << "  number of sfaces: " << S.number_of_sfaces () << std::endl;
+    out << "  number of sface cycles: " << S.number_of_sface_cycles () << std::endl;
+    out << "  connected_components: " << S.number_of_connected_components () << "\n";
     out << "  integrity check...(asserts if not OK)\n";
-    S.check_integrity_and_topological_planarity();
-// S.print_statistics( out );
+    S.check_integrity_and_topological_planarity ();
+    // S.print_statistics( out );
     int i = 0;
     SFace_const_iterator sf;
-    for (sf = S.sfaces_begin(); sf != S.sfaces_end(); ++sf) {
+    for (sf = S.sfaces_begin (); sf != S.sfaces_end (); ++sf) {
       SFace_cycle_const_iterator it;
       out << " the sface cycles of sface " << i++ << " start with an\n";
-      for (it = sf->sface_cycles_begin(); it != sf->sface_cycles_end(); ++it) {
-        if (it.is_svertex()) out << "  svertex at position "
-                                 << vert_dump(SVertex_const_handle(it) ) << "\n";
-        else if (it.is_shalfedge())
+      for (it = sf->sface_cycles_begin (); it != sf->sface_cycles_end (); ++it) {
+        if (it.is_svertex ())
+          out << "  svertex at position "
+              << vert_dump (SVertex_const_handle (it)) << "\n";
+        else if (it.is_shalfedge ())
           out << "  shalfedge from "
-              << vert_dump(SHalfedge_const_handle(it)->source() ) << " to "
-              << vert_dump(SHalfedge_const_handle(it)->target() ) << std::endl;
-        else if (it.is_shalfloop()) out << "  shalfloop lying in the plane "
-                                        << SHalfloop_const_handle(it)->circle() << std::endl;
-        else out << "  unknown bug\n";
+              << vert_dump (SHalfedge_const_handle (it)->source ()) << " to "
+              << vert_dump (SHalfedge_const_handle (it)->target ()) << std::endl;
+        else if (it.is_shalfloop ())
+          out << "  shalfloop lying in the plane "
+              << SHalfloop_const_handle (it)->circle () << std::endl;
+        else
+          out << "  unknown bug\n";
       }
     }
     out << "\n  vertex sphere map end -->\n";
   }
   out << "<!-- sphere map end -->\n";
-  return out.str();
+  return out.str ();
 }
 
 // This uses the Shell Explorer pattern from the CGAL Manual to dump the 3d Nef Polyhedron information
@@ -283,39 +274,33 @@ class NefPoly3_dumper_svg
 public:
   std::ostringstream out;
   CGAL_Iso_cuboid_3 bbox;
-  NefPoly3_dumper_svg(const CGAL_Nef_polyhedron3& N)
-  {
-    bbox = CGALUtils::boundingBox(N);
+  NefPoly3_dumper_svg (const CGAL_Nef_polyhedron3 &N) {
+    bbox = CGALUtils::boundingBox (N);
   }
-  void visit(CGAL_Nef_polyhedron3::Vertex_const_handle vch)
-  {
-    auto p = vch->point();
-    out << "     <!-- vertex " << point_dump(p) << " -->\n";
+  void visit (CGAL_Nef_polyhedron3::Vertex_const_handle vch) {
+    auto p = vch->point ();
+    out << "     <!-- vertex " << point_dump (p) << " -->\n";
   }
-  void visit(CGAL_Nef_polyhedron3::Halfedge_const_handle)
-  {
+  void visit (CGAL_Nef_polyhedron3::Halfedge_const_handle) {
     out << "  <!-- halfedge --> \n";
   }
-  void visit(CGAL_Nef_polyhedron3::SHalfedge_const_handle)
-  {
+  void visit (CGAL_Nef_polyhedron3::SHalfedge_const_handle) {
     out << "  <!-- shalfedge --> \n";
   }
-  void visit(CGAL_Nef_polyhedron3::SHalfloop_const_handle)
-  {
+  void visit (CGAL_Nef_polyhedron3::SHalfloop_const_handle) {
     out << "  <!-- shalfloop --> \n";
   }
-  void visit(CGAL_Nef_polyhedron3::SFace_const_handle)
-  {
+  void visit (CGAL_Nef_polyhedron3::SFace_const_handle) {
     out << "  <!-- sface --> \n";
   }
-  void visit(CGAL_Nef_polyhedron3::Halffacet_const_handle hfacet)
-  {
+  void visit (CGAL_Nef_polyhedron3::Halffacet_const_handle hfacet) {
     int contour_count = 0;
-    out << "  <!-- Halffacet visit. Mark: " << (*hfacet).mark() << " -->\n";
+    out << "  <!-- Halffacet visit. Mark: " << (*hfacet).mark () << " -->\n";
     std::string color = "gold";
-    if (!(*hfacet).mark()) color = "green";
+    if (!(*hfacet).mark ())
+      color = "green";
     CGAL_Nef_polyhedron3::Halffacet_cycle_const_iterator i;
-    CGAL_forall_facet_cycles_of(i, hfacet) {
+    CGAL_forall_facet_cycles_of (i, hfacet) {
       CGAL_Nef_polyhedron3::SHalfloop_const_handle shl_handle;
       out << "   <!-- Halffacet cycle begin: -->\n";
       if (contour_count == 0) {
@@ -323,24 +308,26 @@ public:
       } else {
         out << "    <!-- Hole contour:--> \n";
       }
-      CGAL_Nef_polyhedron3::SHalfedge_around_facet_const_circulator c1(i), c2(c1);
-      CGAL_For_all(c1, c2) {
+      CGAL_Nef_polyhedron3::SHalfedge_around_facet_const_circulator c1 (i), c2 (c1);
+      CGAL_For_all (c1, c2) {
         // don't know why we use source()->source(), except that's what CGAL does internally
-        auto source = c1->source()->source()->point();
-        auto target = c1->source()->target()->point();
-        auto tp1 = project_svg_3to2(source, bbox);
-        auto tp2 = project_svg_3to2(target, bbox);
-        out << "     <!-- " << CGAL::to_double(source.x()) << ","
-            << CGAL::to_double(source.y()) << ","
-            << CGAL::to_double(source.z()) << " -->\n";
+        auto source = c1->source ()->source ()->point ();
+        auto target = c1->source ()->target ()->point ();
+        auto tp1 = project_svg_3to2 (source, bbox);
+        auto tp2 = project_svg_3to2 (target, bbox);
+        out << "     <!-- " << CGAL::to_double (source.x ()) << ","
+            << CGAL::to_double (source.y ()) << ","
+            << CGAL::to_double (source.z ()) << " -->\n";
         out << "     <line "
-            << "x1='" << CGAL::to_double(tp1.x()) << "' "
-            << "y1='" << CGAL::to_double(tp1.y()) << "' "
-            << "x2='" << CGAL::to_double(tp2.x()) << "' "
-            << "y2='" << CGAL::to_double(tp2.y()) << "' "
+            << "x1='" << CGAL::to_double (tp1.x ()) << "' "
+            << "y1='" << CGAL::to_double (tp1.y ()) << "' "
+            << "x2='" << CGAL::to_double (tp2.x ()) << "' "
+            << "y2='" << CGAL::to_double (tp2.y ()) << "' "
             << " stroke='" << color << "'";
-        if (!(*hfacet).mark()) out << " stroke-dasharray='4 4' />\n";
-        else out << " />\n";
+        if (!(*hfacet).mark ())
+          out << " stroke-dasharray='4 4' />\n";
+        else
+          out << " />\n";
       }
       contour_count++;
       out << "   <!-- Halffacet cycle end -->\n";
@@ -349,48 +336,48 @@ public:
   }
 };
 
-
-std::string dump_svg(const CGAL_Nef_polyhedron3& N)
-{
+std::string dump_svg (const CGAL_Nef_polyhedron3 &N) {
   std::ostringstream out;
   std::string linewidth = "0.05";
   out << "<!--CGAL_Nef_polyhedron3 dump begin-->\n";
-  out << svg_header() << "\n" << svg_border() << "\n";
-  out << svg_styleblock(linewidth) << "\n" << svg_axes() << "\n";
+  out << svg_header () << "\n"
+      << svg_border () << "\n";
+  out << svg_styleblock (linewidth) << "\n"
+      << svg_axes () << "\n";
   out << "\n<!-- CGAL Nef Polyhedron data"
-      << "\nnumber of vertices " << N.number_of_vertices()
-      << "\nnumber of halfedges " << N.number_of_halfedges()
-      << "\nnumber of edges " << N.number_of_edges()
-      << "\nnumber of halffacets " << N.number_of_halffacets()
-      << "\nnumber of facets " << N.number_of_facets()
-      << "\nnumber of volumes " << N.number_of_volumes()
-      << "\nis_simple()? " << N.is_simple()
-      << "\nis_valid()? " << (const_cast<CGAL_Nef_polyhedron3&>(N)).is_valid()
+      << "\nnumber of vertices " << N.number_of_vertices ()
+      << "\nnumber of halfedges " << N.number_of_halfedges ()
+      << "\nnumber of edges " << N.number_of_edges ()
+      << "\nnumber of halffacets " << N.number_of_halffacets ()
+      << "\nnumber of facets " << N.number_of_facets ()
+      << "\nnumber of volumes " << N.number_of_volumes ()
+      << "\nis_simple()? " << N.is_simple ()
+      << "\nis_valid()? " << (const_cast<CGAL_Nef_polyhedron3 &> (N)).is_valid ()
       << "\n -->\n";
   out << "<!-- CGAL Nef Polyhedron sphere map: -->\n";
-  out << sphere_map_dump(N);
+  out << sphere_map_dump (N);
 
   CGAL_Nef_polyhedron3::Volume_const_iterator c;
-  CGAL_forall_volumes(c, N) {
+  CGAL_forall_volumes (c, N) {
     out << " <!--Volume begin-->\n";
-    out << "  <!--Mark: " << (*c).mark() << "-->\n";
+    out << "  <!--Mark: " << (*c).mark () << "-->\n";
     CGAL_Nef_polyhedron3::Shell_entry_const_iterator it;
-    CGAL_forall_shells_of(it, c) {
+    CGAL_forall_shells_of (it, c) {
       out << "  <!--Shell begin-->\n";
-      NefPoly3_dumper_svg dumper_svg(N);
-      N.visit_shell_objects(CGAL_Nef_polyhedron3::SFace_const_handle(it), dumper_svg);
-      out << dumper_svg.out.str();
+      NefPoly3_dumper_svg dumper_svg (N);
+      N.visit_shell_objects (CGAL_Nef_polyhedron3::SFace_const_handle (it), dumper_svg);
+      out << dumper_svg.out.str ();
       out << "  <!--Shell end-->\n";
     }
     out << " <!--Volume end-->\n";
   }
   out << "<!--CGAL_Nef_polyhedron3 dump end-->\n";
   out << "</svg>";
-  auto tmp = out.str();
-  boost::replace_all(tmp, "'", "\"");
+  auto tmp = out.str ();
+  boost::replace_all (tmp, "'", "\"");
   return tmp;
 }
 
-} // namespace
+} // namespace OpenSCAD
 
 #endif // ENABLE_CGAL
diff --git a/src/utils/svg.h b/src/utils/svg.h
index 62ae893dd..8a9cc07e4 100644
--- a/src/utils/svg.h
+++ b/src/utils/svg.h
@@ -16,11 +16,11 @@ extern int svg_cursor_py;
 extern int svg_px_width;
 extern int svg_px_height;
 
-std::string svg_header(int widthpx = SVG_PXW, int heightpx = SVG_PXH);
-std::string svg_label(const std::string& s);
-std::string svg_border();
-std::string svg_axes();
-std::string dump_svg(const CGAL_Nef_polyhedron2& N);
-std::string dump_svg(const CGAL_Nef_polyhedron3& N);
-
-} // namespace
+std::string svg_header (int widthpx = SVG_PXW, int heightpx = SVG_PXH);
+std::string svg_label (const std::string &s);
+std::string svg_border ();
+std::string svg_axes ();
+std::string dump_svg (const CGAL_Nef_polyhedron2 &N);
+std::string dump_svg (const CGAL_Nef_polyhedron3 &N);
+
+} // namespace OpenSCAD
diff --git a/src/utils/version_check.h b/src/utils/version_check.h
index eff3cf315..3f64411d2 100644
--- a/src/utils/version_check.h
+++ b/src/utils/version_check.h
@@ -24,31 +24,27 @@
 #define GMPMAJOR 5
 #define GMPMINOR 0
 #define GMPPATCH 0
-#define SYS_GMP_VER  (__GNU_MP_VERSION * 10000 + __GNU_MP_VERSION_MINOR * 100 + __GNU_MP_VERSION_PATCHLEVEL * 1)
+#define SYS_GMP_VER (__GNU_MP_VERSION * 10000 + __GNU_MP_VERSION_MINOR * 100 + __GNU_MP_VERSION_PATCHLEVEL * 1)
 #if SYS_GMP_VER < GMPMAJOR * 10000 + GMPMINOR * 100 + GMPPATCH * 1
 #error GNU GMP library missing or version too old. See README.md. To force compile, run qmake CONFIG+=skip-version-check
 #else
 
-
 #include <mpfr.h>
 #if MPFR_VERSION < MPFR_VERSION_NUM(3, 0, 0)
 #error GNU MPFR library missing or version too old. See README.md. To force compile, run qmake CONFIG+=skip-version-check
 #else
 
-
 #include <Eigen/Core>
 #if !EIGEN_VERSION_AT_LEAST(3, 0, 0)
 #error eigen library missing or version too old. See README.md. To force compile, run qmake CONFIG+=skip-version-check
 #else
 
-
 #include <boost/version.hpp>
 // boost 1.55 = 105500
 #if BOOST_VERSION < 105500
 #error boost library missing or version too old. See README.md. To force compile, run qmake CONFIG+=skip-version-check
 #else
 
-
 #ifdef ENABLE_CGAL
 #include <CGAL/version.h>
 
@@ -57,7 +53,6 @@
 #endif //ENABLE_CGAL
 #else
 
-
 #if defined(ENABLE_OPENCSG) && defined(OPENCSG_GLEW)
 #include <GL/glew.h>
 // kludge - GLEW doesn't have compiler-accessible version numbering
@@ -65,7 +60,6 @@
 #error GLEW library missing or version too old. See README.md. To force compile, run qmake CONFIG+=skip-version-check
 #else
 
-
 #include <opencsg.h>
 // 1.4.2 -> 0x0142
 #if OPENCSG_VERSION < 0x0142
@@ -73,7 +67,6 @@
 #else
 #endif // ENABLE_OPENCSG
 
-
 #ifndef OPENSCAD_NOGUI
 #include <QtCore/qglobal.h>
 #if QT_VERSION < QT_VERSION_CHECK(5, 12, 0)
@@ -81,7 +74,6 @@
 #endif // QT
 #endif
 
-
 #ifdef ENABLE_OPENCSG
 #endif // OpenCSG
 #endif // GLEW
@@ -97,9 +89,7 @@
 #endif // GMP
 
 // see github issue #552
-#define GCC_VERSION (__GNUC__ * 10000 \
-                     + __GNUC_MINOR__ * 100 \
-                     + __GNUC_PATCHLEVEL__)
+#define GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)
 #if GCC_VERSION == 40802
 #warning "gcc 4.8.2 contains a bug causing a crash in CGAL."
 #endif
diff --git a/src/utils/version_helper.h b/src/utils/version_helper.h
index f578b4f6b..2ae5d9291 100644
--- a/src/utils/version_helper.h
+++ b/src/utils/version_helper.h
@@ -5,34 +5,31 @@
 
 namespace OpenSCAD {
 
-struct library_version_number
-{
+struct library_version_number {
   const unsigned int major;
   const unsigned int minor;
   const unsigned int micro;
 };
 
-const auto get_version_string = [](const library_version_number& header_version, const library_version_number& runtime_version)
-  {
-    std::ostringstream version_stream;
-
-    version_stream << header_version.major << '.' << header_version.minor << '.' << header_version.micro;
-    const bool match = (header_version.major == runtime_version.major && header_version.minor == runtime_version.minor && header_version.micro == runtime_version.micro);
-    if (!match) {
-      version_stream << " (runtime: " << runtime_version.major << '.' << runtime_version.minor << '.' << runtime_version.micro << ')';
-    }
-    return version_stream.str();
-  };
-
-const auto get_version = [](const std::string& header_version, const std::string& runtime_version)
-  {
-    std::ostringstream version_stream;
-
-    version_stream << header_version;
-    if (header_version != runtime_version) {
-      version_stream << " (runtime: " << runtime_version << ')';
-    }
-    return version_stream.str();
-  };
+const auto get_version_string = [] (const library_version_number &header_version, const library_version_number &runtime_version) {
+  std::ostringstream version_stream;
+
+  version_stream << header_version.major << '.' << header_version.minor << '.' << header_version.micro;
+  const bool match = (header_version.major == runtime_version.major && header_version.minor == runtime_version.minor && header_version.micro == runtime_version.micro);
+  if (!match) {
+    version_stream << " (runtime: " << runtime_version.major << '.' << runtime_version.minor << '.' << runtime_version.micro << ')';
+  }
+  return version_stream.str ();
+};
+
+const auto get_version = [] (const std::string &header_version, const std::string &runtime_version) {
+  std::ostringstream version_stream;
+
+  version_stream << header_version;
+  if (header_version != runtime_version) {
+    version_stream << " (runtime: " << runtime_version << ')';
+  }
+  return version_stream.str ();
+};
 
 } // namespace OpenSCAD
diff --git a/src/version.cc b/src/version.cc
index cc27518a5..da12b4273 100644
--- a/src/version.cc
+++ b/src/version.cc
@@ -28,18 +28,17 @@
 
 #include <string>
 
-#define QUOTE(x__) # x__
-#define QUOTED(x__) QUOTE(x__)
+#define QUOTE(x__) #x__
+#define QUOTED(x__) QUOTE (x__)
 
-std::string openscad_shortversionnumber = QUOTED(OPENSCAD_SHORTVERSION);
-std::string openscad_versionnumber = QUOTED(OPENSCAD_VERSION);
+std::string openscad_shortversionnumber = QUOTED (OPENSCAD_SHORTVERSION);
+std::string openscad_versionnumber = QUOTED (OPENSCAD_VERSION);
 
 std::string openscad_displayversionnumber =
 #ifdef OPENSCAD_COMMIT
-  QUOTED(OPENSCAD_VERSION)
-  " (git " QUOTED(OPENSCAD_COMMIT) ")";
+  QUOTED (OPENSCAD_VERSION) " (git " QUOTED (OPENSCAD_COMMIT) ")";
 #else
-  QUOTED(OPENSCAD_SHORTVERSION);
+  QUOTED (OPENSCAD_SHORTVERSION);
 #endif
 
 std::string openscad_detailedversionnumber =
