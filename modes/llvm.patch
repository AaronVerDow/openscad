diff --git a/scripts/beautify.sh b/scripts/beautify.sh
index ed8107a6d..fefe3c624 100755
--- a/scripts/beautify.sh
+++ b/scripts/beautify.sh
@@ -5,7 +5,8 @@ SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
 ROOT_DIR=$SCRIPT_DIR/..
 
 FORMAT_CMD_UNCRUSTIFY="uncrustify -c "$ROOT_DIR/.uncrustify.cfg" --no-backup"
-FORMAT_CMD_CLANG="clang-format --style LLVM" #|GNU|Google|Chromium|Microsoft|Mozilla|WebKit
+#|GNU|Google|Chromium|Microsoft|Mozilla|WebKit
+FORMAT_CMD_CLANG="clang-format -i --style LLVM" 
 FORMAT_CMD=$FORMAT_CMD_CLANG
 
 # Filter out any files that shouldn't be auto-formatted.
diff --git a/src/Cache.h b/src/Cache.h
index 3c801bd5e..433964593 100644
--- a/src/Cache.h
+++ b/src/Cache.h
@@ -44,19 +44,19 @@
 
 #pragma once
 
+#include "utils/printutils.h"
 #include <cstddef>
 #include <unordered_map>
-#include "utils/printutils.h"
 
-template <class Key, class T>
-class Cache
-{
+template <class Key, class T> class Cache {
   struct Node {
-    inline Node() : keyPtr(nullptr), t(nullptr), c(0), p(nullptr), n(nullptr) {
-    }
-    inline Node(T * data, size_t cost) : keyPtr(nullptr), t(data), c(cost), p(nullptr), n(nullptr) {
-    }
-    const Key *keyPtr; T *t; size_t c; Node *p, *n;
+    inline Node() : keyPtr(nullptr), t(nullptr), c(0), p(nullptr), n(nullptr) {}
+    inline Node(T *data, size_t cost)
+        : keyPtr(nullptr), t(data), c(cost), p(nullptr), n(nullptr) {}
+    const Key *keyPtr;
+    T *t;
+    size_t c;
+    Node *p, *n;
   };
   using map_type = typename std::unordered_map<Key, Node>;
   using iterator_type = typename map_type::iterator;
@@ -67,25 +67,33 @@ class Cache
   void *unused{nullptr};
   size_t mx, total{0};
 
-  inline void unlink(Node& n) {
-    if (n.p) n.p->n = n.n;
-    if (n.n) n.n->p = n.p;
-    if (l == &n) l = n.p;
-    if (f == &n) f = n.n;
+  inline void unlink(Node &n) {
+    if (n.p)
+      n.p->n = n.n;
+    if (n.n)
+      n.n->p = n.p;
+    if (l == &n)
+      l = n.p;
+    if (f == &n)
+      f = n.n;
     total -= n.c;
     T *obj = n.t;
     hash.erase(*n.keyPtr);
     delete obj;
   }
-  inline T *relink(const Key& key) {
+  inline T *relink(const Key &key) {
     auto i = hash.find(key);
-    if (i == hash.end()) return nullptr;
+    if (i == hash.end())
+      return nullptr;
 
-    Node& n = i->second;
+    Node &n = i->second;
     if (f != &n) {
-      if (n.p) n.p->n = n.n;
-      if (n.n) n.n->p = n.p;
-      if (l == &n) l = n.p;
+      if (n.p)
+        n.p->n = n.n;
+      if (n.n)
+        n.n->p = n.p;
+      if (l == &n)
+        l = n.p;
       n.p = nullptr;
       n.n = f;
       f->p = &n;
@@ -96,11 +104,14 @@ class Cache
 
 public:
   inline explicit Cache(size_t maxCost = 100)
-    : f(nullptr), l(nullptr), mx(maxCost) { }
+      : f(nullptr), l(nullptr), mx(maxCost) {}
   inline ~Cache() { clear(); }
 
   [[nodiscard]] inline size_t maxCost() const { return mx; }
-  void setMaxCost(size_t m) { mx = m; trim(mx); }
+  void setMaxCost(size_t m) {
+    mx = m;
+    trim(mx);
+  }
   [[nodiscard]] inline size_t totalCost() const { return total; }
 
   [[nodiscard]] inline size_t size() const { return hash.size(); }
@@ -108,28 +119,32 @@ public:
 
   void clear() {
     while (f) {
-      delete f->t; f = f->n;
+      delete f->t;
+      f = f->n;
     }
     hash.clear();
     l = nullptr;
     total = 0;
   }
 
-  bool insert(const Key& key, T *object, size_t cost);
-  T *object(const Key& key) const { return const_cast<Cache<Key, T> *>(this)->relink(key); }
-  inline bool contains(const Key& key) const { return hash.find(key) != hash.end(); }
-  T *operator[](const Key& key) const { return object(key); }
+  bool insert(const Key &key, T *object, size_t cost);
+  T *object(const Key &key) const {
+    return const_cast<Cache<Key, T> *>(this)->relink(key);
+  }
+  inline bool contains(const Key &key) const {
+    return hash.find(key) != hash.end();
+  }
+  T *operator[](const Key &key) const { return object(key); }
 
-  bool remove(const Key& key);
-  T *take(const Key& key);
+  bool remove(const Key &key);
+  T *take(const Key &key);
 
 private:
   void trim(size_t m);
 };
 
 template <class Key, class T>
-inline bool Cache<Key, T>::remove(const Key& key)
-{
+inline bool Cache<Key, T>::remove(const Key &key) {
   auto i = hash.find(key);
   if (i == hash.end()) {
     return false;
@@ -139,13 +154,12 @@ inline bool Cache<Key, T>::remove(const Key& key)
   }
 }
 
-template <class Key, class T>
-inline T *Cache<Key, T>::take(const Key& key)
-{
+template <class Key, class T> inline T *Cache<Key, T>::take(const Key &key) {
   iterator_type i = hash.find(key);
-  if (i == hash.end()) return 0;
+  if (i == hash.end())
+    return 0;
 
-  Node& n = *i;
+  Node &n = *i;
   T *t = n.t;
   n.t = 0;
   unlink(n);
@@ -153,8 +167,7 @@ inline T *Cache<Key, T>::take(const Key& key)
 }
 
 template <class Key, class T>
-bool Cache<Key, T>::insert(const Key& akey, T *aobject, size_t acost)
-{
+bool Cache<Key, T>::insert(const Key &akey, T *aobject, size_t acost) {
   remove(akey);
   if (acost > mx) {
     delete aobject;
@@ -167,16 +180,16 @@ bool Cache<Key, T>::insert(const Key& akey, T *aobject, size_t acost)
   total += acost;
   Node *n = &i->second;
   n->keyPtr = &i->first;
-  if (f) f->p = n;
+  if (f)
+    f->p = n;
   n->n = f;
   f = n;
-  if (!l) l = f;
+  if (!l)
+    l = f;
   return true;
 }
 
-template <class Key, class T>
-void Cache<Key, T>::trim(size_t m)
-{
+template <class Key, class T> void Cache<Key, T>::trim(size_t m) {
   Node *n = l;
   while (n && total > m) {
     Node *u = n;
diff --git a/src/Feature.cc b/src/Feature.cc
index 6b0075a7a..7ad133573 100644
--- a/src/Feature.cc
+++ b/src/Feature.cc
@@ -15,8 +15,8 @@
  * NOTE: All features double-register pointers to themselves in these two
  * structures, and can be accessed from either.
  */
-Feature::map_t Feature::feature_map;  // Double-listed values. ----v
-Feature::list_t Feature::feature_list;  // Double-listed values. --^
+Feature::map_t Feature::feature_map;   // Double-listed values. ----v
+Feature::list_t Feature::feature_list; // Double-listed values. --^
 
 /*
  * List of features, the names given here are used in both command line
@@ -27,36 +27,44 @@ Feature::list_t Feature::feature_list;  // Double-listed values. --^
  * const Features listed below.
  */
 const Feature Feature::ExperimentalRoof("roof", "Enable <code>roof</code>");
-const Feature Feature::ExperimentalInputDriverDBus("input-driver-dbus", "Enable DBus input drivers (requires restart)");
-const Feature Feature::ExperimentalLazyUnion("lazy-union", "Enable lazy unions.");
-const Feature Feature::ExperimentalVxORenderersIndexing("vertex-object-renderers-indexing", "Enable indexing in vertex object renderers");
-const Feature Feature::ExperimentalTextMetricsFunctions("textmetrics", "Enable the <code>textmetrics()</code> and <code>fontmetrics()</code> functions.");
-const Feature Feature::ExperimentalImportFunction("import-function", "Enable import function returning data instead of geometry.");
-const Feature Feature::ExperimentalObjectFunction("object-function", "Enable object function to allow user creation of objects.");
-const Feature Feature::ExperimentalPredictibleOutput("predictible-output", "Attempt to produce predictible, diffable outputs (e.g. sorting the STL, or remeshing in a determined order)");
+const Feature Feature::ExperimentalInputDriverDBus(
+    "input-driver-dbus", "Enable DBus input drivers (requires restart)");
+const Feature Feature::ExperimentalLazyUnion("lazy-union",
+                                             "Enable lazy unions.");
+const Feature Feature::ExperimentalVxORenderersIndexing(
+    "vertex-object-renderers-indexing",
+    "Enable indexing in vertex object renderers");
+const Feature Feature::ExperimentalTextMetricsFunctions(
+    "textmetrics", "Enable the <code>textmetrics()</code> and "
+                   "<code>fontmetrics()</code> functions.");
+const Feature Feature::ExperimentalImportFunction(
+    "import-function",
+    "Enable import function returning data instead of geometry.");
+const Feature Feature::ExperimentalObjectFunction(
+    "object-function",
+    "Enable object function to allow user creation of objects.");
+const Feature Feature::ExperimentalPredictibleOutput(
+    "predictible-output",
+    "Attempt to produce predictible, diffable outputs (e.g. sorting the STL, "
+    "or remeshing in a determined order)");
 #ifdef ENABLE_PYTHON
-const Feature Feature::ExperimentalPythonEngine("python-engine", "Enable experimental Python Engine (implies risk of malicious scripts downloaded).");
+const Feature Feature::ExperimentalPythonEngine(
+    "python-engine", "Enable experimental Python Engine (implies risk of "
+                     "malicious scripts downloaded).");
 #endif
 
-Feature::Feature(const std::string& name, std::string description, bool hidden)
-  : name(name), description(std::move(description))
-{
+Feature::Feature(const std::string &name, std::string description, bool hidden)
+    : name(name), description(std::move(description)) {
   feature_map[name] = this;
-  if (!hidden) feature_list.push_back(this);
+  if (!hidden)
+    feature_list.push_back(this);
 }
 
-const std::string& Feature::get_name() const
-{
-  return name;
-}
+const std::string &Feature::get_name() const { return name; }
 
-const std::string& Feature::get_description() const
-{
-  return description;
-}
+const std::string &Feature::get_description() const { return description; }
 
-bool Feature::is_enabled() const
-{
+bool Feature::is_enabled() const {
 #ifdef ENABLE_EXPERIMENTAL
   return enabled;
 #else
@@ -64,57 +72,48 @@ bool Feature::is_enabled() const
 #endif
 }
 
-void Feature::enable(bool status)
-{
-  enabled = status;
-}
+void Feature::enable(bool status) { enabled = status; }
 
 // Note, features are also accessed by iterator with begin/end.
-void Feature::enable_feature(const std::string& feature_name, bool status)
-{
+void Feature::enable_feature(const std::string &feature_name, bool status) {
   auto it = feature_map.find(feature_name);
   if (it != feature_map.end()) {
     it->second->enable(status);
   } else {
-    LOG(message_group::Warning, "Ignoring request to enable unknown feature '%1$s'.", feature_name);
+    LOG(message_group::Warning,
+        "Ignoring request to enable unknown feature '%1$s'.", feature_name);
   }
 }
 
-void Feature::enable_all(bool status)
-{
-  for (const auto& f : boost::make_iterator_range(Feature::begin(), Feature::end())) {
+void Feature::enable_all(bool status) {
+  for (const auto &f :
+       boost::make_iterator_range(Feature::begin(), Feature::end())) {
     f->enable(status);
   }
 }
 
-Feature::iterator Feature::begin()
-{
-  return feature_list.begin();
-}
+Feature::iterator Feature::begin() { return feature_list.begin(); }
 
-Feature::iterator Feature::end()
-{
-  return feature_list.end();
-}
+Feature::iterator Feature::end() { return feature_list.end(); }
 
-std::string Feature::features()
-{
+std::string Feature::features() {
   const auto seq = boost::make_iterator_range(Feature::begin(), Feature::end());
   const auto str = [](const Feature *const f) {
-      return (boost::format("%s%s") % f->get_name() % (f->is_enabled() ? "*" : "")).str();
-    };
+    return (boost::format("%s%s") % f->get_name() %
+            (f->is_enabled() ? "*" : ""))
+        .str();
+  };
   return boost::algorithm::join(boost::adaptors::transform(seq, str), ", ");
 }
 
-ExperimentalFeatureException::ExperimentalFeatureException(const std::string& what_arg)
-  : EvaluationException(what_arg)
-{
-
-}
+ExperimentalFeatureException::ExperimentalFeatureException(
+    const std::string &what_arg)
+    : EvaluationException(what_arg) {}
 
-void ExperimentalFeatureException::check(const Feature& feature)
-{
+void ExperimentalFeatureException::check(const Feature &feature) {
   if (!feature.is_enabled()) {
-    throw ExperimentalFeatureException(STR("ERROR: Experimental feature not enabled: '", feature.get_name(), "'. Please check preferences."));
+    throw ExperimentalFeatureException(
+        STR("ERROR: Experimental feature not enabled: '", feature.get_name(),
+            "'. Please check preferences."));
   }
 }
diff --git a/src/Feature.h b/src/Feature.h
index d475de6f9..537474391 100644
--- a/src/Feature.h
+++ b/src/Feature.h
@@ -1,13 +1,12 @@
 #pragma once
 
-#include <string>
 #include <map>
+#include <string>
 #include <vector>
 
 #include "utils/exceptions.h"
 
-class Feature
-{
+class Feature {
 public:
   using list_t = std::vector<Feature *>;
   using iterator = list_t::iterator;
@@ -25,13 +24,13 @@ public:
 #endif
 
 #ifdef ENABLE_GUI_TESTS
-  static constexpr bool HasGuiTesting {true};
+  static constexpr bool HasGuiTesting{true};
 #else
-  static constexpr bool HasGuiTesting {false};
+  static constexpr bool HasGuiTesting{false};
 #endif
 
-  [[nodiscard]] const std::string& get_name() const;
-  [[nodiscard]] const std::string& get_description() const;
+  [[nodiscard]] const std::string &get_name() const;
+  [[nodiscard]] const std::string &get_description() const;
 
   [[nodiscard]] bool is_enabled() const;
   void enable(bool status);
@@ -40,7 +39,8 @@ public:
   static iterator end();
 
   static std::string features();
-  static void enable_feature(const std::string& feature_name, bool status = true);
+  static void enable_feature(const std::string &feature_name,
+                             bool status = true);
   static void enable_all(bool status = true);
 
 private:
@@ -53,15 +53,15 @@ private:
   static map_t feature_map;
   static list_t feature_list;
 
-  Feature(const std::string& name, std::string description, bool hidden = false);
+  Feature(const std::string &name, std::string description,
+          bool hidden = false);
   virtual ~Feature() = default;
 };
 
-class ExperimentalFeatureException : public EvaluationException
-{
+class ExperimentalFeatureException : public EvaluationException {
 public:
-  static void check(const Feature& feature);
+  static void check(const Feature &feature);
 
 private:
-  ExperimentalFeatureException(const std::string& what_arg);
+  ExperimentalFeatureException(const std::string &what_arg);
 };
diff --git a/src/FontCache.cc b/src/FontCache.cc
index 39f440729..23ce455dc 100644
--- a/src/FontCache.cc
+++ b/src/FontCache.cc
@@ -27,8 +27,8 @@
 #include "FontCache.h"
 
 #include <cassert>
-#include <cstdlib>
 #include <cstdint>
+#include <cstdlib>
 #include <ctime>
 #include <filesystem>
 #include <iostream>
@@ -37,9 +37,9 @@
 #include <vector>
 
 #include <boost/algorithm/string.hpp>
-#include <hb.h>
 #include <fontconfig/fontconfig.h>
 #include <ft2build.h>
+#include <hb.h>
 #include FT_FREETYPE_H
 #include FT_TYPES_H
 #include FT_TRUETYPE_IDS_H
@@ -53,37 +53,36 @@ std::vector<std::string> fontpath;
 
 namespace fs = std::filesystem;
 
-std::string get_fontconfig_version()
-{
+std::string get_fontconfig_version() {
   const unsigned int version = FcGetVersion();
 
-  const OpenSCAD::library_version_number header_version{FC_MAJOR, FC_MINOR, FC_REVISION};
-  const OpenSCAD::library_version_number runtime_version{version / 10000, (version / 100) % 100, version % 100};
+  const OpenSCAD::library_version_number header_version{FC_MAJOR, FC_MINOR,
+                                                        FC_REVISION};
+  const OpenSCAD::library_version_number runtime_version{
+      version / 10000, (version / 100) % 100, version % 100};
   return OpenSCAD::get_version_string(header_version, runtime_version);
 }
 
-std::string get_harfbuzz_version()
-{
+std::string get_harfbuzz_version() {
   unsigned int major, minor, micro;
   hb_version(&major, &minor, &micro);
 
-  const OpenSCAD::library_version_number header_version{HB_VERSION_MAJOR, HB_VERSION_MINOR, HB_VERSION_MICRO};
+  const OpenSCAD::library_version_number header_version{
+      HB_VERSION_MAJOR, HB_VERSION_MINOR, HB_VERSION_MICRO};
   const OpenSCAD::library_version_number runtime_version{major, minor, micro};
   return OpenSCAD::get_version_string(header_version, runtime_version);
 }
 
-std::string get_freetype_version()
-{
+std::string get_freetype_version() {
   return FontCache::instance()->get_freetype_version();
 }
 
-FontInfo::FontInfo(std::string family, std::string style, std::string file, uint32_t hash)
-  : family(std::move(family)), style(std::move(style)), file(std::move(file)), hash(hash)
-{
-}
+FontInfo::FontInfo(std::string family, std::string style, std::string file,
+                   uint32_t hash)
+    : family(std::move(family)), style(std::move(style)), file(std::move(file)),
+      hash(hash) {}
 
-bool FontInfo::operator<(const FontInfo& rhs) const
-{
+bool FontInfo::operator<(const FontInfo &rhs) const {
   if (family < rhs.family) {
     return true;
   }
@@ -93,28 +92,17 @@ bool FontInfo::operator<(const FontInfo& rhs) const
   return file < rhs.file;
 }
 
-const std::string& FontInfo::get_family() const
-{
-  return family;
-}
+const std::string &FontInfo::get_family() const { return family; }
 
-const std::string& FontInfo::get_style() const
-{
-  return style;
-}
+const std::string &FontInfo::get_style() const { return style; }
 
-const std::string& FontInfo::get_file() const
-{
-  return file;
-}
+const std::string &FontInfo::get_file() const { return file; }
 
-const uint32_t FontInfo::get_hash() const
-{
-  return hash;
-}
+const uint32_t FontInfo::get_hash() const { return hash; }
 
 FontCache *FontCache::self = nullptr;
-FontCache::InitHandlerFunc *FontCache::cb_handler = FontCache::defaultInitHandler;
+FontCache::InitHandlerFunc *FontCache::cb_handler =
+    FontCache::defaultInitHandler;
 void *FontCache::cb_userdata = nullptr;
 const std::string FontCache::DEFAULT_FONT("Liberation Sans:style=Regular");
 
@@ -123,29 +111,29 @@ const std::string FontCache::DEFAULT_FONT("Liberation Sans:style=Regular");
  * handler is registered, the cache build is just called synchronously in the
  * current thread by this handler.
  */
-void FontCache::defaultInitHandler(FontCacheInitializer *initializer, void *)
-{
+void FontCache::defaultInitHandler(FontCacheInitializer *initializer, void *) {
   initializer->run();
 }
 
-FontCache::FontCache()
-{
+FontCache::FontCache() {
   this->init_ok = false;
   this->library = nullptr;
 
-  // If we've got a bundled fonts.conf, initialize fontconfig with our own config
-  // by overriding the built-in fontconfig path.
-  // For system installs and dev environments, we leave this alone
+  // If we've got a bundled fonts.conf, initialize fontconfig with our own
+  // config by overriding the built-in fontconfig path. For system installs and
+  // dev environments, we leave this alone
   const fs::path fontdir(PlatformUtils::resourcePath("fonts"));
   if (fs::is_regular_file(fontdir / "fonts.conf")) {
     auto abspath = fontdir.empty() ? fs::current_path() : fs::absolute(fontdir);
-    PlatformUtils::setenv("FONTCONFIG_PATH", (abspath.generic_string()).c_str(), 0);
+    PlatformUtils::setenv("FONTCONFIG_PATH", (abspath.generic_string()).c_str(),
+                          0);
   }
 
   // Just load the configs. We'll build the fonts once all configs are loaded
   this->config = FcInitLoadConfig();
   if (!this->config) {
-    LOG(message_group::Font_Warning, "Can't initialize fontconfig library, text() objects will not be rendered");
+    LOG(message_group::Font_Warning, "Can't initialize fontconfig library, "
+                                     "text() objects will not be rendered");
     return;
   }
 
@@ -155,7 +143,10 @@ FontCache::FontCache()
 #ifndef __EMSCRIPTEN__
     builtinfontpath = fs::canonical(builtinfontpath);
 #endif
-    FcConfigParseAndLoad(this->config, reinterpret_cast<const FcChar8 *>(builtinfontpath.generic_string().c_str()), false);
+    FcConfigParseAndLoad(this->config,
+                         reinterpret_cast<const FcChar8 *>(
+                             builtinfontpath.generic_string().c_str()),
+                         false);
     add_font_dir(builtinfontpath.generic_string());
   }
 
@@ -172,7 +163,9 @@ FontCache::FontCache()
     std::string paths(env_font_path);
     const std::string sep = PlatformUtils::pathSeparatorChar();
     using string_split_iterator = boost::split_iterator<std::string::iterator>;
-    for (string_split_iterator it = boost::make_split_iterator(paths, boost::first_finder(sep, boost::is_iequal())); it != string_split_iterator(); ++it) {
+    for (string_split_iterator it = boost::make_split_iterator(
+             paths, boost::first_finder(sep, boost::is_iequal()));
+         it != string_split_iterator(); ++it) {
       const fs::path p(boost::copy_range<std::string>(*it));
       if (fs::exists(p) && fs::is_directory(p)) {
         const std::string path = fs::absolute(p).string();
@@ -193,23 +186,22 @@ FontCache::FontCache()
 
   const FT_Error error = FT_Init_FreeType(&this->library);
   if (error) {
-    LOG(message_group::Font_Warning, "Can't initialize freetype library, text() objects will not be rendered");
+    LOG(message_group::Font_Warning, "Can't initialize freetype library, "
+                                     "text() objects will not be rendered");
     return;
   }
 
   this->init_ok = true;
 }
 
-FontCache *FontCache::instance()
-{
+FontCache *FontCache::instance() {
   if (!self) {
     self = new FontCache();
   }
   return self;
 }
 
-const std::string FontCache::get_freetype_version() const
-{
+const std::string FontCache::get_freetype_version() const {
   if (!this->is_init_ok()) {
     return "(not initialized)";
   }
@@ -217,37 +209,40 @@ const std::string FontCache::get_freetype_version() const
   FT_Int major, minor, micro;
   FT_Library_Version(this->library, &major, &minor, &micro);
 
-  const OpenSCAD::library_version_number header_version{FREETYPE_MAJOR, FREETYPE_MINOR, FREETYPE_PATCH};
-  const OpenSCAD::library_version_number runtime_version{static_cast<unsigned>(major), static_cast<unsigned>(minor), static_cast<unsigned>(micro)};
+  const OpenSCAD::library_version_number header_version{
+      FREETYPE_MAJOR, FREETYPE_MINOR, FREETYPE_PATCH};
+  const OpenSCAD::library_version_number runtime_version{
+      static_cast<unsigned>(major), static_cast<unsigned>(minor),
+      static_cast<unsigned>(micro)};
   return OpenSCAD::get_version_string(header_version, runtime_version);
 }
 
-void FontCache::registerProgressHandler(InitHandlerFunc *handler, void *userdata)
-{
+void FontCache::registerProgressHandler(InitHandlerFunc *handler,
+                                        void *userdata) {
   FontCache::cb_handler = handler;
   FontCache::cb_userdata = userdata;
 }
 
-void FontCache::register_font_file(const std::string& path)
-{
-  if (!FcConfigAppFontAddFile(this->config, reinterpret_cast<const FcChar8 *>(path.c_str()))) {
+void FontCache::register_font_file(const std::string &path) {
+  if (!FcConfigAppFontAddFile(
+          this->config, reinterpret_cast<const FcChar8 *>(path.c_str()))) {
     LOG("Can't register font '%1$s'", path);
   }
 }
 
-void FontCache::add_font_dir(const std::string& path)
-{
+void FontCache::add_font_dir(const std::string &path) {
   if (!fs::is_directory(path)) {
     return;
   }
-  if (!FcConfigAppFontAddDir(this->config, reinterpret_cast<const FcChar8 *>(path.c_str()))) {
+  if (!FcConfigAppFontAddDir(this->config,
+                             reinterpret_cast<const FcChar8 *>(path.c_str()))) {
     LOG("Can't register font directory '%1$s'", path);
   }
 }
 
-std::vector<uint32_t> FontCache::filter(const std::u32string& str) const
-{
-  FcObjectSet *object_set = FcObjectSetBuild(FC_FAMILY, FC_STYLE, FC_FILE, nullptr);
+std::vector<uint32_t> FontCache::filter(const std::u32string &str) const {
+  FcObjectSet *object_set =
+      FcObjectSetBuild(FC_FAMILY, FC_STYLE, FC_FILE, nullptr);
   FcPattern *pattern = FcPatternCreate();
   init_pattern(pattern);
   FcCharSet *charSet = FcCharSetCreate();
@@ -273,9 +268,9 @@ std::vector<uint32_t> FontCache::filter(const std::u32string& str) const
   return result;
 }
 
-FontInfoList *FontCache::list_fonts() const
-{
-  FcObjectSet *object_set = FcObjectSetBuild(FC_FAMILY, FC_STYLE, FC_FILE, nullptr);
+FontInfoList *FontCache::list_fonts() const {
+  FcObjectSet *object_set =
+      FcObjectSetBuild(FC_FAMILY, FC_STYLE, FC_FILE, nullptr);
   FcPattern *pattern = FcPatternCreate();
   init_pattern(pattern);
   FcFontSet *font_set = FcFontList(this->config, pattern, object_set);
@@ -301,9 +296,9 @@ FontInfoList *FontCache::list_fonts() const
       continue;
     }
 
-    const std::string family((const char *) family_value);
-    const std::string style((const char *) style_value);
-    const std::string file((const char *) file_value);
+    const std::string family((const char *)family_value);
+    const std::string style((const char *)style_value);
+    const std::string file((const char *)file_value);
 
     list->emplace_back(family, style, file, FcPatternHash(p));
   }
@@ -312,27 +307,19 @@ FontInfoList *FontCache::list_fonts() const
   return list;
 }
 
-bool FontCache::is_init_ok() const
-{
-  return this->init_ok;
-}
+bool FontCache::is_init_ok() const { return this->init_ok; }
 
-void FontCache::clear()
-{
-  this->cache.clear();
-}
+void FontCache::clear() { this->cache.clear(); }
 
-void FontCache::dump_cache(const std::string& info)
-{
+void FontCache::dump_cache(const std::string &info) {
   std::cout << info << ":";
-  for (const auto& item : this->cache) {
+  for (const auto &item : this->cache) {
     std::cout << " " << item.first << " (" << item.second.second << ")";
   }
   std::cout << std::endl;
 }
 
-void FontCache::check_cleanup()
-{
+void FontCache::check_cleanup() {
   if (this->cache.size() < MAX_NR_OF_CACHE_ENTRIES) {
     return;
   }
@@ -347,8 +334,7 @@ void FontCache::check_cleanup()
   this->cache.erase(pos);
 }
 
-FontFacePtr FontCache::get_font(const std::string& font)
-{
+FontFacePtr FontCache::get_font(const std::string &font) {
   FontFacePtr face;
   auto it = this->cache.find(font);
   if (it == this->cache.end()) {
@@ -364,8 +350,7 @@ FontFacePtr FontCache::get_font(const std::string& font)
   return face;
 }
 
-FontFacePtr FontCache::find_face(const std::string& font) const
-{
+FontFacePtr FontCache::find_face(const std::string &font) const {
   std::string trimmed(font);
   boost::algorithm::trim(trimmed);
 
@@ -373,27 +358,26 @@ FontFacePtr FontCache::find_face(const std::string& font) const
   PRINTDB("font = \"%s\", lookup = \"%s\"", font % lookup);
   FontFacePtr face = find_face_fontconfig(lookup);
   if (face) {
-    PRINTDB("result = \"%s\", style = \"%s\"", face->face_->family_name % face->face_->style_name);
+    PRINTDB("result = \"%s\", style = \"%s\"",
+            face->face_->family_name % face->face_->style_name);
   } else {
     PRINTD("font not found");
   }
   return face;
 }
 
-void FontCache::init_pattern(FcPattern *pattern) const
-{
+void FontCache::init_pattern(FcPattern *pattern) const {
   assert(pattern);
   const FcValue true_value = {
-    .type = FcTypeBool,
-    .u = {.b = true},
+      .type = FcTypeBool,
+      .u = {.b = true},
   };
 
   FcPatternAdd(pattern, FC_OUTLINE, true_value, true);
   FcPatternAdd(pattern, FC_SCALABLE, true_value, true);
 }
 
-FontFacePtr FontCache::find_face_fontconfig(const std::string& font) const
-{
+FontFacePtr FontCache::find_face_fontconfig(const std::string &font) const {
   FcResult result;
 
   FcPattern *pattern = FcNameParse((unsigned char *)font.c_str());
@@ -420,13 +404,15 @@ FontFacePtr FontCache::find_face_fontconfig(const std::string& font) const
 
   FcChar8 *font_features;
   std::string font_features_str;
-  if (FcPatternGetString(match, FC_FONT_FEATURES, 0, &font_features) == FcResultMatch) {
+  if (FcPatternGetString(match, FC_FONT_FEATURES, 0, &font_features) ==
+      FcResultMatch) {
     font_features_str = (const char *)(font_features);
     PRINTDB("Found font features: '%s'", font_features_str);
   }
 
   FT_Face ftFace;
-  const FT_Error error = FT_New_Face(this->library, (const char *)file_value, font_index, &ftFace);
+  const FT_Error error =
+      FT_New_Face(this->library, (const char *)file_value, font_index, &ftFace);
 
   FcPatternDestroy(pattern);
   FcPatternDestroy(match);
@@ -441,36 +427,54 @@ FontFacePtr FontCache::find_face_fontconfig(const std::string& font) const
 
   for (int a = 0; a < face->face_->num_charmaps; ++a) {
     FT_CharMap charmap = face->face_->charmaps[a];
-    PRINTDB("charmap = %d: platform = %d, encoding = %d", a % charmap->platform_id % charmap->encoding_id);
+    PRINTDB("charmap = %d: platform = %d, encoding = %d",
+            a % charmap->platform_id % charmap->encoding_id);
   }
 
   if (FT_Select_Charmap(face->face_, ft_encoding_unicode) == 0) {
-    PRINTDB("Successfully selected unicode charmap: %s/%s", face->face_->family_name % face->face_->style_name);
+    PRINTDB("Successfully selected unicode charmap: %s/%s",
+            face->face_->family_name % face->face_->style_name);
   } else {
     bool charmap_set = false;
-    if (!charmap_set) charmap_set = try_charmap(face, TT_PLATFORM_MICROSOFT, TT_MS_ID_UNICODE_CS);
-    if (!charmap_set) charmap_set = try_charmap(face, TT_PLATFORM_ISO, TT_ISO_ID_10646);
-    if (!charmap_set) charmap_set = try_charmap(face, TT_PLATFORM_APPLE_UNICODE, -1);
-    if (!charmap_set) charmap_set = try_charmap(face, TT_PLATFORM_MICROSOFT, TT_MS_ID_SYMBOL_CS);
-    if (!charmap_set) charmap_set = try_charmap(face, TT_PLATFORM_MACINTOSH, TT_MAC_ID_ROMAN);
-    if (!charmap_set) charmap_set = try_charmap(face, TT_PLATFORM_ISO, TT_ISO_ID_8859_1);
-    if (!charmap_set) charmap_set = try_charmap(face, TT_PLATFORM_ISO, TT_ISO_ID_7BIT_ASCII);
-    if (!charmap_set) LOG(message_group::Font_Warning, "Could not select a char map for font '%1$s/%2$s'", face->face_->family_name, face->face_->style_name);
+    if (!charmap_set)
+      charmap_set =
+          try_charmap(face, TT_PLATFORM_MICROSOFT, TT_MS_ID_UNICODE_CS);
+    if (!charmap_set)
+      charmap_set = try_charmap(face, TT_PLATFORM_ISO, TT_ISO_ID_10646);
+    if (!charmap_set)
+      charmap_set = try_charmap(face, TT_PLATFORM_APPLE_UNICODE, -1);
+    if (!charmap_set)
+      charmap_set =
+          try_charmap(face, TT_PLATFORM_MICROSOFT, TT_MS_ID_SYMBOL_CS);
+    if (!charmap_set)
+      charmap_set = try_charmap(face, TT_PLATFORM_MACINTOSH, TT_MAC_ID_ROMAN);
+    if (!charmap_set)
+      charmap_set = try_charmap(face, TT_PLATFORM_ISO, TT_ISO_ID_8859_1);
+    if (!charmap_set)
+      charmap_set = try_charmap(face, TT_PLATFORM_ISO, TT_ISO_ID_7BIT_ASCII);
+    if (!charmap_set)
+      LOG(message_group::Font_Warning,
+          "Could not select a char map for font '%1$s/%2$s'",
+          face->face_->family_name, face->face_->style_name);
   }
 
   return face;
 }
 
-bool FontCache::try_charmap(const FontFacePtr& face_ptr, int platform_id, int encoding_id) const
-{
+bool FontCache::try_charmap(const FontFacePtr &face_ptr, int platform_id,
+                            int encoding_id) const {
   FT_Face face = face_ptr->face_;
   for (int idx = 0; idx < face->num_charmaps; ++idx) {
     FT_CharMap charmap = face->charmaps[idx];
-    if ((charmap->platform_id == platform_id) && ((encoding_id < 0) || (charmap->encoding_id == encoding_id))) {
+    if ((charmap->platform_id == platform_id) &&
+        ((encoding_id < 0) || (charmap->encoding_id == encoding_id))) {
       if (FT_Set_Charmap(face, charmap) == 0) {
-        PRINTDB("Selected charmap: platform_id = %d, encoding_id = %d", charmap->platform_id % charmap->encoding_id);
+        PRINTDB("Selected charmap: platform_id = %d, encoding_id = %d",
+                charmap->platform_id % charmap->encoding_id);
         if (is_windows_symbol_font(face)) {
-          PRINTDB("Detected windows symbol font with character codes in the Private Use Area of Unicode at 0xf000: %s/%s", face->family_name % face->style_name);
+          PRINTDB("Detected windows symbol font with character codes in the "
+                  "Private Use Area of Unicode at 0xf000: %s/%s",
+                  face->family_name % face->style_name);
         }
         return true;
       }
@@ -479,8 +483,7 @@ bool FontCache::try_charmap(const FontFacePtr& face_ptr, int platform_id, int en
   return false;
 }
 
-bool FontCache::is_windows_symbol_font(const FT_Face& face) const
-{
+bool FontCache::is_windows_symbol_font(const FT_Face &face) const {
   if (face->charmap->platform_id != TT_PLATFORM_MICROSOFT) {
     return false;
   }
diff --git a/src/FontCache.h b/src/FontCache.h
index a4b69198d..37ae38dc7 100644
--- a/src/FontCache.h
+++ b/src/FontCache.h
@@ -28,11 +28,10 @@
 #include <cstdint>
 #include <ctime>
 #include <map>
-#include <string>
+#include <memory>
 #include <string>
 #include <utility>
 #include <vector>
-#include <memory>
 
 #include <ft2build.h>
 #include FT_FREETYPE_H
@@ -42,17 +41,18 @@ std::string get_fontconfig_version();
 std::string get_harfbuzz_version();
 std::string get_freetype_version();
 
-class FontInfo
-{
+class FontInfo {
 public:
-  FontInfo(std::string family, std::string style, std::string file, uint32_t hash);
+  FontInfo(std::string family, std::string style, std::string file,
+           uint32_t hash);
   virtual ~FontInfo() = default;
 
-  [[nodiscard]] const std::string& get_family() const;
-  [[nodiscard]] const std::string& get_style() const;
-  [[nodiscard]] const std::string& get_file() const;
+  [[nodiscard]] const std::string &get_family() const;
+  [[nodiscard]] const std::string &get_style() const;
+  [[nodiscard]] const std::string &get_file() const;
   [[nodiscard]] const uint32_t get_hash() const;
-  bool operator<(const FontInfo& rhs) const;
+  bool operator<(const FontInfo &rhs) const;
+
 private:
   std::string family;
   std::string style;
@@ -67,33 +67,28 @@ using FontInfoList = std::vector<FontInfo>;
  * can be passed to the GUI to run in a separate thread while showing a
  * progress dialog.
  */
-class FontCacheInitializer
-{
+class FontCacheInitializer {
 public:
-  FontCacheInitializer(FcConfig *config) : config(config) { }
+  FontCacheInitializer(FcConfig *config) : config(config) {}
   void run() { FcConfigBuildFonts(config); }
+
 private:
   FcConfig *config;
 };
 
-struct FontFace
-{
+struct FontFace {
   FT_Face face_;
   std::vector<std::string> features_;
 
   FontFace(FT_Face face, std::vector<std::string> features)
-    : face_(face), features_(std::move(features)) {
-  }
+      : face_(face), features_(std::move(features)) {}
 
-  virtual ~FontFace() {
-    FT_Done_Face(face_);
-  }
+  virtual ~FontFace() { FT_Done_Face(face_); }
 };
 
 using FontFacePtr = std::shared_ptr<const FontFace>;
 
-class FontCache
-{
+class FontCache {
 public:
   const static std::string DEFAULT_FONT;
   const static unsigned int MAX_NR_OF_CACHE_ENTRIES = 5;
@@ -102,18 +97,19 @@ public:
   virtual ~FontCache() = default;
 
   [[nodiscard]] bool is_init_ok() const;
-  FontFacePtr get_font(const std::string& font);
-  [[nodiscard]] bool is_windows_symbol_font(const FT_Face& face) const;
-  void register_font_file(const std::string& path);
+  FontFacePtr get_font(const std::string &font);
+  [[nodiscard]] bool is_windows_symbol_font(const FT_Face &face) const;
+  void register_font_file(const std::string &path);
   void clear();
   [[nodiscard]] FontInfoList *list_fonts() const;
-  [[nodiscard]] std::vector<uint32_t> filter(const std::u32string&) const;
+  [[nodiscard]] std::vector<uint32_t> filter(const std::u32string &) const;
   [[nodiscard]] const std::string get_freetype_version() const;
 
   static FontCache *instance();
 
-  using InitHandlerFunc = void (FontCacheInitializer *, void *);
-  static void registerProgressHandler(InitHandlerFunc *handler, void *userdata = nullptr);
+  using InitHandlerFunc = void(FontCacheInitializer *, void *);
+  static void registerProgressHandler(InitHandlerFunc *handler,
+                                      void *userdata = nullptr);
 
 private:
   using cache_entry_t = std::pair<FontFacePtr, std::time_t>;
@@ -123,7 +119,8 @@ private:
   static InitHandlerFunc *cb_handler;
   static void *cb_userdata;
 
-  static void defaultInitHandler(FontCacheInitializer *delegate, void *userdata);
+  static void defaultInitHandler(FontCacheInitializer *delegate,
+                                 void *userdata);
 
   bool init_ok;
   cache_t cache;
@@ -131,13 +128,13 @@ private:
   FT_Library library;
 
   void check_cleanup();
-  void dump_cache(const std::string& info);
+  void dump_cache(const std::string &info);
 
-  void add_font_dir(const std::string& path);
+  void add_font_dir(const std::string &path);
   void init_pattern(FcPattern *pattern) const;
 
-  [[nodiscard]] FontFacePtr find_face(const std::string& font) const;
-  [[nodiscard]] FontFacePtr find_face_fontconfig(const std::string& font) const;
-  bool try_charmap(const FontFacePtr& face_ptr, int platform_id, int encoding_id) const;
+  [[nodiscard]] FontFacePtr find_face(const std::string &font) const;
+  [[nodiscard]] FontFacePtr find_face_fontconfig(const std::string &font) const;
+  bool try_charmap(const FontFacePtr &face_ptr, int platform_id,
+                   int encoding_id) const;
 };
-
diff --git a/src/LibraryInfo.cc b/src/LibraryInfo.cc
index 3b73daa22..9b5b57ec3 100644
--- a/src/LibraryInfo.cc
+++ b/src/LibraryInfo.cc
@@ -5,22 +5,22 @@
 #include <string>
 #include <vector>
 
-#include <clipper2/clipper.version.h>
 #include <Eigen/Core>
+#include <clipper2/clipper.version.h>
 #include <glib.h>
 
 #include "io/lib3mf_utils.h"
 
 #ifndef OPENSCAD_NOGUI
-#include <QtGlobal>
-#include <Qsci/qsciglobal.h>
 #include "gui/input/InputDriverManager.h"
+#include <Qsci/qsciglobal.h>
+#include <QtGlobal>
 #endif
 
 #ifdef ENABLE_CGAL
+#include "geometry/cgal/cgal.h"
 #include <CGAL/version.h>
 #include <boost/algorithm/string.hpp>
-#include "geometry/cgal/cgal.h"
 #if defined(__GNUG__)
 #define GCC_INT_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100)
 #if GCC_INT_VERSION > 40600 || defined(__clang__)
@@ -52,27 +52,25 @@
 #define TOSTRING(x) STRINGIFY(x)
 
 #ifdef ENABLE_MANIFOLD
-#include <manifold/version.h>  // if it is new enough for us, it has version.h
-#define MANIFOLD_VERSION_STRING \
-        TOSTRING(MANIFOLD_VERSION_MAJOR) "." \
-        TOSTRING(MANIFOLD_VERSION_MINOR) "." \
-        TOSTRING(MANIFOLD_VERSION_PATCH)
+#include <manifold/version.h> // if it is new enough for us, it has version.h
+#define MANIFOLD_VERSION_STRING                                                \
+  TOSTRING(MANIFOLD_VERSION_MAJOR)                                             \
+  "." TOSTRING(MANIFOLD_VERSION_MINOR) "." TOSTRING(MANIFOLD_VERSION_PATCH)
 #else
 #define MANIFOLD_VERSION_STRING "<not enabled>"
 #endif
 
-#include "platform/PlatformUtils.h"
-#include "version.h"
 #include "Feature.h"
 #include "FontCache.h"
+#include "platform/PlatformUtils.h"
+#include "version.h"
 
 extern std::vector<std::string> librarypath;
 extern std::vector<std::string> fontpath;
 extern const std::string get_cairo_version();
 extern const char *LODEPNG_VERSION_STRING;
 
-std::string LibraryInfo::info()
-{
+std::string LibraryInfo::info() {
   std::ostringstream s;
 
 #if defined(__x86_64__) || defined(_M_X64)
@@ -84,11 +82,14 @@ std::string LibraryInfo::info()
 #endif
 
 #if defined(__GNUG__) && !defined(__clang__)
-  const std::string compiler_info("GCC " + std::string(TOSTRING(__VERSION__)) + bits);
+  const std::string compiler_info("GCC " + std::string(TOSTRING(__VERSION__)) +
+                                  bits);
 #elif defined(_MSC_VER)
-  const std::string compiler_info("MSVC " + std::string(TOSTRING(_MSC_FULL_VER)) + bits);
+  const std::string compiler_info("MSVC " +
+                                  std::string(TOSTRING(_MSC_FULL_VER)) + bits);
 #elif defined(__clang__)
-  const std::string compiler_info("Clang " + std::string(TOSTRING(__clang_version__)) + bits);
+  const std::string compiler_info(
+      "Clang " + std::string(TOSTRING(__clang_version__)) + bits);
 #else
   const std::string compiler_info("unknown compiler");
 #endif
@@ -118,12 +119,14 @@ std::string LibraryInfo::info()
   std::string cgal_2d_kernel = typeid(CGAL_Kernel2).name();
 #if defined(openscad_info_demangle_)
   int status;
-  cgal_3d_kernel = std::string(abi::__cxa_demangle(cgal_3d_kernel.c_str(), nullptr, nullptr, &status) );
-  cgal_2d_kernel = std::string(abi::__cxa_demangle(cgal_2d_kernel.c_str(), nullptr, nullptr, &status) );
+  cgal_3d_kernel = std::string(
+      abi::__cxa_demangle(cgal_3d_kernel.c_str(), nullptr, nullptr, &status));
+  cgal_2d_kernel = std::string(
+      abi::__cxa_demangle(cgal_2d_kernel.c_str(), nullptr, nullptr, &status));
 #endif // demangle
   boost::replace_all(cgal_3d_kernel, "CGAL::", "");
   boost::replace_all(cgal_2d_kernel, "CGAL::", "");
-#else // ENABLE_CGAL
+#else  // ENABLE_CGAL
   std::string cgal_3d_kernel = "";
   std::string cgal_2d_kernel = "";
 #endif // ENABLE_CGAL
@@ -134,13 +137,14 @@ std::string LibraryInfo::info()
   s << "OpenSCAD Version: " << openscad_detailedversionnumber
     << "\nSystem information: " << PlatformUtils::sysinfo()
     << "\nUser Agent: " << PlatformUtils::user_agent()
-    << "\nCompiler: " << compiler_info
-    << "\nMinGW build: " << mingwstatus
+    << "\nCompiler: " << compiler_info << "\nMinGW build: " << mingwstatus
     << "\nDebug build: " << debugstatus
     << "\nBoost version: " << BOOST_LIB_VERSION
-    << "\nEigen version: " << EIGEN_WORLD_VERSION << "." << EIGEN_MAJOR_VERSION << "." << EIGEN_MINOR_VERSION
+    << "\nEigen version: " << EIGEN_WORLD_VERSION << "." << EIGEN_MAJOR_VERSION
+    << "." << EIGEN_MINOR_VERSION
 #ifdef ENABLE_CGAL
-    << "\nCGAL version, kernels: " << TOSTRING(CGAL_VERSION) << ", " << cgal_3d_kernel << ", " << cgal_2d_kernel
+    << "\nCGAL version, kernels: " << TOSTRING(CGAL_VERSION) << ", "
+    << cgal_3d_kernel << ", " << cgal_2d_kernel
 #endif
 #ifdef ENABLE_PYTHON
     << "\nPython Version: " << python_version()
@@ -153,7 +157,8 @@ std::string LibraryInfo::info()
     << "\nQScintilla version: " << QSCINTILLA_VERSION_STR
     << "\nInputDrivers: " << InputDriverManager::instance()->listDrivers()
 #endif
-    << "\nGLib version: " << GLIB_MAJOR_VERSION << "." << GLIB_MINOR_VERSION << "." << GLIB_MICRO_VERSION
+    << "\nGLib version: " << GLIB_MAJOR_VERSION << "." << GLIB_MINOR_VERSION
+    << "." << GLIB_MICRO_VERSION
     << "\nlodepng version: " << LODEPNG_VERSION_STRING
     << "\nlibzip version: " << LIBZIP_VERSION
     << "\nfontconfig version: " << get_fontconfig_version()
@@ -175,14 +180,15 @@ std::string LibraryInfo::info()
     << "\nOPENSCADPATH: " << (env_path == nullptr ? "<not set>" : env_path)
     << "\nOpenSCAD library path:\n";
 
-  for (const auto& path : librarypath) {
+  for (const auto &path : librarypath) {
     s << "  " << path << "\n";
   }
 
-  s << "\nOPENSCAD_FONT_PATH: " << (env_font_path == nullptr ? "<not set>" : env_font_path)
+  s << "\nOPENSCAD_FONT_PATH: "
+    << (env_font_path == nullptr ? "<not set>" : env_font_path)
     << "\nOpenSCAD font path:\n";
 
-  for (const auto& path : fontpath) {
+  for (const auto &path : fontpath) {
     s << "  " << path << "\n";
   }
 
diff --git a/src/RenderStatistic.cc b/src/RenderStatistic.cc
index ce95a7bd8..f8d90a918 100644
--- a/src/RenderStatistic.cc
+++ b/src/RenderStatistic.cc
@@ -23,7 +23,6 @@
  *
  */
 
-
 #include "RenderStatistic.h"
 
 #include <algorithm>
@@ -42,95 +41,101 @@
 
 #include "geometry/Geometry.h"
 #include "geometry/GeometryCache.h"
-#include "geometry/linalg.h"
-#include "geometry/Polygon2d.h"
 #include "geometry/PolySet.h"
+#include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 #include "glview/Camera.h"
 #include "utils/printutils.h"
 #ifdef ENABLE_CGAL
-#include "geometry/cgal/CGALNefGeometry.h"
 #include "geometry/cgal/CGALCache.h"
+#include "geometry/cgal/CGALNefGeometry.h"
 #endif // ENABLE_CGAL
 #ifdef ENABLE_MANIFOLD
 #include "geometry/manifold/ManifoldGeometry.h"
 #include "geometry/manifold/manifoldutils.h"
 #endif // ENABLE_MANIFOLD
 
-
 class GeometryList;
 
 namespace {
 
-struct StatisticVisitor : public GeometryVisitor
-{
-  StatisticVisitor(const std::vector<std::string>& options)
-    : all(std::find(options.begin(), options.end(), "all") != options.end()),
-    options(options) { }
-  virtual void printCamera(const Camera& camera) = 0;
+struct StatisticVisitor : public GeometryVisitor {
+  StatisticVisitor(const std::vector<std::string> &options)
+      : all(std::find(options.begin(), options.end(), "all") != options.end()),
+        options(options) {}
+  virtual void printCamera(const Camera &camera) = 0;
   virtual void printCacheStatistic() = 0;
   virtual void printRenderingTime(std::chrono::milliseconds) = 0;
   virtual void finish() = 0;
+
 protected:
-  bool is_enabled(const std::string& name) {
-    return all || std::find(options.begin(), options.end(), name) != options.end();
+  bool is_enabled(const std::string &name) {
+    return all ||
+           std::find(options.begin(), options.end(), name) != options.end();
   }
+
 private:
   bool all;
   std::vector<std::string> options;
 };
 
-struct LogVisitor : public StatisticVisitor
-{
-  LogVisitor(const std::vector<std::string>& options) : StatisticVisitor(options) { }
-  void visit(const GeometryList& node) override;
-  void visit(const PolySet& node) override;
-  void visit(const Polygon2d& node) override;
+struct LogVisitor : public StatisticVisitor {
+  LogVisitor(const std::vector<std::string> &options)
+      : StatisticVisitor(options) {}
+  void visit(const GeometryList &node) override;
+  void visit(const PolySet &node) override;
+  void visit(const Polygon2d &node) override;
 #ifdef ENABLE_CGAL
-  void visit(const CGALNefGeometry& node) override;
+  void visit(const CGALNefGeometry &node) override;
 #endif // ENABLE_CGAL
 #ifdef ENABLE_MANIFOLD
-  void visit(const ManifoldGeometry& node) override;
+  void visit(const ManifoldGeometry &node) override;
 #endif // ENABLE_MANIFOLD
-  void printCamera(const Camera& camera) override;
+  void printCamera(const Camera &camera) override;
   void printCacheStatistic() override;
   void printRenderingTime(std::chrono::milliseconds) override;
   void finish() override;
+
 private:
-  void printBoundingBox3(const BoundingBox& bb);
+  void printBoundingBox3(const BoundingBox &bb);
 };
 
-struct StreamVisitor : public StatisticVisitor
-{
-  StreamVisitor(const std::vector<std::string>& options, std::ostream& stream) : StatisticVisitor(options), stream(stream) {}
-  StreamVisitor(const std::vector<std::string>& options, const std::string& filename) : StatisticVisitor(options), fstream(filename), stream(fstream) {}
+struct StreamVisitor : public StatisticVisitor {
+  StreamVisitor(const std::vector<std::string> &options, std::ostream &stream)
+      : StatisticVisitor(options), stream(stream) {}
+  StreamVisitor(const std::vector<std::string> &options,
+                const std::string &filename)
+      : StatisticVisitor(options), fstream(filename), stream(fstream) {}
   ~StreamVisitor() override {
-    if (fstream.is_open()) fstream.close();
+    if (fstream.is_open())
+      fstream.close();
   }
-  void visit(const GeometryList& node) override;
-  void visit(const PolySet& node) override;
-  void visit(const Polygon2d& node) override;
+  void visit(const GeometryList &node) override;
+  void visit(const PolySet &node) override;
+  void visit(const Polygon2d &node) override;
 #ifdef ENABLE_CGAL
-  void visit(const CGALNefGeometry& node) override;
+  void visit(const CGALNefGeometry &node) override;
 #endif // ENABLE_CGAL
 #ifdef ENABLE_MANIFOLD
-  void visit(const ManifoldGeometry& node) override;
+  void visit(const ManifoldGeometry &node) override;
 #endif // ENABLE_MANIFOLD
-  void printCamera(const Camera& camera) override;
+  void printCamera(const Camera &camera) override;
   void printCacheStatistic() override;
   void printRenderingTime(std::chrono::milliseconds) override;
   void finish() override;
+
 private:
   nlohmann::json json;
   std::ofstream fstream;
-  std::ostream& stream;
+  std::ostream &stream;
 };
 
-static nlohmann::json getBoundingBox2d(const Geometry& geometry)
-{
-  const auto& bb = geometry.getBoundingBox();
-  const std::array<double, 2> min = { bb.min().x(), bb.min().y() };
-  const std::array<double, 2> max = { bb.max().x(), bb.max().y() };
-  const std::array<double, 2> size = { bb.max().x() - bb.min().x(), bb.max().y() - bb.min().y() };
+static nlohmann::json getBoundingBox2d(const Geometry &geometry) {
+  const auto &bb = geometry.getBoundingBox();
+  const std::array<double, 2> min = {bb.min().x(), bb.min().y()};
+  const std::array<double, 2> max = {bb.max().x(), bb.max().y()};
+  const std::array<double, 2> size = {bb.max().x() - bb.min().x(),
+                                      bb.max().y() - bb.min().y()};
   nlohmann::json bbJson;
   bbJson["min"] = min;
   bbJson["max"] = max;
@@ -138,12 +143,13 @@ static nlohmann::json getBoundingBox2d(const Geometry& geometry)
   return bbJson;
 }
 
-static nlohmann::json getBoundingBox3d(const Geometry& geometry)
-{
-  const auto& bb = geometry.getBoundingBox();
-  const std::array<double, 3> min = { bb.min().x(), bb.min().y(), bb.min().z() };
-  const std::array<double, 3> max = { bb.max().x(), bb.max().y(), bb.max().z() };
-  const std::array<double, 3> size = { bb.max().x() - bb.min().x(), bb.max().y() - bb.min().y(), bb.max().z() - bb.min().z() };
+static nlohmann::json getBoundingBox3d(const Geometry &geometry) {
+  const auto &bb = geometry.getBoundingBox();
+  const std::array<double, 3> min = {bb.min().x(), bb.min().y(), bb.min().z()};
+  const std::array<double, 3> max = {bb.max().x(), bb.max().y(), bb.max().z()};
+  const std::array<double, 3> size = {bb.max().x() - bb.min().x(),
+                                      bb.max().y() - bb.min().y(),
+                                      bb.max().z() - bb.min().z()};
   nlohmann::json bbJson;
   bbJson["min"] = min;
   bbJson["max"] = max;
@@ -151,9 +157,7 @@ static nlohmann::json getBoundingBox3d(const Geometry& geometry)
   return bbJson;
 }
 
-template <typename C>
-static nlohmann::json getCache(C cache)
-{
+template <typename C> static nlohmann::json getCache(C cache) {
   nlohmann::json cacheJson;
   cacheJson["entries"] = cache->size();
   cacheJson["bytes"] = cache->totalCost();
@@ -163,40 +167,36 @@ static nlohmann::json getCache(C cache)
 
 } // namespace
 
-RenderStatistic::RenderStatistic() : begin(std::chrono::steady_clock::now())
-{
-}
+RenderStatistic::RenderStatistic() : begin(std::chrono::steady_clock::now()) {}
 
-void RenderStatistic::start()
-{
-  begin = std::chrono::steady_clock::now();
-}
+void RenderStatistic::start() { begin = std::chrono::steady_clock::now(); }
 
-std::chrono::milliseconds RenderStatistic::ms()
-{
-  const std::chrono::steady_clock::time_point end{std::chrono::steady_clock::now()};
-  const std::chrono::milliseconds ms{std::chrono::duration_cast<std::chrono::milliseconds>(end - begin)};
+std::chrono::milliseconds RenderStatistic::ms() {
+  const std::chrono::steady_clock::time_point end{
+      std::chrono::steady_clock::now()};
+  const std::chrono::milliseconds ms{
+      std::chrono::duration_cast<std::chrono::milliseconds>(end - begin)};
   return ms;
 }
 
-void RenderStatistic::printCacheStatistic()
-{
+void RenderStatistic::printCacheStatistic() {
   LogVisitor visitor({});
   visitor.printCacheStatistic();
 }
 
-void RenderStatistic::printRenderingTime()
-{
+void RenderStatistic::printRenderingTime() {
   LogVisitor visitor({});
   visitor.printRenderingTime(ms());
 }
 
-void RenderStatistic::printAll(const std::shared_ptr<const Geometry>& geom, const Camera& camera, const std::vector<std::string>& options, const std::string& filename)
-{
-  //bool is_log = false;
+void RenderStatistic::printAll(const std::shared_ptr<const Geometry> &geom,
+                               const Camera &camera,
+                               const std::vector<std::string> &options,
+                               const std::string &filename) {
+  // bool is_log = false;
   std::unique_ptr<StatisticVisitor> visitor;
   if (filename.empty()) {
-    //is_log = true;
+    // is_log = true;
     visitor = std::make_unique<LogVisitor>(options);
   } else if (filename == "-") {
     visitor = std::make_unique<StreamVisitor>(options, std::cout);
@@ -213,23 +213,21 @@ void RenderStatistic::printAll(const std::shared_ptr<const Geometry>& geom, cons
   visitor->finish();
 }
 
-void LogVisitor::visit(const GeometryList& geomlist)
-{
+void LogVisitor::visit(const GeometryList &geomlist) {
   LOG("Top level object is a list of objects:");
-  LOG("   Objects:    %1$d",
-      geomlist.getChildren().size());
+  LOG("   Objects:    %1$d", geomlist.getChildren().size());
 }
 
-void LogVisitor::visit(const Polygon2d& poly)
-{
+void LogVisitor::visit(const Polygon2d &poly) {
   LOG("Top level object is a 2D object:");
   LOG("   Contours:   %1$6d", poly.outlines().size());
   if (is_enabled(RenderStatistic::BOUNDING_BOX)) {
-    const auto& bb = poly.getBoundingBox();
+    const auto &bb = poly.getBoundingBox();
     LOG("Bounding box:");
     LOG("   Min:  %1$.2f, %2$.2f", bb.min().x(), bb.min().y());
     LOG("   Max:  %1$.2f, %2$.2f", bb.max().x(), bb.max().y());
-    LOG("   Size: %1$.2f, %2$.2f", bb.max().x() - bb.min().x(), bb.max().y() - bb.min().y());
+    LOG("   Size: %1$.2f, %2$.2f", bb.max().x() - bb.min().x(),
+        bb.max().y() - bb.min().y());
   }
   if (is_enabled(RenderStatistic::AREA)) {
     LOG("Measurements:");
@@ -237,18 +235,19 @@ void LogVisitor::visit(const Polygon2d& poly)
   }
 }
 
-void LogVisitor::printBoundingBox3(const BoundingBox& bb)
-{
+void LogVisitor::printBoundingBox3(const BoundingBox &bb) {
   if (is_enabled(RenderStatistic::BOUNDING_BOX)) {
     LOG("Bounding box:");
-    LOG("   Min:  %1$.2f, %2$.2f, %3$.2f", bb.min().x(), bb.min().y(), bb.min().z());
-    LOG("   Max:  %1$.2f, %2$.2f, %3$.2f", bb.max().x(), bb.max().y(), bb.max().z());
-    LOG("   Size: %1$.2f, %2$.2f, %3$.2f", bb.max().x() - bb.min().x(), bb.max().y() - bb.min().y(), bb.max().z() - bb.min().z());
+    LOG("   Min:  %1$.2f, %2$.2f, %3$.2f", bb.min().x(), bb.min().y(),
+        bb.min().z());
+    LOG("   Max:  %1$.2f, %2$.2f, %3$.2f", bb.max().x(), bb.max().y(),
+        bb.max().z());
+    LOG("   Size: %1$.2f, %2$.2f, %3$.2f", bb.max().x() - bb.min().x(),
+        bb.max().y() - bb.min().y(), bb.max().z() - bb.min().z());
   }
 }
 
-void LogVisitor::visit(const PolySet& ps)
-{
+void LogVisitor::visit(const PolySet &ps) {
   assert(ps.getDimension() == 3);
   LOG("Top level object is a 3D object (PolySet):");
   LOG("   Convex:       %1$s", (ps.isConvex() ? "yes" : "no"));
@@ -261,8 +260,7 @@ void LogVisitor::visit(const PolySet& ps)
 }
 
 #ifdef ENABLE_CGAL
-void LogVisitor::visit(const CGALNefGeometry& nef)
-{
+void LogVisitor::visit(const CGALNefGeometry &nef) {
   if (nef.getDimension() == 3) {
     const bool simple = nef.p3->is_simple();
     LOG("Top level object is a 3D object (Nef polyhedron):");
@@ -274,7 +272,8 @@ void LogVisitor::visit(const CGALNefGeometry& nef)
     LOG("   Facets:     %1$6d", nef.p3->number_of_facets());
     LOG("   Volumes:    %1$6d", nef.p3->number_of_volumes());
     if (!simple) {
-      LOG(message_group::UI_Warning, "Object may not be a valid 2-manifold and may need repair!");
+      LOG(message_group::UI_Warning,
+          "Object may not be a valid 2-manifold and may need repair!");
     }
     printBoundingBox3(nef.getBoundingBox());
   }
@@ -282,10 +281,9 @@ void LogVisitor::visit(const CGALNefGeometry& nef)
 #endif // ENABLE_CGAL
 
 #ifdef ENABLE_MANIFOLD
-void LogVisitor::visit(const ManifoldGeometry& mani_geom)
-{
+void LogVisitor::visit(const ManifoldGeometry &mani_geom) {
   LOG("   Top level object is a 3D object (manifold):");
-  auto& mani = mani_geom.getManifold();
+  auto &mani = mani_geom.getManifold();
 
   LOG("   Status:     %1$s", ManifoldUtils::statusToString(mani.Status()));
   LOG("   Genus:      %1$d", mani.Genus());
@@ -295,19 +293,19 @@ void LogVisitor::visit(const ManifoldGeometry& mani_geom)
 }
 #endif // ENABLE_MANIFOLD
 
-void LogVisitor::printCamera(const Camera& camera)
-{
+void LogVisitor::printCamera(const Camera &camera) {
   if (is_enabled(RenderStatistic::CAMERA)) {
     LOG("Camera:");
-    LOG("   Translation: %1$.2f, %2$.2f, %3$.2f", camera.getVpt().x(), camera.getVpt().y(), camera.getVpt().z());
-    LOG("   Rotation:    %1$.2f, %2$.2f, %3$.2f", camera.getVpr().x(), camera.getVpr().y(), camera.getVpr().z());
+    LOG("   Translation: %1$.2f, %2$.2f, %3$.2f", camera.getVpt().x(),
+        camera.getVpt().y(), camera.getVpt().z());
+    LOG("   Rotation:    %1$.2f, %2$.2f, %3$.2f", camera.getVpr().x(),
+        camera.getVpr().y(), camera.getVpr().z());
     LOG("   Distance:    %1$.2f", camera.zoomValue());
     LOG("   FOV:         %1$.2f", camera.fovValue());
   }
 }
 
-void LogVisitor::printCacheStatistic()
-{
+void LogVisitor::printCacheStatistic() {
   // always enabled
   GeometryCache::instance()->print();
 #ifdef ENABLE_CGAL
@@ -315,26 +313,18 @@ void LogVisitor::printCacheStatistic()
 #endif
 }
 
-void LogVisitor::printRenderingTime(const std::chrono::milliseconds ms)
-{
+void LogVisitor::printRenderingTime(const std::chrono::milliseconds ms) {
   // always enabled
   LOG("Total rendering time: %1$d:%2$02d:%3$02d.%4$03d",
-      (ms.count() / 1000 / 60 / 60),
-      (ms.count() / 1000 / 60 % 60),
-      (ms.count() / 1000 % 60),
-      (ms.count() % 1000));
+      (ms.count() / 1000 / 60 / 60), (ms.count() / 1000 / 60 % 60),
+      (ms.count() / 1000 % 60), (ms.count() % 1000));
 }
 
-void LogVisitor::finish()
-{
-}
+void LogVisitor::finish() {}
 
-void StreamVisitor::visit(const GeometryList& geomlist)
-{
-}
+void StreamVisitor::visit(const GeometryList &geomlist) {}
 
-void StreamVisitor::visit(const Polygon2d& poly)
-{
+void StreamVisitor::visit(const Polygon2d &poly) {
   if (is_enabled(RenderStatistic::GEOMETRY)) {
     nlohmann::json geometryJson;
     geometryJson["dimensions"] = 2;
@@ -347,8 +337,7 @@ void StreamVisitor::visit(const Polygon2d& poly)
   }
 }
 
-void StreamVisitor::visit(const PolySet& ps)
-{
+void StreamVisitor::visit(const PolySet &ps) {
   if (is_enabled(RenderStatistic::GEOMETRY)) {
     assert(ps.getDimension() == 3);
     nlohmann::json geometryJson;
@@ -364,8 +353,7 @@ void StreamVisitor::visit(const PolySet& ps)
 }
 
 #ifdef ENABLE_CGAL
-void StreamVisitor::visit(const CGALNefGeometry& nef)
-{
+void StreamVisitor::visit(const CGALNefGeometry &nef) {
   if (is_enabled(RenderStatistic::GEOMETRY)) {
     nlohmann::json geometryJson;
     geometryJson["dimensions"] = 3;
@@ -383,8 +371,7 @@ void StreamVisitor::visit(const CGALNefGeometry& nef)
 #endif // ENABLE_CGAL
 
 #ifdef ENABLE_MANIFOLD
-void StreamVisitor::visit(const ManifoldGeometry& mani)
-{
+void StreamVisitor::visit(const ManifoldGeometry &mani) {
   if (is_enabled(RenderStatistic::GEOMETRY)) {
     nlohmann::json geometryJson;
     geometryJson["dimensions"] = 3;
@@ -399,11 +386,12 @@ void StreamVisitor::visit(const ManifoldGeometry& mani)
 }
 #endif // ENABLE_MANIFOLD
 
-void StreamVisitor::printCamera(const Camera& camera)
-{
+void StreamVisitor::printCamera(const Camera &camera) {
   if (is_enabled(RenderStatistic::CAMERA)) {
-    const std::array<double, 3> translation = { camera.getVpt().x(), camera.getVpt().y(), camera.getVpt().z() };
-    const std::array<double, 3> rotation = { camera.getVpr().x(), camera.getVpr().y(), camera.getVpr().z() };
+    const std::array<double, 3> translation = {
+        camera.getVpt().x(), camera.getVpt().y(), camera.getVpt().z()};
+    const std::array<double, 3> rotation = {
+        camera.getVpr().x(), camera.getVpr().y(), camera.getVpr().z()};
     nlohmann::json cameraJson;
     cameraJson["translation"] = translation;
     cameraJson["rotation"] = rotation;
@@ -413,8 +401,7 @@ void StreamVisitor::printCamera(const Camera& camera)
   }
 }
 
-void StreamVisitor::printCacheStatistic()
-{
+void StreamVisitor::printCacheStatistic() {
   if (is_enabled(RenderStatistic::CACHE)) {
     nlohmann::json cacheJson;
     cacheJson["geometry_cache"] = getCache(GeometryCache::instance());
@@ -425,15 +412,14 @@ void StreamVisitor::printCacheStatistic()
   }
 }
 
-void StreamVisitor::printRenderingTime(const std::chrono::milliseconds ms)
-{
+void StreamVisitor::printRenderingTime(const std::chrono::milliseconds ms) {
   if (is_enabled(RenderStatistic::TIME)) {
     nlohmann::json timeJson;
-    timeJson["time"] = (boost::format("%1$d:%2$02d:%3$02d.%4$03d")
-                        % (ms.count() / 1000 / 60 / 60)
-                        % (ms.count() / 1000 / 60 % 60)
-                        % (ms.count() / 1000 % 60)
-                        % (ms.count() % 1000)).str();
+    timeJson["time"] =
+        (boost::format("%1$d:%2$02d:%3$02d.%4$03d") %
+         (ms.count() / 1000 / 60 / 60) % (ms.count() / 1000 / 60 % 60) %
+         (ms.count() / 1000 % 60) % (ms.count() % 1000))
+            .str();
     timeJson["total"] = ms.count();
     timeJson["milliseconds"] = ms.count() % 1000;
     timeJson["seconds"] = ms.count() / 1000 % 60;
@@ -443,7 +429,4 @@ void StreamVisitor::printRenderingTime(const std::chrono::milliseconds ms)
   }
 }
 
-void StreamVisitor::finish()
-{
-  stream << json;
-}
+void StreamVisitor::finish() { stream << json; }
diff --git a/src/RenderStatistic.h b/src/RenderStatistic.h
index ebe2edd15..710ab639b 100644
--- a/src/RenderStatistic.h
+++ b/src/RenderStatistic.h
@@ -25,20 +25,19 @@
 
 #pragma once
 
-#include <memory>
 #include <chrono>
+#include <memory>
 #include <string>
 #include <vector>
 
-#include "glview/Camera.h"
 #include "geometry/Geometry.h"
+#include "glview/Camera.h"
 
 /**
  * An utility class to collect and print rendering statistics for the given
  * geometry
  */
-class RenderStatistic
-{
+class RenderStatistic {
 public:
   constexpr static auto CACHE = "cache";
   constexpr static auto TIME = "time";
@@ -64,8 +63,8 @@ public:
   std::chrono::milliseconds ms();
 
   /**
-   * Print some statistic on cache usage. Namely, stats on the @ref GeometryCache
-   * and @ref CGALCache (if enabled).
+   * Print some statistic on cache usage. Namely, stats on the @ref
+   * GeometryCache and @ref CGALCache (if enabled).
    */
   void printCacheStatistic();
 
@@ -77,7 +76,10 @@ public:
   /**
    * Print all available statistic information.
    */
-  void printAll(const std::shared_ptr<const Geometry>& geom, const Camera& camera, const std::vector<std::string>& options = {}, const std::string& filename = {});
+  void printAll(const std::shared_ptr<const Geometry> &geom,
+                const Camera &camera,
+                const std::vector<std::string> &options = {},
+                const std::string &filename = {});
 
 private:
   std::chrono::steady_clock::time_point begin;
diff --git a/src/core/AST.cc b/src/core/AST.cc
index 7cc82107a..57743fadb 100644
--- a/src/core/AST.cc
+++ b/src/core/AST.cc
@@ -1,44 +1,41 @@
 #include "core/AST.h"
+#include "io/fileutils.h"
 #include <filesystem>
-#include <ostream>
 #include <memory>
+#include <ostream>
 #include <sstream>
 #include <string>
-#include "io/fileutils.h"
 
-const Location Location::NONE(0, 0, 0, 0, std::make_shared<fs::path>(fs::path{}));
+const Location Location::NONE(0, 0, 0, 0,
+                              std::make_shared<fs::path>(fs::path{}));
 
-bool operator==(Location const& lhs, Location const& rhs){
-  return
-    lhs.firstLine() == rhs.firstLine() &&
-    lhs.firstColumn() == rhs.firstColumn() &&
-    lhs.lastLine() == rhs.lastLine() &&
-    lhs.lastColumn() == rhs.lastColumn() &&
-    lhs.filePath() == rhs.filePath();
+bool operator==(Location const &lhs, Location const &rhs) {
+  return lhs.firstLine() == rhs.firstLine() &&
+         lhs.firstColumn() == rhs.firstColumn() &&
+         lhs.lastLine() == rhs.lastLine() &&
+         lhs.lastColumn() == rhs.lastColumn() &&
+         lhs.filePath() == rhs.filePath();
 }
 
-bool operator!=(Location const& lhs, Location const& rhs)
-{
+bool operator!=(Location const &lhs, Location const &rhs) {
   return !(lhs == rhs);
 }
 
-bool Location::isNone() const {
-  return ((*this) == Location::NONE);
-}
+bool Location::isNone() const { return ((*this) == Location::NONE); }
 
-std::string Location::toRelativeString(const std::string& docPath) const {
-  if (this->isNone()) return "location unknown";
-  return "in file " + fs_uncomplete((*path), docPath).generic_string() + ", " + "line " + std::to_string(this->firstLine());
+std::string Location::toRelativeString(const std::string &docPath) const {
+  if (this->isNone())
+    return "location unknown";
+  return "in file " + fs_uncomplete((*path), docPath).generic_string() + ", " +
+         "line " + std::to_string(this->firstLine());
 }
 
-std::ostream& operator<<(std::ostream& stream, const ASTNode& ast)
-{
+std::ostream &operator<<(std::ostream &stream, const ASTNode &ast) {
   ast.print(stream, "");
   return stream;
 }
 
-std::string ASTNode::dump(const std::string& indent) const
-{
+std::string ASTNode::dump(const std::string &indent) const {
   std::ostringstream stream;
   print(stream, indent);
   return stream.str();
diff --git a/src/core/AST.h b/src/core/AST.h
index da3d8c7a2..671c3b900 100644
--- a/src/core/AST.h
+++ b/src/core/AST.h
@@ -1,38 +1,39 @@
 #pragma once
 
+#include <filesystem>
+#include <memory>
 #include <ostream>
 #include <string>
-#include <memory>
-#include <filesystem>
 #include <utility>
 namespace fs = std::filesystem;
 
 #include <string>
 
-class Location
-{
+class Location {
 
 public:
   Location(int firstLine, int firstCol, int lastLine, int lastCol,
            std::shared_ptr<fs::path> path)
-    : first_line(firstLine), first_col(firstCol), last_line(lastLine),
-    last_col(lastCol), path(std::move(path)) {
-  }
+      : first_line(firstLine), first_col(firstCol), last_line(lastLine),
+        last_col(lastCol), path(std::move(path)) {}
 
-  [[nodiscard]] std::string fileName() const { return path ? path->generic_string() : ""; }
-  [[nodiscard]] const fs::path& filePath() const { return *path; }
+  [[nodiscard]] std::string fileName() const {
+    return path ? path->generic_string() : "";
+  }
+  [[nodiscard]] const fs::path &filePath() const { return *path; }
   [[nodiscard]] int firstLine() const { return first_line; }
   [[nodiscard]] int firstColumn() const { return first_col; }
   [[nodiscard]] int lastLine() const { return last_line; }
   [[nodiscard]] int lastColumn() const { return last_col; }
   [[nodiscard]] bool isNone() const;
 
-  [[nodiscard]] std::string toRelativeString(const std::string& docPath) const;
+  [[nodiscard]] std::string toRelativeString(const std::string &docPath) const;
 
-  bool operator==(Location const& rhs);
-  bool operator!=(Location const& rhs);
+  bool operator==(Location const &rhs);
+  bool operator!=(Location const &rhs);
 
   static const Location NONE;
+
 private:
   int first_line;
   int first_col;
@@ -41,20 +42,19 @@ private:
   std::shared_ptr<fs::path> path;
 };
 
-class ASTNode
-{
+class ASTNode {
 public:
   ASTNode(Location loc) : loc(std::move(loc)) {}
   virtual ~ASTNode() = default;
 
-  virtual void print(std::ostream& stream, const std::string& indent) const = 0;
+  virtual void print(std::ostream &stream, const std::string &indent) const = 0;
 
-  [[nodiscard]] std::string dump(const std::string& indent) const;
-  [[nodiscard]] const Location& location() const { return loc; }
-  void setLocation(const Location& loc) { this->loc = loc; }
+  [[nodiscard]] std::string dump(const std::string &indent) const;
+  [[nodiscard]] const Location &location() const { return loc; }
+  void setLocation(const Location &loc) { this->loc = loc; }
 
 protected:
   Location loc;
 };
 
-std::ostream& operator<<(std::ostream& stream, const ASTNode& ast);
+std::ostream &operator<<(std::ostream &stream, const ASTNode &ast);
diff --git a/src/core/Arguments.cc b/src/core/Arguments.cc
index 658e89eae..dd38eb660 100644
--- a/src/core/Arguments.cc
+++ b/src/core/Arguments.cc
@@ -26,32 +26,31 @@
 
 #include "core/Arguments.h"
 
-#include <ostream>
-#include <memory>
 #include "core/Expression.h"
+#include <memory>
+#include <ostream>
 
-Arguments::Arguments(const AssignmentList& argument_expressions, const std::shared_ptr<const Context>& context) :
-  evaluation_session(context->session())
-{
-  for (const auto& argument_expression : argument_expressions) {
+Arguments::Arguments(const AssignmentList &argument_expressions,
+                     const std::shared_ptr<const Context> &context)
+    : evaluation_session(context->session()) {
+  for (const auto &argument_expression : argument_expressions) {
     emplace_back(
-      argument_expression->getName().empty() ? boost::none : boost::optional<std::string>(argument_expression->getName()),
-      argument_expression->getExpr()->evaluate(context)
-      );
+        argument_expression->getName().empty()
+            ? boost::none
+            : boost::optional<std::string>(argument_expression->getName()),
+        argument_expression->getExpr()->evaluate(context));
   }
 }
 
-Arguments Arguments::clone() const
-{
+Arguments Arguments::clone() const {
   Arguments output(evaluation_session);
-  for (const Argument& argument : *this) {
+  for (const Argument &argument : *this) {
     output.emplace_back(argument.name, argument.value.clone());
   }
   return output;
 }
 
-std::ostream& operator<<(std::ostream& stream, const Argument& argument)
-{
+std::ostream &operator<<(std::ostream &stream, const Argument &argument) {
   if (argument.name) {
     stream << *argument.name << " = ";
   }
@@ -59,10 +58,9 @@ std::ostream& operator<<(std::ostream& stream, const Argument& argument)
   return stream;
 }
 
-std::ostream& operator<<(std::ostream& stream, const Arguments& arguments)
-{
+std::ostream &operator<<(std::ostream &stream, const Arguments &arguments) {
   bool first = true;
-  for (const auto& argument : arguments) {
+  for (const auto &argument : arguments) {
     if (first) {
       first = false;
     } else {
diff --git a/src/core/Arguments.h b/src/core/Arguments.h
index 120e8e88c..0f9bac2f8 100644
--- a/src/core/Arguments.h
+++ b/src/core/Arguments.h
@@ -1,11 +1,11 @@
 #pragma once
 
+#include <boost/optional.hpp>
 #include <memory>
 #include <ostream>
 #include <string>
 #include <utility>
 #include <vector>
-#include <boost/optional.hpp>
 
 #include "core/Assignment.h"
 #include "core/Context.h"
@@ -14,26 +14,26 @@ struct Argument {
   boost::optional<std::string> name;
   Value value;
 
-  Argument(boost::optional<std::string> name, Value value) : name(std::move(name)), value(std::move(value)) {
-  }
-  Argument(Argument&& other) = default;
-  Argument& operator=(Argument&& other) = default;
-  Argument(const Argument& other) = delete;
-  Argument& operator=(const Argument& other) = delete;
+  Argument(boost::optional<std::string> name, Value value)
+      : name(std::move(name)), value(std::move(value)) {}
+  Argument(Argument &&other) = default;
+  Argument &operator=(Argument &&other) = default;
+  Argument(const Argument &other) = delete;
+  Argument &operator=(const Argument &other) = delete;
   ~Argument() = default;
 
   const Value *operator->() const { return &value; }
   Value *operator->() { return &value; }
 };
 
-class Arguments : public std::vector<Argument>
-{
+class Arguments : public std::vector<Argument> {
 public:
-  Arguments(const AssignmentList& argument_expressions, const std::shared_ptr<const Context>& context);
-  Arguments(Arguments&& other) = default;
-  Arguments& operator=(Arguments&& other) = default;
-  Arguments(const Arguments& other) = delete;
-  Arguments& operator=(const Arguments& other) = delete;
+  Arguments(const AssignmentList &argument_expressions,
+            const std::shared_ptr<const Context> &context);
+  Arguments(Arguments &&other) = default;
+  Arguments &operator=(Arguments &&other) = default;
+  Arguments(const Arguments &other) = delete;
+  Arguments &operator=(const Arguments &other) = delete;
   ~Arguments() = default;
 
 private:
@@ -42,12 +42,16 @@ private:
 public:
   [[nodiscard]] Arguments clone() const;
 
-  [[nodiscard]] EvaluationSession *session() const { return evaluation_session; }
-  [[nodiscard]] const std::string& documentRoot() const { return evaluation_session->documentRoot(); }
+  [[nodiscard]] EvaluationSession *session() const {
+    return evaluation_session;
+  }
+  [[nodiscard]] const std::string &documentRoot() const {
+    return evaluation_session->documentRoot();
+  }
 
 private:
   EvaluationSession *evaluation_session;
 };
 
-std::ostream& operator<<(std::ostream& stream, const Argument& argument);
-std::ostream& operator<<(std::ostream& stream, const Arguments& arguments);
+std::ostream &operator<<(std::ostream &stream, const Argument &argument);
+std::ostream &operator<<(std::ostream &stream, const Arguments &arguments);
diff --git a/src/core/Assignment.cc b/src/core/Assignment.cc
index 10860e0de..710b2d7c6 100644
--- a/src/core/Assignment.cc
+++ b/src/core/Assignment.cc
@@ -25,47 +25,43 @@
  */
 
 #include "core/Assignment.h"
-#include "core/customizer/Annotation.h"
 #include "core/Expression.h"
+#include "core/customizer/Annotation.h"
 #include <ostream>
 #include <string>
 
-void Assignment::addAnnotations(AnnotationList *annotations)
-{
-  for (auto& annotation : *annotations) {
+void Assignment::addAnnotations(AnnotationList *annotations) {
+  for (auto &annotation : *annotations) {
     this->annotations.insert({annotation.getName(), &annotation});
   }
 }
 
-bool Assignment::hasAnnotations() const
-{
-  return !annotations.empty();
-}
+bool Assignment::hasAnnotations() const { return !annotations.empty(); }
 
-const Annotation *Assignment::annotation(const std::string& name) const
-{
+const Annotation *Assignment::annotation(const std::string &name) const {
   auto found = annotations.find(name);
   return found == annotations.end() ? nullptr : found->second;
 }
 
-
-void Assignment::print(std::ostream& stream, const std::string& indent) const
-{
+void Assignment::print(std::ostream &stream, const std::string &indent) const {
   if (this->hasAnnotations()) {
     const Annotation *group = this->annotation("Group");
-    if (group) group->print(stream, indent);
+    if (group)
+      group->print(stream, indent);
     const Annotation *description = this->annotation("Description");
-    if (description) description->print(stream, indent);
+    if (description)
+      description->print(stream, indent);
     const Annotation *parameter = this->annotation("Parameter");
-    if (parameter) parameter->print(stream, indent);
+    if (parameter)
+      parameter->print(stream, indent);
   }
   stream << indent << this->name << " = " << *this->expr << ";\n";
 }
 
-std::ostream& operator<<(std::ostream& stream, const AssignmentList& assignments)
-{
+std::ostream &operator<<(std::ostream &stream,
+                         const AssignmentList &assignments) {
   bool first = true;
-  for (const auto& assignment : assignments) {
+  for (const auto &assignment : assignments) {
     if (first) {
       first = false;
     } else {
diff --git a/src/core/Assignment.h b/src/core/Assignment.h
index 7a360fc6c..0b4228ea1 100644
--- a/src/core/Assignment.h
+++ b/src/core/Assignment.h
@@ -1,38 +1,39 @@
 #pragma once
 
-#include <unordered_map>
 #include <memory>
 #include <ostream>
 #include <string>
+#include <unordered_map>
 #include <utility>
 #include <vector>
 
 #include "core/AST.h"
 #include "core/customizer/Annotation.h"
 
-class Assignment : public ASTNode
-{
+class Assignment : public ASTNode {
 public:
-  Assignment(std::string name, const Location& loc)
-    : ASTNode(loc), name(std::move(name)), locOfOverwrite(Location::NONE) { }
-  Assignment(std::string name,
-             std::shared_ptr<class Expression> expr = {},
-             const Location& loc = Location::NONE)
-    : ASTNode(loc), name(std::move(name)), expr(std::move(expr)), locOfOverwrite(Location::NONE){ }
-
-  void print(std::ostream& stream, const std::string& indent) const override;
-  const std::string& getName() const { return name; }
-  const std::shared_ptr<Expression>& getExpr() const { return expr; }
-  const AnnotationMap& getAnnotations() const { return annotations; }
+  Assignment(std::string name, const Location &loc)
+      : ASTNode(loc), name(std::move(name)), locOfOverwrite(Location::NONE) {}
+  Assignment(std::string name, std::shared_ptr<class Expression> expr = {},
+             const Location &loc = Location::NONE)
+      : ASTNode(loc), name(std::move(name)), expr(std::move(expr)),
+        locOfOverwrite(Location::NONE) {}
+
+  void print(std::ostream &stream, const std::string &indent) const override;
+  const std::string &getName() const { return name; }
+  const std::shared_ptr<Expression> &getExpr() const { return expr; }
+  const AnnotationMap &getAnnotations() const { return annotations; }
   // setExpr used by customizer ParameterObject etc.
   void setExpr(std::shared_ptr<Expression> e) { expr = std::move(e); }
 
   virtual void addAnnotations(AnnotationList *annotations);
   virtual bool hasAnnotations() const;
-  virtual const Annotation *annotation(const std::string& name) const;
+  virtual const Annotation *annotation(const std::string &name) const;
 
-  const Location& locationOfOverwrite() const { return locOfOverwrite; }
-  void setLocationOfOverwrite(const Location& locOfOverwrite) { this->locOfOverwrite = locOfOverwrite; }
+  const Location &locationOfOverwrite() const { return locOfOverwrite; }
+  void setLocationOfOverwrite(const Location &locOfOverwrite) {
+    this->locOfOverwrite = locOfOverwrite;
+  }
 
 protected:
   const std::string name;
@@ -41,11 +42,12 @@ protected:
   Location locOfOverwrite;
 };
 
-template <class ... Args> std::shared_ptr<Assignment> assignment(Args... args) {
-  return std::make_shared<Assignment>(args ...);
+template <class... Args> std::shared_ptr<Assignment> assignment(Args... args) {
+  return std::make_shared<Assignment>(args...);
 }
 
 using AssignmentList = std::vector<std::shared_ptr<Assignment>>;
 using AssignmentMap = std::unordered_map<std::string, const Expression *>;
 
-std::ostream& operator<<(std::ostream& stream, const AssignmentList& assignments);
+std::ostream &operator<<(std::ostream &stream,
+                         const AssignmentList &assignments);
diff --git a/src/core/BaseVisitable.h b/src/core/BaseVisitable.h
index e78901a4f..806e60d48 100644
--- a/src/core/BaseVisitable.h
+++ b/src/core/BaseVisitable.h
@@ -1,32 +1,29 @@
 #pragma once
 
-
 // FIXME: Default constructor Response()
-enum class Response {ContinueTraversal, AbortTraversal, PruneTraversal};
+enum class Response { ContinueTraversal, AbortTraversal, PruneTraversal };
 
 class State;
 
-class BaseVisitor
-{
+class BaseVisitor {
 public:
   virtual ~BaseVisitor() = default;
 };
 
-template <class T>
-class Visitor
-{
+template <class T> class Visitor {
 public:
-  virtual Response visit(State& state, const T&) = 0;
+  virtual Response visit(State &state, const T &) = 0;
 };
 
-class BaseVisitable
-{
+class BaseVisitable {
 public:
   virtual ~BaseVisitable() = default;
-  virtual Response accept(State&, BaseVisitor&) const = 0;
+  virtual Response accept(State &, BaseVisitor &) const = 0;
+
 protected:
   template <class T>
-  static Response acceptImpl(State& state, const T& node, BaseVisitor& visitor) {
+  static Response acceptImpl(State &state, const T &node,
+                             BaseVisitor &visitor) {
     if (auto *p = dynamic_cast<Visitor<T> *>(&visitor)) {
       return p->visit(state, node);
     }
@@ -37,7 +34,7 @@ protected:
   }
 };
 
-#define VISITABLE() \
-        Response accept(State & state, BaseVisitor & visitor) const override { \
-          return acceptImpl(state, *this, visitor); \
-        }
+#define VISITABLE()                                                            \
+  Response accept(State &state, BaseVisitor &visitor) const override {         \
+    return acceptImpl(state, *this, visitor);                                  \
+  }
diff --git a/src/core/BuiltinContext.cc b/src/core/BuiltinContext.cc
index 76b3c7c46..ca4669ff4 100644
--- a/src/core/BuiltinContext.cc
+++ b/src/core/BuiltinContext.cc
@@ -8,44 +8,50 @@
 #include "core/function.h"
 #include "utils/printutils.h"
 
-BuiltinContext::BuiltinContext(EvaluationSession *session) : Context(session)
-{
-}
+BuiltinContext::BuiltinContext(EvaluationSession *session) : Context(session) {}
 
-void BuiltinContext::init()
-{
-  for (const auto& assignment : Builtins::instance()->getAssignments()) {
-    this->set_variable(assignment->getName(), assignment->getExpr()->evaluate(shared_from_this()));
+void BuiltinContext::init() {
+  for (const auto &assignment : Builtins::instance()->getAssignments()) {
+    this->set_variable(assignment->getName(),
+                       assignment->getExpr()->evaluate(shared_from_this()));
   }
 
   this->set_variable("PI", M_PI);
 }
 
-boost::optional<CallableFunction> BuiltinContext::lookup_local_function(const std::string& name, const Location& loc) const
-{
-  const auto& search = Builtins::instance()->getFunctions().find(name);
+boost::optional<CallableFunction>
+BuiltinContext::lookup_local_function(const std::string &name,
+                                      const Location &loc) const {
+  const auto &search = Builtins::instance()->getFunctions().find(name);
   if (search != Builtins::instance()->getFunctions().end()) {
     BuiltinFunction *f = search->second;
     if (f->is_enabled()) {
       return CallableFunction{f};
     }
 
-    LOG(message_group::Warning, loc, documentRoot(), "Experimental builtin function '%1$s' is not enabled", name);
+    LOG(message_group::Warning, loc, documentRoot(),
+        "Experimental builtin function '%1$s' is not enabled", name);
   }
   return Context::lookup_local_function(name, loc);
 }
 
-boost::optional<InstantiableModule> BuiltinContext::lookup_local_module(const std::string& name, const Location& loc) const
-{
-  const auto& search = Builtins::instance()->getModules().find(name);
+boost::optional<InstantiableModule>
+BuiltinContext::lookup_local_module(const std::string &name,
+                                    const Location &loc) const {
+  const auto &search = Builtins::instance()->getModules().find(name);
   if (search != Builtins::instance()->getModules().end()) {
     AbstractModule *m = search->second;
     if (!m->is_enabled()) {
-      LOG(message_group::Warning, loc, documentRoot(), "Experimental builtin module '%1$s' is not enabled", name);
+      LOG(message_group::Warning, loc, documentRoot(),
+          "Experimental builtin module '%1$s' is not enabled", name);
     }
-    std::string replacement = Builtins::instance()->instance()->isDeprecated(name);
+    std::string replacement =
+        Builtins::instance()->instance()->isDeprecated(name);
     if (!replacement.empty()) {
-      LOG(message_group::Deprecated, loc, documentRoot(), "The %1$s() module will be removed in future releases. Use %2$s instead.", name, replacement);
+      LOG(message_group::Deprecated, loc, documentRoot(),
+          "The %1$s() module will be removed in future releases. Use %2$s "
+          "instead.",
+          name, replacement);
     }
     if (m->is_enabled()) {
       return InstantiableModule{get_shared_ptr(), m};
diff --git a/src/core/BuiltinContext.h b/src/core/BuiltinContext.h
index 4efdf4f17..d9b113179 100644
--- a/src/core/BuiltinContext.h
+++ b/src/core/BuiltinContext.h
@@ -5,12 +5,15 @@
 #include "core/AST.h"
 #include "core/Context.h"
 
-class BuiltinContext : public Context
-{
+class BuiltinContext : public Context {
 public:
   void init() override;
-  boost::optional<CallableFunction> lookup_local_function(const std::string& name, const Location& loc) const override;
-  boost::optional<InstantiableModule> lookup_local_module(const std::string& name, const Location& loc) const override;
+  boost::optional<CallableFunction>
+  lookup_local_function(const std::string &name,
+                        const Location &loc) const override;
+  boost::optional<InstantiableModule>
+  lookup_local_module(const std::string &name,
+                      const Location &loc) const override;
 
 protected:
   BuiltinContext(EvaluationSession *session);
diff --git a/src/core/Builtins.cc b/src/core/Builtins.cc
index 4647fc951..1d3f29e09 100644
--- a/src/core/Builtins.cc
+++ b/src/core/Builtins.cc
@@ -1,19 +1,19 @@
 #include "core/Builtins.h"
 
-#include <unordered_map>
 #include <memory>
 #include <string>
+#include <unordered_map>
 #include <vector>
 
 #include "core/AST.h"
+#include "core/Expression.h"
 #include "core/function.h"
 #include "core/module.h"
-#include "core/Expression.h"
 
-std::unordered_map<std::string, const std::vector<std::string>> Builtins::keywordList;
+std::unordered_map<std::string, const std::vector<std::string>>
+    Builtins::keywordList;
 
-Builtins *Builtins::instance(bool erase)
-{
+Builtins *Builtins::instance(bool erase) {
   static auto *builtins = new Builtins;
   if (erase) {
     delete builtins;
@@ -22,27 +22,29 @@ Builtins *Builtins::instance(bool erase)
   return builtins;
 }
 
-void Builtins::init(const std::string& name, class AbstractModule *module)
-{
+void Builtins::init(const std::string &name, class AbstractModule *module) {
 #ifndef ENABLE_EXPERIMENTAL
-  if (module->is_experimental()) return;
+  if (module->is_experimental())
+    return;
 #endif
   Builtins::instance()->modules.emplace(name, module);
 }
 
-void Builtins::init(const std::string& name, AbstractModule *module, const std::vector<std::string>& calltipList)
-{
+void Builtins::init(const std::string &name, AbstractModule *module,
+                    const std::vector<std::string> &calltipList) {
 #ifndef ENABLE_EXPERIMENTAL
-  if (module->is_experimental()) return;
+  if (module->is_experimental())
+    return;
 #endif
   Builtins::instance()->modules.emplace(name, module);
   Builtins::keywordList.insert({name, calltipList});
 }
 
-void Builtins::init(const std::string& name, BuiltinFunction *function, const std::vector<std::string>& calltipList)
-{
+void Builtins::init(const std::string &name, BuiltinFunction *function,
+                    const std::vector<std::string> &calltipList) {
 #ifndef ENABLE_EXPERIMENTAL
-  if (function->is_experimental()) return;
+  if (function->is_experimental())
+    return;
 #endif
   Builtins::instance()->functions.emplace(name, function);
   Builtins::keywordList.insert({name, calltipList});
@@ -73,8 +75,7 @@ extern void initialize_builtin_dxf_dim();
    Registers all builtin functions.
    Call once for the whole app.
  */
-void Builtins::initialize()
-{
+void Builtins::initialize() {
   Builtins::initKeywordList();
 
   register_builtin_functions();
@@ -102,33 +103,38 @@ void Builtins::initialize()
   this->deprecations.emplace("assign", "a regular assignment");
 }
 
-std::string Builtins::isDeprecated(const std::string& name) const
-{
+std::string Builtins::isDeprecated(const std::string &name) const {
   if (this->deprecations.find(name) != this->deprecations.end()) {
     return this->deprecations.at(name);
   }
   return {};
 }
 
-Builtins::Builtins()
-{
-  this->assignments.emplace_back(new Assignment("$fn", std::make_shared<Literal>(0.0)) );
-  this->assignments.emplace_back(new Assignment("$fs", std::make_shared<Literal>(2.0)) );
-  this->assignments.emplace_back(new Assignment("$fa", std::make_shared<Literal>(12.0)) );
-  this->assignments.emplace_back(new Assignment("$t", std::make_shared<Literal>(0.0)) );
-  this->assignments.emplace_back(new Assignment("$preview", std::make_shared<Literal>()) ); //undef as should always be overwritten.
+Builtins::Builtins() {
+  this->assignments.emplace_back(
+      new Assignment("$fn", std::make_shared<Literal>(0.0)));
+  this->assignments.emplace_back(
+      new Assignment("$fs", std::make_shared<Literal>(2.0)));
+  this->assignments.emplace_back(
+      new Assignment("$fa", std::make_shared<Literal>(12.0)));
+  this->assignments.emplace_back(
+      new Assignment("$t", std::make_shared<Literal>(0.0)));
+  this->assignments.emplace_back(new Assignment(
+      "$preview",
+      std::make_shared<Literal>())); // undef as should always be overwritten.
   auto zeroVector = std::make_shared<Vector>(Location::NONE);
   zeroVector->emplace_back(new Literal(0.0));
   zeroVector->emplace_back(new Literal(0.0));
   zeroVector->emplace_back(new Literal(0.0));
-  this->assignments.emplace_back(new Assignment("$vpt", zeroVector) );
-  this->assignments.emplace_back(new Assignment("$vpr", zeroVector) );
-  this->assignments.emplace_back(new Assignment("$vpd", std::make_shared<Literal>(500.0)) );
-  this->assignments.emplace_back(new Assignment("$vpf", std::make_shared<Literal>(22.5)) );
+  this->assignments.emplace_back(new Assignment("$vpt", zeroVector));
+  this->assignments.emplace_back(new Assignment("$vpr", zeroVector));
+  this->assignments.emplace_back(
+      new Assignment("$vpd", std::make_shared<Literal>(500.0)));
+  this->assignments.emplace_back(
+      new Assignment("$vpf", std::make_shared<Literal>(22.5)));
 }
 
-void Builtins::initKeywordList()
-{
+void Builtins::initKeywordList() {
   Builtins::keywordList.insert({"else", {}});
   Builtins::keywordList.insert({"each", {}});
   Builtins::keywordList.insert({"module", {}});
diff --git a/src/core/Builtins.h b/src/core/Builtins.h
index da90c2ada..8c5ed590d 100644
--- a/src/core/Builtins.h
+++ b/src/core/Builtins.h
@@ -1,31 +1,33 @@
 #pragma once
 
+#include "core/Assignment.h"
+#include "core/module.h"
 #include <string>
 #include <unordered_map>
 #include <vector>
-#include "core/module.h"
-#include "core/Assignment.h"
 
 class AbstractModule;
 class BuiltinFunction;
 
 void initialize_rng();
 
-class Builtins
-{
+class Builtins {
 public:
   static Builtins *instance(bool erase = false);
-  static void init(const std::string& name, AbstractModule *module);
-  static void init(const std::string& name, AbstractModule *module, const std::vector<std::string>& calltipList);
-  static void init(const std::string& name, BuiltinFunction *function, const std::vector<std::string>& calltipList);
+  static void init(const std::string &name, AbstractModule *module);
+  static void init(const std::string &name, AbstractModule *module,
+                   const std::vector<std::string> &calltipList);
+  static void init(const std::string &name, BuiltinFunction *function,
+                   const std::vector<std::string> &calltipList);
   void initialize();
-  std::string isDeprecated(const std::string& name) const;
+  std::string isDeprecated(const std::string &name) const;
 
-  const auto& getAssignments() const { return this->assignments; }
-  const auto& getFunctions() const { return this->functions; }
-  const auto& getModules() const { return this->modules; }
+  const auto &getAssignments() const { return this->assignments; }
+  const auto &getFunctions() const { return this->functions; }
+  const auto &getModules() const { return this->modules; }
 
-  static std::unordered_map<std::string, const std::vector<std::string>> keywordList;
+  static std::unordered_map<std::string, const std::vector<std::string>>
+      keywordList;
 
 private:
   Builtins();
diff --git a/src/core/CSGNode.cc b/src/core/CSGNode.cc
index d7d6bd691..99bc6bafb 100644
--- a/src/core/CSGNode.cc
+++ b/src/core/CSGNode.cc
@@ -29,8 +29,8 @@
 #include "geometry/linalg.h"
 
 #include <cassert>
-#include <memory>
 #include <cstddef>
+#include <memory>
 #include <numeric>
 #include <sstream>
 #include <stack>
@@ -64,17 +64,23 @@
 /*!
    \class CSGProduct
 
-   A CSGProduct is a vector of intersections and a vector of subtractions, used for CSG rendering.
+   A CSGProduct is a vector of intersections and a vector of subtractions, used
+   for CSG rendering.
  */
 
 std::shared_ptr<CSGNode> CSGNode::createEmptySet() {
-  return std::shared_ptr<CSGNode>(new CSGLeaf(nullptr, Transform3d(), Color4f(), "empty()", 0));
+  return std::shared_ptr<CSGNode>(
+      new CSGLeaf(nullptr, Transform3d(), Color4f(), "empty()", 0));
 }
 
-std::shared_ptr<CSGNode> CSGOperation::createCSGNode(OpenSCADOperator type, std::shared_ptr<CSGNode> left, std::shared_ptr<CSGNode> right)
-{
-  // Note that std::shared_ptr<CSGNode> == nullptr is different from having a CSGNode with std::shared_ptr<Geometry> geom == nullptr
-  // The former indicates lack of a geometry node (could be echo or assert node), and the latter represents the empty set of geometry.
+std::shared_ptr<CSGNode>
+CSGOperation::createCSGNode(OpenSCADOperator type,
+                            std::shared_ptr<CSGNode> left,
+                            std::shared_ptr<CSGNode> right) {
+  // Note that std::shared_ptr<CSGNode> == nullptr is different from having a
+  // CSGNode with std::shared_ptr<Geometry> geom == nullptr The former indicates
+  // lack of a geometry node (could be echo or assert node), and the latter
+  // represents the empty set of geometry.
   if (!left && !right) {
     return CSGNode::createEmptySet();
   } else if (!left && right) {
@@ -82,32 +88,38 @@ std::shared_ptr<CSGNode> CSGOperation::createCSGNode(OpenSCADOperator type, std:
   } else if (left && !right) {
     return left;
   } else {
-    // In case we're creating a CSG term from a pruned tree, left or right may be the empty set
+    // In case we're creating a CSG term from a pruned tree, left or right may
+    // be the empty set
     if (right->isEmptySet()) {
-      if (type == OpenSCADOperator::UNION || type == OpenSCADOperator::DIFFERENCE) return left;
-      else return right;
+      if (type == OpenSCADOperator::UNION ||
+          type == OpenSCADOperator::DIFFERENCE)
+        return left;
+      else
+        return right;
     }
     if (left->isEmptySet()) {
-      if (type == OpenSCADOperator::UNION) return right;
-      else return left;
+      if (type == OpenSCADOperator::UNION)
+        return right;
+      else
+        return left;
     }
   }
 
   // Pruning the tree. For details, see "Solid Modeling" by Goldfeather:
   // http://www.cc.gatech.edu/~turk/my_papers/pxpl_csg.pdf
-  const auto& leftbox = left->getBoundingBox();
-  const auto& rightbox = right->getBoundingBox();
+  const auto &leftbox = left->getBoundingBox();
+  const auto &rightbox = right->getBoundingBox();
   Vector3d newmin, newmax;
   if (type == OpenSCADOperator::INTERSECTION) {
-    newmin = leftbox.min().array().cwiseMax(rightbox.min().array() );
-    newmax = leftbox.max().array().cwiseMin(rightbox.max().array() );
+    newmin = leftbox.min().array().cwiseMax(rightbox.min().array());
+    newmax = leftbox.max().array().cwiseMin(rightbox.max().array());
     BoundingBox newbox(newmin, newmax);
     if (newbox.isNull()) {
       return CSGNode::createEmptySet(); // Prune entire product
     }
   } else if (type == OpenSCADOperator::DIFFERENCE) {
-    newmin = leftbox.min().array().cwiseMax(rightbox.min().array() );
-    newmax = leftbox.max().array().cwiseMin(rightbox.max().array() );
+    newmin = leftbox.min().array().cwiseMax(rightbox.min().array());
+    newmax = leftbox.max().array().cwiseMin(rightbox.max().array());
     BoundingBox newbox(newmin, newmax);
     if (newbox.isNull()) {
       return left; // Prune the negative component
@@ -117,31 +129,33 @@ std::shared_ptr<CSGNode> CSGOperation::createCSGNode(OpenSCADOperator type, std:
   return {new CSGOperation(type, left, right), CSGOperationDeleter()};
 }
 
-CSGLeaf::CSGLeaf(const std::shared_ptr<const PolySet>& ps, Transform3d matrix, Color4f color, std::string label, const int index)
-  : label(std::move(label)), matrix(std::move(matrix)), color(std::move(color)), index(index)
-{
-  if (ps && !ps->isEmpty()) this->polyset = ps;
+CSGLeaf::CSGLeaf(const std::shared_ptr<const PolySet> &ps, Transform3d matrix,
+                 Color4f color, std::string label, const int index)
+    : label(std::move(label)), matrix(std::move(matrix)),
+      color(std::move(color)), index(index) {
+  if (ps && !ps->isEmpty())
+    this->polyset = ps;
   CSGLeaf::initBoundingBox();
 }
 
-CSGOperation::CSGOperation(OpenSCADOperator type, const std::shared_ptr<CSGNode>& left, const std::shared_ptr<CSGNode>& right)
-  : type(type)
-{
+CSGOperation::CSGOperation(OpenSCADOperator type,
+                           const std::shared_ptr<CSGNode> &left,
+                           const std::shared_ptr<CSGNode> &right)
+    : type(type) {
   this->children.push_back(left);
   this->children.push_back(right);
   CSGOperation::initBoundingBox();
 }
 
-void CSGLeaf::initBoundingBox()
-{
-  if (!this->polyset) return;
+void CSGLeaf::initBoundingBox() {
+  if (!this->polyset)
+    return;
   this->bbox = this->matrix * this->polyset->getBoundingBox();
 }
 
-void CSGOperation::initBoundingBox()
-{
-  const auto& leftbox = this->left()->getBoundingBox();
-  const auto& rightbox = this->right()->getBoundingBox();
+void CSGOperation::initBoundingBox() {
+  const auto &leftbox = this->left()->getBoundingBox();
+  const auto &rightbox = this->right()->getBoundingBox();
   Vector3d newmin, newmax;
   switch (this->type) {
   case OpenSCADOperator::UNION:
@@ -158,20 +172,15 @@ void CSGOperation::initBoundingBox()
   }
 }
 
-bool CSGLeaf::isEmptySet() const
-{
+bool CSGLeaf::isEmptySet() const {
   return polyset == nullptr || polyset->isEmpty();
 }
 
-std::string CSGLeaf::dump() const
-{
-  return this->label;
-}
+std::string CSGLeaf::dump() const { return this->label; }
 
-// Recursive traversal can cause stack overflow with very large loops of child nodes,
-// so tree is traverse iteratively, managing our own stack.
-std::string CSGOperation::dump() const
-{
+// Recursive traversal can cause stack overflow with very large loops of child
+// nodes, so tree is traverse iteratively, managing our own stack.
+std::string CSGOperation::dump() const {
   // tuple(node pointer, postfix string, ispostfix bool)
   std::stack<std::tuple<const CSGOperation *, std::string, bool>> callstack;
   callstack.emplace(this, "", false);
@@ -181,7 +190,8 @@ std::string CSGOperation::dump() const
   bool ispostfix;
   do {
     std::tie(node, postfixstr, ispostfix) = callstack.top();
-    if (!ispostfix) { // handle left child. only right child uses a prefix string
+    if (!ispostfix) { // handle left child. only right child uses a prefix
+                      // string
       std::string lpostfix;
       switch (node->type) {
       case OpenSCADOperator::UNION:
@@ -226,9 +236,11 @@ std::string CSGOperation::dump() const
   return out.str();
 }
 
-void CSGProducts::import(std::shared_ptr<CSGNode> csgnode, OpenSCADOperator type, CSGNode::Flag flags)
-{
-  std::stack<std::tuple<std::shared_ptr<CSGNode>, OpenSCADOperator, CSGNode::Flag>> callstack;
+void CSGProducts::import(std::shared_ptr<CSGNode> csgnode,
+                         OpenSCADOperator type, CSGNode::Flag flags) {
+  std::stack<
+      std::tuple<std::shared_ptr<CSGNode>, OpenSCADOperator, CSGNode::Flag>>
+      callstack;
   callstack.push(std::make_tuple(csgnode, type, flags));
 
   do {
@@ -241,7 +253,8 @@ void CSGProducts::import(std::shared_ptr<CSGNode> csgnode, OpenSCADOperator type
     auto newflags = static_cast<CSGNode::Flag>(csgnode->getFlags() | flags);
 
     if (auto leaf = std::dynamic_pointer_cast<CSGLeaf>(csgnode)) {
-      if (type == OpenSCADOperator::UNION && this->currentproduct->intersections.size() > 0) {
+      if (type == OpenSCADOperator::UNION &&
+          this->currentproduct->intersections.size() > 0) {
         this->createProduct();
       } else if (type == OpenSCADOperator::DIFFERENCE) {
         this->currentlist = &this->currentproduct->subtractions;
@@ -257,79 +270,67 @@ void CSGProducts::import(std::shared_ptr<CSGNode> csgnode, OpenSCADOperator type
   } while (!callstack.empty());
 }
 
-std::string CSGProduct::dump() const
-{
+std::string CSGProduct::dump() const {
   std::ostringstream dump;
   dump << this->intersections.front().leaf->label;
-  for (const auto& csgobj :
-       boost::make_iterator_range(this->intersections.begin() + 1,
-                                  this->intersections.end())) {
+  for (const auto &csgobj : boost::make_iterator_range(
+           this->intersections.begin() + 1, this->intersections.end())) {
     dump << " *" << csgobj.leaf->label;
   }
-  for (const auto& csgobj : this->subtractions) {
+  for (const auto &csgobj : this->subtractions) {
     dump << " -" << csgobj.leaf->label;
   }
   return dump.str();
 }
 
-BoundingBox CSGProduct::getBoundingBox(bool throwntogether) const
-{
+BoundingBox CSGProduct::getBoundingBox(bool throwntogether) const {
   BoundingBox bbox;
-  if (this->intersections.empty()) return bbox;
+  if (this->intersections.empty())
+    return bbox;
 
   if (throwntogether) {
-    bbox = std::accumulate(
-      this->intersections.cbegin() + 1,
-      this->intersections.cend(),
-      this->intersections.front().leaf->bbox,
-      [](const BoundingBox& a, const CSGChainObject& b) {
-      return a.merged(b.leaf->bbox);
-    }
-      );
-    bbox = std::accumulate(
-      this->subtractions.cbegin(),
-      this->subtractions.cend(),
-      bbox,
-      [](const BoundingBox& a, const CSGChainObject& b) {
-      return a.merged(b.leaf->bbox);
-    }
-      );
+    bbox = std::accumulate(this->intersections.cbegin() + 1,
+                           this->intersections.cend(),
+                           this->intersections.front().leaf->bbox,
+                           [](const BoundingBox &a, const CSGChainObject &b) {
+                             return a.merged(b.leaf->bbox);
+                           });
+    bbox = std::accumulate(this->subtractions.cbegin(),
+                           this->subtractions.cend(), bbox,
+                           [](const BoundingBox &a, const CSGChainObject &b) {
+                             return a.merged(b.leaf->bbox);
+                           });
   } else {
-    bbox = std::accumulate(
-      this->intersections.cbegin() + 1,
-      this->intersections.cend(),
-      this->intersections.front().leaf->bbox,
-      [](const BoundingBox& a, const CSGChainObject& b) {
-      return a.intersection(b.leaf->bbox);
-    }
-      );
+    bbox = std::accumulate(this->intersections.cbegin() + 1,
+                           this->intersections.cend(),
+                           this->intersections.front().leaf->bbox,
+                           [](const BoundingBox &a, const CSGChainObject &b) {
+                             return a.intersection(b.leaf->bbox);
+                           });
   }
   return bbox;
 }
 
-std::string CSGProducts::dump() const
-{
+std::string CSGProducts::dump() const {
   std::ostringstream dump;
 
-  for (const auto& product : this->products) {
+  for (const auto &product : this->products) {
     dump << "+" << product.dump() << "\n";
   }
   return dump.str();
 }
 
-BoundingBox CSGProducts::getBoundingBox(bool throwntogether) const
-{
+BoundingBox CSGProducts::getBoundingBox(bool throwntogether) const {
   BoundingBox bbox;
-  for (const auto& product : this->products) {
+  for (const auto &product : this->products) {
     bbox.extend(product.getBoundingBox(throwntogether));
   }
   return bbox;
 }
 
-size_t CSGProducts::size() const
-{
+size_t CSGProducts::size() const {
   size_t count = 0;
-  for (const auto& product : this->products) {
+  for (const auto &product : this->products) {
     count += product.intersections.size() + product.subtractions.size();
   }
   return count;
diff --git a/src/core/CSGNode.h b/src/core/CSGNode.h
index 6d11bd13c..ec83a53fc 100644
--- a/src/core/CSGNode.h
+++ b/src/core/CSGNode.h
@@ -1,35 +1,38 @@
 #pragma once
 
-#include <utility>
+#include "core/enums.h"
+#include "geometry/linalg.h"
 #include <cstddef>
+#include <memory>
 #include <string>
+#include <utility>
 #include <vector>
-#include <memory>
-#include "geometry/linalg.h"
-#include "core/enums.h"
 
 class PolySet;
 
-class CSGNode
-{
+class CSGNode {
 public:
-  enum Flag {
-    FLAG_NONE = 0x00,
-    FLAG_BACKGROUND = 0x01,
-    FLAG_HIGHLIGHT = 0x02
-  };
+  enum Flag { FLAG_NONE = 0x00, FLAG_BACKGROUND = 0x01, FLAG_HIGHLIGHT = 0x02 };
 
   CSGNode(Flag flags = FLAG_NONE) : flags(flags) {}
   virtual ~CSGNode() = default;
   [[nodiscard]] virtual std::string dump() const = 0;
   [[nodiscard]] virtual bool isEmptySet() const { return false; }
 
-  [[nodiscard]] const BoundingBox& getBoundingBox() const { return this->bbox; }
+  [[nodiscard]] const BoundingBox &getBoundingBox() const { return this->bbox; }
   [[nodiscard]] unsigned int getFlags() const { return this->flags; }
-  [[nodiscard]] bool isHighlight() const { return this->flags & FLAG_HIGHLIGHT; }
-  [[nodiscard]] bool isBackground() const { return this->flags & FLAG_BACKGROUND; }
-  void setHighlight(bool on) { on ? this->flags |= FLAG_HIGHLIGHT : this->flags &= ~FLAG_HIGHLIGHT; }
-  void setBackground(bool on) { on ? this->flags |= FLAG_BACKGROUND : this->flags &= ~FLAG_BACKGROUND; }
+  [[nodiscard]] bool isHighlight() const {
+    return this->flags & FLAG_HIGHLIGHT;
+  }
+  [[nodiscard]] bool isBackground() const {
+    return this->flags & FLAG_BACKGROUND;
+  }
+  void setHighlight(bool on) {
+    on ? this->flags |= FLAG_HIGHLIGHT : this->flags &= ~FLAG_HIGHLIGHT;
+  }
+  void setBackground(bool on) {
+    on ? this->flags |= FLAG_BACKGROUND : this->flags &= ~FLAG_BACKGROUND;
+  }
 
   static std::shared_ptr<CSGNode> createEmptySet();
 
@@ -43,30 +46,36 @@ protected:
   friend class CSGProducts;
 };
 
-class CSGOperation : public CSGNode
-{
+class CSGOperation : public CSGNode {
 public:
   CSGOperation() = default;
   void initBoundingBox() override;
   [[nodiscard]] std::string dump() const override;
 
-  std::shared_ptr<CSGNode>& left() { return this->children[0]; }
-  std::shared_ptr<CSGNode>& right() { return this->children[1]; }
-  [[nodiscard]] const std::shared_ptr<CSGNode>& left() const { return this->children[0]; }
-  [[nodiscard]] const std::shared_ptr<CSGNode>& right() const { return this->children[1]; }
+  std::shared_ptr<CSGNode> &left() { return this->children[0]; }
+  std::shared_ptr<CSGNode> &right() { return this->children[1]; }
+  [[nodiscard]] const std::shared_ptr<CSGNode> &left() const {
+    return this->children[0];
+  }
+  [[nodiscard]] const std::shared_ptr<CSGNode> &right() const {
+    return this->children[1];
+  }
 
   [[nodiscard]] OpenSCADOperator getType() const { return this->type; }
 
-  static std::shared_ptr<CSGNode> createCSGNode(OpenSCADOperator type, std::shared_ptr<CSGNode> left, std::shared_ptr<CSGNode> right);
+  static std::shared_ptr<CSGNode> createCSGNode(OpenSCADOperator type,
+                                                std::shared_ptr<CSGNode> left,
+                                                std::shared_ptr<CSGNode> right);
 
 private:
-  CSGOperation(OpenSCADOperator type, const std::shared_ptr<CSGNode>& left, const std::shared_ptr<CSGNode>& right);
+  CSGOperation(OpenSCADOperator type, const std::shared_ptr<CSGNode> &left,
+               const std::shared_ptr<CSGNode> &right);
   OpenSCADOperator type;
   std::vector<std::shared_ptr<CSGNode>> children;
 };
 
-// very large lists of children can overflow stack due to recursive destruction of shared_ptr,
-// so move shared_ptrs into a temporary vector
+// very large lists of children can overflow stack due to recursive destruction
+// of shared_ptr, so move shared_ptrs into a temporary vector
 struct CSGOperationDeleter {
   void operator()(CSGOperation *node) {
     std::vector<std::shared_ptr<CSGNode>> purge;
@@ -84,11 +93,11 @@ struct CSGOperationDeleter {
   }
 };
 
-class CSGLeaf : public CSGNode
-{
+class CSGLeaf : public CSGNode {
 public:
   EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-  CSGLeaf(const std::shared_ptr<const PolySet>& ps, Transform3d matrix, Color4f color, std::string label, const int index);
+  CSGLeaf(const std::shared_ptr<const PolySet> &ps, Transform3d matrix,
+          Color4f color, std::string label, const int index);
   void initBoundingBox() override;
   [[nodiscard]] bool isEmptySet() const override;
   [[nodiscard]] std::string dump() const override;
@@ -106,18 +115,17 @@ public:
    Flags are accumulated in the CSG tree, so the rendered object may
    have different flags than the corresponding leaf node.
  */
-class CSGChainObject
-{
+class CSGChainObject {
 public:
-  CSGChainObject(const std::shared_ptr<CSGLeaf>& leaf, CSGNode::Flag flags = CSGNode::FLAG_NONE)
-    : leaf(leaf), flags(flags) {}
+  CSGChainObject(const std::shared_ptr<CSGLeaf> &leaf,
+                 CSGNode::Flag flags = CSGNode::FLAG_NONE)
+      : leaf(leaf), flags(flags) {}
 
   std::shared_ptr<CSGLeaf> leaf;
   CSGNode::Flag flags;
 };
 
-class CSGProduct
-{
+class CSGProduct {
 public:
   CSGProduct() = default;
 
@@ -128,14 +136,13 @@ public:
   std::vector<CSGChainObject> subtractions;
 };
 
-class CSGProducts
-{
+class CSGProducts {
 public:
-  CSGProducts() {
-    this->createProduct();
-  }
+  CSGProducts() { this->createProduct(); }
 
-  void import(std::shared_ptr<CSGNode> csgtree, OpenSCADOperator type = OpenSCADOperator::UNION, CSGNode::Flag flags = CSGNode::FLAG_NONE);
+  void import(std::shared_ptr<CSGNode> csgtree,
+              OpenSCADOperator type = OpenSCADOperator::UNION,
+              CSGNode::Flag flags = CSGNode::FLAG_NONE);
   [[nodiscard]] std::string dump() const;
   [[nodiscard]] BoundingBox getBoundingBox(bool throwntogether = false) const;
 
diff --git a/src/core/CSGTreeEvaluator.cc b/src/core/CSGTreeEvaluator.cc
index 278ef0d55..025729b75 100644
--- a/src/core/CSGTreeEvaluator.cc
+++ b/src/core/CSGTreeEvaluator.cc
@@ -1,41 +1,42 @@
 #include "core/CSGTreeEvaluator.h"
-#include "geometry/Geometry.h"
-#include "geometry/linalg.h"
-#include "core/State.h"
-#include "core/CsgOpNode.h"
-#include "core/ModuleInstantiation.h"
 #include "core/CSGNode.h"
-#include "core/TransformNode.h"
+#include "core/CgalAdvNode.h"
 #include "core/ColorNode.h"
+#include "core/CsgOpNode.h"
+#include "core/ModuleInstantiation.h"
 #include "core/RenderNode.h"
-#include "core/CgalAdvNode.h"
-#include "utils/printutils.h"
+#include "core/State.h"
+#include "core/TransformNode.h"
+#include "geometry/Geometry.h"
 #include "geometry/GeometryEvaluator.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetBuilder.h"
+#include "geometry/linalg.h"
+#include "utils/printutils.h"
 
-#include <memory>
-#include <string>
-#include <map>
-#include <list>
+#include <boost/range/adaptor/reversed.hpp>
 #include <cassert>
 #include <cstddef>
-#include <boost/range/adaptor/reversed.hpp>
+#include <list>
+#include <map>
+#include <memory>
+#include <string>
 
 /*!
    \class CSGTreeEvaluator
 
-   A visitor responsible for creating a binary tree of CSGNode nodes used for rendering
-   with OpenCSG.
+   A visitor responsible for creating a binary tree of CSGNode nodes used for
+   rendering with OpenCSG.
  */
 
-std::shared_ptr<CSGNode> CSGTreeEvaluator::buildCSGTree(const AbstractNode& node)
-{
+std::shared_ptr<CSGNode>
+CSGTreeEvaluator::buildCSGTree(const AbstractNode &node) {
   this->traverse(node);
 
   std::shared_ptr<CSGNode> t(this->stored_term[node.index()]);
   if (t) {
-    if (t->isHighlight()) this->highlightNodes.push_back(t);
+    if (t->isHighlight())
+      this->highlightNodes.push_back(t);
     if (t->isBackground()) {
       this->backgroundNodes.push_back(t);
       t.reset();
@@ -45,28 +46,30 @@ std::shared_ptr<CSGNode> CSGTreeEvaluator::buildCSGTree(const AbstractNode& node
   return this->rootNode = t;
 }
 
-void CSGTreeEvaluator::applyBackgroundAndHighlight(State& /*state*/, const AbstractNode& node)
-{
-  for (const auto& chnode : this->visitedchildren[node.index()]) {
+void CSGTreeEvaluator::applyBackgroundAndHighlight(State & /*state*/,
+                                                   const AbstractNode &node) {
+  for (const auto &chnode : this->visitedchildren[node.index()]) {
     std::shared_ptr<CSGNode> t(this->stored_term[chnode->index()]);
     this->stored_term.erase(chnode->index());
     if (t) {
-      if (t->isBackground()) this->backgroundNodes.push_back(t);
-      if (t->isHighlight()) this->highlightNodes.push_back(t);
+      if (t->isBackground())
+        this->backgroundNodes.push_back(t);
+      if (t->isHighlight())
+        this->highlightNodes.push_back(t);
     }
   }
 }
 
-void CSGTreeEvaluator::applyToChildren(State& state, const AbstractNode& node, OpenSCADOperator op)
-{
-  const auto& vc = this->visitedchildren[node.index()];
+void CSGTreeEvaluator::applyToChildren(State &state, const AbstractNode &node,
+                                       OpenSCADOperator op) {
+  const auto &vc = this->visitedchildren[node.index()];
   if (vc.empty()) {
     this->stored_term[node.index()] = CSGNode::createEmptySet();
     return;
   }
 
   std::shared_ptr<CSGNode> t1;
-  for (const auto& chnode : vc) {
+  for (const auto &chnode : vc) {
     std::shared_ptr<CSGNode> t2(this->stored_term[chnode->index()]);
     this->stored_term.erase(chnode->index());
     if (t2 && !t1) {
@@ -95,8 +98,8 @@ void CSGTreeEvaluator::applyToChildren(State& state, const AbstractNode& node, O
         }
         break;
       case OpenSCADOperator::INTERSECTION:
-        if (t && !t->isEmptySet() && t != t1 && t != t2 &&
-            t1->isHighlight() && t2->isHighlight()) {
+        if (t && !t->isEmptySet() && t != t1 && t != t2 && t1->isHighlight() &&
+            t2->isHighlight()) {
           t->setHighlight(true);
         } else {
           if (t != t1 && t1->isHighlight()) {
@@ -108,8 +111,7 @@ void CSGTreeEvaluator::applyToChildren(State& state, const AbstractNode& node, O
         }
         break;
       case OpenSCADOperator::UNION:
-        if (t != t1 && t != t2 &&
-            t1->isHighlight() && t2->isHighlight()) {
+        if (t != t1 && t != t2 && t1->isHighlight() && t2->isHighlight()) {
           t->setHighlight(true);
         } else if (t != t1 && t1->isHighlight()) {
           this->highlightNodes.push_back(t1);
@@ -129,14 +131,15 @@ void CSGTreeEvaluator::applyToChildren(State& state, const AbstractNode& node, O
     }
   }
   if (t1) {
-    if (node.modinst->isBackground() || state.isBackground()) t1->setBackground(true);
-    if (node.modinst->isHighlight() || state.isHighlight()) t1->setHighlight(true);
+    if (node.modinst->isBackground() || state.isBackground())
+      t1->setBackground(true);
+    if (node.modinst->isHighlight() || state.isHighlight())
+      t1->setHighlight(true);
   }
   this->stored_term[node.index()] = t1;
 }
 
-Response CSGTreeEvaluator::visit(State& state, const AbstractNode& node)
-{
+Response CSGTreeEvaluator::visit(State &state, const AbstractNode &node) {
   if (state.isPostfix()) {
     applyToChildren(state, node, OpenSCADOperator::UNION);
     addToParent(state, node);
@@ -144,8 +147,8 @@ Response CSGTreeEvaluator::visit(State& state, const AbstractNode& node)
   return Response::ContinueTraversal;
 }
 
-Response CSGTreeEvaluator::visit(State& state, const AbstractIntersectionNode& node)
-{
+Response CSGTreeEvaluator::visit(State &state,
+                                 const AbstractIntersectionNode &node) {
   if (state.isPostfix()) {
     applyToChildren(state, node, OpenSCADOperator::INTERSECTION);
     addToParent(state, node);
@@ -153,63 +156,63 @@ Response CSGTreeEvaluator::visit(State& state, const AbstractIntersectionNode& n
   return Response::ContinueTraversal;
 }
 
-Response CSGTreeEvaluator::visit(State& state, const class ListNode &node)
-{
+Response CSGTreeEvaluator::visit(State &state, const class ListNode &node) {
   if (state.parent()) {
     if (state.isPrefix()) {
-      if (node.modinst->isHighlight()) state.setHighlight(true);
-      if (node.modinst->isBackground()) state.setBackground(true);
+      if (node.modinst->isHighlight())
+        state.setHighlight(true);
+      if (node.modinst->isBackground())
+        state.setBackground(true);
     }
     if (state.isPostfix()) {
-      for (auto& chnode : this->visitedchildren[node.index()]) {
+      for (auto &chnode : this->visitedchildren[node.index()]) {
         addToParent(state, *chnode);
       }
     }
     return Response::ContinueTraversal;
   } else {
     // Handle root modifier on ListNode just like a group
-    return visit(state, (const AbstractNode&)node);
+    return visit(state, (const AbstractNode &)node);
   }
-
 }
 
 // Creates a 1-unit-thick PolySet with dim==2 from a Polygon2d.
-std::shared_ptr<const PolySet> polygon2dToPolySet(const Polygon2d& p2d) {
+std::shared_ptr<const PolySet> polygon2dToPolySet(const Polygon2d &p2d) {
   const auto ps = p2d.tessellate();
   constexpr int dim = 2;
   // Estimating num vertices and polygons: top + bottom + sides
   PolySetBuilder builder(ps->vertices.size() * 2,
-                         ps->indices.size() * 2 + ps->vertices.size(),
-                         dim, p2d.is_convex());
+                         ps->indices.size() * 2 + ps->vertices.size(), dim,
+                         p2d.is_convex());
   builder.setConvexity(p2d.getConvexity());
 
   // Create bottom face.
-  for (const auto& poly : ps->indices) {
+  for (const auto &poly : ps->indices) {
     builder.beginPolygon(poly.size());
     // Flip vertex ordering for bottom polygon
-    for (const auto& ind: boost::adaptors::reverse(poly)) {
+    for (const auto &ind : boost::adaptors::reverse(poly)) {
       builder.addVertex(ps->vertices[ind] - Vector3d(0, 0, 0.5));
     }
   }
 
   // Create top face.
-  for (const auto& poly : ps->indices) {
+  for (const auto &poly : ps->indices) {
     builder.beginPolygon(poly.size());
-    for (const auto& ind: poly) {
+    for (const auto &ind : poly) {
       builder.addVertex(ps->vertices[ind] + Vector3d(0, 0, 0.5));
     }
   }
 
   // Create sides
-  for (const auto& o : p2d.outlines()) {
+  for (const auto &o : p2d.outlines()) {
     for (size_t i = 0; i < o.vertices.size(); ++i) {
-      const Vector2d& prev = o.vertices[i];
-      const Vector2d& curr = o.vertices[(i + 1) % o.vertices.size()];
+      const Vector2d &prev = o.vertices[i];
+      const Vector2d &curr = o.vertices[(i + 1) % o.vertices.size()];
       builder.appendPolygon({
-        Vector3d(prev[0], prev[1], -0.5),
-        Vector3d(curr[0], curr[1], -0.5),
-        Vector3d(curr[0], curr[1], 0.5),
-        Vector3d(prev[0], prev[1], 0.5),
+          Vector3d(prev[0], prev[1], -0.5),
+          Vector3d(curr[0], curr[1], -0.5),
+          Vector3d(curr[0], curr[1], 0.5),
+          Vector3d(prev[0], prev[1], 0.5),
       });
     }
   }
@@ -217,11 +220,9 @@ std::shared_ptr<const PolySet> polygon2dToPolySet(const Polygon2d& p2d) {
   return builder.build();
 }
 
-
 std::shared_ptr<CSGNode> CSGTreeEvaluator::evaluateCSGNodeFromGeometry(
-  State& state, const std::shared_ptr<const Geometry>& geom,
-  const ModuleInstantiation *modinst, const AbstractNode& node)
-{
+    State &state, const std::shared_ptr<const Geometry> &geom,
+    const ModuleInstantiation *modinst, const AbstractNode &node) {
   assert(geom);
   // We cannot render Polygon2d directly, so we convert it to a PolySet here
   std::shared_ptr<const PolySet> ps;
@@ -229,20 +230,24 @@ std::shared_ptr<CSGNode> CSGTreeEvaluator::evaluateCSGNodeFromGeometry(
     if (auto p2d = std::dynamic_pointer_cast<const Polygon2d>(geom)) {
       ps = polygon2dToPolySet(*p2d);
     }
-    // 3D PolySets are tessellated before inserting into Geometry cache, inside GeometryEvaluator::evaluateGeometry
+    // 3D PolySets are tessellated before inserting into Geometry cache, inside
+    // GeometryEvaluator::evaluateGeometry
     else {
       ps = std::dynamic_pointer_cast<const PolySet>(geom);
     }
   }
 
-  std::shared_ptr<CSGNode> t(new CSGLeaf(ps, state.matrix(), state.color(), STR(node.name(), node.index()), node.index()));
-  if (modinst->isHighlight() || state.isHighlight()) t->setHighlight(true);
-  if (modinst->isBackground() || state.isBackground()) t->setBackground(true);
+  std::shared_ptr<CSGNode> t(new CSGLeaf(ps, state.matrix(), state.color(),
+                                         STR(node.name(), node.index()),
+                                         node.index()));
+  if (modinst->isHighlight() || state.isHighlight())
+    t->setHighlight(true);
+  if (modinst->isBackground() || state.isBackground())
+    t->setBackground(true);
   return t;
 }
 
-Response CSGTreeEvaluator::visit(State& state, const AbstractPolyNode& node)
-{
+Response CSGTreeEvaluator::visit(State &state, const AbstractPolyNode &node) {
   if (state.isPostfix()) {
     std::shared_ptr<CSGNode> t1;
     if (this->geomevaluator) {
@@ -260,8 +265,7 @@ Response CSGTreeEvaluator::visit(State& state, const AbstractPolyNode& node)
   return Response::ContinueTraversal;
 }
 
-Response CSGTreeEvaluator::visit(State& state, const CsgOpNode& node)
-{
+Response CSGTreeEvaluator::visit(State &state, const CsgOpNode &node) {
   if (state.isPostfix()) {
     applyToChildren(state, node, node.type);
     addToParent(state, node);
@@ -269,11 +273,12 @@ Response CSGTreeEvaluator::visit(State& state, const CsgOpNode& node)
   return Response::ContinueTraversal;
 }
 
-Response CSGTreeEvaluator::visit(State& state, const TransformNode& node)
-{
+Response CSGTreeEvaluator::visit(State &state, const TransformNode &node) {
   if (state.isPrefix()) {
-    if (matrix_contains_infinity(node.matrix) || matrix_contains_nan(node.matrix)) {
-      LOG(message_group::Warning, "Transformation matrix contains Not-a-Number and/or Infinity - removing object.");
+    if (matrix_contains_infinity(node.matrix) ||
+        matrix_contains_nan(node.matrix)) {
+      LOG(message_group::Warning, "Transformation matrix contains Not-a-Number "
+                                  "and/or Infinity - removing object.");
       return Response::PruneTraversal;
     }
     state.setMatrix(state.matrix() * node.matrix);
@@ -285,10 +290,10 @@ Response CSGTreeEvaluator::visit(State& state, const TransformNode& node)
   return Response::ContinueTraversal;
 }
 
-Response CSGTreeEvaluator::visit(State& state, const ColorNode& node)
-{
+Response CSGTreeEvaluator::visit(State &state, const ColorNode &node) {
   if (state.isPrefix()) {
-    if (!state.color().isValid()) state.setColor(node.color);
+    if (!state.color().isValid())
+      state.setColor(node.color);
   }
   if (state.isPostfix()) {
     applyToChildren(state, node, OpenSCADOperator::UNION);
@@ -297,9 +302,9 @@ Response CSGTreeEvaluator::visit(State& state, const ColorNode& node)
   return Response::ContinueTraversal;
 }
 
-// FIXME: If we've got CGAL support, render this node as a CGAL union into a PolySet
-Response CSGTreeEvaluator::visit(State& state, const RenderNode& node)
-{
+// FIXME: If we've got CGAL support, render this node as a CGAL union into a
+// PolySet
+Response CSGTreeEvaluator::visit(State &state, const RenderNode &node) {
   if (state.isPostfix()) {
     std::shared_ptr<CSGNode> t1;
     std::shared_ptr<const Geometry> geom;
@@ -318,11 +323,11 @@ Response CSGTreeEvaluator::visit(State& state, const RenderNode& node)
   return Response::ContinueTraversal;
 }
 
-Response CSGTreeEvaluator::visit(State& state, const CgalAdvNode& node)
-{
+Response CSGTreeEvaluator::visit(State &state, const CgalAdvNode &node) {
   if (state.isPostfix()) {
     std::shared_ptr<CSGNode> t1;
-    // FIXME: Calling evaluator directly since we're not a PolyNode. Generalize this.
+    // FIXME: Calling evaluator directly since we're not a PolyNode. Generalize
+    // this.
     std::shared_ptr<const Geometry> geom;
     if (this->geomevaluator) {
       geom = this->geomevaluator->evaluateGeometry(node, false);
@@ -343,12 +348,15 @@ Response CSGTreeEvaluator::visit(State& state, const CgalAdvNode& node)
 /*!
    Adds ourself to out parent's list of traversed children.
    Call this for _every_ node which affects output during traversal.
-    Usually, this should be called from the postfix stage, but for some nodes, we defer traversal letting other components (e.g. CGAL) render the subgraph, and we'll then call this from prefix and prune further traversal.
+    Usually, this should be called from the postfix stage, but for some nodes,
+   we defer traversal letting other components (e.g. CGAL) render the subgraph,
+   and we'll then call this from prefix and prune further traversal.
  */
-void CSGTreeEvaluator::addToParent(const State& state, const AbstractNode& node)
-{
+void CSGTreeEvaluator::addToParent(const State &state,
+                                   const AbstractNode &node) {
   this->visitedchildren.erase(node.index());
   if (state.parent()) {
-    this->visitedchildren[state.parent()->index()].push_back(node.shared_from_this());
+    this->visitedchildren[state.parent()->index()].push_back(
+        node.shared_from_this());
   }
 }
diff --git a/src/core/CSGTreeEvaluator.h b/src/core/CSGTreeEvaluator.h
index 2edd0d2f7..f57daae05 100644
--- a/src/core/CSGTreeEvaluator.h
+++ b/src/core/CSGTreeEvaluator.h
@@ -1,65 +1,66 @@
 #pragma once
 
-#include <map>
-#include <list>
-#include <vector>
-#include <cstddef>
-#include "core/NodeVisitor.h"
-#include <memory>
+#include "core/CSGNode.h"
 #include "core/ModuleInstantiation.h"
+#include "core/NodeVisitor.h"
 #include "geometry/Geometry.h"
-#include "core/CSGNode.h"
+#include <cstddef>
+#include <list>
+#include <map>
+#include <memory>
+#include <vector>
 
 class CSGNode;
 class GeometryEvaluator;
 class Tree;
 
-class CSGTreeEvaluator : public NodeVisitor
-{
+class CSGTreeEvaluator : public NodeVisitor {
 public:
-  CSGTreeEvaluator(const Tree& tree, GeometryEvaluator *geomevaluator = nullptr)
-    : tree(tree), geomevaluator(geomevaluator) {
-  }
+  CSGTreeEvaluator(const Tree &tree, GeometryEvaluator *geomevaluator = nullptr)
+      : tree(tree), geomevaluator(geomevaluator) {}
 
-  Response visit(State& state, const AbstractNode& node) override;
-  Response visit(State& state, const AbstractIntersectionNode& node) override;
-  Response visit(State& state, const AbstractPolyNode& node) override;
-  Response visit(State& state, const ListNode& node) override;
-  Response visit(State& state, const CsgOpNode& node) override;
-  Response visit(State& state, const TransformNode& node) override;
-  Response visit(State& state, const ColorNode& node) override;
-  Response visit(State& state, const RenderNode& node) override;
-  Response visit(State& state, const CgalAdvNode& node) override;
+  Response visit(State &state, const AbstractNode &node) override;
+  Response visit(State &state, const AbstractIntersectionNode &node) override;
+  Response visit(State &state, const AbstractPolyNode &node) override;
+  Response visit(State &state, const ListNode &node) override;
+  Response visit(State &state, const CsgOpNode &node) override;
+  Response visit(State &state, const TransformNode &node) override;
+  Response visit(State &state, const ColorNode &node) override;
+  Response visit(State &state, const RenderNode &node) override;
+  Response visit(State &state, const CgalAdvNode &node) override;
 
-  std::shared_ptr<CSGNode> buildCSGTree(const AbstractNode& node);
+  std::shared_ptr<CSGNode> buildCSGTree(const AbstractNode &node);
 
-  [[nodiscard]] const std::shared_ptr<CSGNode>& getRootNode() const {
+  [[nodiscard]] const std::shared_ptr<CSGNode> &getRootNode() const {
     return this->rootNode;
   }
-  [[nodiscard]] const std::vector<std::shared_ptr<CSGNode>>& getHighlightNodes() const {
+  [[nodiscard]] const std::vector<std::shared_ptr<CSGNode>> &
+  getHighlightNodes() const {
     return this->highlightNodes;
   }
-  [[nodiscard]] const std::vector<std::shared_ptr<CSGNode>>& getBackgroundNodes() const {
+  [[nodiscard]] const std::vector<std::shared_ptr<CSGNode>> &
+  getBackgroundNodes() const {
     return this->backgroundNodes;
   }
 
 private:
-  void addToParent(const State& state, const AbstractNode& node);
-  void applyToChildren(State& state, const AbstractNode& node, OpenSCADOperator op);
-  std::shared_ptr<CSGNode> evaluateCSGNodeFromGeometry(State& state,
-                                                       const std::shared_ptr<const Geometry>& geom,
-                                                       const ModuleInstantiation *modinst,
-                                                       const AbstractNode& node);
-  void applyBackgroundAndHighlight(State& state, const AbstractNode& node);
+  void addToParent(const State &state, const AbstractNode &node);
+  void applyToChildren(State &state, const AbstractNode &node,
+                       OpenSCADOperator op);
+  std::shared_ptr<CSGNode> evaluateCSGNodeFromGeometry(
+      State &state, const std::shared_ptr<const Geometry> &geom,
+      const ModuleInstantiation *modinst, const AbstractNode &node);
+  void applyBackgroundAndHighlight(State &state, const AbstractNode &node);
 
   using ChildList = std::list<std::shared_ptr<const AbstractNode>>;
   std::map<int, ChildList> visitedchildren;
 
 protected:
-  const Tree& tree;
+  const Tree &tree;
   GeometryEvaluator *geomevaluator;
   std::shared_ptr<CSGNode> rootNode;
   std::vector<std::shared_ptr<CSGNode>> highlightNodes;
   std::vector<std::shared_ptr<CSGNode>> backgroundNodes;
-  std::map<int, std::shared_ptr<CSGNode>> stored_term; // The term evaluated from each node index
+  std::map<int, std::shared_ptr<CSGNode>>
+      stored_term; // The term evaluated from each node index
 };
diff --git a/src/core/CgalAdvNode.cc b/src/core/CgalAdvNode.cc
index 9df2a48e3..4b2da28fa 100644
--- a/src/core/CgalAdvNode.cc
+++ b/src/core/CgalAdvNode.cc
@@ -25,67 +25,81 @@
  */
 
 #include "core/CgalAdvNode.h"
-#include "core/module.h"
-#include "core/ModuleInstantiation.h"
 #include "core/Builtins.h"
 #include "core/Children.h"
+#include "core/ModuleInstantiation.h"
 #include "core/Parameters.h"
-#include <utility>
+#include "core/module.h"
+#include <boost/assign/std/vector.hpp>
+#include <cassert>
 #include <memory>
 #include <sstream>
-#include <cassert>
-#include <boost/assign/std/vector.hpp>
+#include <utility>
 using namespace boost::assign; // bring 'operator+=()' into scope
 
-static std::shared_ptr<AbstractNode> builtin_minkowski(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+static std::shared_ptr<AbstractNode>
+builtin_minkowski(const ModuleInstantiation *inst, Arguments arguments,
+                  const Children &children) {
   auto node = std::make_shared<CgalAdvNode>(inst, CgalAdvType::MINKOWSKI);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"convexity"});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {"convexity"});
   node->convexity = static_cast<int>(parameters["convexity"].toDouble());
 
   return children.instantiate(node);
 }
 
-static std::shared_ptr<AbstractNode> builtin_hull(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+static std::shared_ptr<AbstractNode>
+builtin_hull(const ModuleInstantiation *inst, Arguments arguments,
+             const Children &children) {
   auto node = std::make_shared<CgalAdvNode>(inst, CgalAdvType::HULL);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {});
   node->convexity = 0;
 
   return children.instantiate(node);
 }
 
-static std::shared_ptr<AbstractNode> builtin_fill(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+static std::shared_ptr<AbstractNode>
+builtin_fill(const ModuleInstantiation *inst, Arguments arguments,
+             const Children &children) {
   auto node = std::make_shared<CgalAdvNode>(inst, CgalAdvType::FILL);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {});
 
   return children.instantiate(node);
 }
 
-static std::shared_ptr<AbstractNode> builtin_resize(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+static std::shared_ptr<AbstractNode>
+builtin_resize(const ModuleInstantiation *inst, Arguments arguments,
+               const Children &children) {
   auto node = std::make_shared<CgalAdvNode>(inst, CgalAdvType::RESIZE);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"newsize", "auto", "convexity"});
+  Parameters parameters = Parameters::parse(
+      std::move(arguments), inst->location(), {"newsize", "auto", "convexity"});
   node->convexity = static_cast<int>(parameters["convexity"].toDouble());
   node->newsize << 0, 0, 0;
   if (parameters["newsize"].type() == Value::Type::VECTOR) {
-    const auto& vs = parameters["newsize"].toVector();
-    if (vs.size() >= 1) node->newsize[0] = vs[0].toDouble();
-    if (vs.size() >= 2) node->newsize[1] = vs[1].toDouble();
-    if (vs.size() >= 3) node->newsize[2] = vs[2].toDouble();
+    const auto &vs = parameters["newsize"].toVector();
+    if (vs.size() >= 1)
+      node->newsize[0] = vs[0].toDouble();
+    if (vs.size() >= 2)
+      node->newsize[1] = vs[1].toDouble();
+    if (vs.size() >= 3)
+      node->newsize[2] = vs[2].toDouble();
   }
-  const auto& autosize = parameters["auto"];
+  const auto &autosize = parameters["auto"];
   node->autosize << false, false, false;
   if (autosize.type() == Value::Type::VECTOR) {
-    const auto& va = autosize.toVector();
-    if (va.size() >= 1) node->autosize[0] = va[0].toBool();
-    if (va.size() >= 2) node->autosize[1] = va[1].toBool();
-    if (va.size() >= 3) node->autosize[2] = va[2].toBool();
+    const auto &va = autosize.toVector();
+    if (va.size() >= 1)
+      node->autosize[0] = va[0].toBool();
+    if (va.size() >= 2)
+      node->autosize[1] = va[1].toBool();
+    if (va.size() >= 3)
+      node->autosize[2] = va[2].toBool();
   } else if (autosize.type() == Value::Type::BOOL) {
     node->autosize << autosize.toBool(), autosize.toBool(), autosize.toBool();
   }
@@ -93,8 +107,7 @@ static std::shared_ptr<AbstractNode> builtin_resize(const ModuleInstantiation *i
   return children.instantiate(node);
 }
 
-std::string CgalAdvNode::name() const
-{
+std::string CgalAdvNode::name() const {
   switch (this->type) {
   case CgalAdvType::MINKOWSKI:
     return "minkowski";
@@ -114,8 +127,7 @@ std::string CgalAdvNode::name() const
   return "internal_error";
 }
 
-std::string CgalAdvNode::toString() const
-{
+std::string CgalAdvNode::toString() const {
   std::ostringstream stream;
 
   stream << this->name();
@@ -128,12 +140,11 @@ std::string CgalAdvNode::toString() const
     stream << "()";
     break;
   case CgalAdvType::RESIZE:
-    stream << "(newsize = ["
-           << this->newsize[0] << "," << this->newsize[1] << "," << this->newsize[2] << "]"
-           << ", auto = ["
-           << this->autosize[0] << "," << this->autosize[1] << "," << this->autosize[2] << "]"
-           << ", convexity = " << this->convexity
-           << ")";
+    stream << "(newsize = [" << this->newsize[0] << "," << this->newsize[1]
+           << "," << this->newsize[2] << "]"
+           << ", auto = [" << this->autosize[0] << "," << this->autosize[1]
+           << "," << this->autosize[2] << "]"
+           << ", convexity = " << this->convexity << ")";
     break;
   default:
     assert(false);
@@ -142,28 +153,28 @@ std::string CgalAdvNode::toString() const
   return stream.str();
 }
 
-void register_builtin_cgaladv()
-{
+void register_builtin_cgaladv() {
   Builtins::init("minkowski", new BuiltinModule(builtin_minkowski),
-  {
-    "minkowski(convexity = number)",
-  });
+                 {
+                     "minkowski(convexity = number)",
+                 });
 
   Builtins::init("hull", new BuiltinModule(builtin_hull),
-  {
-    "hull()",
-  });
+                 {
+                     "hull()",
+                 });
 
   Builtins::init("fill", new BuiltinModule(builtin_fill),
-  {
-    "fill()",
-  });
-
-  Builtins::init("resize", new BuiltinModule(builtin_resize),
-  {
-    "resize([x, y, z])",
-    "resize([x, y, z], boolean)",
-    "resize([x, y, z], [boolean, boolean, boolean])",
-    "resize([x, y, z], [boolean, boolean, boolean], convexity = number)",
-  });
+                 {
+                     "fill()",
+                 });
+
+  Builtins::init(
+      "resize", new BuiltinModule(builtin_resize),
+      {
+          "resize([x, y, z])",
+          "resize([x, y, z], boolean)",
+          "resize([x, y, z], [boolean, boolean, boolean])",
+          "resize([x, y, z], [boolean, boolean, boolean], convexity = number)",
+      });
 }
diff --git a/src/core/CgalAdvNode.h b/src/core/CgalAdvNode.h
index 32cd0f57e..ef5f7df68 100644
--- a/src/core/CgalAdvNode.h
+++ b/src/core/CgalAdvNode.h
@@ -2,23 +2,17 @@
 
 #include <string>
 
-#include "core/node.h"
 #include "core/ModuleInstantiation.h"
+#include "core/node.h"
 #include "geometry/linalg.h"
 
-enum class CgalAdvType {
-  MINKOWSKI,
-  HULL,
-  FILL,
-  RESIZE
-};
+enum class CgalAdvType { MINKOWSKI, HULL, FILL, RESIZE };
 
-class CgalAdvNode : public AbstractNode
-{
+class CgalAdvNode : public AbstractNode {
 public:
   VISITABLE();
-  CgalAdvNode(const ModuleInstantiation *mi, CgalAdvType type) : AbstractNode(mi), type(type) {
-  }
+  CgalAdvNode(const ModuleInstantiation *mi, CgalAdvType type)
+      : AbstractNode(mi), type(type) {}
   std::string toString() const override;
   std::string name() const override;
 
diff --git a/src/core/Children.cc b/src/core/Children.cc
index b620dffc5..98f5829ea 100644
--- a/src/core/Children.cc
+++ b/src/core/Children.cc
@@ -26,23 +26,23 @@
 
 #include "core/Children.h"
 
-#include <memory>
 #include <cstddef>
+#include <memory>
 #include <vector>
 
 #include "core/ScopeContext.h"
 
-std::shared_ptr<AbstractNode> Children::instantiate(const std::shared_ptr<AbstractNode>& target) const
-{
+std::shared_ptr<AbstractNode>
+Children::instantiate(const std::shared_ptr<AbstractNode> &target) const {
   return children_scope->instantiateModules(*scopeContext(), target);
 }
 
-std::shared_ptr<AbstractNode> Children::instantiate(const std::shared_ptr<AbstractNode>& target, const std::vector<size_t>& indices) const
-{
+std::shared_ptr<AbstractNode>
+Children::instantiate(const std::shared_ptr<AbstractNode> &target,
+                      const std::vector<size_t> &indices) const {
   return children_scope->instantiateModules(*scopeContext(), target, indices);
 }
 
-ContextHandle<ScopeContext> Children::scopeContext() const
-{
+ContextHandle<ScopeContext> Children::scopeContext() const {
   return Context::create<ScopeContext>(context, children_scope);
 }
diff --git a/src/core/Children.h b/src/core/Children.h
index 99cb5d2ab..a51cec084 100644
--- a/src/core/Children.h
+++ b/src/core/Children.h
@@ -1,8 +1,8 @@
 #pragma once
 
 #include <cstddef>
-#include <utility>
 #include <memory>
+#include <utility>
 #include <vector>
 
 #include "core/Context.h"
@@ -11,29 +11,35 @@
 class AbstractNode;
 class ScopeContext;
 
-class Children
-{
+class Children {
 public:
-  Children(const LocalScope *children_scope, std::shared_ptr<const Context> context) :
-    children_scope(children_scope),
-    context(std::move(context))
-  {}
-
-  Children(Children&& other) = default;
-  Children& operator=(Children&& other) = default;
-  Children(const Children& other) = default;
-  Children& operator=(const Children& other) = default;
+  Children(const LocalScope *children_scope,
+           std::shared_ptr<const Context> context)
+      : children_scope(children_scope), context(std::move(context)) {}
+
+  Children(Children &&other) = default;
+  Children &operator=(Children &&other) = default;
+  Children(const Children &other) = default;
+  Children &operator=(const Children &other) = default;
   ~Children() = default;
 
   // NOLINTBEGIN(modernize-use-nodiscard)
-  // instantiate just returns a copy of target shared_ptr as a convenience, not crucial to use this value
-  std::shared_ptr<AbstractNode> instantiate(const std::shared_ptr<AbstractNode>& target) const;
-  std::shared_ptr<AbstractNode> instantiate(const std::shared_ptr<AbstractNode>& target, const std::vector<size_t>& indices) const;
+  // instantiate just returns a copy of target shared_ptr as a convenience, not
+  // crucial to use this value
+  std::shared_ptr<AbstractNode>
+  instantiate(const std::shared_ptr<AbstractNode> &target) const;
+  std::shared_ptr<AbstractNode>
+  instantiate(const std::shared_ptr<AbstractNode> &target,
+              const std::vector<size_t> &indices) const;
   // NOLINTEND(modernize-use-nodiscard)
 
   [[nodiscard]] bool empty() const { return !children_scope->hasChildren(); }
-  [[nodiscard]] size_t size() const { return children_scope->moduleInstantiations.size(); }
-  [[nodiscard]] const std::shared_ptr<const Context>& getContext() const { return context; }
+  [[nodiscard]] size_t size() const {
+    return children_scope->moduleInstantiations.size();
+  }
+  [[nodiscard]] const std::shared_ptr<const Context> &getContext() const {
+    return context;
+  }
 
 private:
   const LocalScope *children_scope;
diff --git a/src/core/ColorNode.cc b/src/core/ColorNode.cc
index 37b6c3ee1..8f65b9f7b 100644
--- a/src/core/ColorNode.cc
+++ b/src/core/ColorNode.cc
@@ -26,38 +26,43 @@
 
 #include "core/ColorNode.h"
 
-#include <utility>
-#include <memory>
+#include <boost/algorithm/string/case_conv.hpp>
+#include <boost/assign/list_of.hpp>
+#include <boost/assign/std/vector.hpp>
 #include <cctype>
 #include <cstddef>
+#include <memory>
 #include <string>
-#include <boost/algorithm/string/case_conv.hpp>
-#include <boost/assign/std/vector.hpp>
-#include <boost/assign/list_of.hpp>
+#include <utility>
 
-#include "core/module.h"
-#include "core/ModuleInstantiation.h"
 #include "core/Builtins.h"
 #include "core/Children.h"
-#include "core/Parameters.h"
 #include "core/ColorUtil.h"
+#include "core/ModuleInstantiation.h"
+#include "core/Parameters.h"
+#include "core/module.h"
 #include "geometry/linalg.h"
 #include "utils/printutils.h"
 
 using namespace boost::assign; // bring 'operator+=()' into scope
 
-static std::shared_ptr<AbstractNode> builtin_color(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+static std::shared_ptr<AbstractNode>
+builtin_color(const ModuleInstantiation *inst, Arguments arguments,
+              const Children &children) {
   auto node = std::make_shared<ColorNode>(inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"c", "alpha"});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {"c", "alpha"});
   if (parameters["c"].type() == Value::Type::VECTOR) {
-    const auto& vec = parameters["c"].toVector();
+    const auto &vec = parameters["c"].toVector();
     Vector4f color;
     for (size_t i = 0; i < 4; ++i) {
       color[i] = i < vec.size() ? (float)vec[i].toDouble() : 1.0f;
       if (color[i] > 1 || color[i] < 0) {
-        LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "color() expects numbers between 0.0 and 1.0. Value of %1$.1f is out of range", color[i]);
+        LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+            "color() expects numbers between 0.0 and 1.0. Value of %1$.1f is "
+            "out of range",
+            color[i]);
       }
     }
     node->color = color;
@@ -67,37 +72,37 @@ static std::shared_ptr<AbstractNode> builtin_color(const ModuleInstantiation *in
     if (parsed_color) {
       node->color = *parsed_color;
     } else {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Unable to parse color \"%1$s\"", colorname);
+      LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+          "Unable to parse color \"%1$s\"", colorname);
       LOG("Please see https://en.wikipedia.org/wiki/Web_colors");
     }
   }
   if (parameters["alpha"].type() == Value::Type::NUMBER) {
     node->color.setAlpha(parameters["alpha"].toDouble());
     if (node->color.a() < 0.0f || node->color.a() > 1.0f) {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "color() expects alpha between 0.0 and 1.0. Value of %1$.1f is out of range", node->color.a());
+      LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+          "color() expects alpha between 0.0 and 1.0. Value of %1$.1f is out "
+          "of range",
+          node->color.a());
     }
   }
 
   return children.instantiate(node);
 }
 
-std::string ColorNode::toString() const
-{
-  return STR("color([", this->color.r(), ", ", this->color.g(), ", ", this->color.b(), ", ", this->color.a(), "])");
+std::string ColorNode::toString() const {
+  return STR("color([", this->color.r(), ", ", this->color.g(), ", ",
+             this->color.b(), ", ", this->color.a(), "])");
 }
 
-std::string ColorNode::name() const
-{
-  return "color";
-}
+std::string ColorNode::name() const { return "color"; }
 
-void register_builtin_color()
-{
+void register_builtin_color() {
   Builtins::init("color", new BuiltinModule(builtin_color),
-  {
-    "color(c = [r, g, b, a])",
-    "color(c = [r, g, b], alpha = 1.0)",
-    "color(\"#hexvalue\")",
-    "color(\"colorname\", 1.0)",
-  });
+                 {
+                     "color(c = [r, g, b, a])",
+                     "color(c = [r, g, b], alpha = 1.0)",
+                     "color(\"#hexvalue\")",
+                     "color(\"colorname\", 1.0)",
+                 });
 }
diff --git a/src/core/ColorNode.h b/src/core/ColorNode.h
index 002767312..38ca50c6a 100644
--- a/src/core/ColorNode.h
+++ b/src/core/ColorNode.h
@@ -3,15 +3,14 @@
 #include <string>
 
 #include "core/BaseVisitable.h"
-#include "core/node.h"
 #include "core/ModuleInstantiation.h"
+#include "core/node.h"
 #include "geometry/linalg.h"
 
-class ColorNode : public AbstractNode
-{
+class ColorNode : public AbstractNode {
 public:
   VISITABLE();
-  ColorNode(const ModuleInstantiation *mi) : AbstractNode(mi) { }
+  ColorNode(const ModuleInstantiation *mi) : AbstractNode(mi) {}
   std::string toString() const override;
   std::string name() const override;
 
diff --git a/src/core/ColorUtil.cc b/src/core/ColorUtil.cc
index 6bfd8fa42..324ae25ab 100644
--- a/src/core/ColorUtil.cc
+++ b/src/core/ColorUtil.cc
@@ -1,173 +1,170 @@
-#include <boost/spirit/home/support/common_terminals.hpp>
-#include <string>
-#include <unordered_map>
-#include "geometry/linalg.h"
 #include "core/ColorUtil.h"
+#include "geometry/linalg.h"
 #include "utils/printutils.h"
 #include <boost/algorithm/string/case_conv.hpp>
+#include <boost/spirit/home/support/common_terminals.hpp>
+#include <string>
+#include <unordered_map>
 
 namespace {
 
 // Colors extracted from https://drafts.csswg.org/css-color/ on 2015-08-02
 // CSS Color Module Level 4 - Editor’s Draft, 29 May 2015
 std::unordered_map<std::string, Color4f> webcolors{
-  {"aliceblue", {240, 248, 255}},
-  {"antiquewhite", {250, 235, 215}},
-  {"aqua", {0, 255, 255}},
-  {"aquamarine", {127, 255, 212}},
-  {"azure", {240, 255, 255}},
-  {"beige", {245, 245, 220}},
-  {"bisque", {255, 228, 196}},
-  {"black", {0, 0, 0}},
-  {"blanchedalmond", {255, 235, 205}},
-  {"blue", {0, 0, 255}},
-  {"blueviolet", {138, 43, 226}},
-  {"brown", {165, 42, 42}},
-  {"burlywood", {222, 184, 135}},
-  {"cadetblue", {95, 158, 160}},
-  {"chartreuse", {127, 255, 0}},
-  {"chocolate", {210, 105, 30}},
-  {"coral", {255, 127, 80}},
-  {"cornflowerblue", {100, 149, 237}},
-  {"cornsilk", {255, 248, 220}},
-  {"crimson", {220, 20, 60}},
-  {"cyan", {0, 255, 255}},
-  {"darkblue", {0, 0, 139}},
-  {"darkcyan", {0, 139, 139}},
-  {"darkgoldenrod", {184, 134, 11}},
-  {"darkgray", {169, 169, 169}},
-  {"darkgreen", {0, 100, 0}},
-  {"darkgrey", {169, 169, 169}},
-  {"darkkhaki", {189, 183, 107}},
-  {"darkmagenta", {139, 0, 139}},
-  {"darkolivegreen", {85, 107, 47}},
-  {"darkorange", {255, 140, 0}},
-  {"darkorchid", {153, 50, 204}},
-  {"darkred", {139, 0, 0}},
-  {"darksalmon", {233, 150, 122}},
-  {"darkseagreen", {143, 188, 143}},
-  {"darkslateblue", {72, 61, 139}},
-  {"darkslategray", {47, 79, 79}},
-  {"darkslategrey", {47, 79, 79}},
-  {"darkturquoise", {0, 206, 209}},
-  {"darkviolet", {148, 0, 211}},
-  {"deeppink", {255, 20, 147}},
-  {"deepskyblue", {0, 191, 255}},
-  {"dimgray", {105, 105, 105}},
-  {"dimgrey", {105, 105, 105}},
-  {"dodgerblue", {30, 144, 255}},
-  {"firebrick", {178, 34, 34}},
-  {"floralwhite", {255, 250, 240}},
-  {"forestgreen", {34, 139, 34}},
-  {"fuchsia", {255, 0, 255}},
-  {"gainsboro", {220, 220, 220}},
-  {"ghostwhite", {248, 248, 255}},
-  {"gold", {255, 215, 0}},
-  {"goldenrod", {218, 165, 32}},
-  {"gray", {128, 128, 128}},
-  {"green", {0, 128, 0}},
-  {"greenyellow", {173, 255, 47}},
-  {"grey", {128, 128, 128}},
-  {"honeydew", {240, 255, 240}},
-  {"hotpink", {255, 105, 180}},
-  {"indianred", {205, 92, 92}},
-  {"indigo", {75, 0, 130}},
-  {"ivory", {255, 255, 240}},
-  {"khaki", {240, 230, 140}},
-  {"lavender", {230, 230, 250}},
-  {"lavenderblush", {255, 240, 245}},
-  {"lawngreen", {124, 252, 0}},
-  {"lemonchiffon", {255, 250, 205}},
-  {"lightblue", {173, 216, 230}},
-  {"lightcoral", {240, 128, 128}},
-  {"lightcyan", {224, 255, 255}},
-  {"lightgoldenrodyellow", {250, 250, 210}},
-  {"lightgray", {211, 211, 211}},
-  {"lightgreen", {144, 238, 144}},
-  {"lightgrey", {211, 211, 211}},
-  {"lightpink", {255, 182, 193}},
-  {"lightsalmon", {255, 160, 122}},
-  {"lightseagreen", {32, 178, 170}},
-  {"lightskyblue", {135, 206, 250}},
-  {"lightslategray", {119, 136, 153}},
-  {"lightslategrey", {119, 136, 153}},
-  {"lightsteelblue", {176, 196, 222}},
-  {"lightyellow", {255, 255, 224}},
-  {"lime", {0, 255, 0}},
-  {"limegreen", {50, 205, 50}},
-  {"linen", {250, 240, 230}},
-  {"magenta", {255, 0, 255}},
-  {"maroon", {128, 0, 0}},
-  {"mediumaquamarine", {102, 205, 170}},
-  {"mediumblue", {0, 0, 205}},
-  {"mediumorchid", {186, 85, 211}},
-  {"mediumpurple", {147, 112, 219}},
-  {"mediumseagreen", {60, 179, 113}},
-  {"mediumslateblue", {123, 104, 238}},
-  {"mediumspringgreen", {0, 250, 154}},
-  {"mediumturquoise", {72, 209, 204}},
-  {"mediumvioletred", {199, 21, 133}},
-  {"midnightblue", {25, 25, 112}},
-  {"mintcream", {245, 255, 250}},
-  {"mistyrose", {255, 228, 225}},
-  {"moccasin", {255, 228, 181}},
-  {"navajowhite", {255, 222, 173}},
-  {"navy", {0, 0, 128}},
-  {"oldlace", {253, 245, 230}},
-  {"olive", {128, 128, 0}},
-  {"olivedrab", {107, 142, 35}},
-  {"orange", {255, 165, 0}},
-  {"orangered", {255, 69, 0}},
-  {"orchid", {218, 112, 214}},
-  {"palegoldenrod", {238, 232, 170}},
-  {"palegreen", {152, 251, 152}},
-  {"paleturquoise", {175, 238, 238}},
-  {"palevioletred", {219, 112, 147}},
-  {"papayawhip", {255, 239, 213}},
-  {"peachpuff", {255, 218, 185}},
-  {"peru", {205, 133, 63}},
-  {"pink", {255, 192, 203}},
-  {"plum", {221, 160, 221}},
-  {"powderblue", {176, 224, 230}},
-  {"purple", {128, 0, 128}},
-  {"rebeccapurple", {102, 51, 153}},
-  {"red", {255, 0, 0}},
-  {"rosybrown", {188, 143, 143}},
-  {"royalblue", {65, 105, 225}},
-  {"saddlebrown", {139, 69, 19}},
-  {"salmon", {250, 128, 114}},
-  {"sandybrown", {244, 164, 96}},
-  {"seagreen", {46, 139, 87}},
-  {"seashell", {255, 245, 238}},
-  {"sienna", {160, 82, 45}},
-  {"silver", {192, 192, 192}},
-  {"skyblue", {135, 206, 235}},
-  {"slateblue", {106, 90, 205}},
-  {"slategray", {112, 128, 144}},
-  {"slategrey", {112, 128, 144}},
-  {"snow", {255, 250, 250}},
-  {"springgreen", {0, 255, 127}},
-  {"steelblue", {70, 130, 180}},
-  {"tan", {210, 180, 140}},
-  {"teal", {0, 128, 128}},
-  {"thistle", {216, 191, 216}},
-  {"tomato", {255, 99, 71}},
-  {"turquoise", {64, 224, 208}},
-  {"violet", {238, 130, 238}},
-  {"wheat", {245, 222, 179}},
-  {"white", {255, 255, 255}},
-  {"whitesmoke", {245, 245, 245}},
-  {"yellow", {255, 255, 0}},
-  {"yellowgreen", {154, 205, 50}},
-
-  // additional OpenSCAD specific entry
-  {"transparent", {0, 0, 0, 0}}
-};
+    {"aliceblue", {240, 248, 255}},
+    {"antiquewhite", {250, 235, 215}},
+    {"aqua", {0, 255, 255}},
+    {"aquamarine", {127, 255, 212}},
+    {"azure", {240, 255, 255}},
+    {"beige", {245, 245, 220}},
+    {"bisque", {255, 228, 196}},
+    {"black", {0, 0, 0}},
+    {"blanchedalmond", {255, 235, 205}},
+    {"blue", {0, 0, 255}},
+    {"blueviolet", {138, 43, 226}},
+    {"brown", {165, 42, 42}},
+    {"burlywood", {222, 184, 135}},
+    {"cadetblue", {95, 158, 160}},
+    {"chartreuse", {127, 255, 0}},
+    {"chocolate", {210, 105, 30}},
+    {"coral", {255, 127, 80}},
+    {"cornflowerblue", {100, 149, 237}},
+    {"cornsilk", {255, 248, 220}},
+    {"crimson", {220, 20, 60}},
+    {"cyan", {0, 255, 255}},
+    {"darkblue", {0, 0, 139}},
+    {"darkcyan", {0, 139, 139}},
+    {"darkgoldenrod", {184, 134, 11}},
+    {"darkgray", {169, 169, 169}},
+    {"darkgreen", {0, 100, 0}},
+    {"darkgrey", {169, 169, 169}},
+    {"darkkhaki", {189, 183, 107}},
+    {"darkmagenta", {139, 0, 139}},
+    {"darkolivegreen", {85, 107, 47}},
+    {"darkorange", {255, 140, 0}},
+    {"darkorchid", {153, 50, 204}},
+    {"darkred", {139, 0, 0}},
+    {"darksalmon", {233, 150, 122}},
+    {"darkseagreen", {143, 188, 143}},
+    {"darkslateblue", {72, 61, 139}},
+    {"darkslategray", {47, 79, 79}},
+    {"darkslategrey", {47, 79, 79}},
+    {"darkturquoise", {0, 206, 209}},
+    {"darkviolet", {148, 0, 211}},
+    {"deeppink", {255, 20, 147}},
+    {"deepskyblue", {0, 191, 255}},
+    {"dimgray", {105, 105, 105}},
+    {"dimgrey", {105, 105, 105}},
+    {"dodgerblue", {30, 144, 255}},
+    {"firebrick", {178, 34, 34}},
+    {"floralwhite", {255, 250, 240}},
+    {"forestgreen", {34, 139, 34}},
+    {"fuchsia", {255, 0, 255}},
+    {"gainsboro", {220, 220, 220}},
+    {"ghostwhite", {248, 248, 255}},
+    {"gold", {255, 215, 0}},
+    {"goldenrod", {218, 165, 32}},
+    {"gray", {128, 128, 128}},
+    {"green", {0, 128, 0}},
+    {"greenyellow", {173, 255, 47}},
+    {"grey", {128, 128, 128}},
+    {"honeydew", {240, 255, 240}},
+    {"hotpink", {255, 105, 180}},
+    {"indianred", {205, 92, 92}},
+    {"indigo", {75, 0, 130}},
+    {"ivory", {255, 255, 240}},
+    {"khaki", {240, 230, 140}},
+    {"lavender", {230, 230, 250}},
+    {"lavenderblush", {255, 240, 245}},
+    {"lawngreen", {124, 252, 0}},
+    {"lemonchiffon", {255, 250, 205}},
+    {"lightblue", {173, 216, 230}},
+    {"lightcoral", {240, 128, 128}},
+    {"lightcyan", {224, 255, 255}},
+    {"lightgoldenrodyellow", {250, 250, 210}},
+    {"lightgray", {211, 211, 211}},
+    {"lightgreen", {144, 238, 144}},
+    {"lightgrey", {211, 211, 211}},
+    {"lightpink", {255, 182, 193}},
+    {"lightsalmon", {255, 160, 122}},
+    {"lightseagreen", {32, 178, 170}},
+    {"lightskyblue", {135, 206, 250}},
+    {"lightslategray", {119, 136, 153}},
+    {"lightslategrey", {119, 136, 153}},
+    {"lightsteelblue", {176, 196, 222}},
+    {"lightyellow", {255, 255, 224}},
+    {"lime", {0, 255, 0}},
+    {"limegreen", {50, 205, 50}},
+    {"linen", {250, 240, 230}},
+    {"magenta", {255, 0, 255}},
+    {"maroon", {128, 0, 0}},
+    {"mediumaquamarine", {102, 205, 170}},
+    {"mediumblue", {0, 0, 205}},
+    {"mediumorchid", {186, 85, 211}},
+    {"mediumpurple", {147, 112, 219}},
+    {"mediumseagreen", {60, 179, 113}},
+    {"mediumslateblue", {123, 104, 238}},
+    {"mediumspringgreen", {0, 250, 154}},
+    {"mediumturquoise", {72, 209, 204}},
+    {"mediumvioletred", {199, 21, 133}},
+    {"midnightblue", {25, 25, 112}},
+    {"mintcream", {245, 255, 250}},
+    {"mistyrose", {255, 228, 225}},
+    {"moccasin", {255, 228, 181}},
+    {"navajowhite", {255, 222, 173}},
+    {"navy", {0, 0, 128}},
+    {"oldlace", {253, 245, 230}},
+    {"olive", {128, 128, 0}},
+    {"olivedrab", {107, 142, 35}},
+    {"orange", {255, 165, 0}},
+    {"orangered", {255, 69, 0}},
+    {"orchid", {218, 112, 214}},
+    {"palegoldenrod", {238, 232, 170}},
+    {"palegreen", {152, 251, 152}},
+    {"paleturquoise", {175, 238, 238}},
+    {"palevioletred", {219, 112, 147}},
+    {"papayawhip", {255, 239, 213}},
+    {"peachpuff", {255, 218, 185}},
+    {"peru", {205, 133, 63}},
+    {"pink", {255, 192, 203}},
+    {"plum", {221, 160, 221}},
+    {"powderblue", {176, 224, 230}},
+    {"purple", {128, 0, 128}},
+    {"rebeccapurple", {102, 51, 153}},
+    {"red", {255, 0, 0}},
+    {"rosybrown", {188, 143, 143}},
+    {"royalblue", {65, 105, 225}},
+    {"saddlebrown", {139, 69, 19}},
+    {"salmon", {250, 128, 114}},
+    {"sandybrown", {244, 164, 96}},
+    {"seagreen", {46, 139, 87}},
+    {"seashell", {255, 245, 238}},
+    {"sienna", {160, 82, 45}},
+    {"silver", {192, 192, 192}},
+    {"skyblue", {135, 206, 235}},
+    {"slateblue", {106, 90, 205}},
+    {"slategray", {112, 128, 144}},
+    {"slategrey", {112, 128, 144}},
+    {"snow", {255, 250, 250}},
+    {"springgreen", {0, 255, 127}},
+    {"steelblue", {70, 130, 180}},
+    {"tan", {210, 180, 140}},
+    {"teal", {0, 128, 128}},
+    {"thistle", {216, 191, 216}},
+    {"tomato", {255, 99, 71}},
+    {"turquoise", {64, 224, 208}},
+    {"violet", {238, 130, 238}},
+    {"wheat", {245, 222, 179}},
+    {"white", {255, 255, 255}},
+    {"whitesmoke", {245, 245, 245}},
+    {"yellow", {255, 255, 0}},
+    {"yellowgreen", {154, 205, 50}},
 
+    // additional OpenSCAD specific entry
+    {"transparent", {0, 0, 0, 0}}};
 
 // See http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv
-void rgbtohsv(float r, float g, float b, float& h, float& s, float& v)
-{
+void rgbtohsv(float r, float g, float b, float &h, float &s, float &v) {
   float K = 0.f;
 
   if (g < b) {
@@ -186,25 +183,27 @@ void rgbtohsv(float r, float g, float b, float& h, float& s, float& v)
   v = r;
 }
 
-// Parses hex colors according to: https://drafts.csswg.org/css-color/#typedef-hex-color.
-// If the input is invalid, returns boost::none.
-// Supports the following formats:
+// Parses hex colors according to:
+// https://drafts.csswg.org/css-color/#typedef-hex-color. If the input is
+// invalid, returns boost::none. Supports the following formats:
 // * "#rrggbb"
 // * "#rrggbbaa"
 // * "#rgb"
 // * "#rgba"
-std::optional<Color4f> parse_hex_color(const std::string& hex) {
-  // validate size. short syntax uses one hex digit per color channel instead of 2.
+std::optional<Color4f> parse_hex_color(const std::string &hex) {
+  // validate size. short syntax uses one hex digit per color channel instead
+  // of 2.
   const bool short_syntax = hex.size() == 4 || hex.size() == 5;
   const bool long_syntax = hex.size() == 7 || hex.size() == 9;
-  if (!short_syntax && !long_syntax) return {};
+  if (!short_syntax && !long_syntax)
+    return {};
 
   // validate
-  if (hex[0] != '#') return {};
-  if (!std::all_of(std::begin(hex) + 1, std::end(hex),
-                   [](char c) {
-      return std::isxdigit(static_cast<unsigned char>(c));
-    })) {
+  if (hex[0] != '#')
+    return {};
+  if (!std::all_of(std::begin(hex) + 1, std::end(hex), [](char c) {
+        return std::isxdigit(static_cast<unsigned char>(c));
+      })) {
     return {};
   }
 
@@ -225,7 +224,7 @@ std::optional<Color4f> parse_hex_color(const std::string& hex) {
   return rgba;
 }
 
-std::optional<Color4f> parse_web_color(const std::string& col) {
+std::optional<Color4f> parse_web_color(const std::string &col) {
   std::string colorname = boost::algorithm::to_lower_copy(col);
   if (webcolors.find(colorname) != webcolors.end()) {
     return webcolors.at(colorname);
@@ -237,7 +236,7 @@ std::optional<Color4f> parse_web_color(const std::string& col) {
 
 namespace OpenSCAD {
 
-std::optional<Color4f> parse_color(const std::string& col) {
+std::optional<Color4f> parse_color(const std::string &col) {
   auto webcolor = ::parse_web_color(col);
   if (webcolor) {
     return webcolor;
@@ -251,20 +250,19 @@ std::optional<Color4f> parse_color(const std::string& col) {
   return {};
 }
 
-Color4f getColor(const std::string& col, const Color4f& defaultcolor)
-{
+Color4f getColor(const std::string &col, const Color4f &defaultcolor) {
   const auto parsed = parse_color(col);
 
   if (!parsed) {
-    LOG(message_group::Warning, "Unable to parse color \"%1$s\", reverting to default color.", col);
+    LOG(message_group::Warning,
+        "Unable to parse color \"%1$s\", reverting to default color.", col);
     LOG("Please see https://en.wikipedia.org/wiki/Web_colors");
   }
 
   return parsed.value_or(defaultcolor);
 }
 
-Vector4f getColorHSV(const Color4f& col)
-{
+Vector4f getColorHSV(const Color4f &col) {
   float h, s, v;
   ::rgbtohsv(col.r(), col.g(), col.b(), h, s, v);
   return {h, s, v, col.a()};
@@ -277,8 +275,7 @@ Vector4f getColorHSV(const Color4f& col)
  * @param col the input color
  * @return a color with high contrast to the input color
  */
-Color4f getContrastColor(const Color4f& col)
-{
+Color4f getContrastColor(const Color4f &col) {
   const auto hsv = getColorHSV(col);
   float Y = 0.2126f * col.r() + 0.7152f * col.g() + 0.0722f * col.b();
   float S = hsv[1];
diff --git a/src/core/ColorUtil.h b/src/core/ColorUtil.h
index f2402bfff..8514a2bfd 100644
--- a/src/core/ColorUtil.h
+++ b/src/core/ColorUtil.h
@@ -1,20 +1,20 @@
 #pragma once
 
-#include <string>
 #include <optional>
+#include <string>
 
 #include "geometry/linalg.h"
 
 namespace OpenSCAD {
 
-inline Color4f CORNFIELD_FACE_COLOR{ 0xf9, 0xd7, 0x2c, 0xff };
+inline Color4f CORNFIELD_FACE_COLOR{0xf9, 0xd7, 0x2c, 0xff};
 
-std::optional<Color4f> parse_color(const std::string& col);
+std::optional<Color4f> parse_color(const std::string &col);
 
-Color4f getColor(const std::string& col, const Color4f& defaultcolor);
+Color4f getColor(const std::string &col, const Color4f &defaultcolor);
 
-Color4f getContrastColor(const Color4f& col);
+Color4f getContrastColor(const Color4f &col);
 
-Vector4f getColorHSV(const Color4f& col);
+Vector4f getColorHSV(const Color4f &col);
 
 } // namespace OpenSCAD
diff --git a/src/core/Context.cc b/src/core/Context.cc
index 8b039ea01..52b3dd22b 100644
--- a/src/core/Context.cc
+++ b/src/core/Context.cc
@@ -26,35 +26,30 @@
 
 #include "core/Context.h"
 
-#include <utility>
-#include <memory>
 #include <cstddef>
+#include <memory>
 #include <string>
+#include <utility>
 #include <vector>
 
 #include "core/AST.h"
 #include "core/function.h"
 #include "utils/printutils.h"
 
-Context::Context(EvaluationSession *session) :
-  ContextFrame(session),
-  parent(nullptr)
-{}
+Context::Context(EvaluationSession *session)
+    : ContextFrame(session), parent(nullptr) {}
 
-Context::Context(const std::shared_ptr<const Context>& parent) :
-  ContextFrame(parent->evaluation_session),
-  parent(parent)
-{}
+Context::Context(const std::shared_ptr<const Context> &parent)
+    : ContextFrame(parent->evaluation_session), parent(parent) {}
 
-Context::~Context()
-{
+Context::~Context() {
   Context::clear();
-  if (accountingAdded)   // avoiding bad accounting where exception threw in constructor issue #3871
+  if (accountingAdded) // avoiding bad accounting where exception threw in
+                       // constructor issue #3871
     session()->contextMemoryManager().releaseContext();
 }
 
-const Children *Context::user_module_children() const
-{
+const Children *Context::user_module_children() const {
   if (parent) {
     return parent->user_module_children();
   } else {
@@ -62,8 +57,8 @@ const Children *Context::user_module_children() const
   }
 }
 
-std::vector<const std::shared_ptr<const Context> *> Context::list_referenced_contexts() const
-{
+std::vector<const std::shared_ptr<const Context> *>
+Context::list_referenced_contexts() const {
   std::vector<const std::shared_ptr<const Context> *> output;
   if (parent) {
     output.push_back(&parent);
@@ -71,13 +66,15 @@ std::vector<const std::shared_ptr<const Context> *> Context::list_referenced_con
   return output;
 }
 
-boost::optional<const Value&> Context::try_lookup_variable(const std::string& name) const
-{
+boost::optional<const Value &>
+Context::try_lookup_variable(const std::string &name) const {
   if (is_config_variable(name)) {
     return session()->try_lookup_special_variable(name);
   }
-  for (const Context *context = this; context != nullptr; context = context->getParent().get()) {
-    boost::optional<const Value&> result = context->lookup_local_variable(name);
+  for (const Context *context = this; context != nullptr;
+       context = context->getParent().get()) {
+    boost::optional<const Value &> result =
+        context->lookup_local_variable(name);
     if (result) {
       return result;
     }
@@ -85,48 +82,54 @@ boost::optional<const Value&> Context::try_lookup_variable(const std::string& na
   return boost::none;
 }
 
-const Value& Context::lookup_variable(const std::string& name, const Location& loc) const
-{
-  boost::optional<const Value&> result = try_lookup_variable(name);
+const Value &Context::lookup_variable(const std::string &name,
+                                      const Location &loc) const {
+  boost::optional<const Value &> result = try_lookup_variable(name);
   if (!result) {
-    LOG(message_group::Warning, loc, documentRoot(), "Ignoring unknown variable %1$s", quoteVar(name));
+    LOG(message_group::Warning, loc, documentRoot(),
+        "Ignoring unknown variable %1$s", quoteVar(name));
     return Value::undefined;
   }
   return *result;
 }
 
-boost::optional<CallableFunction> Context::lookup_function(const std::string& name, const Location& loc) const
-{
+boost::optional<CallableFunction>
+Context::lookup_function(const std::string &name, const Location &loc) const {
   if (is_config_variable(name)) {
     return session()->lookup_special_function(name, loc);
   }
-  for (const Context *context = this; context != nullptr; context = context->getParent().get()) {
-    boost::optional<CallableFunction> result = context->lookup_local_function(name, loc);
+  for (const Context *context = this; context != nullptr;
+       context = context->getParent().get()) {
+    boost::optional<CallableFunction> result =
+        context->lookup_local_function(name, loc);
     if (result) {
       return result;
     }
   }
-  LOG(message_group::Warning, loc, documentRoot(), "Ignoring unknown function '%1$s'", name);
+  LOG(message_group::Warning, loc, documentRoot(),
+      "Ignoring unknown function '%1$s'", name);
   return boost::none;
 }
 
-boost::optional<InstantiableModule> Context::lookup_module(const std::string& name, const Location& loc) const
-{
+boost::optional<InstantiableModule>
+Context::lookup_module(const std::string &name, const Location &loc) const {
   if (is_config_variable(name)) {
     return session()->lookup_special_module(name, loc);
   }
-  for (const Context *context = this; context != nullptr; context = context->getParent().get()) {
-    boost::optional<InstantiableModule> result = context->lookup_local_module(name, loc);
+  for (const Context *context = this; context != nullptr;
+       context = context->getParent().get()) {
+    boost::optional<InstantiableModule> result =
+        context->lookup_local_module(name, loc);
     if (result) {
       return result;
     }
   }
-  LOG(message_group::Warning, loc, this->documentRoot(), "Ignoring unknown module '%1$s'", name);
+  LOG(message_group::Warning, loc, this->documentRoot(),
+      "Ignoring unknown module '%1$s'", name);
   return boost::none;
 }
 
-bool Context::set_variable(const std::string& name, Value&& value)
-{
+bool Context::set_variable(const std::string &name, Value &&value) {
   bool new_variable = ContextFrame::set_variable(name, std::move(value));
   if (new_variable) {
     session()->accounting().addContextVariable();
@@ -134,16 +137,14 @@ bool Context::set_variable(const std::string& name, Value&& value)
   return new_variable;
 }
 
-size_t Context::clear()
-{
+size_t Context::clear() {
   size_t removed = ContextFrame::clear();
   session()->accounting().removeContextVariable(removed);
   return removed;
 }
 
 #ifdef DEBUG
-std::string Context::dump() const
-{
+std::string Context::dump() const {
   std::ostringstream s;
   s << boost::format("Context %p:\n") % this;
   Context const *context = this;
diff --git a/src/core/Context.h b/src/core/Context.h
index e09bf768f..2865f7844 100644
--- a/src/core/Context.h
+++ b/src/core/Context.h
@@ -1,13 +1,13 @@
 #pragma once
 
 #include <cassert>
-#include <memory>
 #include <cstddef>
+#include <memory>
 #include <string>
 #include <vector>
 
-#include "core/ContextFrame.h"
 #include "core/AST.h"
+#include "core/ContextFrame.h"
 #include "core/ContextMemoryManager.h"
 
 /**
@@ -15,14 +15,10 @@
  * dynamic scoping stack using object lifetime.
  * The Context objects can hang around for longer, e.g. in case of closures.
  */
-template <typename T>
-class ContextHandle : ContextFrameHandle
-{
+template <typename T> class ContextHandle : ContextFrameHandle {
 public:
-  ContextHandle(std::shared_ptr<T>&& context) :
-    ContextFrameHandle(context.get()),
-    context(std::move(context))
-  {
+  ContextHandle(std::shared_ptr<T> &&context)
+      : ContextFrameHandle(context.get()), context(std::move(context)) {
     try {
       this->context->init();
     } catch (...) {
@@ -31,26 +27,25 @@ public:
     }
   }
 
-  ~ContextHandle()
-  {
+  ~ContextHandle() {
     assert(!!session == !!context);
     if (session) {
       session->contextMemoryManager().addContext(std::move(this->context));
     }
   }
 
-  ContextHandle(const ContextHandle&) = delete;
-  ContextHandle& operator=(const ContextHandle&) = delete;
-  ContextHandle(ContextHandle&& other) noexcept = default;
+  ContextHandle(const ContextHandle &) = delete;
+  ContextHandle &operator=(const ContextHandle &) = delete;
+  ContextHandle(ContextHandle &&other) noexcept = default;
 
   // Valid only if $other is on the top of the stack.
-  ContextHandle& operator=(ContextHandle&& other) noexcept {
+  ContextHandle &operator=(ContextHandle &&other) noexcept {
     assert(session);
     assert(context);
     assert(other.context);
     assert(other.session);
 
-    //session->contextMemoryManager().releaseContext();
+    // session->contextMemoryManager().releaseContext();
     session->contextMemoryManager().addContext(std::move(this->context));
     other.release();
     context = std::move(other.context);
@@ -66,43 +61,56 @@ private:
   std::shared_ptr<T> context;
 };
 
-class Context : public ContextFrame, public std::enable_shared_from_this<Context>
-{
+class Context : public ContextFrame,
+                public std::enable_shared_from_this<Context> {
 protected:
   Context(EvaluationSession *session);
-  Context(const std::shared_ptr<const Context>& parent);
+  Context(const std::shared_ptr<const Context> &parent);
 
 public:
   ~Context() override;
 
-  template <typename C, typename ... T>
-  static ContextHandle<C> create(T&& ... t) {
+  template <typename C, typename... T>
+  static ContextHandle<C> create(T &&...t) {
     return ContextHandle<C>{std::shared_ptr<C>(new C(std::forward<T>(t)...))};
   }
 
-  virtual void init() { }
+  virtual void init() {}
 
-  std::shared_ptr<const Context> get_shared_ptr() const { return shared_from_this(); }
+  std::shared_ptr<const Context> get_shared_ptr() const {
+    return shared_from_this();
+  }
   virtual const class Children *user_module_children() const;
-  virtual std::vector<const std::shared_ptr<const Context> *> list_referenced_contexts() const;
-
-  boost::optional<const Value&> try_lookup_variable(const std::string& name) const;
-  const Value& lookup_variable(const std::string& name, const Location& loc) const;
-  boost::optional<CallableFunction> lookup_function(const std::string& name, const Location& loc) const;
-  boost::optional<InstantiableModule> lookup_module(const std::string& name, const Location& loc) const;
-  bool set_variable(const std::string& name, Value&& value) override;
+  virtual std::vector<const std::shared_ptr<const Context> *>
+  list_referenced_contexts() const;
+
+  boost::optional<const Value &>
+  try_lookup_variable(const std::string &name) const;
+  const Value &lookup_variable(const std::string &name,
+                               const Location &loc) const;
+  boost::optional<CallableFunction> lookup_function(const std::string &name,
+                                                    const Location &loc) const;
+  boost::optional<InstantiableModule> lookup_module(const std::string &name,
+                                                    const Location &loc) const;
+  bool set_variable(const std::string &name, Value &&value) override;
   size_t clear() override;
 
-  const std::shared_ptr<const Context>& getParent() const { return this->parent; }
-  // This modifies the semantics of the context in an error-prone way. Use with caution.
-  void setParent(const std::shared_ptr<const Context>& parent) { this->parent = parent; }
+  const std::shared_ptr<const Context> &getParent() const {
+    return this->parent;
+  }
+  // This modifies the semantics of the context in an error-prone way. Use with
+  // caution.
+  void setParent(const std::shared_ptr<const Context> &parent) {
+    this->parent = parent;
+  }
 
   void setAccountingAdded() { accountingAdded = true; }
 
 protected:
   std::shared_ptr<const Context> parent;
 
-  bool accountingAdded = false;   // avoiding bad accounting when exception threw in constructor issue #3871
+  bool accountingAdded = false; // avoiding bad accounting when exception threw
+                                // in constructor issue #3871
 
 public:
 #ifdef DEBUG
diff --git a/src/core/ContextFrame.cc b/src/core/ContextFrame.cc
index 238c40b01..e1c6521e8 100644
--- a/src/core/ContextFrame.cc
+++ b/src/core/ContextFrame.cc
@@ -24,21 +24,19 @@
  *
  */
 
-#include "core/AST.h"
 #include "core/ContextFrame.h"
+#include "core/AST.h"
 
-#include <utility>
 #include <cstddef>
 #include <string>
+#include <utility>
 #include <vector>
 
+ContextFrame::ContextFrame(EvaluationSession *session)
+    : evaluation_session(session) {}
 
-ContextFrame::ContextFrame(EvaluationSession *session) :
-  evaluation_session(session)
-{}
-
-boost::optional<const Value&> ContextFrame::lookup_local_variable(const std::string& name) const
-{
+boost::optional<const Value &>
+ContextFrame::lookup_local_variable(const std::string &name) const {
   if (is_config_variable(name)) {
     auto result = config_variables.find(name);
     if (result != config_variables.end()) {
@@ -53,42 +51,41 @@ boost::optional<const Value&> ContextFrame::lookup_local_variable(const std::str
   return boost::none;
 }
 
-boost::optional<CallableFunction> ContextFrame::lookup_local_function(const std::string& name, const Location& /*loc*/) const
-{
-  boost::optional<const Value&> value = lookup_local_variable(name);
+boost::optional<CallableFunction>
+ContextFrame::lookup_local_function(const std::string &name,
+                                    const Location & /*loc*/) const {
+  boost::optional<const Value &> value = lookup_local_variable(name);
   if (value && value->type() == Value::Type::FUNCTION) {
     return CallableFunction{&*value};
   }
   return boost::none;
 }
 
-boost::optional<InstantiableModule> ContextFrame::lookup_local_module(const std::string& /*name*/, const Location& /*loc*/) const
-{
+boost::optional<InstantiableModule>
+ContextFrame::lookup_local_module(const std::string & /*name*/,
+                                  const Location & /*loc*/) const {
   return boost::none;
 }
 
-std::vector<const Value *> ContextFrame::list_embedded_values() const
-{
+std::vector<const Value *> ContextFrame::list_embedded_values() const {
   std::vector<const Value *> output;
-  for (const auto& variable : lexical_variables) {
+  for (const auto &variable : lexical_variables) {
     output.push_back(&variable.second);
   }
-  for (const auto& variable : config_variables) {
+  for (const auto &variable : config_variables) {
     output.push_back(&variable.second);
   }
   return output;
 }
 
-size_t ContextFrame::clear()
-{
+size_t ContextFrame::clear() {
   size_t removed = lexical_variables.size() + config_variables.size();
   lexical_variables.clear();
   config_variables.clear();
   return removed;
 }
 
-bool ContextFrame::set_variable(const std::string& name, Value&& value)
-{
+bool ContextFrame::set_variable(const std::string &name, Value &&value) {
   if (is_config_variable(name)) {
     return config_variables.insert_or_assign(name, std::move(value)).second;
   } else {
@@ -96,61 +93,52 @@ bool ContextFrame::set_variable(const std::string& name, Value&& value)
   }
 }
 
-void ContextFrame::apply_variables(const ValueMap& variables)
-{
-  for (const auto& variable : variables) {
+void ContextFrame::apply_variables(const ValueMap &variables) {
+  for (const auto &variable : variables) {
     set_variable(variable.first, variable.second.clone());
   }
 }
 
-void ContextFrame::apply_lexical_variables(const ContextFrame& other)
-{
+void ContextFrame::apply_lexical_variables(const ContextFrame &other) {
   apply_variables(other.lexical_variables);
 }
 
-void ContextFrame::apply_config_variables(const ContextFrame& other)
-{
+void ContextFrame::apply_config_variables(const ContextFrame &other) {
   apply_variables(other.config_variables);
 }
 
-void ContextFrame::apply_variables(ValueMap&& variables)
-{
-  for (auto& variable : variables) {
+void ContextFrame::apply_variables(ValueMap &&variables) {
+  for (auto &variable : variables) {
     set_variable(variable.first, std::move(variable.second));
   }
   variables.clear();
 }
 
-void ContextFrame::apply_lexical_variables(ContextFrame&& other)
-{
+void ContextFrame::apply_lexical_variables(ContextFrame &&other) {
   apply_variables(std::move(other.lexical_variables));
 }
 
-void ContextFrame::apply_config_variables(ContextFrame&& other)
-{
+void ContextFrame::apply_config_variables(ContextFrame &&other) {
   apply_variables(std::move(other.config_variables));
 }
 
-void ContextFrame::apply_variables(ContextFrame&& other)
-{
+void ContextFrame::apply_variables(ContextFrame &&other) {
   apply_variables(std::move(other.lexical_variables));
   apply_variables(std::move(other.config_variables));
 }
 
-bool ContextFrame::is_config_variable(const std::string& name)
-{
+bool ContextFrame::is_config_variable(const std::string &name) {
   return name[0] == '$' && name != "$children";
 }
 
 #ifdef DEBUG
-std::string ContextFrame::dumpFrame() const
-{
+std::string ContextFrame::dumpFrame() const {
   std::ostringstream s;
   s << boost::format("ContextFrame %p:\n") % this;
-  for (const auto& v : lexical_variables) {
+  for (const auto &v : lexical_variables) {
     s << boost::format("    %s = %s\n") % v.first % v.second.toEchoString();
   }
-  for (const auto& v : config_variables) {
+  for (const auto &v : config_variables) {
     s << boost::format("    %s = %s\n") % v.first % v.second.toEchoString();
   }
   return s.str();
diff --git a/src/core/ContextFrame.h b/src/core/ContextFrame.h
index ffae22b31..9e5dd2601 100644
--- a/src/core/ContextFrame.h
+++ b/src/core/ContextFrame.h
@@ -5,44 +5,48 @@
 #include <string>
 #include <vector>
 
-#include "core/EvaluationSession.h"
 #include "core/AST.h"
+#include "core/EvaluationSession.h"
 #include "core/ValueMap.h"
 
-class ContextFrame
-{
+class ContextFrame {
 public:
   ContextFrame(EvaluationSession *session);
   virtual ~ContextFrame() = default;
 
-  ContextFrame(ContextFrame&& other) = default;
+  ContextFrame(ContextFrame &&other) = default;
 
-  virtual boost::optional<const Value&> lookup_local_variable(const std::string& name) const;
-  virtual boost::optional<CallableFunction> lookup_local_function(const std::string& name, const Location& loc) const;
-  virtual boost::optional<InstantiableModule> lookup_local_module(const std::string& name, const Location& loc) const;
+  virtual boost::optional<const Value &>
+  lookup_local_variable(const std::string &name) const;
+  virtual boost::optional<CallableFunction>
+  lookup_local_function(const std::string &name, const Location &loc) const;
+  virtual boost::optional<InstantiableModule>
+  lookup_local_module(const std::string &name, const Location &loc) const;
 
   virtual std::vector<const Value *> list_embedded_values() const;
   virtual size_t clear();
 
-  virtual bool set_variable(const std::string& name, Value&& value);
+  virtual bool set_variable(const std::string &name, Value &&value);
 
-  void apply_variables(const ValueMap& variables);
-  void apply_lexical_variables(const ContextFrame& other);
-  void apply_config_variables(const ContextFrame& other);
-  void apply_variables(const ContextFrame& other) {
+  void apply_variables(const ValueMap &variables);
+  void apply_lexical_variables(const ContextFrame &other);
+  void apply_config_variables(const ContextFrame &other);
+  void apply_variables(const ContextFrame &other) {
     apply_lexical_variables(other);
     apply_config_variables(other);
   }
 
-  void apply_variables(ValueMap&& variables);
-  void apply_lexical_variables(ContextFrame&& other);
-  void apply_config_variables(ContextFrame&& other);
-  void apply_variables(ContextFrame&& other);
+  void apply_variables(ValueMap &&variables);
+  void apply_lexical_variables(ContextFrame &&other);
+  void apply_config_variables(ContextFrame &&other);
+  void apply_variables(ContextFrame &&other);
 
-  static bool is_config_variable(const std::string& name);
+  static bool is_config_variable(const std::string &name);
 
   EvaluationSession *session() const { return evaluation_session; }
-  const std::string& documentRoot() const { return evaluation_session->documentRoot(); }
+  const std::string &documentRoot() const {
+    return evaluation_session->documentRoot();
+  }
 
 protected:
   ValueMap lexical_variables;
@@ -59,40 +63,30 @@ public:
  * A ContextFrameHandle stores a reference to a ContextFrame, and keeps it on
  * the special variable stack for the lifetime of the handle.
  */
-class ContextFrameHandle
-{
+class ContextFrameHandle {
 public:
-  ContextFrameHandle(ContextFrame *frame) :
-    session(frame->session())
-  {
+  ContextFrameHandle(ContextFrame *frame) : session(frame->session()) {
     frame_index = session->push_frame(frame);
   }
-  ~ContextFrameHandle()
-  {
-    release();
-  }
+  ~ContextFrameHandle() { release(); }
 
-  ContextFrameHandle(const ContextFrameHandle&) = delete;
-  ContextFrameHandle& operator=(const ContextFrameHandle&) = delete;
-  ContextFrameHandle& operator=(ContextFrameHandle&&) = delete;
+  ContextFrameHandle(const ContextFrameHandle &) = delete;
+  ContextFrameHandle &operator=(const ContextFrameHandle &) = delete;
+  ContextFrameHandle &operator=(ContextFrameHandle &&) = delete;
 
-  ContextFrameHandle(ContextFrameHandle&& other) noexcept :
-    session(other.session),
-    frame_index(other.frame_index)
-  {
+  ContextFrameHandle(ContextFrameHandle &&other) noexcept
+      : session(other.session), frame_index(other.frame_index) {
     other.session = nullptr;
   }
 
-  ContextFrameHandle& operator=(ContextFrame *frame)
-  {
+  ContextFrameHandle &operator=(ContextFrame *frame) {
     assert(session == frame->session());
     session->replace_frame(frame_index, frame);
     return *this;
   }
 
   // Valid only if handle is on the top of the stack.
-  void release()
-  {
+  void release() {
     if (session) {
       session->pop_frame(frame_index);
       session = nullptr;
diff --git a/src/core/ContextMemoryManager.cc b/src/core/ContextMemoryManager.cc
index 070ee8e6d..7864ca68e 100644
--- a/src/core/ContextMemoryManager.cc
+++ b/src/core/ContextMemoryManager.cc
@@ -26,13 +26,13 @@
 
 #include "core/ContextMemoryManager.h"
 
-#include <variant>
 #include <cassert>
-#include <utility>
-#include <memory>
 #include <deque>
 #include <map>
+#include <memory>
 #include <unordered_set>
+#include <utility>
+#include <variant>
 #include <vector>
 
 #include "core/Context.h"
@@ -54,64 +54,80 @@
  */
 using ValueIdentifier = void *;
 
-struct IdentifierVisitor
-{
-  ValueIdentifier operator()(const VectorType& value) const { return value.ptr.get(); }
-  ValueIdentifier operator()(const EmbeddedVectorType& value) const { return value.ptr.get(); }
-  ValueIdentifier operator()(const ObjectType& value) const { return value.ptr.get(); }
-  ValueIdentifier operator()(const FunctionPtr& value) const { return value.get().get(); }
+struct IdentifierVisitor {
+  ValueIdentifier operator()(const VectorType &value) const {
+    return value.ptr.get();
+  }
+  ValueIdentifier operator()(const EmbeddedVectorType &value) const {
+    return value.ptr.get();
+  }
+  ValueIdentifier operator()(const ObjectType &value) const {
+    return value.ptr.get();
+  }
+  ValueIdentifier operator()(const FunctionPtr &value) const {
+    return value.get().get();
+  }
 
   // all types without identity
-  template <typename T> ValueIdentifier operator()(const T&) const {
+  template <typename T> ValueIdentifier operator()(const T &) const {
     return nullptr;
   }
 };
 
-struct UseCountVisitor
-{
-  int operator()(const VectorType& value) const { return value.ptr.use_count(); }
-  int operator()(const EmbeddedVectorType& value) const { return value.ptr.use_count(); }
-  int operator()(const ObjectType& value) const { return value.ptr.use_count(); }
-  int operator()(const FunctionPtr& value) const { return value.get().use_count(); }
+struct UseCountVisitor {
+  int operator()(const VectorType &value) const {
+    return value.ptr.use_count();
+  }
+  int operator()(const EmbeddedVectorType &value) const {
+    return value.ptr.use_count();
+  }
+  int operator()(const ObjectType &value) const {
+    return value.ptr.use_count();
+  }
+  int operator()(const FunctionPtr &value) const {
+    return value.get().use_count();
+  }
 
   // all types without use count
-  template <typename T> int operator()(const T&) const {
-    return 0;
-  }
+  template <typename T> int operator()(const T &) const { return 0; }
 };
 
-template <typename F>
-struct EmbeddedValuesVisitor {
-  const F&& func;
-  explicit EmbeddedValuesVisitor(F&& func) : func(std::forward<F>(func)) {}
+template <typename F> struct EmbeddedValuesVisitor {
+  const F &&func;
+  explicit EmbeddedValuesVisitor(F &&func) : func(std::forward<F>(func)) {}
 
-  void operator()(const VectorType& value) const { call_each(value.ptr->vec); }
-  void operator()(const EmbeddedVectorType& value) const { call_each(value.ptr->vec); }
-  void operator()(const ObjectType& value) const { call_each(value.ptr->values); }
+  void operator()(const VectorType &value) const { call_each(value.ptr->vec); }
+  void operator()(const EmbeddedVectorType &value) const {
+    call_each(value.ptr->vec);
+  }
+  void operator()(const ObjectType &value) const {
+    call_each(value.ptr->values);
+  }
 
   // unused types
-  template <typename T> void operator()(const T&) const {}
+  template <typename T> void operator()(const T &) const {}
 
 private:
-  void call_each(const std::vector<Value>& vector) const {
-    for (const Value& member : vector) {
+  void call_each(const std::vector<Value> &vector) const {
+    for (const Value &member : vector) {
       func(member);
     }
   }
 };
 
-struct ReferencedContextVisitor
-{
-  const std::shared_ptr<const Context> *operator()(const FunctionPtr& value) const { return &value->getContext(); }
+struct ReferencedContextVisitor {
+  const std::shared_ptr<const Context> *
+  operator()(const FunctionPtr &value) const {
+    return &value->getContext();
+  }
 
   // unused types
-  template <typename T> const std::shared_ptr<const Context> *operator()(const T&) const {
+  template <typename T>
+  const std::shared_ptr<const Context> *operator()(const T &) const {
     return nullptr;
   }
 };
 
-
-
 /*
  * Finds all contexts that have an inbound reference from something that is not
  * another context.
@@ -125,8 +141,8 @@ struct ReferencedContextVisitor
  *
  * Implemented as a breadth first search to save on stack space.
  */
-static std::vector<Context *> findRootContexts(const std::vector<std::shared_ptr<Context>>& managedContexts)
-{
+static std::vector<Context *>
+findRootContexts(const std::vector<std::shared_ptr<Context>> &managedContexts) {
   std::map<ValueIdentifier, int> accountedValueReferences;
   std::map<const Context *, int> accountedContextReferences;
   std::unordered_set<const Context *> fullyAccountedContexts;
@@ -134,49 +150,55 @@ static std::vector<Context *> findRootContexts(const std::vector<std::shared_ptr
   std::deque<const Value *> valueQueue;
   std::deque<const std::shared_ptr<const Context> *> contextQueue;
 
-  auto visitValue = [&](const Value& value) {
-      ValueIdentifier identifier = std::visit(IdentifierVisitor(), value.getVariant());
-      if (!identifier) {
-        return;
-      }
+  auto visitValue = [&](const Value &value) {
+    ValueIdentifier identifier =
+        std::visit(IdentifierVisitor(), value.getVariant());
+    if (!identifier) {
+      return;
+    }
 
-      if (!accountedValueReferences.count(identifier)) {
-        accountedValueReferences[identifier] = 0;
-      }
-      const int accountedReferences = ++accountedValueReferences[identifier];
-      const int requiredReferences = std::visit(UseCountVisitor(), value.getVariant());
-      assert(accountedReferences <= requiredReferences);
-
-      if (accountedReferences == requiredReferences) {
-        std::visit(EmbeddedValuesVisitor{[&](const Value& v) {
-                                           valueQueue.push_back(&v);
-                                         }}, value.getVariant());
-
-        const std::shared_ptr<const Context> *referencedContext = std::visit(ReferencedContextVisitor(), value.getVariant());
-        if (referencedContext) {
-          contextQueue.push_back(referencedContext);
-        }
+    if (!accountedValueReferences.count(identifier)) {
+      accountedValueReferences[identifier] = 0;
+    }
+    const int accountedReferences = ++accountedValueReferences[identifier];
+    const int requiredReferences =
+        std::visit(UseCountVisitor(), value.getVariant());
+    assert(accountedReferences <= requiredReferences);
+
+    if (accountedReferences == requiredReferences) {
+      std::visit(EmbeddedValuesVisitor{[&](const Value &v) {
+                   valueQueue.push_back(&v);
+                 }},
+                 value.getVariant());
+
+      const std::shared_ptr<const Context> *referencedContext =
+          std::visit(ReferencedContextVisitor(), value.getVariant());
+      if (referencedContext) {
+        contextQueue.push_back(referencedContext);
       }
-    };
+    }
+  };
 
-  auto visitContext = [&](const std::shared_ptr<const Context>& context) {
-      if (!accountedContextReferences.count(context.get())) {
-        accountedContextReferences[context.get()] = 0;
-      }
-      const int accountedReferences = ++accountedContextReferences[context.get()];
-      const int requiredReferences = context.use_count();
-      assert(accountedReferences <= requiredReferences);
-      if (accountedReferences == requiredReferences) {
-        fullyAccountedContexts.insert(context.get());
-      }
-    };
+  auto visitContext = [&](const std::shared_ptr<const Context> &context) {
+    if (!accountedContextReferences.count(context.get())) {
+      accountedContextReferences[context.get()] = 0;
+    }
+    const int accountedReferences = ++accountedContextReferences[context.get()];
+    const int requiredReferences = context.use_count();
+    assert(accountedReferences <= requiredReferences);
+    if (accountedReferences == requiredReferences) {
+      fullyAccountedContexts.insert(context.get());
+    }
+  };
 
-  for (const std::shared_ptr<Context>& context : managedContexts) {
+  for (const std::shared_ptr<Context> &context : managedContexts) {
     std::vector<const Value *> values = context->list_embedded_values();
     valueQueue.insert(valueQueue.end(), values.begin(), values.end());
 
-    std::vector<const std::shared_ptr<const Context> *> referencedContexts = context->list_referenced_contexts();
-    contextQueue.insert(contextQueue.end(), referencedContexts.begin(), referencedContexts.end());
+    std::vector<const std::shared_ptr<const Context> *> referencedContexts =
+        context->list_referenced_contexts();
+    contextQueue.insert(contextQueue.end(), referencedContexts.begin(),
+                        referencedContexts.end());
 
     accountedContextReferences[context.get()] = 1;
   }
@@ -195,7 +217,7 @@ static std::vector<Context *> findRootContexts(const std::vector<std::shared_ptr
   }
 
   std::vector<Context *> rootContexts;
-  for (const std::shared_ptr<Context>& context : managedContexts) {
+  for (const std::shared_ptr<Context> &context : managedContexts) {
     if (!fullyAccountedContexts.count(context.get())) {
       rootContexts.push_back(context.get());
     }
@@ -203,50 +225,50 @@ static std::vector<Context *> findRootContexts(const std::vector<std::shared_ptr
   return rootContexts;
 }
 
-
-
 /*
  * Finds all contexts reachable from a set of root contexts.
  *
  * Implemented as a breadth first search to save on stack space.
  */
-static std::unordered_set<const Context *> findReachableContexts(const std::vector<Context *>& rootContexts)
-{
+static std::unordered_set<const Context *>
+findReachableContexts(const std::vector<Context *> &rootContexts) {
   std::unordered_set<ValueIdentifier> valuesSeen;
   std::unordered_set<const Context *> contextsSeen;
 
   std::deque<const Value *> valueQueue;
   std::deque<const Context *> contextQueue;
 
-  auto visitValue = [&](const Value& value) {
-      ValueIdentifier identifier = std::visit(IdentifierVisitor(), value.getVariant());
-      if (!identifier) {
-        return;
-      }
-      if (!valuesSeen.count(identifier)) {
-        valuesSeen.insert(identifier);
-        valueQueue.push_back(&value);
-      }
-    };
+  auto visitValue = [&](const Value &value) {
+    ValueIdentifier identifier =
+        std::visit(IdentifierVisitor(), value.getVariant());
+    if (!identifier) {
+      return;
+    }
+    if (!valuesSeen.count(identifier)) {
+      valuesSeen.insert(identifier);
+      valueQueue.push_back(&value);
+    }
+  };
   auto visitContext = [&](const Context *context) {
-      if (!contextsSeen.count(context)) {
-        contextsSeen.insert(context);
-        contextQueue.push_back(context);
-      }
-    };
+    if (!contextsSeen.count(context)) {
+      contextsSeen.insert(context);
+      contextQueue.push_back(context);
+    }
+  };
 
   contextsSeen.insert(rootContexts.begin(), rootContexts.end());
-  contextQueue.insert(contextQueue.end(), rootContexts.begin(), rootContexts.end());
+  contextQueue.insert(contextQueue.end(), rootContexts.begin(),
+                      rootContexts.end());
   while (!valueQueue.empty() || !contextQueue.empty()) {
     if (!valueQueue.empty()) {
       const Value *value = valueQueue.front();
       valueQueue.pop_front();
 
-      std::visit(EmbeddedValuesVisitor{[&](const Value& v) {
-                                         visitValue(v);
-                                       }}, value->getVariant());
+      std::visit(EmbeddedValuesVisitor{[&](const Value &v) { visitValue(v); }},
+                 value->getVariant());
 
-      const std::shared_ptr<const Context> *referencedContext = std::visit(ReferencedContextVisitor(), value->getVariant());
+      const std::shared_ptr<const Context> *referencedContext =
+          std::visit(ReferencedContextVisitor(), value->getVariant());
       if (referencedContext) {
         visitContext(referencedContext->get());
       }
@@ -260,8 +282,10 @@ static std::unordered_set<const Context *> findReachableContexts(const std::vect
         visitValue(*value);
       }
 
-      const std::vector<const std::shared_ptr<const Context> *> referencedContexts = context->list_referenced_contexts();
-      for (const std::shared_ptr<const Context> *referencedContext : referencedContexts) {
+      const std::vector<const std::shared_ptr<const Context> *>
+          referencedContexts = context->list_referenced_contexts();
+      for (const std::shared_ptr<const Context> *referencedContext :
+           referencedContexts) {
         visitContext(referencedContext->get());
       }
     }
@@ -270,13 +294,11 @@ static std::unordered_set<const Context *> findReachableContexts(const std::vect
   return contextsSeen;
 }
 
-
-
 /*
  * Clean up all unreachable contexts.
  */
-static void collectGarbage(std::vector<std::weak_ptr<Context>>& managedContexts)
-{
+static void
+collectGarbage(std::vector<std::weak_ptr<Context>> &managedContexts) {
   /*
    * Garbage collection consists of three phases.
    *
@@ -299,7 +321,7 @@ static void collectGarbage(std::vector<std::weak_ptr<Context>>& managedContexts)
    * Lock all contexts to prevent deletion during reachability analysis.
    */
   std::vector<std::shared_ptr<Context>> allContexts;
-  for (const std::weak_ptr<Context>& managedContext : managedContexts) {
+  for (const std::weak_ptr<Context> &managedContext : managedContexts) {
     std::shared_ptr<Context> context = managedContext.lock();
     if (context) {
       allContexts.push_back(std::move(context));
@@ -308,14 +330,15 @@ static void collectGarbage(std::vector<std::weak_ptr<Context>>& managedContexts)
 
   const std::vector<Context *> rootContexts = findRootContexts(allContexts);
 
-  const std::unordered_set<const Context *> reachableContexts = findReachableContexts(rootContexts);
+  const std::unordered_set<const Context *> reachableContexts =
+      findReachableContexts(rootContexts);
 
 #ifdef DEBUG
   std::vector<std::weak_ptr<Context>> removedContexts;
 #endif
 
   managedContexts.clear();
-  for (const std::shared_ptr<Context>& context : allContexts) {
+  for (const std::shared_ptr<Context> &context : allContexts) {
     if (reachableContexts.count(context.get())) {
       managedContexts.emplace_back(context);
     } else {
@@ -341,25 +364,22 @@ static void collectGarbage(std::vector<std::weak_ptr<Context>>& managedContexts)
   }
 
 #ifdef DEBUG
-  for (const auto& context : removedContexts) {
+  for (const auto &context : removedContexts) {
     assert(context.expired());
   }
 #endif
 }
 
-
-
-ContextMemoryManager::~ContextMemoryManager()
-{
+ContextMemoryManager::~ContextMemoryManager() {
   collectGarbage(managedContexts);
   assert(managedContexts.empty());
   assert(heapSizeAccounting.size() == 0);
 }
 
-void ContextMemoryManager::addContext(const std::shared_ptr<Context>& context)
-{
+void ContextMemoryManager::addContext(const std::shared_ptr<Context> &context) {
   heapSizeAccounting.addContext();
-  context->setAccountingAdded();   // avoiding bad accounting when an exception threw in constructor issue #3871
+  context->setAccountingAdded(); // avoiding bad accounting when an exception
+                                 // threw in constructor issue #3871
 
   /*
    * If we are holding the last copy to this context, no point in invoking
diff --git a/src/core/ContextMemoryManager.h b/src/core/ContextMemoryManager.h
index 9884acef4..5bf481063 100644
--- a/src/core/ContextMemoryManager.h
+++ b/src/core/ContextMemoryManager.h
@@ -15,8 +15,7 @@ class Context;
  * Counts one point for each context, each context variable, and each element
  * in a VectorType value.
  */
-class HeapSizeAccounting
-{
+class HeapSizeAccounting {
 public:
   void addContext(size_t number = 1) { count += number; }
   void removeContext(size_t number = 1) { count -= number; }
@@ -31,15 +30,14 @@ private:
   size_t count = 0;
 };
 
-class ContextMemoryManager
-{
+class ContextMemoryManager {
 public:
   ~ContextMemoryManager();
 
-  void addContext(const std::shared_ptr<Context>& context);
+  void addContext(const std::shared_ptr<Context> &context);
   void releaseContext() { heapSizeAccounting.removeContext(); }
 
-  HeapSizeAccounting& accounting() { return heapSizeAccounting; }
+  HeapSizeAccounting &accounting() { return heapSizeAccounting; }
 
 private:
   std::vector<std::weak_ptr<Context>> managedContexts;
diff --git a/src/core/CsgOpNode.cc b/src/core/CsgOpNode.cc
index 78118dab5..a0975f6df 100644
--- a/src/core/CsgOpNode.cc
+++ b/src/core/CsgOpNode.cc
@@ -26,42 +26,47 @@
 
 #include "core/CsgOpNode.h"
 
-#include "core/module.h"
-#include "core/ModuleInstantiation.h"
 #include "core/Builtins.h"
 #include "core/Children.h"
+#include "core/ModuleInstantiation.h"
 #include "core/Parameters.h"
+#include "core/module.h"
 
-#include <utility>
+#include <cassert>
 #include <memory>
 #include <string>
-#include <cassert>
+#include <utility>
 
-static std::shared_ptr<AbstractNode> builtin_union(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {});
-  return children.instantiate(std::make_shared<CsgOpNode>(inst, OpenSCADOperator::UNION));
+static std::shared_ptr<AbstractNode>
+builtin_union(const ModuleInstantiation *inst, Arguments arguments,
+              const Children &children) {
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {});
+  return children.instantiate(
+      std::make_shared<CsgOpNode>(inst, OpenSCADOperator::UNION));
 }
 
-static std::shared_ptr<AbstractNode> builtin_difference(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {});
-  return children.instantiate(std::make_shared<CsgOpNode>(inst, OpenSCADOperator::DIFFERENCE));
+static std::shared_ptr<AbstractNode>
+builtin_difference(const ModuleInstantiation *inst, Arguments arguments,
+                   const Children &children) {
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {});
+  return children.instantiate(
+      std::make_shared<CsgOpNode>(inst, OpenSCADOperator::DIFFERENCE));
 }
 
-static std::shared_ptr<AbstractNode> builtin_intersection(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {});
-  return children.instantiate(std::make_shared<CsgOpNode>(inst, OpenSCADOperator::INTERSECTION));
+static std::shared_ptr<AbstractNode>
+builtin_intersection(const ModuleInstantiation *inst, Arguments arguments,
+                     const Children &children) {
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {});
+  return children.instantiate(
+      std::make_shared<CsgOpNode>(inst, OpenSCADOperator::INTERSECTION));
 }
 
-std::string CsgOpNode::toString() const
-{
-  return this->name() + "()";
-}
+std::string CsgOpNode::toString() const { return this->name() + "()"; }
 
-std::string CsgOpNode::name() const
-{
+std::string CsgOpNode::name() const {
   switch (this->type) {
   case OpenSCADOperator::UNION:
     return "union";
@@ -78,20 +83,19 @@ std::string CsgOpNode::name() const
   return "internal_error";
 }
 
-void register_builtin_csgops()
-{
+void register_builtin_csgops() {
   Builtins::init("union", new BuiltinModule(builtin_union),
-  {
-    "union()",
-  });
+                 {
+                     "union()",
+                 });
 
   Builtins::init("difference", new BuiltinModule(builtin_difference),
-  {
-    "difference()",
-  });
+                 {
+                     "difference()",
+                 });
 
   Builtins::init("intersection", new BuiltinModule(builtin_intersection),
-  {
-    "intersection()",
-  });
+                 {
+                     "intersection()",
+                 });
 }
diff --git a/src/core/CsgOpNode.h b/src/core/CsgOpNode.h
index 236f9e976..2ff490fb8 100644
--- a/src/core/CsgOpNode.h
+++ b/src/core/CsgOpNode.h
@@ -2,16 +2,16 @@
 
 #include <string>
 
-#include "core/node.h"
 #include "core/ModuleInstantiation.h"
 #include "core/enums.h"
+#include "core/node.h"
 
-class CsgOpNode : public AbstractNode
-{
+class CsgOpNode : public AbstractNode {
 public:
   VISITABLE();
   OpenSCADOperator type;
-  CsgOpNode(const ModuleInstantiation *mi, OpenSCADOperator type) : AbstractNode(mi), type(type) { }
+  CsgOpNode(const ModuleInstantiation *mi, OpenSCADOperator type)
+      : AbstractNode(mi), type(type) {}
   std::string toString() const override;
   std::string name() const override;
 };
diff --git a/src/core/DrawingCallback.cc b/src/core/DrawingCallback.cc
index 48e2be283..d244c13bb 100644
--- a/src/core/DrawingCallback.cc
+++ b/src/core/DrawingCallback.cc
@@ -25,31 +25,27 @@
  */
 #include "core/DrawingCallback.h"
 
-#include <memory>
 #include <cmath>
+#include <memory>
 #include <vector>
 
 #include "geometry/Polygon2d.h"
 
-DrawingCallback::DrawingCallback(unsigned long fn, double size) :
-  pen(Vector2d(0, 0)), offset(Vector2d(0, 0)), advance(Vector2d(0, 0)), fn(fn), size(size)
-{
-}
+DrawingCallback::DrawingCallback(unsigned long fn, double size)
+    : pen(Vector2d(0, 0)), offset(Vector2d(0, 0)), advance(Vector2d(0, 0)),
+      fn(fn), size(size) {}
 
-DrawingCallback::~DrawingCallback()
-{
-}
+DrawingCallback::~DrawingCallback() {}
 
-void DrawingCallback::start_glyph()
-{
+void DrawingCallback::start_glyph() {
   this->polygon = std::make_shared<Polygon2d>();
   // FIXME: Why do we think that a glyph is sanitized?
-  // This is technically not true, since we don't maintain correct values for the 'positive' flag.
+  // This is technically not true, since we don't maintain correct values for
+  // the 'positive' flag.
   this->polygon->setSanitized(true);
 }
 
-void DrawingCallback::finish_glyph()
-{
+void DrawingCallback::finish_glyph() {
   if (this->outline.vertices.size() > 0) {
     this->polygon->addOutline(this->outline);
     this->outline.vertices.clear();
@@ -63,28 +59,23 @@ void DrawingCallback::finish_glyph()
   }
 }
 
-std::vector<std::shared_ptr<const Polygon2d>> DrawingCallback::get_result()
-{
+std::vector<std::shared_ptr<const Polygon2d>> DrawingCallback::get_result() {
   return this->polygons;
 }
 
-void DrawingCallback::set_glyph_offset(double offset_x, double offset_y)
-{
+void DrawingCallback::set_glyph_offset(double offset_x, double offset_y) {
   offset = Vector2d(offset_x, offset_y);
 }
 
-void DrawingCallback::add_glyph_advance(double advance_x, double advance_y)
-{
+void DrawingCallback::add_glyph_advance(double advance_x, double advance_y) {
   advance += Vector2d(advance_x, advance_y);
 }
 
-void DrawingCallback::add_vertex(const Vector2d& v)
-{
+void DrawingCallback::add_vertex(const Vector2d &v) {
   this->outline.vertices.push_back(size * (v + offset + advance));
 }
 
-void DrawingCallback::move_to(const Vector2d& to)
-{
+void DrawingCallback::move_to(const Vector2d &to) {
   if (this->outline.vertices.size() > 0) {
     this->polygon->addOutline(this->outline);
     this->outline.vertices.clear();
@@ -93,35 +84,32 @@ void DrawingCallback::move_to(const Vector2d& to)
   pen = to;
 }
 
-void DrawingCallback::line_to(const Vector2d& to)
-{
+void DrawingCallback::line_to(const Vector2d &to) {
   add_vertex(to);
   pen = to;
 }
 
 // Quadric Bezier curve
-void DrawingCallback::curve_to(const Vector2d& c1, const Vector2d& to)
-{
-  // NOTE - this could be done better using a chord length iteration (uniform in space) to implement $fa (lot of work, little gain)
+void DrawingCallback::curve_to(const Vector2d &c1, const Vector2d &to) {
+  // NOTE - this could be done better using a chord length iteration (uniform in
+  // space) to implement $fa (lot of work, little gain)
   for (unsigned long idx = 1; idx <= fn; ++idx) {
     const double a = idx * (1.0 / (double)fn);
-    add_vertex(pen * pow(1 - a, 2) +
-               c1 * 2 * pow(1 - a, 1) * a +
+    add_vertex(pen * pow(1 - a, 2) + c1 * 2 * pow(1 - a, 1) * a +
                to * pow(a, 2));
   }
   pen = to;
 }
 
 // Cubic Bezier curve
-void DrawingCallback::curve_to(const Vector2d& c1, const Vector2d& c2, const Vector2d& to)
-{
-  // NOTE - this could be done better using a chord length iteration (uniform in space) to implement $fa (lot of work, little gain)
+void DrawingCallback::curve_to(const Vector2d &c1, const Vector2d &c2,
+                               const Vector2d &to) {
+  // NOTE - this could be done better using a chord length iteration (uniform in
+  // space) to implement $fa (lot of work, little gain)
   for (unsigned long idx = 1; idx <= fn; ++idx) {
     const double a = idx * (1.0 / (double)fn);
-    add_vertex(pen * pow(1 - a, 3) +
-               c1 * 3 * pow(1 - a, 2) * a +
-               c2 * 3 * pow(1 - a, 1) * pow(a, 2) +
-               to * pow(a, 3));
+    add_vertex(pen * pow(1 - a, 3) + c1 * 3 * pow(1 - a, 2) * a +
+               c2 * 3 * pow(1 - a, 1) * pow(a, 2) + to * pow(a, 3));
   }
   pen = to;
 }
diff --git a/src/core/DrawingCallback.h b/src/core/DrawingCallback.h
index 79fdd8289..814eb6dc8 100644
--- a/src/core/DrawingCallback.h
+++ b/src/core/DrawingCallback.h
@@ -25,18 +25,17 @@
  */
 #pragma once
 
+#include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
+#include <Eigen/Core>
+#include <cmath>
 #include <memory>
 #include <vector>
-#include <cmath>
-#include <Eigen/Core>
-#include "geometry/linalg.h"
-#include "geometry/Polygon2d.h"
 
 class Polygon2d;
 class Geometry;
 
-class DrawingCallback
-{
+class DrawingCallback {
 public:
   DrawingCallback(unsigned long fn, double size);
   virtual ~DrawingCallback();
@@ -47,10 +46,11 @@ public:
   void add_glyph_advance(double advance_x, double advance_y);
   std::vector<std::shared_ptr<const Polygon2d>> get_result();
 
-  void move_to(const Vector2d& to);
-  void line_to(const Vector2d& to);
-  void curve_to(const Vector2d& c1, const Vector2d& to);
-  void curve_to(const Vector2d& c1, const Vector2d& c2, const Vector2d& to);
+  void move_to(const Vector2d &to);
+  void line_to(const Vector2d &to);
+  void curve_to(const Vector2d &c1, const Vector2d &to);
+  void curve_to(const Vector2d &c1, const Vector2d &c2, const Vector2d &to);
+
 private:
   Vector2d pen;
   Vector2d offset;
@@ -62,5 +62,5 @@ private:
   std::shared_ptr<Polygon2d> polygon;
   std::vector<std::shared_ptr<const Polygon2d>> polygons;
 
-  void add_vertex(const Vector2d& v);
+  void add_vertex(const Vector2d &v);
 };
diff --git a/src/core/EvaluationSession.cc b/src/core/EvaluationSession.cc
index aa5c96fc7..abeaaf5d2 100644
--- a/src/core/EvaluationSession.cc
+++ b/src/core/EvaluationSession.cc
@@ -34,29 +34,26 @@
 #include "core/ContextFrame.h"
 #include "utils/printutils.h"
 
-size_t EvaluationSession::push_frame(ContextFrame *frame)
-{
+size_t EvaluationSession::push_frame(ContextFrame *frame) {
   size_t index = stack.size();
   stack.push_back(frame);
   return index;
 }
 
-void EvaluationSession::replace_frame(size_t index, ContextFrame *frame)
-{
+void EvaluationSession::replace_frame(size_t index, ContextFrame *frame) {
   assert(index < stack.size());
   stack[index] = frame;
 }
 
-void EvaluationSession::pop_frame(size_t index)
-{
+void EvaluationSession::pop_frame(size_t index) {
   stack.pop_back();
   assert(stack.size() == index);
 }
 
-boost::optional<const Value&> EvaluationSession::try_lookup_special_variable(const std::string& name) const
-{
+boost::optional<const Value &>
+EvaluationSession::try_lookup_special_variable(const std::string &name) const {
   for (auto it = stack.crbegin(); it != stack.crend(); ++it) {
-    boost::optional<const Value&> result = (*it)->lookup_local_variable(name);
+    boost::optional<const Value &> result = (*it)->lookup_local_variable(name);
     if (result) {
       return result;
     }
@@ -64,36 +61,44 @@ boost::optional<const Value&> EvaluationSession::try_lookup_special_variable(con
   return boost::none;
 }
 
-const Value& EvaluationSession::lookup_special_variable(const std::string& name, const Location& loc) const
-{
-  boost::optional<const Value&> result = try_lookup_special_variable(name);
+const Value &
+EvaluationSession::lookup_special_variable(const std::string &name,
+                                           const Location &loc) const {
+  boost::optional<const Value &> result = try_lookup_special_variable(name);
   if (!result) {
-    LOG(message_group::Warning, loc, documentRoot(), "Ignoring unknown variable %1$s", quoteVar(name));
+    LOG(message_group::Warning, loc, documentRoot(),
+        "Ignoring unknown variable %1$s", quoteVar(name));
     return Value::undefined;
   }
   return *result;
 }
 
-boost::optional<CallableFunction> EvaluationSession::lookup_special_function(const std::string& name, const Location& loc) const
-{
+boost::optional<CallableFunction>
+EvaluationSession::lookup_special_function(const std::string &name,
+                                           const Location &loc) const {
   for (auto it = stack.crbegin(); it != stack.crend(); ++it) {
-    boost::optional<CallableFunction> result = (*it)->lookup_local_function(name, loc);
+    boost::optional<CallableFunction> result =
+        (*it)->lookup_local_function(name, loc);
     if (result) {
       return result;
     }
   }
-  LOG(message_group::Warning, loc, documentRoot(), "Ignoring unknown function '%1$s'", name);
+  LOG(message_group::Warning, loc, documentRoot(),
+      "Ignoring unknown function '%1$s'", name);
   return boost::none;
 }
 
-boost::optional<InstantiableModule> EvaluationSession::lookup_special_module(const std::string& name, const Location& loc) const
-{
+boost::optional<InstantiableModule>
+EvaluationSession::lookup_special_module(const std::string &name,
+                                         const Location &loc) const {
   for (auto it = stack.crbegin(); it != stack.crend(); ++it) {
-    boost::optional<InstantiableModule> result = (*it)->lookup_local_module(name, loc);
+    boost::optional<InstantiableModule> result =
+        (*it)->lookup_local_module(name, loc);
     if (result) {
       return result;
     }
   }
-  LOG(message_group::Warning, loc, documentRoot(), "Ignoring unknown module '%1$s'", name);
+  LOG(message_group::Warning, loc, documentRoot(),
+      "Ignoring unknown module '%1$s'", name);
   return boost::none;
 }
diff --git a/src/core/EvaluationSession.h b/src/core/EvaluationSession.h
index b83b4a7b1..636cb4058 100644
--- a/src/core/EvaluationSession.h
+++ b/src/core/EvaluationSession.h
@@ -1,38 +1,46 @@
 #pragma once
 
+#include <boost/optional.hpp>
 #include <cstddef>
 #include <string>
 #include <utility>
 #include <vector>
-#include <boost/optional.hpp>
 
-#include "core/ContextMemoryManager.h"
 #include "core/AST.h"
+#include "core/ContextMemoryManager.h"
+#include "core/Value.h"
 #include "core/function.h"
 #include "core/module.h"
-#include "core/Value.h"
 
 class ContextFrame;
 
-class EvaluationSession
-{
+class EvaluationSession {
 public:
-  EvaluationSession(std::string documentRoot) :
-    document_root(std::move(documentRoot))
-  {}
+  EvaluationSession(std::string documentRoot)
+      : document_root(std::move(documentRoot)) {}
 
   size_t push_frame(ContextFrame *frame);
   void replace_frame(size_t index, ContextFrame *frame);
   void pop_frame(size_t index);
 
-  [[nodiscard]] boost::optional<const Value&> try_lookup_special_variable(const std::string& name) const;
-  [[nodiscard]] const Value& lookup_special_variable(const std::string& name, const Location& loc) const;
-  [[nodiscard]] boost::optional<CallableFunction> lookup_special_function(const std::string& name, const Location& loc) const;
-  [[nodiscard]] boost::optional<InstantiableModule> lookup_special_module(const std::string& name, const Location& loc) const;
-
-  [[nodiscard]] const std::string& documentRoot() const { return document_root; }
-  ContextMemoryManager& contextMemoryManager() { return context_memory_manager; }
-  HeapSizeAccounting& accounting() { return context_memory_manager.accounting(); }
+  [[nodiscard]] boost::optional<const Value &>
+  try_lookup_special_variable(const std::string &name) const;
+  [[nodiscard]] const Value &lookup_special_variable(const std::string &name,
+                                                     const Location &loc) const;
+  [[nodiscard]] boost::optional<CallableFunction>
+  lookup_special_function(const std::string &name, const Location &loc) const;
+  [[nodiscard]] boost::optional<InstantiableModule>
+  lookup_special_module(const std::string &name, const Location &loc) const;
+
+  [[nodiscard]] const std::string &documentRoot() const {
+    return document_root;
+  }
+  ContextMemoryManager &contextMemoryManager() {
+    return context_memory_manager;
+  }
+  HeapSizeAccounting &accounting() {
+    return context_memory_manager.accounting();
+  }
 
 private:
   std::string document_root;
diff --git a/src/core/Expression.cc b/src/core/Expression.cc
index 67f97dc6d..dd8e875e8 100644
--- a/src/core/Expression.cc
+++ b/src/core/Expression.cc
@@ -25,214 +25,255 @@
  */
 #include "core/Expression.h"
 
-#include "utils/compiler_specific.h"
+#include "core/Context.h"
+#include "core/Parameters.h"
 #include "core/Value.h"
-#include <set>
-#include <functional>
-#include <ostream>
-#include <cstdint>
-#include <cmath>
+#include "utils/StackCheck.h"
+#include "utils/boost-utils.h"
+#include "utils/compiler_specific.h"
+#include "utils/exceptions.h"
+#include "utils/printutils.h"
+#include <algorithm>
+#include <boost/assign/std/vector.hpp>
+#include <boost/regex.hpp>
 #include <cassert>
+#include <cmath>
 #include <cstddef>
+#include <cstdint>
+#include <functional>
 #include <memory>
+#include <ostream>
+#include <set>
 #include <sstream>
-#include <algorithm>
 #include <typeinfo>
 #include <utility>
 #include <variant>
-#include "utils/printutils.h"
-#include "utils/StackCheck.h"
-#include "core/Context.h"
-#include "utils/exceptions.h"
-#include "core/Parameters.h"
-#include "utils/printutils.h"
-#include "utils/boost-utils.h"
-#include <boost/regex.hpp>
-#include <boost/assign/std/vector.hpp>
 using namespace boost::assign; // bring 'operator+=()' into scope
 
-Value Expression::checkUndef(Value&& val, const std::shared_ptr<const Context>& context) const {
-  if (val.isUncheckedUndef()) LOG(message_group::Warning, loc, context->documentRoot(), "%1$s", val.toUndefString());
+Value Expression::checkUndef(
+    Value &&val, const std::shared_ptr<const Context> &context) const {
+  if (val.isUncheckedUndef())
+    LOG(message_group::Warning, loc, context->documentRoot(), "%1$s",
+        val.toUndefString());
   return std::move(val);
 }
 
-bool Expression::isLiteral() const
-{
-  return false;
-}
+bool Expression::isLiteral() const { return false; }
 
-UnaryOp::UnaryOp(UnaryOp::Op op, Expression *expr, const Location& loc) : Expression(loc), op(op), expr(expr)
-{
-}
+UnaryOp::UnaryOp(UnaryOp::Op op, Expression *expr, const Location &loc)
+    : Expression(loc), op(op), expr(expr) {}
 
-Value UnaryOp::evaluate(const std::shared_ptr<const Context>& context) const
-{
+Value UnaryOp::evaluate(const std::shared_ptr<const Context> &context) const {
   switch (this->op) {
-  case (Op::Not):    return !this->expr->evaluate(context).toBool();
-  case (Op::Negate): return checkUndef(-this->expr->evaluate(context), context);
-  case (Op::BinaryNot): return checkUndef(~this->expr->evaluate(context), context);
+  case (Op::Not):
+    return !this->expr->evaluate(context).toBool();
+  case (Op::Negate):
+    return checkUndef(-this->expr->evaluate(context), context);
+  case (Op::BinaryNot):
+    return checkUndef(~this->expr->evaluate(context), context);
   default:
     assert(false && "Non-existent unary operator!");
     throw EvaluationException("Non-existent unary operator!");
   }
 }
 
-const char *UnaryOp::opString() const
-{
+const char *UnaryOp::opString() const {
   switch (this->op) {
-  case Op::Not:    return "!";
-  case Op::Negate: return "-";
-  case Op::BinaryNot: return "~";
+  case Op::Not:
+    return "!";
+  case Op::Negate:
+    return "-";
+  case Op::BinaryNot:
+    return "~";
   default:
     assert(false && "Non-existent unary operator!");
     throw EvaluationException("Non-existent unary operator!");
   }
 }
 
-bool UnaryOp::isLiteral() const {
-  return this->expr->isLiteral();
-}
+bool UnaryOp::isLiteral() const { return this->expr->isLiteral(); }
 
-void UnaryOp::print(std::ostream& stream, const std::string&) const
-{
+void UnaryOp::print(std::ostream &stream, const std::string &) const {
   stream << opString() << *this->expr;
 }
 
-BinaryOp::BinaryOp(Expression *left, BinaryOp::Op op, Expression *right, const Location& loc) :
-  Expression(loc), op(op), left(left), right(right)
-{
-}
+BinaryOp::BinaryOp(Expression *left, BinaryOp::Op op, Expression *right,
+                   const Location &loc)
+    : Expression(loc), op(op), left(left), right(right) {}
 
-Value BinaryOp::evaluate(const std::shared_ptr<const Context>& context) const
-{
+Value BinaryOp::evaluate(const std::shared_ptr<const Context> &context) const {
   switch (this->op) {
   case Op::LogicalAnd:
-    return this->left->evaluate(context).toBool() && this->right->evaluate(context).toBool();
+    return this->left->evaluate(context).toBool() &&
+           this->right->evaluate(context).toBool();
   case Op::LogicalOr:
-    return this->left->evaluate(context).toBool() || this->right->evaluate(context).toBool();
+    return this->left->evaluate(context).toBool() ||
+           this->right->evaluate(context).toBool();
   case Op::Exponent:
-    return checkUndef(this->left->evaluate(context) ^ this->right->evaluate(context), context);
+    return checkUndef(this->left->evaluate(context) ^
+                          this->right->evaluate(context),
+                      context);
   case Op::Multiply:
-    return checkUndef(this->left->evaluate(context) * this->right->evaluate(context), context);
+    return checkUndef(this->left->evaluate(context) *
+                          this->right->evaluate(context),
+                      context);
   case Op::Divide:
-    return checkUndef(this->left->evaluate(context) / this->right->evaluate(context), context);
+    return checkUndef(this->left->evaluate(context) /
+                          this->right->evaluate(context),
+                      context);
   case Op::Modulo:
-    return checkUndef(this->left->evaluate(context) % this->right->evaluate(context), context);
+    return checkUndef(this->left->evaluate(context) %
+                          this->right->evaluate(context),
+                      context);
   case Op::Plus:
-    return checkUndef(this->left->evaluate(context) + this->right->evaluate(context), context);
+    return checkUndef(this->left->evaluate(context) +
+                          this->right->evaluate(context),
+                      context);
   case Op::Minus:
-    return checkUndef(this->left->evaluate(context) - this->right->evaluate(context), context);
+    return checkUndef(this->left->evaluate(context) -
+                          this->right->evaluate(context),
+                      context);
   case Op::ShiftLeft:
-    return checkUndef(this->left->evaluate(context) << this->right->evaluate(context), context);
+    return checkUndef(this->left->evaluate(context)
+                          << this->right->evaluate(context),
+                      context);
   case Op::ShiftRight:
-    return checkUndef(this->left->evaluate(context) >> this->right->evaluate(context), context);
+    return checkUndef(this->left->evaluate(context) >>
+                          this->right->evaluate(context),
+                      context);
   case Op::BinaryAnd:
-    return checkUndef(this->left->evaluate(context) & this->right->evaluate(context), context);
+    return checkUndef(this->left->evaluate(context) &
+                          this->right->evaluate(context),
+                      context);
   case Op::BinaryOr:
-    return checkUndef(this->left->evaluate(context) | this->right->evaluate(context), context);
+    return checkUndef(this->left->evaluate(context) |
+                          this->right->evaluate(context),
+                      context);
   case Op::Less:
-    return checkUndef(this->left->evaluate(context) < this->right->evaluate(context), context);
+    return checkUndef(this->left->evaluate(context) <
+                          this->right->evaluate(context),
+                      context);
   case Op::LessEqual:
-    return checkUndef(this->left->evaluate(context) <= this->right->evaluate(context), context);
+    return checkUndef(this->left->evaluate(context) <=
+                          this->right->evaluate(context),
+                      context);
   case Op::Greater:
-    return checkUndef(this->left->evaluate(context) > this->right->evaluate(context), context);
+    return checkUndef(this->left->evaluate(context) >
+                          this->right->evaluate(context),
+                      context);
   case Op::GreaterEqual:
-    return checkUndef(this->left->evaluate(context) >= this->right->evaluate(context), context);
+    return checkUndef(this->left->evaluate(context) >=
+                          this->right->evaluate(context),
+                      context);
   case Op::Equal:
-    return checkUndef(this->left->evaluate(context) == this->right->evaluate(context), context);
+    return checkUndef(this->left->evaluate(context) ==
+                          this->right->evaluate(context),
+                      context);
   case Op::NotEqual:
-    return checkUndef(this->left->evaluate(context) != this->right->evaluate(context), context);
+    return checkUndef(this->left->evaluate(context) !=
+                          this->right->evaluate(context),
+                      context);
   default:
     assert(false && "Non-existent binary operator!");
     throw EvaluationException("Non-existent binary operator!");
   }
 }
 
-const char *BinaryOp::opString() const
-{
+const char *BinaryOp::opString() const {
   switch (this->op) {
-  case Op::LogicalAnd:   return "&&";
-  case Op::LogicalOr:    return "||";
-  case Op::Exponent:     return "^";
-  case Op::Multiply:     return "*";
-  case Op::Divide:       return "/";
-  case Op::Modulo:       return "%";
-  case Op::Plus:         return "+";
-  case Op::Minus:        return "-";
-  case Op::Less:         return "<";
-  case Op::LessEqual:    return "<=";
-  case Op::Greater:      return ">";
-  case Op::GreaterEqual: return ">=";
-  case Op::Equal:        return "==";
-  case Op::NotEqual:     return "!=";
-  case Op::BinaryOr:     return "|";
-  case Op::BinaryAnd:     return "&";
-  case Op::ShiftLeft:     return "<<";
-  case Op::ShiftRight:     return ">>";
+  case Op::LogicalAnd:
+    return "&&";
+  case Op::LogicalOr:
+    return "||";
+  case Op::Exponent:
+    return "^";
+  case Op::Multiply:
+    return "*";
+  case Op::Divide:
+    return "/";
+  case Op::Modulo:
+    return "%";
+  case Op::Plus:
+    return "+";
+  case Op::Minus:
+    return "-";
+  case Op::Less:
+    return "<";
+  case Op::LessEqual:
+    return "<=";
+  case Op::Greater:
+    return ">";
+  case Op::GreaterEqual:
+    return ">=";
+  case Op::Equal:
+    return "==";
+  case Op::NotEqual:
+    return "!=";
+  case Op::BinaryOr:
+    return "|";
+  case Op::BinaryAnd:
+    return "&";
+  case Op::ShiftLeft:
+    return "<<";
+  case Op::ShiftRight:
+    return ">>";
   default:
     assert(false && "Non-existent binary operator!");
     throw EvaluationException("Non-existent binary operator!");
   }
 }
 
-void BinaryOp::print(std::ostream& stream, const std::string&) const
-{
-  stream << "(" << *this->left << " " << opString() << " " << *this->right << ")";
+void BinaryOp::print(std::ostream &stream, const std::string &) const {
+  stream << "(" << *this->left << " " << opString() << " " << *this->right
+         << ")";
 }
 
-TernaryOp::TernaryOp(Expression *cond, Expression *ifexpr, Expression *elseexpr, const Location& loc)
-  : Expression(loc), cond(cond), ifexpr(ifexpr), elseexpr(elseexpr)
-{
-}
+TernaryOp::TernaryOp(Expression *cond, Expression *ifexpr, Expression *elseexpr,
+                     const Location &loc)
+    : Expression(loc), cond(cond), ifexpr(ifexpr), elseexpr(elseexpr) {}
 
-const Expression *TernaryOp::evaluateStep(const std::shared_ptr<const Context>& context) const
-{
-  return this->cond->evaluate(context).toBool() ? this->ifexpr.get() : this->elseexpr.get();
+const Expression *
+TernaryOp::evaluateStep(const std::shared_ptr<const Context> &context) const {
+  return this->cond->evaluate(context).toBool() ? this->ifexpr.get()
+                                                : this->elseexpr.get();
 }
 
-Value TernaryOp::evaluate(const std::shared_ptr<const Context>& context) const
-{
+Value TernaryOp::evaluate(const std::shared_ptr<const Context> &context) const {
   return evaluateStep(context)->evaluate(context);
 }
 
-void TernaryOp::print(std::ostream& stream, const std::string&) const
-{
-  stream << "(" << *this->cond << " ? " << *this->ifexpr << " : " << *this->elseexpr << ")";
+void TernaryOp::print(std::ostream &stream, const std::string &) const {
+  stream << "(" << *this->cond << " ? " << *this->ifexpr << " : "
+         << *this->elseexpr << ")";
 }
 
-ArrayLookup::ArrayLookup(Expression *array, Expression *index, const Location& loc)
-  : Expression(loc), array(array), index(index)
-{
-}
+ArrayLookup::ArrayLookup(Expression *array, Expression *index,
+                         const Location &loc)
+    : Expression(loc), array(array), index(index) {}
 
-Value ArrayLookup::evaluate(const std::shared_ptr<const Context>& context) const {
+Value ArrayLookup::evaluate(
+    const std::shared_ptr<const Context> &context) const {
   return this->array->evaluate(context)[this->index->evaluate(context)];
 }
 
-void ArrayLookup::print(std::ostream& stream, const std::string&) const
-{
+void ArrayLookup::print(std::ostream &stream, const std::string &) const {
   stream << *array << "[" << *index << "]";
 }
 
-Value Literal::evaluate(const std::shared_ptr<const Context>&) const
-{
+Value Literal::evaluate(const std::shared_ptr<const Context> &) const {
   return value.clone();
 }
 
-void Literal::print(std::ostream& stream, const std::string&) const
-{
+void Literal::print(std::ostream &stream, const std::string &) const {
   stream << value;
 }
 
-Range::Range(Expression *begin, Expression *end, const Location& loc)
-  : Expression(loc), begin(begin), end(end)
-{
-}
+Range::Range(Expression *begin, Expression *end, const Location &loc)
+    : Expression(loc), begin(begin), end(end) {}
 
-Range::Range(Expression *begin, Expression *step, Expression *end, const Location& loc)
-  : Expression(loc), begin(begin), step(step), end(end)
-{
-}
+Range::Range(Expression *begin, Expression *step, Expression *end,
+             const Location &loc)
+    : Expression(loc), begin(begin), step(step), end(end) {}
 
 /**
  * This is separated because PRINT uses quite a lot of stack space and
@@ -241,16 +282,18 @@ Range::Range(Expression *begin, Expression *step, Expression *end, const Locatio
  * noinline is required, as we here specifically optimize for stack usage
  * during normal operating, not runtime during error handling.
  */
-static void NOINLINE print_range_err(const std::string& begin, const std::string& step, const Location& loc, const std::shared_ptr<const Context>& context){
-  LOG(message_group::Warning, loc, context->documentRoot(), "begin %1$s than the end, but step %2$s", begin, step);
+static void NOINLINE print_range_err(
+    const std::string &begin, const std::string &step, const Location &loc,
+    const std::shared_ptr<const Context> &context) {
+  LOG(message_group::Warning, loc, context->documentRoot(),
+      "begin %1$s than the end, but step %2$s", begin, step);
 }
 
-Value Range::evaluate(const std::shared_ptr<const Context>& context) const
-{
+Value Range::evaluate(const std::shared_ptr<const Context> &context) const {
   double begin_val;
   double end_val;
-  if (!this->begin->evaluate(context).getDouble(begin_val)
-      || !this->end->evaluate(context).getDouble(end_val)) {
+  if (!this->begin->evaluate(context).getDouble(begin_val) ||
+      !this->end->evaluate(context).getDouble(end_val)) {
     return Value::undefined.clone();
   }
 
@@ -270,27 +313,25 @@ Value Range::evaluate(const std::shared_ptr<const Context>& context) const
   return RangeType(begin_val, step_val, end_val);
 }
 
-void Range::print(std::ostream& stream, const std::string&) const
-{
+void Range::print(std::ostream &stream, const std::string &) const {
   stream << "[" << *this->begin;
-  if (this->step) stream << " : " << *this->step;
+  if (this->step)
+    stream << " : " << *this->step;
   stream << " : " << *this->end;
   stream << "]";
 }
 
 bool Range::isLiteral() const {
-  return this->step ?
-         begin->isLiteral() && end->isLiteral() && step->isLiteral() :
-         begin->isLiteral() && end->isLiteral();
+  return this->step
+             ? begin->isLiteral() && end->isLiteral() && step->isLiteral()
+             : begin->isLiteral() && end->isLiteral();
 }
 
-Vector::Vector(const Location& loc) : Expression(loc), literal_flag(unknown)
-{
-}
+Vector::Vector(const Location &loc) : Expression(loc), literal_flag(unknown) {}
 
 bool Vector::isLiteral() const {
   if (unknown(literal_flag)) {
-    for (const auto& e : this->children) {
+    for (const auto &e : this->children) {
       if (!e->isLiteral()) {
         literal_flag = false;
         return false;
@@ -303,13 +344,11 @@ bool Vector::isLiteral() const {
   }
 }
 
-void Vector::emplace_back(Expression *expr)
-{
+void Vector::emplace_back(Expression *expr) {
   this->children.emplace_back(expr);
 }
 
-Value Vector::evaluate(const std::shared_ptr<const Context>& context) const
-{
+Value Vector::evaluate(const std::shared_ptr<const Context> &context) const {
   if (children.size() == 1) {
     Value val = children.front()->evaluate(context);
     // If only 1 EmbeddedVectorType, convert to plain VectorType
@@ -323,72 +362,94 @@ Value Vector::evaluate(const std::shared_ptr<const Context>& context) const
   } else {
     VectorType vec(context->session());
     vec.reserve(this->children.size());
-    for (const auto& e : this->children) vec.emplace_back(e->evaluate(context));
+    for (const auto &e : this->children)
+      vec.emplace_back(e->evaluate(context));
     return std::move(vec);
   }
 }
 
-void Vector::print(std::ostream& stream, const std::string&) const
-{
+void Vector::print(std::ostream &stream, const std::string &) const {
   stream << "[";
   for (size_t i = 0; i < this->children.size(); ++i) {
-    if (i > 0) stream << ", ";
+    if (i > 0)
+      stream << ", ";
     stream << *this->children[i];
   }
   stream << "]";
 }
 
-Lookup::Lookup(std::string name, const Location& loc) : Expression(loc), name(std::move(name))
-{
-}
+Lookup::Lookup(std::string name, const Location &loc)
+    : Expression(loc), name(std::move(name)) {}
 
-Value Lookup::evaluate(const std::shared_ptr<const Context>& context) const
-{
+Value Lookup::evaluate(const std::shared_ptr<const Context> &context) const {
   return context->lookup_variable(this->name, loc).clone();
 }
 
-void Lookup::print(std::ostream& stream, const std::string&) const
-{
+void Lookup::print(std::ostream &stream, const std::string &) const {
   stream << this->name;
 }
 
-MemberLookup::MemberLookup(Expression *expr, std::string member, const Location& loc)
-  : Expression(loc), expr(expr), member(std::move(member))
-{
-}
+MemberLookup::MemberLookup(Expression *expr, std::string member,
+                           const Location &loc)
+    : Expression(loc), expr(expr), member(std::move(member)) {}
 
-Value MemberLookup::evaluate(const std::shared_ptr<const Context>& context) const
-{
-  const Value& v = this->expr->evaluate(context);
-  static const boost::regex re_swizzle_validation("^([xyzw]{1,4}|[rgba]{1,4})$");
+Value MemberLookup::evaluate(
+    const std::shared_ptr<const Context> &context) const {
+  const Value &v = this->expr->evaluate(context);
+  static const boost::regex re_swizzle_validation(
+      "^([xyzw]{1,4}|[rgba]{1,4})$");
 
   switch (v.type()) {
   case Value::Type::VECTOR:
-    if (this->member.length() > 1 && boost::regex_match(this->member, re_swizzle_validation)) {
+    if (this->member.length() > 1 &&
+        boost::regex_match(this->member, re_swizzle_validation)) {
       VectorType ret(context->session());
       ret.reserve(this->member.length());
-      for (const char& ch : this->member)
+      for (const char &ch : this->member)
         switch (ch) {
-        case 'r': case 'x': ret.emplace_back(v[0]); break;
-        case 'g': case 'y': ret.emplace_back(v[1]); break;
-        case 'b': case 'z': ret.emplace_back(v[2]); break;
-        case 'a': case 'w': ret.emplace_back(v[3]); break;
+        case 'r':
+        case 'x':
+          ret.emplace_back(v[0]);
+          break;
+        case 'g':
+        case 'y':
+          ret.emplace_back(v[1]);
+          break;
+        case 'b':
+        case 'z':
+          ret.emplace_back(v[2]);
+          break;
+        case 'a':
+        case 'w':
+          ret.emplace_back(v[3]);
+          break;
         }
       return {std::move(ret)};
     }
-    if (this->member == "x") return v[0];
-    if (this->member == "y") return v[1];
-    if (this->member == "z") return v[2];
-    if (this->member == "w") return v[3];
-    if (this->member == "r") return v[0];
-    if (this->member == "g") return v[1];
-    if (this->member == "b") return v[2];
-    if (this->member == "a") return v[3];
+    if (this->member == "x")
+      return v[0];
+    if (this->member == "y")
+      return v[1];
+    if (this->member == "z")
+      return v[2];
+    if (this->member == "w")
+      return v[3];
+    if (this->member == "r")
+      return v[0];
+    if (this->member == "g")
+      return v[1];
+    if (this->member == "b")
+      return v[2];
+    if (this->member == "a")
+      return v[3];
     break;
   case Value::Type::RANGE:
-    if (this->member == "begin") return v[0];
-    if (this->member == "step") return v[1];
-    if (this->member == "end") return v[2];
+    if (this->member == "begin")
+      return v[0];
+    if (this->member == "step")
+      return v[1];
+    if (this->member == "end")
+      return v[2];
     break;
   case Value::Type::OBJECT:
     return v[this->member];
@@ -398,26 +459,27 @@ Value MemberLookup::evaluate(const std::shared_ptr<const Context>& context) cons
   return Value::undefined.clone();
 }
 
-void MemberLookup::print(std::ostream& stream, const std::string&) const
-{
+void MemberLookup::print(std::ostream &stream, const std::string &) const {
   stream << *this->expr << "." << this->member;
 }
 
-FunctionDefinition::FunctionDefinition(Expression *expr, AssignmentList parameters, const Location& loc)
-  : Expression(loc), context(nullptr), parameters(std::move(parameters)), expr(expr)
-{
-}
+FunctionDefinition::FunctionDefinition(Expression *expr,
+                                       AssignmentList parameters,
+                                       const Location &loc)
+    : Expression(loc), context(nullptr), parameters(std::move(parameters)),
+      expr(expr) {}
 
-Value FunctionDefinition::evaluate(const std::shared_ptr<const Context>& context) const
-{
-  return FunctionPtr{FunctionType{context, expr, std::make_unique<AssignmentList>(parameters)}};
+Value FunctionDefinition::evaluate(
+    const std::shared_ptr<const Context> &context) const {
+  return FunctionPtr{FunctionType{
+      context, expr, std::make_unique<AssignmentList>(parameters)}};
 }
 
-void FunctionDefinition::print(std::ostream& stream, const std::string& indent) const
-{
+void FunctionDefinition::print(std::ostream &stream,
+                               const std::string &indent) const {
   stream << indent << "function(";
   bool first = true;
-  for (const auto& parameter : parameters) {
+  for (const auto &parameter : parameters) {
     stream << (first ? "" : ", ") << parameter->getName();
     if (parameter->getExpr()) {
       stream << " = " << *parameter->getExpr();
@@ -434,8 +496,10 @@ void FunctionDefinition::print(std::ostream& stream, const std::string& indent)
  * noinline is required, as we here specifically optimize for stack usage
  * during normal operating, not runtime during error handling.
  */
-static void NOINLINE print_err(const char *name, const Location& loc, const std::shared_ptr<const Context>& context){
-  LOG(message_group::Error, loc, context->documentRoot(), "Recursion detected calling function '%1$s'", name);
+static void NOINLINE print_err(const char *name, const Location &loc,
+                               const std::shared_ptr<const Context> &context) {
+  LOG(message_group::Error, loc, context->documentRoot(),
+      "Recursion detected calling function '%1$s'", name);
 }
 
 /**
@@ -445,13 +509,15 @@ static void NOINLINE print_err(const char *name, const Location& loc, const std:
  * noinline is required, as we here specifically optimize for stack usage
  * during normal operating, not runtime during error handling.
  */
-static void NOINLINE print_trace(const FunctionCall *val, const std::shared_ptr<const Context>& context){
-  LOG(message_group::Trace, val->location(), context->documentRoot(), "called by '%1$s'", val->get_name());
+static void NOINLINE print_trace(
+    const FunctionCall *val, const std::shared_ptr<const Context> &context) {
+  LOG(message_group::Trace, val->location(), context->documentRoot(),
+      "called by '%1$s'", val->get_name());
 }
 
-FunctionCall::FunctionCall(Expression *expr, AssignmentList args, const Location& loc)
-  : Expression(loc), expr(expr), arguments(std::move(args))
-{
+FunctionCall::FunctionCall(Expression *expr, AssignmentList args,
+                           const Location &loc)
+    : Expression(loc), expr(expr), arguments(std::move(args)) {
   if (typeid(*expr) == typeid(Lookup)) {
     isLookup = true;
     const Lookup *lookup = static_cast<Lookup *>(expr);
@@ -466,8 +532,8 @@ FunctionCall::FunctionCall(Expression *expr, AssignmentList args, const Location
   }
 }
 
-boost::optional<CallableFunction> FunctionCall::evaluate_function_expression(const std::shared_ptr<const Context>& context) const
-{
+boost::optional<CallableFunction> FunctionCall::evaluate_function_expression(
+    const std::shared_ptr<const Context> &context) const {
   if (isLookup) {
     return context->lookup_function(name, location());
   } else {
@@ -475,7 +541,8 @@ boost::optional<CallableFunction> FunctionCall::evaluate_function_expression(con
     if (v.type() == Value::Type::FUNCTION) {
       return CallableFunction{std::move(v)};
     } else {
-      LOG(message_group::Warning, loc, context->documentRoot(), "Can't call function on %1$s", v.typeName());
+      LOG(message_group::Warning, loc, context->documentRoot(),
+          "Can't call function on %1$s", v.typeName());
       return boost::none;
     }
   }
@@ -488,12 +555,13 @@ struct SimplifiedExpression {
 };
 using SimplificationResult = std::variant<SimplifiedExpression, Value>;
 
-static SimplificationResult simplify_function_body(const Expression *expression, const std::shared_ptr<const Context>& context)
-{
+static SimplificationResult
+simplify_function_body(const Expression *expression,
+                       const std::shared_ptr<const Context> &context) {
   if (!expression) {
     return Value::undefined.clone();
   } else {
-    const auto& type = typeid(*expression);
+    const auto &type = typeid(*expression);
     if (type == typeid(TernaryOp)) {
       const auto *ternary = static_cast<const TernaryOp *>(expression);
       return SimplifiedExpression{ternary->evaluateStep(context)};
@@ -507,7 +575,8 @@ static SimplificationResult simplify_function_body(const Expression *expression,
       const Let *let = static_cast<const Let *>(expression);
       ContextHandle<Context> let_context{Context::create<Context>(context)};
       let_context->apply_config_variables(*context);
-      return SimplifiedExpression{let->evaluateStep(let_context), std::move(let_context)};
+      return SimplifiedExpression{let->evaluateStep(let_context),
+                                  std::move(let_context)};
     } else if (type == typeid(FunctionCall)) {
       const auto *call = static_cast<const FunctionCall *>(expression);
 
@@ -541,10 +610,13 @@ static SimplificationResult simplify_function_body(const Expression *expression,
           defining_context = function->getContext();
         }
       }
-      ContextHandle<Context> body_context{Context::create<Context>(defining_context)};
+      ContextHandle<Context> body_context{
+          Context::create<Context>(defining_context)};
       body_context->apply_config_variables(*context);
       Arguments arguments{call->arguments, context};
-      Parameters parameters = Parameters::parse(std::move(arguments), call->location(), *required_parameters, defining_context);
+      Parameters parameters =
+          Parameters::parse(std::move(arguments), call->location(),
+                            *required_parameters, defining_context);
       body_context->apply_variables(std::move(parameters).to_context_frame());
 
       return SimplifiedExpression{function_body, std::move(body_context), call};
@@ -554,9 +626,9 @@ static SimplificationResult simplify_function_body(const Expression *expression,
   }
 }
 
-Value FunctionCall::evaluate(const std::shared_ptr<const Context>& context) const
-{
-  const auto& name = get_name();
+Value FunctionCall::evaluate(
+    const std::shared_ptr<const Context> &context) const {
+  const auto &name = get_name();
   if (StackCheck::inst().check()) {
     print_err(name.c_str(), loc, context);
     throw RecursionException::create("function", name, this->loc);
@@ -578,7 +650,8 @@ Value FunctionCall::evaluate(const std::shared_ptr<const Context>& context) cons
         return std::move(*value);
       }
 
-      SimplifiedExpression *simplified_expression = std::get_if<SimplifiedExpression>(&result);
+      SimplifiedExpression *simplified_expression =
+          std::get_if<SimplifiedExpression>(&result);
       assert(simplified_expression);
 
       expression = simplified_expression->expression;
@@ -588,11 +661,14 @@ Value FunctionCall::evaluate(const std::shared_ptr<const Context>& context) cons
       if (simplified_expression->new_active_function_call) {
         current_call = *simplified_expression->new_active_function_call;
         if (recursion_depth++ == 1000000) {
-          LOG(message_group::Error, expression->location(), expression_context->documentRoot(), "Recursion detected calling function '%1$s'", current_call->name);
-          throw RecursionException::create("function", current_call->name, current_call->location());
+          LOG(message_group::Error, expression->location(),
+              expression_context->documentRoot(),
+              "Recursion detected calling function '%1$s'", current_call->name);
+          throw RecursionException::create("function", current_call->name,
+                                           current_call->location());
         }
       }
-    } catch (EvaluationException& e) {
+    } catch (EvaluationException &e) {
       if (e.traceDepth > 0) {
         print_trace(current_call, *expression_context);
         e.traceDepth--;
@@ -602,13 +678,13 @@ Value FunctionCall::evaluate(const std::shared_ptr<const Context>& context) cons
   }
 }
 
-void FunctionCall::print(std::ostream& stream, const std::string&) const
-{
+void FunctionCall::print(std::ostream &stream, const std::string &) const {
   stream << this->get_name() << "(" << this->arguments << ")";
 }
 
-Expression *FunctionCall::create(const std::string& funcname, const AssignmentList& arglist, Expression *expr, const Location& loc)
-{
+Expression *FunctionCall::create(const std::string &funcname,
+                                 const AssignmentList &arglist,
+                                 Expression *expr, const Location &loc) {
   if (funcname == "assert") {
     return new Assert(arglist, expr, loc);
   } else if (funcname == "echo") {
@@ -618,20 +694,19 @@ Expression *FunctionCall::create(const std::string& funcname, const AssignmentLi
   }
   return nullptr;
   // TODO: Generate error/warning if expr != 0?
-  //return new FunctionCall(funcname, arglist, loc);
+  // return new FunctionCall(funcname, arglist, loc);
 }
 
-Assert::Assert(AssignmentList args, Expression *expr, const Location& loc)
-  : Expression(loc), arguments(std::move(args)), expr(expr)
-{
-
-}
+Assert::Assert(AssignmentList args, Expression *expr, const Location &loc)
+    : Expression(loc), arguments(std::move(args)), expr(expr) {}
 
-void Assert::performAssert(const AssignmentList& arguments, const Location& location, const std::shared_ptr<const Context>& context)
-{
-  Parameters parameters = Parameters::parse(Arguments(arguments, context), location, {"condition"}, {"message"});
+void Assert::performAssert(const AssignmentList &arguments,
+                           const Location &location,
+                           const std::shared_ptr<const Context> &context) {
+  Parameters parameters = Parameters::parse(
+      Arguments(arguments, context), location, {"condition"}, {"message"});
   const Expression *conditionExpression = nullptr;
-  for (const auto& argument : arguments) {
+  for (const auto &argument : arguments) {
     if (argument->getName() == "" || argument->getName() == "condition") {
       conditionExpression = argument->getExpr().get();
       break;
@@ -639,71 +714,74 @@ void Assert::performAssert(const AssignmentList& arguments, const Location& loca
   }
 
   if (!parameters["condition"].toBool()) {
-    std::string conditionString = conditionExpression ? STR(" '", *conditionExpression, "'") : "";
-    std::string messageString = parameters.contains("message") ? (": " + parameters["message"].toEchoStringNoThrow()) : "";
-    LOG(message_group::Error, location, context->documentRoot(), "Assertion%1$s failed%2$s", conditionString, messageString);
+    std::string conditionString =
+        conditionExpression ? STR(" '", *conditionExpression, "'") : "";
+    std::string messageString =
+        parameters.contains("message")
+            ? (": " + parameters["message"].toEchoStringNoThrow())
+            : "";
+    LOG(message_group::Error, location, context->documentRoot(),
+        "Assertion%1$s failed%2$s", conditionString, messageString);
     throw AssertionFailedException("Assertion Failed", location);
   }
 }
 
-const Expression *Assert::evaluateStep(const std::shared_ptr<const Context>& context) const
-{
+const Expression *
+Assert::evaluateStep(const std::shared_ptr<const Context> &context) const {
   performAssert(this->arguments, this->loc, context);
   return expr.get();
 }
 
-Value Assert::evaluate(const std::shared_ptr<const Context>& context) const
-{
+Value Assert::evaluate(const std::shared_ptr<const Context> &context) const {
   const Expression *nextexpr = evaluateStep(context);
   return nextexpr ? nextexpr->evaluate(context) : Value::undefined.clone();
 }
 
-void Assert::print(std::ostream& stream, const std::string&) const
-{
+void Assert::print(std::ostream &stream, const std::string &) const {
   stream << "assert(" << this->arguments << ")";
-  if (this->expr) stream << " " << *this->expr;
+  if (this->expr)
+    stream << " " << *this->expr;
 }
 
-Echo::Echo(AssignmentList args, Expression *expr, const Location& loc)
-  : Expression(loc), arguments(std::move(args)), expr(expr)
-{
+Echo::Echo(AssignmentList args, Expression *expr, const Location &loc)
+    : Expression(loc), arguments(std::move(args)), expr(expr) {}
 
-}
-
-const Expression *Echo::evaluateStep(const std::shared_ptr<const Context>& context) const
-{
+const Expression *
+Echo::evaluateStep(const std::shared_ptr<const Context> &context) const {
   Arguments arguments{this->arguments, context};
   LOG(message_group::Echo, "%1$s", STR(arguments));
   return expr.get();
 }
 
-Value Echo::evaluate(const std::shared_ptr<const Context>& context) const
-{
+Value Echo::evaluate(const std::shared_ptr<const Context> &context) const {
   const Expression *nextexpr = evaluateStep(context);
   return nextexpr ? nextexpr->evaluate(context) : Value::undefined.clone();
 }
 
-void Echo::print(std::ostream& stream, const std::string&) const
-{
+void Echo::print(std::ostream &stream, const std::string &) const {
   stream << "echo(" << this->arguments << ")";
-  if (this->expr) stream << " " << *this->expr;
+  if (this->expr)
+    stream << " " << *this->expr;
 }
 
-Let::Let(AssignmentList args, Expression *expr, const Location& loc)
-  : Expression(loc), arguments(std::move(args)), expr(expr)
-{
-}
+Let::Let(AssignmentList args, Expression *expr, const Location &loc)
+    : Expression(loc), arguments(std::move(args)), expr(expr) {}
 
-void Let::doSequentialAssignment(const AssignmentList& assignments, const Location& location, ContextHandle<Context>& targetContext)
-{
+void Let::doSequentialAssignment(const AssignmentList &assignments,
+                                 const Location &location,
+                                 ContextHandle<Context> &targetContext) {
   std::set<std::string> seen;
-  for (const auto& assignment : assignments) {
+  for (const auto &assignment : assignments) {
     Value value = assignment->getExpr()->evaluate(*targetContext);
     if (assignment->getName().empty()) {
-      LOG(message_group::Warning, location, targetContext->documentRoot(), "Assignment without variable name %1$s", value.toEchoStringNoThrow());
+      LOG(message_group::Warning, location, targetContext->documentRoot(),
+          "Assignment without variable name %1$s", value.toEchoStringNoThrow());
     } else if (seen.find(assignment->getName()) != seen.end()) {
-      // TODO Should maybe quote the entire assignment with a new quoteExpr() or quoteStmt().
-      LOG(message_group::Warning, location, targetContext->documentRoot(), "Ignoring duplicate variable assignment %1$s = %2$s", quoteVar(assignment->getName()), value.toEchoStringNoThrow());
+      // TODO Should maybe quote the entire assignment with a new quoteExpr() or
+      // quoteStmt().
+      LOG(message_group::Warning, location, targetContext->documentRoot(),
+          "Ignoring duplicate variable assignment %1$s = %2$s",
+          quoteVar(assignment->getName()), value.toEchoStringNoThrow());
     } else {
       targetContext->set_variable(assignment->getName(), std::move(value));
       seen.insert(assignment->getName());
@@ -711,42 +789,38 @@ void Let::doSequentialAssignment(const AssignmentList& assignments, const Locati
   }
 }
 
-ContextHandle<Context> Let::sequentialAssignmentContext(const AssignmentList& assignments, const Location& location, const std::shared_ptr<const Context>& context)
-{
+ContextHandle<Context> Let::sequentialAssignmentContext(
+    const AssignmentList &assignments, const Location &location,
+    const std::shared_ptr<const Context> &context) {
   ContextHandle<Context> letContext{Context::create<Context>(context)};
   doSequentialAssignment(assignments, location, letContext);
   return letContext;
 }
 
-const Expression *Let::evaluateStep(ContextHandle<Context>& targetContext) const
-{
+const Expression *
+Let::evaluateStep(ContextHandle<Context> &targetContext) const {
   doSequentialAssignment(this->arguments, this->location(), targetContext);
   return this->expr.get();
 }
 
-Value Let::evaluate(const std::shared_ptr<const Context>& context) const
-{
+Value Let::evaluate(const std::shared_ptr<const Context> &context) const {
   ContextHandle<Context> letContext{Context::create<Context>(context)};
   return evaluateStep(letContext)->evaluate(*letContext);
 }
 
-void Let::print(std::ostream& stream, const std::string&) const
-{
+void Let::print(std::ostream &stream, const std::string &) const {
   stream << "let(" << this->arguments << ") " << *expr;
 }
 
-ListComprehension::ListComprehension(const Location& loc) : Expression(loc)
-{
-}
+ListComprehension::ListComprehension(const Location &loc) : Expression(loc) {}
 
-LcIf::LcIf(Expression *cond, Expression *ifexpr, Expression *elseexpr, const Location& loc)
-  : ListComprehension(loc), cond(cond), ifexpr(ifexpr), elseexpr(elseexpr)
-{
-}
+LcIf::LcIf(Expression *cond, Expression *ifexpr, Expression *elseexpr,
+           const Location &loc)
+    : ListComprehension(loc), cond(cond), ifexpr(ifexpr), elseexpr(elseexpr) {}
 
-Value LcIf::evaluate(const std::shared_ptr<const Context>& context) const
-{
-  const std::shared_ptr<Expression>& expr = this->cond->evaluate(context).toBool() ? this->ifexpr : this->elseexpr;
+Value LcIf::evaluate(const std::shared_ptr<const Context> &context) const {
+  const std::shared_ptr<Expression> &expr =
+      this->cond->evaluate(context).toBool() ? this->ifexpr : this->elseexpr;
   if (expr) {
     return expr->evaluate(context);
   } else {
@@ -754,49 +828,54 @@ Value LcIf::evaluate(const std::shared_ptr<const Context>& context) const
   }
 }
 
-void LcIf::print(std::ostream& stream, const std::string&) const
-{
+void LcIf::print(std::ostream &stream, const std::string &) const {
   stream << "if(" << *this->cond << ") (" << *this->ifexpr << ")";
   if (this->elseexpr) {
     stream << " else (" << *this->elseexpr << ")";
   }
 }
 
-LcEach::LcEach(Expression *expr, const Location& loc) : ListComprehension(loc), expr(expr)
-{
-}
+LcEach::LcEach(Expression *expr, const Location &loc)
+    : ListComprehension(loc), expr(expr) {}
 
-// Need this for recurring into already embedded vectors, and performing "each" on their elements
+// Need this for recurring into already embedded vectors, and performing "each"
+// on their elements
 //    Context is only passed along for the possible use in Range warning.
-Value LcEach::evalRecur(Value&& v, const std::shared_ptr<const Context>& context) const
-{
+Value LcEach::evalRecur(Value &&v,
+                        const std::shared_ptr<const Context> &context) const {
   if (v.type() == Value::Type::RANGE) {
-    const RangeType& range = v.toRange();
+    const RangeType &range = v.toRange();
     uint32_t steps = range.numValues();
     if (steps >= 1000000) {
-      LOG(message_group::Warning, loc, context->documentRoot(), "Bad range parameter in for statement: too many elements (%1$lu)", steps);
+      LOG(message_group::Warning, loc, context->documentRoot(),
+          "Bad range parameter in for statement: too many elements (%1$lu)",
+          steps);
     } else {
       EmbeddedVectorType vec(context->session());
       vec.reserve(range.numValues());
-      for (double d : range) vec.emplace_back(d);
+      for (double d : range)
+        vec.emplace_back(d);
       return {std::move(vec)};
     }
   } else if (v.type() == Value::Type::VECTOR) {
-    // Safe to move the overall vector ptr since we have a temporary value (could be a copy, or constructed just for us, doesn't matter)
+    // Safe to move the overall vector ptr since we have a temporary value
+    // (could be a copy, or constructed just for us, doesn't matter)
     auto vec = EmbeddedVectorType(std::move(v.toVectorNonConst()));
     return {std::move(vec)};
   } else if (v.type() == Value::Type::EMBEDDED_VECTOR) {
     EmbeddedVectorType vec(context->session());
     vec.reserve(v.toEmbeddedVector().size());
-    // Not safe to move values out of a vector, since it's shared_ptr maye be shared with another Value,
-    // which should remain constant
-    for (const auto& val : v.toEmbeddedVector()) vec.emplace_back(evalRecur(val.clone(), context) );
+    // Not safe to move values out of a vector, since it's shared_ptr maye be
+    // shared with another Value, which should remain constant
+    for (const auto &val : v.toEmbeddedVector())
+      vec.emplace_back(evalRecur(val.clone(), context));
     return {std::move(vec)};
   } else if (v.type() == Value::Type::STRING) {
     EmbeddedVectorType vec(context->session());
-    auto& wrapper = v.toStrUtf8Wrapper();
+    auto &wrapper = v.toStrUtf8Wrapper();
     vec.reserve(wrapper.size());
-    for (auto ch : wrapper) vec.emplace_back(std::move(ch));
+    for (auto ch : wrapper)
+      vec.emplace_back(std::move(ch));
     return {std::move(vec)};
   } else if (v.type() != Value::Type::UNDEFINED) {
     return std::move(v);
@@ -804,138 +883,138 @@ Value LcEach::evalRecur(Value&& v, const std::shared_ptr<const Context>& context
   return EmbeddedVectorType::Empty();
 }
 
-Value LcEach::evaluate(const std::shared_ptr<const Context>& context) const
-{
+Value LcEach::evaluate(const std::shared_ptr<const Context> &context) const {
   return evalRecur(this->expr->evaluate(context), context);
 }
 
-void LcEach::print(std::ostream& stream, const std::string&) const
-{
+void LcEach::print(std::ostream &stream, const std::string &) const {
   stream << "each (" << *this->expr << ")";
 }
 
-LcFor::LcFor(AssignmentList args, Expression *expr, const Location& loc)
-  : ListComprehension(loc), arguments(std::move(args)), expr(expr)
-{
-}
+LcFor::LcFor(AssignmentList args, Expression *expr, const Location &loc)
+    : ListComprehension(loc), arguments(std::move(args)), expr(expr) {}
 
-static inline ContextHandle<Context> forContext(const std::shared_ptr<const Context>& context, const std::string& name, Value value)
-{
+static inline ContextHandle<Context>
+forContext(const std::shared_ptr<const Context> &context,
+           const std::string &name, Value value) {
   ContextHandle<Context> innerContext{Context::create<Context>(context)};
   innerContext->set_variable(name, std::move(value));
   return innerContext;
 }
 
-static void doForEach(
-  const AssignmentList& assignments,
-  const Location& location,
-  const std::function<void(const std::shared_ptr<const Context>&)>& operation,
-  size_t assignment_index,
-  const std::shared_ptr<const Context>& context,
-  const std::function<void(size_t)> *pReserve = nullptr
-  ) {
+static void
+doForEach(const AssignmentList &assignments, const Location &location,
+          const std::function<void(const std::shared_ptr<const Context> &)>
+              &operation,
+          size_t assignment_index,
+          const std::shared_ptr<const Context> &context,
+          const std::function<void(size_t)> *pReserve = nullptr) {
   if (assignment_index >= assignments.size()) {
     operation(context);
     return;
   }
 
-  const std::string& variable_name = assignments[assignment_index]->getName();
-  Value variable_values = assignments[assignment_index]->getExpr()->evaluate(context);
+  const std::string &variable_name = assignments[assignment_index]->getName();
+  Value variable_values =
+      assignments[assignment_index]->getExpr()->evaluate(context);
 
   if (variable_values.type() == Value::Type::RANGE) {
-    const RangeType& range = variable_values.toRange();
+    const RangeType &range = variable_values.toRange();
     uint32_t steps = range.numValues();
     if (steps >= 1000000) {
       LOG(message_group::Warning, location, context->documentRoot(),
-          "Bad range parameter in for statement: too many elements (%1$lu)", steps);
+          "Bad range parameter in for statement: too many elements (%1$lu)",
+          steps);
     } else {
       if (pReserve) {
         (*pReserve)(steps);
       }
       for (double value : range) {
         doForEach(assignments, location, operation, assignment_index + 1,
-                  *forContext(context, variable_name, value)
-                  );
+                  *forContext(context, variable_name, value));
       }
     }
   } else if (variable_values.type() == Value::Type::VECTOR) {
-    auto& vec = variable_values.toVector();
+    auto &vec = variable_values.toVector();
     if (pReserve) {
       (*pReserve)(vec.size());
     }
-    for (const auto& value : vec) {
+    for (const auto &value : vec) {
       doForEach(assignments, location, operation, assignment_index + 1,
-                *forContext(context, variable_name, value.clone())
-                );
+                *forContext(context, variable_name, value.clone()));
     }
   } else if (variable_values.type() == Value::Type::OBJECT) {
-    auto& keys = variable_values.toObject().keys();
+    auto &keys = variable_values.toObject().keys();
     if (pReserve) {
       (*pReserve)(keys.size());
     }
     for (auto key : keys) {
       doForEach(assignments, location, operation, assignment_index + 1,
-                *forContext(context, variable_name, key)
-                );
+                *forContext(context, variable_name, key));
     }
   } else if (variable_values.type() == Value::Type::STRING) {
-    auto& wrapper = variable_values.toStrUtf8Wrapper();
+    auto &wrapper = variable_values.toStrUtf8Wrapper();
     if (pReserve) {
       (*pReserve)(wrapper.size());
     }
     for (auto value : wrapper) {
       doForEach(assignments, location, operation, assignment_index + 1,
-                *forContext(context, variable_name, Value(std::move(value)))
-                );
+                *forContext(context, variable_name, Value(std::move(value))));
     }
   } else if (variable_values.type() != Value::Type::UNDEFINED) {
     doForEach(assignments, location, operation, assignment_index + 1,
-              *forContext(context, variable_name, std::move(variable_values))
-              );
+              *forContext(context, variable_name, std::move(variable_values)));
   }
 }
 
-void LcFor::forEach(const AssignmentList& assignments, const Location& loc, const std::shared_ptr<const Context>& context, const std::function<void(const std::shared_ptr<const Context>&)>& operation, const std::function<void(size_t)> *pReserve)
-{
+void LcFor::forEach(
+    const AssignmentList &assignments, const Location &loc,
+    const std::shared_ptr<const Context> &context,
+    const std::function<void(const std::shared_ptr<const Context> &)>
+        &operation,
+    const std::function<void(size_t)> *pReserve) {
   doForEach(assignments, loc, operation, 0, context, pReserve);
 }
 
-Value LcFor::evaluate(const std::shared_ptr<const Context>& context) const
-{
+Value LcFor::evaluate(const std::shared_ptr<const Context> &context) const {
   EmbeddedVectorType vec(context->session());
   std::function<void(size_t)> reserve = [&vec](size_t capacity) {
-      vec.reserve(capacity);
-    };
-  forEach(this->arguments, this->loc, context,
-          [&vec, expression = expr.get()] (const std::shared_ptr<const Context>& iterationContext) {
-    vec.emplace_back(expression->evaluate(iterationContext));
-  }, &reserve);
+    vec.reserve(capacity);
+  };
+  forEach(
+      this->arguments, this->loc, context,
+      [&vec, expression = expr.get()](
+          const std::shared_ptr<const Context> &iterationContext) {
+        vec.emplace_back(expression->evaluate(iterationContext));
+      },
+      &reserve);
   return {std::move(vec)};
 }
 
-void LcFor::print(std::ostream& stream, const std::string&) const
-{
+void LcFor::print(std::ostream &stream, const std::string &) const {
   stream << "for(" << this->arguments << ") (" << *this->expr << ")";
 }
 
-LcForC::LcForC(AssignmentList args, AssignmentList incrargs, Expression *cond, Expression *expr, const Location& loc)
-  : ListComprehension(loc), arguments(std::move(args)), incr_arguments(std::move(incrargs)), cond(cond), expr(expr)
-{
-}
+LcForC::LcForC(AssignmentList args, AssignmentList incrargs, Expression *cond,
+               Expression *expr, const Location &loc)
+    : ListComprehension(loc), arguments(std::move(args)),
+      incr_arguments(std::move(incrargs)), cond(cond), expr(expr) {}
 
-Value LcForC::evaluate(const std::shared_ptr<const Context>& context) const
-{
+Value LcForC::evaluate(const std::shared_ptr<const Context> &context) const {
   EmbeddedVectorType output(context->session());
 
-  ContextHandle<Context> initialContext{Let::sequentialAssignmentContext(this->arguments, this->location(), context)};
-  ContextHandle<Context> currentContext{Context::create<Context>(*initialContext)};
+  ContextHandle<Context> initialContext{Let::sequentialAssignmentContext(
+      this->arguments, this->location(), context)};
+  ContextHandle<Context> currentContext{
+      Context::create<Context>(*initialContext)};
 
   unsigned int counter = 0;
   while (this->cond->evaluate(*currentContext).toBool()) {
     output.emplace_back(this->expr->evaluate(*currentContext));
 
     if (counter++ == 1000000) {
-      LOG(message_group::Error, loc, context->documentRoot(), "For loop counter exceeded limit");
+      LOG(message_group::Error, loc, context->documentRoot(),
+          "For loop counter exceeded limit");
       throw LoopCntException::create("for", loc);
     }
 
@@ -950,33 +1029,27 @@ Value LcForC::evaluate(const std::shared_ptr<const Context>& context) const
      * captured context references in lambda functions.
      * So, we reparent the next context to the initial context.
      */
-    ContextHandle<Context> nextContext{Let::sequentialAssignmentContext(this->incr_arguments, this->location(), *currentContext)};
+    ContextHandle<Context> nextContext{Let::sequentialAssignmentContext(
+        this->incr_arguments, this->location(), *currentContext)};
     currentContext = std::move(nextContext);
     currentContext->setParent(*initialContext);
   }
   return {std::move(output)};
 }
 
-void LcForC::print(std::ostream& stream, const std::string&) const
-{
-  stream
-    << "for(" << this->arguments
-    << ";" << *this->cond
-    << ";" << this->incr_arguments
-    << ") " << *this->expr;
+void LcForC::print(std::ostream &stream, const std::string &) const {
+  stream << "for(" << this->arguments << ";" << *this->cond << ";"
+         << this->incr_arguments << ") " << *this->expr;
 }
 
-LcLet::LcLet(AssignmentList args, Expression *expr, const Location& loc)
-  : ListComprehension(loc), arguments(std::move(args)), expr(expr)
-{
-}
+LcLet::LcLet(AssignmentList args, Expression *expr, const Location &loc)
+    : ListComprehension(loc), arguments(std::move(args)), expr(expr) {}
 
-Value LcLet::evaluate(const std::shared_ptr<const Context>& context) const
-{
-  return this->expr->evaluate(*Let::sequentialAssignmentContext(this->arguments, this->location(), context));
+Value LcLet::evaluate(const std::shared_ptr<const Context> &context) const {
+  return this->expr->evaluate(*Let::sequentialAssignmentContext(
+      this->arguments, this->location(), context));
 }
 
-void LcLet::print(std::ostream& stream, const std::string&) const
-{
+void LcLet::print(std::ostream &stream, const std::string &) const {
   stream << "let(" << this->arguments << ") (" << *this->expr << ")";
 }
diff --git a/src/core/Expression.h b/src/core/Expression.h
index b0800c2a4..6fd761752 100644
--- a/src/core/Expression.h
+++ b/src/core/Expression.h
@@ -1,41 +1,38 @@
 #pragma once
 
-#include <ostream>
-#include <utility>
+#include "core/AST.h"
+#include "core/Assignment.h"
+#include "core/Value.h"
+#include "core/function.h"
+#include <boost/logic/tribool.hpp>
 #include <cstddef>
 #include <functional>
+#include <memory>
+#include <ostream>
 #include <string>
+#include <utility>
 #include <vector>
-#include <memory>
-#include <boost/logic/tribool.hpp>
-#include "core/Assignment.h"
-#include "core/AST.h"
-#include "core/function.h"
-#include "core/Value.h"
 
 template <class T> class ContextHandle;
 
-class Expression : public ASTNode
-{
+class Expression : public ASTNode {
 public:
-  Expression(const Location& loc) : ASTNode(loc) {}
+  Expression(const Location &loc) : ASTNode(loc) {}
   [[nodiscard]] virtual bool isLiteral() const;
-  [[nodiscard]] virtual Value evaluate(const std::shared_ptr<const Context>& context) const = 0;
-  Value checkUndef(Value&& val, const std::shared_ptr<const Context>& context) const;
+  [[nodiscard]] virtual Value
+  evaluate(const std::shared_ptr<const Context> &context) const = 0;
+  Value checkUndef(Value &&val,
+                   const std::shared_ptr<const Context> &context) const;
 };
 
-class UnaryOp : public Expression
-{
+class UnaryOp : public Expression {
 public:
-  enum class Op {
-    Not,
-    BinaryNot,
-    Negate
-  };
+  enum class Op { Not, BinaryNot, Negate };
   [[nodiscard]] bool isLiteral() const override;
-  UnaryOp(Op op, Expression *expr, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  UnaryOp(Op op, Expression *expr, const Location &loc);
+  [[nodiscard]] Value
+  evaluate(const std::shared_ptr<const Context> &context) const override;
+  void print(std::ostream &stream, const std::string &indent) const override;
 
 private:
   [[nodiscard]] const char *opString() const;
@@ -44,8 +41,7 @@ private:
   std::shared_ptr<Expression> expr;
 };
 
-class BinaryOp : public Expression
-{
+class BinaryOp : public Expression {
 public:
   enum class Op {
     LogicalAnd,
@@ -68,9 +64,10 @@ public:
     NotEqual
   };
 
-  BinaryOp(Expression *left, Op op, Expression *right, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  BinaryOp(Expression *left, Op op, Expression *right, const Location &loc);
+  [[nodiscard]] Value
+  evaluate(const std::shared_ptr<const Context> &context) const override;
+  void print(std::ostream &stream, const std::string &indent) const override;
 
 private:
   [[nodiscard]] const char *opString() const;
@@ -80,112 +77,139 @@ private:
   std::shared_ptr<Expression> right;
 };
 
-class TernaryOp : public Expression
-{
+class TernaryOp : public Expression {
 public:
-  TernaryOp(Expression *cond, Expression *ifexpr, Expression *elseexpr, const Location& loc);
-  [[nodiscard]] const Expression *evaluateStep(const std::shared_ptr<const Context>& context) const;
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  TernaryOp(Expression *cond, Expression *ifexpr, Expression *elseexpr,
+            const Location &loc);
+  [[nodiscard]] const Expression *
+  evaluateStep(const std::shared_ptr<const Context> &context) const;
+  [[nodiscard]] Value
+  evaluate(const std::shared_ptr<const Context> &context) const override;
+  void print(std::ostream &stream, const std::string &indent) const override;
+
 private:
   std::shared_ptr<Expression> cond;
   std::shared_ptr<Expression> ifexpr;
   std::shared_ptr<Expression> elseexpr;
 };
 
-class ArrayLookup : public Expression
-{
+class ArrayLookup : public Expression {
 public:
-  ArrayLookup(Expression *array, Expression *index, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  ArrayLookup(Expression *array, Expression *index, const Location &loc);
+  [[nodiscard]] Value
+  evaluate(const std::shared_ptr<const Context> &context) const override;
+  void print(std::ostream &stream, const std::string &indent) const override;
+
 private:
   std::shared_ptr<Expression> array;
   std::shared_ptr<Expression> index;
 };
 
-class Literal : public Expression
-{
+class Literal : public Expression {
 public:
-  Literal(const Location& loc = Location::NONE) : Expression(loc), value(Value::undefined.clone()) { }
-  Literal(Value val, const Location& loc = Location::NONE) : Expression(loc), value(std::move(val)) { }
-  [[nodiscard]] bool isBool() const { return value.type() == Value::Type::BOOL; }
+  Literal(const Location &loc = Location::NONE)
+      : Expression(loc), value(Value::undefined.clone()) {}
+  Literal(Value val, const Location &loc = Location::NONE)
+      : Expression(loc), value(std::move(val)) {}
+  [[nodiscard]] bool isBool() const {
+    return value.type() == Value::Type::BOOL;
+  }
   [[nodiscard]] bool toBool() const { return value.toBool(); }
-  [[nodiscard]] bool isDouble() const { return value.type() == Value::Type::NUMBER; }
+  [[nodiscard]] bool isDouble() const {
+    return value.type() == Value::Type::NUMBER;
+  }
   [[nodiscard]] double toDouble() const { return value.toDouble(); }
-  [[nodiscard]] bool isString() const { return value.type() == Value::Type::STRING; }
-  [[nodiscard]] const std::string& toString() const { return value.toStrUtf8Wrapper().toString(); }
-  [[nodiscard]] bool isUndefined() const { return value.type() == Value::Type::UNDEFINED; }
+  [[nodiscard]] bool isString() const {
+    return value.type() == Value::Type::STRING;
+  }
+  [[nodiscard]] const std::string &toString() const {
+    return value.toStrUtf8Wrapper().toString();
+  }
+  [[nodiscard]] bool isUndefined() const {
+    return value.type() == Value::Type::UNDEFINED;
+  }
 
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  [[nodiscard]] Value
+  evaluate(const std::shared_ptr<const Context> &context) const override;
+  void print(std::ostream &stream, const std::string &indent) const override;
   [[nodiscard]] bool isLiteral() const override { return true; }
+
 private:
   const Value value;
 };
 
-class Range : public Expression
-{
+class Range : public Expression {
 public:
-  Range(Expression *begin, Expression *end, const Location& loc);
-  Range(Expression *begin, Expression *step, Expression *end, const Location& loc);
+  Range(Expression *begin, Expression *end, const Location &loc);
+  Range(Expression *begin, Expression *step, Expression *end,
+        const Location &loc);
   [[nodiscard]] const Expression *getBegin() const { return begin.get(); }
   [[nodiscard]] const Expression *getStep() const { return step.get(); }
   [[nodiscard]] const Expression *getEnd() const { return end.get(); }
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  [[nodiscard]] Value
+  evaluate(const std::shared_ptr<const Context> &context) const override;
+  void print(std::ostream &stream, const std::string &indent) const override;
   [[nodiscard]] bool isLiteral() const override;
+
 private:
   std::shared_ptr<Expression> begin;
   std::shared_ptr<Expression> step;
   std::shared_ptr<Expression> end;
 };
 
-class Vector : public Expression
-{
+class Vector : public Expression {
 public:
-  Vector(const Location& loc);
-  const std::vector<std::shared_ptr<Expression>>& getChildren() const { return children; }
-  Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  Vector(const Location &loc);
+  const std::vector<std::shared_ptr<Expression>> &getChildren() const {
+    return children;
+  }
+  Value evaluate(const std::shared_ptr<const Context> &context) const override;
+  void print(std::ostream &stream, const std::string &indent) const override;
   void emplace_back(Expression *expr);
   bool isLiteral() const override;
+
 private:
   std::vector<std::shared_ptr<Expression>> children;
   mutable boost::tribool literal_flag; // cache if already computed
 };
 
-class Lookup : public Expression
-{
+class Lookup : public Expression {
 public:
-  Lookup(std::string name, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
-  [[nodiscard]] const std::string& get_name() const { return name; }
+  Lookup(std::string name, const Location &loc);
+  [[nodiscard]] Value
+  evaluate(const std::shared_ptr<const Context> &context) const override;
+  void print(std::ostream &stream, const std::string &indent) const override;
+  [[nodiscard]] const std::string &get_name() const { return name; }
+
 private:
   std::string name;
 };
 
-class MemberLookup : public Expression
-{
+class MemberLookup : public Expression {
 public:
-  MemberLookup(Expression *expr, std::string member, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  MemberLookup(Expression *expr, std::string member, const Location &loc);
+  [[nodiscard]] Value
+  evaluate(const std::shared_ptr<const Context> &context) const override;
+  void print(std::ostream &stream, const std::string &indent) const override;
+
 private:
   std::shared_ptr<Expression> expr;
   std::string member;
 };
 
-class FunctionCall : public Expression
-{
+class FunctionCall : public Expression {
 public:
-  FunctionCall(Expression *expr, AssignmentList arglist, const Location& loc);
-  [[nodiscard]] boost::optional<CallableFunction> evaluate_function_expression(const std::shared_ptr<const Context>& context) const;
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
-  [[nodiscard]] const std::string& get_name() const { return name; }
-  static Expression *create(const std::string& funcname, const AssignmentList& arglist, Expression *expr, const Location& loc);
+  FunctionCall(Expression *expr, AssignmentList arglist, const Location &loc);
+  [[nodiscard]] boost::optional<CallableFunction> evaluate_function_expression(
+      const std::shared_ptr<const Context> &context) const;
+  [[nodiscard]] Value
+  evaluate(const std::shared_ptr<const Context> &context) const override;
+  void print(std::ostream &stream, const std::string &indent) const override;
+  [[nodiscard]] const std::string &get_name() const { return name; }
+  static Expression *create(const std::string &funcname,
+                            const AssignmentList &arglist, Expression *expr,
+                            const Location &loc);
+
 public:
   bool isLookup;
   std::string name;
@@ -193,93 +217,116 @@ public:
   AssignmentList arguments;
 };
 
-class FunctionDefinition : public Expression
-{
+class FunctionDefinition : public Expression {
 public:
-  FunctionDefinition(Expression *expr, AssignmentList parameters, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  FunctionDefinition(Expression *expr, AssignmentList parameters,
+                     const Location &loc);
+  [[nodiscard]] Value
+  evaluate(const std::shared_ptr<const Context> &context) const override;
+  void print(std::ostream &stream, const std::string &indent) const override;
+
 public:
   std::shared_ptr<const Context> context;
   AssignmentList parameters;
   std::shared_ptr<Expression> expr;
 };
 
-class Assert : public Expression
-{
+class Assert : public Expression {
 public:
-  Assert(AssignmentList args, Expression *expr, const Location& loc);
-  static void performAssert(const AssignmentList& arguments, const Location& location, const std::shared_ptr<const Context>& context);
-  [[nodiscard]] const Expression *evaluateStep(const std::shared_ptr<const Context>& context) const;
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  Assert(AssignmentList args, Expression *expr, const Location &loc);
+  static void performAssert(const AssignmentList &arguments,
+                            const Location &location,
+                            const std::shared_ptr<const Context> &context);
+  [[nodiscard]] const Expression *
+  evaluateStep(const std::shared_ptr<const Context> &context) const;
+  [[nodiscard]] Value
+  evaluate(const std::shared_ptr<const Context> &context) const override;
+  void print(std::ostream &stream, const std::string &indent) const override;
+
 private:
   AssignmentList arguments;
   std::shared_ptr<Expression> expr;
 };
 
-class Echo : public Expression
-{
+class Echo : public Expression {
 public:
-  Echo(AssignmentList args, Expression *expr, const Location& loc);
-  [[nodiscard]] const Expression *evaluateStep(const std::shared_ptr<const Context>& context) const;
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  Echo(AssignmentList args, Expression *expr, const Location &loc);
+  [[nodiscard]] const Expression *
+  evaluateStep(const std::shared_ptr<const Context> &context) const;
+  [[nodiscard]] Value
+  evaluate(const std::shared_ptr<const Context> &context) const override;
+  void print(std::ostream &stream, const std::string &indent) const override;
+
 private:
   AssignmentList arguments;
   std::shared_ptr<Expression> expr;
 };
 
-class Let : public Expression
-{
+class Let : public Expression {
 public:
-  Let(AssignmentList args, Expression *expr, const Location& loc);
-  static void doSequentialAssignment(const AssignmentList& assignments, const Location& location, ContextHandle<Context>& targetContext);
-  static ContextHandle<Context> sequentialAssignmentContext(const AssignmentList& assignments, const Location& location, const std::shared_ptr<const Context>& context);
-  const Expression *evaluateStep(ContextHandle<Context>& targetContext) const;
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  Let(AssignmentList args, Expression *expr, const Location &loc);
+  static void doSequentialAssignment(const AssignmentList &assignments,
+                                     const Location &location,
+                                     ContextHandle<Context> &targetContext);
+  static ContextHandle<Context>
+  sequentialAssignmentContext(const AssignmentList &assignments,
+                              const Location &location,
+                              const std::shared_ptr<const Context> &context);
+  const Expression *evaluateStep(ContextHandle<Context> &targetContext) const;
+  [[nodiscard]] Value
+  evaluate(const std::shared_ptr<const Context> &context) const override;
+  void print(std::ostream &stream, const std::string &indent) const override;
+
 private:
   AssignmentList arguments;
   std::shared_ptr<Expression> expr;
 };
 
-class ListComprehension : public Expression
-{
+class ListComprehension : public Expression {
 public:
-  ListComprehension(const Location& loc);
+  ListComprehension(const Location &loc);
 };
 
-class LcIf : public ListComprehension
-{
+class LcIf : public ListComprehension {
 public:
-  LcIf(Expression *cond, Expression *ifexpr, Expression *elseexpr, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  LcIf(Expression *cond, Expression *ifexpr, Expression *elseexpr,
+       const Location &loc);
+  [[nodiscard]] Value
+  evaluate(const std::shared_ptr<const Context> &context) const override;
+  void print(std::ostream &stream, const std::string &indent) const override;
+
 private:
   std::shared_ptr<Expression> cond;
   std::shared_ptr<Expression> ifexpr;
   std::shared_ptr<Expression> elseexpr;
 };
 
-class LcFor : public ListComprehension
-{
+class LcFor : public ListComprehension {
 public:
-  LcFor(AssignmentList args, Expression *expr, const Location& loc);
-  static void forEach(const AssignmentList& assignments, const Location& loc, const std::shared_ptr<const Context>& context, const std::function<void(const std::shared_ptr<const Context>&)>& operation, const std::function<void(size_t)> *pReserve = nullptr);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  LcFor(AssignmentList args, Expression *expr, const Location &loc);
+  static void
+  forEach(const AssignmentList &assignments, const Location &loc,
+          const std::shared_ptr<const Context> &context,
+          const std::function<void(const std::shared_ptr<const Context> &)>
+              &operation,
+          const std::function<void(size_t)> *pReserve = nullptr);
+  [[nodiscard]] Value
+  evaluate(const std::shared_ptr<const Context> &context) const override;
+  void print(std::ostream &stream, const std::string &indent) const override;
+
 private:
   AssignmentList arguments;
   std::shared_ptr<Expression> expr;
 };
 
-class LcForC : public ListComprehension
-{
+class LcForC : public ListComprehension {
 public:
-  LcForC(AssignmentList args, AssignmentList incrargs, Expression *cond, Expression *expr, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  LcForC(AssignmentList args, AssignmentList incrargs, Expression *cond,
+         Expression *expr, const Location &loc);
+  [[nodiscard]] Value
+  evaluate(const std::shared_ptr<const Context> &context) const override;
+  void print(std::ostream &stream, const std::string &indent) const override;
+
 private:
   AssignmentList arguments;
   AssignmentList incr_arguments;
@@ -287,23 +334,26 @@ private:
   std::shared_ptr<Expression> expr;
 };
 
-class LcEach : public ListComprehension
-{
+class LcEach : public ListComprehension {
 public:
-  LcEach(Expression *expr, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  LcEach(Expression *expr, const Location &loc);
+  [[nodiscard]] Value
+  evaluate(const std::shared_ptr<const Context> &context) const override;
+  void print(std::ostream &stream, const std::string &indent) const override;
+
 private:
-  Value evalRecur(Value&& v, const std::shared_ptr<const Context>& context) const;
+  Value evalRecur(Value &&v,
+                  const std::shared_ptr<const Context> &context) const;
   std::shared_ptr<Expression> expr;
 };
 
-class LcLet : public ListComprehension
-{
+class LcLet : public ListComprehension {
 public:
-  LcLet(AssignmentList args, Expression *expr, const Location& loc);
-  [[nodiscard]] Value evaluate(const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  LcLet(AssignmentList args, Expression *expr, const Location &loc);
+  [[nodiscard]] Value
+  evaluate(const std::shared_ptr<const Context> &context) const override;
+  void print(std::ostream &stream, const std::string &indent) const override;
+
 private:
   AssignmentList arguments;
   std::shared_ptr<Expression> expr;
diff --git a/src/core/FreetypeRenderer.cc b/src/core/FreetypeRenderer.cc
index 892ddb859..340a79bfa 100644
--- a/src/core/FreetypeRenderer.cc
+++ b/src/core/FreetypeRenderer.cc
@@ -26,14 +26,13 @@
 #include "core/FreetypeRenderer.h"
 
 #include <algorithm>
-#include <limits>
-#include <cstdint>
-#include <memory>
 #include <cmath>
+#include <cstdint>
 #include <cstdio>
+#include <limits>
+#include <memory>
 #include <vector>
 
-
 #include <fontconfig/fontconfig.h>
 #include <hb-ft.h>
 
@@ -46,16 +45,18 @@
 
 #include FT_OUTLINE_H
 // NOLINTNEXTLINE(bugprone-macro-parentheses)
-#define SCRIPT_UNTAG(tag)   ((uint8_t)((tag) >> 24)) % ((uint8_t)((tag) >> 16)) % ((uint8_t)((tag) >> 8)) % ((uint8_t)(tag))
+#define SCRIPT_UNTAG(tag)                                                      \
+  ((uint8_t)((tag) >> 24)) % ((uint8_t)((tag) >> 16)) %                        \
+      ((uint8_t)((tag) >> 8)) % ((uint8_t)(tag))
 
-static inline Vector2d get_scaled_vector(const FT_Vector *ft_vector, double scale) {
+static inline Vector2d get_scaled_vector(const FT_Vector *ft_vector,
+                                         double scale) {
   return {ft_vector->x / scale, ft_vector->y / scale};
 }
 
 const double FreetypeRenderer::scale = 1e5;
 
-FreetypeRenderer::FreetypeRenderer()
-{
+FreetypeRenderer::FreetypeRenderer() {
   funcs.move_to = outline_move_to_func;
   funcs.line_to = outline_line_to_func;
   funcs.conic_to = outline_conic_to_func;
@@ -64,42 +65,41 @@ FreetypeRenderer::FreetypeRenderer()
   funcs.shift = 0;
 }
 
-int FreetypeRenderer::outline_move_to_func(const FT_Vector *to, void *user)
-{
+int FreetypeRenderer::outline_move_to_func(const FT_Vector *to, void *user) {
   auto *cb = reinterpret_cast<DrawingCallback *>(user);
 
   cb->move_to(get_scaled_vector(to, scale));
   return 0;
 }
 
-int FreetypeRenderer::outline_line_to_func(const FT_Vector *to, void *user)
-{
+int FreetypeRenderer::outline_line_to_func(const FT_Vector *to, void *user) {
   auto *cb = reinterpret_cast<DrawingCallback *>(user);
 
   cb->line_to(get_scaled_vector(to, scale));
   return 0;
 }
 
-int FreetypeRenderer::outline_conic_to_func(const FT_Vector *c1, const FT_Vector *to, void *user)
-{
+int FreetypeRenderer::outline_conic_to_func(const FT_Vector *c1,
+                                            const FT_Vector *to, void *user) {
   auto *cb = reinterpret_cast<DrawingCallback *>(user);
 
   cb->curve_to(get_scaled_vector(c1, scale), get_scaled_vector(to, scale));
   return 0;
 }
 
-int FreetypeRenderer::outline_cubic_to_func(const FT_Vector *c1, const FT_Vector *c2, const FT_Vector *to, void *user)
-{
+int FreetypeRenderer::outline_cubic_to_func(const FT_Vector *c1,
+                                            const FT_Vector *c2,
+                                            const FT_Vector *to, void *user) {
   auto *cb = reinterpret_cast<DrawingCallback *>(user);
 
-  cb->curve_to(get_scaled_vector(c1, scale), get_scaled_vector(c2, scale), get_scaled_vector(to, scale));
+  cb->curve_to(get_scaled_vector(c1, scale), get_scaled_vector(c2, scale),
+               get_scaled_vector(to, scale));
   return 0;
 }
 
 // Calculate offsets for horizontal text.
 void FreetypeRenderer::ShapeResults::calc_offsets_horiz(
-  const FreetypeRenderer::Params& params)
-{
+    const FreetypeRenderer::Params &params) {
   if (params.halign == "right") {
     x_offset = -advance_x;
   } else if (params.halign == "center") {
@@ -134,8 +134,7 @@ void FreetypeRenderer::ShapeResults::calc_offsets_horiz(
 
 // Calculate offsets for vertical text.
 void FreetypeRenderer::ShapeResults::calc_offsets_vert(
-  const FreetypeRenderer::Params& params)
-{
+    const FreetypeRenderer::Params &params) {
   if (params.halign == "right") {
     x_offset = -right;
   } else if (params.halign == "left") {
@@ -152,8 +151,7 @@ void FreetypeRenderer::ShapeResults::calc_offsets_vert(
 
   if (params.valign == "baseline") {
     LOG(message_group::Warning, params.loc, params.documentPath,
-        "Don't use valign=\"baseline\" with vertical layouts",
-        params.valign);
+        "Don't use valign=\"baseline\" with vertical layouts", params.valign);
     y_offset = 0;
   } else if (params.valign == "center") {
     y_offset = -advance_y / 2.0;
@@ -172,8 +170,8 @@ void FreetypeRenderer::ShapeResults::calc_offsets_vert(
   }
 }
 
-hb_direction_t FreetypeRenderer::Params::detect_direction(const hb_script_t script) const
-{
+hb_direction_t
+FreetypeRenderer::Params::detect_direction(const hb_script_t script) const {
   hb_direction_t hbdirection;
 
   hbdirection = hb_direction_from_string(direction.c_str(), -1);
@@ -194,8 +192,7 @@ hb_direction_t FreetypeRenderer::Params::detect_direction(const hb_script_t scri
   return HB_DIRECTION_LTR;
 }
 
-bool FreetypeRenderer::Params::is_ignored_script(const hb_script_t script)
-{
+bool FreetypeRenderer::Params::is_ignored_script(const hb_script_t script) {
   switch (script) {
   case HB_SCRIPT_COMMON:
   case HB_SCRIPT_INHERITED:
@@ -207,8 +204,9 @@ bool FreetypeRenderer::Params::is_ignored_script(const hb_script_t script)
   }
 }
 
-hb_script_t FreetypeRenderer::Params::detect_script(hb_glyph_info_t *glyph_info, unsigned int glyph_count) const
-{
+hb_script_t
+FreetypeRenderer::Params::detect_script(hb_glyph_info_t *glyph_info,
+                                        unsigned int glyph_count) const {
   hb_script_t hbscript;
 
   hbscript = hb_script_from_string(script.c_str(), -1);
@@ -228,14 +226,15 @@ hb_script_t FreetypeRenderer::Params::detect_script(hb_glyph_info_t *glyph_info,
       }
     }
   }
-  PRINTDB("Detected script '%c%c%c%c' for %s", SCRIPT_UNTAG(hbscript) % text.c_str());
+  PRINTDB("Detected script '%c%c%c%c' for %s",
+          SCRIPT_UNTAG(hbscript) % text.c_str());
   return hbscript;
 }
 
-void FreetypeRenderer::Params::detect_properties()
-{
+void FreetypeRenderer::Params::detect_properties() {
   hb_buffer_t *hb_buf = hb_buffer_create();
-  hb_buffer_add_utf8(hb_buf, text.c_str(), strlen(text.c_str()), 0, strlen(text.c_str()));
+  hb_buffer_add_utf8(hb_buf, text.c_str(), strlen(text.c_str()), 0,
+                     strlen(text.c_str()));
 
   unsigned int glyph_count;
   hb_glyph_info_t *glyph_info = hb_buffer_get_glyph_infos(hb_buf, &glyph_count);
@@ -244,7 +243,9 @@ void FreetypeRenderer::Params::detect_properties()
   hb_buffer_destroy(hb_buf);
 
   if (!is_ignored_script(hbscript)) {
-    char script_buf[5] = { 0, };
+    char script_buf[5] = {
+        0,
+    };
     hb_tag_to_string(hb_script_to_iso15924_tag(hbscript), script_buf);
     set_script(script_buf);
   }
@@ -261,8 +262,7 @@ void FreetypeRenderer::Params::detect_properties()
   set_segments(text_segments);
 }
 
-const FontFacePtr FreetypeRenderer::Params::get_font_face() const
-{
+const FontFacePtr FreetypeRenderer::Params::get_font_face() const {
   FontCache *cache = FontCache::instance();
   if (!cache->is_init_ok()) {
     LOG(message_group::Warning, loc, documentPath,
@@ -285,23 +285,22 @@ const FontFacePtr FreetypeRenderer::Params::get_font_face() const
   return face;
 }
 
-void FreetypeRenderer::Params::set(Parameters& parameters)
-{
+void FreetypeRenderer::Params::set(Parameters &parameters) {
   // Note:
   // This populates all of the Params entries that text() populates.
   // Probably some of them are not needed by some callers.
   // However, we populate them here rather than "knowing" which
   // ones are and are not needed.
 
-  (void) parameters.valid("size", Value::Type::NUMBER);
-  (void) parameters.valid("text", Value::Type::STRING);
-  (void) parameters.valid("spacing", Value::Type::NUMBER);
-  (void) parameters.valid("font", Value::Type::STRING);
-  (void) parameters.valid("direction", Value::Type::STRING);
-  (void) parameters.valid("language", Value::Type::STRING);
-  (void) parameters.valid("script", Value::Type::STRING);
-  (void) parameters.valid("halign", Value::Type::STRING);
-  (void) parameters.valid("valign", Value::Type::STRING);
+  (void)parameters.valid("size", Value::Type::NUMBER);
+  (void)parameters.valid("text", Value::Type::STRING);
+  (void)parameters.valid("spacing", Value::Type::NUMBER);
+  (void)parameters.valid("font", Value::Type::STRING);
+  (void)parameters.valid("direction", Value::Type::STRING);
+  (void)parameters.valid("language", Value::Type::STRING);
+  (void)parameters.valid("script", Value::Type::STRING);
+  (void)parameters.valid("halign", Value::Type::STRING);
+  (void)parameters.valid("valign", Value::Type::STRING);
 
   set_fn(parameters["$fn"].toDouble());
   set_fa(parameters["$fa"].toDouble());
@@ -318,10 +317,8 @@ void FreetypeRenderer::Params::set(Parameters& parameters)
   set_valign(parameters.get("valign", "default"));
 }
 
-
 FreetypeRenderer::ShapeResults::ShapeResults(
-  const FreetypeRenderer::Params& params)
-{
+    const FreetypeRenderer::Params &params) {
   const FontFacePtr face = params.get_font_face();
   if (!face) {
     return;
@@ -330,9 +327,12 @@ FreetypeRenderer::ShapeResults::ShapeResults(
   hb_ft_font = hb_ft_font_create(face->face_, nullptr);
 
   hb_buf = hb_buffer_create();
-  hb_buffer_set_direction(hb_buf, hb_direction_from_string(params.direction.c_str(), -1));
-  hb_buffer_set_script(hb_buf, hb_script_from_string(params.script.c_str(), -1));
-  hb_buffer_set_language(hb_buf, hb_language_from_string(params.language.c_str(), -1));
+  hb_buffer_set_direction(
+      hb_buf, hb_direction_from_string(params.direction.c_str(), -1));
+  hb_buffer_set_script(hb_buf,
+                       hb_script_from_string(params.script.c_str(), -1));
+  hb_buffer_set_language(hb_buf,
+                         hb_language_from_string(params.language.c_str(), -1));
   if (FontCache::instance()->is_windows_symbol_font(face->face_)) {
     // Special handling for symbol fonts like Webdings.
     // see http://www.microsoft.com/typography/otspec/recom.htm
@@ -355,27 +355,30 @@ FreetypeRenderer::ShapeResults::ShapeResults(
           params.text.c_str());
     }
   } else {
-    hb_buffer_add_utf8(hb_buf, params.text.c_str(), strlen(params.text.c_str()), 0, strlen(params.text.c_str()));
+    hb_buffer_add_utf8(hb_buf, params.text.c_str(), strlen(params.text.c_str()),
+                       0, strlen(params.text.c_str()));
   }
 
   std::vector<hb_feature_t> features;
   features.reserve(face->features_.size());
-  std::transform(begin(face->features_), end(face->features_), std::back_inserter(features), [](const std::string& s) {
-    hb_feature_t f;
-    hb_feature_from_string(s.c_str(), s.size(), &f);
-    return f;
-  });
+  std::transform(begin(face->features_), end(face->features_),
+                 std::back_inserter(features), [](const std::string &s) {
+                   hb_feature_t f;
+                   hb_feature_from_string(s.c_str(), s.size(), &f);
+                   return f;
+                 });
   std::vector<hb_feature_t *> features_ptr;
   features.reserve(features.size());
-  std::transform(begin(features), end(features), std::back_inserter(features_ptr), [](hb_feature_t& f) {
-    return &f;
-  });
+  std::transform(begin(features), end(features),
+                 std::back_inserter(features_ptr),
+                 [](hb_feature_t &f) { return &f; });
 
   hb_shape(hb_ft_font, hb_buf, features_ptr.data()[0], features_ptr.size());
 
   unsigned int glyph_count;
   hb_glyph_info_t *glyph_info = hb_buffer_get_glyph_infos(hb_buf, &glyph_count);
-  hb_glyph_position_t *glyph_pos = hb_buffer_get_glyph_positions(hb_buf, &glyph_count);
+  hb_glyph_position_t *glyph_pos =
+      hb_buffer_get_glyph_positions(hb_buf, &glyph_count);
 
   glyph_array.reserve(glyph_count);
   for (unsigned int idx = 0; idx < glyph_count; ++idx) {
@@ -412,7 +415,7 @@ FreetypeRenderer::ShapeResults::ShapeResults(
   bottom = std::numeric_limits<double>::max();
   top = std::numeric_limits<double>::lowest();
 
-  for (const auto& glyph : glyph_array) {
+  for (const auto &glyph : glyph_array) {
     FT_BBox bbox;
     FT_Glyph_Get_CBox(glyph.get_glyph(), FT_GLYPH_BBOX_GRIDFIT, &bbox);
 
@@ -432,15 +435,11 @@ FreetypeRenderer::ShapeResults::ShapeResults(
       const double gxoff = glyph.get_x_offset();
       const double gyoff = glyph.get_y_offset();
 
-      left = std::min(left,
-                      advance_x + gxoff + bbox.xMin / scale);
-      right = std::max(right,
-                       advance_x + gxoff + bbox.xMax / scale);
+      left = std::min(left, advance_x + gxoff + bbox.xMin / scale);
+      right = std::max(right, advance_x + gxoff + bbox.xMax / scale);
 
-      top = std::max(top,
-                     advance_y + gyoff + bbox.yMax / scale);
-      bottom = std::min(bottom,
-                        advance_y + gyoff + bbox.yMin / scale);
+      top = std::max(top, advance_y + gyoff + bbox.yMax / scale);
+      bottom = std::min(bottom, advance_y + gyoff + bbox.yMin / scale);
     }
 
     advance_x += glyph.get_x_advance() * params.spacing;
@@ -451,8 +450,7 @@ FreetypeRenderer::ShapeResults::ShapeResults(
   // contributed they will flip.  If they're still reversed,
   // there was no ink.
   if (right >= left) {
-    if (HB_DIRECTION_IS_HORIZONTAL(
-          hb_buffer_get_direction(hb_buf))) {
+    if (HB_DIRECTION_IS_HORIZONTAL(hb_buffer_get_direction(hb_buf))) {
       calc_offsets_horiz(params);
     } else {
       calc_offsets_vert(params);
@@ -471,8 +469,7 @@ FreetypeRenderer::ShapeResults::ShapeResults(
   ok = true;
 }
 
-FreetypeRenderer::ShapeResults::~ShapeResults()
-{
+FreetypeRenderer::ShapeResults::~ShapeResults() {
   if (hb_buf != nullptr) {
     hb_buffer_destroy(hb_buf);
     hb_buf = nullptr;
@@ -484,8 +481,7 @@ FreetypeRenderer::ShapeResults::~ShapeResults()
 }
 
 FreetypeRenderer::FontMetrics::FontMetrics(
-  const FreetypeRenderer::Params& params)
-{
+    const FreetypeRenderer::Params &params) {
   ok = false;
 
   const FontFacePtr face = params.get_font_face();
@@ -496,21 +492,16 @@ FreetypeRenderer::FontMetrics::FontMetrics(
   // scale is the width of an em in 26.6 fractional points
   // @ 100dpi = 100/72 pixels per point
   const FT_Size_Metrics *size_metrics = &face->face_->size->metrics;
-  nominal_ascent =
-    FT_MulFix(face->face_->ascender, size_metrics->y_scale) / scale
-    * params.size;
-  nominal_descent =
-    FT_MulFix(face->face_->descender, size_metrics->y_scale) / scale
-    * params.size;
-  max_ascent =
-    FT_MulFix(face->face_->bbox.yMax, size_metrics->y_scale) / scale
-    * params.size;
-  max_descent =
-    FT_MulFix(face->face_->bbox.yMin, size_metrics->y_scale) / scale
-    * params.size;
-  interline =
-    FT_MulFix(face->face_->height, size_metrics->y_scale) / scale
-    * params.size;
+  nominal_ascent = FT_MulFix(face->face_->ascender, size_metrics->y_scale) /
+                   scale * params.size;
+  nominal_descent = FT_MulFix(face->face_->descender, size_metrics->y_scale) /
+                    scale * params.size;
+  max_ascent = FT_MulFix(face->face_->bbox.yMax, size_metrics->y_scale) /
+               scale * params.size;
+  max_descent = FT_MulFix(face->face_->bbox.yMin, size_metrics->y_scale) /
+                scale * params.size;
+  interline = FT_MulFix(face->face_->height, size_metrics->y_scale) / scale *
+              params.size;
   family_name = face->face_->family_name;
   style_name = face->face_->style_name;
 
@@ -518,8 +509,7 @@ FreetypeRenderer::FontMetrics::FontMetrics(
 }
 
 FreetypeRenderer::TextMetrics::TextMetrics(
-  const FreetypeRenderer::Params& params)
-{
+    const FreetypeRenderer::Params &params) {
   ok = false;
 
   ShapeResults sr(params);
@@ -561,8 +551,8 @@ FreetypeRenderer::TextMetrics::TextMetrics(
   ok = true;
 }
 
-std::vector<std::shared_ptr<const Polygon2d>> FreetypeRenderer::render(const FreetypeRenderer::Params& params) const
-{
+std::vector<std::shared_ptr<const Polygon2d>>
+FreetypeRenderer::render(const FreetypeRenderer::Params &params) const {
   ShapeResults sr(params);
 
   if (!sr.ok) {
@@ -570,12 +560,12 @@ std::vector<std::shared_ptr<const Polygon2d>> FreetypeRenderer::render(const Fre
   }
 
   DrawingCallback callback(params.segments, params.size);
-  for (const auto& glyph : sr.glyph_array) {
+  for (const auto &glyph : sr.glyph_array) {
     callback.start_glyph();
-    callback.set_glyph_offset(
-      sr.x_offset + glyph.get_x_offset(),
-      sr.y_offset + glyph.get_y_offset());
-    FT_Outline outline = reinterpret_cast<FT_OutlineGlyph>(glyph.get_glyph())->outline;
+    callback.set_glyph_offset(sr.x_offset + glyph.get_x_offset(),
+                              sr.y_offset + glyph.get_y_offset());
+    FT_Outline outline =
+        reinterpret_cast<FT_OutlineGlyph>(glyph.get_glyph())->outline;
     FT_Outline_Decompose(&outline, &funcs, &callback);
 
     double adv_x = glyph.get_x_advance() * params.spacing;
@@ -584,8 +574,10 @@ std::vector<std::shared_ptr<const Polygon2d>> FreetypeRenderer::render(const Fre
     callback.finish_glyph();
   }
 
-  // FIXME: The returned Polygon2d currently contains only outlines with the 'positive' flag set to true,
-  // and where the winding order determines if the outlines should be interpreted as polygons or holes.
-  // We have to rely on any downstream processing to be aware of the winding order, and ignore the 'positive' flag.
+  // FIXME: The returned Polygon2d currently contains only outlines with the
+  // 'positive' flag set to true, and where the winding order determines if the
+  // outlines should be interpreted as polygons or holes. We have to rely on any
+  // downstream processing to be aware of the winding order, and ignore the
+  // 'positive' flag.
   return callback.get_result();
 }
diff --git a/src/core/FreetypeRenderer.h b/src/core/FreetypeRenderer.h
index dc6a60af4..8039db07e 100644
--- a/src/core/FreetypeRenderer.h
+++ b/src/core/FreetypeRenderer.h
@@ -26,88 +26,61 @@
 #pragma once
 
 #include <memory>
+#include <ostream>
 #include <string>
 #include <vector>
-#include <ostream>
 
+#include "FontCache.h"
 #include "core/AST.h"
 #include "core/Parameters.h"
-#include "FontCache.h"
-#include <hb.h>
 #include <ft2build.h>
+#include <hb.h>
 #include FT_FREETYPE_H
 #include FT_GLYPH_H
 
-class FreetypeRenderer
-{
-public:
-  class Params
-  {
+class FreetypeRenderer {
 public:
-    void set_size(double size) {
-      this->size = size;
-    }
-    void set_spacing(double spacing) {
-      this->spacing = spacing;
-    }
-    void set_fn(double fn) {
-      this->fn = fn;
-    }
-    void set_fa(double fa) {
-      this->fa = fa;
-    }
-    void set_fs(double fs) {
-      this->fs = fs;
-    }
-    void set_segments(unsigned int segments) {
-      this->segments = segments;
-    }
-    void set_text(const std::string& text) {
-      this->text = text;
-    }
-    void set_font(const std::string& font) {
-      this->font = font;
-    }
-    void set_direction(const std::string& direction) {
+  class Params {
+  public:
+    void set_size(double size) { this->size = size; }
+    void set_spacing(double spacing) { this->spacing = spacing; }
+    void set_fn(double fn) { this->fn = fn; }
+    void set_fa(double fa) { this->fa = fa; }
+    void set_fs(double fs) { this->fs = fs; }
+    void set_segments(unsigned int segments) { this->segments = segments; }
+    void set_text(const std::string &text) { this->text = text; }
+    void set_font(const std::string &font) { this->font = font; }
+    void set_direction(const std::string &direction) {
       this->direction = direction;
     }
-    void set_language(const std::string& language) {
+    void set_language(const std::string &language) {
       this->language = language;
     }
-    void set_script(const std::string& script) {
-      this->script = script;
-    }
-    void set_halign(const std::string& halign) {
-      this->halign = halign;
-    }
-    void set_valign(const std::string& valign) {
-      this->valign = valign;
-    }
-    void set_loc(const Location& loc) {
-      this->loc = loc;
-    }
-    void set_documentPath(const std::string& path) {
+    void set_script(const std::string &script) { this->script = script; }
+    void set_halign(const std::string &halign) { this->halign = halign; }
+    void set_valign(const std::string &valign) { this->valign = valign; }
+    void set_loc(const Location &loc) { this->loc = loc; }
+    void set_documentPath(const std::string &path) {
       this->documentPath = path;
     }
-    void set(Parameters& parameters);
+    void set(Parameters &parameters);
     [[nodiscard]] const FontFacePtr get_font_face() const;
     void detect_properties();
-    friend std::ostream& operator<<(std::ostream& stream, const FreetypeRenderer::Params& params) {
-      return stream
-             << "text = \"" << params.text
-             << "\", size = " << params.size
-             << ", spacing = " << params.spacing
-             << ", font = \"" << params.font
-             << "\", direction = \"" << params.direction
-             << "\", language = \"" << params.language
-             << (params.script.empty() ? "" : "\", script = \"") << params.script
-             << "\", halign = \"" << params.halign
-             << "\", valign = \"" << params.valign
-             << "\", $fn = " << params.fn
-             << ", $fa = " << params.fa
-             << ", $fs = " << params.fs;
+    friend std::ostream &operator<<(std::ostream &stream,
+                                    const FreetypeRenderer::Params &params) {
+      return stream << "text = \"" << params.text
+                    << "\", size = " << params.size
+                    << ", spacing = " << params.spacing << ", font = \""
+                    << params.font << "\", direction = \"" << params.direction
+                    << "\", language = \"" << params.language
+                    << (params.script.empty() ? "" : "\", script = \"")
+                    << params.script << "\", halign = \"" << params.halign
+                    << "\", valign = \"" << params.valign
+                    << "\", $fn = " << params.fn << ", $fa = " << params.fa
+                    << ", $fs = " << params.fs;
     }
-private:
+
+  private:
     double size, spacing, fn, fa, fs;
     unsigned int segments;
     std::string text, font, direction, language, script, halign, valign;
@@ -116,14 +89,14 @@ private:
     static bool is_ignored_script(const hb_script_t script);
     hb_script_t detect_script(hb_glyph_info_t *glyph_info,
                               unsigned int glyph_count) const;
-    [[nodiscard]] hb_direction_t detect_direction(const hb_script_t script) const;
+    [[nodiscard]] hb_direction_t
+    detect_direction(const hb_script_t script) const;
 
     friend class FreetypeRenderer;
   };
 
-  class TextMetrics
-  {
-public:
+  class TextMetrics {
+  public:
     bool ok; // true if object is valid
     // The values here are all at their final size; they have been
     // descaled down from the 1e5 size used for Freetype, and rescaled
@@ -138,11 +111,10 @@ public:
     double descent;
     double x_offset;
     double y_offset;
-    TextMetrics(const FreetypeRenderer::Params& params);
+    TextMetrics(const FreetypeRenderer::Params &params);
   };
-  class FontMetrics
-  {
-public:
+  class FontMetrics {
+  public:
     bool ok; // true if object is valid
     // The values here are all at their final size; they have been
     // descaled down from the 1e5 size used for Freetype, and rescaled
@@ -154,12 +126,14 @@ public:
     double interline;
     std::string family_name;
     std::string style_name;
-    FontMetrics(const FreetypeRenderer::Params& params);
+    FontMetrics(const FreetypeRenderer::Params &params);
   };
   FreetypeRenderer();
   virtual ~FreetypeRenderer() = default;
 
-  [[nodiscard]] std::vector<std::shared_ptr<const class Polygon2d>> render(const FreetypeRenderer::Params& params) const;
+  [[nodiscard]] std::vector<std::shared_ptr<const class Polygon2d>>
+  render(const FreetypeRenderer::Params &params) const;
+
 private:
   const static double scale;
   FT_Outline_Funcs funcs;
@@ -168,26 +142,34 @@ private:
   // that it is freed when the GlyphData is destroyed.
   // However, glyph_pos points to data that the caller must ensure
   // remains valid until the GlyphData is destroyed.
-  class GlyphData
-  {
-public:
-    GlyphData(FT_Glyph glyph, unsigned int idx, hb_glyph_position_t *glyph_pos) : glyph(glyph), idx(idx), glyph_pos(glyph_pos) {}
+  class GlyphData {
+  public:
+    GlyphData(FT_Glyph glyph, unsigned int idx, hb_glyph_position_t *glyph_pos)
+        : glyph(glyph), idx(idx), glyph_pos(glyph_pos) {}
     [[nodiscard]] unsigned int get_idx() const { return idx; }
     [[nodiscard]] FT_Glyph get_glyph() const { return glyph; }
-    [[nodiscard]] double get_x_offset() const { return glyph_pos->x_offset / scale; }
-    [[nodiscard]] double get_y_offset() const { return glyph_pos->y_offset / scale; }
-    [[nodiscard]] double get_x_advance() const { return glyph_pos->x_advance / scale; }
-    [[nodiscard]] double get_y_advance() const { return glyph_pos->y_advance / scale; }
+    [[nodiscard]] double get_x_offset() const {
+      return glyph_pos->x_offset / scale;
+    }
+    [[nodiscard]] double get_y_offset() const {
+      return glyph_pos->y_offset / scale;
+    }
+    [[nodiscard]] double get_x_advance() const {
+      return glyph_pos->x_advance / scale;
+    }
+    [[nodiscard]] double get_y_advance() const {
+      return glyph_pos->y_advance / scale;
+    }
     ~GlyphData() { FT_Done_Glyph(glyph); }
-private:
+
+  private:
     FT_Glyph glyph;
     unsigned int idx;
     hb_glyph_position_t *glyph_pos;
   };
 
-  class ShapeResults
-  {
-public:
+  class ShapeResults {
+  public:
     bool ok{false}; // true if object is valid
     // The values here are all in fractions of the specified size.
     // They have been downscaled from the 1e+5 unit size used for
@@ -204,17 +186,20 @@ public:
     double advance_y{0.0};
     double ascent{0.0};
     double descent{0.0};
-    ShapeResults(const FreetypeRenderer::Params& params);
+    ShapeResults(const FreetypeRenderer::Params &params);
     virtual ~ShapeResults();
-private:
-    void calc_offsets_horiz(const FreetypeRenderer::Params& params);
-    void calc_offsets_vert(const FreetypeRenderer::Params& params);
+
+  private:
+    void calc_offsets_horiz(const FreetypeRenderer::Params &params);
+    void calc_offsets_vert(const FreetypeRenderer::Params &params);
     hb_font_t *hb_ft_font{nullptr};
     hb_buffer_t *hb_buf{nullptr};
   };
 
   static int outline_move_to_func(const FT_Vector *to, void *user);
   static int outline_line_to_func(const FT_Vector *to, void *user);
-  static int outline_conic_to_func(const FT_Vector *c1, const FT_Vector *to, void *user);
-  static int outline_cubic_to_func(const FT_Vector *c1, const FT_Vector *c2, const FT_Vector *to, void *user);
+  static int outline_conic_to_func(const FT_Vector *c1, const FT_Vector *to,
+                                   void *user);
+  static int outline_cubic_to_func(const FT_Vector *c1, const FT_Vector *c2,
+                                   const FT_Vector *to, void *user);
 };
diff --git a/src/core/FunctionType.cc b/src/core/FunctionType.cc
index 71724e652..af4ca2530 100644
--- a/src/core/FunctionType.cc
+++ b/src/core/FunctionType.cc
@@ -1,33 +1,32 @@
 #include "core/FunctionType.h"
 
-#include <ostream>
-#include "core/Value.h"
 #include "core/Expression.h"
+#include "core/Value.h"
+#include <ostream>
 
-Value FunctionType::operator==(const FunctionType& other) const {
+Value FunctionType::operator==(const FunctionType &other) const {
   return this == &other;
 }
-Value FunctionType::operator!=(const FunctionType& other) const {
+Value FunctionType::operator!=(const FunctionType &other) const {
   return this != &other;
 }
-Value FunctionType::operator<(const FunctionType& /*other*/) const {
+Value FunctionType::operator<(const FunctionType & /*other*/) const {
   return Value::undef("operation undefined (function < function)");
 }
-Value FunctionType::operator>(const FunctionType& /*other*/) const {
+Value FunctionType::operator>(const FunctionType & /*other*/) const {
   return Value::undef("operation undefined (function > function)");
 }
-Value FunctionType::operator<=(const FunctionType& /*other*/) const {
+Value FunctionType::operator<=(const FunctionType & /*other*/) const {
   return Value::undef("operation undefined (function <= function)");
 }
-Value FunctionType::operator>=(const FunctionType& /*other*/) const {
+Value FunctionType::operator>=(const FunctionType & /*other*/) const {
   return Value::undef("operation undefined (function >= function)");
 }
 
-std::ostream& operator<<(std::ostream& stream, const FunctionType& f)
-{
+std::ostream &operator<<(std::ostream &stream, const FunctionType &f) {
   stream << "function(";
   bool first = true;
-  for (const auto& parameter : *(f.getParameters())) {
+  for (const auto &parameter : *(f.getParameters())) {
     stream << (first ? "" : ", ") << parameter->getName();
     if (parameter->getExpr()) {
       stream << " = " << *parameter->getExpr();
diff --git a/src/core/FunctionType.h b/src/core/FunctionType.h
index bed08fa94..ae871992f 100644
--- a/src/core/FunctionType.h
+++ b/src/core/FunctionType.h
@@ -1,8 +1,8 @@
 #pragma once
 
-#include <utility>
 #include <memory>
 #include <ostream>
+#include <utility>
 
 #include "core/Assignment.h"
 
@@ -10,25 +10,34 @@ class Context;
 class Expression;
 class Value;
 
-class FunctionType
-{
+class FunctionType {
 public:
-  FunctionType(std::shared_ptr<const Context> context, std::shared_ptr<Expression> expr, std::shared_ptr<AssignmentList> parameters)
-    : context(std::move(context)), expr(std::move(expr)), parameters(std::move(parameters)) { }
-  Value operator==(const FunctionType& other) const;
-  Value operator!=(const FunctionType& other) const;
-  Value operator<(const FunctionType& other) const;
-  Value operator>(const FunctionType& other) const;
-  Value operator<=(const FunctionType& other) const;
-  Value operator>=(const FunctionType& other) const;
+  FunctionType(std::shared_ptr<const Context> context,
+               std::shared_ptr<Expression> expr,
+               std::shared_ptr<AssignmentList> parameters)
+      : context(std::move(context)), expr(std::move(expr)),
+        parameters(std::move(parameters)) {}
+  Value operator==(const FunctionType &other) const;
+  Value operator!=(const FunctionType &other) const;
+  Value operator<(const FunctionType &other) const;
+  Value operator>(const FunctionType &other) const;
+  Value operator<=(const FunctionType &other) const;
+  Value operator>=(const FunctionType &other) const;
+
+  [[nodiscard]] const std::shared_ptr<const Context> &getContext() const {
+    return context;
+  }
+  [[nodiscard]] const std::shared_ptr<Expression> &getExpr() const {
+    return expr;
+  }
+  [[nodiscard]] const std::shared_ptr<AssignmentList> &getParameters() const {
+    return parameters;
+  }
 
-  [[nodiscard]] const std::shared_ptr<const Context>& getContext() const { return context; }
-  [[nodiscard]] const std::shared_ptr<Expression>& getExpr() const { return expr; }
-  [[nodiscard]] const std::shared_ptr<AssignmentList>& getParameters() const { return parameters; }
 private:
   std::shared_ptr<const Context> context;
   std::shared_ptr<Expression> expr;
   std::shared_ptr<AssignmentList> parameters;
 };
 
-std::ostream& operator<<(std::ostream& stream, const FunctionType& f);
+std::ostream &operator<<(std::ostream &stream, const FunctionType &f);
diff --git a/src/core/GroupModule.cc b/src/core/GroupModule.cc
index 91f261abe..133bd774c 100644
--- a/src/core/GroupModule.cc
+++ b/src/core/GroupModule.cc
@@ -24,24 +24,25 @@
  *
  */
 
-#include <utility>
-#include <memory>
-#include "core/ModuleInstantiation.h"
-#include "core/node.h"
 #include "core/Builtins.h"
 #include "core/Children.h"
+#include "core/ModuleInstantiation.h"
 #include "core/Parameters.h"
+#include "core/node.h"
+#include <memory>
+#include <utility>
 
-std::shared_ptr<AbstractNode> builtin_group(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {});
+std::shared_ptr<AbstractNode> builtin_group(const ModuleInstantiation *inst,
+                                            Arguments arguments,
+                                            const Children &children) {
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {});
   return children.instantiate(std::make_shared<GroupNode>(inst));
 }
 
-void register_builtin_group()
-{
+void register_builtin_group() {
   Builtins::init("group", new BuiltinModule(builtin_group),
-  {
-    "group",
-  });
+                 {
+                     "group",
+                 });
 }
diff --git a/src/core/ImportNode.cc b/src/core/ImportNode.cc
index 7ea933038..9002129de 100644
--- a/src/core/ImportNode.cc
+++ b/src/core/ImportNode.cc
@@ -29,65 +29,80 @@
 #include "geometry/Geometry.h"
 #include "io/import.h"
 
-#include "core/module.h"
 #include "core/ModuleInstantiation.h"
+#include "core/module.h"
 #include "geometry/PolySet.h"
 #ifdef ENABLE_CGAL
 #include "geometry/cgal/CGALNefGeometry.h"
 #endif
-#include "geometry/Polygon2d.h"
+#include "Feature.h"
 #include "core/Builtins.h"
 #include "core/Children.h"
-#include "io/DxfData.h"
 #include "core/Parameters.h"
-#include "utils/printutils.h"
-#include "io/fileutils.h"
-#include "Feature.h"
+#include "geometry/Polygon2d.h"
 #include "handle_dep.h"
+#include "io/DxfData.h"
+#include "io/fileutils.h"
+#include "utils/printutils.h"
+#include <boost/algorithm/string.hpp>
 #include <cmath>
+#include <filesystem>
 #include <ios>
-#include <utility>
 #include <memory>
-#include <sys/types.h>
 #include <sstream>
-#include <boost/algorithm/string.hpp>
-#include <filesystem>
+#include <sys/types.h>
+#include <utility>
 namespace fs = std::filesystem;
 #include <boost/assign/std/vector.hpp>
 using namespace boost::assign; // bring 'operator+=()' into scope
 
+static std::shared_ptr<AbstractNode> do_import(const ModuleInstantiation *inst,
+                                               Arguments arguments,
+                                               ImportType type) {
+  Parameters parameters = Parameters::parse(
+      std::move(arguments), inst->location(),
+      {"file", "layer", "convexity", "origin", "scale"},
+      {"width", "height", "filename", "layername", "center", "dpi", "id"});
 
-static std::shared_ptr<AbstractNode> do_import(const ModuleInstantiation *inst, Arguments arguments, ImportType type)
-{
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(),
-                                            {"file", "layer", "convexity", "origin", "scale"},
-                                            {"width", "height", "filename", "layername", "center", "dpi", "id"}
-                                            );
-
-  const auto& v = parameters["file"];
+  const auto &v = parameters["file"];
   std::string filename;
   if (v.isDefined()) {
-    filename = lookup_file(v.isUndefined() ? "" : v.toString(), inst->location().filePath().parent_path().string(), parameters.documentRoot());
+    filename = lookup_file(v.isUndefined() ? "" : v.toString(),
+                           inst->location().filePath().parent_path().string(),
+                           parameters.documentRoot());
   } else {
-    const auto& filename_val = parameters["filename"];
+    const auto &filename_val = parameters["filename"];
     if (!filename_val.isUndefined()) {
-      LOG(message_group::Deprecated, "filename= is deprecated. Please use file=");
+      LOG(message_group::Deprecated,
+          "filename= is deprecated. Please use file=");
     }
-    filename = lookup_file(filename_val.isUndefined() ? "" : filename_val.toString(), inst->location().filePath().parent_path().string(), parameters.documentRoot());
+    filename =
+        lookup_file(filename_val.isUndefined() ? "" : filename_val.toString(),
+                    inst->location().filePath().parent_path().string(),
+                    parameters.documentRoot());
   }
-  if (!filename.empty()) handle_dep(filename);
+  if (!filename.empty())
+    handle_dep(filename);
   ImportType actualtype = type;
   if (actualtype == ImportType::UNKNOWN) {
     std::string extraw = fs::path(filename).extension().generic_string();
     std::string ext = boost::algorithm::to_lower_copy(extraw);
-    if (ext == ".stl") actualtype = ImportType::STL;
-    else if (ext == ".off") actualtype = ImportType::OFF;
-    else if (ext == ".dxf") actualtype = ImportType::DXF;
-    else if (ext == ".nef3") actualtype = ImportType::NEF3;
-    else if (ext == ".3mf") actualtype = ImportType::_3MF;
-    else if (ext == ".amf") actualtype = ImportType::AMF;
-    else if (ext == ".svg") actualtype = ImportType::SVG;
-    else if (ext == ".obj") actualtype = ImportType::OBJ;
+    if (ext == ".stl")
+      actualtype = ImportType::STL;
+    else if (ext == ".off")
+      actualtype = ImportType::OFF;
+    else if (ext == ".dxf")
+      actualtype = ImportType::DXF;
+    else if (ext == ".nef3")
+      actualtype = ImportType::NEF3;
+    else if (ext == ".3mf")
+      actualtype = ImportType::_3MF;
+    else if (ext == ".amf")
+      actualtype = ImportType::AMF;
+    else if (ext == ".svg")
+      actualtype = ImportType::SVG;
+    else if (ext == ".obj")
+      actualtype = ImportType::OBJ;
   }
 
   auto node = std::make_shared<ImportNode>(inst, actualtype);
@@ -97,48 +112,56 @@ static std::shared_ptr<AbstractNode> do_import(const ModuleInstantiation *inst,
   node->fa = parameters["$fa"].toDouble();
 
   node->filename = filename;
-  const auto& layerval = parameters["layer"];
+  const auto &layerval = parameters["layer"];
   if (layerval.isDefined()) {
     node->layer = layerval.toString();
   } else {
-    const auto& layername = parameters["layername"];
+    const auto &layername = parameters["layername"];
     if (layername.isDefined()) {
-      LOG(message_group::Deprecated, "layername= is deprecated. Please use layer=");
+      LOG(message_group::Deprecated,
+          "layername= is deprecated. Please use layer=");
       node->layer = layername.toString();
     }
   }
-  const auto& idval = parameters["id"];
+  const auto &idval = parameters["id"];
   if (idval.isDefined()) {
     node->id = idval.toString();
   }
   node->convexity = (int)parameters["convexity"].toDouble();
 
-  if (node->convexity <= 0) node->convexity = 1;
+  if (node->convexity <= 0)
+    node->convexity = 1;
 
-  const auto& origin = parameters["origin"];
+  const auto &origin = parameters["origin"];
   node->origin_x = node->origin_y = 0;
   bool originOk = origin.getVec2(node->origin_x, node->origin_y);
   originOk &= std::isfinite(node->origin_x) && std::isfinite(node->origin_y);
   if (origin.isDefined() && !originOk) {
-    LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Unable to convert import(..., origin=%1$s) parameter to vec2", origin.toEchoStringNoThrow());
+    LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+        "Unable to convert import(..., origin=%1$s) parameter to vec2",
+        origin.toEchoStringNoThrow());
   }
 
-  const auto& center = parameters["center"];
+  const auto &center = parameters["center"];
   node->center = center.type() == Value::Type::BOOL ? center.toBool() : false;
 
   node->scale = parameters["scale"].toDouble();
-  if (node->scale <= 0) node->scale = 1;
+  if (node->scale <= 0)
+    node->scale = 1;
 
   node->dpi = ImportNode::SVG_DEFAULT_DPI;
-  const auto& dpi = parameters["dpi"];
+  const auto &dpi = parameters["dpi"];
   if (dpi.type() == Value::Type::NUMBER) {
     double val = dpi.toDouble();
     if (val < 0.001) {
-      std::string filePath = fs_uncomplete(inst->location().filePath(), parameters.documentRoot()).generic_string();
+      std::string filePath =
+          fs_uncomplete(inst->location().filePath(), parameters.documentRoot())
+              .generic_string();
       LOG(message_group::Warning,
-          "Invalid dpi value giving, using default of %1$f dpi. Value must be positive and >= 0.001, file %2$s, import() at line %3$d",
-          origin.toEchoStringNoThrow(), filePath, filePath, inst->location().firstLine()
-          );
+          "Invalid dpi value giving, using default of %1$f dpi. Value must be "
+          "positive and >= 0.001, file %2$s, import() at line %3$d",
+          origin.toEchoStringNoThrow(), filePath, filePath,
+          inst->location().firstLine());
     } else {
       node->dpi = val;
     }
@@ -150,8 +173,10 @@ static std::shared_ptr<AbstractNode> do_import(const ModuleInstantiation *inst,
   return node;
 }
 
-static std::shared_ptr<AbstractNode> builtin_import(const ModuleInstantiation *inst, Arguments arguments)
-{ return do_import(inst, std::move(arguments), ImportType::UNKNOWN); }
+static std::shared_ptr<AbstractNode>
+builtin_import(const ModuleInstantiation *inst, Arguments arguments) {
+  return do_import(inst, std::move(arguments), ImportType::UNKNOWN);
+}
 
 template <typename T>
 static std::unique_ptr<T> optionally_center(std::unique_ptr<T> g, bool center) {
@@ -159,7 +184,7 @@ static std::unique_ptr<T> optionally_center(std::unique_ptr<T> g, bool center) {
     auto bbox = g->getBoundingBox();
     auto center = bbox.center();
 
-    if constexpr (std::is_same_v<T, Polygon2d> ) {
+    if constexpr (std::is_same_v<T, Polygon2d>) {
       auto mat = Transform2d::Identity();
       auto translate = mat.translation();
 
@@ -185,8 +210,7 @@ static std::unique_ptr<T> optionally_center(std::unique_ptr<T> g, bool center) {
 /*!
    Will return an empty geometry if the import failed, but not nullptr
  */
-std::unique_ptr<const Geometry> ImportNode::createGeometry() const
-{
+std::unique_ptr<const Geometry> ImportNode::createGeometry() const {
   std::unique_ptr<Geometry> g;
   auto loc = this->modinst->location();
 
@@ -212,11 +236,14 @@ std::unique_ptr<const Geometry> ImportNode::createGeometry() const
     break;
   }
   case ImportType::SVG: {
-    g = import_svg(this->fn, this->fs, this->fa, this->filename, this->id, this->layer, this->dpi, this->center, loc);
+    g = import_svg(this->fn, this->fs, this->fa, this->filename, this->id,
+                   this->layer, this->dpi, this->center, loc);
     break;
   }
   case ImportType::DXF: {
-    DxfData dd(this->fn, this->fs, this->fa, this->filename, this->layer.value_or(""), this->origin_x, this->origin_y, this->scale);
+    DxfData dd(this->fn, this->fs, this->fa, this->filename,
+               this->layer.value_or(""), this->origin_x, this->origin_y,
+               this->scale);
     g = optionally_center(dd.toPolygon2d(), this->center);
     break;
   }
@@ -227,7 +254,10 @@ std::unique_ptr<const Geometry> ImportNode::createGeometry() const
   }
 #endif
   default:
-    LOG(message_group::Error, "Unsupported file format while trying to import file '%1$s', import() at line %2$d", this->filename, loc.firstLine());
+    LOG(message_group::Error,
+        "Unsupported file format while trying to import file '%1$s', import() "
+        "at line %2$d",
+        this->filename, loc.firstLine());
     g = PolySet::createEmpty();
   }
 
@@ -235,8 +265,7 @@ std::unique_ptr<const Geometry> ImportNode::createGeometry() const
   return g;
 }
 
-std::string ImportNode::toString() const
-{
+std::string ImportNode::toString() const {
   std::ostringstream stream;
   fs::path path((std::string)this->filename);
 
@@ -248,29 +277,25 @@ std::string ImportNode::toString() const
   if (this->layer) {
     stream << ", layer = " << QuotedString(this->layer.get());
   }
-  stream << ", origin = [" << std::dec << this->origin_x << ", " << this->origin_y << "]";
+  stream << ", origin = [" << std::dec << this->origin_x << ", "
+         << this->origin_y << "]";
   if (this->type == ImportType::SVG) {
     stream << ", dpi = " << this->dpi;
   }
   stream << ", scale = " << this->scale
          << ", center = " << (this->center ? "true" : "false")
-         << ", convexity = " << this->convexity
-         << ", $fn = " << this->fn << ", $fa = " << this->fa << ", $fs = " << this->fs
-         << ", timestamp = " << fs_timestamp(path)
-         << ")";
+         << ", convexity = " << this->convexity << ", $fn = " << this->fn
+         << ", $fa = " << this->fa << ", $fs = " << this->fs
+         << ", timestamp = " << fs_timestamp(path) << ")";
 
   return stream.str();
 }
 
-std::string ImportNode::name() const
-{
-  return "import";
-}
+std::string ImportNode::name() const { return "import"; }
 
-void register_builtin_import()
-{
+void register_builtin_import() {
   Builtins::init("import", new BuiltinModule(builtin_import),
-  {
-    "import(string, [number, [number]])",
-  });
+                 {
+                     "import(string, [number, [number]])",
+                 });
 }
diff --git a/src/core/ImportNode.h b/src/core/ImportNode.h
index 1e2caf0f3..97efbe4b5 100644
--- a/src/core/ImportNode.h
+++ b/src/core/ImportNode.h
@@ -1,12 +1,12 @@
 #pragma once
 
+#include <boost/optional.hpp>
 #include <memory>
 #include <string>
-#include <boost/optional.hpp>
 
-#include "core/node.h"
 #include "core/ModuleInstantiation.h"
 #include "core/Value.h"
+#include "core/node.h"
 
 enum class ImportType {
   UNKNOWN,
@@ -20,13 +20,13 @@ enum class ImportType {
   OBJ,
 };
 
-class ImportNode : public LeafNode
-{
+class ImportNode : public LeafNode {
 public:
   constexpr static double SVG_DEFAULT_DPI = 72.0;
 
   VISITABLE();
-  ImportNode(const ModuleInstantiation *mi, ImportType type) : LeafNode(mi), type(type) { }
+  ImportNode(const ModuleInstantiation *mi, ImportType type)
+      : LeafNode(mi), type(type) {}
   std::string toString() const override;
   std::string name() const override;
 
diff --git a/src/core/IndicatorData.h b/src/core/IndicatorData.h
index d8926892a..84c057ce1 100644
--- a/src/core/IndicatorData.h
+++ b/src/core/IndicatorData.h
@@ -2,15 +2,12 @@
 
 #include <string>
 #include <utility>
-#include <utility>
 
-struct IndicatorData
-{
+struct IndicatorData {
   IndicatorData(int firstLine, int firstCol, int lastLine, int lastCol,
                 std::string path)
-    : first_line(firstLine), first_col(firstCol), last_line(lastLine),
-    last_col(lastCol), path(std::move(path)) {
-  }
+      : first_line(firstLine), first_col(firstCol), last_line(lastLine),
+        last_col(lastCol), path(std::move(path)) {}
 
   int first_line;
   int first_col;
diff --git a/src/core/LinearExtrudeNode.cc b/src/core/LinearExtrudeNode.cc
index 2a58b7710..487ad1476 100644
--- a/src/core/LinearExtrudeNode.cc
+++ b/src/core/LinearExtrudeNode.cc
@@ -26,32 +26,34 @@
 
 #include "core/LinearExtrudeNode.h"
 
-#include "core/module.h"
-#include "core/ModuleInstantiation.h"
+#include "core/Builtins.h"
 #include "core/Children.h"
+#include "core/ModuleInstantiation.h"
 #include "core/Parameters.h"
-#include "utils/printutils.h"
-#include "io/fileutils.h"
-#include "core/Builtins.h"
+#include "core/module.h"
 #include "handle_dep.h"
+#include "io/fileutils.h"
+#include "utils/printutils.h"
 
-#include <utility>
-#include <memory>
+#include <boost/assign/std/vector.hpp>
 #include <cmath>
+#include <memory>
 #include <sstream>
-#include <boost/assign/std/vector.hpp>
+#include <utility>
 using namespace boost::assign; // bring 'operator+=()' into scope
 
 #include <filesystem>
 
 namespace {
-std::shared_ptr<AbstractNode> builtin_linear_extrude(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+std::shared_ptr<AbstractNode>
+builtin_linear_extrude(const ModuleInstantiation *inst, Arguments arguments,
+                       const Children &children) {
   auto node = std::make_shared<LinearExtrudeNode>(inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(),
-                                            {"height", "v", "scale", "center", "twist", "slices", "segments"},
-                                            {"convexity", "h"});
+  Parameters parameters = Parameters::parse(
+      std::move(arguments), inst->location(),
+      {"height", "v", "scale", "center", "twist", "slices", "segments"},
+      {"convexity", "h"});
   parameters.set_caller("linear_extrude");
 
   node->fn = parameters["$fn"].toDouble();
@@ -61,12 +63,13 @@ std::shared_ptr<AbstractNode> builtin_linear_extrude(const ModuleInstantiation *
   double height = 100.0;
 
   if (parameters["v"].isDefined()) {
-    if (!parameters["v"].getVec3(node->height[0], node->height[1], node->height[2])) {
+    if (!parameters["v"].getVec3(node->height[0], node->height[1],
+                                 node->height[2])) {
       LOG(message_group::Error, "v when specified should be a 3d vector.");
     }
     height = 1.0;
   }
-  const Value& heightValue = parameters[{"height", "h"}];
+  const Value &heightValue = parameters[{"height", "h"}];
   if (heightValue.isDefined()) {
     if (!heightValue.getFiniteDouble(height)) {
       LOG(message_group::Error, "height when specified should be a number.");
@@ -82,19 +85,28 @@ std::shared_ptr<AbstractNode> builtin_linear_extrude(const ModuleInstantiation *
   bool scaleOK = parameters["scale"].getFiniteDouble(node->scale_x);
   scaleOK &= parameters["scale"].getFiniteDouble(node->scale_y);
   scaleOK |= parameters["scale"].getVec2(node->scale_x, node->scale_y, true);
-  if ((parameters["scale"].isDefined()) && (!scaleOK || !std::isfinite(node->scale_x) || !std::isfinite(node->scale_y))) {
-    LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "linear_extrude(..., scale=%1$s) could not be converted", parameters["scale"].toEchoStringNoThrow());
+  if ((parameters["scale"].isDefined()) &&
+      (!scaleOK || !std::isfinite(node->scale_x) ||
+       !std::isfinite(node->scale_y))) {
+    LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+        "linear_extrude(..., scale=%1$s) could not be converted",
+        parameters["scale"].toEchoStringNoThrow());
   }
 
-  if (parameters["center"].type() == Value::Type::BOOL) node->center = parameters["center"].toBool();
+  if (parameters["center"].type() == Value::Type::BOOL)
+    node->center = parameters["center"].toBool();
 
-  if (node->height[2] <= 0) node->height[2] = 0;
+  if (node->height[2] <= 0)
+    node->height[2] = 0;
 
-  if (node->scale_x < 0) node->scale_x = 0;
-  if (node->scale_y < 0) node->scale_y = 0;
+  if (node->scale_x < 0)
+    node->scale_x = 0;
+  if (node->scale_y < 0)
+    node->scale_y = 0;
 
   node->has_slices = parameters.validate_integral("slices", node->slices, 1u);
-  node->has_segments = parameters.validate_integral("segments", node->segments, 0u);
+  node->has_segments =
+      parameters.validate_integral("segments", node->segments, 0u);
 
   node->twist = 0.0;
   parameters["twist"].getFiniteDouble(node->twist);
@@ -109,8 +121,7 @@ std::shared_ptr<AbstractNode> builtin_linear_extrude(const ModuleInstantiation *
 
 } // namespace
 
-std::string LinearExtrudeNode::toString() const
-{
+std::string LinearExtrudeNode::toString() const {
   std::ostringstream stream;
 
   stream << this->name() << "(";
@@ -142,7 +153,8 @@ std::string LinearExtrudeNode::toString() const
   }
 
   if (!(this->has_slices && this->has_segments)) {
-    stream << ", $fn = " << this->fn << ", $fa = " << this->fa << ", $fs = " << this->fs;
+    stream << ", $fn = " << this->fn << ", $fa = " << this->fa
+           << ", $fs = " << this->fs;
   }
   if (this->convexity > 1) {
     stream << ", convexity = " << this->convexity;
@@ -151,10 +163,11 @@ std::string LinearExtrudeNode::toString() const
   return stream.str();
 }
 
-void register_builtin_linear_extrude()
-{
-  Builtins::init("linear_extrude", new BuiltinModule(builtin_linear_extrude),
-  {
-    "linear_extrude(height = 100, center = false, convexity = 1, twist = 0, scale = 1.0, [slices, segments, v, $fn, $fs, $fa])",
-  });
+void register_builtin_linear_extrude() {
+  Builtins::init(
+      "linear_extrude", new BuiltinModule(builtin_linear_extrude),
+      {
+          "linear_extrude(height = 100, center = false, convexity = 1, twist = "
+          "0, scale = 1.0, [slices, segments, v, $fn, $fs, $fa])",
+      });
 }
diff --git a/src/core/LinearExtrudeNode.h b/src/core/LinearExtrudeNode.h
index 1caf2a9a7..c29e3fa12 100644
--- a/src/core/LinearExtrudeNode.h
+++ b/src/core/LinearExtrudeNode.h
@@ -2,17 +2,15 @@
 
 #include <string>
 
-#include "core/node.h"
 #include "core/ModuleInstantiation.h"
 #include "core/Value.h"
+#include "core/node.h"
 #include "geometry/linalg.h"
 
-class LinearExtrudeNode : public AbstractPolyNode
-{
+class LinearExtrudeNode : public AbstractPolyNode {
 public:
   VISITABLE();
-  LinearExtrudeNode(const ModuleInstantiation *mi) : AbstractPolyNode(mi) {
-  }
+  LinearExtrudeNode(const ModuleInstantiation *mi) : AbstractPolyNode(mi) {}
   std::string toString() const override;
   std::string name() const override { return "linear_extrude"; }
 
diff --git a/src/core/LocalScope.cc b/src/core/LocalScope.cc
index bf5cdf8d3..3429c5494 100644
--- a/src/core/LocalScope.cc
+++ b/src/core/LocalScope.cc
@@ -1,9 +1,9 @@
 #include "core/LocalScope.h"
 
 #include <cassert>
-#include <ostream>
-#include <memory>
 #include <cstddef>
+#include <memory>
+#include <ostream>
 #include <string>
 #include <vector>
 
@@ -13,54 +13,56 @@
 #include "core/function.h"
 #include "core/node.h"
 
-void LocalScope::addModuleInst(const std::shared_ptr<ModuleInstantiation>& modinst)
-{
+void LocalScope::addModuleInst(
+    const std::shared_ptr<ModuleInstantiation> &modinst) {
   assert(modinst);
   this->moduleInstantiations.push_back(modinst);
 }
 
-void LocalScope::addModule(const std::shared_ptr<class UserModule>& module)
-{
+void LocalScope::addModule(const std::shared_ptr<class UserModule> &module) {
   assert(module);
   auto it = this->modules.find(module->name);
-  if (it != this->modules.end()) it->second = module;
-  else this->modules.emplace(module->name, module);
+  if (it != this->modules.end())
+    it->second = module;
+  else
+    this->modules.emplace(module->name, module);
   this->astModules.emplace_back(module->name, module);
 }
 
-void LocalScope::addFunction(const std::shared_ptr<class UserFunction>& func)
-{
+void LocalScope::addFunction(const std::shared_ptr<class UserFunction> &func) {
   assert(func);
   auto it = this->functions.find(func->name);
-  if (it != this->functions.end()) it->second = func;
-  else this->functions.emplace(func->name, func);
+  if (it != this->functions.end())
+    it->second = func;
+  else
+    this->functions.emplace(func->name, func);
   this->astFunctions.emplace_back(func->name, func);
 }
 
-void LocalScope::addAssignment(const std::shared_ptr<Assignment>& assignment)
-{
+void LocalScope::addAssignment(const std::shared_ptr<Assignment> &assignment) {
   this->assignments.push_back(assignment);
 }
 
-void LocalScope::print(std::ostream& stream, const std::string& indent, const bool inlined) const
-{
-  for (const auto& f : this->astFunctions) {
+void LocalScope::print(std::ostream &stream, const std::string &indent,
+                       const bool inlined) const {
+  for (const auto &f : this->astFunctions) {
     f.second->print(stream, indent);
   }
-  for (const auto& m : this->astModules) {
+  for (const auto &m : this->astModules) {
     m.second->print(stream, indent);
   }
-  for (const auto& assignment : this->assignments) {
+  for (const auto &assignment : this->assignments) {
     assignment->print(stream, indent);
   }
-  for (const auto& inst : this->moduleInstantiations) {
+  for (const auto &inst : this->moduleInstantiations) {
     inst->print(stream, indent, inlined);
   }
 }
 
-std::shared_ptr<AbstractNode> LocalScope::instantiateModules(const std::shared_ptr<const Context>& context, const std::shared_ptr<AbstractNode>& target) const
-{
-  for (const auto& modinst : this->moduleInstantiations) {
+std::shared_ptr<AbstractNode> LocalScope::instantiateModules(
+    const std::shared_ptr<const Context> &context,
+    const std::shared_ptr<AbstractNode> &target) const {
+  for (const auto &modinst : this->moduleInstantiations) {
     auto node = modinst->evaluate(context);
     if (node) {
       target->children.push_back(node);
@@ -69,8 +71,10 @@ std::shared_ptr<AbstractNode> LocalScope::instantiateModules(const std::shared_p
   return target;
 }
 
-std::shared_ptr<AbstractNode> LocalScope::instantiateModules(const std::shared_ptr<const Context>& context, const std::shared_ptr<AbstractNode>& target, const std::vector<size_t>& indices) const
-{
+std::shared_ptr<AbstractNode>
+LocalScope::instantiateModules(const std::shared_ptr<const Context> &context,
+                               const std::shared_ptr<AbstractNode> &target,
+                               const std::vector<size_t> &indices) const {
   for (size_t index : indices) {
     assert(index < this->moduleInstantiations.size());
     auto node = moduleInstantiations[index]->evaluate(context);
diff --git a/src/core/LocalScope.h b/src/core/LocalScope.h
index bd7c66aae..b03a2b87a 100644
--- a/src/core/LocalScope.h
+++ b/src/core/LocalScope.h
@@ -1,37 +1,47 @@
 #pragma once
 
 #include "core/Assignment.h"
-#include <utility>
-#include <ostream>
 #include <cstddef>
-#include <unordered_map>
 #include <memory>
+#include <ostream>
 #include <string>
+#include <unordered_map>
+#include <utility>
 #include <vector>
 
 class AbstractNode;
 class Context;
 
-class LocalScope
-{
+class LocalScope {
 public:
-  size_t numElements() const { return assignments.size() + moduleInstantiations.size(); }
-  void print(std::ostream& stream, const std::string& indent, const bool inlined = false) const;
-  std::shared_ptr<AbstractNode> instantiateModules(const std::shared_ptr<const Context>& context, const std::shared_ptr<AbstractNode>& target) const;
-  std::shared_ptr<AbstractNode> instantiateModules(const std::shared_ptr<const Context>& context, const std::shared_ptr<AbstractNode>& target, const std::vector<size_t>& indices) const;
-  void addModuleInst(const std::shared_ptr<class ModuleInstantiation>& modinst);
-  void addModule(const std::shared_ptr<class UserModule>& module);
-  void addFunction(const std::shared_ptr<class UserFunction>& function);
-  void addAssignment(const std::shared_ptr<class Assignment>& assignment);
-  bool hasChildren() const {return !(moduleInstantiations.empty());}
+  size_t numElements() const {
+    return assignments.size() + moduleInstantiations.size();
+  }
+  void print(std::ostream &stream, const std::string &indent,
+             const bool inlined = false) const;
+  std::shared_ptr<AbstractNode>
+  instantiateModules(const std::shared_ptr<const Context> &context,
+                     const std::shared_ptr<AbstractNode> &target) const;
+  std::shared_ptr<AbstractNode>
+  instantiateModules(const std::shared_ptr<const Context> &context,
+                     const std::shared_ptr<AbstractNode> &target,
+                     const std::vector<size_t> &indices) const;
+  void addModuleInst(const std::shared_ptr<class ModuleInstantiation> &modinst);
+  void addModule(const std::shared_ptr<class UserModule> &module);
+  void addFunction(const std::shared_ptr<class UserFunction> &function);
+  void addAssignment(const std::shared_ptr<class Assignment> &assignment);
+  bool hasChildren() const { return !(moduleInstantiations.empty()); }
 
   AssignmentList assignments;
   std::vector<std::shared_ptr<ModuleInstantiation>> moduleInstantiations;
 
-  // Modules and functions are stored twice; once for lookup and once for AST serialization
-  // FIXME: Should we split this class into an ASTNode and a run-time support class?
+  // Modules and functions are stored twice; once for lookup and once for AST
+  // serialization
+  // FIXME: Should we split this class into an ASTNode and a run-time support
+  // class?
   std::unordered_map<std::string, std::shared_ptr<UserFunction>> functions;
-  std::vector<std::pair<std::string, std::shared_ptr<UserFunction>>> astFunctions;
+  std::vector<std::pair<std::string, std::shared_ptr<UserFunction>>>
+      astFunctions;
 
   std::unordered_map<std::string, std::shared_ptr<UserModule>> modules;
   std::vector<std::pair<std::string, std::shared_ptr<UserModule>>> astModules;
diff --git a/src/core/ModuleInstantiation.cc b/src/core/ModuleInstantiation.cc
index 3715cef0a..b4d775944 100644
--- a/src/core/ModuleInstantiation.cc
+++ b/src/core/ModuleInstantiation.cc
@@ -1,24 +1,27 @@
 #include "core/ModuleInstantiation.h"
 
-#include <ostream>
-#include <memory>
 #include <cstddef>
+#include <memory>
+#include <ostream>
 #include <string>
 
-#include "utils/compiler_specific.h"
 #include "core/Context.h"
 #include "core/Expression.h"
+#include "utils/compiler_specific.h"
 #include "utils/exceptions.h"
 #include "utils/printutils.h"
 
-void ModuleInstantiation::print(std::ostream& stream, const std::string& indent, const bool inlined) const
-{
-  if (!inlined) stream << indent;
+void ModuleInstantiation::print(std::ostream &stream, const std::string &indent,
+                                const bool inlined) const {
+  if (!inlined)
+    stream << indent;
   stream << modname + "(";
   for (size_t i = 0; i < this->arguments.size(); ++i) {
-    const auto& arg = this->arguments[i];
-    if (i > 0) stream << ", ";
-    if (!arg->getName().empty()) stream << arg->getName() << " = ";
+    const auto &arg = this->arguments[i];
+    if (i > 0)
+      stream << ", ";
+    if (!arg->getName().empty())
+      stream << arg->getName() << " = ";
     stream << *arg->getExpr();
   }
   if (scope.numElements() == 0) {
@@ -33,8 +36,9 @@ void ModuleInstantiation::print(std::ostream& stream, const std::string& indent,
   }
 }
 
-void IfElseModuleInstantiation::print(std::ostream& stream, const std::string& indent, const bool inlined) const
-{
+void IfElseModuleInstantiation::print(std::ostream &stream,
+                                      const std::string &indent,
+                                      const bool inlined) const {
   ModuleInstantiation::print(stream, indent, inlined);
   if (else_scope) {
     auto num_elements = else_scope->numElements();
@@ -60,21 +64,26 @@ void IfElseModuleInstantiation::print(std::ostream& stream, const std::string& i
  * noinline is required, as we here specifically optimize for stack usage
  * during normal operating, not runtime during error handling.
  */
-static void NOINLINE print_trace(const ModuleInstantiation *mod, const std::shared_ptr<const Context>& context){
-  LOG(message_group::Trace, mod->location(), context->documentRoot(), "called by '%1$s'", mod->name());
+static void NOINLINE
+print_trace(const ModuleInstantiation *mod,
+            const std::shared_ptr<const Context> &context) {
+  LOG(message_group::Trace, mod->location(), context->documentRoot(),
+      "called by '%1$s'", mod->name());
 }
 
-std::shared_ptr<AbstractNode> ModuleInstantiation::evaluate(const std::shared_ptr<const Context>& context) const
-{
-  boost::optional<InstantiableModule> module = context->lookup_module(this->name(), this->loc);
+std::shared_ptr<AbstractNode> ModuleInstantiation::evaluate(
+    const std::shared_ptr<const Context> &context) const {
+  boost::optional<InstantiableModule> module =
+      context->lookup_module(this->name(), this->loc);
   if (!module) {
     return nullptr;
   }
 
-  try{
-    auto node = module->module->instantiate(module->defining_context, this, context);
+  try {
+    auto node =
+        module->module->instantiate(module->defining_context, this, context);
     return node;
-  } catch (EvaluationException& e) {
+  } catch (EvaluationException &e) {
     if (e.traceDepth > 0) {
       print_trace(this, context);
       e.traceDepth--;
@@ -83,8 +92,7 @@ std::shared_ptr<AbstractNode> ModuleInstantiation::evaluate(const std::shared_pt
   }
 }
 
-LocalScope *IfElseModuleInstantiation::makeElseScope()
-{
+LocalScope *IfElseModuleInstantiation::makeElseScope() {
   this->else_scope = std::make_unique<LocalScope>();
   return this->else_scope.get();
 }
diff --git a/src/core/ModuleInstantiation.h b/src/core/ModuleInstantiation.h
index 509672b40..0dd2ba7cf 100644
--- a/src/core/ModuleInstantiation.h
+++ b/src/core/ModuleInstantiation.h
@@ -2,25 +2,29 @@
 
 #include "core/AST.h"
 #include "core/LocalScope.h"
-#include <ostream>
 #include <memory>
+#include <ostream>
 #include <string>
 #include <utility>
 #include <vector>
 
 using ModuleInstantiationList = std::vector<class ModuleInstantiation *>;
 
-class ModuleInstantiation : public ASTNode
-{
+class ModuleInstantiation : public ASTNode {
 public:
-  ModuleInstantiation(std::string name, AssignmentList args = AssignmentList(), const Location& loc = Location::NONE)
-    : ASTNode(loc), arguments(std::move(args)), modname(std::move(name)) { }
-
-  virtual void print(std::ostream& stream, const std::string& indent, const bool inlined) const;
-  void print(std::ostream& stream, const std::string& indent) const override { print(stream, indent, false); }
-  std::shared_ptr<AbstractNode> evaluate(const std::shared_ptr<const Context>& context) const;
-
-  const std::string& name() const { return this->modname; }
+  ModuleInstantiation(std::string name, AssignmentList args = AssignmentList(),
+                      const Location &loc = Location::NONE)
+      : ASTNode(loc), arguments(std::move(args)), modname(std::move(name)) {}
+
+  virtual void print(std::ostream &stream, const std::string &indent,
+                     const bool inlined) const;
+  void print(std::ostream &stream, const std::string &indent) const override {
+    print(stream, indent, false);
+  }
+  std::shared_ptr<AbstractNode>
+  evaluate(const std::shared_ptr<const Context> &context) const;
+
+  const std::string &name() const { return this->modname; }
   bool isBackground() const { return this->tag_background; }
   bool isHighlight() const { return this->tag_highlight; }
   bool isRoot() const { return this->tag_root; }
@@ -31,19 +35,23 @@ public:
   bool tag_root{false};
   bool tag_highlight{false};
   bool tag_background{false};
+
 protected:
   std::string modname;
 };
 
-class IfElseModuleInstantiation : public ModuleInstantiation
-{
+class IfElseModuleInstantiation : public ModuleInstantiation {
 public:
-  IfElseModuleInstantiation(std::shared_ptr<class Expression> expr, const Location& loc) :
-    ModuleInstantiation("if", AssignmentList{assignment("", std::move(expr))}, loc) { }
+  IfElseModuleInstantiation(std::shared_ptr<class Expression> expr,
+                            const Location &loc)
+      : ModuleInstantiation(
+            "if", AssignmentList{assignment("", std::move(expr))}, loc) {}
 
   LocalScope *makeElseScope();
   LocalScope *getElseScope() const { return this->else_scope.get(); }
-  void print(std::ostream& stream, const std::string& indent, const bool inlined) const final;
+  void print(std::ostream &stream, const std::string &indent,
+             const bool inlined) const final;
+
 private:
   std::unique_ptr<LocalScope> else_scope;
 };
diff --git a/src/core/NodeCache.h b/src/core/NodeCache.h
index 0550160fd..cfd47fb52 100644
--- a/src/core/NodeCache.h
+++ b/src/core/NodeCache.h
@@ -1,10 +1,10 @@
 #pragma once
 
-#include <utility>
-#include <string>
-#include <unordered_map>
 #include <cassert>
 #include <cstddef>
+#include <string>
+#include <unordered_map>
+#include <utility>
 
 #include "core/node.h"
 #include "utils/printutils.h"
@@ -15,22 +15,21 @@
    every time a new tree is generated.
  */
 
-class NodeCache
-{
+class NodeCache {
 public:
   NodeCache() = default;
 
-  bool contains(const AbstractNode& node) const {
+  bool contains(const AbstractNode &node) const {
     auto result = this->cache.find(node.index());
-    return result != this->cache.end() &&
-           result->second.second >= 0L &&
+    return result != this->cache.end() && result->second.second >= 0L &&
            (long)this->rootString.size() >= result->second.second;
   }
 
-  std::string operator[](const AbstractNode& node) const {
+  std::string operator[](const AbstractNode &node) const {
     // throws std::out_of_range on miss
     auto indexpair = this->cache.at(node.index());
-    return rootString.substr(indexpair.first, indexpair.second - indexpair.first);
+    return rootString.substr(indexpair.first,
+                             indexpair.second - indexpair.first);
   }
 
   void insertStart(const size_t nodeidx, const long startindex) {
@@ -44,11 +43,12 @@ public:
     assert(indexpair.second == -1L && "end index inserted twice");
     this->cache[nodeidx] = std::make_pair(indexpair.first, endindex);
 #ifdef DEBUG
-    PRINTDB("NodeCache insert {%i,[%d:%d]}", nodeidx % indexpair.first % endindex);
+    PRINTDB("NodeCache insert {%i,[%d:%d]}",
+            nodeidx % indexpair.first % endindex);
 #endif
   }
 
-  void setRootString(const std::string& rootString) {
+  void setRootString(const std::string &rootString) {
     this->rootString = rootString;
   }
 
diff --git a/src/core/NodeDumper.cc b/src/core/NodeDumper.cc
index 3724a87df..a42b4d638 100644
--- a/src/core/NodeDumper.cc
+++ b/src/core/NodeDumper.cc
@@ -1,13 +1,12 @@
 #include "core/NodeDumper.h"
-#include "core/State.h"
 #include "core/ModuleInstantiation.h"
+#include "core/State.h"
 #include <algorithm>
+#include <boost/regex.hpp>
 #include <iterator>
 #include <ostream>
-#include <string>
 #include <sstream>
-#include <boost/regex.hpp>
-
+#include <string>
 
 void GroupNodeChecker::incChildCount(int groupNodeIndex) {
   auto search = this->groupChildCounts.find(groupNodeIndex);
@@ -26,8 +25,7 @@ int GroupNodeChecker::getChildCount(int groupNodeIndex) const {
   }
 }
 
-Response GroupNodeChecker::visit(State& state, const GroupNode& node)
-{
+Response GroupNodeChecker::visit(State &state, const GroupNode &node) {
   if (state.isPrefix()) {
     // create entry for group node, which children may increment
     this->groupChildCounts.emplace(node.index(), 0);
@@ -39,15 +37,13 @@ Response GroupNodeChecker::visit(State& state, const GroupNode& node)
   return Response::ContinueTraversal;
 }
 
-Response GroupNodeChecker::visit(State& state, const AbstractNode&)
-{
+Response GroupNodeChecker::visit(State &state, const AbstractNode &) {
   if (state.isPostfix() && state.parent()) {
     this->incChildCount(state.parent()->index());
   }
   return Response::ContinueTraversal;
 }
 
-
 /*!
    \class NodeDumper
 
@@ -56,27 +52,23 @@ Response GroupNodeChecker::visit(State& state, const AbstractNode&)
    any node or subtree.
  */
 
-void NodeDumper::initCache()
-{
+void NodeDumper::initCache() {
   this->dumpstream.str("");
   this->dumpstream.clear();
   this->cache.clear();
 }
 
-void NodeDumper::finalizeCache()
-{
+void NodeDumper::finalizeCache() {
   this->cache.setRootString(this->dumpstream.str());
 }
 
-bool NodeDumper::isCached(const AbstractNode& node) const
-{
+bool NodeDumper::isCached(const AbstractNode &node) const {
   return this->cache.contains(node);
 }
 
-Response NodeDumper::visit(State& state, const GroupNode& node)
-{
+Response NodeDumper::visit(State &state, const GroupNode &node) {
   if (!this->idString) {
-    return NodeDumper::visit(state, (const AbstractNode&)node);
+    return NodeDumper::visit(state, (const AbstractNode &)node);
   }
   if (state.isPrefix()) {
     // For handling root modifier '!'
@@ -85,14 +77,18 @@ Response NodeDumper::visit(State& state, const GroupNode& node)
       this->initCache();
     }
 
-    // ListNodes can pass down modifiers to children via state, so check both modinst and state
-    if (node.modinst->isBackground() || state.isBackground()) this->dumpstream << "%";
-    if (node.modinst->isHighlight() || state.isHighlight()) this->dumpstream << "#";
+    // ListNodes can pass down modifiers to children via state, so check both
+    // modinst and state
+    if (node.modinst->isBackground() || state.isBackground())
+      this->dumpstream << "%";
+    if (node.modinst->isHighlight() || state.isHighlight())
+      this->dumpstream << "#";
 
 // If IDPREFIX is set, we will output "/*id*/" in front of each node
 // which is useful for debugging.
 #ifdef IDPREFIX
-    if (this->idString) this->dumpstream << "\n";
+    if (this->idString)
+      this->dumpstream << "\n";
     this->dumpstream << "/*" << node.index() << "*/";
 #endif
 
@@ -112,7 +108,8 @@ Response NodeDumper::visit(State& state, const GroupNode& node)
     this->cache.insertEnd(node.index(), this->dumpstream.tellp());
 
     // For handling root modifier '!'
-    // Check if we are processing the root of the current Tree and finalize cache
+    // Check if we are processing the root of the current Tree and finalize
+    // cache
     if (this->root.get() == &node) {
       this->finalizeCache();
     }
@@ -121,12 +118,10 @@ Response NodeDumper::visit(State& state, const GroupNode& node)
   return Response::ContinueTraversal;
 }
 
-
 /*!
    Called for each node in the tree.
  */
-Response NodeDumper::visit(State& state, const AbstractNode& node)
-{
+Response NodeDumper::visit(State &state, const AbstractNode &node) {
   if (state.isPrefix()) {
 
     // For handling root modifier '!'
@@ -135,14 +130,18 @@ Response NodeDumper::visit(State& state, const AbstractNode& node)
       this->initCache();
     }
 
-    // ListNodes can pass down modifiers to children via state, so check both modinst and state
-    if (node.modinst->isBackground() || state.isBackground()) this->dumpstream << "%";
-    if (node.modinst->isHighlight() || state.isHighlight()) this->dumpstream << "#";
+    // ListNodes can pass down modifiers to children via state, so check both
+    // modinst and state
+    if (node.modinst->isBackground() || state.isBackground())
+      this->dumpstream << "%";
+    if (node.modinst->isHighlight() || state.isHighlight())
+      this->dumpstream << "#";
 
 // If IDPREFIX is set, we will output "/*id*/" in front of each node
 // which is useful for debugging.
 #ifdef IDPREFIX
-    if (this->idString) this->dumpstream << "\n";
+    if (this->idString)
+      this->dumpstream << "\n";
     this->dumpstream << "/*" << node.index() << "*/";
 #endif
 
@@ -154,7 +153,8 @@ Response NodeDumper::visit(State& state, const AbstractNode& node)
       static const boost::regex re(R"([^\s\"]+|\"(?:[^\"\\]|\\.)*\")");
       const auto name = STR(node);
       boost::sregex_token_iterator it(name.begin(), name.end(), re, 0);
-      std::copy(it, boost::sregex_token_iterator(), std::ostream_iterator<std::string>(this->dumpstream));
+      std::copy(it, boost::sregex_token_iterator(),
+                std::ostream_iterator<std::string>(this->dumpstream));
 
       if (node.getChildren().size() > 0) {
         this->dumpstream << "{";
@@ -198,7 +198,8 @@ Response NodeDumper::visit(State& state, const AbstractNode& node)
     this->cache.insertEnd(node.index(), this->dumpstream.tellp());
 
     // For handling root modifier '!'
-    // Check if we are processing the root of the current Tree and finalize cache
+    // Check if we are processing the root of the current Tree and finalize
+    // cache
     if (this->root.get() == &node) {
       this->finalizeCache();
     }
@@ -210,16 +211,17 @@ Response NodeDumper::visit(State& state, const AbstractNode& node)
 /*!
    Handle list nodes specially: Only list children
  */
-Response NodeDumper::visit(State& state, const ListNode& node)
-{
+Response NodeDumper::visit(State &state, const ListNode &node) {
   if (state.isPrefix()) {
     // For handling root modifier '!'
     if (this->root.get() == &node) {
       this->initCache();
     }
     // pass modifiers down to children via state
-    if (node.modinst->isHighlight()) state.setHighlight(true);
-    if (node.modinst->isBackground()) state.setBackground(true);
+    if (node.modinst->isHighlight())
+      state.setHighlight(true);
+    if (node.modinst->isBackground())
+      state.setBackground(true);
     this->cache.insertStart(node.index(), this->dumpstream.tellp());
   } else if (state.isPostfix()) {
     this->cache.insertEnd(node.index(), this->dumpstream.tellp());
@@ -235,9 +237,9 @@ Response NodeDumper::visit(State& state, const ListNode& node)
 /*!
    Handle root nodes specially: Only list children
  */
-Response NodeDumper::visit(State& state, const RootNode& node)
-{
-  if (isCached(node)) return Response::PruneTraversal;
+Response NodeDumper::visit(State &state, const RootNode &node) {
+  if (isCached(node))
+    return Response::PruneTraversal;
 
   if (state.isPrefix()) {
     this->initCache();
diff --git a/src/core/NodeDumper.h b/src/core/NodeDumper.h
index b1f4d0248..126b6dd36 100644
--- a/src/core/NodeDumper.h
+++ b/src/core/NodeDumper.h
@@ -1,26 +1,25 @@
 #pragma once
 
-#include <sstream>
+#include "core/NodeCache.h"
+#include "core/NodeVisitor.h"
+#include "core/node.h"
 #include <memory>
+#include <sstream>
 #include <string>
 #include <unordered_map>
 #include <utility>
-#include "core/NodeVisitor.h"
-#include "core/node.h"
-#include "core/NodeCache.h"
 
 // GroupNodeChecker does a quick first pass to count children of group nodes
 // If a GroupNode has 0 children, don't include in node id strings
 // If a GroupNode has 1 child, we replace it with its child
-// This makes id strings much more compact for deeply nested trees, recursive scad scripts,
-// and increases likelihood of node cache hits.
-class GroupNodeChecker : public NodeVisitor
-{
+// This makes id strings much more compact for deeply nested trees, recursive
+// scad scripts, and increases likelihood of node cache hits.
+class GroupNodeChecker : public NodeVisitor {
 public:
   GroupNodeChecker() = default;
 
-  Response visit(State& state, const AbstractNode& node) override;
-  Response visit(State& state, const GroupNode& node) override;
+  Response visit(State &state, const AbstractNode &node) override;
+  Response visit(State &state, const GroupNode &node) override;
   void incChildCount(int groupNodeIndex);
   int getChildCount(int groupNodeIndex) const;
   void reset() { groupChildCounts.clear(); }
@@ -30,27 +29,28 @@ private:
   std::unordered_map<int, int> groupChildCounts;
 };
 
-class NodeDumper : public NodeVisitor
-{
+class NodeDumper : public NodeVisitor {
 public:
-  NodeDumper(NodeCache& cache, std::shared_ptr<const AbstractNode> root_node, std::string indent, bool idString) :
-    cache(cache), indent(std::move(indent)), idString(idString), root(std::move(root_node)) {
+  NodeDumper(NodeCache &cache, std::shared_ptr<const AbstractNode> root_node,
+             std::string indent, bool idString)
+      : cache(cache), indent(std::move(indent)), idString(idString),
+        root(std::move(root_node)) {
     if (idString) {
       groupChecker.traverse(*root);
     }
   }
 
-  Response visit(State& state, const AbstractNode& node) override;
-  Response visit(State& state, const GroupNode& node) override;
-  Response visit(State& state, const ListNode& node) override;
-  Response visit(State& state, const RootNode& node) override;
+  Response visit(State &state, const AbstractNode &node) override;
+  Response visit(State &state, const GroupNode &node) override;
+  Response visit(State &state, const ListNode &node) override;
+  Response visit(State &state, const RootNode &node) override;
 
 private:
   void initCache();
   void finalizeCache();
-  bool isCached(const AbstractNode& node) const;
+  bool isCached(const AbstractNode &node) const;
 
-  NodeCache& cache;
+  NodeCache &cache;
   // Output Formatting options
   std::string indent;
   bool idString;
@@ -59,7 +59,4 @@ private:
   std::shared_ptr<const AbstractNode> root;
   GroupNodeChecker groupChecker;
   std::ostringstream dumpstream;
-
 };
-
-
diff --git a/src/core/NodeVisitor.cc b/src/core/NodeVisitor.cc
index 1cce775b2..c5e2e530a 100644
--- a/src/core/NodeVisitor.cc
+++ b/src/core/NodeVisitor.cc
@@ -3,8 +3,7 @@
 
 State NodeVisitor::nullstate(nullptr);
 
-Response NodeVisitor::traverse(const AbstractNode& node, const State& state)
-{
+Response NodeVisitor::traverse(const AbstractNode &node, const State &state) {
   State newstate = state;
   newstate.setNumChildren(node.getChildren().size());
 
@@ -16,9 +15,10 @@ Response NodeVisitor::traverse(const AbstractNode& node, const State& state)
   // Pruned traversals mean don't traverse children
   if (response == Response::ContinueTraversal) {
     newstate.setParent(node.shared_from_this());
-    for (const auto& chnode : node.getChildren()) {
+    for (const auto &chnode : node.getChildren()) {
       response = this->traverse(*chnode, newstate);
-      if (response == Response::AbortTraversal) return response; // Abort immediately
+      if (response == Response::AbortTraversal)
+        return response; // Abort immediately
     }
   }
 
@@ -30,6 +30,7 @@ Response NodeVisitor::traverse(const AbstractNode& node, const State& state)
     response = node.accept(newstate, *this);
   }
 
-  if (response != Response::AbortTraversal) response = Response::ContinueTraversal;
+  if (response != Response::AbortTraversal)
+    response = Response::ContinueTraversal;
   return response;
 }
diff --git a/src/core/NodeVisitor.h b/src/core/NodeVisitor.h
index 3252fc108..193625b35 100644
--- a/src/core/NodeVisitor.h
+++ b/src/core/NodeVisitor.h
@@ -1,97 +1,96 @@
 #pragma once
 
 #include "core/BaseVisitable.h"
-#include "core/node.h"
 #include "core/State.h"
+#include "core/node.h"
 
 class State;
 
-class NodeVisitor :
-  public BaseVisitor,
-  public Visitor<class AbstractNode>,
-  public Visitor<class AbstractIntersectionNode>,
-  public Visitor<class AbstractPolyNode>,
-  public Visitor<class ListNode>,
-  public Visitor<class GroupNode>,
-  public Visitor<class RootNode>,
-  public Visitor<class LeafNode>,
-  public Visitor<class CgalAdvNode>,
-  public Visitor<class CsgOpNode>,
-  public Visitor<class LinearExtrudeNode>,
-  public Visitor<class RotateExtrudeNode>,
-  public Visitor<class RoofNode>,
-  public Visitor<class ImportNode>,
-  public Visitor<class TextNode>,
-  public Visitor<class ProjectionNode>,
-  public Visitor<class RenderNode>,
-  public Visitor<class SurfaceNode>,
-  public Visitor<class TransformNode>,
-  public Visitor<class ColorNode>,
-  public Visitor<class OffsetNode>
-{
+class NodeVisitor : public BaseVisitor,
+                    public Visitor<class AbstractNode>,
+                    public Visitor<class AbstractIntersectionNode>,
+                    public Visitor<class AbstractPolyNode>,
+                    public Visitor<class ListNode>,
+                    public Visitor<class GroupNode>,
+                    public Visitor<class RootNode>,
+                    public Visitor<class LeafNode>,
+                    public Visitor<class CgalAdvNode>,
+                    public Visitor<class CsgOpNode>,
+                    public Visitor<class LinearExtrudeNode>,
+                    public Visitor<class RotateExtrudeNode>,
+                    public Visitor<class RoofNode>,
+                    public Visitor<class ImportNode>,
+                    public Visitor<class TextNode>,
+                    public Visitor<class ProjectionNode>,
+                    public Visitor<class RenderNode>,
+                    public Visitor<class SurfaceNode>,
+                    public Visitor<class TransformNode>,
+                    public Visitor<class ColorNode>,
+                    public Visitor<class OffsetNode> {
 public:
   NodeVisitor() = default;
 
-  Response traverse(const AbstractNode& node, const State& state = NodeVisitor::nullstate);
+  Response traverse(const AbstractNode &node,
+                    const State &state = NodeVisitor::nullstate);
 
-  Response visit(State& state, const AbstractNode& node) override = 0;
-  Response visit(State& state, const AbstractIntersectionNode& node) override {
-    return visit(state, (const AbstractNode&) node);
+  Response visit(State &state, const AbstractNode &node) override = 0;
+  Response visit(State &state, const AbstractIntersectionNode &node) override {
+    return visit(state, (const AbstractNode &)node);
   }
-  Response visit(State& state, const AbstractPolyNode& node) override {
-    return visit(state, (const AbstractNode&) node);
+  Response visit(State &state, const AbstractPolyNode &node) override {
+    return visit(state, (const AbstractNode &)node);
   }
-  Response visit(State& state, const ListNode& node) override {
-    return visit(state, (const AbstractNode&) node);
+  Response visit(State &state, const ListNode &node) override {
+    return visit(state, (const AbstractNode &)node);
   }
 
-  Response visit(State& state, const GroupNode& node) override {
-    return visit(state, (const AbstractNode&) node);
+  Response visit(State &state, const GroupNode &node) override {
+    return visit(state, (const AbstractNode &)node);
   }
-  Response visit(State& state, const RootNode& node) override {
-    return visit(state, (const GroupNode&) node);
+  Response visit(State &state, const RootNode &node) override {
+    return visit(state, (const GroupNode &)node);
   }
-  Response visit(State& state, const LeafNode& node) override {
-    return visit(state, (const AbstractPolyNode&) node);
+  Response visit(State &state, const LeafNode &node) override {
+    return visit(state, (const AbstractPolyNode &)node);
   }
-  Response visit(State& state, const CgalAdvNode& node) override {
-    return visit(state, (const AbstractNode&) node);
+  Response visit(State &state, const CgalAdvNode &node) override {
+    return visit(state, (const AbstractNode &)node);
   }
-  Response visit(State& state, const CsgOpNode& node) override {
-    return visit(state, (const AbstractNode&) node);
+  Response visit(State &state, const CsgOpNode &node) override {
+    return visit(state, (const AbstractNode &)node);
   }
-  Response visit(State& state, const LinearExtrudeNode& node) override {
-    return visit(state, (const AbstractPolyNode&) node);
+  Response visit(State &state, const LinearExtrudeNode &node) override {
+    return visit(state, (const AbstractPolyNode &)node);
   }
-  Response visit(State& state, const RotateExtrudeNode& node) override {
-    return visit(state, (const AbstractPolyNode&) node);
+  Response visit(State &state, const RotateExtrudeNode &node) override {
+    return visit(state, (const AbstractPolyNode &)node);
   }
-  Response visit(State& state, const RoofNode& node) override {
-    return visit(state, (const AbstractPolyNode&) node);
+  Response visit(State &state, const RoofNode &node) override {
+    return visit(state, (const AbstractPolyNode &)node);
   }
-  Response visit(State& state, const ImportNode& node) override {
-    return visit(state, (const LeafNode&) node);
+  Response visit(State &state, const ImportNode &node) override {
+    return visit(state, (const LeafNode &)node);
   }
-  Response visit(State& state, const TextNode& node) override {
-    return visit(state, (const AbstractPolyNode&) node);
+  Response visit(State &state, const TextNode &node) override {
+    return visit(state, (const AbstractPolyNode &)node);
   }
-  Response visit(State& state, const ProjectionNode& node) override {
-    return visit(state, (const AbstractPolyNode&) node);
+  Response visit(State &state, const ProjectionNode &node) override {
+    return visit(state, (const AbstractPolyNode &)node);
   }
-  Response visit(State& state, const RenderNode& node) override {
-    return visit(state, (const AbstractNode&) node);
+  Response visit(State &state, const RenderNode &node) override {
+    return visit(state, (const AbstractNode &)node);
   }
-  Response visit(State& state, const SurfaceNode& node) override {
-    return visit(state, (const LeafNode&) node);
+  Response visit(State &state, const SurfaceNode &node) override {
+    return visit(state, (const LeafNode &)node);
   }
-  Response visit(State& state, const TransformNode& node) override {
-    return visit(state, (const AbstractNode&) node);
+  Response visit(State &state, const TransformNode &node) override {
+    return visit(state, (const AbstractNode &)node);
   }
-  Response visit(State& state, const ColorNode& node) override {
-    return visit(state, (const AbstractNode&) node);
+  Response visit(State &state, const ColorNode &node) override {
+    return visit(state, (const AbstractNode &)node);
   }
-  Response visit(State& state, const OffsetNode& node) override {
-    return visit(state, (const AbstractPolyNode&) node);
+  Response visit(State &state, const OffsetNode &node) override {
+    return visit(state, (const AbstractPolyNode &)node);
   }
   // Add visit() methods for new visitable subtypes of AbstractNode here
 
diff --git a/src/core/OffsetNode.cc b/src/core/OffsetNode.cc
index ba4b485e5..13c356019 100644
--- a/src/core/OffsetNode.cc
+++ b/src/core/OffsetNode.cc
@@ -26,25 +26,27 @@
 
 #include "core/OffsetNode.h"
 
-#include "core/module.h"
-#include "core/ModuleInstantiation.h"
+#include "core/Builtins.h"
 #include "core/Children.h"
+#include "core/ModuleInstantiation.h"
 #include "core/Parameters.h"
-#include "core/Builtins.h"
+#include "core/module.h"
 
+#include <boost/assign/std/vector.hpp>
 #include <clipper2/clipper.offset.h>
 #include <ios>
-#include <utility>
 #include <memory>
 #include <sstream>
-#include <boost/assign/std/vector.hpp>
+#include <utility>
 using namespace boost::assign; // bring 'operator+=()' into scope
 
-static std::shared_ptr<AbstractNode> builtin_offset(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+static std::shared_ptr<AbstractNode>
+builtin_offset(const ModuleInstantiation *inst, Arguments arguments,
+               const Children &children) {
   auto node = std::make_shared<OffsetNode>(inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"r"}, {"delta", "chamfer"});
+  Parameters parameters = Parameters::parse(
+      std::move(arguments), inst->location(), {"r"}, {"delta", "chamfer"});
 
   node->fn = parameters["$fn"].toDouble();
   node->fs = parameters["$fs"].toDouble();
@@ -60,7 +62,8 @@ static std::shared_ptr<AbstractNode> builtin_offset(const ModuleInstantiation *i
   } else if (parameters["delta"].isDefinedAs(Value::Type::NUMBER)) {
     node->delta = parameters["delta"].toDouble();
     node->join_type = Clipper2Lib::JoinType::Miter;
-    if (parameters["chamfer"].isDefinedAs(Value::Type::BOOL) && parameters["chamfer"].toBool()) {
+    if (parameters["chamfer"].isDefinedAs(Value::Type::BOOL) &&
+        parameters["chamfer"].toBool()) {
       node->chamfer = true;
       node->join_type = Clipper2Lib::JoinType::Square;
     }
@@ -69,8 +72,7 @@ static std::shared_ptr<AbstractNode> builtin_offset(const ModuleInstantiation *i
   return children.instantiate(node);
 }
 
-std::string OffsetNode::toString() const
-{
+std::string OffsetNode::toString() const {
   std::ostringstream stream;
 
   bool isRadius = this->join_type == Clipper2Lib::JoinType::Round;
@@ -80,19 +82,17 @@ std::string OffsetNode::toString() const
   if (!isRadius) {
     stream << ", chamfer = " << (this->chamfer ? "true" : "false");
   }
-  stream << ", $fn = " << this->fn
-         << ", $fa = " << this->fa
+  stream << ", $fn = " << this->fn << ", $fa = " << this->fa
          << ", $fs = " << this->fs << ")";
 
   return stream.str();
 }
 
-void register_builtin_offset()
-{
+void register_builtin_offset() {
   Builtins::init("offset", new BuiltinModule(builtin_offset),
-  {
-    "offset(r = number)",
-    "offset(delta = number)",
-    "offset(delta = number, chamfer = false)",
-  });
+                 {
+                     "offset(r = number)",
+                     "offset(delta = number)",
+                     "offset(delta = number, chamfer = false)",
+                 });
 }
diff --git a/src/core/OffsetNode.h b/src/core/OffsetNode.h
index c68805cd4..f45f8ae79 100644
--- a/src/core/OffsetNode.h
+++ b/src/core/OffsetNode.h
@@ -1,21 +1,21 @@
 #pragma once
 
-#include "core/node.h"
-#include "core/ModuleInstantiation.h"
 #include "clipper2/clipper.h"
+#include "core/ModuleInstantiation.h"
+#include "core/node.h"
 
 #include <string>
 
-class OffsetNode : public AbstractPolyNode
-{
+class OffsetNode : public AbstractPolyNode {
 public:
   VISITABLE();
-  OffsetNode(const ModuleInstantiation *mi) : AbstractPolyNode(mi) { }
+  OffsetNode(const ModuleInstantiation *mi) : AbstractPolyNode(mi) {}
   std::string toString() const override;
   std::string name() const override { return "offset"; }
 
   bool chamfer{false};
   double fn{0}, fs{0}, fa{0}, delta{1};
-  double miter_limit{1000000.0}; // currently fixed high value to disable chamfers with jtMiter
+  double miter_limit{
+      1000000.0}; // currently fixed high value to disable chamfers with jtMiter
   Clipper2Lib::JoinType join_type{Clipper2Lib::JoinType::Round};
 };
diff --git a/src/core/Parameters.cc b/src/core/Parameters.cc
index 10e616ecd..306399b11 100644
--- a/src/core/Parameters.cc
+++ b/src/core/Parameters.cc
@@ -26,12 +26,12 @@
 
 #include "core/Parameters.h"
 
-#include <initializer_list>
 #include <cassert>
-#include <sstream>
-#include <memory>
 #include <cstddef>
+#include <initializer_list>
+#include <memory>
 #include <set>
+#include <sstream>
 #include <string>
 #include <utility>
 #include <vector>
@@ -39,20 +39,15 @@
 #include "core/AST.h"
 #include "core/Expression.h"
 
-Parameters::Parameters(ContextFrame&& frame, Location loc) :
-  loc(std::move(loc)),
-  frame(std::move(frame)),
-  handle(&this->frame)
-{}
+Parameters::Parameters(ContextFrame &&frame, Location loc)
+    : loc(std::move(loc)), frame(std::move(frame)), handle(&this->frame) {}
 
-Parameters::Parameters(Parameters&& other) noexcept :
-  loc(std::move(other.loc)),
-  frame(std::move(other).to_context_frame()),
-  handle(&this->frame)
-{}
+Parameters::Parameters(Parameters &&other) noexcept
+    : loc(std::move(other.loc)), frame(std::move(other).to_context_frame()),
+      handle(&this->frame) {}
 
-boost::optional<const Value&> Parameters::lookup(const std::string& name) const
-{
+boost::optional<const Value &>
+Parameters::lookup(const std::string &name) const {
   if (ContextFrame::is_config_variable(name)) {
     return frame.session()->try_lookup_special_variable(name);
   } else {
@@ -60,29 +55,29 @@ boost::optional<const Value&> Parameters::lookup(const std::string& name) const
   }
 }
 
-const Value& Parameters::get(const std::string& name) const
-{
-  boost::optional<const Value&> value = lookup(name);
+const Value &Parameters::get(const std::string &name) const {
+  boost::optional<const Value &> value = lookup(name);
   if (!value) {
     return Value::undefined;
   }
   return *value;
 }
 
-const Value& Parameters::get(const std::initializer_list<std::string> names) const
-{
+const Value &
+Parameters::get(const std::initializer_list<std::string> names) const {
   std::string matchName;
-  boost::optional<const Value&> matchValue;
+  boost::optional<const Value &> matchValue;
 
-  for (const std::string& name: names) {
-    boost::optional<const Value&> value = lookup(name);
+  for (const std::string &name : names) {
+    boost::optional<const Value &> value = lookup(name);
     if (value && value->isDefined()) {
       if (!matchValue) {
         matchName = name;
         matchValue = value;
       } else {
         LOG(message_group::Warning, loc, documentRoot(),
-            "Specified both %1$s and %2$s", quoteVar(matchName), quoteVar(name));
+            "Specified both %1$s and %2$s", quoteVar(matchName),
+            quoteVar(name));
       }
     }
   }
@@ -90,34 +85,34 @@ const Value& Parameters::get(const std::initializer_list<std::string> names) con
   return matchValue ? *matchValue : Value::undefined;
 }
 
-double Parameters::get(const std::string& name, double default_value) const
-{
-  boost::optional<const Value&> value = lookup(name);
-  return (value && value->type() == Value::Type::NUMBER) ? value->toDouble() : default_value;
+double Parameters::get(const std::string &name, double default_value) const {
+  boost::optional<const Value &> value = lookup(name);
+  return (value && value->type() == Value::Type::NUMBER) ? value->toDouble()
+                                                         : default_value;
 }
 
-const std::string& Parameters::get(const std::string& name, const std::string& default_value) const
-{
-  boost::optional<const Value&> value = lookup(name);
-  return (value && value->type() == Value::Type::STRING) ? value->toStrUtf8Wrapper().toString() : default_value;
+const std::string &Parameters::get(const std::string &name,
+                                   const std::string &default_value) const {
+  boost::optional<const Value &> value = lookup(name);
+  return (value && value->type() == Value::Type::STRING)
+             ? value->toStrUtf8Wrapper().toString()
+             : default_value;
 }
 
-bool Parameters::valid(const std::string& name, const Value& value,
-                       Value::Type type)
-{
+bool Parameters::valid(const std::string &name, const Value &value,
+                       Value::Type type) {
   if (value.type() == type) {
     return true;
   }
-  print_argConvert_warning(caller, name, value, {type}, loc,
-                           documentRoot());
+  print_argConvert_warning(caller, name, value, {type}, loc, documentRoot());
   return false;
 }
 
-// Note:  unused, doesn't really work right because in some cases where the parameter
-// is not supplied, lookup() returns an existing Value with a value of undef.
-bool Parameters::valid_required(const std::string& name, Value::Type type)
-{
-  boost::optional<const Value&> value = lookup(name);
+// Note:  unused, doesn't really work right because in some cases where the
+// parameter is not supplied, lookup() returns an existing Value with a value of
+// undef.
+bool Parameters::valid_required(const std::string &name, Value::Type type) {
+  boost::optional<const Value &> value = lookup(name);
   if (!value) {
     LOG(message_group::Warning, loc, documentRoot(),
         "%1$s: missing argument %2$s", caller, quoteVar(name));
@@ -126,9 +121,8 @@ bool Parameters::valid_required(const std::string& name, Value::Type type)
   return valid(name, *value, type);
 }
 
-bool Parameters::valid(const std::string& name, Value::Type type)
-{
-  boost::optional<const Value&> value = lookup(name);
+bool Parameters::valid(const std::string &name, Value::Type type) {
+  boost::optional<const Value &> value = lookup(name);
   if (!value || value->isUndefined()) {
     return true;
   }
@@ -136,37 +130,34 @@ bool Parameters::valid(const std::string& name, Value::Type type)
 }
 
 // Handle all general warnings and return true if a valid number is found.
-bool Parameters::validate_number(const std::string& name, double& out)
-{
-  boost::optional<const Value&> value = lookup(name);
+bool Parameters::validate_number(const std::string &name, double &out) {
+  boost::optional<const Value &> value = lookup(name);
   if (!value || value->isUndefined()) {
     return false;
   } else if (valid(name, *value, Value::Type::NUMBER)) {
     if (value->getFiniteDouble(out)) {
       return true;
     } else {
-      LOG(message_group::Warning, loc, documentRoot(), "%1$s(..., %2$s=%3$s) argument cannot be infinite or nan", caller, name, value->toString());
+      LOG(message_group::Warning, loc, documentRoot(),
+          "%1$s(..., %2$s=%3$s) argument cannot be infinite or nan", caller,
+          name, value->toString());
       return false;
     }
   }
   return false;
 }
 
-ContextFrame Parameters::to_context_frame() &&
-{
+ContextFrame Parameters::to_context_frame() && {
   handle.release();
   return std::move(frame);
 }
 
 template <class T, class F>
-static ContextFrame parse_without_defaults(
-  Arguments arguments,
-  const Location& loc,
-  const std::vector<T>& required_parameters,
-  const std::vector<T>& optional_parameters,
-  bool warn_for_unexpected_arguments,
-  F parameter_name
-  ) {
+static ContextFrame
+parse_without_defaults(Arguments arguments, const Location &loc,
+                       const std::vector<T> &required_parameters,
+                       const std::vector<T> &optional_parameters,
+                       bool warn_for_unexpected_arguments, F parameter_name) {
   ContextFrame output{arguments.session()};
 
   std::set<std::string> named_arguments;
@@ -174,39 +165,46 @@ static ContextFrame parse_without_defaults(
   size_t parameter_position = 0;
   bool warned_for_extra_arguments = false;
 
-  for (auto& argument : arguments) {
+  for (auto &argument : arguments) {
     std::string name;
     if (argument.name) {
       name = *argument.name;
       if (named_arguments.count(name)) {
-        LOG(message_group::Warning, loc, arguments.documentRoot(), "argument %1$s supplied more than once", quoteVar(name));
+        LOG(message_group::Warning, loc, arguments.documentRoot(),
+            "argument %1$s supplied more than once", quoteVar(name));
       } else if (output.lookup_local_variable(name)) {
-        LOG(message_group::Warning, loc, arguments.documentRoot(), "argument %1$s overrides positional argument", quoteVar(name));
-      } else if (warn_for_unexpected_arguments && !ContextFrame::is_config_variable(name)) {
+        LOG(message_group::Warning, loc, arguments.documentRoot(),
+            "argument %1$s overrides positional argument", quoteVar(name));
+      } else if (warn_for_unexpected_arguments &&
+                 !ContextFrame::is_config_variable(name)) {
         bool found = false;
-        for (const auto& parameter : required_parameters) {
+        for (const auto &parameter : required_parameters) {
           if (parameter_name(parameter) == name) {
             found = true;
             break;
           }
         }
-        for (const auto& parameter : optional_parameters) {
+        for (const auto &parameter : optional_parameters) {
           if (parameter_name(parameter) == name) {
             found = true;
             break;
           }
         }
         if (!found) {
-          LOG(message_group::Warning, loc, arguments.documentRoot(), "variable %1$s not specified as parameter", quoteVar(name));
+          LOG(message_group::Warning, loc, arguments.documentRoot(),
+              "variable %1$s not specified as parameter", quoteVar(name));
         }
       }
       named_arguments.insert(name);
     } else {
-      while (parameter_position < required_parameters.size() + optional_parameters.size()) {
-        std::string candidate_name = (parameter_position < required_parameters.size())
-    ? parameter_name(required_parameters[parameter_position])
-    : parameter_name(optional_parameters[parameter_position - required_parameters.size()])
-        ;
+      while (parameter_position <
+             required_parameters.size() + optional_parameters.size()) {
+        std::string candidate_name =
+            (parameter_position < required_parameters.size())
+                ? parameter_name(required_parameters[parameter_position])
+                : parameter_name(
+                      optional_parameters[parameter_position -
+                                          required_parameters.size()]);
         parameter_position++;
         if (!named_arguments.count(candidate_name)) {
           name = candidate_name;
@@ -215,7 +213,8 @@ static ContextFrame parse_without_defaults(
       }
       if (name.empty()) {
         if (warn_for_unexpected_arguments && !warned_for_extra_arguments) {
-          LOG(message_group::Warning, loc, arguments.documentRoot(), "Too many unnamed arguments supplied");
+          LOG(message_group::Warning, loc, arguments.documentRoot(),
+              "Too many unnamed arguments supplied");
           warned_for_extra_arguments = true;
         }
         continue;
@@ -227,19 +226,15 @@ static ContextFrame parse_without_defaults(
   return output;
 }
 
-Parameters Parameters::parse(
-  Arguments arguments,
-  const Location& loc,
-  const std::vector<std::string>& required_parameters,
-  const std::vector<std::string>& optional_parameters
-  ) {
-  ContextFrame frame{parse_without_defaults(std::move(arguments), loc, required_parameters, optional_parameters, true,
-                                            [](const std::string& s) -> std::string {
-      return s;
-    }
-                                            )};
+Parameters
+Parameters::parse(Arguments arguments, const Location &loc,
+                  const std::vector<std::string> &required_parameters,
+                  const std::vector<std::string> &optional_parameters) {
+  ContextFrame frame{parse_without_defaults(
+      std::move(arguments), loc, required_parameters, optional_parameters, true,
+      [](const std::string &s) -> std::string { return s; })};
 
-  for (const auto& parameter : required_parameters) {
+  for (const auto &parameter : required_parameters) {
     if (!frame.lookup_local_variable(parameter)) {
       frame.set_variable(parameter, Value::undefined.clone());
     }
@@ -248,22 +243,22 @@ Parameters Parameters::parse(
   return Parameters{std::move(frame), loc};
 }
 
-Parameters Parameters::parse(
-  Arguments arguments,
-  const Location& loc,
-  const AssignmentList& required_parameters,
-  const std::shared_ptr<const Context>& defining_context
-  ) {
-  ContextFrame frame{parse_without_defaults(std::move(arguments), loc, required_parameters, {}, OpenSCAD::parameterCheck,
-                                            [](const std::shared_ptr<Assignment>& assignment) {
-      return assignment->getName();
-    }
-                                            )};
-
-  for (const auto& parameter : required_parameters) {
+Parameters
+Parameters::parse(Arguments arguments, const Location &loc,
+                  const AssignmentList &required_parameters,
+                  const std::shared_ptr<const Context> &defining_context) {
+  ContextFrame frame{
+      parse_without_defaults(std::move(arguments), loc, required_parameters, {},
+                             OpenSCAD::parameterCheck,
+                             [](const std::shared_ptr<Assignment> &assignment) {
+                               return assignment->getName();
+                             })};
+
+  for (const auto &parameter : required_parameters) {
     if (!frame.lookup_local_variable(parameter->getName())) {
       if (parameter->getExpr()) {
-        frame.set_variable(parameter->getName(), parameter->getExpr()->evaluate(defining_context));
+        frame.set_variable(parameter->getName(),
+                           parameter->getExpr()->evaluate(defining_context));
       } else {
         frame.set_variable(parameter->getName(), Value::undefined.clone());
       }
@@ -273,31 +268,27 @@ Parameters Parameters::parse(
   return Parameters{std::move(frame), loc};
 }
 
-void Parameters::set_caller(const std::string& caller)
-{
+void Parameters::set_caller(const std::string &caller) {
   this->caller = caller;
 }
 
-void print_argCnt_warning(
-  const std::string& name,
-  int found,
-  const std::string& expected,
-  const Location& loc,
-  const std::string& documentRoot
-  ) {
-  LOG(message_group::Warning, loc, documentRoot, "%1$s() number of parameters does not match: expected %2$s, found %3$i", name, expected, found);
+void print_argCnt_warning(const std::string &name, int found,
+                          const std::string &expected, const Location &loc,
+                          const std::string &documentRoot) {
+  LOG(message_group::Warning, loc, documentRoot,
+      "%1$s() number of parameters does not match: expected %2$s, found %3$i",
+      name, expected, found);
 }
 
-void print_argConvert_positioned_warning(
-  const std::string& calledName,
-  const std::string& where,
-  const Value& found,
-  std::vector<Value::Type> expected,
-  const Location& loc,
-  const std::string& documentRoot
-  ){
+void print_argConvert_positioned_warning(const std::string &calledName,
+                                         const std::string &where,
+                                         const Value &found,
+                                         std::vector<Value::Type> expected,
+                                         const Location &loc,
+                                         const std::string &documentRoot) {
   std::stringstream message;
-  message << calledName << "() parameter could not be converted: " << where << ": expected ";
+  message << calledName << "() parameter could not be converted: " << where
+          << ": expected ";
   if (expected.size() == 1) {
     message << Value::typeName(expected[0]);
   } else {
@@ -308,20 +299,19 @@ void print_argConvert_positioned_warning(
     }
     message << ")";
   }
-  message << ", found " << found.typeName() << " " << "(" << found.toEchoStringNoThrow() << ")";
+  message << ", found " << found.typeName() << " " << "("
+          << found.toEchoStringNoThrow() << ")";
   LOG(message_group::Warning, loc, documentRoot, "%1$s", message.str());
 }
 
-void print_argConvert_warning(
-  const std::string& calledName,
-  const std::string& argName,
-  const Value& found,
-  std::vector<Value::Type> expected,
-  const Location& loc,
-  const std::string& documentRoot
-  ) {
+void print_argConvert_warning(const std::string &calledName,
+                              const std::string &argName, const Value &found,
+                              std::vector<Value::Type> expected,
+                              const Location &loc,
+                              const std::string &documentRoot) {
   std::stringstream message;
-  message << calledName << "(..., " << argName << "=" << found.toEchoStringNoThrow() << ") Invalid type: expected ";
+  message << calledName << "(..., " << argName << "="
+          << found.toEchoStringNoThrow() << ") Invalid type: expected ";
   if (expected.size() == 1) {
     message << Value::typeName(expected[0]);
   } else {
diff --git a/src/core/Parameters.h b/src/core/Parameters.h
index 749bfee8d..3a89d101f 100644
--- a/src/core/Parameters.h
+++ b/src/core/Parameters.h
@@ -6,8 +6,8 @@
 #include <string>
 #include <vector>
 
-#include "core/Arguments.h"
 #include "core/AST.h"
+#include "core/Arguments.h"
 #include "core/ContextFrame.h"
 
 /*
@@ -17,13 +17,12 @@
  * But special variables passed as parameters ARE accessible on the execution
  * stack. Thus, a Parameters is a ContextFrame, held by a ContextFrameHandle.
  */
-class Parameters
-{
+class Parameters {
 private:
-  Parameters(ContextFrame&& frame, Location loc);
+  Parameters(ContextFrame &&frame, Location loc);
 
 public:
-  Parameters(Parameters&& other) noexcept;
+  Parameters(Parameters &&other) noexcept;
 
   /*
    * Matches arguments with parameters.
@@ -31,60 +30,61 @@ public:
    * Required parameters are set to undefined if absent;
    * Optional parameters are not set at all.
    */
-  static Parameters parse(
-    Arguments arguments,
-    const Location& loc,
-    const std::vector<std::string>& required_parameters,
-    const std::vector<std::string>& optional_parameters = {}
-    );
+  static Parameters
+  parse(Arguments arguments, const Location &loc,
+        const std::vector<std::string> &required_parameters,
+        const std::vector<std::string> &optional_parameters = {});
   /*
    * Matches arguments with parameters.
-   * Supports default arguments, and requires a context in which to interpret them.
-   * Absent parameters without defaults are set to undefined.
+   * Supports default arguments, and requires a context in which to interpret
+   * them. Absent parameters without defaults are set to undefined.
    */
-  static Parameters parse(
-    Arguments arguments,
-    const Location& loc,
-    const AssignmentList& required_parameters,
-    const std::shared_ptr<const Context>& defining_context
-    );
+  static Parameters
+  parse(Arguments arguments, const Location &loc,
+        const AssignmentList &required_parameters,
+        const std::shared_ptr<const Context> &defining_context);
 
-  boost::optional<const Value&> lookup(const std::string& name) const;
+  boost::optional<const Value &> lookup(const std::string &name) const;
 
-  void set_caller(const std::string& caller);
-  const Value& get(const std::string& name) const;
-  const Value& get(const std::initializer_list<std::string> names) const;
-  double get(const std::string& name, double default_value) const;
-  const std::string& get(const std::string& name, const std::string& default_value) const;
+  void set_caller(const std::string &caller);
+  const Value &get(const std::string &name) const;
+  const Value &get(const std::initializer_list<std::string> names) const;
+  double get(const std::string &name, double default_value) const;
+  const std::string &get(const std::string &name,
+                         const std::string &default_value) const;
 
-  bool contains(const std::string& name) const { return bool(lookup(name)); }
-  const Value& operator[](const std::string& name) const { return get(name); }
-  const Value& operator[](const std::initializer_list<std::string> names) const { return get(names); }
-  bool valid(const std::string& name, Value::Type type);
-  bool valid_required(const std::string& name, Value::Type type);
-  bool validate_number(const std::string& name, double& out);
-  template <typename T> bool validate_integral(const std::string& name, T& out,
-                                               T lo = std::numeric_limits<T>::min(),
-                                               T hi = std::numeric_limits<T>::max());
+  bool contains(const std::string &name) const { return bool(lookup(name)); }
+  const Value &operator[](const std::string &name) const { return get(name); }
+  const Value &
+  operator[](const std::initializer_list<std::string> names) const {
+    return get(names);
+  }
+  bool valid(const std::string &name, Value::Type type);
+  bool valid_required(const std::string &name, Value::Type type);
+  bool validate_number(const std::string &name, double &out);
+  template <typename T>
+  bool validate_integral(const std::string &name, T &out,
+                         T lo = std::numeric_limits<T>::min(),
+                         T hi = std::numeric_limits<T>::max());
 
   ContextFrame to_context_frame() &&;
 
-  const std::string& documentRoot() const { return frame.documentRoot(); }
-  const Location& location() const { return loc; }
+  const std::string &documentRoot() const { return frame.documentRoot(); }
+  const Location &location() const { return loc; }
 
 private:
   Location loc;
   ContextFrame frame;
   ContextFrameHandle handle;
-  bool valid(const std::string& name, const Value& value, Value::Type type);
+  bool valid(const std::string &name, const Value &value, Value::Type type);
   std::string caller = "";
 };
 
 // Silently clamp to the given range(defaults to numeric_limits)
 // as long as param is a finite number.
 template <typename T>
-bool Parameters::validate_integral(const std::string& name, T& out, T lo, T hi)
-{
+bool Parameters::validate_integral(const std::string &name, T &out, T lo,
+                                   T hi) {
   double temp;
   if (validate_number(name, temp)) {
     if (temp < lo) {
@@ -99,12 +99,17 @@ bool Parameters::validate_integral(const std::string& name, T& out, T lo, T hi)
   return false;
 }
 
-void print_argCnt_warning(const std::string& name, int found,
-                          const std::string& expected, const Location& loc,
-                          const std::string& documentRoot);
-void print_argConvert_positioned_warning(const std::string& calledName, const std::string& where,
-                                         const Value& found, std::vector<Value::Type> expected,
-                                         const Location& loc, const std::string& documentRoot);
-void print_argConvert_warning(const std::string& calledName, const std::string& argName,
-                              const Value& found, std::vector<Value::Type> expected,
-                              const Location& loc, const std::string& documentRoot);
+void print_argCnt_warning(const std::string &name, int found,
+                          const std::string &expected, const Location &loc,
+                          const std::string &documentRoot);
+void print_argConvert_positioned_warning(const std::string &calledName,
+                                         const std::string &where,
+                                         const Value &found,
+                                         std::vector<Value::Type> expected,
+                                         const Location &loc,
+                                         const std::string &documentRoot);
+void print_argConvert_warning(const std::string &calledName,
+                              const std::string &argName, const Value &found,
+                              std::vector<Value::Type> expected,
+                              const Location &loc,
+                              const std::string &documentRoot);
diff --git a/src/core/ProjectionNode.cc b/src/core/ProjectionNode.cc
index 07ea7c033..3107a3c45 100644
--- a/src/core/ProjectionNode.cc
+++ b/src/core/ProjectionNode.cc
@@ -25,23 +25,25 @@
  */
 
 #include "core/ProjectionNode.h"
-#include "core/module.h"
-#include "core/ModuleInstantiation.h"
+#include "core/Builtins.h"
 #include "core/Children.h"
+#include "core/ModuleInstantiation.h"
 #include "core/Parameters.h"
-#include "core/Builtins.h"
+#include "core/module.h"
 
-#include <utility>
-#include <memory>
-#include <cassert>
 #include <boost/assign/std/vector.hpp>
+#include <cassert>
+#include <memory>
+#include <utility>
 using namespace boost::assign; // bring 'operator+=()' into scope
 
-static std::shared_ptr<AbstractNode> builtin_projection(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+static std::shared_ptr<AbstractNode>
+builtin_projection(const ModuleInstantiation *inst, Arguments arguments,
+                   const Children &children) {
   auto node = std::make_shared<ProjectionNode>(inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"cut"}, {"convexity"});
+  Parameters parameters = Parameters::parse(
+      std::move(arguments), inst->location(), {"cut"}, {"convexity"});
   node->convexity = static_cast<int>(parameters["convexity"].toDouble());
   if (parameters["cut"].type() == Value::Type::BOOL) {
     node->cut_mode = parameters["cut"].toBool();
@@ -50,16 +52,14 @@ static std::shared_ptr<AbstractNode> builtin_projection(const ModuleInstantiatio
   return children.instantiate(node);
 }
 
-std::string ProjectionNode::toString() const
-{
+std::string ProjectionNode::toString() const {
   return STR("projection(cut = ", (this->cut_mode ? "true" : "false"),
              ", convexity = ", this->convexity, ")");
 }
 
-void register_builtin_projection()
-{
+void register_builtin_projection() {
   Builtins::init("projection", new BuiltinModule(builtin_projection),
-  {
-    "projection(cut = false)",
-  });
+                 {
+                     "projection(cut = false)",
+                 });
 }
diff --git a/src/core/ProjectionNode.h b/src/core/ProjectionNode.h
index c9b6da64e..d29d90303 100644
--- a/src/core/ProjectionNode.h
+++ b/src/core/ProjectionNode.h
@@ -4,11 +4,10 @@
 #include "core/node.h"
 #include <string>
 
-class ProjectionNode : public AbstractPolyNode
-{
+class ProjectionNode : public AbstractPolyNode {
 public:
   VISITABLE();
-  ProjectionNode(const ModuleInstantiation *mi) : AbstractPolyNode(mi) { }
+  ProjectionNode(const ModuleInstantiation *mi) : AbstractPolyNode(mi) {}
   std::string toString() const override;
   std::string name() const override { return "projection"; }
 
diff --git a/src/core/RangeType.h b/src/core/RangeType.h
index 2bbbeaa4b..816460687 100644
--- a/src/core/RangeType.h
+++ b/src/core/RangeType.h
@@ -1,13 +1,12 @@
 #pragma once
 
+#include <cmath>
+#include <cstdint>
 #include <iterator>
 #include <limits>
-#include <cstdint>
 #include <ostream>
-#include <cmath>
 
-class RangeType
-{
+class RangeType {
 private:
   double begin_val;
   double step_val;
@@ -18,19 +17,20 @@ public:
   static constexpr uint32_t MAX_RANGE_STEPS = 10000;
   static const RangeType EMPTY;
 
-  class iterator
-  {
-public:
+  class iterator {
+  public:
     // iterator_traits required types:
     using iterator_category = std::forward_iterator_tag;
     using value_type = double;
-    using difference_type = void; // type used by operator-(iterator), not implemented for forward iterator
-    using reference = value_type; // type used by operator*(), not actually a reference
-    using pointer = void;     // type used by operator->(), not implemented
-    iterator(const RangeType& range, iter_state state) :
-      range(range), val(range.begin_val), state(state),
-      num_values(range.numValues()), i_step(state == iter_state::RANGE_END ? num_values : 0)
-    {
+    using difference_type = void; // type used by operator-(iterator), not
+                                  // implemented for forward iterator
+    using reference =
+        value_type;       // type used by operator*(), not actually a reference
+    using pointer = void; // type used by operator->(), not implemented
+    iterator(const RangeType &range, iter_state state)
+        : range(range), val(range.begin_val), state(state),
+          num_values(range.numValues()),
+          i_step(state == iter_state::RANGE_END ? num_values : 0) {
       if (std::isnan(range.begin_val) || std::isnan(range.end_val) ||
           std::isnan(range.step_val) || range.step_val == 0) {
         i_step = num_values;
@@ -38,7 +38,7 @@ public:
       update_state();
     }
 
-    iterator& operator++() {
+    iterator &operator++() {
       val = range.begin_val + range.step_val * ++i_step;
       update_state();
       return *this;
@@ -46,13 +46,14 @@ public:
 
     reference operator*() { return val; }
 
-    bool operator==(const iterator& other) const {
+    bool operator==(const iterator &other) const {
       return (val == other.val || state != iter_state::RANGE_RUNNING) &&
              state == other.state && range == other.range;
     }
-    bool operator!=(const iterator& other) const { return !(*this == other); }
-private:
-    const RangeType& range;
+    bool operator!=(const iterator &other) const { return !(*this == other); }
+
+  private:
+    const RangeType &range;
     double val;
     iter_state state;
     const uint32_t num_values;
@@ -62,93 +63,103 @@ private:
         state = iter_state::RANGE_END;
       }
     }
-
   };
 
-  RangeType(const RangeType&) = delete;       // never copy, move instead
-  RangeType& operator=(const RangeType&) = delete; // never copy, move instead
-  RangeType(RangeType&&) = default;
-  RangeType& operator=(RangeType&&) = default;
+  RangeType(const RangeType &) = delete;            // never copy, move instead
+  RangeType &operator=(const RangeType &) = delete; // never copy, move instead
+  RangeType(RangeType &&) = default;
+  RangeType &operator=(RangeType &&) = default;
   ~RangeType() = default;
 
   explicit RangeType(double begin, double step, double end)
-    : begin_val(begin), step_val(step), end_val(end) {}
+      : begin_val(begin), step_val(step), end_val(end) {}
 
-  bool operator==(const RangeType& other) const {
+  bool operator==(const RangeType &other) const {
     auto n1 = this->numValues();
     auto n2 = other.numValues();
-    if (n1 == 0) return n2 == 0;
-    if (n2 == 0) return false;
-    return this == &other ||
-           (this->begin_val == other.begin_val &&
-            this->step_val == other.step_val &&
-            n1 == n2);
+    if (n1 == 0)
+      return n2 == 0;
+    if (n2 == 0)
+      return false;
+    return this == &other || (this->begin_val == other.begin_val &&
+                              this->step_val == other.step_val && n1 == n2);
   }
 
-  bool operator!=(const RangeType& other) const {
-    return !(*this == other);
-  }
+  bool operator!=(const RangeType &other) const { return !(*this == other); }
 
-  bool operator<(const RangeType& other) const {
+  bool operator<(const RangeType &other) const {
     auto n1 = this->numValues();
     auto n2 = other.numValues();
-    if (n1 == 0) return 0 < n2;
-    if (n2 == 0) return false;
+    if (n1 == 0)
+      return 0 < n2;
+    if (n2 == 0)
+      return false;
     return this->begin_val < other.begin_val ||
            (this->begin_val == other.begin_val &&
-            (this->step_val < other.step_val || (this->step_val == other.step_val && n1 < n2))
-           );
+            (this->step_val < other.step_val ||
+             (this->step_val == other.step_val && n1 < n2)));
   }
 
-  bool operator<=(const RangeType& other) const {
+  bool operator<=(const RangeType &other) const {
     auto n1 = this->numValues();
     auto n2 = other.numValues();
-    if (n1 == 0) return true; // (0 <= n2) is always true
-    if (n2 == 0) return false;
+    if (n1 == 0)
+      return true; // (0 <= n2) is always true
+    if (n2 == 0)
+      return false;
     return this->begin_val < other.begin_val ||
            (this->begin_val == other.begin_val &&
-            (this->step_val < other.step_val || (this->step_val == other.step_val && n1 <= n2))
-           );
+            (this->step_val < other.step_val ||
+             (this->step_val == other.step_val && n1 <= n2)));
   }
 
-  bool operator>(const RangeType& other) const {
+  bool operator>(const RangeType &other) const {
     auto n1 = this->numValues();
     auto n2 = other.numValues();
-    if (n2 == 0) return n1 > 0;
-    if (n1 == 0) return false;
+    if (n2 == 0)
+      return n1 > 0;
+    if (n1 == 0)
+      return false;
     return this->begin_val > other.begin_val ||
            (this->begin_val == other.begin_val &&
-            (this->step_val > other.step_val || (this->step_val == other.step_val && n1 > n2))
-           );
+            (this->step_val > other.step_val ||
+             (this->step_val == other.step_val && n1 > n2)));
   }
 
-  bool operator>=(const RangeType& other) const {
+  bool operator>=(const RangeType &other) const {
     auto n1 = this->numValues();
     auto n2 = other.numValues();
-    if (n2 == 0) return true; // (n1 >= 0) is always true
-    if (n1 == 0) return false;
+    if (n2 == 0)
+      return true; // (n1 >= 0) is always true
+    if (n1 == 0)
+      return false;
     return this->begin_val > other.begin_val ||
            (this->begin_val == other.begin_val &&
-            (this->step_val > other.step_val || (this->step_val == other.step_val && n1 >= n2))
-           );
+            (this->step_val > other.step_val ||
+             (this->step_val == other.step_val && n1 >= n2)));
   }
 
   [[nodiscard]] double begin_value() const { return begin_val; }
   [[nodiscard]] double step_value() const { return step_val; }
   [[nodiscard]] double end_value() const { return end_val; }
 
-  [[nodiscard]] iterator begin() const { return {*this, iter_state::RANGE_BEGIN}; }
+  [[nodiscard]] iterator begin() const {
+    return {*this, iter_state::RANGE_BEGIN};
+  }
   [[nodiscard]] iterator end() const { return {*this, iter_state::RANGE_END}; }
 
-  /// return number of values, max uint32_t value if step is 0 or range is infinite
+  /// return number of values, max uint32_t value if step is 0 or range is
+  /// infinite
   [[nodiscard]] uint32_t numValues() const {
     if (std::isnan(begin_val) || std::isnan(end_val) || std::isnan(step_val)) {
       return 0;
     }
     if (step_val < 0) {
-      if (begin_val < end_val) return 0;
+      if (begin_val < end_val)
+        return 0;
     } else {
-      if (begin_val > end_val) return 0;
+      if (begin_val > end_val)
+        return 0;
     }
     if ((begin_val == end_val) || std::isinf(step_val)) {
       return 1;
@@ -156,12 +167,12 @@ private:
     if (std::isinf(begin_val) || std::isinf(end_val) || step_val == 0) {
       return std::numeric_limits<uint32_t>::max();
     }
-    // Use nextafter to compensate for possible floating point inaccurary where result is just below a whole number.
+    // Use nextafter to compensate for possible floating point inaccurary where
+    // result is just below a whole number.
     const uint32_t max = std::numeric_limits<uint32_t>::max();
     uint32_t num_steps = std::nextafter((end_val - begin_val) / step_val, max);
     return (num_steps == max) ? max : num_steps + 1;
   }
-
 };
 
-std::ostream& operator<<(std::ostream& stream, const RangeType& r);
+std::ostream &operator<<(std::ostream &stream, const RangeType &r);
diff --git a/src/core/RenderNode.cc b/src/core/RenderNode.cc
index 320e67f27..c96cae1b7 100644
--- a/src/core/RenderNode.cc
+++ b/src/core/RenderNode.cc
@@ -25,22 +25,24 @@
  */
 
 #include "core/RenderNode.h"
-#include "core/module.h"
-#include "core/ModuleInstantiation.h"
 #include "core/Builtins.h"
 #include "core/Children.h"
+#include "core/ModuleInstantiation.h"
 #include "core/Parameters.h"
+#include "core/module.h"
 
-#include <utility>
-#include <memory>
 #include <boost/assign/std/vector.hpp>
+#include <memory>
+#include <utility>
 using namespace boost::assign; // bring 'operator+=()' into scope
 
-static std::shared_ptr<AbstractNode> builtin_render(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+static std::shared_ptr<AbstractNode>
+builtin_render(const ModuleInstantiation *inst, Arguments arguments,
+               const Children &children) {
   auto node = std::make_shared<RenderNode>(inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"convexity"});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {"convexity"});
   if (parameters["convexity"].type() == Value::Type::NUMBER) {
     node->convexity = static_cast<int>(parameters["convexity"].toDouble());
   }
@@ -48,15 +50,13 @@ static std::shared_ptr<AbstractNode> builtin_render(const ModuleInstantiation *i
   return children.instantiate(node);
 }
 
-std::string RenderNode::toString() const
-{
+std::string RenderNode::toString() const {
   return STR(this->name(), "(convexity = ", convexity, ")");
 }
 
-void register_builtin_render()
-{
+void register_builtin_render() {
   Builtins::init("render", new BuiltinModule(builtin_render),
-  {
-    "render(convexity = 1)",
-  });
+                 {
+                     "render(convexity = 1)",
+                 });
 }
diff --git a/src/core/RenderNode.h b/src/core/RenderNode.h
index 02f1e94b6..648e67c10 100644
--- a/src/core/RenderNode.h
+++ b/src/core/RenderNode.h
@@ -4,11 +4,10 @@
 #include "core/node.h"
 #include <string>
 
-class RenderNode : public AbstractNode
-{
+class RenderNode : public AbstractNode {
 public:
   VISITABLE();
-  RenderNode(const ModuleInstantiation *mi) : AbstractNode(mi) { }
+  RenderNode(const ModuleInstantiation *mi) : AbstractNode(mi) {}
   std::string toString() const override;
   std::string name() const override { return "render"; }
 
diff --git a/src/core/RenderVariables.cc b/src/core/RenderVariables.cc
index 719e6649c..a42a07087 100644
--- a/src/core/RenderVariables.cc
+++ b/src/core/RenderVariables.cc
@@ -1,19 +1,18 @@
 #include "core/RenderVariables.h"
-#include "core/Context.h"
 #include "core/BuiltinContext.h"
+#include "core/Context.h"
 
-void
-RenderVariables::applyToContext(ContextHandle<BuiltinContext>& context) const
-{
+void RenderVariables::applyToContext(
+    ContextHandle<BuiltinContext> &context) const {
   context->set_variable("$preview", preview);
   context->set_variable("$t", time);
 
   const auto vpr = camera.getVpr();
-  context->set_variable("$vpr",
-                        VectorType(context->session(), vpr.x(), vpr.y(), vpr.z()));
+  context->set_variable(
+      "$vpr", VectorType(context->session(), vpr.x(), vpr.y(), vpr.z()));
   const auto vpt = camera.getVpt();
-  context->set_variable("$vpt",
-                        VectorType(context->session(), vpt.x(), vpt.y(), vpt.z()));
+  context->set_variable(
+      "$vpt", VectorType(context->session(), vpt.x(), vpt.y(), vpt.z()));
   const auto vpd = camera.zoomValue();
   context->set_variable("$vpd", vpd);
   const auto vpf = camera.fovValue();
diff --git a/src/core/RenderVariables.h b/src/core/RenderVariables.h
index 7e3b117ec..e00026914 100644
--- a/src/core/RenderVariables.h
+++ b/src/core/RenderVariables.h
@@ -1,12 +1,11 @@
-#include "glview/Camera.h"
-#include "core/Context.h"
 #include "core/BuiltinContext.h"
+#include "core/Context.h"
+#include "glview/Camera.h"
 
-class RenderVariables
-{
+class RenderVariables {
 public:
   bool preview;
   double time;
   Camera camera;
-  void applyToContext(ContextHandle<BuiltinContext>& context) const;
+  void applyToContext(ContextHandle<BuiltinContext> &context) const;
 };
diff --git a/src/core/RoofNode.cc b/src/core/RoofNode.cc
index 979be260e..3df200a39 100644
--- a/src/core/RoofNode.cc
+++ b/src/core/RoofNode.cc
@@ -4,24 +4,23 @@
 #include "core/RoofNode.h"
 
 #include <algorithm>
-#include <utility>
 #include <memory>
 #include <sstream>
+#include <utility>
 
-#include "core/module.h"
-#include "core/ModuleInstantiation.h"
 #include "core/Builtins.h"
-#include "core/Parameters.h"
 #include "core/Children.h"
+#include "core/ModuleInstantiation.h"
+#include "core/Parameters.h"
+#include "core/module.h"
 
-static std::shared_ptr<AbstractNode> builtin_roof(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+static std::shared_ptr<AbstractNode>
+builtin_roof(const ModuleInstantiation *inst, Arguments arguments,
+             const Children &children) {
   auto node = std::make_shared<RoofNode>(inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(),
-                                            {"method"},
-                                            {"convexity"}
-                                            );
+  Parameters parameters = Parameters::parse(
+      std::move(arguments), inst->location(), {"method"}, {"convexity"});
 
   node->fn = parameters["$fn"].toDouble();
   node->fs = parameters["$fs"].toDouble();
@@ -49,30 +48,27 @@ static std::shared_ptr<AbstractNode> builtin_roof(const ModuleInstantiation *ins
   double tmp_convexity = 0.0;
   parameters["convexity"].getFiniteDouble(tmp_convexity);
   node->convexity = static_cast<int>(tmp_convexity);
-  if (node->convexity <= 0) node->convexity = 1;
+  if (node->convexity <= 0)
+    node->convexity = 1;
 
   children.instantiate(node);
 
   return node;
 }
 
-std::string RoofNode::toString() const
-{
+std::string RoofNode::toString() const {
   std::stringstream stream;
 
   stream << "roof(method = \"" << this->method << "\""
-         << ", $fa = " << this->fa
-         << ", $fs = " << this->fs
-         << ", $fn = " << this->fn
-         << ", convexity = " << this->convexity
+         << ", $fa = " << this->fa << ", $fs = " << this->fs
+         << ", $fn = " << this->fn << ", convexity = " << this->convexity
          << ")";
 
   return stream.str();
 }
 
-void register_builtin_roof()
-{
-  Builtins::init("roof", new BuiltinModule(builtin_roof, &Feature::ExperimentalRoof), {
-    "roof(method = \"voronoi\")"
-  });
+void register_builtin_roof() {
+  Builtins::init("roof",
+                 new BuiltinModule(builtin_roof, &Feature::ExperimentalRoof),
+                 {"roof(method = \"voronoi\")"});
 }
diff --git a/src/core/RoofNode.h b/src/core/RoofNode.h
index 127ea855f..7888881fe 100644
--- a/src/core/RoofNode.h
+++ b/src/core/RoofNode.h
@@ -10,8 +10,7 @@
 #include "core/ModuleInstantiation.h"
 #include "core/node.h"
 
-class RoofNode : public AbstractPolyNode
-{
+class RoofNode : public AbstractPolyNode {
 public:
   VISITABLE();
   RoofNode(const ModuleInstantiation *mi) : AbstractPolyNode(mi) {}
@@ -22,12 +21,12 @@ public:
   int convexity = 1;
   std::string method;
 
-  class roof_exception : public std::exception
-  {
-public:
+  class roof_exception : public std::exception {
+  public:
     roof_exception(std::string message) : m(std::move(message)) {}
-    std::string message() {return m;}
-private:
+    std::string message() { return m; }
+
+  private:
     std::string m;
   };
 };
diff --git a/src/core/RotateExtrudeNode.cc b/src/core/RotateExtrudeNode.cc
index 38ab24ef9..9f0fd1c41 100644
--- a/src/core/RotateExtrudeNode.cc
+++ b/src/core/RotateExtrudeNode.cc
@@ -25,30 +25,32 @@
  */
 
 #include "core/RotateExtrudeNode.h"
-#include "core/module.h"
-#include "core/ModuleInstantiation.h"
+#include "core/Builtins.h"
 #include "core/Children.h"
+#include "core/ModuleInstantiation.h"
 #include "core/Parameters.h"
-#include "utils/printutils.h"
-#include "io/fileutils.h"
-#include "core/Builtins.h"
+#include "core/module.h"
 #include "handle_dep.h"
+#include "io/fileutils.h"
+#include "utils/printutils.h"
+#include <boost/assign/std/vector.hpp>
+#include <cmath>
 #include <ios>
-#include <utility>
 #include <memory>
-#include <cmath>
 #include <sstream>
-#include <boost/assign/std/vector.hpp>
+#include <utility>
 using namespace boost::assign; // bring 'operator+=()' into scope
 
 namespace {
 
-std::shared_ptr<AbstractNode> builtin_rotate_extrude(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+std::shared_ptr<AbstractNode>
+builtin_rotate_extrude(const ModuleInstantiation *inst, Arguments arguments,
+                       const Children &children) {
   auto node = std::make_shared<RotateExtrudeNode>(inst);
 
-  const Parameters parameters = Parameters::parse(std::move(arguments), inst->location(),
-                                                  {"angle", "start"}, {"convexity", "a"});
+  const Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(),
+                        {"angle", "start"}, {"convexity", "a"});
 
   node->fn = parameters["$fn"].toDouble();
   node->fs = parameters["$fs"].toDouble();
@@ -61,44 +63,59 @@ std::shared_ptr<AbstractNode> builtin_rotate_extrude(const ModuleInstantiation *
   bool hasAngle = parameters[{"angle", "a"}].getFiniteDouble(node->angle);
   if (hasAngle) {
     node->start = 0;
-    if ((node->angle <= -360) || (node->angle > 360)) node->angle = 360;
+    if ((node->angle <= -360) || (node->angle > 360))
+      node->angle = 360;
   } else {
     node->angle = 360;
     node->start = 180;
   }
   bool hasStart = parameters["start"].getFiniteDouble(node->start);
   if (!hasAngle && !hasStart && (int)node->fn % 2 != 0) {
-    LOG(message_group::Deprecated, "In future releases, rotational extrusion without \"angle\" will start at zero, the +X axis.  Set start=180 to explicitly start on the -X axis.");
+    LOG(message_group::Deprecated,
+        "In future releases, rotational extrusion without \"angle\" will start "
+        "at zero, the +X axis.  Set start=180 to explicitly start on the -X "
+        "axis.");
   }
 
-  if (node->convexity <= 0) node->convexity = 2;
+  if (node->convexity <= 0)
+    node->convexity = 2;
 
   children.instantiate(node);
 
   return node;
 }
 
-}  // namespace
+} // namespace
 
-std::string RotateExtrudeNode::toString() const
-{
+std::string RotateExtrudeNode::toString() const {
   std::ostringstream stream;
 
-  stream << this->name() << "("
-    "angle = " << this->angle << ", "
-    "start = " << this->start << ", "
-    "convexity = " << this->convexity << ", "
-    "$fn = " << this->fn << ", "
-    "$fa = " << this->fa << ", "
-    "$fs = " << this->fs << ")";
+  stream << this->name()
+         << "("
+            "angle = "
+         << this->angle
+         << ", "
+            "start = "
+         << this->start
+         << ", "
+            "convexity = "
+         << this->convexity
+         << ", "
+            "$fn = "
+         << this->fn
+         << ", "
+            "$fa = "
+         << this->fa
+         << ", "
+            "$fs = "
+         << this->fs << ")";
 
   return stream.str();
 }
 
-void register_builtin_rotate_extrude()
-{
+void register_builtin_rotate_extrude() {
   Builtins::init("rotate_extrude", new BuiltinModule(builtin_rotate_extrude),
-  {
-    "rotate_extrude(angle = 360, convexity = 2)",
-  });
+                 {
+                     "rotate_extrude(angle = 360, convexity = 2)",
+                 });
 }
diff --git a/src/core/RotateExtrudeNode.h b/src/core/RotateExtrudeNode.h
index 0827326c7..7c72da2e5 100644
--- a/src/core/RotateExtrudeNode.h
+++ b/src/core/RotateExtrudeNode.h
@@ -2,12 +2,11 @@
 
 #include <string>
 
-#include "core/node.h"
 #include "core/ModuleInstantiation.h"
 #include "core/Value.h"
+#include "core/node.h"
 
-class RotateExtrudeNode : public AbstractPolyNode
-{
+class RotateExtrudeNode : public AbstractPolyNode {
 public:
   VISITABLE();
   RotateExtrudeNode(const ModuleInstantiation *mi) : AbstractPolyNode(mi) {
diff --git a/src/core/ScopeContext.cc b/src/core/ScopeContext.cc
index 9ce02825c..e93c9df8f 100644
--- a/src/core/ScopeContext.cc
+++ b/src/core/ScopeContext.cc
@@ -1,13 +1,13 @@
 #include "core/ScopeContext.h"
 #include "core/Expression.h"
 #include "core/Parameters.h"
-#include "utils/printutils.h"
 #include "core/SourceFileCache.h"
 #include "core/UserModule.h"
+#include "utils/printutils.h"
 
-#include <utility>
-#include <memory>
 #include <cmath>
+#include <memory>
+#include <utility>
 #include <vector>
 
 // Experimental code. See issue #399
@@ -55,21 +55,32 @@ void ScopeContext::evaluateAssignments(const AssignmentList& assignments)
 }
 #endif // if 0
 
-void ScopeContext::init()
-{
-  for (const auto& assignment : scope->assignments) {
-    if (assignment->getExpr()->isLiteral() && lookup_local_variable(assignment->getName())) {
-      LOG(message_group::Warning, assignment->location(), this->documentRoot(), "Parameter %1$s is overwritten with a literal", quoteVar(assignment->getName()));
+void ScopeContext::init() {
+  for (const auto &assignment : scope->assignments) {
+    if (assignment->getExpr()->isLiteral() &&
+        lookup_local_variable(assignment->getName())) {
+      LOG(message_group::Warning, assignment->location(), this->documentRoot(),
+          "Parameter %1$s is overwritten with a literal",
+          quoteVar(assignment->getName()));
     }
-    try{
-      set_variable(assignment->getName(), assignment->getExpr()->evaluate(get_shared_ptr()));
-    } catch (EvaluationException& e) {
+    try {
+      set_variable(assignment->getName(),
+                   assignment->getExpr()->evaluate(get_shared_ptr()));
+    } catch (EvaluationException &e) {
       if (e.traceDepth > 0) {
-        if (assignment->locationOfOverwrite().isNone()){
-          LOG(message_group::Trace, assignment->location(), this->documentRoot(), "assignment to %1$s", quoteVar(assignment->getName()));
+        if (assignment->locationOfOverwrite().isNone()) {
+          LOG(message_group::Trace, assignment->location(),
+              this->documentRoot(), "assignment to %1$s",
+              quoteVar(assignment->getName()));
         } else {
-          LOG(message_group::Trace, assignment->location(), this->documentRoot(), "overwritten assignment to %1$s (this is where the assignment is evaluated)", quoteVar(assignment->getName()));
-          LOG(message_group::Trace, assignment->locationOfOverwrite(), this->documentRoot(), "overwriting assignment to %1$s", quoteVar(assignment->getName()));
+          LOG(message_group::Trace, assignment->location(),
+              this->documentRoot(),
+              "overwritten assignment to %1$s (this is where the assignment is "
+              "evaluated)",
+              quoteVar(assignment->getName()));
+          LOG(message_group::Trace, assignment->locationOfOverwrite(),
+              this->documentRoot(), "overwriting assignment to %1$s",
+              quoteVar(assignment->getName()));
         }
         e.traceDepth--;
       }
@@ -77,78 +88,93 @@ void ScopeContext::init()
     }
   }
 
-// Experimental code. See issue #399
-//	evaluateAssignments(module.scope.assignments);
+  // Experimental code. See issue #399
+  //	evaluateAssignments(module.scope.assignments);
 }
 
-boost::optional<CallableFunction> ScopeContext::lookup_local_function(const std::string& name, const Location& loc) const
-{
-  const auto& search = scope->functions.find(name);
+boost::optional<CallableFunction>
+ScopeContext::lookup_local_function(const std::string &name,
+                                    const Location &loc) const {
+  const auto &search = scope->functions.find(name);
   if (search != scope->functions.end()) {
-    return CallableFunction{CallableUserFunction{get_shared_ptr(), search->second.get()}};
+    return CallableFunction{
+        CallableUserFunction{get_shared_ptr(), search->second.get()}};
   }
   return Context::lookup_local_function(name, loc);
 }
 
-boost::optional<InstantiableModule> ScopeContext::lookup_local_module(const std::string& name, const Location& loc) const
-{
-  const auto& search = scope->modules.find(name);
+boost::optional<InstantiableModule>
+ScopeContext::lookup_local_module(const std::string &name,
+                                  const Location &loc) const {
+  const auto &search = scope->modules.find(name);
   if (search != scope->modules.end()) {
     return InstantiableModule{get_shared_ptr(), search->second.get()};
   }
   return Context::lookup_local_module(name, loc);
 }
 
-UserModuleContext::UserModuleContext(const std::shared_ptr<const Context>& parent, const UserModule *module, const Location& loc, Arguments arguments, Children children) :
-  ScopeContext(parent, &module->body),
-  children(std::move(children))
-{
+UserModuleContext::UserModuleContext(
+    const std::shared_ptr<const Context> &parent, const UserModule *module,
+    const Location &loc, Arguments arguments, Children children)
+    : ScopeContext(parent, &module->body), children(std::move(children)) {
   set_variable("$children", Value(double(this->children.size())));
   set_variable("$parent_modules", Value(double(StaticModuleNameStack::size())));
-  apply_variables(Parameters::parse(std::move(arguments), loc, module->parameters, parent).to_context_frame());
+  apply_variables(
+      Parameters::parse(std::move(arguments), loc, module->parameters, parent)
+          .to_context_frame());
 }
 
-std::vector<const std::shared_ptr<const Context> *> UserModuleContext::list_referenced_contexts() const
-{
-  std::vector<const std::shared_ptr<const Context> *> output = Context::list_referenced_contexts();
+std::vector<const std::shared_ptr<const Context> *>
+UserModuleContext::list_referenced_contexts() const {
+  std::vector<const std::shared_ptr<const Context> *> output =
+      Context::list_referenced_contexts();
   output.push_back(&children.getContext());
   return output;
 }
 
-boost::optional<CallableFunction> FileContext::lookup_local_function(const std::string& name, const Location& loc) const
-{
+boost::optional<CallableFunction>
+FileContext::lookup_local_function(const std::string &name,
+                                   const Location &loc) const {
   auto result = ScopeContext::lookup_local_function(name, loc);
   if (result) {
     return result;
   }
 
-  for (const auto& m : source_file->usedlibs) {
-    // usedmod is nullptr if the library wasn't be compiled (error or file-not-found)
+  for (const auto &m : source_file->usedlibs) {
+    // usedmod is nullptr if the library wasn't be compiled (error or
+    // file-not-found)
     auto usedmod = SourceFileCache::instance()->lookup(m);
-    if (usedmod && usedmod->scope.functions.find(name) != usedmod->scope.functions.end()) {
-      ContextHandle<FileContext> context{Context::create<FileContext>(this->parent, usedmod)};
+    if (usedmod &&
+        usedmod->scope.functions.find(name) != usedmod->scope.functions.end()) {
+      ContextHandle<FileContext> context{
+          Context::create<FileContext>(this->parent, usedmod)};
 #ifdef DEBUG
       PRINTDB("FileContext for function %s::%s:", m % name);
       PRINTDB("%s", context->dump());
 #endif
-      return CallableFunction{CallableUserFunction{*context, usedmod->scope.functions[name].get()}};
+      return CallableFunction{
+          CallableUserFunction{*context, usedmod->scope.functions[name].get()}};
     }
   }
   return boost::none;
 }
 
-boost::optional<InstantiableModule> FileContext::lookup_local_module(const std::string& name, const Location& loc) const
-{
+boost::optional<InstantiableModule>
+FileContext::lookup_local_module(const std::string &name,
+                                 const Location &loc) const {
   auto result = ScopeContext::lookup_local_module(name, loc);
   if (result) {
     return result;
   }
 
-  for (const auto& m : source_file->usedlibs) {
-    // usedmod is nullptr if the library wasn't be compiled (error or file-not-found)
+  for (const auto &m : source_file->usedlibs) {
+    // usedmod is nullptr if the library wasn't be compiled (error or
+    // file-not-found)
     auto usedmod = SourceFileCache::instance()->lookup(m);
-    if (usedmod && usedmod->scope.modules.find(name) != usedmod->scope.modules.end()) {
-      ContextHandle<FileContext> context{Context::create<FileContext>(this->parent, usedmod)};
+    if (usedmod &&
+        usedmod->scope.modules.find(name) != usedmod->scope.modules.end()) {
+      ContextHandle<FileContext> context{
+          Context::create<FileContext>(this->parent, usedmod)};
 #ifdef DEBUG
       PRINTDB("FileContext for module %s::%s:", m % name);
       PRINTDB("%s", context->dump());
diff --git a/src/core/ScopeContext.h b/src/core/ScopeContext.h
index a52281741..fca858a0a 100644
--- a/src/core/ScopeContext.h
+++ b/src/core/ScopeContext.h
@@ -4,44 +4,48 @@
 #include <string>
 #include <vector>
 
-#include "core/Arguments.h"
 #include "core/AST.h"
+#include "core/Arguments.h"
 #include "core/Children.h"
 #include "core/Context.h"
 #include "core/SourceFile.h"
 
 class UserModule;
 
-class ScopeContext : public Context
-{
+class ScopeContext : public Context {
 public:
   void init() override;
-  boost::optional<CallableFunction> lookup_local_function(const std::string& name, const Location& loc) const override;
-  boost::optional<InstantiableModule> lookup_local_module(const std::string& name, const Location& loc) const override;
+  boost::optional<CallableFunction>
+  lookup_local_function(const std::string &name,
+                        const Location &loc) const override;
+  boost::optional<InstantiableModule>
+  lookup_local_module(const std::string &name,
+                      const Location &loc) const override;
 
 protected:
-  ScopeContext(const std::shared_ptr<const Context>& parent, const LocalScope *scope) :
-    Context(parent),
-    scope(scope)
-  {}
+  ScopeContext(const std::shared_ptr<const Context> &parent,
+               const LocalScope *scope)
+      : Context(parent), scope(scope) {}
 
 private:
-// Experimental code. See issue #399
-//	void evaluateAssignments(const AssignmentList &assignments);
+  // Experimental code. See issue #399
+  //	void evaluateAssignments(const AssignmentList &assignments);
 
   const LocalScope *scope;
 
   friend class Context;
 };
 
-class UserModuleContext : public ScopeContext
-{
+class UserModuleContext : public ScopeContext {
 public:
   const Children *user_module_children() const override { return &children; }
-  std::vector<const std::shared_ptr<const Context> *> list_referenced_contexts() const override;
+  std::vector<const std::shared_ptr<const Context> *>
+  list_referenced_contexts() const override;
 
 protected:
-  UserModuleContext(const std::shared_ptr<const Context>& parent, const UserModule *module, const Location& loc, Arguments arguments, Children children);
+  UserModuleContext(const std::shared_ptr<const Context> &parent,
+                    const UserModule *module, const Location &loc,
+                    Arguments arguments, Children children);
 
 private:
   Children children;
@@ -49,17 +53,19 @@ private:
   friend class Context;
 };
 
-class FileContext : public ScopeContext
-{
+class FileContext : public ScopeContext {
 public:
-  boost::optional<CallableFunction> lookup_local_function(const std::string& name, const Location& loc) const override;
-  boost::optional<InstantiableModule> lookup_local_module(const std::string& name, const Location& loc) const override;
+  boost::optional<CallableFunction>
+  lookup_local_function(const std::string &name,
+                        const Location &loc) const override;
+  boost::optional<InstantiableModule>
+  lookup_local_module(const std::string &name,
+                      const Location &loc) const override;
 
 protected:
-  FileContext(const std::shared_ptr<const Context>& parent, const SourceFile *source_file) :
-    ScopeContext(parent, &source_file->scope),
-    source_file(source_file)
-  {}
+  FileContext(const std::shared_ptr<const Context> &parent,
+              const SourceFile *source_file)
+      : ScopeContext(parent, &source_file->scope), source_file(source_file) {}
 
 private:
   const SourceFile *source_file;
diff --git a/src/core/Selection.h b/src/core/Selection.h
index 543cdf0e3..7cb08cce2 100644
--- a/src/core/Selection.h
+++ b/src/core/Selection.h
@@ -27,14 +27,10 @@
 #pragma once
 #include "geometry/linalg.h"
 
-enum class SelectionType {
-  SELECTION_POINT,
-  SELECTION_LINE
-};
+enum class SelectionType { SELECTION_POINT, SELECTION_LINE };
 
 struct SelectedObject {
   SelectionType type;
   Vector3d p1;
   Vector3d p2;
 };
-
diff --git a/src/core/Settings.cc b/src/core/Settings.cc
index 3fb113863..8f8f92298 100644
--- a/src/core/Settings.cc
+++ b/src/core/Settings.cc
@@ -1,19 +1,19 @@
 #include "core/Settings.h"
 
-#include <ostream>
+#include <boost/algorithm/string.hpp>
+#include <boost/lexical_cast.hpp>
+#include <boost/range/adaptors.hpp>
 #include <cassert>
 #include <cstddef>
 #include <istream>
 #include <iterator>
+#include <ostream>
 #include <string>
 #include <utility>
 #include <vector>
-#include <boost/algorithm/string.hpp>
-#include <boost/lexical_cast.hpp>
-#include <boost/range/adaptors.hpp>
 
-#include "io/export_enums.h"
 #include "io/export.h"
+#include "io/export_enums.h"
 #include "utils/printutils.h"
 
 #include "json/json.hpp"
@@ -26,13 +26,15 @@ namespace {
 
 std::vector<SettingsEntryBase *> entries;
 
-std::vector<SettingsEntryEnum<std::string>::Item> createFileFormatItems(std::vector<FileFormat> formats) {
+std::vector<SettingsEntryEnum<std::string>::Item>
+createFileFormatItems(std::vector<FileFormat> formats) {
   std::vector<SettingsEntryEnum<std::string>::Item> items;
   std::transform(formats.begin(), formats.end(), std::back_inserter(items),
-                 [](const FileFormat& format){
-        const FileFormatInfo& info = fileformat::info(format);
-        return SettingsEntryEnum<std::string>::Item{info.identifier, info.identifier, info.description};
-      });
+                 [](const FileFormat &format) {
+                   const FileFormatInfo &info = fileformat::info(format);
+                   return SettingsEntryEnum<std::string>::Item{
+                       info.identifier, info.identifier, info.description};
+                 });
   return items;
 }
 
@@ -54,26 +56,22 @@ std::vector<SettingsEntryEnum<std::string>::Item> axisValues() {
 
 } // namespace
 
-void Settings::visit(const SettingsVisitor& visitor)
-{
+void Settings::visit(const SettingsVisitor &visitor) {
   for (SettingsEntryBase *entry : entries) {
     visitor.handle(*entry);
   }
 }
 
-SettingsEntryBase::SettingsEntryBase(std::string category, std::string name) :
-  _category(std::move(category)), _name(std::move(name))
-{
+SettingsEntryBase::SettingsEntryBase(std::string category, std::string name)
+    : _category(std::move(category)), _name(std::move(name)) {
   entries.push_back(this);
 }
 
-std::string SettingsEntryBool::encode() const
-{
+std::string SettingsEntryBool::encode() const {
   return _value ? "true" : "false";
 }
 
-const bool SettingsEntryBool::decode(const std::string& encoded) const
-{
+const bool SettingsEntryBool::decode(const std::string &encoded) const {
   std::string trimmed = boost::algorithm::trim_copy(encoded);
   if (trimmed == "true") {
     return true;
@@ -82,42 +80,33 @@ const bool SettingsEntryBool::decode(const std::string& encoded) const
   } else {
     try {
       return boost::lexical_cast<bool>(trimmed);
-    } catch (const boost::bad_lexical_cast&) {
+    } catch (const boost::bad_lexical_cast &) {
       return defaultValue();
     }
   }
 }
 
-std::string SettingsEntryInt::encode() const
-{
-  return STR(_value);
-}
+std::string SettingsEntryInt::encode() const { return STR(_value); }
 
-const int SettingsEntryInt::decode(const std::string& encoded) const
-{
+const int SettingsEntryInt::decode(const std::string &encoded) const {
   try {
     return boost::lexical_cast<int>(boost::algorithm::trim_copy(encoded));
-  } catch (const boost::bad_lexical_cast&) {
+  } catch (const boost::bad_lexical_cast &) {
     return defaultValue();
   }
 }
 
-std::string SettingsEntryDouble::encode() const
-{
-  return STR(_value);
-}
+std::string SettingsEntryDouble::encode() const { return STR(_value); }
 
-const double SettingsEntryDouble::decode(const std::string& encoded) const
-{
+const double SettingsEntryDouble::decode(const std::string &encoded) const {
   try {
     return boost::lexical_cast<double>(boost::algorithm::trim_copy(encoded));
-  } catch (const boost::bad_lexical_cast&) {
+  } catch (const boost::bad_lexical_cast &) {
     return defaultValue();
   }
 }
 
-std::ostream& operator<<(std::ostream& stream, const LocalAppParameter& param)
-{
+std::ostream &operator<<(std::ostream &stream, const LocalAppParameter &param) {
   json data;
   data["type"] = static_cast<int>(param.type);
   if (!param.value.empty()) {
@@ -127,8 +116,7 @@ std::ostream& operator<<(std::ostream& stream, const LocalAppParameter& param)
   return stream;
 }
 
-std::istream& operator>>(std::istream& stream, LocalAppParameter& param)
-{
+std::istream &operator>>(std::istream &stream, LocalAppParameter &param) {
   try {
     json data;
     stream >> data;
@@ -136,137 +124,210 @@ std::istream& operator>>(std::istream& stream, LocalAppParameter& param)
     if (data.contains("value")) {
       param.value = data["value"];
     }
-  } catch (const json::exception& e) {
+  } catch (const json::exception &e) {
     param.type = LocalAppParameterType::invalid;
     param.value = "";
   }
   return stream;
 }
 
-SettingsEntryBool Settings::showWarningsIn3dView("3dview", "showWarningsIn3dView", true);
-SettingsEntryBool Settings::mouseCentricZoom("3dview", "mouseCentricZoom", true);
-SettingsEntryBool Settings::mouseSwapButtons("3dview", "mouseSwapButtons", false);
-SettingsEntryInt Settings::indentationWidth("editor", "indentationWidth", 1, 16, 4);
+SettingsEntryBool Settings::showWarningsIn3dView("3dview",
+                                                 "showWarningsIn3dView", true);
+SettingsEntryBool Settings::mouseCentricZoom("3dview", "mouseCentricZoom",
+                                             true);
+SettingsEntryBool Settings::mouseSwapButtons("3dview", "mouseSwapButtons",
+                                             false);
+SettingsEntryInt Settings::indentationWidth("editor", "indentationWidth", 1, 16,
+                                            4);
 SettingsEntryInt Settings::tabWidth("editor", "tabWidth", 1, 16, 4);
-SettingsEntryEnum<std::string> Settings::lineWrap("editor", "lineWrap", {
-    {"None", "none", _("None")},
-    {"Char", "char", _("Wrap at character boundaries")},
-    {"Word", "word", _("Wrap at word boundaries")}
-  }, "Word");
-SettingsEntryEnum<std::string> Settings::lineWrapIndentationStyle("editor", "lineWrapIndentationStyle", {
-    {"Fixed",    "fixed",    _("Fixed")},
-    {"Same",     "same",     _("Same")},
-    {"Indented", "indented", _("Indented")}
-  }, "Fixed");
-SettingsEntryInt Settings::lineWrapIndentation("editor", "lineWrapIndentation", 0, 999, 4);
-SettingsEntryEnum<std::string> Settings::lineWrapVisualizationBegin("editor", "lineWrapVisualizationBegin", {
-    {"None",   "none",   _("None")},
-    {"Text",   "text", _("Text")},
-    {"Border", "border", _("Border")},
-    {"Margin", "margin", _("Margin")}
-  }, "None");
-SettingsEntryEnum<std::string> Settings::lineWrapVisualizationEnd("editor", "lineWrapVisualizationEnd", {
-    {"None",   "none",   _("None")},
-    {"Text",   "text",   _("Text")},
-    {"Border", "border", _("Border")},
-    {"Margin", "margin", _("Margin")}
-  }, "Border");
-SettingsEntryEnum<std::string> Settings::showWhitespace("editor", "showWhitespaces", {
-    {"Never",            "never",        _("Never")},
-    {"Always",           "always",       _("Always")},
-    {"AfterIndentation", "after-indent", _("After indentation")}
-  }, "Never");
-SettingsEntryInt Settings::showWhitespaceSize("editor", "showWhitespacesSize", 1, 16, 2);
+SettingsEntryEnum<std::string>
+    Settings::lineWrap("editor", "lineWrap",
+                       {{"None", "none", _("None")},
+                        {"Char", "char", _("Wrap at character boundaries")},
+                        {"Word", "word", _("Wrap at word boundaries")}},
+                       "Word");
+SettingsEntryEnum<std::string> Settings::lineWrapIndentationStyle(
+    "editor", "lineWrapIndentationStyle",
+    {{"Fixed", "fixed", _("Fixed")},
+     {"Same", "same", _("Same")},
+     {"Indented", "indented", _("Indented")}},
+    "Fixed");
+SettingsEntryInt Settings::lineWrapIndentation("editor", "lineWrapIndentation",
+                                               0, 999, 4);
+SettingsEntryEnum<std::string>
+    Settings::lineWrapVisualizationBegin("editor", "lineWrapVisualizationBegin",
+                                         {{"None", "none", _("None")},
+                                          {"Text", "text", _("Text")},
+                                          {"Border", "border", _("Border")},
+                                          {"Margin", "margin", _("Margin")}},
+                                         "None");
+SettingsEntryEnum<std::string>
+    Settings::lineWrapVisualizationEnd("editor", "lineWrapVisualizationEnd",
+                                       {{"None", "none", _("None")},
+                                        {"Text", "text", _("Text")},
+                                        {"Border", "border", _("Border")},
+                                        {"Margin", "margin", _("Margin")}},
+                                       "Border");
+SettingsEntryEnum<std::string> Settings::showWhitespace(
+    "editor", "showWhitespaces",
+    {{"Never", "never", _("Never")},
+     {"Always", "always", _("Always")},
+     {"AfterIndentation", "after-indent", _("After indentation")}},
+    "Never");
+SettingsEntryInt Settings::showWhitespaceSize("editor", "showWhitespacesSize",
+                                              1, 16, 2);
 SettingsEntryBool Settings::autoIndent("editor", "autoIndent", true);
-SettingsEntryBool Settings::backspaceUnindents("editor", "backspaceUnindents", false);
-SettingsEntryEnum<std::string> Settings::indentStyle("editor", "indentStyle", {
-    {"Spaces", "spaces", _("Spaces")},
-    {"Tabs",   "tabs",   _("Tabs")}
-  }, "spaces");
-SettingsEntryEnum<std::string> Settings::tabKeyFunction("editor", "tabKeyFunction", {
-    {"Indent",    "indent", _("Indent")},
-    {"InsertTab", "tab",    _("Insert Tab")}
-  }, "Indent");
-SettingsEntryBool Settings::highlightCurrentLine("editor", "highlightCurrentLine", true);
-SettingsEntryBool Settings::enableBraceMatching("editor", "enableBraceMatching", true);
-SettingsEntryBool Settings::enableLineNumbers("editor", "enableLineNumbers", true);
-SettingsEntryBool Settings::enableNumberScrollWheel("editor", "enableNumberScrollWheel", true);
-SettingsEntryEnum<std::string> Settings::modifierNumberScrollWheel("editor", "modifierNumberScrollWheel", {
-    {"Alt",               "alt",               _("Alt")},
-    {"Left Mouse Button", "left-mouse-button", _("Left Mouse Button")},
-    {"Either",            "either",            _("Either")}
-  }, "Alt");
-
-SettingsEntryString Settings::defaultPrintService("printing", "printService", "NONE");
-SettingsEntryBool Settings::enableRemotePrintServices("printing", "enableRemotePrintServices", false);
-SettingsEntryBool Settings::printServiceAlwaysShowDialog("printing", "always-show-dialog", false);
-SettingsEntryString Settings::printServiceName("printing", "printServiceName", "");
+SettingsEntryBool Settings::backspaceUnindents("editor", "backspaceUnindents",
+                                               false);
+SettingsEntryEnum<std::string> Settings::indentStyle(
+    "editor", "indentStyle",
+    {{"Spaces", "spaces", _("Spaces")}, {"Tabs", "tabs", _("Tabs")}}, "spaces");
+SettingsEntryEnum<std::string> Settings::tabKeyFunction(
+    "editor", "tabKeyFunction",
+    {{"Indent", "indent", _("Indent")}, {"InsertTab", "tab", _("Insert Tab")}},
+    "Indent");
+SettingsEntryBool Settings::highlightCurrentLine("editor",
+                                                 "highlightCurrentLine", true);
+SettingsEntryBool Settings::enableBraceMatching("editor", "enableBraceMatching",
+                                                true);
+SettingsEntryBool Settings::enableLineNumbers("editor", "enableLineNumbers",
+                                              true);
+SettingsEntryBool Settings::enableNumberScrollWheel("editor",
+                                                    "enableNumberScrollWheel",
+                                                    true);
+SettingsEntryEnum<std::string> Settings::modifierNumberScrollWheel(
+    "editor", "modifierNumberScrollWheel",
+    {{"Alt", "alt", _("Alt")},
+     {"Left Mouse Button", "left-mouse-button", _("Left Mouse Button")},
+     {"Either", "either", _("Either")}},
+    "Alt");
+
+SettingsEntryString Settings::defaultPrintService("printing", "printService",
+                                                  "NONE");
+SettingsEntryBool
+    Settings::enableRemotePrintServices("printing", "enableRemotePrintServices",
+                                        false);
+SettingsEntryBool Settings::printServiceAlwaysShowDialog("printing",
+                                                         "always-show-dialog",
+                                                         false);
+SettingsEntryString Settings::printServiceName("printing", "printServiceName",
+                                               "");
 SettingsEntryEnum<std::string> Settings::printServiceFileFormat(
-  "printing", "printServiceFileFormat", createFileFormatItems(fileformat::all3D()),
-  fileformat::info(FileFormat::ASCII_STL).description);
+    "printing", "printServiceFileFormat",
+    createFileFormatItems(fileformat::all3D()),
+    fileformat::info(FileFormat::ASCII_STL).description);
 
 SettingsEntryString Settings::octoPrintUrl("printing", "octoPrintUrl", "");
-SettingsEntryString Settings::octoPrintApiKey("printing", "octoPrintApiKey", "");
-SettingsEntryEnum<std::string> Settings::octoPrintAction("printing", "octoPrintAction", {
-    {"upload", "upload", _("Upload only")},
-    {"slice",  "slice",  _("Upload & Slice")},
-    {"select", "select", _("Upload, Slice & Select for printing")},
-    {"print",  "print",  _("Upload, Slice & Start printing")}
-  }, "upload");
-SettingsEntryString Settings::octoPrintSlicerEngine("printing", "octoPrintSlicerEngine", "");
-SettingsEntryString Settings::octoPrintSlicerEngineDesc("printing", "octoPrintSlicerEngineDesc", "");
-SettingsEntryString Settings::octoPrintSlicerProfile("printing", "octoPrintSlicerProfile", "");
-SettingsEntryString Settings::octoPrintSlicerProfileDesc("printing", "octoPrintSlicerProfileDesc", "");
+SettingsEntryString Settings::octoPrintApiKey("printing", "octoPrintApiKey",
+                                              "");
+SettingsEntryEnum<std::string> Settings::octoPrintAction(
+    "printing", "octoPrintAction",
+    {{"upload", "upload", _("Upload only")},
+     {"slice", "slice", _("Upload & Slice")},
+     {"select", "select", _("Upload, Slice & Select for printing")},
+     {"print", "print", _("Upload, Slice & Start printing")}},
+    "upload");
+SettingsEntryString
+    Settings::octoPrintSlicerEngine("printing", "octoPrintSlicerEngine", "");
+SettingsEntryString
+    Settings::octoPrintSlicerEngineDesc("printing", "octoPrintSlicerEngineDesc",
+                                        "");
+SettingsEntryString
+    Settings::octoPrintSlicerProfile("printing", "octoPrintSlicerProfile", "");
+SettingsEntryString
+    Settings::octoPrintSlicerProfileDesc("printing",
+                                         "octoPrintSlicerProfileDesc", "");
 SettingsEntryEnum<std::string> Settings::octoPrintFileFormat(
-  "printing", "octoPrintFileFormat",
-  createFileFormatItems({FileFormat::ASCII_STL, FileFormat::BINARY_STL, FileFormat::_3MF, FileFormat::OFF}),
-  fileformat::info(FileFormat::ASCII_STL).description);
-
-SettingsEntryString Settings::localAppExecutable("printing", "localAppExecutable", "");
-SettingsEntryString Settings::localAppTempDir("printing", "localAppTempDir", "");
+    "printing", "octoPrintFileFormat",
+    createFileFormatItems({FileFormat::ASCII_STL, FileFormat::BINARY_STL,
+                           FileFormat::_3MF, FileFormat::OFF}),
+    fileformat::info(FileFormat::ASCII_STL).description);
+
+SettingsEntryString Settings::localAppExecutable("printing",
+                                                 "localAppExecutable", "");
+SettingsEntryString Settings::localAppTempDir("printing", "localAppTempDir",
+                                              "");
 SettingsEntryEnum<std::string> Settings::localAppFileFormat(
-  "printing", "localAppFileFormat", createFileFormatItems(fileformat::all3D()),
-  fileformat::info(FileFormat::ASCII_STL).description);
-SettingsEntryList<LocalAppParameter> Settings::localAppParameterList("printing", "localAppParameterList");
-
-SettingsEntryEnum<std::string> Settings::renderBackend3D("advanced", "renderBackend3D", {
-    {"CGAL",     "cgal",     "CGAL (old/slow)"},
-    {"Manifold", "manifold", "Manifold (new/fast)"}
-  }, "CGAL");
-SettingsEntryEnum<std::string> Settings::toolbarExport3D("advanced", "toolbarExport3D", createFileFormatItems(fileformat::all3D()), fileformat::info(FileFormat::ASCII_STL).description);
-SettingsEntryEnum<std::string> Settings::toolbarExport2D("advanced", "toolbarExport2D", createFileFormatItems(fileformat::all2D()), fileformat::info(FileFormat::DXF).description);
+    "printing", "localAppFileFormat",
+    createFileFormatItems(fileformat::all3D()),
+    fileformat::info(FileFormat::ASCII_STL).description);
+SettingsEntryList<LocalAppParameter>
+    Settings::localAppParameterList("printing", "localAppParameterList");
+
+SettingsEntryEnum<std::string>
+    Settings::renderBackend3D("advanced", "renderBackend3D",
+                              {{"CGAL", "cgal", "CGAL (old/slow)"},
+                               {"Manifold", "manifold", "Manifold (new/fast)"}},
+                              "CGAL");
+SettingsEntryEnum<std::string> Settings::toolbarExport3D(
+    "advanced", "toolbarExport3D", createFileFormatItems(fileformat::all3D()),
+    fileformat::info(FileFormat::ASCII_STL).description);
+SettingsEntryEnum<std::string>
+    Settings::toolbarExport2D("advanced", "toolbarExport2D",
+                              createFileFormatItems(fileformat::all2D()),
+                              fileformat::info(FileFormat::DXF).description);
 
 SettingsEntryBool Settings::summaryCamera("summary", "camera", false);
 SettingsEntryBool Settings::summaryArea("summary", "measurementArea", false);
 SettingsEntryBool Settings::summaryBoundingBox("summary", "boundingBox", false);
 
-SettingsEntryBool Settings::inputEnableDriverHIDAPI("input", "enableDriverHIDAPI", false);
-SettingsEntryBool Settings::inputEnableDriverHIDAPILog("input", "enableDriverHIDAPILog", false);
-SettingsEntryBool Settings::inputEnableDriverSPNAV("input", "enableDriverSPNAV", false);
-SettingsEntryBool Settings::inputEnableDriverJOYSTICK("input", "enableDriverJOYSTICK", false);
-SettingsEntryBool Settings::inputEnableDriverQGAMEPAD("input", "enableDriverQGAMEPAD", false);
-SettingsEntryBool Settings::inputEnableDriverDBUS("input", "enableDriverDBUS", false);
-
-SettingsEntryEnum<std::string> Settings::inputTranslationX("input", "translationX", axisValues(), "+1");
-SettingsEntryEnum<std::string> Settings::inputTranslationY("input", "translationY", axisValues(), "-2");
-SettingsEntryEnum<std::string> Settings::inputTranslationZ("input", "translationZ", axisValues(), "-3");
-SettingsEntryEnum<std::string> Settings::inputTranslationXVPRel("input", "translationXVPRel", axisValues(), "None");
-SettingsEntryEnum<std::string> Settings::inputTranslationYVPRel("input", "translationYVPRel", axisValues(), "None");
-SettingsEntryEnum<std::string> Settings::inputTranslationZVPRel("input", "translationZVPRel", axisValues(), "None");
-SettingsEntryEnum<std::string> Settings::inputRotateX("input", "rotateX", axisValues(), "+4");
-SettingsEntryEnum<std::string> Settings::inputRotateY("input", "rotateY", axisValues(), "-5");
-SettingsEntryEnum<std::string> Settings::inputRotateZ("input", "rotateZ", axisValues(), "-6");
-SettingsEntryEnum<std::string> Settings::inputRotateXVPRel("input", "rotateXVPRel", axisValues(), "None");
-SettingsEntryEnum<std::string> Settings::inputRotateYVPRel("input", "rotateYVPRel", axisValues(), "None");
-SettingsEntryEnum<std::string> Settings::inputRotateZVPRel("input", "rotateZVPRel", axisValues(), "None");
-SettingsEntryEnum<std::string> Settings::inputZoom("input", "zoom", axisValues(), "None");
-SettingsEntryEnum<std::string> Settings::inputZoom2("input", "zoom2", axisValues(), "None");
-
-SettingsEntryDouble Settings::inputTranslationGain("input", "translationGain", 0.01, 0.01, 9.99, 1.00);
-SettingsEntryDouble Settings::inputTranslationVPRelGain("input", "translationVPRelGain", 0.01, 0.01, 9.99, 1.00);
-SettingsEntryDouble Settings::inputRotateGain("input", "rotateGain", 0.01, 0.01, 9.99, 1.00);
-SettingsEntryDouble Settings::inputRotateVPRelGain("input", "rotateVPRelGain", 0.01, 0.01, 9.99, 1.00);
-SettingsEntryDouble Settings::inputZoomGain("input", "zoomGain", 0.1, 0.1, 99.9, 1.0);
+SettingsEntryBool
+    Settings::inputEnableDriverHIDAPI("input", "enableDriverHIDAPI", false);
+SettingsEntryBool Settings::inputEnableDriverHIDAPILog("input",
+                                                       "enableDriverHIDAPILog",
+                                                       false);
+SettingsEntryBool Settings::inputEnableDriverSPNAV("input", "enableDriverSPNAV",
+                                                   false);
+SettingsEntryBool
+    Settings::inputEnableDriverJOYSTICK("input", "enableDriverJOYSTICK", false);
+SettingsEntryBool
+    Settings::inputEnableDriverQGAMEPAD("input", "enableDriverQGAMEPAD", false);
+SettingsEntryBool Settings::inputEnableDriverDBUS("input", "enableDriverDBUS",
+                                                  false);
+
+SettingsEntryEnum<std::string>
+    Settings::inputTranslationX("input", "translationX", axisValues(), "+1");
+SettingsEntryEnum<std::string>
+    Settings::inputTranslationY("input", "translationY", axisValues(), "-2");
+SettingsEntryEnum<std::string>
+    Settings::inputTranslationZ("input", "translationZ", axisValues(), "-3");
+SettingsEntryEnum<std::string>
+    Settings::inputTranslationXVPRel("input", "translationXVPRel", axisValues(),
+                                     "None");
+SettingsEntryEnum<std::string>
+    Settings::inputTranslationYVPRel("input", "translationYVPRel", axisValues(),
+                                     "None");
+SettingsEntryEnum<std::string>
+    Settings::inputTranslationZVPRel("input", "translationZVPRel", axisValues(),
+                                     "None");
+SettingsEntryEnum<std::string> Settings::inputRotateX("input", "rotateX",
+                                                      axisValues(), "+4");
+SettingsEntryEnum<std::string> Settings::inputRotateY("input", "rotateY",
+                                                      axisValues(), "-5");
+SettingsEntryEnum<std::string> Settings::inputRotateZ("input", "rotateZ",
+                                                      axisValues(), "-6");
+SettingsEntryEnum<std::string>
+    Settings::inputRotateXVPRel("input", "rotateXVPRel", axisValues(), "None");
+SettingsEntryEnum<std::string>
+    Settings::inputRotateYVPRel("input", "rotateYVPRel", axisValues(), "None");
+SettingsEntryEnum<std::string>
+    Settings::inputRotateZVPRel("input", "rotateZVPRel", axisValues(), "None");
+SettingsEntryEnum<std::string> Settings::inputZoom("input", "zoom",
+                                                   axisValues(), "None");
+SettingsEntryEnum<std::string> Settings::inputZoom2("input", "zoom2",
+                                                    axisValues(), "None");
+
+SettingsEntryDouble Settings::inputTranslationGain("input", "translationGain",
+                                                   0.01, 0.01, 9.99, 1.00);
+SettingsEntryDouble Settings::inputTranslationVPRelGain("input",
+                                                        "translationVPRelGain",
+                                                        0.01, 0.01, 9.99, 1.00);
+SettingsEntryDouble Settings::inputRotateGain("input", "rotateGain", 0.01, 0.01,
+                                              9.99, 1.00);
+SettingsEntryDouble Settings::inputRotateVPRelGain("input", "rotateVPRelGain",
+                                                   0.01, 0.01, 9.99, 1.00);
+SettingsEntryDouble Settings::inputZoomGain("input", "zoomGain", 0.1, 0.1, 99.9,
+                                            1.0);
 
 SettingsEntryString Settings::inputButton0("input", "button0", "");
 SettingsEntryString Settings::inputButton1("input", "button1", "");
@@ -292,95 +353,185 @@ SettingsEntryString Settings::inputButton20("input", "button20", "");
 SettingsEntryString Settings::inputButton21("input", "button21", "");
 SettingsEntryString Settings::inputButton22("input", "button22", "");
 SettingsEntryString Settings::inputButton23("input", "button23", "");
-SettingsEntryDouble Settings::axisTrim0("input", "axisTrim0", -1.0, 0.01, 1.0, 0.0);
-SettingsEntryDouble Settings::axisTrim1("input", "axisTrim1", -1.0, 0.01, 1.0, 0.0);
-SettingsEntryDouble Settings::axisTrim2("input", "axisTrim2", -1.0, 0.01, 1.0, 0.0);
-SettingsEntryDouble Settings::axisTrim3("input", "axisTrim3", -1.0, 0.01, 1.0, 0.0);
-SettingsEntryDouble Settings::axisTrim4("input", "axisTrim4", -1.0, 0.01, 1.0, 0.0);
-SettingsEntryDouble Settings::axisTrim5("input", "axisTrim5", -1.0, 0.01, 1.0, 0.0);
-SettingsEntryDouble Settings::axisTrim6("input", "axisTrim6", -1.0, 0.01, 1.0, 0.0);
-SettingsEntryDouble Settings::axisTrim7("input", "axisTrim7", -1.0, 0.01, 1.0, 0.0);
-SettingsEntryDouble Settings::axisTrim8("input", "axisTrim8", -1.0, 0.01, 1.0, 0.0);
-SettingsEntryDouble Settings::axisDeadzone0("input", "axisDeadzone0", 0.0, 0.01, 1.0, 0.10);
-SettingsEntryDouble Settings::axisDeadzone1("input", "axisDeadzone1", 0.0, 0.01, 1.0, 0.10);
-SettingsEntryDouble Settings::axisDeadzone2("input", "axisDeadzone2", 0.0, 0.01, 1.0, 0.10);
-SettingsEntryDouble Settings::axisDeadzone3("input", "axisDeadzone3", 0.0, 0.01, 1.0, 0.10);
-SettingsEntryDouble Settings::axisDeadzone4("input", "axisDeadzone4", 0.0, 0.01, 1.0, 0.10);
-SettingsEntryDouble Settings::axisDeadzone5("input", "axisDeadzone5", 0.0, 0.01, 1.0, 0.10);
-SettingsEntryDouble Settings::axisDeadzone6("input", "axisDeadzone6", 0.0, 0.01, 1.0, 0.10);
-SettingsEntryDouble Settings::axisDeadzone7("input", "axisDeadzone7", 0.0, 0.01, 1.0, 0.10);
-SettingsEntryDouble Settings::axisDeadzone8("input", "axisDeadzone8", 0.0, 0.01, 1.0, 0.10);
+SettingsEntryDouble Settings::axisTrim0("input", "axisTrim0", -1.0, 0.01, 1.0,
+                                        0.0);
+SettingsEntryDouble Settings::axisTrim1("input", "axisTrim1", -1.0, 0.01, 1.0,
+                                        0.0);
+SettingsEntryDouble Settings::axisTrim2("input", "axisTrim2", -1.0, 0.01, 1.0,
+                                        0.0);
+SettingsEntryDouble Settings::axisTrim3("input", "axisTrim3", -1.0, 0.01, 1.0,
+                                        0.0);
+SettingsEntryDouble Settings::axisTrim4("input", "axisTrim4", -1.0, 0.01, 1.0,
+                                        0.0);
+SettingsEntryDouble Settings::axisTrim5("input", "axisTrim5", -1.0, 0.01, 1.0,
+                                        0.0);
+SettingsEntryDouble Settings::axisTrim6("input", "axisTrim6", -1.0, 0.01, 1.0,
+                                        0.0);
+SettingsEntryDouble Settings::axisTrim7("input", "axisTrim7", -1.0, 0.01, 1.0,
+                                        0.0);
+SettingsEntryDouble Settings::axisTrim8("input", "axisTrim8", -1.0, 0.01, 1.0,
+                                        0.0);
+SettingsEntryDouble Settings::axisDeadzone0("input", "axisDeadzone0", 0.0, 0.01,
+                                            1.0, 0.10);
+SettingsEntryDouble Settings::axisDeadzone1("input", "axisDeadzone1", 0.0, 0.01,
+                                            1.0, 0.10);
+SettingsEntryDouble Settings::axisDeadzone2("input", "axisDeadzone2", 0.0, 0.01,
+                                            1.0, 0.10);
+SettingsEntryDouble Settings::axisDeadzone3("input", "axisDeadzone3", 0.0, 0.01,
+                                            1.0, 0.10);
+SettingsEntryDouble Settings::axisDeadzone4("input", "axisDeadzone4", 0.0, 0.01,
+                                            1.0, 0.10);
+SettingsEntryDouble Settings::axisDeadzone5("input", "axisDeadzone5", 0.0, 0.01,
+                                            1.0, 0.10);
+SettingsEntryDouble Settings::axisDeadzone6("input", "axisDeadzone6", 0.0, 0.01,
+                                            1.0, 0.10);
+SettingsEntryDouble Settings::axisDeadzone7("input", "axisDeadzone7", 0.0, 0.01,
+                                            1.0, 0.10);
+SettingsEntryDouble Settings::axisDeadzone8("input", "axisDeadzone8", 0.0, 0.01,
+                                            1.0, 0.10);
 
 SettingsEntryInt Settings::joystickNr("input", "joystickNr", 0, 9, 0);
 
-SettingsEntryString SettingsPython::pythonTrustedFiles(SECTION_PYTHON, "trusted-files", "");
-SettingsEntryString SettingsPython::pythonVirtualEnv(SECTION_PYTHON, "virtual-env", "");
-
-SettingsEntryBool SettingsExportPdf::exportPdfAlwaysShowDialog(SECTION_EXPORT_PDF, "always-show-dialog", true);
-SettingsEntryEnum<ExportPdfPaperSize> SettingsExportPdf::exportPdfPaperSize(SECTION_EXPORT_PDF, "paper-size", {
-    {ExportPdfPaperSize::A6,      "a6",      _("A6 (105 x 148 mm)")},
-    {ExportPdfPaperSize::A5,      "a5",      _("A5 (148 x 210 mm)")},
-    {ExportPdfPaperSize::A4,      "a4",      _("A4 (210x297 mm)")},
-    {ExportPdfPaperSize::A3,      "a3",      _("A3 (297x420 mm)")},
-    {ExportPdfPaperSize::LETTER,  "letter",  _("Letter (8.5x11 in)")},
-    {ExportPdfPaperSize::LEGAL,   "legal",   _("Legal (8.5x14 in)")},
-    {ExportPdfPaperSize::TABLOID, "tabloid", _("Tabloid (11x17 in)")}
-  }, ExportPdfPaperSize::A4);
-SettingsEntryEnum<ExportPdfPaperOrientation> SettingsExportPdf::exportPdfOrientation(SECTION_EXPORT_PDF, "orientation", {
-    {ExportPdfPaperOrientation::PORTRAIT,  "portrait",  _("Portrait (Vertical)")},
-    {ExportPdfPaperOrientation::LANDSCAPE, "landscape", _("Landscape (Horizontal)")},
-    {ExportPdfPaperOrientation::AUTO,      "auto",      _("Auto")}
-  }, ExportPdfPaperOrientation::PORTRAIT);
-SettingsEntryBool SettingsExportPdf::exportPdfShowFilename(SECTION_EXPORT_PDF, "show-filename", false);
-SettingsEntryBool SettingsExportPdf::exportPdfShowScale(SECTION_EXPORT_PDF, "show-scale", true);
-SettingsEntryBool SettingsExportPdf::exportPdfShowScaleMessage(SECTION_EXPORT_PDF, "show-scale-message", true);
-SettingsEntryBool SettingsExportPdf::exportPdfShowGrid(SECTION_EXPORT_PDF, "show-grid", false);
-SettingsEntryDouble SettingsExportPdf::exportPdfGridSize(SECTION_EXPORT_PDF, "grid-size", 1.0, 1.0, 100.0, 10.0);
-SettingsEntryBool SettingsExportPdf::exportPdfAddMetaData(SECTION_EXPORT_PDF, "add-meta-data", true);
-SettingsEntryBool SettingsExportPdf::exportPdfAddMetaDataAuthor(SECTION_EXPORT_PDF, "add-meta-data-author", false);
-SettingsEntryBool SettingsExportPdf::exportPdfAddMetaDataSubject(SECTION_EXPORT_PDF, "add-meta-data-subject", false);
-SettingsEntryBool SettingsExportPdf::exportPdfAddMetaDataKeywords(SECTION_EXPORT_PDF, "add-meta-data-keywords", false);
-SettingsEntryString SettingsExportPdf::exportPdfMetaDataTitle(SECTION_EXPORT_PDF, "meta-data-title", "");
-SettingsEntryString SettingsExportPdf::exportPdfMetaDataAuthor(SECTION_EXPORT_PDF, "meta-data-author", "");
-SettingsEntryString SettingsExportPdf::exportPdfMetaDataSubject(SECTION_EXPORT_PDF, "meta-data-subject", "");
-SettingsEntryString SettingsExportPdf::exportPdfMetaDataKeywords(SECTION_EXPORT_PDF, "meta-data-keywords", "");
-SettingsEntryBool SettingsExportPdf::exportPdfFill(SECTION_EXPORT_PDF, "fill", false);
-SettingsEntryString SettingsExportPdf::exportPdfFillColor(SECTION_EXPORT_PDF, "fill-color", "black");
-SettingsEntryBool SettingsExportPdf::exportPdfStroke(SECTION_EXPORT_PDF, "stroke", true);
-SettingsEntryString SettingsExportPdf::exportPdfStrokeColor(SECTION_EXPORT_PDF, "stroke-color", "black");
-SettingsEntryDouble SettingsExportPdf::exportPdfStrokeWidth(SECTION_EXPORT_PDF, "stroke-width", 0, 0.01, 999, 0.35);
-
-SettingsEntryBool SettingsExport3mf::export3mfAlwaysShowDialog(SECTION_EXPORT_3MF, "always-show-dialog", true);
-SettingsEntryEnum<Export3mfColorMode> SettingsExport3mf::export3mfColorMode(SECTION_EXPORT_3MF, "color-mode", {
-    {Export3mfColorMode::model,               "model",               _("Use colors from model")},
-    {Export3mfColorMode::none,                "none",                _("No colors")},
-    {Export3mfColorMode::selected_only,       "selected-only",       _("Use selected color only")},
-  }, Export3mfColorMode::model);
-SettingsEntryEnum<Export3mfUnit> SettingsExport3mf::export3mfUnit(SECTION_EXPORT_3MF, "unit", {
-    {Export3mfUnit::micron,     "micron",     _("Micron")},
-    {Export3mfUnit::millimeter, "millimeter", _("Millimeter")},
-    {Export3mfUnit::centimeter, "centimeter", _("Centimeter")},
-    {Export3mfUnit::meter,      "meter",      _("Meter")},
-    {Export3mfUnit::inch,       "inch",       _("Inch")},
-    {Export3mfUnit::foot,       "foot",       _("Feet")},
-  }, Export3mfUnit::millimeter);
-SettingsEntryString SettingsExport3mf::export3mfColor(SECTION_EXPORT_3MF, "color", "#f9d72c"); // Cornfield: CGAL_FACE_FRONT_COLOR
-SettingsEntryEnum<Export3mfMaterialType> SettingsExport3mf::export3mfMaterialType(SECTION_EXPORT_3MF, "material-type", {
-    {Export3mfMaterialType::color,        "color",        _("Color")},
-    {Export3mfMaterialType::basematerial, "basematerial", _("Base Material")},
-  }, Export3mfMaterialType::basematerial);
-SettingsEntryInt SettingsExport3mf::export3mfDecimalPrecision(SECTION_EXPORT_3MF, "decimal-precision", 1, 16, 6);
-SettingsEntryBool SettingsExport3mf::export3mfAddMetaData(SECTION_EXPORT_3MF, "add-meta-data", true);
-SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataDesigner(SECTION_EXPORT_3MF, "add-meta-data-designer", false);
-SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataDescription(SECTION_EXPORT_3MF, "add-meta-data-description", false);
-SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataCopyright(SECTION_EXPORT_3MF, "add-meta-data-copyright", false);
-SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataLicenseTerms(SECTION_EXPORT_3MF, "add-meta-data-license-terms", false);
-SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataRating(SECTION_EXPORT_3MF, "add-meta-data-rating", false);
-SettingsEntryString SettingsExport3mf::export3mfMetaDataTitle(SECTION_EXPORT_3MF, "meta-data-title", "");
-SettingsEntryString SettingsExport3mf::export3mfMetaDataDesigner(SECTION_EXPORT_3MF, "meta-data-designer", "");
-SettingsEntryString SettingsExport3mf::export3mfMetaDataDescription(SECTION_EXPORT_3MF, "meta-data-description", "");
-SettingsEntryString SettingsExport3mf::export3mfMetaDataCopyright(SECTION_EXPORT_3MF, "meta-data-copyright", "");
-SettingsEntryString SettingsExport3mf::export3mfMetaDataLicenseTerms(SECTION_EXPORT_3MF, "meta-data-license-terms", "");
-SettingsEntryString SettingsExport3mf::export3mfMetaDataRating(SECTION_EXPORT_3MF, "meta-data-rating", "");
+SettingsEntryString SettingsPython::pythonTrustedFiles(SECTION_PYTHON,
+                                                       "trusted-files", "");
+SettingsEntryString SettingsPython::pythonVirtualEnv(SECTION_PYTHON,
+                                                     "virtual-env", "");
+
+SettingsEntryBool
+    SettingsExportPdf::exportPdfAlwaysShowDialog(SECTION_EXPORT_PDF,
+                                                 "always-show-dialog", true);
+SettingsEntryEnum<ExportPdfPaperSize> SettingsExportPdf::exportPdfPaperSize(
+    SECTION_EXPORT_PDF, "paper-size",
+    {{ExportPdfPaperSize::A6, "a6", _("A6 (105 x 148 mm)")},
+     {ExportPdfPaperSize::A5, "a5", _("A5 (148 x 210 mm)")},
+     {ExportPdfPaperSize::A4, "a4", _("A4 (210x297 mm)")},
+     {ExportPdfPaperSize::A3, "a3", _("A3 (297x420 mm)")},
+     {ExportPdfPaperSize::LETTER, "letter", _("Letter (8.5x11 in)")},
+     {ExportPdfPaperSize::LEGAL, "legal", _("Legal (8.5x14 in)")},
+     {ExportPdfPaperSize::TABLOID, "tabloid", _("Tabloid (11x17 in)")}},
+    ExportPdfPaperSize::A4);
+SettingsEntryEnum<ExportPdfPaperOrientation>
+    SettingsExportPdf::exportPdfOrientation(
+        SECTION_EXPORT_PDF, "orientation",
+        {{ExportPdfPaperOrientation::PORTRAIT, "portrait",
+          _("Portrait (Vertical)")},
+         {ExportPdfPaperOrientation::LANDSCAPE, "landscape",
+          _("Landscape (Horizontal)")},
+         {ExportPdfPaperOrientation::AUTO, "auto", _("Auto")}},
+        ExportPdfPaperOrientation::PORTRAIT);
+SettingsEntryBool SettingsExportPdf::exportPdfShowFilename(SECTION_EXPORT_PDF,
+                                                           "show-filename",
+                                                           false);
+SettingsEntryBool SettingsExportPdf::exportPdfShowScale(SECTION_EXPORT_PDF,
+                                                        "show-scale", true);
+SettingsEntryBool
+    SettingsExportPdf::exportPdfShowScaleMessage(SECTION_EXPORT_PDF,
+                                                 "show-scale-message", true);
+SettingsEntryBool SettingsExportPdf::exportPdfShowGrid(SECTION_EXPORT_PDF,
+                                                       "show-grid", false);
+SettingsEntryDouble SettingsExportPdf::exportPdfGridSize(SECTION_EXPORT_PDF,
+                                                         "grid-size", 1.0, 1.0,
+                                                         100.0, 10.0);
+SettingsEntryBool SettingsExportPdf::exportPdfAddMetaData(SECTION_EXPORT_PDF,
+                                                          "add-meta-data",
+                                                          true);
+SettingsEntryBool SettingsExportPdf::exportPdfAddMetaDataAuthor(
+    SECTION_EXPORT_PDF, "add-meta-data-author", false);
+SettingsEntryBool SettingsExportPdf::exportPdfAddMetaDataSubject(
+    SECTION_EXPORT_PDF, "add-meta-data-subject", false);
+SettingsEntryBool SettingsExportPdf::exportPdfAddMetaDataKeywords(
+    SECTION_EXPORT_PDF, "add-meta-data-keywords", false);
+SettingsEntryString
+    SettingsExportPdf::exportPdfMetaDataTitle(SECTION_EXPORT_PDF,
+                                              "meta-data-title", "");
+SettingsEntryString
+    SettingsExportPdf::exportPdfMetaDataAuthor(SECTION_EXPORT_PDF,
+                                               "meta-data-author", "");
+SettingsEntryString
+    SettingsExportPdf::exportPdfMetaDataSubject(SECTION_EXPORT_PDF,
+                                                "meta-data-subject", "");
+SettingsEntryString
+    SettingsExportPdf::exportPdfMetaDataKeywords(SECTION_EXPORT_PDF,
+                                                 "meta-data-keywords", "");
+SettingsEntryBool SettingsExportPdf::exportPdfFill(SECTION_EXPORT_PDF, "fill",
+                                                   false);
+SettingsEntryString SettingsExportPdf::exportPdfFillColor(SECTION_EXPORT_PDF,
+                                                          "fill-color",
+                                                          "black");
+SettingsEntryBool SettingsExportPdf::exportPdfStroke(SECTION_EXPORT_PDF,
+                                                     "stroke", true);
+SettingsEntryString SettingsExportPdf::exportPdfStrokeColor(SECTION_EXPORT_PDF,
+                                                            "stroke-color",
+                                                            "black");
+SettingsEntryDouble SettingsExportPdf::exportPdfStrokeWidth(SECTION_EXPORT_PDF,
+                                                            "stroke-width", 0,
+                                                            0.01, 999, 0.35);
+
+SettingsEntryBool
+    SettingsExport3mf::export3mfAlwaysShowDialog(SECTION_EXPORT_3MF,
+                                                 "always-show-dialog", true);
+SettingsEntryEnum<Export3mfColorMode> SettingsExport3mf::export3mfColorMode(
+    SECTION_EXPORT_3MF, "color-mode",
+    {
+        {Export3mfColorMode::model, "model", _("Use colors from model")},
+        {Export3mfColorMode::none, "none", _("No colors")},
+        {Export3mfColorMode::selected_only, "selected-only",
+         _("Use selected color only")},
+    },
+    Export3mfColorMode::model);
+SettingsEntryEnum<Export3mfUnit> SettingsExport3mf::export3mfUnit(
+    SECTION_EXPORT_3MF, "unit",
+    {
+        {Export3mfUnit::micron, "micron", _("Micron")},
+        {Export3mfUnit::millimeter, "millimeter", _("Millimeter")},
+        {Export3mfUnit::centimeter, "centimeter", _("Centimeter")},
+        {Export3mfUnit::meter, "meter", _("Meter")},
+        {Export3mfUnit::inch, "inch", _("Inch")},
+        {Export3mfUnit::foot, "foot", _("Feet")},
+    },
+    Export3mfUnit::millimeter);
+SettingsEntryString SettingsExport3mf::export3mfColor(
+    SECTION_EXPORT_3MF, "color", "#f9d72c"); // Cornfield: CGAL_FACE_FRONT_COLOR
+SettingsEntryEnum<Export3mfMaterialType>
+    SettingsExport3mf::export3mfMaterialType(
+        SECTION_EXPORT_3MF, "material-type",
+        {
+            {Export3mfMaterialType::color, "color", _("Color")},
+            {Export3mfMaterialType::basematerial, "basematerial",
+             _("Base Material")},
+        },
+        Export3mfMaterialType::basematerial);
+SettingsEntryInt
+    SettingsExport3mf::export3mfDecimalPrecision(SECTION_EXPORT_3MF,
+                                                 "decimal-precision", 1, 16, 6);
+SettingsEntryBool SettingsExport3mf::export3mfAddMetaData(SECTION_EXPORT_3MF,
+                                                          "add-meta-data",
+                                                          true);
+SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataDesigner(
+    SECTION_EXPORT_3MF, "add-meta-data-designer", false);
+SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataDescription(
+    SECTION_EXPORT_3MF, "add-meta-data-description", false);
+SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataCopyright(
+    SECTION_EXPORT_3MF, "add-meta-data-copyright", false);
+SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataLicenseTerms(
+    SECTION_EXPORT_3MF, "add-meta-data-license-terms", false);
+SettingsEntryBool SettingsExport3mf::export3mfAddMetaDataRating(
+    SECTION_EXPORT_3MF, "add-meta-data-rating", false);
+SettingsEntryString
+    SettingsExport3mf::export3mfMetaDataTitle(SECTION_EXPORT_3MF,
+                                              "meta-data-title", "");
+SettingsEntryString
+    SettingsExport3mf::export3mfMetaDataDesigner(SECTION_EXPORT_3MF,
+                                                 "meta-data-designer", "");
+SettingsEntryString SettingsExport3mf::export3mfMetaDataDescription(
+    SECTION_EXPORT_3MF, "meta-data-description", "");
+SettingsEntryString
+    SettingsExport3mf::export3mfMetaDataCopyright(SECTION_EXPORT_3MF,
+                                                  "meta-data-copyright", "");
+SettingsEntryString SettingsExport3mf::export3mfMetaDataLicenseTerms(
+    SECTION_EXPORT_3MF, "meta-data-license-terms", "");
+SettingsEntryString
+    SettingsExport3mf::export3mfMetaDataRating(SECTION_EXPORT_3MF,
+                                               "meta-data-rating", "");
 
 } // namespace Settings
diff --git a/src/core/Settings.h b/src/core/Settings.h
index 6755bcf33..3e28e1e7f 100644
--- a/src/core/Settings.h
+++ b/src/core/Settings.h
@@ -1,13 +1,13 @@
 #pragma once
 
+#include <array>
 #include <cstddef>
 #include <cstdint>
+#include <sstream>
 #include <string>
+#include <tuple>
 #include <utility>
 #include <vector>
-#include <array>
-#include <sstream>
-#include <tuple>
 
 #include "io/export_enums.h"
 
@@ -21,23 +21,23 @@ constexpr inline size_t max_buttons = 24;
 
 // Property name in GUI designer for matching enum values
 constexpr inline auto PROPERTY_NAME = "_settings_value";
-// Additional value for enums that can map to an additional value (e.g. GridSize in PDF Export)
+// Additional value for enums that can map to an additional value (e.g. GridSize
+// in PDF Export)
 constexpr inline auto PROPERTY_SELECTED_VALUE = "_selected_value";
 
 constexpr inline auto SECTION_PYTHON = "python";
 constexpr inline auto SECTION_EXPORT_PDF = "export-pdf";
 constexpr inline auto SECTION_EXPORT_3MF = "export-3mf";
 
-class SettingsEntryBase
-{
+class SettingsEntryBase {
 public:
-  const std::string& category() const { return _category; }
-  const std::string& name() const { return _name; }
+  const std::string &category() const { return _category; }
+  const std::string &name() const { return _name; }
   const std::string key() const { return category() + "/" + name(); }
 
   virtual bool isDefault() const = 0;
   virtual std::string encode() const = 0;
-  virtual void set(const std::string& encoded) = 0;
+  virtual void set(const std::string &encoded) = 0;
   virtual const std::tuple<std::string, std::string> help() const = 0;
 
 protected:
@@ -49,35 +49,32 @@ private:
   std::string _name;
 };
 
-template <typename entry_type>
-class SettingsEntry : public SettingsEntryBase
-{
+template <typename entry_type> class SettingsEntry : public SettingsEntryBase {
 public:
   using entry_type_t = entry_type;
 
-  virtual const entry_type decode(const std::string& encoded) const = 0;
+  virtual const entry_type decode(const std::string &encoded) const = 0;
 
 protected:
-  SettingsEntry(const std::string& category, const std::string& name) : SettingsEntryBase(category, name) {}
+  SettingsEntry(const std::string &category, const std::string &name)
+      : SettingsEntryBase(category, name) {}
   virtual ~SettingsEntry() = default;
 };
 
-class SettingsEntryBool : public SettingsEntry<bool>
-{
+class SettingsEntryBool : public SettingsEntry<bool> {
 public:
-  SettingsEntryBool(const std::string& category, const std::string& name, bool defaultValue) :
-    SettingsEntry(category, name),
-    _value(defaultValue),
-    _defaultValue(defaultValue)
-  {}
+  SettingsEntryBool(const std::string &category, const std::string &name,
+                    bool defaultValue)
+      : SettingsEntry(category, name), _value(defaultValue),
+        _defaultValue(defaultValue) {}
 
   bool value() const { return _value; }
   void setValue(bool value) { _value = value; }
   bool defaultValue() const { return _defaultValue; }
   bool isDefault() const override { return _value == _defaultValue; }
   std::string encode() const override;
-  const bool decode(const std::string& encoded) const override;
-  void set(const std::string& encoded) override { setValue(decode(encoded)); }
+  const bool decode(const std::string &encoded) const override;
+  void set(const std::string &encoded) override { setValue(decode(encoded)); }
   const std::tuple<std::string, std::string> help() const override {
     return {"bool", defaultValue() ? "<true>/false" : "true/<false>"};
   }
@@ -87,16 +84,12 @@ private:
   bool _defaultValue;
 };
 
-class SettingsEntryInt : public SettingsEntry<int>
-{
+class SettingsEntryInt : public SettingsEntry<int> {
 public:
-  SettingsEntryInt(const std::string& category, const std::string& name, int minimum, int maximum, int defaultValue) :
-    SettingsEntry(category, name),
-    _value(defaultValue),
-    _defaultValue(defaultValue),
-    _minimum(minimum),
-    _maximum(maximum)
-  {}
+  SettingsEntryInt(const std::string &category, const std::string &name,
+                   int minimum, int maximum, int defaultValue)
+      : SettingsEntry(category, name), _value(defaultValue),
+        _defaultValue(defaultValue), _minimum(minimum), _maximum(maximum) {}
 
   int value() const { return _value; }
   void setValue(int value) { _value = value; }
@@ -105,10 +98,12 @@ public:
   int defaultValue() const { return _defaultValue; }
   bool isDefault() const override { return _value == _defaultValue; }
   std::string encode() const override;
-  const int decode(const std::string& encoded) const override;
-  void set(const std::string& encoded) override { setValue(decode(encoded)); }
+  const int decode(const std::string &encoded) const override;
+  void set(const std::string &encoded) override { setValue(decode(encoded)); }
   const std::tuple<std::string, std::string> help() const override {
-    return {"int", std::to_string(_minimum) + " : <" + std::to_string(defaultValue()) + "> : " + std::to_string(maximum())};
+    return {"int", std::to_string(_minimum) + " : <" +
+                       std::to_string(defaultValue()) +
+                       "> : " + std::to_string(maximum())};
   }
 
 private:
@@ -118,17 +113,14 @@ private:
   int _maximum;
 };
 
-class SettingsEntryDouble : public SettingsEntry<double>
-{
+class SettingsEntryDouble : public SettingsEntry<double> {
 public:
-  SettingsEntryDouble(const std::string& category, const std::string& name, double minimum, double step, double maximum, double defaultValue) :
-    SettingsEntry(category, name),
-    _value(defaultValue),
-    _defaultValue(defaultValue),
-    _minimum(minimum),
-    _step(step),
-    _maximum(maximum)
-  {}
+  SettingsEntryDouble(const std::string &category, const std::string &name,
+                      double minimum, double step, double maximum,
+                      double defaultValue)
+      : SettingsEntry(category, name), _value(defaultValue),
+        _defaultValue(defaultValue), _minimum(minimum), _step(step),
+        _maximum(maximum) {}
 
   double value() const { return _value; }
   void setValue(double value) { _value = value; }
@@ -138,10 +130,12 @@ public:
   double defaultValue() const { return _defaultValue; }
   bool isDefault() const override { return _value == _defaultValue; }
   std::string encode() const override;
-  const double decode(const std::string& encoded) const override;
-  void set(const std::string& encoded) override { setValue(decode(encoded)); }
+  const double decode(const std::string &encoded) const override;
+  void set(const std::string &encoded) override { setValue(decode(encoded)); }
   const std::tuple<std::string, std::string> help() const override {
-    return {"double", std::to_string(_minimum) + " : <" + std::to_string(defaultValue()) + "> : " + std::to_string(maximum())};
+    return {"double", std::to_string(_minimum) + " : <" +
+                          std::to_string(defaultValue()) +
+                          "> : " + std::to_string(maximum())};
   }
 
 private:
@@ -152,23 +146,25 @@ private:
   double _maximum;
 };
 
-class SettingsEntryString : public SettingsEntry<std::string>
-{
+class SettingsEntryString : public SettingsEntry<std::string> {
 public:
-  SettingsEntryString(const std::string& category, const std::string& name, const std::string& defaultValue) :
-    SettingsEntry(category, name),
-    _value(defaultValue),
-    _defaultValue(defaultValue)
-  {}
-
-  const std::string& value() const { return _value; }
-  void setValue(const std::string& value) { _value = value; }
-  const std::string& defaultValue() const { return _defaultValue; }
+  SettingsEntryString(const std::string &category, const std::string &name,
+                      const std::string &defaultValue)
+      : SettingsEntry(category, name), _value(defaultValue),
+        _defaultValue(defaultValue) {}
+
+  const std::string &value() const { return _value; }
+  void setValue(const std::string &value) { _value = value; }
+  const std::string &defaultValue() const { return _defaultValue; }
   bool isDefault() const override { return _value == _defaultValue; }
   std::string encode() const override { return value(); }
-  const std::string decode(const std::string& encoded) const override { return encoded; }
-  void set(const std::string& encoded) override { setValue(decode(encoded)); }
-  const std::tuple<std::string, std::string> help() const override { return {"string", "\"" + encode() + "\""}; }
+  const std::string decode(const std::string &encoded) const override {
+    return encoded;
+  }
+  void set(const std::string &encoded) override { setValue(decode(encoded)); }
+  const std::tuple<std::string, std::string> help() const override {
+    return {"string", "\"" + encode() + "\""};
+  }
 
 private:
   std::string _value;
@@ -176,39 +172,41 @@ private:
 };
 
 template <typename enum_type>
-class SettingsEntryEnum : public SettingsEntry<enum_type>
-{
+class SettingsEntryEnum : public SettingsEntry<enum_type> {
 public:
   struct Item {
-    Item(enum_type value, std::string name, std::string description) : value(value), name(std::move(name)), description(std::move(description)) {
-    }
+    Item(enum_type value, std::string name, std::string description)
+        : value(value), name(std::move(name)),
+          description(std::move(description)) {}
     enum_type value;
     std::string name;
     std::string description;
   };
-  SettingsEntryEnum(const std::string& category, const std::string& name, std::vector<Item> items, enum_type defaultValue) :
-    SettingsEntry<enum_type>(category, name),
-    _items(std::move(items)),
-    _defaultValue(std::move(defaultValue))
-  {
+  SettingsEntryEnum(const std::string &category, const std::string &name,
+                    std::vector<Item> items, enum_type defaultValue)
+      : SettingsEntry<enum_type>(category, name), _items(std::move(items)),
+        _defaultValue(std::move(defaultValue)) {
     setValue(_defaultValue);
   }
 
-  const Item& item() const { return _items[_index]; }
-  const enum_type& value() const { return item().value; }
+  const Item &item() const { return _items[_index]; }
+  const enum_type &value() const { return item().value; }
   size_t index() const { return _index; }
-  void setValue(const enum_type& value);
-  void setIndex(size_t index) { if (index < _items.size()) _index = index; }
-  const std::vector<Item>& items() const { return _items; }
-  const enum_type& defaultValue() const { return _defaultValue; }
+  void setValue(const enum_type &value);
+  void setIndex(size_t index) {
+    if (index < _items.size())
+      _index = index;
+  }
+  const std::vector<Item> &items() const { return _items; }
+  const enum_type &defaultValue() const { return _defaultValue; }
   bool isDefault() const override { return value() == _defaultValue; }
   std::string encode() const override;
-  const enum_type decode(const std::string& encoded) const override;
-  void set(const std::string& encoded) override { setValue(decode(encoded)); }
+  const enum_type decode(const std::string &encoded) const override;
+  void set(const std::string &encoded) override { setValue(decode(encoded)); }
   const std::tuple<std::string, std::string> help() const override {
     std::string sep = "[";
     std::string list = "";
-    for (const auto& item : items()) {
+    for (const auto &item : items()) {
       const auto def = item.value == defaultValue();
       const auto p = def ? "<" : "";
       const auto s = def ? ">" : "";
@@ -226,8 +224,7 @@ private:
 };
 
 template <typename enum_type>
-void SettingsEntryEnum<enum_type>::setValue(const enum_type& value)
-{
+void SettingsEntryEnum<enum_type>::setValue(const enum_type &value) {
   for (size_t i = 0; i < _items.size(); ++i) {
     if (_items[i].value == value) {
       _index = i;
@@ -237,11 +234,14 @@ void SettingsEntryEnum<enum_type>::setValue(const enum_type& value)
 }
 
 template <typename enum_type>
-std::string SettingsEntryEnum<enum_type>::encode() const { return item().name; }
+std::string SettingsEntryEnum<enum_type>::encode() const {
+  return item().name;
+}
 
 template <typename enum_type>
-const enum_type SettingsEntryEnum<enum_type>::decode(const std::string& encoded) const {
-  for (const Item& item : items()) {
+const enum_type
+SettingsEntryEnum<enum_type>::decode(const std::string &encoded) const {
+  for (const Item &item : items()) {
     if (item.name == encoded) {
       return item.value;
     }
@@ -249,17 +249,19 @@ const enum_type SettingsEntryEnum<enum_type>::decode(const std::string& encoded)
   return defaultValue();
 }
 
-template <>
-inline std::string SettingsEntryEnum<std::string>::encode() const { return value(); }
+template <> inline std::string SettingsEntryEnum<std::string>::encode() const {
+  return value();
+}
 
 template <>
-inline const std::string SettingsEntryEnum<std::string>::decode(const std::string& encoded) const { return encoded; }
+inline const std::string
+SettingsEntryEnum<std::string>::decode(const std::string &encoded) const {
+  return encoded;
+}
 
-class LocalAppParameterType
-{
+class LocalAppParameterType {
 public:
-  enum Value : uint8_t
-  {
+  enum Value : uint8_t {
     invalid,
     string,
     file,
@@ -270,33 +272,45 @@ public:
   };
 
   LocalAppParameterType() = default;
-  constexpr LocalAppParameterType(Value v) : value(v) { }
-  constexpr operator Value() const {
-    return value;
-  }
+  constexpr LocalAppParameterType(Value v) : value(v) {}
+  constexpr operator Value() const { return value; }
   explicit operator bool() const = delete;
 
   std::string icon() const {
     switch (value) {
-    case string: return "chokusen-parameter";
-    case file: return "chokusen-orthogonal";
-    case dir: return "chokusen-folder";
-    case extension: return "chokusen-parameter";
-    case source: return "chokusen-file";
-    case sourcedir: return "chokusen-folder";
-    default: return "*invalid*";
+    case string:
+      return "chokusen-parameter";
+    case file:
+      return "chokusen-orthogonal";
+    case dir:
+      return "chokusen-folder";
+    case extension:
+      return "chokusen-parameter";
+    case source:
+      return "chokusen-file";
+    case sourcedir:
+      return "chokusen-folder";
+    default:
+      return "*invalid*";
     }
   }
 
   std::string description() const {
     switch (value) {
-    case string: return "";
-    case file: return "<full path to the output file>";
-    case dir: return "<directory of the output file>";
-    case extension: return "<extension of the output file without leading dot>";
-    case source: return "<full path to the main source file>";
-    case sourcedir: return "<directory of the main source file>";
-    default: return "*invalid*";
+    case string:
+      return "";
+    case file:
+      return "<full path to the output file>";
+    case dir:
+      return "<directory of the output file>";
+    case extension:
+      return "<extension of the output file without leading dot>";
+    case source:
+      return "<full path to the main source file>";
+    case sourcedir:
+      return "<directory of the main source file>";
+    default:
+      return "*invalid*";
     }
   }
 
@@ -308,35 +322,30 @@ struct LocalAppParameter {
   LocalAppParameterType type;
   std::string value;
 
-  LocalAppParameter() : type(LocalAppParameterType::string), value("") {
-  }
-  LocalAppParameter(const LocalAppParameterType t, std::string v) : type(t), value(std::move(v)) {
-  }
-  operator bool() const {
-    return type != LocalAppParameterType::invalid;
-  }
+  LocalAppParameter() : type(LocalAppParameterType::string), value("") {}
+  LocalAppParameter(const LocalAppParameterType t, std::string v)
+      : type(t), value(std::move(v)) {}
+  operator bool() const { return type != LocalAppParameterType::invalid; }
 };
 
 template <typename item_type>
-class SettingsEntryList : public SettingsEntry<std::vector<item_type>>
-{
+class SettingsEntryList : public SettingsEntry<std::vector<item_type>> {
 public:
   using list_type_t = std::vector<item_type>;
-  SettingsEntryList(const std::string& category, const std::string& name) :
-    SettingsEntry<std::vector<item_type>>(category, name)
-  {
-  }
-  const list_type_t& value() const { return _items; }
-  void setValue(const list_type_t& items) { _items = items; }
+  SettingsEntryList(const std::string &category, const std::string &name)
+      : SettingsEntry<std::vector<item_type>>(category, name) {}
+  const list_type_t &value() const { return _items; }
+  void setValue(const list_type_t &items) { _items = items; }
   bool isDefault() const override { return _items.empty(); }
   std::string encode() const override {
     std::ostringstream oss;
-    for (const auto& item : _items) {
+    for (const auto &item : _items) {
       oss << item;
     }
     return oss.str();
   }
-  const std::vector<item_type> decode(const std::string& encoded) const override {
+  const std::vector<item_type>
+  decode(const std::string &encoded) const override {
     std::vector<item_type> items;
     std::stringstream ss;
     ss << encoded;
@@ -349,7 +358,7 @@ public:
     }
     return items;
   }
-  void set(const std::string& encoded) override { setValue(decode(encoded)); }
+  void set(const std::string &encoded) override { setValue(decode(encoded)); }
   const std::tuple<std::string, std::string> help() const override {
     return {"list", ""};
   }
@@ -360,8 +369,7 @@ private:
 
 class SettingsVisitor;
 
-class Settings
-{
+class Settings {
 public:
   static SettingsEntryBool showWarningsIn3dView;
   static SettingsEntryBool mouseCentricZoom;
@@ -484,18 +492,16 @@ public:
   static SettingsEntryDouble axisDeadzone8;
   static SettingsEntryInt joystickNr;
 
-  static void visit(const SettingsVisitor& visitor);
+  static void visit(const SettingsVisitor &visitor);
 };
 
-class SettingsPython
-{
+class SettingsPython {
 public:
   static SettingsEntryString pythonTrustedFiles;
   static SettingsEntryString pythonVirtualEnv;
 };
 
-class SettingsExportPdf
-{
+class SettingsExportPdf {
 public:
   static SettingsEntryBool exportPdfAlwaysShowDialog;
   static SettingsEntryEnum<ExportPdfPaperSize> exportPdfPaperSize;
@@ -520,28 +526,27 @@ public:
   static SettingsEntryDouble exportPdfStrokeWidth;
 
   static constexpr std::array<const SettingsEntryBase *, 17> cmdline{
-    &exportPdfPaperSize,
-    &exportPdfOrientation,
-    &exportPdfShowFilename,
-    &exportPdfShowScale,
-    &exportPdfShowScaleMessage,
-    &exportPdfShowGrid,
-    &exportPdfGridSize,
-    &exportPdfAddMetaData,
-    &exportPdfMetaDataTitle,
-    &exportPdfMetaDataAuthor,
-    &exportPdfMetaDataSubject,
-    &exportPdfMetaDataKeywords,
-    &exportPdfFill,
-    &exportPdfFillColor,
-    &exportPdfStroke,
-    &exportPdfStrokeColor,
-    &exportPdfStrokeWidth,
+      &exportPdfPaperSize,
+      &exportPdfOrientation,
+      &exportPdfShowFilename,
+      &exportPdfShowScale,
+      &exportPdfShowScaleMessage,
+      &exportPdfShowGrid,
+      &exportPdfGridSize,
+      &exportPdfAddMetaData,
+      &exportPdfMetaDataTitle,
+      &exportPdfMetaDataAuthor,
+      &exportPdfMetaDataSubject,
+      &exportPdfMetaDataKeywords,
+      &exportPdfFill,
+      &exportPdfFillColor,
+      &exportPdfStroke,
+      &exportPdfStrokeColor,
+      &exportPdfStrokeWidth,
   };
 };
 
-class SettingsExport3mf
-{
+class SettingsExport3mf {
 public:
   static SettingsEntryBool export3mfAlwaysShowDialog;
   static SettingsEntryEnum<Export3mfColorMode> export3mfColorMode;
@@ -563,28 +568,27 @@ public:
   static SettingsEntryString export3mfMetaDataRating;
 
   static constexpr std::array<const SettingsEntryBase *, 12> cmdline{
-    &export3mfColorMode,
-    &export3mfUnit,
-    &export3mfColor,
-    &export3mfMaterialType,
-    &export3mfDecimalPrecision,
-    &export3mfAddMetaData,
-    &export3mfMetaDataTitle,
-    &export3mfMetaDataDesigner,
-    &export3mfMetaDataDescription,
-    &export3mfMetaDataCopyright,
-    &export3mfMetaDataLicenseTerms,
-    &export3mfMetaDataRating,
+      &export3mfColorMode,
+      &export3mfUnit,
+      &export3mfColor,
+      &export3mfMaterialType,
+      &export3mfDecimalPrecision,
+      &export3mfAddMetaData,
+      &export3mfMetaDataTitle,
+      &export3mfMetaDataDesigner,
+      &export3mfMetaDataDescription,
+      &export3mfMetaDataCopyright,
+      &export3mfMetaDataLicenseTerms,
+      &export3mfMetaDataRating,
   };
 };
 
-class SettingsVisitor
-{
+class SettingsVisitor {
 public:
   SettingsVisitor() = default;
   virtual ~SettingsVisitor() = default;
 
-  virtual void handle(SettingsEntryBase& entry) const = 0;
+  virtual void handle(SettingsEntryBase &entry) const = 0;
 };
 
 } // namespace Settings
diff --git a/src/core/SourceFile.cc b/src/core/SourceFile.cc
index 3b87eb69a..b8a66fef3 100644
--- a/src/core/SourceFile.cc
+++ b/src/core/SourceFile.cc
@@ -25,19 +25,19 @@
  */
 
 #include "core/SourceFile.h"
+#include "core/ScopeContext.h"
 #include "core/SourceFileCache.h"
+#include "core/StatCache.h"
 #include "core/node.h"
-#include "utils/printutils.h"
-#include "utils/exceptions.h"
-#include "core/ScopeContext.h"
 #include "core/parsersettings.h"
-#include "core/StatCache.h"
+#include "utils/exceptions.h"
+#include "utils/printutils.h"
 #include <algorithm>
-#include <ctime>
-#include <ostream>
-#include <memory>
 #include <boost/algorithm/string.hpp>
+#include <ctime>
 #include <filesystem>
+#include <memory>
+#include <ostream>
 #include <string>
 #include <utility>
 #include <vector>
@@ -47,22 +47,17 @@ namespace fs = std::filesystem;
 #include <sys/stat.h>
 
 SourceFile::SourceFile(std::string path, std::string filename)
-  : ASTNode(Location::NONE), path(std::move(path)), filename(std::move(filename))
-{
-}
+    : ASTNode(Location::NONE), path(std::move(path)),
+      filename(std::move(filename)) {}
 
-void SourceFile::print(std::ostream& stream, const std::string& indent) const
-{
+void SourceFile::print(std::ostream &stream, const std::string &indent) const {
   scope.print(stream, indent);
 }
 
-void SourceFile::registerUse(const std::string& path, const Location& loc)
-{
-  PRINTDB("registerUse(): (%p) %d, %d - %d, %d (%s) -> %s", this %
-          loc.firstLine() % loc.firstColumn() %
-          loc.lastLine() % loc.lastColumn() %
-          loc.fileName() %
-          path);
+void SourceFile::registerUse(const std::string &path, const Location &loc) {
+  PRINTDB("registerUse(): (%p) %d, %d - %d, %d (%s) -> %s",
+          this % loc.firstLine() % loc.firstColumn() % loc.lastLine() %
+              loc.lastColumn() % loc.fileName() % path);
 
   auto ext = fs::path(path).extension().generic_string();
 
@@ -74,40 +69,41 @@ void SourceFile::registerUse(const std::string& path, const Location& loc)
     }
   } else {
     auto pos = std::find(usedlibs.begin(), usedlibs.end(), path);
-    if (pos != usedlibs.end()) usedlibs.erase(pos);
+    if (pos != usedlibs.end())
+      usedlibs.erase(pos);
     usedlibs.insert(usedlibs.begin(), path);
     if (!loc.isNone()) {
-      indicatorData.emplace_back(loc.firstLine(), loc.firstColumn(), loc.lastLine(), loc.lastColumn(), path);
+      indicatorData.emplace_back(loc.firstLine(), loc.firstColumn(),
+                                 loc.lastLine(), loc.lastColumn(), path);
     }
   }
 }
 
-void SourceFile::registerInclude(const std::string& localpath, const std::string& fullpath, const Location& loc)
-{
-  PRINTDB("registerInclude(): (%p) %d, %d - %d, %d (%s) -> %s", this %
-          loc.firstLine() % loc.firstColumn() %
-          loc.lastLine() % loc.lastColumn() %
-          localpath %
-          fullpath);
+void SourceFile::registerInclude(const std::string &localpath,
+                                 const std::string &fullpath,
+                                 const Location &loc) {
+  PRINTDB("registerInclude(): (%p) %d, %d - %d, %d (%s) -> %s",
+          this % loc.firstLine() % loc.firstColumn() % loc.lastLine() %
+              loc.lastColumn() % localpath % fullpath);
 
   this->includes[localpath] = fullpath;
   if (!loc.isNone()) {
-    indicatorData.emplace_back(loc.firstLine(), loc.firstColumn(), loc.lastLine(), loc.lastColumn(), fullpath);
+    indicatorData.emplace_back(loc.firstLine(), loc.firstColumn(),
+                               loc.lastLine(), loc.lastColumn(), fullpath);
   }
 }
 
-time_t SourceFile::includesChanged() const
-{
+time_t SourceFile::includesChanged() const {
   time_t latest = 0;
-  for (const auto& item : this->includes) {
+  for (const auto &item : this->includes) {
     auto mtime = include_modified(item.second);
-    if (mtime > latest) latest = mtime;
+    if (mtime > latest)
+      latest = mtime;
   }
   return latest;
 }
 
-time_t SourceFile::include_modified(const std::string& filename) const
-{
+time_t SourceFile::include_modified(const std::string &filename) const {
   struct stat st;
 
   if (StatCache::stat(filename, st) == 0) {
@@ -121,17 +117,18 @@ time_t SourceFile::include_modified(const std::string& filename) const
    Check if any dependencies have been modified and recompile them.
    Returns true if anything was recompiled.
  */
-time_t SourceFile::handleDependencies(bool is_root)
-{
-  if (is_root) SourceFileCache::clear_markers();
-  else if (this->is_handling_dependencies) return 0;
+time_t SourceFile::handleDependencies(bool is_root) {
+  if (is_root)
+    SourceFileCache::clear_markers();
+  else if (this->is_handling_dependencies)
+    return 0;
   this->is_handling_dependencies = true;
 
   std::vector<std::pair<std::string, std::string>> updates;
 
   // If a lib in usedlibs was previously missing, we need to relocate it
-  // by searching the applicable paths. We can identify a previously missing module
-  // as it will have a relative path.
+  // by searching the applicable paths. We can identify a previously missing
+  // module as it will have a relative path.
   time_t latest = 0;
   for (auto filename : this->usedlibs) {
 
@@ -152,8 +149,10 @@ time_t SourceFile::handleDependencies(bool is_root)
     if (found) {
       auto oldmodule = SourceFileCache::instance()->lookup(filename);
       SourceFile *newmodule;
-      auto mtime = SourceFileCache::instance()->evaluate(this->getFullpath(), filename, newmodule);
-      if (mtime > latest) latest = mtime;
+      auto mtime = SourceFileCache::instance()->evaluate(this->getFullpath(),
+                                                         filename, newmodule);
+      if (mtime > latest)
+        latest = mtime;
       auto changed = newmodule && newmodule != oldmodule;
       // Detect appearance but not removal of files, and keep old module
       // on compile errors (FIXME: Is this correct behavior?)
@@ -166,32 +165,36 @@ time_t SourceFile::handleDependencies(bool is_root)
   }
 
   // Relative filenames which were located are reinserted as absolute filenames
-  for (const auto& files : updates) {
+  for (const auto &files : updates) {
     auto pos = std::find(usedlibs.begin(), usedlibs.end(), files.first);
-    if (pos != usedlibs.end()) *pos = files.second;
+    if (pos != usedlibs.end())
+      *pos = files.second;
   }
   return latest;
 }
 
-std::shared_ptr<AbstractNode> SourceFile::instantiate(const std::shared_ptr<const Context>& context, std::shared_ptr<const FileContext> *resulting_file_context) const
-{
+std::shared_ptr<AbstractNode> SourceFile::instantiate(
+    const std::shared_ptr<const Context> &context,
+    std::shared_ptr<const FileContext> *resulting_file_context) const {
   auto node = std::make_shared<RootNode>();
   try {
-    ContextHandle<FileContext> file_context{Context::create<FileContext>(context, this)};
+    ContextHandle<FileContext> file_context{
+        Context::create<FileContext>(context, this)};
     *resulting_file_context = *file_context;
     this->scope.instantiateModules(*file_context, node);
-  } catch (HardWarningException& e) {
+  } catch (HardWarningException &e) {
     throw;
-  } catch (EvaluationException& e) {
-    // LOG(message_group::NONE,,e.what()); //please output the message before throwing the exception
+  } catch (EvaluationException &e) {
+    // LOG(message_group::NONE,,e.what()); //please output the message before
+    // throwing the exception
     *resulting_file_context = nullptr;
   }
   return node;
 }
 
-//please preferably use getFilename
-//if you compare filenames (which is the origin of this method),
-//please call getFilename first and use this method only as a fallback
+// please preferably use getFilename
+// if you compare filenames (which is the origin of this method),
+// please call getFilename first and use this method only as a fallback
 const std::string SourceFile::getFullpath() const {
   if (fs::path(this->filename).is_absolute()) {
     return this->filename;
diff --git a/src/core/SourceFile.h b/src/core/SourceFile.h
index 903b69c43..df5348570 100644
--- a/src/core/SourceFile.h
+++ b/src/core/SourceFile.h
@@ -1,37 +1,39 @@
 #pragma once
 
-#include <ostream>
+#include <ctime>
 #include <memory>
+#include <ostream>
 #include <string>
 #include <unordered_map>
-#include <ctime>
 #include <vector>
 
-#include "core/module.h"
 #include "core/AST.h"
-#include "core/LocalScope.h"
 #include "core/IndicatorData.h"
+#include "core/LocalScope.h"
+#include "core/module.h"
 
-class SourceFile : public ASTNode
-{
+class SourceFile : public ASTNode {
 public:
   SourceFile(std::string path, std::string filename);
 
-  std::shared_ptr<AbstractNode> instantiate(const std::shared_ptr<const Context>& context, std::shared_ptr<const class FileContext> *resulting_file_context) const;
-  void print(std::ostream& stream, const std::string& indent) const override;
+  std::shared_ptr<AbstractNode> instantiate(
+      const std::shared_ptr<const Context> &context,
+      std::shared_ptr<const class FileContext> *resulting_file_context) const;
+  void print(std::ostream &stream, const std::string &indent) const override;
 
-  void setModulePath(const std::string& path) { this->path = path; }
-  const std::string& modulePath() const { return this->path; }
-  void registerUse(const std::string& path, const Location& loc);
-  void registerInclude(const std::string& localpath, const std::string& fullpath, const Location& loc);
+  void setModulePath(const std::string &path) { this->path = path; }
+  const std::string &modulePath() const { return this->path; }
+  void registerUse(const std::string &path, const Location &loc);
+  void registerInclude(const std::string &localpath,
+                       const std::string &fullpath, const Location &loc);
   std::time_t includesChanged() const;
   std::time_t handleDependencies(bool is_root = true);
   bool hasIncludes() const { return !this->includes.empty(); }
   bool usesLibraries() const { return !this->usedlibs.empty(); }
   bool isHandlingDependencies() const { return this->is_handling_dependencies; }
   void clearHandlingDependencies() { this->is_handling_dependencies = false; }
-  void setFilename(const std::string& filename) { this->filename = filename; }
-  const std::string& getFilename() const { return this->filename; }
+  void setFilename(const std::string &filename) { this->filename = filename; }
+  const std::string &getFilename() const { return this->filename; }
   const std::string getFullpath() const;
 
   LocalScope scope;
@@ -40,7 +42,7 @@ public:
   std::vector<IndicatorData> indicatorData;
 
 private:
-  std::time_t include_modified(const std::string& filename) const;
+  std::time_t include_modified(const std::string &filename) const;
 
   std::unordered_map<std::string, std::string> includes;
   bool is_handling_dependencies{false};
diff --git a/src/core/SourceFileCache.cc b/src/core/SourceFileCache.cc
index 72523479c..6607b5eb9 100644
--- a/src/core/SourceFileCache.cc
+++ b/src/core/SourceFileCache.cc
@@ -1,19 +1,20 @@
 #include "core/SourceFileCache.h"
-#include "core/StatCache.h"
 #include "core/SourceFile.h"
-#include "utils/printutils.h"
+#include "core/StatCache.h"
 #include "openscad.h"
-#include <ctime>
+#include "utils/printutils.h"
 #include <boost/format.hpp>
+#include <ctime>
 
+#include <algorithm>
 #include <cstdio>
 #include <fstream>
 #include <string>
 #include <sys/stat.h>
-#include <algorithm>
 
 /*!
-   FIXME: Implement an LRU scheme to avoid having an ever-growing source file cache
+   FIXME: Implement an LRU scheme to avoid having an ever-growing source file
+   cache
  */
 
 SourceFileCache *SourceFileCache::inst = nullptr;
@@ -23,13 +24,15 @@ SourceFileCache *SourceFileCache::inst = nullptr;
    needing reevaluation. Updates the cache if necessary.
    The given filename must be absolute.
 
-   Sets the given source file reference to the new file, or nullptr on any error (e.g. compile
-   error or file not found).
+   Sets the given source file reference to the new file, or nullptr on any error
+   (e.g. compile error or file not found).
 
-   Returns the latest modification time of the file, its dependencies or includes.
+   Returns the latest modification time of the file, its dependencies or
+   includes.
  */
-std::time_t SourceFileCache::evaluate(const std::string& mainFile, const std::string& filename, SourceFile *& sourceFile)
-{
+std::time_t SourceFileCache::evaluate(const std::string &mainFile,
+                                      const std::string &filename,
+                                      SourceFile *&sourceFile) {
   sourceFile = nullptr;
   auto entry = this->entries.find(filename);
   bool found{entry != this->entries.end()};
@@ -37,19 +40,21 @@ std::time_t SourceFileCache::evaluate(const std::string& mainFile, const std::st
 
   // Don't try to recursively evaluate - if the file changes
   // during evaluation, that would be really bad.
-  if (file && file->isHandlingDependencies()) return 0;
+  if (file && file->isHandlingDependencies())
+    return 0;
 
   // Create cache ID
   struct stat st;
   bool valid = (StatCache::stat(filename, st) == 0);
 
   // If file isn't there, just return and let the cache retain the old file
-  if (!valid) return 0;
+  if (!valid)
+    return 0;
 
   // If the file is present, we'll always cache some result
   std::string cache_id = str(boost::format("%x.%x") % st.st_mtime % st.st_size);
 
-  cache_entry& cacheEntry = this->entries[filename];
+  cache_entry &cacheEntry = this->entries[filename];
   // Initialize entry, if new
   if (!found) {
     cacheEntry.file = nullptr;
@@ -77,7 +82,8 @@ std::time_t SourceFileCache::evaluate(const std::string& mainFile, const std::st
 
 #ifdef DEBUG
   // Causes too much debug output
-  //if (!shouldCompile) LOG(message_group::NONE,,"Using cached library: %1$s (%2$p)",filename,file);
+  // if (!shouldCompile) LOG(message_group::NONE,,"Using cached library: %1$s
+  // (%2$p)",filename,file);
 #endif
 
   // If cache lookup failed (non-existing or old timestamp), compile file
@@ -94,7 +100,8 @@ std::time_t SourceFileCache::evaluate(const std::string& mainFile, const std::st
     {
       std::ifstream ifs(filename.c_str());
       if (!ifs.is_open()) {
-        LOG(message_group::Warning, "Can't open library file '%1$s'\n", filename);
+        LOG(message_group::Warning, "Can't open library file '%1$s'\n",
+            filename);
         return 0;
       }
       text = STR(ifs.rdbuf(), "\n\x03\n", commandline_commands);
@@ -103,12 +110,15 @@ std::time_t SourceFileCache::evaluate(const std::string& mainFile, const std::st
     print_messages_push();
 
     delete cacheEntry.parsed_file;
-    file = parse(cacheEntry.parsed_file, text, filename, mainFile, false) ? cacheEntry.parsed_file : nullptr;
+    file = parse(cacheEntry.parsed_file, text, filename, mainFile, false)
+               ? cacheEntry.parsed_file
+               : nullptr;
     PRINTDB("compiled file: %s", filename);
     cacheEntry.file = file;
     cacheEntry.cache_id = cache_id;
     auto mod = file ? file : cacheEntry.parsed_file;
-    if (!found && mod) cacheEntry.includes_mtime = mod->includesChanged();
+    if (!found && mod)
+      cacheEntry.includes_mtime = mod->includesChanged();
     print_messages_pop();
   }
 
@@ -119,18 +129,15 @@ std::time_t SourceFileCache::evaluate(const std::string& mainFile, const std::st
   return std::max({deps_mtime, cacheEntry.mtime, cacheEntry.includes_mtime});
 }
 
-void SourceFileCache::clear()
-{
-  this->entries.clear();
-}
+void SourceFileCache::clear() { this->entries.clear(); }
 
-SourceFile *SourceFileCache::lookup(const std::string& filename)
-{
+SourceFile *SourceFileCache::lookup(const std::string &filename) {
   auto it = this->entries.find(filename);
   return it != this->entries.end() ? it->second.file : nullptr;
 }
 
 void SourceFileCache::clear_markers() {
-  for (const auto& entry : instance()->entries)
-    if (auto lib = entry.second.file) lib->clearHandlingDependencies();
+  for (const auto &entry : instance()->entries)
+    if (auto lib = entry.second.file)
+      lib->clearHandlingDependencies();
 }
diff --git a/src/core/SourceFileCache.h b/src/core/SourceFileCache.h
index eb736a530..8aba61b32 100644
--- a/src/core/SourceFileCache.h
+++ b/src/core/SourceFileCache.h
@@ -1,7 +1,7 @@
 #pragma once
 
-#include <string>
 #include <ctime>
+#include <string>
 #include <unordered_map>
 
 class SourceFile;
@@ -9,13 +9,17 @@ class SourceFile;
 /*!
    Caches SourceFiles based on their filenames
  */
-class SourceFileCache
-{
+class SourceFileCache {
 public:
-  static SourceFileCache *instance() { if (!inst) inst = new SourceFileCache; return inst; }
+  static SourceFileCache *instance() {
+    if (!inst)
+      inst = new SourceFileCache;
+    return inst;
+  }
 
-  std::time_t evaluate(const std::string& mainFile, const std::string& filename, SourceFile *& sourceFile);
-  SourceFile *lookup(const std::string& filename);
+  std::time_t evaluate(const std::string &mainFile, const std::string &filename,
+                       SourceFile *&sourceFile);
+  SourceFile *lookup(const std::string &filename);
   size_t size() const { return this->entries.size(); }
   void clear();
   static void clear_markers();
@@ -27,9 +31,9 @@ private:
 
   struct cache_entry {
     SourceFile *file{};
-    SourceFile *parsed_file{};                   // the last version parsed for the include list
+    SourceFile *parsed_file{}; // the last version parsed for the include list
     std::string cache_id;
-    std::time_t mtime{}; // time file last modified
+    std::time_t mtime{};          // time file last modified
     std::time_t includes_mtime{}; // time the includes last changed
   };
   std::unordered_map<std::string, cache_entry> entries;
diff --git a/src/core/StatCache.cc b/src/core/StatCache.cc
index cf7cf0737..9f84afaac 100644
--- a/src/core/StatCache.cc
+++ b/src/core/StatCache.cc
@@ -26,22 +26,23 @@
 
 #include "core/StatCache.h"
 
+#include <chrono>
 #include <string>
 #include <unordered_map>
-#include <chrono>
 
 namespace {
 
-const float stale = 190;  // 190ms, maximum lifetime of a cache entry chosen to be shorter than the automatic reload poll time
+const float stale = 190; // 190ms, maximum lifetime of a cache entry chosen to
+                         // be shorter than the automatic reload poll time
 
-double millis_clock()
-{
-  return std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
+double millis_clock() {
+  return std::chrono::duration_cast<std::chrono::milliseconds>(
+             std::chrono::system_clock::now().time_since_epoch())
+      .count();
 }
 
-struct CacheEntry
-{
-  struct stat st;  // result from stat
+struct CacheEntry {
+  struct stat st;   // result from stat
   double timestamp; // the time stat was called
 };
 
@@ -51,17 +52,17 @@ std::unordered_map<std::string, CacheEntry> statMap;
 
 namespace StatCache {
 
-int stat(const std::string& path, struct ::stat &st)
-{
+int stat(const std::string &path, struct ::stat &st) {
   auto iter = statMap.find(path);
-  if (iter != statMap.end()) {                // Have we got an entry for this file?
+  if (iter != statMap.end()) { // Have we got an entry for this file?
     if (millis_clock() - iter->second.timestamp < stale) {
-      st = iter->second.st;      // Not stale yet so return it
+      st = iter->second.st; // Not stale yet so return it
       return 0;
     }
-    statMap.erase(iter);                // Remove stale entry
+    statMap.erase(iter); // Remove stale entry
   }
-  if (auto rv = ::stat(path.c_str(), &st)) return rv; // stat failed
+  if (auto rv = ::stat(path.c_str(), &st))
+    return rv; // stat failed
   statMap[path] = {st, millis_clock()};
   return 0;
 }
diff --git a/src/core/StatCache.h b/src/core/StatCache.h
index bc46f5f2b..7d82cf9fb 100644
--- a/src/core/StatCache.h
+++ b/src/core/StatCache.h
@@ -31,6 +31,6 @@
 
 namespace StatCache {
 
-int stat(const std::string& path, struct ::stat &st);
+int stat(const std::string &path, struct ::stat &st);
 
 }
diff --git a/src/core/State.h b/src/core/State.h
index c327fe66e..279626e17 100644
--- a/src/core/State.h
+++ b/src/core/State.h
@@ -1,17 +1,16 @@
 #pragma once
 
+#include "core/node.h"
+#include "geometry/linalg.h"
 #include <cstring>
 #include <memory>
 #include <utility>
-#include "geometry/linalg.h"
-#include "core/node.h"
 
-class State
-{
+class State {
 
 public:
   State(std::shared_ptr<const AbstractNode> parent)
-    : parentnode(std::move(parent)) {
+      : parentnode(std::move(parent)) {
     this->matrix_ = Transform3d::Identity();
   }
 
@@ -20,9 +19,11 @@ public:
   void setHighlight(bool on) { FLAG(this->flags, HIGHLIGHT, on); }
   void setBackground(bool on) { FLAG(this->flags, BACKGROUND, on); }
   void setNumChildren(unsigned int numc) { this->numchildren = numc; }
-  void setParent(const std::shared_ptr<const AbstractNode>& parent) { this->parentnode = parent; }
-  void setMatrix(const Transform3d& m) { this->matrix_ = m; }
-  void setColor(const Color4f& c) { this->color_ = c; }
+  void setParent(const std::shared_ptr<const AbstractNode> &parent) {
+    this->parentnode = parent;
+  }
+  void setMatrix(const Transform3d &m) { this->matrix_ = m; }
+  void setColor(const Color4f &c) { this->color_ = c; }
   void setPreferNef(bool on) { FLAG(this->flags, PREFERNEF, on); }
   [[nodiscard]] bool preferNef() const { return this->flags & PREFERNEF; }
 
@@ -31,21 +32,23 @@ public:
   [[nodiscard]] bool isHighlight() const { return this->flags & HIGHLIGHT; }
   [[nodiscard]] bool isBackground() const { return this->flags & BACKGROUND; }
   [[nodiscard]] unsigned int numChildren() const { return this->numchildren; }
-  [[nodiscard]] std::shared_ptr<const AbstractNode> parent() const { return this->parentnode; }
-  [[nodiscard]] const Transform3d& matrix() const { return this->matrix_; }
-  [[nodiscard]] const Color4f& color() const { return this->color_; }
+  [[nodiscard]] std::shared_ptr<const AbstractNode> parent() const {
+    return this->parentnode;
+  }
+  [[nodiscard]] const Transform3d &matrix() const { return this->matrix_; }
+  [[nodiscard]] const Color4f &color() const { return this->color_; }
 
 private:
   enum StateFlags : unsigned int {
-    NONE       = 0x00u,
-    PREFIX     = 0x01u,
-    POSTFIX    = 0x02u,
-    PREFERNEF  = 0x04u,
-    HIGHLIGHT  = 0x08u,
+    NONE = 0x00u,
+    PREFIX = 0x01u,
+    POSTFIX = 0x02u,
+    PREFERNEF = 0x04u,
+    HIGHLIGHT = 0x08u,
     BACKGROUND = 0x10u
   };
 
-  constexpr void FLAG(unsigned int& var, StateFlags flag, bool on) {
+  constexpr void FLAG(unsigned int &var, StateFlags flag, bool on) {
     if (on) {
       var |= flag;
     } else {
diff --git a/src/core/SurfaceNode.cc b/src/core/SurfaceNode.cc
index 2e5134bbe..134340bca 100644
--- a/src/core/SurfaceNode.cc
+++ b/src/core/SurfaceNode.cc
@@ -26,51 +26,55 @@
 
 #include "core/SurfaceNode.h"
 
-#include "core/module.h"
+#include "core/Builtins.h"
+#include "core/Children.h"
 #include "core/ModuleInstantiation.h"
+#include "core/Parameters.h"
+#include "core/module.h"
 #include "core/node.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetBuilder.h"
-#include "core/Builtins.h"
-#include "core/Children.h"
-#include "core/Parameters.h"
-#include "utils/printutils.h"
-#include "io/fileutils.h"
 #include "handle_dep.h"
+#include "io/fileutils.h"
 #include "lodepng/lodepng.h"
+#include "utils/printutils.h"
 
 #include <algorithm>
+#include <cstddef>
+#include <cstdint>
 #include <cstring>
+#include <fstream>
+#include <memory>
 #include <new>
+#include <sstream>
 #include <string>
+#include <unordered_map>
 #include <utility>
-#include <memory>
-#include <cstdint>
-#include <cstddef>
-#include <sstream>
-#include <fstream>
 #include <vector>
-#include <unordered_map>
 
-#include <boost/functional/hash.hpp>
-#include <boost/tokenizer.hpp>
-#include <boost/lexical_cast.hpp>
 #include <boost/algorithm/string.hpp>
 #include <boost/assign/std/vector.hpp>
+#include <boost/functional/hash.hpp>
+#include <boost/lexical_cast.hpp>
+#include <boost/tokenizer.hpp>
 using namespace boost::assign; // bring 'operator+=()' into scope
 
 #include <filesystem>
 namespace fs = std::filesystem;
 
-
-static std::shared_ptr<AbstractNode> builtin_surface(const ModuleInstantiation *inst, Arguments arguments)
-{
+static std::shared_ptr<AbstractNode>
+builtin_surface(const ModuleInstantiation *inst, Arguments arguments) {
   auto node = std::make_shared<SurfaceNode>(inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"file", "center", "convexity"}, {"invert"});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(),
+                        {"file", "center", "convexity"}, {"invert"});
 
-  std::string fileval = parameters["file"].isUndefined() ? "" : parameters["file"].toString();
-  auto filename = lookup_file(fileval, inst->location().filePath().parent_path().string(), parameters.documentRoot());
+  std::string fileval =
+      parameters["file"].isUndefined() ? "" : parameters["file"].toString();
+  auto filename =
+      lookup_file(fileval, inst->location().filePath().parent_path().string(),
+                  parameters.documentRoot());
   node->filename = filename;
   handle_dep(fs::path(filename).generic_string());
 
@@ -89,46 +93,47 @@ static std::shared_ptr<AbstractNode> builtin_surface(const ModuleInstantiation *
   return node;
 }
 
-void SurfaceNode::convert_image(img_data_t& data, std::vector<uint8_t>& img, unsigned int width, unsigned int height) const
-{
+void SurfaceNode::convert_image(img_data_t &data, std::vector<uint8_t> &img,
+                                unsigned int width, unsigned int height) const {
   data.width = width;
   data.height = height;
-  data.resize( (size_t)width * height);
+  data.resize((size_t)width * height);
   double min_val = 200;
   for (unsigned int y = 0; y < height; ++y) {
     for (unsigned int x = 0; x < width; ++x) {
       long idx = 4l * (y * width + x);
-      double pixel = 0.2126 * img[idx] + 0.7152 * img[idx + 1] + 0.0722 * img[idx + 2];
+      double pixel =
+          0.2126 * img[idx] + 0.7152 * img[idx + 1] + 0.0722 * img[idx + 2];
       double z = 100.0 / 255 * (invert ? 1 - pixel : pixel);
-      data[ x + (width * (height - 1 - y)) ] = z;
+      data[x + (width * (height - 1 - y))] = z;
       min_val = std::min(z, min_val);
     }
   }
   data.min_val = min_val;
 }
 
-bool SurfaceNode::is_png(std::vector<uint8_t>& png) const
-{
+bool SurfaceNode::is_png(std::vector<uint8_t> &png) const {
   const size_t pngHeaderLength = 8;
-  const uint8_t pngHeader[pngHeaderLength] = {0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a};
+  const uint8_t pngHeader[pngHeaderLength] = {0x89, 0x50, 0x4e, 0x47,
+                                              0x0d, 0x0a, 0x1a, 0x0a};
   return (png.size() >= pngHeaderLength &&
           std::memcmp(png.data(), pngHeader, pngHeaderLength) == 0);
 }
 
-img_data_t SurfaceNode::read_png_or_dat(std::string filename) const
-{
+img_data_t SurfaceNode::read_png_or_dat(std::string filename) const {
   img_data_t data;
   std::vector<uint8_t> png;
   int ret_val = 0;
-  try{
+  try {
     ret_val = lodepng::load_file(png, filename);
-  } catch (std::bad_alloc& ba) {
+  } catch (std::bad_alloc &ba) {
     LOG(message_group::Warning, "bad_alloc caught for '%1$s'.", ba.what());
     return data;
   }
 
   if (ret_val == 78) {
-    LOG(message_group::Warning, "The file '%1$s' couldn't be opened.", filename);
+    LOG(message_group::Warning, "The file '%1$s' couldn't be opened.",
+        filename);
     return data;
   }
 
@@ -151,8 +156,7 @@ img_data_t SurfaceNode::read_png_or_dat(std::string filename) const
   return data;
 }
 
-img_data_t SurfaceNode::read_dat(std::string filename) const
-{
+img_data_t SurfaceNode::read_dat(std::string filename) const {
   img_data_t data;
   std::ifstream stream(filename.c_str());
 
@@ -162,14 +166,17 @@ img_data_t SurfaceNode::read_dat(std::string filename) const
   }
 
   int lines = 0, columns = 0;
-  double min_val = 1; // this balances out with the (min_val-1) inside createGeometry, to match old behavior
+  double min_val = 1; // this balances out with the (min_val-1) inside
+                      // createGeometry, to match old behavior
 
   using tokenizer = boost::tokenizer<boost::char_separator<char>>;
   boost::char_separator<char> sep(" \t");
 
   // We use an unordered map because the data file may not be rectangular,
   // and we may need to fill in some bits.
-  using unordered_image_data_t = std::unordered_map<std::pair<int, int>, double, boost::hash<std::pair<int, int>>>;
+  using unordered_image_data_t =
+      std::unordered_map<std::pair<int, int>, double,
+                         boost::hash<std::pair<int, int>>>;
   unordered_image_data_t unordered_data;
 
   while (!stream.eof()) {
@@ -178,20 +185,23 @@ img_data_t SurfaceNode::read_dat(std::string filename) const
       std::getline(stream, line);
       boost::trim(line);
     }
-    if (line.size() == 0 && stream.eof()) break;
+    if (line.size() == 0 && stream.eof())
+      break;
 
     int col = 0;
     tokenizer tokens(line, sep);
     try {
-      for (const auto& token : tokens) {
+      for (const auto &token : tokens) {
         auto v = boost::lexical_cast<double>(token);
-        unordered_data[ std::make_pair(lines, col++) ] = v;
-        if (col > columns) columns = col;
+        unordered_data[std::make_pair(lines, col++)] = v;
+        if (col > columns)
+          columns = col;
         min_val = std::min(v, min_val);
       }
-    } catch (const boost::bad_lexical_cast& blc) {
+    } catch (const boost::bad_lexical_cast &blc) {
       if (!stream.eof()) {
-        LOG(message_group::Warning, "Illegal value in '%1$s': %2$s", filename, blc.what());
+        LOG(message_group::Warning, "Illegal value in '%1$s': %2$s", filename,
+            blc.what());
       }
       return data;
     }
@@ -203,116 +213,101 @@ img_data_t SurfaceNode::read_dat(std::string filename) const
   data.height = lines;
   data.min_val = min_val;
 
-  // Now convert the unordered, possibly non-rectangular data into a well ordered vector
-  // for faster access and reduced memory usage.
-  data.resize( (size_t)lines * columns);
+  // Now convert the unordered, possibly non-rectangular data into a well
+  // ordered vector for faster access and reduced memory usage.
+  data.resize((size_t)lines * columns);
   for (int i = 0; i < lines; ++i)
     for (int j = 0; j < columns; ++j)
-      data[ i * columns + j ] = unordered_data[std::make_pair(i, j)];
+      data[i * columns + j] = unordered_data[std::make_pair(i, j)];
 
   return data;
 }
 
 // FIXME: Look for faster way to generate PolySet directly
-std::unique_ptr<const Geometry> SurfaceNode::createGeometry() const
-{
+std::unique_ptr<const Geometry> SurfaceNode::createGeometry() const {
   auto data = read_png_or_dat(filename);
 
   int lines = data.height;
   int columns = data.width;
-  double min_val = data.min_value() - 1; // make the bottom solid, and match old code
+  double min_val =
+      data.min_value() - 1; // make the bottom solid, and match old code
 
   // reserve the polygon vector size so we don't have to reallocate as often
 
   double ox = center ? -(columns - 1) / 2.0 : 0;
   double oy = center ? -(lines - 1) / 2.0 : 0;
 
-  int num_indices = (lines - 1) * (columns - 1) * 4 + (lines - 1) * 2 + (columns - 1) * 2 + 1;
+  int num_indices =
+      (lines - 1) * (columns - 1) * 4 + (lines - 1) * 2 + (columns - 1) * 2 + 1;
   PolySetBuilder builder(0, num_indices);
   builder.setConvexity(convexity);
   // the bulk of the heightmap
   for (int i = 1; i < lines; ++i)
     for (int j = 1; j < columns; ++j) {
-      double v1 = data[ (j - 1) + (i - 1) * columns ];
-      double v2 = data[ (j) + (i - 1) * columns ];
-      double v3 = data[ (j - 1) + (i) * columns ];
-      double v4 = data[ (j) + (i) * columns ];
+      double v1 = data[(j - 1) + (i - 1) * columns];
+      double v2 = data[(j) + (i - 1) * columns];
+      double v3 = data[(j - 1) + (i)*columns];
+      double v4 = data[(j) + (i)*columns];
 
       double vx = (v1 + v2 + v3 + v4) / 4;
 
-      builder.appendPolygon({
-        Vector3d(ox + j - 1, oy + i - 1, v1),
-        Vector3d(ox + j, oy + i - 1, v2),
-        Vector3d(ox + j - 0.5, oy + i - 0.5, vx)
-      });
-
-      builder.appendPolygon({
-        Vector3d(ox + j, oy + i - 1, v2),
-        Vector3d(ox + j, oy + i, v4),
-        Vector3d(ox + j - 0.5, oy + i - 0.5, vx)
-      });
-
-      builder.appendPolygon({
-        Vector3d(ox + j, oy + i, v4),
-        Vector3d(ox + j - 1, oy + i, v3),
-        Vector3d(ox + j - 0.5, oy + i - 0.5, vx)
-      });
-
-      builder.appendPolygon({
-        Vector3d(ox + j - 1, oy + i, v3),
-        Vector3d(ox + j - 1, oy + i - 1, v1),
-        Vector3d(ox + j - 0.5, oy + i - 0.5, vx)
-      });
+      builder.appendPolygon({Vector3d(ox + j - 1, oy + i - 1, v1),
+                             Vector3d(ox + j, oy + i - 1, v2),
+                             Vector3d(ox + j - 0.5, oy + i - 0.5, vx)});
+
+      builder.appendPolygon({Vector3d(ox + j, oy + i - 1, v2),
+                             Vector3d(ox + j, oy + i, v4),
+                             Vector3d(ox + j - 0.5, oy + i - 0.5, vx)});
+
+      builder.appendPolygon({Vector3d(ox + j, oy + i, v4),
+                             Vector3d(ox + j - 1, oy + i, v3),
+                             Vector3d(ox + j - 0.5, oy + i - 0.5, vx)});
+
+      builder.appendPolygon({Vector3d(ox + j - 1, oy + i, v3),
+                             Vector3d(ox + j - 1, oy + i - 1, v1),
+                             Vector3d(ox + j - 0.5, oy + i - 0.5, vx)});
     }
 
   // edges along Y
   for (int i = 1; i < lines; ++i) {
-    double v1 = data[ (0) + (i - 1) * columns ];
-    double v2 = data[ (0) + (i) * columns ];
-    double v3 = data[ (columns - 1) + (i - 1) * columns ];
-    double v4 = data[ (columns - 1) + (i) * columns ];
-
-
-    builder.appendPolygon({
-      Vector3d(ox + 0, oy + i - 1, min_val),
-      Vector3d(ox + 0, oy + i - 1, v1),
-      Vector3d(ox + 0, oy + i, v2),
-      Vector3d(ox + 0, oy + i, min_val)
-    });
-
-    builder.appendPolygon({
-      Vector3d(ox + columns - 1, oy + i, min_val),
-      Vector3d(ox + columns - 1, oy + i, v4),
-      Vector3d(ox + columns - 1, oy + i - 1, v3),
-      Vector3d(ox + columns - 1, oy + i - 1, min_val)
-    });
+    double v1 = data[(0) + (i - 1) * columns];
+    double v2 = data[(0) + (i)*columns];
+    double v3 = data[(columns - 1) + (i - 1) * columns];
+    double v4 = data[(columns - 1) + (i)*columns];
+
+    builder.appendPolygon({Vector3d(ox + 0, oy + i - 1, min_val),
+                           Vector3d(ox + 0, oy + i - 1, v1),
+                           Vector3d(ox + 0, oy + i, v2),
+                           Vector3d(ox + 0, oy + i, min_val)});
+
+    builder.appendPolygon({Vector3d(ox + columns - 1, oy + i, min_val),
+                           Vector3d(ox + columns - 1, oy + i, v4),
+                           Vector3d(ox + columns - 1, oy + i - 1, v3),
+                           Vector3d(ox + columns - 1, oy + i - 1, min_val)});
   }
 
   // edges along X
   for (int i = 1; i < columns; ++i) {
-    double v1 = data[ (i - 1) + (0) * columns ];
-    double v2 = data[ (i) + (0) * columns ];
-    double v3 = data[ (i - 1) + (lines - 1) * columns ];
-    double v4 = data[ (i) + (lines - 1) * columns ];
-
-    builder.appendPolygon({
-      Vector3d(ox + i, oy + 0, min_val),
-      Vector3d(ox + i, oy + 0, v2),
-      Vector3d(ox + i - 1, oy + 0, v1),
-      Vector3d(ox + i - 1, oy + 0, min_val)
-    });
-
-    builder.appendPolygon({
-      Vector3d(ox + i - 1, oy + lines - 1, min_val),
-      Vector3d(ox + i - 1, oy + lines - 1, v3),
-      Vector3d(ox + i, oy + lines - 1, v4),
-      Vector3d(ox + i, oy + lines - 1, min_val)
-    });
+    double v1 = data[(i - 1) + (0) * columns];
+    double v2 = data[(i) + (0) * columns];
+    double v3 = data[(i - 1) + (lines - 1) * columns];
+    double v4 = data[(i) + (lines - 1) * columns];
+
+    builder.appendPolygon({Vector3d(ox + i, oy + 0, min_val),
+                           Vector3d(ox + i, oy + 0, v2),
+                           Vector3d(ox + i - 1, oy + 0, v1),
+                           Vector3d(ox + i - 1, oy + 0, min_val)});
+
+    builder.appendPolygon({Vector3d(ox + i - 1, oy + lines - 1, min_val),
+                           Vector3d(ox + i - 1, oy + lines - 1, v3),
+                           Vector3d(ox + i, oy + lines - 1, v4),
+                           Vector3d(ox + i, oy + lines - 1, min_val)});
   }
 
-  // the bottom of the shape (one less than the real minimum value), making it a solid volume
+  // the bottom of the shape (one less than the real minimum value), making it a
+  // solid volume
   if (columns > 1 && lines > 1) {
-    builder.beginPolygon(2 * (columns - 1) + 2 * (lines - 1) );
+    builder.beginPolygon(2 * (columns - 1) + 2 * (lines - 1));
     for (int i = 0; i < lines - 1; ++i)
       builder.addVertex(Vector3d(ox + 0, oy + i, min_val));
     for (int i = 0; i < columns - 1; ++i)
@@ -326,24 +321,23 @@ std::unique_ptr<const Geometry> SurfaceNode::createGeometry() const
   return builder.build();
 }
 
-std::string SurfaceNode::toString() const
-{
+std::string SurfaceNode::toString() const {
   std::ostringstream stream;
   fs::path path{static_cast<std::string>(this->filename)}; // gcc-4.6
 
   stream << this->name() << "(file = " << this->filename
          << ", center = " << (this->center ? "true" : "false")
          << ", invert = " << (this->invert ? "true" : "false")
-         << ", " "timestamp = " << fs_timestamp(path)
-         << ")";
+         << ", "
+            "timestamp = "
+         << fs_timestamp(path) << ")";
 
   return stream.str();
 }
 
-void register_builtin_surface()
-{
+void register_builtin_surface() {
   Builtins::init("surface", new BuiltinModule(builtin_surface),
-  {
-    "surface(string, center = false, invert = false, number)",
-  });
+                 {
+                     "surface(string, center = false, invert = false, number)",
+                 });
 }
diff --git a/src/core/SurfaceNode.h b/src/core/SurfaceNode.h
index df58f84a9..116143be4 100644
--- a/src/core/SurfaceNode.h
+++ b/src/core/SurfaceNode.h
@@ -24,49 +24,52 @@
  *
  */
 
+#include <cstddef>
 #include <cstdint>
 #include <memory>
-#include <cstddef>
 #include <string>
 #include <vector>
 
-#include "core/node.h"
 #include "core/ModuleInstantiation.h"
 #include "core/Value.h"
+#include "core/node.h"
 
-struct img_data_t
-{
+struct img_data_t {
 public:
   using storage_type = double; // float could be enough here
 
   img_data_t() {
-    min_val = 0; height = width = 0;
+    min_val = 0;
+    height = width = 0;
   }
 
-  void clear() { min_val = 0; height = width = 0; storage.clear(); }
+  void clear() {
+    min_val = 0;
+    height = width = 0;
+    storage.clear();
+  }
 
   void reserve(size_t x) { storage.reserve(x); }
 
   void resize(size_t x) { storage.resize(x); }
 
-  storage_type& operator[](int x) { return storage[x]; }
+  storage_type &operator[](int x) { return storage[x]; }
 
-  storage_type min_value() { return min_val; } // *std::min_element(storage.begin(), storage.end());
+  storage_type min_value() {
+    return min_val;
+  } // *std::min_element(storage.begin(), storage.end());
 
 public:
   unsigned int height; // rows
-  unsigned int width; // columns
+  unsigned int width;  // columns
   storage_type min_val;
   std::vector<storage_type> storage;
-
 };
 
-
-class SurfaceNode : public LeafNode
-{
+class SurfaceNode : public LeafNode {
 public:
   VISITABLE();
-  SurfaceNode(const ModuleInstantiation *mi) : LeafNode(mi) { }
+  SurfaceNode(const ModuleInstantiation *mi) : LeafNode(mi) {}
   std::string toString() const override;
   std::string name() const override { return "surface"; }
 
@@ -76,9 +79,11 @@ public:
   int convexity{1};
 
   std::unique_ptr<const Geometry> createGeometry() const override;
+
 private:
-  void convert_image(img_data_t& data, std::vector<uint8_t>& img, unsigned int width, unsigned int height) const;
-  bool is_png(std::vector<uint8_t>& img) const;
+  void convert_image(img_data_t &data, std::vector<uint8_t> &img,
+                     unsigned int width, unsigned int height) const;
+  bool is_png(std::vector<uint8_t> &img) const;
   img_data_t read_dat(std::string filename) const;
   img_data_t read_png_or_dat(std::string filename) const;
 };
diff --git a/src/core/TextNode.cc b/src/core/TextNode.cc
index 274971622..c0b262545 100644
--- a/src/core/TextNode.cc
+++ b/src/core/TextNode.cc
@@ -26,31 +26,30 @@
 
 #include "core/TextNode.h"
 
-#include <utility>
 #include <memory>
+#include <utility>
 #include <vector>
 
+#include "core/Builtins.h"
 #include "core/Children.h"
-#include "core/module.h"
 #include "core/ModuleInstantiation.h"
 #include "core/Parameters.h"
+#include "core/module.h"
 #include "utils/printutils.h"
-#include "core/Builtins.h"
 
 #include "core/FreetypeRenderer.h"
 
 #include <boost/assign/std/vector.hpp>
 using namespace boost::assign; // bring 'operator+=()' into scope
 
-static std::shared_ptr<AbstractNode> builtin_text(const ModuleInstantiation *inst, Arguments arguments)
-{
+static std::shared_ptr<AbstractNode>
+builtin_text(const ModuleInstantiation *inst, Arguments arguments) {
   auto node = std::make_shared<TextNode>(inst);
 
   auto *session = arguments.session();
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(),
-                                            {"text", "size", "font"},
-                                            {"direction", "language", "script", "halign", "valign", "spacing"}
-                                            );
+  Parameters parameters = Parameters::parse(
+      std::move(arguments), inst->location(), {"text", "size", "font"},
+      {"direction", "language", "script", "halign", "valign", "spacing"});
   parameters.set_caller("text");
 
   node->params.set_loc(inst->location());
@@ -61,26 +60,22 @@ static std::shared_ptr<AbstractNode> builtin_text(const ModuleInstantiation *ins
   return node;
 }
 
-std::vector<std::shared_ptr<const Polygon2d>> TextNode::createPolygonList() const
-{
+std::vector<std::shared_ptr<const Polygon2d>>
+TextNode::createPolygonList() const {
   FreetypeRenderer renderer;
   return renderer.render(this->get_params());
 }
 
-FreetypeRenderer::Params TextNode::get_params() const
-{
-  return params;
-}
+FreetypeRenderer::Params TextNode::get_params() const { return params; }
 
-std::string TextNode::toString() const
-{
+std::string TextNode::toString() const {
   return STR(name(), "(", this->params, ")");
 }
 
-void register_builtin_text()
-{
-  Builtins::init("text", new BuiltinModule(builtin_text),
-  {
-    R"(text(text = "", size = 10, font = "", halign = "left", valign = "baseline", spacing = 1, direction = "ltr", language = "en", script = "latin"[, $fn]))",
-  });
+void register_builtin_text() {
+  Builtins::init(
+      "text", new BuiltinModule(builtin_text),
+      {
+          R"(text(text = "", size = 10, font = "", halign = "left", valign = "baseline", spacing = 1, direction = "ltr", language = "en", script = "latin"[, $fn]))",
+      });
 }
diff --git a/src/core/TextNode.h b/src/core/TextNode.h
index 0bf4e4783..662797752 100644
--- a/src/core/TextNode.h
+++ b/src/core/TextNode.h
@@ -4,15 +4,14 @@
 #include <string>
 #include <vector>
 
-#include "core/node.h"
-#include "core/ModuleInstantiation.h"
 #include "core/FreetypeRenderer.h"
+#include "core/ModuleInstantiation.h"
+#include "core/node.h"
 #include "geometry/Polygon2d.h"
 
 class TextModule;
 
-class TextNode : public AbstractPolyNode
-{
+class TextNode : public AbstractPolyNode {
 public:
   VISITABLE();
   TextNode(const ModuleInstantiation *mi) : AbstractPolyNode(mi) {}
diff --git a/src/core/TransformNode.cc b/src/core/TransformNode.cc
index e767b741d..21c418a44 100644
--- a/src/core/TransformNode.cc
+++ b/src/core/TransformNode.cc
@@ -25,38 +25,34 @@
  */
 
 #include "core/TransformNode.h"
-#include "geometry/linalg.h"
-#include "core/ModuleInstantiation.h"
-#include "core/Children.h"
 #include "core/Builtins.h"
-#include "core/Value.h"
+#include "core/Children.h"
+#include "core/ModuleInstantiation.h"
 #include "core/Parameters.h"
-#include "utils/printutils.h"
+#include "core/Value.h"
+#include "geometry/linalg.h"
 #include "utils/degree_trig.h"
+#include "utils/printutils.h"
 #include <algorithm>
+#include <boost/assign/std/vector.hpp>
+#include <cassert>
 #include <cmath>
-#include <memory>
 #include <cstddef>
+#include <memory>
 #include <sstream>
 #include <utility>
 #include <vector>
-#include <cassert>
-#include <boost/assign/std/vector.hpp>
 using namespace boost::assign; // bring 'operator+=()' into scope
 
-enum class transform_type_e {
-  SCALE,
-  ROTATE,
-  MIRROR,
-  TRANSLATE,
-  MULTMATRIX
-};
+enum class transform_type_e { SCALE, ROTATE, MIRROR, TRANSLATE, MULTMATRIX };
 
-std::shared_ptr<AbstractNode> builtin_scale(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+std::shared_ptr<AbstractNode> builtin_scale(const ModuleInstantiation *inst,
+                                            Arguments arguments,
+                                            const Children &children) {
   auto node = std::make_shared<TransformNode>(inst, "scale");
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"v"});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {"v"});
 
   Vector3d scalevec(1, 1, 1);
   if (!parameters["v"].getVec3(scalevec[0], scalevec[1], scalevec[2], 1.0)) {
@@ -64,12 +60,18 @@ std::shared_ptr<AbstractNode> builtin_scale(const ModuleInstantiation *inst, Arg
     if (parameters["v"].getDouble(num)) {
       scalevec.setConstant(num);
     } else {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Unable to convert scale(%1$s) parameter to a number, a vec3 or vec2 of numbers or a number", parameters["v"].toEchoStringNoThrow());
+      LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+          "Unable to convert scale(%1$s) parameter to a number, a vec3 or vec2 "
+          "of numbers or a number",
+          parameters["v"].toEchoStringNoThrow());
     }
   }
   if (OpenSCAD::rangeCheck) {
-    if (scalevec[0] == 0 || scalevec[1] == 0 || scalevec[2] == 0 || !std::isfinite(scalevec[0])|| !std::isfinite(scalevec[1])|| !std::isfinite(scalevec[2])) {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "scale(%1$s)", parameters["v"].toEchoStringNoThrow());
+    if (scalevec[0] == 0 || scalevec[1] == 0 || scalevec[2] == 0 ||
+        !std::isfinite(scalevec[0]) || !std::isfinite(scalevec[1]) ||
+        !std::isfinite(scalevec[2])) {
+      LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+          "scale(%1$s)", parameters["v"].toEchoStringNoThrow());
     }
   }
   node->matrix.scale(scalevec);
@@ -77,20 +79,22 @@ std::shared_ptr<AbstractNode> builtin_scale(const ModuleInstantiation *inst, Arg
   return children.instantiate(node);
 }
 
-std::shared_ptr<AbstractNode> builtin_rotate(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+std::shared_ptr<AbstractNode> builtin_rotate(const ModuleInstantiation *inst,
+                                             Arguments arguments,
+                                             const Children &children) {
   auto node = std::make_shared<TransformNode>(inst, "rotate");
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"a", "v"});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {"a", "v"});
 
-  const auto& val_a = parameters["a"];
-  const auto& val_v = parameters["v"];
+  const auto &val_a = parameters["a"];
+  const auto &val_v = parameters["v"];
   if (val_a.type() == Value::Type::VECTOR) {
     double sx = 0, sy = 0, sz = 0;
     double cx = 1, cy = 1, cz = 1;
     double a = 0.0;
     bool ok = true;
-    const auto& vec_a = val_a.toVector();
+    const auto &vec_a = val_a.toVector();
     switch (vec_a.size()) {
     default:
       ok &= false;
@@ -120,19 +124,25 @@ std::shared_ptr<AbstractNode> builtin_rotate(const ModuleInstantiation *inst, Ar
     bool v_supplied = val_v.isDefined();
     if (ok) {
       if (v_supplied) {
-        LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "When parameter a is supplied as vector, v is ignored rotate(a=%1$s, v=%2$s)", val_a.toEchoStringNoThrow(), val_v.toEchoStringNoThrow());
+        LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+            "When parameter a is supplied as vector, v is ignored "
+            "rotate(a=%1$s, v=%2$s)",
+            val_a.toEchoStringNoThrow(), val_v.toEchoStringNoThrow());
       }
     } else {
       if (v_supplied) {
-        LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Problem converting rotate(a=%1$s, v=%2$s) parameter", val_a.toEchoStringNoThrow(), val_v.toEchoStringNoThrow());
+        LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+            "Problem converting rotate(a=%1$s, v=%2$s) parameter",
+            val_a.toEchoStringNoThrow(), val_v.toEchoStringNoThrow());
       } else {
-        LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Problem converting rotate(a=%1$s) parameter", val_a.toEchoStringNoThrow());
+        LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+            "Problem converting rotate(a=%1$s) parameter",
+            val_a.toEchoStringNoThrow());
       }
     }
     Matrix3d M;
-    M << cy * cz,  cz * sx * sy - cx * sz,   cx * cz * sy + sx * sz,
-      cy *sz,  cx *cz + sx * sy * sz,  -cz * sx + cx * sy * sz,
-      -sy,       cy *sx,                  cx *cy;
+    M << cy * cz, cz * sx * sy - cx * sz, cx * cz * sy + sx * sz, cy * sz,
+        cx * cz + sx * sy * sz, -cz * sx + cx * sy * sz, -sy, cy * sx, cx * cy;
     node->matrix.rotate(M);
   } else {
     double a = 0.0;
@@ -144,92 +154,112 @@ std::shared_ptr<AbstractNode> builtin_rotate(const ModuleInstantiation *inst, Ar
     node->matrix.rotate(angle_axis_degrees(aConverted ? a : 0, v));
     if (val_v.isDefined() && !vConverted) {
       if (aConverted) {
-        LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Problem converting rotate(..., v=%1$s) parameter", val_v.toEchoStringNoThrow());
+        LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+            "Problem converting rotate(..., v=%1$s) parameter",
+            val_v.toEchoStringNoThrow());
       } else {
-        LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Problem converting rotate(a=%1$s, v=%2$s) parameter", val_a.toEchoStringNoThrow(), val_v.toEchoStringNoThrow());
+        LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+            "Problem converting rotate(a=%1$s, v=%2$s) parameter",
+            val_a.toEchoStringNoThrow(), val_v.toEchoStringNoThrow());
       }
     } else if (!aConverted) {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Problem converting rotate(a=%1$s) parameter", val_a.toEchoStringNoThrow());
+      LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+          "Problem converting rotate(a=%1$s) parameter",
+          val_a.toEchoStringNoThrow());
     }
   }
 
   return children.instantiate(node);
 }
 
-std::shared_ptr<AbstractNode> builtin_mirror(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+std::shared_ptr<AbstractNode> builtin_mirror(const ModuleInstantiation *inst,
+                                             Arguments arguments,
+                                             const Children &children) {
   auto node = std::make_shared<TransformNode>(inst, "mirror");
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"v"});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {"v"});
 
   double x = 1.0, y = 0.0, z = 0.0;
   if (!parameters["v"].getVec3(x, y, z, 0.0)) {
-    LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Unable to convert mirror(%1$s) parameter to a vec3 or vec2 of numbers", parameters["v"].toEchoStringNoThrow());
+    LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+        "Unable to convert mirror(%1$s) parameter to a vec3 or vec2 of numbers",
+        parameters["v"].toEchoStringNoThrow());
   }
 
   // x /= sqrt(x*x + y*y + z*z)
   // y /= sqrt(x*x + y*y + z*z)
   // z /= sqrt(x*x + y*y + z*z)
   if (x != 0.0 || y != 0.0 || z != 0.0) {
-    // skip using sqrt to normalize the vector since each element of matrix contributes it with two multiplied terms
-    // instead just divide directly within each matrix element
-    // simplified calculation leads to less float errors
+    // skip using sqrt to normalize the vector since each element of matrix
+    // contributes it with two multiplied terms instead just divide directly
+    // within each matrix element simplified calculation leads to less float
+    // errors
     double a = x * x + y * y + z * z;
 
     Matrix4d m;
-    m << 1 - 2 * x * x / a, -2 * y * x / a, -2 * z * x / a, 0,
-      -2 * x * y / a, 1 - 2 * y * y / a, -2 * z * y / a, 0,
-      -2 * x * z / a, -2 * y * z / a, 1 - 2 * z * z / a, 0,
-      0, 0, 0, 1;
+    m << 1 - 2 * x * x / a, -2 * y * x / a, -2 * z * x / a, 0, -2 * x * y / a,
+        1 - 2 * y * y / a, -2 * z * y / a, 0, -2 * x * z / a, -2 * y * z / a,
+        1 - 2 * z * z / a, 0, 0, 0, 0, 1;
     node->matrix = m;
   }
 
   return children.instantiate(node);
 }
 
-std::shared_ptr<AbstractNode> builtin_translate(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+std::shared_ptr<AbstractNode> builtin_translate(const ModuleInstantiation *inst,
+                                                Arguments arguments,
+                                                const Children &children) {
   auto node = std::make_shared<TransformNode>(inst, "translate");
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"v"});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {"v"});
 
   Vector3d translatevec(0, 0, 0);
-  bool ok = parameters["v"].getVec3(translatevec[0], translatevec[1], translatevec[2], 0.0);
-  ok &= std::isfinite(translatevec[0]) && std::isfinite(translatevec[1]) && std::isfinite(translatevec[2]);
+  bool ok = parameters["v"].getVec3(translatevec[0], translatevec[1],
+                                    translatevec[2], 0.0);
+  ok &= std::isfinite(translatevec[0]) && std::isfinite(translatevec[1]) &&
+        std::isfinite(translatevec[2]);
   if (ok) {
     node->matrix.translate(translatevec);
   } else {
-    LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Unable to convert translate(%1$s) parameter to a vec3 or vec2 of numbers", parameters["v"].toEchoStringNoThrow());
+    LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+        "Unable to convert translate(%1$s) parameter to a vec3 or vec2 of "
+        "numbers",
+        parameters["v"].toEchoStringNoThrow());
   }
 
   return children.instantiate(node);
 }
 
-std::shared_ptr<AbstractNode> builtin_multmatrix(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+std::shared_ptr<AbstractNode>
+builtin_multmatrix(const ModuleInstantiation *inst, Arguments arguments,
+                   const Children &children) {
   auto node = std::make_shared<TransformNode>(inst, "multmatrix");
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"m"});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {"m"});
 
   if (parameters["m"].type() == Value::Type::VECTOR) {
     Matrix4d rawmatrix{Matrix4d::Identity()};
-    const auto& mat = parameters["m"].toVector();
+    const auto &mat = parameters["m"].toVector();
     for (size_t row_i = 0; row_i < std::min(mat.size(), size_t(4)); ++row_i) {
-      const auto& row = mat[row_i].toVector();
+      const auto &row = mat[row_i].toVector();
       for (size_t col_i = 0; col_i < std::min(row.size(), size_t(4)); ++col_i) {
         row[col_i].getDouble(rawmatrix(row_i, col_i));
       }
     }
     double w = rawmatrix(3, 3);
-    if (w != 1.0) node->matrix = rawmatrix / w;
-    else node->matrix = rawmatrix;
+    if (w != 1.0)
+      node->matrix = rawmatrix / w;
+    else
+      node->matrix = rawmatrix;
   }
 
   return children.instantiate(node);
 }
 
-std::string TransformNode::toString() const
-{
+std::string TransformNode::toString() const {
   std::ostringstream stream;
 
   stream << "multmatrix([";
@@ -237,57 +267,50 @@ std::string TransformNode::toString() const
     stream << "[";
     for (int i = 0; i < 4; ++i) {
       stream << this->matrix(j, i);
-      if (i != 3) stream << ", ";
+      if (i != 3)
+        stream << ", ";
     }
     stream << "]";
-    if (j != 3) stream << ", ";
+    if (j != 3)
+      stream << ", ";
   }
   stream << "])";
 
   return stream.str();
 }
 
-TransformNode::TransformNode(const ModuleInstantiation *mi, std::string verbose_name) :
-  AbstractNode(mi),
-  matrix(Transform3d::Identity()),
-  _name(std::move(verbose_name))
-{
-}
+TransformNode::TransformNode(const ModuleInstantiation *mi,
+                             std::string verbose_name)
+    : AbstractNode(mi), matrix(Transform3d::Identity()),
+      _name(std::move(verbose_name)) {}
 
-std::string TransformNode::name() const
-{
-  return "transform";
-}
+std::string TransformNode::name() const { return "transform"; }
 
-std::string TransformNode::verbose_name() const
-{
-  return _name;
-}
+std::string TransformNode::verbose_name() const { return _name; }
 
-void register_builtin_transform()
-{
+void register_builtin_transform() {
   Builtins::init("scale", new BuiltinModule(builtin_scale),
-  {
-    "scale([x, y, z])",
-  });
+                 {
+                     "scale([x, y, z])",
+                 });
 
   Builtins::init("rotate", new BuiltinModule(builtin_rotate),
-  {
-    "rotate([x, y, z])",
-  });
+                 {
+                     "rotate([x, y, z])",
+                 });
 
   Builtins::init("mirror", new BuiltinModule(builtin_mirror),
-  {
-    "mirror([x, y, z])",
-  });
+                 {
+                     "mirror([x, y, z])",
+                 });
 
   Builtins::init("translate", new BuiltinModule(builtin_translate),
-  {
-    "translate([x, y, z])",
-  });
+                 {
+                     "translate([x, y, z])",
+                 });
 
   Builtins::init("multmatrix", new BuiltinModule(builtin_multmatrix),
-  {
-    "multmatrix(matrix_4_by_4)",
-  });
+                 {
+                     "multmatrix(matrix_4_by_4)",
+                 });
 }
diff --git a/src/core/TransformNode.h b/src/core/TransformNode.h
index 3aaadb9a0..a00c25ab5 100644
--- a/src/core/TransformNode.h
+++ b/src/core/TransformNode.h
@@ -2,12 +2,11 @@
 
 #include <string>
 
-#include "core/node.h"
 #include "core/ModuleInstantiation.h"
+#include "core/node.h"
 #include "geometry/linalg.h"
 
-class TransformNode : public AbstractNode
-{
+class TransformNode : public AbstractNode {
 public:
   VISITABLE();
   EIGEN_MAKE_ALIGNED_OPERATOR_NEW
diff --git a/src/core/Tree.cc b/src/core/Tree.cc
index 9c54d3e37..bb145abe1 100644
--- a/src/core/Tree.cc
+++ b/src/core/Tree.cc
@@ -1,27 +1,24 @@
 #include "core/Tree.h"
 #include "core/NodeDumper.h"
 
-#include <memory>
 #include <cassert>
+#include <memory>
 #include <string>
 #include <tuple>
 
-Tree::~Tree()
-{
-  this->nodecachemap.clear();
-}
+Tree::~Tree() { this->nodecachemap.clear(); }
 
 /*!
    Returns the cached string representation of the subtree rooted by \a node.
    If node is not cached, the cache will be rebuilt.
  */
-const std::string Tree::getString(const AbstractNode& node, const std::string& indent) const
-{
+const std::string Tree::getString(const AbstractNode &node,
+                                  const std::string &indent) const {
   assert(this->root_node);
   bool idString = false;
 
   // Retrieve a nodecache given a tuple of NodeDumper constructor options
-  NodeCache& nodecache = this->nodecachemap[std::make_tuple(indent, idString)];
+  NodeCache &nodecache = this->nodecachemap[std::make_tuple(indent, idString)];
 
   if (!nodecache.contains(node)) {
     NodeDumper dumper(nodecache, this->root_node, indent, idString);
@@ -40,14 +37,13 @@ const std::string Tree::getString(const AbstractNode& node, const std::string& i
    is stripped for whitespace. Especially indentation whitespace is important to
    strip to enable cache hits for equivalent nodes from different scopes.
  */
-const std::string Tree::getIdString(const AbstractNode& node) const
-{
+const std::string Tree::getIdString(const AbstractNode &node) const {
   assert(this->root_node);
   const std::string indent = "";
   const bool idString = true;
 
   // Retrieve a nodecache given a tuple of NodeDumper constructor options
-  NodeCache& nodecache = this->nodecachemap[make_tuple(indent, idString)];
+  NodeCache &nodecache = this->nodecachemap[make_tuple(indent, idString)];
 
   if (!nodecache.contains(node)) {
     nodecache.clear();
@@ -62,17 +58,13 @@ const std::string Tree::getIdString(const AbstractNode& node) const
 /*!
    Sets a new root. Will clear the existing cache.
  */
-void Tree::setRoot(const std::shared_ptr<const AbstractNode>& root)
-{
+void Tree::setRoot(const std::shared_ptr<const AbstractNode> &root) {
   this->root_node = root;
   this->nodecachemap.clear();
 }
 
-void Tree::setDocumentPath(const std::string& path){
+void Tree::setDocumentPath(const std::string &path) {
   this->document_path = path;
 }
 
-const std::string Tree::getDocumentPath() const
-{
-  return this->document_path;
-}
+const std::string Tree::getDocumentPath() const { return this->document_path; }
diff --git a/src/core/Tree.h b/src/core/Tree.h
index efe74daab..37c1efb22 100644
--- a/src/core/Tree.h
+++ b/src/core/Tree.h
@@ -1,30 +1,35 @@
 #pragma once
 
 #include "core/NodeCache.h"
-#include <tuple>
-#include <memory>
 #include <map>
+#include <memory>
 #include <string>
+#include <tuple>
 #include <utility>
 
 /*!
    For now, just an abstraction of the node tree which keeps a dump
    cache based on node indices around.
 
-   Note that since node trees don't survive a recompilation, the tree cannot either.
+   Note that since node trees don't survive a recompilation, the tree cannot
+   either.
  */
-class Tree
-{
+class Tree {
 public:
-  Tree(std::shared_ptr<const AbstractNode> root = nullptr, std::string path = {}) : root_node(std::move(root)), document_path(std::move(path)) {}
+  Tree(std::shared_ptr<const AbstractNode> root = nullptr,
+       std::string path = {})
+      : root_node(std::move(root)), document_path(std::move(path)) {}
   ~Tree();
 
-  void setRoot(const std::shared_ptr<const AbstractNode>& root);
-  void setDocumentPath(const std::string& path);
-  const std::shared_ptr<const AbstractNode>& root() const { return this->root_node; }
+  void setRoot(const std::shared_ptr<const AbstractNode> &root);
+  void setDocumentPath(const std::string &path);
+  const std::shared_ptr<const AbstractNode> &root() const {
+    return this->root_node;
+  }
 
-  const std::string getString(const AbstractNode& node, const std::string& indent) const;
-  const std::string getIdString(const AbstractNode& node) const;
+  const std::string getString(const AbstractNode &node,
+                              const std::string &indent) const;
+  const std::string getIdString(const AbstractNode &node) const;
   const std::string getDocumentPath() const;
 
 private:
diff --git a/src/core/UndefType.cc b/src/core/UndefType.cc
index 3b0463ad1..f3cf21e05 100644
--- a/src/core/UndefType.cc
+++ b/src/core/UndefType.cc
@@ -1,14 +1,14 @@
 #include "core/Value.h"
 
-Value UndefType::operator<(const UndefType& /*other*/) const {
+Value UndefType::operator<(const UndefType & /*other*/) const {
   return Value::undef("operation undefined (undefined < undefined)");
 }
-Value UndefType::operator>(const UndefType& /*other*/) const {
+Value UndefType::operator>(const UndefType & /*other*/) const {
   return Value::undef("operation undefined (undefined > undefined)");
 }
-Value UndefType::operator<=(const UndefType& /*other*/) const {
+Value UndefType::operator<=(const UndefType & /*other*/) const {
   return Value::undef("operation undefined (undefined <= undefined)");
 }
-Value UndefType::operator>=(const UndefType& /*other*/) const {
+Value UndefType::operator>=(const UndefType & /*other*/) const {
   return Value::undef("operation undefined (undefined >= undefined)");
 }
diff --git a/src/core/UndefType.h b/src/core/UndefType.h
index 1bee3c348..2963b3424 100644
--- a/src/core/UndefType.h
+++ b/src/core/UndefType.h
@@ -10,25 +10,31 @@
 class Value;
 
 /*
-   Require a reason why (string), any time an undefined value is created/returned.
-   This allows for passing of "exception" information from low level functions (i.e. from value.cc)
-   up to Expression::evaluate() or other functions where a proper "WARNING: ..."
-   with ASTNode Location info (source file, line number) can be included.
+   Require a reason why (string), any time an undefined value is
+   created/returned. This allows for passing of "exception" information from low
+   level functions (i.e. from value.cc) up to Expression::evaluate() or other
+   functions where a proper "WARNING: ..." with ASTNode Location info (source
+   file, line number) can be included.
  */
-class UndefType
-{
+class UndefType {
 public:
   // TODO: eventually deprecate undef creation without a reason.
-  UndefType() : reasons{std::make_unique<std::vector<std::string>>()} { }
-  explicit UndefType(const std::string& why) : reasons{std::make_unique<std::vector<std::string>>(std::initializer_list<std::string>({why}))} { }
+  UndefType() : reasons{std::make_unique<std::vector<std::string>>()} {}
+  explicit UndefType(const std::string &why)
+      : reasons{std::make_unique<std::vector<std::string>>(
+            std::initializer_list<std::string>({why}))} {}
 
-  // Append another reason in case a chain of undefined operations are made before handling
-  const UndefType& append(const std::string& why) const { reasons->push_back(why); return *this; }
+  // Append another reason in case a chain of undefined operations are made
+  // before handling
+  const UndefType &append(const std::string &why) const {
+    reasons->push_back(why);
+    return *this;
+  }
 
-  Value operator<(const UndefType& other) const;
-  Value operator>(const UndefType& other) const;
-  Value operator<=(const UndefType& other) const;
-  Value operator>=(const UndefType& other) const;
+  Value operator<(const UndefType &other) const;
+  Value operator>(const UndefType &other) const;
+  Value operator<=(const UndefType &other) const;
+  Value operator>=(const UndefType &other) const;
 
   std::string toString() const {
     std::ostringstream stream;
@@ -44,16 +50,16 @@ public:
     return stream.str();
   }
   bool empty() const { return reasons->empty(); }
+
 private:
   // using unique_ptr to keep the size small enough that the variant of
   // all value types does not exceed the 24 bytes.
-  // mutable to allow clearing reasons, which should avoid duplication of warnings that have already been displayed.
+  // mutable to allow clearing reasons, which should avoid duplication of
+  // warnings that have already been displayed.
   mutable std::unique_ptr<std::vector<std::string>> reasons;
 };
 
-
-inline std::ostream& operator<<(std::ostream& stream, const UndefType& /*u*/)
-{
+inline std::ostream &operator<<(std::ostream &stream, const UndefType & /*u*/) {
   stream << "undef";
   return stream;
 }
diff --git a/src/core/UserModule.cc b/src/core/UserModule.cc
index d36dc29cb..de0267f71 100644
--- a/src/core/UserModule.cc
+++ b/src/core/UserModule.cc
@@ -26,38 +26,43 @@
 
 #include "core/UserModule.h"
 
-#include <ostream>
 #include <memory>
+#include <ostream>
 #include <vector>
 
 #include "core/AST.h"
+#include "core/Expression.h"
 #include "core/ModuleInstantiation.h"
+#include "core/ScopeContext.h"
 #include "core/node.h"
-#include "utils/exceptions.h"
 #include "utils/StackCheck.h"
-#include "core/ScopeContext.h"
-#include "core/Expression.h"
-#include "utils/printutils.h"
 #include "utils/compiler_specific.h"
+#include "utils/exceptions.h"
+#include "utils/printutils.h"
 #include <cstddef>
 #include <sstream>
 #include <string>
 
 std::vector<std::string> StaticModuleNameStack::stack;
 
-static void NOINLINE print_err(std::string name, const Location& loc, const std::shared_ptr<const Context>& context){
-  LOG(message_group::Error, loc, context->documentRoot(), "Recursion detected calling module '%1$s'", name);
+static void NOINLINE print_err(std::string name, const Location &loc,
+                               const std::shared_ptr<const Context> &context) {
+  LOG(message_group::Error, loc, context->documentRoot(),
+      "Recursion detected calling module '%1$s'", name);
 }
 
-static void NOINLINE print_trace(const UserModule *mod, const std::shared_ptr<const UserModuleContext>& context, const AssignmentList& parameters){
+static void NOINLINE
+print_trace(const UserModule *mod,
+            const std::shared_ptr<const UserModuleContext> &context,
+            const AssignmentList &parameters) {
   std::stringstream stream;
   if (parameters.size() == 0) {
-    //nothing to do
+    // nothing to do
   } else if (StackCheck::inst().check()) {
     stream << "...";
   } else {
     bool first = true;
-    for (const auto& assignment : parameters) {
+    for (const auto &assignment : parameters) {
       if (first) {
         first = false;
       } else {
@@ -68,42 +73,45 @@ static void NOINLINE print_trace(const UserModule *mod, const std::shared_ptr<co
         stream << " = ";
       }
       try {
-        stream << context->lookup_variable(assignment->getName(), Location::NONE);
-      } catch (EvaluationException& e) {
+        stream << context->lookup_variable(assignment->getName(),
+                                           Location::NONE);
+      } catch (EvaluationException &e) {
         stream << "...";
       }
     }
   }
-  LOG(message_group::Trace, mod->location(), context->documentRoot(), "call of '%1$s(%2$s)'",
-      mod->name, stream.str()
-      );
+  LOG(message_group::Trace, mod->location(), context->documentRoot(),
+      "call of '%1$s(%2$s)'", mod->name, stream.str());
 }
 
-std::shared_ptr<AbstractNode> UserModule::instantiate(const std::shared_ptr<const Context>& defining_context, const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context) const
-{
+std::shared_ptr<AbstractNode>
+UserModule::instantiate(const std::shared_ptr<const Context> &defining_context,
+                        const ModuleInstantiation *inst,
+                        const std::shared_ptr<const Context> &context) const {
   if (StackCheck::inst().check()) {
     print_err(inst->name(), loc, context);
     throw RecursionException::create("module", inst->name(), loc);
     return nullptr;
   }
 
-  StaticModuleNameStack name{inst->name()}; // push on static stack, pop at end of method!
-  ContextHandle<UserModuleContext> module_context{Context::create<UserModuleContext>(
-                                                    defining_context,
-                                                    this,
-                                                    inst->location(),
-                                                    Arguments(inst->arguments, context),
-                                                    Children(&inst->scope, context)
-                                                    )};
+  StaticModuleNameStack name{
+      inst->name()}; // push on static stack, pop at end of method!
+  ContextHandle<UserModuleContext> module_context{
+      Context::create<UserModuleContext>(defining_context, this,
+                                         inst->location(),
+                                         Arguments(inst->arguments, context),
+                                         Children(&inst->scope, context))};
 #if 0 && DEBUG
   PRINTDB("UserModuleContext for module %s(%s):\n", this->name % STR(this->parameters));
   PRINTDB("%s", module_context->dump());
 #endif
 
   std::shared_ptr<AbstractNode> ret;
-  try{
-    ret = this->body.instantiateModules(*module_context, std::make_shared<GroupNode>(inst, std::string("module ") + this->name));
-  } catch (EvaluationException& e) {
+  try {
+    ret = this->body.instantiateModules(
+        *module_context,
+        std::make_shared<GroupNode>(inst, std::string("module ") + this->name));
+  } catch (EvaluationException &e) {
     if (OpenSCAD::traceUsermoduleParameters && e.traceDepth > 0) {
       print_trace(this, *module_context, this->parameters);
       e.traceDepth--;
@@ -113,16 +121,17 @@ std::shared_ptr<AbstractNode> UserModule::instantiate(const std::shared_ptr<cons
   return ret;
 }
 
-void UserModule::print(std::ostream& stream, const std::string& indent) const
-{
+void UserModule::print(std::ostream &stream, const std::string &indent) const {
   std::string tab;
   if (!this->name.empty()) {
     stream << indent << "module " << this->name << "(";
     for (size_t i = 0; i < this->parameters.size(); ++i) {
-      const auto& parameter = this->parameters[i];
-      if (i > 0) stream << ", ";
+      const auto &parameter = this->parameters[i];
+      if (i > 0)
+        stream << ", ";
       stream << parameter->getName();
-      if (parameter->getExpr()) stream << " = " << *parameter->getExpr();
+      if (parameter->getExpr())
+        stream << " = " << *parameter->getExpr();
     }
     stream << ") {\n";
     tab = "\t";
diff --git a/src/core/UserModule.h b/src/core/UserModule.h
index 39cc4df34..af5c5257d 100644
--- a/src/core/UserModule.h
+++ b/src/core/UserModule.h
@@ -1,42 +1,43 @@
 #pragma once
 
-#include <ostream>
 #include <memory>
+#include <ostream>
 #include <string>
 #include <vector>
 
-#include "core/module.h"
 #include "core/AST.h"
 #include "core/LocalScope.h"
+#include "core/module.h"
 
 class Feature;
 
-class StaticModuleNameStack
-{
+class StaticModuleNameStack {
 public:
-  StaticModuleNameStack(const std::string& name) {
-    stack.push_back(name);
-  }
-  ~StaticModuleNameStack() {
-    stack.pop_back();
-  }
+  StaticModuleNameStack(const std::string &name) { stack.push_back(name); }
+  ~StaticModuleNameStack() { stack.pop_back(); }
 
   static int size() { return stack.size(); }
-  static const std::string& at(int idx) { return stack[idx]; }
+  static const std::string &at(int idx) { return stack[idx]; }
 
 private:
   static std::vector<std::string> stack;
 };
 
-class UserModule : public AbstractModule, public ASTNode
-{
+class UserModule : public AbstractModule, public ASTNode {
 public:
-  UserModule(const char *name, const Location& loc) : ASTNode(loc), name(name) { }
-  UserModule(const char *name, const Feature& feature, const Location& loc) : AbstractModule(feature), ASTNode(loc), name(name) { }
-
-  std::shared_ptr<AbstractNode> instantiate(const std::shared_ptr<const Context>& defining_context, const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context) const override;
-  void print(std::ostream& stream, const std::string& indent) const override;
-  static const std::string& stack_element(int n) { return StaticModuleNameStack::at(n); }
+  UserModule(const char *name, const Location &loc)
+      : ASTNode(loc), name(name) {}
+  UserModule(const char *name, const Feature &feature, const Location &loc)
+      : AbstractModule(feature), ASTNode(loc), name(name) {}
+
+  std::shared_ptr<AbstractNode>
+  instantiate(const std::shared_ptr<const Context> &defining_context,
+              const ModuleInstantiation *inst,
+              const std::shared_ptr<const Context> &context) const override;
+  void print(std::ostream &stream, const std::string &indent) const override;
+  static const std::string &stack_element(int n) {
+    return StaticModuleNameStack::at(n);
+  }
   static int stack_size() { return StaticModuleNameStack::size(); }
 
   std::string name;
diff --git a/src/core/Value.cc b/src/core/Value.cc
index 976204a98..66b1928ab 100644
--- a/src/core/Value.cc
+++ b/src/core/Value.cc
@@ -26,29 +26,29 @@
 
 #include "core/Value.h"
 
-#include <filesystem>
-#include <cmath>
-#include <variant>
-#include <limits>
-#include <ostream>
-#include <utility>
-#include <cstdint>
+#include <boost/lexical_cast.hpp>
 #include <cassert>
+#include <cmath>
 #include <cstddef>
+#include <cstdint>
+#include <filesystem>
+#include <limits>
 #include <memory>
+#include <ostream>
 #include <sstream>
 #include <string>
+#include <utility>
+#include <variant>
 #include <vector>
-#include <boost/lexical_cast.hpp>
 
 #include "core/EvaluationSession.h"
 #include "io/fileutils.h"
-#include "utils/printutils.h"
 #include "utils/StackCheck.h"
 #include "utils/boost-utils.h"
+#include "utils/printutils.h"
 #include <double-conversion/double-conversion.h>
-#include <double-conversion/utils.h>
 #include <double-conversion/ieee.h>
+#include <double-conversion/utils.h>
 
 namespace fs = std::filesystem;
 
@@ -56,10 +56,11 @@ const Value Value::undefined;
 const VectorType VectorType::EMPTY(nullptr);
 const RangeType RangeType::EMPTY{0, 0, 0};
 
-
 /* Define values for double-conversion library. */
 #define DC_BUFFER_SIZE (128)
-#define DC_FLAGS (double_conversion::DoubleToStringConverter::UNIQUE_ZERO | double_conversion::DoubleToStringConverter::EMIT_POSITIVE_EXPONENT_SIGN)
+#define DC_FLAGS                                                               \
+  (double_conversion::DoubleToStringConverter::UNIQUE_ZERO |                   \
+   double_conversion::DoubleToStringConverter::EMIT_POSITIVE_EXPONENT_SIGN)
 #define DC_INF "inf"
 #define DC_NAN "nan"
 #define DC_EXP 'e'
@@ -72,57 +73,71 @@ const RangeType RangeType::EMPTY{0, 0, 0};
  * conversion, defeating the purpose of using double-conversion library */
 #define DC_PRECISION_REQUESTED (6)
 
-//private definitions used by trimTrailingZeroesHelper
+// private definitions used by trimTrailingZeroesHelper
 #define TRIM_TRAILINGZEROES_DONE (0)
 #define TRIM_TRAILINGZEROES_CONTINUE (1)
 
-//process parameter buffer from the end to start to find out where the zeroes are located (if any).
-//parameter pos shall be the pos in buffer where '\0' is located.
-//parameter currentpos shall be set to end of buffer (where '\0' is located).
-//set parameters exppos and decimalpos when needed.
-//leave parameter zeropos as is.
-inline int trimTrailingZeroesHelper(char *buffer, const int pos, char *currentpos = nullptr, char *exppos = nullptr, char *decimalpos = nullptr, char *zeropos = nullptr) {
+// process parameter buffer from the end to start to find out where the zeroes
+// are located (if any). parameter pos shall be the pos in buffer where '\0' is
+// located. parameter currentpos shall be set to end of buffer (where '\0' is
+// located). set parameters exppos and decimalpos when needed. leave parameter
+// zeropos as is.
+inline int trimTrailingZeroesHelper(char *buffer, const int pos,
+                                    char *currentpos = nullptr,
+                                    char *exppos = nullptr,
+                                    char *decimalpos = nullptr,
+                                    char *zeropos = nullptr) {
 
   int cont = TRIM_TRAILINGZEROES_CONTINUE;
 
-  //we have exhausted all positions from end to start
-  if (currentpos <= buffer) return TRIM_TRAILINGZEROES_DONE;
+  // we have exhausted all positions from end to start
+  if (currentpos <= buffer)
+    return TRIM_TRAILINGZEROES_DONE;
 
-  //we do no need to process the terminator of string
+  // we do no need to process the terminator of string
   if (*currentpos == '\0') {
     currentpos--;
-    cont = trimTrailingZeroesHelper(buffer, pos, currentpos, exppos, decimalpos, zeropos);
+    cont = trimTrailingZeroesHelper(buffer, pos, currentpos, exppos, decimalpos,
+                                    zeropos);
   }
 
-  //we have an exponent and jumps to the position before the exponent - no need to process the characters belonging to the exponent
+  // we have an exponent and jumps to the position before the exponent - no need
+  // to process the characters belonging to the exponent
   if (cont && exppos && currentpos >= exppos) {
     currentpos = exppos;
     currentpos--;
-    cont = trimTrailingZeroesHelper(buffer, pos, currentpos, exppos, decimalpos, zeropos);
+    cont = trimTrailingZeroesHelper(buffer, pos, currentpos, exppos, decimalpos,
+                                    zeropos);
   }
 
-  //we are still on the right side of the decimal and still counting zeroes (keep track of) from the back to start
+  // we are still on the right side of the decimal and still counting zeroes
+  // (keep track of) from the back to start
   if (cont && currentpos && decimalpos < currentpos && *currentpos == '0') {
     zeropos = currentpos;
     currentpos--;
-    cont = trimTrailingZeroesHelper(buffer, pos, currentpos, exppos, decimalpos, zeropos);
+    cont = trimTrailingZeroesHelper(buffer, pos, currentpos, exppos, decimalpos,
+                                    zeropos);
   }
 
-  //we have found the first occurrence of not a zero and have zeroes and exponent to take care of (move exponent to either the position of the zero or the decimal)
+  // we have found the first occurrence of not a zero and have zeroes and
+  // exponent to take care of (move exponent to either the position of the zero
+  // or the decimal)
   if (cont && zeropos && exppos) {
     int count = &buffer[pos] - exppos + 1;
     memmove(zeropos - 1 == decimalpos ? decimalpos : zeropos, exppos, count);
     return TRIM_TRAILINGZEROES_DONE;
   }
 
-  //we have found a zero and need to take care of (truncate the string to the position of either the zero or the decimal)
+  // we have found a zero and need to take care of (truncate the string to the
+  // position of either the zero or the decimal)
   if (cont && zeropos) {
     zeropos - 1 == decimalpos ? *decimalpos = '\0' : *zeropos = '\0';
     return TRIM_TRAILINGZEROES_DONE;
   }
 
-  //we have just another character (other than a zero) and are done
-  if (cont && !zeropos) return TRIM_TRAILINGZEROES_DONE;
+  // we have just another character (other than a zero) and are done
+  if (cont && !zeropos)
+    return TRIM_TRAILINGZEROES_DONE;
 
   return TRIM_TRAILINGZEROES_DONE;
 }
@@ -131,11 +146,13 @@ inline void trimTrailingZeroes(char *buffer, const int pos) {
   char *decimal = strchr(buffer, '.');
   if (decimal) {
     char *exppos = strchr(buffer, DC_EXP);
-    trimTrailingZeroesHelper(buffer, pos, &buffer[pos], exppos, decimal, nullptr);
+    trimTrailingZeroesHelper(buffer, pos, &buffer[pos], exppos, decimal,
+                             nullptr);
   }
 }
 
-inline bool HandleSpecialValues(const double& value, double_conversion::StringBuilder& builder) {
+inline bool HandleSpecialValues(const double &value,
+                                double_conversion::StringBuilder &builder) {
   double_conversion::Double double_inspect(value);
   if (double_inspect.IsInfinite()) {
     if (value < 0) {
@@ -151,8 +168,10 @@ inline bool HandleSpecialValues(const double& value, double_conversion::StringBu
   return false;
 }
 
-inline std::string DoubleConvert(const double& value, char *buffer,
-                                 double_conversion::StringBuilder& builder, const double_conversion::DoubleToStringConverter& dc) {
+inline std::string
+DoubleConvert(const double &value, char *buffer,
+              double_conversion::StringBuilder &builder,
+              const double_conversion::DoubleToStringConverter &dc) {
   builder.Reset();
   if (double_conversion::Double(value).IsSpecial()) {
     HandleSpecialValues(value, builder);
@@ -166,21 +185,19 @@ inline std::string DoubleConvert(const double& value, char *buffer,
   return buffer;
 }
 
-static uint32_t convert_to_uint32(const double d)
-{
+static uint32_t convert_to_uint32(const double d) {
   auto ret = std::numeric_limits<uint32_t>::max();
   if (std::isfinite(d)) {
     try {
       ret = boost::numeric_cast<uint32_t>(d);
-    } catch (boost::bad_numeric_cast&) {
+    } catch (boost::bad_numeric_cast &) {
       // ignore, leaving the default max() value
     }
   }
   return ret;
 }
 
-std::ostream& operator<<(std::ostream& stream, const Filename& filename)
-{
+std::ostream &operator<<(std::ostream &stream, const Filename &filename) {
   fs::path fnpath{static_cast<std::string>(filename)}; // gcc-4.6
   auto fpath = fs_uncomplete(fnpath, fs::current_path());
   stream << QuotedString(fpath.generic_string());
@@ -188,17 +205,27 @@ std::ostream& operator<<(std::ostream& stream, const Filename& filename)
 }
 
 // FIXME: This could probably be done more elegantly using boost::regex
-std::ostream& operator<<(std::ostream& stream, const QuotedString& s)
-{
+std::ostream &operator<<(std::ostream &stream, const QuotedString &s) {
   stream << '"';
   for (char c : s) {
     switch (c) {
-    case '\t': stream << "\\t"; break;
-    case '\n': stream << "\\n"; break;
-    case '\r': stream << "\\r"; break;
-    case '"':  stream << "\\\""; break;
-    case '\\': stream << "\\\\"; break;
-    default:   stream << c;
+    case '\t':
+      stream << "\\t";
+      break;
+    case '\n':
+      stream << "\\n";
+      break;
+    case '\r':
+      stream << "\\r";
+      break;
+    case '"':
+      stream << "\\\"";
+      break;
+    case '\\':
+      stream << "\\\\";
+      break;
+    default:
+      stream << c;
     }
   }
   return stream << '"';
@@ -206,91 +233,106 @@ std::ostream& operator<<(std::ostream& stream, const QuotedString& s)
 
 Value Value::clone() const {
   switch (this->type()) {
-  case Type::UNDEFINED: return {};
-  case Type::BOOL:      return std::get<bool>(this->value);
-  case Type::NUMBER:    return std::get<double>(this->value);
-  case Type::STRING:    return std::get<str_utf8_wrapper>(this->value).clone();
-  case Type::RANGE:     return std::get<RangePtr>(this->value).clone();
-  case Type::VECTOR:    return std::get<VectorType>(this->value).clone();
-  case Type::OBJECT:    return std::get<ObjectType>(this->value).clone();
-  case Type::FUNCTION:  return std::get<FunctionPtr>(this->value).clone();
-  default: assert(false && "unknown Value variant type"); return {};
-  }
-}
-
-Value Value::undef(const std::string& why)
-{
-  return Value{UndefType{why}};
-}
-
-std::string Value::typeName(Type type)
-{
+  case Type::UNDEFINED:
+    return {};
+  case Type::BOOL:
+    return std::get<bool>(this->value);
+  case Type::NUMBER:
+    return std::get<double>(this->value);
+  case Type::STRING:
+    return std::get<str_utf8_wrapper>(this->value).clone();
+  case Type::RANGE:
+    return std::get<RangePtr>(this->value).clone();
+  case Type::VECTOR:
+    return std::get<VectorType>(this->value).clone();
+  case Type::OBJECT:
+    return std::get<ObjectType>(this->value).clone();
+  case Type::FUNCTION:
+    return std::get<FunctionPtr>(this->value).clone();
+  default:
+    assert(false && "unknown Value variant type");
+    return {};
+  }
+}
+
+Value Value::undef(const std::string &why) { return Value{UndefType{why}}; }
+
+std::string Value::typeName(Type type) {
   switch (type) {
-  case Type::UNDEFINED: return "undefined";
-  case Type::BOOL:      return "bool";
-  case Type::NUMBER:    return "number";
-  case Type::STRING:    return "string";
-  case Type::VECTOR:    return "vector";
-  case Type::RANGE:     return "range";
-  case Type::OBJECT:    return "object";
-  case Type::FUNCTION:  return "function";
-  default: assert(false && "unknown Value variant type"); return "<unknown>";
-  }
-}
-
-const std::string Value::typeName() const
-{
-  return typeName(this->type());
-}
-
-// free functions for use by static_visitor templated functions in creating undef messages.
-std::string getTypeName(const UndefType&) { return "undefined"; }
+  case Type::UNDEFINED:
+    return "undefined";
+  case Type::BOOL:
+    return "bool";
+  case Type::NUMBER:
+    return "number";
+  case Type::STRING:
+    return "string";
+  case Type::VECTOR:
+    return "vector";
+  case Type::RANGE:
+    return "range";
+  case Type::OBJECT:
+    return "object";
+  case Type::FUNCTION:
+    return "function";
+  default:
+    assert(false && "unknown Value variant type");
+    return "<unknown>";
+  }
+}
+
+const std::string Value::typeName() const { return typeName(this->type()); }
+
+// free functions for use by static_visitor templated functions in creating
+// undef messages.
+std::string getTypeName(const UndefType &) { return "undefined"; }
 std::string getTypeName(bool) { return "bool"; }
 std::string getTypeName(double) { return "number"; }
-std::string getTypeName(const str_utf8_wrapper&) { return "string"; }
-std::string getTypeName(const VectorType&) { return "vector"; }
-std::string getTypeName(const ObjectType&) { return "object"; }
-std::string getTypeName(const RangePtr&) { return "range"; }
-std::string getTypeName(const FunctionPtr&) { return "function"; }
-
-bool Value::toBool() const
-{
+std::string getTypeName(const str_utf8_wrapper &) { return "string"; }
+std::string getTypeName(const VectorType &) { return "vector"; }
+std::string getTypeName(const ObjectType &) { return "object"; }
+std::string getTypeName(const RangePtr &) { return "range"; }
+std::string getTypeName(const FunctionPtr &) { return "function"; }
+
+bool Value::toBool() const {
   // NOLINTBEGIN(bugprone-branch-clone)
   switch (this->type()) {
-  case Type::UNDEFINED: return false;
-  case Type::BOOL:      return std::get<bool>(this->value);
-  case Type::NUMBER:    return std::get<double>(this->value) != 0;
-  case Type::STRING:    return !std::get<str_utf8_wrapper>(this->value).empty();
-  case Type::VECTOR:    return !std::get<VectorType>(this->value).empty();
-  case Type::RANGE:     return true;
-  case Type::OBJECT:    return !std::get<ObjectType>(this->value).empty();
-  case Type::FUNCTION:  return true;
-  default: assert(false && "unknown Value variant type"); return false;
+  case Type::UNDEFINED:
+    return false;
+  case Type::BOOL:
+    return std::get<bool>(this->value);
+  case Type::NUMBER:
+    return std::get<double>(this->value) != 0;
+  case Type::STRING:
+    return !std::get<str_utf8_wrapper>(this->value).empty();
+  case Type::VECTOR:
+    return !std::get<VectorType>(this->value).empty();
+  case Type::RANGE:
+    return true;
+  case Type::OBJECT:
+    return !std::get<ObjectType>(this->value).empty();
+  case Type::FUNCTION:
+    return true;
+  default:
+    assert(false && "unknown Value variant type");
+    return false;
   }
   // NOLINTEND(bugprone-branch-clone)
 }
 
-// Convert the value to a double with an integer value, for use in bitwise operations.
-// Since there are several possible ways to do this (floor, ceil, round, trunc) this function
-// centralizes the choice for consistency.
-double Value::toInteger() const
-{
-  return trunc(this->toDouble());
-}
+// Convert the value to a double with an integer value, for use in bitwise
+// operations. Since there are several possible ways to do this (floor, ceil,
+// round, trunc) this function centralizes the choice for consistency.
+double Value::toInteger() const { return trunc(this->toDouble()); }
 
-int64_t Value::toInt64() const
-{
-  return this->toInteger();
-}
+int64_t Value::toInt64() const { return this->toInteger(); }
 
-double Value::toDouble() const
-{
+double Value::toDouble() const {
   const double *d = std::get_if<double>(&this->value);
   return d ? *d : 0.0;
 }
 
-bool Value::getDouble(double& v) const
-{
+bool Value::getDouble(double &v) const {
   const double *d = std::get_if<double>(&this->value);
   if (d) {
     v = *d;
@@ -299,8 +341,7 @@ bool Value::getDouble(double& v) const
   return false;
 }
 
-bool Value::getFiniteDouble(double& v) const
-{
+bool Value::getFiniteDouble(double &v) const {
   double result;
   if (getDouble(result) && std::isfinite(result)) {
     v = result;
@@ -309,69 +350,64 @@ bool Value::getFiniteDouble(double& v) const
   return false;
 }
 
-bool Value::getUnsignedInt(unsigned int& v) const
-{
+bool Value::getUnsignedInt(unsigned int &v) const {
   double result;
-  if (getFiniteDouble(result) &&
-      result >= 0.0 && result <= std::numeric_limits<unsigned int>::max()) {
+  if (getFiniteDouble(result) && result >= 0.0 &&
+      result <= std::numeric_limits<unsigned int>::max()) {
     v = result;
     return true;
   }
   return false;
 }
 
-bool Value::getPositiveInt(unsigned int& v) const
-{
+bool Value::getPositiveInt(unsigned int &v) const {
   double result;
-  if (getFiniteDouble(result) &&
-      result >= 1 && result <= std::numeric_limits<unsigned int>::max()) {
+  if (getFiniteDouble(result) && result >= 1 &&
+      result <= std::numeric_limits<unsigned int>::max()) {
     v = result;
     return true;
   }
   return false;
 }
 
-const str_utf8_wrapper& Value::toStrUtf8Wrapper() const {
+const str_utf8_wrapper &Value::toStrUtf8Wrapper() const {
   return std::get<str_utf8_wrapper>(this->value);
 }
 
-// Optimization to avoid multiple stream instantiations and copies to str for long vectors.
-// Functions identically to "class tostring_visitor", except outputting to stream and not returning strings
-class tostream_visitor
-{
+// Optimization to avoid multiple stream instantiations and copies to str for
+// long vectors. Functions identically to "class tostring_visitor", except
+// outputting to stream and not returning strings
+class tostream_visitor {
 public:
-  std::ostringstream& stream;
+  std::ostringstream &stream;
   mutable char buffer[DC_BUFFER_SIZE];
   mutable double_conversion::StringBuilder builder;
   double_conversion::DoubleToStringConverter dc;
 
-  tostream_visitor(std::ostringstream& stream)
-    : stream(stream), builder(buffer, DC_BUFFER_SIZE),
-    dc(DC_FLAGS, DC_INF, DC_NAN, DC_EXP, DC_DECIMAL_LOW_EXP, DC_DECIMAL_HIGH_EXP, DC_MAX_LEADING_ZEROES, DC_MAX_TRAILING_ZEROES)
-  {}
+  tostream_visitor(std::ostringstream &stream)
+      : stream(stream), builder(buffer, DC_BUFFER_SIZE),
+        dc(DC_FLAGS, DC_INF, DC_NAN, DC_EXP, DC_DECIMAL_LOW_EXP,
+           DC_DECIMAL_HIGH_EXP, DC_MAX_LEADING_ZEROES, DC_MAX_TRAILING_ZEROES) {
+  }
 
-  template <typename T> void operator()(const T& op1) const {
-    //std::cout << "[generic tostream_visitor]\n";
+  template <typename T> void operator()(const T &op1) const {
+    // std::cout << "[generic tostream_visitor]\n";
     stream << boost::lexical_cast<std::string>(op1);
   }
 
-  void operator()(const double& op1) const {
+  void operator()(const double &op1) const {
     stream << DoubleConvert(op1, buffer, builder, dc);
   }
 
-  void operator()(const UndefType&) const {
-    stream << "undef";
-  }
+  void operator()(const UndefType &) const { stream << "undef"; }
 
-  void operator()(const bool& v) const {
-    stream << (v ? "true" : "false");
-  }
+  void operator()(const bool &v) const { stream << (v ? "true" : "false"); }
 
-  void operator()(const EmbeddedVectorType&) const {
+  void operator()(const EmbeddedVectorType &) const {
     assert(false && "Error: unexpected visit to EmbeddedVectorType!");
   }
 
-  void operator()(const VectorType& v) const {
+  void operator()(const VectorType &v) const {
     if (StackCheck::inst().check()) {
       throw VectorEchoStringException::create();
     }
@@ -387,84 +423,69 @@ public:
     stream << ']';
   }
 
-  void operator()(const str_utf8_wrapper& v) const {
+  void operator()(const str_utf8_wrapper &v) const {
     stream << '"' << v.toString() << '"';
   }
 
-  void operator()(const RangePtr& v) const {
-    stream << *v;
-  }
+  void operator()(const RangePtr &v) const { stream << *v; }
 
-  void operator()(const FunctionPtr& v) const {
-    stream << *v;
-  }
+  void operator()(const FunctionPtr &v) const { stream << *v; }
 };
 
-class tostring_visitor
-{
+class tostring_visitor {
 public:
-  template <typename T> std::string operator()(const T& op1) const {
+  template <typename T> std::string operator()(const T &op1) const {
     assert(false && "unhandled tostring_visitor type");
     return STR(op1);
   }
 
-  std::string operator()(const str_utf8_wrapper& op1) const {
+  std::string operator()(const str_utf8_wrapper &op1) const {
     return op1.toString();
   }
 
-  std::string operator()(const double& op1) const {
+  std::string operator()(const double &op1) const {
     char buffer[DC_BUFFER_SIZE];
     double_conversion::StringBuilder builder(buffer, DC_BUFFER_SIZE);
-    double_conversion::DoubleToStringConverter dc(DC_FLAGS, DC_INF, DC_NAN, DC_EXP,
-                                                  DC_DECIMAL_LOW_EXP, DC_DECIMAL_HIGH_EXP, DC_MAX_LEADING_ZEROES, DC_MAX_TRAILING_ZEROES);
+    double_conversion::DoubleToStringConverter dc(
+        DC_FLAGS, DC_INF, DC_NAN, DC_EXP, DC_DECIMAL_LOW_EXP,
+        DC_DECIMAL_HIGH_EXP, DC_MAX_LEADING_ZEROES, DC_MAX_TRAILING_ZEROES);
     return DoubleConvert(op1, buffer, builder, dc);
   }
 
-  std::string operator()(const UndefType&) const {
-    return "undef";
-  }
+  std::string operator()(const UndefType &) const { return "undef"; }
 
-  std::string operator()(const bool& v) const {
-    return v ? "true" : "false";
-  }
+  std::string operator()(const bool &v) const { return v ? "true" : "false"; }
 
-  std::string operator()(const EmbeddedVectorType&) const {
+  std::string operator()(const EmbeddedVectorType &) const {
     assert(false && "Error: unexpected visit to EmbeddedVectorType!");
     return "";
   }
 
-  std::string operator()(const VectorType& v) const {
-    // Create a single stream and pass reference to it for list elements for optimization.
+  std::string operator()(const VectorType &v) const {
+    // Create a single stream and pass reference to it for list elements for
+    // optimization.
     std::ostringstream stream;
     try {
       (tostream_visitor(stream))(v);
-    } catch (EvaluationException& e) {
+    } catch (EvaluationException &e) {
       LOG(message_group::Error, e.what());
       throw;
     }
     return stream.str();
   }
 
-  std::string operator()(const ObjectType& v) const {
-    return STR(v);
-  }
+  std::string operator()(const ObjectType &v) const { return STR(v); }
 
-  std::string operator()(const RangePtr& v) const {
-    return STR(*v);
-  }
+  std::string operator()(const RangePtr &v) const { return STR(*v); }
 
-  std::string operator()(const FunctionPtr& v) const {
-    return STR(*v);
-  }
+  std::string operator()(const FunctionPtr &v) const { return STR(*v); }
 };
 
-std::string Value::toString() const
-{
+std::string Value::toString() const {
   return std::visit(tostring_visitor(), this->value);
 }
 
-std::string Value::toEchoString() const
-{
+std::string Value::toEchoString() const {
   if (type() == Value::Type::STRING) {
     return std::string("\"") + toString() + '"';
   } else {
@@ -472,37 +493,29 @@ std::string Value::toEchoString() const
   }
 }
 
-std::string Value::toEchoStringNoThrow() const
-{
+std::string Value::toEchoStringNoThrow() const {
   std::string ret;
-  try{
+  try {
     ret = toEchoString();
-  } catch (EvaluationException& e) {
+  } catch (EvaluationException &e) {
     ret = "...";
   }
   return ret;
 }
 
-const UndefType& Value::toUndef() const
-{
+const UndefType &Value::toUndef() const {
   return std::get<UndefType>(this->value);
 }
 
-std::string Value::toUndefString() const
-{
+std::string Value::toUndefString() const {
   return std::get<UndefType>(this->value).toString();
 }
 
-class chr_visitor
-{
+class chr_visitor {
 public:
-  template <typename S> std::string operator()(const S&) const
-  {
-    return "";
-  }
+  template <typename S> std::string operator()(const S &) const { return ""; }
 
-  std::string operator()(const double& v) const
-  {
+  std::string operator()(const double &v) const {
     char buf[8];
     memset(buf, 0, 8);
     if (v > 0) {
@@ -514,51 +527,51 @@ public:
     return {buf};
   }
 
-  std::string operator()(const VectorType& v) const
-  {
+  std::string operator()(const VectorType &v) const {
     std::ostringstream stream;
-    for (auto& val : v) {
+    for (auto &val : v) {
       stream << val.chrString();
     }
     return stream.str();
   }
 
-  std::string operator()(const RangePtr& v) const
-  {
+  std::string operator()(const RangePtr &v) const {
     const uint32_t steps = v->numValues();
     if (steps >= RangeType::MAX_RANGE_STEPS) {
-      LOG(message_group::Warning, "Bad range parameter in for statement: too many elements (%1$lu).", steps);
+      LOG(message_group::Warning,
+          "Bad range parameter in for statement: too many elements (%1$lu).",
+          steps);
       return "";
     }
 
     std::ostringstream stream;
-    for (double d : *v) stream << Value(d).chrString();
+    for (double d : *v)
+      stream << Value(d).chrString();
     return stream.str();
   }
 };
 
-std::string Value::chrString() const
-{
+std::string Value::chrString() const {
   return std::visit(chr_visitor(), this->value);
 }
 
-VectorType::VectorType(EvaluationSession *session) :
-  ptr(std::shared_ptr<VectorObject>(new VectorObject(), VectorObjectDeleter() ))
-{
+VectorType::VectorType(EvaluationSession *session)
+    : ptr(std::shared_ptr<VectorObject>(new VectorObject(),
+                                        VectorObjectDeleter())) {
   ptr->evaluation_session = session;
 }
 
-VectorType::VectorType(class EvaluationSession *session, double x, double y, double z) :
-  ptr(std::shared_ptr<VectorObject>(new VectorObject(), VectorObjectDeleter() ))
-{
+VectorType::VectorType(class EvaluationSession *session, double x, double y,
+                       double z)
+    : ptr(std::shared_ptr<VectorObject>(new VectorObject(),
+                                        VectorObjectDeleter())) {
   ptr->evaluation_session = session;
   emplace_back(x);
   emplace_back(y);
   emplace_back(z);
 }
 
-void VectorType::emplace_back(Value&& val)
-{
+void VectorType::emplace_back(Value &&val) {
   if (val.type() == Value::Type::EMBEDDED_VECTOR) {
     emplace_back(std::move(val.toEmbeddedVectorNonConst()));
   } else {
@@ -570,32 +583,33 @@ void VectorType::emplace_back(Value&& val)
 }
 
 // Specialized handler for EmbeddedVectorTypes
-void VectorType::emplace_back(EmbeddedVectorType&& mbed)
-{
+void VectorType::emplace_back(EmbeddedVectorType &&mbed) {
   if (mbed.size() > 1) {
-    // embed_excess represents how many to add to vec.size() to get the total elements after flattening,
-    // the embedded vector itself already counts towards an element in the parent's size, so subtract 1 from its size.
+    // embed_excess represents how many to add to vec.size() to get the total
+    // elements after flattening, the embedded vector itself already counts
+    // towards an element in the parent's size, so subtract 1 from its size.
     ptr->embed_excess += mbed.size() - 1;
     ptr->vec.emplace_back(std::move(mbed));
     if (ptr->evaluation_session) {
       ptr->evaluation_session->accounting().addVectorElement(1);
     }
   } else if (mbed.size() == 1) {
-    // If embedded vector contains only one value, then insert a copy of that element
-    // Due to the above mentioned "-1" count, putting it in directaly as an EmbeddedVector
-    // would not change embed_excess, which is needed to check if flatten is required.
+    // If embedded vector contains only one value, then insert a copy of that
+    // element Due to the above mentioned "-1" count, putting it in directaly as
+    // an EmbeddedVector would not change embed_excess, which is needed to check
+    // if flatten is required.
     emplace_back(mbed.ptr->vec[0].clone());
   }
   // else mbed.size() == 0, do nothing
 }
 
-void VectorType::flatten() const
-{
+void VectorType::flatten() const {
   vec_t ret;
   ret.reserve(this->size());
-  // VectorType::iterator already handles the tricky recursive navigation of embedded vectors,
-  // so just build up our new vector from that.
-  for (const auto& el : *this) ret.emplace_back(el.clone());
+  // VectorType::iterator already handles the tricky recursive navigation of
+  // embedded vectors, so just build up our new vector from that.
+  for (const auto &el : *this)
+    ret.emplace_back(el.clone());
   assert(ret.size() == this->size());
   ptr->embed_excess = 0;
   if (ptr->evaluation_session) {
@@ -605,8 +619,7 @@ void VectorType::flatten() const
   ptr->vec = std::move(ret);
 }
 
-void VectorType::VectorObjectDeleter::operator()(VectorObject *v)
-{
+void VectorType::VectorObjectDeleter::operator()(VectorObject *v) {
   if (v->evaluation_session) {
     v->evaluation_session->accounting().removeVectorElement(v->vec.size());
   }
@@ -616,63 +629,65 @@ void VectorType::VectorObjectDeleter::operator()(VectorObject *v)
   std::vector<std::shared_ptr<VectorObject>> purge;
   while (true) {
     if (v && v->embed_excess) {
-      for (Value& val : v->vec) {
+      for (Value &val : v->vec) {
         auto type = val.type();
         if (type == Value::Type::EMBEDDED_VECTOR) {
-          std::shared_ptr<VectorObject>& temp = std::get<EmbeddedVectorType>(val.value).ptr;
-          if (temp.use_count() <= 1) purge.emplace_back(std::move(temp));
+          std::shared_ptr<VectorObject> &temp =
+              std::get<EmbeddedVectorType>(val.value).ptr;
+          if (temp.use_count() <= 1)
+            purge.emplace_back(std::move(temp));
         } else if (type == Value::Type::VECTOR) {
-          std::shared_ptr<VectorObject>& temp = std::get<VectorType>(val.value).ptr;
-          if (temp.use_count() <= 1) purge.emplace_back(std::move(temp));
+          std::shared_ptr<VectorObject> &temp =
+              std::get<VectorType>(val.value).ptr;
+          if (temp.use_count() <= 1)
+            purge.emplace_back(std::move(temp));
         }
       }
     }
-    if (purge.empty()) break;
-    curr = std::move(purge.back()); // this should cause destruction of the *previous value* for curr
+    if (purge.empty())
+      break;
+    curr = std::move(purge.back()); // this should cause destruction of the
+                                    // *previous value* for curr
     v = curr.get();
     purge.pop_back();
   }
   delete orig;
 }
 
-const VectorType& Value::toVector() const
-{
+const VectorType &Value::toVector() const {
   static const VectorType empty(nullptr);
   const VectorType *v = std::get_if<VectorType>(&this->value);
   return v ? *v : empty;
 }
 
-VectorType& Value::toVectorNonConst()
-{
+VectorType &Value::toVectorNonConst() {
   return std::get<VectorType>(this->value);
 }
 
-const ObjectType& Value::toObject() const
-{
+const ObjectType &Value::toObject() const {
   static const ObjectType empty(nullptr);
   const ObjectType *v = std::get_if<ObjectType>(&this->value);
   return v ? *v : empty;
 }
 
-EmbeddedVectorType& Value::toEmbeddedVectorNonConst()
-{
+EmbeddedVectorType &Value::toEmbeddedVectorNonConst() {
   return std::get<EmbeddedVectorType>(this->value);
 }
 
-const EmbeddedVectorType& Value::toEmbeddedVector() const
-{
+const EmbeddedVectorType &Value::toEmbeddedVector() const {
   return std::get<EmbeddedVectorType>(this->value);
 }
 
-bool Value::getVec2(double& x, double& y, bool ignoreInfinite) const
-{
-  if (this->type() != Type::VECTOR) return false;
-  const auto& v = this->toVector();
-  if (v.size() != 2) return false;
+bool Value::getVec2(double &x, double &y, bool ignoreInfinite) const {
+  if (this->type() != Type::VECTOR)
+    return false;
+  const auto &v = this->toVector();
+  if (v.size() != 2)
+    return false;
   double rx, ry;
   bool valid = ignoreInfinite
-    ? v[0].getFiniteDouble(rx) && v[1].getFiniteDouble(ry)
-    : v[0].getDouble(rx) && v[1].getDouble(ry);
+                   ? v[0].getFiniteDouble(rx) && v[1].getFiniteDouble(ry)
+                   : v[0].getDouble(rx) && v[1].getDouble(ry);
   if (valid) {
     x = rx;
     y = ry;
@@ -680,47 +695,48 @@ bool Value::getVec2(double& x, double& y, bool ignoreInfinite) const
   return valid;
 }
 
-bool Value::getVec3(double& x, double& y, double& z) const
-{
-  if (this->type() != Type::VECTOR) return false;
-  const VectorType& v = this->toVector();
-  if (v.size() != 3) return false;
+bool Value::getVec3(double &x, double &y, double &z) const {
+  if (this->type() != Type::VECTOR)
+    return false;
+  const VectorType &v = this->toVector();
+  if (v.size() != 3)
+    return false;
   return (v[0].getDouble(x) && v[1].getDouble(y) && v[2].getDouble(z));
 }
 
-bool Value::getVec3(double& x, double& y, double& z, double defaultval) const
-{
-  if (this->type() != Type::VECTOR) return false;
-  const VectorType& v = toVector();
+bool Value::getVec3(double &x, double &y, double &z, double defaultval) const {
+  if (this->type() != Type::VECTOR)
+    return false;
+  const VectorType &v = toVector();
   if (v.size() == 2) {
     getVec2(x, y);
     z = defaultval;
     return true;
   } else {
-    if (v.size() != 3) return false;
+    if (v.size() != 3)
+      return false;
   }
   return (v[0].getDouble(x) && v[1].getDouble(y) && v[2].getDouble(z));
 }
 
-const RangeType& Value::toRange() const
-{
+const RangeType &Value::toRange() const {
   const RangePtr *val = std::get_if<RangePtr>(&this->value);
   if (val) {
     return **val;
-  } else return RangeType::EMPTY;
+  } else
+    return RangeType::EMPTY;
 }
 
-const FunctionType& Value::toFunction() const
-{
+const FunctionType &Value::toFunction() const {
   return *std::get<FunctionPtr>(this->value);
 }
 
-bool Value::isUncheckedUndef() const
-{
-  return this->type() == Type::UNDEFINED && !std::get<UndefType>(this->value).empty();
+bool Value::isUncheckedUndef() const {
+  return this->type() == Type::UNDEFINED &&
+         !std::get<UndefType>(this->value).empty();
 }
 
-Value ObjectType::operator==(const ObjectType& other) const {
+Value ObjectType::operator==(const ObjectType &other) const {
   if (other.ptr == this->ptr) {
     return true;
   }
@@ -728,224 +744,265 @@ Value ObjectType::operator==(const ObjectType& other) const {
     return false;
   }
 
-  for ( size_t i = 0; i < this->ptr->values.size(); i++){
+  for (size_t i = 0; i < this->ptr->values.size(); i++) {
     auto key_the_same = this->ptr->keys[i] != other.ptr->keys[i];
     if (key_the_same) {
       return false;
     }
 
     auto value_the_same = this->ptr->values[i] != other.ptr->values[i];
-    if (value_the_same.toBool() ) {
+    if (value_the_same.toBool()) {
       return false;
     }
   }
   return true;
 }
-Value ObjectType::operator!=(const ObjectType& other) const {
+Value ObjectType::operator!=(const ObjectType &other) const {
   Value a = *this == other;
   return !a.toBool();
 }
 
-Value ObjectType::operator<(const ObjectType& /*other*/) const {
+Value ObjectType::operator<(const ObjectType & /*other*/) const {
   return Value::undef("operation undefined (object < object)");
 }
-Value ObjectType::operator>(const ObjectType& /*other*/) const {
+Value ObjectType::operator>(const ObjectType & /*other*/) const {
   return Value::undef("operation undefined (object > object)");
 }
-Value ObjectType::operator<=(const ObjectType& /*other*/) const {
+Value ObjectType::operator<=(const ObjectType & /*other*/) const {
   return Value::undef("operation undefined (object <= object)");
 }
-Value ObjectType::operator>=(const ObjectType& /*other*/) const {
+Value ObjectType::operator>=(const ObjectType & /*other*/) const {
   return Value::undef("operation undefined (object >= object)");
 }
 
-Value VectorType::operator==(const VectorType& v) const {
+Value VectorType::operator==(const VectorType &v) const {
   size_t i = 0;
-  auto first1 = this->begin(), last1 = this->end(), first2 = v.begin(), last2 = v.end();
-  for ( ; (first1 != last1) && (first2 != last2); ++first1, ++first2, ++i) {
+  auto first1 = this->begin(), last1 = this->end(), first2 = v.begin(),
+       last2 = v.end();
+  for (; (first1 != last1) && (first2 != last2); ++first1, ++first2, ++i) {
     Value temp = *first1 == *first2;
     if (temp.isUndefined()) {
       temp.toUndef().append(STR("in vector comparison at index ", i));
       return temp;
     }
-    if (!temp.toBool()) return false;
+    if (!temp.toBool())
+      return false;
   }
   return (first1 == last1) && (first2 == last2);
 }
 
-Value VectorType::operator!=(const VectorType& v) const {
+Value VectorType::operator!=(const VectorType &v) const {
   Value temp = this->VectorType::operator==(v);
-  if (temp.isUndefined()) return temp;
+  if (temp.isUndefined())
+    return temp;
   return !temp.toBool();
 }
 
 // lexicographical compare with possible undef result
-Value VectorType::operator<(const VectorType& v) const {
-  auto first1 = this->begin(), last1 = this->end(), first2 = v.begin(), last2 = v.end();
+Value VectorType::operator<(const VectorType &v) const {
+  auto first1 = this->begin(), last1 = this->end(), first2 = v.begin(),
+       last2 = v.end();
   size_t i = 0;
-  for ( ; (first1 != last1) && (first2 != last2); ++first1, ++first2, ++i) {
+  for (; (first1 != last1) && (first2 != last2); ++first1, ++first2, ++i) {
     Value temp = *first1 < *first2;
     if (temp.isUndefined()) {
       temp.toUndef().append(STR("in vector comparison at index ", i));
       return temp;
     }
-    if (temp.toBool()) return true;
-    if ((*first2 < *first1).toBool()) return false;
+    if (temp.toBool())
+      return true;
+    if ((*first2 < *first1).toBool())
+      return false;
   }
   return (first1 == last1) && (first2 != last2);
 }
 
-Value VectorType::operator>(const VectorType& v) const {
+Value VectorType::operator>(const VectorType &v) const {
   return v.VectorType::operator<(*this);
 }
 
-Value VectorType::operator<=(const VectorType& v) const {
+Value VectorType::operator<=(const VectorType &v) const {
   Value temp = this->VectorType::operator>(v);
-  if (temp.isUndefined()) return temp;
+  if (temp.isUndefined())
+    return temp;
   return !temp.toBool();
 }
 
-Value VectorType::operator>=(const VectorType& v) const {
+Value VectorType::operator>=(const VectorType &v) const {
   Value temp = this->VectorType::operator<(v);
-  if (temp.isUndefined()) return temp;
+  if (temp.isUndefined())
+    return temp;
   return !temp.toBool();
 }
 
-class notequal_visitor
-{
+class notequal_visitor {
 public:
-  template <typename T, typename U> Value operator()(const T& /*op1*/, const U& /*op2*/) const { return true; }
-  template <typename T> Value operator()(const T& op1, const T& op2) const { return op1 != op2; }
-  Value operator()(const UndefType&, const UndefType&) const { return false; }
-  template <typename T> Value operator()(const ValuePtr<T>& op1, const ValuePtr<T>& op2) const { return *op1 != *op2; }
+  template <typename T, typename U>
+  Value operator()(const T & /*op1*/, const U & /*op2*/) const {
+    return true;
+  }
+  template <typename T> Value operator()(const T &op1, const T &op2) const {
+    return op1 != op2;
+  }
+  Value operator()(const UndefType &, const UndefType &) const { return false; }
+  template <typename T>
+  Value operator()(const ValuePtr<T> &op1, const ValuePtr<T> &op2) const {
+    return *op1 != *op2;
+  }
 };
 
-class equals_visitor
-{
+class equals_visitor {
 public:
-  template <typename T, typename U> Value operator()(const T& /*op1*/, const U& /*op2*/) const { return false; }
-  template <typename T> Value operator()(const T& op1, const T& op2) const { return op1 == op2; }
-  Value operator()(const UndefType&, const UndefType&) const { return true; }
-  template <typename T> Value operator()(const ValuePtr<T>& op1, const ValuePtr<T>& op2) const { return *op1 == *op2; }
+  template <typename T, typename U>
+  Value operator()(const T & /*op1*/, const U & /*op2*/) const {
+    return false;
+  }
+  template <typename T> Value operator()(const T &op1, const T &op2) const {
+    return op1 == op2;
+  }
+  Value operator()(const UndefType &, const UndefType &) const { return true; }
+  template <typename T>
+  Value operator()(const ValuePtr<T> &op1, const ValuePtr<T> &op2) const {
+    return *op1 == *op2;
+  }
 };
 
-class less_visitor
-{
+class less_visitor {
 public:
-  template <typename T, typename U> Value operator()(const T& op1, const U& op2) const {
-    return Value::undef(STR("undefined operation (", getTypeName(op1), " < ", getTypeName(op2), ")"));
+  template <typename T, typename U>
+  Value operator()(const T &op1, const U &op2) const {
+    return Value::undef(STR("undefined operation (", getTypeName(op1), " < ",
+                            getTypeName(op2), ")"));
+  }
+  template <typename T> Value operator()(const T &op1, const T &op2) const {
+    return op1 < op2;
+  }
+  template <typename T>
+  Value operator()(const ValuePtr<T> &op1, const ValuePtr<T> &op2) const {
+    return *op1 < *op2;
   }
-  template <typename T> Value operator()(const T& op1, const T& op2) const { return op1 < op2; }
-  template <typename T> Value operator()(const ValuePtr<T>& op1, const ValuePtr<T>& op2) const { return *op1 < *op2; }
 };
 
-class greater_visitor
-{
+class greater_visitor {
 public:
-  template <typename T, typename U> Value operator()(const T& op1, const U& op2) const {
-    return Value::undef(STR("undefined operation (", getTypeName(op1), " > ", getTypeName(op2), ")"));
+  template <typename T, typename U>
+  Value operator()(const T &op1, const U &op2) const {
+    return Value::undef(STR("undefined operation (", getTypeName(op1), " > ",
+                            getTypeName(op2), ")"));
+  }
+  template <typename T> Value operator()(const T &op1, const T &op2) const {
+    return op1 > op2;
+  }
+  template <typename T>
+  Value operator()(const ValuePtr<T> &op1, const ValuePtr<T> &op2) const {
+    return *op1 > *op2;
   }
-  template <typename T> Value operator()(const T& op1, const T& op2) const { return op1 > op2; }
-  template <typename T> Value operator()(const ValuePtr<T>& op1, const ValuePtr<T>& op2) const { return *op1 > *op2; }
 };
 
-class lessequal_visitor
-{
+class lessequal_visitor {
 public:
-  template <typename T, typename U> Value operator()(const T& op1, const U& op2) const {
-    return Value::undef(STR("undefined operation (", getTypeName(op1), " <= ", getTypeName(op2), ")"));
+  template <typename T, typename U>
+  Value operator()(const T &op1, const U &op2) const {
+    return Value::undef(STR("undefined operation (", getTypeName(op1),
+                            " <= ", getTypeName(op2), ")"));
+  }
+  template <typename T> Value operator()(const T &op1, const T &op2) const {
+    return op1 <= op2;
+  }
+  template <typename T>
+  Value operator()(const ValuePtr<T> &op1, const ValuePtr<T> &op2) const {
+    return *op1 <= *op2;
   }
-  template <typename T> Value operator()(const T& op1, const T& op2) const { return op1 <= op2; }
-  template <typename T> Value operator()(const ValuePtr<T>& op1, const ValuePtr<T>& op2) const { return *op1 <= *op2; }
 };
 
-class greaterequal_visitor
-{
+class greaterequal_visitor {
 public:
-  template <typename T, typename U> Value operator()(const T& op1, const U& op2) const {
-    return Value::undef(STR("undefined operation (", getTypeName(op1), " >= ", getTypeName(op2), ")"));
+  template <typename T, typename U>
+  Value operator()(const T &op1, const U &op2) const {
+    return Value::undef(STR("undefined operation (", getTypeName(op1),
+                            " >= ", getTypeName(op2), ")"));
+  }
+  template <typename T> Value operator()(const T &op1, const T &op2) const {
+    return op1 >= op2;
+  }
+  template <typename T>
+  Value operator()(const ValuePtr<T> &op1, const ValuePtr<T> &op2) const {
+    return *op1 >= *op2;
   }
-  template <typename T> Value operator()(const T& op1, const T& op2) const { return op1 >= op2; }
-  template <typename T> Value operator()(const ValuePtr<T>& op1, const ValuePtr<T>& op2) const { return *op1 >= *op2; }
 };
 
-Value Value::operator==(const Value& v) const
-{
+Value Value::operator==(const Value &v) const {
   return std::visit(equals_visitor(), this->value, v.value);
 }
 
-Value Value::operator!=(const Value& v) const
-{
+Value Value::operator!=(const Value &v) const {
   return std::visit(notequal_visitor(), this->value, v.value);
 }
 
-Value Value::operator<(const Value& v) const
-{
+Value Value::operator<(const Value &v) const {
   return std::visit(less_visitor(), this->value, v.value);
 }
 
-Value Value::operator>=(const Value& v) const
-{
+Value Value::operator>=(const Value &v) const {
   return std::visit(greaterequal_visitor(), this->value, v.value);
 }
 
-Value Value::operator>(const Value& v) const
-{
+Value Value::operator>(const Value &v) const {
   return std::visit(greater_visitor(), this->value, v.value);
 }
 
-Value Value::operator<=(const Value& v) const
-{
+Value Value::operator<=(const Value &v) const {
   return std::visit(lessequal_visitor(), this->value, v.value);
 }
 
-bool Value::cmp_less(const Value& v1, const Value& v2) {
+bool Value::cmp_less(const Value &v1, const Value &v2) {
   return v1.operator<(v2).toBool();
 }
 
-class plus_visitor
-{
+class plus_visitor {
 public:
-  template <typename T, typename U> Value operator()(const T& op1, const U& op2) const {
-    return Value::undef(STR("undefined operation (", getTypeName(op1), " + ", getTypeName(op2), ")"));
+  template <typename T, typename U>
+  Value operator()(const T &op1, const U &op2) const {
+    return Value::undef(STR("undefined operation (", getTypeName(op1), " + ",
+                            getTypeName(op2), ")"));
   }
 
-  Value operator()(const double& op1, const double& op2) const {
+  Value operator()(const double &op1, const double &op2) const {
     return op1 + op2;
   }
 
-  Value operator()(const VectorType& op1, const VectorType& op2) const {
+  Value operator()(const VectorType &op1, const VectorType &op2) const {
     VectorType sum(op1.evaluation_session());
     sum.reserve(op1.size());
     // FIXME: should we really truncate to shortest vector here?
     //   Maybe better to either "add zeroes" and return longest
     //   and/or issue an warning/error about length mismatch.
-    for (auto it1 = op1.begin(), end1 = op1.end(), it2 = op2.begin(), end2 = op2.end();
-         it1 != end1 && it2 != end2;
-         ++it1, ++it2) {
+    for (auto it1 = op1.begin(), end1 = op1.end(), it2 = op2.begin(),
+              end2 = op2.end();
+         it1 != end1 && it2 != end2; ++it1, ++it2) {
       sum.emplace_back(*it1 + *it2);
     }
     return std::move(sum);
   }
 };
 
-Value Value::operator+(const Value& v) const
-{
+Value Value::operator+(const Value &v) const {
   return std::visit(plus_visitor(), this->value, v.value);
 }
 
-class minus_visitor
-{
+class minus_visitor {
 public:
-  template <typename T, typename U> Value operator()(const T& op1, const U& op2) const {
-    return Value::undef(STR("undefined operation (", getTypeName(op1), " - ", getTypeName(op2), ")"));
+  template <typename T, typename U>
+  Value operator()(const T &op1, const U &op2) const {
+    return Value::undef(STR("undefined operation (", getTypeName(op1), " - ",
+                            getTypeName(op2), ")"));
   }
 
-  Value operator()(const double& op1, const double& op2) const {
+  Value operator()(const double &op1, const double &op2) const {
     return op1 - op2;
   }
 
-  Value operator()(const VectorType& op1, const VectorType& op2) const {
+  Value operator()(const VectorType &op1, const VectorType &op2) const {
     VectorType sum(op1.evaluation_session());
     sum.reserve(op1.size());
     for (size_t i = 0; i < op1.size() && i < op2.size(); ++i) {
@@ -955,39 +1012,40 @@ public:
   }
 };
 
-Value Value::operator-(const Value& v) const
-{
+Value Value::operator-(const Value &v) const {
   return std::visit(minus_visitor(), this->value, v.value);
 }
 
-Value multvecnum(const VectorType& vecval, const Value& numval)
-{
+Value multvecnum(const VectorType &vecval, const Value &numval) {
   // Vector * Number
   VectorType dstv(vecval.evaluation_session());
   dstv.reserve(vecval.size());
-  for (const auto& val : vecval) {
+  for (const auto &val : vecval) {
     dstv.emplace_back(val * numval);
   }
   return std::move(dstv);
 }
 
-Value multmatvec(const VectorType& matrixvec, const VectorType& vectorvec)
-{
+Value multmatvec(const VectorType &matrixvec, const VectorType &vectorvec) {
   // Matrix * Vector
   VectorType dstv(matrixvec.evaluation_session());
   dstv.reserve(matrixvec.size());
   for (size_t i = 0; i < matrixvec.size(); ++i) {
     if (matrixvec[i].type() != Value::Type::VECTOR ||
         matrixvec[i].toVector().size() != vectorvec.size()) {
-      return Value::undef(STR("Matrix must be rectangular. Problem at row ", i));
+      return Value::undef(
+          STR("Matrix must be rectangular. Problem at row ", i));
     }
     double r_e = 0.0;
     for (size_t j = 0; j < matrixvec[i].toVector().size(); ++j) {
       if (matrixvec[i].toVector()[j].type() != Value::Type::NUMBER) {
-        return Value::undef(STR("Matrix must contain only numbers. Problem at row ", i, ", col ", j));
+        return Value::undef(
+            STR("Matrix must contain only numbers. Problem at row ", i,
+                ", col ", j));
       }
       if (vectorvec[j].type() != Value::Type::NUMBER) {
-        return Value::undef(STR("Vector must contain only numbers. Problem at index ", j));
+        return Value::undef(
+            STR("Vector must contain only numbers. Problem at index ", j));
       }
       r_e += matrixvec[i].toVector()[j].toDouble() * vectorvec[j].toDouble();
     }
@@ -996,8 +1054,7 @@ Value multmatvec(const VectorType& matrixvec, const VectorType& vectorvec)
   return std::move(dstv);
 }
 
-Value multvecmat(const VectorType& vectorvec, const VectorType& matrixvec)
-{
+Value multvecmat(const VectorType &vectorvec, const VectorType &matrixvec) {
   assert(vectorvec.size() == matrixvec.size());
   // Vector * Matrix
   VectorType dstv(matrixvec[0].toVector().evaluation_session());
@@ -1008,16 +1065,24 @@ Value multvecmat(const VectorType& vectorvec, const VectorType& matrixvec)
     for (size_t j = 0; j < vectorvec.size(); ++j) {
       if (matrixvec[j].type() != Value::Type::VECTOR ||
           matrixvec[j].toVector().size() != firstRowSize) {
-        LOG(message_group::Warning, "Matrix must be rectangular. Problem at row %1$lu", j);
-        return Value::undef(STR("Matrix must be rectangular. Problem at row ", j));
+        LOG(message_group::Warning,
+            "Matrix must be rectangular. Problem at row %1$lu", j);
+        return Value::undef(
+            STR("Matrix must be rectangular. Problem at row ", j));
       }
       if (vectorvec[j].type() != Value::Type::NUMBER) {
-        LOG(message_group::Warning, "Vector must contain only numbers. Problem at index %1$lu", j);
-        return Value::undef(STR("Vector must contain only numbers. Problem at index ", j));
+        LOG(message_group::Warning,
+            "Vector must contain only numbers. Problem at index %1$lu", j);
+        return Value::undef(
+            STR("Vector must contain only numbers. Problem at index ", j));
       }
       if (matrixvec[j].toVector()[i].type() != Value::Type::NUMBER) {
-        LOG(message_group::Warning, "Matrix must contain only numbers. Problem at row %1$lu, col %2$lu", j, i);
-        return Value::undef(STR("Matrix must contain only numbers. Problem at row ", j, ", col ", i));
+        LOG(message_group::Warning,
+            "Matrix must contain only numbers. Problem at row %1$lu, col %2$lu",
+            j, i);
+        return Value::undef(
+            STR("Matrix must contain only numbers. Problem at row ", j,
+                ", col ", i));
       }
       r_e += vectorvec[j].toDouble() * matrixvec[j].toVector()[i].toDouble();
     }
@@ -1026,56 +1091,83 @@ Value multvecmat(const VectorType& vectorvec, const VectorType& matrixvec)
   return {std::move(dstv)};
 }
 
-Value multvecvec(const VectorType& vec1, const VectorType& vec2) {
+Value multvecvec(const VectorType &vec1, const VectorType &vec2) {
   // Vector dot product.
   auto r = 0.0;
   for (size_t i = 0; i < vec1.size(); i++) {
-    if (vec1[i].type() != Value::Type::NUMBER || vec2[i].type() != Value::Type::NUMBER) {
-      return Value::undef(STR("undefined operation (", vec1[i].typeName(), " * ", vec2[i].typeName(), ")"));
+    if (vec1[i].type() != Value::Type::NUMBER ||
+        vec2[i].type() != Value::Type::NUMBER) {
+      return Value::undef(STR("undefined operation (", vec1[i].typeName(),
+                              " * ", vec2[i].typeName(), ")"));
     }
     r += vec1[i].toDouble() * vec2[i].toDouble();
   }
   return {r};
 }
 
-class multiply_visitor
-{
+class multiply_visitor {
 public:
-  template <typename T, typename U> Value operator()(const T& op1, const U& op2) const {
-    return Value::undef(STR("undefined operation (", getTypeName(op1), " * ", getTypeName(op2), ")"));
+  template <typename T, typename U>
+  Value operator()(const T &op1, const U &op2) const {
+    return Value::undef(STR("undefined operation (", getTypeName(op1), " * ",
+                            getTypeName(op2), ")"));
+  }
+  Value operator()(const double &op1, const double &op2) const {
+    return op1 * op2;
+  }
+  Value operator()(const double &op1, const VectorType &op2) const {
+    return multvecnum(op2, op1);
+  }
+  Value operator()(const VectorType &op1, const double &op2) const {
+    return multvecnum(op1, op2);
   }
-  Value operator()(const double& op1, const double& op2) const { return op1 * op2; }
-  Value operator()(const double& op1, const VectorType& op2) const { return multvecnum(op2, op1); }
-  Value operator()(const VectorType& op1, const double& op2) const { return multvecnum(op1, op2); }
 
-  Value operator()(const VectorType& op1, const VectorType& op2) const {
-    if (op1.empty() || op2.empty()) return Value::undef("Multiplication is undefined on empty vectors");
+  Value operator()(const VectorType &op1, const VectorType &op2) const {
+    if (op1.empty() || op2.empty())
+      return Value::undef("Multiplication is undefined on empty vectors");
     auto first1 = op1.begin(), first2 = op2.begin();
     auto eltype1 = (*first1).type(), eltype2 = (*first2).type();
     if (eltype1 == Value::Type::NUMBER) {
       if (eltype2 == Value::Type::NUMBER) {
-        if (op1.size() == op2.size()) return multvecvec(op1, op2);
-        else return Value::undef(STR("vector*vector requires matching lengths (", op1.size(), " != ", op2.size(), ')'));
+        if (op1.size() == op2.size())
+          return multvecvec(op1, op2);
+        else
+          return Value::undef(STR("vector*vector requires matching lengths (",
+                                  op1.size(), " != ", op2.size(), ')'));
       } else if (eltype2 == Value::Type::VECTOR) {
-        if (op1.size() == op2.size()) return multvecmat(op1, op2);
-        else return Value::undef(STR("vector*matrix requires vector length to match matrix row count (", op1.size(), " != ", op2.size(), ')'));
+        if (op1.size() == op2.size())
+          return multvecmat(op1, op2);
+        else
+          return Value::undef(STR("vector*matrix requires vector length to "
+                                  "match matrix row count (",
+                                  op1.size(), " != ", op2.size(), ')'));
       }
     } else if (eltype1 == Value::Type::VECTOR) {
       if (eltype2 == Value::Type::NUMBER) {
-        if ((*first1).toVector().size() == op2.size()) return multmatvec(op1, op2);
-        else return Value::undef(STR("matrix*vector requires matrix column count to match vector length (", (*first1).toVector().size(), " != ", op2.size(), ')'));
+        if ((*first1).toVector().size() == op2.size())
+          return multmatvec(op1, op2);
+        else
+          return Value::undef(STR("matrix*vector requires matrix column count "
+                                  "to match vector length (",
+                                  (*first1).toVector().size(),
+                                  " != ", op2.size(), ')'));
       } else if (eltype2 == Value::Type::VECTOR) {
         if ((*first1).toVector().size() == op2.size()) {
           // Matrix * Matrix
           VectorType dstv(op1.evaluation_session());
           dstv.reserve(op1.size());
           size_t i = 0;
-          for (const auto& srcrow : op1) {
-            const auto& srcrowvec = srcrow.toVector();
-            if (srcrowvec.size() != op2.size()) return Value::undef(STR("matrix*matrix left operand row length does not match right operand row count (", srcrowvec.size(), " != ", op2.size(), ") at row ", i));
+          for (const auto &srcrow : op1) {
+            const auto &srcrowvec = srcrow.toVector();
+            if (srcrowvec.size() != op2.size())
+              return Value::undef(
+                  STR("matrix*matrix left operand row length does not match "
+                      "right operand row count (",
+                      srcrowvec.size(), " != ", op2.size(), ") at row ", i));
             auto temp = multvecmat(srcrowvec, op2);
             if (temp.isUndefined()) {
-              temp.toUndef().append(STR("while processing left operand at row ", i));
+              temp.toUndef().append(
+                  STR("while processing left operand at row ", i));
               return temp;
             } else {
               dstv.emplace_back(std::move(temp));
@@ -1084,51 +1176,55 @@ public:
           }
           return {std::move(dstv)};
         } else {
-          return Value::undef(STR("matrix*matrix requires left operand column count to match right operand row count (", (*first1).toVector().size(), " != ", op2.size(), ')'));
+          return Value::undef(STR("matrix*matrix requires left operand column "
+                                  "count to match right operand row count (",
+                                  (*first1).toVector().size(),
+                                  " != ", op2.size(), ')'));
         }
       }
     }
-    return Value::undef(STR("undefined vector*vector multiplication where first elements are types ", (*first1).typeName(), " and ", (*first2).typeName() ));
+    return Value::undef(STR("undefined vector*vector multiplication where "
+                            "first elements are types ",
+                            (*first1).typeName(), " and ",
+                            (*first2).typeName()));
   }
 };
 
-Value Value::operator*(const Value& v) const
-{
+Value Value::operator*(const Value &v) const {
   return std::visit(multiply_visitor(), this->value, v.value);
 }
 
-Value Value::operator/(const Value& v) const
-{
+Value Value::operator/(const Value &v) const {
   if (this->type() == Type::NUMBER && v.type() == Type::NUMBER) {
     return this->toDouble() / v.toDouble();
   } else if (this->type() == Type::VECTOR && v.type() == Type::NUMBER) {
     VectorType dstv(this->toVector().evaluation_session());
     dstv.reserve(this->toVector().size());
-    for (const auto& vecval : this->toVector()) {
+    for (const auto &vecval : this->toVector()) {
       dstv.emplace_back(vecval / v);
     }
     return std::move(dstv);
   } else if (this->type() == Type::NUMBER && v.type() == Type::VECTOR) {
     VectorType dstv(v.toVector().evaluation_session());
     dstv.reserve(v.toVector().size());
-    for (const auto& vecval : v.toVector()) {
+    for (const auto &vecval : v.toVector()) {
       dstv.emplace_back(*this / vecval);
     }
     return std::move(dstv);
   }
-  return Value::undef(STR("undefined operation (", this->typeName(), " / ", v.typeName(), ")"));
+  return Value::undef(
+      STR("undefined operation (", this->typeName(), " / ", v.typeName(), ")"));
 }
 
-Value Value::operator%(const Value& v) const
-{
+Value Value::operator%(const Value &v) const {
   if (this->type() == Type::NUMBER && v.type() == Type::NUMBER) {
     return fmod(std::get<double>(this->value), std::get<double>(v.value));
   }
-  return Value::undef(STR("undefined operation (", this->typeName(), " % ", v.typeName(), ")"));
+  return Value::undef(
+      STR("undefined operation (", this->typeName(), " % ", v.typeName(), ")"));
 }
 
-Value Value::operator<<(const Value& v) const
-{
+Value Value::operator<<(const Value &v) const {
   if (this->type() == Type::NUMBER && v.type() == Type::NUMBER) {
     int64_t lhs = this->toInt64();
     int64_t rhs = v.toInt64();
@@ -1140,11 +1236,11 @@ Value Value::operator<<(const Value& v) const
     }
     return (double)(lhs << rhs);
   }
-  return Value::undef(STR("undefined operation (", this->typeName(), " << ", v.typeName(), ")"));
+  return Value::undef(STR("undefined operation (", this->typeName(), " << ",
+                          v.typeName(), ")"));
 }
 
-Value Value::operator>>(const Value& v) const
-{
+Value Value::operator>>(const Value &v) const {
   if (this->type() == Type::NUMBER && v.type() == Type::NUMBER) {
     int64_t lhs = this->toInt64();
     int64_t rhs = v.toInt64();
@@ -1156,34 +1252,33 @@ Value Value::operator>>(const Value& v) const
     }
     return (double)(lhs >> rhs);
   }
-  return Value::undef(STR("undefined operation (", this->typeName(), " >> ", v.typeName(), ")"));
+  return Value::undef(STR("undefined operation (", this->typeName(), " >> ",
+                          v.typeName(), ")"));
 }
 
-Value Value::operator&(const Value& v) const
-{
+Value Value::operator&(const Value &v) const {
   if (this->type() == Type::NUMBER && v.type() == Type::NUMBER) {
     return (double)(this->toInt64() & v.toInt64());
   }
-  return Value::undef(STR("undefined operation (", this->typeName(), " & ", v.typeName(), ")"));
+  return Value::undef(
+      STR("undefined operation (", this->typeName(), " & ", v.typeName(), ")"));
 }
 
-Value Value::operator|(const Value& v) const
-{
+Value Value::operator|(const Value &v) const {
   if (this->type() == Type::NUMBER && v.type() == Type::NUMBER) {
     return (double)(this->toInt64() | v.toInt64());
   }
-  return Value::undef(STR("undefined operation (", this->typeName(), " | ", v.typeName(), ")"));
+  return Value::undef(
+      STR("undefined operation (", this->typeName(), " | ", v.typeName(), ")"));
 }
 
-
-Value Value::operator-() const
-{
+Value Value::operator-() const {
   if (this->type() == Type::NUMBER) {
     return {-this->toDouble()};
   } else if (this->type() == Type::VECTOR) {
     VectorType dstv(this->toVector().evaluation_session());
     dstv.reserve(this->toVector().size());
-    for (const auto& vecval : this->toVector()) {
+    for (const auto &vecval : this->toVector()) {
       dstv.emplace_back(-vecval);
     }
     return std::move(dstv);
@@ -1191,31 +1286,30 @@ Value Value::operator-() const
   return Value::undef(STR("undefined operation (-", this->typeName(), ")"));
 }
 
-Value Value::operator~() const
-{
+Value Value::operator~() const {
   if (this->type() == Type::NUMBER) {
     return (double)~this->toInt64();
   }
   return Value::undef(STR("undefined operation (~", this->typeName(), ")"));
 }
 
-Value Value::operator^(const Value& v) const
-{
+Value Value::operator^(const Value &v) const {
   if (this->type() == Type::NUMBER && v.type() == Type::NUMBER) {
     return {pow(std::get<double>(this->value), std::get<double>(v.value))};
   }
-  return Value::undef(STR("undefined operation (", this->typeName(), " ^ ", v.typeName(), ")"));
+  return Value::undef(
+      STR("undefined operation (", this->typeName(), " ^ ", v.typeName(), ")"));
 }
 
 /*
  * bracket operation [] detecting multi-byte unicode.
- * If the string is multi-byte unicode then the index will offset to the character (2 or 4 byte) and not to the byte.
- * A 'normal' string with byte chars are a subset of unicode and still work.
+ * If the string is multi-byte unicode then the index will offset to the
+ * character (2 or 4 byte) and not to the byte. A 'normal' string with byte
+ * chars are a subset of unicode and still work.
  */
-class bracket_visitor
-{
+class bracket_visitor {
 public:
-  Value operator()(const str_utf8_wrapper& str, const double& idx) const {
+  Value operator()(const str_utf8_wrapper &str, const double &idx) const {
     const auto i = convert_to_uint32(idx);
     auto unichar = str[i];
     if (unichar.empty()) {
@@ -1224,90 +1318,94 @@ public:
     return unichar;
   }
 
-  Value operator()(const VectorType& vec, const double& idx) const {
+  Value operator()(const VectorType &vec, const double &idx) const {
     const auto i = convert_to_uint32(idx);
-    if (i < vec.size()) return vec[i].clone();
-    return Value::undef(STR("index ", i, " out of bounds for vector of size ", vec.size()));
+    if (i < vec.size())
+      return vec[i].clone();
+    return Value::undef(
+        STR("index ", i, " out of bounds for vector of size ", vec.size()));
   }
 
-  Value operator()(const ObjectType& obj, const str_utf8_wrapper& key) const {
+  Value operator()(const ObjectType &obj, const str_utf8_wrapper &key) const {
     return obj[key].clone();
   }
 
-  Value operator()(const RangePtr& range, const double& idx) const {
+  Value operator()(const RangePtr &range, const double &idx) const {
     const auto i = convert_to_uint32(idx);
     switch (i) {
-    case 0: return range->begin_value();
-    case 1: return range->step_value();
-    case 2: return range->end_value();
+    case 0:
+      return range->begin_value();
+    case 1:
+      return range->step_value();
+    case 2:
+      return range->end_value();
     }
-    return Value::undef("subscript operator only defined for indices 0-2 on range (begin,step,end)");
+    return Value::undef("subscript operator only defined for indices 0-2 on "
+                        "range (begin,step,end)");
   }
 
-  template <typename T, typename U> Value operator()(const T& op1, const U& op2) const {
-    //std::cout << "generic bracket_visitor " << getTypeName(op1) << " " << getTypeName(op2) << "\n";
-    return Value::undef(STR("undefined operation ", getTypeName(op1), "[", getTypeName(op2), "]"));
+  template <typename T, typename U>
+  Value operator()(const T &op1, const U &op2) const {
+    // std::cout << "generic bracket_visitor " << getTypeName(op1) << " " <<
+    // getTypeName(op2) << "\n";
+    return Value::undef(STR("undefined operation ", getTypeName(op1), "[",
+                            getTypeName(op2), "]"));
   }
 };
 
-Value Value::operator[](const Value& v) const
-{
+Value Value::operator[](const Value &v) const {
   return std::visit(bracket_visitor(), this->value, v.value);
 }
 
-Value Value::operator[](size_t idx) const
-{
+Value Value::operator[](size_t idx) const {
   Value v{(double)idx};
   return std::visit(bracket_visitor(), this->value, v.value);
 }
 
-std::ostream& operator<<(std::ostream& stream, const RangeType& r)
-{
+std::ostream &operator<<(std::ostream &stream, const RangeType &r) {
   char buffer[DC_BUFFER_SIZE];
   double_conversion::StringBuilder builder(buffer, DC_BUFFER_SIZE);
-  double_conversion::DoubleToStringConverter dc(DC_FLAGS, DC_INF,
-                                                DC_NAN, DC_EXP, DC_DECIMAL_LOW_EXP, DC_DECIMAL_HIGH_EXP,
-                                                DC_MAX_LEADING_ZEROES, DC_MAX_TRAILING_ZEROES);
-  return stream << "["
-                << DoubleConvert(r.begin_value(), buffer, builder, dc) << " : "
-                << DoubleConvert(r.step_value(), buffer, builder, dc) << " : "
-                << DoubleConvert(r.end_value(),   buffer, builder, dc) << "]";
+  double_conversion::DoubleToStringConverter dc(
+      DC_FLAGS, DC_INF, DC_NAN, DC_EXP, DC_DECIMAL_LOW_EXP, DC_DECIMAL_HIGH_EXP,
+      DC_MAX_LEADING_ZEROES, DC_MAX_TRAILING_ZEROES);
+  return stream << "[" << DoubleConvert(r.begin_value(), buffer, builder, dc)
+                << " : " << DoubleConvert(r.step_value(), buffer, builder, dc)
+                << " : " << DoubleConvert(r.end_value(), buffer, builder, dc)
+                << "]";
 }
 
 // called by clone()
-ObjectType::ObjectType(const std::shared_ptr<ObjectObject>& copy)
-  : ptr(copy)
-{
-}
+ObjectType::ObjectType(const std::shared_ptr<ObjectObject> &copy) : ptr(copy) {}
 
-ObjectType::ObjectType(EvaluationSession *session) :
-  ptr(std::make_shared<ObjectObject>())
-{
+ObjectType::ObjectType(EvaluationSession *session)
+    : ptr(std::make_shared<ObjectObject>()) {
   ptr->evaluation_session = session;
 }
 
-const Value& ObjectType::get(const std::string& key) const { return ptr->get(key); }
-bool ObjectType::set(const std::string& key, Value value)               { return ptr->set(key, std::move(value)); }
-bool ObjectType::del(const std::string& key)                            { return ptr->del(key) != NOINDEX; }
-bool ObjectType::contains(const std::string& key) const { return ptr->find(key) != NOINDEX; }
+const Value &ObjectType::get(const std::string &key) const {
+  return ptr->get(key);
+}
+bool ObjectType::set(const std::string &key, Value value) {
+  return ptr->set(key, std::move(value));
+}
+bool ObjectType::del(const std::string &key) {
+  return ptr->del(key) != NOINDEX;
+}
+bool ObjectType::contains(const std::string &key) const {
+  return ptr->find(key) != NOINDEX;
+}
 bool ObjectType::empty() const { return ptr->values.empty(); }
-const std::vector<std::string>& ObjectType::keys() const { return ptr->keys; }
-const std::vector<Value>& ObjectType::values() const { return ptr->values; }
+const std::vector<std::string> &ObjectType::keys() const { return ptr->keys; }
+const std::vector<Value> &ObjectType::values() const { return ptr->values; }
 
-const Value& ObjectType::operator[](const str_utf8_wrapper& v) const
-{
+const Value &ObjectType::operator[](const str_utf8_wrapper &v) const {
   return this->get(v.toString());
 }
 
-
 // Copy explicitly only when necessary
-ObjectType ObjectType::clone() const
-{
-  return ObjectType(this->ptr);
-}
+ObjectType ObjectType::clone() const { return ObjectType(this->ptr); }
 
-std::ostream& operator<<(std::ostream& stream, const ObjectType& v)
-{
+std::ostream &operator<<(std::ostream &stream, const ObjectType &v) {
   stream << "{ ";
   auto iter = v.ptr->keys.begin();
   if (iter != v.ptr->keys.end()) {
diff --git a/src/core/Value.h b/src/core/Value.h
index 8260ac6fb..787c25234 100644
--- a/src/core/Value.h
+++ b/src/core/Value.h
@@ -1,55 +1,52 @@
 #pragma once
 
-#include <iterator>
-#include <unordered_map>
-#include <utility>
-#include <vector>
-#include <string>
 #include <algorithm>
 #include <cstddef>
-#include <ostream>
+#include <iterator>
 #include <memory>
+#include <ostream>
+#include <string>
 #include <type_traits>
+#include <unordered_map>
+#include <utility>
 #include <variant>
+#include <vector>
 
 #include "core/FunctionType.h"
 #include "core/RangeType.h"
-#include "core/str_utf8_wrapper.h"
 #include "core/UndefType.h"
+#include "core/str_utf8_wrapper.h"
 
 class tostring_visitor;
 class tostream_visitor;
 class Expression;
 class Value;
 
-class QuotedString : public std::string
-{
+class QuotedString : public std::string {
 public:
   QuotedString() : std::string() {}
-  QuotedString(const std::string& s) : std::string(s) {}
+  QuotedString(const std::string &s) : std::string(s) {}
 };
-std::ostream& operator<<(std::ostream& stream, const QuotedString& s);
+std::ostream &operator<<(std::ostream &stream, const QuotedString &s);
 
-class Filename : public QuotedString
-{
+class Filename : public QuotedString {
 public:
   Filename() : QuotedString() {}
-  Filename(const std::string& f) : QuotedString(f) {}
+  Filename(const std::string &f) : QuotedString(f) {}
 };
-std::ostream& operator<<(std::ostream& stream, const Filename& filename);
+std::ostream &operator<<(std::ostream &stream, const Filename &filename);
 
-template <typename T>
-class ValuePtr
-{
+template <typename T> class ValuePtr {
 private:
-  explicit ValuePtr(std::shared_ptr<T> val_in) : value(std::move(val_in)) { }
+  explicit ValuePtr(std::shared_ptr<T> val_in) : value(std::move(val_in)) {}
+
 public:
-  ValuePtr(T&& value) : value(std::make_shared<T>(std::move(value))) { }
+  ValuePtr(T &&value) : value(std::make_shared<T>(std::move(value))) {}
   [[nodiscard]] ValuePtr clone() const { return ValuePtr(value); }
 
-  const T& operator*() const { return *value; }
+  const T &operator*() const { return *value; }
   const T *operator->() const { return value.get(); }
-  [[nodiscard]] const std::shared_ptr<T>& get() const { return value; }
+  [[nodiscard]] const std::shared_ptr<T> &get() const { return value; }
 
 private:
   std::shared_ptr<T> value;
@@ -61,19 +58,20 @@ using FunctionPtr = ValuePtr<FunctionType>;
 /**
  *  Value class encapsulates a std::variant value which can represent any of the
  *  value types existing in the SCAD language.
- * -- As part of a refactoring effort which began as PR #2881 and continued as PR #3102,
- *    Value and its constituent types have been made (nominally) "move only".
- * -- In some cases a copy of a Value is necessary or unavoidable, in which case Value::clone() can be used.
- * -- Value::clone() is used instead of automatic copy construction/assignment so this action is
- *    made deliberate and explicit (and discouraged).
- * -- Recommended to make use of RVO (Return Value Optimization) wherever possible:
- *       https://en.cppreference.com/w/cpp/language/copy_elision
- * -- Classes which cache Values such as Context or dxf_dim_cache(see dxfdim.cc), when queried
- *    should return either a const reference or a clone of the cached value if returning by-value.
- *    NEVER return a non-const reference!
+ * -- As part of a refactoring effort which began as PR #2881 and continued as
+ * PR #3102, Value and its constituent types have been made (nominally) "move
+ * only".
+ * -- In some cases a copy of a Value is necessary or unavoidable, in which case
+ * Value::clone() can be used.
+ * -- Value::clone() is used instead of automatic copy construction/assignment
+ * so this action is made deliberate and explicit (and discouraged).
+ * -- Recommended to make use of RVO (Return Value Optimization) wherever
+ * possible: https://en.cppreference.com/w/cpp/language/copy_elision
+ * -- Classes which cache Values such as Context or dxf_dim_cache(see
+ * dxfdim.cc), when queried should return either a const reference or a clone of
+ * the cached value if returning by-value. NEVER return a non-const reference!
  */
-class Value
-{
+class Value {
 public:
   enum class Type {
     UNDEFINED,
@@ -86,239 +84,296 @@ public:
     FUNCTION,
     OBJECT
   };
-  // FIXME: eventually remove this in favor of specific messages for each undef usage
+  // FIXME: eventually remove this in favor of specific messages for each undef
+  // usage
   static const Value undefined;
 
   /**
-   * VectorType is the underlying "BoundedType" of std::variant for OpenSCAD vectors.
-   * It holds only a shared_ptr to its VectorObject type, and provides a convenient
-   * interface for various operations needed on the vector.
+   * VectorType is the underlying "BoundedType" of std::variant for OpenSCAD
+   * vectors. It holds only a shared_ptr to its VectorObject type, and provides
+   * a convenient interface for various operations needed on the vector.
    *
-   * EmbeddedVectorType class derives from VectorType and enables O(1) concatenation of vectors
-   * by treating their elements as elements of their parent, traversable via VectorType's custom iterator.
-   * -- An embedded vector should never exist "in the wild", only as a pseudo-element of a parent vector.
-   *    Eg "Lc*" Expressions return Embedded Vectors but they are necessarily child expressions of a Vector expression.
-   * -- Any VectorType containing embedded elements will be forced to "flatten" upon usage of operator[],
-   *    which is the only case of random-access.
-   * -- Any loops through VectorTypes should prefer automatic range-based for loops eg: for(const auto& value : vec) { ... }
-   *    which make use of begin() and end() iterators of VectorType.  https://en.cppreference.com/w/cpp/language/range-for
-   * -- Moving a temporary Value of type VectorType or EmbeddedVectorType is always safe,
-   *    since it just moves the shared_ptr in its possession (which might be a copy but that doesn't matter).
-   *    Additionally any VectorType can be converted to an EmbeddedVectorType by moving it into
+   * EmbeddedVectorType class derives from VectorType and enables O(1)
+   * concatenation of vectors by treating their elements as elements of their
+   * parent, traversable via VectorType's custom iterator.
+   * -- An embedded vector should never exist "in the wild", only as a
+   * pseudo-element of a parent vector. Eg "Lc*" Expressions return Embedded
+   * Vectors but they are necessarily child expressions of a Vector expression.
+   * -- Any VectorType containing embedded elements will be forced to "flatten"
+   * upon usage of operator[], which is the only case of random-access.
+   * -- Any loops through VectorTypes should prefer automatic range-based for
+   * loops eg: for(const auto& value : vec) { ... } which make use of begin()
+   * and end() iterators of VectorType.
+   * https://en.cppreference.com/w/cpp/language/range-for
+   * -- Moving a temporary Value of type VectorType or EmbeddedVectorType is
+   * always safe, since it just moves the shared_ptr in its possession (which
+   * might be a copy but that doesn't matter). Additionally any VectorType can
+   * be converted to an EmbeddedVectorType by moving it into
    *    EmbeddedVectorType's converting constructor (or vice-versa).
-   * -- HOWEVER, moving elements out of a [Embedded]VectorType is potentially DANGEROUS unless it can be
-   *    verified that ( ptr.use_count() == 1 ) for that outermost [Embedded]VectorType
-   *    AND recursively any EmbeddedVectorTypes which led to that element.
-   *    Therefore elements are currently cloned rather than making any attempt to move.
-   *    Performing such use_count checks may be an area for further optimization.
+   * -- HOWEVER, moving elements out of a [Embedded]VectorType is potentially
+   * DANGEROUS unless it can be verified that ( ptr.use_count() == 1 ) for that
+   * outermost [Embedded]VectorType AND recursively any EmbeddedVectorTypes
+   * which led to that element. Therefore elements are currently cloned rather
+   * than making any attempt to move. Performing such use_count checks may be an
+   * area for further optimization.
    */
   class EmbeddedVectorType;
-  class VectorType
-  {
+  class VectorType {
 
-protected:
+  protected:
     // The object type which VectorType's shared_ptr points to.
     struct VectorObject {
       using vec_t = std::vector<Value>;
       using size_type = vec_t::size_type;
       vec_t vec;
-      size_type embed_excess = 0; // Keep count of the number of embedded elements *excess of* vec.size()
-      class EvaluationSession *evaluation_session = nullptr; // Used for heap size bookkeeping. May be null for vectors of known small maximum size.
-      [[nodiscard]] size_type size() const { return vec.size() + embed_excess;  }
-      [[nodiscard]] bool empty() const { return vec.empty() && embed_excess == 0;  }
+      size_type embed_excess = 0; // Keep count of the number of embedded
+                                  // elements *excess of* vec.size()
+      class EvaluationSession *evaluation_session =
+          nullptr; // Used for heap size bookkeeping. May be null for vectors of
+                   // known small maximum size.
+      [[nodiscard]] size_type size() const { return vec.size() + embed_excess; }
+      [[nodiscard]] bool empty() const {
+        return vec.empty() && embed_excess == 0;
+      }
     };
     using vec_t = VectorObject::vec_t;
-public:
+
+  public:
     std::shared_ptr<VectorObject> ptr;
-protected:
 
+  protected:
     // A Deleter is used on the shared_ptrs to avoid stack overflow in cases
-    // of destructing a very large list of nested embedded vectors, such as from a
-    // recursive function which concats one element at a time.
-    // (A similar solution can also be seen with CSGNode.h:CSGOperationDeleter).
+    // of destructing a very large list of nested embedded vectors, such as from
+    // a recursive function which concats one element at a time. (A similar
+    // solution can also be seen with CSGNode.h:CSGOperationDeleter).
     struct VectorObjectDeleter {
       void operator()(VectorObject *vec);
     };
-    void flatten() const; // flatten replaces VectorObject::vec with a new vector
-                          // where any embedded elements are copied directly into the top level vec,
-                          // leaving only true elements for straightforward indexing by operator[].
-    explicit VectorType(const std::shared_ptr<VectorObject>& copy) : ptr(copy) { } // called by clone()
-public:
+    void
+    flatten() const; // flatten replaces VectorObject::vec with a new vector
+                     // where any embedded elements are copied directly into the
+                     // top level vec, leaving only true elements for
+                     // straightforward indexing by operator[].
+    explicit VectorType(const std::shared_ptr<VectorObject> &copy)
+        : ptr(copy) {} // called by clone()
+  public:
     using size_type = VectorObject::size_type;
     static const VectorType EMPTY;
-    // EmbeddedVectorType-aware iterator, manages its own stack of begin/end vec_t::const_iterators
-    // such that calling code will only receive references to "true" elements (i.e. NOT EmbeddedVectorTypes).
-    // Also tracks the overall element index. In case flattening occurs during iteration, it can continue based on that index. (Issue #3541)
-    class iterator
-    {
-private:
+    // EmbeddedVectorType-aware iterator, manages its own stack of begin/end
+    // vec_t::const_iterators such that calling code will only receive
+    // references to "true" elements (i.e. NOT EmbeddedVectorTypes). Also tracks
+    // the overall element index. In case flattening occurs during iteration, it
+    // can continue based on that index. (Issue #3541)
+    class iterator {
+    private:
       const VectorObject *vo;
-      std::vector<std::pair<vec_t::const_iterator, vec_t::const_iterator>> it_stack;
+      std::vector<std::pair<vec_t::const_iterator, vec_t::const_iterator>>
+          it_stack;
       vec_t::const_iterator it, end;
       size_t index;
 
-      // Recursively push stack while current (pseudo)element is an EmbeddedVector
-      //  - Depends on the fact that VectorType::emplace_back(EmbeddedVectorType&& mbed)
-      //    will not embed an empty vector, which ensures iterator will arrive at an actual element,
-      //    unless already at end of parent VectorType.
-      void check_and_push()
-      {
+      // Recursively push stack while current (pseudo)element is an
+      // EmbeddedVector
+      //  - Depends on the fact that
+      //  VectorType::emplace_back(EmbeddedVectorType&& mbed)
+      //    will not embed an empty vector, which ensures iterator will arrive
+      //    at an actual element, unless already at end of parent VectorType.
+      void check_and_push() {
         if (it != end) {
           while (it->type() == Type::EMBEDDED_VECTOR) {
-            const vec_t& cur = it->toEmbeddedVector().ptr->vec;
+            const vec_t &cur = it->toEmbeddedVector().ptr->vec;
             it_stack.emplace_back(it, end);
             it = cur.begin();
             end = cur.end();
           }
         }
       }
-public:
+
+    public:
       using iterator_category = std::forward_iterator_tag;
       using value_type = Value;
       using difference_type = void;
-      using reference = const value_type&;
+      using reference = const value_type &;
       using pointer = const value_type *;
 
-      iterator() : vo(EMPTY.ptr.get()), it_stack(), it(EMPTY.ptr->vec.begin()), end(EMPTY.ptr->vec.end()), index(0) {}
-      iterator(const VectorObject *v) : vo(v), it(v->vec.begin()), end(v->vec.end()), index(0) {
-        if (vo->embed_excess) check_and_push();
+      iterator()
+          : vo(EMPTY.ptr.get()), it_stack(), it(EMPTY.ptr->vec.begin()),
+            end(EMPTY.ptr->vec.end()), index(0) {}
+      iterator(const VectorObject *v)
+          : vo(v), it(v->vec.begin()), end(v->vec.end()), index(0) {
+        if (vo->embed_excess)
+          check_and_push();
       }
-      iterator(const VectorObject *v, bool /*end*/) : vo(v), index(v->size()) { }
-      iterator& operator++() {
+      iterator(const VectorObject *v, bool /*end*/) : vo(v), index(v->size()) {}
+      iterator &operator++() {
         ++index;
         if (vo->embed_excess) {
-          // recursively increment and pop stack while at the end of EmbeddedVector(s)
+          // recursively increment and pop stack while at the end of
+          // EmbeddedVector(s)
           while (++it == end && !it_stack.empty()) {
-            const auto& up = it_stack.back();
+            const auto &up = it_stack.back();
             it = up.first;
             end = up.second;
             it_stack.pop_back();
           }
           check_and_push();
         } else { // vo->vec is flat
-          it = vo->vec.begin() + static_cast<vec_t::iterator::difference_type>(index);
+          it = vo->vec.begin() +
+               static_cast<vec_t::iterator::difference_type>(index);
         }
         return *this;
       }
       reference operator*() const { return *it; }
       pointer operator->() const { return &*it; }
-      bool operator==(const iterator& other) const { return this->vo == other.vo && this->index == other.index; }
-      bool operator!=(const iterator& other) const { return this->vo != other.vo || this->index != other.index; }
+      bool operator==(const iterator &other) const {
+        return this->vo == other.vo && this->index == other.index;
+      }
+      bool operator!=(const iterator &other) const {
+        return this->vo != other.vo || this->index != other.index;
+      }
     };
     using const_iterator = const iterator;
     VectorType(class EvaluationSession *session);
     VectorType(class EvaluationSession *session, double x, double y, double z);
-    VectorType(const VectorType&) = delete; // never copy, move instead
-    VectorType& operator=(const VectorType&) = delete; // never copy, move instead
-    VectorType(VectorType&&) = default;
-    VectorType& operator=(VectorType&&) = default;
+    VectorType(const VectorType &) = delete; // never copy, move instead
+    VectorType &
+    operator=(const VectorType &) = delete; // never copy, move instead
+    VectorType(VectorType &&) = default;
+    VectorType &operator=(VectorType &&) = default;
     ~VectorType() = default;
-    [[nodiscard]] VectorType clone() const { return VectorType(this->ptr); } // Copy explicitly only when necessary
+    [[nodiscard]] VectorType clone() const {
+      return VectorType(this->ptr);
+    } // Copy explicitly only when necessary
     static Value Empty() { return VectorType(nullptr); }
 
-    void reserve(size_t size) {
-      ptr->vec.reserve(size);
-    }
+    void reserve(size_t size) { ptr->vec.reserve(size); }
 
     [[nodiscard]] const_iterator begin() const { return iterator(ptr.get()); }
-    [[nodiscard]] const_iterator   end() const { return iterator(ptr.get(), true); }
+    [[nodiscard]] const_iterator end() const {
+      return iterator(ptr.get(), true);
+    }
     [[nodiscard]] size_type size() const { return ptr->size(); }
     [[nodiscard]] bool empty() const { return ptr->empty(); }
     // const accesses to VectorObject require .clone to be move-able
-    const Value& operator[](size_t idx) const {
+    const Value &operator[](size_t idx) const {
       if (idx < this->size()) {
-        if (ptr->embed_excess) flatten();
+        if (ptr->embed_excess)
+          flatten();
         return ptr->vec[idx];
       } else {
         return Value::undefined;
       }
     }
-    Value operator==(const VectorType& v) const;
-    Value operator<(const VectorType& v) const;
-    Value operator>(const VectorType& v) const;
-    Value operator!=(const VectorType& v) const;
-    Value operator<=(const VectorType& v) const;
-    Value operator>=(const VectorType& v) const;
-    [[nodiscard]] class EvaluationSession *evaluation_session() const { return ptr->evaluation_session; }
-
-    void emplace_back(Value&& val);
-    void emplace_back(EmbeddedVectorType&& mbed);
-    template <typename ... Args> void emplace_back(Args&&... args) { emplace_back(Value(std::forward<Args>(args)...)); }
+    Value operator==(const VectorType &v) const;
+    Value operator<(const VectorType &v) const;
+    Value operator>(const VectorType &v) const;
+    Value operator!=(const VectorType &v) const;
+    Value operator<=(const VectorType &v) const;
+    Value operator>=(const VectorType &v) const;
+    [[nodiscard]] class EvaluationSession *evaluation_session() const {
+      return ptr->evaluation_session;
+    }
+
+    void emplace_back(Value &&val);
+    void emplace_back(EmbeddedVectorType &&mbed);
+    template <typename... Args> void emplace_back(Args &&...args) {
+      emplace_back(Value(std::forward<Args>(args)...));
+    }
   };
 
-  class EmbeddedVectorType : public VectorType
-  {
-private:
-    explicit EmbeddedVectorType(const std::shared_ptr<VectorObject>& copy) : VectorType(copy) { } // called by clone()
-public:
-    EmbeddedVectorType(class EvaluationSession *session) : VectorType(session) {}
-    EmbeddedVectorType(const EmbeddedVectorType&) = delete;
-    EmbeddedVectorType& operator=(const EmbeddedVectorType&) = delete;
-    EmbeddedVectorType(EmbeddedVectorType&&) = default;
-    EmbeddedVectorType& operator=(EmbeddedVectorType&&) = default;
+  class EmbeddedVectorType : public VectorType {
+  private:
+    explicit EmbeddedVectorType(const std::shared_ptr<VectorObject> &copy)
+        : VectorType(copy) {} // called by clone()
+  public:
+    EmbeddedVectorType(class EvaluationSession *session)
+        : VectorType(session) {}
+    EmbeddedVectorType(const EmbeddedVectorType &) = delete;
+    EmbeddedVectorType &operator=(const EmbeddedVectorType &) = delete;
+    EmbeddedVectorType(EmbeddedVectorType &&) = default;
+    EmbeddedVectorType &operator=(EmbeddedVectorType &&) = default;
     ~EmbeddedVectorType() = default;
-    EmbeddedVectorType(VectorType&& v) : VectorType(std::move(v)) {} // converting constructor
-    [[nodiscard]] EmbeddedVectorType clone() const { return EmbeddedVectorType(this->ptr); }
+    EmbeddedVectorType(VectorType &&v)
+        : VectorType(std::move(v)) {} // converting constructor
+    [[nodiscard]] EmbeddedVectorType clone() const {
+      return EmbeddedVectorType(this->ptr);
+    }
     static Value Empty() { return EmbeddedVectorType(nullptr); }
   };
 
-  class ObjectType
-  {
-protected:
+  class ObjectType {
+  protected:
     struct ObjectObject;
     struct ObjectObjectDeleter {
       void operator()(ObjectObject *obj);
     };
 
-private:
-    explicit ObjectType(const std::shared_ptr<ObjectObject>& copy);
+  private:
+    explicit ObjectType(const std::shared_ptr<ObjectObject> &copy);
 
-public:
+  public:
     std::shared_ptr<ObjectObject> ptr;
     ObjectType(class EvaluationSession *session);
     [[nodiscard]] ObjectType clone() const;
-    [[nodiscard]] const Value& get(const std::string& key) const;
-    bool set(const std::string& key, Value value);
-    bool del(const std::string& key); // true if was present
-    bool contains(const std::string& key) const;
+    [[nodiscard]] const Value &get(const std::string &key) const;
+    bool set(const std::string &key, Value value);
+    bool del(const std::string &key); // true if was present
+    bool contains(const std::string &key) const;
     bool empty() const;
-    Value operator==(const ObjectType& v) const;
-    Value operator<(const ObjectType& v) const;
-    Value operator>(const ObjectType& v) const;
-    Value operator!=(const ObjectType& v) const;
-    Value operator<=(const ObjectType& v) const;
-    Value operator>=(const ObjectType& v) const;
-    const Value& operator[](const str_utf8_wrapper& v) const;
-    [[nodiscard]] const std::vector<std::string>& keys() const;
-    [[nodiscard]] const std::vector<Value>& values() const;
+    Value operator==(const ObjectType &v) const;
+    Value operator<(const ObjectType &v) const;
+    Value operator>(const ObjectType &v) const;
+    Value operator!=(const ObjectType &v) const;
+    Value operator<=(const ObjectType &v) const;
+    Value operator>=(const ObjectType &v) const;
+    const Value &operator[](const str_utf8_wrapper &v) const;
+    [[nodiscard]] const std::vector<std::string> &keys() const;
+    [[nodiscard]] const std::vector<Value> &values() const;
   };
 
 private:
-  Value() : value(UndefType()) { } // Don't default construct empty Values.  If "undefined" needed, use reference to Value::undefined, or call Value::undef() for return by value
+  Value()
+      : value(UndefType()) {
+  } // Don't default construct empty Values.  If "undefined" needed, use
+    // reference to Value::undefined, or call Value::undef() for return by value
 public:
-  Value(const Value&) = delete; // never copy, move instead
-  Value& operator=(const Value& v) = delete; // never copy, move instead
-  Value(Value&&) = default;
-  Value& operator=(Value&&) = default;
+  Value(const Value &) = delete;             // never copy, move instead
+  Value &operator=(const Value &v) = delete; // never copy, move instead
+  Value(Value &&) = default;
+  Value &operator=(Value &&) = default;
   [[nodiscard]] Value clone() const; // Use sparingly to explicitly copy a Value
   ~Value() = default;
 
-  Value(int v) : value(double(v)) { }
-  Value(const char *v) : value(str_utf8_wrapper(v)) { } // prevent insane implicit conversion to bool!
-  Value(char *v) : value(str_utf8_wrapper(v)) { } // prevent insane implicit conversion to bool!
-                                                  // http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0608r3.html
+  Value(int v) : value(double(v)) {}
+  Value(const char *v)
+      : value(str_utf8_wrapper(v)) {
+  } // prevent insane implicit conversion to bool!
+  Value(char *v)
+      : value(str_utf8_wrapper(v)) {
+  } // prevent insane implicit conversion to bool!
+    // http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0608r3.html
   // Don't shadow move constructor
-  template <class T, class = std::enable_if_t<!std::is_same_v<std::decay_t<T>, Value>>>
-  Value(T&& val) : value(std::forward<T>(val)) { }
+  template <class T,
+            class = std::enable_if_t<!std::is_same_v<std::decay_t<T>, Value>>>
+  Value(T &&val) : value(std::forward<T>(val)) {}
 
-  static Value undef(const std::string& why); // creation of undef requires a reason!
+  static Value
+  undef(const std::string &why); // creation of undef requires a reason!
 
   [[nodiscard]] const std::string typeName() const;
   [[nodiscard]] static std::string typeName(Type type);
-  [[nodiscard]] Type type() const { return static_cast<Type>(this->value.index()); }
-  [[nodiscard]] bool isDefinedAs(const Type type) const { return this->type() == type; }
-  [[nodiscard]] bool isDefined()   const { return this->type() != Type::UNDEFINED; }
-  [[nodiscard]] bool isUndefined() const { return this->type() == Type::UNDEFINED; }
+  [[nodiscard]] Type type() const {
+    return static_cast<Type>(this->value.index());
+  }
+  [[nodiscard]] bool isDefinedAs(const Type type) const {
+    return this->type() == type;
+  }
+  [[nodiscard]] bool isDefined() const {
+    return this->type() != Type::UNDEFINED;
+  }
+  [[nodiscard]] bool isUndefined() const {
+    return this->type() == Type::UNDEFINED;
+  }
   [[nodiscard]] bool isUncheckedUndef() const;
 
   // Conversion to std::variant "BoundedType"s. const ref where appropriate.
@@ -326,65 +381,70 @@ public:
   [[nodiscard]] double toDouble() const;
   [[nodiscard]] double toInteger() const;
   [[nodiscard]] int64_t toInt64() const;
-  [[nodiscard]] const str_utf8_wrapper& toStrUtf8Wrapper() const;
-  [[nodiscard]] const VectorType& toVector() const;
-  [[nodiscard]] const EmbeddedVectorType& toEmbeddedVector() const;
-  [[nodiscard]] VectorType& toVectorNonConst();
-  [[nodiscard]] EmbeddedVectorType& toEmbeddedVectorNonConst();
-  [[nodiscard]] const RangeType& toRange() const;
-  [[nodiscard]] const FunctionType& toFunction() const;
-  [[nodiscard]] const ObjectType& toObject() const;
+  [[nodiscard]] const str_utf8_wrapper &toStrUtf8Wrapper() const;
+  [[nodiscard]] const VectorType &toVector() const;
+  [[nodiscard]] const EmbeddedVectorType &toEmbeddedVector() const;
+  [[nodiscard]] VectorType &toVectorNonConst();
+  [[nodiscard]] EmbeddedVectorType &toEmbeddedVectorNonConst();
+  [[nodiscard]] const RangeType &toRange() const;
+  [[nodiscard]] const FunctionType &toFunction() const;
+  [[nodiscard]] const ObjectType &toObject() const;
 
   // Other conversion utility functions
-  bool getDouble(double& v) const;
-  bool getFiniteDouble(double& v) const;
-  bool getUnsignedInt(unsigned int& v) const;
-  bool getPositiveInt(unsigned int& v) const;
+  bool getDouble(double &v) const;
+  bool getFiniteDouble(double &v) const;
+  bool getUnsignedInt(unsigned int &v) const;
+  bool getPositiveInt(unsigned int &v) const;
   [[nodiscard]] std::string toString() const;
   [[nodiscard]] std::string toEchoString() const;
-  [[nodiscard]] std::string toEchoStringNoThrow() const; //use this for warnings
-  [[nodiscard]] const UndefType& toUndef() const;
+  [[nodiscard]] std::string toEchoStringNoThrow() const; // use this for
+                                                         // warnings
+  [[nodiscard]] const UndefType &toUndef() const;
   [[nodiscard]] std::string toUndefString() const;
   [[nodiscard]] std::string chrString() const;
-  bool getVec2(double& x, double& y, bool ignoreInfinite = false) const;
-  bool getVec3(double& x, double& y, double& z) const;
-  bool getVec3(double& x, double& y, double& z, double defaultval) const;
+  bool getVec2(double &x, double &y, bool ignoreInfinite = false) const;
+  bool getVec3(double &x, double &y, double &z) const;
+  bool getVec3(double &x, double &y, double &z, double defaultval) const;
 
   // Common Operators
   operator bool() const = delete;
-  Value operator==(const Value& v) const;
-  Value operator!=(const Value& v) const;
-  Value operator<(const Value& v) const;
-  Value operator<=(const Value& v) const;
-  Value operator>=(const Value& v) const;
-  Value operator>(const Value& v) const;
+  Value operator==(const Value &v) const;
+  Value operator!=(const Value &v) const;
+  Value operator<(const Value &v) const;
+  Value operator<=(const Value &v) const;
+  Value operator>=(const Value &v) const;
+  Value operator>(const Value &v) const;
   Value operator-() const;
   Value operator~() const;
   Value operator[](size_t idx) const;
-  Value operator[](const Value& v) const;
-  Value operator+(const Value& v) const;
-  Value operator-(const Value& v) const;
-  Value operator<<(const Value& v) const;
-  Value operator>>(const Value& v) const;
-  Value operator&(const Value& v) const;
-  Value operator|(const Value& v) const;
-  Value operator*(const Value& v) const;
-  Value operator/(const Value& v) const;
-  Value operator%(const Value& v) const;
-  Value operator^(const Value& v) const;
-
-  static bool cmp_less(const Value& v1, const Value& v2);
-
-  friend std::ostream& operator<<(std::ostream& stream, const Value& value) {
-    if (value.type() == Value::Type::STRING) stream << QuotedString(value.toString());
-    else stream << value.toString();
+  Value operator[](const Value &v) const;
+  Value operator+(const Value &v) const;
+  Value operator-(const Value &v) const;
+  Value operator<<(const Value &v) const;
+  Value operator>>(const Value &v) const;
+  Value operator&(const Value &v) const;
+  Value operator|(const Value &v) const;
+  Value operator*(const Value &v) const;
+  Value operator/(const Value &v) const;
+  Value operator%(const Value &v) const;
+  Value operator^(const Value &v) const;
+
+  static bool cmp_less(const Value &v1, const Value &v2);
+
+  friend std::ostream &operator<<(std::ostream &stream, const Value &value) {
+    if (value.type() == Value::Type::STRING)
+      stream << QuotedString(value.toString());
+    else
+      stream << value.toString();
     return stream;
   }
 
-  using Variant = std::variant<UndefType, bool, double, str_utf8_wrapper, VectorType, EmbeddedVectorType, RangePtr, FunctionPtr, ObjectType>;
+  using Variant =
+      std::variant<UndefType, bool, double, str_utf8_wrapper, VectorType,
+                   EmbeddedVectorType, RangePtr, FunctionPtr, ObjectType>;
 
   static_assert(sizeof(Value::Variant) <= 24, "Memory size of Value too big");
-  [[nodiscard]] const Variant& getVariant() const { return value; }
+  [[nodiscard]] const Variant &getVariant() const { return value; }
 
 private:
   Variant value;
@@ -409,26 +469,27 @@ struct Value::ObjectType::ObjectObject {
   std::vector<std::string> keys;
   std::vector<Value> values;
 
-  const size_t find(const std::string& key) {
-    if (!keys.empty() && map.empty()){
-      for ( size_t i = 0; i < keys.size(); i++) {
+  const size_t find(const std::string &key) {
+    if (!keys.empty() && map.empty()) {
+      for (size_t i = 0; i < keys.size(); i++) {
         map.emplace(keys[i], i);
       }
     }
     auto it = map.find(key);
     if (it != map.end()) {
       return it->second;
-    } else return NOINDEX;
+    } else
+      return NOINDEX;
   }
 
-  bool set(const std::string& key, Value value) {
+  bool set(const std::string &key, Value value) {
     size_t index = find(key);
     if (index != NOINDEX) {
       // if contains key, keep at same position
       values[index] = std::move(value);
     } else {
       if (!map.empty()) {
-        map[key] = keys.size();       // incremental update
+        map[key] = keys.size(); // incremental update
       }
       keys.emplace_back(key);
       values.emplace_back(std::move(value));
@@ -436,7 +497,7 @@ struct Value::ObjectType::ObjectObject {
     return index == NOINDEX;
   }
 
-  size_t del(const std::string& key) {
+  size_t del(const std::string &key) {
     size_t index = find(key);
     if (index != NOINDEX) {
       keys.erase(keys.begin() + index);
@@ -446,14 +507,16 @@ struct Value::ObjectType::ObjectObject {
     return index;
   }
 
-  const Value& get(const std::string& key) {
+  const Value &get(const std::string &key) {
     size_t index = find(key);
-    if (index != NOINDEX)return values[index];
-    else return Value::undefined;
+    if (index != NOINDEX)
+      return values[index];
+    else
+      return Value::undefined;
   }
 };
 
-std::ostream& operator<<(std::ostream& stream, const Value::ObjectType& u);
+std::ostream &operator<<(std::ostream &stream, const Value::ObjectType &u);
 
 using VectorType = Value::VectorType;
 using EmbeddedVectorType = Value::EmbeddedVectorType;
diff --git a/src/core/ValueMap.h b/src/core/ValueMap.h
index 226658499..2a97fe7fe 100644
--- a/src/core/ValueMap.h
+++ b/src/core/ValueMap.h
@@ -3,13 +3,12 @@
 
 #include <cstddef>
 #include <string>
-#include <utility>
 #include <unordered_map>
+#include <utility>
 
 // Wrapper for provide *futuristic* unordered_map features,
 // plus some functions specialized to our use case.
-class ValueMap
-{
+class ValueMap {
   using map_t = std::unordered_map<std::string, Value>;
   map_t map;
 
@@ -17,27 +16,30 @@ public:
   using iterator = map_t::iterator;
   using const_iterator = map_t::const_iterator;
 
-// Gotta have C++20 for this beast
-  bool contains(const std::string& name) const { return map.count(name); }
+  // Gotta have C++20 for this beast
+  bool contains(const std::string &name) const { return map.count(name); }
 
-// Directly wrapped calls
-  const_iterator find(const std::string& name) const {  return map.find(name); }
-  const_iterator begin() const {  return map.cbegin(); }
-  const_iterator end() const {  return map.cend(); }
-  iterator begin() {  return map.begin(); }
-  iterator end() {  return map.end(); }
+  // Directly wrapped calls
+  const_iterator find(const std::string &name) const { return map.find(name); }
+  const_iterator begin() const { return map.cbegin(); }
+  const_iterator end() const { return map.cend(); }
+  iterator begin() { return map.begin(); }
+  iterator end() { return map.end(); }
   void clear() { map.clear(); }
   size_t size() const { return map.size(); }
-  template <typename ... Args> std::pair<iterator, bool> emplace(Args&&... args) {
+  template <typename... Args>
+  std::pair<iterator, bool> emplace(Args &&...args) {
     return map.emplace(std::forward<Args>(args)...);
   }
-  std::pair<iterator, bool> insert_or_assign(const std::string& name, Value&& value) {
+  std::pair<iterator, bool> insert_or_assign(const std::string &name,
+                                             Value &&value) {
     return map.insert_or_assign(name, std::move(value));
   }
 
-  // Get value by name, without possibility of default-constructing a missing name
+  // Get value by name, without possibility of default-constructing a missing
+  // name
   //   return Value::undefined if key missing
-  const Value& get(const std::string& name) const {
+  const Value &get(const std::string &name) const {
     auto result = map.find(name);
     return result == map.end() ? Value::undefined : result->second;
   }
diff --git a/src/core/builtin_functions.cc b/src/core/builtin_functions.cc
index 630e46104..cec9369b7 100644
--- a/src/core/builtin_functions.cc
+++ b/src/core/builtin_functions.cc
@@ -24,28 +24,28 @@
  *
  */
 
-#include "core/function.h"
 #include "core/AST.h"
 #include "core/Arguments.h"
-#include "core/Expression.h"
 #include "core/Builtins.h"
-#include "utils/printutils.h"
-#include "core/UserModule.h"
-#include "utils/degree_trig.h"
+#include "core/Expression.h"
 #include "core/FreetypeRenderer.h"
 #include "core/Parameters.h"
-#include "io/import.h"
+#include "core/UserModule.h"
+#include "core/function.h"
 #include "io/fileutils.h"
+#include "io/import.h"
+#include "utils/degree_trig.h"
+#include "utils/printutils.h"
 
-#include <utility>
-#include <cstdint>
-#include <memory>
+#include <algorithm>
 #include <cmath>
-#include <sstream>
+#include <cstdint>
 #include <ctime>
 #include <limits>
-#include <algorithm>
+#include <memory>
 #include <random>
+#include <sstream>
+#include <utility>
 #include <vector>
 
 #include "utils/boost-utils.h"
@@ -71,33 +71,42 @@ void initialize_rng() {
   seed_val ^= distributor(deterministic_rng);
 }
 
-
-static inline bool check_arguments(const char *function_name, const Arguments& arguments, const Location& loc, unsigned int expected_count, bool warn = true)
-{
+static inline bool check_arguments(const char *function_name,
+                                   const Arguments &arguments,
+                                   const Location &loc,
+                                   unsigned int expected_count,
+                                   bool warn = true) {
   if (arguments.size() != expected_count) {
     if (warn) {
-      print_argCnt_warning(function_name, arguments.size(), STR(expected_count), loc, arguments.documentRoot());
+      print_argCnt_warning(function_name, arguments.size(), STR(expected_count),
+                           loc, arguments.documentRoot());
     }
     return false;
   }
   return true;
 }
 /* // Commented due to compiler warning of unused function.
-   static inline bool try_check_arguments(const Arguments& arguments, int expected_count)
+   static inline bool try_check_arguments(const Arguments& arguments, int
+   expected_count)
    {
-   return check_arguments(nullptr, arguments, Location::NONE, expected_count, false);
+   return check_arguments(nullptr, arguments, Location::NONE, expected_count,
+   false);
    }
  */
 template <size_t N>
-static inline bool check_arguments(const char *function_name, const Arguments& arguments, const Location& loc, const Value::Type (& expected_types) [N], bool warn = true)
-{
+static inline bool
+check_arguments(const char *function_name, const Arguments &arguments,
+                const Location &loc, const Value::Type (&expected_types)[N],
+                bool warn = true) {
   if (!check_arguments(function_name, arguments, loc, N, warn)) {
     return false;
   }
   for (size_t i = 0; i < N; i++) {
     if (arguments[i]->type() != expected_types[i]) {
       if (warn) {
-        print_argConvert_positioned_warning(function_name, "argument " + STR(i), arguments[i]->clone(), {expected_types[i]}, loc, arguments.documentRoot());
+        print_argConvert_positioned_warning(
+            function_name, "argument " + STR(i), arguments[i]->clone(),
+            {expected_types[i]}, loc, arguments.documentRoot());
       }
       return false;
     }
@@ -106,70 +115,79 @@ static inline bool check_arguments(const char *function_name, const Arguments& a
 }
 
 template <size_t N>
-static inline bool try_check_arguments(const Arguments& arguments, const Value::Type (& expected_types) [N])
-{
-  return check_arguments(nullptr, arguments, Location::NONE, expected_types, false);
+static inline bool try_check_arguments(const Arguments &arguments,
+                                       const Value::Type (&expected_types)[N]) {
+  return check_arguments(nullptr, arguments, Location::NONE, expected_types,
+                         false);
 }
 
-Value builtin_abs(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("abs", arguments, loc, { Value::Type::NUMBER })) {
+Value builtin_abs(Arguments arguments, const Location &loc) {
+  if (!check_arguments("abs", arguments, loc, {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {std::fabs(arguments[0]->toDouble())};
 }
 
-Value builtin_sign(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("sign", arguments, loc, { Value::Type::NUMBER })) {
+Value builtin_sign(Arguments arguments, const Location &loc) {
+  if (!check_arguments("sign", arguments, loc, {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   double x = arguments[0]->toDouble();
   return {(x < 0) ? -1.0 : ((x > 0) ? 1.0 : 0.0)};
 }
 
-Value builtin_rands(Arguments arguments, const Location& loc)
-{
+Value builtin_rands(Arguments arguments, const Location &loc) {
   if (arguments.size() < 3 || arguments.size() > 4) {
-    print_argCnt_warning("rands", arguments.size(), "3 or 4", loc, arguments.documentRoot());
+    print_argCnt_warning("rands", arguments.size(), "3 or 4", loc,
+                         arguments.documentRoot());
     return Value::undefined.clone();
   } else if (arguments.size() == 3) {
-    if (!check_arguments("rands", arguments, loc, { Value::Type::NUMBER, Value::Type::NUMBER, Value::Type::NUMBER })) {
+    if (!check_arguments(
+            "rands", arguments, loc,
+            {Value::Type::NUMBER, Value::Type::NUMBER, Value::Type::NUMBER})) {
       return Value::undefined.clone();
     }
   } else {
-    if (!check_arguments("rands", arguments, loc, { Value::Type::NUMBER, Value::Type::NUMBER, Value::Type::NUMBER, Value::Type::NUMBER })) {
+    if (!check_arguments("rands", arguments, loc,
+                         {Value::Type::NUMBER, Value::Type::NUMBER,
+                          Value::Type::NUMBER, Value::Type::NUMBER})) {
       return Value::undefined.clone();
     }
   }
 
   double min = arguments[0]->toDouble();
   if (std::isinf(min) || std::isnan(min)) {
-    LOG(message_group::Warning, loc, arguments.documentRoot(), "rands() range min cannot be infinite");
+    LOG(message_group::Warning, loc, arguments.documentRoot(),
+        "rands() range min cannot be infinite");
     min = -std::numeric_limits<double>::max() / 2;
     LOG(message_group::Warning, "resetting to %1f", min);
   }
 
   double max = arguments[1]->toDouble();
-  if (std::isinf(max)  || std::isnan(max)) {
-    LOG(message_group::Warning, loc, arguments.documentRoot(), "rands() range max cannot be infinite");
+  if (std::isinf(max) || std::isnan(max)) {
+    LOG(message_group::Warning, loc, arguments.documentRoot(),
+        "rands() range max cannot be infinite");
     max = std::numeric_limits<double>::max() / 2;
     LOG(message_group::Warning, "resetting to %1f", max);
   }
   if (max < min) {
-    double tmp = min; min = max; max = tmp;
+    double tmp = min;
+    min = max;
+    max = tmp;
   }
 
-  double numresultsd = std::abs(arguments[2]->toDouble() );
+  double numresultsd = std::abs(arguments[2]->toDouble());
   if (std::isinf(numresultsd) || std::isnan(numresultsd)) {
-    LOG(message_group::Warning, loc, arguments.documentRoot(), "rands() cannot create an infinite number of results");
+    LOG(message_group::Warning, loc, arguments.documentRoot(),
+        "rands() cannot create an infinite number of results");
     LOG(message_group::Warning, "resetting number of results to 1");
     numresultsd = 1;
   }
   auto numresults = boost_numeric_cast<size_t, double>(numresultsd);
 
   if (arguments.size() > 3) {
-    auto seed = static_cast<uint32_t>(hash_floating_point(arguments[3]->toDouble() ));
+    auto seed =
+        static_cast<uint32_t>(hash_floating_point(arguments[3]->toDouble()));
     deterministic_rng.seed(seed);
   }
 
@@ -187,37 +205,46 @@ Value builtin_rands(Arguments arguments, const Location& loc)
   return std::move(vec);
 }
 
-static std::vector<double> min_max_arguments(const Arguments& arguments, const Location& loc, const char *function_name)
-{
+static std::vector<double> min_max_arguments(const Arguments &arguments,
+                                             const Location &loc,
+                                             const char *function_name) {
   std::vector<double> output;
   // preserve special handling of the first argument
   // as a template for vector processing
   if (arguments.size() == 0) {
-    print_argCnt_warning(function_name, arguments.size(), "at least 1", loc, arguments.documentRoot());
+    print_argCnt_warning(function_name, arguments.size(), "at least 1", loc,
+                         arguments.documentRoot());
     return {};
-  } else if (arguments.size() == 1 && arguments[0]->type() == Value::Type::VECTOR) {
-    const auto& elements = arguments[0]->toVector();
+  } else if (arguments.size() == 1 &&
+             arguments[0]->type() == Value::Type::VECTOR) {
+    const auto &elements = arguments[0]->toVector();
     if (elements.size() == 0) {
-      print_argCnt_warning(function_name, elements.size(), "at least 1 vector element", loc, arguments.documentRoot());
+      print_argCnt_warning(function_name, elements.size(),
+                           "at least 1 vector element", loc,
+                           arguments.documentRoot());
       return {};
     }
     for (size_t i = 0; i < elements.size(); i++) {
-      const auto& element = elements[i];
+      const auto &element = elements[i];
       // 4/20/14 semantic change per discussion:
       // break on any non-number
       if (element.type() != Value::Type::NUMBER) {
-        print_argConvert_positioned_warning(function_name, "vector element " + STR(i), element, {Value::Type::NUMBER}, loc, arguments.documentRoot());
+        print_argConvert_positioned_warning(
+            function_name, "vector element " + STR(i), element,
+            {Value::Type::NUMBER}, loc, arguments.documentRoot());
         return {};
       }
       output.push_back(element.toDouble());
     }
   } else {
     for (size_t i = 0; i < arguments.size(); i++) {
-      const auto& argument = arguments[i];
+      const auto &argument = arguments[i];
       // 4/20/14 semantic change per discussion:
       // break on any non-number
       if (argument->type() != Value::Type::NUMBER) {
-        print_argConvert_positioned_warning(function_name, "argument " + STR(i), argument->clone(), {Value::Type::NUMBER}, loc, arguments.documentRoot());
+        print_argConvert_positioned_warning(
+            function_name, "argument " + STR(i), argument->clone(),
+            {Value::Type::NUMBER}, loc, arguments.documentRoot());
         return {};
       }
       output.push_back(argument->toDouble());
@@ -226,8 +253,7 @@ static std::vector<double> min_max_arguments(const Arguments& arguments, const L
   return output;
 }
 
-Value builtin_min(Arguments arguments, const Location& loc)
-{
+Value builtin_min(Arguments arguments, const Location &loc) {
   std::vector<double> values = min_max_arguments(arguments, loc, "min");
   if (values.empty()) {
     return Value::undefined.clone();
@@ -235,8 +261,7 @@ Value builtin_min(Arguments arguments, const Location& loc)
   return {*std::min_element(values.begin(), values.end())};
 }
 
-Value builtin_max(Arguments arguments, const Location& loc)
-{
+Value builtin_max(Arguments arguments, const Location &loc) {
   std::vector<double> values = min_max_arguments(arguments, loc, "max");
   if (values.empty()) {
     return Value::undefined.clone();
@@ -244,133 +269,122 @@ Value builtin_max(Arguments arguments, const Location& loc)
   return {*std::max_element(values.begin(), values.end())};
 }
 
-Value builtin_sin(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("sin", arguments, loc, { Value::Type::NUMBER })) {
+Value builtin_sin(Arguments arguments, const Location &loc) {
+  if (!check_arguments("sin", arguments, loc, {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {sin_degrees(arguments[0]->toDouble())};
 }
 
-Value builtin_cos(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("cos", arguments, loc, { Value::Type::NUMBER })) {
+Value builtin_cos(Arguments arguments, const Location &loc) {
+  if (!check_arguments("cos", arguments, loc, {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {cos_degrees(arguments[0]->toDouble())};
 }
 
-Value builtin_asin(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("asin", arguments, loc, { Value::Type::NUMBER })) {
+Value builtin_asin(Arguments arguments, const Location &loc) {
+  if (!check_arguments("asin", arguments, loc, {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {asin_degrees(arguments[0]->toDouble())};
 }
 
-Value builtin_acos(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("acos", arguments, loc, { Value::Type::NUMBER })) {
+Value builtin_acos(Arguments arguments, const Location &loc) {
+  if (!check_arguments("acos", arguments, loc, {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {acos_degrees(arguments[0]->toDouble())};
 }
 
-Value builtin_tan(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("tan", arguments, loc, { Value::Type::NUMBER })) {
+Value builtin_tan(Arguments arguments, const Location &loc) {
+  if (!check_arguments("tan", arguments, loc, {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {tan_degrees(arguments[0]->toDouble())};
 }
 
-Value builtin_atan(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("atan", arguments, loc, { Value::Type::NUMBER })) {
+Value builtin_atan(Arguments arguments, const Location &loc) {
+  if (!check_arguments("atan", arguments, loc, {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {atan_degrees(arguments[0]->toDouble())};
 }
 
-Value builtin_atan2(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("atan2", arguments, loc, { Value::Type::NUMBER, Value::Type::NUMBER })) {
+Value builtin_atan2(Arguments arguments, const Location &loc) {
+  if (!check_arguments("atan2", arguments, loc,
+                       {Value::Type::NUMBER, Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {atan2_degrees(arguments[0]->toDouble(), arguments[1]->toDouble())};
 }
 
-Value builtin_pow(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("pow", arguments, loc, { Value::Type::NUMBER, Value::Type::NUMBER })) {
+Value builtin_pow(Arguments arguments, const Location &loc) {
+  if (!check_arguments("pow", arguments, loc,
+                       {Value::Type::NUMBER, Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {pow(arguments[0]->toDouble(), arguments[1]->toDouble())};
 }
 
-Value builtin_round(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("round", arguments, loc, { Value::Type::NUMBER })) {
+Value builtin_round(Arguments arguments, const Location &loc) {
+  if (!check_arguments("round", arguments, loc, {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {round(arguments[0]->toDouble())};
 }
 
-Value builtin_ceil(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("ceil", arguments, loc, { Value::Type::NUMBER })) {
+Value builtin_ceil(Arguments arguments, const Location &loc) {
+  if (!check_arguments("ceil", arguments, loc, {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {ceil(arguments[0]->toDouble())};
 }
 
-Value builtin_floor(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("floor", arguments, loc, { Value::Type::NUMBER })) {
+Value builtin_floor(Arguments arguments, const Location &loc) {
+  if (!check_arguments("floor", arguments, loc, {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {floor(arguments[0]->toDouble())};
 }
 
-Value builtin_sqrt(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("sqrt", arguments, loc, { Value::Type::NUMBER })) {
+Value builtin_sqrt(Arguments arguments, const Location &loc) {
+  if (!check_arguments("sqrt", arguments, loc, {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {sqrt(arguments[0]->toDouble())};
 }
 
-Value builtin_exp(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("exp", arguments, loc, { Value::Type::NUMBER })) {
+Value builtin_exp(Arguments arguments, const Location &loc) {
+  if (!check_arguments("exp", arguments, loc, {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {exp(arguments[0]->toDouble())};
 }
 
-Value builtin_length(Arguments arguments, const Location& loc)
-{
-  if (try_check_arguments(arguments, { Value::Type::VECTOR })) {
+Value builtin_length(Arguments arguments, const Location &loc) {
+  if (try_check_arguments(arguments, {Value::Type::VECTOR})) {
     return {double(arguments[0]->toVector().size())};
   }
-  if (!check_arguments("len", arguments, loc, { Value::Type::STRING })) {
+  if (!check_arguments("len", arguments, loc, {Value::Type::STRING})) {
     return Value::undefined.clone();
   }
-  //Unicode glyph count for the length -- rather than the string (num. of bytes) length.
-  return {double( arguments[0]->toStrUtf8Wrapper().get_utf8_strlen() )};
+  // Unicode glyph count for the length -- rather than the string (num. of
+  // bytes) length.
+  return {double(arguments[0]->toStrUtf8Wrapper().get_utf8_strlen())};
 }
 
-Value builtin_log(Arguments arguments, const Location& loc)
-{
+Value builtin_log(Arguments arguments, const Location &loc) {
   double x, y;
   if (arguments.size() == 1) {
-    if (!check_arguments("log", arguments, loc, { Value::Type::NUMBER })) {
+    if (!check_arguments("log", arguments, loc, {Value::Type::NUMBER})) {
       return Value::undefined.clone();
     }
     x = 10.0;
     y = arguments[0]->toDouble();
   } else {
-    if (!check_arguments("log", arguments, loc, { Value::Type::NUMBER, Value::Type::NUMBER })) {
+    if (!check_arguments("log", arguments, loc,
+                         {Value::Type::NUMBER, Value::Type::NUMBER})) {
       return Value::undefined.clone();
     }
     x = arguments[0]->toDouble();
@@ -379,40 +393,37 @@ Value builtin_log(Arguments arguments, const Location& loc)
   return {log(y) / log(x)};
 }
 
-Value builtin_ln(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("ln", arguments, loc, { Value::Type::NUMBER })) {
+Value builtin_ln(Arguments arguments, const Location &loc) {
+  if (!check_arguments("ln", arguments, loc, {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   }
   return {log(arguments[0]->toDouble())};
 }
 
-Value builtin_str(Arguments arguments, const Location& /*loc*/)
-{
+Value builtin_str(Arguments arguments, const Location & /*loc*/) {
   std::ostringstream stream;
-  for (const auto& argument : arguments) {
+  for (const auto &argument : arguments) {
     stream << argument->toString();
   }
   return {stream.str()};
 }
 
-Value builtin_chr(Arguments arguments, const Location& /*loc*/)
-{
+Value builtin_chr(Arguments arguments, const Location & /*loc*/) {
   std::ostringstream stream;
-  for (const auto& argument : arguments) {
+  for (const auto &argument : arguments) {
     stream << argument->chrString();
   }
   return {stream.str()};
 }
 
-Value builtin_ord(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("ord", arguments, loc, { Value::Type::STRING })) {
+Value builtin_ord(Arguments arguments, const Location &loc) {
+  if (!check_arguments("ord", arguments, loc, {Value::Type::STRING})) {
     return Value::undefined.clone();
   }
-  const str_utf8_wrapper& arg_str = arguments[0]->toStrUtf8Wrapper();
+  const str_utf8_wrapper &arg_str = arguments[0]->toStrUtf8Wrapper();
   if (!arg_str.utf8_validate()) {
-    LOG(message_group::Warning, loc, arguments.documentRoot(), "ord() argument '%1$s' is not a valid utf8 string", arg_str.toString());
+    LOG(message_group::Warning, loc, arguments.documentRoot(),
+        "ord() argument '%1$s' is not a valid utf8 string", arg_str.toString());
     return Value::undefined.clone();
   }
 
@@ -423,13 +434,13 @@ Value builtin_ord(Arguments arguments, const Location& loc)
   return {(double)arg_str.get_utf8_char()};
 }
 
-Value builtin_concat(Arguments arguments, const Location& /*loc*/)
-{
+Value builtin_concat(Arguments arguments, const Location & /*loc*/) {
   VectorType result(arguments.session());
   result.reserve(arguments.size());
-  for (auto& argument : arguments) {
+  for (auto &argument : arguments) {
     if (argument->type() == Value::Type::VECTOR) {
-      result.emplace_back(EmbeddedVectorType(std::move(argument->toVectorNonConst())));
+      result.emplace_back(
+          EmbeddedVectorType(std::move(argument->toVectorNonConst())));
     } else {
       result.emplace_back(std::move(argument.value));
     }
@@ -437,50 +448,51 @@ Value builtin_concat(Arguments arguments, const Location& /*loc*/)
   return std::move(result);
 }
 
-#define OBJECT_HELP "In an unnamed list, entries must be [key,value] to set or [key] to delete. The key must be <string>."
+#define OBJECT_HELP                                                            \
+  "In an unnamed list, entries must be [key,value] to set or [key] to "        \
+  "delete. The key must be <string>."
 
-static std::string builtin_object_unnamed(ObjectType& result, const Value& value, int arg_index) {
+static std::string builtin_object_unnamed(ObjectType &result,
+                                          const Value &value, int arg_index) {
 
   std::string prior_args = "Argument " + std::to_string(arg_index) + " ";
 
-  switch (value.type()){
+  switch (value.type()) {
   case Value::Type::OBJECT: {
-    const auto& obj = value.toObject();
-    for (const auto& key : obj.keys()) {
+    const auto &obj = value.toObject();
+    for (const auto &key : obj.keys()) {
       result.set(key, obj.get(key).clone());
     }
     return "";
   }
   case Value::Type::VECTOR: {
 
-    const VectorType& vector = value.toVector();
+    const VectorType &vector = value.toVector();
     int element = 0;
-    for (const auto& member : vector) {
+    for (const auto &member : vector) {
       std::string prior_entries = "Element " + std::to_string(element++) + " ";
 
       if (member.type() != Value::Type::VECTOR) {
-        return str(boost::format(
-                     "object( %s[%s<%s>] ) Entry type is not a list, it is <%s>. " OBJECT_HELP)
-                   % prior_args.c_str()
-                   % prior_entries.c_str()
-                   % Value::typeName(member.type())
-                   % Value::typeName(member.type()));
+        return str(boost::format("object( %s[%s<%s>] ) Entry type is not a "
+                                 "list, it is <%s>. " OBJECT_HELP) %
+                   prior_args.c_str() % prior_entries.c_str() %
+                   Value::typeName(member.type()) %
+                   Value::typeName(member.type()));
       }
 
-      const auto& entry = member.toVector();
-      switch (entry.size()){
+      const auto &entry = member.toVector();
+      switch (entry.size()) {
       case 2:
       case 1: {
         if (entry[0].type() != Value::Type::STRING) {
           const char *es = entry.size() == 1 ? "" : ",value";
-          return str(boost::format("object(%s[%s[<%s>%s]]) The key of the entry is not <string> but <%s>. " OBJECT_HELP)
-                     % prior_args
-                     % prior_entries
-                     % Value::typeName(entry[0].type())
-                     % es
-                     % Value::typeName(entry[0].type()));
+          return str(
+              boost::format("object(%s[%s[<%s>%s]]) The key of the entry is "
+                            "not <string> but <%s>. " OBJECT_HELP) %
+              prior_args % prior_entries % Value::typeName(entry[0].type()) %
+              es % Value::typeName(entry[0].type()));
         }
-        const auto& key = entry[0].toString();
+        const auto &key = entry[0].toString();
         if (entry.size() == 1) {
           result.del(key);
         } else {
@@ -489,47 +501,50 @@ static std::string builtin_object_unnamed(ObjectType& result, const Value& value
         break;
       };
 
-      case 0: return str(boost::format("object(%s[%s[]]) Entry is empty. " OBJECT_HELP)
-                         % prior_args.c_str()
-                         % prior_entries.c_str());
+      case 0:
+        return str(
+            boost::format("object(%s[%s[]]) Entry is empty. " OBJECT_HELP) %
+            prior_args.c_str() % prior_entries.c_str());
 
-      default: return str(boost::format("object(%s[%s[...]]) Entry length is %d, must be 1 [key] or 2 [key,value]. " OBJECT_HELP)
-                          % prior_args
-                          % prior_entries
-                          % entry.size());
+      default:
+        return str(boost::format("object(%s[%s[...]]) Entry length is %d, must "
+                                 "be 1 [key] or 2 [key,value]. " OBJECT_HELP) %
+                   prior_args % prior_entries % entry.size());
       }
     }
     return "";
   }
   default:
-    return str(boost::format("object(%s<%s>) An unnamed argument must be either <object> or <list>, it is <%s>. ")
-               % prior_args
-               % Value::typeName(value.type())
-               % Value::typeName(value.type()));
+    return str(boost::format("object(%s<%s>) An unnamed argument must be "
+                             "either <object> or <list>, it is <%s>. ") %
+               prior_args % Value::typeName(value.type()) %
+               Value::typeName(value.type()));
   }
 }
 /**
     The builtin_object function takes either a named or unnamed argument.
-    A named argument is assigned with name=value to the result object. An unnamed
-    argument is either an object or a vector. An object will have its
+    A named argument is assigned with name=value to the result object. An
+   unnamed argument is either an object or a vector. An object will have its
     entries copied, potentially overwriting earlier entries. A vector
     must be of vectors. It can contain as member vectors:
 
         ["k"]       deletes key k
         ["k", v]    sets key k=v
 
-    Any other values are incorrect and will return undef and be logged as warning.
+    Any other values are incorrect and will return undef and be logged as
+   warning.
  */
-Value builtin_object(const std::shared_ptr<const Context>& context, const FunctionCall *call)
-{
+Value builtin_object(const std::shared_ptr<const Context> &context,
+                     const FunctionCall *call) {
   ObjectType result(context->session());
   int n = 0;
-  for (const auto& argument : call->arguments) {
+  for (const auto &argument : call->arguments) {
     Value value = argument->getExpr()->evaluate(context);
     if (argument->getName().empty()) {
       const auto error = builtin_object_unnamed(result, value, n);
       if (!error.empty()) {
-        LOG(message_group::Warning, call->location(), context->documentRoot(), error.c_str());
+        LOG(message_group::Warning, call->location(), context->documentRoot(),
+            error.c_str());
         return Value::undef(error);
       }
     } else {
@@ -540,29 +555,31 @@ Value builtin_object(const std::shared_ptr<const Context>& context, const Functi
   return result;
 }
 
-Value builtin_has_key(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("has_key", arguments, loc, { Value::Type::OBJECT, Value::Type::STRING })) {
+Value builtin_has_key(Arguments arguments, const Location &loc) {
+  if (!check_arguments("has_key", arguments, loc,
+                       {Value::Type::OBJECT, Value::Type::STRING})) {
     return Value::undefined.clone();
   }
-  const auto& obj = arguments[0]->toObject();
-  const auto& key = arguments[1]->toString();
+  const auto &obj = arguments[0]->toObject();
+  const auto &key = arguments[1]->toString();
   return obj.contains(key);
 }
 
-Value builtin_lookup(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("lookup", arguments, loc, { Value::Type::NUMBER, Value::Type::VECTOR })) {
+Value builtin_lookup(Arguments arguments, const Location &loc) {
+  if (!check_arguments("lookup", arguments, loc,
+                       {Value::Type::NUMBER, Value::Type::VECTOR})) {
     return Value::undefined.clone();
   }
   double p = arguments[0]->toDouble();
   if (!std::isfinite(p)) {
-    LOG(message_group::Warning, loc, arguments.documentRoot(), "lookup(%1$s, ...) first argument is not a number", arguments[0]->toEchoStringNoThrow());
+    LOG(message_group::Warning, loc, arguments.documentRoot(),
+        "lookup(%1$s, ...) first argument is not a number",
+        arguments[0]->toEchoStringNoThrow());
     return Value::undefined.clone();
   }
 
   double low_p, low_v, high_p, high_v;
-  const auto& vec = arguments[1]->toVector();
+  const auto &vec = arguments[1]->toVector();
 
   // Second must be a vector of vec2, with valid numbers inside
   auto it = vec.begin();
@@ -585,10 +602,12 @@ Value builtin_lookup(Arguments arguments, const Location& loc)
       }
     }
   }
-  if (p <= low_p) return {high_v};
-  if (p >= high_p) return {low_v};
+  if (p <= low_p)
+    return {high_v};
+  if (p >= high_p)
+    return {low_v};
   double f = (p - low_p) / (high_p - low_p);
-  return {high_v *f + low_v * (1 - f)};
+  return {high_v * f + low_v * (1 - f)};
 }
 
 /*
@@ -619,36 +638,43 @@ Value builtin_lookup(Arguments arguments, const Location& loc)
         - returns [0]
     search("e","abcdabcd",1);
         - returns []
-    search("a",[ ["a",1],["b",2],["c",3],["d",4],["a",5],["b",6],["c",7],["d",8],["e",9] ]);
+    search("a",[
+   ["a",1],["b",2],["c",3],["d",4],["a",5],["b",6],["c",7],["d",8],["e",9] ]);
         - returns [0,4]
 
    Search on different column; return Index values:
-    search(3,[ ["a",1],["b",2],["c",3],["d",4],["a",5],["b",6],["c",7],["d",8],["e",3] ], 0, 1);
+    search(3,[
+   ["a",1],["b",2],["c",3],["d",4],["a",5],["b",6],["c",7],["d",8],["e",3] ], 0,
+   1);
         - returns [0,8]
 
    Search on list of values:
     Return all matches per search vector element:
-      search("abc",[ ["a",1],["b",2],["c",3],["d",4],["a",5],["b",6],["c",7],["d",8],["e",9] ], 0);
+      search("abc",[
+   ["a",1],["b",2],["c",3],["d",4],["a",5],["b",6],["c",7],["d",8],["e",9] ],
+   0);
         - returns [[0,4],[1,5],[2,6]]
 
     Return first match per search vector element; special case return vector:
-      search("abc",[ ["a",1],["b",2],["c",3],["d",4],["a",5],["b",6],["c",7],["d",8],["e",9] ], 1);
+      search("abc",[
+   ["a",1],["b",2],["c",3],["d",4],["a",5],["b",6],["c",7],["d",8],["e",9] ],
+   1);
         - returns [0,1,2]
 
     Return first two matches per search vector element; vector of vectors:
-      search("abce",[ ["a",1],["b",2],["c",3],["d",4],["a",5],["b",6],["c",7],["d",8],["e",9] ], 2);
+      search("abce",[
+   ["a",1],["b",2],["c",3],["d",4],["a",5],["b",6],["c",7],["d",8],["e",9] ],
+   2);
         - returns [[0,4],[1,5],[2,6],[8]]
 
  */
 
-static VectorType search(
-  const str_utf8_wrapper& find,
-  const str_utf8_wrapper& table,
-  unsigned int num_returns_per_match,
-  EvaluationSession *session
-  ) {
+static VectorType search(const str_utf8_wrapper &find,
+                         const str_utf8_wrapper &table,
+                         unsigned int num_returns_per_match,
+                         EvaluationSession *session) {
   VectorType returnvec(session);
-  //Unicode glyph count for the length
+  // Unicode glyph count for the length
   size_t findThisSize = find.get_utf8_strlen();
   size_t searchTableSize = table.get_utf8_strlen();
   for (size_t i = 0; i < findThisSize; ++i) {
@@ -657,7 +683,8 @@ static VectorType search(
     const auto ft = find[i];
     for (size_t j = 0; j < searchTableSize; ++j) {
       const auto st = table[j];
-      if (!ft.empty() && !st.empty() && ft.get_utf8_char() == st.get_utf8_char()) {
+      if (!ft.empty() && !st.empty() &&
+          ft.get_utf8_char() == st.get_utf8_char()) {
         matchCount++;
         if (num_returns_per_match == 1) {
           returnvec.emplace_back(double(j));
@@ -677,16 +704,12 @@ static VectorType search(
   return returnvec;
 }
 
-static VectorType search(
-  const str_utf8_wrapper& find,
-  const VectorType& table,
-  unsigned int num_returns_per_match,
-  unsigned int index_col_num,
-  const Location& loc,
-  EvaluationSession *session
-  ) {
+static VectorType search(const str_utf8_wrapper &find, const VectorType &table,
+                         unsigned int num_returns_per_match,
+                         unsigned int index_col_num, const Location &loc,
+                         EvaluationSession *session) {
   VectorType returnvec(session);
-  //Unicode glyph count for the length
+  // Unicode glyph count for the length
   unsigned int findThisSize = find.get_utf8_strlen();
   unsigned int searchTableSize = table.size();
   for (size_t i = 0; i < findThisSize; ++i) {
@@ -694,12 +717,17 @@ static VectorType search(
     VectorType resultvec(session);
     const auto ft = find[i];
     for (size_t j = 0; j < searchTableSize; ++j) {
-      const auto& entryVec = table[j].toVector();
+      const auto &entryVec = table[j].toVector();
       if (entryVec.size() <= index_col_num) {
-        LOG(message_group::Warning, loc, session->documentRoot(), "Invalid entry in search vector at index %1$d, required number of values in the entry: %2$d. Invalid entry: %3$s", j, (index_col_num + 1), table[j].toEchoStringNoThrow());
+        LOG(message_group::Warning, loc, session->documentRoot(),
+            "Invalid entry in search vector at index %1$d, required number of "
+            "values in the entry: %2$d. Invalid entry: %3$s",
+            j, (index_col_num + 1), table[j].toEchoStringNoThrow());
         return {session};
       }
-      if (!ft.empty() && ft.get_utf8_char() == entryVec[index_col_num].toStrUtf8Wrapper().get_utf8_char()) {
+      if (!ft.empty() &&
+          ft.get_utf8_char() ==
+              entryVec[index_col_num].toStrUtf8Wrapper().get_utf8_char()) {
         matchCount++;
         if (num_returns_per_match == 1) {
           returnvec.emplace_back(double(j));
@@ -719,50 +747,58 @@ static VectorType search(
   return returnvec;
 }
 
-Value builtin_search(Arguments arguments, const Location& loc)
-{
+Value builtin_search(Arguments arguments, const Location &loc) {
   if (arguments.size() < 2 || arguments.size() > 4) {
-    print_argCnt_warning("search", arguments.size(), "between 2 and 4", loc, arguments.documentRoot());
+    print_argCnt_warning("search", arguments.size(), "between 2 and 4", loc,
+                         arguments.documentRoot());
     return Value::undefined.clone();
   }
 
-  const Value& findThis = arguments[0].value;
-  const Value& searchTable = arguments[1].value;
-  unsigned int num_returns_per_match = (arguments.size() > 2) ? (unsigned int)arguments[2]->toDouble() : 1;
-  unsigned int index_col_num = (arguments.size() > 3) ? (unsigned int)arguments[3]->toDouble() : 0;
+  const Value &findThis = arguments[0].value;
+  const Value &searchTable = arguments[1].value;
+  unsigned int num_returns_per_match =
+      (arguments.size() > 2) ? (unsigned int)arguments[2]->toDouble() : 1;
+  unsigned int index_col_num =
+      (arguments.size() > 3) ? (unsigned int)arguments[3]->toDouble() : 0;
 
   VectorType returnvec(arguments.session());
 
   if (findThis.type() == Value::Type::NUMBER) {
     unsigned int matchCount = 0;
     size_t j = 0;
-    for (const auto& search_element : searchTable.toVector()) {
+    for (const auto &search_element : searchTable.toVector()) {
       if ((index_col_num == 0 && (findThis == search_element).toBool()) ||
           (index_col_num < search_element.toVector().size() &&
            (findThis == search_element.toVector()[index_col_num]).toBool())) {
         returnvec.emplace_back(double(j));
         matchCount++;
-        if (num_returns_per_match != 0 && matchCount >= num_returns_per_match) break;
+        if (num_returns_per_match != 0 && matchCount >= num_returns_per_match)
+          break;
       }
       ++j;
     }
   } else if (findThis.type() == Value::Type::STRING) {
     if (searchTable.type() == Value::Type::STRING) {
-      returnvec = search(findThis.toStrUtf8Wrapper(), searchTable.toStrUtf8Wrapper(), num_returns_per_match, arguments.session());
+      returnvec =
+          search(findThis.toStrUtf8Wrapper(), searchTable.toStrUtf8Wrapper(),
+                 num_returns_per_match, arguments.session());
     } else {
-      returnvec = search(findThis.toStrUtf8Wrapper(), searchTable.toVector(), num_returns_per_match, index_col_num, loc, arguments.session());
+      returnvec = search(findThis.toStrUtf8Wrapper(), searchTable.toVector(),
+                         num_returns_per_match, index_col_num, loc,
+                         arguments.session());
     }
   } else if (findThis.type() == Value::Type::VECTOR) {
-    const auto& findVec = findThis.toVector();
-    for (const auto& find_value : findVec) {
+    const auto &findVec = findThis.toVector();
+    for (const auto &find_value : findVec) {
       unsigned int matchCount = 0;
       VectorType resultvec(arguments.session());
 
       size_t j = 0;
-      for (const auto& search_element : searchTable.toVector()) {
+      for (const auto &search_element : searchTable.toVector()) {
         if ((index_col_num == 0 && (find_value == search_element).toBool()) ||
             (index_col_num < search_element.toVector().size() &&
-             (find_value == search_element.toVector()[index_col_num]).toBool())) {
+             (find_value == search_element.toVector()[index_col_num])
+                 .toBool())) {
           matchCount++;
           if (num_returns_per_match == 1) {
             returnvec.emplace_back(double(j));
@@ -770,13 +806,13 @@ Value builtin_search(Arguments arguments, const Location& loc)
           } else {
             resultvec.emplace_back(double(j));
           }
-          if (num_returns_per_match > 1 && matchCount >= num_returns_per_match) break;
+          if (num_returns_per_match > 1 && matchCount >= num_returns_per_match)
+            break;
         }
         ++j;
       }
       if ((num_returns_per_match == 1 && matchCount == 0) ||
-          num_returns_per_match == 0 ||
-          num_returns_per_match > 1) {
+          num_returns_per_match == 0 || num_returns_per_match > 1) {
         returnvec.emplace_back(std::move(resultvec));
       }
     }
@@ -786,11 +822,10 @@ Value builtin_search(Arguments arguments, const Location& loc)
   return std::move(returnvec);
 }
 
-#define QUOTE(x__) # x__
+#define QUOTE(x__) #x__
 #define QUOTED(x__) QUOTE(x__)
 
-Value builtin_version(Arguments arguments, const Location& /*loc*/)
-{
+Value builtin_version(Arguments arguments, const Location & /*loc*/) {
   VectorType vec(arguments.session());
   vec.emplace_back(double(OPENSCAD_YEAR));
   vec.emplace_back(double(OPENSCAD_MONTH));
@@ -800,9 +835,10 @@ Value builtin_version(Arguments arguments, const Location& /*loc*/)
   return std::move(vec);
 }
 
-Value builtin_version_num(Arguments arguments, const Location& loc)
-{
-  Value val = (arguments.size() == 0) ? builtin_version(std::move(arguments), loc) : std::move(arguments[0].value);
+Value builtin_version_num(Arguments arguments, const Location &loc) {
+  Value val = (arguments.size() == 0)
+                  ? builtin_version(std::move(arguments), loc)
+                  : std::move(arguments[0].value);
   double y, m, d;
   if (!val.getVec3(y, m, d, 0)) {
     return Value::undefined.clone();
@@ -810,12 +846,12 @@ Value builtin_version_num(Arguments arguments, const Location& loc)
   return {y * 10000 + m * 100 + d};
 }
 
-Value builtin_parent_module(Arguments arguments, const Location& loc)
-{
+Value builtin_parent_module(Arguments arguments, const Location &loc) {
   double d;
   if (arguments.size() == 0) {
     d = 1;
-  } else if (!check_arguments("parent_module", arguments, loc, { Value::Type::NUMBER })) {
+  } else if (!check_arguments("parent_module", arguments, loc,
+                              {Value::Type::NUMBER})) {
     return Value::undefined.clone();
   } else {
     d = arguments[0]->toDouble();
@@ -824,81 +860,92 @@ Value builtin_parent_module(Arguments arguments, const Location& loc)
   int n = trunc(d);
   int s = UserModule::stack_size();
   if (n < 0) {
-    LOG(message_group::Warning, loc, arguments.documentRoot(), "Negative parent module index (%1$d) not allowed", n);
+    LOG(message_group::Warning, loc, arguments.documentRoot(),
+        "Negative parent module index (%1$d) not allowed", n);
     return Value::undefined.clone();
   }
   if (n >= s) {
-    LOG(message_group::Warning, loc, arguments.documentRoot(), "Parent module index (%1$d) greater than the number of modules on the stack", n);
+    LOG(message_group::Warning, loc, arguments.documentRoot(),
+        "Parent module index (%1$d) greater than the number of modules on the "
+        "stack",
+        n);
     return Value::undefined.clone();
   }
   return {UserModule::stack_element(s - 1 - n)};
 }
 
-Value builtin_norm(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("norm", arguments, loc, { Value::Type::VECTOR })) {
+Value builtin_norm(Arguments arguments, const Location &loc) {
+  if (!check_arguments("norm", arguments, loc, {Value::Type::VECTOR})) {
     return Value::undefined.clone();
   }
   double sum = 0;
-  for (const auto& v : arguments[0]->toVector()) {
+  for (const auto &v : arguments[0]->toVector()) {
     if (v.type() == Value::Type::NUMBER) {
       double x = v.toDouble();
       sum += x * x;
     } else {
-      LOG(message_group::Warning, loc, arguments.documentRoot(), "Incorrect arguments to norm()");
+      LOG(message_group::Warning, loc, arguments.documentRoot(),
+          "Incorrect arguments to norm()");
       return Value::undefined.clone();
     }
   }
   return {sqrt(sum)};
 }
 
-Value builtin_cross(Arguments arguments, const Location& loc)
-{
-  if (!check_arguments("cross", arguments, loc, { Value::Type::VECTOR, Value::Type::VECTOR })) {
+Value builtin_cross(Arguments arguments, const Location &loc) {
+  if (!check_arguments("cross", arguments, loc,
+                       {Value::Type::VECTOR, Value::Type::VECTOR})) {
     return Value::undefined.clone();
   }
 
-  const auto& v0 = arguments[0]->toVector();
-  const auto& v1 = arguments[1]->toVector();
+  const auto &v0 = arguments[0]->toVector();
+  const auto &v1 = arguments[1]->toVector();
   if ((v0.size() == 2) && (v1.size() == 2)) {
-    return {v0[0].toDouble() * v1[1].toDouble() - v0[1].toDouble() * v1[0].toDouble()};
+    return {v0[0].toDouble() * v1[1].toDouble() -
+            v0[1].toDouble() * v1[0].toDouble()};
   }
 
   if ((v0.size() != 3) || (v1.size() != 3)) {
-    LOG(message_group::Warning, loc, arguments.documentRoot(), "Invalid vector size of parameter for cross()");
+    LOG(message_group::Warning, loc, arguments.documentRoot(),
+        "Invalid vector size of parameter for cross()");
     return Value::undefined.clone();
   }
   for (unsigned int a = 0; a < 3; ++a) {
-    if ((v0[a].type() != Value::Type::NUMBER) || (v1[a].type() != Value::Type::NUMBER)) {
-      LOG(message_group::Warning, loc, arguments.documentRoot(), "Invalid value in parameter vector for cross()");
+    if ((v0[a].type() != Value::Type::NUMBER) ||
+        (v1[a].type() != Value::Type::NUMBER)) {
+      LOG(message_group::Warning, loc, arguments.documentRoot(),
+          "Invalid value in parameter vector for cross()");
       return Value::undefined.clone();
     }
     double d0 = v0[a].toDouble();
     double d1 = v1[a].toDouble();
     if (std::isnan(d0) || std::isnan(d1)) {
-      LOG(message_group::Warning, loc, arguments.documentRoot(), "Invalid value (NaN) in parameter vector for cross()");
+      LOG(message_group::Warning, loc, arguments.documentRoot(),
+          "Invalid value (NaN) in parameter vector for cross()");
       return Value::undefined.clone();
     }
     if (std::isinf(d0) || std::isinf(d1)) {
-      LOG(message_group::Warning, loc, arguments.documentRoot(), "Invalid value (INF) in parameter vector for cross()");
+      LOG(message_group::Warning, loc, arguments.documentRoot(),
+          "Invalid value (INF) in parameter vector for cross()");
       return Value::undefined.clone();
     }
   }
 
-  double x = v0[1].toDouble() * v1[2].toDouble() - v0[2].toDouble() * v1[1].toDouble();
-  double y = v0[2].toDouble() * v1[0].toDouble() - v0[0].toDouble() * v1[2].toDouble();
-  double z = v0[0].toDouble() * v1[1].toDouble() - v0[1].toDouble() * v1[0].toDouble();
+  double x =
+      v0[1].toDouble() * v1[2].toDouble() - v0[2].toDouble() * v1[1].toDouble();
+  double y =
+      v0[2].toDouble() * v1[0].toDouble() - v0[0].toDouble() * v1[2].toDouble();
+  double z =
+      v0[0].toDouble() * v1[1].toDouble() - v0[1].toDouble() * v1[0].toDouble();
 
   return VectorType(arguments.session(), x, y, z);
 }
 
-Value builtin_textmetrics(Arguments arguments, const Location& loc)
-{
+Value builtin_textmetrics(Arguments arguments, const Location &loc) {
   auto *session = arguments.session();
-  Parameters parameters = Parameters::parse(std::move(arguments), loc,
-                                            { "text", "size", "font" },
-                                            { "direction", "language", "script", "halign", "valign", "spacing" }
-                                            );
+  Parameters parameters = Parameters::parse(
+      std::move(arguments), loc, {"text", "size", "font"},
+      {"direction", "language", "script", "halign", "valign", "spacing"});
   parameters.set_caller("textmetrics");
 
   FreetypeRenderer::Params ftparams;
@@ -946,12 +993,10 @@ Value builtin_textmetrics(Arguments arguments, const Location& loc)
   return std::move(text_metrics);
 }
 
-Value builtin_fontmetrics(Arguments arguments, const Location& loc)
-{
+Value builtin_fontmetrics(Arguments arguments, const Location &loc) {
   auto *session = arguments.session();
-  Parameters parameters = Parameters::parse(std::move(arguments), loc,
-                                            { "size", "font" }
-                                            );
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), loc, {"size", "font"});
   parameters.set_caller("fontmetrics");
 
   FreetypeRenderer::Params ftparams;
@@ -986,13 +1031,15 @@ Value builtin_fontmetrics(Arguments arguments, const Location& loc)
   return std::move(font_metrics);
 }
 
-Value builtin_is_undef(const std::shared_ptr<const Context>& context, const FunctionCall *call)
-{
+Value builtin_is_undef(const std::shared_ptr<const Context> &context,
+                       const FunctionCall *call) {
   if (call->arguments.size() != 1) {
-    print_argCnt_warning("is_undef", call->arguments.size(), "1", call->location(), context->documentRoot());
+    print_argCnt_warning("is_undef", call->arguments.size(), "1",
+                         call->location(), context->documentRoot());
     return Value::undefined.clone();
   }
-  if (auto lookup = std::dynamic_pointer_cast<Lookup>(call->arguments[0]->getExpr())) {
+  if (auto lookup =
+          std::dynamic_pointer_cast<Lookup>(call->arguments[0]->getExpr())) {
     auto result = context->try_lookup_variable(lookup->get_name());
     return !result || result->isUndefined();
   } else {
@@ -1000,293 +1047,302 @@ Value builtin_is_undef(const std::shared_ptr<const Context>& context, const Func
   }
 }
 
-Value builtin_is_list(Arguments arguments, const Location& loc)
-{
+Value builtin_is_list(Arguments arguments, const Location &loc) {
   if (!check_arguments("is_list", arguments, loc, 1)) {
     return Value::undefined.clone();
   }
   return {arguments[0]->isDefinedAs(Value::Type::VECTOR)};
 }
 
-Value builtin_is_num(Arguments arguments, const Location& loc)
-{
+Value builtin_is_num(Arguments arguments, const Location &loc) {
   if (!check_arguments("is_num", arguments, loc, 1)) {
     return Value::undefined.clone();
   }
-  return {arguments[0]->isDefinedAs(Value::Type::NUMBER) && !std::isnan(arguments[0]->toDouble())};
+  return {arguments[0]->isDefinedAs(Value::Type::NUMBER) &&
+          !std::isnan(arguments[0]->toDouble())};
 }
 
-Value builtin_is_bool(Arguments arguments, const Location& loc)
-{
+Value builtin_is_bool(Arguments arguments, const Location &loc) {
   if (!check_arguments("is_bool", arguments, loc, 1)) {
     return Value::undefined.clone();
   }
   return {arguments[0]->isDefinedAs(Value::Type::BOOL)};
 }
 
-Value builtin_is_string(Arguments arguments, const Location& loc)
-{
+Value builtin_is_string(Arguments arguments, const Location &loc) {
   if (!check_arguments("is_string", arguments, loc, 1)) {
     return Value::undefined.clone();
   }
   return {arguments[0]->isDefinedAs(Value::Type::STRING)};
 }
 
-Value builtin_is_function(Arguments arguments, const Location& loc)
-{
+Value builtin_is_function(Arguments arguments, const Location &loc) {
   if (!check_arguments("is_function", arguments, loc, 1)) {
     return Value::undefined.clone();
   }
   return {arguments[0]->isDefinedAs(Value::Type::FUNCTION)};
 }
 
-Value builtin_is_object(Arguments arguments, const Location& loc)
-{
+Value builtin_is_object(Arguments arguments, const Location &loc) {
   if (!check_arguments("is_object", arguments, loc, 1)) {
     return Value::undefined.clone();
   }
   return {arguments[0]->isDefinedAs(Value::Type::OBJECT)};
 }
 
-Value builtin_import(Arguments arguments, const Location& loc)
-{
+Value builtin_import(Arguments arguments, const Location &loc) {
   auto session = arguments.session();
-  const Parameters parameters = Parameters::parse(std::move(arguments), loc, {}, {"file"});
+  const Parameters parameters =
+      Parameters::parse(std::move(arguments), loc, {}, {"file"});
   std::string raw_filename = parameters.get("file", "");
-  std::string file = lookup_file(raw_filename, loc.filePath().parent_path().string(), parameters.documentRoot());
+  std::string file =
+      lookup_file(raw_filename, loc.filePath().parent_path().string(),
+                  parameters.documentRoot());
   return import_json(file, session, loc);
 }
 
-void register_builtin_functions()
-{
+void register_builtin_functions() {
   Builtins::init("abs", new BuiltinFunction(&builtin_abs),
-  {
-    "abs(number) -> number",
-  });
+                 {
+                     "abs(number) -> number",
+                 });
 
   Builtins::init("sign", new BuiltinFunction(&builtin_sign),
-  {
-    "sign(number) -> -1, 0 or 1",
-  });
+                 {
+                     "sign(number) -> -1, 0 or 1",
+                 });
 
   Builtins::init("rands", new BuiltinFunction(&builtin_rands),
-  {
-    "rands(min, max, num_results) -> vector",
-    "rands(min, max, num_results, seed) -> vector",
-  });
+                 {
+                     "rands(min, max, num_results) -> vector",
+                     "rands(min, max, num_results, seed) -> vector",
+                 });
 
   Builtins::init("min", new BuiltinFunction(&builtin_min),
-  {
-    "min(number, number, ...) -> number",
-    "min(vector) -> number",
-  });
+                 {
+                     "min(number, number, ...) -> number",
+                     "min(vector) -> number",
+                 });
 
   Builtins::init("max", new BuiltinFunction(&builtin_max),
-  {
-    "max(number, number, ...) -> number",
-    "max(vector) -> number",
-  });
+                 {
+                     "max(number, number, ...) -> number",
+                     "max(vector) -> number",
+                 });
 
   Builtins::init("sin", new BuiltinFunction(&builtin_sin),
-  {
-    "sin(degrees) -> number",
-  });
+                 {
+                     "sin(degrees) -> number",
+                 });
 
   Builtins::init("cos", new BuiltinFunction(&builtin_cos),
-  {
-    "cos(degrees) -> number",
-  });
+                 {
+                     "cos(degrees) -> number",
+                 });
 
   Builtins::init("asin", new BuiltinFunction(&builtin_asin),
-  {
-    "asin(number) -> degrees",
-  });
+                 {
+                     "asin(number) -> degrees",
+                 });
 
   Builtins::init("acos", new BuiltinFunction(&builtin_acos),
-  {
-    "acos(number) -> degrees",
-  });
+                 {
+                     "acos(number) -> degrees",
+                 });
 
   Builtins::init("tan", new BuiltinFunction(&builtin_tan),
-  {
-    "tan(degrees) -> number",
-  });
+                 {
+                     "tan(degrees) -> number",
+                 });
 
   Builtins::init("atan", new BuiltinFunction(&builtin_atan),
-  {
-    "atan(number) -> degrees",
-  });
+                 {
+                     "atan(number) -> degrees",
+                 });
 
   Builtins::init("atan2", new BuiltinFunction(&builtin_atan2),
-  {
-    "atan2(number, number) -> degrees",
-  });
+                 {
+                     "atan2(number, number) -> degrees",
+                 });
 
   Builtins::init("round", new BuiltinFunction(&builtin_round),
-  {
-    "round(number) -> number",
-  });
+                 {
+                     "round(number) -> number",
+                 });
 
   Builtins::init("ceil", new BuiltinFunction(&builtin_ceil),
-  {
-    "ceil(number) -> number",
-  });
+                 {
+                     "ceil(number) -> number",
+                 });
 
   Builtins::init("floor", new BuiltinFunction(&builtin_floor),
-  {
-    "floor(number) -> number",
-  });
+                 {
+                     "floor(number) -> number",
+                 });
 
   Builtins::init("pow", new BuiltinFunction(&builtin_pow),
-  {
-    "pow(base, exponent) -> number",
-  });
+                 {
+                     "pow(base, exponent) -> number",
+                 });
 
   Builtins::init("sqrt", new BuiltinFunction(&builtin_sqrt),
-  {
-    "sqrt(number) -> number",
-  });
+                 {
+                     "sqrt(number) -> number",
+                 });
 
   Builtins::init("exp", new BuiltinFunction(&builtin_exp),
-  {
-    "exp(number) -> number",
-  });
+                 {
+                     "exp(number) -> number",
+                 });
 
   Builtins::init("len", new BuiltinFunction(&builtin_length),
-  {
-    "len(string) -> number",
-    "len(vector) -> number",
-  });
+                 {
+                     "len(string) -> number",
+                     "len(vector) -> number",
+                 });
 
   Builtins::init("log", new BuiltinFunction(&builtin_log),
-  {
-    "log(number) -> number",
-  });
+                 {
+                     "log(number) -> number",
+                 });
 
   Builtins::init("ln", new BuiltinFunction(&builtin_ln),
-  {
-    "ln(number) -> number",
-  });
+                 {
+                     "ln(number) -> number",
+                 });
 
   Builtins::init("str", new BuiltinFunction(&builtin_str),
-  {
-    "str(number or string, ...) -> string",
-  });
+                 {
+                     "str(number or string, ...) -> string",
+                 });
 
   Builtins::init("chr", new BuiltinFunction(&builtin_chr),
-  {
-    "chr(number) -> string",
-    "chr(vector) -> string",
-    "chr(range) -> string",
-  });
-
-  Builtins::init("textmetrics",
-                 new BuiltinFunction(&builtin_textmetrics,
-                                     &Feature::ExperimentalTextMetricsFunctions),
-  {
-    "textmetrics(text, size, font, direction, language, script, halign, valign, spacing) -> object",
-  });
-
-  Builtins::init("fontmetrics",
-                 new BuiltinFunction(&builtin_fontmetrics,
-                                     &Feature::ExperimentalTextMetricsFunctions),
-  {
-    "fontmetrics(size, font) -> object",
-  });
+                 {
+                     "chr(number) -> string",
+                     "chr(vector) -> string",
+                     "chr(range) -> string",
+                 });
+
+  Builtins::init(
+      "textmetrics",
+      new BuiltinFunction(&builtin_textmetrics,
+                          &Feature::ExperimentalTextMetricsFunctions),
+      {
+          "textmetrics(text, size, font, direction, language, script, halign, "
+          "valign, spacing) -> object",
+      });
+
+  Builtins::init(
+      "fontmetrics",
+      new BuiltinFunction(&builtin_fontmetrics,
+                          &Feature::ExperimentalTextMetricsFunctions),
+      {
+          "fontmetrics(size, font) -> object",
+      });
 
   Builtins::init("ord", new BuiltinFunction(&builtin_ord),
-  {
-    "ord(string) -> number",
-  });
+                 {
+                     "ord(string) -> number",
+                 });
 
   Builtins::init("concat", new BuiltinFunction(&builtin_concat),
-  {
-    "concat(number or string or vector, ...) -> vector",
-  });
+                 {
+                     "concat(number or string or vector, ...) -> vector",
+                 });
 
   Builtins::init("lookup", new BuiltinFunction(&builtin_lookup),
-  {
-    "lookup(key, <key,value> vector) -> value",
-  });
+                 {
+                     "lookup(key, <key,value> vector) -> value",
+                 });
 
   Builtins::init("search", new BuiltinFunction(&builtin_search),
-  {
-    "search(string , string or vector [, num_returns_per_match [, index_col_num ] ] ) -> vector",
-  });
+                 {
+                     "search(string , string or vector [, "
+                     "num_returns_per_match [, index_col_num ] ] ) -> vector",
+                 });
 
   Builtins::init("version", new BuiltinFunction(&builtin_version),
-  {
-    "version() -> vector",
-  });
+                 {
+                     "version() -> vector",
+                 });
 
   Builtins::init("version_num", new BuiltinFunction(&builtin_version_num),
-  {
-    "version_num() -> number",
-  });
+                 {
+                     "version_num() -> number",
+                 });
 
   Builtins::init("norm", new BuiltinFunction(&builtin_norm),
-  {
-    "norm(vector) -> number",
-  });
+                 {
+                     "norm(vector) -> number",
+                 });
 
   Builtins::init("cross", new BuiltinFunction(&builtin_cross),
-  {
-    "cross(vector, vector) -> vector",
-  });
+                 {
+                     "cross(vector, vector) -> vector",
+                 });
 
   Builtins::init("parent_module", new BuiltinFunction(&builtin_parent_module),
-  {
-    "parent_module(number) -> string",
-  });
+                 {
+                     "parent_module(number) -> string",
+                 });
 
   Builtins::init("is_undef", new BuiltinFunction(&builtin_is_undef),
-  {
-    "is_undef(arg) -> boolean",
-  });
+                 {
+                     "is_undef(arg) -> boolean",
+                 });
 
   Builtins::init("is_list", new BuiltinFunction(&builtin_is_list),
-  {
-    "is_list(arg) -> boolean",
-  });
+                 {
+                     "is_list(arg) -> boolean",
+                 });
 
   Builtins::init("is_num", new BuiltinFunction(&builtin_is_num),
-  {
-    "is_num(arg) -> boolean",
-  });
+                 {
+                     "is_num(arg) -> boolean",
+                 });
 
   Builtins::init("is_bool", new BuiltinFunction(&builtin_is_bool),
-  {
-    "is_bool(arg) -> boolean",
-  });
+                 {
+                     "is_bool(arg) -> boolean",
+                 });
 
   Builtins::init("is_string", new BuiltinFunction(&builtin_is_string),
-  {
-    "is_string(arg) -> boolean",
-  });
+                 {
+                     "is_string(arg) -> boolean",
+                 });
 
   Builtins::init("is_function", new BuiltinFunction(&builtin_is_function),
-  {
-    "is_function(arg) -> boolean",
-  });
-
-  Builtins::init("is_object", new BuiltinFunction(&builtin_is_object,
-                                                  &Feature::ExperimentalTextMetricsFunctions),
-  {
-    "is_object(arg) -> boolean",
-  });
-
-  Builtins::init("object", new BuiltinFunction(&builtin_object, &Feature::ExperimentalObjectFunction),
-  {
-    "object([ object, ] [ key-val list, ] key=value, ...) -> object",
-  });
-
-  Builtins::init("has_key", new BuiltinFunction(&builtin_has_key, &Feature::ExperimentalObjectFunction),
-  {
-    "has_key(object, key) -> boolean",
-  });
-
-  Builtins::init("import", new BuiltinFunction(&builtin_import, &Feature::ExperimentalImportFunction),
-  {
-    "import(file) -> object",
-  });
+                 {
+                     "is_function(arg) -> boolean",
+                 });
+
+  Builtins::init(
+      "is_object",
+      new BuiltinFunction(&builtin_is_object,
+                          &Feature::ExperimentalTextMetricsFunctions),
+      {
+          "is_object(arg) -> boolean",
+      });
+
+  Builtins::init(
+      "object",
+      new BuiltinFunction(&builtin_object,
+                          &Feature::ExperimentalObjectFunction),
+      {
+          "object([ object, ] [ key-val list, ] key=value, ...) -> object",
+      });
+
+  Builtins::init("has_key",
+                 new BuiltinFunction(&builtin_has_key,
+                                     &Feature::ExperimentalObjectFunction),
+                 {
+                     "has_key(object, key) -> boolean",
+                 });
+
+  Builtins::init("import",
+                 new BuiltinFunction(&builtin_import,
+                                     &Feature::ExperimentalImportFunction),
+                 {
+                     "import(file) -> object",
+                 });
 }
diff --git a/src/core/control.cc b/src/core/control.cc
index 2598f886f..7538ccd77 100644
--- a/src/core/control.cc
+++ b/src/core/control.cc
@@ -24,24 +24,24 @@
  *
  */
 
-#include <utility>
-#include <memory>
 #include <cstddef>
+#include <memory>
+#include <utility>
 #include <vector>
 
-#include "core/module.h"
-#include "core/ModuleInstantiation.h"
-#include "core/node.h"
 #include "core/Arguments.h"
+#include "core/Builtins.h"
 #include "core/Children.h"
 #include "core/Expression.h"
-#include "core/Builtins.h"
+#include "core/ModuleInstantiation.h"
 #include "core/Parameters.h"
+#include "core/module.h"
+#include "core/node.h"
 #include "utils/printutils.h"
 #include <cstdint>
 
-static std::shared_ptr<AbstractNode> lazyUnionNode(const ModuleInstantiation *inst)
-{
+static std::shared_ptr<AbstractNode>
+lazyUnionNode(const ModuleInstantiation *inst) {
   if (Feature::ExperimentalLazyUnion.is_enabled()) {
     return std::make_shared<ListNode>(inst);
   } else {
@@ -49,33 +49,47 @@ static std::shared_ptr<AbstractNode> lazyUnionNode(const ModuleInstantiation *in
   }
 }
 
-static boost::optional<size_t> validChildIndex(int n, const Children *children, const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
+static boost::optional<size_t>
+validChildIndex(int n, const Children *children,
+                const ModuleInstantiation *inst,
+                const std::shared_ptr<const Context> &context) {
   if (n < 0 || n >= static_cast<int>(children->size())) {
-    LOG(message_group::Warning, inst->location(), context->documentRoot(), "Children index (%1$d) out of bounds (%2$d children)", n, children->size());
+    LOG(message_group::Warning, inst->location(), context->documentRoot(),
+        "Children index (%1$d) out of bounds (%2$d children)", n,
+        children->size());
     return boost::none;
   }
   return size_t(n);
 }
 
-static boost::optional<size_t> validChildIndex(const Value& value, const Children *children, const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
+static boost::optional<size_t>
+validChildIndex(const Value &value, const Children *children,
+                const ModuleInstantiation *inst,
+                const std::shared_ptr<const Context> &context) {
   if (value.type() != Value::Type::NUMBER) {
-    LOG(message_group::Warning, inst->location(), context->documentRoot(), "Bad parameter type (%1$s) for children, only accept: empty, number, vector, range.", value.toString());
+    LOG(message_group::Warning, inst->location(), context->documentRoot(),
+        "Bad parameter type (%1$s) for children, only accept: empty, number, "
+        "vector, range.",
+        value.toString());
     return boost::none;
   }
-  return validChildIndex(static_cast<int>(value.toDouble()), children, inst, context);
+  return validChildIndex(static_cast<int>(value.toDouble()), children, inst,
+                         context);
 }
 
-static std::shared_ptr<AbstractNode> builtin_child(const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
-  LOG(message_group::Deprecated, "child() will be removed in future releases. Use children() instead.");
+static std::shared_ptr<AbstractNode>
+builtin_child(const ModuleInstantiation *inst,
+              const std::shared_ptr<const Context> &context) {
+  LOG(message_group::Deprecated,
+      "child() will be removed in future releases. Use children() instead.");
 
   Arguments arguments{inst->arguments, context};
 
   BuiltinModule::noChildren(inst, arguments);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {}, std::vector<std::string>{"index"});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {},
+                        std::vector<std::string>{"index"});
   const Children *children = context->user_module_children();
   if (!children) {
     // child() called outside any user module
@@ -94,13 +108,16 @@ static std::shared_ptr<AbstractNode> builtin_child(const ModuleInstantiation *in
   return children->instantiate(lazyUnionNode(inst), {*index});
 }
 
-static std::shared_ptr<AbstractNode> builtin_children(const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
+static std::shared_ptr<AbstractNode>
+builtin_children(const ModuleInstantiation *inst,
+                 const std::shared_ptr<const Context> &context) {
   Arguments arguments{inst->arguments, context};
 
   BuiltinModule::noChildren(inst, arguments);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {}, std::vector<std::string>{"index"});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {},
+                        std::vector<std::string>{"index"});
   const Children *children = context->user_module_children();
   if (!children) {
     // children() called outside any user module
@@ -121,7 +138,7 @@ static std::shared_ptr<AbstractNode> builtin_children(const ModuleInstantiation
     return children->instantiate(lazyUnionNode(inst), {*index});
   } else if (parameters["index"].type() == Value::Type::VECTOR) {
     std::vector<size_t> indices;
-    for (const auto& val : parameters["index"].toVector()) {
+    for (const auto &val : parameters["index"].toVector()) {
       auto index = validChildIndex(val, children, inst, context);
       if (index) {
         indices.push_back(*index);
@@ -129,7 +146,7 @@ static std::shared_ptr<AbstractNode> builtin_children(const ModuleInstantiation
     }
     return children->instantiate(lazyUnionNode(inst), indices);
   } else if (parameters["index"].type() == Value::Type::RANGE) {
-    const RangeType& range = parameters["index"].toRange();
+    const RangeType &range = parameters["index"].toRange();
     uint32_t steps = range.numValues();
     if (steps >= RangeType::MAX_RANGE_STEPS) {
       LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
@@ -138,7 +155,8 @@ static std::shared_ptr<AbstractNode> builtin_children(const ModuleInstantiation
     }
     std::vector<size_t> indices;
     for (double d : range) {
-      auto index = validChildIndex(static_cast<int>(d), children, inst, context);
+      auto index =
+          validChildIndex(static_cast<int>(d), children, inst, context);
       if (index) {
         indices.push_back(*index);
       }
@@ -146,13 +164,17 @@ static std::shared_ptr<AbstractNode> builtin_children(const ModuleInstantiation
     return children->instantiate(lazyUnionNode(inst), indices);
   } else {
     // Invalid argument
-    LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Bad parameter type (%1$s) for children, only accept: empty, number, vector, range", parameters["index"].toEchoStringNoThrow());
+    LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+        "Bad parameter type (%1$s) for children, only accept: empty, number, "
+        "vector, range",
+        parameters["index"].toEchoStringNoThrow());
     return {};
   }
 }
 
-static std::shared_ptr<AbstractNode> builtin_echo(const ModuleInstantiation *inst, Arguments arguments, const Children& children)
-{
+static std::shared_ptr<AbstractNode>
+builtin_echo(const ModuleInstantiation *inst, Arguments arguments,
+             const Children &children) {
   LOG(message_group::Echo, "%1$s", STR(arguments));
 
   auto node = children.instantiate(lazyUnionNode(inst));
@@ -163,8 +185,9 @@ static std::shared_ptr<AbstractNode> builtin_echo(const ModuleInstantiation *ins
   return node;
 }
 
-static std::shared_ptr<AbstractNode> builtin_assert(const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
+static std::shared_ptr<AbstractNode>
+builtin_assert(const ModuleInstantiation *inst,
+               const std::shared_ptr<const Context> &context) {
   Assert::performAssert(inst->arguments, inst->location(), context);
 
   auto node = Children(&inst->scope, context).instantiate(lazyUnionNode(inst));
@@ -175,118 +198,133 @@ static std::shared_ptr<AbstractNode> builtin_assert(const ModuleInstantiation *i
   return node;
 }
 
-static std::shared_ptr<AbstractNode> builtin_let(const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
-  return Children(&inst->scope, *Let::sequentialAssignmentContext(inst->arguments, inst->location(), context)).instantiate(lazyUnionNode(inst));
+static std::shared_ptr<AbstractNode>
+builtin_let(const ModuleInstantiation *inst,
+            const std::shared_ptr<const Context> &context) {
+  return Children(&inst->scope, *Let::sequentialAssignmentContext(
+                                    inst->arguments, inst->location(), context))
+      .instantiate(lazyUnionNode(inst));
 }
 
-static std::shared_ptr<AbstractNode> builtin_assign(const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
+static std::shared_ptr<AbstractNode>
+builtin_assign(const ModuleInstantiation *inst,
+               const std::shared_ptr<const Context> &context) {
   // We create a new context to avoid arguments from influencing each other
   // -> parallel evaluation. This is to be backwards compatible.
   Arguments arguments{inst->arguments, context};
   ContextHandle<Context> assignContext{Context::create<Context>(context)};
-  for (auto& argument : arguments) {
+  for (auto &argument : arguments) {
     if (!argument.name) {
-      LOG(message_group::Warning, inst->location(), context->documentRoot(), "Assignment without variable name %1$s", argument->toEchoStringNoThrow());
+      LOG(message_group::Warning, inst->location(), context->documentRoot(),
+          "Assignment without variable name %1$s",
+          argument->toEchoStringNoThrow());
     } else {
       if (assignContext->lookup_local_variable(*argument.name)) {
-        // TODO Should maybe quote the entire assignment with a new quoteExpr() or quoteStmt().
-        LOG(message_group::Warning, inst->location(), context->documentRoot(), "Duplicate variable assignment %1$s = %2$s", quoteVar(*argument.name), argument->toEchoStringNoThrow());
+        // TODO Should maybe quote the entire assignment with a new quoteExpr()
+        // or quoteStmt().
+        LOG(message_group::Warning, inst->location(), context->documentRoot(),
+            "Duplicate variable assignment %1$s = %2$s",
+            quoteVar(*argument.name), argument->toEchoStringNoThrow());
       }
       assignContext->set_variable(*argument.name, std::move(argument.value));
     }
   }
 
-  return Children(&inst->scope, *assignContext).instantiate(lazyUnionNode(inst));
+  return Children(&inst->scope, *assignContext)
+      .instantiate(lazyUnionNode(inst));
 }
 
-static std::shared_ptr<AbstractNode> builtin_for(const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
+static std::shared_ptr<AbstractNode>
+builtin_for(const ModuleInstantiation *inst,
+            const std::shared_ptr<const Context> &context) {
   auto node = lazyUnionNode(inst);
   if (!inst->arguments.empty()) {
-    LcFor::forEach(inst->arguments, inst->location(), context,
-                   [inst, node] (const std::shared_ptr<const Context>& iterationContext) {
-      Children(&inst->scope, iterationContext).instantiate(node);
-    }
-                   );
+    LcFor::forEach(
+        inst->arguments, inst->location(), context,
+        [inst, node](const std::shared_ptr<const Context> &iterationContext) {
+          Children(&inst->scope, iterationContext).instantiate(node);
+        });
   }
   return node;
 }
 
-static std::shared_ptr<AbstractNode> builtin_intersection_for(const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
+static std::shared_ptr<AbstractNode>
+builtin_intersection_for(const ModuleInstantiation *inst,
+                         const std::shared_ptr<const Context> &context) {
   auto node = std::make_shared<AbstractIntersectionNode>(inst);
   if (!inst->arguments.empty()) {
-    LcFor::forEach(inst->arguments, inst->location(), context,
-                   [inst, node] (const std::shared_ptr<const Context>& iterationContext) {
-      Children(&inst->scope, iterationContext).instantiate(node);
-    }
-                   );
+    LcFor::forEach(
+        inst->arguments, inst->location(), context,
+        [inst, node](const std::shared_ptr<const Context> &iterationContext) {
+          Children(&inst->scope, iterationContext).instantiate(node);
+        });
   }
   return node;
 }
 
-static std::shared_ptr<AbstractNode> builtin_if(const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context)
-{
+static std::shared_ptr<AbstractNode>
+builtin_if(const ModuleInstantiation *inst,
+           const std::shared_ptr<const Context> &context) {
   Arguments arguments{inst->arguments, context};
   const auto *ifelse = dynamic_cast<const IfElseModuleInstantiation *>(inst);
   if (arguments.size() > 0 && arguments[0]->toBool()) {
     return Children(&inst->scope, context).instantiate(lazyUnionNode(inst));
   } else if (ifelse->getElseScope()) {
-    return Children(ifelse->getElseScope(), context).instantiate(lazyUnionNode(inst));
+    return Children(ifelse->getElseScope(), context)
+        .instantiate(lazyUnionNode(inst));
   } else {
-    // "if" with failed condition, and no "else" should not count as valid CSGNode
+    // "if" with failed condition, and no "else" should not count as valid
+    // CSGNode
     return nullptr;
   }
 }
 
-void register_builtin_control()
-{
+void register_builtin_control() {
   Builtins::init("assign", new BuiltinModule(builtin_assign));
   Builtins::init("child", new BuiltinModule(builtin_child));
 
   Builtins::init("children", new BuiltinModule(builtin_children),
-  {
-    "children()",
-    "children(number)",
-    "children([start : step : end])",
-    "children([start : end])",
-    "children([vector])",
-  });
+                 {
+                     "children()",
+                     "children(number)",
+                     "children([start : step : end])",
+                     "children([start : end])",
+                     "children([vector])",
+                 });
 
   Builtins::init("echo", new BuiltinModule(builtin_echo),
-  {
-    "echo(arg, ...)",
-  });
+                 {
+                     "echo(arg, ...)",
+                 });
 
   Builtins::init("assert", new BuiltinModule(builtin_assert),
-  {
-    "assert(boolean)",
-    "assert(boolean, string)",
-  });
+                 {
+                     "assert(boolean)",
+                     "assert(boolean, string)",
+                 });
 
   Builtins::init("for", new BuiltinModule(builtin_for),
-  {
-    "for([start : increment : end])",
-    "for([start : end])",
-    "for([vector])",
-  });
+                 {
+                     "for([start : increment : end])",
+                     "for([start : end])",
+                     "for([vector])",
+                 });
 
   Builtins::init("let", new BuiltinModule(builtin_let),
-  {
-    "let(arg, ...) expression",
-  });
-
-  Builtins::init("intersection_for", new BuiltinModule(builtin_intersection_for),
-  {
-    "intersection_for([start : increment : end])",
-    "intersection_for([start : end])",
-    "intersection_for([vector])",
-  });
+                 {
+                     "let(arg, ...) expression",
+                 });
+
+  Builtins::init("intersection_for",
+                 new BuiltinModule(builtin_intersection_for),
+                 {
+                     "intersection_for([start : increment : end])",
+                     "intersection_for([start : end])",
+                     "intersection_for([vector])",
+                 });
 
   Builtins::init("if", new BuiltinModule(builtin_if),
-  {
-    "if(boolean)",
-  });
+                 {
+                     "if(boolean)",
+                 });
 }
diff --git a/src/core/customizer/Annotation.cc b/src/core/customizer/Annotation.cc
index d8b953414..b976a58c5 100644
--- a/src/core/customizer/Annotation.cc
+++ b/src/core/customizer/Annotation.cc
@@ -24,22 +24,18 @@
  *
  */
 
-
 #include "core/customizer/Annotation.h"
 
-#include <ostream>
 #include <memory>
+#include <ostream>
 #include <string>
 #include <utility>
 
 #include "core/Expression.h"
 
 Annotation::Annotation(std::string name, std::shared_ptr<Expression> expr)
-  : name(std::move(name)), expr(std::move(expr))
-{
-}
+    : name(std::move(name)), expr(std::move(expr)) {}
 
-void Annotation::print(std::ostream& stream, const std::string& indent) const
-{
+void Annotation::print(std::ostream &stream, const std::string &indent) const {
   stream << indent << "//" << name << "(" << *this->expr << ")" << std::endl;
 }
diff --git a/src/core/customizer/Annotation.h b/src/core/customizer/Annotation.h
index 290c5626b..7bcb4fa4f 100644
--- a/src/core/customizer/Annotation.h
+++ b/src/core/customizer/Annotation.h
@@ -1,19 +1,20 @@
 #pragma once
 
-#include <ostream>
 #include <memory>
+#include <ostream>
 #include <string>
-#include <vector>
 #include <unordered_map>
+#include <vector>
 
-class Annotation
-{
+class Annotation {
 public:
   Annotation(std::string name, std::shared_ptr<class Expression> expr);
 
-  void print(std::ostream& stream, const std::string& indent) const;
-  [[nodiscard]] const std::string& getName() const { return name; }
-  [[nodiscard]] const std::shared_ptr<Expression>& getExpr() const { return expr; }
+  void print(std::ostream &stream, const std::string &indent) const;
+  [[nodiscard]] const std::string &getName() const { return name; }
+  [[nodiscard]] const std::shared_ptr<Expression> &getExpr() const {
+    return expr;
+  }
 
 private:
   std::string name;
diff --git a/src/core/customizer/CommentParser.cc b/src/core/customizer/CommentParser.cc
index d06545f5c..992a40e42 100644
--- a/src/core/customizer/CommentParser.cc
+++ b/src/core/customizer/CommentParser.cc
@@ -1,15 +1,16 @@
 #include "core/customizer/CommentParser.h"
 
-#include <memory>
 #include <cstddef>
+#include <memory>
 
 #include "core/Expression.h"
 #include "core/customizer/Annotation.h"
+#include <boost/range/adaptor/reversed.hpp>
 #include <string>
 #include <vector>
-#include <boost/range/adaptor/reversed.hpp>
 // gcc 4.8 and earlier have issues with std::regex see
-// #2291 and https://stackoverflow.com/questions/12530406/is-gcc-4-8-or-earlier-buggy-about-regular-expressions
+// #2291 and
+// https://stackoverflow.com/questions/12530406/is-gcc-4-8-or-earlier-buggy-about-regular-expressions
 // therefore, we use boost::regex
 #include <boost/regex.hpp>
 
@@ -25,7 +26,7 @@ using GroupList = std::vector<GroupInfo>;
 
  */
 
-static int getLineToStop(const std::string& fulltext){
+static int getLineToStop(const std::string &fulltext) {
   int lineNo = 1;
   bool inString = false;
   for (unsigned int i = 0; i < fulltext.length(); ++i) {
@@ -41,7 +42,7 @@ static int getLineToStop(const std::string& fulltext){
       continue;
     }
 
-    //start or end of string negate the checkpoint
+    // start or end of string negate the checkpoint
     if (fulltext[i] == '"') {
       inString = !inString;
       continue;
@@ -49,12 +50,13 @@ static int getLineToStop(const std::string& fulltext){
 
     if (!inString && fulltext.compare(i, 2, "//") == 0) {
       i++;
-      while (i < fulltext.length() && fulltext[i] != '\n') i++;
+      while (i < fulltext.length() && fulltext[i] != '\n')
+        i++;
       lineNo++;
       continue;
     }
 
-    //start of multi line comment if check is true
+    // start of multi line comment if check is true
     if (!inString && fulltext.compare(i, 2, "/*") == 0) {
       i++;
       if (i < fulltext.length()) {
@@ -78,24 +80,26 @@ static int getLineToStop(const std::string& fulltext){
   return lineNo;
 }
 
-
 /*
    Finds the given line in the given source code text, and
    extracts the comment (excluding the "//" prefix)
  */
-static std::string getComment(const std::string& fulltext, int line)
-{
-  if (line < 1) return "";
+static std::string getComment(const std::string &fulltext, int line) {
+  if (line < 1)
+    return "";
 
   // Locate line
   std::size_t start = 0;
   for (; start < fulltext.length(); ++start) {
-    if (line <= 1) break;
-    if (fulltext[start] == '\n') line--;
+    if (line <= 1)
+      break;
+    if (fulltext[start] == '\n')
+      line--;
   }
 
   std::size_t end = start + 1;
-  while (end < fulltext.size() && fulltext[end] != '\n') end++;
+  while (end < fulltext.size() && fulltext[end] != '\n')
+    end++;
 
   std::string comment = fulltext.substr(start, end - start);
 
@@ -108,15 +112,20 @@ static std::string getComment(const std::string& fulltext, int line)
       startText++;
       continue;
     }
-    if (comment[startText] == '"') inString = !inString;
+    if (comment[startText] == '"')
+      inString = !inString;
     if (!inString) {
-      if (comment.compare(startText, 2, "//") == 0) break;
-      if (comment[startText] == ';' && noOfSemicolon > 0) return "";
-      if (comment[startText] == ';') noOfSemicolon++;
+      if (comment.compare(startText, 2, "//") == 0)
+        break;
+      if (comment[startText] == ';' && noOfSemicolon > 0)
+        return "";
+      if (comment[startText] == ';')
+        noOfSemicolon++;
     }
   }
 
-  if (startText + 2 > comment.length()) return "";
+  if (startText + 2 > comment.length())
+    return "";
 
   std::string result = comment.substr(startText + 2);
   return result;
@@ -126,24 +135,28 @@ static std::string getComment(const std::string& fulltext, int line)
    Extracts a parameter description from comment on the given line.
    Returns description, without any "//"
  */
-static std::string getDescription(const std::string& fulltext, int line)
-{
-  if (line < 1) return "";
+static std::string getDescription(const std::string &fulltext, int line) {
+  if (line < 1)
+    return "";
 
   unsigned int start = 0;
   for (; start < fulltext.length(); ++start) {
-    if (line <= 1) break;
-    if (fulltext[start] == '\n') line--;
+    if (line <= 1)
+      break;
+    if (fulltext[start] == '\n')
+      line--;
   }
 
   // not a valid description
-  if (fulltext.compare(start, 2, "//") != 0) return "";
+  if (fulltext.compare(start, 2, "//") != 0)
+    return "";
 
   // Jump over the two forward slashes
   start = start + 2;
 
-  //Jump over all the spaces
-  while (fulltext[start] == ' ' || fulltext[start] == '\t') start++;
+  // Jump over all the spaces
+  while (fulltext[start] == ' ' || fulltext[start] == '\t')
+    start++;
   std::string retString = "";
 
   // go till the end of the line
@@ -163,9 +176,8 @@ static std::string getDescription(const std::string& fulltext, int line)
 /*
    Create groups by parsing the multi line comment provided
  */
-static GroupInfo createGroup(std::string comment, int lineNo)
-{
-  //store info related to group
+static GroupInfo createGroup(std::string comment, int lineNo) {
+  // store info related to group
   GroupInfo groupInfo;
   std::string finalGroupName;
 
@@ -188,15 +200,13 @@ static GroupInfo createGroup(std::string comment, int lineNo)
   return groupInfo;
 }
 
-
 /*
    This function collect all groups of parameters described in the
    scad file.
  */
-static GroupList collectGroups(const std::string& fulltext)
-{
-  GroupList groupList; // container of all group names
-  int lineNo = 1; // tracks line number
+static GroupList collectGroups(const std::string &fulltext) {
+  GroupList groupList;   // container of all group names
+  int lineNo = 1;        // tracks line number
   bool inString = false; // check if its string or (line-) comment
 
   // iterate through whole scad file
@@ -213,7 +223,7 @@ static GroupList collectGroups(const std::string& fulltext)
       continue;
     }
 
-    //start or end of string negate the checkpoint
+    // start or end of string negate the checkpoint
     if (fulltext[i] == '"') {
       inString = !inString;
       continue;
@@ -221,14 +231,15 @@ static GroupList collectGroups(const std::string& fulltext)
 
     if (!inString && fulltext.compare(i, 2, "//") == 0) {
       i++;
-      while (i < fulltext.length() && fulltext[i] != '\n') i++;
+      while (i < fulltext.length() && fulltext[i] != '\n')
+        i++;
       lineNo++;
       continue;
     }
 
-    //start of multi line comment if check is true
+    // start of multi line comment if check is true
     if (!inString && fulltext.compare(i, 2, "/*") == 0) {
-      //store comment
+      // store comment
       std::string comment;
       i++;
       if (i < fulltext.length()) {
@@ -247,40 +258,40 @@ static GroupList collectGroups(const std::string& fulltext)
         i++;
       }
 
-      if (isGroup) groupList.push_back(createGroup(comment, lineNo));
+      if (isGroup)
+        groupList.push_back(createGroup(comment, lineNo));
     }
   }
   return groupList;
 }
 
-
-
 /*!
    Insert Parameters in AST of given scad file
    form of annotations
  */
-void CommentParser::collectParameters(const std::string& fulltext, SourceFile *root_file)
-{
+void CommentParser::collectParameters(const std::string &fulltext,
+                                      SourceFile *root_file) {
   static auto EmptyStringLiteral(std::make_shared<Literal>(""));
 
   // Get all groups of parameters
   GroupList groupList = collectGroups(fulltext);
   int parseTill = getLineToStop(fulltext);
   // Extract parameters for all literal assignments
-  for (auto& assignment : root_file->scope.assignments) {
-    if (!assignment->getExpr()->isLiteral()) continue; // Only consider literals
+  for (auto &assignment : root_file->scope.assignments) {
+    if (!assignment->getExpr()->isLiteral())
+      continue; // Only consider literals
 
     // get location of assignment node
     auto firstLocation = assignment->location();
     auto overwriteLocation = assignment->locationOfOverwrite();
-    auto location = overwriteLocation.isNone() ? firstLocation : overwriteLocation;
+    auto location =
+        overwriteLocation.isNone() ? firstLocation : overwriteLocation;
 
     int firstLine = location.firstLine();
-    if (firstLine >= parseTill || (
-          location.fileName() != "" &&
-          location.fileName() != root_file->getFilename() &&
-          location.fileName() != root_file->getFullpath()
-          )) {
+    if (firstLine >= parseTill ||
+        (location.fileName() != "" &&
+         location.fileName() != root_file->getFilename() &&
+         location.fileName() != root_file->getFullpath())) {
       continue;
     }
     // making list to add annotations
@@ -289,27 +300,29 @@ void CommentParser::collectParameters(const std::string& fulltext, SourceFile *r
     // Extracting the parameter comment
     std::shared_ptr<Expression> params;
     std::string comment = getComment(fulltext, firstLine);
-    if (comment.length() > 0) { // don't parse what doesn't exist, so we don't get bogus errors from the parser
+    if (comment.length() > 0) { // don't parse what doesn't exist, so we don't
+                                // get bogus errors from the parser
       // getting the node for parameter annotation
       params = CommentParser::parser(comment.c_str());
     }
-    if (!params) params = EmptyStringLiteral;
+    if (!params)
+      params = EmptyStringLiteral;
 
     // adding parameter to the list
     annotationList->push_back(Annotation("Parameter", params));
 
-    //extracting the description
+    // extracting the description
     std::string descr = getDescription(fulltext, firstLine - 1);
     if (descr != "") {
-      //creating node for description
+      // creating node for description
       std::shared_ptr<Expression> expr(new Literal(descr));
       annotationList->push_back(Annotation("Description", expr));
     }
 
     // Look for the group to which the given assignment belong
-    for (const auto& groupInfo :boost::adaptors::reverse(groupList)) {
+    for (const auto &groupInfo : boost::adaptors::reverse(groupList)) {
       if (groupInfo.lineNo < firstLine) {
-        //creating node for description
+        // creating node for description
         std::shared_ptr<Expression> expr(new Literal(groupInfo.commentString));
         annotationList->push_back(Annotation("Group", expr));
         break;
diff --git a/src/core/customizer/CommentParser.h b/src/core/customizer/CommentParser.h
index 25cdea291..e1c84bfe6 100644
--- a/src/core/customizer/CommentParser.h
+++ b/src/core/customizer/CommentParser.h
@@ -8,6 +8,6 @@
 namespace CommentParser {
 
 std::shared_ptr<Expression> parser(const char *text);
-void collectParameters(const std::string& fulltext, SourceFile *root_file);
+void collectParameters(const std::string &fulltext, SourceFile *root_file);
 
-}
+} // namespace CommentParser
diff --git a/src/core/customizer/ParameterObject.cc b/src/core/customizer/ParameterObject.cc
index 44cba56f4..8fcd95dea 100644
--- a/src/core/customizer/ParameterObject.cc
+++ b/src/core/customizer/ParameterObject.cc
@@ -1,25 +1,25 @@
 #include "core/customizer/ParameterObject.h"
 
 #include "core/AST.h"
-#include "core/customizer/Annotation.h"
 #include "core/Assignment.h"
 #include "core/Expression.h"
 #include "core/SourceFile.h"
+#include "core/customizer/Annotation.h"
 
-#include <variant>
+#include <boost/algorithm/string.hpp>
+#include <cstddef>
 #include <map>
-#include <utility>
 #include <memory>
-#include <cstddef>
 #include <sstream>
 #include <string>
+#include <utility>
+#include <variant>
 #include <vector>
-#include <boost/algorithm/string.hpp>
 
 namespace {
 
-bool set_enum_value(json& o, const std::string& name, const EnumParameter::EnumItem& item)
-{
+bool set_enum_value(json &o, const std::string &name,
+                    const EnumParameter::EnumItem &item) {
   EnumParameter::EnumValue itemValue = item.value;
   double *doubleValue = std::get_if<double>(&itemValue);
   if (doubleValue) {
@@ -31,10 +31,10 @@ bool set_enum_value(json& o, const std::string& name, const EnumParameter::EnumI
   }
 }
 
-}
+} // namespace
 
-bool BoolParameter::importValue(boost::property_tree::ptree encodedValue, bool store)
-{
+bool BoolParameter::importValue(boost::property_tree::ptree encodedValue,
+                                bool store) {
   boost::optional<bool> decoded = encodedValue.get_value_optional<bool>();
   if (!decoded) {
     return false;
@@ -45,42 +45,39 @@ bool BoolParameter::importValue(boost::property_tree::ptree encodedValue, bool s
   return true;
 }
 
-boost::property_tree::ptree BoolParameter::exportValue() const
-{
+boost::property_tree::ptree BoolParameter::exportValue() const {
   boost::property_tree::ptree output;
   output.put_value<bool>(value);
   return output;
 }
 
-json BoolParameter::jsonValue() const
-{
+json BoolParameter::jsonValue() const {
   json o;
   o["type"] = "boolean";
   o["initial"] = defaultValue;
   return o;
 }
 
-void BoolParameter::apply(Assignment *assignment) const
-{
+void BoolParameter::apply(Assignment *assignment) const {
   assignment->setExpr(std::make_shared<Literal>(value));
 }
 
-StringParameter::StringParameter(
-  const std::string& name, const std::string& description, const std::string& group,
-  const std::string& defaultValue,
-  boost::optional<size_t> maximumSize
-  ) :
-  ParameterObject(name, description, group, ParameterObject::ParameterType::String),
-  value(defaultValue), defaultValue(defaultValue),
-  maximumSize(maximumSize)
-{
+StringParameter::StringParameter(const std::string &name,
+                                 const std::string &description,
+                                 const std::string &group,
+                                 const std::string &defaultValue,
+                                 boost::optional<size_t> maximumSize)
+    : ParameterObject(name, description, group,
+                      ParameterObject::ParameterType::String),
+      value(defaultValue), defaultValue(defaultValue),
+      maximumSize(maximumSize) {
   if (maximumSize && defaultValue.size() > *maximumSize) {
     maximumSize = defaultValue.size();
   }
 }
 
-bool StringParameter::importValue(boost::property_tree::ptree encodedValue, bool store)
-{
+bool StringParameter::importValue(boost::property_tree::ptree encodedValue,
+                                  bool store) {
   if (store) {
     value = encodedValue.data();
     if (maximumSize && value.size() > *maximumSize) {
@@ -90,15 +87,13 @@ bool StringParameter::importValue(boost::property_tree::ptree encodedValue, bool
   return true;
 }
 
-boost::property_tree::ptree StringParameter::exportValue() const
-{
+boost::property_tree::ptree StringParameter::exportValue() const {
   boost::property_tree::ptree output;
   output.data() = value;
   return output;
 }
 
-json StringParameter::jsonValue() const
-{
+json StringParameter::jsonValue() const {
   json o;
   o["type"] = "string";
   o["initial"] = defaultValue;
@@ -108,13 +103,12 @@ json StringParameter::jsonValue() const
   return o;
 }
 
-void StringParameter::apply(Assignment *assignment) const
-{
+void StringParameter::apply(Assignment *assignment) const {
   assignment->setExpr(std::make_shared<Literal>(value));
 }
 
-bool NumberParameter::importValue(boost::property_tree::ptree encodedValue, bool store)
-{
+bool NumberParameter::importValue(boost::property_tree::ptree encodedValue,
+                                  bool store) {
   boost::optional<double> decoded = encodedValue.get_value_optional<double>();
   if (!decoded) {
     return false;
@@ -131,15 +125,13 @@ bool NumberParameter::importValue(boost::property_tree::ptree encodedValue, bool
   return true;
 }
 
-boost::property_tree::ptree NumberParameter::exportValue() const
-{
+boost::property_tree::ptree NumberParameter::exportValue() const {
   boost::property_tree::ptree output;
   output.put_value<double>(value);
   return output;
 }
 
-json NumberParameter::jsonValue() const
-{
+json NumberParameter::jsonValue() const {
   json o;
   o["type"] = "number";
   o["initial"] = defaultValue;
@@ -152,18 +144,20 @@ json NumberParameter::jsonValue() const
   return o;
 }
 
-void NumberParameter::apply(Assignment *assignment) const
-{
+void NumberParameter::apply(Assignment *assignment) const {
   assignment->setExpr(std::make_shared<Literal>(value));
 }
 
-bool VectorParameter::importValue(boost::property_tree::ptree encodedValue, bool store)
-{
+bool VectorParameter::importValue(boost::property_tree::ptree encodedValue,
+                                  bool store) {
   std::vector<double> decoded;
 
-  // NOLINTBEGIN(*NewDeleteLeaks) LLVM bug https://github.com/llvm/llvm-project/issues/40486
-  std::string encoded = boost::algorithm::erase_all_copy(encodedValue.data(), " ");
-  if (encoded.size() < 2 || encoded[0] != '[' || encoded[encoded.size() - 1] != ']') {
+  // NOLINTBEGIN(*NewDeleteLeaks) LLVM bug
+  // https://github.com/llvm/llvm-project/issues/40486
+  std::string encoded =
+      boost::algorithm::erase_all_copy(encodedValue.data(), " ");
+  if (encoded.size() < 2 || encoded[0] != '[' ||
+      encoded[encoded.size() - 1] != ']') {
     return false;
   }
   encoded.erase(encoded.begin());
@@ -173,7 +167,7 @@ bool VectorParameter::importValue(boost::property_tree::ptree encodedValue, bool
   boost::algorithm::split(items, encoded, boost::algorithm::is_any_of(","));
   // NOLINTEND(*NewDeleteLeaks)
 
-  for (const std::string& item : items) {
+  for (const std::string &item : items) {
     std::stringstream stream(item);
     double itemValue;
     stream >> itemValue;
@@ -201,8 +195,7 @@ bool VectorParameter::importValue(boost::property_tree::ptree encodedValue, bool
   return true;
 }
 
-boost::property_tree::ptree VectorParameter::exportValue() const
-{
+boost::property_tree::ptree VectorParameter::exportValue() const {
   std::stringstream encoded;
   encoded << "[";
   for (size_t i = 0; i < value.size(); i++) {
@@ -218,8 +211,7 @@ boost::property_tree::ptree VectorParameter::exportValue() const
   return output;
 }
 
-json VectorParameter::jsonValue() const
-{
+json VectorParameter::jsonValue() const {
   json o;
   o["type"] = "number";
   o["initial"] = defaultValue;
@@ -232,8 +224,7 @@ json VectorParameter::jsonValue() const
   return o;
 }
 
-void VectorParameter::apply(Assignment *assignment) const
-{
+void VectorParameter::apply(Assignment *assignment) const {
   std::shared_ptr<Vector> vector = std::make_shared<Vector>(Location::NONE);
   for (double item : value) {
     vector->emplace_back(new Literal(item));
@@ -241,13 +232,15 @@ void VectorParameter::apply(Assignment *assignment) const
   assignment->setExpr(std::move(vector));
 }
 
-bool EnumParameter::importValue(boost::property_tree::ptree encodedValue, bool store)
-{
+bool EnumParameter::importValue(boost::property_tree::ptree encodedValue,
+                                bool store) {
   bool found = false;
   int index;
-  boost::optional<double> decodedDouble = encodedValue.get_value_optional<double>();
+  boost::optional<double> decodedDouble =
+      encodedValue.get_value_optional<double>();
   for (size_t i = 0; i < items.size(); i++) {
-    if ((decodedDouble && items[i].value == EnumValue(*decodedDouble)) || items[i].value == EnumValue(encodedValue.data())) {
+    if ((decodedDouble && items[i].value == EnumValue(*decodedDouble)) ||
+        items[i].value == EnumValue(encodedValue.data())) {
       index = i;
       found = true;
       break;
@@ -263,9 +256,8 @@ bool EnumParameter::importValue(boost::property_tree::ptree encodedValue, bool s
   return true;
 }
 
-boost::property_tree::ptree EnumParameter::exportValue() const
-{
-  const EnumValue& itemValue = items[valueIndex].value;
+boost::property_tree::ptree EnumParameter::exportValue() const {
+  const EnumValue &itemValue = items[valueIndex].value;
   boost::property_tree::ptree output;
   if (std::holds_alternative<double>(itemValue)) {
     output.put_value<double>(std::get<double>(itemValue));
@@ -275,8 +267,7 @@ boost::property_tree::ptree EnumParameter::exportValue() const
   return output;
 }
 
-json EnumParameter::jsonValue() const
-{
+json EnumParameter::jsonValue() const {
   json o;
   if (set_enum_value(o, "initial", items[defaultValueIndex])) {
     o["type"] = "number";
@@ -285,7 +276,7 @@ json EnumParameter::jsonValue() const
   }
 
   json options;
-  for (const auto& item : items) {
+  for (const auto &item : items) {
     json option;
     option["name"] = item.key;
     set_enum_value(option, "value", item);
@@ -296,25 +287,23 @@ json EnumParameter::jsonValue() const
   return o;
 }
 
-void EnumParameter::apply(Assignment *assignment) const
-{
-  const EnumValue& itemValue = items[valueIndex].value;
+void EnumParameter::apply(Assignment *assignment) const {
+  const EnumValue &itemValue = items[valueIndex].value;
   if (std::holds_alternative<double>(itemValue)) {
     assignment->setExpr(std::make_shared<Literal>(std::get<double>(itemValue)));
   } else {
-    assignment->setExpr(std::make_shared<Literal>(std::get<std::string>(itemValue)));
+    assignment->setExpr(
+        std::make_shared<Literal>(std::get<std::string>(itemValue)));
   }
 }
 
-
-
-struct EnumValues
-{
+struct EnumValues {
   std::vector<EnumParameter::EnumItem> items;
   int defaultValueIndex;
 };
-static EnumValues parseEnumItems(const Expression *parameter, const std::string& defaultKey, const EnumParameter::EnumValue& defaultValue)
-{
+static EnumValues parseEnumItems(const Expression *parameter,
+                                 const std::string &defaultKey,
+                                 const EnumParameter::EnumValue &defaultValue) {
   EnumValues output;
 
   const auto *expression = dynamic_cast<const Vector *>(parameter);
@@ -323,10 +312,11 @@ static EnumValues parseEnumItems(const Expression *parameter, const std::string&
   }
 
   std::vector<EnumParameter::EnumItem> items;
-  const auto& elements = expression->getChildren();
-  for (const auto& elementPointer : elements) {
+  const auto &elements = expression->getChildren();
+  for (const auto &elementPointer : elements) {
     EnumParameter::EnumItem item;
-    if (const auto *element = dynamic_cast<const Literal *>(elementPointer.get())) {
+    if (const auto *element =
+            dynamic_cast<const Literal *>(elementPointer.get())) {
       // string or number literal
       if (element->isDouble()) {
         if (elements.size() == 1) {
@@ -342,13 +332,15 @@ static EnumValues parseEnumItems(const Expression *parameter, const std::string&
       } else {
         return output;
       }
-    } else if (const auto *element = dynamic_cast<const Vector *>(elementPointer.get())) {
+    } else if (const auto *element =
+                   dynamic_cast<const Vector *>(elementPointer.get())) {
       // [value, key] vector
       if (element->getChildren().size() != 2) {
         return output;
       }
 
-      const auto *key = dynamic_cast<const Literal *>(element->getChildren()[1].get());
+      const auto *key =
+          dynamic_cast<const Literal *>(element->getChildren()[1].get());
       if (!key) {
         return output;
       }
@@ -360,7 +352,8 @@ static EnumValues parseEnumItems(const Expression *parameter, const std::string&
         return output;
       }
 
-      const auto *value = dynamic_cast<const Literal *>(element->getChildren()[0].get());
+      const auto *value =
+          dynamic_cast<const Literal *>(element->getChildren()[0].get());
       if (!value) {
         return output;
       }
@@ -392,14 +385,13 @@ static EnumValues parseEnumItems(const Expression *parameter, const std::string&
   return output;
 }
 
-struct NumericLimits
-{
+struct NumericLimits {
   boost::optional<double> minimum;
   boost::optional<double> maximum;
   boost::optional<double> step;
 };
-static NumericLimits parseNumericLimits(const Expression *parameter, const std::vector<double>& values)
-{
+static NumericLimits parseNumericLimits(const Expression *parameter,
+                                        const std::vector<double> &values) {
   NumericLimits output;
 
   if (const auto *step = dynamic_cast<const Literal *>(parameter)) {
@@ -408,7 +400,8 @@ static NumericLimits parseNumericLimits(const Expression *parameter, const std::
     }
   } else if (const auto *maximum = dynamic_cast<const Vector *>(parameter)) {
     if (maximum->getChildren().size() == 1) {
-      const auto *maximumChild = dynamic_cast<const Literal *>(maximum->getChildren()[0].get());
+      const auto *maximumChild =
+          dynamic_cast<const Literal *>(maximum->getChildren()[0].get());
       if (maximumChild && maximumChild->isDouble()) {
         output.maximum = maximumChild->toDouble();
       }
@@ -416,10 +409,7 @@ static NumericLimits parseNumericLimits(const Expression *parameter, const std::
   } else if (const auto *range = dynamic_cast<const Range *>(parameter)) {
     const auto *minimum = dynamic_cast<const Literal *>(range->getBegin());
     const auto *maximum = dynamic_cast<const Literal *>(range->getEnd());
-    if (
-      minimum && minimum->isDouble()
-      && maximum && maximum->isDouble()
-      ) {
+    if (minimum && minimum->isDouble() && maximum && maximum->isDouble()) {
       output.minimum = minimum->toDouble();
       output.maximum = maximum->toDouble();
 
@@ -441,8 +431,8 @@ static NumericLimits parseNumericLimits(const Expression *parameter, const std::
   return output;
 }
 
-std::unique_ptr<ParameterObject> ParameterObject::fromAssignment(const Assignment *assignment)
-{
+std::unique_ptr<ParameterObject>
+ParameterObject::fromAssignment(const Assignment *assignment) {
   std::string name = assignment->getName();
 
   const Expression *parameter = nullptr;
@@ -453,9 +443,11 @@ std::unique_ptr<ParameterObject> ParameterObject::fromAssignment(const Assignmen
   parameter = parameterAnnotation->getExpr().get();
 
   std::string description;
-  const Annotation *descriptionAnnotation = assignment->annotation("Description");
+  const Annotation *descriptionAnnotation =
+      assignment->annotation("Description");
   if (descriptionAnnotation) {
-    const auto *expression = dynamic_cast<const Literal *>(descriptionAnnotation->getExpr().get());
+    const auto *expression =
+        dynamic_cast<const Literal *>(descriptionAnnotation->getExpr().get());
     if (expression && expression->isString()) {
       description = expression->toString();
     }
@@ -464,18 +456,20 @@ std::unique_ptr<ParameterObject> ParameterObject::fromAssignment(const Assignmen
   std::string group = "Parameters";
   const Annotation *groupAnnotation = assignment->annotation("Group");
   if (groupAnnotation) {
-    const auto *expression = dynamic_cast<const Literal *>(groupAnnotation->getExpr().get());
+    const auto *expression =
+        dynamic_cast<const Literal *>(groupAnnotation->getExpr().get());
     if (expression && expression->isString()) {
       group = boost::algorithm::trim_copy(expression->toString());
-
     }
-    if (group == "Hidden") return nullptr;
+    if (group == "Hidden")
+      return nullptr;
   }
 
   const Expression *valueExpression = assignment->getExpr().get();
   if (const auto *expression = dynamic_cast<const Literal *>(valueExpression)) {
     if (expression->isBool()) {
-      return std::make_unique<BoolParameter>(name, description, group, expression->toBool());
+      return std::make_unique<BoolParameter>(name, description, group,
+                                             expression->toBool());
     }
 
     if (expression->isDouble() || expression->isString()) {
@@ -490,32 +484,39 @@ std::unique_ptr<ParameterObject> ParameterObject::fromAssignment(const Assignmen
       }
       EnumValues values = parseEnumItems(parameter, key, value);
       if (!values.items.empty()) {
-        return std::make_unique<EnumParameter>(name, description, group, values.defaultValueIndex, values.items);
+        return std::make_unique<EnumParameter>(
+            name, description, group, values.defaultValueIndex, values.items);
       }
     }
 
     if (expression->isString()) {
       std::string value = expression->toString();
       boost::optional<size_t> maximumSize = boost::none;
-      const auto *maximumSizeExpression = dynamic_cast<const Literal *>(parameter);
+      const auto *maximumSizeExpression =
+          dynamic_cast<const Literal *>(parameter);
       if (maximumSizeExpression && maximumSizeExpression->isDouble()) {
         maximumSize = (size_t)(maximumSizeExpression->toDouble());
       }
-      return std::make_unique<StringParameter>(name, description, group, value, maximumSize);
+      return std::make_unique<StringParameter>(name, description, group, value,
+                                               maximumSize);
     }
 
     if (expression->isDouble()) {
       double value = expression->toDouble();
       NumericLimits limits = parseNumericLimits(parameter, {value});
-      return std::make_unique<NumberParameter>(name, description, group, value, limits.minimum, limits.maximum, limits.step);
+      return std::make_unique<NumberParameter>(name, description, group, value,
+                                               limits.minimum, limits.maximum,
+                                               limits.step);
     }
-  } else if (const auto *expression = dynamic_cast<const Vector *>(valueExpression)) {
-    if (expression->getChildren().size() < 1 || expression->getChildren().size() > 4) {
+  } else if (const auto *expression =
+                 dynamic_cast<const Vector *>(valueExpression)) {
+    if (expression->getChildren().size() < 1 ||
+        expression->getChildren().size() > 4) {
       return nullptr;
     }
 
     std::vector<double> value;
-    for (const auto& element : expression->getChildren()) {
+    for (const auto &element : expression->getChildren()) {
       const auto *item = dynamic_cast<const Literal *>(element.get());
       if (!item) {
         return nullptr;
@@ -527,16 +528,19 @@ std::unique_ptr<ParameterObject> ParameterObject::fromAssignment(const Assignmen
     }
 
     NumericLimits limits = parseNumericLimits(parameter, value);
-    return std::make_unique<VectorParameter>(name, description, group, value, limits.minimum, limits.maximum, limits.step);
+    return std::make_unique<VectorParameter>(name, description, group, value,
+                                             limits.minimum, limits.maximum,
+                                             limits.step);
   }
   return nullptr;
 }
 
-ParameterObjects ParameterObjects::fromSourceFile(const SourceFile *sourceFile)
-{
+ParameterObjects
+ParameterObjects::fromSourceFile(const SourceFile *sourceFile) {
   ParameterObjects output;
-  for (const auto& assignment : sourceFile->scope.assignments) {
-    std::unique_ptr<ParameterObject> parameter = ParameterObject::fromAssignment(assignment.get());
+  for (const auto &assignment : sourceFile->scope.assignments) {
+    std::unique_ptr<ParameterObject> parameter =
+        ParameterObject::fromAssignment(assignment.get());
     if (parameter) {
       output.push_back(std::move(parameter));
     }
@@ -544,16 +548,14 @@ ParameterObjects ParameterObjects::fromSourceFile(const SourceFile *sourceFile)
   return output;
 }
 
-void ParameterObjects::reset()
-{
-  for (const auto& parameter : *this) {
+void ParameterObjects::reset() {
+  for (const auto &parameter : *this) {
     parameter->reset();
   }
 }
 
-void ParameterObjects::importValues(const ParameterSet& values)
-{
-  for (const auto& parameter : *this) {
+void ParameterObjects::importValues(const ParameterSet &values) {
+  for (const auto &parameter : *this) {
     auto it = values.find(parameter->name());
     if (it == values.end()) {
       parameter->reset();
@@ -563,24 +565,22 @@ void ParameterObjects::importValues(const ParameterSet& values)
   }
 }
 
-ParameterSet ParameterObjects::exportValues(const std::string& setName)
-{
+ParameterSet ParameterObjects::exportValues(const std::string &setName) {
   ParameterSet output;
   output.setName(setName);
-  for (const auto& parameter : *this) {
+  for (const auto &parameter : *this) {
     output[parameter->name()] = parameter->exportValue();
   }
   return output;
 }
 
-void ParameterObjects::apply(SourceFile *sourceFile) const
-{
+void ParameterObjects::apply(SourceFile *sourceFile) const {
   std::map<std::string, ParameterObject *> namedParameters;
-  for (const auto& parameter : *this) {
+  for (const auto &parameter : *this) {
     namedParameters[parameter->name()] = parameter.get();
   }
 
-  for (auto& assignment : sourceFile->scope.assignments) {
+  for (auto &assignment : sourceFile->scope.assignments) {
     if (namedParameters.count(assignment->getName())) {
       namedParameters[assignment->getName()]->apply(assignment.get());
     }
diff --git a/src/core/customizer/ParameterObject.h b/src/core/customizer/ParameterObject.h
index e4d12e0b4..9271f0846 100644
--- a/src/core/customizer/ParameterObject.h
+++ b/src/core/customizer/ParameterObject.h
@@ -1,8 +1,8 @@
 #pragma once
 
-#include <memory>
-#include <cstddef>
 #include "json/json.hpp"
+#include <cstddef>
+#include <memory>
 #include <string>
 #include <utility>
 #include <variant>
@@ -14,28 +14,31 @@ using json = nlohmann::json;
 class SourceFile;
 class Assignment;
 
-class ParameterObject
-{
+class ParameterObject {
 public:
   enum class ParameterType { Bool, String, Number, Vector, Enum };
 
   virtual ~ParameterObject() = default;
-  static std::unique_ptr<ParameterObject> fromAssignment(const Assignment *assignment);
+  static std::unique_ptr<ParameterObject>
+  fromAssignment(const Assignment *assignment);
 
   [[nodiscard]] ParameterType type() const { return type_; }
-  [[nodiscard]] const std::string& name() const { return name_; }
-  [[nodiscard]] const std::string& description() const { return description_; }
-  [[nodiscard]] const std::string& group() const { return group_; }
+  [[nodiscard]] const std::string &name() const { return name_; }
+  [[nodiscard]] const std::string &description() const { return description_; }
+  [[nodiscard]] const std::string &group() const { return group_; }
 
   virtual void reset() = 0;
-  virtual bool importValue(boost::property_tree::ptree encodedValue, bool store) = 0;
+  virtual bool importValue(boost::property_tree::ptree encodedValue,
+                           bool store) = 0;
   [[nodiscard]] virtual boost::property_tree::ptree exportValue() const = 0;
   [[nodiscard]] virtual json jsonValue() const = 0;
   virtual void apply(Assignment *assignment) const = 0;
 
 protected:
-  ParameterObject(std::string name, std::string description, std::string group, ParameterType type) :
-    type_(type), name_(std::move(name)), description_(std::move(description)), group_(std::move(group)) {}
+  ParameterObject(std::string name, std::string description, std::string group,
+                  ParameterType type)
+      : type_(type), name_(std::move(name)),
+        description_(std::move(description)), group_(std::move(group)) {}
 
   ParameterType type_;
   std::string name_;
@@ -43,19 +46,17 @@ protected:
   std::string group_;
 };
 
-class BoolParameter : public ParameterObject
-{
+class BoolParameter : public ParameterObject {
 public:
-  BoolParameter(
-    const std::string& name, const std::string& description, const std::string& group,
-    bool defaultValue
-    ) :
-    ParameterObject(name, description, group, ParameterObject::ParameterType::Bool),
-    value(defaultValue), defaultValue(defaultValue)
-  {}
+  BoolParameter(const std::string &name, const std::string &description,
+                const std::string &group, bool defaultValue)
+      : ParameterObject(name, description, group,
+                        ParameterObject::ParameterType::Bool),
+        value(defaultValue), defaultValue(defaultValue) {}
 
   void reset() override { value = defaultValue; }
-  bool importValue(boost::property_tree::ptree encodedValue, bool store) override;
+  bool importValue(boost::property_tree::ptree encodedValue,
+                   bool store) override;
   [[nodiscard]] boost::property_tree::ptree exportValue() const override;
   [[nodiscard]] json jsonValue() const override;
   void apply(Assignment *assignment) const override;
@@ -64,17 +65,15 @@ public:
   bool defaultValue;
 };
 
-class StringParameter : public ParameterObject
-{
+class StringParameter : public ParameterObject {
 public:
-  StringParameter(
-    const std::string& name, const std::string& description, const std::string& group,
-    const std::string& defaultValue,
-    boost::optional<size_t> maximumSize
-    );
+  StringParameter(const std::string &name, const std::string &description,
+                  const std::string &group, const std::string &defaultValue,
+                  boost::optional<size_t> maximumSize);
 
   void reset() override { value = defaultValue; }
-  bool importValue(boost::property_tree::ptree encodedValue, bool store) override;
+  bool importValue(boost::property_tree::ptree encodedValue,
+                   bool store) override;
   [[nodiscard]] boost::property_tree::ptree exportValue() const override;
   [[nodiscard]] json jsonValue() const override;
   void apply(Assignment *assignment) const override;
@@ -84,21 +83,20 @@ public:
   boost::optional<size_t> maximumSize;
 };
 
-class NumberParameter : public ParameterObject
-{
+class NumberParameter : public ParameterObject {
 public:
-  NumberParameter(
-    const std::string& name, const std::string& description, const std::string& group,
-    double defaultValue,
-    boost::optional<double> minimum, boost::optional<double> maximum, boost::optional<double> step
-    ) :
-    ParameterObject(name, description, group, ParameterObject::ParameterType::Number),
-    value(defaultValue), defaultValue(defaultValue),
-    minimum(minimum), maximum(maximum), step(step)
-  {}
+  NumberParameter(const std::string &name, const std::string &description,
+                  const std::string &group, double defaultValue,
+                  boost::optional<double> minimum,
+                  boost::optional<double> maximum, boost::optional<double> step)
+      : ParameterObject(name, description, group,
+                        ParameterObject::ParameterType::Number),
+        value(defaultValue), defaultValue(defaultValue), minimum(minimum),
+        maximum(maximum), step(step) {}
 
   void reset() override { value = defaultValue; }
-  bool importValue(boost::property_tree::ptree encodedValue, bool store) override;
+  bool importValue(boost::property_tree::ptree encodedValue,
+                   bool store) override;
   [[nodiscard]] boost::property_tree::ptree exportValue() const override;
   [[nodiscard]] json jsonValue() const override;
   void apply(Assignment *assignment) const override;
@@ -110,21 +108,21 @@ public:
   boost::optional<double> step;
 };
 
-class VectorParameter : public ParameterObject
-{
+class VectorParameter : public ParameterObject {
 public:
-  VectorParameter(
-    const std::string& name, const std::string& description, const std::string& group,
-    const std::vector<double>& defaultValue,
-    boost::optional<double> minimum, boost::optional<double> maximum, boost::optional<double> step
-    ) :
-    ParameterObject(name, description, group, ParameterObject::ParameterType::Vector),
-    value(defaultValue), defaultValue(defaultValue),
-    minimum(minimum), maximum(maximum), step(step)
-  {}
+  VectorParameter(const std::string &name, const std::string &description,
+                  const std::string &group,
+                  const std::vector<double> &defaultValue,
+                  boost::optional<double> minimum,
+                  boost::optional<double> maximum, boost::optional<double> step)
+      : ParameterObject(name, description, group,
+                        ParameterObject::ParameterType::Vector),
+        value(defaultValue), defaultValue(defaultValue), minimum(minimum),
+        maximum(maximum), step(step) {}
 
   void reset() override { value = defaultValue; }
-  bool importValue(boost::property_tree::ptree encodedValue, bool store) override;
+  bool importValue(boost::property_tree::ptree encodedValue,
+                   bool store) override;
   [[nodiscard]] boost::property_tree::ptree exportValue() const override;
   [[nodiscard]] json jsonValue() const override;
   void apply(Assignment *assignment) const override;
@@ -136,8 +134,7 @@ public:
   boost::optional<double> step;
 };
 
-class EnumParameter : public ParameterObject
-{
+class EnumParameter : public ParameterObject {
 public:
   using EnumValue = std::variant<double, std::string>;
   struct EnumItem {
@@ -145,18 +142,17 @@ public:
     EnumValue value;
   };
 
-  EnumParameter(
-    const std::string& name, const std::string& description, const std::string& group,
-    int defaultValueIndex,
-    std::vector<EnumItem> items
-    ) :
-    ParameterObject(name, description, group, ParameterObject::ParameterType::Enum),
-    valueIndex(defaultValueIndex), defaultValueIndex(defaultValueIndex),
-    items(std::move(items))
-  {}
+  EnumParameter(const std::string &name, const std::string &description,
+                const std::string &group, int defaultValueIndex,
+                std::vector<EnumItem> items)
+      : ParameterObject(name, description, group,
+                        ParameterObject::ParameterType::Enum),
+        valueIndex(defaultValueIndex), defaultValueIndex(defaultValueIndex),
+        items(std::move(items)) {}
 
   void reset() override { valueIndex = defaultValueIndex; }
-  bool importValue(boost::property_tree::ptree encodedValue, bool store) override;
+  bool importValue(boost::property_tree::ptree encodedValue,
+                   bool store) override;
   [[nodiscard]] boost::property_tree::ptree exportValue() const override;
   [[nodiscard]] json jsonValue() const override;
   void apply(Assignment *assignment) const override;
@@ -166,12 +162,11 @@ public:
   std::vector<EnumItem> items;
 };
 
-class ParameterObjects : public std::vector<std::unique_ptr<ParameterObject>>
-{
+class ParameterObjects : public std::vector<std::unique_ptr<ParameterObject>> {
 public:
   static ParameterObjects fromSourceFile(const SourceFile *sourceFile);
   void reset();
-  void importValues(const ParameterSet& values);
-  ParameterSet exportValues(const std::string& setName);
+  void importValues(const ParameterSet &values);
+  ParameterSet exportValues(const std::string &setName);
   void apply(SourceFile *sourceFile) const;
 };
diff --git a/src/core/customizer/ParameterSet.cc b/src/core/customizer/ParameterSet.cc
index 304daef70..d2e7ebd8c 100644
--- a/src/core/customizer/ParameterSet.cc
+++ b/src/core/customizer/ParameterSet.cc
@@ -8,26 +8,27 @@ static std::string parameterSetsKey("parameterSets");
 static std::string fileFormatVersionKey("fileFormatVersion");
 static std::string fileFormatVersionValue("1");
 
-bool ParameterSets::readFile(const std::string& filename)
-{
+bool ParameterSets::readFile(const std::string &filename) {
   boost::property_tree::ptree root;
 
   try {
     boost::property_tree::read_json(filename, root);
-  } catch (const boost::property_tree::json_parser_error& e) {
-    LOG(message_group::Error, "Cannot open Parameter Set '%1$s': %2$s", filename, e.what());
+  } catch (const boost::property_tree::json_parser_error &e) {
+    LOG(message_group::Error, "Cannot open Parameter Set '%1$s': %2$s",
+        filename, e.what());
     return false;
   }
 
-  boost::optional<boost::property_tree::ptree&> sets = root.get_child_optional(parameterSetsKey);
+  boost::optional<boost::property_tree::ptree &> sets =
+      root.get_child_optional(parameterSetsKey);
   if (!sets) {
     return false;
   }
 
-  for (const auto& entry : *sets) {
+  for (const auto &entry : *sets) {
     ParameterSet set;
     set.setName(entry.first);
-    for (const auto& value : entry.second) {
+    for (const auto &value : entry.second) {
       set[value.first] = value.second;
     }
     push_back(set);
@@ -35,24 +36,27 @@ bool ParameterSets::readFile(const std::string& filename)
   return true;
 }
 
-void ParameterSets::writeFile(const std::string& filename) const
-{
+void ParameterSets::writeFile(const std::string &filename) const {
   boost::property_tree::ptree sets;
-  for (const auto& set : *this) {
+  for (const auto &set : *this) {
     boost::property_tree::ptree setTree;
-    for (const auto& parameter : set) {
-      setTree.push_back(boost::property_tree::ptree::value_type(parameter.first, parameter.second));
+    for (const auto &parameter : set) {
+      setTree.push_back(boost::property_tree::ptree::value_type(
+          parameter.first, parameter.second));
     }
-    sets.push_back(boost::property_tree::ptree::value_type(set.name(), setTree));
+    sets.push_back(
+        boost::property_tree::ptree::value_type(set.name(), setTree));
   }
 
   boost::property_tree::ptree root;
   root.put<std::string>(fileFormatVersionKey, fileFormatVersionValue);
-  root.push_back(boost::property_tree::ptree::value_type(parameterSetsKey, sets));
+  root.push_back(
+      boost::property_tree::ptree::value_type(parameterSetsKey, sets));
 
   try {
     boost::property_tree::write_json(filename, root);
-  } catch (const boost::property_tree::json_parser_error& e) {
-    LOG(message_group::Error, "Cannot write Parameter Set '%1$s': %2$s", filename, e.what());
+  } catch (const boost::property_tree::json_parser_error &e) {
+    LOG(message_group::Error, "Cannot write Parameter Set '%1$s': %2$s",
+        filename, e.what());
   }
 }
diff --git a/src/core/customizer/ParameterSet.h b/src/core/customizer/ParameterSet.h
index b842c146d..99f661d55 100644
--- a/src/core/customizer/ParameterSet.h
+++ b/src/core/customizer/ParameterSet.h
@@ -1,23 +1,21 @@
 #pragma once
 
+#include <boost/property_tree/ptree.hpp>
 #include <map>
 #include <string>
 #include <vector>
-#include <boost/property_tree/ptree.hpp>
 
-class ParameterSet : public std::map<std::string, boost::property_tree::ptree>
-{
+class ParameterSet : public std::map<std::string, boost::property_tree::ptree> {
 public:
-  [[nodiscard]] const std::string& name() const { return _name; }
-  void setName(const std::string& name) { _name = name; }
+  [[nodiscard]] const std::string &name() const { return _name; }
+  void setName(const std::string &name) { _name = name; }
 
 private:
   std::string _name;
 };
 
-class ParameterSets : public std::vector<ParameterSet>
-{
+class ParameterSets : public std::vector<ParameterSet> {
 public:
-  bool readFile(const std::string& filename);
-  void writeFile(const std::string& filename) const;
+  bool readFile(const std::string &filename);
+  void writeFile(const std::string &filename) const;
 };
diff --git a/src/core/enums.h b/src/core/enums.h
index 46a20e422..b2b845599 100644
--- a/src/core/enums.h
+++ b/src/core/enums.h
@@ -1,5 +1,5 @@
 #pragma once
-#undef DIFFERENCE //#defined in winuser.h
+#undef DIFFERENCE // #defined in winuser.h
 
 enum class OpenSCADOperator {
   UNION,
diff --git a/src/core/function.cc b/src/core/function.cc
index af785370a..90be48c1c 100644
--- a/src/core/function.cc
+++ b/src/core/function.cc
@@ -30,37 +30,40 @@
 #include "core/Arguments.h"
 #include "core/Expression.h"
 
-#include <ostream>
-#include <memory>
 #include <cstddef>
+#include <memory>
+#include <ostream>
 #include <utility>
 
-BuiltinFunction::BuiltinFunction(Value(*f)(const std::shared_ptr<const Context>&, const FunctionCall *), const Feature *feature) :
-  evaluate(f),
-  feature(feature)
-{}
+BuiltinFunction::BuiltinFunction(
+    Value (*f)(const std::shared_ptr<const Context> &, const FunctionCall *),
+    const Feature *feature)
+    : evaluate(f), feature(feature) {}
 
-BuiltinFunction::BuiltinFunction(Value(*f)(Arguments, const Location&), const Feature *feature) :
-  feature(feature)
-{
-  evaluate = [f] (const std::shared_ptr<const Context>& context, const FunctionCall *call) {
-      return f(Arguments(call->arguments, context), call->location());
-    };
+BuiltinFunction::BuiltinFunction(Value (*f)(Arguments, const Location &),
+                                 const Feature *feature)
+    : feature(feature) {
+  evaluate = [f](const std::shared_ptr<const Context> &context,
+                 const FunctionCall *call) {
+    return f(Arguments(call->arguments, context), call->location());
+  };
 }
 
-UserFunction::UserFunction(const char *name, AssignmentList& parameters, std::shared_ptr<Expression> expr, const Location& loc)
-  : ASTNode(loc), name(name), parameters(parameters), expr(std::move(expr))
-{
-}
+UserFunction::UserFunction(const char *name, AssignmentList &parameters,
+                           std::shared_ptr<Expression> expr,
+                           const Location &loc)
+    : ASTNode(loc), name(name), parameters(parameters), expr(std::move(expr)) {}
 
-void UserFunction::print(std::ostream& stream, const std::string& indent) const
-{
+void UserFunction::print(std::ostream &stream,
+                         const std::string &indent) const {
   stream << indent << "function " << name << "(";
   for (size_t i = 0; i < parameters.size(); ++i) {
-    const auto& parameter = parameters[i];
-    if (i > 0) stream << ", ";
+    const auto &parameter = parameters[i];
+    if (i > 0)
+      stream << ", ";
     stream << parameter->getName();
-    if (parameter->getExpr()) stream << " = " << *parameter->getExpr();
+    if (parameter->getExpr())
+      stream << " = " << *parameter->getExpr();
   }
   stream << ") = " << *expr << ";\n";
 }
diff --git a/src/core/function.h b/src/core/function.h
index 6cb6fb016..342076852 100644
--- a/src/core/function.h
+++ b/src/core/function.h
@@ -1,51 +1,57 @@
 #pragma once
 
+#include "Feature.h"
 #include "core/AST.h"
 #include "core/Assignment.h"
-#include "Feature.h"
 #include "core/Value.h"
 
-#include <ostream>
-#include <memory>
 #include <functional>
+#include <memory>
+#include <ostream>
 #include <string>
 #include <variant>
 
 class Arguments;
 class FunctionCall;
 
-class BuiltinFunction
-{
+class BuiltinFunction {
 public:
-  std::function<Value(const std::shared_ptr<const Context>&, const FunctionCall *)> evaluate;
+  std::function<Value(const std::shared_ptr<const Context> &,
+                      const FunctionCall *)>
+      evaluate;
 
 private:
   const Feature *feature;
 
 public:
-  BuiltinFunction(Value(*f)(const std::shared_ptr<const Context>&, const FunctionCall *), const Feature *feature = nullptr);
-  BuiltinFunction(Value(*f)(Arguments, const Location&), const Feature *feature = nullptr);
+  BuiltinFunction(Value (*f)(const std::shared_ptr<const Context> &,
+                             const FunctionCall *),
+                  const Feature *feature = nullptr);
+  BuiltinFunction(Value (*f)(Arguments, const Location &),
+                  const Feature *feature = nullptr);
 
   [[nodiscard]] bool is_experimental() const { return feature != nullptr; }
-  [[nodiscard]] bool is_enabled() const { return (feature == nullptr) || feature->is_enabled(); }
+  [[nodiscard]] bool is_enabled() const {
+    return (feature == nullptr) || feature->is_enabled();
+  }
 };
 
-class UserFunction : public ASTNode
-{
+class UserFunction : public ASTNode {
 public:
   std::string name;
   AssignmentList parameters;
   std::shared_ptr<Expression> expr;
 
-  UserFunction(const char *name, AssignmentList& parameters, std::shared_ptr<Expression> expr, const Location& loc);
+  UserFunction(const char *name, AssignmentList &parameters,
+               std::shared_ptr<Expression> expr, const Location &loc);
 
-  void print(std::ostream& stream, const std::string& indent) const override;
+  void print(std::ostream &stream, const std::string &indent) const override;
 };
 
-
-struct CallableUserFunction
-{
+struct CallableUserFunction {
   std::shared_ptr<const Context> defining_context;
   const UserFunction *function;
 };
-using CallableFunction = std::variant<const BuiltinFunction *, CallableUserFunction, Value, const Value *>;
+using CallableFunction =
+    std::variant<const BuiltinFunction *, CallableUserFunction, Value,
+                 const Value *>;
diff --git a/src/core/module.cc b/src/core/module.cc
index d5d57dd50..f772c774d 100644
--- a/src/core/module.cc
+++ b/src/core/module.cc
@@ -26,47 +26,58 @@
 
 #include "core/module.h"
 
-#include <utility>
-#include <string>
-#include <memory>
 #include "core/Arguments.h"
 #include "core/Children.h"
 #include "core/Context.h"
 #include "core/ModuleInstantiation.h"
+#include <memory>
+#include <string>
+#include <utility>
 
-BuiltinModule::BuiltinModule(std::shared_ptr<AbstractNode>(*instantiate)(const ModuleInstantiation *, const std::shared_ptr<const Context>&), const Feature *feature) :
-  AbstractModule(feature),
-  do_instantiate(instantiate)
-{}
+BuiltinModule::BuiltinModule(std::shared_ptr<AbstractNode> (*instantiate)(
+                                 const ModuleInstantiation *,
+                                 const std::shared_ptr<const Context> &),
+                             const Feature *feature)
+    : AbstractModule(feature), do_instantiate(instantiate) {}
 
-BuiltinModule::BuiltinModule(std::shared_ptr<AbstractNode>(*instantiate)(const ModuleInstantiation *, Arguments, const Children&), const Feature *feature) :
-  AbstractModule(feature)
-{
-  do_instantiate = [instantiate](const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context) {
-      return instantiate(inst, Arguments(inst->arguments, context), Children(&inst->scope, context));
-    };
+BuiltinModule::BuiltinModule(
+    std::shared_ptr<AbstractNode> (*instantiate)(const ModuleInstantiation *,
+                                                 Arguments, const Children &),
+    const Feature *feature)
+    : AbstractModule(feature) {
+  do_instantiate =
+      [instantiate](const ModuleInstantiation *inst,
+                    const std::shared_ptr<const Context> &context) {
+        return instantiate(inst, Arguments(inst->arguments, context),
+                           Children(&inst->scope, context));
+      };
 }
 
-BuiltinModule::BuiltinModule(std::shared_ptr<AbstractNode>(*instantiate)(const ModuleInstantiation *, Arguments), const Feature *feature) :
-  AbstractModule(feature)
-{
-  do_instantiate = [instantiate](const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context) {
-      Arguments arguments(inst->arguments, context);
-      noChildren(inst, arguments);
-      return instantiate(inst, std::move(arguments));
-    };
+BuiltinModule::BuiltinModule(std::shared_ptr<AbstractNode> (*instantiate)(
+                                 const ModuleInstantiation *, Arguments),
+                             const Feature *feature)
+    : AbstractModule(feature) {
+  do_instantiate =
+      [instantiate](const ModuleInstantiation *inst,
+                    const std::shared_ptr<const Context> &context) {
+        Arguments arguments(inst->arguments, context);
+        noChildren(inst, arguments);
+        return instantiate(inst, std::move(arguments));
+      };
 }
 
-
-std::shared_ptr<AbstractNode> BuiltinModule::instantiate(const std::shared_ptr<const Context>& /*defining_context*/, const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context) const
-{
+std::shared_ptr<AbstractNode> BuiltinModule::instantiate(
+    const std::shared_ptr<const Context> & /*defining_context*/,
+    const ModuleInstantiation *inst,
+    const std::shared_ptr<const Context> &context) const {
   return do_instantiate(inst, context);
 }
 
-void BuiltinModule::noChildren(const ModuleInstantiation *inst, Arguments& arguments, std::string auxmsg) {
+void BuiltinModule::noChildren(const ModuleInstantiation *inst,
+                               Arguments &arguments, std::string auxmsg) {
   if (inst->scope.hasChildren()) {
     LOG(message_group::Warning, inst->location(), arguments.documentRoot(),
         "module %1$s() does not support child modules%2$s%3$s", inst->name(),
-        auxmsg.size() != 0  ? " " : "", auxmsg);
+        auxmsg.size() != 0 ? " " : "", auxmsg);
   }
 }
diff --git a/src/core/module.h b/src/core/module.h
index 49d60236a..5750d9eaa 100644
--- a/src/core/module.h
+++ b/src/core/module.h
@@ -1,9 +1,9 @@
 #pragma once
 
-#include <string>
-#include <memory>
-#include <functional>
 #include "Feature.h"
+#include <functional>
+#include <memory>
+#include <string>
 
 class AbstractNode;
 class Arguments;
@@ -11,35 +11,53 @@ class Children;
 class Context;
 class ModuleInstantiation;
 
-class AbstractModule
-{
+class AbstractModule {
 private:
   const Feature *feature;
+
 public:
   AbstractModule() : feature(nullptr) {}
-  AbstractModule(const Feature& feature) : feature(&feature) {}
+  AbstractModule(const Feature &feature) : feature(&feature) {}
   AbstractModule(const Feature *feature) : feature(feature) {}
   virtual ~AbstractModule() = default;
-  [[nodiscard]] virtual bool is_experimental() const { return feature != nullptr; }
-  [[nodiscard]] virtual bool is_enabled() const { return (feature == nullptr) || feature->is_enabled(); }
-  virtual std::shared_ptr<AbstractNode> instantiate(const std::shared_ptr<const Context>& defining_context, const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context) const = 0;
+  [[nodiscard]] virtual bool is_experimental() const {
+    return feature != nullptr;
+  }
+  [[nodiscard]] virtual bool is_enabled() const {
+    return (feature == nullptr) || feature->is_enabled();
+  }
+  virtual std::shared_ptr<AbstractNode>
+  instantiate(const std::shared_ptr<const Context> &defining_context,
+              const ModuleInstantiation *inst,
+              const std::shared_ptr<const Context> &context) const = 0;
 };
 
-class BuiltinModule : public AbstractModule
-{
+class BuiltinModule : public AbstractModule {
 public:
-  BuiltinModule(std::shared_ptr<AbstractNode>(*instantiate)(const ModuleInstantiation *, const std::shared_ptr<const Context>&), const Feature *feature = nullptr);
-  BuiltinModule(std::shared_ptr<AbstractNode>(*instantiate)(const ModuleInstantiation *, Arguments, const Children&), const Feature *feature = nullptr);
-  BuiltinModule(std::shared_ptr<AbstractNode>(*instantiate)(const ModuleInstantiation *, Arguments), const Feature *feature = nullptr);
-  std::shared_ptr<AbstractNode> instantiate(const std::shared_ptr<const Context>& defining_context, const ModuleInstantiation *inst, const std::shared_ptr<const Context>& context) const override;
-  static void noChildren(const ModuleInstantiation *, Arguments&, std::string auxmsg = {});
+  BuiltinModule(std::shared_ptr<AbstractNode> (*instantiate)(
+                    const ModuleInstantiation *,
+                    const std::shared_ptr<const Context> &),
+                const Feature *feature = nullptr);
+  BuiltinModule(std::shared_ptr<AbstractNode> (*instantiate)(
+                    const ModuleInstantiation *, Arguments, const Children &),
+                const Feature *feature = nullptr);
+  BuiltinModule(std::shared_ptr<AbstractNode> (*instantiate)(
+                    const ModuleInstantiation *, Arguments),
+                const Feature *feature = nullptr);
+  std::shared_ptr<AbstractNode>
+  instantiate(const std::shared_ptr<const Context> &defining_context,
+              const ModuleInstantiation *inst,
+              const std::shared_ptr<const Context> &context) const override;
+  static void noChildren(const ModuleInstantiation *, Arguments &,
+                         std::string auxmsg = {});
 
 private:
-  std::function<std::shared_ptr<AbstractNode>(const ModuleInstantiation *, const std::shared_ptr<const Context>&)> do_instantiate;
+  std::function<std::shared_ptr<AbstractNode>(
+      const ModuleInstantiation *, const std::shared_ptr<const Context> &)>
+      do_instantiate;
 };
 
-struct InstantiableModule
-{
+struct InstantiableModule {
   std::shared_ptr<const Context> defining_context;
   const AbstractModule *module;
 };
diff --git a/src/core/node.cc b/src/core/node.cc
index 87ba927be..26493617d 100644
--- a/src/core/node.cc
+++ b/src/core/node.cc
@@ -29,35 +29,29 @@
 #include "core/ModuleInstantiation.h"
 #include "core/progress.h"
 
-#include <deque>
-#include <memory>
+#include <algorithm>
 #include <cstddef>
+#include <deque>
 #include <functional>
 #include <iostream>
-#include <algorithm>
+#include <memory>
 #include <string>
 
 size_t AbstractNode::idx_counter;
 
-AbstractNode::AbstractNode(const ModuleInstantiation *mi) :
-  modinst(mi),
-  idx(idx_counter++)
-{
-}
+AbstractNode::AbstractNode(const ModuleInstantiation *mi)
+    : modinst(mi), idx(idx_counter++) {}
 
-std::string AbstractNode::toString() const
-{
-  return this->name() + "()";
-}
+std::string AbstractNode::toString() const { return this->name() + "()"; }
 
-std::shared_ptr<const AbstractNode> AbstractNode::getNodeByID(int idx, std::deque<std::shared_ptr<const AbstractNode>>& path) const
-{
+std::shared_ptr<const AbstractNode> AbstractNode::getNodeByID(
+    int idx, std::deque<std::shared_ptr<const AbstractNode>> &path) const {
   auto self = shared_from_this();
   if (this->idx == idx) {
     path.push_back(self);
     return self;
   }
-  for (const auto& node : this->children) {
+  for (const auto &node : this->children) {
     auto res = node->getNodeByID(idx, path);
     if (res) {
       path.push_back(self);
@@ -67,16 +61,17 @@ std::shared_ptr<const AbstractNode> AbstractNode::getNodeByID(int idx, std::dequ
   return nullptr;
 }
 
-void AbstractNode::getCodeLocation(int currentLevel,  int includeLevel,
-                                   int *firstLine, int *firstColumn, int *lastLine, int *lastColumn,
-                                   int nestedModuleDepth) const
-{
+void AbstractNode::getCodeLocation(int currentLevel, int includeLevel,
+                                   int *firstLine, int *firstColumn,
+                                   int *lastLine, int *lastColumn,
+                                   int nestedModuleDepth) const {
   auto location = modinst->location();
   if (currentLevel >= includeLevel && nestedModuleDepth == 0) {
     if (*firstLine < 0 || *firstLine > location.firstLine()) {
       *firstLine = location.firstLine();
       *firstColumn = location.firstColumn();
-    } else if (*firstLine == location.firstLine() && *firstColumn > location.firstColumn()) {
+    } else if (*firstLine == location.firstLine() &&
+               *firstColumn > location.firstColumn()) {
       *firstColumn = location.firstColumn();
     }
 
@@ -87,13 +82,15 @@ void AbstractNode::getCodeLocation(int currentLevel,  int includeLevel,
       if (*firstLine < 0 || *firstLine > location.firstLine()) {
         *firstLine = location.firstLine();
         *firstColumn = location.firstColumn();
-      } else if (*firstLine == location.firstLine() && *firstColumn > location.firstColumn()) {
+      } else if (*firstLine == location.firstLine() &&
+                 *firstColumn > location.firstColumn()) {
         *firstColumn = location.firstColumn();
       }
       if (*lastLine < 0 || *lastLine < location.lastLine()) {
         *lastLine = location.lastLine();
         *lastColumn = location.lastColumn();
-      } else if (*lastLine == location.lastLine() && *lastColumn < location.lastColumn()) {
+      } else if (*lastLine == location.lastLine() &&
+                 *lastColumn < location.lastColumn()) {
         *lastColumn = location.lastColumn();
       }
     }
@@ -107,68 +104,55 @@ void AbstractNode::getCodeLocation(int currentLevel,  int includeLevel,
   }
 
   if (nestedModuleDepth >= 0) {
-    for (const auto& node : children) {
-      node->getCodeLocation(currentLevel + 1, includeLevel, firstLine,  firstColumn, lastLine,
-                            lastColumn, nestedModuleDepth);
+    for (const auto &node : children) {
+      node->getCodeLocation(currentLevel + 1, includeLevel, firstLine,
+                            firstColumn, lastLine, lastColumn,
+                            nestedModuleDepth);
     }
   }
 }
 
-void AbstractNode::findNodesWithSameMod(const std::shared_ptr<const AbstractNode>& node_mod,
-                                        std::vector<std::shared_ptr<const AbstractNode>>& nodes) const {
+void AbstractNode::findNodesWithSameMod(
+    const std::shared_ptr<const AbstractNode> &node_mod,
+    std::vector<std::shared_ptr<const AbstractNode>> &nodes) const {
   if (node_mod->modinst == modinst) {
     nodes.push_back(shared_from_this());
   }
-  for (const auto& step : children) {
+  for (const auto &step : children) {
     step->findNodesWithSameMod(node_mod, nodes);
   }
 }
 
-std::string GroupNode::name() const
-{
-  return "group";
-}
+std::string GroupNode::name() const { return "group"; }
 
-std::string GroupNode::verbose_name() const
-{
-  return this->_name;
-}
+std::string GroupNode::verbose_name() const { return this->_name; }
 
-std::string ListNode::name() const
-{
-  return "list";
-}
+std::string ListNode::name() const { return "list"; }
 
-std::string RootNode::name() const
-{
-  return "root";
-}
+std::string RootNode::name() const { return "root"; }
 
-std::string AbstractIntersectionNode::toString() const
-{
+std::string AbstractIntersectionNode::toString() const {
   return this->name() + "()";
 }
 
-std::string AbstractIntersectionNode::name() const
-{
+std::string AbstractIntersectionNode::name() const {
   // We write intersection here since the module will have to be evaluated
-  // before we get here and it will not longer retain the intersection_for parameters
+  // before we get here and it will not longer retain the intersection_for
+  // parameters
   return "intersection";
 }
 
-void AbstractNode::progress_prepare()
-{
-  std::for_each(this->children.begin(), this->children.end(), std::mem_fn(&AbstractNode::progress_prepare));
+void AbstractNode::progress_prepare() {
+  std::for_each(this->children.begin(), this->children.end(),
+                std::mem_fn(&AbstractNode::progress_prepare));
   this->progress_mark = ++progress_report_count;
 }
 
-void AbstractNode::progress_report() const
-{
+void AbstractNode::progress_report() const {
   progress_update(shared_from_this(), this->progress_mark);
 }
 
-std::ostream& operator<<(std::ostream& stream, const AbstractNode& node)
-{
+std::ostream &operator<<(std::ostream &stream, const AbstractNode &node) {
   stream << node.toString();
   return stream;
 }
@@ -176,29 +160,33 @@ std::ostream& operator<<(std::ostream& stream, const AbstractNode& node)
 /*!
    Locates and returns the node containing a root modifier (!).
    Returns nullptr if no root modifier was found.
-   If a second root modifier was found, nextLocation (if non-zero) will be set to point to
-   the location of that second modifier.
+   If a second root modifier was found, nextLocation (if non-zero) will be set
+   to point to the location of that second modifier.
  */
-std::shared_ptr<AbstractNode> find_root_tag(const std::shared_ptr<AbstractNode>& node, const Location **nextLocation)
-{
+std::shared_ptr<AbstractNode>
+find_root_tag(const std::shared_ptr<AbstractNode> &node,
+              const Location **nextLocation) {
   std::shared_ptr<AbstractNode> rootTag;
 
-  std::function<void (const std::shared_ptr<const AbstractNode>&)> recursive_find_tag = [&](const std::shared_ptr<const AbstractNode>& node) {
-      for (const auto& child : node->children) {
-        if (child->modinst->tag_root) {
-          if (!rootTag) {
-            rootTag = child;
-            // shortcut if we're not interested in further root modifiers
-            if (!nextLocation) return;
-          } else if (nextLocation && rootTag->modinst != child->modinst) {
-            // Throw if we have more than one root modifier in the source
-            *nextLocation = &child->modinst->location();
-            return;
-          }
-        }
-        recursive_find_tag(child);
-      }
-    };
+  std::function<void(const std::shared_ptr<const AbstractNode> &)>
+      recursive_find_tag =
+          [&](const std::shared_ptr<const AbstractNode> &node) {
+            for (const auto &child : node->children) {
+              if (child->modinst->tag_root) {
+                if (!rootTag) {
+                  rootTag = child;
+                  // shortcut if we're not interested in further root modifiers
+                  if (!nextLocation)
+                    return;
+                } else if (nextLocation && rootTag->modinst != child->modinst) {
+                  // Throw if we have more than one root modifier in the source
+                  *nextLocation = &child->modinst->location();
+                  return;
+                }
+              }
+              recursive_find_tag(child);
+            }
+          };
 
   recursive_find_tag(node);
 
diff --git a/src/core/node.h b/src/core/node.h
index 070abb0e2..e407379e0 100644
--- a/src/core/node.h
+++ b/src/core/node.h
@@ -1,22 +1,27 @@
 #pragma once
 
-#include <ostream>
-#include <memory>
 #include <cstddef>
+#include <deque>
+#include <memory>
+#include <ostream>
+#include <string>
 #include <utility>
 #include <vector>
-#include <string>
-#include <deque>
 
-#include "core/BaseVisitable.h"
 #include "core/AST.h"
+#include "core/BaseVisitable.h"
 #include "core/ModuleInstantiation.h"
 
 extern int progress_report_count;
-extern void (*progress_report_f)(const std::shared_ptr<const AbstractNode>&, void *, int);
+extern void (*progress_report_f)(const std::shared_ptr<const AbstractNode> &,
+                                 void *, int);
 extern void *progress_report_vp;
 
-void progress_report_prep(const std::shared_ptr<AbstractNode>& root, void (*f)(const std::shared_ptr<const AbstractNode>& node, void *vp, int mark), void *vp);
+void progress_report_prep(
+    const std::shared_ptr<AbstractNode> &root,
+    void (*f)(const std::shared_ptr<const AbstractNode> &node, void *vp,
+              int mark),
+    void *vp);
 void progress_report_fin();
 
 /*!
@@ -26,8 +31,8 @@ void progress_report_fin();
    scratch for each compile.
 
  */
-class AbstractNode : public BaseVisitable, public std::enable_shared_from_this<AbstractNode>
-{
+class AbstractNode : public BaseVisitable,
+                     public std::enable_shared_from_this<AbstractNode> {
   // FIXME: the idx_counter/idx is mostly (only?) for debugging.
   // We can hash on pointer value or smth. else.
   //  -> remove and
@@ -38,15 +43,15 @@ public:
   AbstractNode(const ModuleInstantiation *mi);
   virtual std::string toString() const;
   /*! The 'OpenSCAD name' of this node, defaults to classname, but can be
-      overloaded to provide specialization for e.g. CSG nodes, primitive nodes etc.
-      Used for human-readable output. */
+      overloaded to provide specialization for e.g. CSG nodes, primitive nodes
+     etc. Used for human-readable output. */
   virtual std::string name() const = 0;
 
-  /*| When a more specific name for user interaction shall be used, such as module names,
-      the verbose name shall be overloaded. */
+  /*| When a more specific name for user interaction shall be used, such as
+     module names, the verbose name shall be overloaded. */
   virtual std::string verbose_name() const { return this->name(); }
 
-  const std::vector<std::shared_ptr<AbstractNode>>& getChildren() const {
+  const std::vector<std::shared_ptr<AbstractNode>> &getChildren() const {
     return this->children;
   }
   size_t index() const { return this->idx; }
@@ -65,48 +70,46 @@ public:
 
   int idx; // Node index (unique per tree)
 
-  std::shared_ptr<const AbstractNode> getNodeByID(int idx, std::deque<std::shared_ptr<const AbstractNode>>& path) const;
+  std::shared_ptr<const AbstractNode>
+  getNodeByID(int idx,
+              std::deque<std::shared_ptr<const AbstractNode>> &path) const;
 
   // returns the precise source code location associated with the node
-  void getCodeLocation(int currentLevel,  int includeLevel, int *firstLine,
-                       int *firstColumn, int *lastLine, int *lastColumn, int nestedModuleDepth) const;
+  void getCodeLocation(int currentLevel, int includeLevel, int *firstLine,
+                       int *firstColumn, int *lastLine, int *lastColumn,
+                       int nestedModuleDepth) const;
 
-  void findNodesWithSameMod(const std::shared_ptr<const AbstractNode>& node_mod,
-                            std::vector<std::shared_ptr<const AbstractNode>>& nodes) const;
+  void findNodesWithSameMod(
+      const std::shared_ptr<const AbstractNode> &node_mod,
+      std::vector<std::shared_ptr<const AbstractNode>> &nodes) const;
 
   std::shared_ptr<AbstractNode> clone(void);
 };
 
-class AbstractIntersectionNode : public AbstractNode
-{
+class AbstractIntersectionNode : public AbstractNode {
 public:
   VISITABLE();
-  AbstractIntersectionNode(const ModuleInstantiation *mi) : AbstractNode(mi) { }
+  AbstractIntersectionNode(const ModuleInstantiation *mi) : AbstractNode(mi) {}
   std::string toString() const override;
   std::string name() const override;
 };
 
-class AbstractPolyNode : public AbstractNode
-{
+class AbstractPolyNode : public AbstractNode {
 public:
   VISITABLE();
-  AbstractPolyNode(const ModuleInstantiation *mi) : AbstractNode(mi) { }
+  AbstractPolyNode(const ModuleInstantiation *mi) : AbstractNode(mi) {}
 
-  enum class render_mode_e {
-    RENDER_CGAL,
-    RENDER_OPENCSG
-  };
+  enum class render_mode_e { RENDER_CGAL, RENDER_OPENCSG };
 };
 
 /*!
    Used for organizing objects into lists which should not be grouped but merely
    unpacked by the parent node.
  */
-class ListNode : public AbstractNode
-{
+class ListNode : public AbstractNode {
 public:
   VISITABLE();
-  ListNode(const ModuleInstantiation *mi) : AbstractNode(mi) { }
+  ListNode(const ModuleInstantiation *mi) : AbstractNode(mi) {}
   std::string name() const override;
 };
 
@@ -114,13 +117,14 @@ public:
    Logically groups objects together. Used as a way of passing
    objects around without having to perform unions on them.
  */
-class GroupNode : public AbstractNode
-{
+class GroupNode : public AbstractNode {
 public:
   VISITABLE();
-  GroupNode(const ModuleInstantiation *mi, std::string name = "") : AbstractNode(mi), _name(std::move(name)) { }
+  GroupNode(const ModuleInstantiation *mi, std::string name = "")
+      : AbstractNode(mi), _name(std::move(name)) {}
   std::string name() const override;
   std::string verbose_name() const override;
+
 private:
   const std::string _name;
 };
@@ -128,23 +132,24 @@ private:
 /*!
    Only instantiated once, for the top-level file.
  */
-class RootNode : public GroupNode
-{
+class RootNode : public GroupNode {
 public:
   VISITABLE();
-  RootNode() : GroupNode(&mi), mi("group") { }
+  RootNode() : GroupNode(&mi), mi("group") {}
   std::string name() const override;
+
 private:
   ModuleInstantiation mi;
 };
 
-class LeafNode : public AbstractPolyNode
-{
+class LeafNode : public AbstractPolyNode {
 public:
   VISITABLE();
-  LeafNode(const ModuleInstantiation *mi) : AbstractPolyNode(mi) { }
+  LeafNode(const ModuleInstantiation *mi) : AbstractPolyNode(mi) {}
   virtual std::unique_ptr<const class Geometry> createGeometry() const = 0;
 };
 
-std::ostream& operator<<(std::ostream& stream, const AbstractNode& node);
-std::shared_ptr<AbstractNode> find_root_tag(const std::shared_ptr<AbstractNode>& node, const Location **nextLocation = nullptr);
+std::ostream &operator<<(std::ostream &stream, const AbstractNode &node);
+std::shared_ptr<AbstractNode>
+find_root_tag(const std::shared_ptr<AbstractNode> &node,
+              const Location **nextLocation = nullptr);
diff --git a/src/core/node_clone.cc b/src/core/node_clone.cc
index b383f13a3..d29fb3e78 100644
--- a/src/core/node_clone.cc
+++ b/src/core/node_clone.cc
@@ -24,89 +24,74 @@
  *
  */
 
-#include "geometry/linalg.h"
-#include "geometry/GeometryUtils.h"
-#include "core/primitives.h"
-#include "core/TransformNode.h"
-#include "core/RotateExtrudeNode.h"
-#include "core/LinearExtrudeNode.h"
 #include "core/CgalAdvNode.h"
-#include "core/CsgOpNode.h"
 #include "core/ColorNode.h"
-#include "core/RoofNode.h"
+#include "core/CsgOpNode.h"
+#include "core/ImportNode.h"
+#include "core/LinearExtrudeNode.h"
+#include "core/OffsetNode.h"
+#include "core/ProjectionNode.h"
 #include "core/RenderNode.h"
+#include "core/RoofNode.h"
+#include "core/RotateExtrudeNode.h"
 #include "core/SurfaceNode.h"
 #include "core/TextNode.h"
-#include "core/OffsetNode.h"
-#include "core/ProjectionNode.h"
-#include "core/ImportNode.h"
+#include "core/TransformNode.h"
+#include "core/primitives.h"
+#include "geometry/GeometryUtils.h"
+#include "geometry/linalg.h"
 
 std::vector<ModuleInstantiation *> modinsts_list;
 
-#define NodeCloneFunc(T) std::shared_ptr<T> clone_what(const T * node) { \
-          ModuleInstantiation *inst = new ModuleInstantiation(node->modinst->name(), \
-                                                              node->modinst->arguments, node->modinst->location()); \
-          modinsts_list.push_back(inst); \
-          auto clone = std::make_shared<T>(*node); \
-          clone->modinst = inst; \
-          return clone; \
-}
+#define NodeCloneFunc(T)                                                       \
+  std::shared_ptr<T> clone_what(const T *node) {                               \
+    ModuleInstantiation *inst = new ModuleInstantiation(                       \
+        node->modinst->name(), node->modinst->arguments,                       \
+        node->modinst->location());                                            \
+    modinsts_list.push_back(inst);                                             \
+    auto clone = std::make_shared<T>(*node);                                   \
+    clone->modinst = inst;                                                     \
+    return clone;                                                              \
+  }
 
-#define NodeCloneUse(T) { const T *node = dynamic_cast<const T *>(this); if ((node) != nullptr) clone = clone_what(node); }
-NodeCloneFunc(CubeNode)
-NodeCloneFunc(SphereNode)
-NodeCloneFunc(CylinderNode)
-NodeCloneFunc(PolyhedronNode)
-NodeCloneFunc(SquareNode)
-NodeCloneFunc(CircleNode)
-NodeCloneFunc(PolygonNode)
-NodeCloneFunc(TransformNode)
-NodeCloneFunc(ColorNode)
-NodeCloneFunc(RotateExtrudeNode)
-NodeCloneFunc(LinearExtrudeNode)
-NodeCloneFunc(CsgOpNode)
-NodeCloneFunc(CgalAdvNode)
-NodeCloneFunc(RenderNode)
-NodeCloneFunc(SurfaceNode)
-NodeCloneFunc(TextNode)
-NodeCloneFunc(OffsetNode)
-NodeCloneFunc(ProjectionNode)
-NodeCloneFunc(GroupNode)
-NodeCloneFunc(ImportNode)
+#define NodeCloneUse(T)                                                        \
+  {                                                                            \
+    const T *node = dynamic_cast<const T *>(this);                             \
+    if ((node) != nullptr)                                                     \
+      clone = clone_what(node);                                                \
+  }
+NodeCloneFunc(CubeNode) NodeCloneFunc(SphereNode) NodeCloneFunc(
+    CylinderNode) NodeCloneFunc(PolyhedronNode) NodeCloneFunc(SquareNode)
+    NodeCloneFunc(CircleNode) NodeCloneFunc(PolygonNode) NodeCloneFunc(
+        TransformNode) NodeCloneFunc(ColorNode) NodeCloneFunc(RotateExtrudeNode)
+        NodeCloneFunc(LinearExtrudeNode) NodeCloneFunc(CsgOpNode) NodeCloneFunc(
+            CgalAdvNode) NodeCloneFunc(RenderNode) NodeCloneFunc(SurfaceNode)
+            NodeCloneFunc(TextNode) NodeCloneFunc(OffsetNode)
+                NodeCloneFunc(ProjectionNode) NodeCloneFunc(GroupNode)
+                    NodeCloneFunc(ImportNode)
 #if defined(ENABLE_EXPERIMENTAL) && defined(ENABLE_CGAL)
-NodeCloneFunc(RoofNode)
+                        NodeCloneFunc(RoofNode)
 #endif
 
-std::shared_ptr<AbstractNode> AbstractNode::clone(void)
-{
+                            std::shared_ptr<AbstractNode> AbstractNode::clone(
+                                void) {
   std::shared_ptr<AbstractNode> clone = nullptr;
-  NodeCloneUse(CubeNode)
-  NodeCloneUse(SphereNode)
-  NodeCloneUse(CylinderNode)
-  NodeCloneUse(PolyhedronNode)
-  NodeCloneUse(SquareNode)
-  NodeCloneUse(CircleNode)
-  NodeCloneUse(PolygonNode)
-  NodeCloneUse(TransformNode)
-  NodeCloneUse(ColorNode)
-  NodeCloneUse(RotateExtrudeNode)
-  NodeCloneUse(LinearExtrudeNode)
-  NodeCloneUse(CsgOpNode)
-  NodeCloneUse(CgalAdvNode)
-  NodeCloneUse(RenderNode)
-  NodeCloneUse(SurfaceNode)
-  NodeCloneUse(TextNode)
-  NodeCloneUse(OffsetNode)
-  NodeCloneUse(ProjectionNode)
-  NodeCloneUse(GroupNode)
-  NodeCloneUse(ImportNode)
+  NodeCloneUse(CubeNode) NodeCloneUse(SphereNode) NodeCloneUse(CylinderNode)
+      NodeCloneUse(PolyhedronNode) NodeCloneUse(SquareNode) NodeCloneUse(
+          CircleNode) NodeCloneUse(PolygonNode) NodeCloneUse(TransformNode)
+          NodeCloneUse(ColorNode) NodeCloneUse(RotateExtrudeNode)
+              NodeCloneUse(LinearExtrudeNode) NodeCloneUse(CsgOpNode)
+                  NodeCloneUse(CgalAdvNode) NodeCloneUse(RenderNode)
+                      NodeCloneUse(SurfaceNode) NodeCloneUse(TextNode)
+                          NodeCloneUse(OffsetNode) NodeCloneUse(ProjectionNode)
+                              NodeCloneUse(GroupNode) NodeCloneUse(ImportNode)
 #if defined(ENABLE_EXPERIMENTAL) && defined(ENABLE_CGAL)
-  NodeCloneUse(RoofNode)
+                                  NodeCloneUse(RoofNode)
 #endif
-  if (clone != nullptr) {
+                                      if (clone != nullptr) {
     clone->idx = idx_counter++;
     clone->children.clear();
-    for (const auto& child: this->children) {
+    for (const auto &child : this->children) {
       clone->children.push_back(child->clone());
     }
     return clone;
diff --git a/src/core/parsersettings.cc b/src/core/parsersettings.cc
index 2a867fdb6..dbc834d94 100644
--- a/src/core/parsersettings.cc
+++ b/src/core/parsersettings.cc
@@ -1,36 +1,32 @@
 #include "core/parsersettings.h"
 
 #include <algorithm>
-#include <iterator>
 #include <cassert>
+#include <iterator>
 #include <string>
 #include <vector>
 
-#include <filesystem>
-#include <boost/algorithm/string.hpp>
 #include "platform/PlatformUtils.h"
+#include <boost/algorithm/string.hpp>
+#include <filesystem>
 
 namespace fs = std::filesystem;
 
 std::vector<std::string> librarypath;
 
-static void add_librarydir(const std::string& libdir)
-{
+static void add_librarydir(const std::string &libdir) {
   librarypath.push_back(libdir);
 }
 
-const std::vector<std::string>& get_library_path()
-{
-  return librarypath;
-}
+const std::vector<std::string> &get_library_path() { return librarypath; }
 
 /*!
-   Searces for the given file in library paths and returns the full path if found.
-   Returns an empty path if file cannot be found or filename is a directory.
+   Searces for the given file in library paths and returns the full path if
+   found. Returns an empty path if file cannot be found or filename is a
+   directory.
  */
-fs::path search_libs(const fs::path& localpath)
-{
-  for (const auto& dir : librarypath) {
+fs::path search_libs(const fs::path &localpath) {
+  for (const auto &dir : librarypath) {
     fs::path usepath = fs::path(dir) / localpath;
     if (fs::exists(usepath) && !fs::is_directory(usepath)) {
       return usepath.string();
@@ -40,10 +36,10 @@ fs::path search_libs(const fs::path& localpath)
 }
 
 // files must be 'ordinary' - they must exist and be non-directories
-// FIXME: We cannot print any output here since these function is called periodically
-// from "Automatic reload and compile"
-static bool check_valid(const fs::path& p, const std::vector<std::string> *openfilenames)
-{
+// FIXME: We cannot print any output here since these function is called
+// periodically from "Automatic reload and compile"
+static bool check_valid(const fs::path &p,
+                        const std::vector<std::string> *openfilenames) {
   if (p.empty()) {
     // LOG(message_group::Warning,,"File path is blank: %1$s",p);
     return false;
@@ -60,10 +56,10 @@ static bool check_valid(const fs::path& p, const std::vector<std::string> *openf
     // LOG(message_group::Warning,,"%1$s invalid - points to a directory",p);
     return false;
   }
-  const std::string& fullname = p.generic_string();
+  const std::string &fullname = p.generic_string();
   // Detect circular includes
   if (openfilenames) {
-    for (const auto& s : *openfilenames) {
+    for (const auto &s : *openfilenames) {
       if (s == fullname) {
         // LOG(message_group::Warning,,"circular include file %1$s",fullname);
         return false;
@@ -82,10 +78,9 @@ static bool check_valid(const fs::path& p, const std::vector<std::string> *openf
    Returns the absolute path to a valid file, or an empty path if no
    valid files could be found.
  */
-inline fs::path find_valid_path_(const fs::path& sourcepath,
-                                 const fs::path& localpath,
-                                 const std::vector<std::string> *openfilenames)
-{
+inline fs::path
+find_valid_path_(const fs::path &sourcepath, const fs::path &localpath,
+                 const std::vector<std::string> *openfilenames) {
   if (localpath.is_absolute()) {
     if (check_valid(localpath, openfilenames)) {
 #ifndef __EMSCRIPTEN__
@@ -97,30 +92,31 @@ inline fs::path find_valid_path_(const fs::path& sourcepath,
   } else {
     fs::path fpath = sourcepath / localpath;
 #ifndef __EMSCRIPTEN__
-    if (fs::exists(fpath)) fpath = fs::canonical(fpath);
+    if (fs::exists(fpath))
+      fpath = fs::canonical(fpath);
 #endif
-    if (check_valid(fpath, openfilenames)) return fpath;
+    if (check_valid(fpath, openfilenames))
+      return fpath;
     fpath = search_libs(localpath);
-    if (!fpath.empty() && check_valid(fpath, openfilenames)) return fpath;
+    if (!fpath.empty() && check_valid(fpath, openfilenames))
+      return fpath;
   }
   return {};
 }
 
-fs::path find_valid_path(const fs::path& sourcepath,
-                         const fs::path& localpath,
-                         const std::vector<std::string> *openfilenames)
-{
-  return {find_valid_path_(sourcepath, localpath, openfilenames).generic_string()};
+fs::path find_valid_path(const fs::path &sourcepath, const fs::path &localpath,
+                         const std::vector<std::string> *openfilenames) {
+  return {
+      find_valid_path_(sourcepath, localpath, openfilenames).generic_string()};
 }
 
-
-static bool path_contains_file(fs::path dir, fs::path file)
-{
+static bool path_contains_file(fs::path dir, fs::path file) {
   // from https://stackoverflow.com/a/15549954/1080604
   // If dir ends with "/" and isn't the root directory, then the final
   // component returned by iterators will include "." and will interfere
   // with the std::equal check below, so we strip it before proceeding.
-  if (dir.filename() == ".") dir.remove_filename();
+  if (dir.filename() == ".")
+    dir.remove_filename();
   // We're also not interested in the file's name.
   assert(file.has_filename());
   file.remove_filename();
@@ -129,16 +125,16 @@ static bool path_contains_file(fs::path dir, fs::path file)
   // reside in dir.
   auto dir_len = std::distance(dir.begin(), dir.end());
   auto file_len = std::distance(file.begin(), file.end());
-  if (dir_len > file_len) return false;
+  if (dir_len > file_len)
+    return false;
 
   // This stops checking when it reaches dir.end(), so it's OK if file
   // has more directory components afterward. They won't be checked.
   return std::equal(dir.begin(), dir.end(), file.begin());
 }
 
-fs::path get_library_for_path(const fs::path& localpath)
-{
-  for (const auto& libpath : librarypath) {
+fs::path get_library_for_path(const fs::path &localpath) {
+  for (const auto &libpath : librarypath) {
     if (path_contains_file(fs::path(libpath), localpath)) {
       return libpath;
     }
@@ -146,18 +142,19 @@ fs::path get_library_for_path(const fs::path& localpath)
   return {};
 }
 
-
-void parser_init()
-{
+void parser_init() {
   // Add paths from OPENSCADPATH before adding built-in paths
   const char *openscadpaths = getenv("OPENSCADPATH");
   if (openscadpaths) {
     std::string paths(openscadpaths);
     std::string sep = PlatformUtils::pathSeparatorChar();
     using string_split_iterator = boost::split_iterator<std::string::iterator>;
-    for (string_split_iterator it = boost::make_split_iterator(paths, boost::first_finder(sep, boost::is_iequal())); it != string_split_iterator(); ++it) {
+    for (string_split_iterator it = boost::make_split_iterator(
+             paths, boost::first_finder(sep, boost::is_iequal()));
+         it != string_split_iterator(); ++it) {
       auto str{boost::copy_range<std::string>(*it)};
-      fs::path abspath = str.empty() ? fs::current_path() : fs::absolute(fs::path(str));
+      fs::path abspath =
+          str.empty() ? fs::current_path() : fs::absolute(fs::path(str));
       add_librarydir(abspath.generic_string());
     }
   }
diff --git a/src/core/parsersettings.h b/src/core/parsersettings.h
index 7ae3a9a5e..1d9b00c92 100644
--- a/src/core/parsersettings.h
+++ b/src/core/parsersettings.h
@@ -1,8 +1,8 @@
 #pragma once
 
+#include <filesystem>
 #include <string>
 #include <vector>
-#include <filesystem>
 
 namespace fs = std::filesystem;
 
@@ -13,10 +13,10 @@ extern int parser_error_pos;
  */
 void parser_init();
 
-fs::path search_libs(const fs::path& localpath);
-fs::path find_valid_path(const fs::path& sourcepath,
-                         const fs::path& localpath,
-                         const std::vector<std::string> *openfilenames = nullptr);
-fs::path get_library_for_path(const fs::path& localpath);
+fs::path search_libs(const fs::path &localpath);
+fs::path
+find_valid_path(const fs::path &sourcepath, const fs::path &localpath,
+                const std::vector<std::string> *openfilenames = nullptr);
+fs::path get_library_for_path(const fs::path &localpath);
 
-const std::vector<std::string>& get_library_path();
\ No newline at end of file
+const std::vector<std::string> &get_library_path();
\ No newline at end of file
diff --git a/src/core/primitives.cc b/src/core/primitives.cc
index 3db0f7aba..491aad11d 100644
--- a/src/core/primitives.cc
+++ b/src/core/primitives.cc
@@ -25,29 +25,29 @@
  */
 
 #include "core/primitives.h"
-#include "geometry/Geometry.h"
-#include "geometry/linalg.h"
 #include "core/Builtins.h"
 #include "core/Children.h"
 #include "core/ModuleInstantiation.h"
 #include "core/Parameters.h"
+#include "core/module.h"
+#include "core/node.h"
+#include "geometry/Geometry.h"
 #include "geometry/PolySet.h"
 #include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 #include "utils/calc.h"
-#include "core/node.h"
 #include "utils/degree_trig.h"
-#include "core/module.h"
 #include "utils/printutils.h"
 #include <algorithm>
-#include <utility>
 #include <boost/assign/std/vector.hpp>
 #include <cassert>
-#include <cstddef>
 #include <cmath>
+#include <cstddef>
 #include <iterator>
 #include <memory>
 #include <sstream>
 #include <string>
+#include <utility>
 #include <vector>
 
 using namespace boost::assign; // bring 'operator+=()' into scope
@@ -55,10 +55,11 @@ using namespace boost::assign; // bring 'operator+=()' into scope
 #define F_MINIMUM 0.01
 
 template <class InsertIterator>
-static void generate_circle(InsertIterator iter, double r, double z, int fragments) {
+static void generate_circle(InsertIterator iter, double r, double z,
+                            int fragments) {
   for (int i = 0; i < fragments; ++i) {
     double phi = (360.0 * i) / fragments;
-    *(iter++) = {r *cos_degrees(phi), r *sin_degrees(phi), z};
+    *(iter++) = {r * cos_degrees(phi), r * sin_degrees(phi), z};
   }
 }
 
@@ -71,13 +72,15 @@ static void generate_circle(InsertIterator iter, double r, double z, int fragmen
  * @param inst containing instantiation.
  * @param radius_var name of the variable to lookup for the radius value.
  * @param diameter_var name of the variable to lookup for the diameter value.
- * @return radius value of type Value::Type::NUMBER or Value::Type::UNDEFINED if both
- *         variables are invalid or not set.
+ * @return radius value of type Value::Type::NUMBER or Value::Type::UNDEFINED if
+ * both variables are invalid or not set.
  */
-static Value lookup_radius(const Parameters& parameters, const ModuleInstantiation *inst, const std::string& diameter_var, const std::string& radius_var)
-{
-  const auto& d = parameters[diameter_var];
-  const auto& r = parameters[radius_var];
+static Value lookup_radius(const Parameters &parameters,
+                           const ModuleInstantiation *inst,
+                           const std::string &diameter_var,
+                           const std::string &radius_var) {
+  const auto &d = parameters[diameter_var];
+  const auto &r = parameters[radius_var];
   const auto r_defined = (r.type() == Value::Type::NUMBER);
 
   if (d.type() == Value::Type::NUMBER) {
@@ -94,8 +97,9 @@ static Value lookup_radius(const Parameters& parameters, const ModuleInstantiati
   }
 }
 
-static void set_fragments(const Parameters& parameters, const ModuleInstantiation *inst, double& fn, double& fs, double& fa)
-{
+static void set_fragments(const Parameters &parameters,
+                          const ModuleInstantiation *inst, double &fn,
+                          double &fs, double &fa) {
   fn = parameters["$fn"].toDouble();
   fs = parameters["$fs"].toDouble();
   fa = parameters["$fa"].toDouble();
@@ -112,14 +116,9 @@ static void set_fragments(const Parameters& parameters, const ModuleInstantiatio
   }
 }
 
-
-
-std::unique_ptr<const Geometry> CubeNode::createGeometry() const
-{
-  if (this->x <= 0 || !std::isfinite(this->x)
-      || this->y <= 0 || !std::isfinite(this->y)
-      || this->z <= 0 || !std::isfinite(this->z)
-      ) {
+std::unique_ptr<const Geometry> CubeNode::createGeometry() const {
+  if (this->x <= 0 || !std::isfinite(this->x) || this->y <= 0 ||
+      !std::isfinite(this->y) || this->z <= 0 || !std::isfinite(this->z)) {
     return PolySet::createEmpty();
   }
 
@@ -143,24 +142,25 @@ std::unique_ptr<const Geometry> CubeNode::createGeometry() const
                               i & 4 ? z2 : z1);
   }
   ps->indices = {
-    {4, 5, 7, 6},   // top
-    {2, 3, 1, 0},   // bottom
-    {0, 1, 5, 4},   // front
-    {1, 3, 7, 5},   // right
-    {3, 2, 6, 7},   // back
-    {2, 0, 4, 6},   // left
+      {4, 5, 7, 6}, // top
+      {2, 3, 1, 0}, // bottom
+      {0, 1, 5, 4}, // front
+      {1, 3, 7, 5}, // right
+      {3, 2, 6, 7}, // back
+      {2, 0, 4, 6}, // left
   };
 
   return ps;
 }
 
-static std::shared_ptr<AbstractNode> builtin_cube(const ModuleInstantiation *inst, Arguments arguments)
-{
+static std::shared_ptr<AbstractNode>
+builtin_cube(const ModuleInstantiation *inst, Arguments arguments) {
   auto node = std::make_shared<CubeNode>(inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"size", "center"});
+  Parameters parameters = Parameters::parse(
+      std::move(arguments), inst->location(), {"size", "center"});
 
-  const auto& size = parameters["size"];
+  const auto &size = parameters["size"];
   if (size.isDefined()) {
     bool converted = false;
     converted |= size.getDouble(node->x);
@@ -168,12 +168,17 @@ static std::shared_ptr<AbstractNode> builtin_cube(const ModuleInstantiation *ins
     converted |= size.getDouble(node->z);
     converted |= size.getVec3(node->x, node->y, node->z);
     if (!converted) {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Unable to convert cube(size=%1$s, ...) parameter to a number or a vec3 of numbers", size.toEchoStringNoThrow());
+      LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+          "Unable to convert cube(size=%1$s, ...) parameter to a number or a "
+          "vec3 of numbers",
+          size.toEchoStringNoThrow());
     } else if (OpenSCAD::rangeCheck) {
       bool ok = (node->x > 0) && (node->y > 0) && (node->z > 0);
-      ok &= std::isfinite(node->x) && std::isfinite(node->y) && std::isfinite(node->z);
+      ok &= std::isfinite(node->x) && std::isfinite(node->y) &&
+            std::isfinite(node->z);
       if (!ok) {
-        LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "cube(size=%1$s, ...)", size.toEchoStringNoThrow());
+        LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+            "cube(size=%1$s, ...)", size.toEchoStringNoThrow());
       }
     }
   }
@@ -184,8 +189,7 @@ static std::shared_ptr<AbstractNode> builtin_cube(const ModuleInstantiation *ins
   return node;
 }
 
-std::unique_ptr<const Geometry> SphereNode::createGeometry() const
-{
+std::unique_ptr<const Geometry> SphereNode::createGeometry() const {
   if (this->r <= 0 || !std::isfinite(this->r)) {
     return PolySet::createEmpty();
   }
@@ -194,8 +198,8 @@ std::unique_ptr<const Geometry> SphereNode::createGeometry() const
   size_t num_rings = (num_fragments + 1) / 2;
   // Uncomment the following three lines to enable experimental sphere
   // tessellation
-  //  if (num_rings % 2 == 0) num_rings++; // To ensure that the middle ring is at
-  //  phi == 0 degrees
+  //  if (num_rings % 2 == 0) num_rings++; // To ensure that the middle ring is
+  //  at phi == 0 degrees
 
   auto polyset = std::make_unique<PolySet>(3, /*convex*/ true);
   polyset->vertices.reserve(num_rings * num_fragments);
@@ -205,7 +209,8 @@ std::unique_ptr<const Geometry> SphereNode::createGeometry() const
     //                double phi = (180.0 * (i + offset)) / (fragments/2);
     const double phi = (180.0 * (i + 0.5)) / num_rings;
     const double radius = r * sin_degrees(phi);
-    generate_circle(std::back_inserter(polyset->vertices), radius, r * cos_degrees(phi), num_fragments);
+    generate_circle(std::back_inserter(polyset->vertices), radius,
+                    r * cos_degrees(phi), num_fragments);
   }
 
   polyset->indices.push_back({});
@@ -216,10 +221,10 @@ std::unique_ptr<const Geometry> SphereNode::createGeometry() const
   for (int i = 0; i < num_rings - 1; ++i) {
     for (int r = 0; r < num_fragments; ++r) {
       polyset->indices.push_back({
-        i *num_fragments + (r + 1) % num_fragments,
-        i * num_fragments + r,
-        (i + 1) * num_fragments + r,
-        (i + 1) * num_fragments + (r + 1) % num_fragments,
+          i * num_fragments + (r + 1) % num_fragments,
+          i * num_fragments + r,
+          (i + 1) * num_fragments + r,
+          (i + 1) * num_fragments + (r + 1) % num_fragments,
       });
     }
   }
@@ -232,11 +237,12 @@ std::unique_ptr<const Geometry> SphereNode::createGeometry() const
   return polyset;
 }
 
-static std::shared_ptr<AbstractNode> builtin_sphere(const ModuleInstantiation *inst, Arguments arguments)
-{
+static std::shared_ptr<AbstractNode>
+builtin_sphere(const ModuleInstantiation *inst, Arguments arguments) {
   auto node = std::make_shared<SphereNode>(inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"r"}, {"d"});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {"r"}, {"d"});
 
   set_fragments(parameters, inst, node->fn, node->fs, node->fa);
   const auto r = lookup_radius(parameters, inst, "d", "r");
@@ -251,20 +257,15 @@ static std::shared_ptr<AbstractNode> builtin_sphere(const ModuleInstantiation *i
   return node;
 }
 
-
-
-std::unique_ptr<const Geometry> CylinderNode::createGeometry() const
-{
-  if (
-    this->h <= 0 || !std::isfinite(this->h)
-    || this->r1 < 0 || !std::isfinite(this->r1)
-    || this->r2 < 0 || !std::isfinite(this->r2)
-    || (this->r1 <= 0 && this->r2 <= 0)
-    ) {
+std::unique_ptr<const Geometry> CylinderNode::createGeometry() const {
+  if (this->h <= 0 || !std::isfinite(this->h) || this->r1 < 0 ||
+      !std::isfinite(this->r1) || this->r2 < 0 || !std::isfinite(this->r2) ||
+      (this->r1 <= 0 && this->r2 <= 0)) {
     return PolySet::createEmpty();
   }
 
-  auto num_fragments = Calc::get_fragments_from_r(std::fmax(this->r1, this->r2), this->fn, this->fs, this->fa);
+  auto num_fragments = Calc::get_fragments_from_r(std::fmax(this->r1, this->r2),
+                                                  this->fn, this->fs, this->fa);
 
   double z1, z2;
   if (this->center) {
@@ -279,24 +280,30 @@ std::unique_ptr<const Geometry> CylinderNode::createGeometry() const
   bool inverted_cone = (r1 == 0.0);
 
   auto polyset = std::make_unique<PolySet>(3, /*convex*/ true);
-  polyset->vertices.reserve((cone || inverted_cone) ? num_fragments + 1 : 2 * num_fragments);
+  polyset->vertices.reserve((cone || inverted_cone) ? num_fragments + 1
+                                                    : 2 * num_fragments);
 
   if (inverted_cone) {
     polyset->vertices.emplace_back(0.0, 0.0, z1);
   } else {
-    generate_circle(std::back_inserter(polyset->vertices), r1, z1, num_fragments);
+    generate_circle(std::back_inserter(polyset->vertices), r1, z1,
+                    num_fragments);
   }
   if (cone) {
     polyset->vertices.emplace_back(0.0, 0.0, z2);
   } else {
-    generate_circle(std::back_inserter(polyset->vertices), r2, z2, num_fragments);
+    generate_circle(std::back_inserter(polyset->vertices), r2, z2,
+                    num_fragments);
   }
 
   for (int i = 0; i < num_fragments; ++i) {
     int j = (i + 1) % num_fragments;
-    if (cone) polyset->indices.push_back({i, j, num_fragments});
-    else if (inverted_cone) polyset->indices.push_back({0, j + 1, i + 1});
-    else polyset->indices.push_back({i, j, j + num_fragments, i + num_fragments});
+    if (cone)
+      polyset->indices.push_back({i, j, num_fragments});
+    else if (inverted_cone)
+      polyset->indices.push_back({0, j + 1, i + 1});
+    else
+      polyset->indices.push_back({i, j, j + num_fragments, i + num_fragments});
   }
 
   if (!inverted_cone) {
@@ -316,11 +323,13 @@ std::unique_ptr<const Geometry> CylinderNode::createGeometry() const
   return polyset;
 }
 
-static std::shared_ptr<AbstractNode> builtin_cylinder(const ModuleInstantiation *inst, Arguments arguments)
-{
+static std::shared_ptr<AbstractNode>
+builtin_cylinder(const ModuleInstantiation *inst, Arguments arguments) {
   auto node = std::make_shared<CylinderNode>(inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"h", "r1", "r2", "center"}, {"r", "d", "d1", "d2"});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(),
+                        {"h", "r1", "r2", "center"}, {"r", "d", "d1", "d2"});
 
   set_fragments(parameters, inst, node->fn, node->fs, node->fa);
   if (parameters["h"].type() == Value::Type::NUMBER) {
@@ -331,9 +340,9 @@ static std::shared_ptr<AbstractNode> builtin_cylinder(const ModuleInstantiation
   auto r1 = lookup_radius(parameters, inst, "d1", "r1");
   auto r2 = lookup_radius(parameters, inst, "d2", "r2");
   if (r.type() == Value::Type::NUMBER &&
-      (r1.type() == Value::Type::NUMBER || r2.type() == Value::Type::NUMBER)
-      ) {
-    LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Cylinder parameters ambiguous");
+      (r1.type() == Value::Type::NUMBER || r2.type() == Value::Type::NUMBER)) {
+    LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+        "Cylinder parameters ambiguous");
   }
 
   if (r.type() == Value::Type::NUMBER) {
@@ -349,13 +358,17 @@ static std::shared_ptr<AbstractNode> builtin_cylinder(const ModuleInstantiation
 
   if (OpenSCAD::rangeCheck) {
     if (node->h <= 0 || !std::isfinite(node->h)) {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "cylinder(h=%1$s, ...)", parameters["h"].toEchoStringNoThrow());
+      LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+          "cylinder(h=%1$s, ...)", parameters["h"].toEchoStringNoThrow());
     }
-    if (node->r1 < 0 || node->r2 < 0 || (node->r1 == 0 && node->r2 == 0) || !std::isfinite(node->r1) || !std::isfinite(node->r2)) {
+    if (node->r1 < 0 || node->r2 < 0 || (node->r1 == 0 && node->r2 == 0) ||
+        !std::isfinite(node->r1) || !std::isfinite(node->r2)) {
       LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
           "cylinder(r1=%1$s, r2=%2$s, ...)",
-          (r1.type() == Value::Type::NUMBER ? r1.toEchoStringNoThrow() : r.toEchoStringNoThrow()),
-          (r2.type() == Value::Type::NUMBER ? r2.toEchoStringNoThrow() : r.toEchoStringNoThrow()));
+          (r1.type() == Value::Type::NUMBER ? r1.toEchoStringNoThrow()
+                                            : r.toEchoStringNoThrow()),
+          (r2.type() == Value::Type::NUMBER ? r2.toEchoStringNoThrow()
+                                            : r.toEchoStringNoThrow()));
     }
   }
 
@@ -366,13 +379,11 @@ static std::shared_ptr<AbstractNode> builtin_cylinder(const ModuleInstantiation
   return node;
 }
 
-
-std::string PolyhedronNode::toString() const
-{
+std::string PolyhedronNode::toString() const {
   std::ostringstream stream;
   stream << "polyhedron(points = [";
   bool firstPoint = true;
-  for (const auto& point : this->points) {
+  for (const auto &point : this->points) {
     if (firstPoint) {
       firstPoint = false;
     } else {
@@ -382,7 +393,7 @@ std::string PolyhedronNode::toString() const
   }
   stream << "], faces = [";
   bool firstFace = true;
-  for (const auto& face : this->faces) {
+  for (const auto &face : this->faces) {
     if (firstFace) {
       firstFace = false;
     } else {
@@ -390,7 +401,7 @@ std::string PolyhedronNode::toString() const
     }
     stream << "[";
     bool firstIndex = true;
-    for (const auto& index : face) {
+    for (const auto &index : face) {
       if (firstIndex) {
         firstIndex = false;
       } else {
@@ -404,14 +415,13 @@ std::string PolyhedronNode::toString() const
   return stream.str();
 }
 
-std::unique_ptr<const Geometry> PolyhedronNode::createGeometry() const
-{
+std::unique_ptr<const Geometry> PolyhedronNode::createGeometry() const {
   auto p = PolySet::createEmpty();
   p->setConvexity(this->convexity);
   p->vertices = this->points;
   p->indices = this->faces;
   bool is_triangular = true;
-  for (auto& poly : p->indices) {
+  for (auto &poly : p->indices) {
     std::reverse(poly.begin(), poly.end());
     if (is_triangular && poly.size() > 3) {
       is_triangular = false;
@@ -421,23 +431,29 @@ std::unique_ptr<const Geometry> PolyhedronNode::createGeometry() const
   return p;
 }
 
-static std::shared_ptr<AbstractNode> builtin_polyhedron(const ModuleInstantiation *inst, Arguments arguments)
-{
+static std::shared_ptr<AbstractNode>
+builtin_polyhedron(const ModuleInstantiation *inst, Arguments arguments) {
   auto node = std::make_shared<PolyhedronNode>(inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"points", "faces", "convexity"}, {"triangles"});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(),
+                        {"points", "faces", "convexity"}, {"triangles"});
 
   if (parameters["points"].type() != Value::Type::VECTOR) {
-    LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert points = %1$s to a vector of coordinates", parameters["points"].toEchoStringNoThrow());
+    LOG(message_group::Error, inst->location(), parameters.documentRoot(),
+        "Unable to convert points = %1$s to a vector of coordinates",
+        parameters["points"].toEchoStringNoThrow());
     return node;
   }
   node->points.reserve(parameters["points"].toVector().size());
-  for (const Value& pointValue : parameters["points"].toVector()) {
+  for (const Value &pointValue : parameters["points"].toVector()) {
     Vector3d point;
     if (!pointValue.getVec3(point[0], point[1], point[2], 0.0) ||
-        !std::isfinite(point[0]) || !std::isfinite(point[1]) || !std::isfinite(point[2])
-        ) {
-      LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert points[%1$d] = %2$s to a vec3 of numbers", node->points.size(), pointValue.toEchoStringNoThrow());
+        !std::isfinite(point[0]) || !std::isfinite(point[1]) ||
+        !std::isfinite(point[2])) {
+      LOG(message_group::Error, inst->location(), parameters.documentRoot(),
+          "Unable to convert points[%1$d] = %2$s to a vec3 of numbers",
+          node->points.size(), pointValue.toEchoStringNoThrow());
       node->points.push_back({0, 0, 0});
     } else {
       node->points.push_back(point);
@@ -445,34 +461,47 @@ static std::shared_ptr<AbstractNode> builtin_polyhedron(const ModuleInstantiatio
   }
 
   const Value *faces = nullptr;
-  if (parameters["faces"].type() == Value::Type::UNDEFINED && parameters["triangles"].type() != Value::Type::UNDEFINED) {
+  if (parameters["faces"].type() == Value::Type::UNDEFINED &&
+      parameters["triangles"].type() != Value::Type::UNDEFINED) {
     // backwards compatible
-    LOG(message_group::Deprecated, inst->location(), parameters.documentRoot(), "polyhedron(triangles=[]) will be removed in future releases. Use polyhedron(faces=[]) instead.");
+    LOG(message_group::Deprecated, inst->location(), parameters.documentRoot(),
+        "polyhedron(triangles=[]) will be removed in future releases. Use "
+        "polyhedron(faces=[]) instead.");
     faces = &parameters["triangles"];
   } else {
     faces = &parameters["faces"];
   }
   if (faces->type() != Value::Type::VECTOR) {
-    LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert faces = %1$s to a vector of vector of point indices", faces->toEchoStringNoThrow());
+    LOG(message_group::Error, inst->location(), parameters.documentRoot(),
+        "Unable to convert faces = %1$s to a vector of vector of point indices",
+        faces->toEchoStringNoThrow());
     return node;
   }
   size_t faceIndex = 0;
   node->faces.reserve(faces->toVector().size());
-  for (const Value& faceValue : faces->toVector()) {
+  for (const Value &faceValue : faces->toVector()) {
     if (faceValue.type() != Value::Type::VECTOR) {
-      LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert faces[%1$d] = %2$s to a vector of numbers", faceIndex, faceValue.toEchoStringNoThrow());
+      LOG(message_group::Error, inst->location(), parameters.documentRoot(),
+          "Unable to convert faces[%1$d] = %2$s to a vector of numbers",
+          faceIndex, faceValue.toEchoStringNoThrow());
     } else {
       size_t pointIndexIndex = 0;
       IndexedFace face;
-      for (const Value& pointIndexValue : faceValue.toVector()) {
+      for (const Value &pointIndexValue : faceValue.toVector()) {
         if (pointIndexValue.type() != Value::Type::NUMBER) {
-          LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert faces[%1$d][%2$d] = %3$s to a number", faceIndex, pointIndexIndex, pointIndexValue.toEchoStringNoThrow());
+          LOG(message_group::Error, inst->location(), parameters.documentRoot(),
+              "Unable to convert faces[%1$d][%2$d] = %3$s to a number",
+              faceIndex, pointIndexIndex,
+              pointIndexValue.toEchoStringNoThrow());
         } else {
           auto pointIndex = (size_t)pointIndexValue.toDouble();
           if (pointIndex < node->points.size()) {
             face.push_back(pointIndex);
           } else {
-            LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Point index %1$d is out of bounds (from faces[%2$d][%3$d])", pointIndex, faceIndex, pointIndexIndex);
+            LOG(message_group::Warning, inst->location(),
+                parameters.documentRoot(),
+                "Point index %1$d is out of bounds (from faces[%2$d][%3$d])",
+                pointIndex, faceIndex, pointIndexIndex);
           }
         }
         pointIndexIndex++;
@@ -486,16 +515,15 @@ static std::shared_ptr<AbstractNode> builtin_polyhedron(const ModuleInstantiatio
   }
 
   node->convexity = (int)parameters["convexity"].toDouble();
-  if (node->convexity < 1) node->convexity = 1;
+  if (node->convexity < 1)
+    node->convexity = 1;
 
   return node;
 }
 
-
-std::unique_ptr<const Geometry> SquareNode::createGeometry() const
-{
-  if (this->x <= 0 || !std::isfinite(this->x) ||
-      this->y <= 0 || !std::isfinite(this->y)) {
+std::unique_ptr<const Geometry> SquareNode::createGeometry() const {
+  if (this->x <= 0 || !std::isfinite(this->x) || this->y <= 0 ||
+      !std::isfinite(this->y)) {
     return std::make_unique<Polygon2d>();
   }
 
@@ -511,26 +539,31 @@ std::unique_ptr<const Geometry> SquareNode::createGeometry() const
   return std::make_unique<Polygon2d>(o);
 }
 
-static std::shared_ptr<AbstractNode> builtin_square(const ModuleInstantiation *inst, Arguments arguments)
-{
+static std::shared_ptr<AbstractNode>
+builtin_square(const ModuleInstantiation *inst, Arguments arguments) {
   auto node = std::make_shared<SquareNode>(inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"size", "center"});
+  Parameters parameters = Parameters::parse(
+      std::move(arguments), inst->location(), {"size", "center"});
 
-  const auto& size = parameters["size"];
+  const auto &size = parameters["size"];
   if (size.isDefined()) {
     bool converted = false;
     converted |= size.getDouble(node->x);
     converted |= size.getDouble(node->y);
     converted |= size.getVec2(node->x, node->y);
     if (!converted) {
-      LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Unable to convert square(size=%1$s, ...) parameter to a number or a vec2 of numbers", size.toEchoStringNoThrow());
+      LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+          "Unable to convert square(size=%1$s, ...) parameter to a number or a "
+          "vec2 of numbers",
+          size.toEchoStringNoThrow());
     } else if (OpenSCAD::rangeCheck) {
       bool ok = true;
       ok &= (node->x > 0) && (node->y > 0);
       ok &= std::isfinite(node->x) && std::isfinite(node->y);
       if (!ok) {
-        LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "square(size=%1$s, ...)", size.toEchoStringNoThrow());
+        LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
+            "square(size=%1$s, ...)", size.toEchoStringNoThrow());
       }
     }
   }
@@ -541,13 +574,13 @@ static std::shared_ptr<AbstractNode> builtin_square(const ModuleInstantiation *i
   return node;
 }
 
-std::unique_ptr<const Geometry> CircleNode::createGeometry() const
-{
+std::unique_ptr<const Geometry> CircleNode::createGeometry() const {
   if (this->r <= 0 || !std::isfinite(this->r)) {
     return std::make_unique<Polygon2d>();
   }
 
-  auto fragments = Calc::get_fragments_from_r(this->r, this->fn, this->fs, this->fa);
+  auto fragments =
+      Calc::get_fragments_from_r(this->r, this->fn, this->fs, this->fa);
   Outline2d o;
   o.vertices.resize(fragments);
   for (int i = 0; i < fragments; ++i) {
@@ -557,11 +590,12 @@ std::unique_ptr<const Geometry> CircleNode::createGeometry() const
   return std::make_unique<Polygon2d>(o);
 }
 
-static std::shared_ptr<AbstractNode> builtin_circle(const ModuleInstantiation *inst, Arguments arguments)
-{
+static std::shared_ptr<AbstractNode>
+builtin_circle(const ModuleInstantiation *inst, Arguments arguments) {
   auto node = std::make_shared<CircleNode>(inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"r"}, {"d"});
+  Parameters parameters =
+      Parameters::parse(std::move(arguments), inst->location(), {"r"}, {"d"});
 
   set_fragments(parameters, inst, node->fn, node->fs, node->fa);
   const auto r = lookup_radius(parameters, inst, "d", "r");
@@ -576,14 +610,11 @@ static std::shared_ptr<AbstractNode> builtin_circle(const ModuleInstantiation *i
   return node;
 }
 
-
-
-std::string PolygonNode::toString() const
-{
+std::string PolygonNode::toString() const {
   std::ostringstream stream;
   stream << "polygon(points = [";
   bool firstPoint = true;
-  for (const auto& point : this->points) {
+  for (const auto &point : this->points) {
     if (firstPoint) {
       firstPoint = false;
     } else {
@@ -597,7 +628,7 @@ std::string PolygonNode::toString() const
   } else {
     stream << "[";
     bool firstPath = true;
-    for (const auto& path : this->paths) {
+    for (const auto &path : this->paths) {
       if (firstPath) {
         firstPath = false;
       } else {
@@ -605,7 +636,7 @@ std::string PolygonNode::toString() const
       }
       stream << "[";
       bool firstIndex = true;
-      for (const auto& index : path) {
+      for (const auto &index : path) {
         if (firstIndex) {
           firstIndex = false;
         } else {
@@ -621,22 +652,21 @@ std::string PolygonNode::toString() const
   return stream.str();
 }
 
-std::unique_ptr<const Geometry> PolygonNode::createGeometry() const
-{
+std::unique_ptr<const Geometry> PolygonNode::createGeometry() const {
   auto p = std::make_unique<Polygon2d>();
   if (this->paths.empty() && this->points.size() > 2) {
     Outline2d outline;
-    for (const auto& point : this->points) {
+    for (const auto &point : this->points) {
       outline.vertices.push_back(point);
     }
     p->addOutline(outline);
   } else {
     bool positive = true; // First outline is positive
-    for (const auto& path : this->paths) {
+    for (const auto &path : this->paths) {
       Outline2d outline;
-      for (const auto& index : path) {
+      for (const auto &index : path) {
         assert(index < this->points.size());
-        const auto& point = points[index];
+        const auto &point = points[index];
         outline.vertices.push_back(point);
       }
       outline.positive = positive;
@@ -650,22 +680,26 @@ std::unique_ptr<const Geometry> PolygonNode::createGeometry() const
   return p;
 }
 
-static std::shared_ptr<AbstractNode> builtin_polygon(const ModuleInstantiation *inst, Arguments arguments)
-{
+static std::shared_ptr<AbstractNode>
+builtin_polygon(const ModuleInstantiation *inst, Arguments arguments) {
   auto node = std::make_shared<PolygonNode>(inst);
 
-  Parameters parameters = Parameters::parse(std::move(arguments), inst->location(), {"points", "paths", "convexity"});
+  Parameters parameters = Parameters::parse(
+      std::move(arguments), inst->location(), {"points", "paths", "convexity"});
 
   if (parameters["points"].type() != Value::Type::VECTOR) {
-    LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert points = %1$s to a vector of coordinates", parameters["points"].toEchoStringNoThrow());
+    LOG(message_group::Error, inst->location(), parameters.documentRoot(),
+        "Unable to convert points = %1$s to a vector of coordinates",
+        parameters["points"].toEchoStringNoThrow());
     return node;
   }
-  for (const Value& pointValue : parameters["points"].toVector()) {
+  for (const Value &pointValue : parameters["points"].toVector()) {
     Vector2d point;
-    if (!pointValue.getVec2(point[0], point[1]) ||
-        !std::isfinite(point[0]) || !std::isfinite(point[1])
-        ) {
-      LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert points[%1$d] = %2$s to a vec2 of numbers", node->points.size(), pointValue.toEchoStringNoThrow());
+    if (!pointValue.getVec2(point[0], point[1]) || !std::isfinite(point[0]) ||
+        !std::isfinite(point[1])) {
+      LOG(message_group::Error, inst->location(), parameters.documentRoot(),
+          "Unable to convert points[%1$d] = %2$s to a vec2 of numbers",
+          node->points.size(), pointValue.toEchoStringNoThrow());
       node->points.push_back({0, 0});
     } else {
       node->points.push_back(point);
@@ -674,21 +708,30 @@ static std::shared_ptr<AbstractNode> builtin_polygon(const ModuleInstantiation *
 
   if (parameters["paths"].type() == Value::Type::VECTOR) {
     size_t pathIndex = 0;
-    for (const Value& pathValue : parameters["paths"].toVector()) {
+    for (const Value &pathValue : parameters["paths"].toVector()) {
       if (pathValue.type() != Value::Type::VECTOR) {
-        LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert paths[%1$d] = %2$s to a vector of numbers", pathIndex, pathValue.toEchoStringNoThrow());
+        LOG(message_group::Error, inst->location(), parameters.documentRoot(),
+            "Unable to convert paths[%1$d] = %2$s to a vector of numbers",
+            pathIndex, pathValue.toEchoStringNoThrow());
       } else {
         size_t pointIndexIndex = 0;
         std::vector<size_t> path;
-        for (const Value& pointIndexValue : pathValue.toVector()) {
+        for (const Value &pointIndexValue : pathValue.toVector()) {
           if (pointIndexValue.type() != Value::Type::NUMBER) {
-            LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert paths[%1$d][%2$d] = %3$s to a number", pathIndex, pointIndexIndex, pointIndexValue.toEchoStringNoThrow());
+            LOG(message_group::Error, inst->location(),
+                parameters.documentRoot(),
+                "Unable to convert paths[%1$d][%2$d] = %3$s to a number",
+                pathIndex, pointIndexIndex,
+                pointIndexValue.toEchoStringNoThrow());
           } else {
             auto pointIndex = (size_t)pointIndexValue.toDouble();
             if (pointIndex < node->points.size()) {
               path.push_back(pointIndex);
             } else {
-              LOG(message_group::Warning, inst->location(), parameters.documentRoot(), "Point index %1$d is out of bounds (from paths[%2$d][%3$d])", pointIndex, pathIndex, pointIndexIndex);
+              LOG(message_group::Warning, inst->location(),
+                  parameters.documentRoot(),
+                  "Point index %1$d is out of bounds (from paths[%2$d][%3$d])",
+                  pointIndex, pathIndex, pointIndexIndex);
             }
           }
           pointIndexIndex++;
@@ -698,64 +741,65 @@ static std::shared_ptr<AbstractNode> builtin_polygon(const ModuleInstantiation *
       pathIndex++;
     }
   } else if (parameters["paths"].type() != Value::Type::UNDEFINED) {
-    LOG(message_group::Error, inst->location(), parameters.documentRoot(), "Unable to convert paths = %1$s to a vector of vector of point indices", parameters["paths"].toEchoStringNoThrow());
+    LOG(message_group::Error, inst->location(), parameters.documentRoot(),
+        "Unable to convert paths = %1$s to a vector of vector of point indices",
+        parameters["paths"].toEchoStringNoThrow());
     return node;
   }
 
   node->convexity = (int)parameters["convexity"].toDouble();
-  if (node->convexity < 1) node->convexity = 1;
+  if (node->convexity < 1)
+    node->convexity = 1;
 
   return node;
 }
 
-
-
-void register_builtin_primitives()
-{
+void register_builtin_primitives() {
   Builtins::init("cube", new BuiltinModule(builtin_cube),
-  {
-    "cube(size)",
-    "cube([width, depth, height])",
-    "cube([width, depth, height], center = true)",
-  });
+                 {
+                     "cube(size)",
+                     "cube([width, depth, height])",
+                     "cube([width, depth, height], center = true)",
+                 });
 
   Builtins::init("sphere", new BuiltinModule(builtin_sphere),
-  {
-    "sphere(radius)",
-    "sphere(r = radius)",
-    "sphere(d = diameter)",
-  });
-
-  Builtins::init("cylinder", new BuiltinModule(builtin_cylinder),
-  {
-    "cylinder(h, r1, r2)",
-    "cylinder(h = height, r = radius, center = true)",
-    "cylinder(h = height, r1 = bottom, r2 = top, center = true)",
-    "cylinder(h = height, d = diameter, center = true)",
-    "cylinder(h = height, d1 = bottom, d2 = top, center = true)",
-  });
+                 {
+                     "sphere(radius)",
+                     "sphere(r = radius)",
+                     "sphere(d = diameter)",
+                 });
+
+  Builtins::init(
+      "cylinder", new BuiltinModule(builtin_cylinder),
+      {
+          "cylinder(h, r1, r2)",
+          "cylinder(h = height, r = radius, center = true)",
+          "cylinder(h = height, r1 = bottom, r2 = top, center = true)",
+          "cylinder(h = height, d = diameter, center = true)",
+          "cylinder(h = height, d1 = bottom, d2 = top, center = true)",
+      });
 
   Builtins::init("polyhedron", new BuiltinModule(builtin_polyhedron),
-  {
-    "polyhedron(points, faces, convexity)",
-  });
+                 {
+                     "polyhedron(points, faces, convexity)",
+                 });
 
   Builtins::init("square", new BuiltinModule(builtin_square),
-  {
-    "square(size, center = true)",
-    "square([width,height], center = true)",
-  });
+                 {
+                     "square(size, center = true)",
+                     "square([width,height], center = true)",
+                 });
 
   Builtins::init("circle", new BuiltinModule(builtin_circle),
-  {
-    "circle(radius)",
-    "circle(r = radius)",
-    "circle(d = diameter)",
-  });
+                 {
+                     "circle(radius)",
+                     "circle(r = radius)",
+                     "circle(d = diameter)",
+                 });
 
   Builtins::init("polygon", new BuiltinModule(builtin_polygon),
-  {
-    "polygon([points])",
-    "polygon([points], [paths])",
-  });
+                 {
+                     "polygon([points])",
+                     "polygon([points], [paths])",
+                 });
 }
diff --git a/src/core/primitives.h b/src/core/primitives.h
index 19c005e6c..2e37345d4 100644
--- a/src/core/primitives.h
+++ b/src/core/primitives.h
@@ -24,30 +24,25 @@
  *
  */
 
-#include "geometry/GeometryUtils.h"
 #include "core/ModuleInstantiation.h"
+#include "core/node.h"
 #include "geometry/Geometry.h"
+#include "geometry/GeometryUtils.h"
 #include "geometry/linalg.h"
-#include "core/node.h"
 
-#include <memory>
 #include <cstddef>
+#include <memory>
 #include <sstream>
 #include <string>
 #include <vector>
 
-class CubeNode : public LeafNode
-{
+class CubeNode : public LeafNode {
 public:
   CubeNode(const ModuleInstantiation *mi) : LeafNode(mi) {}
-  std::string toString() const override
-  {
+  std::string toString() const override {
     std::ostringstream stream;
-    stream << "cube(size = ["
-           << x << ", "
-           << y << ", "
-           << z << "], center = "
-           << (center ? "true" : "false") << ")";
+    stream << "cube(size = [" << x << ", " << y << ", " << z
+           << "], center = " << (center ? "true" : "false") << ")";
     return stream.str();
   }
   std::string name() const override { return "cube"; }
@@ -57,20 +52,14 @@ public:
   bool center = false;
 };
 
-
-class SphereNode : public LeafNode
-{
+class SphereNode : public LeafNode {
 public:
   SphereNode(const ModuleInstantiation *mi) : LeafNode(mi) {}
-  std::string toString() const override
-  {
+  std::string toString() const override {
     std::ostringstream stream;
     stream << "sphere"
-           << "($fn = " << fn
-           << ", $fa = " << fa
-           << ", $fs = " << fs
-           << ", r = " << r
-           << ")";
+           << "($fn = " << fn << ", $fa = " << fa << ", $fs = " << fs
+           << ", r = " << r << ")";
     return stream.str();
   }
   std::string name() const override { return "sphere"; }
@@ -80,23 +69,15 @@ public:
   double r = 1;
 };
 
-
-class CylinderNode : public LeafNode
-{
+class CylinderNode : public LeafNode {
 public:
   CylinderNode(const ModuleInstantiation *mi) : LeafNode(mi) {}
-  std::string toString() const override
-  {
+  std::string toString() const override {
     std::ostringstream stream;
     stream << "cylinder"
-           << "($fn = " << fn
-           << ", $fa = " << fa
-           << ", $fs = " << fs
-           << ", h = " << h
-           << ", r1 = " << r1
-           << ", r2 = " << r2
-           << ", center = " << (center ? "true" : "false")
-           << ")";
+           << "($fn = " << fn << ", $fa = " << fa << ", $fs = " << fs
+           << ", h = " << h << ", r1 = " << r1 << ", r2 = " << r2
+           << ", center = " << (center ? "true" : "false") << ")";
     return stream.str();
   }
   std::string name() const override { return "cylinder"; }
@@ -107,11 +88,9 @@ public:
   bool center = false;
 };
 
-
-class PolyhedronNode : public LeafNode
-{
+class PolyhedronNode : public LeafNode {
 public:
-  PolyhedronNode (const ModuleInstantiation *mi) : LeafNode(mi) {}
+  PolyhedronNode(const ModuleInstantiation *mi) : LeafNode(mi) {}
   std::string toString() const override;
   std::string name() const override { return "polyhedron"; }
   std::unique_ptr<const Geometry> createGeometry() const override;
@@ -121,18 +100,13 @@ public:
   int convexity = 1;
 };
 
-
-class SquareNode : public LeafNode
-{
+class SquareNode : public LeafNode {
 public:
   SquareNode(const ModuleInstantiation *mi) : LeafNode(mi) {}
-  std::string toString() const override
-  {
+  std::string toString() const override {
     std::ostringstream stream;
-    stream << "square(size = ["
-           << x << ", "
-           << y << "], center = "
-           << (center ? "true" : "false") << ")";
+    stream << "square(size = [" << x << ", " << y
+           << "], center = " << (center ? "true" : "false") << ")";
     return stream.str();
   }
   std::string name() const override { return "square"; }
@@ -142,20 +116,14 @@ public:
   bool center = false;
 };
 
-
-class CircleNode : public LeafNode
-{
+class CircleNode : public LeafNode {
 public:
   CircleNode(const ModuleInstantiation *mi) : LeafNode(mi) {}
-  std::string toString() const override
-  {
+  std::string toString() const override {
     std::ostringstream stream;
     stream << "circle"
-           << "($fn = " << fn
-           << ", $fa = " << fa
-           << ", $fs = " << fs
-           << ", r = " << r
-           << ")";
+           << "($fn = " << fn << ", $fa = " << fa << ", $fs = " << fs
+           << ", r = " << r << ")";
     return stream.str();
   }
   std::string name() const override { return "circle"; }
@@ -165,11 +133,9 @@ public:
   double r = 1;
 };
 
-
-class PolygonNode : public LeafNode
-{
+class PolygonNode : public LeafNode {
 public:
-  PolygonNode (const ModuleInstantiation *mi) : LeafNode(mi) {}
+  PolygonNode(const ModuleInstantiation *mi) : LeafNode(mi) {}
   std::string toString() const override;
   std::string name() const override { return "polygon"; }
   std::unique_ptr<const Geometry> createGeometry() const override;
diff --git a/src/core/progress.cc b/src/core/progress.cc
index c011714f6..24aadcb0b 100644
--- a/src/core/progress.cc
+++ b/src/core/progress.cc
@@ -1,37 +1,41 @@
 #include "core/progress.h"
 
-#include <memory>
 #include "core/node.h"
+#include <memory>
 
 int progress_report_count;
 int progress_mark_;
-void (*progress_report_f)(const std::shared_ptr<const AbstractNode>&, void *, int);
+void (*progress_report_f)(const std::shared_ptr<const AbstractNode> &, void *,
+                          int);
 void *progress_report_userdata;
 
-void progress_report_prep(const std::shared_ptr<AbstractNode>& root, void (*f)(const std::shared_ptr<const AbstractNode>& node, void *userdata, int mark), void *userdata)
-{
+void progress_report_prep(
+    const std::shared_ptr<AbstractNode> &root,
+    void (*f)(const std::shared_ptr<const AbstractNode> &node, void *userdata,
+              int mark),
+    void *userdata) {
   progress_report_count = 0;
   progress_report_f = f;
   progress_report_userdata = userdata;
   root->progress_prepare();
 }
 
-void progress_report_fin()
-{
+void progress_report_fin() {
   progress_report_count = 0;
   progress_report_f = nullptr;
   progress_report_userdata = nullptr;
 }
 
-void progress_update(const std::shared_ptr<const AbstractNode>& node, int mark)
-{
+void progress_update(const std::shared_ptr<const AbstractNode> &node,
+                     int mark) {
   if (progress_report_f) {
     progress_mark_ = mark;
     progress_report_f(node, progress_report_userdata, progress_mark_);
   }
 }
 
-void progress_tick()
-{
-  if (progress_report_f) progress_report_f(std::shared_ptr<const AbstractNode>(), progress_report_userdata, ++progress_mark_);
+void progress_tick() {
+  if (progress_report_f)
+    progress_report_f(std::shared_ptr<const AbstractNode>(),
+                      progress_report_userdata, ++progress_mark_);
 }
diff --git a/src/core/progress.h b/src/core/progress.h
index b7c5ad176..bb3878733 100644
--- a/src/core/progress.h
+++ b/src/core/progress.h
@@ -4,18 +4,23 @@
 
 class AbstractNode;
 
-// Reset to 0 in _prep() and increased for each Node instance in progress_prepare()
+// Reset to 0 in _prep() and increased for each Node instance in
+// progress_prepare()
 extern int progress_report_count;
 
-extern void (*progress_report_f)(const std::shared_ptr<const AbstractNode>&, void *, int);
+extern void (*progress_report_f)(const std::shared_ptr<const AbstractNode> &,
+                                 void *, int);
 extern void *progress_report_userdata;
 
-void progress_report_prep(const std::shared_ptr<AbstractNode>& root, void (*f)(const std::shared_ptr<const AbstractNode>& node, void *userdata, int mark), void *userdata);
+void progress_report_prep(
+    const std::shared_ptr<AbstractNode> &root,
+    void (*f)(const std::shared_ptr<const AbstractNode> &node, void *userdata,
+              int mark),
+    void *userdata);
 void progress_report_fin();
-void progress_update(const std::shared_ptr<const AbstractNode>& node, int mark);
-// CGALUtils::applyUnion3D may process nodes out of order, so allow for an increment instead of tracking exact node
+void progress_update(const std::shared_ptr<const AbstractNode> &node, int mark);
+// CGALUtils::applyUnion3D may process nodes out of order, so allow for an
+// increment instead of tracking exact node
 void progress_tick();
 
-class ProgressCancelException
-{
-};
+class ProgressCancelException {};
diff --git a/src/core/str_utf8_wrapper.h b/src/core/str_utf8_wrapper.h
index 67ed584ab..6e51aac22 100644
--- a/src/core/str_utf8_wrapper.h
+++ b/src/core/str_utf8_wrapper.h
@@ -1,53 +1,59 @@
 #pragma once
 
-#include <iterator>
-#include <utility>
-#include <cstdint>
 #include <cstddef>
+#include <cstdint>
+#include <iterator>
 #include <memory>
 #include <string>
+#include <utility>
 
 #include <glib.h>
 
-class str_utf8_wrapper
-{
+class str_utf8_wrapper {
 private:
   // store the cached length in glong, paired with its string
   struct str_utf8_t {
     static constexpr size_t LENGTH_UNKNOWN = -1;
-    str_utf8_t() : u8str(), u8len(0) {
-    }
-    str_utf8_t(std::string s) : u8str(std::move(s)) {
-    }
-    str_utf8_t(const char *cstr) : u8str(cstr) {
-    }
-    str_utf8_t(const char *cstr, size_t size, size_t u8len) : u8str(cstr, size), u8len(u8len) {
-    }
+    str_utf8_t() : u8str(), u8len(0) {}
+    str_utf8_t(std::string s) : u8str(std::move(s)) {}
+    str_utf8_t(const char *cstr) : u8str(cstr) {}
+    str_utf8_t(const char *cstr, size_t size, size_t u8len)
+        : u8str(cstr, size), u8len(u8len) {}
     const std::string u8str;
     size_t u8len = LENGTH_UNKNOWN;
   };
   // private constructor for copying members
-  explicit str_utf8_wrapper(const std::shared_ptr<str_utf8_t>& str_in) : str_ptr(str_in) { }
+  explicit str_utf8_wrapper(const std::shared_ptr<str_utf8_t> &str_in)
+      : str_ptr(str_in) {}
 
 public:
-  class iterator
-  {
-public:
+  class iterator {
+  public:
     // iterator_traits required types:
     using iterator_category = std::forward_iterator_tag;
     using value_type = str_utf8_wrapper;
     using difference_type = void;
-    using reference = value_type; // type used by operator*(), not actually a reference
+    using reference =
+        value_type; // type used by operator*(), not actually a reference
     using pointer = void;
     iterator() : ptr(&nullterm) {} // DefaultConstructible
-    iterator(const str_utf8_wrapper& str) : ptr(str.c_str()), len(char_len()) { }
-    iterator(const str_utf8_wrapper& str, bool /*end*/) : ptr(str.c_str() + str.size()) { }
+    iterator(const str_utf8_wrapper &str) : ptr(str.c_str()), len(char_len()) {}
+    iterator(const str_utf8_wrapper &str, bool /*end*/)
+        : ptr(str.c_str() + str.size()) {}
 
-    iterator& operator++() { ptr += len; len = char_len(); return *this; }
-    reference operator*() { return {ptr, len}; } // Note: returns a new str_utf8_wrapper **by value**, representing a single UTF8 character.
-    bool operator==(const iterator& other) const { return ptr == other.ptr; }
-    bool operator!=(const iterator& other) const { return ptr != other.ptr; }
-private:
+    iterator &operator++() {
+      ptr += len;
+      len = char_len();
+      return *this;
+    }
+    reference operator*() {
+      return {ptr, len};
+    } // Note: returns a new str_utf8_wrapper **by value**, representing a
+      // single UTF8 character.
+    bool operator==(const iterator &other) const { return ptr == other.ptr; }
+    bool operator!=(const iterator &other) const { return ptr != other.ptr; }
+
+  private:
     size_t char_len() { return g_utf8_next_char(ptr) - ptr; }
     static const char nullterm = '\0';
     const char *ptr;
@@ -56,11 +62,14 @@ private:
 
   [[nodiscard]] iterator begin() const { return {*this}; }
   [[nodiscard]] iterator end() const { return {*this, true}; }
-  str_utf8_wrapper() : str_ptr(std::make_shared<str_utf8_t>()) { }
-  str_utf8_wrapper(const std::string& s) : str_ptr(std::make_shared<str_utf8_t>(s)) { }
-  str_utf8_wrapper(const char *cstr) : str_ptr(std::make_shared<str_utf8_t>(cstr)) { }
+  str_utf8_wrapper() : str_ptr(std::make_shared<str_utf8_t>()) {}
+  str_utf8_wrapper(const std::string &s)
+      : str_ptr(std::make_shared<str_utf8_t>(s)) {}
+  str_utf8_wrapper(const char *cstr)
+      : str_ptr(std::make_shared<str_utf8_t>(cstr)) {}
   // for enumerating single utf8 chars from iterator
-  str_utf8_wrapper(const char *cstr, size_t clen) : str_ptr(std::make_shared<str_utf8_t>(cstr, clen, 1)) { }
+  str_utf8_wrapper(const char *cstr, size_t clen)
+      : str_ptr(std::make_shared<str_utf8_t>(cstr, clen, 1)) {}
   str_utf8_wrapper(uint32_t unicode) {
     char out[6] = " ";
     if (unicode != 0 && g_unichar_validate(unicode)) {
@@ -68,28 +77,49 @@ private:
     }
     str_ptr = std::make_shared<str_utf8_t>(out);
   }
-  str_utf8_wrapper(const str_utf8_wrapper&) = delete; // never copy, move instead
-  str_utf8_wrapper& operator=(const str_utf8_wrapper&) = delete; // never copy, move instead
-  str_utf8_wrapper(str_utf8_wrapper&&) = default;
-  str_utf8_wrapper& operator=(str_utf8_wrapper&&) = default;
+  str_utf8_wrapper(const str_utf8_wrapper &) =
+      delete; // never copy, move instead
+  str_utf8_wrapper &
+  operator=(const str_utf8_wrapper &) = delete; // never copy, move instead
+  str_utf8_wrapper(str_utf8_wrapper &&) = default;
+  str_utf8_wrapper &operator=(str_utf8_wrapper &&) = default;
   ~str_utf8_wrapper() = default;
-  [[nodiscard]] str_utf8_wrapper clone() const { return str_utf8_wrapper(this->str_ptr); } // makes a copy of shared_ptr
+  [[nodiscard]] str_utf8_wrapper clone() const {
+    return str_utf8_wrapper(this->str_ptr);
+  } // makes a copy of shared_ptr
 
-  bool operator==(const str_utf8_wrapper& rhs) const { return this->str_ptr->u8str == rhs.str_ptr->u8str; }
-  bool operator!=(const str_utf8_wrapper& rhs) const { return this->str_ptr->u8str != rhs.str_ptr->u8str; }
-  bool operator<(const str_utf8_wrapper& rhs) const { return this->str_ptr->u8str < rhs.str_ptr->u8str; }
-  bool operator>(const str_utf8_wrapper& rhs) const { return this->str_ptr->u8str > rhs.str_ptr->u8str; }
-  bool operator<=(const str_utf8_wrapper& rhs) const { return this->str_ptr->u8str <= rhs.str_ptr->u8str; }
-  bool operator>=(const str_utf8_wrapper& rhs) const { return this->str_ptr->u8str >= rhs.str_ptr->u8str; }
+  bool operator==(const str_utf8_wrapper &rhs) const {
+    return this->str_ptr->u8str == rhs.str_ptr->u8str;
+  }
+  bool operator!=(const str_utf8_wrapper &rhs) const {
+    return this->str_ptr->u8str != rhs.str_ptr->u8str;
+  }
+  bool operator<(const str_utf8_wrapper &rhs) const {
+    return this->str_ptr->u8str < rhs.str_ptr->u8str;
+  }
+  bool operator>(const str_utf8_wrapper &rhs) const {
+    return this->str_ptr->u8str > rhs.str_ptr->u8str;
+  }
+  bool operator<=(const str_utf8_wrapper &rhs) const {
+    return this->str_ptr->u8str <= rhs.str_ptr->u8str;
+  }
+  bool operator>=(const str_utf8_wrapper &rhs) const {
+    return this->str_ptr->u8str >= rhs.str_ptr->u8str;
+  }
   [[nodiscard]] bool empty() const { return this->str_ptr->u8str.empty(); }
-  [[nodiscard]] const char *c_str() const { return this->str_ptr->u8str.c_str(); }
-  [[nodiscard]] const std::string& toString() const { return this->str_ptr->u8str; }
+  [[nodiscard]] const char *c_str() const {
+    return this->str_ptr->u8str.c_str();
+  }
+  [[nodiscard]] const std::string &toString() const {
+    return this->str_ptr->u8str;
+  }
   [[nodiscard]] size_t size() const { return this->str_ptr->u8str.size(); }
   str_utf8_wrapper operator[](const size_t idx) const {
     if (idx < this->size()) {
       // Ensure character (not byte) index is inside the character/glyph array
       if (idx < this->get_utf8_strlen()) {
-        gchar utf8_of_cp[6] = ""; //A buffer for a single unicode character to be copied into
+        gchar utf8_of_cp[6] =
+            ""; // A buffer for a single unicode character to be copied into
         auto ptr = g_utf8_offset_to_pointer(str_ptr->u8str.c_str(), idx);
         if (ptr) {
           g_utf8_strncpy(utf8_of_cp, ptr, 1);
@@ -102,7 +132,8 @@ private:
 
   [[nodiscard]] size_t get_utf8_strlen() const {
     if (str_ptr->u8len == str_utf8_t::LENGTH_UNKNOWN) {
-      str_ptr->u8len = g_utf8_strlen(str_ptr->u8str.c_str(), static_cast<gssize>(str_ptr->u8str.size()));
+      str_ptr->u8len = g_utf8_strlen(
+          str_ptr->u8str.c_str(), static_cast<gssize>(str_ptr->u8str.size()));
     }
     return str_ptr->u8len;
   }
diff --git a/src/geometry/ClipperUtils.cc b/src/geometry/ClipperUtils.cc
index b221c9254..ed5403d59 100644
--- a/src/geometry/ClipperUtils.cc
+++ b/src/geometry/ClipperUtils.cc
@@ -1,26 +1,25 @@
 #include "geometry/ClipperUtils.h"
-#include "geometry/linalg.h"
-#include "geometry/Polygon2d.h"
 #include "clipper2/clipper.h"
+#include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 #include "utils/printutils.h"
 
 #include <algorithm>
+#include <cassert>
 #include <clipper2/clipper.engine.h>
 #include <cmath>
-#include <cassert>
-#include <utility>
-#include <memory>
 #include <cstddef>
+#include <memory>
+#include <utility>
 #include <vector>
 
 namespace ClipperUtils {
 
 namespace {
 
-Clipper2Lib::Paths64 process(const Clipper2Lib::Paths64& polygons,
+Clipper2Lib::Paths64 process(const Clipper2Lib::Paths64 &polygons,
                              Clipper2Lib::ClipType cliptype,
-                             Clipper2Lib::FillRule polytype)
-{
+                             Clipper2Lib::FillRule polytype) {
   Clipper2Lib::Paths64 result;
   Clipper2Lib::Clipper64 clipper;
   clipper.PreserveCollinear(false);
@@ -29,13 +28,14 @@ Clipper2Lib::Paths64 process(const Clipper2Lib::Paths64& polygons,
   return result;
 }
 
-// This is a copy-paste from Clipper2Lib with the modification that the union operation is not performed
-// The reason is numeric robustness. With the insides missing, the intersection points created by the union operation may
-// (due to rounding) be located at slightly different locations than the original geometry and this
-// can give rise to cracks
-void minkowski_outline(const Clipper2Lib::Path64& poly, const Clipper2Lib::Path64& path,
-                       Clipper2Lib::Paths64& quads, bool isSum, bool isClosed)
-{
+// This is a copy-paste from Clipper2Lib with the modification that the union
+// operation is not performed The reason is numeric robustness. With the insides
+// missing, the intersection points created by the union operation may (due to
+// rounding) be located at slightly different locations than the original
+// geometry and this can give rise to cracks
+void minkowski_outline(const Clipper2Lib::Path64 &poly,
+                       const Clipper2Lib::Path64 &path,
+                       Clipper2Lib::Paths64 &quads, bool isSum, bool isClosed) {
   int delta = (isClosed ? 1 : 0);
   size_t polyCnt = poly.size();
   size_t pathCnt = path.size();
@@ -46,7 +46,8 @@ void minkowski_outline(const Clipper2Lib::Path64& poly, const Clipper2Lib::Path6
       Clipper2Lib::Path64 p;
       p.reserve(polyCnt);
       for (auto point : poly) {
-        p.push_back(Clipper2Lib::Point64(path[i].x + point.x, path[i].y + point.y));
+        p.push_back(
+            Clipper2Lib::Point64(path[i].x + point.x, path[i].y + point.y));
       }
       pp.push_back(p);
     }
@@ -55,7 +56,8 @@ void minkowski_outline(const Clipper2Lib::Path64& poly, const Clipper2Lib::Path6
       Clipper2Lib::Path64 p;
       p.reserve(polyCnt);
       for (auto point : poly) {
-        p.push_back(Clipper2Lib::Point64(path[i].x - point.x, path[i].y - point.y));
+        p.push_back(
+            Clipper2Lib::Point64(path[i].x - point.x, path[i].y - point.y));
       }
       pp.push_back(p);
     }
@@ -69,26 +71,26 @@ void minkowski_outline(const Clipper2Lib::Path64& poly, const Clipper2Lib::Path6
       quad.push_back(pp[(i + 1) % pathCnt][j % polyCnt]);
       quad.push_back(pp[(i + 1) % pathCnt][(j + 1) % polyCnt]);
       quad.push_back(pp[i % pathCnt][(j + 1) % polyCnt]);
-      if (!IsPositive(quad)) std::reverse(quad.begin(), quad.end());
+      if (!IsPositive(quad))
+        std::reverse(quad.begin(), quad.end());
       quads.push_back(quad);
     }
 }
 
-// Add the polygon a translated to an arbitrary point of each separate component of b.
-// Ideally, we would translate to the midpoint of component b, but the point can
-// be chosen arbitrarily since the translated object would always stay inside
-// the minkowski sum.
-void fill_minkowski_insides(const Clipper2Lib::Paths64& a,
-                            const Clipper2Lib::Paths64& b,
-                            Clipper2Lib::Paths64& target)
-{
-  for (const auto& b_path : b) {
+// Add the polygon a translated to an arbitrary point of each separate component
+// of b. Ideally, we would translate to the midpoint of component b, but the
+// point can be chosen arbitrarily since the translated object would always stay
+// inside the minkowski sum.
+void fill_minkowski_insides(const Clipper2Lib::Paths64 &a,
+                            const Clipper2Lib::Paths64 &b,
+                            Clipper2Lib::Paths64 &target) {
+  for (const auto &b_path : b) {
     // We only need to add for positive components of b
     if (!b_path.empty() && Clipper2Lib::IsPositive(b_path) == 1) {
-      const auto& delta = b_path[0]; // arbitrary point
-      for (const auto& path : a) {
+      const auto &delta = b_path[0]; // arbitrary point
+      for (const auto &path : a) {
         target.push_back(path);
-        for (auto& point : target.back()) {
+        for (auto &point : target.back()) {
           point.x += delta.x;
           point.y += delta.y;
         }
@@ -97,61 +99,59 @@ void fill_minkowski_insides(const Clipper2Lib::Paths64& a,
   }
 }
 
-void SimplifyPolyTree(const Clipper2Lib::PolyPath64& polytree, double epsilon, Clipper2Lib::PolyPath64& result) {
-  for (const auto& child : polytree) {
-    Clipper2Lib::PolyPath64 *newchild = result.AddChild(Clipper2Lib::SimplifyPath(child->Polygon(), epsilon));
+void SimplifyPolyTree(const Clipper2Lib::PolyPath64 &polytree, double epsilon,
+                      Clipper2Lib::PolyPath64 &result) {
+  for (const auto &child : polytree) {
+    Clipper2Lib::PolyPath64 *newchild =
+        result.AddChild(Clipper2Lib::SimplifyPath(child->Polygon(), epsilon));
     SimplifyPolyTree(*child, epsilon, *newchild);
   }
 }
 
-}  // namespace
+} // namespace
 
 // Using 1 bit less precision than the maximum possible, to limit the chance
-// of data loss when converting back to double (see https://github.com/openscad/openscad/issues/5253).
-const int CLIPPER_BITS{ std::ilogb(0x3FFFFFFFFFFFFFFFLL) };
-
-int scaleBitsFromBounds(const BoundingBox& bounds, int total_bits)
-{
-  const double maxCoeff = std::max({
-      bounds.min().cwiseAbs().maxCoeff(),
-      bounds.max().cwiseAbs().maxCoeff(),
-      bounds.sizes().maxCoeff()
-    });
+// of data loss when converting back to double (see
+// https://github.com/openscad/openscad/issues/5253).
+const int CLIPPER_BITS{std::ilogb(0x3FFFFFFFFFFFFFFFLL)};
+
+int scaleBitsFromBounds(const BoundingBox &bounds, int total_bits) {
+  const double maxCoeff =
+      std::max({bounds.min().cwiseAbs().maxCoeff(),
+                bounds.max().cwiseAbs().maxCoeff(), bounds.sizes().maxCoeff()});
   const int exp = std::ilogb(maxCoeff) + 1;
   const int actual_bits = (total_bits == 0) ? CLIPPER_BITS : total_bits;
   return (actual_bits - 1) - exp;
 }
 
-int scaleBitsFromPrecision(int precision)
-{
+int scaleBitsFromPrecision(int precision) {
   return std::ilogb(std::pow(10, precision)) + 1;
 }
 
-Clipper2Lib::Paths64 fromPolygon2d(const Polygon2d& poly, int scale_bits)
-{
+Clipper2Lib::Paths64 fromPolygon2d(const Polygon2d &poly, int scale_bits) {
   const bool keep_orientation = poly.isSanitized();
   const double scale = std::ldexp(1.0, scale_bits);
   Clipper2Lib::Paths64 result;
-  for (const auto& outline : poly.outlines()) {
+  for (const auto &outline : poly.outlines()) {
     Clipper2Lib::Path64 p;
-    for (const auto& v : outline.vertices) {
+    for (const auto &v : outline.vertices) {
       p.emplace_back(v[0] * scale, v[1] * scale);
     }
     // Make sure all polygons point up, since we project also
     // back-facing polygon in PolySetUtils::project()
-    if (!keep_orientation && !Clipper2Lib::IsPositive(p)) std::reverse(p.begin(), p.end());
+    if (!keep_orientation && !Clipper2Lib::IsPositive(p))
+      std::reverse(p.begin(), p.end());
     result.push_back(std::move(p));
   }
   return result;
 }
 
-Clipper2Lib::Paths64 fromPolygon2d(const Polygon2d& poly)
-{
+Clipper2Lib::Paths64 fromPolygon2d(const Polygon2d &poly) {
   return fromPolygon2d(poly, scaleBitsFromPrecision());
 }
 
-std::unique_ptr<Clipper2Lib::PolyTree64> sanitize(const Clipper2Lib::Paths64& paths)
-{
+std::unique_ptr<Clipper2Lib::PolyTree64>
+sanitize(const Clipper2Lib::Paths64 &paths) {
   auto result = std::make_unique<Clipper2Lib::PolyTree64>();
   Clipper2Lib::Clipper64 clipper;
   clipper.PreserveCollinear(false);
@@ -164,12 +164,12 @@ std::unique_ptr<Clipper2Lib::PolyTree64> sanitize(const Clipper2Lib::Paths64& pa
     // TODO: Is this needed for Clipper2?
     LOG(message_group::Warning, "Range check failed for polygon. skipping");
   }
-  clipper.Execute(Clipper2Lib::ClipType::Union, Clipper2Lib::FillRule::EvenOdd, *result);
+  clipper.Execute(Clipper2Lib::ClipType::Union, Clipper2Lib::FillRule::EvenOdd,
+                  *result);
   return result;
 }
 
-std::unique_ptr<Polygon2d> sanitize(const Polygon2d& poly)
-{
+std::unique_ptr<Polygon2d> sanitize(const Polygon2d &poly) {
   auto scale_bits = scaleBitsFromPrecision();
 
   auto paths = ClipperUtils::fromPolygon2d(poly, scale_bits);
@@ -179,34 +179,39 @@ std::unique_ptr<Polygon2d> sanitize(const Polygon2d& poly)
 /*!
    We want to use a PolyTree to convert to Polygon2d, since only PolyTrees
    have an explicit notion of holes.
-   We could use a Paths structure, but we'd have to check the orientation of each
-   path before adding it to the Polygon2d.
+   We could use a Paths structure, but we'd have to check the orientation of
+   each path before adding it to the Polygon2d.
  */
-std::unique_ptr<Polygon2d> toPolygon2d(const Clipper2Lib::PolyTree64& polytree, int scale_bits)
-{
+std::unique_ptr<Polygon2d> toPolygon2d(const Clipper2Lib::PolyTree64 &polytree,
+                                       int scale_bits) {
   auto result = std::make_unique<Polygon2d>();
   const double scale = std::ldexp(1.0, -scale_bits);
-  auto processChildren = [scale, &result](auto&& processChildren, const Clipper2Lib::PolyPath64& node) -> void {
-      Outline2d outline;
-      // When using offset, clipper can get the hole status wrong.
-      // IsPositive() calculates the area of the polygon, and if it's negative, it's a hole.
-      outline.positive = IsPositive(node.Polygon());
-
-      constexpr double epsilon = 1.1415; // Epsilon taken from Clipper1's default epsilon.
-      const auto cleaned_path = Clipper2Lib::SimplifyPath(node.Polygon(), epsilon);
-
-      // SimplifyPath can potentially reduce the polygon down to no vertices
-      if (cleaned_path.size() >= 3) {
-        for (const auto& ip : cleaned_path) {
-          outline.vertices.emplace_back(scale * ip.x, scale * ip.y);
-        }
-        result->addOutline(outline);
+  auto processChildren =
+      [scale, &result](auto &&processChildren,
+                       const Clipper2Lib::PolyPath64 &node) -> void {
+    Outline2d outline;
+    // When using offset, clipper can get the hole status wrong.
+    // IsPositive() calculates the area of the polygon, and if it's negative,
+    // it's a hole.
+    outline.positive = IsPositive(node.Polygon());
+
+    constexpr double epsilon =
+        1.1415; // Epsilon taken from Clipper1's default epsilon.
+    const auto cleaned_path =
+        Clipper2Lib::SimplifyPath(node.Polygon(), epsilon);
+
+    // SimplifyPath can potentially reduce the polygon down to no vertices
+    if (cleaned_path.size() >= 3) {
+      for (const auto &ip : cleaned_path) {
+        outline.vertices.emplace_back(scale * ip.x, scale * ip.y);
       }
-      for (const auto& child : node) {
-        processChildren(processChildren, *child);
-      }
-    };
-  for (const auto& node : polytree) {
+      result->addOutline(outline);
+    }
+    for (const auto &child : node) {
+      processChildren(processChildren, *child);
+    }
+  };
+  for (const auto &node : polytree) {
     processChildren(processChildren, *node);
   }
   result->setSanitized(true);
@@ -218,14 +223,16 @@ std::unique_ptr<Polygon2d> toPolygon2d(const Clipper2Lib::PolyTree64& polytree,
 
    May return an empty Polygon2d, but will not return nullptr.
  */
-std::unique_ptr<Polygon2d> apply(const std::vector<Clipper2Lib::Paths64>& pathsvector,
-                                 Clipper2Lib::ClipType clipType, int scale_bits)
-{
+std::unique_ptr<Polygon2d>
+apply(const std::vector<Clipper2Lib::Paths64> &pathsvector,
+      Clipper2Lib::ClipType clipType, int scale_bits) {
   Clipper2Lib::Clipper64 clipper;
   clipper.PreserveCollinear(false);
 
-  if (clipType == Clipper2Lib::ClipType::Intersection && pathsvector.size() >= 2) {
-    // intersection operations must be split into a sequence of binary operations
+  if (clipType == Clipper2Lib::ClipType::Intersection &&
+      pathsvector.size() >= 2) {
+    // intersection operations must be split into a sequence of binary
+    // operations
     auto source = pathsvector[0];
     Clipper2Lib::PolyTree64 result;
     for (unsigned int i = 1; i < pathsvector.size(); ++i) {
@@ -241,7 +248,7 @@ std::unique_ptr<Polygon2d> apply(const std::vector<Clipper2Lib::Paths64>& pathsv
   }
 
   bool first = true;
-  for (const auto& paths : pathsvector) {
+  for (const auto &paths : pathsvector) {
     if (first) {
       clipper.AddSubject(paths);
       first = false;
@@ -262,13 +269,13 @@ std::unique_ptr<Polygon2d> apply(const std::vector<Clipper2Lib::Paths64>& pathsv
 
    May return an empty Polygon2d, but will not return nullptr.
  */
-std::unique_ptr<Polygon2d> apply(const std::vector<std::shared_ptr<const Polygon2d>>& polygons,
-                                 Clipper2Lib::ClipType clipType)
-{
+std::unique_ptr<Polygon2d>
+apply(const std::vector<std::shared_ptr<const Polygon2d>> &polygons,
+      Clipper2Lib::ClipType clipType) {
   const int scale_bits = scaleBitsFromPrecision();
 
   std::vector<Clipper2Lib::Paths64> pathsvector;
-  for (const auto& polygon : polygons) {
+  for (const auto &polygon : polygons) {
     if (polygon) {
       auto polypaths = fromPolygon2d(*polygon, scale_bits);
       if (!polygon->isSanitized()) {
@@ -276,7 +283,8 @@ std::unique_ptr<Polygon2d> apply(const std::vector<std::shared_ptr<const Polygon
       }
       pathsvector.push_back(std::move(polypaths));
     } else {
-      // Insert empty object as this could be the positive object in a difference
+      // Insert empty object as this could be the positive object in a
+      // difference
       pathsvector.emplace_back();
     }
   }
@@ -285,32 +293,38 @@ std::unique_ptr<Polygon2d> apply(const std::vector<std::shared_ptr<const Polygon
   return res;
 }
 
-std::unique_ptr<Polygon2d> applyMinkowski(const std::vector<std::shared_ptr<const Polygon2d>>& polygons)
-{
+std::unique_ptr<Polygon2d>
+applyMinkowski(const std::vector<std::shared_ptr<const Polygon2d>> &polygons) {
   if (polygons.size() == 1) {
-    return polygons[0] ? std::make_unique<Polygon2d>(*polygons[0]) : nullptr; // Just copy
+    return polygons[0] ? std::make_unique<Polygon2d>(*polygons[0])
+                       : nullptr; // Just copy
   }
 
   auto it = polygons.begin();
-  while (it != polygons.end() && !(*it)) ++it;
-  if (it == polygons.end()) return nullptr;
+  while (it != polygons.end() && !(*it))
+    ++it;
+  if (it == polygons.end())
+    return nullptr;
   const int scale_bits = scaleBitsFromPrecision();
 
   Clipper2Lib::Clipper64 clipper;
   clipper.PreserveCollinear(false);
-  auto lhs = fromPolygon2d(polygons[0] ? *polygons[0] : Polygon2d(), scale_bits);
+  auto lhs =
+      fromPolygon2d(polygons[0] ? *polygons[0] : Polygon2d(), scale_bits);
 
   for (size_t i = 1; i < polygons.size(); ++i) {
-    if (!polygons[i]) continue;
+    if (!polygons[i])
+      continue;
     Clipper2Lib::Paths64 minkowski_terms;
     auto rhs = fromPolygon2d(*polygons[i], scale_bits);
 
     // First, convolve each outline of lhs with the outlines of rhs
-    for (auto const& rhs_path : rhs) {
-      for (auto const& lhs_path : lhs) {
+    for (auto const &rhs_path : rhs) {
+      for (auto const &lhs_path : lhs) {
         Clipper2Lib::Paths64 result;
         minkowski_outline(lhs_path, rhs_path, result, true, true);
-        minkowski_terms.insert(minkowski_terms.end(), result.begin(), result.end());
+        minkowski_terms.insert(minkowski_terms.end(), result.begin(),
+                               result.end());
       }
     }
 
@@ -318,31 +332,33 @@ std::unique_ptr<Polygon2d> applyMinkowski(const std::vector<std::shared_ptr<cons
     fill_minkowski_insides(lhs, rhs, minkowski_terms);
     fill_minkowski_insides(rhs, lhs, minkowski_terms);
 
-    // This union operation must be performed at each iteration since the minkowski_terms
-    // now contain lots of small quads
+    // This union operation must be performed at each iteration since the
+    // minkowski_terms now contain lots of small quads
     clipper.Clear();
     clipper.AddSubject(minkowski_terms);
 
     if (i != polygons.size() - 1) {
-      clipper.Execute(Clipper2Lib::ClipType::Union, Clipper2Lib::FillRule::NonZero, lhs);
+      clipper.Execute(Clipper2Lib::ClipType::Union,
+                      Clipper2Lib::FillRule::NonZero, lhs);
     }
   }
 
   Clipper2Lib::PolyTree64 polytree;
-  clipper.Execute(Clipper2Lib::ClipType::Union, Clipper2Lib::FillRule::NonZero, polytree);
+  clipper.Execute(Clipper2Lib::ClipType::Union, Clipper2Lib::FillRule::NonZero,
+                  polytree);
   return toPolygon2d(polytree, scale_bits);
 }
 
-std::unique_ptr<Polygon2d> applyOffset(const Polygon2d& poly, double offset, Clipper2Lib::JoinType joinType,
-                                       double miter_limit, double arc_tolerance)
-{
+std::unique_ptr<Polygon2d> applyOffset(const Polygon2d &poly, double offset,
+                                       Clipper2Lib::JoinType joinType,
+                                       double miter_limit,
+                                       double arc_tolerance) {
   const bool isMiter = joinType == Clipper2Lib::JoinType::Miter;
   const bool isRound = joinType == Clipper2Lib::JoinType::Round;
   const int scale_bits = scaleBitsFromPrecision();
-  Clipper2Lib::ClipperOffset co(
-    isMiter ? miter_limit : 2.0,
-    isRound ? std::ldexp(arc_tolerance, scale_bits) : 1.0
-    );
+  Clipper2Lib::ClipperOffset co(isMiter ? miter_limit : 2.0,
+                                isRound ? std::ldexp(arc_tolerance, scale_bits)
+                                        : 1.0);
   auto p = ClipperUtils::fromPolygon2d(poly, scale_bits);
   co.AddPaths(p, joinType, Clipper2Lib::EndType::Polygon);
   Clipper2Lib::PolyTree64 result;
@@ -350,26 +366,31 @@ std::unique_ptr<Polygon2d> applyOffset(const Polygon2d& poly, double offset, Cli
   return toPolygon2d(result, scale_bits);
 }
 
-std::unique_ptr<Polygon2d> applyProjection(const std::vector<std::shared_ptr<const Polygon2d>>& polygons)
-{
+std::unique_ptr<Polygon2d>
+applyProjection(const std::vector<std::shared_ptr<const Polygon2d>> &polygons) {
   const int scale_bits = scaleBitsFromPrecision();
 
   Clipper2Lib::Clipper64 sumclipper;
   sumclipper.PreserveCollinear(false);
-  for (const auto& poly : polygons) {
-    Clipper2Lib::Paths64 result = ClipperUtils::fromPolygon2d(*poly, scale_bits);
+  for (const auto &poly : polygons) {
+    Clipper2Lib::Paths64 result =
+        ClipperUtils::fromPolygon2d(*poly, scale_bits);
     // Using NonZero ensures that we don't create holes from polygons sharing
     // edges since we're unioning a mesh
-    result = ClipperUtils::process(result, Clipper2Lib::ClipType::Union, Clipper2Lib::FillRule::NonZero);
+    result = ClipperUtils::process(result, Clipper2Lib::ClipType::Union,
+                                   Clipper2Lib::FillRule::NonZero);
     // Add correctly winded polygons to the main clipper
     sumclipper.AddSubject(result);
   }
 
   Clipper2Lib::PolyTree64 sumresult;
-  // This is key - without StrictlySimple, we tend to get self-intersecting results
-  // FIXME: StrictlySimple doesn't exist in Clipper2. Check if it still exposes problems without
+  // This is key - without StrictlySimple, we tend to get self-intersecting
+  // results
+  // FIXME: StrictlySimple doesn't exist in Clipper2. Check if it still exposes
+  // problems without
   //  sumclipper.StrictlySimple(true);
-  sumclipper.Execute(Clipper2Lib::ClipType::Union, Clipper2Lib::FillRule::NonZero, sumresult);
+  sumclipper.Execute(Clipper2Lib::ClipType::Union,
+                     Clipper2Lib::FillRule::NonZero, sumresult);
   if (sumresult.Count() > 0) {
     return ClipperUtils::toPolygon2d(sumresult, scale_bits);
   }
diff --git a/src/geometry/ClipperUtils.h b/src/geometry/ClipperUtils.h
index daf9657b5..5a485a7a2 100644
--- a/src/geometry/ClipperUtils.h
+++ b/src/geometry/ClipperUtils.h
@@ -1,8 +1,8 @@
 #pragma once
 
 #include "clipper2/clipper.h"
-#include "geometry/linalg.h"
 #include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 
 #include <memory>
 #include <vector>
@@ -11,17 +11,26 @@ namespace ClipperUtils {
 
 constexpr int DEFAULT_PRECISION = 8;
 
-int scaleBitsFromBounds(const BoundingBox& bounds, int bits = 0);
+int scaleBitsFromBounds(const BoundingBox &bounds, int bits = 0);
 int scaleBitsFromPrecision(int precision = DEFAULT_PRECISION);
 
-std::unique_ptr<Clipper2Lib::PolyTree64> sanitize(const Clipper2Lib::Paths64& paths);
-std::unique_ptr<Polygon2d> sanitize(const Polygon2d& poly);
-
-Clipper2Lib::Paths64 fromPolygon2d(const Polygon2d& poly, int scale_bits);
-std::unique_ptr<Polygon2d> toPolygon2d(const Clipper2Lib::PolyTree64& poly, int scale_bits);
-
-std::unique_ptr<Polygon2d> applyOffset(const Polygon2d& poly, double offset, Clipper2Lib::JoinType joinType, double miter_limit, double arc_tolerance);
-std::unique_ptr<Polygon2d> applyMinkowski(const std::vector<std::shared_ptr<const Polygon2d>>& polygons);
-std::unique_ptr<Polygon2d> applyProjection(const std::vector<std::shared_ptr<const Polygon2d>>& polygons);
-std::unique_ptr<Polygon2d> apply(const std::vector<std::shared_ptr<const Polygon2d>>& polygons, Clipper2Lib::ClipType);
-}
+std::unique_ptr<Clipper2Lib::PolyTree64>
+sanitize(const Clipper2Lib::Paths64 &paths);
+std::unique_ptr<Polygon2d> sanitize(const Polygon2d &poly);
+
+Clipper2Lib::Paths64 fromPolygon2d(const Polygon2d &poly, int scale_bits);
+std::unique_ptr<Polygon2d> toPolygon2d(const Clipper2Lib::PolyTree64 &poly,
+                                       int scale_bits);
+
+std::unique_ptr<Polygon2d> applyOffset(const Polygon2d &poly, double offset,
+                                       Clipper2Lib::JoinType joinType,
+                                       double miter_limit,
+                                       double arc_tolerance);
+std::unique_ptr<Polygon2d>
+applyMinkowski(const std::vector<std::shared_ptr<const Polygon2d>> &polygons);
+std::unique_ptr<Polygon2d>
+applyProjection(const std::vector<std::shared_ptr<const Polygon2d>> &polygons);
+std::unique_ptr<Polygon2d>
+apply(const std::vector<std::shared_ptr<const Polygon2d>> &polygons,
+      Clipper2Lib::ClipType);
+} // namespace ClipperUtils
diff --git a/src/geometry/Geometry.cc b/src/geometry/Geometry.cc
index d9a46927e..dd215f6d2 100644
--- a/src/geometry/Geometry.cc
+++ b/src/geometry/Geometry.cc
@@ -1,54 +1,49 @@
 #include "geometry/Geometry.h"
 #include "geometry/linalg.h"
 #include "utils/printutils.h"
-#include <sstream>
-#include <memory>
 #include <boost/foreach.hpp>
 #include <cstddef>
+#include <memory>
+#include <sstream>
 #include <string>
 #include <utility>
 
-GeometryList::GeometryList(Geometry::Geometries geometries) : children(std::move(geometries))
-{
-}
+GeometryList::GeometryList(Geometry::Geometries geometries)
+    : children(std::move(geometries)) {}
 
-std::unique_ptr<Geometry> GeometryList::copy() const
-{
+std::unique_ptr<Geometry> GeometryList::copy() const {
   return std::make_unique<GeometryList>(*this);
 }
 
-size_t GeometryList::memsize() const
-{
+size_t GeometryList::memsize() const {
   size_t sum = 0;
-  for (const auto& item : this->children) {
+  for (const auto &item : this->children) {
     sum += item.second->memsize();
   }
   return sum;
 }
 
-BoundingBox GeometryList::getBoundingBox() const
-{
+BoundingBox GeometryList::getBoundingBox() const {
   BoundingBox bbox;
-  for (const auto& item : this->children) {
+  for (const auto &item : this->children) {
     bbox.extend(item.second->getBoundingBox());
   }
   return bbox;
 }
 
-std::string GeometryList::dump() const
-{
+std::string GeometryList::dump() const {
   std::stringstream out;
-  for (const auto& item : this->children) {
+  for (const auto &item : this->children) {
     out << item.second->dump();
   }
   return out.str();
 }
 
-unsigned int GeometryList::getDimension() const
-{
+unsigned int GeometryList::getDimension() const {
   unsigned int dim = 0;
-  for (const auto& item : this->children) {
-    if (!dim) dim = item.second->getDimension();
+  for (const auto &item : this->children) {
+    if (!dim)
+      dim = item.second->getDimension();
     else if (dim != item.second->getDimension()) {
       LOG(message_group::Warning, "Mixing 2D and 3D objects is not supported.");
       break;
@@ -57,18 +52,19 @@ unsigned int GeometryList::getDimension() const
   return dim;
 }
 
-bool GeometryList::isEmpty() const
-{
-  for (const auto& item : this->children) {
-    if (!item.second->isEmpty()) return false;
+bool GeometryList::isEmpty() const {
+  for (const auto &item : this->children) {
+    if (!item.second->isEmpty())
+      return false;
   }
   return true;
 }
 
-void flatten(const GeometryList& geomlist, GeometryList::Geometries& childlist)
-{
-  for (const auto& item : geomlist.getChildren()) {
-    if (const auto chlist = std::dynamic_pointer_cast<const GeometryList>(item.second)) {
+void flatten(const GeometryList &geomlist,
+             GeometryList::Geometries &childlist) {
+  for (const auto &item : geomlist.getChildren()) {
+    if (const auto chlist =
+            std::dynamic_pointer_cast<const GeometryList>(item.second)) {
       flatten(*chlist, childlist);
     } else {
       childlist.push_back(item);
@@ -81,8 +77,7 @@ void flatten(const GeometryList& geomlist, GeometryList::Geometries& childlist)
    children directly reachable GeometryLists are collected in a flat
    list)
  */
-Geometry::Geometries GeometryList::flatten() const
-{
+Geometry::Geometries GeometryList::flatten() const {
   Geometries newchildren;
   ::flatten(*this, newchildren);
   return newchildren;
diff --git a/src/geometry/Geometry.h b/src/geometry/Geometry.h
index 6ae983c06..b38dc74ef 100644
--- a/src/geometry/Geometry.h
+++ b/src/geometry/Geometry.h
@@ -1,11 +1,11 @@
 #pragma once
 
 #include <cassert>
-#include <utility>
 #include <cstddef>
-#include <string>
 #include <list>
 #include <memory>
+#include <string>
+#include <utility>
 
 #include "geometry/linalg.h"
 
@@ -19,17 +19,17 @@ class PolySet;
 class ManifoldGeometry;
 #endif
 
-class Geometry
-{
+class Geometry {
 public:
-  using GeometryItem = std::pair<std::shared_ptr<const AbstractNode>, std::shared_ptr<const Geometry>>;
+  using GeometryItem = std::pair<std::shared_ptr<const AbstractNode>,
+                                 std::shared_ptr<const Geometry>>;
   using Geometries = std::list<GeometryItem>;
 
   Geometry() = default;
-  Geometry(const Geometry&) = default;
-  Geometry& operator=(const Geometry&) = default;
-  Geometry(Geometry&&) = default;
-  Geometry& operator=(Geometry&&) = default;
+  Geometry(const Geometry &) = default;
+  Geometry &operator=(const Geometry &) = default;
+  Geometry(Geometry &&) = default;
+  Geometry &operator=(Geometry &&) = default;
   virtual ~Geometry() = default;
 
   [[nodiscard]] virtual size_t memsize() const = 0;
@@ -41,43 +41,44 @@ public:
   [[nodiscard]] virtual size_t numFacets() const = 0;
   [[nodiscard]] unsigned int getConvexity() const { return convexity; }
   void setConvexity(int c) { this->convexity = c; }
-  virtual void setColor(const Color4f& c) {}
+  virtual void setColor(const Color4f &c) {}
 
-  virtual void transform(const Transform3d& /*mat*/) { assert(!"transform not implemented!"); }
-  virtual void resize(const Vector3d& /*newsize*/, const Eigen::Matrix<bool, 3, 1>& /*autosize*/) {
+  virtual void transform(const Transform3d & /*mat*/) {
+    assert(!"transform not implemented!");
+  }
+  virtual void resize(const Vector3d & /*newsize*/,
+                      const Eigen::Matrix<bool, 3, 1> & /*autosize*/) {
     assert(!"resize not implemented!");
   }
 
-  virtual void accept(GeometryVisitor& visitor) const = 0;
+  virtual void accept(GeometryVisitor &visitor) const = 0;
+
 protected:
   int convexity{1};
 };
 
 /**
- * A Base class for simple visitors to process different Geometry subclasses uniformly
+ * A Base class for simple visitors to process different Geometry subclasses
+ * uniformly
  */
-class GeometryVisitor
-{
+class GeometryVisitor {
 public:
-  virtual void visit(const GeometryList& node) = 0;
-  virtual void visit(const PolySet& node) = 0;
-  virtual void visit(const Polygon2d& node) = 0;
+  virtual void visit(const GeometryList &node) = 0;
+  virtual void visit(const PolySet &node) = 0;
+  virtual void visit(const Polygon2d &node) = 0;
 #ifdef ENABLE_CGAL
-  virtual void visit(const CGALNefGeometry& node) = 0;
+  virtual void visit(const CGALNefGeometry &node) = 0;
 #endif
 #ifdef ENABLE_MANIFOLD
-  virtual void visit(const ManifoldGeometry& node) = 0;
+  virtual void visit(const ManifoldGeometry &node) = 0;
 #endif
   virtual ~GeometryVisitor() = default;
 };
 
-#define VISITABLE_GEOMETRY() \
-        void accept(GeometryVisitor & visitor) const override { \
-          visitor.visit(*this); \
-        }
+#define VISITABLE_GEOMETRY()                                                   \
+  void accept(GeometryVisitor &visitor) const override { visitor.visit(*this); }
 
-class GeometryList : public Geometry
-{
+class GeometryList : public Geometry {
 public:
   VISITABLE_GEOMETRY();
   Geometries children;
@@ -91,12 +92,12 @@ public:
   [[nodiscard]] unsigned int getDimension() const override;
   [[nodiscard]] bool isEmpty() const override;
   [[nodiscard]] std::unique_ptr<Geometry> copy() const override;
-  [[nodiscard]] size_t numFacets() const override { assert(false && "not implemented"); return 0; }
-
-  [[nodiscard]] const Geometries& getChildren() const {
-    return this->children;
+  [[nodiscard]] size_t numFacets() const override {
+    assert(false && "not implemented");
+    return 0;
   }
 
-  [[nodiscard]] Geometries flatten() const;
+  [[nodiscard]] const Geometries &getChildren() const { return this->children; }
 
+  [[nodiscard]] Geometries flatten() const;
 };
diff --git a/src/geometry/GeometryCache.cc b/src/geometry/GeometryCache.cc
index a1877f17e..6aa19146e 100644
--- a/src/geometry/GeometryCache.cc
+++ b/src/geometry/GeometryCache.cc
@@ -1,9 +1,9 @@
 #include "geometry/GeometryCache.h"
-#include "utils/printutils.h"
 #include "geometry/Geometry.h"
+#include "utils/printutils.h"
 
-#include <memory>
 #include <cstddef>
+#include <memory>
 #include <string>
 
 #ifdef ENABLE_CGAL
@@ -12,56 +12,52 @@
 
 GeometryCache *GeometryCache::inst = nullptr;
 
-std::shared_ptr<const Geometry> GeometryCache::get(const std::string& id) const
-{
-  const auto& geom = this->cache[id]->geom;
+std::shared_ptr<const Geometry>
+GeometryCache::get(const std::string &id) const {
+  const auto &geom = this->cache[id]->geom;
 #ifdef DEBUG
-  PRINTDB("Geometry Cache hit: %s (%d bytes)", id.substr(0, 40) % (geom ? geom->memsize() : 0));
+  PRINTDB("Geometry Cache hit: %s (%d bytes)",
+          id.substr(0, 40) % (geom ? geom->memsize() : 0));
 #endif
   return geom;
 }
 
-bool GeometryCache::insert(const std::string& id, const std::shared_ptr<const Geometry>& geom)
-{
-  auto inserted = this->cache.insert(id, new cache_entry(geom), geom ? geom->memsize() : 0);
+bool GeometryCache::insert(const std::string &id,
+                           const std::shared_ptr<const Geometry> &geom) {
+  auto inserted =
+      this->cache.insert(id, new cache_entry(geom), geom ? geom->memsize() : 0);
 #if defined(ENABLE_CGAL) && defined(DEBUG)
   assert(!dynamic_cast<const CGALNefGeometry *>(geom.get()));
-  if (inserted) PRINTDB("Geometry Cache insert: %s (%d bytes)",
-                        id.substr(0, 40) % (geom ? geom->memsize() : 0));
-  else PRINTDB("Geometry Cache insert failed: %s (%d bytes)",
-               id.substr(0, 40) % (geom ? geom->memsize() : 0));
+  if (inserted)
+    PRINTDB("Geometry Cache insert: %s (%d bytes)",
+            id.substr(0, 40) % (geom ? geom->memsize() : 0));
+  else
+    PRINTDB("Geometry Cache insert failed: %s (%d bytes)",
+            id.substr(0, 40) % (geom ? geom->memsize() : 0));
 #endif
   return inserted;
 }
 
-size_t GeometryCache::size() const
-{
-  return cache.size();
-}
+size_t GeometryCache::size() const { return cache.size(); }
 
-size_t GeometryCache::totalCost() const
-{
-  return cache.totalCost();
-}
+size_t GeometryCache::totalCost() const { return cache.totalCost(); }
 
-size_t GeometryCache::maxSizeMB() const
-{
+size_t GeometryCache::maxSizeMB() const {
   return this->cache.maxCost() / (1024ul * 1024ul);
 }
 
-void GeometryCache::setMaxSizeMB(size_t limit)
-{
+void GeometryCache::setMaxSizeMB(size_t limit) {
   this->cache.setMaxCost(limit * 1024ul * 1024ul);
 }
 
-void GeometryCache::print()
-{
+void GeometryCache::print() {
   LOG("Geometries in cache: %1$d", this->cache.size());
   LOG("Geometry cache size in bytes: %1$d", this->cache.totalCost());
 }
 
-GeometryCache::cache_entry::cache_entry(const std::shared_ptr<const Geometry>& geom)
-  : geom(geom)
-{
-  if (print_messages_stack.size() > 0) this->msg = print_messages_stack.back();
+GeometryCache::cache_entry::cache_entry(
+    const std::shared_ptr<const Geometry> &geom)
+    : geom(geom) {
+  if (print_messages_stack.size() > 0)
+    this->msg = print_messages_stack.back();
 }
diff --git a/src/geometry/GeometryCache.h b/src/geometry/GeometryCache.h
index 7bbcd3e55..cbfb1c6cc 100644
--- a/src/geometry/GeometryCache.h
+++ b/src/geometry/GeometryCache.h
@@ -7,16 +7,23 @@
 #include "Cache.h"
 #include "geometry/Geometry.h"
 
-class GeometryCache
-{
+class GeometryCache {
 public:
-  GeometryCache(size_t memorylimit = 100ul * 1024ul * 1024ul) : cache(memorylimit) {}
-
-  static GeometryCache *instance() { if (!inst) inst = new GeometryCache; return inst; }
-
-  bool contains(const std::string& id) const { return this->cache.contains(id); }
-  std::shared_ptr<const class Geometry> get(const std::string& id) const;
-  bool insert(const std::string& id, const std::shared_ptr<const Geometry>& geom);
+  GeometryCache(size_t memorylimit = 100ul * 1024ul * 1024ul)
+      : cache(memorylimit) {}
+
+  static GeometryCache *instance() {
+    if (!inst)
+      inst = new GeometryCache;
+    return inst;
+  }
+
+  bool contains(const std::string &id) const {
+    return this->cache.contains(id);
+  }
+  std::shared_ptr<const class Geometry> get(const std::string &id) const;
+  bool insert(const std::string &id,
+              const std::shared_ptr<const Geometry> &geom);
   size_t size() const;
   size_t totalCost() const;
   size_t maxSizeMB() const;
@@ -30,7 +37,7 @@ private:
   struct cache_entry {
     std::shared_ptr<const class Geometry> geom;
     std::string msg;
-    cache_entry(const std::shared_ptr<const Geometry>& geom);
+    cache_entry(const std::shared_ptr<const Geometry> &geom);
   };
 
   Cache<std::string, cache_entry> cache;
diff --git a/src/geometry/GeometryEvaluator.cc b/src/geometry/GeometryEvaluator.cc
index d65ae2270..e56ebb575 100644
--- a/src/geometry/GeometryEvaluator.cc
+++ b/src/geometry/GeometryEvaluator.cc
@@ -1,45 +1,44 @@
 #include "geometry/GeometryEvaluator.h"
-#include "geometry/Geometry.h"
-#include "geometry/cgal/cgal.h"
-#include "geometry/linalg.h"
-#include "core/Tree.h"
-#include "geometry/GeometryCache.h"
-#include "geometry/Polygon2d.h"
-#include "core/ModuleInstantiation.h"
-#include "core/State.h"
+#include "core/CgalAdvNode.h"
 #include "core/ColorNode.h"
-#include "core/OffsetNode.h"
-#include "core/TransformNode.h"
+#include "core/CsgOpNode.h"
 #include "core/LinearExtrudeNode.h"
+#include "core/ModuleInstantiation.h"
+#include "core/OffsetNode.h"
+#include "core/ProjectionNode.h"
+#include "core/RenderNode.h"
 #include "core/RoofNode.h"
-#include "geometry/roof_ss.h"
-#include "geometry/roof_vd.h"
 #include "core/RotateExtrudeNode.h"
-#include "core/CgalAdvNode.h"
-#include "core/ProjectionNode.h"
-#include "core/CsgOpNode.h"
+#include "core/State.h"
 #include "core/TextNode.h"
-#include "core/RenderNode.h"
+#include "core/TransformNode.h"
+#include "core/Tree.h"
 #include "geometry/ClipperUtils.h"
-#include "geometry/PolySetUtils.h"
+#include "geometry/Geometry.h"
+#include "geometry/GeometryCache.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetBuilder.h"
-#include "utils/calc.h"
-#include "utils/printutils.h"
-#include "utils/calc.h"
+#include "geometry/PolySetUtils.h"
+#include "geometry/Polygon2d.h"
+#include "geometry/boolean_utils.h"
+#include "geometry/cgal/cgal.h"
+#include "geometry/linalg.h"
+#include "geometry/roof_ss.h"
+#include "geometry/roof_vd.h"
 #include "glview/RenderSettings.h"
+#include "utils/calc.h"
 #include "utils/degree_trig.h"
-#include <iterator>
+#include "utils/printutils.h"
 #include <cassert>
+#include <iterator>
 #include <list>
-#include <utility>
 #include <memory>
-#include "geometry/boolean_utils.h"
+#include <utility>
 #ifdef ENABLE_CGAL
 #include "geometry/cgal/CGALCache.h"
 #include "geometry/cgal/cgalutils.h"
-#include <CGAL/convex_hull_2.h>
 #include <CGAL/Point_2.h>
+#include <CGAL/convex_hull_2.h>
 #endif
 #ifdef ENABLE_MANIFOLD
 #include "geometry/manifold/manifoldutils.h"
@@ -53,19 +52,21 @@ class Geometry;
 class Polygon2d;
 class Tree;
 
-GeometryEvaluator::GeometryEvaluator(const Tree& tree) : tree(tree) { }
+GeometryEvaluator::GeometryEvaluator(const Tree &tree) : tree(tree) {}
 
 /*!
    Set allownef to false to force the result to _not_ be a Nef polyhedron
 
    There are some guarantees on the returned geometry:
- * 2D and 3D geometry cannot be mixed; we will return either _only_ 2D or _only_ 3D geometries
- * PolySet geometries are always 3D. 2D Polysets are only created for special-purpose rendering operations downstream from here.
- * Needs validation: Implementation-specific geometries shouldn't be mixed (Nef polyhedron, Manifold)
+ * 2D and 3D geometry cannot be mixed; we will return either _only_ 2D or _only_
+ 3D geometries
+ * PolySet geometries are always 3D. 2D Polysets are only created for
+ special-purpose rendering operations downstream from here.
+ * Needs validation: Implementation-specific geometries shouldn't be mixed (Nef
+ polyhedron, Manifold)
  */
-std::shared_ptr<const Geometry> GeometryEvaluator::evaluateGeometry(const AbstractNode& node,
-                                                                    bool allownef)
-{
+std::shared_ptr<const Geometry>
+GeometryEvaluator::evaluateGeometry(const AbstractNode &node, bool allownef) {
   auto result = smartCacheGet(node, allownef);
   if (!result) {
     // If not found in any caches, we need to evaluate the geometry
@@ -79,15 +80,19 @@ std::shared_ptr<const Geometry> GeometryEvaluator::evaluateGeometry(const Abstra
   }
 
   // Convert engine-specific 3D geometry to PolySet if needed
-  // Note: we don't store the converted into the cache as it would conflict with subsequent calls where allownef is true.
+  // Note: we don't store the converted into the cache as it would conflict with
+  // subsequent calls where allownef is true.
   if (!allownef) {
     if (auto ps = PolySetUtils::getGeometryAsPolySet(result)) {
       assert(ps->getDimension() == 3);
       // We cannot render concave polygons, so tessellate any PolySets
       if (!ps->isEmpty() && !ps->isTriangular()) {
-        // Since is_convex() doesn't handle non-planar faces, we need to tessellate
-        // also in the indeterminate state so we cannot just use a boolean comparison. See #1061
-        bool convex = bool(ps->convexValue()); // bool is true only if tribool is true, (not indeterminate and not false)
+        // Since is_convex() doesn't handle non-planar faces, we need to
+        // tessellate also in the indeterminate state so we cannot just use a
+        // boolean comparison. See #1061
+        bool convex =
+            bool(ps->convexValue()); // bool is true only if tribool is true,
+                                     // (not indeterminate and not false)
         if (!convex) {
           ps = PolySetUtils::tessellate_faces(*ps);
         }
@@ -98,25 +103,34 @@ std::shared_ptr<const Geometry> GeometryEvaluator::evaluateGeometry(const Abstra
   return result;
 }
 
-bool GeometryEvaluator::isValidDim(const Geometry::GeometryItem& item, unsigned int& dim) const {
+bool GeometryEvaluator::isValidDim(const Geometry::GeometryItem &item,
+                                   unsigned int &dim) const {
   if (!item.first->modinst->isBackground() && item.second) {
-    if (!dim) dim = item.second->getDimension();
+    if (!dim)
+      dim = item.second->getDimension();
     else if (dim != item.second->getDimension() && !item.second->isEmpty()) {
-      LOG(message_group::Warning, item.first->modinst->location(), this->tree.getDocumentPath(), "Mixing 2D and 3D objects is not supported");
+      LOG(message_group::Warning, item.first->modinst->location(),
+          this->tree.getDocumentPath(),
+          "Mixing 2D and 3D objects is not supported");
       return false;
     }
   }
   return true;
 }
 
-GeometryEvaluator::ResultObject GeometryEvaluator::applyToChildren(const AbstractNode& node, OpenSCADOperator op)
-{
+GeometryEvaluator::ResultObject
+GeometryEvaluator::applyToChildren(const AbstractNode &node,
+                                   OpenSCADOperator op) {
   unsigned int dim = 0;
-  for (const auto& item : this->visitedchildren[node.index()]) {
-    if (!isValidDim(item, dim)) break;
+  for (const auto &item : this->visitedchildren[node.index()]) {
+    if (!isValidDim(item, dim))
+      break;
   }
-  if (dim == 2) return ResultObject::mutableResult(std::shared_ptr<Geometry>(applyToChildren2D(node, op)));
-  else if (dim == 3) return applyToChildren3D(node, op);
+  if (dim == 2)
+    return ResultObject::mutableResult(
+        std::shared_ptr<Geometry>(applyToChildren2D(node, op)));
+  else if (dim == 3)
+    return applyToChildren3D(node, op);
   return {};
 }
 
@@ -125,81 +139,90 @@ GeometryEvaluator::ResultObject GeometryEvaluator::applyToChildren(const Abstrac
 
    May return nullptr or any 3D Geometry object
  */
-GeometryEvaluator::ResultObject GeometryEvaluator::applyToChildren3D(const AbstractNode& node, OpenSCADOperator op)
-{
+GeometryEvaluator::ResultObject
+GeometryEvaluator::applyToChildren3D(const AbstractNode &node,
+                                     OpenSCADOperator op) {
   Geometry::Geometries children = collectChildren3D(node);
-  if (children.empty()) return {};
+  if (children.empty())
+    return {};
 
   if (op == OpenSCADOperator::HULL) {
-    return ResultObject::mutableResult(std::shared_ptr<Geometry>(applyHull(children)));
+    return ResultObject::mutableResult(
+        std::shared_ptr<Geometry>(applyHull(children)));
   } else if (op == OpenSCADOperator::FILL) {
-    for (const auto& item : children) {
-      LOG(message_group::Warning, item.first->modinst->location(), this->tree.getDocumentPath(), "fill() not yet implemented for 3D");
+    for (const auto &item : children) {
+      LOG(message_group::Warning, item.first->modinst->location(),
+          this->tree.getDocumentPath(), "fill() not yet implemented for 3D");
     }
   }
 
   // Only one child -> this is a noop
-  if (children.size() == 1) return ResultObject::constResult(children.front().second);
+  if (children.size() == 1)
+    return ResultObject::constResult(children.front().second);
 
   switch (op) {
-  case OpenSCADOperator::MINKOWSKI:
-  {
+  case OpenSCADOperator::MINKOWSKI: {
     Geometry::Geometries actualchildren;
-    for (const auto& item : children) {
-      if (item.second && !item.second->isEmpty()) actualchildren.push_back(item);
+    for (const auto &item : children) {
+      if (item.second && !item.second->isEmpty())
+        actualchildren.push_back(item);
     }
-    if (actualchildren.empty()) return {};
-    if (actualchildren.size() == 1) return ResultObject::constResult(actualchildren.front().second);
+    if (actualchildren.empty())
+      return {};
+    if (actualchildren.size() == 1)
+      return ResultObject::constResult(actualchildren.front().second);
     return ResultObject::constResult(applyMinkowski(actualchildren));
     break;
   }
-  case OpenSCADOperator::UNION:
-  {
+  case OpenSCADOperator::UNION: {
     Geometry::Geometries actualchildren;
-    for (const auto& item : children) {
-      if (item.second && !item.second->isEmpty()) actualchildren.push_back(item);
+    for (const auto &item : children) {
+      if (item.second && !item.second->isEmpty())
+        actualchildren.push_back(item);
     }
-    if (actualchildren.empty()) return {};
-    if (actualchildren.size() == 1) return ResultObject::constResult(actualchildren.front().second);
+    if (actualchildren.empty())
+      return {};
+    if (actualchildren.size() == 1)
+      return ResultObject::constResult(actualchildren.front().second);
 #ifdef ENABLE_MANIFOLD
     if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
-      return ResultObject::mutableResult(ManifoldUtils::applyOperator3DManifold(actualchildren, op));
+      return ResultObject::mutableResult(
+          ManifoldUtils::applyOperator3DManifold(actualchildren, op));
     }
 #endif
 #ifdef ENABLE_CGAL
-    return ResultObject::constResult(std::shared_ptr<const Geometry>(CGALUtils::applyUnion3D(actualchildren.begin(), actualchildren.end())));
+    return ResultObject::constResult(std::shared_ptr<const Geometry>(
+        CGALUtils::applyUnion3D(actualchildren.begin(), actualchildren.end())));
 #else
     assert(false && "No boolean backend available");
 #endif
     break;
   }
-  default:
-  {
+  default: {
 #ifdef ENABLE_MANIFOLD
     if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
-      return ResultObject::mutableResult(ManifoldUtils::applyOperator3DManifold(children, op));
+      return ResultObject::mutableResult(
+          ManifoldUtils::applyOperator3DManifold(children, op));
     }
 #endif
 #ifdef ENABLE_CGAL
     return ResultObject::constResult(CGALUtils::applyOperator3D(children, op));
 #else
     assert(false && "No boolean backend available");
-    #endif
+#endif
     break;
   }
   }
 }
 
-
-
 /*!
    Apply 2D hull.
 
    May return an empty geometry but will not return nullptr.
  */
 
-std::unique_ptr<Polygon2d> GeometryEvaluator::applyHull2D(const AbstractNode& node)
-{
+std::unique_ptr<Polygon2d>
+GeometryEvaluator::applyHull2D(const AbstractNode &node) {
   auto children = collectChildren2D(node);
   auto geometry = std::make_unique<Polygon2d>();
 
@@ -207,10 +230,10 @@ std::unique_ptr<Polygon2d> GeometryEvaluator::applyHull2D(const AbstractNode& no
   using CGALPoint2 = CGAL::Point_2<CGAL_DoubleKernel>;
   // Collect point cloud
   std::list<CGALPoint2> points;
-  for (const auto& p : children) {
+  for (const auto &p : children) {
     if (p) {
-      for (const auto& o : p->outlines()) {
-        for (const auto& v : o.vertices) {
+      for (const auto &o : p->outlines()) {
+        for (const auto &v : o.vertices) {
           points.emplace_back(v[0], v[1]);
         }
       }
@@ -220,31 +243,35 @@ std::unique_ptr<Polygon2d> GeometryEvaluator::applyHull2D(const AbstractNode& no
     // Apply hull
     std::list<CGALPoint2> result;
     try {
-      CGAL::convex_hull_2(points.begin(), points.end(), std::back_inserter(result));
+      CGAL::convex_hull_2(points.begin(), points.end(),
+                          std::back_inserter(result));
       // Construct Polygon2d
       Outline2d outline;
-      for (const auto& p : result) {
+      for (const auto &p : result) {
         outline.vertices.emplace_back(p[0], p[1]);
       }
       geometry->addOutline(outline);
       geometry->setSanitized(true);
-    } catch (const CGAL::Failure_exception& e) {
-      LOG(message_group::Warning, "GeometryEvaluator::applyHull2D() during CGAL::convex_hull_2(): %1$s", e.what());
+    } catch (const CGAL::Failure_exception &e) {
+      LOG(message_group::Warning,
+          "GeometryEvaluator::applyHull2D() during CGAL::convex_hull_2(): %1$s",
+          e.what());
     }
   }
 #endif // ifdef ENABLE_CGAL
   return geometry;
 }
 
-std::unique_ptr<Polygon2d> GeometryEvaluator::applyFill2D(const AbstractNode& node)
-{
+std::unique_ptr<Polygon2d>
+GeometryEvaluator::applyFill2D(const AbstractNode &node) {
   // Merge and sanitize input geometry
-  auto geometry_in = ClipperUtils::apply(collectChildren2D(node), Clipper2Lib::ClipType::Union);
+  auto geometry_in = ClipperUtils::apply(collectChildren2D(node),
+                                         Clipper2Lib::ClipType::Union);
   assert(geometry_in->isSanitized());
 
   std::vector<std::shared_ptr<const Polygon2d>> newchildren;
   // Keep only the 'positive' outlines, eg: the outside edges
-  for (const auto& outline : geometry_in->outlines()) {
+  for (const auto &outline : geometry_in->outlines()) {
     if (outline.positive) {
       newchildren.push_back(std::make_shared<Polygon2d>(outline));
     }
@@ -254,16 +281,16 @@ std::unique_ptr<Polygon2d> GeometryEvaluator::applyFill2D(const AbstractNode& no
   return ClipperUtils::apply(newchildren, Clipper2Lib::ClipType::Union);
 }
 
-std::unique_ptr<Geometry> GeometryEvaluator::applyHull3D(const AbstractNode& node)
-{
+std::unique_ptr<Geometry>
+GeometryEvaluator::applyHull3D(const AbstractNode &node) {
   Geometry::Geometries children = collectChildren3D(node);
 
   auto P = PolySet::createEmpty();
   return applyHull(children);
 }
 
-std::unique_ptr<Polygon2d> GeometryEvaluator::applyMinkowski2D(const AbstractNode& node)
-{
+std::unique_ptr<Polygon2d>
+GeometryEvaluator::applyMinkowski2D(const AbstractNode &node) {
   auto children = collectChildren2D(node);
   if (!children.empty()) {
     return ClipperUtils::applyMinkowski(children);
@@ -275,13 +302,14 @@ std::unique_ptr<Polygon2d> GeometryEvaluator::applyMinkowski2D(const AbstractNod
    Returns a list of Polygon2d children of the given node.
    May return empty Polygon2d object, but not nullptr objects
  */
-std::vector<std::shared_ptr<const Polygon2d>> GeometryEvaluator::collectChildren2D(const AbstractNode& node)
-{
+std::vector<std::shared_ptr<const Polygon2d>>
+GeometryEvaluator::collectChildren2D(const AbstractNode &node) {
   std::vector<std::shared_ptr<const Polygon2d>> children;
-  for (const auto& item : this->visitedchildren[node.index()]) {
-    auto& chnode = item.first;
-    auto& chgeom = item.second;
-    if (chnode->modinst->isBackground()) continue;
+  for (const auto &item : this->visitedchildren[node.index()]) {
+    auto &chnode = item.first;
+    auto &chgeom = item.second;
+    if (chnode->modinst->isBackground())
+      continue;
 
     // NB! We insert into the cache here to ensure that all children of
     // a node is a valid object. If we inserted as we created them, the
@@ -291,13 +319,16 @@ std::vector<std::shared_ptr<const Polygon2d>> GeometryEvaluator::collectChildren
 
     if (chgeom) {
       if (chgeom->getDimension() == 3) {
-        LOG(message_group::Warning, item.first->modinst->location(), this->tree.getDocumentPath(), "Ignoring 3D child object for 2D operation");
+        LOG(message_group::Warning, item.first->modinst->location(),
+            this->tree.getDocumentPath(),
+            "Ignoring 3D child object for 2D operation");
         children.push_back(nullptr); // replace 3D geometry with empty geometry
       } else {
         if (chgeom->isEmpty()) {
           children.push_back(nullptr);
         } else {
-          const auto polygon2d = std::dynamic_pointer_cast<const Polygon2d>(chgeom);
+          const auto polygon2d =
+              std::dynamic_pointer_cast<const Polygon2d>(chgeom);
           assert(polygon2d);
           children.push_back(polygon2d);
         }
@@ -310,14 +341,13 @@ std::vector<std::shared_ptr<const Polygon2d>> GeometryEvaluator::collectChildren
 }
 
 /*!
-   Since we can generate both Nef and non-Nef geometry, we need to insert it into
-   the appropriate cache.
-   This method inserts the geometry into the appropriate cache if it's not already cached.
+   Since we can generate both Nef and non-Nef geometry, we need to insert it
+   into the appropriate cache. This method inserts the geometry into the
+   appropriate cache if it's not already cached.
  */
-void GeometryEvaluator::smartCacheInsert(const AbstractNode& node,
-                                         const std::shared_ptr<const Geometry>& geom)
-{
-  const std::string& key = this->tree.getIdString(node);
+void GeometryEvaluator::smartCacheInsert(
+    const AbstractNode &node, const std::shared_ptr<const Geometry> &geom) {
+  const std::string &key = this->tree.getIdString(node);
 
   if (CGALCache::acceptsGeometry(geom)) {
     if (!CGALCache::instance()->contains(key)) {
@@ -331,24 +361,27 @@ void GeometryEvaluator::smartCacheInsert(const AbstractNode& node,
 
     // Perhaps add acceptsGeometry() to GeometryCache as well?
     if (!GeometryCache::instance()->insert(key, geom)) {
-      LOG(message_group::Warning, "GeometryEvaluator: Node didn't fit into cache.");
+      LOG(message_group::Warning,
+          "GeometryEvaluator: Node didn't fit into cache.");
     }
   }
 }
 
-bool GeometryEvaluator::isSmartCached(const AbstractNode& node)
-{
-  const std::string& key = this->tree.getIdString(node);
-  return GeometryCache::instance()->contains(key) || CGALCache::instance()->contains(key);
+bool GeometryEvaluator::isSmartCached(const AbstractNode &node) {
+  const std::string &key = this->tree.getIdString(node);
+  return GeometryCache::instance()->contains(key) ||
+         CGALCache::instance()->contains(key);
 }
 
-std::shared_ptr<const Geometry> GeometryEvaluator::smartCacheGet(const AbstractNode& node, bool preferNef)
-{
-  const std::string& key = this->tree.getIdString(node);
+std::shared_ptr<const Geometry>
+GeometryEvaluator::smartCacheGet(const AbstractNode &node, bool preferNef) {
+  const std::string &key = this->tree.getIdString(node);
   const bool hasgeom = GeometryCache::instance()->contains(key);
   const bool hascgal = CGALCache::instance()->contains(key);
-  if (hascgal && (preferNef || !hasgeom)) return CGALCache::instance()->get(key);
-  if (hasgeom) return GeometryCache::instance()->get(key);
+  if (hascgal && (preferNef || !hasgeom))
+    return CGALCache::instance()->get(key);
+  if (hasgeom)
+    return GeometryCache::instance()->get(key);
   return {};
 }
 
@@ -356,13 +389,14 @@ std::shared_ptr<const Geometry> GeometryEvaluator::smartCacheGet(const AbstractN
    Returns a list of 3D Geometry children of the given node.
    May return empty geometries, but not nullptr objects
  */
-Geometry::Geometries GeometryEvaluator::collectChildren3D(const AbstractNode& node)
-{
+Geometry::Geometries
+GeometryEvaluator::collectChildren3D(const AbstractNode &node) {
   Geometry::Geometries children;
-  for (const auto& item : this->visitedchildren[node.index()]) {
-    auto& chnode = item.first;
-    const std::shared_ptr<const Geometry>& chgeom = item.second;
-    if (chnode->modinst->isBackground()) continue;
+  for (const auto &item : this->visitedchildren[node.index()]) {
+    auto &chnode = item.first;
+    const std::shared_ptr<const Geometry> &chgeom = item.second;
+    if (chnode->modinst->isBackground())
+      continue;
 
     // NB! We insert into the cache here to ensure that all children of
     // a node is a valid object. If we inserted as we created them, the
@@ -371,8 +405,11 @@ Geometry::Geometries GeometryEvaluator::collectChildren3D(const AbstractNode& no
     smartCacheInsert(*chnode, chgeom);
 
     if (chgeom && chgeom->getDimension() == 2) {
-      LOG(message_group::Warning, item.first->modinst->location(), this->tree.getDocumentPath(), "Ignoring 2D child object for 3D operation");
-      children.push_back(std::make_pair(item.first, nullptr)); // replace 2D geometry with empty geometry
+      LOG(message_group::Warning, item.first->modinst->location(),
+          this->tree.getDocumentPath(),
+          "Ignoring 2D child object for 3D operation");
+      children.push_back(std::make_pair(
+          item.first, nullptr)); // replace 2D geometry with empty geometry
     } else {
       // Add children if geometry is 3D OR null/empty
       children.push_back(item);
@@ -384,8 +421,9 @@ Geometry::Geometries GeometryEvaluator::collectChildren3D(const AbstractNode& no
 /*!
 
  */
-std::unique_ptr<Polygon2d> GeometryEvaluator::applyToChildren2D(const AbstractNode& node, OpenSCADOperator op)
-{
+std::unique_ptr<Polygon2d>
+GeometryEvaluator::applyToChildren2D(const AbstractNode &node,
+                                     OpenSCADOperator op) {
   node.progress_report();
   if (op == OpenSCADOperator::MINKOWSKI) {
     return applyMinkowski2D(node);
@@ -438,13 +476,13 @@ std::unique_ptr<Polygon2d> GeometryEvaluator::applyToChildren2D(const AbstractNo
 
    The added geometry can be nullptr if it wasn't possible to evaluate it.
  */
-void GeometryEvaluator::addToParent(const State& state,
-                                    const AbstractNode& node,
-                                    const std::shared_ptr<const Geometry>& geom)
-{
+void GeometryEvaluator::addToParent(
+    const State &state, const AbstractNode &node,
+    const std::shared_ptr<const Geometry> &geom) {
   this->visitedchildren.erase(node.index());
   if (state.parent()) {
-    this->visitedchildren[state.parent()->index()].push_back(std::make_pair(node.shared_from_this(), geom));
+    this->visitedchildren[state.parent()->index()].push_back(
+        std::make_pair(node.shared_from_this(), geom));
   } else {
     // Root node
     this->root = geom;
@@ -452,9 +490,9 @@ void GeometryEvaluator::addToParent(const State& state,
   }
 }
 
-Response GeometryEvaluator::visit(State& state, const ColorNode& node)
-{
-  if (state.isPrefix() && isSmartCached(node)) return Response::PruneTraversal;
+Response GeometryEvaluator::visit(State &state, const ColorNode &node) {
+  if (state.isPrefix() && isSmartCached(node))
+    return Response::PruneTraversal;
   if (state.isPostfix()) {
     std::shared_ptr<const Geometry> geom;
     if (!isSmartCached(node)) {
@@ -462,7 +500,8 @@ Response GeometryEvaluator::visit(State& state, const ColorNode& node)
       ResultObject res = applyToChildren(node, OpenSCADOperator::UNION);
       if ((geom = res.constptr())) {
         auto mutableGeom = res.asMutableGeometry();
-        if (mutableGeom) mutableGeom->setColor(node.color);
+        if (mutableGeom)
+          mutableGeom->setColor(node.color);
         geom = mutableGeom;
       }
     } else {
@@ -477,11 +516,12 @@ Response GeometryEvaluator::visit(State& state, const ColorNode& node)
 /*!
    Custom nodes are handled here => implicit union
  */
-Response GeometryEvaluator::visit(State& state, const AbstractNode& node)
-{
+Response GeometryEvaluator::visit(State &state, const AbstractNode &node) {
   if (state.isPrefix()) {
-    if (isSmartCached(node)) return Response::PruneTraversal;
-    state.setPreferNef(true); // Improve quality of CSG by avoiding conversion loss
+    if (isSmartCached(node))
+      return Response::PruneTraversal;
+    state.setPreferNef(
+        true); // Improve quality of CSG by avoiding conversion loss
   }
   if (state.isPostfix()) {
     std::shared_ptr<const Geometry> geom;
@@ -499,19 +539,20 @@ Response GeometryEvaluator::visit(State& state, const AbstractNode& node)
 /*!
    Pass children to parent without touching them. Used by e.g. for loops
  */
-Response GeometryEvaluator::visit(State& state, const ListNode& node)
-{
+Response GeometryEvaluator::visit(State &state, const ListNode &node) {
   if (state.parent()) {
     if (state.isPrefix() && node.modinst->isBackground()) {
-      if (node.modinst->isBackground()) state.setBackground(true);
+      if (node.modinst->isBackground())
+        state.setBackground(true);
       return Response::PruneTraversal;
     }
     if (state.isPostfix()) {
       unsigned int dim = 0;
-      for (const auto& item : this->visitedchildren[node.index()]) {
-        if (!isValidDim(item, dim)) break;
-        auto& chnode = item.first;
-        const std::shared_ptr<const Geometry>& chgeom = item.second;
+      for (const auto &item : this->visitedchildren[node.index()]) {
+        if (!isValidDim(item, dim))
+          break;
+        auto &chnode = item.first;
+        const std::shared_ptr<const Geometry> &chgeom = item.second;
         addToParent(state, *chnode, chgeom);
       }
       this->visitedchildren.erase(node.index());
@@ -525,12 +566,12 @@ Response GeometryEvaluator::visit(State& state, const ListNode& node)
 
 /*!
  */
-Response GeometryEvaluator::visit(State& state, const GroupNode& node)
-{
-  return visit(state, (const AbstractNode&)node);
+Response GeometryEvaluator::visit(State &state, const GroupNode &node) {
+  return visit(state, (const AbstractNode &)node);
 }
 
-Response GeometryEvaluator::lazyEvaluateRootNode(State& state, const AbstractNode& node) {
+Response GeometryEvaluator::lazyEvaluateRootNode(State &state,
+                                                 const AbstractNode &node) {
   if (state.isPrefix()) {
     if (node.modinst->isBackground()) {
       state.setBackground(true);
@@ -545,21 +586,26 @@ Response GeometryEvaluator::lazyEvaluateRootNode(State& state, const AbstractNod
 
     unsigned int dim = 0;
     GeometryList::Geometries geometries;
-    for (const auto& item : this->visitedchildren[node.index()]) {
-      if (!isValidDim(item, dim)) break;
-      auto& chnode = item.first;
-      const std::shared_ptr<const Geometry>& chgeom = item.second;
-      if (chnode->modinst->isBackground()) continue;
+    for (const auto &item : this->visitedchildren[node.index()]) {
+      if (!isValidDim(item, dim))
+        break;
+      auto &chnode = item.first;
+      const std::shared_ptr<const Geometry> &chgeom = item.second;
+      if (chnode->modinst->isBackground())
+        continue;
       // NB! We insert into the cache here to ensure that all children of
       // a node is a valid object. If we inserted as we created them, the
-      // cache could have been modified before we reach this point due to a large
-      // sibling object.
+      // cache could have been modified before we reach this point due to a
+      // large sibling object.
       smartCacheInsert(*chnode, chgeom);
       // Only use valid geometries
-      if (chgeom && !chgeom->isEmpty()) geometries.push_back(item);
+      if (chgeom && !chgeom->isEmpty())
+        geometries.push_back(item);
     }
-    if (geometries.size() == 1) geom = geometries.front().second;
-    else if (geometries.size() > 1) geom = std::make_shared<GeometryList>(geometries);
+    if (geometries.size() == 1)
+      geom = geometries.front().second;
+    else if (geometries.size() > 1)
+      geom = std::make_shared<GeometryList>(geometries);
 
     this->root = geom;
   }
@@ -573,27 +619,30 @@ Response GeometryEvaluator::lazyEvaluateRootNode(State& state, const AbstractNod
    NB! This is likely a temporary measure until a better implementation of
    group nodes is in place.
  */
-Response GeometryEvaluator::visit(State& state, const RootNode& node)
-{
+Response GeometryEvaluator::visit(State &state, const RootNode &node) {
   // If we didn't enable lazy unions, just union the top-level objects
   if (!Feature::ExperimentalLazyUnion.is_enabled()) {
-    return visit(state, (const GroupNode&)node);
+    return visit(state, (const GroupNode &)node);
   }
   return lazyEvaluateRootNode(state, node);
 }
 
-Response GeometryEvaluator::visit(State& state, const OffsetNode& node)
-{
-  if (state.isPrefix() && isSmartCached(node)) return Response::PruneTraversal;
+Response GeometryEvaluator::visit(State &state, const OffsetNode &node) {
+  if (state.isPrefix() && isSmartCached(node))
+    return Response::PruneTraversal;
   if (state.isPostfix()) {
     std::shared_ptr<const Geometry> geom;
     if (!isSmartCached(node)) {
-      if (const auto polygon = applyToChildren2D(node, OpenSCADOperator::UNION)) {
-        // ClipperLib documentation: The formula for the number of steps in a full
-        // circular arc is ... Pi / acos(1 - arc_tolerance / abs(delta))
-        double n = Calc::get_fragments_from_r(std::abs(node.delta), node.fn, node.fs, node.fa);
-        double arc_tolerance = std::abs(node.delta) * (1 - cos_degrees(180 / n));
-        geom = ClipperUtils::applyOffset(*polygon, node.delta, node.join_type, node.miter_limit, arc_tolerance);
+      if (const auto polygon =
+              applyToChildren2D(node, OpenSCADOperator::UNION)) {
+        // ClipperLib documentation: The formula for the number of steps in a
+        // full circular arc is ... Pi / acos(1 - arc_tolerance / abs(delta))
+        double n = Calc::get_fragments_from_r(std::abs(node.delta), node.fn,
+                                              node.fs, node.fa);
+        double arc_tolerance =
+            std::abs(node.delta) * (1 - cos_degrees(180 / n));
+        geom = ClipperUtils::applyOffset(*polygon, node.delta, node.join_type,
+                                         node.miter_limit, arc_tolerance);
         assert(geom);
       }
     } else {
@@ -608,18 +657,20 @@ Response GeometryEvaluator::visit(State& state, const OffsetNode& node)
 /*!
    RenderNodes just pass on convexity
  */
-Response GeometryEvaluator::visit(State& state, const RenderNode& node)
-{
+Response GeometryEvaluator::visit(State &state, const RenderNode &node) {
   if (state.isPrefix()) {
-    if (isSmartCached(node)) return Response::PruneTraversal;
-    state.setPreferNef(true); // Improve quality of CSG by avoiding conversion loss
+    if (isSmartCached(node))
+      return Response::PruneTraversal;
+    state.setPreferNef(
+        true); // Improve quality of CSG by avoiding conversion loss
   }
   if (state.isPostfix()) {
     std::shared_ptr<const Geometry> geom;
     if (!isSmartCached(node)) {
       ResultObject res = applyToChildren(node, OpenSCADOperator::UNION);
       auto mutableGeom = res.asMutableGeometry();
-      if (mutableGeom) mutableGeom->setConvexity(node.convexity);
+      if (mutableGeom)
+        mutableGeom->setConvexity(node.convexity);
       geom = mutableGeom;
     } else {
       geom = smartCacheGet(node, state.preferNef());
@@ -636,19 +687,20 @@ Response GeometryEvaluator::visit(State& state, const RenderNode& node)
    input: None
    output: PolySet or Polygon2d
  */
-Response GeometryEvaluator::visit(State& state, const LeafNode& node)
-{
+Response GeometryEvaluator::visit(State &state, const LeafNode &node) {
   if (state.isPrefix()) {
     std::shared_ptr<const Geometry> geom;
     if (!isSmartCached(node)) {
       geom = node.createGeometry();
       assert(geom);
-      if (const auto polygon = std::dynamic_pointer_cast<const Polygon2d>(geom)) {
+      if (const auto polygon =
+              std::dynamic_pointer_cast<const Polygon2d>(geom)) {
         if (!polygon->isSanitized()) {
           geom = ClipperUtils::sanitize(*polygon);
         }
-      } else if (const auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
-//        assert(!ps->hasDegeneratePolygons());
+      } else if (const auto ps =
+                     std::dynamic_pointer_cast<const PolySet>(geom)) {
+        //        assert(!ps->hasDegeneratePolygons());
       }
     } else {
       geom = smartCacheGet(node, state.preferNef());
@@ -659,8 +711,7 @@ Response GeometryEvaluator::visit(State& state, const LeafNode& node)
   return Response::PruneTraversal;
 }
 
-Response GeometryEvaluator::visit(State& state, const TextNode& node)
-{
+Response GeometryEvaluator::visit(State &state, const TextNode &node) {
   if (state.isPrefix()) {
     std::shared_ptr<const Geometry> geom;
     if (!isSmartCached(node)) {
@@ -675,18 +726,18 @@ Response GeometryEvaluator::visit(State& state, const TextNode& node)
   return Response::PruneTraversal;
 }
 
-
 /*!
    input: List of 2D or 3D objects (not mixed)
    output: Polygon2d or 3D PolySet
    operation:
     o Perform csg op on children
  */
-Response GeometryEvaluator::visit(State& state, const CsgOpNode& node)
-{
+Response GeometryEvaluator::visit(State &state, const CsgOpNode &node) {
   if (state.isPrefix()) {
-    if (isSmartCached(node)) return Response::PruneTraversal;
-    state.setPreferNef(true); // Improve quality of CSG by avoiding conversion loss
+    if (isSmartCached(node))
+      return Response::PruneTraversal;
+    state.setPreferNef(
+        true); // Improve quality of CSG by avoiding conversion loss
   }
   if (state.isPostfix()) {
     std::shared_ptr<const Geometry> geom;
@@ -708,39 +759,47 @@ Response GeometryEvaluator::visit(State& state, const CsgOpNode& node)
     o Union all children
     o Perform transform
  */
-Response GeometryEvaluator::visit(State& state, const TransformNode& node)
-{
-  if (state.isPrefix() && isSmartCached(node)) return Response::PruneTraversal;
+Response GeometryEvaluator::visit(State &state, const TransformNode &node) {
+  if (state.isPrefix() && isSmartCached(node))
+    return Response::PruneTraversal;
   if (state.isPostfix()) {
     std::shared_ptr<const Geometry> geom;
     if (!isSmartCached(node)) {
-      if (matrix_contains_infinity(node.matrix) || matrix_contains_nan(node.matrix)) {
-        // due to the way parse/eval works we can't currently distinguish between NaN and Inf
-        LOG(message_group::Warning, node.modinst->location(), this->tree.getDocumentPath(), "Transformation matrix contains Not-a-Number and/or Infinity - removing object.");
+      if (matrix_contains_infinity(node.matrix) ||
+          matrix_contains_nan(node.matrix)) {
+        // due to the way parse/eval works we can't currently distinguish
+        // between NaN and Inf
+        LOG(message_group::Warning, node.modinst->location(),
+            this->tree.getDocumentPath(),
+            "Transformation matrix contains Not-a-Number and/or Infinity - "
+            "removing object.");
       } else {
         // First union all children
         ResultObject res = applyToChildren(node, OpenSCADOperator::UNION);
         if ((geom = res.constptr())) {
           if (geom->getDimension() == 2) {
-            auto polygons = std::dynamic_pointer_cast<Polygon2d>(res.asMutableGeometry());
+            auto polygons =
+                std::dynamic_pointer_cast<Polygon2d>(res.asMutableGeometry());
             assert(polygons);
 
             Transform2d mat2;
-            mat2.matrix() <<
-              node.matrix(0, 0), node.matrix(0, 1), node.matrix(0, 3),
-              node.matrix(1, 0), node.matrix(1, 1), node.matrix(1, 3),
-              node.matrix(3, 0), node.matrix(3, 1), node.matrix(3, 3);
+            mat2.matrix() << node.matrix(0, 0), node.matrix(0, 1),
+                node.matrix(0, 3), node.matrix(1, 0), node.matrix(1, 1),
+                node.matrix(1, 3), node.matrix(3, 0), node.matrix(3, 1),
+                node.matrix(3, 3);
             polygons->transform(mat2);
-            // FIXME: We lose the transform if we copied a const geometry above. Probably similar issue in multiple places
-            // A 2D transformation may flip the winding order of a polygon.
-            // If that happens with a sanitized polygon, we need to reverse
-            // the winding order for it to be correct.
+            // FIXME: We lose the transform if we copied a const geometry above.
+            // Probably similar issue in multiple places A 2D transformation may
+            // flip the winding order of a polygon. If that happens with a
+            // sanitized polygon, we need to reverse the winding order for it to
+            // be correct.
             if (polygons->isSanitized() && mat2.matrix().determinant() <= 0) {
               geom = ClipperUtils::sanitize(*polygons);
             }
           } else if (geom->getDimension() == 3) {
             auto mutableGeom = res.asMutableGeometry();
-            if (mutableGeom) mutableGeom->transform(node.matrix);
+            if (mutableGeom)
+              mutableGeom->transform(node.matrix);
             geom = mutableGeom;
           }
         }
@@ -761,15 +820,17 @@ Response GeometryEvaluator::visit(State& state, const TransformNode& node)
     o Union all children
     o Perform extrude
  */
-Response GeometryEvaluator::visit(State& state, const LinearExtrudeNode& node)
-{
-  if (state.isPrefix() && isSmartCached(node)) return Response::PruneTraversal;
+Response GeometryEvaluator::visit(State &state, const LinearExtrudeNode &node) {
+  if (state.isPrefix() && isSmartCached(node))
+    return Response::PruneTraversal;
   if (state.isPostfix()) {
     std::shared_ptr<const Geometry> geom;
     if (!isSmartCached(node)) {
-      const std::shared_ptr<const Geometry> geometry = applyToChildren2D(node, OpenSCADOperator::UNION);
+      const std::shared_ptr<const Geometry> geometry =
+          applyToChildren2D(node, OpenSCADOperator::UNION);
       if (geometry) {
-        const auto polygons = std::dynamic_pointer_cast<const Polygon2d>(geometry);
+        const auto polygons =
+            std::dynamic_pointer_cast<const Polygon2d>(geometry);
         geom = extrudePolygon(node, *polygons);
         assert(geom);
       }
@@ -789,13 +850,14 @@ Response GeometryEvaluator::visit(State& state, const LinearExtrudeNode& node)
     o Union all children
     o Perform extrude
  */
-Response GeometryEvaluator::visit(State& state, const RotateExtrudeNode& node)
-{
-  if (state.isPrefix() && isSmartCached(node)) return Response::PruneTraversal;
+Response GeometryEvaluator::visit(State &state, const RotateExtrudeNode &node) {
+  if (state.isPrefix() && isSmartCached(node))
+    return Response::PruneTraversal;
   if (state.isPostfix()) {
     std::shared_ptr<const Geometry> geom;
     if (!isSmartCached(node)) {
-      const std::shared_ptr<const Polygon2d> geometry = applyToChildren2D(node, OpenSCADOperator::UNION);
+      const std::shared_ptr<const Polygon2d> geometry =
+          applyToChildren2D(node, OpenSCADOperator::UNION);
       if (geometry) {
         geom = rotatePolygon(node, *geometry);
       }
@@ -811,16 +873,17 @@ Response GeometryEvaluator::visit(State& state, const RotateExtrudeNode& node)
 /*!
    FIXME: Not in use
  */
-Response GeometryEvaluator::visit(State& /*state*/, const AbstractPolyNode& /*node*/)
-{
+Response GeometryEvaluator::visit(State & /*state*/,
+                                  const AbstractPolyNode & /*node*/) {
   assert(false);
   return Response::AbortTraversal;
 }
 
-std::shared_ptr<const Geometry> GeometryEvaluator::projectionCut(const ProjectionNode& node)
-{
+std::shared_ptr<const Geometry>
+GeometryEvaluator::projectionCut(const ProjectionNode &node) {
   std::shared_ptr<const Geometry> geom;
-  std::shared_ptr<const Geometry> newgeom = applyToChildren3D(node, OpenSCADOperator::UNION).constptr();
+  std::shared_ptr<const Geometry> newgeom =
+      applyToChildren3D(node, OpenSCADOperator::UNION).constptr();
   if (newgeom) {
 #ifdef ENABLE_MANIFOLD
     if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
@@ -845,11 +908,12 @@ std::shared_ptr<const Geometry> GeometryEvaluator::projectionCut(const Projectio
   return geom;
 }
 
-std::shared_ptr<const Geometry> GeometryEvaluator::projectionNoCut(const ProjectionNode& node)
-{
+std::shared_ptr<const Geometry>
+GeometryEvaluator::projectionNoCut(const ProjectionNode &node) {
 #ifdef ENABLE_MANIFOLD
   if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
-    const std::shared_ptr<const Geometry> newgeom = applyToChildren3D(node, OpenSCADOperator::UNION).constptr();
+    const std::shared_ptr<const Geometry> newgeom =
+        applyToChildren3D(node, OpenSCADOperator::UNION).constptr();
     if (newgeom) {
       auto manifold = ManifoldUtils::createManifoldFromGeometry(newgeom);
       if (manifold != nullptr) {
@@ -863,8 +927,9 @@ std::shared_ptr<const Geometry> GeometryEvaluator::projectionNoCut(const Project
 #endif // ifdef ENABLE_MANIFOLD
 
   std::vector<std::shared_ptr<const Polygon2d>> tmp_geom;
-  for (const auto& [chnode, chgeom] : this->visitedchildren[node.index()]) {
-    if (chnode->modinst->isBackground()) continue;
+  for (const auto &[chnode, chgeom] : this->visitedchildren[node.index()]) {
+    if (chnode->modinst->isBackground())
+      continue;
 
     // Clipper version of Geometry projection
     // Clipper doesn't handle meshes very well.
@@ -880,7 +945,6 @@ std::shared_ptr<const Geometry> GeometryEvaluator::projectionNoCut(const Project
   return std::shared_ptr(std::move(projected));
 }
 
-
 /*!
    input: List of 3D objects
    output: Polygon2d
@@ -888,9 +952,9 @@ std::shared_ptr<const Geometry> GeometryEvaluator::projectionNoCut(const Project
     o Union all children
     o Perform projection
  */
-Response GeometryEvaluator::visit(State& state, const ProjectionNode& node)
-{
-  if (state.isPrefix() && isSmartCached(node)) return Response::PruneTraversal;
+Response GeometryEvaluator::visit(State &state, const ProjectionNode &node) {
+  if (state.isPrefix() && isSmartCached(node))
+    return Response::PruneTraversal;
   if (state.isPostfix()) {
     std::shared_ptr<const Geometry> geom;
     if (isSmartCached(node)) {
@@ -914,9 +978,9 @@ Response GeometryEvaluator::visit(State& state, const ProjectionNode& node)
    operation:
     o Perform cgal operation
  */
-Response GeometryEvaluator::visit(State& state, const CgalAdvNode& node)
-{
-  if (state.isPrefix() && isSmartCached(node)) return Response::PruneTraversal;
+Response GeometryEvaluator::visit(State &state, const CgalAdvNode &node) {
+  if (state.isPrefix() && isSmartCached(node))
+    return Response::PruneTraversal;
   if (state.isPostfix()) {
     std::shared_ptr<const Geometry> geom;
     if (!isSmartCached(node)) {
@@ -962,11 +1026,13 @@ Response GeometryEvaluator::visit(State& state, const CgalAdvNode& node)
   return Response::ContinueTraversal;
 }
 
-Response GeometryEvaluator::visit(State& state, const AbstractIntersectionNode& node)
-{
+Response GeometryEvaluator::visit(State &state,
+                                  const AbstractIntersectionNode &node) {
   if (state.isPrefix()) {
-    if (isSmartCached(node)) return Response::PruneTraversal;
-    state.setPreferNef(true); // Improve quality of CSG by avoiding conversion loss
+    if (isSmartCached(node))
+      return Response::PruneTraversal;
+    state.setPreferNef(
+        true); // Improve quality of CSG by avoiding conversion loss
   }
   if (state.isPostfix()) {
     std::shared_ptr<const Geometry> geom;
@@ -983,8 +1049,8 @@ Response GeometryEvaluator::visit(State& state, const AbstractIntersectionNode&
 
 #if defined(ENABLE_EXPERIMENTAL) && defined(ENABLE_CGAL)
 // FIXME: What is the convex/manifold situation of the resulting PolySet?
-static std::unique_ptr<Geometry> roofOverPolygon(const RoofNode& node, const Polygon2d& poly)
-{
+static std::unique_ptr<Geometry> roofOverPolygon(const RoofNode &node,
+                                                 const Polygon2d &poly) {
   std::unique_ptr<PolySet> roof;
   if (node.method == "voronoi") {
     roof = roof_vd::voronoi_diagram_roof(poly, node.fa, node.fs);
@@ -999,9 +1065,9 @@ static std::unique_ptr<Geometry> roofOverPolygon(const RoofNode& node, const Pol
   return roof;
 }
 
-Response GeometryEvaluator::visit(State& state, const RoofNode& node)
-{
-  if (state.isPrefix() && isSmartCached(node)) return Response::PruneTraversal;
+Response GeometryEvaluator::visit(State &state, const RoofNode &node) {
+  if (state.isPrefix() && isSmartCached(node))
+    return Response::PruneTraversal;
   if (state.isPostfix()) {
     std::shared_ptr<const Geometry> geom;
     if (!isSmartCached(node)) {
@@ -1010,8 +1076,9 @@ Response GeometryEvaluator::visit(State& state, const RoofNode& node)
         std::unique_ptr<Geometry> roof;
         try {
           roof = roofOverPolygon(node, *polygon2d);
-        } catch (RoofNode::roof_exception& e) {
-          LOG(message_group::Error, node.modinst->location(), this->tree.getDocumentPath(),
+        } catch (RoofNode::roof_exception &e) {
+          LOG(message_group::Error, node.modinst->location(),
+              this->tree.getDocumentPath(),
               "Skeleton computation error. " + e.message());
           roof = PolySet::createEmpty();
         }
diff --git a/src/geometry/GeometryEvaluator.h b/src/geometry/GeometryEvaluator.h
index 1b72de0d1..8fe0b6b45 100644
--- a/src/geometry/GeometryEvaluator.h
+++ b/src/geometry/GeometryEvaluator.h
@@ -1,108 +1,132 @@
 #pragma once
 
 #include "core/NodeVisitor.h"
-#include "geometry/linalg.h"
 #include "core/enums.h"
 #include "geometry/Geometry.h"
+#include "geometry/linalg.h"
 
 #include <cassert>
+#include <map>
 #include <memory>
 #include <utility>
 #include <vector>
-#include <map>
 
 class CGALNefGeometry;
 class Polygon2d;
 class Tree;
 
-// This evaluates a node tree into concrete geometry usign an underlying geometry engine
-// FIXME: Ideally, each engine should implement its own subtype. Instead we currently have
-// multiple embedded engines with varoius methods of selecting the right one.
-class GeometryEvaluator : public NodeVisitor
-{
+// This evaluates a node tree into concrete geometry usign an underlying
+// geometry engine
+// FIXME: Ideally, each engine should implement its own subtype. Instead we
+// currently have multiple embedded engines with varoius methods of selecting
+// the right one.
+class GeometryEvaluator : public NodeVisitor {
 public:
-  GeometryEvaluator(const Tree& tree);
+  GeometryEvaluator(const Tree &tree);
 
-  std::shared_ptr<const Geometry> evaluateGeometry(const AbstractNode& node, bool allownef);
+  std::shared_ptr<const Geometry> evaluateGeometry(const AbstractNode &node,
+                                                   bool allownef);
 
-  Response visit(State& state, const AbstractNode& node) override;
-  Response visit(State& state, const ColorNode& node) override;
-  Response visit(State& state, const AbstractIntersectionNode& node) override;
-  Response visit(State& state, const AbstractPolyNode& node) override;
-  Response visit(State& state, const LinearExtrudeNode& node) override;
-  Response visit(State& state, const RotateExtrudeNode& node) override;
+  Response visit(State &state, const AbstractNode &node) override;
+  Response visit(State &state, const ColorNode &node) override;
+  Response visit(State &state, const AbstractIntersectionNode &node) override;
+  Response visit(State &state, const AbstractPolyNode &node) override;
+  Response visit(State &state, const LinearExtrudeNode &node) override;
+  Response visit(State &state, const RotateExtrudeNode &node) override;
 #if defined(ENABLE_EXPERIMENTAL) && defined(ENABLE_CGAL)
-  Response visit(State& state, const RoofNode& node) override;
+  Response visit(State &state, const RoofNode &node) override;
 #endif
-  Response visit(State& state, const ListNode& node) override;
-  Response visit(State& state, const GroupNode& node) override;
-  Response visit(State& state, const RootNode& node) override;
-  Response visit(State& state, const LeafNode& node) override;
-  Response visit(State& state, const TransformNode& node) override;
-  Response visit(State& state, const CsgOpNode& node) override;
-  Response visit(State& state, const CgalAdvNode& node) override;
-  Response visit(State& state, const ProjectionNode& node) override;
-  Response visit(State& state, const RenderNode& node) override;
-  Response visit(State& state, const TextNode& node) override;
-  Response visit(State& state, const OffsetNode& node) override;
+  Response visit(State &state, const ListNode &node) override;
+  Response visit(State &state, const GroupNode &node) override;
+  Response visit(State &state, const RootNode &node) override;
+  Response visit(State &state, const LeafNode &node) override;
+  Response visit(State &state, const TransformNode &node) override;
+  Response visit(State &state, const CsgOpNode &node) override;
+  Response visit(State &state, const CgalAdvNode &node) override;
+  Response visit(State &state, const ProjectionNode &node) override;
+  Response visit(State &state, const RenderNode &node) override;
+  Response visit(State &state, const TextNode &node) override;
+  Response visit(State &state, const OffsetNode &node) override;
 
-  [[nodiscard]] const Tree& getTree() const { return this->tree; }
+  [[nodiscard]] const Tree &getTree() const { return this->tree; }
 
 private:
-  class ResultObject
-  {
-public:
+  class ResultObject {
+  public:
     // This makes it explicit if we want a const vs. non-const result.
     // This is important to avoid inadvertently tagging a geometry as const when
     // the underlying geometry is actually mutable.
     // The template trick, combined with private constructors, makes it possible
     // to create a ResultObject containing a const, _only_ from const objects
     // (i.e. no implicit conversion from non-const to const).
-    template <class T> static ResultObject constResult(std::shared_ptr<const T> geom) {return {geom};}
-    template <class T> static ResultObject mutableResult(std::shared_ptr<T> geom) {return {geom};}
+    template <class T>
+    static ResultObject constResult(std::shared_ptr<const T> geom) {
+      return {geom};
+    }
+    template <class T>
+    static ResultObject mutableResult(std::shared_ptr<T> geom) {
+      return {geom};
+    }
 
     // Default constructor with nullptr can be used to represent empty geometry,
     // for example union() with no children, etc.
     ResultObject() : is_const(true) {}
-    std::shared_ptr<Geometry> ptr() { assert(!is_const); return pointer; }
+    std::shared_ptr<Geometry> ptr() {
+      assert(!is_const);
+      return pointer;
+    }
     [[nodiscard]] std::shared_ptr<const Geometry> constptr() const {
-      return is_const ? const_pointer : std::static_pointer_cast<const Geometry>(pointer);
+      return is_const ? const_pointer
+                      : std::static_pointer_cast<const Geometry>(pointer);
     }
     std::shared_ptr<Geometry> asMutableGeometry() {
-      if (is_const) return {constptr() ? constptr()->copy() : nullptr};
-      else return ptr();
+      if (is_const)
+        return {constptr() ? constptr()->copy() : nullptr};
+      else
+        return ptr();
     }
-private:
-    template <class T> ResultObject(std::shared_ptr<const T> g) : is_const(true), const_pointer(std::move(g)) {}
-    template <class T> ResultObject(std::shared_ptr<T> g) : is_const(false), pointer(std::move(g)) {}
+
+  private:
+    template <class T>
+    ResultObject(std::shared_ptr<const T> g)
+        : is_const(true), const_pointer(std::move(g)) {}
+    template <class T>
+    ResultObject(std::shared_ptr<T> g)
+        : is_const(false), pointer(std::move(g)) {}
 
     bool is_const;
     std::shared_ptr<Geometry> pointer;
     std::shared_ptr<const Geometry> const_pointer;
   };
 
-  void smartCacheInsert(const AbstractNode& node, const std::shared_ptr<const Geometry>& geom);
-  std::shared_ptr<const Geometry> smartCacheGet(const AbstractNode& node, bool preferNef);
-  bool isSmartCached(const AbstractNode& node);
-  bool isValidDim(const Geometry::GeometryItem& item, unsigned int& dim) const;
-  std::vector<std::shared_ptr<const Polygon2d>> collectChildren2D(const AbstractNode& node);
-  Geometry::Geometries collectChildren3D(const AbstractNode& node);
-  std::unique_ptr<Polygon2d> applyMinkowski2D(const AbstractNode& node);
-  std::unique_ptr<Polygon2d> applyHull2D(const AbstractNode& node);
-  std::unique_ptr<Polygon2d> applyFill2D(const AbstractNode& node);
-  std::unique_ptr<Geometry> applyHull3D(const AbstractNode& node);
-  void applyResize3D(CGALNefGeometry& N, const Vector3d& newsize, const Eigen::Matrix<bool, 3, 1>& autosize);
-  std::unique_ptr<Polygon2d> applyToChildren2D(const AbstractNode& node, OpenSCADOperator op);
-  ResultObject applyToChildren3D(const AbstractNode& node, OpenSCADOperator op);
-  ResultObject applyToChildren(const AbstractNode& node, OpenSCADOperator op);
-  std::shared_ptr<const Geometry> projectionCut(const ProjectionNode& node);
-  std::shared_ptr<const Geometry> projectionNoCut(const ProjectionNode& node);
+  void smartCacheInsert(const AbstractNode &node,
+                        const std::shared_ptr<const Geometry> &geom);
+  std::shared_ptr<const Geometry> smartCacheGet(const AbstractNode &node,
+                                                bool preferNef);
+  bool isSmartCached(const AbstractNode &node);
+  bool isValidDim(const Geometry::GeometryItem &item, unsigned int &dim) const;
+  std::vector<std::shared_ptr<const Polygon2d>>
+  collectChildren2D(const AbstractNode &node);
+  Geometry::Geometries collectChildren3D(const AbstractNode &node);
+  std::unique_ptr<Polygon2d> applyMinkowski2D(const AbstractNode &node);
+  std::unique_ptr<Polygon2d> applyHull2D(const AbstractNode &node);
+  std::unique_ptr<Polygon2d> applyFill2D(const AbstractNode &node);
+  std::unique_ptr<Geometry> applyHull3D(const AbstractNode &node);
+  void applyResize3D(CGALNefGeometry &N, const Vector3d &newsize,
+                     const Eigen::Matrix<bool, 3, 1> &autosize);
+  std::unique_ptr<Polygon2d> applyToChildren2D(const AbstractNode &node,
+                                               OpenSCADOperator op);
+  ResultObject applyToChildren3D(const AbstractNode &node, OpenSCADOperator op);
+  ResultObject applyToChildren(const AbstractNode &node, OpenSCADOperator op);
+  std::shared_ptr<const Geometry> projectionCut(const ProjectionNode &node);
+  std::shared_ptr<const Geometry> projectionNoCut(const ProjectionNode &node);
 
-  void addToParent(const State& state, const AbstractNode& node, const std::shared_ptr<const Geometry>& geom);
-  Response lazyEvaluateRootNode(State& state, const AbstractNode& node);
+  void addToParent(const State &state, const AbstractNode &node,
+                   const std::shared_ptr<const Geometry> &geom);
+  Response lazyEvaluateRootNode(State &state, const AbstractNode &node);
 
   std::map<int, Geometry::Geometries> visitedchildren;
-  const Tree& tree;
+  const Tree &tree;
   std::shared_ptr<const Geometry> root;
 
 public:
diff --git a/src/geometry/GeometryUtils.cc b/src/geometry/GeometryUtils.cc
index 09d09425d..991ac6422 100644
--- a/src/geometry/GeometryUtils.cc
+++ b/src/geometry/GeometryUtils.cc
@@ -1,32 +1,32 @@
 #include "geometry/GeometryUtils.h"
 
 #include <algorithm>
-#include <cassert>
-#include <unordered_map>
-#include <list>
-#include <utility>
 #include <boost/functional/hash.hpp>
-#include <cstddef>
+#include <cassert>
 #include <cmath>
+#include <cstddef>
+#include <list>
 #include <memory>
 #include <string>
+#include <unordered_map>
+#include <utility>
 #include <vector>
 
 #include "geometry/Geometry.h"
+#include "geometry/PolySet.h"
+#include "geometry/Reindexer.h"
 #include "geometry/linalg.h"
+#include "glview/RenderSettings.h"
 #include "libtess2/Include/tesselator.h"
 #include "utils/printutils.h"
-#include "geometry/Reindexer.h"
-#include "glview/RenderSettings.h"
-#include "geometry/PolySet.h"
 
 #ifdef ENABLE_CGAL
 #include "geometry/cgal/cgalutils.h"
 #endif
 
 #ifdef ENABLE_MANIFOLD
-#include "geometry/manifold/manifoldutils.h"
 #include "geometry/manifold/ManifoldGeometry.h"
+#include "geometry/manifold/manifoldutils.h"
 #endif
 
 static void *stdAlloc(void *userData, unsigned int size) {
@@ -45,66 +45,68 @@ using IndexedEdge = std::pair<int, int>;
    Helper class for keeping track of edges in a mesh.
    Can probably be replaced with a proper HalfEdge mesh later on
  */
-class EdgeDict
-{
+class EdgeDict {
 public:
-// Counts occurrences of edges
-  using IndexedEdgeDict = std::unordered_map<IndexedEdge, int, boost::hash<IndexedEdge>>;
+  // Counts occurrences of edges
+  using IndexedEdgeDict =
+      std::unordered_map<IndexedEdge, int, boost::hash<IndexedEdge>>;
 
   EdgeDict() = default;
 
-  void add(const IndexedFace& face) {
+  void add(const IndexedFace &face) {
     for (size_t i = 0; i < face.size(); ++i) {
       IndexedEdge e(face[(i + 1) % face.size()], face[i]);
-      if (this->count(e) > 0) this->remove(e);
-      else this->add(e.second, e.first);
+      if (this->count(e) > 0)
+        this->remove(e);
+      else
+        this->add(e.second, e.first);
     }
   }
 
-  void remove(const IndexedTriangle& t) {
+  void remove(const IndexedTriangle &t) {
     for (int i = 0; i < 3; ++i) {
       IndexedEdge e(t[i], t[(i + 1) % 3]);
       // If the edge exist, remove it
-      if (this->count(e) > 0) this->remove(e);
-      else this->add(e.second, e.first);
+      if (this->count(e) > 0)
+        this->remove(e);
+      else
+        this->add(e.second, e.first);
     }
   }
 
-  void add(const IndexedTriangle& t) {
+  void add(const IndexedTriangle &t) {
     for (int i = 0; i < 3; ++i) {
       IndexedEdge e(t[(i + 1) % 3], t[i]);
       // If an opposite edge exists, they cancel out
-      if (this->count(e) > 0) this->remove(e);
-      else this->add(e.second, e.first);
+      if (this->count(e) > 0)
+        this->remove(e);
+      else
+        this->add(e.second, e.first);
     }
   }
 
-  void add(int start, int end) {
-    this->add(IndexedEdge(start, end));
-  }
+  void add(int start, int end) { this->add(IndexedEdge(start, end)); }
 
-  void add(const IndexedEdge& e) {
+  void add(const IndexedEdge &e) {
     this->edges[e]++;
-//    PRINTDB("add: (%d,%d)", e.first % e.second);
+    //    PRINTDB("add: (%d,%d)", e.first % e.second);
   }
 
-  void remove(int start, int end) {
-    this->remove(IndexedEdge(start, end));
-  }
+  void remove(int start, int end) { this->remove(IndexedEdge(start, end)); }
 
-  void remove(const IndexedEdge& e) {
+  void remove(const IndexedEdge &e) {
     this->edges[e]--;
-    if (this->edges[e] == 0) this->edges.erase(e);
-//    PRINTDB("remove: (%d,%d)", e.first % e.second);
+    if (this->edges[e] == 0)
+      this->edges.erase(e);
+    //    PRINTDB("remove: (%d,%d)", e.first % e.second);
   }
 
-  int count(int start, int end) {
-    return this->count(IndexedEdge(start, end));
-  }
+  int count(int start, int end) { return this->count(IndexedEdge(start, end)); }
 
-  int count(const IndexedEdge& e) {
+  int count(const IndexedEdge &e) {
     auto it = this->edges.find(e);
-    if (it != edges.end()) return it->second;
+    if (it != edges.end())
+      return it->second;
     return 0;
   }
 
@@ -113,31 +115,37 @@ public:
   size_t size() const { return this->edges.size(); }
 
   void print() const {
-//    for (const auto& v : this->edges) {
-//      const auto& e = v.first;
-//      PRINTDB("     (%d,%d)%s", e.first % e.second % ((v.second > 1) ? std::to_string(v.second).c_str() : ""));
-//    }
+    //    for (const auto& v : this->edges) {
+    //      const auto& e = v.first;
+    //      PRINTDB("     (%d,%d)%s", e.first % e.second % ((v.second > 1) ?
+    //      std::to_string(v.second).c_str() : ""));
+    //    }
   }
 
   void remove_from_v2e(int vidx, int next, int prev) {
-    auto& l = v2e[vidx];
+    auto &l = v2e[vidx];
     auto it = std::find(l.begin(), l.end(), next);
-    if (it != l.end()) l.erase(it);
-    if (l.empty()) v2e.erase(vidx);
+    if (it != l.end())
+      l.erase(it);
+    if (l.empty())
+      v2e.erase(vidx);
 
-    auto& l2 = v2e_reverse[vidx];
+    auto &l2 = v2e_reverse[vidx];
     it = std::find(l2.begin(), l2.end(), prev);
-    if (it != l2.end()) l2.erase(it);
-    if (l2.empty()) v2e_reverse.erase(vidx);
+    if (it != l2.end())
+      l2.erase(it);
+    if (l2.empty())
+      v2e_reverse.erase(vidx);
   }
 
-  void extractTriangle(int vidx, int next, std::vector<IndexedTriangle>& triangles) {
+  void extractTriangle(int vidx, int next,
+                       std::vector<IndexedTriangle> &triangles) {
     assert(v2e_reverse.find(vidx) != v2e_reverse.end());
     assert(!v2e_reverse[vidx].empty());
     auto prev = v2e_reverse[vidx].front();
 
     IndexedTriangle t(prev, vidx, next);
-//    PRINTDB("Clipping ear: %d %d %d", t[0] % t[1] % t[2]);
+    //    PRINTDB("Clipping ear: %d %d %d", t[0] % t[1] % t[2]);
     triangles.push_back(t);
     // Remove the generated triangle from the original.
     // Add new boundary edges to the edge dict
@@ -155,12 +163,12 @@ public:
   }
 
   // Triangulate remaining loops and add to triangles
-  void triangulateLoops(std::vector<IndexedTriangle>& triangles) {
+  void triangulateLoops(std::vector<IndexedTriangle> &triangles) {
     // First, look for self-intersections in edges
     v2e.clear();
     v2e_reverse.clear();
-    for (const auto& v : this->edges) {
-      const auto& e = v.first;
+    for (const auto &v : this->edges) {
+      const auto &e = v.first;
       for (int i = 0; i < v.second; ++i) {
         v2e[e.first].push_back(e.second);
         v2e_reverse[e.second].push_back(e.first);
@@ -191,7 +199,6 @@ public:
   std::unordered_map<int, std::list<int>> v2e_reverse;
 };
 
-
 /*!
    Tessellates input contours into a triangle mesh.
 
@@ -210,11 +217,10 @@ public:
 
    Returns true on error, false on success.
  */
-bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vertices,
-                                               const std::vector<IndexedFace>& faces,
-                                               std::vector<IndexedTriangle>& triangles,
-                                               const Vector3f *normal)
-{
+bool GeometryUtils::tessellatePolygonWithHoles(
+    const std::vector<Vector3f> &vertices,
+    const std::vector<IndexedFace> &faces,
+    std::vector<IndexedTriangle> &triangles, const Vector3f *normal) {
   // Algorithm outline:
   // o Remove consecutive equal vertices and null ears (i.e. 23,24,23)
   // o Ignore polygons with < 3 vertices
@@ -223,22 +229,27 @@ bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vert
   // o Postprocess to clean up misbehaviors in libtess2
 
   // No polygon. FIXME: Will this ever happen or can we assert here?
-  if (faces.empty()) return false;
+  if (faces.empty())
+    return false;
 
   // Remove consecutive equal vertices, as well as null ears
   auto cleanfaces = faces;
-  for (auto& face : cleanfaces) {
+  for (auto &face : cleanfaces) {
     size_t i = 0;
     while (face.size() >= 3 && i < face.size()) {
-      if (face[i] == face[(i + 1) % face.size()]) { // Two consecutively equal indices
+      if (face[i] ==
+          face[(i + 1) % face.size()]) { // Two consecutively equal indices
         face.erase(face.begin() + i);
-      } else if (face[(i + face.size() - 1) % face.size()] == face[(i + 1) % face.size()]) { // Null ear
-        if (i == 0) face.erase(face.begin() + i, face.begin() + i + 2);
-        else face.erase(face.begin() + i - 1, face.begin() + i + 1);
+      } else if (face[(i + face.size() - 1) % face.size()] ==
+                 face[(i + 1) % face.size()]) { // Null ear
+        if (i == 0)
+          face.erase(face.begin() + i, face.begin() + i + 2);
+        else
+          face.erase(face.begin() + i - 1, face.begin() + i + 1);
         i--;
       } else {
         // Filter away inf and nan vertices as they cause libtess2 to crash
-        const auto& v = vertices[face[i]];
+        const auto &v = vertices[face[i]];
         int k;
         for (k = 0; k < 3; ++k) {
           if (std::isnan(v[k]) || std::isinf(v[k])) {
@@ -246,12 +257,14 @@ bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vert
             break;
           }
         }
-        if (k == 3) i++;
+        if (k == 3)
+          i++;
       }
     }
   }
   // First polygon has < 3 points - no output
-  if (cleanfaces[0].size() < 3) return false;
+  if (cleanfaces[0].size() < 3)
+    return false;
   // Remove collapsed holes
   for (size_t i = 1; i < cleanfaces.size(); ++i) {
     if (cleanfaces[i].size() < 3) {
@@ -262,8 +275,10 @@ bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vert
 
   if (cleanfaces.size() == 1 && cleanfaces[0].size() == 3) {
     // Input polygon has 3 points. shortcut tessellation.
-    //PRINTDB("  tri: %d %d %d", cleanfaces[0][0] % cleanfaces[0][1] % cleanfaces[0][2]);
-    triangles.emplace_back(cleanfaces[0][0], cleanfaces[0][1], cleanfaces[0][2]);
+    // PRINTDB("  tri: %d %d %d", cleanfaces[0][0] % cleanfaces[0][1] %
+    // cleanfaces[0][2]);
+    triangles.emplace_back(cleanfaces[0][0], cleanfaces[0][1],
+                           cleanfaces[0][2]);
     return false;
   }
 
@@ -271,7 +286,7 @@ bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vert
   // This contains all edges in the original polygon.
   // To maintain connectivity, all these edges must exist in the output.
   EdgeDict edges;
-  for (const auto& face : cleanfaces) {
+  for (const auto &face : cleanfaces) {
     edges.add(face);
   }
 
@@ -292,26 +307,30 @@ bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vert
   ma.memfree = stdFree;
   ma.extraVertices = 256; // realloc not provided, allow 256 extra vertices.
 
-  if (!(tess = tessNewTess(&ma))) return true;
+  if (!(tess = tessNewTess(&ma)))
+    return true;
 
   std::vector<TESSreal> contour;
-  // Since libtess2's indices is based on the running number of points added, we need to map back
-  // to our indices. allindices does the mapping.
+  // Since libtess2's indices is based on the running number of points added, we
+  // need to map back to our indices. allindices does the mapping.
   std::vector<int> allindices;
-  for (const auto& face : cleanfaces) {
+  for (const auto &face : cleanfaces) {
     contour.clear();
     for (auto idx : face) {
-      const auto& v = vertices[idx];
+      const auto &v = vertices[idx];
       contour.push_back(v[0]);
       contour.push_back(v[1]);
       contour.push_back(v[2]);
       allindices.push_back(idx);
     }
     assert(face.size() >= 3);
-    tessAddContour(tess, 3, &contour.front(), sizeof(TESSreal) * 3, face.size());
+    tessAddContour(tess, 3, &contour.front(), sizeof(TESSreal) * 3,
+                   face.size());
   }
 
-  if (!tessTesselate(tess, TESS_WINDING_ODD, TESS_CONSTRAINED_DELAUNAY_TRIANGLES, 3, 3, normalvec)) return false;
+  if (!tessTesselate(tess, TESS_WINDING_ODD,
+                     TESS_CONSTRAINED_DELAUNAY_TRIANGLES, 3, 3, normalvec))
+    return false;
 
   const auto vindices = tessGetVertexIndices(tess);
   const auto elements = tessGetElements(tess);
@@ -332,9 +351,11 @@ bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vert
      Algorithm:
      A) Collect all triangles using _only_ existing vertices -> triangles
      B) Locate all unused vertices
-     C) For each unused vertex, create a triangle connecting it to the existing mesh
+     C) For each unused vertex, create a triangle connecting it to the existing
+     mesh
    */
-  auto inputSize = allindices.size(); // inputSize is number of points added to libtess2
+  auto inputSize =
+      allindices.size(); // inputSize is number of points added to libtess2
   std::vector<int> vflags(inputSize); // Inits with 0's
 
   IndexedTriangle tri;
@@ -355,18 +376,18 @@ bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vert
     //         elements[t * 3 + 0] % mappedtri[0] %
     //         elements[t * 3 + 1] % mappedtri[1] %
     //         elements[t * 3 + 2] % mappedtri[2]);
-    // FIXME: We ignore self-intersecting triangles rather than detecting and handling this
+    // FIXME: We ignore self-intersecting triangles rather than detecting and
+    // handling this
     if (!err) {
       vflags[tri[0]]++; // B)
       vflags[tri[1]]++;
       vflags[tri[2]]++;
 
-      // For each edge in mappedtri, locate the opposite edge in the original polygon.
-      // If an opposite edge was found, we need to flip.
-      // In addition, remove each edge from the dict to be able to later find
-      // missing edges.
-      // Note: In some degenerate cases, we create triangles with mixed edge directions.
-      // In this case, don't reverse, but attempt to carry on
+      // For each edge in mappedtri, locate the opposite edge in the original
+      // polygon. If an opposite edge was found, we need to flip. In addition,
+      // remove each edge from the dict to be able to later find missing edges.
+      // Note: In some degenerate cases, we create triangles with mixed edge
+      // directions. In this case, don't reverse, but attempt to carry on
       auto reverse = false;
       for (int i = 0; i < 3; ++i) {
         const IndexedEdge e(mappedtri[i], mappedtri[(i + 1) % 3]);
@@ -379,7 +400,8 @@ bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vert
       }
       if (reverse) {
         mappedtri.reverseInPlace();
-//        PRINTDB("  reversed: %d %d %d", mappedtri[0] % mappedtri[1] % mappedtri[2]);
+        //        PRINTDB("  reversed: %d %d %d", mappedtri[0] % mappedtri[1] %
+        //        mappedtri[2]);
       }
 
       // Remove the generated triangle from the original.
@@ -432,25 +454,28 @@ bool GeometryUtils::tessellatePolygonWithHoles(const std::vector<Vector3f>& vert
    Tessellates a single contour. Non-indexed version.
    Appends resulting triangles to triangles.
  */
-bool GeometryUtils::tessellatePolygon(const Polygon& polygon, Polygons& triangles,
-                                      const Vector3f *normal)
-{
+bool GeometryUtils::tessellatePolygon(const Polygon &polygon,
+                                      Polygons &triangles,
+                                      const Vector3f *normal) {
   auto err = false;
   Reindexer<Vector3f> uniqueVertices;
   std::vector<IndexedFace> indexedfaces{{}};
-  auto& currface = indexedfaces.back();
-  for (const auto& v : polygon) {
+  auto &currface = indexedfaces.back();
+  for (const auto &v : polygon) {
     auto idx = uniqueVertices.lookup(v.cast<float>());
-    if (currface.empty() || idx != currface.back()) currface.push_back(idx);
+    if (currface.empty() || idx != currface.back())
+      currface.push_back(idx);
   }
-  if (currface.front() == currface.back()) currface.pop_back();
+  if (currface.front() == currface.back())
+    currface.pop_back();
   if (currface.size() >= 3) { // Cull empty triangles
-    const auto& verts = uniqueVertices.getArray();
+    const auto &verts = uniqueVertices.getArray();
     std::vector<IndexedTriangle> indexedtriangles;
-    err = tessellatePolygonWithHoles(verts, indexedfaces, indexedtriangles, normal);
-    for (const auto& t : indexedtriangles) {
+    err = tessellatePolygonWithHoles(verts, indexedfaces, indexedtriangles,
+                                     normal);
+    for (const auto &t : indexedtriangles) {
       triangles.push_back(Polygon());
-      Polygon& p = triangles.back();
+      Polygon &p = triangles.back();
       p.push_back(verts[t[0]].cast<double>());
       p.push_back(verts[t[1]].cast<double>());
       p.push_back(verts[t[2]].cast<double>());
@@ -459,11 +484,11 @@ bool GeometryUtils::tessellatePolygon(const Polygon& polygon, Polygons& triangle
   return err;
 }
 
-int GeometryUtils::findUnconnectedEdges(const std::vector<std::vector<IndexedFace>>& polygons)
-{
+int GeometryUtils::findUnconnectedEdges(
+    const std::vector<std::vector<IndexedFace>> &polygons) {
   EdgeDict edges;
-  for (const auto& faces : polygons) {
-    for (const auto& face : faces) {
+  for (const auto &faces : polygons) {
+    for (const auto &face : faces) {
       edges.add(face);
     }
   }
@@ -476,10 +501,10 @@ int GeometryUtils::findUnconnectedEdges(const std::vector<std::vector<IndexedFac
   return edges.size();
 }
 
-int GeometryUtils::findUnconnectedEdges(const std::vector<IndexedTriangle>& triangles)
-{
+int GeometryUtils::findUnconnectedEdges(
+    const std::vector<IndexedTriangle> &triangles) {
   EdgeDict edges;
-  for (const auto& t : triangles) {
+  for (const auto &t : triangles) {
     edges.add(t);
   }
 #if 1 // for debugging
@@ -492,27 +517,31 @@ int GeometryUtils::findUnconnectedEdges(const std::vector<IndexedTriangle>& tria
   return edges.size();
 }
 
-Transform3d GeometryUtils::getResizeTransform(const BoundingBox& bbox, const Vector3d& newsize, const Eigen::Matrix<bool, 3, 1>& autosize)
-{
+Transform3d
+GeometryUtils::getResizeTransform(const BoundingBox &bbox,
+                                  const Vector3d &newsize,
+                                  const Eigen::Matrix<bool, 3, 1> &autosize) {
   // Find largest dimension
   int maxdim = 0;
-  for (int i = 1; i < 3; ++i) if (newsize[i] > newsize[maxdim]) maxdim = i;
+  for (int i = 1; i < 3; ++i)
+    if (newsize[i] > newsize[maxdim])
+      maxdim = i;
 
   // Default scale (scale with 1 if the new size is 0)
   Vector3d scale(1, 1, 1);
-  for (int i = 0; i < 3; ++i) if (newsize[i] > 0) scale[i] = newsize[i] / bbox.sizes()[i];
+  for (int i = 0; i < 3; ++i)
+    if (newsize[i] > 0)
+      scale[i] = newsize[i] / bbox.sizes()[i];
 
   // Autoscale where applicable
   double autoscale = scale[maxdim];
   Vector3d newscale;
-  for (int i = 0; i < 3; ++i) newscale[i] = !autosize[i] || (newsize[i] > 0) ? scale[i] : autoscale;
+  for (int i = 0; i < 3; ++i)
+    newscale[i] = !autosize[i] || (newsize[i] > 0) ? scale[i] : autoscale;
 
   Transform3d t;
-  t.matrix() <<
-    newscale[0], 0, 0, 0,
-    0, newscale[1], 0, 0,
-    0, 0, newscale[2], 0,
-    0, 0, 0, 1;
+  t.matrix() << newscale[0], 0, 0, 0, 0, newscale[1], 0, 0, 0, 0, newscale[2],
+      0, 0, 0, 0, 1;
 
   return t;
 }
@@ -520,17 +549,19 @@ Transform3d GeometryUtils::getResizeTransform(const BoundingBox& bbox, const Vec
 // Return or force creation of backend-specific geometry.
 // Will prefer Manifold if multiple backends are enabled.
 // geom must be a 3D PolySet or the correct backend-specific geometry.
-std::shared_ptr<const Geometry> GeometryUtils::getBackendSpecificGeometry(const std::shared_ptr<const Geometry>& geom)
-{
+std::shared_ptr<const Geometry> GeometryUtils::getBackendSpecificGeometry(
+    const std::shared_ptr<const Geometry> &geom) {
 #if ENABLE_MANIFOLD
   if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
     if (const auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
-      std::shared_ptr<ManifoldGeometry> mani = ManifoldUtils::createManifoldFromPolySet(*ps);
+      std::shared_ptr<ManifoldGeometry> mani =
+          ManifoldUtils::createManifoldFromPolySet(*ps);
       if (mani == nullptr) {
         mani = std::make_shared<ManifoldGeometry>();
       }
       return mani;
-    } else if (auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
+    } else if (auto mani =
+                   std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
       return geom;
     } else {
       assert(false && "Unexpected geometry");
@@ -540,7 +571,8 @@ std::shared_ptr<const Geometry> GeometryUtils::getBackendSpecificGeometry(const
 #if ENABLE_CGAL
   if (auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
     return CGALUtils::createNefPolyhedronFromPolySet(*ps);
-  } else if (auto poly = std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
+  } else if (auto poly =
+                 std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
     return geom;
   } else {
     assert(false && "Unexpected geometry");
diff --git a/src/geometry/GeometryUtils.h b/src/geometry/GeometryUtils.h
index 7ea5d5ee6..d5e57598f 100644
--- a/src/geometry/GeometryUtils.h
+++ b/src/geometry/GeometryUtils.h
@@ -1,10 +1,10 @@
 #pragma once
 
-#include "geometry/linalg.h"
 #include "geometry/Geometry.h"
-#include <vector>
+#include "geometry/linalg.h"
 #include <boost/container/small_vector.hpp>
 #include <memory>
+#include <vector>
 
 using Polygon = std::vector<Vector3d>;
 using Polygons = std::vector<Polygon>;
@@ -32,18 +32,19 @@ struct IndexedPolyMesh {
 
 namespace GeometryUtils {
 
-bool tessellatePolygon(const Polygon& polygon,
-                       Polygons& triangles,
+bool tessellatePolygon(const Polygon &polygon, Polygons &triangles,
                        const Vector3f *normal = nullptr);
-bool tessellatePolygonWithHoles(const std::vector<Vector3f>& vertices,
-                                const std::vector<IndexedFace>& faces,
-                                std::vector<IndexedTriangle>& triangles,
+bool tessellatePolygonWithHoles(const std::vector<Vector3f> &vertices,
+                                const std::vector<IndexedFace> &faces,
+                                std::vector<IndexedTriangle> &triangles,
                                 const Vector3f *normal = nullptr);
 
-int findUnconnectedEdges(const std::vector<std::vector<IndexedFace>>& polygons);
-int findUnconnectedEdges(const std::vector<IndexedTriangle>& triangles);
+int findUnconnectedEdges(const std::vector<std::vector<IndexedFace>> &polygons);
+int findUnconnectedEdges(const std::vector<IndexedTriangle> &triangles);
 
-Transform3d getResizeTransform(const BoundingBox& bbox, const Vector3d& newsize, const Eigen::Matrix<bool, 3, 1>& autosize);
-std::shared_ptr<const Geometry> getBackendSpecificGeometry(const std::shared_ptr<const Geometry>& geom);
+Transform3d getResizeTransform(const BoundingBox &bbox, const Vector3d &newsize,
+                               const Eigen::Matrix<bool, 3, 1> &autosize);
+std::shared_ptr<const Geometry>
+getBackendSpecificGeometry(const std::shared_ptr<const Geometry> &geom);
 
-}
+} // namespace GeometryUtils
diff --git a/src/geometry/Grid.h b/src/geometry/Grid.h
index ea26ed9df..b2ee70447 100644
--- a/src/geometry/Grid.h
+++ b/src/geometry/Grid.h
@@ -9,8 +9,8 @@
 #include <unordered_map>
 #include <utility>
 
-//const double GRID_COARSE = 0.001;
-//const double GRID_FINE   = 0.000001;
+// const double GRID_COARSE = 0.001;
+// const double GRID_FINE   = 0.000001;
 /* Using decimals that are exactly convertible to binary floating point
    (and then converted exactly to a GMPQ Rational that uses a small amount
    of bytes aka "limbs" in CGAL's engine) provides at least a 5% speedup
@@ -19,29 +19,28 @@
 const double GRID_COARSE = 0.0009765625;
 const double GRID_FINE = 0.00000095367431640625;
 
-template <typename T>
-class Grid2d
-{
+template <typename T> class Grid2d {
 public:
   double res;
-  std::unordered_map<std::pair<int64_t, int64_t>, T, boost::hash<std::pair<int64_t, int64_t>>> db;
+  std::unordered_map<std::pair<int64_t, int64_t>, T,
+                     boost::hash<std::pair<int64_t, int64_t>>>
+      db;
 
-  Grid2d(double resolution) {
-    res = resolution;
-  }
+  Grid2d(double resolution) { res = resolution; }
   /*!
      Aligns x,y to the grid or to existing point if one close enough exists.
-     Returns the value stored if a point already existing or an uninitialized new value
-     if not.
+     Returns the value stored if a point already existing or an uninitialized
+     new value if not.
    */
-  T& align(double& x, double& y) {
+  T &align(double &x, double &y) {
     auto ix = (int64_t)std::round(x / res);
     auto iy = (int64_t)std::round(y / res);
     if (db.find(std::make_pair(ix, iy)) == db.end()) {
       int dist = 10;
       for (int64_t jx = ix - 1; jx <= ix + 1; ++jx) {
         for (int64_t jy = iy - 1; jy <= iy + 1; ++jy) {
-          if (db.find(std::make_pair(jx, jy)) == db.end()) continue;
+          if (db.find(std::make_pair(jx, jy)) == db.end())
+            continue;
           int d = abs(int(ix - jx)) + abs(int(iy - jy));
           if (d < dist) {
             dist = d;
@@ -58,10 +57,12 @@ public:
   [[nodiscard]] bool has(double x, double y) const {
     auto ix = (int64_t)std::round(x / res);
     auto iy = (int64_t)std::round(y / res);
-    if (db.find(std::make_pair(ix, iy)) != db.end()) return true;
+    if (db.find(std::make_pair(ix, iy)) != db.end())
+      return true;
     for (int64_t jx = ix - 1; jx <= ix + 1; ++jx)
       for (int64_t jy = iy - 1; jy <= iy + 1; ++jy) {
-        if (db.find(std::make_pair(jx, jy)) != db.end()) return true;
+        if (db.find(std::make_pair(jx, jy)) != db.end())
+          return true;
       }
     return false;
   }
@@ -69,31 +70,24 @@ public:
   bool eq(double x1, double y1, double x2, double y2) {
     align(x1, y1);
     align(x2, y2);
-    if (fabs(x1 - x2) < res && fabs(y1 - y2) < res) return true;
+    if (fabs(x1 - x2) < res && fabs(y1 - y2) < res)
+      return true;
     return false;
   }
-  T& data(double x, double y) {
-    return align(x, y);
-  }
-  T& operator()(double x, double y) {
-    return align(x, y);
-  }
+  T &data(double x, double y) { return align(x, y); }
+  T &operator()(double x, double y) { return align(x, y); }
 };
 
-template <typename T>
-class Grid3d
-{
+template <typename T> class Grid3d {
 public:
   double res;
   using Key = Vector3l;
   using GridContainer = std::unordered_map<Key, T>;
   GridContainer db;
 
-  Grid3d(double resolution) {
-    res = resolution;
-  }
+  Grid3d(double resolution) { res = resolution; }
 
-  inline void createGridVertex(const Vector3d& v, Vector3l& i) {
+  inline void createGridVertex(const Vector3d &v, Vector3l &i) {
     i[0] = int64_t(v[0] / this->res);
     i[1] = int64_t(v[1] / this->res);
     i[2] = int64_t(v[2] / this->res);
@@ -101,7 +95,7 @@ public:
 
   // Aligns vertex to the grid. Returns index of the vertex.
   // Will automatically increase the index as new unique vertices are added.
-  T align(Vector3d& v) {
+  T align(Vector3d &v) {
     Vector3l key;
     createGridVertex(v, key);
     auto iter = db.find(key);
@@ -112,7 +106,8 @@ public:
           for (int64_t jz = key[2] - 1; jz <= key[2] + 1; ++jz) {
             Vector3l k(jx, jy, jz);
             auto tmpiter = db.find(k);
-            if (tmpiter == db.end()) continue;
+            if (tmpiter == db.end())
+              continue;
             float d = sqrt((key - k).squaredNorm());
             if (d < dist) {
               dist = d;
@@ -141,11 +136,12 @@ public:
     return data;
   }
 
-  bool has(const Vector3d& v, T *data = nullptr) {
+  bool has(const Vector3d &v, T *data = nullptr) {
     Vector3l key = createGridVertex(v);
     typename GridContainer::iterator pos = db.find(key);
     if (pos != db.end()) {
-      if (data) *data = pos->second;
+      if (data)
+        *data = pos->second;
       return true;
     }
     for (int64_t jx = key[0] - 1; jx <= key[0] + 1; ++jx)
@@ -153,15 +149,13 @@ public:
         for (int64_t jz = key[2] - 1; jz <= key[2] + 1; ++jz) {
           pos = db.find(Vector3l(jx, jy, jz));
           if (pos != db.end()) {
-            if (data) *data = pos->second;
+            if (data)
+              *data = pos->second;
             return true;
           }
         }
     return false;
   }
 
-  T data(Vector3d v) {
-    return align(v);
-  }
-
+  T data(Vector3d v) { return align(v); }
 };
diff --git a/src/geometry/PolySet.cc b/src/geometry/PolySet.cc
index a7e81d446..ff2cf0fdb 100644
--- a/src/geometry/PolySet.cc
+++ b/src/geometry/PolySet.cc
@@ -26,15 +26,15 @@
 
 #include "geometry/PolySet.h"
 #include "geometry/Geometry.h"
+#include "geometry/Grid.h"
 #include "geometry/PolySetUtils.h"
 #include "geometry/linalg.h"
 #include "utils/printutils.h"
-#include "geometry/Grid.h"
-#include <algorithm>
-#include <sstream>
-#include <memory>
 #include <Eigen/LU>
+#include <algorithm>
 #include <cstddef>
+#include <memory>
+#include <sstream>
 #include <string>
 #include <vector>
 
@@ -53,23 +53,18 @@
  */
 
 PolySet::PolySet(unsigned int dim, boost::tribool convex)
-  : dim_(dim), convex_(convex)
-{
-}
+    : dim_(dim), convex_(convex) {}
 
 std::unique_ptr<Geometry> PolySet::copy() const {
   return std::make_unique<PolySet>(*this);
 }
 
-std::string PolySet::dump() const
-{
+std::string PolySet::dump() const {
   std::ostringstream out;
   out << "PolySet:"
-      << "\n dimensions:" << dim_
-      << "\n convexity:" << this->convexity
-      << "\n num polygons: " << indices.size()
-      << "\n polygons data:";
-  for (const auto& polygon : indices) {
+      << "\n dimensions:" << dim_ << "\n convexity:" << this->convexity
+      << "\n num polygons: " << indices.size() << "\n polygons data:";
+  for (const auto &polygon : indices) {
     out << "\n  polygon begin:";
     for (auto v : polygon) {
       out << "\n   vertex:" << this->vertices[v].transpose();
@@ -79,69 +74,71 @@ std::string PolySet::dump() const
   return out.str();
 }
 
-BoundingBox PolySet::getBoundingBox() const
-{
+BoundingBox PolySet::getBoundingBox() const {
   if (bbox_.isNull()) {
-    for (const auto& v : vertices) {
+    for (const auto &v : vertices) {
       bbox_.extend(v);
     }
   }
   return bbox_;
 }
 
-size_t PolySet::memsize() const
-{
+size_t PolySet::memsize() const {
   size_t mem = 0;
-  for (const auto& p : this->indices) mem += p.size() * sizeof(int);
-  for (const auto& p : this->vertices) mem += p.size() * sizeof(Vector3d);
+  for (const auto &p : this->indices)
+    mem += p.size() * sizeof(int);
+  for (const auto &p : this->vertices)
+    mem += p.size() * sizeof(Vector3d);
   mem += sizeof(PolySet);
   return mem;
 }
-void PolySet::transform(const Transform3d& mat)
-{
-  // If mirroring transform, flip faces to avoid the object to end up being inside-out
+void PolySet::transform(const Transform3d &mat) {
+  // If mirroring transform, flip faces to avoid the object to end up being
+  // inside-out
   bool mirrored = mat.matrix().determinant() < 0;
 
-  for (auto& v : this->vertices)
+  for (auto &v : this->vertices)
     v = mat * v;
 
   if (mirrored)
-    for (auto& p : this->indices) {
+    for (auto &p : this->indices) {
       std::reverse(p.begin(), p.end());
     }
   bbox_.setNull();
 }
 
-void PolySet::setColor(const Color4f& c) {
+void PolySet::setColor(const Color4f &c) {
   colors = {c};
   color_indices.assign(indices.size(), 0);
 }
 
 bool PolySet::isConvex() const {
-  if (convex_ || this->isEmpty()) return true;
-  if (!convex_) return false;
+  if (convex_ || this->isEmpty())
+    return true;
+  if (!convex_)
+    return false;
   bool is_convex = PolySetUtils::is_approximately_convex(*this);
   convex_ = is_convex;
   return is_convex;
 }
 
-void PolySet::resize(const Vector3d& newsize, const Eigen::Matrix<bool, 3, 1>& autosize)
-{
-  this->transform(GeometryUtils::getResizeTransform(this->getBoundingBox(), newsize, autosize));
+void PolySet::resize(const Vector3d &newsize,
+                     const Eigen::Matrix<bool, 3, 1> &autosize) {
+  this->transform(GeometryUtils::getResizeTransform(this->getBoundingBox(),
+                                                    newsize, autosize));
 }
 
 /*!
-   Quantizes vertices by gridding them as well as merges close vertices belonging to
-   neighboring grids.
-   May reduce the number of polygons if polygons collapse into < 3 vertices.
+   Quantizes vertices by gridding them as well as merges close vertices
+   belonging to neighboring grids. May reduce the number of polygons if polygons
+   collapse into < 3 vertices.
  */
-void PolySet::quantizeVertices(std::vector<Vector3d> *pPointsOut)
-{
+void PolySet::quantizeVertices(std::vector<Vector3d> *pPointsOut) {
   const bool has_colors = !this->color_indices.empty();
   Grid3d<unsigned int> grid(GRID_FINE);
   std::vector<unsigned int> polygon_indices; // Vertex indices in one polygon
   for (size_t i = 0; i < this->indices.size();) {
-    IndexedFace& ind_f = this->indices[i];
+    IndexedFace &ind_f = this->indices[i];
     polygon_indices.resize(ind_f.size());
     // Quantize all vertices. Build index list
     for (unsigned int i = 0; i < ind_f.size(); ++i) {
@@ -153,7 +150,8 @@ void PolySet::quantizeVertices(std::vector<Vector3d> *pPointsOut)
     // Remove consecutive duplicate vertices
     auto currp = ind_f.begin();
     for (unsigned int i = 0; i < polygon_indices.size(); ++i) {
-      if (polygon_indices[i] != polygon_indices[(i + 1) % polygon_indices.size()]) {
+      if (polygon_indices[i] !=
+          polygon_indices[(i + 1) % polygon_indices.size()]) {
         (*currp++) = ind_f[i];
       }
     }
@@ -161,7 +159,8 @@ void PolySet::quantizeVertices(std::vector<Vector3d> *pPointsOut)
     if (ind_f.size() < 3) {
       PRINTD("Removing collapsed polygon due to quantizing");
       this->indices.erase(this->indices.begin() + i);
-      if (has_colors) this->color_indices.erase(this->color_indices.begin() + i);
+      if (has_colors)
+        this->color_indices.erase(this->color_indices.begin() + i);
     } else {
       i++;
     }
diff --git a/src/geometry/PolySet.h b/src/geometry/PolySet.h
index 9c8e5dd58..59eb42f5e 100644
--- a/src/geometry/PolySet.h
+++ b/src/geometry/PolySet.h
@@ -1,27 +1,28 @@
 #pragma once
 
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
 #include "geometry/GeometryUtils.h"
 #include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 #include "utils/boost-utils.h"
 
+#include <cstddef>
 #include <cstdint>
 #include <memory>
-#include <cstddef>
 #include <string>
 #include <vector>
 
 class PolySetBuilder;
 
-class PolySet : public Geometry
-{
+class PolySet : public Geometry {
   friend class PolySetBuilder;
+
 public:
   VISITABLE_GEOMETRY();
   PolygonIndices indices;
   std::vector<Vector3d> vertices;
-  // Per polygon color, indexing the colors vector below. Can be empty, and -1 means no specific color.
+  // Per polygon color, indexing the colors vector below. Can be empty, and -1
+  // means no specific color.
   std::vector<int32_t> color_indices;
   std::vector<Color4f> colors;
 
@@ -36,9 +37,10 @@ public:
 
   void quantizeVertices(std::vector<Vector3d> *pPointsOut = nullptr);
   size_t numFacets() const override { return indices.size(); }
-  void transform(const Transform3d& mat) override;
-  void resize(const Vector3d& newsize, const Eigen::Matrix<bool, 3, 1>& autosize) override;
-  void setColor(const Color4f& c) override;
+  void transform(const Transform3d &mat) override;
+  void resize(const Vector3d &newsize,
+              const Eigen::Matrix<bool, 3, 1> &autosize) override;
+  void setColor(const Color4f &c) override;
 
   bool isConvex() const;
   boost::tribool convexValue() const { return convex_; }
@@ -46,7 +48,9 @@ public:
   bool isTriangular() const { return is_triangular_; }
   void setTriangular(bool triangular) { is_triangular_ = triangular; }
 
-  static std::unique_ptr<PolySet> createEmpty() { return std::make_unique<PolySet>(3); }
+  static std::unique_ptr<PolySet> createEmpty() {
+    return std::make_unique<PolySet>(3);
+  }
 
 private:
   bool is_triangular_ = false;
diff --git a/src/geometry/PolySetBuilder.cc b/src/geometry/PolySetBuilder.cc
index 1cd05f100..b8ced3527 100644
--- a/src/geometry/PolySetBuilder.cc
+++ b/src/geometry/PolySetBuilder.cc
@@ -25,78 +25,73 @@
  */
 
 #include "geometry/PolySetBuilder.h"
-#include "geometry/linalg.h"
-#include "geometry/PolySet.h"
 #include "geometry/Geometry.h"
+#include "geometry/PolySet.h"
+#include "geometry/linalg.h"
 
 #ifdef ENABLE_CGAL
-#include "geometry/cgal/cgalutils.h"
 #include "geometry/cgal/CGALNefGeometry.h"
+#include "geometry/cgal/cgalutils.h"
 #endif
 #ifdef ENABLE_MANIFOLD
 #include "geometry/manifold/ManifoldGeometry.h"
 #endif
 
 #include <algorithm>
-#include <iterator>
 #include <cassert>
-#include <utility>
 #include <cstdint>
+#include <iterator>
 #include <memory>
+#include <utility>
 #include <vector>
 
-PolySetBuilder::PolySetBuilder(int vertices_count, int indices_count, int dim, boost::tribool convex)
-  : dim_(dim), convex_(convex)
-{
+PolySetBuilder::PolySetBuilder(int vertices_count, int indices_count, int dim,
+                               boost::tribool convex)
+    : dim_(dim), convex_(convex) {
   reserve(vertices_count, indices_count);
 }
 
 void PolySetBuilder::reserve(int vertices_count, int indices_count) {
-  if (vertices_count != 0) vertices_.reserve(vertices_count);
-  if (indices_count != 0) indices_.reserve(indices_count);
+  if (vertices_count != 0)
+    vertices_.reserve(vertices_count);
+  if (indices_count != 0)
+    indices_.reserve(indices_count);
 }
 
-void PolySetBuilder::setConvexity(int convexity){
-  convexity_ = convexity;
-}
+void PolySetBuilder::setConvexity(int convexity) { convexity_ = convexity; }
 
-void PolySetBuilder::addColor(const Color4f& color)
-{
+void PolySetBuilder::addColor(const Color4f &color) {
   colors_.push_back(color);
 }
 
-void PolySetBuilder::addColorIndex(const int32_t idx)
-{
+void PolySetBuilder::addColorIndex(const int32_t idx) {
   color_indices_.push_back(idx);
 }
 
-int PolySetBuilder::numVertices() const {
-  return vertices_.size();
-}
+int PolySetBuilder::numVertices() const { return vertices_.size(); }
 
-int PolySetBuilder::numPolygons() const {
-  return indices_.size();
-}
+int PolySetBuilder::numPolygons() const { return indices_.size(); }
 
 bool PolySetBuilder::isEmpty() const {
   return vertices_.size() == 0 && indices_.size() == 0;
 }
 
-int PolySetBuilder::vertexIndex(const Vector3d& pt)
-{
+int PolySetBuilder::vertexIndex(const Vector3d &pt) {
   return vertices_.lookup(pt);
 }
 
-void PolySetBuilder::appendGeometry(const std::shared_ptr<const Geometry>& geom)
-{
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
-    for (const Geometry::GeometryItem& item : geomlist->getChildren()) {
+void PolySetBuilder::appendGeometry(
+    const std::shared_ptr<const Geometry> &geom) {
+  if (const auto geomlist =
+          std::dynamic_pointer_cast<const GeometryList>(geom)) {
+    for (const Geometry::GeometryItem &item : geomlist->getChildren()) {
       appendGeometry(item.second);
     }
   } else if (const auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
     appendPolySet(*ps);
 #ifdef ENABLE_CGAL
-  } else if (const auto N = std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
+  } else if (const auto N =
+                 std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
     if (const auto ps = CGALUtils::createPolySetFromNefPolyhedron3(*(N->p3))) {
       appendPolySet(*ps);
     } else {
@@ -104,28 +99,29 @@ void PolySetBuilder::appendGeometry(const std::shared_ptr<const Geometry>& geom)
     }
 #endif // ifdef ENABLE_CGAL
 #ifdef ENABLE_MANIFOLD
-  } else if (const auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
+  } else if (const auto mani =
+                 std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
     appendPolySet(*mani->toPolySet());
 #endif
-  } else if (std::dynamic_pointer_cast<const Polygon2d>(geom)) { // NOLINT(bugprone-branch-clone)
+  } else if (std::dynamic_pointer_cast<const Polygon2d>(
+                 geom)) { // NOLINT(bugprone-branch-clone)
     assert(false && "Unsupported geometry");
   } else { // NOLINT(bugprone-branch-clone)
     assert(false && "Not implemented");
   }
-
 }
 
-void PolySetBuilder::appendPolygon(const std::vector<int>& inds)
-{
+void PolySetBuilder::appendPolygon(const std::vector<int> &inds) {
   beginPolygon(inds.size());
-  for (int idx : inds) addVertex(idx);
+  for (int idx : inds)
+    addVertex(idx);
   endPolygon();
 }
 
-void PolySetBuilder::appendPolygon(const std::vector<Vector3d>& polygon)
-{
+void PolySetBuilder::appendPolygon(const std::vector<Vector3d> &polygon) {
   beginPolygon(polygon.size());
-  for (const auto& v: polygon) addVertex(v);
+  for (const auto &v : polygon)
+    addVertex(v);
   endPolygon();
 }
 
@@ -134,21 +130,19 @@ void PolySetBuilder::beginPolygon(int nvertices) {
   current_polygon_.reserve(nvertices);
 }
 
-void PolySetBuilder::addVertex(int ind)
-{
+void PolySetBuilder::addVertex(int ind) {
   // Ignore consecutive duplicate indices
-  if (current_polygon_.empty() || (ind != current_polygon_.back() && ind != current_polygon_.front())) {
+  if (current_polygon_.empty() ||
+      (ind != current_polygon_.back() && ind != current_polygon_.front())) {
     current_polygon_.push_back(ind);
   }
 }
 
-void PolySetBuilder::addVertex(const Vector3d& v)
-{
-  addVertex(vertexIndex(v));
-}
+void PolySetBuilder::addVertex(const Vector3d &v) { addVertex(vertexIndex(v)); }
 
-void PolySetBuilder::endPolygon(const Color4f& color) {
-  // FIXME: Should we check for self-touching polygons (non-consecutive duplicate indices)?
+void PolySetBuilder::endPolygon(const Color4f &color) {
+  // FIXME: Should we check for self-touching polygons (non-consecutive
+  // duplicate indices)?
 
   // FIXME: Can we move? What would the state of current_polygon_ be after move?
   if (current_polygon_.size() >= 3) {
@@ -170,8 +164,7 @@ void PolySetBuilder::endPolygon(const Color4f& color) {
   current_polygon_.clear();
 }
 
-void PolySetBuilder::appendPolySet(const PolySet& ps)
-{
+void PolySetBuilder::appendPolySet(const PolySet &ps) {
   // Copy color indices lazily.
   if (!ps.color_indices.empty()) {
     // If we hadn't built color_indices_ yet, catch up / fill w/ -1.
@@ -183,7 +176,7 @@ void PolySetBuilder::appendPolySet(const PolySet& ps)
     auto nColors = ps.colors.size();
     std::vector<uint32_t> color_map(nColors);
     for (size_t i = 0; i < nColors; i++) {
-      const auto& color = ps.colors[i];
+      const auto &color = ps.colors[i];
       // Find index of color in colors_, or add it if it doesn't exist
       auto it = std::find(colors_.begin(), colors_.end(), color);
       if (it == colors_.end()) {
@@ -197,22 +190,23 @@ void PolySetBuilder::appendPolySet(const PolySet& ps)
       color_indices_.push_back(color_index < 0 ? -1 : color_map[color_index]);
     }
   } else if (!color_indices_.empty()) {
-    // If we already built color_indices_ but don't have colors with this ps, fill with -1.
+    // If we already built color_indices_ but don't have colors with this ps,
+    // fill with -1.
     color_indices_.resize(color_indices_.size() + ps.indices.size(), -1);
   }
 
-  reserve(numVertices() + ps.vertices.size(), numPolygons() + ps.indices.size());
-  for (const auto& poly : ps.indices) {
+  reserve(numVertices() + ps.vertices.size(),
+          numPolygons() + ps.indices.size());
+  for (const auto &poly : ps.indices) {
     beginPolygon(poly.size());
-    for (const auto& ind: poly) {
+    for (const auto &ind : poly) {
       addVertex(ps.vertices[ind]);
     }
     endPolygon();
   }
 }
 
-std::unique_ptr<PolySet> PolySetBuilder::build()
-{
+std::unique_ptr<PolySet> PolySetBuilder::build() {
   endPolygon();
   std::unique_ptr<PolySet> polyset;
   polyset = std::make_unique<PolySet>(dim_, convex_);
@@ -222,7 +216,7 @@ std::unique_ptr<PolySet> PolySetBuilder::build()
   polyset->colors = std::move(colors_);
   polyset->setConvexity(convexity_);
   bool is_triangular = true;
-  for (const auto& face : polyset->indices) {
+  for (const auto &face : polyset->indices) {
     if (face.size() > 3) {
       is_triangular = false;
       break;
diff --git a/src/geometry/PolySetBuilder.h b/src/geometry/PolySetBuilder.h
index 04363f933..b05581add 100644
--- a/src/geometry/PolySetBuilder.h
+++ b/src/geometry/PolySetBuilder.h
@@ -4,41 +4,43 @@
 #include <memory>
 #include <vector>
 
-#include "geometry/Reindexer.h"
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
+#include "geometry/GeometryUtils.h"
 #include "geometry/Polygon2d.h"
+#include "geometry/Reindexer.h"
+#include "geometry/linalg.h"
 #include "utils/boost-utils.h"
-#include "geometry/GeometryUtils.h"
 
 class PolySet;
 
-class PolySetBuilder
-{
+class PolySetBuilder {
 public:
-  PolySetBuilder(int vertices_count = 0, int indices_count = 0, int dim = 3, boost::tribool convex = unknown);
+  PolySetBuilder(int vertices_count = 0, int indices_count = 0, int dim = 3,
+                 boost::tribool convex = unknown);
   void reserve(int vertices_count = 0, int indices_count = 0);
   void setConvexity(int n);
-  int vertexIndex(const Vector3d& coord);
+  int vertexIndex(const Vector3d &coord);
   int numVertices() const;
   int numPolygons() const;
   bool isEmpty() const;
 
-  void appendPolySet(const PolySet& ps);
-  void appendGeometry(const std::shared_ptr<const Geometry>& geom);
-  void appendPolygon(const std::vector<int>& inds);
-  void appendPolygon(const std::vector<Vector3d>& v);
+  void appendPolySet(const PolySet &ps);
+  void appendGeometry(const std::shared_ptr<const Geometry> &geom);
+  void appendPolygon(const std::vector<int> &inds);
+  void appendPolygon(const std::vector<Vector3d> &v);
 
   void beginPolygon(int nvertices);
   void addVertex(int ind);
-  void addVertex(const Vector3d& v);
-  // Calling this is optional; will be called automatically when adding a new polygon or building the PolySet
-  void endPolygon(const Color4f& color = {});
+  void addVertex(const Vector3d &v);
+  // Calling this is optional; will be called automatically when adding a new
+  // polygon or building the PolySet
+  void endPolygon(const Color4f &color = {});
 
-  void addColor(const Color4f& color);
+  void addColor(const Color4f &color);
   void addColorIndex(int idx); // should be paired with begin/endPolygon()
 
   std::unique_ptr<PolySet> build();
+
 private:
   Reindexer<Vector3d> vertices_;
   PolygonIndices indices_;
diff --git a/src/geometry/PolySetUtils.cc b/src/geometry/PolySetUtils.cc
index d58ace789..5996b0396 100644
--- a/src/geometry/PolySetUtils.cc
+++ b/src/geometry/PolySetUtils.cc
@@ -1,21 +1,21 @@
 #include "geometry/PolySetUtils.h"
 
 #include <cassert>
+#include <cstddef>
 #include <cstdint>
 #include <memory>
-#include <cstddef>
 #include <sstream>
 #include <vector>
 
 #include <boost/range/adaptor/reversed.hpp>
 
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
+#include "geometry/GeometryUtils.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetBuilder.h"
 #include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 #include "utils/printutils.h"
-#include "geometry/GeometryUtils.h"
 #ifdef ENABLE_CGAL
 #include "geometry/cgal/cgalutils.h"
 #endif
@@ -28,13 +28,13 @@ namespace PolySetUtils {
 // Project all polygons (also back-facing) into a Polygon2d instance.
 // It is important to select all faces, since filtering by normal vector here
 // will trigger floating point incertainties and cause problems later.
-std::unique_ptr<Polygon2d> project(const PolySet& ps) {
+std::unique_ptr<Polygon2d> project(const PolySet &ps) {
   auto poly = std::make_unique<Polygon2d>();
 
   Vector3d pt;
-  for (const auto& p : ps.indices) {
+  for (const auto &p : ps.indices) {
     Outline2d outline;
-    for (const auto& v : p) {
+    for (const auto &v : p) {
       pt = ps.vertices[v];
       outline.vertices.emplace_back(pt[0], pt[1]);
     }
@@ -62,8 +62,7 @@ std::unique_ptr<Polygon2d> project(const PolySet& ps) {
    polyset has simple polygon faces with no holes.
    The tessellation will be robust wrt. degenerate and self-intersecting
  */
-std::unique_ptr<PolySet> tessellate_faces(const PolySet& polyset)
-{
+std::unique_ptr<PolySet> tessellate_faces(const PolySet &polyset) {
   int degeneratePolygons = 0;
   auto result = std::make_unique<PolySet>(3, polyset.convexValue());
   result->setConvexity(polyset.getConvexity());
@@ -91,18 +90,21 @@ std::unique_ptr<PolySet> tessellate_faces(const PolySet& polyset)
     result->colors = polyset.colors;
   }
   for (size_t i = 0, n = polyset.indices.size(); i < n; i++) {
-    const auto& pgon = polyset.indices[i];
+    const auto &pgon = polyset.indices[i];
     if (pgon.size() < 3) {
       degeneratePolygons++;
       continue;
     }
-    auto& currface = polygons.emplace_back();
-    for (const auto& ind : pgon) {
+    auto &currface = polygons.emplace_back();
+    for (const auto &ind : pgon) {
       const Vector3f v = polyset.vertices[ind].cast<float>();
-      if (currface.empty() || v != polyset.vertices[currface.back()].cast<float>())currface.push_back(ind);
+      if (currface.empty() ||
+          v != polyset.vertices[currface.back()].cast<float>())
+        currface.push_back(ind);
     }
     const Vector3f head = polyset.vertices[currface.front()].cast<float>();
-    while (!currface.empty() && head == polyset.vertices[currface.back()].cast<float>())
+    while (!currface.empty() &&
+           head == polyset.vertices[currface.back()].cast<float>())
       currface.pop_back();
     if (currface.size() < 3) {
       polygons.pop_back();
@@ -111,7 +113,7 @@ std::unique_ptr<PolySet> tessellate_faces(const PolySet& polyset)
     if (has_colors) {
       polygon_color_indices.push_back(polyset.color_indices[i]);
     }
-    for (const auto& ind : currface)
+    for (const auto &ind : currface)
       used[ind] = true;
   }
   // remove unreferenced vertices
@@ -127,8 +129,8 @@ std::unique_ptr<PolySet> tessellate_faces(const PolySet& polyset)
   }
   if (verts.size() != polyset.vertices.size()) {
     // only remap indices when some vertices are really removed
-    for (auto& face : polygons) {
-      for (auto& ind : face)
+    for (auto &face : polygons) {
+      for (auto &ind : face)
         ind = indexMap[ind];
     }
   }
@@ -137,22 +139,25 @@ std::unique_ptr<PolySet> tessellate_faces(const PolySet& polyset)
   std::vector<IndexedTriangle> triangles;
   std::vector<IndexedFace> facesBuffer(1);
   for (size_t i = 0, n = polygons.size(); i < n; i++) {
-    const auto& face = polygons[i];
+    const auto &face = polygons[i];
     if (face.size() == 3) {
       // trivial case - triangles cannot be concave or have holes
       result->indices.push_back({face[0], face[1], face[2]});
-      if (has_colors)result->color_indices.push_back(polygon_color_indices[i]);
+      if (has_colors)
+        result->color_indices.push_back(polygon_color_indices[i]);
     }
     // Quads seem trivial, but can be concave, and can have degenerate cases.
     // So everything more complex than triangles goes into the general case.
     else {
       triangles.clear();
       facesBuffer[0] = face;
-      auto err = GeometryUtils::tessellatePolygonWithHoles(verts, facesBuffer, triangles, nullptr);
+      auto err = GeometryUtils::tessellatePolygonWithHoles(verts, facesBuffer,
+                                                           triangles, nullptr);
       if (!err) {
-        for (const auto& t : triangles) {
+        for (const auto &t : triangles) {
           result->indices.push_back({t[0], t[1], t[2]});
-          if (has_colors)result->color_indices.push_back(polygon_color_indices[i]);
+          if (has_colors)
+            result->color_indices.push_back(polygon_color_indices[i]);
         }
       }
     }
@@ -163,7 +168,7 @@ std::unique_ptr<PolySet> tessellate_faces(const PolySet& polyset)
   return result;
 }
 
-bool is_approximately_convex(const PolySet& ps) {
+bool is_approximately_convex(const PolySet &ps) {
 #ifdef ENABLE_CGAL
   return CGALUtils::is_approximately_convex(ps);
 #else
@@ -172,9 +177,10 @@ bool is_approximately_convex(const PolySet& ps) {
 }
 
 // Get as or convert the geometry to a PolySet.
-std::shared_ptr<const PolySet> getGeometryAsPolySet(const std::shared_ptr<const Geometry>& geom)
-{
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
+std::shared_ptr<const PolySet>
+getGeometryAsPolySet(const std::shared_ptr<const Geometry> &geom) {
+  if (const auto geomlist =
+          std::dynamic_pointer_cast<const GeometryList>(geom)) {
     PolySetBuilder builder;
     builder.appendGeometry(geom);
     return builder.build();
@@ -201,18 +207,16 @@ std::shared_ptr<const PolySet> getGeometryAsPolySet(const std::shared_ptr<const
   return nullptr;
 }
 
-
-std::string polySetToPolyhedronSource(const PolySet& ps)
-{
+std::string polySetToPolyhedronSource(const PolySet &ps) {
   std::stringstream sstr;
   sstr << "polyhedron(\n";
   sstr << "  points=[\n";
-  for (const auto& v : ps.vertices) {
+  for (const auto &v : ps.vertices) {
     sstr << "[" << v[0] << ", " << v[1] << ", " << v[2] << "],\n";
   }
   sstr << "  ],\n";
   sstr << "  faces=[\n";
-  for (const auto& polygon : ps.indices) {
+  for (const auto &polygon : ps.indices) {
     sstr << "[";
     for (const auto idx : boost::adaptors::reverse(polygon)) {
       sstr << idx << ",";
diff --git a/src/geometry/PolySetUtils.h b/src/geometry/PolySetUtils.h
index 086417aa7..1a2d49116 100644
--- a/src/geometry/PolySetUtils.h
+++ b/src/geometry/PolySetUtils.h
@@ -1,7 +1,7 @@
 #pragma once
 
-#include <string>
 #include <memory>
+#include <string>
 
 #include "geometry/Geometry.h"
 
@@ -10,12 +10,13 @@ class PolySet;
 
 namespace PolySetUtils {
 
-std::unique_ptr<Polygon2d> project(const PolySet& ps);
-std::unique_ptr<PolySet> tessellate_faces(const PolySet& inps);
-bool is_approximately_convex(const PolySet& ps);
+std::unique_ptr<Polygon2d> project(const PolySet &ps);
+std::unique_ptr<PolySet> tessellate_faces(const PolySet &inps);
+bool is_approximately_convex(const PolySet &ps);
 
-std::shared_ptr<const PolySet> getGeometryAsPolySet(const std::shared_ptr<const class Geometry>&);
+std::shared_ptr<const PolySet>
+getGeometryAsPolySet(const std::shared_ptr<const class Geometry> &);
 
-std::string polySetToPolyhedronSource(const PolySet& ps);
+std::string polySetToPolyhedronSource(const PolySet &ps);
 
-}
+} // namespace PolySetUtils
diff --git a/src/geometry/Polygon2d.cc b/src/geometry/Polygon2d.cc
index 409d306de..0df3e5a67 100644
--- a/src/geometry/Polygon2d.cc
+++ b/src/geometry/Polygon2d.cc
@@ -1,10 +1,10 @@
 #include "geometry/Polygon2d.h"
 
-#include <sstream>
-#include <utility>
 #include <cstddef>
-#include <string>
 #include <memory>
+#include <sstream>
+#include <string>
+#include <utility>
 
 #include "geometry/Geometry.h"
 #include "geometry/linalg.h"
@@ -12,24 +12,22 @@
 #ifdef ENABLE_MANIFOLD
 #include "geometry/manifold/manifoldutils.h"
 #endif
-#include "geometry/cgal/cgalutils.h"
 #include "Feature.h"
 #include "geometry/PolySet.h"
+#include "geometry/cgal/cgalutils.h"
 #include "glview/RenderSettings.h"
 
-
 Polygon2d::Polygon2d(Outline2d outline) : sanitized(true) {
   addOutline(std::move(outline));
 }
 
-std::unique_ptr<Geometry> Polygon2d::copy() const
-{
+std::unique_ptr<Geometry> Polygon2d::copy() const {
   return std::make_unique<Polygon2d>(*this);
 }
 
 BoundingBox Outline2d::getBoundingBox() const {
   BoundingBox bbox;
-  for (const auto& v : this->vertices) {
+  for (const auto &v : this->vertices) {
     bbox.extend(Vector3d(v[0], v[1], 0));
   }
   return bbox;
@@ -50,31 +48,28 @@ BoundingBox Outline2d::getBoundingBox() const {
    the flag can be set manually.
  */
 
-size_t Polygon2d::memsize() const
-{
+size_t Polygon2d::memsize() const {
   size_t mem = 0;
-  for (const auto& o : this->outlines()) {
+  for (const auto &o : this->outlines()) {
     mem += o.vertices.size() * sizeof(Vector2d) + sizeof(Outline2d);
   }
   mem += sizeof(Polygon2d);
   return mem;
 }
 
-BoundingBox Polygon2d::getBoundingBox() const
-{
+BoundingBox Polygon2d::getBoundingBox() const {
   BoundingBox bbox;
-  for (const auto& o : this->outlines()) {
+  for (const auto &o : this->outlines()) {
     bbox.extend(o.getBoundingBox());
   }
   return bbox;
 }
 
-std::string Polygon2d::dump() const
-{
+std::string Polygon2d::dump() const {
   std::ostringstream out;
-  for (const auto& o : this->theoutlines) {
+  for (const auto &o : this->theoutlines) {
     out << "contour:\n";
-    for (const auto& v : o.vertices) {
+    for (const auto &v : o.vertices) {
       out << "  " << v.transpose();
     }
     out << "\n";
@@ -82,27 +77,23 @@ std::string Polygon2d::dump() const
   return out.str();
 }
 
-bool Polygon2d::isEmpty() const
-{
-  return this->theoutlines.empty();
-}
+bool Polygon2d::isEmpty() const { return this->theoutlines.empty(); }
 
-void Polygon2d::transform(const Transform2d& mat)
-{
+void Polygon2d::transform(const Transform2d &mat) {
   if (mat.matrix().determinant() == 0) {
     LOG(message_group::Warning, "Scaling a 2D object with 0 - removing object");
     this->theoutlines.clear();
     return;
   }
-  for (auto& o : this->theoutlines) {
-    for (auto& v : o.vertices) {
+  for (auto &o : this->theoutlines) {
+    for (auto &v : o.vertices) {
       v = mat * v;
     }
   }
 }
 
-void Polygon2d::resize(const Vector2d& newsize, const Eigen::Matrix<bool, 2, 1>& autosize)
-{
+void Polygon2d::resize(const Vector2d &newsize,
+                       const Eigen::Matrix<bool, 2, 1> &autosize) {
   auto bbox = this->getBoundingBox();
 
   // Find largest dimension
@@ -113,53 +104,50 @@ void Polygon2d::resize(const Vector2d& newsize, const Eigen::Matrix<bool, 2, 1>&
                  newsize[1] > 0 ? newsize[1] / bbox.sizes()[1] : 1);
 
   // Autoscale where applicable
-  double autoscale = newsize[maxdim] > 0 ? newsize[maxdim] / bbox.sizes()[maxdim] : 1;
+  double autoscale =
+      newsize[maxdim] > 0 ? newsize[maxdim] / bbox.sizes()[maxdim] : 1;
   Vector2d newscale(!autosize[0] || (newsize[0] > 0) ? scale[0] : autoscale,
                     !autosize[1] || (newsize[1] > 0) ? scale[1] : autoscale);
 
   Transform2d t;
-  t.matrix() <<
-    newscale[0], 0, 0,
-    0, newscale[1], 0,
-    0, 0, 1;
+  t.matrix() << newscale[0], 0, 0, 0, newscale[1], 0, 0, 0, 1;
 
   this->transform(t);
 }
 
-bool Polygon2d::is_convex() const
-{
-  if (theoutlines.size() > 1) return false;
-  if (theoutlines.empty()) return true;
+bool Polygon2d::is_convex() const {
+  if (theoutlines.size() > 1)
+    return false;
+  if (theoutlines.empty())
+    return true;
 
-  auto const& pts = theoutlines[0].vertices;
+  auto const &pts = theoutlines[0].vertices;
   int N = pts.size();
 
   // Check for a right turn. This assumes the polygon is simple.
   for (int i = 0; i < N; ++i) {
-    const auto& d1 = pts[(i + 1) % N] - pts[i];
-    const auto& d2 = pts[(i + 2) % N] - pts[(i + 1) % N];
+    const auto &d1 = pts[(i + 1) % N] - pts[i];
+    const auto &d2 = pts[(i + 2) % N] - pts[(i + 1) % N];
     double zcross = d1[0] * d2[1] - d1[1] * d2[0];
-    if (zcross < 0) return false;
+    if (zcross < 0)
+      return false;
   }
   return true;
 }
 
-double Polygon2d::area() const
-{
+double Polygon2d::area() const {
   auto ps = tessellate();
   if (ps == nullptr) {
     return 0;
   }
 
   double area = 0.0;
-  for (const auto& poly : ps->indices) {
-    const auto& v1 = ps->vertices[poly[0]];
-    const auto& v2 = ps->vertices[poly[1]];
-    const auto& v3 = ps->vertices[poly[2]];
-    area += 0.5 * (
-      v1.x() * (v2.y() - v3.y())
-      + v2.x() * (v3.y() - v1.y())
-      + v3.x() * (v1.y() - v2.y()));
+  for (const auto &poly : ps->indices) {
+    const auto &v1 = ps->vertices[poly[0]];
+    const auto &v2 = ps->vertices[poly[1]];
+    const auto &v3 = ps->vertices[poly[2]];
+    area += 0.5 * (v1.x() * (v2.y() - v3.y()) + v2.x() * (v3.y() - v1.y()) +
+                   v3.x() * (v1.y() - v2.y()));
   }
   return area;
 }
@@ -172,17 +160,18 @@ double Polygon2d::area() const
  * Rendering (both preview and render mode)
  * Polygon area calculation
  *
- * One use-case is special: For geometry construction in Manifold mode, we require this function to
- * guarantee that vertices and their order are untouched (apart from adding a zero 3rd dimension)
+ * One use-case is special: For geometry construction in Manifold mode, we
+ require this function to
+ * guarantee that vertices and their order are untouched (apart from adding a
+ zero 3rd dimension)
  *
  */
-std::unique_ptr<PolySet> Polygon2d::tessellate() const
-{
+std::unique_ptr<PolySet> Polygon2d::tessellate() const {
   PRINTDB("Polygon2d::tessellate(): %d outlines", this->outlines().size());
 #if defined(ENABLE_MANIFOLD) && defined(USE_MANIFOLD_TRIANGULATOR)
   if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
     return ManifoldUtils::createTriangulatedPolySetFromPolygon2d(*this);
   } else
 #endif
-  return CGALUtils::createTriangulatedPolySetFromPolygon2d(*this);
+    return CGALUtils::createTriangulatedPolySetFromPolygon2d(*this);
 }
diff --git a/src/geometry/Polygon2d.h b/src/geometry/Polygon2d.h
index 948dda826..115c8313e 100644
--- a/src/geometry/Polygon2d.h
+++ b/src/geometry/Polygon2d.h
@@ -1,17 +1,18 @@
 #pragma once
 
-#include <utility>
-#include <memory>
-#include <cstddef>
-#include <string>
-#include <vector>
 #include "geometry/Geometry.h"
 #include "geometry/linalg.h"
+#include <cstddef>
+#include <memory>
 #include <numeric>
+#include <string>
+#include <utility>
+#include <vector>
 
 /*!
    A single contour.
-   positive is (optionally) used to distinguish between polygon contours and hole contours.
+   positive is (optionally) used to distinguish between polygon contours and
+   hole contours.
  */
 struct Outline2d {
   Outline2d() = default;
@@ -20,8 +21,7 @@ struct Outline2d {
   [[nodiscard]] BoundingBox getBoundingBox() const;
 };
 
-class Polygon2d : public Geometry
-{
+class Polygon2d : public Geometry {
 public:
   VISITABLE_GEOMETRY();
   Polygon2d() = default;
@@ -33,33 +33,37 @@ public:
   [[nodiscard]] bool isEmpty() const override;
   [[nodiscard]] std::unique_ptr<Geometry> copy() const override;
   [[nodiscard]] size_t numFacets() const override {
-    return std::accumulate(theoutlines.begin(), theoutlines.end(), 0,
-                           [](size_t a, const Outline2d& b) {
-      return a + b.vertices.size();
-    }
-                           );
+    return std::accumulate(
+        theoutlines.begin(), theoutlines.end(), 0,
+        [](size_t a, const Outline2d &b) { return a + b.vertices.size(); });
+  }
+  void addOutline(Outline2d outline) {
+    this->theoutlines.push_back(std::move(outline));
   }
-  void addOutline(Outline2d outline) { this->theoutlines.push_back(std::move(outline)); }
   [[nodiscard]] std::unique_ptr<PolySet> tessellate() const;
   [[nodiscard]] double area() const;
 
   using Outlines2d = std::vector<Outline2d>;
-  [[nodiscard]] const Outlines2d& outlines() const { return theoutlines; }
+  [[nodiscard]] const Outlines2d &outlines() const { return theoutlines; }
   // Note: The "using" here is a kludge to avoid a compiler warning.
   // It would be better to fix the class relationships, so that Polygon2d does
   // not inherit an unused 3d transform function.
   // But that will likely require significant refactoring.
   using Geometry::transform;
 
-  void transform(const Transform2d& mat);
-  void resize(const Vector2d& newsize, const Eigen::Matrix<bool, 2, 1>& autosize);
-  void resize(const Vector3d& newsize, const Eigen::Matrix<bool, 3, 1>& autosize) override {
-    resize(Vector2d(newsize[0], newsize[1]), Eigen::Matrix<bool, 2, 1>(autosize[0], autosize[1]));
+  void transform(const Transform2d &mat);
+  void resize(const Vector2d &newsize,
+              const Eigen::Matrix<bool, 2, 1> &autosize);
+  void resize(const Vector3d &newsize,
+              const Eigen::Matrix<bool, 3, 1> &autosize) override {
+    resize(Vector2d(newsize[0], newsize[1]),
+           Eigen::Matrix<bool, 2, 1>(autosize[0], autosize[1]));
   }
 
   [[nodiscard]] bool isSanitized() const { return this->sanitized; }
   void setSanitized(bool s) { this->sanitized = s; }
   [[nodiscard]] bool is_convex() const;
+
 private:
   Outlines2d theoutlines;
   bool sanitized{false};
diff --git a/src/geometry/Reindexer.h b/src/geometry/Reindexer.h
index c43a58920..05807f653 100644
--- a/src/geometry/Reindexer.h
+++ b/src/geometry/Reindexer.h
@@ -1,28 +1,27 @@
 #pragma once
 
+#include "utils/hash.h" // IWYU pragma: keep
+#include <algorithm>
 #include <cstddef>
 #include <unordered_map>
 #include <vector>
-#include <algorithm>
-#include "utils/hash.h" // IWYU pragma: keep
 
 /*!
    Reindexes a collection of elements of type T.
-   Typically used to compress an element array by creating and reusing indexes to
-   a new array or to merge two index tables to two arrays into a common index.
-   The latter is necessary for VBO's or for unifying texture coordinate indices to
-   multiple texture coordinate arrays.
+   Typically used to compress an element array by creating and reusing indexes
+   to a new array or to merge two index tables to two arrays into a common
+   index. The latter is necessary for VBO's or for unifying texture coordinate
+   indices to multiple texture coordinate arrays.
  */
-template <typename T>
-class Reindexer
-{
+template <typename T> class Reindexer {
 public:
   /*!
      Looks up a value. Will insert the value if it doesn't already exist.
      Returns the new index. */
-  int lookup(const T& val) {
+  int lookup(const T &val) {
     auto iter = this->map.find(val);
-    if (iter != this->map.end()) return iter->second;
+    if (iter != this->map.end())
+      return iter->second;
     else {
       this->map.insert(std::make_pair(val, this->map.size()));
       return this->map.size() - 1;
@@ -32,23 +31,19 @@ public:
   /*!
      Returns the current size of the new element array
    */
-  [[nodiscard]] std::size_t size() const {
-    return this->map.size();
-  }
+  [[nodiscard]] std::size_t size() const { return this->map.size(); }
 
   /*!
      Reserve the requested size for the new element map
    */
-  void reserve(std::size_t n) {
-    return this->map.reserve(n);
-  }
+  void reserve(std::size_t n) { return this->map.reserve(n); }
 
   /*!
      Return a copy of the new element array
    */
-  const std::vector<T>& getArray() {
+  const std::vector<T> &getArray() {
     this->vec.resize(this->map.size());
-    for (const auto& entry : map) {
+    for (const auto &entry : map) {
       this->vec[entry.second] = entry.first;
     }
     return this->vec;
diff --git a/src/geometry/boolean_utils.cc b/src/geometry/boolean_utils.cc
index 0b34760f9..5eda17adb 100644
--- a/src/geometry/boolean_utils.cc
+++ b/src/geometry/boolean_utils.cc
@@ -1,114 +1,116 @@
 #include "geometry/boolean_utils.h"
 
-#include <utility>
 #include <memory>
+#include <utility>
 #include <vector>
 
 #ifdef ENABLE_CGAL
 #include "geometry/cgal/CGALNefGeometry.h"
+#include "geometry/cgal/cgalutils.h"
 #include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
 #include <CGAL/convex_hull_3.h>
-#include "geometry/cgal/cgalutils.h"
-#endif  // ENABLE_CGAL
+#endif // ENABLE_CGAL
 #ifdef ENABLE_MANIFOLD
 #include "geometry/manifold/ManifoldGeometry.h"
 #include "geometry/manifold/manifoldutils.h"
-#endif  // ENABLE_MANIFOLD
+#endif // ENABLE_MANIFOLD
 
-#include "glview/RenderSettings.h"
 #include "geometry/PolySet.h"
+#include "glview/RenderSettings.h"
 #include "utils/printutils.h"
 
-#include "geometry/Reindexer.h"
 #include "geometry/GeometryUtils.h"
+#include "geometry/Reindexer.h"
 
 #ifdef ENABLE_CGAL
-std::unique_ptr<PolySet> applyHull(const Geometry::Geometries& children)
-{
+std::unique_ptr<PolySet> applyHull(const Geometry::Geometries &children) {
   using Hull_kernel = CGAL::Epick;
   // Collect point cloud
   Reindexer<Hull_kernel::Point_3> reindexer;
 
   auto addCapacity = [&](const auto n) {
-      reindexer.reserve(reindexer.size() + n);
-    };
+    reindexer.reserve(reindexer.size() + n);
+  };
 
-  auto addPoint = [&](const auto& v) {
-      reindexer.lookup(v);
-    };
+  auto addPoint = [&](const auto &v) { reindexer.lookup(v); };
 
-  for (const auto& item : children) {
-    auto& chgeom = item.second;
+  for (const auto &item : children) {
+    auto &chgeom = item.second;
 #ifdef ENABLE_CGAL
     if (const auto *N = dynamic_cast<const CGALNefGeometry *>(chgeom.get())) {
       if (!N->isEmpty()) {
         addCapacity(N->p3->number_of_vertices());
-        for (auto it = N->p3->vertices_begin(); it != N->p3->vertices_end(); ++it) {
-          addPoint(CGALUtils::vector_convert<Hull_kernel::Point_3>(it->point()));
+        for (auto it = N->p3->vertices_begin(); it != N->p3->vertices_end();
+             ++it) {
+          addPoint(
+              CGALUtils::vector_convert<Hull_kernel::Point_3>(it->point()));
         }
       }
-#endif  // ENABLE_CGAL
+#endif // ENABLE_CGAL
 #ifdef ENABLE_MANIFOLD
-  } else if (const auto *mani = dynamic_cast<const ManifoldGeometry *>(chgeom.get())) {
-    addCapacity(mani->numVertices());
-    mani->foreachVertexUntilTrue([&](auto& p) {
-      addPoint(CGALUtils::vector_convert<Hull_kernel::Point_3>(p));
-      return false;
-    });
-#endif  // ENABLE_MANIFOLD
-  } else if (const auto *ps = dynamic_cast<const PolySet *>(chgeom.get())) {
-    addCapacity(ps->indices.size() * 3);
-    for (const auto& p : ps->indices) {
-      for (const auto& ind : p) {
-        addPoint(CGALUtils::vector_convert<Hull_kernel::Point_3>(ps->vertices[ind]));
+    } else if (const auto *mani =
+                   dynamic_cast<const ManifoldGeometry *>(chgeom.get())) {
+      addCapacity(mani->numVertices());
+      mani->foreachVertexUntilTrue([&](auto &p) {
+        addPoint(CGALUtils::vector_convert<Hull_kernel::Point_3>(p));
+        return false;
+      });
+#endif // ENABLE_MANIFOLD
+    } else if (const auto *ps = dynamic_cast<const PolySet *>(chgeom.get())) {
+      addCapacity(ps->indices.size() * 3);
+      for (const auto &p : ps->indices) {
+        for (const auto &ind : p) {
+          addPoint(CGALUtils::vector_convert<Hull_kernel::Point_3>(
+              ps->vertices[ind]));
+        }
       }
     }
   }
-}
 
-const auto& points = reindexer.getArray();
-if (points.size() <= 3) return nullptr;
+  const auto &points = reindexer.getArray();
+  if (points.size() <= 3)
+    return nullptr;
 
-// Apply hull
-if (points.size() >= 4) {
-  try {
-    CGAL::Polyhedron_3<Hull_kernel> r;
-    CGAL::convex_hull_3(points.begin(), points.end(), r);
-    PRINTDB("After hull vertices: %d", r.size_of_vertices());
-    PRINTDB("After hull facets: %d", r.size_of_facets());
-    PRINTDB("After hull closed: %d", r.is_closed());
-    PRINTDB("After hull valid: %d", r.is_valid());
-    // FIXME: Make sure PolySet is set to convex.
-    // FIXME: Can we guarantee a manifold PolySet here?
-    return CGALUtils::createPolySetFromPolyhedron(r);
-  } catch (const CGAL::Failure_exception& e) {
-    LOG(message_group::Error, "CGAL error in applyHull(): %1$s", e.what());
+  // Apply hull
+  if (points.size() >= 4) {
+    try {
+      CGAL::Polyhedron_3<Hull_kernel> r;
+      CGAL::convex_hull_3(points.begin(), points.end(), r);
+      PRINTDB("After hull vertices: %d", r.size_of_vertices());
+      PRINTDB("After hull facets: %d", r.size_of_facets());
+      PRINTDB("After hull closed: %d", r.is_closed());
+      PRINTDB("After hull valid: %d", r.is_valid());
+      // FIXME: Make sure PolySet is set to convex.
+      // FIXME: Can we guarantee a manifold PolySet here?
+      return CGALUtils::createPolySetFromPolyhedron(r);
+    } catch (const CGAL::Failure_exception &e) {
+      LOG(message_group::Error, "CGAL error in applyHull(): %1$s", e.what());
+    }
   }
-}
-return nullptr;
+  return nullptr;
 
-/*!
-   children cannot contain nullptr objects
+  /*!
+     children cannot contain nullptr objects
 
-   FIXME: This shouldn't return const, but it does due to internal implementation details
- */
-std::shared_ptr<const Geometry> applyMinkowski(const Geometry::Geometries& children)
-{
+     FIXME: This shouldn't return const, but it does due to internal
+     implementation details
+   */
+  std::shared_ptr<const Geometry> applyMinkowski(
+      const Geometry::Geometries &children) {
 #if ENABLE_MANIFOLD
-  if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
-    return ManifoldUtils::applyMinkowski(children);
+    if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
+      return ManifoldUtils::applyMinkowski(children);
+    }
+#endif // ENABLE_MANIFOLD
+    return CGALUtils::applyMinkowski3D(children);
   }
-#endif  // ENABLE_MANIFOLD
-  return CGALUtils::applyMinkowski3D(children);
-}
 #else  // ENABLE_CGAL
-std::unique_ptr<PolySet> applyHull(const Geometry::Geometries& children)
-{
+std::unique_ptr<PolySet> applyHull(const Geometry::Geometries &children) {
   return std::make_unique<PolySet>(3, true);
 }
 
-std::shared_ptr<const Geometry> applyMinkowski(const Geometry::Geometries& children)
-{
+std::shared_ptr<const Geometry>
+applyMinkowski(const Geometry::Geometries &children) {
   return std::make_shared<PolySet>(3);
 }
-#endif  // !ENABLE_CGAL
+#endif // !ENABLE_CGAL
diff --git a/src/geometry/boolean_utils.h b/src/geometry/boolean_utils.h
index 082a23e87..3d4c162f6 100644
--- a/src/geometry/boolean_utils.h
+++ b/src/geometry/boolean_utils.h
@@ -1,8 +1,9 @@
 #pragma once
 
-#include <memory>
-#include "geometry/PolySet.h"
 #include "geometry/Geometry.h"
+#include "geometry/PolySet.h"
+#include <memory>
 
-std::unique_ptr<PolySet> applyHull(const Geometry::Geometries& children);
-std::shared_ptr<const Geometry> applyMinkowski(const Geometry::Geometries& children);
+std::unique_ptr<PolySet> applyHull(const Geometry::Geometries &children);
+std::shared_ptr<const Geometry>
+applyMinkowski(const Geometry::Geometries &children);
diff --git a/src/geometry/cgal/CGALCache.cc b/src/geometry/cgal/CGALCache.cc
index a5e895a18..b1eca50d1 100644
--- a/src/geometry/cgal/CGALCache.cc
+++ b/src/geometry/cgal/CGALCache.cc
@@ -1,8 +1,8 @@
 #include "geometry/cgal/CGALCache.h"
 
 #include <cassert>
-#include <memory>
 #include <cstddef>
+#include <memory>
 #include <string>
 
 #include "geometry/Geometry.h"
@@ -16,20 +16,18 @@
 
 CGALCache *CGALCache::inst = nullptr;
 
-CGALCache::CGALCache(size_t limit) : cache(limit)
-{
-}
+CGALCache::CGALCache(size_t limit) : cache(limit) {}
 
-std::shared_ptr<const Geometry> CGALCache::get(const std::string& id) const
-{
-  const auto& N = this->cache[id]->N;
+std::shared_ptr<const Geometry> CGALCache::get(const std::string &id) const {
+  const auto &N = this->cache[id]->N;
 #ifdef DEBUG
-  LOG("CGAL Cache hit: %1$s (%2$d bytes)", id.substr(0, 40), N ? N->memsize() : 0);
+  LOG("CGAL Cache hit: %1$s (%2$d bytes)", id.substr(0, 40),
+      N ? N->memsize() : 0);
 #endif
   return N;
 }
 
-bool CGALCache::acceptsGeometry(const std::shared_ptr<const Geometry>& geom) {
+bool CGALCache::acceptsGeometry(const std::shared_ptr<const Geometry> &geom) {
   return 0
 #ifdef ENABLE_CGAL
          || std::dynamic_pointer_cast<const CGALNefGeometry>(geom) != nullptr
@@ -37,53 +35,46 @@ bool CGALCache::acceptsGeometry(const std::shared_ptr<const Geometry>& geom) {
 #ifdef ENABLE_MANIFOLD
          || std::dynamic_pointer_cast<const ManifoldGeometry>(geom) != nullptr
 #endif
-  ;
+      ;
 }
 
-bool CGALCache::insert(const std::string& id, const std::shared_ptr<const Geometry>& N)
-{
+bool CGALCache::insert(const std::string &id,
+                       const std::shared_ptr<const Geometry> &N) {
   assert(acceptsGeometry(N));
-  auto inserted = this->cache.insert(id, new cache_entry(N), N ? N->memsize() : 0);
+  auto inserted =
+      this->cache.insert(id, new cache_entry(N), N ? N->memsize() : 0);
 #ifdef DEBUG
-  if (inserted) LOG("CGAL Cache insert: %1$s (%2$d bytes)", id.substr(0, 40), (N ? N->memsize() : 0));
-  else LOG("CGAL Cache insert failed: %1$s (%2$d bytes)", id.substr(0, 40), (N ? N->memsize() : 0));
+  if (inserted)
+    LOG("CGAL Cache insert: %1$s (%2$d bytes)", id.substr(0, 40),
+        (N ? N->memsize() : 0));
+  else
+    LOG("CGAL Cache insert failed: %1$s (%2$d bytes)", id.substr(0, 40),
+        (N ? N->memsize() : 0));
 #endif
   return inserted;
 }
 
-size_t CGALCache::size() const
-{
-  return cache.size();
-}
+size_t CGALCache::size() const { return cache.size(); }
 
-size_t CGALCache::totalCost() const
-{
-  return cache.totalCost();
-}
+size_t CGALCache::totalCost() const { return cache.totalCost(); }
 
-size_t CGALCache::maxSizeMB() const
-{
+size_t CGALCache::maxSizeMB() const {
   return this->cache.maxCost() / (1024ul * 1024ul);
 }
 
-void CGALCache::setMaxSizeMB(size_t limit)
-{
+void CGALCache::setMaxSizeMB(size_t limit) {
   this->cache.setMaxCost(limit * 1024ul * 1024ul);
 }
 
-void CGALCache::clear()
-{
-  cache.clear();
-}
+void CGALCache::clear() { cache.clear(); }
 
-void CGALCache::print()
-{
+void CGALCache::print() {
   LOG("CGAL Polyhedrons in cache: %1$d", this->cache.size());
   LOG("CGAL cache size in bytes: %1$d", this->cache.totalCost());
 }
 
-CGALCache::cache_entry::cache_entry(const std::shared_ptr<const Geometry>& N)
-  : N(N)
-{
-  if (print_messages_stack.size() > 0) this->msg = print_messages_stack.back();
+CGALCache::cache_entry::cache_entry(const std::shared_ptr<const Geometry> &N)
+    : N(N) {
+  if (print_messages_stack.size() > 0)
+    this->msg = print_messages_stack.back();
 }
diff --git a/src/geometry/cgal/CGALCache.h b/src/geometry/cgal/CGALCache.h
index 4653b6663..c3d0910ea 100644
--- a/src/geometry/cgal/CGALCache.h
+++ b/src/geometry/cgal/CGALCache.h
@@ -1,22 +1,27 @@
 #pragma once
 
 #include "Cache.h"
+#include "geometry/Geometry.h"
 #include <cstddef>
 #include <memory>
 #include <string>
-#include "geometry/Geometry.h"
 
-class CGALCache
-{
+class CGALCache {
 public:
-  CGALCache(size_t limit = 100ul *1024ul *1024ul);
+  CGALCache(size_t limit = 100ul * 1024ul * 1024ul);
 
-  static CGALCache *instance() { if (!inst) inst = new CGALCache; return inst; }
-  static bool acceptsGeometry(const std::shared_ptr<const Geometry>& geom);
+  static CGALCache *instance() {
+    if (!inst)
+      inst = new CGALCache;
+    return inst;
+  }
+  static bool acceptsGeometry(const std::shared_ptr<const Geometry> &geom);
 
-  bool contains(const std::string& id) const { return this->cache.contains(id); }
-  std::shared_ptr<const Geometry> get(const std::string& id) const;
-  bool insert(const std::string& id, const std::shared_ptr<const Geometry>& N);
+  bool contains(const std::string &id) const {
+    return this->cache.contains(id);
+  }
+  std::shared_ptr<const Geometry> get(const std::string &id) const;
+  bool insert(const std::string &id, const std::shared_ptr<const Geometry> &N);
   size_t size() const;
   size_t totalCost() const;
   size_t maxSizeMB() const;
@@ -30,7 +35,7 @@ private:
   struct cache_entry {
     std::shared_ptr<const Geometry> N;
     std::string msg;
-    cache_entry(const std::shared_ptr<const Geometry>& N);
+    cache_entry(const std::shared_ptr<const Geometry> &N);
   };
 
   Cache<std::string, cache_entry> cache;
diff --git a/src/geometry/cgal/CGALNefGeometry.cc b/src/geometry/cgal/CGALNefGeometry.cc
index bc0b17c8f..80759fc67 100644
--- a/src/geometry/cgal/CGALNefGeometry.cc
+++ b/src/geometry/cgal/CGALNefGeometry.cc
@@ -1,81 +1,77 @@
 #include "geometry/cgal/CGALNefGeometry.h"
 
-#include <memory>
 #include <cstddef>
+#include <memory>
 #include <string>
 
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
 #include "geometry/cgal/cgal.h"
 #include "geometry/cgal/cgalutils.h"
+#include "geometry/linalg.h"
 #include "utils/printutils.h"
 #include "utils/svg.h"
 
 // Copy constructor only performs shallow copies, so all modifying functions
-// must reset p3 with a new CGAL_Nef_polyhedron3 object, to prevent cache corruption.
-// This is also partly enforced by p3 pointing to a const object.
-CGALNefGeometry::CGALNefGeometry(const CGALNefGeometry& src) : Geometry(src)
-{
-  if (src.p3) this->p3 = src.p3;
+// must reset p3 with a new CGAL_Nef_polyhedron3 object, to prevent cache
+// corruption. This is also partly enforced by p3 pointing to a const object.
+CGALNefGeometry::CGALNefGeometry(const CGALNefGeometry &src) : Geometry(src) {
+  if (src.p3)
+    this->p3 = src.p3;
 }
 
-std::unique_ptr<Geometry> CGALNefGeometry::copy() const
-{
+std::unique_ptr<Geometry> CGALNefGeometry::copy() const {
   return std::make_unique<CGALNefGeometry>(*this);
 }
 
-CGALNefGeometry CGALNefGeometry::operator+(const CGALNefGeometry& other) const
-{
+CGALNefGeometry CGALNefGeometry::operator+(const CGALNefGeometry &other) const {
   return {std::make_shared<CGAL_Nef_polyhedron3>((*this->p3) + (*other.p3))};
 }
 
-CGALNefGeometry& CGALNefGeometry::operator+=(const CGALNefGeometry& other)
-{
+CGALNefGeometry &CGALNefGeometry::operator+=(const CGALNefGeometry &other) {
   this->p3 = std::make_shared<CGAL_Nef_polyhedron3>((*this->p3) + (*other.p3));
   return *this;
 }
 
-CGALNefGeometry& CGALNefGeometry::operator*=(const CGALNefGeometry& other)
-{
+CGALNefGeometry &CGALNefGeometry::operator*=(const CGALNefGeometry &other) {
   this->p3 = std::make_shared<CGAL_Nef_polyhedron3>((*this->p3) * (*other.p3));
   return *this;
 }
 
-CGALNefGeometry& CGALNefGeometry::operator-=(const CGALNefGeometry& other)
-{
+CGALNefGeometry &CGALNefGeometry::operator-=(const CGALNefGeometry &other) {
   this->p3 = std::make_shared<CGAL_Nef_polyhedron3>((*this->p3) - (*other.p3));
   return *this;
 }
 
-// Note: this is only the fallback method in case of failure in CGALUtils::applyMinkowski (see: cgalutils-applyops.cc)
-CGALNefGeometry& CGALNefGeometry::minkowski(const CGALNefGeometry& other)
-{
+// Note: this is only the fallback method in case of failure in
+// CGALUtils::applyMinkowski (see: cgalutils-applyops.cc)
+CGALNefGeometry &CGALNefGeometry::minkowski(const CGALNefGeometry &other) {
   // It is required to construct copies of our const input operands here.
-  // "Postcondition: If either of the input polyhedra is non-convex, it is modified during the computation,
+  // "Postcondition: If either of the input polyhedra is non-convex, it is
+  // modified during the computation,
   //  i.e., it is decomposed into convex pieces."
-  // from https://doc.cgal.org/latest/Minkowski_sum_3/group__PkgMinkowskiSum3Ref.html
+  // from
+  // https://doc.cgal.org/latest/Minkowski_sum_3/group__PkgMinkowskiSum3Ref.html
   CGAL_Nef_polyhedron3 op1(*this->p3);
   CGAL_Nef_polyhedron3 op2(*other.p3);
-  this->p3 = std::make_shared<CGAL_Nef_polyhedron3>(CGAL::minkowski_sum_3(op1, op2));
+  this->p3 =
+      std::make_shared<CGAL_Nef_polyhedron3>(CGAL::minkowski_sum_3(op1, op2));
   return *this;
 }
 
-size_t CGALNefGeometry::memsize() const
-{
-  if (this->isEmpty()) return 0;
+size_t CGALNefGeometry::memsize() const {
+  if (this->isEmpty())
+    return 0;
 
   auto memsize = sizeof(CGALNefGeometry);
-  memsize += const_cast<CGAL_Nef_polyhedron3&>(*this->p3).bytes();
+  memsize += const_cast<CGAL_Nef_polyhedron3 &>(*this->p3).bytes();
   return memsize;
 }
 
-bool CGALNefGeometry::isEmpty() const
-{
+bool CGALNefGeometry::isEmpty() const {
   return !this->p3 || this->p3->is_empty();
 }
 
-BoundingBox CGALNefGeometry::getBoundingBox() const
-{
+BoundingBox CGALNefGeometry::getBoundingBox() const {
   if (isEmpty()) {
     return {};
   }
@@ -87,28 +83,25 @@ BoundingBox CGALNefGeometry::getBoundingBox() const
   return result;
 }
 
-void CGALNefGeometry::resize(const Vector3d& newsize,
-                             const Eigen::Matrix<bool, 3, 1>& autosize)
-{
+void CGALNefGeometry::resize(const Vector3d &newsize,
+                             const Eigen::Matrix<bool, 3, 1> &autosize) {
   // Based on resize() in Giles Bathgate's RapCAD (but not exactly)
-  if (this->isEmpty()) return;
+  if (this->isEmpty())
+    return;
 
-  transform(
-    CGALUtils::computeResizeTransform(
-      CGALUtils::boundingBox(*this->p3),
-      getDimension(), newsize, autosize));
+  transform(CGALUtils::computeResizeTransform(
+      CGALUtils::boundingBox(*this->p3), getDimension(), newsize, autosize));
 }
 
-std::string CGALNefGeometry::dump() const
-{
+std::string CGALNefGeometry::dump() const {
   return OpenSCAD::dump_svg(*this->p3);
 }
 
-void CGALNefGeometry::transform(const Transform3d& matrix)
-{
+void CGALNefGeometry::transform(const Transform3d &matrix) {
   if (!this->isEmpty()) {
     if (matrix.matrix().determinant() == 0) {
-      LOG(message_group::Warning, "Scaling a 3D object with 0 - removing object");
+      LOG(message_group::Warning,
+          "Scaling a 3D object with 0 - removing object");
       this->reset();
     } else {
       auto N = std::make_shared<CGAL_Nef_polyhedron3>(*this->p3);
diff --git a/src/geometry/cgal/CGALNefGeometry.h b/src/geometry/cgal/CGALNefGeometry.h
index cdef9c4b8..47bd9c146 100644
--- a/src/geometry/cgal/CGALNefGeometry.h
+++ b/src/geometry/cgal/CGALNefGeometry.h
@@ -1,23 +1,23 @@
 #pragma once
 
-#include "geometry/cgal/cgal.h"
 #include "geometry/Geometry.h"
+#include "geometry/cgal/cgal.h"
+#include "geometry/linalg.h"
 #include <cstddef>
 #include <memory>
 #include <string>
 #include <utility>
-#include "geometry/linalg.h"
 
-class CGALNefGeometry : public Geometry
-{
+class CGALNefGeometry : public Geometry {
 public:
   VISITABLE_GEOMETRY();
   CGALNefGeometry() = default;
-  CGALNefGeometry(std::shared_ptr<const CGAL_Nef_polyhedron3> p) : p3(std::move(p)) {}
-  CGALNefGeometry(const CGALNefGeometry& src);
-  CGALNefGeometry& operator=(const CGALNefGeometry&) = default;
-  CGALNefGeometry(CGALNefGeometry&&) = default;
-  CGALNefGeometry& operator=(CGALNefGeometry&&) = default;
+  CGALNefGeometry(std::shared_ptr<const CGAL_Nef_polyhedron3> p)
+      : p3(std::move(p)) {}
+  CGALNefGeometry(const CGALNefGeometry &src);
+  CGALNefGeometry &operator=(const CGALNefGeometry &) = default;
+  CGALNefGeometry(CGALNefGeometry &&) = default;
+  CGALNefGeometry &operator=(CGALNefGeometry &&) = default;
   ~CGALNefGeometry() override = default;
 
   [[nodiscard]] size_t memsize() const override;
@@ -28,16 +28,19 @@ public:
   // Empty means it is a geometric node which has zero area/volume
   [[nodiscard]] bool isEmpty() const override;
   [[nodiscard]] std::unique_ptr<Geometry> copy() const override;
-  [[nodiscard]] size_t numFacets() const override { return p3->number_of_facets(); }
+  [[nodiscard]] size_t numFacets() const override {
+    return p3->number_of_facets();
+  }
 
   void reset() { p3.reset(); }
-  CGALNefGeometry operator+(const CGALNefGeometry& other) const;
-  CGALNefGeometry& operator+=(const CGALNefGeometry& other);
-  CGALNefGeometry& operator*=(const CGALNefGeometry& other);
-  CGALNefGeometry& operator-=(const CGALNefGeometry& other);
-  CGALNefGeometry& minkowski(const CGALNefGeometry& other);
-  void transform(const Transform3d& matrix) override;
-  void resize(const Vector3d& newsize, const Eigen::Matrix<bool, 3, 1>& autosize) override;
+  CGALNefGeometry operator+(const CGALNefGeometry &other) const;
+  CGALNefGeometry &operator+=(const CGALNefGeometry &other);
+  CGALNefGeometry &operator*=(const CGALNefGeometry &other);
+  CGALNefGeometry &operator-=(const CGALNefGeometry &other);
+  CGALNefGeometry &minkowski(const CGALNefGeometry &other);
+  void transform(const Transform3d &matrix) override;
+  void resize(const Vector3d &newsize,
+              const Eigen::Matrix<bool, 3, 1> &autosize) override;
 
   std::shared_ptr<const CGAL_Nef_polyhedron3> p3;
 };
diff --git a/src/geometry/cgal/cgal.h b/src/geometry/cgal/cgal.h
index 6fb0425b1..4078d6ea1 100644
--- a/src/geometry/cgal/cgal.h
+++ b/src/geometry/cgal/cgal.h
@@ -2,14 +2,16 @@
 
 #ifdef ENABLE_CGAL
 
-// STL Allocator doesn't make any significant difference on my Linux dev machine - Hans
+// STL Allocator doesn't make any significant difference on my Linux dev machine
+// - Hans
 /*
  #ifdef USE_MIMALLOC
  #ifndef MI_OVERRIDE
  #include <mimalloc.h>
-    // If using CGAL_ALLOCATOR to override, then make sure to define it as the first thing
-    // ****** NOTE: THAT MEANS THIS FILE "cgal.h" SHOULD ALWAYS COME BEFORE OTHER CGAL INCLUDES! ******
- #define CGAL_ALLOCATOR(t) mi_stl_allocator<t>
+    // If using CGAL_ALLOCATOR to override, then make sure to define it as the
+ first thing
+    // ****** NOTE: THAT MEANS THIS FILE "cgal.h" SHOULD ALWAYS COME BEFORE
+ OTHER CGAL INCLUDES! ****** #define CGAL_ALLOCATOR(t) mi_stl_allocator<t>
  #endif
  #endif
    //*/
@@ -17,21 +19,21 @@
 #include <vector>
 
 #include "CGAL/CGAL_workaround_Mark_bounded_volumes.h" // This file must be included prior to CGAL/Nef_polyhedron_3.h
-#include <CGAL/Gmpq.h>
+#include <CGAL/Cartesian.h>
+#include <CGAL/Exact_predicates_exact_constructions_kernel.h>
 #include <CGAL/Extended_cartesian.h>
+#include <CGAL/Gmpq.h>
+#include <CGAL/IO/Nef_polyhedron_iostream_3.h> // for dumping .nef3
+#include <CGAL/IO/Polyhedron_iostream.h>
 #include <CGAL/Nef_polyhedron_2.h>
-#include <CGAL/Cartesian.h>
-#include <CGAL/Polyhedron_3.h>
 #include <CGAL/Nef_polyhedron_3.h>
-#include <CGAL/Surface_mesh.h>
-#include <CGAL/IO/Polyhedron_iostream.h>
-#include <CGAL/IO/Nef_polyhedron_iostream_3.h> // for dumping .nef3
-#include <CGAL/Exact_predicates_exact_constructions_kernel.h>
 #include <CGAL/Polygon_2.h>
 #include <CGAL/Polygon_with_holes_2.h>
+#include <CGAL/Polyhedron_3.h>
+#include <CGAL/Surface_mesh.h>
+#include <CGAL/bounding_box.h>
 #include <CGAL/minkowski_sum_2.h>
 #include <CGAL/minkowski_sum_3.h>
-#include <CGAL/bounding_box.h>
 #include <CGAL/utils.h>
 #include <CGAL/version.h>
 
@@ -45,7 +47,8 @@ using CGAL_Kernel2 = CGAL::Extended_cartesian<NT2>;
 using CGAL_Nef_polyhedron2 = CGAL::Nef_polyhedron_2<CGAL_Kernel2>;
 
 using CGAL_Point_2e = CGAL_Nef_polyhedron2::Explorer::Point;
-using CGAL_Iso_rectangle_2e = CGAL::Iso_rectangle_2<CGAL::Simple_cartesian<NT2>>;
+using CGAL_Iso_rectangle_2e =
+    CGAL::Iso_rectangle_2<CGAL::Simple_cartesian<NT2>>;
 
 // 3D
 
diff --git a/src/geometry/cgal/cgalutils-applyops-minkowski.cc b/src/geometry/cgal/cgalutils-applyops-minkowski.cc
index 6d73a14d2..1da1fa2c9 100644
--- a/src/geometry/cgal/cgalutils-applyops-minkowski.cc
+++ b/src/geometry/cgal/cgalutils-applyops-minkowski.cc
@@ -9,8 +9,8 @@
 
 namespace CGALUtils {
 
-std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& children)
-{
+std::shared_ptr<const Geometry>
+applyMinkowski3D(const Geometry::Geometries &children) {
   assert(children.size() >= 2);
 
   CGAL::Timer t;
@@ -18,7 +18,8 @@ std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& chi
   t_tot.start();
 
   auto it = children.begin();
-  std::shared_ptr<const Geometry> operands[2] = {it->second, std::shared_ptr<const Geometry>()};
+  std::shared_ptr<const Geometry> operands[2] = {
+      it->second, std::shared_ptr<const Geometry>()};
   try {
     while (++it != children.end()) {
       operands[1] = it->second;
@@ -32,27 +33,35 @@ std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& chi
         CGAL_Polyhedron poly;
 
         auto ps = std::dynamic_pointer_cast<const PolySet>(operands[i]);
-        auto nef = std::dynamic_pointer_cast<const CGALNefGeometry>(operands[i]);
+        auto nef =
+            std::dynamic_pointer_cast<const CGALNefGeometry>(operands[i]);
 
         if (!nef) {
           nef = CGALUtils::getNefPolyhedronFromGeometry(operands[i]);
         }
 
-        if (ps) CGALUtils::createPolyhedronFromPolySet(*ps, poly);
-        else if (nef && nef->p3->is_simple()) CGALUtils::convertNefToPolyhedron(*nef->p3, poly);
-        else throw 0;
+        if (ps)
+          CGALUtils::createPolyhedronFromPolySet(*ps, poly);
+        else if (nef && nef->p3->is_simple())
+          CGALUtils::convertNefToPolyhedron(*nef->p3, poly);
+        else
+          throw 0;
 
         if ((ps && ps->isConvex()) ||
             (!ps && CGALUtils::is_weakly_convex(poly))) {
-          PRINTDB("Minkowski: child %d is convex and %s", i % (ps?"PolySet":"Nef"));
+          PRINTDB("Minkowski: child %d is convex and %s",
+                  i % (ps ? "PolySet" : "Nef"));
           P[i].push_back(poly);
         } else {
           CGAL_Nef_polyhedron3 decomposed_nef;
 
           if (ps) {
-            PRINTDB("Minkowski: child %d is nonconvex PolySet, transforming to Nef and decomposing...", i);
+            PRINTDB("Minkowski: child %d is nonconvex PolySet, transforming to "
+                    "Nef and decomposing...",
+                    i);
             auto p = CGALUtils::getNefPolyhedronFromGeometry(ps);
-            if (p && !p->isEmpty()) decomposed_nef = *p->p3;
+            if (p && !p->isEmpty())
+              decomposed_nef = *p->p3;
           } else {
             PRINTDB("Minkowski: child %d is nonconvex Nef, decomposing...", i);
             decomposed_nef = *nef->p3;
@@ -61,16 +70,18 @@ std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& chi
           t.start();
           CGAL::convex_decomposition_3(decomposed_nef);
 
-          // the first volume is the outer volume, which ignored in the decomposition
-          for (auto ci = ++decomposed_nef.volumes_begin(); ci != decomposed_nef.volumes_end(); ++ci) {
+          // the first volume is the outer volume, which ignored in the
+          // decomposition
+          for (auto ci = ++decomposed_nef.volumes_begin();
+               ci != decomposed_nef.volumes_end(); ++ci) {
             if (ci->mark()) {
               CGAL_Polyhedron poly;
-              decomposed_nef.convert_inner_shell_to_polyhedron(ci->shells_begin(), poly);
+              decomposed_nef.convert_inner_shell_to_polyhedron(
+                  ci->shells_begin(), poly);
               P[i].push_back(poly);
             }
           }
 
-
           PRINTDB("Minkowski: decomposed into %d convex parts", P[i].size());
           t.stop();
           PRINTDB("Minkowski: decomposition took %f s", t.time());
@@ -90,13 +101,15 @@ std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& chi
 
           for (int k = 0; k < 2; ++k) {
             auto it = P[k].begin();
-            std::advance(it, k == 0?i:j);
+            std::advance(it, k == 0 ? i : j);
 
-            CGAL_Polyhedron const& poly = *it;
+            CGAL_Polyhedron const &poly = *it;
             points[k].reserve(poly.size_of_vertices());
 
-            for (CGAL_Polyhedron::Vertex_const_iterator pi = poly.vertices_begin(); pi != poly.vertices_end(); ++pi) {
-              CGAL_Polyhedron::Point_3 const& p = pi->point();
+            for (CGAL_Polyhedron::Vertex_const_iterator pi =
+                     poly.vertices_begin();
+                 pi != poly.vertices_end(); ++pi) {
+              CGAL_Polyhedron::Point_3 const &p = pi->point();
               points[k].push_back(conv(p));
             }
           }
@@ -105,7 +118,8 @@ std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& chi
           minkowski_points.reserve(points[0].size() * points[1].size());
           for (size_t i = 0; i < points[0].size(); ++i) {
             for (size_t j = 0; j < points[1].size(); ++j) {
-              minkowski_points.push_back(points[0][i] + (points[1][j] - CGAL::ORIGIN));
+              minkowski_points.push_back(points[0][i] +
+                                         (points[1][j] - CGAL::ORIGIN));
             }
           }
 
@@ -116,18 +130,23 @@ std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& chi
 
           CGAL::Polyhedron_3<Hull_kernel> result;
           t.stop();
-          PRINTDB("Minkowski: Point cloud creation (%d ⨉ %d -> %d) took %f ms", points[0].size() % points[1].size() % minkowski_points.size() % (t.time() * 1000));
+          PRINTDB("Minkowski: Point cloud creation (%d ⨉ %d -> %d) took %f ms",
+                  points[0].size() % points[1].size() %
+                      minkowski_points.size() % (t.time() * 1000));
           t.reset();
 
           t.start();
 
-          CGAL::convex_hull_3(minkowski_points.begin(), minkowski_points.end(), result);
+          CGAL::convex_hull_3(minkowski_points.begin(), minkowski_points.end(),
+                              result);
 
           std::vector<Hull_kernel::Point_3> strict_points;
           strict_points.reserve(minkowski_points.size());
 
-          for (CGAL::Polyhedron_3<Hull_kernel>::Vertex_iterator i = result.vertices_begin(); i != result.vertices_end(); ++i) {
-            Hull_kernel::Point_3 const& p = i->point();
+          for (CGAL::Polyhedron_3<Hull_kernel>::Vertex_iterator i =
+                   result.vertices_begin();
+               i != result.vertices_end(); ++i) {
+            Hull_kernel::Point_3 const &p = i->point();
 
             CGAL::Polyhedron_3<Hull_kernel>::Vertex::Halfedge_handle h, e;
             h = i->halfedge();
@@ -136,19 +155,24 @@ std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& chi
             bool coplanar = true;
 
             do {
-              Hull_kernel::Point_3 const& q = h->opposite()->vertex()->point();
-              if (coplanar && !CGAL::coplanar(p, q,
-                                              h->next_on_vertex()->opposite()->vertex()->point(),
-                                              h->next_on_vertex()->next_on_vertex()->opposite()->vertex()->point())) {
+              Hull_kernel::Point_3 const &q = h->opposite()->vertex()->point();
+              if (coplanar &&
+                  !CGAL::coplanar(
+                      p, q, h->next_on_vertex()->opposite()->vertex()->point(),
+                      h->next_on_vertex()
+                          ->next_on_vertex()
+                          ->opposite()
+                          ->vertex()
+                          ->point())) {
                 coplanar = false;
               }
 
+              for (CGAL::Polyhedron_3<Hull_kernel>::Vertex::Halfedge_handle j =
+                       h->next_on_vertex();
+                   j != h && !collinear && !coplanar; j = j->next_on_vertex()) {
 
-              for (CGAL::Polyhedron_3<Hull_kernel>::Vertex::Halfedge_handle j = h->next_on_vertex();
-                   j != h && !collinear && !coplanar;
-                   j = j->next_on_vertex()) {
-
-                Hull_kernel::Point_3 const& r = j->opposite()->vertex()->point();
+                Hull_kernel::Point_3 const &r =
+                    j->opposite()->vertex()->point();
                 if (CGAL::collinear(p, q, r)) {
                   collinear = true;
                 }
@@ -157,12 +181,13 @@ std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& chi
               h = h->next_on_vertex();
             } while (h != e && !collinear);
 
-            if (!collinear && !coplanar) strict_points.push_back(p);
+            if (!collinear && !coplanar)
+              strict_points.push_back(p);
           }
 
           result.clear();
-          CGAL::convex_hull_3(strict_points.begin(), strict_points.end(), result);
-
+          CGAL::convex_hull_3(strict_points.begin(), strict_points.end(),
+                              result);
 
           t.stop();
           PRINTDB("Minkowski: Computing convex hull took %f s", t.time());
@@ -172,11 +197,12 @@ std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& chi
         }
       }
 
-      if (it != std::next(children.begin())) operands[0].reset();
+      if (it != std::next(children.begin()))
+        operands[0].reset();
 
-      auto partToGeom = [&](auto& poly) -> std::shared_ptr<const Geometry> {
-          return CGALUtils::createPolySetFromPolyhedron(poly);
-        };
+      auto partToGeom = [&](auto &poly) -> std::shared_ptr<const Geometry> {
+        return CGALUtils::createPolySetFromPolyhedron(poly);
+      };
 
       if (result_parts.size() == 1) {
         operands[0] = partToGeom(*result_parts.begin());
@@ -184,13 +210,16 @@ std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& chi
         t.start();
         PRINTDB("Minkowski: Computing union of %d parts", result_parts.size());
         Geometry::Geometries fake_children;
-        for (const auto& part : result_parts) {
-          fake_children.emplace_back(std::shared_ptr<const AbstractNode>(), partToGeom(part));
+        for (const auto &part : result_parts) {
+          fake_children.emplace_back(std::shared_ptr<const AbstractNode>(),
+                                     partToGeom(part));
         }
-        auto N = CGALUtils::applyUnion3D(fake_children.begin(), fake_children.end());
+        auto N =
+            CGALUtils::applyUnion3D(fake_children.begin(), fake_children.end());
         // FIXME: This should really never throw.
         // Assert once we figured out what went wrong with issue #1069?
-        if (!N) throw 0;
+        if (!N)
+          throw 0;
         t.stop();
         PRINTDB("Minkowski: Union done: %f s", t.time());
         t.reset();
@@ -208,9 +237,10 @@ std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& chi
     // If anything throws we simply fall back to Nef Minkowski
     PRINTD("Minkowski: Falling back to Nef Minkowski");
 
-    auto N = std::shared_ptr<const Geometry>(CGALUtils::applyOperator3D(children, OpenSCADOperator::MINKOWSKI));
+    auto N = std::shared_ptr<const Geometry>(
+        CGALUtils::applyOperator3D(children, OpenSCADOperator::MINKOWSKI));
     return N;
   }
 }
 
-}  // namespace CGALUtils
\ No newline at end of file
+} // namespace CGALUtils
\ No newline at end of file
diff --git a/src/geometry/cgal/cgalutils-applyops.cc b/src/geometry/cgal/cgalutils-applyops.cc
index 67c3aefdd..ccb47fb6f 100644
--- a/src/geometry/cgal/cgalutils-applyops.cc
+++ b/src/geometry/cgal/cgalutils-applyops.cc
@@ -1,32 +1,32 @@
 // this file is split into many separate cgalutils* files
 // in order to workaround gcc 4.9.1 crashing on systems with only 2GB of RAM
-#include "geometry/cgal/cgal.h"
-#include "geometry/Geometry.h"
-#include "geometry/cgal/cgalutils.h"
 #include "Feature.h"
+#include "core/progress.h"
+#include "geometry/Geometry.h"
 #include "geometry/PolySet.h"
+#include "geometry/cgal/cgal.h"
+#include "geometry/cgal/cgalutils.h"
 #include "utils/printutils.h"
-#include "core/progress.h"
 #ifdef ENABLE_MANIFOLD
 #include "geometry/manifold/ManifoldGeometry.h"
 #include "geometry/manifold/manifoldutils.h"
 #endif
 #include "core/node.h"
 
-#include <cassert>
-#include <utility>
-#include <exception>
 #include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
-#include <CGAL/normal_vector_newell_3.h>
 #include <CGAL/Handle_hash_function.h>
+#include <CGAL/normal_vector_newell_3.h>
+#include <cassert>
+#include <exception>
+#include <utility>
 
 #include <CGAL/config.h>
 #include <CGAL/version.h>
 
 #include <CGAL/convex_hull_3.h>
 
-#include "geometry/Reindexer.h"
 #include "geometry/GeometryUtils.h"
+#include "geometry/Reindexer.h"
 
 #include <cstddef>
 #include <memory>
@@ -35,20 +35,22 @@
 
 namespace CGALUtils {
 
-std::unique_ptr<const Geometry> applyUnion3D(
-  Geometry::Geometries::iterator chbegin, Geometry::Geometries::iterator chend)
-{
+std::unique_ptr<const Geometry>
+applyUnion3D(Geometry::Geometries::iterator chbegin,
+             Geometry::Geometries::iterator chend) {
   using QueueConstItem = std::pair<std::shared_ptr<const CGALNefGeometry>, int>;
   struct QueueItemGreater {
     // stable sort for priority_queue by facets, then progress mark
-    bool operator()(const QueueConstItem& lhs, const QueueConstItem& rhs) const
-    {
+    bool operator()(const QueueConstItem &lhs,
+                    const QueueConstItem &rhs) const {
       size_t l = lhs.first->p3->number_of_facets();
       size_t r = rhs.first->p3->number_of_facets();
       return (l > r) || (l == r && lhs.second > rhs.second);
     }
   };
-  std::priority_queue<QueueConstItem, std::vector<QueueConstItem>, QueueItemGreater> q;
+  std::priority_queue<QueueConstItem, std::vector<QueueConstItem>,
+                      QueueItemGreater>
+      q;
 
   try {
     // sort children by fewest faces
@@ -69,7 +71,8 @@ std::unique_ptr<const Geometry> applyUnion3D(
       q.pop();
       auto p2 = q.top();
       q.pop();
-      q.emplace(std::make_unique<const CGALNefGeometry>(*p1.first + *p2.first), -1);
+      q.emplace(std::make_unique<const CGALNefGeometry>(*p1.first + *p2.first),
+                -1);
       progress_tick();
     }
 
@@ -78,26 +81,29 @@ std::unique_ptr<const Geometry> applyUnion3D(
     } else {
       return nullptr;
     }
-  } catch (const CGAL::Failure_exception& e) {
-    LOG(message_group::Error, "CGAL error in CGALUtils::applyUnion3D: %1$s", e.what());
+  } catch (const CGAL::Failure_exception &e) {
+    LOG(message_group::Error, "CGAL error in CGALUtils::applyUnion3D: %1$s",
+        e.what());
   }
   return nullptr;
 }
 
 /*!
    Applies op to all children and returns the result.
-   The child list should be guaranteed to contain non-NULL 3D or empty Geometry objects
+   The child list should be guaranteed to contain non-NULL 3D or empty Geometry
+   objects
  */
-std::shared_ptr<const Geometry> applyOperator3D(const Geometry::Geometries& children, OpenSCADOperator op)
-{
+std::shared_ptr<const Geometry>
+applyOperator3D(const Geometry::Geometries &children, OpenSCADOperator op) {
   std::shared_ptr<CGALNefGeometry> N;
 
-  assert(op != OpenSCADOperator::UNION && "use applyUnion3D() instead of applyOperator3D()");
+  assert(op != OpenSCADOperator::UNION &&
+         "use applyUnion3D() instead of applyOperator3D()");
   bool foundFirst = false;
 
   try {
-    for (const auto& item : children) {
-      const std::shared_ptr<const Geometry>& chgeom = item.second;
+    for (const auto &item : children) {
+      const std::shared_ptr<const Geometry> &chgeom = item.second;
       auto chN = getNefPolyhedronFromGeometry(chgeom);
 
       // Initialize N with first expected geometric object
@@ -121,7 +127,8 @@ std::shared_ptr<const Geometry> applyOperator3D(const Geometry::Geometries& chil
       }
 
       // empty op <something> => empty
-      if (!N || N->isEmpty()) continue;
+      if (!N || N->isEmpty())
+        continue;
 
       switch (op) {
       case OpenSCADOperator::INTERSECTION:
@@ -134,22 +141,35 @@ std::shared_ptr<const Geometry> applyOperator3D(const Geometry::Geometries& chil
         N->minkowski(*chN);
         break;
       default:
-        LOG(message_group::Error, "Unsupported CGAL operator: %1$d", static_cast<int>(op));
+        LOG(message_group::Error, "Unsupported CGAL operator: %1$d",
+            static_cast<int>(op));
       }
-      if (item.first) item.first->progress_report();
+      if (item.first)
+        item.first->progress_report();
     }
   }
-  // union && difference assert triggered by tests/data/scad/bugs/rotate-diff-nonmanifold-crash.scad and tests/data/scad/bugs/issue204.scad
-  catch (const CGAL::Failure_exception& e) {
-    std::string opstr = op == OpenSCADOperator::INTERSECTION ? "intersection" : op == OpenSCADOperator::DIFFERENCE ? "difference" : op == OpenSCADOperator::UNION ? "union" : "UNKNOWN";
-    LOG(message_group::Error, "CGAL error in CGALUtils::applyOperator3D %1$s: %2$s", opstr, e.what());
+  // union && difference assert triggered by
+  // tests/data/scad/bugs/rotate-diff-nonmanifold-crash.scad and
+  // tests/data/scad/bugs/issue204.scad
+  catch (const CGAL::Failure_exception &e) {
+    std::string opstr = op == OpenSCADOperator::INTERSECTION ? "intersection"
+                        : op == OpenSCADOperator::DIFFERENCE ? "difference"
+                        : op == OpenSCADOperator::UNION      ? "union"
+                                                             : "UNKNOWN";
+    LOG(message_group::Error,
+        "CGAL error in CGALUtils::applyOperator3D %1$s: %2$s", opstr, e.what());
   }
-  // boost any_cast throws exceptions inside CGAL code, ending here https://github.com/openscad/openscad/issues/3756
-  catch (const std::exception& e) {
-    std::string opstr = op == OpenSCADOperator::INTERSECTION ? "intersection" : op == OpenSCADOperator::DIFFERENCE ? "difference" : op == OpenSCADOperator::UNION ? "union" : "UNKNOWN";
-    LOG(message_group::Error, "exception in CGALUtils::applyOperator3D %1$s: %2$s", opstr, e.what());
+  // boost any_cast throws exceptions inside CGAL code, ending here
+  // https://github.com/openscad/openscad/issues/3756
+  catch (const std::exception &e) {
+    std::string opstr = op == OpenSCADOperator::INTERSECTION ? "intersection"
+                        : op == OpenSCADOperator::DIFFERENCE ? "difference"
+                        : op == OpenSCADOperator::UNION      ? "union"
+                                                             : "UNKNOWN";
+    LOG(message_group::Error,
+        "exception in CGALUtils::applyOperator3D %1$s: %2$s", opstr, e.what());
   }
   return N;
 }
 
-}  // namespace CGALUtils
+} // namespace CGALUtils
diff --git a/src/geometry/cgal/cgalutils-closed.cc b/src/geometry/cgal/cgalutils-closed.cc
index 71a5815c2..9ee821195 100644
--- a/src/geometry/cgal/cgalutils-closed.cc
+++ b/src/geometry/cgal/cgalutils-closed.cc
@@ -1,18 +1,16 @@
-// Portions of this file are Copyright 2021 Google LLC, and licensed under GPL2+. See COPYING.
+// Portions of this file are Copyright 2021 Google LLC, and licensed under
+// GPL2+. See COPYING.
 #include "geometry/cgal/cgalutils.h"
 
-#include <CGAL/boost/graph/helpers.h>
 #include <CGAL/Surface_mesh.h>
+#include <CGAL/boost/graph/helpers.h>
 
 namespace CGALUtils {
 
-template <typename Polyhedron>
-bool isClosed(const Polyhedron& p)
-{
+template <typename Polyhedron> bool isClosed(const Polyhedron &p) {
   return CGAL::is_closed(p);
 }
 
-template bool isClosed(const CGAL_DoubleMesh& p);
+template bool isClosed(const CGAL_DoubleMesh &p);
 
 } // namespace CGALUtils
-
diff --git a/src/geometry/cgal/cgalutils-convex.cc b/src/geometry/cgal/cgalutils-convex.cc
index 01329daf0..c4d91edc1 100644
--- a/src/geometry/cgal/cgalutils-convex.cc
+++ b/src/geometry/cgal/cgalutils-convex.cc
@@ -9,19 +9,24 @@
 
 namespace CGALUtils {
 
-template <typename K>
-bool is_weakly_convex(const CGAL::Polyhedron_3<K>& p) {
+template <typename K> bool is_weakly_convex(const CGAL::Polyhedron_3<K> &p) {
   using Polyhedron = typename CGAL::Polyhedron_3<K>;
 
-  for (typename Polyhedron::Edge_const_iterator i = p.edges_begin(); i != p.edges_end(); ++i) {
-    typename Polyhedron::Plane_3 p(i->opposite()->vertex()->point(), i->vertex()->point(), i->next()->vertex()->point());
+  for (typename Polyhedron::Edge_const_iterator i = p.edges_begin();
+       i != p.edges_end(); ++i) {
+    typename Polyhedron::Plane_3 p(i->opposite()->vertex()->point(),
+                                   i->vertex()->point(),
+                                   i->next()->vertex()->point());
     if (p.has_on_positive_side(i->opposite()->next()->vertex()->point()) &&
-        CGAL::squared_distance(p, i->opposite()->next()->vertex()->point()) > 1e-8) {
+        CGAL::squared_distance(p, i->opposite()->next()->vertex()->point()) >
+            1e-8) {
       return false;
     }
   }
   // Also make sure that there is only one shell:
-  std::unordered_set<typename Polyhedron::Facet_const_handle, typename CGAL::Handle_hash_function> visited;
+  std::unordered_set<typename Polyhedron::Facet_const_handle,
+                     typename CGAL::Handle_hash_function>
+      visited;
   // c++11
   visited.reserve(p.size_of_facets());
 
@@ -47,25 +52,25 @@ bool is_weakly_convex(const CGAL::Polyhedron_3<K>& p) {
   return visited.size() == p.size_of_facets();
 }
 
-template bool is_weakly_convex(const CGAL::Polyhedron_3<CGAL_Kernel3>& p);
+template bool is_weakly_convex(const CGAL::Polyhedron_3<CGAL_Kernel3> &p);
 
 template <typename K>
-bool is_weakly_convex(const CGAL::Surface_mesh<CGAL::Point_3<K>>& m) {
+bool is_weakly_convex(const CGAL::Surface_mesh<CGAL::Point_3<K>> &m) {
   using Mesh = typename CGAL::Surface_mesh<CGAL::Point_3<K>>;
 
   for (auto i : m.halfedges()) {
-    CGAL::Plane_3<K> p(
-      m.point(m.target(m.opposite(i))),
-      m.point(m.target(i)),
-      m.point(m.target(m.next(i))));
-    const auto& pt = m.point(m.target(m.next(m.opposite(i))));
+    CGAL::Plane_3<K> p(m.point(m.target(m.opposite(i))), m.point(m.target(i)),
+                       m.point(m.target(m.next(i))));
+    const auto &pt = m.point(m.target(m.next(m.opposite(i))));
     if (p.has_on_positive_side(pt) && CGAL::squared_distance(p, pt) > 1e-8) {
       return false;
     }
   }
 
   // Also make sure that there is only one shell:
-  std::unordered_set<typename Mesh::Face_index, typename CGAL::Handle_hash_function> visited;
+  std::unordered_set<typename Mesh::Face_index,
+                     typename CGAL::Handle_hash_function>
+      visited;
   visited.reserve(m.number_of_faces());
 
   std::queue<typename Mesh::Face_index> to_explore;
@@ -77,7 +82,8 @@ bool is_weakly_convex(const CGAL::Surface_mesh<CGAL::Point_3<K>>& m) {
     to_explore.pop();
 
     CGAL::Halfedge_around_face_iterator<Mesh> he, end;
-    for (boost::tie(he, end) = CGAL::halfedges_around_face(m.halfedge(f), m); he != end; ++he) {
+    for (boost::tie(he, end) = CGAL::halfedges_around_face(m.halfedge(f), m);
+         he != end; ++he) {
       typename Mesh::Face_index o = m.face(m.opposite(*he));
 
       if (!visited.count(o)) {
@@ -90,8 +96,8 @@ bool is_weakly_convex(const CGAL::Surface_mesh<CGAL::Point_3<K>>& m) {
   return visited.size() == m.number_of_faces();
 }
 
-template bool is_weakly_convex(const CGAL::Surface_mesh<CGAL_Point_3>& m);
+template bool is_weakly_convex(const CGAL::Surface_mesh<CGAL_Point_3> &m);
 
-}  // namespace CGALUtils
+} // namespace CGALUtils
 
 #endif // ENABLE_CGAL
diff --git a/src/geometry/cgal/cgalutils-kernel.cc b/src/geometry/cgal/cgalutils-kernel.cc
index cbb46c8c8..77012d99f 100644
--- a/src/geometry/cgal/cgalutils-kernel.cc
+++ b/src/geometry/cgal/cgalutils-kernel.cc
@@ -1,4 +1,5 @@
-// Portions of this file are Copyright 2021 Google LLC, and licensed under GPL2+. See COPYING.
+// Portions of this file are Copyright 2021 Google LLC, and licensed under
+// GPL2+. See COPYING.
 #include "geometry/cgal/cgalutils.h"
 #include <CGAL/Cartesian_converter.h>
 #include <CGAL/gmpxx.h>
@@ -7,22 +8,20 @@ namespace CGALUtils {
 
 template <>
 double KernelConverter<CGAL::Cartesian<CGAL::Gmpq>, CGAL::Epick>::operator()(
-  const CGAL::Gmpq& n) const
-{
+    const CGAL::Gmpq &n) const {
   return CGAL::to_double(n);
 }
 
 template <>
-CGAL::Gmpq KernelConverter<CGAL::Epick, CGAL::Cartesian<CGAL::Gmpq>>::operator()(
-  const double& n) const
-{
+CGAL::Gmpq
+KernelConverter<CGAL::Epick, CGAL::Cartesian<CGAL::Gmpq>>::operator()(
+    const double &n) const {
   return n;
 }
 
 template <>
 double KernelConverter<CGAL::Epick, CGAL_DoubleKernel>::operator()(
-  const double& n) const
-{
+    const double &n) const {
   return n;
 }
 
diff --git a/src/geometry/cgal/cgalutils-mesh-edits.h b/src/geometry/cgal/cgalutils-mesh-edits.h
index f873597db..bf905e50c 100644
--- a/src/geometry/cgal/cgalutils-mesh-edits.h
+++ b/src/geometry/cgal/cgalutils-mesh-edits.h
@@ -1,4 +1,5 @@
-// Portions of this file are Copyright 2021 Google LLC, and licensed under GPL2+. See COPYING.
+// Portions of this file are Copyright 2021 Google LLC, and licensed under
+// GPL2+. See COPYING.
 #pragma once
 
 #include <CGAL/Polygon_mesh_processing/triangulate_faces.h>
@@ -16,9 +17,7 @@ namespace CGALUtils {
 namespace PMP = CGAL::Polygon_mesh_processing;
 
 /*! Buffer of changes to be applied to a triangle mesh. */
-template <typename TriangleMesh>
-class TriangleMeshEdits
-{
+template <typename TriangleMesh> class TriangleMeshEdits {
 
 private:
   using GT = boost::graph_traits<TriangleMesh>;
@@ -33,34 +32,27 @@ private:
   std::unordered_map<vertex_descriptor, vertex_descriptor> vertexReplacements;
 
 public:
-
   bool isEmpty() {
-    return facesToRemove.empty() &&
-           verticesToRemove.empty() &&
-           facesToAdd.empty() &&
-           vertexReplacements.empty();
+    return facesToRemove.empty() && verticesToRemove.empty() &&
+           facesToAdd.empty() && vertexReplacements.empty();
   }
 
-  void removeFace(const face_descriptor& f) {
-    facesToRemove.insert(f);
-  }
+  void removeFace(const face_descriptor &f) { facesToRemove.insert(f); }
 
-  void removeVertex(const vertex_descriptor& v) {
-    verticesToRemove.insert(v);
-  }
+  void removeVertex(const vertex_descriptor &v) { verticesToRemove.insert(v); }
 
-  void addFace(const std::vector<vertex_descriptor>& vertices) {
+  void addFace(const std::vector<vertex_descriptor> &vertices) {
     facesToAdd.push_back(vertices);
   }
 
-  void replaceVertex(const vertex_descriptor& original, const vertex_descriptor& replacement) {
+  void replaceVertex(const vertex_descriptor &original,
+                     const vertex_descriptor &replacement) {
     vertexReplacements[original] = replacement;
   }
 
   static bool findCollapsibleVertices(
-    const std::vector<vertex_descriptor>& path,
-    const TriangleMesh& tm,
-    const std::function<void(size_t, vertex_descriptor)>& sinkFn) {
+      const std::vector<vertex_descriptor> &path, const TriangleMesh &tm,
+      const std::function<void(size_t, vertex_descriptor)> &sinkFn) {
     if (path.size() <= 3) {
       return false;
     }
@@ -85,72 +77,79 @@ public:
 
   /*! Mutating in place is tricky, to say the least, so this creates a new mesh
    * and overwrites the original to it at the end for now. */
-  bool apply(TriangleMesh& src) const
-  {
+  bool apply(TriangleMesh &src) const {
     TriangleMesh copy;
     auto wasValid = CGAL::is_valid_polygon_mesh(src);
     auto wasClosed = CGAL::is_closed(src);
 
     auto edgesAdded = 0;
-    for (auto& vs : facesToAdd) edgesAdded += vs.size();
-
-    auto projectedVertexCount = src.number_of_vertices() - verticesToRemove.size();
-    auto projectedHalfedgeCount = src.number_of_halfedges() + edgesAdded * 2; // This is crude
-    auto projectedFaceCount = src.number_of_faces() - facesToRemove.size() + facesToAdd.size();
+    for (auto &vs : facesToAdd)
+      edgesAdded += vs.size();
+
+    auto projectedVertexCount =
+        src.number_of_vertices() - verticesToRemove.size();
+    auto projectedHalfedgeCount =
+        src.number_of_halfedges() + edgesAdded * 2; // This is crude
+    auto projectedFaceCount =
+        src.number_of_faces() - facesToRemove.size() + facesToAdd.size();
     copy.reserve(copy.number_of_vertices() + projectedVertexCount,
                  copy.number_of_halfedges() + projectedHalfedgeCount,
                  copy.number_of_faces() + projectedFaceCount);
 
-    // TODO(ochafik): Speed up with a lookup vector : std::vector<vertex_descriptor> vertexMap(src.number_of_vertices());
+    // TODO(ochafik): Speed up with a lookup vector :
+    // std::vector<vertex_descriptor> vertexMap(src.number_of_vertices());
     std::unordered_map<vertex_descriptor, vertex_descriptor> vertexMap;
     vertexMap.reserve(projectedVertexCount);
 
     auto getDestinationVertex = [&](auto srcVertex) {
-        auto repIt = vertexReplacements.find(srcVertex);
-        if (repIt != vertexReplacements.end()) {
-          srcVertex = repIt->second;
-        }
-        auto it = vertexMap.find(srcVertex);
-        if (it == vertexMap.end()) {
-          auto v = copy.add_vertex(src.point(srcVertex));
-          vertexMap[srcVertex] = v;
-          return v;
-        }
-        return it->second;
-      };
+      auto repIt = vertexReplacements.find(srcVertex);
+      if (repIt != vertexReplacements.end()) {
+        srcVertex = repIt->second;
+      }
+      auto it = vertexMap.find(srcVertex);
+      if (it == vertexMap.end()) {
+        auto v = copy.add_vertex(src.point(srcVertex));
+        vertexMap[srcVertex] = v;
+        return v;
+      }
+      return it->second;
+    };
 
     std::vector<vertex_descriptor> polygon;
 
-    auto addFace = [&](auto& polygon) {
-        auto face = copy.add_face(polygon);
-        if (face.is_valid()) {
-          if (polygon.size() > 3) {
-            PMP::triangulate_face(face, copy);
-          }
-          return true;
-        } else {
-          LOG(message_group::Warning, "Failed to add face with %1$lu vertices!", polygon.size());
-          return false;
+    auto addFace = [&](auto &polygon) {
+      auto face = copy.add_face(polygon);
+      if (face.is_valid()) {
+        if (polygon.size() > 3) {
+          PMP::triangulate_face(face, copy);
         }
-      };
-    auto copyFace = [&](auto& f) {
-        polygon.clear();
-
-        CGAL::Vertex_around_face_iterator<TriangleMesh> vit, vend;
-        for (boost::tie(vit, vend) = vertices_around_face(src.halfedge(f), src); vit != vend; ++vit) {
-          auto v = *vit;
-          if (verticesToRemove.find(v) != verticesToRemove.end()) {
-            continue;
-          }
-          polygon.push_back(getDestinationVertex(v));
-        }
-        if (polygon.size() < 3) {
-          LOG(message_group::Warning, "Attempted to remove too many vertices around this copied face, remesh aborted!");
-          return false;
+        return true;
+      } else {
+        LOG(message_group::Warning, "Failed to add face with %1$lu vertices!",
+            polygon.size());
+        return false;
+      }
+    };
+    auto copyFace = [&](auto &f) {
+      polygon.clear();
+
+      CGAL::Vertex_around_face_iterator<TriangleMesh> vit, vend;
+      for (boost::tie(vit, vend) = vertices_around_face(src.halfedge(f), src);
+           vit != vend; ++vit) {
+        auto v = *vit;
+        if (verticesToRemove.find(v) != verticesToRemove.end()) {
+          continue;
         }
+        polygon.push_back(getDestinationVertex(v));
+      }
+      if (polygon.size() < 3) {
+        LOG(message_group::Warning, "Attempted to remove too many vertices "
+                                    "around this copied face, remesh aborted!");
+        return false;
+      }
 
-        return addFace(polygon);
-      };
+      return addFace(polygon);
+    };
 
     for (auto f : src.faces()) {
       if (src.is_removed(f)) {
@@ -164,7 +163,7 @@ public:
       }
     }
 
-    for (auto& originalPolygon : facesToAdd) {
+    for (auto &originalPolygon : facesToAdd) {
       polygon.clear();
 
       for (auto v : originalPolygon) {
@@ -174,7 +173,8 @@ public:
         polygon.push_back(getDestinationVertex(v));
       }
       if (polygon.size() < 3) {
-        LOG(message_group::Warning, "Attempted to remove too many vertices around this added face, remesh aborted!");
+        LOG(message_group::Warning, "Attempted to remove too many vertices "
+                                    "around this added face, remesh aborted!");
         return false;
       }
       if (!addFace(polygon)) {
diff --git a/src/geometry/cgal/cgalutils-mesh.cc b/src/geometry/cgal/cgalutils-mesh.cc
index 4a5b208f5..507c8aef4 100644
--- a/src/geometry/cgal/cgalutils-mesh.cc
+++ b/src/geometry/cgal/cgalutils-mesh.cc
@@ -1,40 +1,39 @@
 #include "geometry/cgal/cgalutils.h"
 
-#include <unordered_map>
-#include <memory>
 #include <cstddef>
+#include <memory>
+#include <unordered_map>
 #include <vector>
 
-#include <boost/range/adaptor/transformed.hpp>
 #include <CGAL/Point_3.h>
-#include <CGAL/boost/graph/convert_nef_polyhedron_to_polygon_mesh.h>
-#include <CGAL/boost/graph/graph_traits_Surface_mesh.h>
-#include <CGAL/Surface_mesh.h>
 #include <CGAL/Polygon_mesh_processing/polygon_soup_to_polygon_mesh.h>
 #include <CGAL/Polygon_mesh_processing/repair_polygon_soup.h>
+#include <CGAL/Surface_mesh.h>
+#include <CGAL/boost/graph/convert_nef_polyhedron_to_polygon_mesh.h>
+#include <CGAL/boost/graph/graph_traits_Surface_mesh.h>
+#include <boost/range/adaptor/transformed.hpp>
 
+#include "geometry/PolySetBuilder.h"
 #include "geometry/cgal/cgal.h"
 #include "geometry/linalg.h"
-#include "geometry/PolySetBuilder.h"
 
 namespace CGALUtils {
 
 namespace PMP = CGAL::Polygon_mesh_processing;
 
-CGAL_DoubleMesh repairPolySet(const PolySet& ps)
-{
+CGAL_DoubleMesh repairPolySet(const PolySet &ps) {
   std::vector<CGAL_DoubleMesh::Point> points;
   std::vector<std::vector<size_t>> polygons;
 
   // at least 3*numFacets
   points.reserve(ps.indices.size() * 3);
   polygons.reserve(ps.indices.size());
-  for (const auto& inds : ps.indices) {
-    std::vector<size_t>& polygon = polygons.emplace_back();
+  for (const auto &inds : ps.indices) {
+    std::vector<size_t> &polygon = polygons.emplace_back();
     polygon.reserve(inds.size());
-    for (const auto& ind : inds) {
+    for (const auto &ind : inds) {
       polygon.push_back(points.size());
-      auto& pt = ps.vertices[ind];
+      auto &pt = ps.vertices[ind];
       points.emplace_back(pt[0], pt[1], pt[2]);
     }
   }
@@ -47,37 +46,38 @@ CGAL_DoubleMesh repairPolySet(const PolySet& ps)
 }
 
 template <class SurfaceMesh>
-std::shared_ptr<SurfaceMesh> createSurfaceMeshFromPolySet(const PolySet& ps)
-{
+std::shared_ptr<SurfaceMesh> createSurfaceMeshFromPolySet(const PolySet &ps) {
   auto mesh = std::make_shared<SurfaceMesh>();
   mesh->reserve(ps.vertices.size(), ps.indices.size() * 3, ps.indices.size());
-  for (const auto& v : ps.vertices) {
+  for (const auto &v : ps.vertices) {
     mesh->add_vertex(typename SurfaceMesh::Point(v[0], v[1], v[2]));
   }
-  for (const auto& face : ps.indices) {
-    mesh->add_face(face | boost::adaptors::transformed([](uint32_t i){
-        return typename SurfaceMesh::Vertex_index(i);
-      }));
+  for (const auto &face : ps.indices) {
+    mesh->add_face(face | boost::adaptors::transformed([](uint32_t i) {
+                     return typename SurfaceMesh::Vertex_index(i);
+                   }));
   }
   return mesh;
 }
 
-template std::shared_ptr<CGAL_DoubleMesh> createSurfaceMeshFromPolySet<CGAL_DoubleMesh>(const PolySet& ps);
-template std::shared_ptr<CGAL_Kernel3Mesh> createSurfaceMeshFromPolySet(const PolySet& ps);
-
+template std::shared_ptr<CGAL_DoubleMesh>
+createSurfaceMeshFromPolySet<CGAL_DoubleMesh>(const PolySet &ps);
+template std::shared_ptr<CGAL_Kernel3Mesh>
+createSurfaceMeshFromPolySet(const PolySet &ps);
 
 template <class SurfaceMesh>
-std::unique_ptr<PolySet> createPolySetFromSurfaceMesh(const SurfaceMesh& mesh)
-{
-  //  FIXME: We may want to convert directly, without PolySetBuilder here, to maintain manifoldness, if possible.
+std::unique_ptr<PolySet> createPolySetFromSurfaceMesh(const SurfaceMesh &mesh) {
+  //  FIXME: We may want to convert directly, without PolySetBuilder here, to
+  //  maintain manifoldness, if possible.
   PolySetBuilder builder(0, mesh.number_of_faces() + mesh.number_of_faces());
-  for (const auto& f : mesh.faces()) {
+  for (const auto &f : mesh.faces()) {
     builder.beginPolygon(mesh.degree(f));
 
     CGAL::Vertex_around_face_iterator<SurfaceMesh> vbegin, vend;
-    for (boost::tie(vbegin, vend) = vertices_around_face(mesh.halfedge(f), mesh); vbegin != vend;
-         ++vbegin) {
-      auto& v = mesh.point(*vbegin);
+    for (boost::tie(vbegin, vend) =
+             vertices_around_face(mesh.halfedge(f), mesh);
+         vbegin != vend; ++vbegin) {
+      auto &v = mesh.point(*vbegin);
       // for (auto &v : f) {
       double x = CGAL::to_double(v.x());
       double y = CGAL::to_double(v.y());
@@ -89,10 +89,8 @@ std::unique_ptr<PolySet> createPolySetFromSurfaceMesh(const SurfaceMesh& mesh)
 }
 
 template <class InputKernel, class OutputKernel>
-void copyMesh(
-  const CGAL::Surface_mesh<CGAL::Point_3<InputKernel>>& input,
-  CGAL::Surface_mesh<CGAL::Point_3<OutputKernel>>& output)
-{
+void copyMesh(const CGAL::Surface_mesh<CGAL::Point_3<InputKernel>> &input,
+              CGAL::Surface_mesh<CGAL::Point_3<OutputKernel>> &output) {
   using InputMesh = CGAL::Surface_mesh<CGAL::Point_3<InputKernel>>;
   using OutputMesh = CGAL::Surface_mesh<CGAL::Point_3<OutputKernel>>;
 
@@ -101,18 +99,24 @@ void copyMesh(
                  output.number_of_halfedges() + input.number_of_halfedges(),
                  output.number_of_faces() + input.number_of_faces());
 
-  std::vector<typename CGAL::Surface_mesh<CGAL::Point_3<OutputKernel>>::Vertex_index> polygon;
-  std::unordered_map<typename InputMesh::Vertex_index, typename OutputMesh::Vertex_index> reindexer;
+  std::vector<
+      typename CGAL::Surface_mesh<CGAL::Point_3<OutputKernel>>::Vertex_index>
+      polygon;
+  std::unordered_map<typename InputMesh::Vertex_index,
+                     typename OutputMesh::Vertex_index>
+      reindexer;
   for (auto face : input.faces()) {
     polygon.clear();
 
-    CGAL::Vertex_around_face_iterator<typename CGAL::Surface_mesh<CGAL::Point_3<InputKernel>>>
-    vbegin, vend;
-    for (boost::tie(vbegin, vend) = vertices_around_face(input.halfedge(face), input);
+    CGAL::Vertex_around_face_iterator<
+        typename CGAL::Surface_mesh<CGAL::Point_3<InputKernel>>>
+        vbegin, vend;
+    for (boost::tie(vbegin, vend) =
+             vertices_around_face(input.halfedge(face), input);
          vbegin != vend; ++vbegin) {
       auto input_vertex = *vbegin;
       auto size_before = reindexer.size();
-      auto& output_vertex = reindexer[input_vertex];
+      auto &output_vertex = reindexer[input_vertex];
       if (size_before != reindexer.size()) {
         output_vertex = output.add_vertex(converter(input.point(input_vertex)));
       }
@@ -122,7 +126,8 @@ void copyMesh(
   }
 }
 
-template void copyMesh(const CGAL::Surface_mesh<CGAL::Point_3<CGAL::Epick>>& input, CGAL_DoubleMesh& output);
-
+template void
+copyMesh(const CGAL::Surface_mesh<CGAL::Point_3<CGAL::Epick>> &input,
+         CGAL_DoubleMesh &output);
 
 } // namespace CGALUtils
diff --git a/src/geometry/cgal/cgalutils-orient.cc b/src/geometry/cgal/cgalutils-orient.cc
index 92f67421a..bea9ea6d5 100644
--- a/src/geometry/cgal/cgalutils-orient.cc
+++ b/src/geometry/cgal/cgalutils-orient.cc
@@ -1,4 +1,5 @@
-// Portions of this file are Copyright 2021 Google LLC, and licensed under GPL2+. See COPYING.
+// Portions of this file are Copyright 2021 Google LLC, and licensed under
+// GPL2+. See COPYING.
 #include "geometry/cgal/cgalutils.h"
 
 #include <CGAL/Polygon_mesh_processing/orientation.h>
@@ -6,13 +7,10 @@
 
 namespace CGALUtils {
 
-template <typename SurfaceMesh>
-void orientToBoundAVolume(SurfaceMesh& mesh)
-{
+template <typename SurfaceMesh> void orientToBoundAVolume(SurfaceMesh &mesh) {
   CGAL::Polygon_mesh_processing::orient_to_bound_a_volume(mesh);
 }
 
-template void orientToBoundAVolume(CGAL_DoubleMesh& polyhedron);
+template void orientToBoundAVolume(CGAL_DoubleMesh &polyhedron);
 
 } // namespace CGALUtils
-
diff --git a/src/geometry/cgal/cgalutils-polyhedron.cc b/src/geometry/cgal/cgalutils-polyhedron.cc
index 08d1b2704..a4fae197b 100644
--- a/src/geometry/cgal/cgalutils-polyhedron.cc
+++ b/src/geometry/cgal/cgalutils-polyhedron.cc
@@ -2,43 +2,46 @@
 #include "geometry/cgal/cgalutils.h"
 
 #include <algorithm>
+#include <cstddef>
 #include <iterator>
-#include <ostream>
 #include <memory>
-#include <cstddef>
+#include <ostream>
 #include <vector>
 
-#include <boost/range/adaptor/reversed.hpp>
 #include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
 #include <CGAL/boost/graph/convert_nef_polyhedron_to_polygon_mesh.h>
+#include <boost/range/adaptor/reversed.hpp>
 
-#include "geometry/linalg.h"
+#include "geometry/Grid.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetBuilder.h"
+#include "geometry/linalg.h"
 #include "utils/printutils.h"
-#include "geometry/Grid.h"
 
 #undef GEN_SURFACE_DEBUG
 namespace /* anonymous */ {
 
 template <typename Polyhedron>
-class CGAL_Build_PolySet : public CGAL::Modifier_base<typename Polyhedron::HalfedgeDS>
-{
+class CGAL_Build_PolySet
+    : public CGAL::Modifier_base<typename Polyhedron::HalfedgeDS> {
   using HDS = typename Polyhedron::HalfedgeDS;
-  using CGAL_Polybuilder = CGAL::Polyhedron_incremental_builder_3<typename Polyhedron::HalfedgeDS>;
+  using CGAL_Polybuilder =
+      CGAL::Polyhedron_incremental_builder_3<typename Polyhedron::HalfedgeDS>;
+
 public:
   using CGALPoint = typename CGAL_Polybuilder::Point_3;
 
-  const PolySet& ps;
-  CGAL_Build_PolySet(const PolySet& ps) : ps(ps) { }
+  const PolySet &ps;
+  CGAL_Build_PolySet(const PolySet &ps) : ps(ps) {}
 
 /*
    Using Grid here is important for performance reasons. See following model.
-   If we don't grid the geometry before converting to a Nef Polyhedron, the quads
-   in the cylinders to tessellated into triangles since floating point
-   incertainty causes the faces to not be 100% planar. The incertainty is exaggerated
-   by the transform. This wasn't a problem earlier since we used Nef for everything,
-   but optimizations since then has made us keep it in floating point space longer.
+   If we don't grid the geometry before converting to a Nef Polyhedron, the
+   quads in the cylinders to tessellated into triangles since floating point
+   incertainty causes the faces to not be 100% planar. The incertainty is
+   exaggerated by the transform. This wasn't a problem earlier since we used Nef
+   for everything, but optimizations since then has made us keep it in floating
+   point space longer.
 
    minkowski() {
    cube([200, 50, 7], center = true);
@@ -47,7 +50,7 @@ public:
    }
  */
 #if 1 // Use Grid
-  void operator()(HDS& hds) override {
+  void operator()(HDS &hds) override {
     CGAL_Polybuilder B(hds, true);
 
     Grid3d<int> grid(GRID_FINE);
@@ -55,7 +58,7 @@ public:
     std::vector<std::vector<size_t>> indices;
 
     // Align all vertices to grid and build vertex array in vertices
-    for (const auto& p : ps.indices) {
+    for (const auto &p : ps.indices) {
       indices.emplace_back();
       indices.back().reserve(p.size());
       for (auto ind : boost::adaptors::reverse(p)) {
@@ -75,28 +78,33 @@ public:
     int pidx = 0;
 #endif
     B.begin_surface(vertices.size(), ps.indices.size());
-    for (const auto& p : vertices) {
+    for (const auto &p : vertices) {
       B.add_vertex(p);
     }
-    for (auto& pindices : indices) {
+    for (auto &pindices : indices) {
 #ifdef GEN_SURFACE_DEBUG
-      if (pidx++ > 0) printf(",");
+      if (pidx++ > 0)
+        printf(",");
 #endif
 
       // We remove duplicate indices since there is a bug in CGAL's
-      // Polyhedron_incremental_builder_3::test_facet() which fails to detect this
+      // Polyhedron_incremental_builder_3::test_facet() which fails to detect
+      // this
       auto last = std::unique(pindices.begin(), pindices.end());
       std::advance(last, -1);
-      if (*last != pindices.front()) last++; // In case the first & last are equal
+      if (*last != pindices.front())
+        last++; // In case the first & last are equal
       pindices.erase(last, pindices.end());
-      if (pindices.size() >= 3 && B.test_facet(pindices.begin(), pindices.end())) {
+      if (pindices.size() >= 3 &&
+          B.test_facet(pindices.begin(), pindices.end())) {
         B.add_facet(pindices.begin(), pindices.end());
       }
 #ifdef GEN_SURFACE_DEBUG
       printf("[");
       int fidx = 0;
       for (auto i : boost::adaptors::reverse(pindices)) {
-        if (fidx++ > 0) printf(",");
+        if (fidx++ > 0)
+          printf(",");
         printf("%ld", i);
       }
       printf("]");
@@ -109,16 +117,17 @@ public:
 #ifdef GEN_SURFACE_DEBUG
     printf("points=[");
     for (std::size_t i = 0; i < vertices.size(); ++i) {
-      if (i > 0) printf(",");
-      const CGALPoint& p = vertices[i];
-      printf("[%g,%g,%g]", CGAL::to_double(p.x()), CGAL::to_double(p.y()), CGAL::to_double(p.z()));
+      if (i > 0)
+        printf(",");
+      const CGALPoint &p = vertices[i];
+      printf("[%g,%g,%g]", CGAL::to_double(p.x()), CGAL::to_double(p.y()),
+             CGAL::to_double(p.z()));
     }
     printf("]);\n");
 #endif
   }
 #else // Don't use Grid
-  void operator()(HDS& hds)
-  {
+  void operator()(HDS &hds) {
     CGAL_Polybuilder B(hds, true);
     Reindexer<Vector3d> vertices;
     std::vector<size_t> indices(3);
@@ -129,16 +138,18 @@ public:
 #ifdef GEN_SURFACE_DEBUG
     printf("polyhedron(faces=[");
 #endif
-    for (const auto& p : ps.indices) {
+    for (const auto &p : ps.indices) {
 #ifdef GEN_SURFACE_DEBUG
-      if (pidx++ > 0) printf(",");
+      if (pidx++ > 0)
+        printf(",");
 #endif
       indices.clear();
-      for (const auto& v: boost::adaptors::reverse(p)) {
+      for (const auto &v : boost::adaptors::reverse(p)) {
         size_t s = vertices.size();
         size_t idx = vertices.lookup(v);
         // If we added a vertex, also add it to the CGAL builder
-        if (idx == s) B.add_vertex(CGALPoint(v[0], v[1], v[2]));
+        if (idx == s)
+          B.add_vertex(CGALPoint(v[0], v[1], v[2]));
         indices.push_back(idx);
       }
       // We perform this test since there is a bug in CGAL's
@@ -160,7 +171,8 @@ public:
         printf("[");
         int fidx = 0;
         for (auto i : indices) {
-          if (fidx++ > 0) printf(",");
+          if (fidx++ > 0)
+            printf(",");
           printf("%ld", i);
         }
         printf("]");
@@ -173,8 +185,9 @@ public:
 
     printf("points=[");
     for (std::size_t vidx = 0; vidx < vertices.size(); ++vidx) {
-      if (vidx > 0) printf(",");
-      const Vector3d& v = vertices.getArray()[vidx];
+      if (vidx > 0)
+        printf(",");
+      const Vector3d &v = vertices.getArray()[vidx];
       printf("[%g,%g,%g]", v[0], v[1], v[2]);
     }
     printf("]);\n");
@@ -184,30 +197,33 @@ public:
 };
 
 template <class InputKernel, class OutputKernel>
-struct Copy_polyhedron_to : public CGAL::Modifier_base<typename CGAL::Polyhedron_3<OutputKernel>::HalfedgeDS>
-{
+struct Copy_polyhedron_to
+    : public CGAL::Modifier_base<
+          typename CGAL::Polyhedron_3<OutputKernel>::HalfedgeDS> {
   using Polyhedron_output = CGAL::Polyhedron_3<OutputKernel>;
   using Polyhedron_input = CGAL::Polyhedron_3<InputKernel>;
 
-  Copy_polyhedron_to(const Polyhedron_input& in_poly) : in_poly(in_poly) {}
+  Copy_polyhedron_to(const Polyhedron_input &in_poly) : in_poly(in_poly) {}
 
-  void operator()(typename Polyhedron_output::HalfedgeDS& out_hds) override
-  {
+  void operator()(typename Polyhedron_output::HalfedgeDS &out_hds) override {
     using Output_HDS = typename Polyhedron_output::HalfedgeDS;
 
     CGAL::Polyhedron_incremental_builder_3<Output_HDS> builder(out_hds);
 
-    using Vertex_const_iterator = typename Polyhedron_input::Vertex_const_iterator;
-    using Facet_const_iterator = typename Polyhedron_input::Facet_const_iterator;
-    using HFCC = typename Polyhedron_input::Halfedge_around_facet_const_circulator;
+    using Vertex_const_iterator =
+        typename Polyhedron_input::Vertex_const_iterator;
+    using Facet_const_iterator =
+        typename Polyhedron_input::Facet_const_iterator;
+    using HFCC =
+        typename Polyhedron_input::Halfedge_around_facet_const_circulator;
 
-    builder.begin_surface(in_poly.size_of_vertices(),
-                          in_poly.size_of_facets(),
+    builder.begin_surface(in_poly.size_of_vertices(), in_poly.size_of_facets(),
                           in_poly.size_of_halfedges());
 
-    auto converter = CGALUtils::getCartesianConverter<InputKernel, OutputKernel>();
-    for (Vertex_const_iterator
-         vi = in_poly.vertices_begin(), end = in_poly.vertices_end();
+    auto converter =
+        CGALUtils::getCartesianConverter<InputKernel, OutputKernel>();
+    for (Vertex_const_iterator vi = in_poly.vertices_begin(),
+                               end = in_poly.vertices_end();
          vi != end; ++vi) {
       typename Polyhedron_output::Point_3 p(converter(vi->point().x()),
                                             converter(vi->point().y()),
@@ -218,8 +234,8 @@ struct Copy_polyhedron_to : public CGAL::Modifier_base<typename CGAL::Polyhedron
     using Index = CGAL::Inverse_index<Vertex_const_iterator>;
     Index index(in_poly.vertices_begin(), in_poly.vertices_end());
 
-    for (Facet_const_iterator
-         fi = in_poly.facets_begin(), end = in_poly.facets_end();
+    for (Facet_const_iterator fi = in_poly.facets_begin(),
+                              end = in_poly.facets_end();
          fi != end; ++fi) {
       HFCC hc = fi->facet_begin();
       HFCC hc_end = hc;
@@ -235,71 +251,73 @@ struct Copy_polyhedron_to : public CGAL::Modifier_base<typename CGAL::Polyhedron
     builder.end_surface();
   } // end operator()(..)
 private:
-  const Polyhedron_input& in_poly;
-};   // end Copy_polyhedron_to<>
+  const Polyhedron_input &in_poly;
+}; // end Copy_polyhedron_to<>
 
 } // namespace
 
 namespace CGALUtils {
 
 template <class InputKernel, class OutputKernel>
-void copyPolyhedron(const CGAL::Polyhedron_3<InputKernel>& poly_a, CGAL::Polyhedron_3<OutputKernel>& poly_b)
-{
+void copyPolyhedron(const CGAL::Polyhedron_3<InputKernel> &poly_a,
+                    CGAL::Polyhedron_3<OutputKernel> &poly_b) {
   // Copy is also used in "append" cases.
-  poly_b.reserve(
-    poly_b.size_of_vertices() + poly_a.size_of_vertices(),
-    poly_b.size_of_halfedges() + poly_a.size_of_halfedges(),
-    poly_b.size_of_facets() + poly_a.size_of_facets());
+  poly_b.reserve(poly_b.size_of_vertices() + poly_a.size_of_vertices(),
+                 poly_b.size_of_halfedges() + poly_a.size_of_halfedges(),
+                 poly_b.size_of_facets() + poly_a.size_of_facets());
 
   Copy_polyhedron_to<InputKernel, OutputKernel> modifier(poly_a);
   poly_b.delegate(modifier);
 }
 
-template void copyPolyhedron<CGAL::Epick, CGAL_Kernel3>(const CGAL::Polyhedron_3<CGAL::Epick>&, CGAL_Polyhedron&);
-template void copyPolyhedron<CGAL_Kernel3, CGAL::Epick>(const CGAL_Polyhedron&, CGAL::Polyhedron_3<CGAL::Epick>&);
+template void copyPolyhedron<CGAL::Epick, CGAL_Kernel3>(
+    const CGAL::Polyhedron_3<CGAL::Epick> &, CGAL_Polyhedron &);
+template void
+copyPolyhedron<CGAL_Kernel3, CGAL::Epick>(const CGAL_Polyhedron &,
+                                          CGAL::Polyhedron_3<CGAL::Epick> &);
 
 template <typename K>
-void convertNefToPolyhedron(
-  const CGAL::Nef_polyhedron_3<K>& nef, CGAL::Polyhedron_3<K>& polyhedron)
-{
+void convertNefToPolyhedron(const CGAL::Nef_polyhedron_3<K> &nef,
+                            CGAL::Polyhedron_3<K> &polyhedron) {
   nef.convert_to_polyhedron(polyhedron);
 }
 
-template void convertNefToPolyhedron(const CGAL_Nef_polyhedron3& nef, CGAL_Polyhedron& polyhedron);
+template void convertNefToPolyhedron(const CGAL_Nef_polyhedron3 &nef,
+                                     CGAL_Polyhedron &polyhedron);
 
 template <typename SurfaceMesh>
-void convertNefToSurfaceMesh(const CGAL_Nef_polyhedron3& nef, SurfaceMesh& mesh)
-{
+void convertNefToSurfaceMesh(const CGAL_Nef_polyhedron3 &nef,
+                             SurfaceMesh &mesh) {
   constexpr bool triangulate = false;
   CGAL::convert_nef_polyhedron_to_polygon_mesh(nef, mesh, triangulate);
 }
 
-void convertSurfaceMeshToNef(const CGAL_Kernel3Mesh& mesh, CGAL_Nef_polyhedron3& nef)
-{
+void convertSurfaceMeshToNef(const CGAL_Kernel3Mesh &mesh,
+                             CGAL_Nef_polyhedron3 &nef) {
   nef = CGAL_Nef_polyhedron3(mesh);
 }
 
-
 template <typename Polyhedron>
-bool createPolyhedronFromPolySet(const PolySet& ps, Polyhedron& p)
-{
+bool createPolyhedronFromPolySet(const PolySet &ps, Polyhedron &p) {
   bool err = false;
   try {
     CGAL_Build_PolySet<Polyhedron> builder(ps);
     p.delegate(builder);
-  } catch (const CGAL::Assertion_exception& e) {
-    LOG(message_group::Error, "CGAL error in CGALUtils::createPolyhedronFromPolySet: %1$s", e.what());
+  } catch (const CGAL::Assertion_exception &e) {
+    LOG(message_group::Error,
+        "CGAL error in CGALUtils::createPolyhedronFromPolySet: %1$s", e.what());
     err = true;
   }
   return err;
 }
 
-template bool createPolyhedronFromPolySet(const PolySet& ps, CGAL_Polyhedron& p);
-template bool createPolyhedronFromPolySet(const PolySet& ps, CGAL::Polyhedron_3<CGAL::Epick>& p);
+template bool createPolyhedronFromPolySet(const PolySet &ps,
+                                          CGAL_Polyhedron &p);
+template bool createPolyhedronFromPolySet(const PolySet &ps,
+                                          CGAL::Polyhedron_3<CGAL::Epick> &p);
 
 template <typename Polyhedron>
-std::unique_ptr<PolySet> createPolySetFromPolyhedron(const Polyhedron& p)
-{
+std::unique_ptr<PolySet> createPolySetFromPolyhedron(const Polyhedron &p) {
   using Vertex = typename Polyhedron::Vertex;
   using FCI = typename Polyhedron::Facet_const_iterator;
   using HFCC = typename Polyhedron::Halfedge_around_facet_const_circulator;
@@ -311,7 +329,7 @@ std::unique_ptr<PolySet> createPolySetFromPolyhedron(const Polyhedron& p)
     HFCC hc_end = hc;
     builder.beginPolygon(fi->facet_degree());
     do {
-      Vertex const& v = *((hc++)->vertex());
+      Vertex const &v = *((hc++)->vertex());
       double x = CGAL::to_double(v.point().x());
       double y = CGAL::to_double(v.point().y());
       double z = CGAL::to_double(v.point().z());
@@ -321,29 +339,27 @@ std::unique_ptr<PolySet> createPolySetFromPolyhedron(const Polyhedron& p)
   return builder.build();
 }
 
-template std::unique_ptr<PolySet> createPolySetFromPolyhedron(const CGAL_Polyhedron& p);
-template std::unique_ptr<PolySet> createPolySetFromPolyhedron(const CGAL::Polyhedron_3<CGAL::Epick>& p);
+template std::unique_ptr<PolySet>
+createPolySetFromPolyhedron(const CGAL_Polyhedron &p);
+template std::unique_ptr<PolySet>
+createPolySetFromPolyhedron(const CGAL::Polyhedron_3<CGAL::Epick> &p);
 
-class Polyhedron_writer
-{
+class Polyhedron_writer {
   std::ostream *out{nullptr};
   bool firstv{true};
   std::vector<int> indices;
+
 public:
   Polyhedron_writer() = default;
-  void write_header(std::ostream& stream,
-                    std::size_t /*vertices*/,
-                    std::size_t /*halfedges*/,
-                    std::size_t /*facets*/
+  void write_header(std::ostream &stream, std::size_t /*vertices*/,
+                    std::size_t /*halfedges*/, std::size_t /*facets*/
                     /*bool normals = false*/) {
     this->out = &stream;
     *out << "polyhedron(points=[";
     firstv = true;
   }
-  void write_footer() {
-    *out << "]);" << std::endl;
-  }
-  void write_vertex(const double& x, const double& y, const double& z) {
+  void write_footer() { *out << "]);" << std::endl; }
+  void write_vertex(const double &x, const double &y, const double &z) {
     *out << (firstv ? "" : ",") << '[' << x << ',' << y << ',' << z << ']';
     firstv = false;
   }
@@ -356,9 +372,7 @@ public:
     indices.clear();
     firstv = false;
   }
-  void write_facet_vertex_index(std::size_t index) {
-    indices.push_back(index);
-  }
+  void write_facet_vertex_index(std::size_t index) { indices.push_back(index); }
   void write_facet_end() {
     bool firsti = true;
     for (auto i : boost::adaptors::reverse(indices)) {
@@ -369,4 +383,4 @@ public:
   }
 };
 
-}  // namespace CGALUtils
+} // namespace CGALUtils
diff --git a/src/geometry/cgal/cgalutils-project.cc b/src/geometry/cgal/cgalutils-project.cc
index ab31eb4a2..60eecc1c8 100644
--- a/src/geometry/cgal/cgalutils-project.cc
+++ b/src/geometry/cgal/cgalutils-project.cc
@@ -3,17 +3,17 @@
 
 #ifdef ENABLE_CGAL
 
+#include "geometry/PolySet.h"
+#include "geometry/PolySetUtils.h"
+#include "geometry/Polygon2d.h"
 #include "geometry/cgal/cgal.h"
 #include "geometry/cgal/cgalutils.h"
-#include "geometry/PolySet.h"
 #include "utils/printutils.h"
-#include "geometry/Polygon2d.h"
-#include "geometry/PolySetUtils.h"
 
-#include <memory>
 #include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
-#include <CGAL/normal_vector_newell_3.h>
 #include <CGAL/Handle_hash_function.h>
+#include <CGAL/normal_vector_newell_3.h>
+#include <memory>
 
 #include <CGAL/config.h>
 #include <CGAL/version.h>
@@ -24,18 +24,19 @@
 
 #include <vector>
 
-static void add_outline_to_poly(CGAL_Nef_polyhedron2::Explorer& explorer,
-                                CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator circ,
-                                CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator end,
-                                bool positive,
-                                Polygon2d& poly) {
+static void add_outline_to_poly(
+    CGAL_Nef_polyhedron2::Explorer &explorer,
+    CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator circ,
+    CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator end,
+    bool positive, Polygon2d &poly) {
   Outline2d outline;
 
   CGAL_For_all(circ, end) {
     if (explorer.is_standard(explorer.target(circ))) {
-      CGAL_Nef_polyhedron2::Explorer::Point ep = explorer.point(explorer.target(circ));
-      outline.vertices.push_back(Vector2d(to_double(ep.x()),
-                                          to_double(ep.y())));
+      CGAL_Nef_polyhedron2::Explorer::Point ep =
+          explorer.point(explorer.target(circ));
+      outline.vertices.push_back(
+          Vector2d(to_double(ep.x()), to_double(ep.y())));
     }
   }
 
@@ -45,20 +46,26 @@ static void add_outline_to_poly(CGAL_Nef_polyhedron2::Explorer& explorer,
   }
 }
 
-static std::unique_ptr<Polygon2d> convertToPolygon2d(const CGAL_Nef_polyhedron2& p2)
-{
+static std::unique_ptr<Polygon2d>
+convertToPolygon2d(const CGAL_Nef_polyhedron2 &p2) {
   auto poly = std::make_unique<Polygon2d>();
 
   using Explorer = CGAL_Nef_polyhedron2::Explorer;
   using fci_t = Explorer::Face_const_iterator;
   using heafcc_t = Explorer::Halfedge_around_face_const_circulator;
   Explorer E = p2.explorer();
-  for (fci_t fit = E.faces_begin(), facesend = E.faces_end(); fit != facesend; ++fit) {
-    if (!fit->mark()) continue;
+  for (fci_t fit = E.faces_begin(), facesend = E.faces_end(); fit != facesend;
+       ++fit) {
+    if (!fit->mark())
+      continue;
     heafcc_t fcirc(E.face_cycle(fit)), fend(fcirc);
     add_outline_to_poly(E, fcirc, fend, true, *poly);
-    for (CGAL_Nef_polyhedron2::Explorer::Hole_const_iterator j = E.holes_begin(fit); j != E.holes_end(fit); ++j) {
-      CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator hcirc(j), hend(hcirc);
+    for (CGAL_Nef_polyhedron2::Explorer::Hole_const_iterator j =
+             E.holes_begin(fit);
+         j != E.holes_end(fit); ++j) {
+      CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator
+          hcirc(j),
+          hend(hcirc);
       add_outline_to_poly(E, hcirc, hend, false, *poly);
     }
   }
@@ -94,15 +101,13 @@ static std::unique_ptr<Polygon2d> convertToPolygon2d(const CGAL_Nef_polyhedron2&
    OGL_helper.h
  */
 
-class ZRemover
-{
+class ZRemover {
 public:
   CGAL_Nef_polyhedron2::Boundary boundary;
   std::shared_ptr<CGAL_Nef_polyhedron2> tmpnef2d;
   std::shared_ptr<CGAL_Nef_polyhedron2> output_nefpoly2d;
   CGAL::Direction_3<CGAL_Kernel3> up;
-  ZRemover()
-  {
+  ZRemover() {
     output_nefpoly2d = std::make_shared<CGAL_Nef_polyhedron2>();
     boundary = CGAL_Nef_polyhedron2::INCLUDED;
     up = CGAL::Direction_3<CGAL_Kernel3>(0, 0, 1);
@@ -115,9 +120,7 @@ public:
   void visit(CGAL_Nef_polyhedron3::Halffacet_const_handle hfacet);
 };
 
-
-void ZRemover::visit(CGAL_Nef_polyhedron3::Halffacet_const_handle hfacet)
-{
+void ZRemover::visit(CGAL_Nef_polyhedron3::Halffacet_const_handle hfacet) {
   PRINTDB(" <!-- ZRemover Halffacet visit. Mark: %i --> ", hfacet->mark());
   if (hfacet->plane().orthogonal_direction() != this->up) {
     PRINTD("  <!-- ZRemover down-facing half-facet. skipping -->");
@@ -132,25 +135,32 @@ void ZRemover::visit(CGAL_Nef_polyhedron3::Halffacet_const_handle hfacet)
   CGAL_forall_facet_cycles_of(fci, hfacet) {
     if (fci.is_shalfedge()) {
       PRINTD(" <!-- ZRemover Halffacet cycle begin -->");
-      CGAL_Nef_polyhedron3::SHalfedge_around_facet_const_circulator c1(fci), cend(c1);
+      CGAL_Nef_polyhedron3::SHalfedge_around_facet_const_circulator c1(fci),
+          cend(c1);
       std::vector<CGAL_Nef_polyhedron2::Explorer::Point> contour;
       CGAL_For_all(c1, cend) {
         CGAL_Nef_polyhedron3::Point_3 point3d = c1->source()->target()->point();
-        CGAL_Nef_polyhedron2::Explorer::Point point2d(CGAL::to_double(point3d.x()),
-                                                      CGAL::to_double(point3d.y()));
+        CGAL_Nef_polyhedron2::Explorer::Point point2d(
+            CGAL::to_double(point3d.x()), CGAL::to_double(point3d.y()));
         contour.push_back(point2d);
       }
-      if (contour.size() == 0) continue;
+      if (contour.size() == 0)
+        continue;
 
-      if (OpenSCAD::debug != "") PRINTDB(" <!-- is_simple_2: %i -->", CGAL::is_simple_2(contour.begin(), contour.end()));
+      if (OpenSCAD::debug != "")
+        PRINTDB(" <!-- is_simple_2: %i -->",
+                CGAL::is_simple_2(contour.begin(), contour.end()));
 
-      tmpnef2d = std::make_shared<CGAL_Nef_polyhedron2>(contour.begin(), contour.end(), boundary);
+      tmpnef2d = std::make_shared<CGAL_Nef_polyhedron2>(
+          contour.begin(), contour.end(), boundary);
 
       if (contour_counter == 0) {
-        PRINTDB(" <!-- contour is a body. make union(). %i points -->", contour.size());
+        PRINTDB(" <!-- contour is a body. make union(). %i points -->",
+                contour.size());
         *(output_nefpoly2d) += *(tmpnef2d);
       } else {
-        PRINTDB(" <!-- contour is a hole. make intersection(). %i points -->", contour.size());
+        PRINTDB(" <!-- contour is a hole. make intersection(). %i points -->",
+                contour.size());
         *(output_nefpoly2d) *= *(tmpnef2d);
       }
 
@@ -168,21 +178,21 @@ void ZRemover::visit(CGAL_Nef_polyhedron3::Halffacet_const_handle hfacet)
   PRINTD(" <!-- ZRemover Halffacet visit end -->");
 }
 
-
-
 namespace CGALUtils {
 
-std::unique_ptr<Polygon2d> project(const CGALNefGeometry& N, bool cut)
-{
+std::unique_ptr<Polygon2d> project(const CGALNefGeometry &N, bool cut) {
   std::unique_ptr<Polygon2d> poly;
-  if (N.getDimension() != 3) return poly;
+  if (N.getDimension() != 3)
+    return poly;
 
   CGALNefGeometry newN;
   if (cut) {
     try {
-      CGAL_Nef_polyhedron3::Plane_3 xy_plane = CGAL_Nef_polyhedron3::Plane_3(0, 0, 1, 0);
-      newN.p3 = std::make_shared<CGAL_Nef_polyhedron3>(N.p3->intersection(xy_plane, CGAL_Nef_polyhedron3::PLANE_ONLY));
-    } catch (const CGAL::Failure_exception& e) {
+      CGAL_Nef_polyhedron3::Plane_3 xy_plane =
+          CGAL_Nef_polyhedron3::Plane_3(0, 0, 1, 0);
+      newN.p3 = std::make_shared<CGAL_Nef_polyhedron3>(
+          N.p3->intersection(xy_plane, CGAL_Nef_polyhedron3::PLANE_ONLY));
+    } catch (const CGAL::Failure_exception &e) {
       PRINTDB("CGALUtils::project during plane intersection: %s", e.what());
       try {
         PRINTD("Trying alternative intersection using very large thin box: ");
@@ -191,17 +201,21 @@ std::unique_ptr<Polygon2d> project(const CGALNefGeometry& N, bool cut)
         double inf = 1e8;
         double eps = 0.001;
         CGAL_Point_3 minpt(-inf, -inf, -eps);
-        CGAL_Point_3 maxpt(inf,  inf,  eps);
+        CGAL_Point_3 maxpt(inf, inf, eps);
         CGAL_Iso_cuboid_3 bigcuboid(minpt, maxpt);
         pts.reserve(8);
-        for (int i = 0; i < 8; ++i) pts.push_back(bigcuboid.vertex(i));
+        for (int i = 0; i < 8; ++i)
+          pts.push_back(bigcuboid.vertex(i));
         CGAL_Polyhedron bigbox;
         CGAL::convex_hull_3(pts.begin(), pts.end(), bigbox);
         CGAL_Nef_polyhedron3 nef_bigbox(bigbox);
-        newN.p3 = std::make_shared<CGAL_Nef_polyhedron3>(nef_bigbox.intersection(*N.p3));
-      } catch (const CGAL::Failure_exception& e) {
-        LOG(message_group::Error, " CGAL error in CGALUtils::project during bigbox intersection: %1$s", e.what());
-
+        newN.p3 = std::make_shared<CGAL_Nef_polyhedron3>(
+            nef_bigbox.intersection(*N.p3));
+      } catch (const CGAL::Failure_exception &e) {
+        LOG(message_group::Error,
+            " CGAL error in CGALUtils::project during bigbox intersection: "
+            "%1$s",
+            e.what());
       }
     }
 
@@ -227,13 +241,15 @@ std::unique_ptr<Polygon2d> project(const CGALNefGeometry& N, bool cut)
         PRINTD("<!-- volume end. -->");
       }
       poly = convertToPolygon2d(*zremover.output_nefpoly2d);
-    } catch (const CGAL::Failure_exception& e) {
-      LOG(message_group::Error, "CGAL error in CGALUtils::project while flattening: %1$s", e.what());
+    } catch (const CGAL::Failure_exception &e) {
+      LOG(message_group::Error,
+          "CGAL error in CGALUtils::project while flattening: %1$s", e.what());
     }
     PRINTD("</svg>");
 
   }
-  // In projection mode all the triangles are projected manually into the XY plane
+  // In projection mode all the triangles are projected manually into the XY
+  // plane
   else {
     if (auto ps = CGALUtils::createPolySetFromNefPolyhedron3(*N.p3)) {
       poly = PolySetUtils::project(*ps);
@@ -245,6 +261,6 @@ std::unique_ptr<Polygon2d> project(const CGALNefGeometry& N, bool cut)
   return poly;
 }
 
-} // namespace
+} // namespace CGALUtils
 
 #endif // ENABLE_CGAL
diff --git a/src/geometry/cgal/cgalutils-tess.cc b/src/geometry/cgal/cgalutils-tess.cc
index 7761a433c..87278f494 100644
--- a/src/geometry/cgal/cgalutils-tess.cc
+++ b/src/geometry/cgal/cgalutils-tess.cc
@@ -1,15 +1,16 @@
 #include "geometry/cgal/cgalutils.h"
 #include "utils/printutils.h"
-#include <list>
 #include <cstddef>
-//#include "geometry/cgal/cgal.h"
-//#include "libtess2/Source/tess.h"
+#include <list>
+// #include "geometry/cgal/cgal.h"
+// #include "libtess2/Source/tess.h"
 
 #include <CGAL/Constrained_Delaunay_triangulation_2.h>
 #if CGAL_VERSION_NR < CGAL_VERSION_NUMBER(5, 4, 0)
 #include <CGAL/Triangulation_2_projection_traits_3.h>
 using Tess_kernel = CGAL::Epick;
-using Projection = CGAL::Triangulation_2_filtered_projection_traits_3<Tess_kernel>;
+using Projection =
+    CGAL::Triangulation_2_filtered_projection_traits_3<Tess_kernel>;
 #else
 #include <CGAL/Projection_traits_3.h>
 using Tess_kernel = CGAL::Epick;
@@ -23,16 +24,17 @@ struct FaceInfo {
 };
 
 using Fbb = CGAL::Triangulation_face_base_with_info_2<FaceInfo, Tess_kernel>;
-using Tds = CGAL::Triangulation_data_structure_2<CGAL::Triangulation_vertex_base_2<Projection>, CGAL::Constrained_triangulation_face_base_2<Projection, Fbb>>;
-using CDT = CGAL::Constrained_Delaunay_triangulation_2<Projection, Tds, CGAL::Exact_predicates_tag>;
-
-
-static void mark_domains(CDT& ct,
-                         CDT::Face_handle start,
-                         int index,
-                         std::list<CDT::Edge>& border)
-{
-  if (start->info().nesting_level != -1) return;
+using Tds = CGAL::Triangulation_data_structure_2<
+    CGAL::Triangulation_vertex_base_2<Projection>,
+    CGAL::Constrained_triangulation_face_base_2<Projection, Fbb>>;
+using CDT =
+    CGAL::Constrained_Delaunay_triangulation_2<Projection, Tds,
+                                               CGAL::Exact_predicates_tag>;
+
+static void mark_domains(CDT &ct, CDT::Face_handle start, int index,
+                         std::list<CDT::Edge> &border) {
+  if (start->info().nesting_level != -1)
+    return;
   std::list<CDT::Face_handle> queue;
   queue.push_back(start);
   while (!queue.empty()) {
@@ -44,24 +46,25 @@ static void mark_domains(CDT& ct,
         CDT::Edge e(fh, i);
         CDT::Face_handle n = fh->neighbor(i);
         if (n->info().nesting_level == -1) {
-          if (ct.is_constrained(e)) border.push_back(e);
-          else queue.push_back(n);
+          if (ct.is_constrained(e))
+            border.push_back(e);
+          else
+            queue.push_back(n);
         }
       }
     }
   }
 }
 
-
-//explore set of facets connected with non constrained edges,
-//and attribute to each such set a nesting level.
-//We start from facets incident to the infinite vertex, with a nesting
-//level of 0. Then we recursively consider the non-explored facets incident
-//to constrained edges bounding the former set and increase the nesting level by 1.
-//Facets in the domain are those with an odd nesting level.
-static void mark_domains(CDT& cdt)
-{
-  for (CDT::All_faces_iterator it = cdt.all_faces_begin(); it != cdt.all_faces_end(); ++it) {
+// explore set of facets connected with non constrained edges,
+// and attribute to each such set a nesting level.
+// We start from facets incident to the infinite vertex, with a nesting
+// level of 0. Then we recursively consider the non-explored facets incident
+// to constrained edges bounding the former set and increase the nesting level
+// by 1. Facets in the domain are those with an odd nesting level.
+static void mark_domains(CDT &cdt) {
+  for (CDT::All_faces_iterator it = cdt.all_faces_begin();
+       it != cdt.all_faces_end(); ++it) {
     it->info().nesting_level = -1;
   }
   std::list<CDT::Edge> border;
@@ -82,30 +85,33 @@ namespace CGALUtils {
    should be added as a separate PolygonK instance.
    The tessellator will handle almost planar polygons.
 
-   If the normal is given, we will assume this as the normal vector of the polygon.
-   Otherwise, we will try to calculate it using Newell's method.
+   If the normal is given, we will assume this as the normal vector of the
+   polygon. Otherwise, we will try to calculate it using Newell's method.
 
    The resulting triangles is added to the given triangles vector.
  */
-bool tessellatePolygonWithHoles(const std::vector<std::vector<CGAL::Point_3<CGAL::Epick>>>& polygons,
-                                Polygons& triangles,
-                                const CGAL::Vector_3<CGAL::Epick> *normal)
-{
+bool tessellatePolygonWithHoles(
+    const std::vector<std::vector<CGAL::Point_3<CGAL::Epick>>> &polygons,
+    Polygons &triangles, const CGAL::Vector_3<CGAL::Epick> *normal) {
   // No polygon. FIXME: Will this ever happen or can we assert here?
-  if (polygons.empty()) return false;
+  if (polygons.empty())
+    return false;
 
   // No hole
-  if (polygons.size() == 1) return tessellatePolygon(polygons.front(), triangles, normal);
+  if (polygons.size() == 1)
+    return tessellatePolygon(polygons.front(), triangles, normal);
 
   CGAL::Vector_3<CGAL::Epick> normalvec;
   if (normal) {
     normalvec = *normal;
   } else {
     // Calculate best guess at face normal using Newell's method
-    CGAL::normal_vector_newell_3(polygons.front().begin(), polygons.front().end(), normalvec);
+    CGAL::normal_vector_newell_3(polygons.front().begin(),
+                                 polygons.front().end(), normalvec);
   }
   double sqrl = normalvec.squared_length();
-  if (sqrl > 0.0) normalvec = normalvec / sqrt(sqrl);
+  if (sqrl > 0.0)
+    normalvec = normalvec / sqrt(sqrl);
 
   // Pass the normal vector to the (undocumented)
   // CGAL::Triangulation_2_filtered_projection_traits_3. This
@@ -114,13 +120,13 @@ bool tessellatePolygonWithHoles(const std::vector<std::vector<CGAL::Point_3<CGAL
   // the Constrained Delaunay Triangulator.
   Projection actualProjection(normalvec);
   CDT cdt(actualProjection);
-  for (const auto& poly : polygons) {
+  for (const auto &poly : polygons) {
     for (size_t i = 0; i < poly.size(); ++i) {
       cdt.insert_constraint(poly[i], poly[(i + 1) % poly.size()]);
     }
   }
 
-  //Mark facets that are inside the domain bounded by the polygon
+  // Mark facets that are inside the domain bounded by the polygon
   mark_domains(cdt);
 
   // Iterate over the resulting faces
@@ -139,10 +145,9 @@ bool tessellatePolygonWithHoles(const std::vector<std::vector<CGAL::Point_3<CGAL
   return false;
 }
 
-bool tessellatePolygon(const std::vector<CGAL::Point_3<CGAL::Epick>>& polygon,
-                       Polygons& triangles,
-                       const CGAL::Vector_3<CGAL::Epick> *normal)
-{
+bool tessellatePolygon(const std::vector<CGAL::Point_3<CGAL::Epick>> &polygon,
+                       Polygons &triangles,
+                       const CGAL::Vector_3<CGAL::Epick> *normal) {
   if (polygon.size() == 3) {
     PRINTD("input polygon has 3 points. shortcut tessellation.");
     Polygon t;
@@ -161,7 +166,8 @@ bool tessellatePolygon(const std::vector<CGAL::Point_3<CGAL::Epick>>& polygon,
     CGAL::normal_vector_newell_3(polygon.begin(), polygon.end(), normalvec);
   }
   double sqrl = normalvec.squared_length();
-  if (sqrl > 0.0) normalvec = normalvec / sqrt(sqrl);
+  if (sqrl > 0.0)
+    normalvec = normalvec / sqrt(sqrl);
 
   // Pass the normal vector to the (undocumented)
   // CGAL::Triangulation_2_filtered_projection_traits_3. This
@@ -174,7 +180,7 @@ bool tessellatePolygon(const std::vector<CGAL::Point_3<CGAL::Epick>>& polygon,
     cdt.insert_constraint(polygon[i], polygon[(i + 1) % polygon.size()]);
   }
 
-  //Mark facets that are inside the domain bounded by the polygon
+  // Mark facets that are inside the domain bounded by the polygon
   mark_domains(cdt);
 
   // Iterate over the resulting faces
@@ -193,4 +199,4 @@ bool tessellatePolygon(const std::vector<CGAL::Point_3<CGAL::Epick>>& polygon,
   return false;
 }
 
-}  // namespace CGALUtils
+} // namespace CGALUtils
diff --git a/src/geometry/cgal/cgalutils-triangulate.cc b/src/geometry/cgal/cgalutils-triangulate.cc
index b8ce0bbfe..d90ef9aaf 100644
--- a/src/geometry/cgal/cgalutils-triangulate.cc
+++ b/src/geometry/cgal/cgalutils-triangulate.cc
@@ -1,4 +1,5 @@
-// Portions of this file are Copyright 2021 Google LLC, and licensed under GPL2+. See COPYING.
+// Portions of this file are Copyright 2021 Google LLC, and licensed under
+// GPL2+. See COPYING.
 #include "geometry/cgal/cgalutils.h"
 
 #include <cassert>
@@ -20,8 +21,7 @@ namespace CGALUtils {
 
 namespace Polygon2DCGAL {
 
-struct FaceInfo
-{
+struct FaceInfo {
   FaceInfo() = default;
   int nesting_level{42};
   [[nodiscard]] bool in_domain() const { return nesting_level % 2 == 1; }
@@ -41,13 +41,10 @@ using CDT = CGAL::Constrained_Delaunay_triangulation_2<K, TDS, Itag>;
 using Point = CDT::Point;
 using Polygon_2 = CGAL::Polygon_2<K>;
 
-void
-mark_domains(CDT& ct,
-             CDT::Face_handle start,
-             int index,
-             std::list<CDT::Edge>& border)
-{
-  if (start->info().nesting_level != -1) return;
+void mark_domains(CDT &ct, CDT::Face_handle start, int index,
+                  std::list<CDT::Edge> &border) {
+  if (start->info().nesting_level != -1)
+    return;
 
   std::list<CDT::Face_handle> queue;
   queue.push_back(start);
@@ -61,8 +58,10 @@ mark_domains(CDT& ct,
         CDT::Edge e(fh, i);
         auto n = fh->neighbor(i);
         if (n->info().nesting_level == -1) {
-          if (ct.is_constrained(e)) border.push_back(e);
-          else queue.push_back(n);
+          if (ct.is_constrained(e))
+            border.push_back(e);
+          else
+            queue.push_back(n);
         }
       }
     }
@@ -73,12 +72,11 @@ mark_domains(CDT& ct,
 // and attribute to each such set a nesting level.
 // We start from facets incident to the infinite vertex, with a nesting
 // level of 0. Then we recursively consider the non-explored facets incident
-// to constrained edges bounding the former set and increase the nesting level by 1.
-// Facets in the domain are those with an odd nesting level.
-void
-mark_domains(CDT& cdt)
-{
-  for (CDT::All_faces_iterator it = cdt.all_faces_begin(); it != cdt.all_faces_end(); ++it) {
+// to constrained edges bounding the former set and increase the nesting level
+// by 1. Facets in the domain are those with an odd nesting level.
+void mark_domains(CDT &cdt) {
+  for (CDT::All_faces_iterator it = cdt.all_faces_begin();
+       it != cdt.all_faces_end(); ++it) {
     it->info().nesting_level = -1;
   }
 
@@ -97,16 +95,15 @@ mark_domains(CDT& cdt)
 
 } // namespace Polygon2DCGAL
 
-template <typename SurfaceMesh>
-void triangulateFaces(SurfaceMesh& mesh)
-{
+template <typename SurfaceMesh> void triangulateFaces(SurfaceMesh &mesh) {
   CGAL::Polygon_mesh_processing::triangulate_faces(mesh);
 }
 
-template void triangulateFaces(CGAL::Surface_mesh<CGAL::Point_3<CGAL::Epick>>& polyhedron);
+template void
+triangulateFaces(CGAL::Surface_mesh<CGAL::Point_3<CGAL::Epick>> &polyhedron);
 
-std::unique_ptr<PolySet> createTriangulatedPolySetFromPolygon2d(const Polygon2d& polygon2d)
-{
+std::unique_ptr<PolySet>
+createTriangulatedPolySetFromPolygon2d(const Polygon2d &polygon2d) {
   auto polyset = std::make_unique<PolySet>(2);
   polyset->setTriangular(true);
 
@@ -114,27 +111,28 @@ std::unique_ptr<PolySet> createTriangulatedPolySetFromPolygon2d(const Polygon2d&
 
   try {
     // Adds all vertices, and add all contours as constraints.
-    for (const auto& outline : polygon2d.outlines()) {
+    for (const auto &outline : polygon2d.outlines()) {
       Polygon2DCGAL::CDT::Vertex_handle prev;
       for (int i = 0; i <= outline.vertices.size(); i++) {
         const int idx = i % outline.vertices.size();
-        const auto& v = outline.vertices[idx];
+        const auto &v = outline.vertices[idx];
         auto curr = cdt.insert({v[0], v[1]});
-        // FIXME: We need be make sure that client relying on vertex indices being
-        // maintained also skips coincident vertices the same way.
+        // FIXME: We need be make sure that client relying on vertex indices
+        // being maintained also skips coincident vertices the same way.
         if (curr != prev) {
           // Don't add the first vertex twice
           if (i < outline.vertices.size()) {
             polyset->vertices.emplace_back(v[0], v[1], 0.0);
             curr->info().id = polyset->vertices.size() - 1;
           }
-          if (prev != nullptr) cdt.insert_constraint(prev, curr);
+          if (prev != nullptr)
+            cdt.insert_constraint(prev, curr);
           prev = curr;
         }
       }
     }
 
-  } catch (const CGAL::Precondition_exception& e) {
+  } catch (const CGAL::Precondition_exception &e) {
     LOG("CGAL error in Polygon2d::tesselate(): %1$s", e.what());
     return nullptr;
   }
@@ -142,25 +140,25 @@ std::unique_ptr<PolySet> createTriangulatedPolySetFromPolygon2d(const Polygon2d&
   // To extract triangles which is part of our polygon, we need to filter away
   // triangles inside holes.
   mark_domains(cdt);
-  for (auto fit = cdt.finite_faces_begin(); fit != cdt.finite_faces_end(); ++fit) {
+  for (auto fit = cdt.finite_faces_begin(); fit != cdt.finite_faces_end();
+       ++fit) {
     if (fit->info().in_domain()) {
       // If this assert hits, it means that the polygon2d somehow contains
       // self-intersecting or intersecting constraints. This shouldn't happen
       // since Clipper guarantees no overlaps, but could happen if we lose
-      // precision from converting from Clipper's coordinate space (int64) to Polygon2's (double).
-      // One possible workaround is to reduce Clipper's precision further,
-      // see https://github.com/openscad/openscad/issues/5253.
+      // precision from converting from Clipper's coordinate space (int64) to
+      // Polygon2's (double). One possible workaround is to reduce Clipper's
+      // precision further, see
+      // https://github.com/openscad/openscad/issues/5253.
       assert(fit->vertex(0)->info().id != -1);
       assert(fit->vertex(1)->info().id != -1);
       assert(fit->vertex(2)->info().id != -1);
-      polyset->indices.push_back({
-          fit->vertex(0)->info().id,
-          fit->vertex(1)->info().id,
-          fit->vertex(2)->info().id});
+      polyset->indices.push_back({fit->vertex(0)->info().id,
+                                  fit->vertex(1)->info().id,
+                                  fit->vertex(2)->info().id});
     }
   }
   return polyset;
 }
 
 } // namespace CGALUtils
-
diff --git a/src/geometry/cgal/cgalutils.cc b/src/geometry/cgal/cgalutils.cc
index 4d91fb033..64b15cdff 100644
--- a/src/geometry/cgal/cgalutils.cc
+++ b/src/geometry/cgal/cgalutils.cc
@@ -2,32 +2,32 @@
 // in order to workaround gcc 4.9.1 crashing on systems with only 2GB of RAM
 #include "geometry/cgal/cgalutils.h"
 
+#include "core/node.h"
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
-#include "geometry/cgal/cgal.h"
 #include "geometry/PolySet.h"
-#include "utils/printutils.h"
-#include "geometry/Polygon2d.h"
 #include "geometry/PolySetUtils.h"
-#include "core/node.h"
+#include "geometry/Polygon2d.h"
+#include "geometry/cgal/cgal.h"
+#include "geometry/linalg.h"
 #include "utils/degree_trig.h"
+#include "utils/printutils.h"
 
-#include <cassert>
-#include <set>
-#include <utility>
-#include <memory>
 #include <CGAL/Aff_transformation_3.h>
-#include <CGAL/normal_vector_newell_3.h>
 #include <CGAL/Handle_hash_function.h>
 #include <CGAL/Surface_mesh.h>
+#include <CGAL/normal_vector_newell_3.h>
+#include <cassert>
+#include <memory>
+#include <set>
+#include <utility>
 
 #include <CGAL/config.h>
 #include <CGAL/version.h>
 
 #include <CGAL/convex_hull_3.h>
 
-#include "geometry/Reindexer.h"
 #include "geometry/GeometryUtils.h"
+#include "geometry/Reindexer.h"
 #ifdef ENABLE_MANIFOLD
 #include "geometry/manifold/ManifoldGeometry.h"
 #endif
@@ -39,12 +39,13 @@
 
 namespace CGALUtils {
 
-// TODO: We could rewrite this to use PolygonMeshProcessing concepts, similar to how
-// we create Manifold geometries from PolySet; convert via Surface_mesh, check if it's closed,
-// use repair|orient_polygon_soup, etc.
-std::unique_ptr<CGALNefGeometry> createNefPolyhedronFromPolySet(const PolySet& ps)
-{
-  if (ps.isEmpty()) return std::make_unique<CGALNefGeometry>();
+// TODO: We could rewrite this to use PolygonMeshProcessing concepts, similar to
+// how we create Manifold geometries from PolySet; convert via Surface_mesh,
+// check if it's closed, use repair|orient_polygon_soup, etc.
+std::unique_ptr<CGALNefGeometry>
+createNefPolyhedronFromPolySet(const PolySet &ps) {
+  if (ps.isEmpty())
+    return std::make_unique<CGALNefGeometry>();
   assert(ps.getDimension() == 3);
 
   // Since is_convex doesn't work well with non-planar faces,
@@ -61,14 +62,16 @@ std::unique_ptr<CGALNefGeometry> createNefPolyhedronFromPolySet(const PolySet& p
       points[i] = vector_convert<Hull_kernel::Point_3>(points3d[i]);
     }
 
-    if (points.size() <= 3) return std::make_unique<CGALNefGeometry>();
+    if (points.size() <= 3)
+      return std::make_unique<CGALNefGeometry>();
 
     // Apply hull
     CGAL::Polyhedron_3<Hull_kernel> r;
     CGAL::convex_hull_3(points.begin(), points.end(), r);
     CGAL_Polyhedron r_exact;
     CGALUtils::copyPolyhedron(r, r_exact);
-    return std::make_unique<CGALNefGeometry>(std::make_shared<CGAL_Nef_polyhedron3>(r_exact));
+    return std::make_unique<CGALNefGeometry>(
+        std::make_shared<CGAL_Nef_polyhedron3>(r_exact));
   }
 
   std::shared_ptr<CGAL_Nef_polyhedron3> N;
@@ -78,54 +81,64 @@ std::unique_ptr<CGALNefGeometry> createNefPolyhedronFromPolySet(const PolySet& p
     auto err = CGALUtils::createPolyhedronFromPolySet(psq, P);
     if (!err) {
       if (!P.is_closed()) {
-        LOG(message_group::Error, "The given mesh is not closed! Unable to convert to CGALNefGeometry.");
+        LOG(message_group::Error, "The given mesh is not closed! Unable to "
+                                  "convert to CGALNefGeometry.");
       } else if (!P.is_valid(false, 0)) {
-        LOG(message_group::Error, "The given mesh is invalid! Unable to convert to CGALNefGeometry.");
+        LOG(message_group::Error,
+            "The given mesh is invalid! Unable to convert to CGALNefGeometry.");
       } else {
         N = std::make_shared<CGAL_Nef_polyhedron3>(P);
       }
     }
-  } catch (const CGAL::Assertion_exception& e) {
-    // First two tests matches against CGAL < 4.10, the last two tests matches against CGAL >= 4.10
+  } catch (const CGAL::Assertion_exception &e) {
+    // First two tests matches against CGAL < 4.10, the last two tests matches
+    // against CGAL >= 4.10
     if ((std::string(e.what()).find("Plane_constructor") != std::string::npos &&
          std::string(e.what()).find("has_on") != std::string::npos) ||
-        std::string(e.what()).find("ss_plane.has_on(sv_prev->point())") != std::string::npos ||
-        std::string(e.what()).find("ss_circle.has_on(sp)") != std::string::npos) {
+        std::string(e.what()).find("ss_plane.has_on(sv_prev->point())") !=
+            std::string::npos ||
+        std::string(e.what()).find("ss_circle.has_on(sp)") !=
+            std::string::npos) {
       LOG("PolySet has nonplanar faces. Attempting alternate construction");
       plane_error = true;
     } else {
-      LOG(message_group::Error, "CGAL error in CGAL_Nef_polyhedron3(): %1$s", e.what());
+      LOG(message_group::Error, "CGAL error in CGAL_Nef_polyhedron3(): %1$s",
+          e.what());
     }
   }
-  if (plane_error) try {
+  if (plane_error)
+    try {
       CGAL_Polyhedron P;
       auto err = CGALUtils::createPolyhedronFromPolySet(*ps_tri, P);
       if (!err) {
         PRINTDB("Polyhedron is closed: %d", P.is_closed());
         PRINTDB("Polyhedron is valid: %d", P.is_valid(false, 0));
       }
-      if (!err) N = std::make_shared<CGAL_Nef_polyhedron3>(P);
-    } catch (const CGAL::Assertion_exception& e) {
-      LOG(message_group::Error, "Alternate construction failed. CGAL error in CGAL_Nef_polyhedron3(): %1$s", e.what());
+      if (!err)
+        N = std::make_shared<CGAL_Nef_polyhedron3>(P);
+    } catch (const CGAL::Assertion_exception &e) {
+      LOG(message_group::Error,
+          "Alternate construction failed. CGAL error in "
+          "CGAL_Nef_polyhedron3(): %1$s",
+          e.what());
     }
   return std::make_unique<CGALNefGeometry>(N);
 }
 
 template <typename K>
-CGAL::Iso_cuboid_3<K> boundingBox(const CGAL::Nef_polyhedron_3<K>& N)
-{
+CGAL::Iso_cuboid_3<K> boundingBox(const CGAL::Nef_polyhedron_3<K> &N) {
   CGAL::Iso_cuboid_3<K> result(0, 0, 0, 0, 0, 0);
   typename CGAL::Nef_polyhedron_3<K>::Vertex_const_iterator vi;
   std::vector<typename CGAL::Point_3<K>> points;
   // can be optimized by rewriting bounding_box to accept vertices
   CGAL_forall_vertices(vi, N) points.push_back(vi->point());
-  if (points.size()) result = CGAL::bounding_box(points.begin(), points.end());
+  if (points.size())
+    result = CGAL::bounding_box(points.begin(), points.end());
   return result;
 }
-template CGAL_Iso_cuboid_3 boundingBox(const CGAL_Nef_polyhedron3& N);
+template CGAL_Iso_cuboid_3 boundingBox(const CGAL_Nef_polyhedron3 &N);
 
-CGAL_Iso_cuboid_3 createIsoCuboidFromBoundingBox(const BoundingBox& bbox)
-{
+CGAL_Iso_cuboid_3 createIsoCuboidFromBoundingBox(const BoundingBox &bbox) {
   return {vector_convert<CGAL_Point_3>(bbox.min()),
           vector_convert<CGAL_Point_3>(bbox.max())};
 }
@@ -133,32 +146,33 @@ CGAL_Iso_cuboid_3 createIsoCuboidFromBoundingBox(const BoundingBox& bbox)
 namespace {
 
 // lexicographic comparison
-bool operator<(Vector3d const& a, Vector3d const& b) {
+bool operator<(Vector3d const &a, Vector3d const &b) {
   for (int i = 0; i < 3; ++i) {
-    if (a[i] < b[i]) return true;
-    else if (a[i] == b[i]) continue;
+    if (a[i] < b[i])
+      return true;
+    else if (a[i] == b[i])
+      continue;
     return false;
   }
   return false;
 }
-}
+} // namespace
 
 struct VecPairCompare {
-  bool operator()(std::pair<Vector3d, Vector3d> const& a,
-                  std::pair<Vector3d, Vector3d> const& b) const {
+  bool operator()(std::pair<Vector3d, Vector3d> const &a,
+                  std::pair<Vector3d, Vector3d> const &b) const {
     return a.first < b.first || (!(b.first < a.first) && a.second < b.second);
   }
 };
 
-
 /*!
    Check if all faces of a polyset is within 0.1 degree of being convex.
 
    NB! This function can give false positives if the polyset contains
-   non-planar faces. To be on the safe side, consider passing a tessellated polyset.
-   See issue #1061.
+   non-planar faces. To be on the safe side, consider passing a tessellated
+   polyset. See issue #1061.
  */
-bool is_approximately_convex(const PolySet& ps) {
+bool is_approximately_convex(const PolySet &ps) {
 
   const double angle_threshold = cos_degrees(.1); // .1°
 
@@ -181,8 +195,10 @@ bool is_approximately_convex(const PolySet& ps) {
       std::vector<Point> v(N);
       for (size_t j = 0; j < N; ++j) {
         v[j] = vector_convert<Point>(ps.vertices[ps.indices[i][j]]);
-        Edge edge(ps.vertices[ps.indices[i][j]], ps.vertices[ps.indices[i][(j + 1) % N]]);
-        if (edge_to_facet_map.count(edge)) return false; // edge already exists: nonmanifold
+        Edge edge(ps.vertices[ps.indices[i][j]],
+                  ps.vertices[ps.indices[i][(j + 1) % N]]);
+        if (edge_to_facet_map.count(edge))
+          return false; // edge already exists: nonmanifold
         edge_to_facet_map[edge] = i;
       }
       Vector normal;
@@ -194,21 +210,24 @@ bool is_approximately_convex(const PolySet& ps) {
 
   for (size_t i = 0; i < ps.indices.size(); ++i) {
     auto N = ps.indices[i].size();
-    if (N < 3) continue;
+    if (N < 3)
+      continue;
     for (size_t j = 0; j < N; ++j) {
-      Edge other_edge(ps.vertices[ps.indices[i][(j + 1) % N]], ps.vertices[ps.indices[i][j]]);
-      if (edge_to_facet_map.count(other_edge) == 0) return false; //
-      //Edge_to_facet_map::const_iterator it = edge_to_facet_map.find(other_edge);
-      //if (it == edge_to_facet_map.end()) return false; // not a closed manifold
-      //int other_facet = it->second;
+      Edge other_edge(ps.vertices[ps.indices[i][(j + 1) % N]],
+                      ps.vertices[ps.indices[i][j]]);
+      if (edge_to_facet_map.count(other_edge) == 0)
+        return false; //
+      // Edge_to_facet_map::const_iterator it =
+      // edge_to_facet_map.find(other_edge); if (it == edge_to_facet_map.end())
+      // return false; // not a closed manifold int other_facet = it->second;
       int other_facet = edge_to_facet_map[other_edge];
 
       auto p = vector_convert<Point>(ps.vertices[ps.indices[i][(j + 2) % N]]);
 
       if (facet_planes[other_facet].has_on_positive_side(p)) {
         // Check angle
-        const auto& u = facet_planes[other_facet].orthogonal_vector();
-        const auto& v = facet_planes[i].orthogonal_vector();
+        const auto &u = facet_planes[other_facet].orthogonal_vector();
+        const auto &v = facet_planes[i].orthogonal_vector();
 
         double cos_angle = u / sqrt(u * u) * v / sqrt(v * v);
         if (cos_angle < angle_threshold) {
@@ -224,12 +243,15 @@ bool is_approximately_convex(const PolySet& ps) {
   explored_facets.insert(0);
 
   while (!facets_to_visit.empty()) {
-    int f = facets_to_visit.front(); facets_to_visit.pop();
+    int f = facets_to_visit.front();
+    facets_to_visit.pop();
 
     for (size_t i = 0; i < ps.indices[f].size(); ++i) {
       int j = (i + 1) % ps.indices[f].size();
-      auto it = edge_to_facet_map.find(Edge(ps.vertices[ps.indices[f][j]], ps.vertices[ps.indices[f][i]]));
-      if (it == edge_to_facet_map.end()) return false; // Nonmanifold
+      auto it = edge_to_facet_map.find(
+          Edge(ps.vertices[ps.indices[f][j]], ps.vertices[ps.indices[f][i]]));
+      if (it == edge_to_facet_map.end())
+        return false; // Nonmanifold
       if (!explored_facets.count(it->second)) {
         explored_facets.insert(it->second);
         facets_to_visit.push(it->second);
@@ -241,18 +263,23 @@ bool is_approximately_convex(const PolySet& ps) {
   return explored_facets.size() == ps.indices.size();
 }
 
-std::shared_ptr<const CGALNefGeometry> getNefPolyhedronFromGeometry(const std::shared_ptr<const Geometry>& geom)
-{
+std::shared_ptr<const CGALNefGeometry>
+getNefPolyhedronFromGeometry(const std::shared_ptr<const Geometry> &geom) {
   if (auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
-    return std::shared_ptr<CGALNefGeometry>(createNefPolyhedronFromPolySet(*ps));
+    return std::shared_ptr<CGALNefGeometry>(
+        createNefPolyhedronFromPolySet(*ps));
   } else if (auto poly2d = std::dynamic_pointer_cast<const Polygon2d>(geom)) {
     std::shared_ptr<PolySet> ps(poly2d->tessellate());
-    return std::shared_ptr<CGALNefGeometry>(createNefPolyhedronFromPolySet(*ps));
-  } else if (auto nef = std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
+    return std::shared_ptr<CGALNefGeometry>(
+        createNefPolyhedronFromPolySet(*ps));
+  } else if (auto nef =
+                 std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
     return nef;
 #if ENABLE_MANIFOLD
-  } else if (auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
-    return std::shared_ptr<CGALNefGeometry>(createNefPolyhedronFromPolySet(*mani->toPolySet()));
+  } else if (auto mani =
+                 std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
+    return std::shared_ptr<CGALNefGeometry>(
+        createNefPolyhedronFromPolySet(*mani->toPolySet()));
 #endif
   }
   return nullptr;
@@ -265,8 +292,8 @@ std::shared_ptr<const CGALNefGeometry> getNefPolyhedronFromGeometry(const std::s
    formats) do not allow for holes in their faces. The function documents
    the method used to deal with this
  */
-std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3(const CGAL_Nef_polyhedron3& N)
-{
+std::unique_ptr<PolySet>
+createPolySetFromNefPolyhedron3(const CGAL_Nef_polyhedron3 &N) {
   // 1. Build Indexed PolyMesh
   // 2. Validate mesh (manifoldness)
   // 3. Triangulate each face
@@ -283,11 +310,11 @@ std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3(const CGAL_Nef_polyhedr
   typename Nef::Halffacet_const_iterator hfaceti;
   CGAL_forall_halffacets(hfaceti, N) {
     Nef::Plane_3 plane(hfaceti->plane());
-    // Since we're downscaling to float, vertices might merge during this conversion.
-    // To avoid passing equal vertices to the tessellator, we remove consecutively identical
-    // vertices.
+    // Since we're downscaling to float, vertices might merge during this
+    // conversion. To avoid passing equal vertices to the tessellator, we remove
+    // consecutively identical vertices.
     polygons.emplace_back();
-    auto& faces = polygons.back();
+    auto &faces = polygons.back();
     // the 0-mark-volume is the 'empty' volume of space. skip it.
     if (!hfaceti->incident_volume()->mark()) {
       typename Nef::Halffacet_cycle_const_iterator cyclei;
@@ -295,30 +322,35 @@ std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3(const CGAL_Nef_polyhedr
         typename Nef::SHalfedge_around_facet_const_circulator c1(cyclei);
         typename Nef::SHalfedge_around_facet_const_circulator c2(c1);
         faces.push_back(IndexedFace());
-        auto& currface = faces.back();
+        auto &currface = faces.back();
         CGAL_For_all(c1, c2) {
           auto p = c1->source()->center_vertex()->point();
           // Create vertex indices and remove consecutive duplicate vertices
           auto idx = allVertices.lookup(vector_convert<Vector3f>(p));
-          if (currface.empty() || idx != currface.back()) currface.push_back(idx);
+          if (currface.empty() || idx != currface.back())
+            currface.push_back(idx);
         }
-        if (!currface.empty() && currface.front() == currface.back()) currface.pop_back();
-        if (currface.size() < 3) faces.pop_back(); // Cull empty triangles
+        if (!currface.empty() && currface.front() == currface.back())
+          currface.pop_back();
+        if (currface.size() < 3)
+          faces.pop_back(); // Cull empty triangles
       }
     }
-    if (faces.empty()) polygons.pop_back(); // Cull empty faces
+    if (faces.empty())
+      polygons.pop_back(); // Cull empty faces
   }
 
   // 2. Validate mesh (manifoldness)
   auto unconnected = GeometryUtils::findUnconnectedEdges(polygons);
   if (unconnected > 0) {
-    LOG(message_group::Error, "Non-manifold mesh encountered: %1$d unconnected edges", unconnected);
+    LOG(message_group::Error,
+        "Non-manifold mesh encountered: %1$d unconnected edges", unconnected);
   }
   // 3. Triangulate each face
-  const auto& verts = allVertices.getArray();
+  const auto &verts = allVertices.getArray();
   std::vector<IndexedTriangle> allTriangles;
-  for (const auto& faces : polygons) {
-#if 0 // For debugging
+  for (const auto &faces : polygons) {
+#if 0  // For debugging
     std::cerr << "---\n";
     for (const auto& poly : faces) {
       for (auto i : poly) {
@@ -326,7 +358,7 @@ std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3(const CGAL_Nef_polyhedr
       }
       std::cerr << "\n";
     }
-#if 0 // debug
+#if 0  // debug
     std::cerr.precision(20);
     for (const auto& poly : faces) {
       for (auto i : poly) {
@@ -337,7 +369,7 @@ std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3(const CGAL_Nef_polyhedr
 #endif // debug
     std::cerr << "-\n";
 #endif // debug
-#if 0 // For debugging
+#if 0  // For debugging
     std::cerr.precision(20);
     for (size_t i = 0; i < allVertices.size(); ++i) {
       std::cerr << verts[i][0] << ", " << verts[i][1] << ", " << verts[i][2] << "\n";
@@ -352,14 +384,17 @@ std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3(const CGAL_Nef_polyhedr
        just output the resulting 3d triangles*/
 
     // We cannot trust the plane from Nef polyhedron to be correct.
-    // Passing an incorrect normal vector can cause a crash in the constrained delaunay triangulator
-    // See http://cgal-discuss.949826.n4.nabble.com/Nef3-Wrong-normal-vector-reported-causes-triangulator-crash-tt4660282.html
+    // Passing an incorrect normal vector can cause a crash in the constrained
+    // delaunay triangulator See
+    // http://cgal-discuss.949826.n4.nabble.com/Nef3-Wrong-normal-vector-reported-causes-triangulator-crash-tt4660282.html
     // CGAL::Vector_3<CGAL_Kernel3> nvec = plane.orthogonal_vector();
-    // K::Vector_3 normal(CGAL::to_double(nvec.x()), CGAL::to_double(nvec.y()), CGAL::to_double(nvec.z()));
+    // K::Vector_3 normal(CGAL::to_double(nvec.x()), CGAL::to_double(nvec.y()),
+    // CGAL::to_double(nvec.z()));
     std::vector<IndexedTriangle> triangles;
-    auto err = GeometryUtils::tessellatePolygonWithHoles(verts, faces, triangles, nullptr);
+    auto err = GeometryUtils::tessellatePolygonWithHoles(verts, faces,
+                                                         triangles, nullptr);
     if (!err) {
-      for (const auto& t : triangles) {
+      for (const auto &t : triangles) {
         assert(t[0] >= 0 && t[0] < static_cast<int>(allVertices.size()));
         assert(t[1] >= 0 && t[1] < static_cast<int>(allVertices.size()));
         assert(t[2] >= 0 && t[2] < static_cast<int>(allVertices.size()));
@@ -368,7 +403,7 @@ std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3(const CGAL_Nef_polyhedr
     }
   }
 
-#if 0 // For debugging
+#if 0  // For debugging
   for (const auto& t : allTriangles) {
     std::cerr << t[0] << " " << t[1] << " " << t[2] << "\n";
   }
@@ -376,21 +411,22 @@ std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3(const CGAL_Nef_polyhedr
   // 4. Validate mesh (manifoldness)
   auto unconnected2 = GeometryUtils::findUnconnectedEdges(allTriangles);
   if (unconnected2 > 0) {
-    LOG(message_group::Error, "Non-manifold mesh created: %1$d unconnected edges", unconnected2);
+    LOG(message_group::Error,
+        "Non-manifold mesh created: %1$d unconnected edges", unconnected2);
   }
 
   auto polyset = PolySet::createEmpty();
   polyset->vertices.reserve(verts.size());
-  for (const auto& v : verts) {
+  for (const auto &v : verts) {
     polyset->vertices.emplace_back(v.cast<double>());
   }
   polyset->indices.reserve(allTriangles.size());
-  for (const auto& tri : allTriangles) {
+  for (const auto &tri : allTriangles) {
     polyset->indices.push_back({tri[0], tri[1], tri[2]});
   }
   polyset->setTriangular(true);
 
-#if 0 // For debugging
+#if 0  // For debugging
   std::cerr.precision(20);
   for (size_t i = 0; i < allVertices.size(); ++i) {
     std::cerr << verts[i][0] << ", " << verts[i][1] << ", " << verts[i][2] << "\n";
@@ -401,39 +437,39 @@ std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3(const CGAL_Nef_polyhedr
 }
 
 template <typename K>
-CGAL::Aff_transformation_3<K> createAffineTransformFromMatrix(const Transform3d& matrix) {
+CGAL::Aff_transformation_3<K>
+createAffineTransformFromMatrix(const Transform3d &matrix) {
   return CGAL::Aff_transformation_3<K>(
-    matrix(0, 0), matrix(0, 1), matrix(0, 2), matrix(0, 3),
-    matrix(1, 0), matrix(1, 1), matrix(1, 2), matrix(1, 3),
-    matrix(2, 0), matrix(2, 1), matrix(2, 2), matrix(2, 3), matrix(3, 3));
+      matrix(0, 0), matrix(0, 1), matrix(0, 2), matrix(0, 3), matrix(1, 0),
+      matrix(1, 1), matrix(1, 2), matrix(1, 3), matrix(2, 0), matrix(2, 1),
+      matrix(2, 2), matrix(2, 3), matrix(3, 3));
 }
 
 template <typename K>
-void transform(CGAL::Nef_polyhedron_3<K>& N, const Transform3d& matrix)
-{
+void transform(CGAL::Nef_polyhedron_3<K> &N, const Transform3d &matrix) {
   assert(matrix.matrix().determinant() != 0);
   N.transform(createAffineTransformFromMatrix<K>(matrix));
 }
 
-template void transform(CGAL_Nef_polyhedron3& N, const Transform3d& matrix);
+template void transform(CGAL_Nef_polyhedron3 &N, const Transform3d &matrix);
 
 template <typename K>
-void transform(CGAL::Surface_mesh<CGAL::Point_3<K>>& mesh, const Transform3d& matrix)
-{
+void transform(CGAL::Surface_mesh<CGAL::Point_3<K>> &mesh,
+               const Transform3d &matrix) {
   assert(matrix.matrix().determinant() != 0);
   auto t = createAffineTransformFromMatrix<K>(matrix);
 
   for (auto v : mesh.vertices()) {
-    auto& pt = mesh.point(v);
+    auto &pt = mesh.point(v);
     pt = t(pt);
   }
 }
 
 template <typename K>
-Transform3d computeResizeTransform(
-  const CGAL::Iso_cuboid_3<K>& bb, unsigned int dimension, const Vector3d& newsize,
-  const Eigen::Matrix<bool, 3, 1>& autosize)
-{
+Transform3d computeResizeTransform(const CGAL::Iso_cuboid_3<K> &bb,
+                                   unsigned int dimension,
+                                   const Vector3d &newsize,
+                                   const Eigen::Matrix<bool, 3, 1> &autosize) {
   // Based on resize() in Giles Bathgate's RapCAD (but not exactly)
 
   // The numeric type is our kernel's field type.
@@ -448,12 +484,14 @@ Transform3d computeResizeTransform(
   for (unsigned int i = 0; i < dimension; ++i) {
     if (newsize[i]) {
       if (bbox_size[i] == NT(0)) {
-        LOG(message_group::Warning, "Resize in direction normal to flat object is not implemented");
+        LOG(message_group::Warning,
+            "Resize in direction normal to flat object is not implemented");
         return Transform3d::Identity();
       } else {
         scale[i] = NT(newsize[i]) / bbox_size[i];
       }
-      if (newsize[i] > newsize[newsizemax_index]) newsizemax_index = i;
+      if (newsize[i] > newsize[newsizemax_index])
+        newsizemax_index = i;
     }
   }
 
@@ -462,24 +500,24 @@ Transform3d computeResizeTransform(
     autoscale = NT(newsize[newsizemax_index]) / bbox_size[newsizemax_index];
   }
   for (unsigned int i = 0; i < dimension; ++i) {
-    if (autosize[i] && newsize[i] == 0) scale[i] = autoscale;
+    if (autosize[i] && newsize[i] == 0)
+      scale[i] = autoscale;
   }
 
   Eigen::Matrix4d t;
-  t << CGAL::to_double(scale[0]),           0,        0,        0,
-    0,        CGAL::to_double(scale[1]),           0,        0,
-    0,        0,        CGAL::to_double(scale[2]),           0,
-    0,        0,        0,                                   1;
+  t << CGAL::to_double(scale[0]), 0, 0, 0, 0, CGAL::to_double(scale[1]), 0, 0,
+      0, 0, CGAL::to_double(scale[2]), 0, 0, 0, 0, 1;
 
   return Transform3d(t);
 }
 
-template Transform3d computeResizeTransform(
-  const CGAL_Iso_cuboid_3& bb, unsigned int dimension, const Vector3d& newsize,
-  const Eigen::Matrix<bool, 3, 1>& autosize);
+template Transform3d
+computeResizeTransform(const CGAL_Iso_cuboid_3 &bb, unsigned int dimension,
+                       const Vector3d &newsize,
+                       const Eigen::Matrix<bool, 3, 1> &autosize);
 
-std::shared_ptr<const PolySet> getGeometryAsPolySet(const std::shared_ptr<const Geometry>& geom)
-{
+std::shared_ptr<const PolySet>
+getGeometryAsPolySet(const std::shared_ptr<const Geometry> &geom) {
   if (auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
     return ps;
   }
@@ -502,4 +540,4 @@ std::shared_ptr<const PolySet> getGeometryAsPolySet(const std::shared_ptr<const
   return nullptr;
 }
 
-}  // namespace CGALUtils
+} // namespace CGALUtils
diff --git a/src/geometry/cgal/cgalutils.h b/src/geometry/cgal/cgalutils.h
index 90a454a8a..1846cdb08 100644
--- a/src/geometry/cgal/cgalutils.h
+++ b/src/geometry/cgal/cgalutils.h
@@ -4,118 +4,130 @@
 #include <vector>
 
 #ifdef ENABLE_CGAL
-#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
 #include "geometry/cgal/CGALNefGeometry.h"
 #include "geometry/cgal/cgal.h"
+#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
 #endif
 
+#include "core/enums.h"
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
-#include "geometry/Polygon2d.h"
 #include "geometry/PolySet.h"
-#include "core/enums.h"
+#include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 
 namespace CGALUtils {
 
 #ifdef ENABLE_CGAL
-template <typename Result, typename V>
-Result vector_convert(V const& v) {
-  return Result(CGAL::to_double(v[0]), CGAL::to_double(v[1]), CGAL::to_double(v[2]));
+template <typename Result, typename V> Result vector_convert(V const &v) {
+  return Result(CGAL::to_double(v[0]), CGAL::to_double(v[1]),
+                CGAL::to_double(v[2]));
 }
 
-std::unique_ptr<CGALNefGeometry> createNefPolyhedronFromPolySet(const PolySet& ps);
-template <typename K>
-bool is_weakly_convex(const CGAL::Polyhedron_3<K>& p);
+std::unique_ptr<CGALNefGeometry>
+createNefPolyhedronFromPolySet(const PolySet &ps);
+template <typename K> bool is_weakly_convex(const CGAL::Polyhedron_3<K> &p);
 
 template <typename K>
-bool is_weakly_convex(const CGAL::Surface_mesh<CGAL::Point_3<K>>& m);
+bool is_weakly_convex(const CGAL::Surface_mesh<CGAL::Point_3<K>> &m);
 
-std::shared_ptr<const Geometry> applyOperator3D(const Geometry::Geometries& children, OpenSCADOperator op);
-std::unique_ptr<const Geometry> applyUnion3D(Geometry::Geometries::iterator chbegin, Geometry::Geometries::iterator chend);
-std::shared_ptr<const Geometry> applyMinkowski3D(const Geometry::Geometries& children);
+std::shared_ptr<const Geometry>
+applyOperator3D(const Geometry::Geometries &children, OpenSCADOperator op);
+std::unique_ptr<const Geometry>
+applyUnion3D(Geometry::Geometries::iterator chbegin,
+             Geometry::Geometries::iterator chend);
+std::shared_ptr<const Geometry>
+applyMinkowski3D(const Geometry::Geometries &children);
 
-std::unique_ptr<Polygon2d> project(const CGALNefGeometry& N, bool cut);
+std::unique_ptr<Polygon2d> project(const CGALNefGeometry &N, bool cut);
 template <typename K>
-CGAL::Iso_cuboid_3<K> boundingBox(const CGAL::Nef_polyhedron_3<K>& N);
+CGAL::Iso_cuboid_3<K> boundingBox(const CGAL::Nef_polyhedron_3<K> &N);
 
 template <typename K>
-CGAL::Iso_cuboid_3<K> boundingBox(const CGAL::Surface_mesh<CGAL::Point_3<K>>& mesh);
+CGAL::Iso_cuboid_3<K>
+boundingBox(const CGAL::Surface_mesh<CGAL::Point_3<K>> &mesh);
 
-CGAL_Iso_cuboid_3 createIsoCuboidFromBoundingBox(const BoundingBox& bbox);
-bool is_approximately_convex(const PolySet& ps);
+CGAL_Iso_cuboid_3 createIsoCuboidFromBoundingBox(const BoundingBox &bbox);
+bool is_approximately_convex(const PolySet &ps);
 
 template <typename Polyhedron>
-std::unique_ptr<PolySet> createPolySetFromPolyhedron(const Polyhedron& p);
+std::unique_ptr<PolySet> createPolySetFromPolyhedron(const Polyhedron &p);
 
 template <typename Polyhedron>
-bool createPolyhedronFromPolySet(const PolySet& ps, Polyhedron& p);
+bool createPolyhedronFromPolySet(const PolySet &ps, Polyhedron &p);
 
 template <class InputKernel, class OutputKernel>
-void copyPolyhedron(const CGAL::Polyhedron_3<InputKernel>& poly_a, CGAL::Polyhedron_3<OutputKernel>& poly_b);
+void copyPolyhedron(const CGAL::Polyhedron_3<InputKernel> &poly_a,
+                    CGAL::Polyhedron_3<OutputKernel> &poly_b);
 
 template <class InputKernel, class OutputKernel>
-void copyMesh(const CGAL::Surface_mesh<CGAL::Point_3<InputKernel>>& input,
-              CGAL::Surface_mesh<CGAL::Point_3<OutputKernel>>& output);
+void copyMesh(const CGAL::Surface_mesh<CGAL::Point_3<InputKernel>> &input,
+              CGAL::Surface_mesh<CGAL::Point_3<OutputKernel>> &output);
 
-CGAL_DoubleMesh repairPolySet(const PolySet& ps);
+CGAL_DoubleMesh repairPolySet(const PolySet &ps);
 
 template <class SurfaceMesh>
-std::shared_ptr<SurfaceMesh> createSurfaceMeshFromPolySet(const PolySet& ps);
+std::shared_ptr<SurfaceMesh> createSurfaceMeshFromPolySet(const PolySet &ps);
 template <class SurfaceMesh>
-std::unique_ptr<PolySet> createPolySetFromSurfaceMesh(const SurfaceMesh& mesh);
+std::unique_ptr<PolySet> createPolySetFromSurfaceMesh(const SurfaceMesh &mesh);
 
-std::unique_ptr<PolySet> createPolySetFromNefPolyhedron3(const CGAL_Nef_polyhedron3& N);
+std::unique_ptr<PolySet>
+createPolySetFromNefPolyhedron3(const CGAL_Nef_polyhedron3 &N);
 
-std::shared_ptr<const CGALNefGeometry> getNefPolyhedronFromGeometry(const std::shared_ptr<const Geometry>& geom);
-std::shared_ptr<const CGALNefGeometry> getGeometryAsNefPolyhedron(const std::shared_ptr<const Geometry>&);
+std::shared_ptr<const CGALNefGeometry>
+getNefPolyhedronFromGeometry(const std::shared_ptr<const Geometry> &geom);
+std::shared_ptr<const CGALNefGeometry>
+getGeometryAsNefPolyhedron(const std::shared_ptr<const Geometry> &);
 
 template <typename K>
-CGAL::Aff_transformation_3<K> createAffineTransformFromMatrix(const Transform3d& matrix);
+CGAL::Aff_transformation_3<K>
+createAffineTransformFromMatrix(const Transform3d &matrix);
 template <typename K>
-void transform(CGAL::Nef_polyhedron_3<K>& N, const Transform3d& matrix);
+void transform(CGAL::Nef_polyhedron_3<K> &N, const Transform3d &matrix);
 template <typename K>
-void transform(CGAL::Surface_mesh<CGAL::Point_3<K>>& mesh, const Transform3d& matrix);
+void transform(CGAL::Surface_mesh<CGAL::Point_3<K>> &mesh,
+               const Transform3d &matrix);
 template <typename K>
-Transform3d computeResizeTransform(
-  const CGAL::Iso_cuboid_3<K>& bb, unsigned int dimension, const Vector3d& newsize,
-  const Eigen::Matrix<bool, 3, 1>& autosize);
-bool tessellatePolygon(const std::vector<CGAL::Point_3<CGAL::Epick>>& polygon,
-                       Polygons& triangles,
+Transform3d computeResizeTransform(const CGAL::Iso_cuboid_3<K> &bb,
+                                   unsigned int dimension,
+                                   const Vector3d &newsize,
+                                   const Eigen::Matrix<bool, 3, 1> &autosize);
+bool tessellatePolygon(const std::vector<CGAL::Point_3<CGAL::Epick>> &polygon,
+                       Polygons &triangles,
                        const CGAL::Vector_3<CGAL::Epick> *normal = nullptr);
-bool tessellatePolygonWithHoles(const std::vector<std::vector<CGAL::Point_3<CGAL::Epick>>>& polygons,
-                                Polygons& triangles,
-                                const CGAL::Vector_3<CGAL::Epick> *normal = nullptr);
-bool tessellate3DFaceWithHoles(std::vector<CGAL_Polygon_3>& polygons,
-                               std::vector<CGAL_Polygon_3>& triangles,
-                               CGAL::Plane_3<CGAL_Kernel3>& plane);
-template <typename FromKernel, typename ToKernel>
-struct KernelConverter {
+bool tessellatePolygonWithHoles(
+    const std::vector<std::vector<CGAL::Point_3<CGAL::Epick>>> &polygons,
+    Polygons &triangles, const CGAL::Vector_3<CGAL::Epick> *normal = nullptr);
+bool tessellate3DFaceWithHoles(std::vector<CGAL_Polygon_3> &polygons,
+                               std::vector<CGAL_Polygon_3> &triangles,
+                               CGAL::Plane_3<CGAL_Kernel3> &plane);
+template <typename FromKernel, typename ToKernel> struct KernelConverter {
   // Note: we could have this return `CGAL::to_double(n)` by default, but
   // that would mean that failure to provide a proper specialization would
   // default to lossy conversion.
-  typename ToKernel::FT operator()(const typename FromKernel::FT& n) const;
+  typename ToKernel::FT operator()(const typename FromKernel::FT &n) const;
 };
 template <typename FromKernel, typename ToKernel>
-CGAL::Cartesian_converter<FromKernel, ToKernel, KernelConverter<FromKernel, ToKernel>>
-getCartesianConverter()
-{
-  return CGAL::Cartesian_converter<
-    FromKernel, ToKernel, KernelConverter<FromKernel, ToKernel>>();
+CGAL::Cartesian_converter<FromKernel, ToKernel,
+                          KernelConverter<FromKernel, ToKernel>>
+getCartesianConverter() {
+  return CGAL::Cartesian_converter<FromKernel, ToKernel,
+                                   KernelConverter<FromKernel, ToKernel>>();
 }
 
-template <typename SurfaceMesh>
-void triangulateFaces(SurfaceMesh& mesh);
-template <typename Polyhedron>
-bool isClosed(const Polyhedron& polyhedron);
-template <typename SurfaceMesh>
-void orientToBoundAVolume(SurfaceMesh& mesh);
+template <typename SurfaceMesh> void triangulateFaces(SurfaceMesh &mesh);
+template <typename Polyhedron> bool isClosed(const Polyhedron &polyhedron);
+template <typename SurfaceMesh> void orientToBoundAVolume(SurfaceMesh &mesh);
 template <typename K>
-void convertNefToPolyhedron(const CGAL::Nef_polyhedron_3<K>& nef, CGAL::Polyhedron_3<K>& polyhedron);
+void convertNefToPolyhedron(const CGAL::Nef_polyhedron_3<K> &nef,
+                            CGAL::Polyhedron_3<K> &polyhedron);
 
-void convertNefToSurfaceMesh(const CGAL_Nef_polyhedron3& nef, CGAL_Kernel3Mesh& mesh);
-void convertSurfaceMeshToNef(const CGAL_Kernel3Mesh& mesh, CGAL_Nef_polyhedron3& nef);
+void convertNefToSurfaceMesh(const CGAL_Nef_polyhedron3 &nef,
+                             CGAL_Kernel3Mesh &mesh);
+void convertSurfaceMeshToNef(const CGAL_Kernel3Mesh &mesh,
+                             CGAL_Nef_polyhedron3 &nef);
 
 #endif // ifdef ENABLE_CGAL
-std::unique_ptr<PolySet> createTriangulatedPolySetFromPolygon2d(const Polygon2d& polygon2d);
+std::unique_ptr<PolySet>
+createTriangulatedPolySetFromPolygon2d(const Polygon2d &polygon2d);
 
 } // namespace CGALUtils
diff --git a/src/geometry/linalg.cc b/src/geometry/linalg.cc
index a7f644ee4..f833acb24 100644
--- a/src/geometry/linalg.cc
+++ b/src/geometry/linalg.cc
@@ -1,6 +1,6 @@
 #include "geometry/linalg.h"
-#include <cstdint>
 #include <cmath>
+#include <cstdint>
 
 // FIXME: We can achieve better pruning by either:
 // o Recalculate the box based on the transformed object
@@ -13,14 +13,14 @@
    Transforms the given bounding box by transforming each of its 8 vertices.
    Returns a new bounding box.
  */
-BoundingBox operator*(const Transform3d& m, const BoundingBox& box)
-{
-  if (box.isEmpty()) return box;
+BoundingBox operator*(const Transform3d &m, const BoundingBox &box) {
+  if (box.isEmpty())
+    return box;
   BoundingBox newbox;
-  Vector3d boxvec[2] = { box.min(), box.max() };
-  for (auto& k : boxvec) {
-    for (auto& j : boxvec) {
-      for (auto& i : boxvec) {
+  Vector3d boxvec[2] = {box.min(), box.max()};
+  for (auto &k : boxvec) {
+    for (auto &j : boxvec) {
+      for (auto &i : boxvec) {
         newbox.extend(m * Vector3d(i[0], j[1], k[2]));
       }
     }
@@ -28,21 +28,21 @@ BoundingBox operator*(const Transform3d& m, const BoundingBox& box)
   return newbox;
 }
 
-bool matrix_contains_infinity(const Transform3d& m)
-{
+bool matrix_contains_infinity(const Transform3d &m) {
   for (int i = 0; i < m.matrix().rows(); ++i) {
     for (int j = 0; j < m.matrix().cols(); ++j) {
-      if ((std::isinf)(m(i, j))) return true;
+      if ((std::isinf)(m(i, j)))
+        return true;
     }
   }
   return false;
 }
 
-bool matrix_contains_nan(const Transform3d& m)
-{
+bool matrix_contains_nan(const Transform3d &m) {
   for (int i = 0; i < m.matrix().rows(); ++i) {
     for (int j = 0; j < m.matrix().cols(); ++j) {
-      if ((std::isnan)(m(i, j))) return true;
+      if ((std::isnan)(m(i, j)))
+        return true;
     }
   }
   return false;
@@ -67,12 +67,12 @@ bool matrix_contains_nan(const Transform3d& m)
 using Py_hash_t = int32_t;
 using Py_uhash_t = uint32_t;
 using Float_t = double;
-Py_hash_t hash_floating_point(Float_t v)
-{
+Py_hash_t hash_floating_point(Float_t v) {
   static constexpr int PyHASH_BITS = 31;
-  //if (sizeof(Py_uhash_t)==8) PyHASH_BITS=61;
+  // if (sizeof(Py_uhash_t)==8) PyHASH_BITS=61;
 
-  static constexpr Py_uhash_t PyHASH_MODULUS = (((Py_uhash_t)1 << PyHASH_BITS) - 1);
+  static constexpr Py_uhash_t PyHASH_MODULUS =
+      (((Py_uhash_t)1 << PyHASH_BITS) - 1);
   static constexpr Py_uhash_t PyHASH_INF = 314159;
   static constexpr Py_uhash_t PyHASH_NAN = 0;
 
@@ -81,8 +81,10 @@ Py_hash_t hash_floating_point(Float_t v)
   Py_uhash_t x, y;
 
   if (!std::isfinite(v)) {
-    if (std::isinf(v)) return v > 0 ? PyHASH_INF : -PyHASH_INF;
-    else return PyHASH_NAN;
+    if (std::isinf(v))
+      return v > 0 ? PyHASH_INF : -PyHASH_INF;
+    else
+      return PyHASH_NAN;
   }
 
   m = frexp(v, &e);
@@ -103,7 +105,8 @@ Py_hash_t hash_floating_point(Float_t v)
     y = (Py_uhash_t)m; /* pull out integer part */
     m -= y;
     x += y;
-    if (x >= PyHASH_MODULUS) x -= PyHASH_MODULUS;
+    if (x >= PyHASH_MODULUS)
+      x -= PyHASH_MODULUS;
   }
 
   /* adjust for the exponent;  first reduce it modulo PyHASH_BITS */
diff --git a/src/geometry/linalg.h b/src/geometry/linalg.h
index 3f684c282..4b2a134e5 100644
--- a/src/geometry/linalg.h
+++ b/src/geometry/linalg.h
@@ -1,79 +1,80 @@
 #pragma once
 
 #include <Eigen/Core>
-#include <Eigen/Geometry>
 #include <Eigen/Dense>
+#include <Eigen/Geometry>
 #include <cstdint>
 #include <vector>
 
 using Eigen::Vector2d;
 using Eigen::Vector3d;
-using Eigen::Vector4d;
 using Eigen::Vector3f;
-using Eigen::Vector4f;
 using Eigen::Vector3i;
+using Eigen::Vector4d;
+using Eigen::Vector4f;
 
 #ifdef _MSC_VER
-  #include <Eigen/StdVector> // https://eigen.tuxfamily.org/dox/group__TopicStlContainers.html
-  #if !EIGEN_HAS_CXX11_CONTAINERS
-    #warning "Eigen has detected no support for CXX11 containers and has redefined std::vector"
-  #endif
-using VectorOfVector2d = std::vector<Vector2d, Eigen::aligned_allocator<Vector2d>>;
+#include <Eigen/StdVector> // https://eigen.tuxfamily.org/dox/group__TopicStlContainers.html
+#if !EIGEN_HAS_CXX11_CONTAINERS
+#warning                                                                       \
+    "Eigen has detected no support for CXX11 containers and has redefined std::vector"
+#endif
+using VectorOfVector2d =
+    std::vector<Vector2d, Eigen::aligned_allocator<Vector2d>>;
 #else
 using VectorOfVector2d = std::vector<Vector2d>;
 #endif
 
 using BoundingBox = Eigen::AlignedBox<double, 3>;
-using Eigen::Matrix3f;
 using Eigen::Matrix3d;
+using Eigen::Matrix3f;
 using Eigen::Matrix4d;
 #define Transform3d Eigen::Affine3d
 #define Transform2d Eigen::Affine2d
 
-bool matrix_contains_infinity(const Transform3d& m);
-bool matrix_contains_nan(const Transform3d& m);
+bool matrix_contains_infinity(const Transform3d &m);
+bool matrix_contains_nan(const Transform3d &m);
 int32_t hash_floating_point(double v);
 
-template <typename Derived> bool is_finite(const Eigen::MatrixBase<Derived>& x) {
-  //infinity minus infinity is NaN, which never compares equal to itself
-  return ( (x - x).array() == (x - x).array()).all(); // NOLINT(misc-redundant-expression)
+template <typename Derived>
+bool is_finite(const Eigen::MatrixBase<Derived> &x) {
+  // infinity minus infinity is NaN, which never compares equal to itself
+  return ((x - x).array() == (x - x).array())
+      .all(); // NOLINT(misc-redundant-expression)
 }
 
-template <typename Derived> bool is_nan(const Eigen::MatrixBase<Derived>& x) {
+template <typename Derived> bool is_nan(const Eigen::MatrixBase<Derived> &x) {
   return !((x.array() == x.array())).all();
 }
 
-BoundingBox operator*(const Transform3d& m, const BoundingBox& box);
+BoundingBox operator*(const Transform3d &m, const BoundingBox &box);
 
-class Color4f
-{
+class Color4f {
 public:
-  Color4f(const Vector4f& v) : color_(v) { }
+  Color4f(const Vector4f &v) : color_(v) {}
   Color4f(int r, int g, int b, int a = 255) { setRgba(r, g, b, a); }
-  Color4f(float r = -1.0f, float g = -1.0f, float b = -1.0f, float a = -1.0f) : color_(r, g, b, a) { }
+  Color4f(float r = -1.0f, float g = -1.0f, float b = -1.0f, float a = -1.0f)
+      : color_(r, g, b, a) {}
 
   [[nodiscard]] bool isValid() const { return color_.minCoeff() >= 0.0f; }
-  [[nodiscard]] bool hasRgb() const { return color_[0] >= 0.0f && color_[1] >= 0.0f && color_[2] >= 0.0f; }
+  [[nodiscard]] bool hasRgb() const {
+    return color_[0] >= 0.0f && color_[1] >= 0.0f && color_[2] >= 0.0f;
+  }
   [[nodiscard]] bool hasAlpha() const { return color_[3] >= 0.0f; }
 
   void setRgba(int r, int g, int b, int a = 255) {
-    color_ << static_cast<float>(r) / 255.0f,
-      static_cast<float>(g) / 255.0f,
-      static_cast<float>(b) / 255.0f,
-      static_cast<float>(a) / 255.0f;
+    color_ << static_cast<float>(r) / 255.0f, static_cast<float>(g) / 255.0f,
+        static_cast<float>(b) / 255.0f, static_cast<float>(a) / 255.0f;
   }
   void setRgba(float r, float g, float b, float a = 1.0f) {
     color_ << r, g, b, a;
   }
-  void setRgb(float r, float g, float b) {
-    color_.head<3>() << r, g, b;
-  }
-  void setAlpha(float a) {
-    color_[3] = a;
-  }
+  void setRgb(float r, float g, float b) { color_.head<3>() << r, g, b; }
+  void setAlpha(float a) { color_[3] = a; }
 
-  bool getRgba(int& r, int& g, int& b, int& a) const {
-    if (!isValid()) return false;
+  bool getRgba(int &r, int &g, int &b, int &a) const {
+    if (!isValid())
+      return false;
     r = std::clamp(static_cast<int>(this->r() * 255.0f), 0, 255);
     g = std::clamp(static_cast<int>(this->g() * 255.0f), 0, 255);
     b = std::clamp(static_cast<int>(this->b() * 255.0f), 0, 255);
@@ -81,8 +82,9 @@ public:
     return true;
   }
 
-  bool getRgba(uint8_t& r, uint8_t& g, uint8_t& b, uint8_t& a) const {
-    if (!isValid()) return false;
+  bool getRgba(uint8_t &r, uint8_t &g, uint8_t &b, uint8_t &a) const {
+    if (!isValid())
+      return false;
     r = static_cast<uint8_t>(std::clamp(this->r(), 0.0f, 1.0f) * 255.0f);
     g = static_cast<uint8_t>(std::clamp(this->g(), 0.0f, 1.0f) * 255.0f);
     b = static_cast<uint8_t>(std::clamp(this->b(), 0.0f, 1.0f) * 255.0f);
@@ -90,8 +92,9 @@ public:
     return true;
   }
 
-  bool getRgba(float& r, float& g, float& b, float& a) const {
-    if (!isValid()) return false;
+  bool getRgba(float &r, float &g, float &b, float &a) const {
+    if (!isValid())
+      return false;
     r = this->r();
     g = this->g();
     b = this->b();
@@ -99,28 +102,28 @@ public:
     return true;
   }
 
-  [[nodiscard]] Vector4f toVector4f() const {
-    return color_;
-  }
+  [[nodiscard]] Vector4f toVector4f() const { return color_; }
 
   [[nodiscard]] float r() const { return color_[0]; }
   [[nodiscard]] float g() const { return color_[1]; }
   [[nodiscard]] float b() const { return color_[2]; }
   [[nodiscard]] float a() const { return color_[3]; }
 
-  [[nodiscard]] bool operator<(const Color4f& b) const {
+  [[nodiscard]] bool operator<(const Color4f &b) const {
     for (int i = 0; i < 4; i++) {
-      if (color_[i] < b.color_[i]) return true;
-      if (color_[i] > b.color_[i]) return false;
+      if (color_[i] < b.color_[i])
+        return true;
+      if (color_[i] > b.color_[i])
+        return false;
     }
     return false;
   }
 
-  [[nodiscard]] bool operator==(const Color4f& b) const {
+  [[nodiscard]] bool operator==(const Color4f &b) const {
     return color_ == b.color_;
   }
 
-  [[nodiscard]] bool operator!=(const Color4f& b) const {
+  [[nodiscard]] bool operator!=(const Color4f &b) const {
     return !(*this == b);
   }
 
@@ -135,6 +138,7 @@ public:
     hash = std::hash<float>{}(a()) ^ (hash << 1);
     return hash;
   }
+
 private:
   // Vector4f is fixed-size vectorizable
   // Use Eigen::DontAlign so we can store Color4f in STL containers
@@ -143,8 +147,5 @@ private:
 };
 
 template <> struct std::hash<Color4f> {
-  std::size_t operator()(Color4f const& c) const noexcept {
-    return c.hash();
-  }
+  std::size_t operator()(Color4f const &c) const noexcept { return c.hash(); }
 };
-
diff --git a/src/geometry/linear_extrude.cc b/src/geometry/linear_extrude.cc
index 9b379b457..b4d5ba4c4 100644
--- a/src/geometry/linear_extrude.cc
+++ b/src/geometry/linear_extrude.cc
@@ -1,25 +1,25 @@
 #include "geometry/linear_extrude.h"
 
 #include <algorithm>
+#include <cassert>
 #include <cmath>
+#include <cstddef>
 #include <iterator>
-#include <cassert>
-#include <utility>
 #include <memory>
-#include <cstddef>
 #include <queue>
+#include <utility>
 #include <vector>
 
 #include <boost/logic/tribool.hpp>
 
+#include "core/LinearExtrudeNode.h"
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
 #include "geometry/GeometryUtils.h"
-#include "glview/RenderSettings.h"
-#include "core/LinearExtrudeNode.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetBuilder.h"
 #include "geometry/PolySetUtils.h"
+#include "geometry/linalg.h"
+#include "glview/RenderSettings.h"
 #include "utils/calc.h"
 #include "utils/degree_trig.h"
 
@@ -32,7 +32,7 @@ namespace {
     0 : if v1 ~= v2 (approximation to compoensate for floating point precision)
     1 : if v1  > v2
  */
-int sgn_vdiff(const Vector2d& v1, const Vector2d& v2) {
+int sgn_vdiff(const Vector2d &v1, const Vector2d &v2) {
   constexpr double ratio_threshold = 1e5; // 10ppm difference
   double l1 = v1.norm();
   double l2 = v2.norm();
@@ -46,30 +46,34 @@ int sgn_vdiff(const Vector2d& v1, const Vector2d& v2) {
 // Insert vertices for segments interpolated between v0 and v1.
 // The last vertex (t==1) is not added here to avoid duplicate vertices,
 // since it will be the first vertex of the *next* edge.
-void add_segmented_edge(Outline2d& o, const Vector2d& v0, const Vector2d& v1, unsigned int edge_segments) {
+void add_segmented_edge(Outline2d &o, const Vector2d &v0, const Vector2d &v1,
+                        unsigned int edge_segments) {
   for (unsigned int j = 0; j < edge_segments; ++j) {
     double t = static_cast<double>(j) / edge_segments;
     o.vertices.push_back((1 - t) * v0 + t * v1);
   }
 }
 
-// While total outline segments < fn, increment segment_count for edge with largest
-// (max_edge_length / segment_count).
-Outline2d splitOutlineByFn(
-  const Outline2d& o,
-  const double twist, const double scale_x, const double scale_y,
-  const double fn, unsigned int slices)
-{
+// While total outline segments < fn, increment segment_count for edge with
+// largest (max_edge_length / segment_count).
+Outline2d splitOutlineByFn(const Outline2d &o, const double twist,
+                           const double scale_x, const double scale_y,
+                           const double fn, unsigned int slices) {
 
   struct segment_tracker {
     size_t edge_index;
     double max_edgelen;
     unsigned int segment_count{1u};
-    segment_tracker(size_t i, double len) : edge_index(i), max_edgelen(len) { }
-    // metric for comparison: average between (max segment length, and max segment length after split)
-    [[nodiscard]] double metric() const { return max_edgelen / (segment_count + 0.5); }
-    bool operator<(const segment_tracker& rhs) const { return this->metric() < rhs.metric();  }
-    [[nodiscard]] bool close_match(const segment_tracker& other) const {
+    segment_tracker(size_t i, double len) : edge_index(i), max_edgelen(len) {}
+    // metric for comparison: average between (max segment length, and max
+    // segment length after split)
+    [[nodiscard]] double metric() const {
+      return max_edgelen / (segment_count + 0.5);
+    }
+    bool operator<(const segment_tracker &rhs) const {
+      return this->metric() < rhs.metric();
+    }
+    [[nodiscard]] bool close_match(const segment_tracker &other) const {
       // Edges are grouped when metrics match by at least 99.9%
       constexpr double APPROX_EQ_RATIO = 0.999;
       double l1 = this->metric(), l2 = other.metric();
@@ -87,12 +91,14 @@ Outline2d splitOutlineByFn(
   if (scale_x != scale_y) {
     for (size_t i = 1; i <= num_vertices; ++i) {
       Vector2d v1 = o.vertices[i % num_vertices];
-      double max_edgelen = 0.0; // max length for single edge over all transformed slices
+      double max_edgelen =
+          0.0; // max length for single edge over all transformed slices
       for (unsigned int j = 0; j <= slices; j++) {
         double t = static_cast<double>(j) / slices;
         Vector2d scale(Calc::lerp(1, scale_x, t), Calc::lerp(1, scale_y, t));
         double rot = twist * t;
-        Eigen::Affine2d trans(Eigen::Scaling(scale) * Eigen::Affine2d(rotate_degrees(-rot)));
+        Eigen::Affine2d trans(Eigen::Scaling(scale) *
+                              Eigen::Affine2d(rotate_degrees(-rot)));
         double edgelen = (trans * v1 - trans * v0).norm();
         max_edgelen = std::max(max_edgelen, edgelen);
       }
@@ -116,7 +122,8 @@ Outline2d splitOutlineByFn(
     auto current = q.top();
 
     // Group similar length segmented edges to keep result roughly symmetrical.
-    while (!q.empty() && (tmp_q.empty() || q.top().close_match(tmp_q.front()))) {
+    while (!q.empty() &&
+           (tmp_q.empty() || q.top().close_match(tmp_q.front()))) {
       tmp_q.push_back(q.top());
       q.pop();
     }
@@ -155,13 +162,11 @@ Outline2d splitOutlineByFn(
   return o2;
 }
 
-// For each edge in original outline, find its max length over all slice transforms,
-// and divide into segments no longer than fs.
-Outline2d splitOutlineByFs(
-  const Outline2d& o,
-  const double twist, const double scale_x, const double scale_y,
-  const double fs, unsigned int slices)
-{
+// For each edge in original outline, find its max length over all slice
+// transforms, and divide into segments no longer than fs.
+Outline2d splitOutlineByFs(const Outline2d &o, const double twist,
+                           const double scale_x, const double scale_y,
+                           const double fs, unsigned int slices) {
   const auto num_vertices = o.vertices.size();
 
   Vector2d v0 = o.vertices[0];
@@ -173,16 +178,19 @@ Outline2d splitOutlineByFs(
   if (scale_x != scale_y) {
     for (size_t i = 1; i <= num_vertices; ++i) {
       Vector2d v1 = o.vertices[i % num_vertices];
-      double max_edgelen = 0.0; // max length for single edge over all transformed slices
+      double max_edgelen =
+          0.0; // max length for single edge over all transformed slices
       for (unsigned int j = 0; j <= slices; j++) {
         double t = static_cast<double>(j) / slices;
         Vector2d scale(Calc::lerp(1, scale_x, t), Calc::lerp(1, scale_y, t));
         double rot = twist * t;
-        Eigen::Affine2d trans(Eigen::Scaling(scale) * Eigen::Affine2d(rotate_degrees(-rot)));
+        Eigen::Affine2d trans(Eigen::Scaling(scale) *
+                              Eigen::Affine2d(rotate_degrees(-rot)));
         double edgelen = (trans * v1 - trans * v0).norm();
         max_edgelen = std::max(max_edgelen, edgelen);
       }
-      auto edge_segments = static_cast<unsigned int>(std::ceil(max_edgelen / fs));
+      auto edge_segments =
+          static_cast<unsigned int>(std::ceil(max_edgelen / fs));
       add_segmented_edge(o2, v0, v1, edge_segments);
       v0 = v1;
     }
@@ -190,7 +198,8 @@ Outline2d splitOutlineByFs(
     double max_scale = std::max(scale_x, 1.0);
     for (size_t i = 1; i <= num_vertices; ++i) {
       Vector2d v1 = o.vertices[i % num_vertices];
-      unsigned int edge_segments = static_cast<unsigned int>(std::ceil((v1 - v0).norm() * max_scale / fs));
+      unsigned int edge_segments = static_cast<unsigned int>(
+          std::ceil((v1 - v0).norm() * max_scale / fs));
       add_segmented_edge(o2, v0, v1, edge_segments);
       v0 = v1;
     }
@@ -198,10 +207,11 @@ Outline2d splitOutlineByFs(
   return o2;
 }
 
-std::unique_ptr<PolySet> assemblePolySetForManifold(
-  const Polygon2d& polyref,
-  std::vector<Vector3d>& vertices, PolygonIndices& indices,
-  int convexity, boost::tribool isConvex, int index_offset) {
+std::unique_ptr<PolySet>
+assemblePolySetForManifold(const Polygon2d &polyref,
+                           std::vector<Vector3d> &vertices,
+                           PolygonIndices &indices, int convexity,
+                           boost::tribool isConvex, int index_offset) {
   auto final_polyset = std::make_unique<PolySet>(3, isConvex);
   final_polyset->setTriangular(true);
   final_polyset->setConvexity(convexity);
@@ -211,15 +221,15 @@ std::unique_ptr<PolySet> assemblePolySetForManifold(
   // Create top and bottom face.
   auto ps_bottom = polyref.tessellate(); // bottom
   // Flip vertex ordering for bottom polygon
-  for (auto& p : ps_bottom->indices) {
+  for (auto &p : ps_bottom->indices) {
     std::reverse(p.begin(), p.end());
   }
   std::copy(ps_bottom->indices.begin(), ps_bottom->indices.end(),
             std::back_inserter(final_polyset->indices));
 
-  for (auto& p : ps_bottom->indices) {
+  for (auto &p : ps_bottom->indices) {
     std::reverse(p.begin(), p.end());
-    for (auto& i : p) {
+    for (auto &i : p) {
       i += index_offset;
     }
   }
@@ -231,32 +241,33 @@ std::unique_ptr<PolySet> assemblePolySetForManifold(
   return final_polyset;
 }
 
-std::unique_ptr<PolySet> assemblePolySetForCGAL(const Polygon2d& polyref,
-                                                std::vector<Vector3d>& vertices, PolygonIndices& indices,
-                                                int convexity, boost::tribool isConvex,
-                                                double scale_x, double scale_y,
-                                                const Vector3d& h1, const Vector3d& h2, double twist) {
+std::unique_ptr<PolySet>
+assemblePolySetForCGAL(const Polygon2d &polyref,
+                       std::vector<Vector3d> &vertices, PolygonIndices &indices,
+                       int convexity, boost::tribool isConvex, double scale_x,
+                       double scale_y, const Vector3d &h1, const Vector3d &h2,
+                       double twist) {
 
   PolySetBuilder builder(0, 0, 3, isConvex);
   builder.setConvexity(convexity);
 
-  for (const auto& poly: indices) {
+  for (const auto &poly : indices) {
     builder.beginPolygon(poly.size());
     for (const auto idx : poly) {
       builder.addVertex(vertices[idx]);
     }
   }
 
-  auto translatePolySet = [](PolySet& ps, const Vector3d& translation) {
-      for (auto& v : ps.vertices) {
-        v += translation;
-      }
-    };
+  auto translatePolySet = [](PolySet &ps, const Vector3d &translation) {
+    for (auto &v : ps.vertices) {
+      v += translation;
+    }
+  };
 
   // Create bottom face.
   auto ps_bottom = polyref.tessellate(); // bottom
   // Flip vertex ordering for bottom polygon
-  for (auto& p : ps_bottom->indices) {
+  for (auto &p : ps_bottom->indices) {
     std::reverse(p.begin(), p.end());
   }
   translatePolySet(*ps_bottom, h1);
@@ -266,7 +277,8 @@ std::unique_ptr<PolySet> assemblePolySetForCGAL(const Polygon2d& polyref,
   // If either scale components are 0, then top will be zero-area, so skip it.
   if (scale_x != 0 && scale_y != 0) {
     Polygon2d top_poly(polyref);
-    Eigen::Affine2d trans(Eigen::Scaling(scale_x, scale_y) * Eigen::Affine2d(rotate_degrees(-twist)));
+    Eigen::Affine2d trans(Eigen::Scaling(scale_x, scale_y) *
+                          Eigen::Affine2d(rotate_degrees(-twist)));
     top_poly.transform(trans);
     auto ps_top = top_poly.tessellate();
     translatePolySet(*ps_top, h2);
@@ -280,35 +292,38 @@ std::unique_ptr<PolySet> assemblePolySetForCGAL(const Polygon2d& polyref,
    Attempt to triangulate quads in an ideal way.
    Each quad is composed of two adjacent outline vertices: (prev1, curr1)
    and their corresponding transformed points one step up: (prev2, curr2).
-   Quads are triangulated across the shorter of the two diagonals, which works well in most cases.
-   However, when diagonals are equal length, decision may flip depending on other factors.
+   Quads are triangulated across the shorter of the two diagonals, which works
+   well in most cases. However, when diagonals are equal length, decision may
+   flip depending on other factors.
  */
-void add_slice_indices(PolygonIndices& indices, int slice_idx, int slice_stride, const Polygon2d& poly,
-                       double rot1, double rot2,
-                       const Vector2d& scale1, const Vector2d& scale2)
-{
+void add_slice_indices(PolygonIndices &indices, int slice_idx, int slice_stride,
+                       const Polygon2d &poly, double rot1, double rot2,
+                       const Vector2d &scale1, const Vector2d &scale2) {
   int prev_slice = (slice_idx - 1) * slice_stride;
   int curr_slice = slice_idx * slice_stride;
 
-  Eigen::Affine2d trans1(Eigen::Scaling(scale1) * Eigen::Affine2d(rotate_degrees(-rot1)));
-  Eigen::Affine2d trans2(Eigen::Scaling(scale2) * Eigen::Affine2d(rotate_degrees(-rot2)));
+  Eigen::Affine2d trans1(Eigen::Scaling(scale1) *
+                         Eigen::Affine2d(rotate_degrees(-rot1)));
+  Eigen::Affine2d trans2(Eigen::Scaling(scale2) *
+                         Eigen::Affine2d(rotate_degrees(-rot2)));
 
   bool any_zero = scale2[0] == 0 || scale2[1] == 0;
   // setting back_twist true helps keep diagonals same as previous builds.
   bool back_twist = rot2 <= rot1;
 
   int curr_outline = 0;
-  for (const auto& o : poly.outlines()) {
+  for (const auto &o : poly.outlines()) {
     // prev1: previous slice, previous vertex
     // prev2: current slice, previous vertex
     Vector2d prev1 = trans1 * o.vertices[0];
     Vector2d prev2 = trans2 * o.vertices[0];
 
-    // For equal length diagonals, flip selected choice depending on direction of twist and
-    // whether the outline is negative (eg circle hole inside a larger circle).
-    // This was tested against circles with a single point touching the origin,
-    // and extruded with twist.  Diagonal choice determined by whichever option
-    // matched the direction of diagonal for neighboring edges (which did not exhibit "equal" diagonals).
+    // For equal length diagonals, flip selected choice depending on direction
+    // of twist and whether the outline is negative (eg circle hole inside a
+    // larger circle). This was tested against circles with a single point
+    // touching the origin, and extruded with twist.  Diagonal choice determined
+    // by whichever option matched the direction of diagonal for neighboring
+    // edges (which did not exhibit "equal" diagonals).
     bool flip = ((!o.positive) xor (back_twist));
 
     for (int i = 1; i <= o.vertices.size(); ++i) {
@@ -329,23 +344,23 @@ void add_slice_indices(PolygonIndices& indices, int slice_idx, int slice_stride,
             prev_slice + curr_idx,
             curr_slice + curr_idx,
             prev_slice + prev_idx,
-          });
+        });
         indices.push_back({
             curr_slice + prev_idx,
             prev_slice + prev_idx,
             curr_slice + curr_idx,
-          });
+        });
       } else {
         indices.push_back({
             prev_slice + curr_idx,
             curr_slice + prev_idx,
             prev_slice + prev_idx,
-          });
+        });
         indices.push_back({
             prev_slice + curr_idx,
             curr_slice + curr_idx,
             curr_slice + prev_idx,
-          });
+        });
       }
       prev1 = curr1;
       prev2 = curr2;
@@ -354,45 +369,55 @@ void add_slice_indices(PolygonIndices& indices, int slice_idx, int slice_stride,
   }
 }
 
-size_t calc_num_slices(const LinearExtrudeNode& node, const Polygon2d& poly) {
+size_t calc_num_slices(const LinearExtrudeNode &node, const Polygon2d &poly) {
   size_t num_slices;
   if (node.has_slices) {
     num_slices = node.slices;
   } else if (node.has_twist) {
     double max_r1_sqr = 0; // r1 is before scaling
     Vector2d scale(node.scale_x, node.scale_y);
-    for (const auto& o : poly.outlines())
-      for (const auto& v : o.vertices)
+    for (const auto &o : poly.outlines())
+      for (const auto &v : o.vertices)
         max_r1_sqr = fmax(max_r1_sqr, v.squaredNorm());
     // Calculate Helical curve length for Twist with no Scaling
     if (node.scale_x == 1.0 && node.scale_y == 1.0) {
-      num_slices = (unsigned int)Calc::get_helix_slices(max_r1_sqr, node.height[2], node.twist, node.fn, node.fs, node.fa);
-    } else if (node.scale_x != node.scale_y) {  // non uniform scaling with twist using max slices from twist and non uniform scale
+      num_slices = (unsigned int)Calc::get_helix_slices(
+          max_r1_sqr, node.height[2], node.twist, node.fn, node.fs, node.fa);
+    } else if (node.scale_x !=
+               node.scale_y) {  // non uniform scaling with twist using max
+                                // slices from twist and non uniform scale
       double max_delta_sqr = 0; // delta from before/after scaling
       Vector2d scale(node.scale_x, node.scale_y);
-      for (const auto& o : poly.outlines()) {
-        for (const auto& v : o.vertices) {
-          max_delta_sqr = fmax(max_delta_sqr, (v - v.cwiseProduct(scale)).squaredNorm());
+      for (const auto &o : poly.outlines()) {
+        for (const auto &v : o.vertices) {
+          max_delta_sqr =
+              fmax(max_delta_sqr, (v - v.cwiseProduct(scale)).squaredNorm());
         }
       }
       size_t slicesNonUniScale;
       size_t slicesTwist;
-      slicesNonUniScale = (unsigned int)Calc::get_diagonal_slices(max_delta_sqr, node.height[2], node.fn, node.fs);
-      slicesTwist = (unsigned int)Calc::get_helix_slices(max_r1_sqr, node.height[2], node.twist, node.fn, node.fs, node.fa);
+      slicesNonUniScale = (unsigned int)Calc::get_diagonal_slices(
+          max_delta_sqr, node.height[2], node.fn, node.fs);
+      slicesTwist = (unsigned int)Calc::get_helix_slices(
+          max_r1_sqr, node.height[2], node.twist, node.fn, node.fs, node.fa);
       num_slices = std::max(slicesNonUniScale, slicesTwist);
     } else { // uniform scaling with twist, use conical helix calculation
-      num_slices = (unsigned int)Calc::get_conical_helix_slices(max_r1_sqr, node.height[2], node.twist, node.scale_x, node.fn, node.fs, node.fa);
+      num_slices = (unsigned int)Calc::get_conical_helix_slices(
+          max_r1_sqr, node.height[2], node.twist, node.scale_x, node.fn,
+          node.fs, node.fa);
     }
   } else if (node.scale_x != node.scale_y) {
     // Non uniform scaling, w/o twist
     double max_delta_sqr = 0; // delta from before/after scaling
     Vector2d scale(node.scale_x, node.scale_y);
-    for (const auto& o : poly.outlines()) {
-      for (const auto& v : o.vertices) {
-        max_delta_sqr = fmax(max_delta_sqr, (v - v.cwiseProduct(scale)).squaredNorm());
+    for (const auto &o : poly.outlines()) {
+      for (const auto &v : o.vertices) {
+        max_delta_sqr =
+            fmax(max_delta_sqr, (v - v.cwiseProduct(scale)).squaredNorm());
       }
     }
-    num_slices = Calc::get_diagonal_slices(max_delta_sqr, node.height[2], node.fn, node.fs);
+    num_slices = Calc::get_diagonal_slices(max_delta_sqr, node.height[2],
+                                           node.fn, node.fs);
   } else {
     // uniform or [1,1] scaling w/o twist needs only one slice
     num_slices = 1;
@@ -400,21 +425,23 @@ size_t calc_num_slices(const LinearExtrudeNode& node, const Polygon2d& poly) {
   return num_slices;
 }
 
-}  // namespace
+} // namespace
 
 /*!
-   Input to extrude should be sanitized. This means non-intersecting, correct winding order
-   etc., the input coming from a library like Clipper.
+   Input to extrude should be sanitized. This means non-intersecting, correct
+   winding order etc., the input coming from a library like Clipper.
  */
-std::unique_ptr<Geometry> extrudePolygon(const LinearExtrudeNode& node, const Polygon2d& poly)
-{
+std::unique_ptr<Geometry> extrudePolygon(const LinearExtrudeNode &node,
+                                         const Polygon2d &poly) {
   assert(poly.isSanitized());
-  if (node.height[2] <= 0) return PolySet::createEmpty();
+  if (node.height[2] <= 0)
+    return PolySet::createEmpty();
 
   bool non_linear = node.twist != 0 || node.scale_x != node.scale_y;
   boost::tribool isConvex{poly.is_convex()};
   // Twist makes convex polygons into unknown polyhedrons
-  if (isConvex && non_linear) isConvex = unknown;
+  if (isConvex && non_linear)
+    isConvex = unknown;
 
   // num_slices is the number of volumetric segments, minimum 1.
   // The number of rings of vertices will be num_slices+1.
@@ -426,34 +453,40 @@ std::unique_ptr<Geometry> extrudePolygon(const LinearExtrudeNode& node, const Po
   if (node.has_segments) {
     // Set segments = 0 to disable
     if (node.segments > 0) {
-      for (const auto& o : poly.outlines()) {
+      for (const auto &o : poly.outlines()) {
         if (o.vertices.size() >= node.segments) {
           seg_poly.addOutline(o);
         } else {
-          seg_poly.addOutline(splitOutlineByFn(o, node.twist, node.scale_x, node.scale_y, node.segments, num_slices));
+          seg_poly.addOutline(splitOutlineByFn(o, node.twist, node.scale_x,
+                                               node.scale_y, node.segments,
+                                               num_slices));
         }
       }
       is_segmented = true;
     }
   } else if (non_linear) {
     if (node.fn > 0.0) {
-      for (const auto& o : poly.outlines()) {
+      for (const auto &o : poly.outlines()) {
         if (o.vertices.size() >= node.fn) {
           seg_poly.addOutline(o);
         } else {
-          seg_poly.addOutline(splitOutlineByFn(o, node.twist, node.scale_x, node.scale_y, node.fn, num_slices));
+          seg_poly.addOutline(splitOutlineByFn(
+              o, node.twist, node.scale_x, node.scale_y, node.fn, num_slices));
         }
       }
     } else { // $fs and $fa based segmentation
       auto fa_segs = static_cast<unsigned int>(std::ceil(360.0 / node.fa));
-      for (const auto& o : poly.outlines()) {
+      for (const auto &o : poly.outlines()) {
         if (o.vertices.size() >= fa_segs) {
           seg_poly.addOutline(o);
         } else {
           // try splitting by $fs, then check if $fa results in less segments
-          auto fsOutline = splitOutlineByFs(o, node.twist, node.scale_x, node.scale_y, node.fs, num_slices);
+          auto fsOutline = splitOutlineByFs(o, node.twist, node.scale_x,
+                                            node.scale_y, node.fs, num_slices);
           if (fsOutline.vertices.size() >= fa_segs) {
-            seg_poly.addOutline(splitOutlineByFn(o, node.twist, node.scale_x, node.scale_y, fa_segs, num_slices));
+            seg_poly.addOutline(splitOutlineByFn(o, node.twist, node.scale_x,
+                                                 node.scale_y, fa_segs,
+                                                 num_slices));
           } else {
             seg_poly.addOutline(std::move(fsOutline));
           }
@@ -463,7 +496,7 @@ std::unique_ptr<Geometry> extrudePolygon(const LinearExtrudeNode& node, const Po
     is_segmented = true;
   }
 
-  const Polygon2d& polyref = is_segmented ? seg_poly : poly;
+  const Polygon2d &polyref = is_segmented ? seg_poly : poly;
 
   Vector3d h1 = Vector3d::Zero();
   Vector3d h2 = node.height;
@@ -474,7 +507,7 @@ std::unique_ptr<Geometry> extrudePolygon(const LinearExtrudeNode& node, const Po
   }
 
   int slice_stride = 0;
-  for (const auto& o : polyref.outlines()) {
+  for (const auto &o : polyref.outlines()) {
     slice_stride += o.vertices.size();
   }
   std::vector<Vector3d> vertices;
@@ -488,13 +521,14 @@ std::unique_ptr<Geometry> extrudePolygon(const LinearExtrudeNode& node, const Po
   auto full_height = (h2 - h1);
   for (unsigned int slice_idx = 0; slice_idx <= num_slices; slice_idx++) {
     Eigen::Affine2d trans(
-      Eigen::Scaling(Vector2d(1, 1) - full_scale * slice_idx / num_slices) *
-      Eigen::Affine2d(rotate_degrees(full_rot * slice_idx / num_slices)));
+        Eigen::Scaling(Vector2d(1, 1) - full_scale * slice_idx / num_slices) *
+        Eigen::Affine2d(rotate_degrees(full_rot * slice_idx / num_slices)));
 
-    for (const auto& o : polyref.outlines()) {
-      for (const auto& v : o.vertices) {
+    for (const auto &o : polyref.outlines()) {
+      for (const auto &v : o.vertices) {
         auto tmp = trans * v;
-        vertices.emplace_back(Vector3d(tmp[0], tmp[1], 0.0) + h1 + full_height * slice_idx / num_slices);
+        vertices.emplace_back(Vector3d(tmp[0], tmp[1], 0.0) + h1 +
+                              full_height * slice_idx / num_slices);
       }
     }
   }
@@ -509,21 +543,23 @@ std::unique_ptr<Geometry> extrudePolygon(const LinearExtrudeNode& node, const Po
                         1 - (1 - node.scale_y) * (slice_idx - 1) / num_slices);
     Vector2d scale_curr(1 - (1 - node.scale_x) * slice_idx / num_slices,
                         1 - (1 - node.scale_y) * slice_idx / num_slices);
-    add_slice_indices(indices, slice_idx, slice_stride, polyref, rot_prev, rot_curr, scale_prev, scale_curr);
+    add_slice_indices(indices, slice_idx, slice_stride, polyref, rot_prev,
+                      rot_curr, scale_prev, scale_curr);
   }
 
-  // For Manifold, we can tesselate the endcaps using existing vertices to build a manifold mesh.
-  // Without Manifold, however, we don't have such a tessellator available, so we'll have to build
-  // the polyset from vertices using PolySetBuilder
+  // For Manifold, we can tesselate the endcaps using existing vertices to build
+  // a manifold mesh. Without Manifold, however, we don't have such a
+  // tessellator available, so we'll have to build the polyset from vertices
+  // using PolySetBuilder
 
 #ifdef ENABLE_MANIFOLD
   if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
     return assemblePolySetForManifold(polyref, vertices, indices,
-                                      node.convexity, isConvex, slice_stride * num_slices);
+                                      node.convexity, isConvex,
+                                      slice_stride * num_slices);
   } else
 #endif
-  return assemblePolySetForCGAL(polyref, vertices, indices,
-                                node.convexity, isConvex,
-                                node.scale_x, node.scale_y,
-                                h1, h2, node.twist);
+    return assemblePolySetForCGAL(polyref, vertices, indices, node.convexity,
+                                  isConvex, node.scale_x, node.scale_y, h1, h2,
+                                  node.twist);
 }
diff --git a/src/geometry/linear_extrude.h b/src/geometry/linear_extrude.h
index 68182df6b..c9708868a 100644
--- a/src/geometry/linear_extrude.h
+++ b/src/geometry/linear_extrude.h
@@ -2,8 +2,9 @@
 
 #include <memory>
 
-#include "geometry/Polygon2d.h"
-#include "geometry/Geometry.h"
 #include "core/LinearExtrudeNode.h"
+#include "geometry/Geometry.h"
+#include "geometry/Polygon2d.h"
 
-std::unique_ptr<Geometry> extrudePolygon(const LinearExtrudeNode& node, const Polygon2d& poly);
+std::unique_ptr<Geometry> extrudePolygon(const LinearExtrudeNode &node,
+                                         const Polygon2d &poly);
diff --git a/src/geometry/manifold/ManifoldGeometry.cc b/src/geometry/manifold/ManifoldGeometry.cc
index 83f1cd7be..5645070e1 100644
--- a/src/geometry/manifold/ManifoldGeometry.cc
+++ b/src/geometry/manifold/ManifoldGeometry.cc
@@ -1,73 +1,61 @@
-// Portions of this file are Copyright 2023 Google LLC, and licensed under GPL2+. See COPYING.
+// Portions of this file are Copyright 2023 Google LLC, and licensed under
+// GPL2+. See COPYING.
 #include "geometry/manifold/ManifoldGeometry.h"
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
-#include "geometry/Polygon2d.h"
-#include <map>
-#include <set>
-#include <functional>
-#include <exception>
-#include <sstream>
-#include <utility>
-#include <cstdint>
-#include <manifold/cross_section.h>
-#include <manifold/manifold.h>
 #include "geometry/PolySet.h"
 #include "geometry/PolySetBuilder.h"
 #include "geometry/PolySetUtils.h"
+#include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 #include "geometry/manifold/manifoldutils.h"
 #include "glview/ColorMap.h"
 #include "glview/RenderSettings.h"
 #include <cstddef>
-#include <string>
+#include <cstdint>
+#include <exception>
+#include <functional>
+#include <manifold/cross_section.h>
+#include <manifold/manifold.h>
+#include <map>
 #include <memory>
+#include <set>
+#include <sstream>
+#include <string>
+#include <utility>
 #ifdef ENABLE_CGAL
 #include "geometry/cgal/cgalutils.h"
 #endif
 
 namespace {
 
-template <typename Result, typename V>
-Result vector_convert(V const& v) {
+template <typename Result, typename V> Result vector_convert(V const &v) {
   return Result(v[0], v[1], v[2]);
 }
 
-}
+} // namespace
 
 ManifoldGeometry::ManifoldGeometry() : manifold_(manifold::Manifold()) {}
 
 ManifoldGeometry::ManifoldGeometry(
-  manifold::Manifold mani,
-  const std::set<uint32_t>& originalIDs,
-  const std::map<uint32_t, Color4f>& originalIDToColor,
-  const std::set<uint32_t>& subtractedIDs)
-  : manifold_(std::move(mani)),
-  originalIDs_(originalIDs),
-  originalIDToColor_(originalIDToColor),
-  subtractedIDs_(subtractedIDs)
-{
-}
+    manifold::Manifold mani, const std::set<uint32_t> &originalIDs,
+    const std::map<uint32_t, Color4f> &originalIDToColor,
+    const std::set<uint32_t> &subtractedIDs)
+    : manifold_(std::move(mani)), originalIDs_(originalIDs),
+      originalIDToColor_(originalIDToColor), subtractedIDs_(subtractedIDs) {}
 
-std::unique_ptr<Geometry> ManifoldGeometry::copy() const
-{
+std::unique_ptr<Geometry> ManifoldGeometry::copy() const {
   return std::make_unique<ManifoldGeometry>(*this);
 }
 
-const manifold::Manifold& ManifoldGeometry::getManifold() const {
+const manifold::Manifold &ManifoldGeometry::getManifold() const {
   return manifold_;
 }
 
-bool ManifoldGeometry::isEmpty() const {
-  return getManifold().IsEmpty();
-}
+bool ManifoldGeometry::isEmpty() const { return getManifold().IsEmpty(); }
 
-size_t ManifoldGeometry::numFacets() const {
-  return getManifold().NumTri();
-}
+size_t ManifoldGeometry::numFacets() const { return getManifold().NumTri(); }
 
-size_t ManifoldGeometry::numVertices() const {
-  return getManifold().NumVert();
-}
+size_t ManifoldGeometry::numVertices() const { return getManifold().NumVert(); }
 
 bool ManifoldGeometry::isManifold() const {
   return getManifold().Status() == manifold::Manifold::Error::NoError;
@@ -77,30 +65,29 @@ bool ManifoldGeometry::isValid() const {
   return manifold_.Status() == manifold::Manifold::Error::NoError;
 }
 
-void ManifoldGeometry::clear() {
-  manifold_ = manifold::Manifold();
-}
+void ManifoldGeometry::clear() { manifold_ = manifold::Manifold(); }
 
 size_t ManifoldGeometry::memsize() const {
-  // We don't introspect on the manifold here, as this would force it to leaf node (ie. would render it).
+  // We don't introspect on the manifold here, as this would force it to leaf
+  // node (ie. would render it).
   return 0;
 }
 
 std::string ManifoldGeometry::dump() const {
   std::ostringstream out;
-  auto& manifold = getManifold();
+  auto &manifold = getManifold();
   auto meshgl = manifold.GetMeshGL64();
   out << "Manifold:"
       << "\n status: " << ManifoldUtils::statusToString(manifold.Status())
       << "\n genus: " << manifold.Genus()
       << "\n num vertices: " << meshgl.NumVert()
-      << "\n num polygons: " << meshgl.NumTri()
-      << "\n polygons data:";
+      << "\n num polygons: " << meshgl.NumTri() << "\n polygons data:";
 
   for (size_t faceid = 0; faceid < meshgl.NumTri(); faceid++) {
     out << "\n  polygon begin:";
     for (const int j : {0, 1, 2}) {
-      auto v = vector_convert<Vector3d>(meshgl.GetVertPos(meshgl.GetTriVerts(faceid)[j]));
+      auto v = vector_convert<Vector3d>(
+          meshgl.GetVertPos(meshgl.GetTriVerts(faceid)[j]));
       out << "\n   vertex:" << v;
     }
   }
@@ -118,15 +105,15 @@ std::shared_ptr<PolySet> ManifoldGeometry::toPolySet() const {
 
   // first 3 channels are xyz coordinate
   for (size_t i = 0; i < mesh.vertProperties.size(); i += mesh.numProp)
-    ps->vertices.emplace_back(
-      mesh.vertProperties[i],
-      mesh.vertProperties[i + 1],
-      mesh.vertProperties[i + 2]);
+    ps->vertices.emplace_back(mesh.vertProperties[i],
+                              mesh.vertProperties[i + 1],
+                              mesh.vertProperties[i + 2]);
 
   ps->colors.reserve(originalIDToColor_.size());
   ps->color_indices.reserve(ps->indices.size());
 
-  auto colorScheme = ColorMap::inst()->findColorScheme(RenderSettings::inst()->colorscheme);
+  auto colorScheme =
+      ColorMap::inst()->findColorScheme(RenderSettings::inst()->colorscheme);
   int32_t faceFrontColorIndex = -1;
   int32_t faceBackColorIndex = -1;
 
@@ -134,42 +121,44 @@ std::shared_ptr<PolySet> ManifoldGeometry::toPolySet() const {
   std::map<uint32_t, int32_t> originalIDToColorIndex;
 
   auto getFaceFrontColorIndex = [&]() -> int {
-      if (faceFrontColorIndex < 0) {
-        faceFrontColorIndex = ps->colors.size();
-        ps->colors.push_back(ColorMap::getColor(*colorScheme, RenderColor::CGAL_FACE_FRONT_COLOR));
-      }
-      return faceFrontColorIndex;
-    };
+    if (faceFrontColorIndex < 0) {
+      faceFrontColorIndex = ps->colors.size();
+      ps->colors.push_back(
+          ColorMap::getColor(*colorScheme, RenderColor::CGAL_FACE_FRONT_COLOR));
+    }
+    return faceFrontColorIndex;
+  };
   auto getFaceBackColorIndex = [&]() -> int {
-      if (faceBackColorIndex < 0) {
-        faceBackColorIndex = ps->colors.size();
-        ps->colors.push_back(ColorMap::getColor(*colorScheme, RenderColor::CGAL_FACE_BACK_COLOR));
-      }
-      return faceBackColorIndex;
-    };
+    if (faceBackColorIndex < 0) {
+      faceBackColorIndex = ps->colors.size();
+      ps->colors.push_back(
+          ColorMap::getColor(*colorScheme, RenderColor::CGAL_FACE_BACK_COLOR));
+    }
+    return faceBackColorIndex;
+  };
 
   auto getColorIndex = [&](uint32_t originalID) -> int32_t {
-      if (subtractedIDs_.find(originalID) != subtractedIDs_.end()) {
-        return getFaceBackColorIndex();
-      }
-      auto colorIndexIt = originalIDToColorIndex.find(originalID);
-      if (colorIndexIt != originalIDToColorIndex.end()) {
-        return colorIndexIt->second;
-      }
-      auto colorIt = originalIDToColor_.find(originalID);
-      if (colorIt == originalIDToColor_.end()) {
-        return getFaceFrontColorIndex();
-      }
-      const auto& color = colorIt->second;
+    if (subtractedIDs_.find(originalID) != subtractedIDs_.end()) {
+      return getFaceBackColorIndex();
+    }
+    auto colorIndexIt = originalIDToColorIndex.find(originalID);
+    if (colorIndexIt != originalIDToColorIndex.end()) {
+      return colorIndexIt->second;
+    }
+    auto colorIt = originalIDToColor_.find(originalID);
+    if (colorIt == originalIDToColor_.end()) {
+      return getFaceFrontColorIndex();
+    }
+    const auto &color = colorIt->second;
 
-      auto pair = colorToIndex.insert({color, ps->colors.size()});
-      if (pair.second) {
-        ps->colors.push_back(color);
-      }
-      int32_t color_index = pair.first->second;
-      originalIDToColorIndex[originalID] = color_index;
-      return color_index;
-    };
+    auto pair = colorToIndex.insert({color, ps->colors.size()});
+    if (pair.second) {
+      ps->colors.push_back(color);
+    }
+    int32_t color_index = pair.first->second;
+    originalIDToColorIndex[originalID] = color_index;
+    return color_index;
+  };
 
   auto start = mesh.runIndex[0];
   for (int run = 0, numRun = mesh.runIndex.size() - 1; run < numRun; ++run) {
@@ -182,10 +171,9 @@ std::shared_ptr<PolySet> ManifoldGeometry::toPolySet() const {
 
     auto colorIndex = getColorIndex(id);
     for (size_t i = start; i < end; i += 3) {
-      ps->indices.push_back({
-        static_cast<int>(mesh.triVerts[i]),
-        static_cast<int>(mesh.triVerts[i + 1]),
-        static_cast<int>(mesh.triVerts[i + 2])});
+      ps->indices.push_back({static_cast<int>(mesh.triVerts[i]),
+                             static_cast<int>(mesh.triVerts[i + 1]),
+                             static_cast<int>(mesh.triVerts[i + 2])});
       ps->color_indices.push_back(colorIndex);
     }
     start = end;
@@ -195,22 +183,26 @@ std::shared_ptr<PolySet> ManifoldGeometry::toPolySet() const {
 
 #ifdef ENABLE_CGAL
 template <typename Polyhedron>
-class CGALPolyhedronBuilderFromManifold : public CGAL::Modifier_base<typename Polyhedron::HalfedgeDS>
-{
+class CGALPolyhedronBuilderFromManifold
+    : public CGAL::Modifier_base<typename Polyhedron::HalfedgeDS> {
   using HDS = typename Polyhedron::HalfedgeDS;
-  using CGAL_Polybuilder = CGAL::Polyhedron_incremental_builder_3<typename Polyhedron::HalfedgeDS>;
+  using CGAL_Polybuilder =
+      CGAL::Polyhedron_incremental_builder_3<typename Polyhedron::HalfedgeDS>;
+
 public:
   using CGALPoint = typename CGAL_Polybuilder::Point_3;
 
-  const manifold::MeshGL64& meshgl;
-  CGALPolyhedronBuilderFromManifold(const manifold::MeshGL64& mesh) : meshgl(mesh) { }
+  const manifold::MeshGL64 &meshgl;
+  CGALPolyhedronBuilderFromManifold(const manifold::MeshGL64 &mesh)
+      : meshgl(mesh) {}
 
-  void operator()(HDS& hds) override {
+  void operator()(HDS &hds) override {
     CGAL_Polybuilder B(hds, true);
 
     B.begin_surface(meshgl.NumVert(), meshgl.NumTri());
     for (size_t vertid = 0; vertid < meshgl.NumVert(); vertid++)
-      B.add_vertex(CGALUtils::vector_convert<CGALPoint>(meshgl.GetVertPos(vertid)));
+      B.add_vertex(
+          CGALUtils::vector_convert<CGALPoint>(meshgl.GetVertPos(vertid)));
 
     for (size_t faceid = 0; faceid < meshgl.NumTri(); faceid++) {
       const auto tv = meshgl.GetTriVerts(faceid);
@@ -225,24 +217,27 @@ public:
 };
 
 template <class Polyhedron>
-std::shared_ptr<Polyhedron> ManifoldGeometry::toPolyhedron() const
-{
+std::shared_ptr<Polyhedron> ManifoldGeometry::toPolyhedron() const {
   auto p = std::make_shared<Polyhedron>();
   try {
     auto meshgl = getManifold().GetMeshGL64();
     CGALPolyhedronBuilderFromManifold<Polyhedron> builder(meshgl);
     p->delegate(builder);
-  } catch (const CGAL::Assertion_exception& e) {
-    LOG(message_group::Error, "CGAL error in ManifoldGeometry::toPolyhedron(): %1$s", e.what());
+  } catch (const CGAL::Assertion_exception &e) {
+    LOG(message_group::Error,
+        "CGAL error in ManifoldGeometry::toPolyhedron(): %1$s", e.what());
   }
   return p;
 }
 
-template std::shared_ptr<CGAL::Polyhedron_3<CGAL_Kernel3>> ManifoldGeometry::toPolyhedron() const;
+template std::shared_ptr<CGAL::Polyhedron_3<CGAL_Kernel3>>
+ManifoldGeometry::toPolyhedron() const;
 
 #endif // ifdef ENABLE_CGAL
 
-ManifoldGeometry ManifoldGeometry::binOp(const ManifoldGeometry& lhs, const ManifoldGeometry& rhs, manifold::OpType opType) const {
+ManifoldGeometry ManifoldGeometry::binOp(const ManifoldGeometry &lhs,
+                                         const ManifoldGeometry &rhs,
+                                         manifold::OpType opType) const {
   auto mani = lhs.manifold_.Boolean(rhs.manifold_, opType);
   auto originalIDToColor = lhs.originalIDToColor_;
   auto subtractedIDs = lhs.subtractedIDs_;
@@ -251,7 +246,8 @@ ManifoldGeometry ManifoldGeometry::binOp(const ManifoldGeometry& lhs, const Mani
   originalIDs.insert(rhs.originalIDs_.begin(), rhs.originalIDs_.end());
 
   if (opType == manifold::OpType::Subtract) {
-    // Mark all the original ids coming from rhs as subtracted, unless they're mapped to a color.
+    // Mark all the original ids coming from rhs as subtracted, unless they're
+    // mapped to a color.
     for (const auto id : rhs.originalIDs_) {
       auto it = rhs.originalIDToColor_.find(id);
       if (it != rhs.originalIDToColor_.end()) {
@@ -262,17 +258,21 @@ ManifoldGeometry ManifoldGeometry::binOp(const ManifoldGeometry& lhs, const Mani
     }
   } else {
     // Add the id -> color mapping from the rhs.
-    originalIDToColor.insert(rhs.originalIDToColor_.begin(), rhs.originalIDToColor_.end());
+    originalIDToColor.insert(rhs.originalIDToColor_.begin(),
+                             rhs.originalIDToColor_.end());
     subtractedIDs.insert(rhs.subtractedIDs_.begin(), rhs.subtractedIDs_.end());
   }
   return {mani, originalIDs, originalIDToColor, subtractedIDs};
 }
 
-std::shared_ptr<ManifoldGeometry> minkowskiOp(const ManifoldGeometry& lhs, const ManifoldGeometry& rhs) {
+std::shared_ptr<ManifoldGeometry> minkowskiOp(const ManifoldGeometry &lhs,
+                                              const ManifoldGeometry &rhs) {
 // FIXME: How to deal with operation not supported?
 #ifdef ENABLE_CGAL
-  auto lhs_nef = std::shared_ptr<CGALNefGeometry>(CGALUtils::createNefPolyhedronFromPolySet(*lhs.toPolySet()));
-  auto rhs_nef = std::shared_ptr<CGALNefGeometry>(CGALUtils::createNefPolyhedronFromPolySet(*rhs.toPolySet()));
+  auto lhs_nef = std::shared_ptr<CGALNefGeometry>(
+      CGALUtils::createNefPolyhedronFromPolySet(*lhs.toPolySet()));
+  auto rhs_nef = std::shared_ptr<CGALNefGeometry>(
+      CGALUtils::createNefPolyhedronFromPolySet(*rhs.toPolySet()));
   if (lhs_nef->isEmpty() || rhs_nef->isEmpty()) {
     return {};
   }
@@ -283,33 +283,38 @@ std::shared_ptr<ManifoldGeometry> minkowskiOp(const ManifoldGeometry& lhs, const
     if (ps) {
       return ManifoldUtils::createManifoldFromPolySet(*ps);
     }
-  } catch (const std::exception& e) {
-    LOG(message_group::Error,
-        "Nef minkoswki operation failed: %1$s\n", e.what());
+  } catch (const std::exception &e) {
+    LOG(message_group::Error, "Nef minkoswki operation failed: %1$s\n",
+        e.what());
   } catch (...) {
-    LOG(message_group::Warning,
-        "Nef minkowski hard-crashed");
+    LOG(message_group::Warning, "Nef minkowski hard-crashed");
   }
 #endif // ifdef ENABLE_CGAL
   return {};
 }
 
-ManifoldGeometry ManifoldGeometry::operator+(const ManifoldGeometry& other) const {
+ManifoldGeometry
+ManifoldGeometry::operator+(const ManifoldGeometry &other) const {
   return binOp(*this, other, manifold::OpType::Add);
 }
 
-ManifoldGeometry ManifoldGeometry::operator*(const ManifoldGeometry& other) const {
+ManifoldGeometry
+ManifoldGeometry::operator*(const ManifoldGeometry &other) const {
   return binOp(*this, other, manifold::OpType::Intersect);
 }
 
-ManifoldGeometry ManifoldGeometry::operator-(const ManifoldGeometry& other) const {
+ManifoldGeometry
+ManifoldGeometry::operator-(const ManifoldGeometry &other) const {
   return binOp(*this, other, manifold::OpType::Subtract);
 }
 
-ManifoldGeometry ManifoldGeometry::minkowski(const ManifoldGeometry& other) const {
+ManifoldGeometry
+ManifoldGeometry::minkowski(const ManifoldGeometry &other) const {
   std::shared_ptr<ManifoldGeometry> geom = minkowskiOp(*this, other);
-  if (geom) return *geom;
-  else return {};
+  if (geom)
+    return *geom;
+  else
+    return {};
 }
 
 Polygon2d ManifoldGeometry::slice() const {
@@ -322,18 +327,15 @@ Polygon2d ManifoldGeometry::project() const {
   return ManifoldUtils::polygonsToPolygon2d(cross_section.ToPolygons());
 }
 
-void ManifoldGeometry::transform(const Transform3d& mat) {
+void ManifoldGeometry::transform(const Transform3d &mat) {
   manifold::mat3x4 glMat(
-    // Column-major ordering
-    {mat(0, 0), mat(1, 0), mat(2, 0)},
-    {mat(0, 1), mat(1, 1), mat(2, 1)},
-    {mat(0, 2), mat(1, 2), mat(2, 2)},
-    {mat(0, 3), mat(1, 3), mat(2, 3)}
-    );
+      // Column-major ordering
+      {mat(0, 0), mat(1, 0), mat(2, 0)}, {mat(0, 1), mat(1, 1), mat(2, 1)},
+      {mat(0, 2), mat(1, 2), mat(2, 2)}, {mat(0, 3), mat(1, 3), mat(2, 3)});
   manifold_ = getManifold().Transform(glMat);
 }
 
-void ManifoldGeometry::setColor(const Color4f& c) {
+void ManifoldGeometry::setColor(const Color4f &c) {
   if (manifold_.OriginalID() == -1) {
     manifold_ = manifold_.AsOriginal();
   }
@@ -354,8 +356,7 @@ void ManifoldGeometry::toOriginal() {
   subtractedIDs_.clear();
 }
 
-BoundingBox ManifoldGeometry::getBoundingBox() const
-{
+BoundingBox ManifoldGeometry::getBoundingBox() const {
   BoundingBox result;
   manifold::Box bbox = getManifold().BoundingBox();
   result.extend(vector_convert<Eigen::Vector3d>(bbox.min));
@@ -363,12 +364,16 @@ BoundingBox ManifoldGeometry::getBoundingBox() const
   return result;
 }
 
-void ManifoldGeometry::resize(const Vector3d& newsize, const Eigen::Matrix<bool, 3, 1>& autosize) {
-  transform(GeometryUtils::getResizeTransform(this->getBoundingBox(), newsize, autosize));
+void ManifoldGeometry::resize(const Vector3d &newsize,
+                              const Eigen::Matrix<bool, 3, 1> &autosize) {
+  transform(GeometryUtils::getResizeTransform(this->getBoundingBox(), newsize,
+                                              autosize));
 }
 
-/*! Iterate over all vertices' points until the function returns true (for done). */
-void ManifoldGeometry::foreachVertexUntilTrue(const std::function<bool(const manifold::vec3& pt)>& f) const {
+/*! Iterate over all vertices' points until the function returns true (for
+ * done). */
+void ManifoldGeometry::foreachVertexUntilTrue(
+    const std::function<bool(const manifold::vec3 &pt)> &f) const {
   auto mesh = getManifold().GetMeshGL64();
   const auto numVert = mesh.NumVert();
   for (size_t v = 0; v < numVert; ++v) {
diff --git a/src/geometry/manifold/ManifoldGeometry.h b/src/geometry/manifold/ManifoldGeometry.h
index 1bcce76e3..a67e07383 100644
--- a/src/geometry/manifold/ManifoldGeometry.h
+++ b/src/geometry/manifold/ManifoldGeometry.h
@@ -1,14 +1,15 @@
-// Portions of this file are Copyright 2023 Google LLC, and licensed under GPL2+. See COPYING.
+// Portions of this file are Copyright 2023 Google LLC, and licensed under
+// GPL2+. See COPYING.
 #pragma once
 
 #include "geometry/Geometry.h"
-#include <functional>
-#include <cstdint>
-#include <memory>
 #include "geometry/linalg.h"
-#include <manifold/manifold.h>
 #include <cstddef>
+#include <cstdint>
+#include <functional>
+#include <manifold/manifold.h>
 #include <map>
+#include <memory>
 #include <set>
 #include <string>
 
@@ -18,18 +19,16 @@ class Manifold;
 
 /*! A mutable polyhedron backed by a manifold::Manifold
  */
-class ManifoldGeometry : public Geometry
-{
+class ManifoldGeometry : public Geometry {
 public:
   VISITABLE_GEOMETRY();
 
   ManifoldGeometry();
-  ManifoldGeometry(
-    manifold::Manifold object,
-    const std::set<uint32_t>& originalIDs = {},
-    const std::map<uint32_t, Color4f>& originalIDToColor = {},
-    const std::set<uint32_t>& subtractedIDs = {});
-  ManifoldGeometry(const ManifoldGeometry& other) = default;
+  ManifoldGeometry(manifold::Manifold object,
+                   const std::set<uint32_t> &originalIDs = {},
+                   const std::map<uint32_t, Color4f> &originalIDToColor = {},
+                   const std::set<uint32_t> &subtractedIDs = {});
+  ManifoldGeometry(const ManifoldGeometry &other) = default;
 
   [[nodiscard]] bool isEmpty() const override;
   [[nodiscard]] size_t numFacets() const override;
@@ -51,29 +50,34 @@ public:
   [[nodiscard]] std::shared_ptr<Polyhedron> toPolyhedron() const;
 
   /*! union. */
-  ManifoldGeometry operator+(const ManifoldGeometry& other) const;
+  ManifoldGeometry operator+(const ManifoldGeometry &other) const;
   /*! intersection. */
-  ManifoldGeometry operator*(const ManifoldGeometry& other) const;
+  ManifoldGeometry operator*(const ManifoldGeometry &other) const;
   /*! difference. */
-  ManifoldGeometry operator-(const ManifoldGeometry& other) const;
+  ManifoldGeometry operator-(const ManifoldGeometry &other) const;
   /*! minkowksi operation. */
-  ManifoldGeometry minkowski(const ManifoldGeometry& other) const;
+  ManifoldGeometry minkowski(const ManifoldGeometry &other) const;
 
   Polygon2d slice() const;
   Polygon2d project() const;
 
-  void transform(const Transform3d& mat) override;
-  void setColor(const Color4f& c) override;
+  void transform(const Transform3d &mat) override;
+  void setColor(const Color4f &c) override;
   void toOriginal();
-  void resize(const Vector3d& newsize, const Eigen::Matrix<bool, 3, 1>& autosize) override;
+  void resize(const Vector3d &newsize,
+              const Eigen::Matrix<bool, 3, 1> &autosize) override;
 
-  /*! Iterate over all vertices' points until the function returns true (for done). */
-  void foreachVertexUntilTrue(const std::function<bool(const manifold::vec3& pt)>& f) const;
+  /*! Iterate over all vertices' points until the function returns true (for
+   * done). */
+  void foreachVertexUntilTrue(
+      const std::function<bool(const manifold::vec3 &pt)> &f) const;
 
-  const manifold::Manifold& getManifold() const;
+  const manifold::Manifold &getManifold() const;
 
 private:
-  ManifoldGeometry binOp(const ManifoldGeometry& lhs, const ManifoldGeometry& rhs, manifold::OpType opType) const;
+  ManifoldGeometry binOp(const ManifoldGeometry &lhs,
+                         const ManifoldGeometry &rhs,
+                         manifold::OpType opType) const;
 
   manifold::Manifold manifold_;
   std::set<uint32_t> originalIDs_;
diff --git a/src/geometry/manifold/Polygon2d-manifold.cc b/src/geometry/manifold/Polygon2d-manifold.cc
index a992c4691..20b247086 100644
--- a/src/geometry/manifold/Polygon2d-manifold.cc
+++ b/src/geometry/manifold/Polygon2d-manifold.cc
@@ -7,8 +7,7 @@
 /*!
    Triangulates this polygon2d and returns a 2D-in-3D PolySet.
  */
-std::unique_ptr<PolySet> Polygon2d::tessellate() const
-{
+std::unique_ptr<PolySet> Polygon2d::tessellate() const {
   PRINTDB("Polygon2d::tessellate(): %d outlines", this->outlines().size());
   return std::make_unique<PolySet>(*this);
 }
diff --git a/src/geometry/manifold/manifold-applyops-minkowski.cc b/src/geometry/manifold/manifold-applyops-minkowski.cc
index 6d7ae9e2c..2b138d7e2 100644
--- a/src/geometry/manifold/manifold-applyops-minkowski.cc
+++ b/src/geometry/manifold/manifold-applyops-minkowski.cc
@@ -1,224 +1,250 @@
-// Portions of this file are Copyright 2023 Google LLC, and licensed under GPL2+. See COPYING.
+// Portions of this file are Copyright 2023 Google LLC, and licensed under
+// GPL2+. See COPYING.
 #ifdef ENABLE_MANIFOLD
 
-#include <iterator>
 #include <cassert>
-#include <list>
 #include <exception>
+#include <iterator>
+#include <list>
 #include <memory>
 #include <utility>
 #include <vector>
 
-#include <CGAL/convex_hull_3.h>
 #include <CGAL/Surface_mesh/Surface_mesh.h>
+#include <CGAL/convex_hull_3.h>
 
-#include "geometry/cgal/cgal.h"
 #include "geometry/Geometry.h"
-#include "geometry/cgal/cgalutils.h"
 #include "geometry/PolySet.h"
-#include "utils/printutils.h"
-#include "geometry/manifold/manifoldutils.h"
+#include "geometry/cgal/cgal.h"
+#include "geometry/cgal/cgalutils.h"
 #include "geometry/manifold/ManifoldGeometry.h"
+#include "geometry/manifold/manifoldutils.h"
 #include "utils/parallel.h"
+#include "utils/printutils.h"
 
 namespace ManifoldUtils {
 
 /*!
    children cannot contain nullptr objects
  */
-std::shared_ptr<const Geometry> applyMinkowski(const Geometry::Geometries& children)
-{
+std::shared_ptr<const Geometry>
+applyMinkowski(const Geometry::Geometries &children) {
   assert(children.size() >= 2);
 
   using Hull_kernel = CGAL::Epick;
   using Hull_Mesh = CGAL::Surface_mesh<CGAL::Point_3<Hull_kernel>>;
   using Hull_Points = std::vector<CGAL::Point_3<Hull_kernel>>;
 
-  auto surfaceMeshFromGeometry = [](const std::shared_ptr<const Geometry>& geom, bool *pIsConvexOut) -> std::shared_ptr<CGAL_Kernel3Mesh>
-    {
-      auto ps = std::dynamic_pointer_cast<const PolySet>(geom);
-      if (ps) {
-        auto mesh = CGALUtils::createSurfaceMeshFromPolySet<CGAL_Kernel3Mesh>(*ps);
-        if (pIsConvexOut) *pIsConvexOut = ps->isConvex();
+  auto surfaceMeshFromGeometry =
+      [](const std::shared_ptr<const Geometry> &geom,
+         bool *pIsConvexOut) -> std::shared_ptr<CGAL_Kernel3Mesh> {
+    auto ps = std::dynamic_pointer_cast<const PolySet>(geom);
+    if (ps) {
+      auto mesh =
+          CGALUtils::createSurfaceMeshFromPolySet<CGAL_Kernel3Mesh>(*ps);
+      if (pIsConvexOut)
+        *pIsConvexOut = ps->isConvex();
+      return mesh;
+    } else {
+      if (auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
+        auto mesh =
+            ManifoldUtils::createSurfaceMeshFromManifold<CGAL_Kernel3Mesh>(
+                mani->getManifold());
+        if (pIsConvexOut)
+          *pIsConvexOut = CGALUtils::is_weakly_convex(*mesh);
         return mesh;
-      } else {
-        if (auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
-          auto mesh = ManifoldUtils::createSurfaceMeshFromManifold<CGAL_Kernel3Mesh>(mani->getManifold());
-          if (pIsConvexOut) *pIsConvexOut = CGALUtils::is_weakly_convex(*mesh);
-          return mesh;
-        } else throw 0;
-      }
-      throw 0;
-    };
+      } else
+        throw 0;
+    }
+    throw 0;
+  };
 
   CGAL::Cartesian_converter<CGAL_Kernel3, Hull_kernel> conv;
-  auto getHullPoints = [&](const CGAL_Polyhedron& poly) {
-      std::vector<Hull_kernel::Point_3> out;
-      out.reserve(poly.size_of_vertices());
-      for (auto pi = poly.vertices_begin(); pi != poly.vertices_end(); ++pi) {
-        out.push_back(conv(pi->point()));
-      }
-      return out;
-    };
-  auto getHullPointsFromMesh = [&](const CGAL_Kernel3Mesh& mesh) {
-      std::vector<Hull_kernel::Point_3> out;
-      out.reserve(mesh.number_of_vertices());
-      for (auto idx : mesh.vertices()) {
-        out.push_back(conv(mesh.point(idx)));
-      }
-      return out;
-    };
+  auto getHullPoints = [&](const CGAL_Polyhedron &poly) {
+    std::vector<Hull_kernel::Point_3> out;
+    out.reserve(poly.size_of_vertices());
+    for (auto pi = poly.vertices_begin(); pi != poly.vertices_end(); ++pi) {
+      out.push_back(conv(pi->point()));
+    }
+    return out;
+  };
+  auto getHullPointsFromMesh = [&](const CGAL_Kernel3Mesh &mesh) {
+    std::vector<Hull_kernel::Point_3> out;
+    out.reserve(mesh.number_of_vertices());
+    for (auto idx : mesh.vertices()) {
+      out.push_back(conv(mesh.point(idx)));
+    }
+    return out;
+  };
 
   CGAL::Timer t_tot;
   t_tot.start();
 
   auto it = children.begin();
-  std::vector<std::shared_ptr<const Geometry>> operands = {it->second, std::shared_ptr<const Geometry>()};
+  std::vector<std::shared_ptr<const Geometry>> operands = {
+      it->second, std::shared_ptr<const Geometry>()};
 
   try {
-    // Note: we could parallelize more, e.g. compute all decompositions ahead of time instead of doing them 2 by 2,
-    // but this could use substantially more memory.
+    // Note: we could parallelize more, e.g. compute all decompositions ahead of
+    // time instead of doing them 2 by 2, but this could use substantially more
+    // memory.
     while (++it != children.end()) {
       operands[1] = it->second;
 
       std::vector<std::list<Hull_Points>> part_points(2);
 
-      parallelizable_transform(operands.begin(), operands.begin() + 2, part_points.begin(),
-                               [&](std::shared_ptr<const Geometry>& operand) {
-          std::list<Hull_Points> part_points;
-
-          bool is_convex;
-          auto mesh = surfaceMeshFromGeometry(operand, &is_convex);
-          if (!mesh) throw 0;
-          if (mesh->is_empty()) {
-            throw 0;
-          }
+      parallelizable_transform(
+          operands.begin(), operands.begin() + 2, part_points.begin(),
+          [&](std::shared_ptr<const Geometry> &operand) {
+            std::list<Hull_Points> part_points;
+
+            bool is_convex;
+            auto mesh = surfaceMeshFromGeometry(operand, &is_convex);
+            if (!mesh)
+              throw 0;
+            if (mesh->is_empty()) {
+              throw 0;
+            }
 
-          if (is_convex) {
-            part_points.emplace_back(getHullPointsFromMesh(*mesh));
-          } else {
-            // The CGAL_Nef_polyhedron3 constructor can crash on bad polyhedron, so don't try
-            if (!mesh->is_valid()) throw 0;
-            CGAL_Nef_polyhedron3 decomposed_nef;
-            CGALUtils::convertSurfaceMeshToNef(*mesh, decomposed_nef);
-            CGAL::Timer t;
-            t.start();
-            CGAL::convex_decomposition_3(decomposed_nef);
-
-            // the first volume is the outer volume, which ignored in the decomposition
-            CGAL_Nef_polyhedron3::Volume_const_iterator ci = ++decomposed_nef.volumes_begin();
-            for (; ci != decomposed_nef.volumes_end(); ++ci) {
-              if (ci->mark()) {
-                CGAL_Polyhedron poly;
-                decomposed_nef.convert_inner_shell_to_polyhedron(ci->shells_begin(), poly);
-                part_points.emplace_back(getHullPoints(poly));
+            if (is_convex) {
+              part_points.emplace_back(getHullPointsFromMesh(*mesh));
+            } else {
+              // The CGAL_Nef_polyhedron3 constructor can crash on bad
+              // polyhedron, so don't try
+              if (!mesh->is_valid())
+                throw 0;
+              CGAL_Nef_polyhedron3 decomposed_nef;
+              CGALUtils::convertSurfaceMeshToNef(*mesh, decomposed_nef);
+              CGAL::Timer t;
+              t.start();
+              CGAL::convex_decomposition_3(decomposed_nef);
+
+              // the first volume is the outer volume, which ignored in the
+              // decomposition
+              CGAL_Nef_polyhedron3::Volume_const_iterator ci =
+                  ++decomposed_nef.volumes_begin();
+              for (; ci != decomposed_nef.volumes_end(); ++ci) {
+                if (ci->mark()) {
+                  CGAL_Polyhedron poly;
+                  decomposed_nef.convert_inner_shell_to_polyhedron(
+                      ci->shells_begin(), poly);
+                  part_points.emplace_back(getHullPoints(poly));
+                }
               }
-            }
 
-            PRINTDB("Minkowski: decomposed into %d convex parts", part_points.size());
-            t.stop();
-            PRINTDB("Minkowski: decomposition took %f s", t.time());
-          }
-          return part_points;
-        });
+              PRINTDB("Minkowski: decomposed into %d convex parts",
+                      part_points.size());
+              t.stop();
+              PRINTDB("Minkowski: decomposition took %f s", t.time());
+            }
+            return part_points;
+          });
 
       std::vector<Hull_kernel::Point_3> minkowski_points;
 
-      auto combineParts = [&](const Hull_Points& points0, const Hull_Points& points1) -> std::shared_ptr<const ManifoldGeometry> {
-          CGAL::Timer t;
+      auto combineParts = [&](const Hull_Points &points0,
+                              const Hull_Points &points1)
+          -> std::shared_ptr<const ManifoldGeometry> {
+        CGAL::Timer t;
 
-          t.start();
-          std::vector<Hull_kernel::Point_3> minkowski_points;
+        t.start();
+        std::vector<Hull_kernel::Point_3> minkowski_points;
 
-          minkowski_points.reserve(points0.size() * points1.size());
-          for (const auto& p0 : points0) {
-            for (const auto p1 : points1) {
-              minkowski_points.push_back(p0 + (p1 - CGAL::ORIGIN));
-            }
-          }
-
-          if (minkowski_points.size() <= 3) {
-            t.stop();
-            return std::make_shared<ManifoldGeometry>();
+        minkowski_points.reserve(points0.size() * points1.size());
+        for (const auto &p0 : points0) {
+          for (const auto p1 : points1) {
+            minkowski_points.push_back(p0 + (p1 - CGAL::ORIGIN));
           }
+        }
 
+        if (minkowski_points.size() <= 3) {
           t.stop();
-          PRINTDB("Minkowski: Point cloud creation (%d ⨉ %d -> %d) took %f ms", points0.size() % points1.size() % minkowski_points.size() % (t.time() * 1000));
-          t.reset();
-
-          t.start();
-
-          Hull_Mesh mesh;
-          CGAL::convex_hull_3(minkowski_points.begin(), minkowski_points.end(), mesh);
-
-          std::vector<Hull_kernel::Point_3> strict_points;
-          strict_points.reserve(minkowski_points.size());
-
-          for (auto v : mesh.vertices()) {
-            auto& p = mesh.point(v);
-
-            auto h = mesh.halfedge(v);
-            auto e = h;
-            bool collinear = false;
-            bool coplanar = true;
-
-            do {
-              auto& q = mesh.point(mesh.target(mesh.opposite(h)));
-              if (coplanar && !CGAL::coplanar(p, q,
-                                              mesh.point(mesh.target(mesh.next(h))),
-                                              mesh.point(mesh.target(mesh.next(mesh.opposite(mesh.next(h))))))) {
-                coplanar = false;
-              }
-
+          return std::make_shared<ManifoldGeometry>();
+        }
+
+        t.stop();
+        PRINTDB("Minkowski: Point cloud creation (%d ⨉ %d -> %d) took %f ms",
+                points0.size() % points1.size() % minkowski_points.size() %
+                    (t.time() * 1000));
+        t.reset();
+
+        t.start();
+
+        Hull_Mesh mesh;
+        CGAL::convex_hull_3(minkowski_points.begin(), minkowski_points.end(),
+                            mesh);
+
+        std::vector<Hull_kernel::Point_3> strict_points;
+        strict_points.reserve(minkowski_points.size());
+
+        for (auto v : mesh.vertices()) {
+          auto &p = mesh.point(v);
+
+          auto h = mesh.halfedge(v);
+          auto e = h;
+          bool collinear = false;
+          bool coplanar = true;
+
+          do {
+            auto &q = mesh.point(mesh.target(mesh.opposite(h)));
+            if (coplanar &&
+                !CGAL::coplanar(p, q, mesh.point(mesh.target(mesh.next(h))),
+                                mesh.point(mesh.target(
+                                    mesh.next(mesh.opposite(mesh.next(h))))))) {
+              coplanar = false;
+            }
 
-              for (auto j = mesh.opposite(mesh.next(h));
-                   j != h && !collinear && !coplanar;
-                   j = mesh.opposite(mesh.next(j))) {
+            for (auto j = mesh.opposite(mesh.next(h));
+                 j != h && !collinear && !coplanar;
+                 j = mesh.opposite(mesh.next(j))) {
 
-                auto& r = mesh.point(mesh.target(mesh.opposite(j)));
-                if (CGAL::collinear(p, q, r)) {
-                  collinear = true;
-                }
+              auto &r = mesh.point(mesh.target(mesh.opposite(j)));
+              if (CGAL::collinear(p, q, r)) {
+                collinear = true;
               }
+            }
 
-              h = mesh.opposite(mesh.next(h));
-            } while (h != e && !collinear);
+            h = mesh.opposite(mesh.next(h));
+          } while (h != e && !collinear);
 
-            if (!collinear && !coplanar) strict_points.push_back(p);
-          }
+          if (!collinear && !coplanar)
+            strict_points.push_back(p);
+        }
 
-          mesh.clear();
-          CGAL::convex_hull_3(strict_points.begin(), strict_points.end(), mesh);
+        mesh.clear();
+        CGAL::convex_hull_3(strict_points.begin(), strict_points.end(), mesh);
 
-          t.stop();
-          PRINTDB("Minkowski: Computing convex hull took %f s", t.time());
-          t.reset();
+        t.stop();
+        PRINTDB("Minkowski: Computing convex hull took %f s", t.time());
+        t.reset();
 
-          CGALUtils::triangulateFaces(mesh);
-          return ManifoldUtils::createManifoldFromSurfaceMesh(mesh);
-        };
+        CGALUtils::triangulateFaces(mesh);
+        return ManifoldUtils::createManifoldFromSurfaceMesh(mesh);
+      };
 
-      std::vector<std::shared_ptr<const ManifoldGeometry>> result_parts(part_points[0].size() * part_points[1].size());
+      std::vector<std::shared_ptr<const ManifoldGeometry>> result_parts(
+          part_points[0].size() * part_points[1].size());
       parallelizable_cross_product_transform(
-        part_points[0], part_points[1],
-        result_parts.begin(),
-        combineParts);
+          part_points[0], part_points[1], result_parts.begin(), combineParts);
 
-      if (it != std::next(children.begin())) operands[0].reset();
+      if (it != std::next(children.begin()))
+        operands[0].reset();
 
       CGAL::Timer t;
       t.start();
       PRINTDB("Minkowski: Computing union of %d parts", result_parts.size());
       Geometry::Geometries fake_children;
-      for (const auto& part : result_parts) {
-        fake_children.push_back(std::make_pair(std::shared_ptr<const AbstractNode>(),
-                                               part));
+      for (const auto &part : result_parts) {
+        fake_children.push_back(
+            std::make_pair(std::shared_ptr<const AbstractNode>(), part));
       }
-      auto N = ManifoldUtils::applyOperator3DManifold(fake_children, OpenSCADOperator::UNION);
+      auto N = ManifoldUtils::applyOperator3DManifold(fake_children,
+                                                      OpenSCADOperator::UNION);
 
       // FIXME: This should really never throw.
       // Assert once we figured out what went wrong with issue #1069?
-      if (!N) throw 0;
+      if (!N)
+        throw 0;
       t.stop();
       PRINTDB("Minkowski: Union done: %f s", t.time());
       t.reset();
@@ -231,16 +257,19 @@ std::shared_ptr<const Geometry> applyMinkowski(const Geometry::Geometries& child
     PRINTDB("Minkowski: Total execution time %f s", t_tot.time());
     t_tot.reset();
     return operands[0];
-  } catch (const std::exception& e) {
+  } catch (const std::exception &e) {
     LOG(message_group::Warning,
-        "[manifold] Minkowski failed with error, falling back to Nef operation: %1$s\n", e.what());
+        "[manifold] Minkowski failed with error, falling back to Nef "
+        "operation: %1$s\n",
+        e.what());
   } catch (...) {
     LOG(message_group::Warning,
         "[manifold] Minkowski hard-crashed, falling back to Nef operation.");
   }
-  return ManifoldUtils::applyOperator3DManifold(children, OpenSCADOperator::MINKOWSKI);
+  return ManifoldUtils::applyOperator3DManifold(children,
+                                                OpenSCADOperator::MINKOWSKI);
 }
 
-}  // namespace ManifoldUtils
+} // namespace ManifoldUtils
 
 #endif // ENABLE_MANIFOLD
diff --git a/src/geometry/manifold/manifold-applyops.cc b/src/geometry/manifold/manifold-applyops.cc
index ee67c4f34..2961762b8 100644
--- a/src/geometry/manifold/manifold-applyops.cc
+++ b/src/geometry/manifold/manifold-applyops.cc
@@ -3,33 +3,34 @@
 
 #ifdef ENABLE_MANIFOLD
 
-#include <memory>
-#include "geometry/manifold/manifoldutils.h"
-#include "geometry/Geometry.h"
 #include "core/AST.h"
-#include "geometry/manifold/ManifoldGeometry.h"
 #include "core/node.h"
 #include "core/progress.h"
+#include "geometry/Geometry.h"
+#include "geometry/manifold/ManifoldGeometry.h"
+#include "geometry/manifold/manifoldutils.h"
 #include "utils/printutils.h"
+#include <memory>
 
 namespace ManifoldUtils {
 
-Location getLocation(const std::shared_ptr<const AbstractNode>& node)
-{
+Location getLocation(const std::shared_ptr<const AbstractNode> &node) {
   return node && node->modinst ? node->modinst->location() : Location::NONE;
 }
 
 /*!
    Applies op to all children and returns the result.
-   The child list should be guaranteed to contain non-NULL 3D or empty Geometry objects
+   The child list should be guaranteed to contain non-NULL 3D or empty Geometry
+   objects
  */
-std::shared_ptr<ManifoldGeometry> applyOperator3DManifold(const Geometry::Geometries& children, OpenSCADOperator op)
-{
+std::shared_ptr<ManifoldGeometry>
+applyOperator3DManifold(const Geometry::Geometries &children,
+                        OpenSCADOperator op) {
   std::shared_ptr<ManifoldGeometry> geom;
 
   bool foundFirst = false;
 
-  for (const auto& item : children) {
+  for (const auto &item : children) {
     auto chN = item.second ? createManifoldFromGeometry(item.second) : nullptr;
 
     // Intersecting something with nothing results in nothing
@@ -66,13 +67,15 @@ std::shared_ptr<ManifoldGeometry> applyOperator3DManifold(const Geometry::Geomet
       *geom = geom->minkowski(*chN);
       break;
     default:
-      LOG(message_group::Error, "Unsupported CGAL operator: %1$d", static_cast<int>(op));
+      LOG(message_group::Error, "Unsupported CGAL operator: %1$d",
+          static_cast<int>(op));
     }
-    if (item.first) item.first->progress_report();
+    if (item.first)
+      item.first->progress_report();
   }
   return geom;
 }
 
-}   // namespace ManifoldUtils
+} // namespace ManifoldUtils
 
 #endif // ENABLE_MANIFOLD
diff --git a/src/geometry/manifold/manifoldutils.cc b/src/geometry/manifold/manifoldutils.cc
index 4ce153fa2..0a837b951 100644
--- a/src/geometry/manifold/manifoldutils.cc
+++ b/src/geometry/manifold/manifoldutils.cc
@@ -1,30 +1,31 @@
-// Portions of this file are Copyright 2023 Google LLC, and licensed under GPL2+. See COPYING.
+// Portions of this file are Copyright 2023 Google LLC, and licensed under
+// GPL2+. See COPYING.
 #include "geometry/manifold/manifoldutils.h"
 
-#include <cstddef>
-#include <optional>
-#include <vector>
 #include <cassert>
+#include <cstddef>
+#include <cstdint>
+#include <exception>
 #include <map>
+#include <memory>
+#include <optional>
 #include <set>
-#include <exception>
 #include <utility>
-#include <cstdint>
-#include <memory>
+#include <vector>
 
 #include <manifold/polygon.h>
 #ifdef ENABLE_CGAL
-#include <CGAL/convex_hull_3.h>
 #include <CGAL/Surface_mesh.h>
+#include <CGAL/convex_hull_3.h>
 #endif
 
 #include "geometry/Geometry.h"
+#include "geometry/PolySet.h"
+#include "geometry/PolySetBuilder.h"
+#include "geometry/PolySetUtils.h"
 #include "geometry/linalg.h"
 #include "geometry/manifold/ManifoldGeometry.h"
-#include "geometry/PolySetBuilder.h"
 #include "utils/printutils.h"
-#include "geometry/PolySetUtils.h"
-#include "geometry/PolySet.h"
 #ifdef ENABLE_CGAL
 #include "geometry/cgal/cgalutils.h"
 #endif
@@ -33,15 +34,15 @@ using Error = manifold::Manifold::Error;
 
 namespace {
 
-std::shared_ptr<ManifoldGeometry> createManifoldFromTriangularPolySet(const PolySet& ps)
-{
+std::shared_ptr<ManifoldGeometry>
+createManifoldFromTriangularPolySet(const PolySet &ps) {
   assert(ps.isTriangular());
 
   manifold::MeshGL64 mesh;
 
   mesh.numProp = 3;
   mesh.vertProperties.reserve(ps.vertices.size() * 3);
-  for (const auto& v : ps.vertices) {
+  for (const auto &v : ps.vertices) {
     mesh.vertProperties.push_back(v.x());
     mesh.vertProperties.push_back(v.y());
     mesh.vertProperties.push_back(v.z());
@@ -62,7 +63,7 @@ std::shared_ptr<ManifoldGeometry> createManifoldFromTriangularPolySet(const Poly
     colorToFaceIndices[color].push_back(i);
   }
   auto next_id = manifold::Manifold::ReserveIDs(colorToFaceIndices.size());
-  for (const auto& [color, faceIndices] : colorToFaceIndices) {
+  for (const auto &[color, faceIndices] : colorToFaceIndices) {
 
     auto id = next_id++;
     if (color.has_value()) {
@@ -74,7 +75,7 @@ std::shared_ptr<ManifoldGeometry> createManifoldFromTriangularPolySet(const Poly
     originalIDs.insert(id);
 
     for (size_t faceIndex : faceIndices) {
-      auto& face = ps.indices[faceIndex];
+      auto &face = ps.indices[faceIndex];
       assert(face.size() == 3);
       mesh.triVerts.push_back(face[0]);
       mesh.triVerts.push_back(face[1]);
@@ -100,42 +101,54 @@ std::shared_ptr<ManifoldGeometry> createManifoldFromTriangularPolySet(const Poly
     }
   }
 
-  return std::make_shared<ManifoldGeometry>(mani, originalIDs, originalIDToColor);
+  return std::make_shared<ManifoldGeometry>(mani, originalIDs,
+                                            originalIDToColor);
 }
 
-}  // namespace
+} // namespace
 
 namespace ManifoldUtils {
 
 const char *statusToString(Error status) {
   switch (status) {
-  case Error::NoError: return "NoError";
-  case Error::NonFiniteVertex: return "NonFiniteVertex";
-  case Error::NotManifold: return "NotManifold";
-  case Error::VertexOutOfBounds: return "VertexOutOfBounds";
-  case Error::PropertiesWrongLength: return "PropertiesWrongLength";
-  case Error::MissingPositionProperties: return "MissingPositionProperties";
-  case Error::MergeVectorsDifferentLengths: return "MergeVectorsDifferentLengths";
-  case Error::MergeIndexOutOfBounds: return "MergeIndexOutOfBounds";
-  case Error::TransformWrongLength: return "TransformWrongLength";
-  case Error::RunIndexWrongLength: return "RunIndexWrongLength";
-  case Error::FaceIDWrongLength: return "FaceIDWrongLength";
-  default: return "unknown";
+  case Error::NoError:
+    return "NoError";
+  case Error::NonFiniteVertex:
+    return "NonFiniteVertex";
+  case Error::NotManifold:
+    return "NotManifold";
+  case Error::VertexOutOfBounds:
+    return "VertexOutOfBounds";
+  case Error::PropertiesWrongLength:
+    return "PropertiesWrongLength";
+  case Error::MissingPositionProperties:
+    return "MissingPositionProperties";
+  case Error::MergeVectorsDifferentLengths:
+    return "MergeVectorsDifferentLengths";
+  case Error::MergeIndexOutOfBounds:
+    return "MergeIndexOutOfBounds";
+  case Error::TransformWrongLength:
+    return "TransformWrongLength";
+  case Error::RunIndexWrongLength:
+    return "RunIndexWrongLength";
+  case Error::FaceIDWrongLength:
+    return "FaceIDWrongLength";
+  default:
+    return "unknown";
   }
 }
 
-std::shared_ptr<ManifoldGeometry> createManifoldFromPolySet(const PolySet& ps)
-{
-  // 1. If the PolySet is already manifold, we should be able to build a Manifold object directly
-  // (through using manifold::Mesh).
-  // We need to make sure our PolySet is triangulated before doing that.
-  // Note: We currently don't have a way of directly checking if a PolySet is manifold,
-  // so we just try converting to a Manifold object and check its status.
+std::shared_ptr<ManifoldGeometry> createManifoldFromPolySet(const PolySet &ps) {
+  // 1. If the PolySet is already manifold, we should be able to build a
+  // Manifold object directly (through using manifold::Mesh). We need to make
+  // sure our PolySet is triangulated before doing that. Note: We currently
+  // don't have a way of directly checking if a PolySet is manifold, so we just
+  // try converting to a Manifold object and check its status.
   std::unique_ptr<const PolySet> triangulated;
   if (!ps.isTriangular()) {
     triangulated = PolySetUtils::tessellate_faces(ps);
   }
-  const PolySet& triangle_set = ps.isTriangular() ? ps : *triangulated;
+  const PolySet &triangle_set = ps.isTriangular() ? ps : *triangulated;
 
   // Note: This function also performs a merge if the first attempt fails.
   auto mani = createManifoldFromTriangularPolySet(triangle_set);
@@ -143,12 +156,13 @@ std::shared_ptr<ManifoldGeometry> createManifoldFromPolySet(const PolySet& ps)
     return mani;
   }
 
-  LOG(message_group::Warning, "PolySet -> Manifold conversion failed: %1$s\n"
+  LOG(message_group::Warning,
+      "PolySet -> Manifold conversion failed: %1$s\n"
       "Trying to repair and reconstruct mesh..",
       ManifoldUtils::statusToString(mani->getManifold().Status()));
 
-  // 2. If the PolySet couldn't be converted into a Manifold object, let's try to repair it.
-  // We currently have to utilize some CGAL functions to do this.
+  // 2. If the PolySet couldn't be converted into a Manifold object, let's try
+  // to repair it. We currently have to utilize some CGAL functions to do this.
 #ifdef ENABLE_CGAL
   try {
     PolySet psq(ps);
@@ -165,7 +179,8 @@ std::shared_ptr<ManifoldGeometry> createManifoldFromPolySet(const PolySet& ps)
       for (size_t i = 0, n = points3d.size(); i < n; i++) {
         points[i] = CGALUtils::vector_convert<K::Point_3>(points3d[i]);
       }
-      if (points.size() <= 3) return std::make_shared<ManifoldGeometry>();
+      if (points.size() <= 3)
+        return std::make_shared<ManifoldGeometry>();
 
       // Apply hull
       CGAL::Surface_mesh<CGAL::Point_3<K>> r;
@@ -184,16 +199,18 @@ std::shared_ptr<ManifoldGeometry> createManifoldFromPolySet(const PolySet& ps)
     }
 
     auto geom = createManifoldFromSurfaceMesh(m);
-    // TODO: preserve color if polyset is fully monochrome, or maybe pass colors around in surface mesh?
+    // TODO: preserve color if polyset is fully monochrome, or maybe pass colors
+    // around in surface mesh?
     return geom;
-  } catch (const std::exception& e) {
+  } catch (const std::exception &e) {
     LOG(message_group::Error, "[manifold] CGAL error: %1$s", e.what());
   }
 #endif // ifdef ENABLE_CGAL
   return std::make_shared<ManifoldGeometry>();
 }
 
-std::shared_ptr<const ManifoldGeometry> createManifoldFromGeometry(const std::shared_ptr<const Geometry>& geom) {
+std::shared_ptr<const ManifoldGeometry>
+createManifoldFromGeometry(const std::shared_ptr<const Geometry> &geom) {
   if (auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
     return mani;
   }
@@ -203,11 +220,11 @@ std::shared_ptr<const ManifoldGeometry> createManifoldFromGeometry(const std::sh
   return nullptr;
 }
 
-Polygon2d polygonsToPolygon2d(const manifold::Polygons& polygons) {
+Polygon2d polygonsToPolygon2d(const manifold::Polygons &polygons) {
   Polygon2d poly2d;
-  for (const auto& polygon : polygons) {
+  for (const auto &polygon : polygons) {
     Outline2d outline;
-    for (const auto& v : polygon) {
+    for (const auto &v : polygon) {
       outline.vertices.emplace_back(v[0], v[1]);
     }
     poly2d.addOutline(std::move(outline));
@@ -215,15 +232,15 @@ Polygon2d polygonsToPolygon2d(const manifold::Polygons& polygons) {
   return poly2d;
 }
 
-std::unique_ptr<PolySet> createTriangulatedPolySetFromPolygon2d(const Polygon2d& polygon2d)
-{
+std::unique_ptr<PolySet>
+createTriangulatedPolySetFromPolygon2d(const Polygon2d &polygon2d) {
   auto polyset = std::make_unique<PolySet>(2);
   polyset->setTriangular(true);
 
   manifold::Polygons polygons;
-  for (const auto& outline : polygon2d.outlines()) {
+  for (const auto &outline : polygon2d.outlines()) {
     manifold::SimplePolygon simplePolygon;
-    for (const auto& vertex : outline.vertices) {
+    for (const auto &vertex : outline.vertices) {
       polyset->vertices.emplace_back(vertex[0], vertex[1], 0.0);
       simplePolygon.emplace_back(vertex[0], vertex[1]);
     }
@@ -232,43 +249,45 @@ std::unique_ptr<PolySet> createTriangulatedPolySetFromPolygon2d(const Polygon2d&
 
   const auto triangles = manifold::Triangulate(polygons);
 
-  for (const auto& triangle : triangles) {
+  for (const auto &triangle : triangles) {
     polyset->indices.push_back({triangle[0], triangle[1], triangle[2]});
   }
   return polyset;
-
 }
 
 template <class SurfaceMesh>
-std::shared_ptr<ManifoldGeometry> createManifoldFromSurfaceMesh(const SurfaceMesh& tm)
-{
+std::shared_ptr<ManifoldGeometry>
+createManifoldFromSurfaceMesh(const SurfaceMesh &tm) {
   using vertex_descriptor = typename SurfaceMesh::Vertex_index;
 
   manifold::MeshGL64 meshgl;
 
   meshgl.numProp = 3;
   meshgl.vertProperties.resize(tm.number_of_vertices() * 3);
-  for (vertex_descriptor vd : tm.vertices()){
-    const auto& v = tm.point(vd);
+  for (vertex_descriptor vd : tm.vertices()) {
+    const auto &v = tm.point(vd);
     meshgl.vertProperties[3 * vd] = v.x();
     meshgl.vertProperties[3 * vd + 1] = v.y();
     meshgl.vertProperties[3 * vd + 2] = v.z();
   }
 
   meshgl.triVerts.reserve(tm.number_of_faces() * 3);
-  for (const auto& f : tm.faces()) {
+  for (const auto &f : tm.faces()) {
     size_t idx[3];
     size_t i = 0;
     for (vertex_descriptor vd : vertices_around_face(tm.halfedge(f), tm)) {
-      if (i >= 3) break;
+      if (i >= 3)
+        break;
       idx[i++] = vd;
     }
-    if (i < 3) continue;
+    if (i < 3)
+      continue;
     for (size_t j : {0, 1, 2})
       meshgl.triVerts.emplace_back(idx[j]);
   }
 
-  assert((meshgl.triVerts.size() == tm.number_of_faces() * 3) || !"Mesh was not triangular!");
+  assert((meshgl.triVerts.size() == tm.number_of_faces() * 3) ||
+         !"Mesh was not triangular!");
 
   auto mani = manifold::Manifold(meshgl).AsOriginal();
   if (mani.Status() != Error::NoError) {
@@ -286,17 +305,17 @@ std::shared_ptr<ManifoldGeometry> createManifoldFromSurfaceMesh(const SurfaceMes
 }
 
 template <class SurfaceMesh>
-std::shared_ptr<SurfaceMesh> createSurfaceMeshFromManifold(const manifold::Manifold& mani)
-{
+std::shared_ptr<SurfaceMesh>
+createSurfaceMeshFromManifold(const manifold::Manifold &mani) {
   const auto meshgl = mani.GetMeshGL64();
   auto mesh = std::make_shared<SurfaceMesh>();
   mesh->reserve(meshgl.NumVert(), meshgl.NumTri() * 3, meshgl.NumTri());
   for (auto i = 0; i < meshgl.NumVert(); i++) {
-    const auto& v = meshgl.GetVertPos(i);
+    const auto &v = meshgl.GetVertPos(i);
     mesh->add_vertex(typename SurfaceMesh::Point(v[0], v[1], v[2]));
   }
   for (auto i = 0; i < meshgl.NumTri(); i++) {
-    const auto& tri = meshgl.GetTriVerts(i);
+    const auto &tri = meshgl.GetTriVerts(i);
     mesh->add_face(typename SurfaceMesh::Vertex_index(tri[0]),
                    typename SurfaceMesh::Vertex_index(tri[1]),
                    typename SurfaceMesh::Vertex_index(tri[2]));
@@ -305,10 +324,16 @@ std::shared_ptr<SurfaceMesh> createSurfaceMeshFromManifold(const manifold::Manif
 }
 
 #ifdef ENABLE_CGAL
-template std::shared_ptr<ManifoldGeometry> createManifoldFromSurfaceMesh(const CGAL::Surface_mesh<CGAL::Point_3<CGAL::Epick>>& tm);
-template std::shared_ptr<ManifoldGeometry> createManifoldFromSurfaceMesh(const CGAL_DoubleMesh& tm);
-template std::shared_ptr<CGAL::Surface_mesh<manifold::vec3>> createSurfaceMeshFromManifold<CGAL::Surface_mesh<manifold::vec3>>(const manifold::Manifold& mani);
-template std::shared_ptr<CGAL::Surface_mesh<CGAL_Point_3>> createSurfaceMeshFromManifold<CGAL::Surface_mesh<CGAL_Point_3>>(const manifold::Manifold& mani);
+template std::shared_ptr<ManifoldGeometry> createManifoldFromSurfaceMesh(
+    const CGAL::Surface_mesh<CGAL::Point_3<CGAL::Epick>> &tm);
+template std::shared_ptr<ManifoldGeometry>
+createManifoldFromSurfaceMesh(const CGAL_DoubleMesh &tm);
+template std::shared_ptr<CGAL::Surface_mesh<manifold::vec3>>
+createSurfaceMeshFromManifold<CGAL::Surface_mesh<manifold::vec3>>(
+    const manifold::Manifold &mani);
+template std::shared_ptr<CGAL::Surface_mesh<CGAL_Point_3>>
+createSurfaceMeshFromManifold<CGAL::Surface_mesh<CGAL_Point_3>>(
+    const manifold::Manifold &mani);
 #endif
 
-}  // namespace ManifoldUtils
+} // namespace ManifoldUtils
diff --git a/src/geometry/manifold/manifoldutils.h b/src/geometry/manifold/manifoldutils.h
index 475869f9f..0dd9281ce 100644
--- a/src/geometry/manifold/manifoldutils.h
+++ b/src/geometry/manifold/manifoldutils.h
@@ -4,8 +4,8 @@
 
 #include <CGAL/Surface_mesh/Surface_mesh.h>
 
-#include "geometry/Geometry.h"
 #include "core/enums.h"
+#include "geometry/Geometry.h"
 #include "geometry/manifold/ManifoldGeometry.h"
 #include "manifold/manifold.h"
 
@@ -13,22 +13,30 @@ namespace ManifoldUtils {
 
 const char *statusToString(manifold::Manifold::Error status);
 
-std::shared_ptr<ManifoldGeometry> createManifoldFromPolySet(const PolySet& ps);
-std::shared_ptr<const ManifoldGeometry> createManifoldFromGeometry(const std::shared_ptr<const Geometry>& geom);
+std::shared_ptr<ManifoldGeometry> createManifoldFromPolySet(const PolySet &ps);
+std::shared_ptr<const ManifoldGeometry>
+createManifoldFromGeometry(const std::shared_ptr<const Geometry> &geom);
 
 template <class SurfaceMesh>
-std::shared_ptr<ManifoldGeometry> createManifoldFromSurfaceMesh(const SurfaceMesh& mesh);
+std::shared_ptr<ManifoldGeometry>
+createManifoldFromSurfaceMesh(const SurfaceMesh &mesh);
 template <typename SurfaceMesh>
-std::shared_ptr<SurfaceMesh> createSurfaceMeshFromManifold(const manifold::Manifold& mani);
+std::shared_ptr<SurfaceMesh>
+createSurfaceMeshFromManifold(const manifold::Manifold &mani);
 
-std::shared_ptr<ManifoldGeometry> applyOperator3DManifold(const Geometry::Geometries& children, OpenSCADOperator op);
+std::shared_ptr<ManifoldGeometry>
+applyOperator3DManifold(const Geometry::Geometries &children,
+                        OpenSCADOperator op);
 
-Polygon2d polygonsToPolygon2d(const manifold::Polygons& polygons);
+Polygon2d polygonsToPolygon2d(const manifold::Polygons &polygons);
 
 #ifdef ENABLE_CGAL
-// FIXME: This shouldn't return const, but it does due to internal implementation details.
-std::shared_ptr<const Geometry> applyMinkowski(const Geometry::Geometries& children);
+// FIXME: This shouldn't return const, but it does due to internal
+// implementation details.
+std::shared_ptr<const Geometry>
+applyMinkowski(const Geometry::Geometries &children);
 #endif
 
-std::unique_ptr<PolySet> createTriangulatedPolySetFromPolygon2d(const Polygon2d& polygon2d);
-}
+std::unique_ptr<PolySet>
+createTriangulatedPolySetFromPolygon2d(const Polygon2d &polygon2d);
+} // namespace ManifoldUtils
diff --git a/src/geometry/roof_ss.cc b/src/geometry/roof_ss.cc
index 2d781b76b..bfe7a839a 100644
--- a/src/geometry/roof_ss.cc
+++ b/src/geometry/roof_ss.cc
@@ -3,17 +3,17 @@
 
 #include "geometry/roof_ss.h"
 
-#include <vector>
 #include <clipper2/clipper.engine.h>
-#include <iterator>
 #include <functional>
+#include <iterator>
 #include <memory>
+#include <vector>
 
 #include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
+#include <CGAL/Partition_traits_2.h>
 #include <CGAL/Polygon_with_holes_2.h>
 #include <CGAL/create_straight_skeleton_from_polygon_with_holes_2.h>
 #include <CGAL/partition_2.h>
-#include <CGAL/Partition_traits_2.h>
 #if CGAL_VERSION_NR < CGAL_VERSION_NUMBER(6, 0, 0)
 #include <boost/shared_ptr.hpp>
 #endif
@@ -21,15 +21,17 @@
 #include <algorithm>
 #include <map>
 
-#include "geometry/linalg.h"
-#include "geometry/Polygon2d.h"
-#include "geometry/GeometryUtils.h"
-#include "geometry/ClipperUtils.h"
 #include "core/RoofNode.h"
+#include "geometry/ClipperUtils.h"
+#include "geometry/GeometryUtils.h"
 #include "geometry/PolySetBuilder.h"
+#include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 
-#define RAISE_ROOF_EXCEPTION(message) \
-        throw RoofNode::roof_exception((boost::format("%s line %d: %s") % __FILE__ % __LINE__ % (message)).str());
+#define RAISE_ROOF_EXCEPTION(message)                                          \
+  throw RoofNode::roof_exception(                                              \
+      (boost::format("%s line %d: %s") % __FILE__ % __LINE__ % (message))      \
+          .str());
 
 namespace roof_ss {
 
@@ -50,8 +52,8 @@ using CGAL_SsPtr = boost::shared_ptr<CGAL_Ss>;
 using CGAL_SsPtr = std::shared_ptr<CGAL_Ss>;
 #endif
 
-CGAL_Polygon_2 to_cgal_polygon_2(const Clipper2Lib::Path64& path, int scale_bits)
-{
+CGAL_Polygon_2 to_cgal_polygon_2(const Clipper2Lib::Path64 &path,
+                                 int scale_bits) {
   CGAL_Polygon_2 poly;
   const double scale = std::ldexp(1.0, -scale_bits);
   for (auto v : path) {
@@ -61,58 +63,64 @@ CGAL_Polygon_2 to_cgal_polygon_2(const Clipper2Lib::Path64& path, int scale_bits
 }
 
 // break a list of outlines into polygons with holes
-std::vector<CGAL_Polygon_with_holes_2> polygons_with_holes(const Clipper2Lib::PolyTree64& polytree, int scale_bits)
-{
+std::vector<CGAL_Polygon_with_holes_2>
+polygons_with_holes(const Clipper2Lib::PolyTree64 &polytree, int scale_bits) {
   std::vector<CGAL_Polygon_with_holes_2> ret;
 
   // lambda for recursive walk through polytree
-  std::function<void (const Clipper2Lib::PolyPath64&)> walk = [&](const Clipper2Lib::PolyPath64& c) {
-      // outer path
-      CGAL_Polygon_with_holes_2 c_poly(to_cgal_polygon_2(c.Polygon(), scale_bits));
-      // holes
-      for (const auto& cc : c) {
-        c_poly.add_hole(to_cgal_polygon_2(cc->Polygon(), scale_bits));
-        for (const auto& ccc : *cc)
-          walk(*ccc);
-      }
-      ret.push_back(c_poly);
-      return;
-    };
+  std::function<void(const Clipper2Lib::PolyPath64 &)> walk =
+      [&](const Clipper2Lib::PolyPath64 &c) {
+        // outer path
+        CGAL_Polygon_with_holes_2 c_poly(
+            to_cgal_polygon_2(c.Polygon(), scale_bits));
+        // holes
+        for (const auto &cc : c) {
+          c_poly.add_hole(to_cgal_polygon_2(cc->Polygon(), scale_bits));
+          for (const auto &ccc : *cc)
+            walk(*ccc);
+        }
+        ret.push_back(c_poly);
+        return;
+      };
 
-  for (const auto& root_node : polytree)
+  for (const auto &root_node : polytree)
     walk(*root_node);
 
   return ret;
 }
 
-std::unique_ptr<PolySet> straight_skeleton_roof(const Polygon2d& poly)
-{
+std::unique_ptr<PolySet> straight_skeleton_roof(const Polygon2d &poly) {
   PolySetBuilder hatbuilder;
 
   const int scale_bits = ClipperUtils::scaleBitsFromPrecision();
-  const Clipper2Lib::Paths64 paths = ClipperUtils::fromPolygon2d(poly, scale_bits);
-  const std::unique_ptr<Clipper2Lib::PolyTree64> polytree = ClipperUtils::sanitize(paths);
+  const Clipper2Lib::Paths64 paths =
+      ClipperUtils::fromPolygon2d(poly, scale_bits);
+  const std::unique_ptr<Clipper2Lib::PolyTree64> polytree =
+      ClipperUtils::sanitize(paths);
   auto poly_sanitized = ClipperUtils::toPolygon2d(*polytree, scale_bits);
 
   try {
     // roof
-    const std::vector<CGAL_Polygon_with_holes_2> shapes = polygons_with_holes(*polytree, scale_bits);
-    for (const CGAL_Polygon_with_holes_2& shape : shapes) {
+    const std::vector<CGAL_Polygon_with_holes_2> shapes =
+        polygons_with_holes(*polytree, scale_bits);
+    for (const CGAL_Polygon_with_holes_2 &shape : shapes) {
       const CGAL_SsPtr ss = CGAL::create_interior_straight_skeleton_2(shape);
       // store heights of vertices
-      auto vector2d_comp = [](const Vector2d& a, const Vector2d& b) {
-          return (a[0] < b[0]) || (a[0] == b[0] && a[1] < b[1]);
-        };
-      std::map<Vector2d, double, decltype(vector2d_comp)> heights(vector2d_comp);
+      auto vector2d_comp = [](const Vector2d &a, const Vector2d &b) {
+        return (a[0] < b[0]) || (a[0] == b[0] && a[1] < b[1]);
+      };
+      std::map<Vector2d, double, decltype(vector2d_comp)> heights(
+          vector2d_comp);
       for (auto v = ss->vertices_begin(); v != ss->vertices_end(); v++) {
         const Vector2d p(v->point().x(), v->point().y());
         heights[p] = v->time();
       }
 
-      for (auto ss_face = ss->faces_begin(); ss_face != ss->faces_end(); ss_face++) {
+      for (auto ss_face = ss->faces_begin(); ss_face != ss->faces_end();
+           ss_face++) {
         // convert ss_face to cgal polygon
         CGAL_Polygon_2 face;
-        for (auto h = ss_face->halfedge(); ;) {
+        for (auto h = ss_face->halfedge();;) {
           const CGAL_Point_2 pp = h->vertex()->point();
           face.push_back(pp);
           h = h->next();
@@ -121,19 +129,23 @@ std::unique_ptr<PolySet> straight_skeleton_roof(const Polygon2d& poly)
           }
         }
         if (!face.is_simple()) {
-          RAISE_ROOF_EXCEPTION("A non-simple face in straight skeleton, likely cause is cgal issue #5177");
+          RAISE_ROOF_EXCEPTION("A non-simple face in straight skeleton, likely "
+                               "cause is cgal issue #5177");
         }
 
         // do convex partition if necessary
         std::vector<CGAL_PT::Polygon_2> facets;
-        CGAL::approx_convex_partition_2(face.vertices_begin(), face.vertices_end(),
+        CGAL::approx_convex_partition_2(face.vertices_begin(),
+                                        face.vertices_end(),
                                         std::back_inserter(facets));
 
-        for (const auto& facet : facets) {
+        for (const auto &facet : facets) {
           std::vector<int> roof;
-          for (auto v = facet.vertices_begin(); v != facet.vertices_end(); v++) {
+          for (auto v = facet.vertices_begin(); v != facet.vertices_end();
+               v++) {
             const Vector2d vv(v->x(), v->y());
-            roof.push_back(hatbuilder.vertexIndex(Vector3d(v->x(), v->y(), heights[vv])));
+            roof.push_back(
+                hatbuilder.vertexIndex(Vector3d(v->x(), v->y(), heights[vv])));
           }
           hatbuilder.appendPolygon(roof);
         }
@@ -145,7 +157,7 @@ std::unique_ptr<PolySet> straight_skeleton_roof(const Polygon2d& poly)
       // poly has to go through clipper just as it does for the roof
       // because this may change coordinates
       auto tess = poly_sanitized->tessellate();
-      for (const IndexedFace& triangle : tess->indices) {
+      for (const IndexedFace &triangle : tess->indices) {
         std::vector<int> floor;
         for (const int tv : triangle) {
           floor.push_back(hatbuilder.vertexIndex(tess->vertices[tv]));
@@ -157,9 +169,9 @@ std::unique_ptr<PolySet> straight_skeleton_roof(const Polygon2d& poly)
     }
 
     return hatbuilder.build();
-  } catch (RoofNode::roof_exception& e) {
+  } catch (RoofNode::roof_exception &e) {
     throw;
   }
 }
 
-} // roof_ss
+} // namespace roof_ss
diff --git a/src/geometry/roof_ss.h b/src/geometry/roof_ss.h
index 4d1817946..64af425d7 100644
--- a/src/geometry/roof_ss.h
+++ b/src/geometry/roof_ss.h
@@ -3,10 +3,10 @@
 
 #pragma once
 
-#include <memory>
-#include "geometry/Polygon2d.h"
 #include "geometry/PolySet.h"
+#include "geometry/Polygon2d.h"
+#include <memory>
 
 namespace roof_ss {
-std::unique_ptr<PolySet> straight_skeleton_roof(const Polygon2d& poly);
+std::unique_ptr<PolySet> straight_skeleton_roof(const Polygon2d &poly);
 }
diff --git a/src/geometry/roof_vd.cc b/src/geometry/roof_vd.cc
index de90db677..7dc9a346c 100644
--- a/src/geometry/roof_vd.cc
+++ b/src/geometry/roof_vd.cc
@@ -3,25 +3,27 @@
 
 #include "geometry/roof_vd.h"
 
-#include <ostream>
-#include <cstdint>
-#include <memory>
+#include "geometry/PolySetBuilder.h"
+#include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
+#include <algorithm>
+#include <boost/polygon/voronoi.hpp>
 #include <cmath>
 #include <cstddef>
-#include <algorithm>
+#include <cstdint>
 #include <map>
-#include <boost/polygon/voronoi.hpp>
+#include <memory>
+#include <ostream>
 #include <vector>
-#include "geometry/linalg.h"
-#include "geometry/Polygon2d.h"
-#include "geometry/PolySetBuilder.h"
 
-#include "geometry/GeometryUtils.h"
-#include "geometry/ClipperUtils.h"
 #include "core/RoofNode.h"
+#include "geometry/ClipperUtils.h"
+#include "geometry/GeometryUtils.h"
 
-#define RAISE_ROOF_EXCEPTION(message) \
-        throw RoofNode::roof_exception((boost::format("%s line %d: %s") % __FILE__ % __LINE__ % (message)).str());
+#define RAISE_ROOF_EXCEPTION(message)                                          \
+  throw RoofNode::roof_exception(                                              \
+      (boost::format("%s line %d: %s") % __FILE__ % __LINE__ % (message))      \
+          .str());
 
 namespace roof_vd {
 
@@ -33,7 +35,7 @@ struct Point {
   VD_int a;
   VD_int b;
   Point(VD_int x, VD_int y) : a(x), b(y) {}
-  friend std::ostream& operator<<(std::ostream& os, const Point& point) {
+  friend std::ostream &operator<<(std::ostream &os, const Point &point) {
     return os << "(" << point.a << ", " << point.b << ")";
   }
 };
@@ -41,77 +43,72 @@ struct Point {
 struct Segment {
   Point p0;
   Point p1;
-  Segment(VD_int x1, VD_int y1, VD_int x2, VD_int y2) : p0(x1, y1), p1(x2, y2) {}
-  friend std::ostream& operator<<(std::ostream& os, const Segment& segment) {
+  Segment(VD_int x1, VD_int y1, VD_int x2, VD_int y2)
+      : p0(x1, y1), p1(x2, y2) {}
+  friend std::ostream &operator<<(std::ostream &os, const Segment &segment) {
     return os << segment.p0 << " -- " << segment.p1;
   }
 };
 
-} // roof_vd
+} // namespace roof_vd
 
 // pass our Point and Segment structures to boost::polygon
 namespace boost::polygon {
-template <>
-struct geometry_concept<roof_vd::Point> {
+template <> struct geometry_concept<roof_vd::Point> {
   using type = point_concept;
 };
-template <>
-struct point_traits<roof_vd::Point> {
+template <> struct point_traits<roof_vd::Point> {
   using coordinate_type = roof_vd::VD_int;
 
-  static inline coordinate_type get(
-    const roof_vd::Point& point, const orientation_2d& orient) {
+  static inline coordinate_type get(const roof_vd::Point &point,
+                                    const orientation_2d &orient) {
     return (orient == HORIZONTAL) ? point.a : point.b;
   }
 };
-template <>
-struct geometry_concept<roof_vd::Segment> {
+template <> struct geometry_concept<roof_vd::Segment> {
   using type = segment_concept;
 };
-template <>
-struct segment_traits<roof_vd::Segment> {
+template <> struct segment_traits<roof_vd::Segment> {
   using coordinate_type = roof_vd::VD_int;
   using point_type = roof_vd::Point;
 
-  static inline point_type get(const roof_vd::Segment& segment, const direction_1d& dir) {
+  static inline point_type get(const roof_vd::Segment &segment,
+                               const direction_1d &dir) {
     return dir.to_int() ? segment.p1 : segment.p0;
   }
 };
-}  // boost::polygon
-
+} // namespace boost::polygon
 
 namespace roof_vd {
 
-bool operator==(const Point& lhs, const Point& rhs)
-{
-  return lhs.a == rhs.a  &&  lhs.b == rhs.b;
+bool operator==(const Point &lhs, const Point &rhs) {
+  return lhs.a == rhs.a && lhs.b == rhs.b;
 }
 
-bool operator==(const Segment& lhs, const Segment& rhs)
-{
-  return lhs.p0 == rhs.p0  &&  lhs.p1 == rhs.p1;
+bool operator==(const Segment &lhs, const Segment &rhs) {
+  return lhs.p0 == rhs.p0 && lhs.p1 == rhs.p1;
 }
 
-bool segment_has_endpoint(const Segment& segment, const Point& point) {
+bool segment_has_endpoint(const Segment &segment, const Point &point) {
   return segment.p0 == point || segment.p1 == point;
 }
 
-double distance_to_segment(const Vector2d& vertex, const Segment& segment) {
-  Vector2d segment_normal(-(segment.p1.b - segment.p0.b), segment.p1.a - segment.p0.a);
+double distance_to_segment(const Vector2d &vertex, const Segment &segment) {
+  Vector2d segment_normal(-(segment.p1.b - segment.p0.b),
+                          segment.p1.a - segment.p0.a);
   segment_normal.normalize();
   Vector2d p0_to_vertex(vertex[0] - segment.p0.a, vertex[1] - segment.p0.b);
   return std::abs(segment_normal.dot(p0_to_vertex));
 }
 
-double distance_to_point(const Vector2d& vertex, const Point& point) {
+double distance_to_point(const Vector2d &vertex, const Point &point) {
   Vector2d point_to_vertex(vertex[0] - point.a, vertex[1] - point.b);
   return point_to_vertex.norm();
 }
 
-std::vector<Vector2d> discretize_arc(const Point& point, const Segment& segment,
-                                     const Vector2d& v0, const Vector2d& v1,
-                                     double fa, double fs)
-{
+std::vector<Vector2d> discretize_arc(const Point &point, const Segment &segment,
+                                     const Vector2d &v0, const Vector2d &v1,
+                                     double fa, double fs) {
   std::vector<Vector2d> ret;
 
   const double max_angle_deviation = M_PI / 180.0 * fa / 2.0;
@@ -122,7 +119,8 @@ std::vector<Vector2d> discretize_arc(const Point& point, const Segment& segment,
   const Vector2d p1(segment.p1.a, segment.p1.b);
   const Vector2d p0_to_p1_norm = (p1 - p0).normalized();
 
-  const Vector2d projected_point = p0 + p0_to_p1_norm * p0_to_p1_norm.dot(p - p0);
+  const Vector2d projected_point =
+      p0 + p0_to_p1_norm * p0_to_p1_norm.dot(p - p0);
 
   const double point_distance = (p - projected_point).norm();
 
@@ -136,7 +134,8 @@ std::vector<Vector2d> discretize_arc(const Point& point, const Segment& segment,
   // segment parallel to the x axes on the negative side
   //     a_point -> A(a_point - point)
   Eigen::Matrix2d A, Ai;
-  Ai << point_direction.y(), point_direction.x(), -point_direction.x(), point_direction.y();
+  Ai << point_direction.y(), point_direction.x(), -point_direction.x(),
+      point_direction.y();
   A = Ai.inverse();
 
   // x coordinates of source and target
@@ -146,35 +145,34 @@ std::vector<Vector2d> discretize_arc(const Point& point, const Segment& segment,
     RAISE_ROOF_EXCEPTION("error in parabolic arc discretization");
   }
 
-  // in transformed coordinates the parabola has equation y = (x^2 - point_distance^2) / (2 point_distance)
+  // in transformed coordinates the parabola has equation y = (x^2 -
+  // point_distance^2) / (2 point_distance)
   auto y = [point_distance](double x) {
-      return (x * x - point_distance * point_distance) / (2 * point_distance);
-    };
-  auto y_prime = [point_distance](double x) {
-      return x / point_distance;
-    };
+    return (x * x - point_distance * point_distance) / (2 * point_distance);
+  };
+  auto y_prime = [point_distance](double x) { return x / point_distance; };
   // angle between a segment and the parabola
-  auto segment_angle = [y, y_prime](double x1, double x2){
-      double dx = x2 - x1,
-       dy = y(x2) - y(x1);
-      double tx = 1,
-             ty = (std::abs(x1) < std::abs(x2)) ? y_prime(x1) : y_prime(x2);
-      return std::abs(std::atan2(dx * ty - dy * tx, dx * tx + dy * ty));
-    };
+  auto segment_angle = [y, y_prime](double x1, double x2) {
+    double dx = x2 - x1, dy = y(x2) - y(x1);
+    double tx = 1,
+           ty = (std::abs(x1) < std::abs(x2)) ? y_prime(x1) : y_prime(x2);
+    return std::abs(std::atan2(dx * ty - dy * tx, dx * tx + dy * ty));
+  };
   // squared length of segment
-  auto segment_sqr_length = [y](double x1, double x2){
-      double dx = x2 - x1,
-       dy = y(x2) - y(x1);
-      return dx * dx + dy * dy;
-    };
+  auto segment_sqr_length = [y](double x1, double x2) {
+    double dx = x2 - x1, dy = y(x2) - y(x1);
+    return dx * dx + dy * dy;
+  };
 
-  std::vector<double> transformed_points_x = {transformed_v0_x, transformed_v1_x};
+  std::vector<double> transformed_points_x = {transformed_v0_x,
+                                              transformed_v1_x};
 
   for (;;) {
     double x1 = transformed_points_x.end()[-2];
     double x2 = transformed_points_x.end()[-1];
     if (segment_angle(x1, x2) > max_angle_deviation ||
-        (max_segment_sqr_length > 0 && segment_sqr_length(x1, x2) > max_segment_sqr_length)) {
+        (max_segment_sqr_length > 0 &&
+         segment_sqr_length(x1, x2) > max_segment_sqr_length)) {
       transformed_points_x.end()[-1] = 0.5 * x1 + 0.5 * x2;
     } else {
       if (x2 == transformed_v1_x) {
@@ -201,7 +199,7 @@ std::vector<Vector2d> discretize_arc(const Point& point, const Segment& segment,
 // a structure that saves 2d faces and heights of vertices
 struct Faces_2_plus_1 {
   struct Vector2d_comp {
-    bool operator()(const Vector2d& lhs, const Vector2d& rhs) const {
+    bool operator()(const Vector2d &lhs, const Vector2d &rhs) const {
       return (lhs[0] < rhs[0]) || (lhs[0] == rhs[0] && lhs[1] < rhs[1]);
     }
   };
@@ -209,35 +207,40 @@ struct Faces_2_plus_1 {
   std::map<Vector2d, double, Vector2d_comp> heights;
 };
 
-Faces_2_plus_1 vd_inner_faces(const voronoi_diagram& vd,
-                              const std::vector<Segment>& segments,
-                              double fa, double fs) {
+Faces_2_plus_1 vd_inner_faces(const voronoi_diagram &vd,
+                              const std::vector<Segment> &segments, double fa,
+                              double fs) {
   Faces_2_plus_1 ret;
 
-  auto cell_contains_boundary_point = [&segments](const voronoi_diagram::cell_type *cell,
-                                                  const Point& point) {
-      Segment segment = segments[cell->source_index()];
-      return (cell->contains_segment() && segment_has_endpoint(segment, point) )
-             || (cell->source_category() == ::boost::polygon::SOURCE_CATEGORY_SEGMENT_START_POINT
-                 && segment.p0 == point)
-             || (cell->source_category() == ::boost::polygon::SOURCE_CATEGORY_SEGMENT_END_POINT
-                 && segment.p1 == point);
-    };
-
-  for (const auto& cell : vd.cells()) {
+  auto cell_contains_boundary_point =
+      [&segments](const voronoi_diagram::cell_type *cell, const Point &point) {
+        Segment segment = segments[cell->source_index()];
+        return (cell->contains_segment() &&
+                segment_has_endpoint(segment, point)) ||
+               (cell->source_category() ==
+                    ::boost::polygon::SOURCE_CATEGORY_SEGMENT_START_POINT &&
+                segment.p0 == point) ||
+               (cell->source_category() ==
+                    ::boost::polygon::SOURCE_CATEGORY_SEGMENT_END_POINT &&
+                segment.p1 == point);
+      };
+
+  for (const auto &cell : vd.cells()) {
 
     std::size_t cell_index = cell.source_index();
     if (cell.is_degenerate()) {
       RAISE_ROOF_EXCEPTION("Voronoi error");
     }
-    const Segment& segment = segments[cell_index];
+    const Segment &segment = segments[cell_index];
 
     if (cell.contains_segment()) {
-      // walk around the cell, find edge starting from segment.p1 or passing through it
+      // walk around the cell, find edge starting from segment.p1 or passing
+      // through it
       const voronoi_diagram::edge_type *edge = cell.incident_edge();
       for (;;) {
-        if (cell_contains_boundary_point(edge->twin()->cell(), segment.p1)
-            && !cell_contains_boundary_point(edge->next()->twin()->cell(), segment.p1)) {
+        if (cell_contains_boundary_point(edge->twin()->cell(), segment.p1) &&
+            !cell_contains_boundary_point(edge->next()->twin()->cell(),
+                                          segment.p1)) {
           break;
         }
         edge = edge->next();
@@ -264,11 +267,14 @@ Faces_2_plus_1 vd_inner_faces(const voronoi_diagram& vd,
           }
           Segment twin_segment = segments[twin_cell->source_index()];
           Point twin_point =
-            (twin_cell->source_category() == ::boost::polygon::SOURCE_CATEGORY_SEGMENT_START_POINT) ?
-            twin_segment.p0 : twin_segment.p1;
+              (twin_cell->source_category() ==
+               ::boost::polygon::SOURCE_CATEGORY_SEGMENT_START_POINT)
+                  ? twin_segment.p0
+                  : twin_segment.p1;
           Vector2d v0(edge->vertex0()->x(), edge->vertex0()->y()),
-          v1(edge->vertex1()->x(), edge->vertex1()->y());
-          std::vector<Vector2d> discr = discretize_arc(twin_point, segment, v1, v0, fa, fs);
+              v1(edge->vertex1()->x(), edge->vertex1()->y());
+          std::vector<Vector2d> discr =
+              discretize_arc(twin_point, segment, v1, v0, fa, fs);
           std::reverse(discr.begin(), discr.end());
           for (std::size_t k = 1; k < discr.size(); k++) {
             ret.faces.back().push_back(discr[k]);
@@ -284,32 +290,36 @@ Faces_2_plus_1 vd_inner_faces(const voronoi_diagram& vd,
       }
     } else { // point cell
       const voronoi_diagram::edge_type *edge = cell.incident_edge();
-      const Point point = (cell.source_category() == ::boost::polygon::SOURCE_CATEGORY_SEGMENT_START_POINT) ?
-        segment.p0 : segment.p1;
-      while (!(edge->is_secondary() && edge->prev()->is_secondary() )) {
+      const Point point =
+          (cell.source_category() ==
+           ::boost::polygon::SOURCE_CATEGORY_SEGMENT_START_POINT)
+              ? segment.p0
+              : segment.p1;
+      while (!(edge->is_secondary() && edge->prev()->is_secondary())) {
         edge = edge->next();
         if (edge == cell.incident_edge()) {
           RAISE_ROOF_EXCEPTION("Voronoi error");
         }
       }
 
-      auto add_triangle = [&ret, &point](const Vector2d& v0, const Vector2d& v1) {
-          ret.faces.emplace_back();
+      auto add_triangle = [&ret, &point](const Vector2d &v0,
+                                         const Vector2d &v1) {
+        ret.faces.emplace_back();
 
-          Vector2d p(point.a, point.b);
-          ret.faces.back().push_back(p);
-          ret.heights[p] = 0.0;
+        Vector2d p(point.a, point.b);
+        ret.faces.back().push_back(p);
+        ret.heights[p] = 0.0;
 
-          ret.faces.back().push_back(v0);
-          ret.heights[v0] = distance_to_point(v0, point);
+        ret.faces.back().push_back(v0);
+        ret.heights[v0] = distance_to_point(v0, point);
 
-          ret.faces.back().push_back(v1);
-          ret.heights[v1] = distance_to_point(v1, point);
-        };
+        ret.faces.back().push_back(v1);
+        ret.heights[v1] = distance_to_point(v1, point);
+      };
 
       if (edge->next()->next() != edge &&
           segments[edge->twin()->cell()->source_index()].p0 ==
-          segments[edge->prev()->twin()->cell()->source_index()].p1) {
+              segments[edge->prev()->twin()->cell()->source_index()].p1) {
         // inner non-degenerate cell
         for (;;) {
           edge = edge->next();
@@ -317,10 +327,12 @@ Faces_2_plus_1 vd_inner_faces(const voronoi_diagram& vd,
             break;
           } else {
             Vector2d v0(edge->vertex0()->x(), edge->vertex0()->y()),
-            v1(edge->vertex1()->x(), edge->vertex1()->y());
+                v1(edge->vertex1()->x(), edge->vertex1()->y());
             if (edge->is_curved()) {
-              Segment twin_segment = segments[edge->twin()->cell()->source_index()];
-              std::vector<Vector2d> discr = discretize_arc(point, twin_segment, v0, v1, fa, fs);
+              Segment twin_segment =
+                  segments[edge->twin()->cell()->source_index()];
+              std::vector<Vector2d> discr =
+                  discretize_arc(point, twin_segment, v0, v1, fa, fs);
               for (std::size_t k = 1; k < discr.size(); k++) {
                 add_triangle(discr[k - 1], discr[k]);
               }
@@ -335,8 +347,8 @@ Faces_2_plus_1 vd_inner_faces(const voronoi_diagram& vd,
   return ret;
 }
 
-std::unique_ptr<PolySet> voronoi_diagram_roof(const Polygon2d& poly, double fa, double fs)
-{
+std::unique_ptr<PolySet> voronoi_diagram_roof(const Polygon2d &poly, double fa,
+                                              double fs) {
   PolySetBuilder hatbuilder = PolySetBuilder();
 
   try {
@@ -344,11 +356,13 @@ std::unique_ptr<PolySet> voronoi_diagram_roof(const Polygon2d& poly, double fa,
     // input data for voronoi diagram is 32 bit integers
     // FIXME: Why does this need to be 32 bits? The default we use elsewhere is
     // scaleBitsFromPrecision(DEFAULT_PRECISION) which is 10^8.
-    const int scale_bits = ClipperUtils::scaleBitsFromBounds(poly.getBoundingBox(), 32);
+    const int scale_bits =
+        ClipperUtils::scaleBitsFromBounds(poly.getBoundingBox(), 32);
     const double scale = std::ldexp(1.0, scale_bits);
 
     Clipper2Lib::Paths64 paths = ClipperUtils::fromPolygon2d(poly, scale_bits);
-    // sanitize is important e.g. when after converting to 32 bit integers we have double points
+    // sanitize is important e.g. when after converting to 32 bit integers we
+    // have double points
     paths = Clipper2Lib::PolyTreeToPaths64(*ClipperUtils::sanitize(paths));
     std::vector<Segment> segments;
 
@@ -365,17 +379,18 @@ std::unique_ptr<PolySet> voronoi_diagram_roof(const Polygon2d& poly, double fa,
     Faces_2_plus_1 inner_faces = vd_inner_faces(vd, segments, fa, scale * fs);
 
     // roof
-    for (const std::vector<Vector2d>& face : inner_faces.faces) {
+    for (const std::vector<Vector2d> &face : inner_faces.faces) {
       if (!(face.size() >= 3)) {
         RAISE_ROOF_EXCEPTION("Voronoi error");
       }
-      // convex partition (actually a triangulation - maybe do a proper convex partition later)
+      // convex partition (actually a triangulation - maybe do a proper convex
+      // partition later)
       Polygon2d face_poly;
       Outline2d outline;
       outline.vertices = face;
       face_poly.addOutline(outline);
       auto tess = face_poly.tessellate();
-      for (const IndexedFace& triangle : tess->indices) {
+      for (const IndexedFace &triangle : tess->indices) {
         std::vector<int> roof;
         for (int tvind : triangle) {
           Vector3d tv = tess->vertices[tvind];
@@ -384,7 +399,8 @@ std::unique_ptr<PolySet> voronoi_diagram_roof(const Polygon2d& poly, double fa,
           if (!(inner_faces.heights.find(v) != inner_faces.heights.end())) {
             RAISE_ROOF_EXCEPTION("Voronoi error");
           }
-          roof.push_back(hatbuilder.vertexIndex(Vector3d(v[0] / scale, v[1] / scale, inner_faces.heights[v] / scale)));
+          roof.push_back(hatbuilder.vertexIndex(Vector3d(
+              v[0] / scale, v[1] / scale, inner_faces.heights[v] / scale)));
         }
         hatbuilder.appendPolygon(roof);
       }
@@ -395,7 +411,7 @@ std::unique_ptr<PolySet> voronoi_diagram_roof(const Polygon2d& poly, double fa,
       // poly has to go through clipper just as it does for the roof
       // because this may change coordinates
       Polygon2d poly_floor;
-      for (const auto& path : paths) {
+      for (const auto &path : paths) {
         Outline2d o;
         for (auto p : path) {
           o.vertices.push_back({p.x / scale, p.y / scale});
@@ -403,7 +419,7 @@ std::unique_ptr<PolySet> voronoi_diagram_roof(const Polygon2d& poly, double fa,
         poly_floor.addOutline(o);
       }
       auto tess = poly_floor.tessellate();
-      for (const IndexedFace& triangle : tess->indices) {
+      for (const IndexedFace &triangle : tess->indices) {
         std::vector<int> floor;
         for (const int tv : triangle) {
           floor.push_back(hatbuilder.vertexIndex(tess->vertices[tv]));
@@ -413,11 +429,11 @@ std::unique_ptr<PolySet> voronoi_diagram_roof(const Polygon2d& poly, double fa,
         hatbuilder.appendPolygon(floor);
       }
     }
-  } catch (RoofNode::roof_exception& e) {
+  } catch (RoofNode::roof_exception &e) {
     throw;
   }
 
   return hatbuilder.build();
 }
 
-} // roof_vd
+} // namespace roof_vd
diff --git a/src/geometry/roof_vd.h b/src/geometry/roof_vd.h
index 6744bf464..0bad1a816 100644
--- a/src/geometry/roof_vd.h
+++ b/src/geometry/roof_vd.h
@@ -3,10 +3,11 @@
 
 #pragma once
 
-#include <memory>
-#include "geometry/Polygon2d.h"
 #include "geometry/PolySet.h"
+#include "geometry/Polygon2d.h"
+#include <memory>
 
 namespace roof_vd {
-std::unique_ptr<PolySet> voronoi_diagram_roof(const Polygon2d& poly, double fa, double fs);
+std::unique_ptr<PolySet> voronoi_diagram_roof(const Polygon2d &poly, double fa,
+                                              double fs);
 }
diff --git a/src/geometry/rotate_extrude.cc b/src/geometry/rotate_extrude.cc
index 00e565885..31fe8b63b 100644
--- a/src/geometry/rotate_extrude.cc
+++ b/src/geometry/rotate_extrude.cc
@@ -2,30 +2,30 @@
 
 #include <algorithm>
 #include <cassert>
-#include <cstddef>
 #include <cmath>
+#include <cstddef>
 #include <iterator>
 #include <memory>
 #include <utility>
 #include <vector>
 
 #include "core/RotateExtrudeNode.h"
-#include "geometry/GeometryUtils.h"
 #include "geometry/Geometry.h"
+#include "geometry/GeometryUtils.h"
+#include "geometry/PolySet.h"
 #include "geometry/PolySetBuilder.h"
 #include "geometry/PolySetUtils.h"
 #include "geometry/Polygon2d.h"
 #include "geometry/linalg.h"
-#include "geometry/PolySet.h"
 #include "utils/calc.h"
 #include "utils/degree_trig.h"
 #include "utils/printutils.h"
 
-static std::unique_ptr<PolySet> assemblePolySetForManifold(const Polygon2d& polyref,
-                                                           std::vector<Vector3d>& vertices,
-                                                           PolygonIndices& indices, bool closed, int convexity,
-                                                           int index_offset, bool flip_faces)
-{
+static std::unique_ptr<PolySet>
+assemblePolySetForManifold(const Polygon2d &polyref,
+                           std::vector<Vector3d> &vertices,
+                           PolygonIndices &indices, bool closed, int convexity,
+                           int index_offset, bool flip_faces) {
   auto final_polyset = std::make_unique<PolySet>(3, false);
   final_polyset->setTriangular(true);
   final_polyset->setConvexity(convexity);
@@ -34,19 +34,19 @@ static std::unique_ptr<PolySet> assemblePolySetForManifold(const Polygon2d& poly
 
   if (!closed) {
     // Create top and bottom face.
-    auto ps_bottom = polyref.tessellate();  // bottom
+    auto ps_bottom = polyref.tessellate(); // bottom
     // Flip vertex ordering for bottom polygon unless flip_faces is true
     if (!flip_faces) {
-      for (auto& p : ps_bottom->indices) {
+      for (auto &p : ps_bottom->indices) {
         std::reverse(p.begin(), p.end());
       }
     }
     std::copy(ps_bottom->indices.begin(), ps_bottom->indices.end(),
               std::back_inserter(final_polyset->indices));
 
-    for (auto& p : ps_bottom->indices) {
+    for (auto &p : ps_bottom->indices) {
       std::reverse(p.begin(), p.end());
-      for (auto& i : p) {
+      for (auto &i : p) {
         i += index_offset;
       }
     }
@@ -54,14 +54,14 @@ static std::unique_ptr<PolySet> assemblePolySetForManifold(const Polygon2d& poly
               std::back_inserter(final_polyset->indices));
   }
 
-//  LOG(PolySetUtils::polySetToPolyhedronSource(*final_polyset));
+  //  LOG(PolySetUtils::polySetToPolyhedronSource(*final_polyset));
 
   return final_polyset;
 }
 
 /*!
-   Input to extrude should be clean. This means non-intersecting, correct winding order
-   etc., the input coming from a library like Clipper.
+   Input to extrude should be clean. This means non-intersecting, correct
+   winding order etc., the input coming from a library like Clipper.
 
    FIXME: We should handle some common corner cases better:
    o 2D polygon having an edge being on the Y axis:
@@ -71,60 +71,67 @@ static std::unique_ptr<PolySet> assemblePolySetForManifold(const Polygon2d& poly
     This is more complex as the resulting geometry will (may?) be nonmanifold.
     In any case, the previous case is a specialization of this, so the following
     should be handled for both cases:
-    Since the ring associated with this vertex will have a radius of zero, it will
-    collapse to one vertex. Any quad using this ring will be collapsed to a triangle.
+    Since the ring associated with this vertex will have a radius of zero, it
+   will collapse to one vertex. Any quad using this ring will be collapsed to a
+   triangle.
 
    Currently, we generate a lot of zero-area triangles
  */
-std::unique_ptr<Geometry> rotatePolygon(const RotateExtrudeNode& node, const Polygon2d& poly)
-{
-  if (node.angle == 0) return nullptr;
+std::unique_ptr<Geometry> rotatePolygon(const RotateExtrudeNode &node,
+                                        const Polygon2d &poly) {
+  if (node.angle == 0)
+    return nullptr;
 
   double min_x = 0;
   double max_x = 0;
-  for (const auto& o : poly.outlines()) {
-    for (const auto& v : o.vertices) {
+  for (const auto &o : poly.outlines()) {
+    for (const auto &v : o.vertices) {
       min_x = fmin(min_x, v[0]);
       max_x = fmax(max_x, v[0]);
     }
   }
 
   if (max_x > 0 && min_x < 0) {
-    LOG(
-      message_group::Error,
-      "all points for rotate_extrude() must have the same X coordinate sign (range is %1$.2f -> %2$.2f)",
-      min_x, max_x);
+    LOG(message_group::Error,
+        "all points for rotate_extrude() must have the same X coordinate sign "
+        "(range is %1$.2f -> %2$.2f)",
+        min_x, max_x);
     return nullptr;
   }
 
-  // # of sections. For closed rotations, # vertices is thus fragments*outline_size. For open
-  // rotations # vertices is (fragments+1)*outline_size.
+  // # of sections. For closed rotations, # vertices is thus
+  // fragments*outline_size. For open rotations # vertices is
+  // (fragments+1)*outline_size.
   const auto num_sections = (unsigned int)std::ceil(fmax(
-                                                      Calc::get_fragments_from_r(max_x - min_x, node.fn, node.fs, node.fa) * std::abs(node.angle) / 360,
-                                                      1));
+      Calc::get_fragments_from_r(max_x - min_x, node.fn, node.fs, node.fa) *
+          std::abs(node.angle) / 360,
+      1));
   const bool closed = node.angle == 360;
   // # of rings of vertices
   const int num_rings = num_sections + (closed ? 0 : 1);
 
-  const bool flip_faces = (min_x >= 0 && node.angle > 0) || (min_x < 0 && node.angle < 0);
+  const bool flip_faces =
+      (min_x >= 0 && node.angle > 0) || (min_x < 0 && node.angle < 0);
 
   // slice_stride is the number of vertices in a single ring
   size_t slice_stride = 0;
-  for (const auto& o : poly.outlines()) {
+  for (const auto &o : poly.outlines()) {
     slice_stride += o.vertices.size();
   }
   const int num_vertices = slice_stride * num_rings;
   std::vector<Vector3d> vertices;
   vertices.reserve(num_vertices);
   PolygonIndices indices;
-  indices.reserve(slice_stride * num_rings * 2);  // sides + endcaps if needed
+  indices.reserve(slice_stride * num_rings * 2); // sides + endcaps if needed
 
   // Calculate all vertices
   for (unsigned int j = 0; j < num_rings; ++j) {
-    for (const auto& outline : poly.outlines()) {
-      const double angle = node.start + j * node.angle / num_sections;  // start on the X axis
-      for (const auto& v : outline.vertices) {
-        vertices.emplace_back(v[0] * cos_degrees(angle), v[0] * sin_degrees(angle), v[1]);
+    for (const auto &outline : poly.outlines()) {
+      const double angle =
+          node.start + j * node.angle / num_sections; // start on the X axis
+      for (const auto &v : outline.vertices) {
+        vertices.emplace_back(v[0] * cos_degrees(angle),
+                              v[0] * sin_degrees(angle), v[1]);
       }
     }
   }
@@ -134,32 +141,32 @@ std::unique_ptr<Geometry> rotatePolygon(const RotateExtrudeNode& node, const Pol
     const int prev_slice = (slice_idx - 1) * slice_stride;
     const int curr_slice = slice_idx * slice_stride;
     int curr_outline = 0;
-    for (const auto& outline : poly.outlines()) {
+    for (const auto &outline : poly.outlines()) {
       assert(outline.vertices.size() > 2);
       for (int i = 1; i <= outline.vertices.size(); ++i) {
         const int curr_idx = curr_outline + (i % outline.vertices.size());
         const int prev_idx = curr_outline + i - 1;
         if (flip_faces) {
           indices.push_back({
-            (prev_slice + prev_idx) % num_vertices,
-            (curr_slice + curr_idx) % num_vertices,
-            (prev_slice + curr_idx) % num_vertices,
+              (prev_slice + prev_idx) % num_vertices,
+              (curr_slice + curr_idx) % num_vertices,
+              (prev_slice + curr_idx) % num_vertices,
           });
           indices.push_back({
-            (curr_slice + curr_idx) % num_vertices,
-            (prev_slice + prev_idx) % num_vertices,
-            (curr_slice + prev_idx) % num_vertices,
+              (curr_slice + curr_idx) % num_vertices,
+              (prev_slice + prev_idx) % num_vertices,
+              (curr_slice + prev_idx) % num_vertices,
           });
         } else {
           indices.push_back({
-            (prev_slice + curr_idx) % num_vertices,
-            (curr_slice + curr_idx) % num_vertices,
-            (prev_slice + prev_idx) % num_vertices,
+              (prev_slice + curr_idx) % num_vertices,
+              (curr_slice + curr_idx) % num_vertices,
+              (prev_slice + prev_idx) % num_vertices,
           });
           indices.push_back({
-            (curr_slice + prev_idx) % num_vertices,
-            (prev_slice + prev_idx) % num_vertices,
-            (curr_slice + curr_idx) % num_vertices,
+              (curr_slice + prev_idx) % num_vertices,
+              (prev_slice + prev_idx) % num_vertices,
+              (curr_slice + curr_idx) % num_vertices,
           });
         }
       }
@@ -167,10 +174,12 @@ std::unique_ptr<Geometry> rotatePolygon(const RotateExtrudeNode& node, const Pol
     }
   }
 
-  // TODO(kintel): Without Manifold, we don't have such tessellator available which guarantees to not modify vertices, so we technically may end up with
-  // broken end caps if we build OpenSCAD without ENABLE_MANIFOLD. Should be fixed, but it's low priority and it's not
-  // trivial to come up with a test case for this.
-  return assemblePolySetForManifold(poly, vertices, indices, closed, node.convexity,
-                                    slice_stride * num_sections, flip_faces);
-
+  // TODO(kintel): Without Manifold, we don't have such tessellator available
+  // which guarantees to not modify vertices, so we technically may end up with
+  // broken end caps if we build OpenSCAD without ENABLE_MANIFOLD. Should be
+  // fixed, but it's low priority and it's not trivial to come up with a test
+  // case for this.
+  return assemblePolySetForManifold(poly, vertices, indices, closed,
+                                    node.convexity, slice_stride * num_sections,
+                                    flip_faces);
 }
diff --git a/src/geometry/rotate_extrude.h b/src/geometry/rotate_extrude.h
index 380593fbf..5728c7cb1 100644
--- a/src/geometry/rotate_extrude.h
+++ b/src/geometry/rotate_extrude.h
@@ -6,4 +6,5 @@
 #include "geometry/Geometry.h"
 #include "geometry/Polygon2d.h"
 
-std::unique_ptr<Geometry> rotatePolygon(const RotateExtrudeNode& node, const Polygon2d& poly);
+std::unique_ptr<Geometry> rotatePolygon(const RotateExtrudeNode &node,
+                                        const Polygon2d &poly);
diff --git a/src/glview/Camera.cc b/src/glview/Camera.cc
index c631f31bd..3f01c5f19 100644
--- a/src/glview/Camera.cc
+++ b/src/glview/Camera.cc
@@ -1,8 +1,8 @@
 #include "glview/Camera.h"
 #include "geometry/linalg.h"
 #include "glview/RenderSettings.h"
-#include "utils/printutils.h"
 #include "utils/degree_trig.h"
+#include "utils/printutils.h"
 
 #include <cassert>
 #include <memory>
@@ -15,10 +15,9 @@ constexpr double DEFAULT_FOV = 22.5;
 constexpr int DEFAULT_WIDTH = 512;
 constexpr int DEFAULT_HEIGHT = 512;
 
-}  // namespace
+} // namespace
 
-Camera::Camera() : fov(DEFAULT_FOV)
-{
+Camera::Camera() : fov(DEFAULT_FOV) {
   PRINTD("Camera()");
 
   // gimbal cam values
@@ -29,8 +28,7 @@ Camera::Camera() : fov(DEFAULT_FOV)
   locked = false;
 }
 
-void Camera::setup(std::vector<double> params)
-{
+void Camera::setup(std::vector<double> params) {
   if (params.size() == 7) {
     setVpt(params[0], params[1], params[2]);
     setVpr(params[3], params[4], params[5]);
@@ -41,9 +39,8 @@ void Camera::setup(std::vector<double> params)
     object_trans = -center;
     auto dir = center - eye;
     viewer_distance = dir.norm();
-    object_rot.z() = (!dir[1] && !dir[0]) ? dir[2] < 0 ? 0
-                                           : 180
-                              : -atan2_degrees(dir[1], dir[0]) + 90;
+    object_rot.z() = (!dir[1] && !dir[0]) ? dir[2] < 0 ? 0 : 180
+                                          : -atan2_degrees(dir[1], dir[0]) + 90;
     object_rot.y() = 0;
     Eigen::Vector3d projection(dir[0], dir[1], 0);
     object_rot.x() = -atan2_degrees(dir[2], projection.norm());
@@ -55,8 +52,7 @@ void Camera::setup(std::vector<double> params)
 /*!
    Moves camera so that the given bbox is fully visible.
  */
-void Camera::viewAll(const BoundingBox& bbox)
-{
+void Camera::viewAll(const BoundingBox &bbox) {
   if (bbox.isEmpty()) {
     setVpt(0, 0, 0);
     setVpd(DEFAULT_DISTANCE);
@@ -70,13 +66,14 @@ void Camera::viewAll(const BoundingBox& bbox)
     double bboxRadius = bbox.diagonal().norm() / 2;
     double radius = (bbox.center() + object_trans).norm() + bboxRadius;
     this->viewer_distance = radius / sin_degrees(this->fov / 2);
-    PRINTDB("modified obj trans x y z %f %f %f", object_trans.x() % object_trans.y() % object_trans.z());
-    PRINTDB("modified obj rot   x y z %f %f %f", object_rot.x() % object_rot.y() % object_rot.z());
+    PRINTDB("modified obj trans x y z %f %f %f",
+            object_trans.x() % object_trans.y() % object_trans.z());
+    PRINTDB("modified obj rot   x y z %f %f %f",
+            object_rot.x() % object_rot.y() % object_rot.z());
   }
 }
 
-void Camera::zoom(int zoom, bool relative)
-{
+void Camera::zoom(int zoom, bool relative) {
   if (relative) {
     this->viewer_distance *= pow(0.9, zoom / 120.0);
   } else {
@@ -84,13 +81,9 @@ void Camera::zoom(int zoom, bool relative)
   }
 }
 
-void Camera::setProjection(ProjectionType type)
-{
-  this->projection = type;
-}
+void Camera::setProjection(ProjectionType type) { this->projection = type; }
 
-void Camera::resetView()
-{
+void Camera::resetView() {
   setVpr(55, 0, 25); // set in user space units
   setVpt(0, 0, 0);
   setVpd(DEFAULT_DISTANCE);
@@ -102,9 +95,10 @@ void Camera::resetView()
  * are assigned on top-level, the values are used to change the camera
  * rotation, translation and distance.
  */
-void Camera::updateView(const std::shared_ptr<const FileContext>& context, bool enableWarning)
-{
-  if (locked) return;
+void Camera::updateView(const std::shared_ptr<const FileContext> &context,
+                        bool enableWarning) {
+  if (locked)
+    return;
 
   bool noauto = false;
   double x, y, z;
@@ -114,7 +108,9 @@ void Camera::updateView(const std::shared_ptr<const FileContext>& context, bool
       setVpr(x, y, z);
       noauto = true;
     } else {
-      LOG(message_group::Warning, "Unable to convert $vpr=%1$s to a vec3 or vec2 of numbers", vpr->toEchoString());
+      LOG(message_group::Warning,
+          "Unable to convert $vpr=%1$s to a vec3 or vec2 of numbers",
+          vpr->toEchoString());
     }
   }
 
@@ -124,7 +120,9 @@ void Camera::updateView(const std::shared_ptr<const FileContext>& context, bool
       setVpt(x, y, z);
       noauto = true;
     } else {
-      LOG(message_group::Warning, "Unable to convert $vpt=%1$s to a vec3 or vec2 of numbers", vpt->toEchoString());
+      LOG(message_group::Warning,
+          "Unable to convert $vpt=%1$s to a vec3 or vec2 of numbers",
+          vpt->toEchoString());
     }
   }
 
@@ -134,7 +132,8 @@ void Camera::updateView(const std::shared_ptr<const FileContext>& context, bool
       setVpd(vpd->toDouble());
       noauto = true;
     } else {
-      LOG(message_group::Warning, "Unable to convert $vpd=%1$s to a number", vpd->toEchoString());
+      LOG(message_group::Warning, "Unable to convert $vpd=%1$s to a number",
+          vpd->toEchoString());
     }
   }
 
@@ -144,69 +143,52 @@ void Camera::updateView(const std::shared_ptr<const FileContext>& context, bool
       setVpf(vpf->toDouble());
       noauto = true;
     } else {
-      LOG(message_group::Warning, "Unable to convert $vpf=%1$s to a number", vpf->toEchoString());
+      LOG(message_group::Warning, "Unable to convert $vpf=%1$s to a number",
+          vpf->toEchoString());
     }
   }
 
   if (enableWarning && (viewall || autocenter) && noauto) {
-    LOG(message_group::UI_Warning, "Viewall and autocenter disabled in favor of $vp*");
+    LOG(message_group::UI_Warning,
+        "Viewall and autocenter disabled in favor of $vp*");
     viewall = false;
     autocenter = false;
   }
 }
 
-Eigen::Vector3d Camera::getVpt() const
-{
-  return -object_trans;
-}
+Eigen::Vector3d Camera::getVpt() const { return -object_trans; }
 
-void Camera::setVpt(double x, double y, double z)
-{
+void Camera::setVpt(double x, double y, double z) {
   object_trans << -x, -y, -z;
 }
 
-static double wrap(double angle)
-{
+static double wrap(double angle) {
   return fmod(360.0 + angle, 360.0); // force angle to be 0-360
 }
 
-Eigen::Vector3d Camera::getVpr() const
-{
-  return {wrap(90 - object_rot.x()), wrap(-object_rot.y()), wrap(-object_rot.z())};
+Eigen::Vector3d Camera::getVpr() const {
+  return {wrap(90 - object_rot.x()), wrap(-object_rot.y()),
+          wrap(-object_rot.z())};
 }
 
-void Camera::setVpr(double x, double y, double z)
-{
+void Camera::setVpr(double x, double y, double z) {
   object_rot << wrap(90 - x), wrap(-y), wrap(-z);
 }
 
-void Camera::setVpd(double d)
-{
-  viewer_distance = d;
-}
+void Camera::setVpd(double d) { viewer_distance = d; }
 
-double Camera::zoomValue() const
-{
-  return viewer_distance;
-}
+double Camera::zoomValue() const { return viewer_distance; }
 
-void Camera::setVpf(double f)
-{
-  fov = f;
-}
+void Camera::setVpf(double f) { fov = f; }
 
-double Camera::fovValue() const
-{
-  return fov;
-}
+double Camera::fovValue() const { return fov; }
 
-std::string Camera::statusText() const
-{
+std::string Camera::statusText() const {
   const auto vpt = getVpt();
   const auto vpr = getVpr();
-  boost::format fmt(_("Viewport: translate = [ %.2f %.2f %.2f ], rotate = [ %.2f %.2f %.2f ], distance = %.2f, fov = %.2f"));
-  fmt % vpt.x() % vpt.y() % vpt.z()
-  % vpr.x() % vpr.y() % vpr.z()
-  % viewer_distance % fov;
+  boost::format fmt(_("Viewport: translate = [ %.2f %.2f %.2f ], rotate = [ "
+                      "%.2f %.2f %.2f ], distance = %.2f, fov = %.2f"));
+  fmt % vpt.x() % vpt.y() % vpt.z() % vpr.x() % vpr.y() % vpr.z() %
+      viewer_distance % fov;
   return fmt.str();
 }
diff --git a/src/glview/Camera.h b/src/glview/Camera.h
index 1d76b53c2..e2c65fa49 100644
--- a/src/glview/Camera.h
+++ b/src/glview/Camera.h
@@ -16,17 +16,19 @@
 
  */
 
-#include "geometry/linalg.h"
 #include "core/ScopeContext.h"
+#include "geometry/linalg.h"
+#include <Eigen/Geometry>
 #include <memory>
 #include <string>
 #include <vector>
-#include <Eigen/Geometry>
 
-class Camera
-{
+class Camera {
 public:
-  enum class ProjectionType { ORTHOGONAL, PERSPECTIVE } projection{ProjectionType::PERSPECTIVE};
+  enum class ProjectionType {
+    ORTHOGONAL,
+    PERSPECTIVE
+  } projection{ProjectionType::PERSPECTIVE};
   Camera();
   void setup(std::vector<double> params);
   void gimbalDefaultTranslate();
@@ -35,11 +37,13 @@ public:
   [[nodiscard]] double zoomValue() const;
   [[nodiscard]] double fovValue() const;
   void resetView();
-  void updateView(const std::shared_ptr<const class FileContext>& context, bool enableWarning);
-  void viewAll(const BoundingBox& bbox);
+  void updateView(const std::shared_ptr<const class FileContext> &context,
+                  bool enableWarning);
+  void viewAll(const BoundingBox &bbox);
   [[nodiscard]] std::string statusText() const;
 
-  // accessors to get and set camera settings in the user space format (different for historical reasons)
+  // accessors to get and set camera settings in the user space format
+  // (different for historical reasons)
   [[nodiscard]] Eigen::Vector3d getVpt() const;
   void setVpt(double x, double y, double z);
   [[nodiscard]] Eigen::Vector3d getVpr() const;
diff --git a/src/glview/ColorMap.cc b/src/glview/ColorMap.cc
index 181ae5bb6..b15ed64b0 100644
--- a/src/glview/ColorMap.cc
+++ b/src/glview/ColorMap.cc
@@ -1,45 +1,55 @@
 #include "glview/ColorMap.h"
 #include "core/ColorUtil.h"
-#include "utils/printutils.h"
 #include "platform/PlatformUtils.h"
+#include "utils/printutils.h"
 
 #include <algorithm>
+#include <boost/property_tree/json_parser.hpp>
+#include <cmath>
+#include <exception>
+#include <filesystem>
 #include <iomanip>
-#include <stdexcept>
 #include <list>
-#include <utility>
-#include <exception>
 #include <memory>
-#include <boost/property_tree/json_parser.hpp>
-#include <filesystem>
-#include <cmath>
+#include <stdexcept>
+#include <utility>
 
 namespace fs = std::filesystem;
 
 static const char *DEFAULT_COLOR_SCHEME_NAME = "Cornfield";
 
-RenderColorScheme::RenderColorScheme() : _path("")
-{
+RenderColorScheme::RenderColorScheme() : _path("") {
   _name = DEFAULT_COLOR_SCHEME_NAME;
   _index = 1000;
   _show_in_gui = true;
 
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::BACKGROUND_COLOR, Color4f(0xff, 0xff, 0xe5)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::BACKGROUND_STOP_COLOR, Color4f(0xff, 0xff, 0xe5)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::AXES_COLOR, Color4f(0x00, 0x00, 0x00)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::OPENCSG_FACE_FRONT_COLOR, Color4f(0xf9, 0xd7, 0x2c)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::OPENCSG_FACE_BACK_COLOR, Color4f(0x9d, 0xcb, 0x51)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::CGAL_FACE_FRONT_COLOR, Color4f(0xf9, 0xd7, 0x2c)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::CGAL_FACE_2D_COLOR, Color4f(0x00, 0xbf, 0x99)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::CGAL_FACE_BACK_COLOR, Color4f(0x9d, 0xcb, 0x51)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::CGAL_EDGE_FRONT_COLOR, Color4f(0xff, 0xec, 0x5e)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::CGAL_EDGE_BACK_COLOR, Color4f(0xab, 0xd8, 0x56)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::CGAL_EDGE_2D_COLOR, Color4f(0xff, 0x00, 0x00)));
-  _color_scheme.insert(ColorScheme::value_type(RenderColor::CROSSHAIR_COLOR, Color4f(0x80, 0x00, 0x00)));
-}
-
-RenderColorScheme::RenderColorScheme(const fs::path& path) : _path(path)
-{
+  _color_scheme.insert(ColorScheme::value_type(RenderColor::BACKGROUND_COLOR,
+                                               Color4f(0xff, 0xff, 0xe5)));
+  _color_scheme.insert(ColorScheme::value_type(
+      RenderColor::BACKGROUND_STOP_COLOR, Color4f(0xff, 0xff, 0xe5)));
+  _color_scheme.insert(ColorScheme::value_type(RenderColor::AXES_COLOR,
+                                               Color4f(0x00, 0x00, 0x00)));
+  _color_scheme.insert(ColorScheme::value_type(
+      RenderColor::OPENCSG_FACE_FRONT_COLOR, Color4f(0xf9, 0xd7, 0x2c)));
+  _color_scheme.insert(ColorScheme::value_type(
+      RenderColor::OPENCSG_FACE_BACK_COLOR, Color4f(0x9d, 0xcb, 0x51)));
+  _color_scheme.insert(ColorScheme::value_type(
+      RenderColor::CGAL_FACE_FRONT_COLOR, Color4f(0xf9, 0xd7, 0x2c)));
+  _color_scheme.insert(ColorScheme::value_type(RenderColor::CGAL_FACE_2D_COLOR,
+                                               Color4f(0x00, 0xbf, 0x99)));
+  _color_scheme.insert(ColorScheme::value_type(
+      RenderColor::CGAL_FACE_BACK_COLOR, Color4f(0x9d, 0xcb, 0x51)));
+  _color_scheme.insert(ColorScheme::value_type(
+      RenderColor::CGAL_EDGE_FRONT_COLOR, Color4f(0xff, 0xec, 0x5e)));
+  _color_scheme.insert(ColorScheme::value_type(
+      RenderColor::CGAL_EDGE_BACK_COLOR, Color4f(0xab, 0xd8, 0x56)));
+  _color_scheme.insert(ColorScheme::value_type(RenderColor::CGAL_EDGE_2D_COLOR,
+                                               Color4f(0xff, 0x00, 0x00)));
+  _color_scheme.insert(ColorScheme::value_type(RenderColor::CROSSHAIR_COLOR,
+                                               Color4f(0x80, 0x00, 0x00)));
+}
+
+RenderColorScheme::RenderColorScheme(const fs::path &path) : _path(path) {
   try {
     boost::property_tree::read_json(path.generic_string().c_str(), pt);
     _name = pt.get<std::string>("name");
@@ -57,13 +67,14 @@ RenderColorScheme::RenderColorScheme(const fs::path& path) : _path(path)
     addColor(RenderColor::CGAL_EDGE_BACK_COLOR, "cgal-edge-back");
     addColor(RenderColor::CGAL_EDGE_2D_COLOR, "cgal-edge-2d");
     addColor(RenderColor::CROSSHAIR_COLOR, "crosshair");
-    try{
+    try {
       addColor(RenderColor::BACKGROUND_STOP_COLOR, "background-stop");
-    } catch (const std::exception& e) {
+    } catch (const std::exception &e) {
       addColor(RenderColor::BACKGROUND_STOP_COLOR, "background");
     }
-  } catch (const std::exception& e) {
-    LOG("Error reading color scheme file: '%1$s': %2$s", path.generic_string().c_str(), e.what());
+  } catch (const std::exception &e) {
+    LOG("Error reading color scheme file: '%1$s': %2$s",
+        path.generic_string().c_str(), e.what());
     _error = e.what();
     _name = "";
     _index = 0;
@@ -71,49 +82,26 @@ RenderColorScheme::RenderColorScheme(const fs::path& path) : _path(path)
   }
 }
 
-bool RenderColorScheme::valid() const
-{
-  return !_name.empty();
-}
+bool RenderColorScheme::valid() const { return !_name.empty(); }
 
-const std::string& RenderColorScheme::name() const
-{
-  return _name;
-}
+const std::string &RenderColorScheme::name() const { return _name; }
 
-int RenderColorScheme::index() const
-{
-  return _index;
-}
+int RenderColorScheme::index() const { return _index; }
 
-bool RenderColorScheme::showInGui() const
-{
-  return _show_in_gui;
-}
+bool RenderColorScheme::showInGui() const { return _show_in_gui; }
 
-std::string RenderColorScheme::path() const
-{
-  return _path.string();
-}
+std::string RenderColorScheme::path() const { return _path.string(); }
 
-std::string RenderColorScheme::error() const
-{
-  return _error;
-}
+std::string RenderColorScheme::error() const { return _error; }
 
-ColorScheme& RenderColorScheme::colorScheme()
-{
-  return _color_scheme;
-}
+ColorScheme &RenderColorScheme::colorScheme() { return _color_scheme; }
 
-const boost::property_tree::ptree& RenderColorScheme::propertyTree() const
-{
+const boost::property_tree::ptree &RenderColorScheme::propertyTree() const {
   return pt;
 }
 
-void RenderColorScheme::addColor(RenderColor colorKey, const std::string& key)
-{
-  const boost::property_tree::ptree& colors = pt.get_child("colors");
+void RenderColorScheme::addColor(RenderColor colorKey, const std::string &key) {
+  const boost::property_tree::ptree &colors = pt.get_child("colors");
   auto color = colors.get<std::string>(key);
   if ((color.length() == 7) && (color.at(0) == '#')) {
     char *endptr;
@@ -123,12 +111,12 @@ void RenderColorScheme::addColor(RenderColor colorKey, const std::string& key)
     int b = val & 0xff;
     _color_scheme.insert(ColorScheme::value_type(colorKey, Color4f(r, g, b)));
   } else {
-    throw std::invalid_argument(std::string("invalid color value for key '") + key + "': '" + color + "'");
+    throw std::invalid_argument(std::string("invalid color value for key '") +
+                                key + "': '" + color + "'");
   }
 }
 
-ColorMap *ColorMap::inst(bool erase)
-{
+ColorMap *ColorMap::inst(bool erase) {
   static auto *instance = new ColorMap;
   if (erase) {
     delete instance;
@@ -137,25 +125,21 @@ ColorMap *ColorMap::inst(bool erase)
   return instance;
 }
 
-ColorMap::ColorMap()
-{
+ColorMap::ColorMap() {
   colorSchemeSet = enumerateColorSchemes();
   dump();
 }
 
-const char *ColorMap::defaultColorSchemeName() const
-{
+const char *ColorMap::defaultColorSchemeName() const {
   return DEFAULT_COLOR_SCHEME_NAME;
 }
 
-const ColorScheme& ColorMap::defaultColorScheme() const
-{
+const ColorScheme &ColorMap::defaultColorScheme() const {
   return *findColorScheme(DEFAULT_COLOR_SCHEME_NAME);
 }
 
-const ColorScheme *ColorMap::findColorScheme(const std::string& name) const
-{
-  for (const auto& item : colorSchemeSet) {
+const ColorScheme *ColorMap::findColorScheme(const std::string &name) const {
+  for (const auto &item : colorSchemeSet) {
     RenderColorScheme *scheme = item.second.get();
     if (name == scheme->name()) {
       return &scheme->colorScheme();
@@ -164,32 +148,34 @@ const ColorScheme *ColorMap::findColorScheme(const std::string& name) const
   return nullptr;
 }
 
-void ColorMap::dump() const
-{
+void ColorMap::dump() const {
   PRINTD("Listing available color schemes...");
 
   std::list<std::string> names = colorSchemeNames();
   unsigned int length = 0;
-  for (const auto& name : names) {
+  for (const auto &name : names) {
     length = name.length() > length ? name.length() : length;
   }
 
-  for (const auto& item : colorSchemeSet) {
+  for (const auto &item : colorSchemeSet) {
     const RenderColorScheme *cs = item.second.get();
     const char gui = cs->showInGui() ? 'G' : '-';
     if (cs->path().empty()) {
-      PRINTDB("%6d:%c: %s (built-in)", cs->index() % gui % boost::io::group(std::setw(length), cs->name()));
+      PRINTDB("%6d:%c: %s (built-in)",
+              cs->index() % gui %
+                  boost::io::group(std::setw(length), cs->name()));
     } else {
-      PRINTDB("%6d:%c: %s from %s", cs->index() % gui % boost::io::group(std::setw(length), cs->name()) % cs->path());
+      PRINTDB("%6d:%c: %s from %s",
+              cs->index() % gui %
+                  boost::io::group(std::setw(length), cs->name()) % cs->path());
     }
   }
   PRINTD("done.");
 }
 
-std::list<std::string> ColorMap::colorSchemeNames(bool guiOnly) const
-{
+std::list<std::string> ColorMap::colorSchemeNames(bool guiOnly) const {
   std::list<std::string> colorSchemeNames;
-  for (const auto& item : colorSchemeSet) {
+  for (const auto &item : colorSchemeSet) {
     const RenderColorScheme *scheme = item.second.get();
     if (guiOnly && !scheme->showInGui()) {
       continue;
@@ -199,23 +185,26 @@ std::list<std::string> ColorMap::colorSchemeNames(bool guiOnly) const
   return colorSchemeNames;
 }
 
-Color4f ColorMap::getColor(const ColorScheme& cs, const RenderColor rc)
-{
-  if (cs.count(rc)) return cs.at(rc);
-  if (ColorMap::inst()->defaultColorScheme().count(rc)) return ColorMap::inst()->defaultColorScheme().at(rc);
+Color4f ColorMap::getColor(const ColorScheme &cs, const RenderColor rc) {
+  if (cs.count(rc))
+    return cs.at(rc);
+  if (ColorMap::inst()->defaultColorScheme().count(rc))
+    return ColorMap::inst()->defaultColorScheme().at(rc);
   return {0, 0, 0, 127};
 }
 
-void ColorMap::enumerateColorSchemesInPath(colorscheme_set_t& result_set, const fs::path& basePath)
-{
+void ColorMap::enumerateColorSchemesInPath(colorscheme_set_t &result_set,
+                                           const fs::path &basePath) {
   const fs::path color_schemes = basePath / "color-schemes" / "render";
 
-  PRINTDB("Enumerating color schemes from '%s'", color_schemes.generic_string().c_str());
+  PRINTDB("Enumerating color schemes from '%s'",
+          color_schemes.generic_string().c_str());
 
   fs::directory_iterator end_iter;
 
   if (fs::exists(color_schemes) && fs::is_directory(color_schemes)) {
-    for (fs::directory_iterator dir_iter(color_schemes); dir_iter != end_iter; ++dir_iter) {
+    for (fs::directory_iterator dir_iter(color_schemes); dir_iter != end_iter;
+         ++dir_iter) {
       if (!fs::is_regular_file(dir_iter->status())) {
         continue;
       }
@@ -226,25 +215,30 @@ void ColorMap::enumerateColorSchemesInPath(colorscheme_set_t& result_set, const
       }
 
       auto *colorScheme = new RenderColorScheme(path);
-      if (colorScheme->valid() && (findColorScheme(colorScheme->name()) == nullptr)) {
-        result_set.insert(colorscheme_set_t::value_type(colorScheme->index(), std::shared_ptr<RenderColorScheme>(colorScheme)));
+      if (colorScheme->valid() &&
+          (findColorScheme(colorScheme->name()) == nullptr)) {
+        result_set.insert(colorscheme_set_t::value_type(
+            colorScheme->index(),
+            std::shared_ptr<RenderColorScheme>(colorScheme)));
         PRINTDB("Found file '%s' with color scheme '%s' and index %d",
-                colorScheme->path() % colorScheme->name() % colorScheme->index());
+                colorScheme->path() % colorScheme->name() %
+                    colorScheme->index());
       } else {
-        PRINTDB("Invalid file '%s': %s", colorScheme->path() % colorScheme->error());
+        PRINTDB("Invalid file '%s': %s",
+                colorScheme->path() % colorScheme->error());
         delete colorScheme;
       }
     }
   }
 }
 
-ColorMap::colorscheme_set_t ColorMap::enumerateColorSchemes()
-{
+ColorMap::colorscheme_set_t ColorMap::enumerateColorSchemes() {
   colorscheme_set_t result_set;
 
   auto *defaultColorScheme = new RenderColorScheme();
-  result_set.insert(colorscheme_set_t::value_type(defaultColorScheme->index(),
-                                                  std::shared_ptr<RenderColorScheme>(defaultColorScheme)));
+  result_set.insert(colorscheme_set_t::value_type(
+      defaultColorScheme->index(),
+      std::shared_ptr<RenderColorScheme>(defaultColorScheme)));
   enumerateColorSchemesInPath(result_set, PlatformUtils::resourceBasePath());
   enumerateColorSchemesInPath(result_set, PlatformUtils::userConfigPath());
 
diff --git a/src/glview/ColorMap.h b/src/glview/ColorMap.h
index 90ed649f0..0b8e2abc7 100644
--- a/src/glview/ColorMap.h
+++ b/src/glview/ColorMap.h
@@ -1,16 +1,16 @@
 #pragma once
 
 #include <functional>
-#include <memory>
-#include <map>
-#include <string>
 #include <list>
+#include <map>
 #include <memory.h>
+#include <memory>
+#include <string>
 
 #include "geometry/linalg.h"
 
-#include <filesystem>
 #include <boost/property_tree/ptree.hpp>
+#include <filesystem>
 
 namespace fs = std::filesystem;
 
@@ -31,8 +31,7 @@ enum class RenderColor {
 
 using ColorScheme = std::map<RenderColor, Color4f>;
 
-class RenderColorScheme
-{
+class RenderColorScheme {
 private:
   const fs::path _path;
 
@@ -52,45 +51,48 @@ public:
   /**
    * Constructor for reading external JSON files.
    */
-  RenderColorScheme(const fs::path& path);
+  RenderColorScheme(const fs::path &path);
   virtual ~RenderColorScheme() = default;
 
-  [[nodiscard]] const std::string& name() const;
+  [[nodiscard]] const std::string &name() const;
   [[nodiscard]] int index() const;
   [[nodiscard]] bool valid() const;
   [[nodiscard]] bool showInGui() const;
-  ColorScheme& colorScheme();
-  [[nodiscard]] const boost::property_tree::ptree& propertyTree() const;
+  ColorScheme &colorScheme();
+  [[nodiscard]] const boost::property_tree::ptree &propertyTree() const;
 
 private:
   [[nodiscard]] std::string path() const;
   [[nodiscard]] std::string error() const;
-  void addColor(RenderColor colorKey, const std::string& key);
+  void addColor(RenderColor colorKey, const std::string &key);
 
   friend class ColorMap;
 };
 
-class ColorMap
-{
-  using colorscheme_set_t = std::multimap<int, std::shared_ptr<RenderColorScheme>, std::less<>>;
+class ColorMap {
+  using colorscheme_set_t =
+      std::multimap<int, std::shared_ptr<RenderColorScheme>, std::less<>>;
 
 public:
   static ColorMap *inst(bool erase = false);
 
   [[nodiscard]] const char *defaultColorSchemeName() const;
-  [[nodiscard]] const ColorScheme& defaultColorScheme() const;
-  [[nodiscard]] const ColorScheme *findColorScheme(const std::string& name) const;
-  [[nodiscard]] std::list<std::string> colorSchemeNames(bool guiOnly = false) const;
+  [[nodiscard]] const ColorScheme &defaultColorScheme() const;
+  [[nodiscard]] const ColorScheme *
+  findColorScheme(const std::string &name) const;
+  [[nodiscard]] std::list<std::string>
+  colorSchemeNames(bool guiOnly = false) const;
 
-  static Color4f getColor(const ColorScheme& cs, const RenderColor rc);
-  static Color4f getContrastColor(const Color4f& col);
-  static Color4f getColorHSV(const Color4f& col);
+  static Color4f getColor(const ColorScheme &cs, const RenderColor rc);
+  static Color4f getContrastColor(const Color4f &col);
+  static Color4f getColorHSV(const Color4f &col);
 
 private:
   ColorMap();
   virtual ~ColorMap() = default;
   void dump() const;
   colorscheme_set_t enumerateColorSchemes();
-  void enumerateColorSchemesInPath(colorscheme_set_t& result_set, const fs::path& path);
+  void enumerateColorSchemesInPath(colorscheme_set_t &result_set,
+                                   const fs::path &path);
   colorscheme_set_t colorSchemeSet;
 };
diff --git a/src/glview/CsgInfo.h b/src/glview/CsgInfo.h
index 6fd180ca1..c1065547f 100644
--- a/src/glview/CsgInfo.h
+++ b/src/glview/CsgInfo.h
@@ -7,48 +7,51 @@
 #include "core/CSGTreeEvaluator.h"
 #include "core/Tree.h"
 #include "geometry/GeometryEvaluator.h"
-#include "glview/preview/CSGTreeNormalizer.h"
 #include "glview/RenderSettings.h"
+#include "glview/preview/CSGTreeNormalizer.h"
 #include "utils/printutils.h"
 
-
 /*
    Small helper class for compiling and normalizing node trees into CSG products
  */
-class CsgInfo
-{
+class CsgInfo {
 public:
   CsgInfo() = default;
   std::shared_ptr<class CSGProducts> root_products;
   std::shared_ptr<CSGProducts> highlights_products;
   std::shared_ptr<CSGProducts> background_products;
 
-  bool compile_products(const Tree& tree) {
-    auto& root_node = tree.root();
+  bool compile_products(const Tree &tree) {
+    auto &root_node = tree.root();
     GeometryEvaluator geomevaluator(tree);
     CSGTreeEvaluator evaluator(tree, &geomevaluator);
     const std::shared_ptr<CSGNode> csgRoot = evaluator.buildCSGTree(*root_node);
-    std::vector<std::shared_ptr<CSGNode>> highlightNodes = evaluator.getHighlightNodes();
-    std::vector<std::shared_ptr<CSGNode>> backgroundNodes = evaluator.getBackgroundNodes();
+    std::vector<std::shared_ptr<CSGNode>> highlightNodes =
+        evaluator.getHighlightNodes();
+    std::vector<std::shared_ptr<CSGNode>> backgroundNodes =
+        evaluator.getBackgroundNodes();
 
     LOG("Compiling design (CSG Products normalization)...");
     CSGTreeNormalizer normalizer(RenderSettings::inst()->openCSGTermLimit);
     if (csgRoot) {
-      const std::shared_ptr<CSGNode> normalizedRoot = normalizer.normalize(csgRoot);
+      const std::shared_ptr<CSGNode> normalizedRoot =
+          normalizer.normalize(csgRoot);
       if (normalizedRoot) {
         this->root_products = std::make_shared<CSGProducts>();
         this->root_products->import(normalizedRoot);
-        LOG("Normalized CSG tree has %1$d elements", int(this->root_products->size()));
+        LOG("Normalized CSG tree has %1$d elements",
+            int(this->root_products->size()));
       } else {
         this->root_products.reset();
-        LOG(message_group::Warning, "CSG normalization resulted in an empty tree");
+        LOG(message_group::Warning,
+            "CSG normalization resulted in an empty tree");
       }
     }
 
     if (highlightNodes.size() > 0) {
       LOG("Compiling highlights (%1$i CSG Trees)...", highlightNodes.size());
       this->highlights_products = std::make_shared<CSGProducts>();
-      for (auto& highlightNode : highlightNodes) {
+      for (auto &highlightNode : highlightNodes) {
         highlightNode = normalizer.normalize(highlightNode);
         this->highlights_products->import(highlightNode);
       }
@@ -57,7 +60,7 @@ public:
     if (backgroundNodes.size() > 0) {
       LOG("Compiling background (%1$i CSG Trees)...", backgroundNodes.size());
       this->background_products = std::make_shared<CSGProducts>();
-      for (auto& backgroundNode : backgroundNodes) {
+      for (auto &backgroundNode : backgroundNodes) {
         backgroundNode = normalizer.normalize(backgroundNode);
         this->background_products->import(backgroundNode);
       }
diff --git a/src/glview/GLView.cc b/src/glview/GLView.cc
index fb133f138..e0eb3bc25 100644
--- a/src/glview/GLView.cc
+++ b/src/glview/GLView.cc
@@ -1,25 +1,24 @@
 #include "glview/GLView.h"
 #include "geometry/linalg.h"
-#include "glview/system-gl.h"
 #include "glview/ColorMap.h"
 #include "glview/RenderSettings.h"
-#include "utils/printutils.h"
 #include "glview/Renderer.h"
-#include "utils/degree_trig.h"
 #include "glview/hershey.h"
+#include "glview/system-gl.h"
+#include "utils/degree_trig.h"
+#include "utils/printutils.h"
 
-#include <functional>
-#include <memory>
 #include <cmath>
 #include <cstdio>
+#include <functional>
+#include <memory>
 #include <string>
 
 #ifdef ENABLE_OPENCSG
 #include <opencsg.h>
 #endif
 
-GLView::GLView()
-{
+GLView::GLView() {
   aspectratio = 1;
   showedges = false;
   showaxes = false;
@@ -36,30 +35,32 @@ GLView::GLView()
 #endif
 }
 
-GLView::~GLView()
-{
-  teardownShader();
-}
+GLView::~GLView() { teardownShader(); }
 
 void GLView::setupShader() {
-  if (edge_shader) return;
-
-  auto resource = ShaderUtils::compileShaderProgram(ShaderUtils::loadShaderSource("ViewEdges.vert"),
-                                                    ShaderUtils::loadShaderSource("ViewEdges.frag"));
-
-  edge_shader = std::make_unique<ShaderUtils::ShaderInfo>(ShaderUtils::ShaderInfo{
-    .resource = resource,
-    .type = ShaderUtils::ShaderType::EDGE_RENDERING,
-    .uniforms = {
-    },
-    .attributes = {
-      {"barycentric", glGetAttribLocation(resource.shader_program, "barycentric")},
-    },
-  });
+  if (edge_shader)
+    return;
+
+  auto resource = ShaderUtils::compileShaderProgram(
+      ShaderUtils::loadShaderSource("ViewEdges.vert"),
+      ShaderUtils::loadShaderSource("ViewEdges.frag"));
+
+  edge_shader =
+      std::make_unique<ShaderUtils::ShaderInfo>(ShaderUtils::ShaderInfo{
+          .resource = resource,
+          .type = ShaderUtils::ShaderType::EDGE_RENDERING,
+          .uniforms = {},
+          .attributes =
+              {
+                  {"barycentric",
+                   glGetAttribLocation(resource.shader_program, "barycentric")},
+              },
+      });
 }
 
 void GLView::teardownShader() {
-  if (edge_shader == nullptr) return; // if OpenGL context was not initialized
+  if (edge_shader == nullptr)
+    return; // if OpenGL context was not initialized
   if (edge_shader->resource.shader_program) {
     glDeleteProgram(edge_shader->resource.shader_program);
   }
@@ -71,28 +72,23 @@ void GLView::teardownShader() {
   }
 }
 
-void GLView::setRenderer(std::shared_ptr<Renderer> r)
-{
-  this->renderer = r;
-}
+void GLView::setRenderer(std::shared_ptr<Renderer> r) { this->renderer = r; }
 
 /* update the color schemes of the Renderer attached to this GLView
    to match the colorscheme of this GLView.*/
-void GLView::updateColorScheme()
-{
-  if (this->renderer) this->renderer->setColorScheme(*this->colorscheme);
+void GLView::updateColorScheme() {
+  if (this->renderer)
+    this->renderer->setColorScheme(*this->colorscheme);
 }
 
 /* change this GLView's colorscheme to the one given, and update the
    Renderer attached to this GLView as well. */
-void GLView::setColorScheme(const ColorScheme& cs)
-{
+void GLView::setColorScheme(const ColorScheme &cs) {
   this->colorscheme = &cs;
   this->updateColorScheme();
 }
 
-void GLView::setColorScheme(const std::string& cs)
-{
+void GLView::setColorScheme(const std::string &cs) {
   const auto colorscheme = ColorMap::inst()->findColorScheme(cs);
   if (colorscheme) {
     setColorScheme(*colorscheme);
@@ -101,8 +97,7 @@ void GLView::setColorScheme(const std::string& cs)
   }
 }
 
-void GLView::resizeGL(int w, int h)
-{
+void GLView::resizeGL(int w, int h) {
   cam.pixel_width = w;
   cam.pixel_height = h;
   glViewport(0, 0, w, h);
@@ -112,13 +107,9 @@ void GLView::resizeGL(int w, int h)
   setupShader();
 }
 
-void GLView::setCamera(const Camera& cam)
-{
-  this->cam = cam;
-}
+void GLView::setCamera(const Camera &cam) { this->cam = cam; }
 
-void GLView::setupCamera()
-{
+void GLView::setupCamera() {
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();
   auto dist = cam.zoomValue();
@@ -130,8 +121,7 @@ void GLView::setupCamera()
   default:
   case Camera::ProjectionType::ORTHOGONAL: {
     auto height = dist * tan_degrees(cam.fov / 2);
-    glOrtho(-height * aspectratio, height * aspectratio,
-            -height, height,
+    glOrtho(-height * aspectratio, height * aspectratio, -height, height,
             -100 * dist, +100 * dist);
     break;
   }
@@ -139,25 +129,30 @@ void GLView::setupCamera()
   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
   gluLookAt(0.0, -dist, 0.0, // eye
-            0.0, 0.0,   0.0,// center
-            0.0, 0.0,   1.0);// up
+            0.0, 0.0, 0.0,   // center
+            0.0, 0.0, 1.0);  // up
 
   glRotated(cam.object_rot.x(), 1.0, 0.0, 0.0);
   glRotated(cam.object_rot.y(), 0.0, 1.0, 0.0);
   glRotated(cam.object_rot.z(), 0.0, 0.0, 1.0);
-  glTranslated(cam.object_trans[0], cam.object_trans[1], cam.object_trans[2]); // translation be part of modelview matrix!
+  glTranslated(cam.object_trans[0], cam.object_trans[1],
+               cam.object_trans[2]); // translation be part of modelview matrix!
   glGetDoublev(GL_MODELVIEW_MATRIX, this->modelview);
-  glTranslated(-cam.object_trans[0], -cam.object_trans[1], -cam.object_trans[2]);
+  glTranslated(-cam.object_trans[0], -cam.object_trans[1],
+               -cam.object_trans[2]);
   glGetDoublev(GL_PROJECTION_MATRIX, this->projection);
 }
 
-void GLView::paintGL()
-{
+void GLView::paintGL() {
   glDisable(GL_LIGHTING);
-  auto bgcol = ColorMap::getColor(*this->colorscheme, RenderColor::BACKGROUND_COLOR);
-  auto bgstopcol = ColorMap::getColor(*this->colorscheme, RenderColor::BACKGROUND_STOP_COLOR);
-  auto axescolor = ColorMap::getColor(*this->colorscheme, RenderColor::AXES_COLOR);
-  auto crosshaircol = ColorMap::getColor(*this->colorscheme, RenderColor::CROSSHAIR_COLOR);
+  auto bgcol =
+      ColorMap::getColor(*this->colorscheme, RenderColor::BACKGROUND_COLOR);
+  auto bgstopcol = ColorMap::getColor(*this->colorscheme,
+                                      RenderColor::BACKGROUND_STOP_COLOR);
+  auto axescolor =
+      ColorMap::getColor(*this->colorscheme, RenderColor::AXES_COLOR);
+  auto crosshaircol =
+      ColorMap::getColor(*this->colorscheme, RenderColor::CROSSHAIR_COLOR);
 
   glClearColor(bgcol.r(), bgcol.g(), bgcol.b(), 1.0);
   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
@@ -171,7 +166,7 @@ void GLView::paintGL()
     glMatrixMode(GL_MODELVIEW);
     glLoadIdentity();
 
-    //draw screen aligned quad with color gradient
+    // draw screen aligned quad with color gradient
     glBegin(GL_QUADS);
     glColor3f(bgcol.r(), bgcol.g(), bgcol.b());
     glVertex2f(-1.0f, +1.0f);
@@ -187,12 +182,16 @@ void GLView::paintGL()
   setupCamera();
 
   // The crosshair should be fixed at the center of the viewport...
-  if (showcrosshairs) GLView::showCrosshairs(crosshaircol);
-  glTranslated(cam.object_trans.x(), cam.object_trans.y(), cam.object_trans.z());
+  if (showcrosshairs)
+    GLView::showCrosshairs(crosshaircol);
+  glTranslated(cam.object_trans.x(), cam.object_trans.y(),
+               cam.object_trans.z());
   // ...the axis lines need to follow the object translation.
-  if (showaxes) GLView::showAxes(axescolor);
+  if (showaxes)
+    GLView::showAxes(axescolor);
   // mark the scale along the axis lines
-  if (showaxes && showscale) GLView::showScalemarkers(axescolor);
+  if (showaxes && showscale)
+    GLView::showScalemarkers(axescolor);
 
   glEnable(GL_LIGHTING);
   glDepthFunc(GL_LESS);
@@ -203,7 +202,8 @@ void GLView::paintGL()
 
   if (this->renderer) {
 #if defined(ENABLE_OPENCSG)
-    // FIXME: This belongs in the OpenCSG renderer, but it doesn't know about this ID yet
+    // FIXME: This belongs in the OpenCSG renderer, but it doesn't know about
+    // this ID yet
     OpenCSG::setContext(this->opencsg_id);
 #endif
     this->renderer->prepare(edge_shader.get());
@@ -211,27 +211,30 @@ void GLView::paintGL()
   }
   Vector3d eyedir(this->modelview[2], this->modelview[6], this->modelview[10]);
   glColor3f(1, 0, 0);
-  for (const SelectedObject& obj:this->selected_obj) {
+  for (const SelectedObject &obj : this->selected_obj) {
     showObject(obj, eyedir);
   }
   glColor3f(0, 1, 0);
-  for (const SelectedObject& obj: this->shown_obj) {
+  for (const SelectedObject &obj : this->shown_obj) {
     showObject(obj, eyedir);
   }
   glDisable(GL_LIGHTING);
-  if (showaxes) GLView::showSmallaxes(axescolor);
+  if (showaxes)
+    GLView::showSmallaxes(axescolor);
 
-  // Workaround for inconsistent QT behavior related to handling custom OpenGL widgets that
-  // leave non opaque alpha values in final output.
-  // On wayland that can cause window to become transparent or blurry trail effect in the
-  // parts that contain partially transparent objects.
+  // Workaround for inconsistent QT behavior related to handling custom OpenGL
+  // widgets that leave non opaque alpha values in final output. On wayland that
+  // can cause window to become transparent or blurry trail effect in the parts
+  // that contain partially transparent objects.
   //
-  // At the end of rendering clear alpha value, so that it doesn't matter how rest of the
-  // compositing stack at QT and desktop level would interpret transparent pixels.
+  // At the end of rendering clear alpha value, so that it doesn't matter how
+  // rest of the compositing stack at QT and desktop level would interpret
+  // transparent pixels.
   //
   // Solves https://github.com/openscad/openscad/issues/3689.
   //
-  // Originally developed by @karliss for FreeCAD (https://github.com/FreeCAD/FreeCAD/pull/19499).
+  // Originally developed by @karliss for FreeCAD
+  // (https://github.com/FreeCAD/FreeCAD/pull/19499).
   GLboolean mask[4];
   glGetBooleanv(GL_COLOR_WRITEMASK, mask);
   glColorMask(false, false, false, true);
@@ -253,8 +256,7 @@ void glCompileCheck(GLuint shader) {
   }
 }
 
-void GLView::enable_opencsg_shaders()
-{
+void GLView::enable_opencsg_shaders() {
   // All OpenGL 2 contexts are OpenCSG capable
 #ifdef USE_GLEW
   const bool hasOpenGL2_0 = GLEW_VERSION_2_0;
@@ -271,22 +273,20 @@ void GLView::enable_opencsg_shaders()
 }
 #endif // ifdef ENABLE_OPENCSG
 
-
 #ifdef DEBUG
 // Requires OpenGL 4.3+
 /*
-   void GLAPIENTRY MessageCallback(GLenum source, GLenum type, GLuint id, GLenum severity,
-                                  GLsizei length, const GLchar* message, const void* userParam)
+   void GLAPIENTRY MessageCallback(GLenum source, GLenum type, GLuint id, GLenum
+   severity, GLsizei length, const GLchar* message, const void* userParam)
    {
-    fprintf(stderr, "GL CALLBACK: %s type = 0x%X, severity = 0x%X, message = %s\n",
-            (type == GL_DEBUG_TYPE_ERROR ? "** GL ERROR **" : "" ),
-            type, severity, message);
+    fprintf(stderr, "GL CALLBACK: %s type = 0x%X, severity = 0x%X, message =
+   %s\n", (type == GL_DEBUG_TYPE_ERROR ? "** GL ERROR **" : "" ), type,
+   severity, message);
    }
    //*/
 #endif
 
-void GLView::initializeGL()
-{
+void GLView::initializeGL() {
 #ifdef DEBUG
 /*
    // Requires OpenGL 4.3+
@@ -325,8 +325,7 @@ void GLView::initializeGL()
 #endif
 }
 
-void GLView::showSmallaxes(const Color4f& col)
-{
+void GLView::showSmallaxes(const Color4f &col) {
   auto dpi = this->getDPI();
   // Small axis cross in the lower left corner
   glDepthFunc(GL_ALWAYS);
@@ -336,12 +335,9 @@ void GLView::showSmallaxes(const Color4f& col)
   glLoadIdentity();
   glTranslatef(-0.8f, -0.8f, 0.0f);
   auto scale = 90.0;
-  glOrtho(-scale * dpi * aspectratio, scale * dpi * aspectratio,
-          -scale * dpi, scale * dpi,
-          -scale * dpi, scale * dpi);
-  gluLookAt(0.0, -1.0, 0.0,
-            0.0, 0.0, 0.0,
-            0.0, 0.0, 1.0);
+  glOrtho(-scale * dpi * aspectratio, scale * dpi * aspectratio, -scale * dpi,
+          scale * dpi, -scale * dpi, scale * dpi);
+  gluLookAt(0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0);
 
   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
@@ -352,11 +348,14 @@ void GLView::showSmallaxes(const Color4f& col)
   glLineWidth(dpi);
   glBegin(GL_LINES);
   glColor3d(1.0, 0.0, 0.0);
-  glVertex3d(0, 0, 0); glVertex3d(10 * dpi, 0, 0);
+  glVertex3d(0, 0, 0);
+  glVertex3d(10 * dpi, 0, 0);
   glColor3d(0.0, 1.0, 0.0);
-  glVertex3d(0, 0, 0); glVertex3d(0, 10 * dpi, 0);
+  glVertex3d(0, 0, 0);
+  glVertex3d(0, 10 * dpi, 0);
   glColor3d(0.0, 0.0, 1.0);
-  glVertex3d(0, 0, 0); glVertex3d(0, 0, 10 * dpi);
+  glVertex3d(0, 0, 0);
+  glVertex3d(0, 0, 10 * dpi);
   glEnd();
 
   GLdouble mat_model[16];
@@ -369,16 +368,22 @@ void GLView::showSmallaxes(const Color4f& col)
   glGetIntegerv(GL_VIEWPORT, viewport);
 
   GLdouble xlabel_x, xlabel_y, xlabel_z;
-  gluProject(12 * dpi, 0, 0, mat_model, mat_proj, viewport, &xlabel_x, &xlabel_y, &xlabel_z);
-  xlabel_x = std::round(xlabel_x); xlabel_y = std::round(xlabel_y);
+  gluProject(12 * dpi, 0, 0, mat_model, mat_proj, viewport, &xlabel_x,
+             &xlabel_y, &xlabel_z);
+  xlabel_x = std::round(xlabel_x);
+  xlabel_y = std::round(xlabel_y);
 
   GLdouble ylabel_x, ylabel_y, ylabel_z;
-  gluProject(0, 12 * dpi, 0, mat_model, mat_proj, viewport, &ylabel_x, &ylabel_y, &ylabel_z);
-  ylabel_x = std::round(ylabel_x); ylabel_y = std::round(ylabel_y);
+  gluProject(0, 12 * dpi, 0, mat_model, mat_proj, viewport, &ylabel_x,
+             &ylabel_y, &ylabel_z);
+  ylabel_x = std::round(ylabel_x);
+  ylabel_y = std::round(ylabel_y);
 
   GLdouble zlabel_x, zlabel_y, zlabel_z;
-  gluProject(0, 0, 12 * dpi, mat_model, mat_proj, viewport, &zlabel_x, &zlabel_y, &zlabel_z);
-  zlabel_x = std::round(zlabel_x); zlabel_y = std::round(zlabel_y);
+  gluProject(0, 0, 12 * dpi, mat_model, mat_proj, viewport, &zlabel_x,
+             &zlabel_y, &zlabel_z);
+  zlabel_x = std::round(zlabel_x);
+  zlabel_y = std::round(zlabel_y);
 
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();
@@ -393,20 +398,26 @@ void GLView::showSmallaxes(const Color4f& col)
   float d = 3 * dpi;
   glBegin(GL_LINES);
   // X Label
-  glVertex3d(xlabel_x - d, xlabel_y - d, 0); glVertex3d(xlabel_x + d, xlabel_y + d, 0);
-  glVertex3d(xlabel_x - d, xlabel_y + d, 0); glVertex3d(xlabel_x + d, xlabel_y - d, 0);
+  glVertex3d(xlabel_x - d, xlabel_y - d, 0);
+  glVertex3d(xlabel_x + d, xlabel_y + d, 0);
+  glVertex3d(xlabel_x - d, xlabel_y + d, 0);
+  glVertex3d(xlabel_x + d, xlabel_y - d, 0);
   // Y Label
-  glVertex3d(ylabel_x - d, ylabel_y - d, 0); glVertex3d(ylabel_x + d, ylabel_y + d, 0);
-  glVertex3d(ylabel_x - d, ylabel_y + d, 0); glVertex3d(ylabel_x, ylabel_y, 0);
+  glVertex3d(ylabel_x - d, ylabel_y - d, 0);
+  glVertex3d(ylabel_x + d, ylabel_y + d, 0);
+  glVertex3d(ylabel_x - d, ylabel_y + d, 0);
+  glVertex3d(ylabel_x, ylabel_y, 0);
   // Z Label
-  glVertex3d(zlabel_x - d, zlabel_y - d, 0); glVertex3d(zlabel_x + d, zlabel_y - d, 0);
-  glVertex3d(zlabel_x - d, zlabel_y + d, 0); glVertex3d(zlabel_x + d, zlabel_y + d, 0);
-  glVertex3d(zlabel_x - d, zlabel_y - d, 0); glVertex3d(zlabel_x + d, zlabel_y + d, 0);
+  glVertex3d(zlabel_x - d, zlabel_y - d, 0);
+  glVertex3d(zlabel_x + d, zlabel_y - d, 0);
+  glVertex3d(zlabel_x - d, zlabel_y + d, 0);
+  glVertex3d(zlabel_x + d, zlabel_y + d, 0);
+  glVertex3d(zlabel_x - d, zlabel_y - d, 0);
+  glVertex3d(zlabel_x + d, zlabel_y + d, 0);
   glEnd();
 }
 
-void GLView::showAxes(const Color4f& col)
-{
+void GLView::showAxes(const Color4f &col) {
   // Large gray axis cross inline with the model
   glLineWidth(this->getDPI());
   glColor3f(col.r(), col.g(), col.b());
@@ -434,8 +445,7 @@ void GLView::showAxes(const Color4f& col)
   glPopAttrib();
 }
 
-void GLView::showCrosshairs(const Color4f& col)
-{
+void GLView::showCrosshairs(const Color4f &col) {
   glLineWidth(this->getDPI());
   glColor3f(col.r(), col.g(), col.b());
   glBegin(GL_LINES);
@@ -448,36 +458,45 @@ void GLView::showCrosshairs(const Color4f& col)
   glEnd();
 }
 
-void GLView::showObject(const SelectedObject& obj, const Vector3d& eyedir)
-{
+void GLView::showObject(const SelectedObject &obj, const Vector3d &eyedir) {
   auto vd = cam.zoomValue() / 200.0;
   switch (obj.type) {
-  case SelectionType::SELECTION_POINT:
-  {
+  case SelectionType::SELECTION_POINT: {
     double n = 1 / sqrt(3);
     // create an octaeder
-    //x- x+ y- y+ z- z+
-    int sequence[] = { 2, 0, 4, 1, 2, 4, 0, 3, 4, 3, 1, 4, 0, 2, 5, 2, 1, 5, 3, 0, 5, 1, 3, 5 };
+    // x- x+ y- y+ z- z+
+    int sequence[] = {2, 0, 4, 1, 2, 4, 0, 3, 4, 3, 1, 4,
+                      0, 2, 5, 2, 1, 5, 3, 0, 5, 1, 3, 5};
     glBegin(GL_TRIANGLES);
     for (int i = 0; i < 8; i++) {
-      glNormal3f((i & 1)?-n:n, (i & 2)?-n:n, (i & 4)?-n:n);
+      glNormal3f((i & 1) ? -n : n, (i & 2) ? -n : n, (i & 4) ? -n : n);
       for (int j = 0; j < 3; j++) {
         int code = sequence[i * 3 + j];
         switch (code) {
-        case 0: glVertex3d(obj.p1[0] - vd, obj.p1[1], obj.p1[2]); break;
-        case 1: glVertex3d(obj.p1[0] + vd, obj.p1[1], obj.p1[2]); break;
-        case 2: glVertex3d(obj.p1[0], obj.p1[1] - vd, obj.p1[2]); break;
-        case 3: glVertex3d(obj.p1[0], obj.p1[1] + vd, obj.p1[2]); break;
-        case 4: glVertex3d(obj.p1[0], obj.p1[1], obj.p1[2] - vd); break;
-        case 5: glVertex3d(obj.p1[0], obj.p1[1], obj.p1[2] + vd); break;
+        case 0:
+          glVertex3d(obj.p1[0] - vd, obj.p1[1], obj.p1[2]);
+          break;
+        case 1:
+          glVertex3d(obj.p1[0] + vd, obj.p1[1], obj.p1[2]);
+          break;
+        case 2:
+          glVertex3d(obj.p1[0], obj.p1[1] - vd, obj.p1[2]);
+          break;
+        case 3:
+          glVertex3d(obj.p1[0], obj.p1[1] + vd, obj.p1[2]);
+          break;
+        case 4:
+          glVertex3d(obj.p1[0], obj.p1[1], obj.p1[2] - vd);
+          break;
+        case 5:
+          glVertex3d(obj.p1[0], obj.p1[1], obj.p1[2] + vd);
+          break;
         }
       }
     }
     glEnd();
-  }
-  break;
-  case SelectionType::SELECTION_LINE:
-  {
+  } break;
+  case SelectionType::SELECTION_LINE: {
     Vector3d diff = obj.p2 - obj.p1;
     Vector3d wdir = eyedir.cross(diff).normalized() * vd / 2.0;
     glBegin(GL_QUADS);
@@ -486,13 +505,11 @@ void GLView::showObject(const SelectedObject& obj, const Vector3d& eyedir)
     glVertex3d(obj.p2[0] + wdir[0], obj.p2[1] + wdir[1], obj.p2[2] + wdir[2]);
     glVertex3d(obj.p1[0] + wdir[0], obj.p1[1] + wdir[1], obj.p1[2] + wdir[2]);
     glEnd();
-  }
-  break;
+  } break;
   }
 }
 
-void GLView::showScalemarkers(const Color4f& col)
-{
+void GLView::showScalemarkers(const Color4f &col) {
   // Add scale ticks on large axes
   auto l = cam.zoomValue();
   glLineWidth(this->getDPI());
@@ -514,25 +531,26 @@ void GLView::showScalemarkers(const Color4f& col)
   for (auto div = 0; div < divs; ++div) {
     double i = div * tick_width; // i represents the position along the axis
     int size_div;
-    if (line_cnt > 0 && line_cnt % 10 == 0) { // major tick
-      size_div = size_div_sm * .5; // resize to a major tick
+    if (line_cnt > 0 && line_cnt % 10 == 0) {       // major tick
+      size_div = size_div_sm * .5;                  // resize to a major tick
       GLView::decodeMarkerValue(i, l, size_div_sm); // print number
-    } else {        // minor tick
+    } else {                                        // minor tick
       size_div = size_div_sm; // set the minor tick to the standard size
 
-      // Draw additional labels if there are few major tick labels visible due to
-      // zoom. Because the spacing/units of major tick marks only change when the
-      // viewport changes size by a factor of 10, it can be hard to see the
-      // major tick labels when when the viewport is slightly larger than size at
-      // which the last tick spacing change occurred. When zoom level is such
+      // Draw additional labels if there are few major tick labels visible due
+      // to zoom. Because the spacing/units of major tick marks only change when
+      // the viewport changes size by a factor of 10, it can be hard to see the
+      // major tick labels when when the viewport is slightly larger than size
+      // at which the last tick spacing change occurred. When zoom level is such
       // that very few major tick marks are visible, additional labels are drawn
-      // every 2 minor ticks. We can detect that very few major ticks are visible
-      // by checking if the viewport size is larger than the adjusted scale by
-      // only a small ratio.
+      // every 2 minor ticks. We can detect that very few major ticks are
+      // visible by checking if the viewport size is larger than the adjusted
+      // scale by only a small ratio.
       const double more_labels_threshold = 3;
       // draw additional labels every 2 minor ticks
       const int more_labels_freq = 2;
-      if (line_cnt > 0 && line_cnt % more_labels_freq == 0 && l / l_adjusted < more_labels_threshold) {
+      if (line_cnt > 0 && line_cnt % more_labels_freq == 0 &&
+          l / l_adjusted < more_labels_threshold) {
         GLView::decodeMarkerValue(i, l, size_div_sm); // print number
       }
     }
@@ -550,19 +568,25 @@ void GLView::showScalemarkers(const Color4f& col)
     // positive axes
     glBegin(GL_LINES);
     // x
-    glVertex3d(i, 0, 0); glVertex3d(i, -l / size_div, 0); // 1 arm
-    //glVertex3d(i,-l/size_div,0); glVertex3d(i,l/size_div,0); // 2 arms
-    //glVertex3d(i,0,-l/size_div); glVertex3d(i,0,l/size_div); // 4 arms (w/ 2 arms line)
+    glVertex3d(i, 0, 0);
+    glVertex3d(i, -l / size_div, 0); // 1 arm
+    // glVertex3d(i,-l/size_div,0); glVertex3d(i,l/size_div,0); // 2 arms
+    // glVertex3d(i,0,-l/size_div); glVertex3d(i,0,l/size_div); // 4 arms (w/ 2
+    // arms line)
 
     // y
-    glVertex3d(0, i, 0); glVertex3d(-l / size_div, i, 0); // 1 arm
-    //glVertex3d(-l/size_div,i,0); glVertex3d(l/size_div,i,0); // 2 arms
-    //glVertex3d(0,i,-l/size_div); glVertex3d(0,i,l/size_div); // 4 arms (w/ 2 arms line)
+    glVertex3d(0, i, 0);
+    glVertex3d(-l / size_div, i, 0); // 1 arm
+    // glVertex3d(-l/size_div,i,0); glVertex3d(l/size_div,i,0); // 2 arms
+    // glVertex3d(0,i,-l/size_div); glVertex3d(0,i,l/size_div); // 4 arms (w/ 2
+    // arms line)
 
     // z
-    glVertex3d(0, 0, i); glVertex3d(-l / size_div, 0, i); // 1 arm
-    //glVertex3d(-l/size_div,0,i); glVertex3d(l/size_div,0,i); // 2 arms
-    //glVertex3d(0,-l/size_div,i); glVertex3d(0,l/size_div,i); // 4 arms (w/ 2 arms line)
+    glVertex3d(0, 0, i);
+    glVertex3d(-l / size_div, 0, i); // 1 arm
+    // glVertex3d(-l/size_div,0,i); glVertex3d(l/size_div,0,i); // 2 arms
+    // glVertex3d(0,-l/size_div,i); glVertex3d(0,l/size_div,i); // 4 arms (w/ 2
+    // arms line)
     glEnd();
 
     // negative axes
@@ -571,32 +595,37 @@ void GLView::showScalemarkers(const Color4f& col)
     glLineStipple(3, 0xAAAA);
     glBegin(GL_LINES);
     // x
-    glVertex3d(-i, 0, 0); glVertex3d(-i, -l / size_div, 0); // 1 arm
-    //glVertex3d(-i,-l/size_div,0); glVertex3d(-i,l/size_div,0); // 2 arms
-    //glVertex3d(-i,0,-l/size_div); glVertex3d(-i,0,l/size_div); // 4 arms (w/ 2 arms line)
+    glVertex3d(-i, 0, 0);
+    glVertex3d(-i, -l / size_div, 0); // 1 arm
+    // glVertex3d(-i,-l/size_div,0); glVertex3d(-i,l/size_div,0); // 2 arms
+    // glVertex3d(-i,0,-l/size_div); glVertex3d(-i,0,l/size_div); // 4 arms (w/
+    // 2 arms line)
 
     // y
-    glVertex3d(0, -i, 0); glVertex3d(-l / size_div, -i, 0); // 1 arm
-    //glVertex3d(-l/size_div,-i,0); glVertex3d(l/size_div,-i,0); // 2 arms
-    //glVertex3d(0,-i,-l/size_div); glVertex3d(0,-i,l/size_div); // 4 arms (w/ 2 arms line)
+    glVertex3d(0, -i, 0);
+    glVertex3d(-l / size_div, -i, 0); // 1 arm
+    // glVertex3d(-l/size_div,-i,0); glVertex3d(l/size_div,-i,0); // 2 arms
+    // glVertex3d(0,-i,-l/size_div); glVertex3d(0,-i,l/size_div); // 4 arms (w/
+    // 2 arms line)
 
     // z
-    glVertex3d(0, 0, -i); glVertex3d(-l / size_div, 0, -i); // 1 arm
-    //glVertex3d(-l/size_div,0,-i); glVertex3d(l/size_div,0,-i); // 2 arms
-    //glVertex3d(0,-l/size_div,-i); glVertex3d(0,l/size_div,-i); // 4 arms (w/ 2 arms line)
+    glVertex3d(0, 0, -i);
+    glVertex3d(-l / size_div, 0, -i); // 1 arm
+    // glVertex3d(-l/size_div,0,-i); glVertex3d(l/size_div,0,-i); // 2 arms
+    // glVertex3d(0,-l/size_div,-i); glVertex3d(0,l/size_div,-i); // 4 arms (w/
+    // 2 arms line)
     glEnd();
     glPopAttrib();
   }
 }
 
-void GLView::decodeMarkerValue(double i, double l, int size_div_sm)
-{
+void GLView::decodeMarkerValue(double i, double l, int size_div_sm) {
   // We draw both at once the positive and corresponding negative number.
   const std::string pos_number_str = STR(i);
   const std::string neg_number_str = "-" + pos_number_str;
 
   const float font_size = (l / size_div_sm);
-  const float baseline_offset = font_size / 5;  // hovering a bit above axis
+  const float baseline_offset = font_size / 5; // hovering a bit above axis
 
   // Length of the minus sign. We want the digits to be centered around
   // their ticks, but not have the minus prefix shift center of gravity.
@@ -605,39 +634,42 @@ void GLView::decodeMarkerValue(double i, double l, int size_div_sm)
   // Draw functions that help map 2D axis label drawings into their plane.
   // Since we're just on axis, no need for fancy affine transformation,
   // just calling glVertex3d() with coordinates in the right plane.
-  using PlaneVertexDraw = std::function<void (
-                                          float x, float y, float font_height, float baseline_offset)>;
+  using PlaneVertexDraw = std::function<void(
+      float x, float y, float font_height, float baseline_offset)>;
 
   const PlaneVertexDraw axis_draw_planes[3] = {
-    [](float x, float y, float /*fh*/, float bl) {
-      glVertex3d(x, y + bl, 0);  // x-label along x-axis; font drawn above line
-    },
-    [](float x, float y, float fh, float bl) {
-      glVertex3d(-y + (fh + bl), x, 0);  // y-label along y-axis; font below
-    },
-    [](float x, float y, float fh, float bl) {
-      glVertex3d(-y + (fh + bl), 0, x);  // z-label along z-axis; font below
-    },
+      [](float x, float y, float /*fh*/, float bl) {
+        glVertex3d(x, y + bl, 0); // x-label along x-axis; font drawn above line
+      },
+      [](float x, float y, float fh, float bl) {
+        glVertex3d(-y + (fh + bl), x, 0); // y-label along y-axis; font below
+      },
+      [](float x, float y, float fh, float bl) {
+        glVertex3d(-y + (fh + bl), 0, x); // z-label along z-axis; font below
+      },
   };
   bool needs_glend = false;
-  for (const PlaneVertexDraw& axis_draw : axis_draw_planes) {
+  for (const PlaneVertexDraw &axis_draw : axis_draw_planes) {
     // We get 'plot instructions', a sequence of vertices. Translate into gl ops
     const auto plot_fun = [&](bool pen_down, float x, float y) {
-        if (!pen_down) { // Start a new line, coordinates just move not draw
-          if (needs_glend) glEnd();
-          glBegin(GL_LINE_STRIP);
-          needs_glend = true;
-        }
-        axis_draw(x, y, font_size, baseline_offset);
-      };
+      if (!pen_down) { // Start a new line, coordinates just move not draw
+        if (needs_glend)
+          glEnd();
+        glBegin(GL_LINE_STRIP);
+        needs_glend = true;
+      }
+      axis_draw(x, y, font_size, baseline_offset);
+    };
 
-    hershey::DrawText(pos_number_str, i, 0,
-                      hershey::TextAlign::kCenter, font_size, plot_fun);
-    if (needs_glend) glEnd();
+    hershey::DrawText(pos_number_str, i, 0, hershey::TextAlign::kCenter,
+                      font_size, plot_fun);
+    if (needs_glend)
+      glEnd();
     needs_glend = false;
     hershey::DrawText(neg_number_str, -i - prefix_offset, 0,
                       hershey::TextAlign::kCenter, font_size, plot_fun);
-    if (needs_glend) glEnd();
+    if (needs_glend)
+      glEnd();
     needs_glend = false;
   }
 }
diff --git a/src/glview/GLView.h b/src/glview/GLView.h
index 3e32daeb4..37756bed4 100644
--- a/src/glview/GLView.h
+++ b/src/glview/GLView.h
@@ -17,20 +17,19 @@
 
  */
 
-#include <memory>
+#include "core/Selection.h"
+#include "geometry/linalg.h"
+#include "glview/Camera.h"
+#include "glview/ColorMap.h"
+#include "glview/Renderer.h"
+#include "glview/system-gl.h"
 #include <Eigen/Core>
 #include <Eigen/Geometry>
+#include <memory>
 #include <string>
 #include <vector>
-#include "glview/Camera.h"
-#include "geometry/linalg.h"
-#include "glview/ColorMap.h"
-#include "glview/system-gl.h"
-#include "core/Selection.h"
-#include "glview/Renderer.h"
 
-class GLView
-{
+class GLView {
 public:
   GLView();
   virtual ~GLView();
@@ -45,11 +44,11 @@ public:
   void resizeGL(int w, int h);
   virtual void paintGL();
 
-  void setCamera(const Camera& cam);
+  void setCamera(const Camera &cam);
   void setupCamera();
 
-  void setColorScheme(const ColorScheme& cs);
-  void setColorScheme(const std::string& cs);
+  void setColorScheme(const ColorScheme &cs);
+  void setColorScheme(const std::string &cs);
   void updateColorScheme();
 
   [[nodiscard]] bool showAxes() const { return this->showaxes; }
@@ -87,11 +86,12 @@ public:
   virtual void display_opencsg_warning() = 0;
   int opencsg_id;
 #endif
-  void showObject(const SelectedObject& pt, const Vector3d& eyedir);
+  void showObject(const SelectedObject &pt, const Vector3d &eyedir);
+
 private:
-  void showCrosshairs(const Color4f& col);
-  void showAxes(const Color4f& col);
-  void showSmallaxes(const Color4f& col);
-  void showScalemarkers(const Color4f& col);
+  void showCrosshairs(const Color4f &col);
+  void showAxes(const Color4f &col);
+  void showSmallaxes(const Color4f &col);
+  void showScalemarkers(const Color4f &col);
   void decodeMarkerValue(double i, double l, int size_div_sm);
 };
diff --git a/src/glview/NULLGL.cc b/src/glview/NULLGL.cc
index 41e355a86..6af9168d0 100644
--- a/src/glview/NULLGL.cc
+++ b/src/glview/NULLGL.cc
@@ -8,10 +8,10 @@
 #include "geometry/linalg.h"
 #include "glview/Camera.h"
 #include "glview/ColorMap.h"
-#include "glview/Renderer.h"
-#include "glview/fbo.h"
 #include "glview/GLView.h"
 #include "glview/OpenGLContext.h"
+#include "glview/Renderer.h"
+#include "glview/fbo.h"
 #include "glview/system-gl.h"
 
 bool FBO::resize(size_t, size_t) { return false; }
@@ -21,17 +21,23 @@ GLView::~GLView() = default;
 GLView::GLView() = default;
 std::string gl_dump() { return {"GL Renderer: NULLGL\n"}; }
 std::string gl_extensions_dump() { return {"NULLGL Extensions"}; }
-std::unique_ptr<FBO> createFBO(int, int) {return nullptr;}
+std::unique_ptr<FBO> createFBO(int, int) { return nullptr; }
 std::vector<uint8_t> OpenGLContext::getFramebuffer() const { return {}; }
 void FBO::destroy() {}
 void FBO::unbind() {}
 void GLView::initializeGL() {}
 void GLView::paintGL() {}
 void GLView::resizeGL(int w, int h) {}
-void GLView::setCamera(const Camera& /*cam*/) {assert(false && "not implemented");}
-void GLView::setColorScheme(const ColorScheme& /*cs*/){assert(false && "not implemented");}
-void GLView::setColorScheme(const std::string& /*cs*/) {assert(false && "not implemented");}
+void GLView::setCamera(const Camera & /*cam*/) {
+  assert(false && "not implemented");
+}
+void GLView::setColorScheme(const ColorScheme & /*cs*/) {
+  assert(false && "not implemented");
+}
+void GLView::setColorScheme(const std::string & /*cs*/) {
+  assert(false && "not implemented");
+}
 void GLView::setRenderer(std::shared_ptr<Renderer>) {}
-void GLView::showAxes(const Color4f& col) {}
-void GLView::showCrosshairs(const Color4f& col) {}
-void GLView::showSmallaxes(const Color4f& col) {}
\ No newline at end of file
+void GLView::showAxes(const Color4f &col) {}
+void GLView::showCrosshairs(const Color4f &col) {}
+void GLView::showSmallaxes(const Color4f &col) {}
\ No newline at end of file
diff --git a/src/glview/OffscreenContext.h b/src/glview/OffscreenContext.h
index 794b8d68b..fad9d3ecb 100644
--- a/src/glview/OffscreenContext.h
+++ b/src/glview/OffscreenContext.h
@@ -1,10 +1,10 @@
 #pragma once
 
-#include <cstdint>
 #include "glview/OpenGLContext.h"
+#include <cstdint>
 
-class OffscreenContext : public OpenGLContext
-{
+class OffscreenContext : public OpenGLContext {
 public:
-  OffscreenContext(uint32_t width, uint32_t height) : OpenGLContext(width, height) {}
+  OffscreenContext(uint32_t width, uint32_t height)
+      : OpenGLContext(width, height) {}
 };
diff --git a/src/glview/OffscreenContextCGL.cc b/src/glview/OffscreenContextCGL.cc
index 5d8af174e..406121cc3 100644
--- a/src/glview/OffscreenContextCGL.cc
+++ b/src/glview/OffscreenContextCGL.cc
@@ -1,22 +1,20 @@
 #include "glview/OffscreenContextCGL.h"
 
-#include <sstream>
-#include <memory>
 #include <cstddef>
-#include <string>
 #include <iostream>
+#include <memory>
+#include <sstream>
+#include <string>
 
 #include "glview/system-gl.h"
 #include <OpenGL/OpenGL.h>
 
-class OffscreenContextCGL : public OffscreenContext
-{
+class OffscreenContextCGL : public OffscreenContext {
 
 public:
-  OffscreenContextCGL(int width, int height) : OffscreenContext(width, height) {}
-  ~OffscreenContextCGL() {
-    CGLDestroyContext(cglContext);
-  }
+  OffscreenContextCGL(int width, int height)
+      : OffscreenContext(width, height) {}
+  ~OffscreenContextCGL() { CGLDestroyContext(cglContext); }
 
   // FIXME: What info are we really interested in here?
   std::string getInfo() const override {
@@ -33,29 +31,31 @@ public:
   CGLContextObj cglContext = nullptr;
 };
 
-std::shared_ptr<OffscreenContext> CreateOffscreenContextCGL(size_t width, size_t height,
-                                                            size_t majorGLVersion, size_t minorGLVersion)
-{
+std::shared_ptr<OffscreenContext>
+CreateOffscreenContextCGL(size_t width, size_t height, size_t majorGLVersion,
+                          size_t minorGLVersion) {
   auto ctx = std::make_shared<OffscreenContextCGL>(width, height);
 
   CGLOpenGLProfile glVersion = kCGLOGLPVersion_Legacy;
-  if (majorGLVersion >= 4) glVersion = kCGLOGLPVersion_GL4_Core;
-  else if (majorGLVersion >= 3) glVersion = kCGLOGLPVersion_GL3_Core;
+  if (majorGLVersion >= 4)
+    glVersion = kCGLOGLPVersion_GL4_Core;
+  else if (majorGLVersion >= 3)
+    glVersion = kCGLOGLPVersion_GL3_Core;
 
   CGLPixelFormatAttribute attributes[13] = {
-    kCGLPFAOpenGLProfile, (CGLPixelFormatAttribute)glVersion,
-    kCGLPFAColorSize, (CGLPixelFormatAttribute)24,
-    kCGLPFAAlphaSize, (CGLPixelFormatAttribute)8,
-    kCGLPFADoubleBuffer,
-    kCGLPFASampleBuffers, (CGLPixelFormatAttribute)1,
-    kCGLPFASamples,  (CGLPixelFormatAttribute)4,
-    (CGLPixelFormatAttribute) 0
-  };
+      kCGLPFAOpenGLProfile,       (CGLPixelFormatAttribute)glVersion,
+      kCGLPFAColorSize,           (CGLPixelFormatAttribute)24,
+      kCGLPFAAlphaSize,           (CGLPixelFormatAttribute)8,
+      kCGLPFADoubleBuffer,        kCGLPFASampleBuffers,
+      (CGLPixelFormatAttribute)1, kCGLPFASamples,
+      (CGLPixelFormatAttribute)4, (CGLPixelFormatAttribute)0};
   CGLPixelFormatObj pixelFormat = NULL;
   GLint numPixelFormats = 0;
-  const auto status = CGLChoosePixelFormat(attributes, &pixelFormat, &numPixelFormats);
+  const auto status =
+      CGLChoosePixelFormat(attributes, &pixelFormat, &numPixelFormats);
   if (status != kCGLNoError) {
-    std::cerr << "CGLChoosePixelFormat() failed: " << CGLErrorString(status) << std::endl;
+    std::cerr << "CGLChoosePixelFormat() failed: " << CGLErrorString(status)
+              << std::endl;
     return nullptr;
   }
   CGLCreateContext(pixelFormat, NULL, &ctx->cglContext);
diff --git a/src/glview/OffscreenContextCGL.h b/src/glview/OffscreenContextCGL.h
index 0fc65b545..07582b713 100644
--- a/src/glview/OffscreenContextCGL.h
+++ b/src/glview/OffscreenContextCGL.h
@@ -5,5 +5,6 @@
 
 #include "glview/OffscreenContext.h"
 
-std::shared_ptr<OffscreenContext> CreateOffscreenContextCGL(size_t width, size_t height,
-                                                            size_t majorGLVersion, size_t minorGLVersion);
+std::shared_ptr<OffscreenContext>
+CreateOffscreenContextCGL(size_t width, size_t height, size_t majorGLVersion,
+                          size_t minorGLVersion);
diff --git a/src/glview/OffscreenContextEGL.cc b/src/glview/OffscreenContextEGL.cc
index ea811f883..72a3fe5fa 100644
--- a/src/glview/OffscreenContextEGL.cc
+++ b/src/glview/OffscreenContextEGL.cc
@@ -1,8 +1,8 @@
 #include "glview/OffscreenContextEGL.h"
 
-#include <memory>
-#include <fcntl.h>
 #include <cstddef>
+#include <fcntl.h>
+#include <memory>
 #include <set>
 #include <sstream>
 #include <string>
@@ -15,44 +15,48 @@
 
 namespace {
 
-#define CASE_STR(value) case value: return #value;
-const char *eglGetErrorString(EGLint error)
-{
+#define CASE_STR(value)                                                        \
+  case value:                                                                  \
+    return #value;
+const char *eglGetErrorString(EGLint error) {
   switch (error) {
-  CASE_STR(EGL_SUCCESS)
-  CASE_STR(EGL_NOT_INITIALIZED)
-  CASE_STR(EGL_BAD_ACCESS)
-  CASE_STR(EGL_BAD_ALLOC)
-  CASE_STR(EGL_BAD_ATTRIBUTE)
-  CASE_STR(EGL_BAD_CONTEXT)
-  CASE_STR(EGL_BAD_CONFIG)
-  CASE_STR(EGL_BAD_CURRENT_SURFACE)
-  CASE_STR(EGL_BAD_DISPLAY)
-  CASE_STR(EGL_BAD_SURFACE)
-  CASE_STR(EGL_BAD_MATCH)
-  CASE_STR(EGL_BAD_PARAMETER)
-  CASE_STR(EGL_BAD_NATIVE_PIXMAP)
-  CASE_STR(EGL_BAD_NATIVE_WINDOW)
-  CASE_STR(EGL_CONTEXT_LOST)
-  default: return "Unknown";
+    CASE_STR(EGL_SUCCESS)
+    CASE_STR(EGL_NOT_INITIALIZED)
+    CASE_STR(EGL_BAD_ACCESS)
+    CASE_STR(EGL_BAD_ALLOC)
+    CASE_STR(EGL_BAD_ATTRIBUTE)
+    CASE_STR(EGL_BAD_CONTEXT)
+    CASE_STR(EGL_BAD_CONFIG)
+    CASE_STR(EGL_BAD_CURRENT_SURFACE)
+    CASE_STR(EGL_BAD_DISPLAY)
+    CASE_STR(EGL_BAD_SURFACE)
+    CASE_STR(EGL_BAD_MATCH)
+    CASE_STR(EGL_BAD_PARAMETER)
+    CASE_STR(EGL_BAD_NATIVE_PIXMAP)
+    CASE_STR(EGL_BAD_NATIVE_WINDOW)
+    CASE_STR(EGL_CONTEXT_LOST)
+  default:
+    return "Unknown";
   }
 }
 #undef CASE_STR
 
 } // namespace
 
-class OffscreenContextEGL : public OffscreenContext
-{
+class OffscreenContextEGL : public OffscreenContext {
 
 public:
   EGLDisplay eglDisplay;
   EGLSurface eglSurface;
   EGLContext eglContext;
 
-  OffscreenContextEGL(int width, int height) : OffscreenContext(width, height) {}
+  OffscreenContextEGL(int width, int height)
+      : OffscreenContext(width, height) {}
   ~OffscreenContextEGL() {
-    if (this->eglSurface) eglDestroySurface(this->eglDisplay, this->eglSurface);
-    if (this->eglDisplay) eglTerminate(this->eglDisplay);
+    if (this->eglSurface)
+      eglDestroySurface(this->eglDisplay, this->eglSurface);
+    if (this->eglDisplay)
+      eglTerminate(this->eglDisplay);
   }
 
   std::string getInfo() const override {
@@ -68,7 +72,8 @@ public:
   }
 
   bool makeCurrent() const override {
-    return eglMakeCurrent(this->eglDisplay, this->eglSurface, this->eglSurface, this->eglContext);
+    return eglMakeCurrent(this->eglDisplay, this->eglSurface, this->eglSurface,
+                          this->eglContext);
   }
 
   void findPlatformDisplay() {
@@ -81,7 +86,8 @@ public:
       clientExtensions.insert(extension);
     }
 
-    if (clientExtensions.find("EGL_EXT_platform_device") == clientExtensions.end()) {
+    if (clientExtensions.find("EGL_EXT_platform_device") ==
+        clientExtensions.end()) {
       return;
     }
 
@@ -91,18 +97,20 @@ public:
       eglQueryDevicesEXT(1, &eglDevice, &numDevices);
       if (numDevices > 0) {
         // FIXME: Attribs
-        this->eglDisplay = eglGetPlatformDisplayEXT(EGL_PLATFORM_DEVICE_EXT, eglDevice, nullptr);
+        this->eglDisplay = eglGetPlatformDisplayEXT(EGL_PLATFORM_DEVICE_EXT,
+                                                    eglDevice, nullptr);
       }
     }
   }
 
-  void createSurface(const EGLConfig& config, size_t width, size_t height) {
+  void createSurface(const EGLConfig &config, size_t width, size_t height) {
     const EGLint pbufferAttribs[] = {
-      EGL_WIDTH, static_cast<EGLint>(width),
-      EGL_HEIGHT, static_cast<EGLint>(height),
-      EGL_NONE,
+        EGL_WIDTH,  static_cast<EGLint>(width),
+        EGL_HEIGHT, static_cast<EGLint>(height),
+        EGL_NONE,
     };
-    this->eglSurface = eglCreatePbufferSurface(this->eglDisplay, config, pbufferAttribs);
+    this->eglSurface =
+        eglCreatePbufferSurface(this->eglDisplay, config, pbufferAttribs);
   }
 };
 
@@ -110,10 +118,10 @@ public:
 // OpenGL core major.minor
 // OpenGL compatibility major.minor
 // OpenGL ES major.minor
-std::shared_ptr<OffscreenContext> CreateOffscreenContextEGL(size_t width, size_t height,
-                                                            size_t majorGLVersion, size_t minorGLVersion,
-                                                            bool gles, bool compatibilityProfile)
-{
+std::shared_ptr<OffscreenContext>
+CreateOffscreenContextEGL(size_t width, size_t height, size_t majorGLVersion,
+                          size_t minorGLVersion, bool gles,
+                          bool compatibilityProfile) {
   auto ctx = std::make_shared<OffscreenContextEGL>(width, height);
 
   int initialEglVersion = gladLoaderLoadEGL(nullptr);
@@ -122,26 +130,29 @@ std::shared_ptr<OffscreenContext> CreateOffscreenContextEGL(size_t width, size_t
     return nullptr;
   }
   PRINTDB("GLAD: Loaded EGL %d.%d on first load",
-          GLAD_VERSION_MAJOR(initialEglVersion) % GLAD_VERSION_MINOR(initialEglVersion));
+          GLAD_VERSION_MAJOR(initialEglVersion) %
+              GLAD_VERSION_MINOR(initialEglVersion));
 
   EGLint conformant;
-  if (!gles) conformant = EGL_OPENGL_BIT;
-  else if (majorGLVersion >= 3) conformant = EGL_OPENGL_ES3_BIT;
-  else if (majorGLVersion >= 2) conformant = EGL_OPENGL_ES2_BIT;
-  else conformant = EGL_OPENGL_ES_BIT;
-
-  const EGLint configAttribs[] = {
-    EGL_SURFACE_TYPE, EGL_PBUFFER_BIT,
-    EGL_BLUE_SIZE, 8,
-    EGL_GREEN_SIZE, 8,
-    EGL_RED_SIZE, 8,
-    EGL_ALPHA_SIZE, 8,
-    EGL_DEPTH_SIZE, 24,
-    EGL_STENCIL_SIZE, 8,
-    EGL_CONFORMANT, conformant,
-    EGL_CONFIG_CAVEAT, EGL_NONE,
-    EGL_NONE
-  };
+  if (!gles)
+    conformant = EGL_OPENGL_BIT;
+  else if (majorGLVersion >= 3)
+    conformant = EGL_OPENGL_ES3_BIT;
+  else if (majorGLVersion >= 2)
+    conformant = EGL_OPENGL_ES2_BIT;
+  else
+    conformant = EGL_OPENGL_ES_BIT;
+
+  const EGLint configAttribs[] = {EGL_SURFACE_TYPE,  EGL_PBUFFER_BIT,
+                                  EGL_BLUE_SIZE,     8,
+                                  EGL_GREEN_SIZE,    8,
+                                  EGL_RED_SIZE,      8,
+                                  EGL_ALPHA_SIZE,    8,
+                                  EGL_DEPTH_SIZE,    24,
+                                  EGL_STENCIL_SIZE,  8,
+                                  EGL_CONFORMANT,    conformant,
+                                  EGL_CONFIG_CAVEAT, EGL_NONE,
+                                  EGL_NONE};
 
   // FIXME: Should we try default display first?
   // If so, we also have to try initializing it
@@ -161,18 +172,21 @@ std::shared_ptr<OffscreenContext> CreateOffscreenContextEGL(size_t width, size_t
     return nullptr;
   }
 
-  PRINTDB("Initialized EGL version: %d.%d (%s)", major % minor % eglQueryString(ctx->eglDisplay, EGL_VENDOR));
+  PRINTDB("Initialized EGL version: %d.%d (%s)",
+          major % minor % eglQueryString(ctx->eglDisplay, EGL_VENDOR));
 
   const auto eglVersion = gladLoaderLoadEGL(ctx->eglDisplay);
   if (!eglVersion) {
     LOG("gladLoaderLoadEGL(eglDisplay): Unable to reload EGL");
     return nullptr;
   }
-  PRINTDB("GLAD: Loaded EGL %d.%d after reload", GLAD_VERSION_MAJOR(eglVersion) % GLAD_VERSION_MINOR(eglVersion));
+  PRINTDB("GLAD: Loaded EGL %d.%d after reload",
+          GLAD_VERSION_MAJOR(eglVersion) % GLAD_VERSION_MINOR(eglVersion));
 
   EGLint numConfigs;
   EGLConfig config;
-  bool gotConfig = eglChooseConfig(ctx->eglDisplay, configAttribs, &config, 1, &numConfigs);
+  bool gotConfig =
+      eglChooseConfig(ctx->eglDisplay, configAttribs, &config, 1, &numConfigs);
   if (!gotConfig || numConfigs == 0) {
     LOG("Failed to choose config (eglError: %1$x)", eglGetError());
     return nullptr;
@@ -189,15 +203,20 @@ std::shared_ptr<OffscreenContext> CreateOffscreenContextEGL(size_t width, size_t
   }
 
   std::vector<EGLint> ctxattr = {
-    EGL_CONTEXT_MAJOR_VERSION, static_cast<EGLint>(majorGLVersion),
-    EGL_CONTEXT_MINOR_VERSION, static_cast<EGLint>(minorGLVersion),
+      EGL_CONTEXT_MAJOR_VERSION,
+      static_cast<EGLint>(majorGLVersion),
+      EGL_CONTEXT_MINOR_VERSION,
+      static_cast<EGLint>(minorGLVersion),
   };
   if (!gles) {
     ctxattr.push_back(EGL_CONTEXT_OPENGL_PROFILE_MASK);
-    ctxattr.push_back(compatibilityProfile ? EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT : EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT);
+    ctxattr.push_back(compatibilityProfile
+                          ? EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT
+                          : EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT);
   }
   ctxattr.push_back(EGL_NONE);
-  ctx->eglContext = eglCreateContext(ctx->eglDisplay, config, EGL_NO_CONTEXT, ctxattr.data());
+  ctx->eglContext =
+      eglCreateContext(ctx->eglDisplay, config, EGL_NO_CONTEXT, ctxattr.data());
   if (ctx->eglContext == EGL_NO_CONTEXT) {
     LOG("Unable to create EGL context (eglError: %1$x)", eglGetError());
     return nullptr;
diff --git a/src/glview/OffscreenContextEGL.h b/src/glview/OffscreenContextEGL.h
index d446e9970..4238fc23e 100644
--- a/src/glview/OffscreenContextEGL.h
+++ b/src/glview/OffscreenContextEGL.h
@@ -5,6 +5,7 @@
 
 #include "glview/OffscreenContext.h"
 
-std::shared_ptr<OffscreenContext> CreateOffscreenContextEGL(
-  size_t width, size_t height, size_t majorGLVersion,
-  size_t minorGLVersion, bool gles, bool compatibilityProfile);
+std::shared_ptr<OffscreenContext>
+CreateOffscreenContextEGL(size_t width, size_t height, size_t majorGLVersion,
+                          size_t minorGLVersion, bool gles,
+                          bool compatibilityProfile);
diff --git a/src/glview/OffscreenContextFactory.cc b/src/glview/OffscreenContextFactory.cc
index c0b45b8ad..07e7550e4 100644
--- a/src/glview/OffscreenContextFactory.cc
+++ b/src/glview/OffscreenContextFactory.cc
@@ -6,19 +6,19 @@
 #include "utils/printutils.h"
 
 #ifdef __APPLE__
-#include "glview/offscreen-old/OffscreenContextNSOpenGL.h"
 #include "glview/OffscreenContextCGL.h"
+#include "glview/offscreen-old/OffscreenContextNSOpenGL.h"
 #endif
 #ifdef _WIN32
 #include "glview/offscreen-old/OffscreenContextWGL.h"
 #endif
 #ifdef ENABLE_EGL
-#include "glview/offscreen-old/OffscreenContextEGL.h"
 #include "glview/OffscreenContextEGL.h"
+#include "glview/offscreen-old/OffscreenContextEGL.h"
 #endif
 #ifdef ENABLE_GLX
-#include "glview/offscreen-old/OffscreenContextGLX.h"
 #include "glview/OffscreenContextGLX.h"
+#include "glview/offscreen-old/OffscreenContextGLX.h"
 #endif
 #ifdef NULLGL
 #include "glview/OffscreenContextNULL.h"
@@ -42,16 +42,21 @@ const char *defaultProvider() {
 #ifdef _WIN32
   return "wgl-old";
 #endif
-#endif  // NULLGL
+#endif // NULLGL
 }
 
-std::shared_ptr<OpenGLContext> create(const std::string& provider, const OffscreenContextFactory::ContextAttributes& attrib)
-{
+std::shared_ptr<OpenGLContext>
+create(const std::string &provider,
+       const OffscreenContextFactory::ContextAttributes &attrib) {
   PRINTDB("Creating OpenGL context with the %1s provider:", provider);
   PRINTDB("  Size: %d x %d", attrib.width % attrib.height);
-  PRINTDB("  Version: %s %d.%d %s", (attrib.gles ? "OpenGL ES" : "OpenGL") % attrib.majorGLVersion % attrib.minorGLVersion %
-          (attrib.compatibilityProfile ? "(compatibility profile requested)" : ""));
-  // FIXME: We should log an error if the chosen provider doesn't support all our attribs.
+  PRINTDB("  Version: %s %d.%d %s",
+          (attrib.gles ? "OpenGL ES" : "OpenGL") % attrib.majorGLVersion %
+              attrib.minorGLVersion %
+              (attrib.compatibilityProfile ? "(compatibility profile requested)"
+                                           : ""));
+  // FIXME: We should log an error if the chosen provider doesn't support all
+  // our attribs.
 #ifdef NULLGL
   if (provider == "nullgl") {
     return CreateOffscreenContextNULL();
@@ -65,29 +70,35 @@ std::shared_ptr<OpenGLContext> create(const std::string& provider, const Offscre
     if (attrib.compatibilityProfile) {
       LOG("Compatibility context is not available on macOS");
     }
-    return offscreen_old::CreateOffscreenContextNSOpenGL(attrib.width, attrib.height, attrib.majorGLVersion, attrib.minorGLVersion);
+    return offscreen_old::CreateOffscreenContextNSOpenGL(
+        attrib.width, attrib.height, attrib.majorGLVersion,
+        attrib.minorGLVersion);
   } else if (provider == "cgl") {
-    return CreateOffscreenContextCGL(attrib.width, attrib.height, attrib.majorGLVersion, attrib.minorGLVersion);
+    return CreateOffscreenContextCGL(attrib.width, attrib.height,
+                                     attrib.majorGLVersion,
+                                     attrib.minorGLVersion);
   }
 #endif // ifdef __APPLE__
 #if ENABLE_EGL
   if (provider == "egl-old") {
-    return offscreen_old::CreateOffscreenContextEGL(attrib.width, attrib.height,
-                                                    attrib.majorGLVersion, attrib.minorGLVersion,
-                                                    attrib.gles, attrib.compatibilityProfile);
+    return offscreen_old::CreateOffscreenContextEGL(
+        attrib.width, attrib.height, attrib.majorGLVersion,
+        attrib.minorGLVersion, attrib.gles, attrib.compatibilityProfile);
   } else if (provider == "egl") {
-    return CreateOffscreenContextEGL(attrib.width, attrib.height,
-                                     attrib.majorGLVersion, attrib.minorGLVersion,
-                                     attrib.gles, attrib.compatibilityProfile);
+    return CreateOffscreenContextEGL(
+        attrib.width, attrib.height, attrib.majorGLVersion,
+        attrib.minorGLVersion, attrib.gles, attrib.compatibilityProfile);
   } else
 #endif
 #ifdef ENABLE_GLX
-  if (provider == "glx-old") {
-    return offscreen_old::CreateOffscreenContextGLX(attrib.width, attrib.height, attrib.majorGLVersion, attrib.minorGLVersion,
-                                                    attrib.gles, attrib.compatibilityProfile);
+      if (provider == "glx-old") {
+    return offscreen_old::CreateOffscreenContextGLX(
+        attrib.width, attrib.height, attrib.majorGLVersion,
+        attrib.minorGLVersion, attrib.gles, attrib.compatibilityProfile);
   } else if (provider == "glx") {
-    return CreateOffscreenContextGLX(attrib.width, attrib.height, attrib.majorGLVersion, attrib.minorGLVersion,
-                                     attrib.gles, attrib.compatibilityProfile);
+    return CreateOffscreenContextGLX(
+        attrib.width, attrib.height, attrib.majorGLVersion,
+        attrib.minorGLVersion, attrib.gles, attrib.compatibilityProfile);
   }
 #endif
 #ifdef _WIN32
@@ -95,14 +106,14 @@ std::shared_ptr<OpenGLContext> create(const std::string& provider, const Offscre
     if (attrib.gles) {
       LOG("GLES is not supported on Windows");
     }
-    return offscreen_old::CreateOffscreenContextWGL(attrib.width, attrib.height,
-                                                    attrib.majorGLVersion, attrib.minorGLVersion,
-                                                    attrib.compatibilityProfile);
+    return offscreen_old::CreateOffscreenContextWGL(
+        attrib.width, attrib.height, attrib.majorGLVersion,
+        attrib.minorGLVersion, attrib.compatibilityProfile);
   } else
 #endif
-#endif  // NULLGL
+#endif // NULLGL
   LOG("GL context provider '%1$s' not found", provider);
   return nullptr;
 }
 
-}  // namespace OffscreenContextFactory
+} // namespace OffscreenContextFactory
diff --git a/src/glview/OffscreenContextFactory.h b/src/glview/OffscreenContextFactory.h
index 9b83e0559..97faf0b49 100644
--- a/src/glview/OffscreenContextFactory.h
+++ b/src/glview/OffscreenContextFactory.h
@@ -14,10 +14,12 @@ struct ContextAttributes {
   uint32_t majorGLVersion;   // Minimum OpenGL or GLES major version
   uint32_t minorGLVersion;   // Minimum OpenGL or GLES minor version
   bool gles;                 // Request a GLES context
-  bool compatibilityProfile; // Request a compatibility context (to support legacy OpenGL calls)
+  bool compatibilityProfile; // Request a compatibility context (to support
+                             // legacy OpenGL calls)
 };
 
 const char *defaultProvider();
-std::shared_ptr<OpenGLContext> create(const std::string& provider, const ContextAttributes& attrib);
+std::shared_ptr<OpenGLContext> create(const std::string &provider,
+                                      const ContextAttributes &attrib);
 
-}  // namespace OffscreenContextFactory
+} // namespace OffscreenContextFactory
diff --git a/src/glview/OffscreenContextGLX.cc b/src/glview/OffscreenContextGLX.cc
index 06d1604da..9a62ede42 100644
--- a/src/glview/OffscreenContextGLX.cc
+++ b/src/glview/OffscreenContextGLX.cc
@@ -10,8 +10,8 @@
 #include <sstream>
 #include <string>
 
-#include "utils/scope_guard.hpp"
 #include "utils/printutils.h"
+#include "utils/scope_guard.hpp"
 
 namespace {
 
@@ -21,19 +21,21 @@ int xlibErrorHandler(Display *dpy, XErrorEvent *event) {
   return 0;
 }
 
-}  // namespace
+} // namespace
 
-class OffscreenContextGLX : public OffscreenContext
-{
+class OffscreenContextGLX : public OffscreenContext {
 public:
   GLXContext glxContext = nullptr;
   Display *display = nullptr;
   Window xWindow = 0;
-  OffscreenContextGLX(int width, int height) : OffscreenContext(width, height) {}
+  OffscreenContextGLX(int width, int height)
+      : OffscreenContext(width, height) {}
   ~OffscreenContextGLX() {
     if (this->display) {
-      if (this->glxContext) glXDestroyContext(this->display, this->glxContext);
-      if (this->xWindow) XDestroyWindow(this->display, this->xWindow);
+      if (this->glxContext)
+        glXDestroyContext(this->display, this->glxContext);
+      if (this->xWindow)
+        XDestroyWindow(this->display, this->xWindow);
       XCloseDisplay(this->display);
     }
   }
@@ -53,36 +55,48 @@ public:
   }
 
   bool makeCurrent() const override {
-    return glXMakeContextCurrent(this->display, this->xWindow, this->xWindow, this->glxContext);
+    return glXMakeContextCurrent(this->display, this->xWindow, this->xWindow,
+                                 this->glxContext);
   }
 
-  // Create an OpenGL context, and a dummy X11 window to draw into, without showing (mapping) it.
-  // This purposely does not use glxCreateWindow, to avoid crashes,
-  // "failed to create drawable" errors, and Mesa "WARNING: Application calling
-  // GLX 1.3 function when GLX 1.3 is not supported! This is an application bug!"
+  // Create an OpenGL context, and a dummy X11 window to draw into, without
+  // showing (mapping) it. This purposely does not use glxCreateWindow, to avoid
+  // crashes, "failed to create drawable" errors, and Mesa "WARNING: Application
+  // calling GLX 1.3 function when GLX 1.3 is not supported! This is an
+  // application bug!"
 
   //  This function will alter ctx.openGLContext and ctx.xwindow if successful
-  bool createGLXContext(size_t majorGLVersion, size_t minorGLVersion, bool compatibilityProfile) {
-    const int attributes[] = {
-      GLX_DRAWABLE_TYPE, GLX_WINDOW_BIT | GLX_PIXMAP_BIT,
-      GLX_RENDER_TYPE, GLX_RGBA_BIT,
-      GLX_RED_SIZE, 8,
-      GLX_GREEN_SIZE, 8,
-      GLX_BLUE_SIZE, 8,
-      GLX_ALPHA_SIZE, 8,
-      GLX_DEPTH_SIZE, 24, // depth-stencil for OpenCSG
-      GLX_STENCIL_SIZE, 8,
-      None
-    };
+  bool createGLXContext(size_t majorGLVersion, size_t minorGLVersion,
+                        bool compatibilityProfile) {
+    const int attributes[] = {GLX_DRAWABLE_TYPE,
+                              GLX_WINDOW_BIT | GLX_PIXMAP_BIT,
+                              GLX_RENDER_TYPE,
+                              GLX_RGBA_BIT,
+                              GLX_RED_SIZE,
+                              8,
+                              GLX_GREEN_SIZE,
+                              8,
+                              GLX_BLUE_SIZE,
+                              8,
+                              GLX_ALPHA_SIZE,
+                              8,
+                              GLX_DEPTH_SIZE,
+                              24, // depth-stencil for OpenCSG
+                              GLX_STENCIL_SIZE,
+                              8,
+                              None};
 
     int numConfigs = 0;
     GLXFBConfig *fbconfigs = nullptr;
     XVisualInfo *visinfo = nullptr;
     auto guard = sg::make_scope_guard([&fbconfigs, &visinfo]() {
-      if (fbconfigs) XFree(fbconfigs);
-      if (visinfo) XFree(visinfo);
+      if (fbconfigs)
+        XFree(fbconfigs);
+      if (visinfo)
+        XFree(visinfo);
     });
-    fbconfigs = glXChooseFBConfig(this->display, DefaultScreen(this->display), attributes, &numConfigs);
+    fbconfigs = glXChooseFBConfig(this->display, DefaultScreen(this->display),
+                                  attributes, &numConfigs);
     if (fbconfigs == nullptr) {
       LOG("glXChooseFBConfig() failed");
       return false;
@@ -93,22 +107,23 @@ public:
       return false;
     }
 
-    // We can't depend on XCreateWindow() returning 0 on failure, so we use a custom Xlib error handler
+    // We can't depend on XCreateWindow() returning 0 on failure, so we use a
+    // custom Xlib error handler
     XErrorHandler originalErrorHandler = XSetErrorHandler(xlibErrorHandler);
-    auto errorGuard = sg::make_scope_guard([originalErrorHandler]() {
-      XSetErrorHandler(originalErrorHandler);
-    });
+    auto errorGuard = sg::make_scope_guard(
+        [originalErrorHandler]() { XSetErrorHandler(originalErrorHandler); });
 
     const auto root = DefaultRootWindow(this->display);
     XSetWindowAttributes windowAttributes = {
-      .event_mask = StructureNotifyMask | ExposureMask | KeyPressMask,
-      .colormap = XCreateColormap(this->display, root, visinfo->visual, AllocNone),
+        .event_mask = StructureNotifyMask | ExposureMask | KeyPressMask,
+        .colormap =
+            XCreateColormap(this->display, root, visinfo->visual, AllocNone),
     };
     unsigned long mask = CWBackPixel | CWBorderPixel | CWColormap | CWEventMask;
 
-    this->xWindow =
-      XCreateWindow(this->display, root, 0, 0, this->width(), this->height(), 0,
-                    visinfo->depth, InputOutput, visinfo->visual, mask, &windowAttributes);
+    this->xWindow = XCreateWindow(
+        this->display, root, 0, 0, this->width(), this->height(), 0,
+        visinfo->depth, InputOutput, visinfo->visual, mask, &windowAttributes);
     XSync(this->display, false);
     if (xlibLastError != Success) {
       char description[1024];
@@ -118,20 +133,25 @@ public:
     }
 
     GLint context_attributes[] = {
-      GLX_CONTEXT_MAJOR_VERSION_ARB, static_cast<GLint>(majorGLVersion),
-      GLX_CONTEXT_MINOR_VERSION_ARB, static_cast<GLint>(minorGLVersion),
-      GLX_CONTEXT_PROFILE_MASK_ARB, compatibilityProfile ? GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB : GLX_CONTEXT_CORE_PROFILE_BIT_ARB,
-      None
-    };
+        GLX_CONTEXT_MAJOR_VERSION_ARB,
+        static_cast<GLint>(majorGLVersion),
+        GLX_CONTEXT_MINOR_VERSION_ARB,
+        static_cast<GLint>(minorGLVersion),
+        GLX_CONTEXT_PROFILE_MASK_ARB,
+        compatibilityProfile ? GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB
+                             : GLX_CONTEXT_CORE_PROFILE_BIT_ARB,
+        None};
 
     if (glXCreateContextAttribsARB) {
-      this->glxContext = glXCreateContextAttribsARB(this->display, fbconfigs[0], nullptr, 1, context_attributes);
+      this->glxContext = glXCreateContextAttribsARB(
+          this->display, fbconfigs[0], nullptr, 1, context_attributes);
       if (!this->glxContext) {
         LOG("Unable to create GLX context using glXCreateContextAttribsARB()");
       }
     }
     if (!this->glxContext) {
-      this->glxContext = glXCreateNewContext(this->display, fbconfigs[0], GLX_RGBA_TYPE, nullptr, 1);
+      this->glxContext = glXCreateNewContext(this->display, fbconfigs[0],
+                                             GLX_RGBA_TYPE, nullptr, 1);
       if (!this->glxContext) {
         LOG("Unable to create GLX context using glXCreateNewContext()");
         return false;
@@ -141,7 +161,6 @@ public:
   }
 };
 
-
 /*
    create a dummy X window without showing it. (without 'mapping' it)
    and save information to the ctx.
@@ -152,16 +171,17 @@ public:
 
    This function will alter ctx.openGLContext and ctx.xwindow if successful
  */
-std::shared_ptr<OffscreenContext> CreateOffscreenContextGLX(size_t width, size_t height,
-                                                            size_t majorGLVersion, size_t minorGLVersion, bool gles, bool compatibilityProfile)
-{
+std::shared_ptr<OffscreenContext>
+CreateOffscreenContextGLX(size_t width, size_t height, size_t majorGLVersion,
+                          size_t minorGLVersion, bool gles,
+                          bool compatibilityProfile) {
   auto ctx = std::make_shared<OffscreenContextGLX>(width, height);
 
   ctx->display = XOpenDisplay(nullptr);
   if (ctx->display == nullptr) {
     LOG("Unable to open a connection to the X server.");
     char *dpyenv = getenv("DISPLAY");
-    LOG("  DISPLAY=%1$s", (dpyenv?dpyenv:""));
+    LOG("  DISPLAY=%1$s", (dpyenv ? dpyenv : ""));
     return nullptr;
   }
 
@@ -175,15 +195,19 @@ std::shared_ptr<OffscreenContext> CreateOffscreenContextGLX(size_t width, size_t
   PRINTDB("GLAD: Loaded GLX %d.%d", glxMajor % glxMinor);
 
   // We require GLX >= 1.3.
-  // However, glxQueryVersion sometimes returns an earlier version than is actually available, so
-  // we also accept GLX < 1.3 as long as glXGetVisualFromFBConfig() exists.
-  // FIXME: Figure out if this is still relevant with GLAD, as we may want to check functions anyway?
+  // However, glxQueryVersion sometimes returns an earlier version than is
+  // actually available, so we also accept GLX < 1.3 as long as
+  // glXGetVisualFromFBConfig() exists.
+  // FIXME: Figure out if this is still relevant with GLAD, as we may want to
+  // check functions anyway?
   if (glxMajor == 1 && glxMinor <= 2 && glXGetVisualFromFBConfig == nullptr) {
-    LOG("Error: GLX version 1.3 functions missing. Your GLX version: %1$d.%2$d", glxMajor, glxMinor);
+    LOG("Error: GLX version 1.3 functions missing. Your GLX version: %1$d.%2$d",
+        glxMajor, glxMinor);
     return nullptr;
   }
 
-  if (!ctx->createGLXContext(majorGLVersion, minorGLVersion, compatibilityProfile)) {
+  if (!ctx->createGLXContext(majorGLVersion, minorGLVersion,
+                             compatibilityProfile)) {
     return nullptr;
   }
 
diff --git a/src/glview/OffscreenContextGLX.h b/src/glview/OffscreenContextGLX.h
index 7cec59866..5329f5389 100644
--- a/src/glview/OffscreenContextGLX.h
+++ b/src/glview/OffscreenContextGLX.h
@@ -5,6 +5,7 @@
 
 #include "glview/OffscreenContext.h"
 
-std::shared_ptr<OffscreenContext> CreateOffscreenContextGLX(
-  size_t width, size_t height, size_t majorGLVersion,
-  size_t minorGLVersion, bool gles, bool compatibilityProfile);
+std::shared_ptr<OffscreenContext>
+CreateOffscreenContextGLX(size_t width, size_t height, size_t majorGLVersion,
+                          size_t minorGLVersion, bool gles,
+                          bool compatibilityProfile);
diff --git a/src/glview/OffscreenContextNULL.cc b/src/glview/OffscreenContextNULL.cc
index 16b43449a..5a9d04c41 100644
--- a/src/glview/OffscreenContextNULL.cc
+++ b/src/glview/OffscreenContextNULL.cc
@@ -9,19 +9,15 @@
 
 #include "glview/OffscreenContext.h"
 
-class OffscreenContextNULL : public OffscreenContext
-{
+class OffscreenContextNULL : public OffscreenContext {
 public:
   OffscreenContextNULL() : OffscreenContext(0, 0) {}
   ~OffscreenContextNULL() override = default;
 
-  std::string getInfo() const override {
-    return "GL context creator: NULLGL";
-  }
+  std::string getInfo() const override { return "GL context creator: NULLGL"; }
   bool makeCurrent() const override { return true; }
 };
 
-std::shared_ptr<OffscreenContext> CreateOffscreenContextNULL()
-{
+std::shared_ptr<OffscreenContext> CreateOffscreenContextNULL() {
   return std::make_shared<OffscreenContextNULL>();
 }
diff --git a/src/glview/OffscreenView.cc b/src/glview/OffscreenView.cc
index 00e6f6e0c..59d928abd 100644
--- a/src/glview/OffscreenView.cc
+++ b/src/glview/OffscreenView.cc
@@ -1,19 +1,19 @@
 #include "glview/OffscreenView.h"
 #include "glview/system-gl.h"
-#include <iostream>
-#include <cstdint>
 #include <cmath>
+#include <cstdint>
 #include <cstdio>
-#include <string>
 #include <cstdlib>
-#include <sstream>
 #include <fstream>
+#include <iostream>
+#include <sstream>
+#include <string>
 #include <vector>
 
-#include "io/imageutils.h"
-#include "utils/printutils.h"
 #include "glview/OffscreenContextFactory.h"
 #include "glview/fbo.h"
+#include "io/imageutils.h"
+#include "utils/printutils.h"
 #if defined(USE_GLEW) || defined(OPENCSG_GLEW)
 #include "glview/glew-utils.h"
 #endif
@@ -24,36 +24,38 @@ namespace {
    Capture framebuffer from OpenGL and write it to the given ostream.
    Called by save_framebuffer() from platform-specific code.
  */
-bool save_framebuffer(const OpenGLContext *ctx, std::ostream& output)
-{
-  if (!ctx) return false;
+bool save_framebuffer(const OpenGLContext *ctx, std::ostream &output) {
+  if (!ctx)
+    return false;
 
   const auto pixels = ctx->getFramebuffer();
 
   const size_t samplesPerPixel = 4; // R, G, B and A
   // Flip it vertically - images read from OpenGL buffers are upside-down
-  std::vector<uint8_t> flippedBuffer(samplesPerPixel * ctx->height() * ctx->width());
-  flip_image(&pixels[0], flippedBuffer.data(), samplesPerPixel, ctx->width(), ctx->height());
+  std::vector<uint8_t> flippedBuffer(samplesPerPixel * ctx->height() *
+                                     ctx->width());
+  flip_image(&pixels[0], flippedBuffer.data(), samplesPerPixel, ctx->width(),
+             ctx->height());
 
   return write_png(output, flippedBuffer.data(), ctx->width(), ctx->height());
 }
 
-}  // namespace
+} // namespace
 
-OffscreenView::OffscreenView(uint32_t width, uint32_t height)
-{
+OffscreenView::OffscreenView(uint32_t width, uint32_t height) {
   OffscreenContextFactory::ContextAttributes attrib = {
-    .width = width,
-    .height = height,
-    .majorGLVersion = 2,
-    .minorGLVersion = 0,
+      .width = width,
+      .height = height,
+      .majorGLVersion = 2,
+      .minorGLVersion = 0,
   };
   auto provider = OffscreenContextFactory::defaultProvider();
   // We cannot initialize GLX GLEW with an EGL context:
   // https://github.com/nigels-com/glew/issues/273
   // ..so if we're using GLEW, default to creating a GLX context.
   // FIXME: It's possible that GLEW was built using EGL, in which case this
-  // logic isn't correct, but we don't have a good way of determining how GLEW was built.
+  // logic isn't correct, but we don't have a good way of determining how GLEW
+  // was built.
 #if defined(USE_GLEW) || defined(OPENCSG_GLEW)
   provider = !strcmp(provider, "egl") ? "glx" : provider;
 #endif
@@ -67,7 +69,8 @@ OffscreenView::OffscreenView(uint32_t width, uint32_t height)
       throw OffscreenViewException("Unable to obtain GL Context");
     }
   }
-  if (!this->ctx->makeCurrent()) throw OffscreenViewException("Unable to make GL context current");
+  if (!this->ctx->makeCurrent())
+    throw OffscreenViewException("Unable to make GL context current");
 
 #ifndef NULLGL
 #if defined(USE_GLEW) || defined(OPENCSG_GLEW)
@@ -81,7 +84,8 @@ OffscreenView::OffscreenView(uint32_t width, uint32_t height)
   if (version == 0) {
     throw OffscreenViewException("Unable to initialize GLAD");
   }
-  PRINTDB("GLAD: Loaded OpenGL %d.%d", GLAD_VERSION_MAJOR(version) % GLAD_VERSION_MINOR(version));
+  PRINTDB("GLAD: Loaded OpenGL %d.%d",
+          GLAD_VERSION_MAJOR(version) % GLAD_VERSION_MINOR(version));
 #endif // USE_GLAD
 
 #endif // NULLGL
@@ -96,20 +100,15 @@ OffscreenView::OffscreenView(uint32_t width, uint32_t height)
   GLView::resizeGL(width, height);
 }
 
-OffscreenView::~OffscreenView()
-{
-  fbo.reset();
-}
+OffscreenView::~OffscreenView() { fbo.reset(); }
 
 #ifdef ENABLE_OPENCSG
-void OffscreenView::display_opencsg_warning()
-{
+void OffscreenView::display_opencsg_warning() {
   LOG("OpenSCAD recommended OpenGL version is 2.0.");
 }
 #endif
 
-bool OffscreenView::save(const char *filename) const
-{
+bool OffscreenView::save(const char *filename) const {
   std::ofstream fstream(filename, std::ios::out | std::ios::binary);
   if (!fstream.is_open()) {
     std::cerr << "Can't open file " << filename << " for writing";
@@ -121,13 +120,11 @@ bool OffscreenView::save(const char *filename) const
   return true;
 }
 
-bool OffscreenView::save(std::ostream& output) const
-{
+bool OffscreenView::save(std::ostream &output) const {
   return save_framebuffer(this->ctx.get(), output);
 }
 
-std::string OffscreenView::getRendererInfo() const
-{
+std::string OffscreenView::getRendererInfo() const {
   std::ostringstream result;
   result << this->ctx->getInfo() << "\n" << gl_dump();
   return result.str();
diff --git a/src/glview/OffscreenView.h b/src/glview/OffscreenView.h
index 6d7d1ce2d..5fb543bc5 100644
--- a/src/glview/OffscreenView.h
+++ b/src/glview/OffscreenView.h
@@ -1,27 +1,26 @@
 #pragma once
 
-#include <stdexcept>
 #include <cstdint>
 #include <memory>
-#include <string>
 #include <ostream>
+#include <stdexcept>
+#include <string>
 
 #include "glview/GLView.h"
 #include "glview/OpenGLContext.h"
 #include "glview/fbo.h"
 
-class OffscreenViewException : public std::runtime_error
-{
+class OffscreenViewException : public std::runtime_error {
 public:
-  OffscreenViewException(const std::string& what_arg) : std::runtime_error(what_arg) {}
+  OffscreenViewException(const std::string &what_arg)
+      : std::runtime_error(what_arg) {}
 };
 
-class OffscreenView : public GLView
-{
+class OffscreenView : public GLView {
 public:
   OffscreenView(uint32_t width, uint32_t height);
   ~OffscreenView() override;
-  bool save(std::ostream& output) const;
+  bool save(std::ostream &output) const;
   // TODO: Do we need to worry about deletion order?
   std::shared_ptr<OpenGLContext> ctx;
   std::unique_ptr<FBO> fbo;
diff --git a/src/glview/OpenGLContext.cc b/src/glview/OpenGLContext.cc
index fffe784c9..a4df58747 100644
--- a/src/glview/OpenGLContext.cc
+++ b/src/glview/OpenGLContext.cc
@@ -1,15 +1,15 @@
 #include "glview/OpenGLContext.h"
 
-#include <cstdint>
 #include <cstddef>
+#include <cstdint>
 #include <vector>
 
 #include "glview/system-gl.h"
 
-std::vector<uint8_t> OpenGLContext::getFramebuffer() const
-{
+std::vector<uint8_t> OpenGLContext::getFramebuffer() const {
   const size_t samplesPerPixel = 4; // R, G, B and A
   std::vector<uint8_t> buffer(samplesPerPixel * this->width_ * this->height_);
-  GL_CHECK(glReadPixels(0, 0, this->width_, this->height_, GL_RGBA, GL_UNSIGNED_BYTE, buffer.data()));
+  GL_CHECK(glReadPixels(0, 0, this->width_, this->height_, GL_RGBA,
+                        GL_UNSIGNED_BYTE, buffer.data()));
   return buffer;
 }
diff --git a/src/glview/OpenGLContext.h b/src/glview/OpenGLContext.h
index d350c1edb..c2867ee20 100644
--- a/src/glview/OpenGLContext.h
+++ b/src/glview/OpenGLContext.h
@@ -1,17 +1,17 @@
 #pragma once
 
-#include <vector>
-#include <string>
 #include <cstdint>
+#include <string>
+#include <vector>
 
-class OpenGLContext
-{
+class OpenGLContext {
 protected:
   uint32_t width_;
   uint32_t height_;
 
 public:
-  OpenGLContext(uint32_t width, uint32_t height) : width_(width), height_(height) {}
+  OpenGLContext(uint32_t width, uint32_t height)
+      : width_(width), height_(height) {}
   virtual ~OpenGLContext() = default;
   uint32_t width() const { return this->width_; }
   uint32_t height() const { return this->height_; }
diff --git a/src/glview/PolySetRenderer.cc b/src/glview/PolySetRenderer.cc
index ed481c4ac..3dc671a95 100644
--- a/src/glview/PolySetRenderer.cc
+++ b/src/glview/PolySetRenderer.cc
@@ -29,28 +29,28 @@
 #include <cassert>
 #include <cmath>
 #include <cstddef>
-#include <utility>
 #include <memory>
+#include <utility>
 #include <vector>
 #ifdef _MSC_VER
 // Boost conflicts with MPFR under MSVC (google it)
 #include <mpfr.h>
 #endif
 
-#include "glview/system-gl.h"
 #include "core/Selection.h"
-#include "geometry/cgal/cgalutils.h"
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetUtils.h"
+#include "geometry/cgal/cgalutils.h"
+#include "geometry/linalg.h"
 #include "glview/ColorMap.h"
-#include "glview/cgal/CGALRenderUtils.h"
-#include "glview/VBORenderer.h"
 #include "glview/Renderer.h"
 #include "glview/ShaderUtils.h"
 #include "glview/VBOBuilder.h"
+#include "glview/VBORenderer.h"
 #include "glview/VertexState.h"
+#include "glview/cgal/CGALRenderUtils.h"
+#include "glview/system-gl.h"
 
 #ifdef ENABLE_CGAL
 #include "geometry/cgal/CGALNefGeometry.h"
@@ -60,34 +60,38 @@
 #endif
 
 // This renderer is used in Manifold mode (F6 with Manifold as geometry engine)
-PolySetRenderer::PolySetRenderer(const std::shared_ptr<const class Geometry>& geom)
-{
+PolySetRenderer::PolySetRenderer(
+    const std::shared_ptr<const class Geometry> &geom) {
   this->addGeometry(geom);
 }
 
-void PolySetRenderer::addGeometry(const std::shared_ptr<const Geometry>& geom)
-{
+void PolySetRenderer::addGeometry(const std::shared_ptr<const Geometry> &geom) {
   assert(geom != nullptr);
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
-    for (const auto& item : geomlist->getChildren()) {
+  if (const auto geomlist =
+          std::dynamic_pointer_cast<const GeometryList>(geom)) {
+    for (const auto &item : geomlist->getChildren()) {
       this->addGeometry(item.second);
     }
   } else if (const auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
     assert(ps->getDimension() == 3);
-    // We need to tessellate here, in case the generated PolySet contains concave polygons
-    // See tests/data/scad/3D/features/polyhedron-concave-test.scad
+    // We need to tessellate here, in case the generated PolySet contains
+    // concave polygons See
+    // tests/data/scad/3D/features/polyhedron-concave-test.scad
     this->polysets_.push_back(PolySetUtils::tessellate_faces(*ps));
-  } else if (const auto poly = std::dynamic_pointer_cast<const Polygon2d>(geom)) {
+  } else if (const auto poly =
+                 std::dynamic_pointer_cast<const Polygon2d>(geom)) {
     this->polygons_.emplace_back(
-      poly, std::shared_ptr<const PolySet>(poly->tessellate()));
+        poly, std::shared_ptr<const PolySet>(poly->tessellate()));
 #ifdef ENABLE_MANIFOLD
-  } else if (const auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
+  } else if (const auto mani =
+                 std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
     this->polysets_.push_back(mani->toPolySet());
 #endif
 #ifdef ENABLE_CGAL
-  } else if (const auto N = std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
-    // Note: It's rare, but possible for Nef polyhedrons to exist among geometries in Manifold mode.
-    // One way is through import("file.nef3")
+  } else if (const auto N =
+                 std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
+    // Note: It's rare, but possible for Nef polyhedrons to exist among
+    // geometries in Manifold mode. One way is through import("file.nef3")
     assert(N->getDimension() == 3);
     if (!N->isEmpty()) {
       if (auto ps = CGALUtils::createPolySetFromNefPolyhedron3(*N->p3)) {
@@ -97,43 +101,48 @@ void PolySetRenderer::addGeometry(const std::shared_ptr<const Geometry>& geom)
     }
 #endif // ifdef ENABLE_CGAL
   } else {
-    const auto& geom_ref = *geom.get();
+    const auto &geom_ref = *geom.get();
     LOG("Unsupported geom '%1$s' in PolySetRenderer", typeid(geom_ref).name());
     assert(false && "Unsupported geom in PolySetRenderer");
   }
 }
 
 // Overridden from Renderer
-void PolySetRenderer::setColorScheme(const ColorScheme& cs)
-{
+void PolySetRenderer::setColorScheme(const ColorScheme &cs) {
   Renderer::setColorScheme(cs);
-  colormap_[ColorMode::CGAL_FACE_2D_COLOR] = ColorMap::getColor(cs, RenderColor::CGAL_FACE_2D_COLOR);
-  colormap_[ColorMode::CGAL_EDGE_2D_COLOR] = ColorMap::getColor(cs, RenderColor::CGAL_EDGE_2D_COLOR);
+  colormap_[ColorMode::CGAL_FACE_2D_COLOR] =
+      ColorMap::getColor(cs, RenderColor::CGAL_FACE_2D_COLOR);
+  colormap_[ColorMode::CGAL_EDGE_2D_COLOR] =
+      ColorMap::getColor(cs, RenderColor::CGAL_EDGE_2D_COLOR);
 }
 
-
-void PolySetRenderer::createPolySetStates(const ShaderUtils::ShaderInfo *shaderinfo) {
-  VertexStateContainer& vertex_state_container = polyset_vertex_state_containers_.emplace_back();
-  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(), vertex_state_container);
+void PolySetRenderer::createPolySetStates(
+    const ShaderUtils::ShaderInfo *shaderinfo) {
+  VertexStateContainer &vertex_state_container =
+      polyset_vertex_state_containers_.emplace_back();
+  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(),
+                         vertex_state_container);
 
   vbo_builder.addSurfaceData(); // position, normal, color
   vbo_builder.addShaderData();
   const bool enable_barycentric = true;
 
   size_t num_vertices = 0;
-  for (const auto& polyset : this->polysets_) {
+  for (const auto &polyset : this->polysets_) {
     num_vertices += calcNumVertices(*polyset);
   }
   vbo_builder.allocateBuffers(num_vertices);
 
-  for (const auto& polyset : this->polysets_) {
+  for (const auto &polyset : this->polysets_) {
     Color4f color;
-    if (!polyset->colors.empty()) color = polyset->colors[0];
+    if (!polyset->colors.empty())
+      color = polyset->colors[0];
     getShaderColor(ColorMode::MATERIAL, color, color);
     add_shader_pointers(vbo_builder, shaderinfo);
 
     vbo_builder.writeSurface();
-    vbo_builder.create_surface(*polyset, Transform3d::Identity(), color, enable_barycentric, false);
+    vbo_builder.create_surface(*polyset, Transform3d::Identity(), color,
+                               enable_barycentric, false);
   }
 
   vbo_builder.createInterleavedVBOs();
@@ -145,12 +154,14 @@ void PolySetRenderer::createPolygonStates() {
 }
 
 void PolySetRenderer::createPolygonSurfaceStates() {
-  VertexStateContainer& vertex_state_container = polygon_vertex_state_containers_.emplace_back();
-  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(), vertex_state_container);
+  VertexStateContainer &vertex_state_container =
+      polygon_vertex_state_containers_.emplace_back();
+  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(),
+                         vertex_state_container);
   vbo_builder.addSurfaceData();
 
   size_t num_vertices = 0;
-  for (const auto&[_, polyset] : this->polygons_) {
+  for (const auto &[_, polyset] : this->polygons_) {
     num_vertices += calcNumVertices(*polyset);
   }
 
@@ -163,7 +174,7 @@ void PolySetRenderer::createPolygonSurfaceStates() {
   });
   vertex_state_container.states().emplace_back(std::move(init_state));
 
-  for (const auto&[polygon, polyset] : this->polygons_) {
+  for (const auto &[polygon, polyset] : this->polygons_) {
     Color4f color;
     getColorSchemeColor(ColorMode::CGAL_FACE_2D_COLOR, color);
     vbo_builder.create_polygons(*polyset, Transform3d::Identity(), color);
@@ -173,13 +184,15 @@ void PolySetRenderer::createPolygonSurfaceStates() {
 }
 
 void PolySetRenderer::createPolygonEdgeStates() {
-  VertexStateContainer& vertex_state_container = polygon_vertex_state_containers_.emplace_back();
-  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(), vertex_state_container);
+  VertexStateContainer &vertex_state_container =
+      polygon_vertex_state_containers_.emplace_back();
+  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(),
+                         vertex_state_container);
 
   vbo_builder.addEdgeData();
 
   size_t num_vertices = 0;
-  for (const auto&[polygon, _] : this->polygons_) {
+  for (const auto &[polygon, _] : this->polygons_) {
     num_vertices += calcNumEdgeVertices(*polygon);
   }
 
@@ -194,7 +207,7 @@ void PolySetRenderer::createPolygonEdgeStates() {
   });
   vertex_state_container.states().emplace_back(std::move(edge_state));
 
-  for (const auto&[polygon, _] : this->polygons_) {
+  for (const auto &[polygon, _] : this->polygons_) {
     Color4f color;
     getColorSchemeColor(ColorMode::CGAL_EDGE_2D_COLOR, color);
     vbo_builder.writeEdge();
@@ -211,12 +224,12 @@ void PolySetRenderer::createPolygonEdgeStates() {
   vbo_builder.createInterleavedVBOs();
 }
 
-
-void PolySetRenderer::prepare(const ShaderUtils::ShaderInfo *shaderinfo)
-{
-  if (polyset_vertex_state_containers_.empty() && polygon_vertex_state_containers_.empty()) {
+void PolySetRenderer::prepare(const ShaderUtils::ShaderInfo *shaderinfo) {
+  if (polyset_vertex_state_containers_.empty() &&
+      polygon_vertex_state_containers_.empty()) {
     if (!this->polysets_.empty() && !this->polygons_.empty()) {
-      LOG(message_group::Error, "PolySetRenderer::prepare() called with both polysets and polygons");
+      LOG(message_group::Error,
+          "PolySetRenderer::prepare() called with both polysets and polygons");
     } else if (!this->polysets_.empty()) {
       createPolySetStates(shaderinfo);
     } else if (!this->polygons_.empty()) {
@@ -225,28 +238,31 @@ void PolySetRenderer::prepare(const ShaderUtils::ShaderInfo *shaderinfo)
   }
 }
 
-void PolySetRenderer::draw(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const
-{
+void PolySetRenderer::draw(bool showedges,
+                           const ShaderUtils::ShaderInfo *shaderinfo) const {
 
   drawPolySets(showedges, shaderinfo);
   drawPolygons();
 }
 
-void PolySetRenderer::drawPolySets(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const
-{
+void PolySetRenderer::drawPolySets(
+    bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const {
   // Only use shader if select rendering or showedges
-  const bool enable_shader = shaderinfo && (
-    shaderinfo->type == ShaderUtils::ShaderType::EDGE_RENDERING && showedges ||
-    shaderinfo->type == ShaderUtils::ShaderType::SELECT_RENDERING);
+  const bool enable_shader =
+      shaderinfo &&
+      (shaderinfo->type == ShaderUtils::ShaderType::EDGE_RENDERING &&
+           showedges ||
+       shaderinfo->type == ShaderUtils::ShaderType::SELECT_RENDERING);
   if (enable_shader) {
     GL_TRACE("glUseProgram(%d)", shaderinfo->resource.shader_program);
     GL_CHECKD(glUseProgram(shaderinfo->resource.shader_program));
     VBOUtils::shader_attribs_enable(*shaderinfo);
   }
 
-  for (const auto& container : polyset_vertex_state_containers_) {
-    for (const auto& vertex_state : container.states()) {
-      const auto shader_vs = std::dynamic_pointer_cast<VBOShaderVertexState>(vertex_state);
+  for (const auto &container : polyset_vertex_state_containers_) {
+    for (const auto &vertex_state : container.states()) {
+      const auto shader_vs =
+          std::dynamic_pointer_cast<VBOShaderVertexState>(vertex_state);
       if (!shader_vs || (shader_vs && showedges)) {
         vertex_state->draw();
       }
@@ -269,9 +285,10 @@ void PolySetRenderer::drawPolygons() const {
   GL_CHECKD(glGetFloatv(GL_POINT_SIZE, &current_point_size));
   GL_CHECKD(glGetFloatv(GL_LINE_WIDTH, &current_line_width));
 
-  for (const auto& container : polygon_vertex_state_containers_) {
-    for (const auto& vertex_state : container.states()) {
-      if (vertex_state)vertex_state->draw();
+  for (const auto &container : polygon_vertex_state_containers_) {
+    for (const auto &vertex_state : container.states()) {
+      if (vertex_state)
+        vertex_state->draw();
     }
   }
 
@@ -281,33 +298,39 @@ void PolySetRenderer::drawPolygons() const {
   GL_TRACE("glLineWidth(%d)", current_line_width);
   GL_CHECKD(glLineWidth(current_line_width));
 
-  if (!origVBOBuilderState) glDisableClientState(GL_VERTEX_ARRAY);
-  if (!origNormalArrayState) glDisableClientState(GL_NORMAL_ARRAY);
-  if (!origColorArrayState) glDisableClientState(GL_COLOR_ARRAY);
+  if (!origVBOBuilderState)
+    glDisableClientState(GL_VERTEX_ARRAY);
+  if (!origNormalArrayState)
+    glDisableClientState(GL_NORMAL_ARRAY);
+  if (!origColorArrayState)
+    glDisableClientState(GL_COLOR_ARRAY);
 }
 
-BoundingBox PolySetRenderer::getBoundingBox() const
-{
+BoundingBox PolySetRenderer::getBoundingBox() const {
   BoundingBox bbox;
 
-  for (const auto& ps : this->polysets_) {
+  for (const auto &ps : this->polysets_) {
     bbox.extend(ps->getBoundingBox());
   }
-  for (const auto&[polygon, polyset] : this->polygons_) {
+  for (const auto &[polygon, polyset] : this->polygons_) {
     bbox.extend(polygon->getBoundingBox());
   }
   return bbox;
 }
 
-std::vector<SelectedObject> PolySetRenderer::findModelObject(const Vector3d& near_pt, const Vector3d& far_pt, int /*mouse_x*/, int /*mouse_y*/, double tolerance) {
+std::vector<SelectedObject>
+PolySetRenderer::findModelObject(const Vector3d &near_pt,
+                                 const Vector3d &far_pt, int /*mouse_x*/,
+                                 int /*mouse_y*/, double tolerance) {
   std::vector<SelectedObject> results;
   double dist_near;
   double dist_nearest = NAN;
   Vector3d pt1_nearest;
   Vector3d pt2_nearest;
-  for (const auto& ps : this->polysets_) {
-    for (const auto& pt: ps->vertices) {
-      const double dist_pt = calculateLinePointDistance(near_pt, far_pt, pt, dist_near);
+  for (const auto &ps : this->polysets_) {
+    for (const auto &pt : ps->vertices) {
+      const double dist_pt =
+          calculateLinePointDistance(near_pt, far_pt, pt, dist_near);
       if (dist_pt < tolerance) {
         if (isnan(dist_nearest) || dist_near < dist_nearest) {
           dist_nearest = dist_near;
@@ -318,20 +341,21 @@ std::vector<SelectedObject> PolySetRenderer::findModelObject(const Vector3d& nea
   }
   if (!isnan(dist_nearest)) {
     const SelectedObject obj = {
-      .type = SelectionType::SELECTION_POINT,
-      .p1 = pt1_nearest,
+        .type = SelectionType::SELECTION_POINT,
+        .p1 = pt1_nearest,
     };
     results.push_back(obj);
     return results;
   }
-  for (const std::shared_ptr<const PolySet>& ps : this->polysets_) {
-    for (const auto& pol : ps->indices) {
+  for (const std::shared_ptr<const PolySet> &ps : this->polysets_) {
+    for (const auto &pol : ps->indices) {
       const int n = pol.size();
       for (int i = 0; i < n; i++) {
         const int ind1 = pol[i];
         const int ind2 = pol[(i + 1) % n];
         double dist_lat;
-        const double dist_norm = std::fabs(calculateLineLineDistance(ps->vertices[ind1], ps->vertices[ind2], near_pt, far_pt, dist_lat));
+        const double dist_norm = std::fabs(calculateLineLineDistance(
+            ps->vertices[ind1], ps->vertices[ind2], near_pt, far_pt, dist_lat));
         if (dist_lat >= 0 && dist_lat <= 1 && dist_norm < tolerance) {
           dist_nearest = dist_lat;
           pt1_nearest = ps->vertices[ind1];
@@ -343,9 +367,9 @@ std::vector<SelectedObject> PolySetRenderer::findModelObject(const Vector3d& nea
 
   if (!isnan(dist_nearest)) {
     const SelectedObject obj = {
-      .type = SelectionType::SELECTION_LINE,
-      .p1 = pt1_nearest,
-      .p2 = pt2_nearest,
+        .type = SelectionType::SELECTION_LINE,
+        .p1 = pt1_nearest,
+        .p2 = pt2_nearest,
     };
     results.push_back(obj);
     return results;
diff --git a/src/glview/PolySetRenderer.h b/src/glview/PolySetRenderer.h
index 745dde2bf..c337ec28a 100644
--- a/src/glview/PolySetRenderer.h
+++ b/src/glview/PolySetRenderer.h
@@ -6,37 +6,43 @@
 
 #include "core/Selection.h"
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
-#include "geometry/Polygon2d.h"
 #include "geometry/PolySet.h"
+#include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 #include "glview/ColorMap.h"
 #include "glview/ShaderUtils.h"
-#include "glview/VertexState.h"
 #include "glview/VBORenderer.h"
+#include "glview/VertexState.h"
 
-class PolySetRenderer : public VBORenderer
-{
+class PolySetRenderer : public VBORenderer {
 public:
-  PolySetRenderer(const std::shared_ptr<const class Geometry>& geom);
+  PolySetRenderer(const std::shared_ptr<const class Geometry> &geom);
   ~PolySetRenderer() override = default;
   void prepare(const ShaderUtils::ShaderInfo *shaderinfo) override;
-  void draw(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const override;
-  void setColorScheme(const ColorScheme& cs) override;
+  void draw(bool showedges,
+            const ShaderUtils::ShaderInfo *shaderinfo) const override;
+  void setColorScheme(const ColorScheme &cs) override;
   BoundingBox getBoundingBox() const override;
-  std::vector<SelectedObject> findModelObject(const Vector3d& near_pt, const Vector3d& far_pt, int mouse_x, int mouse_y, double tolerance) override;
+  std::vector<SelectedObject> findModelObject(const Vector3d &near_pt,
+                                              const Vector3d &far_pt,
+                                              int mouse_x, int mouse_y,
+                                              double tolerance) override;
 
 private:
-  void addGeometry(const std::shared_ptr<const class Geometry>& geom);
+  void addGeometry(const std::shared_ptr<const class Geometry> &geom);
   void createPolySetStates(const ShaderUtils::ShaderInfo *shaderinfo);
   void createPolygonStates();
   void createPolygonSurfaceStates();
   void createPolygonEdgeStates();
 
-  void drawPolySets(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const;
+  void drawPolySets(bool showedges,
+                    const ShaderUtils::ShaderInfo *shaderinfo) const;
   void drawPolygons() const;
 
   std::vector<std::shared_ptr<const class PolySet>> polysets_;
-  std::vector<std::pair<std::shared_ptr<const Polygon2d>, std::shared_ptr<const PolySet>>> polygons_;
+  std::vector<std::pair<std::shared_ptr<const Polygon2d>,
+                        std::shared_ptr<const PolySet>>>
+      polygons_;
 
   std::vector<VertexStateContainer> polyset_vertex_state_containers_;
   std::vector<VertexStateContainer> polygon_vertex_state_containers_;
diff --git a/src/glview/RenderSettings.cc b/src/glview/RenderSettings.cc
index b7e5843fe..c84678cbb 100644
--- a/src/glview/RenderSettings.cc
+++ b/src/glview/RenderSettings.cc
@@ -1,7 +1,7 @@
 #include "glview/RenderSettings.h"
+#include "utils/printutils.h"
 #include <stdexcept>
 #include <string>
-#include "utils/printutils.h"
 
 std::string renderBackend3DToString(RenderBackend3D backend) {
   switch (backend) {
diff --git a/src/glview/RenderSettings.h b/src/glview/RenderSettings.h
index 915f4fde0..fcc6b8aa5 100644
--- a/src/glview/RenderSettings.h
+++ b/src/glview/RenderSettings.h
@@ -8,13 +8,13 @@ enum class RenderBackend3D {
   ManifoldBackend,
 };
 
-inline constexpr RenderBackend3D DEFAULT_RENDERING_BACKEND_3D = RenderBackend3D::CGALBackend; // ManifoldBackend;
+inline constexpr RenderBackend3D DEFAULT_RENDERING_BACKEND_3D =
+    RenderBackend3D::CGALBackend; // ManifoldBackend;
 
 std::string renderBackend3DToString(RenderBackend3D backend);
 RenderBackend3D renderBackend3DFromString(std::string backend);
 
-class RenderSettings
-{
+class RenderSettings {
 public:
   static RenderSettings *inst(bool erase = false);
 
@@ -22,6 +22,7 @@ public:
   unsigned int openCSGTermLimit;
   double far_gl_clip_limit;
   std::string colorscheme;
+
 private:
   RenderSettings();
 };
diff --git a/src/glview/Renderer.cc b/src/glview/Renderer.cc
index 43dd3e496..3f696a7cd 100644
--- a/src/glview/Renderer.cc
+++ b/src/glview/Renderer.cc
@@ -1,22 +1,21 @@
 #include "glview/Renderer.h"
 #include "geometry/linalg.h"
 #include "glview/ColorMap.h"
-#include "utils/printutils.h"
-#include "platform/PlatformUtils.h"
 #include "glview/system-gl.h"
+#include "platform/PlatformUtils.h"
+#include "utils/printutils.h"
 
-#include <sstream>
 #include <Eigen/LU>
 #include <fstream>
+#include <sstream>
 #include <string>
 #include <vector>
 
 #ifndef NULLGL
 
-
 namespace {
 
-GLuint compileShader(const std::string& name, GLuint shader_type) {
+GLuint compileShader(const std::string &name, GLuint shader_type) {
   auto shader_source = ShaderUtils::loadShaderSource(name);
   const GLuint shader = glCreateShader(shader_type);
   auto *c_source = shader_source.c_str();
@@ -34,29 +33,36 @@ GLuint compileShader(const std::string& name, GLuint shader_type) {
   return shader;
 }
 
-}  // namespace
+} // namespace
 
 namespace RendererUtils {
 
-CSGMode getCsgMode(const bool highlight_mode, const bool background_mode, const OpenSCADOperator type) {
-  int csgmode = highlight_mode ? CSGMODE_HIGHLIGHT : (background_mode ? CSGMODE_BACKGROUND : CSGMODE_NORMAL);
-  if (type == OpenSCADOperator::DIFFERENCE) csgmode |= CSGMODE_DIFFERENCE_FLAG;
+CSGMode getCsgMode(const bool highlight_mode, const bool background_mode,
+                   const OpenSCADOperator type) {
+  int csgmode = highlight_mode
+                    ? CSGMODE_HIGHLIGHT
+                    : (background_mode ? CSGMODE_BACKGROUND : CSGMODE_NORMAL);
+  if (type == OpenSCADOperator::DIFFERENCE)
+    csgmode |= CSGMODE_DIFFERENCE_FLAG;
   return static_cast<CSGMode>(csgmode);
 }
 
-std::string loadShaderSource(const std::string& name) {
-  std::string shaderPath = (PlatformUtils::resourcePath("shaders") / name).string();
+std::string loadShaderSource(const std::string &name) {
+  std::string shaderPath =
+      (PlatformUtils::resourcePath("shaders") / name).string();
   std::ostringstream buffer;
   const std::ifstream f(shaderPath);
   if (f.is_open()) {
     buffer << f.rdbuf();
   } else {
-    LOG(message_group::UI_Error, "Cannot open shader source file: '%1$s'", shaderPath);
+    LOG(message_group::UI_Error, "Cannot open shader source file: '%1$s'",
+        shaderPath);
   }
   return buffer.str();
 }
 
-ShaderUtils::ShaderResource compileShaderProgram(const std::string& vs_str, const std::string& fs_str) {
+ShaderUtils::ShaderResource compileShaderProgram(const std::string &vs_str,
+                                                 const std::string &fs_str) {
   int shaderstatus;
   const char *vs_source = vs_str.c_str();
   const char *fs_source = fs_str.c_str();
@@ -70,7 +76,8 @@ ShaderUtils::ShaderResource compileShaderProgram(const std::string& vs_str, cons
     char logbuffer[1000];
     glGetShaderInfoLog(vertex_shader, sizeof(logbuffer), &loglen, logbuffer);
     // FIXME: Use OpenCAD log to error instead of stderr
-    fprintf(stderr, __FILE__ ": OpenGL vertex shader Error:\n%.*s\n\n", loglen, logbuffer);
+    fprintf(stderr, __FILE__ ": OpenGL vertex shader Error:\n%.*s\n\n", loglen,
+            logbuffer);
     return {};
   }
 
@@ -83,7 +90,8 @@ ShaderUtils::ShaderResource compileShaderProgram(const std::string& vs_str, cons
     char logbuffer[1000];
     glGetShaderInfoLog(fragment_shader, sizeof(logbuffer), &loglen, logbuffer);
     // FIXME: Use OpenCAD log to error instead of stderr
-    fprintf(stderr, __FILE__ ": OpenGL fragment shader Error:\n%.*s\n\n", loglen, logbuffer);
+    fprintf(stderr, __FILE__ ": OpenGL fragment shader Error:\n%.*s\n\n",
+            loglen, logbuffer);
     return {};
   }
 
@@ -100,7 +108,8 @@ ShaderUtils::ShaderResource compileShaderProgram(const std::string& vs_str, cons
     char logbuffer[1000];
     glGetProgramInfoLog(shader_prog, sizeof(logbuffer), &loglen, logbuffer);
     // FIXME: Use OpenCAD log to error instead of stderr
-    fprintf(stderr, __FILE__ ": OpenGL Program Linker Error:\n%.*s\n\n", loglen, logbuffer);
+    fprintf(stderr, __FILE__ ": OpenGL Program Linker Error:\n%.*s\n\n", loglen,
+            logbuffer);
     return {};
   } else {
     glValidateProgram(shader_prog);
@@ -110,22 +119,22 @@ ShaderUtils::ShaderResource compileShaderProgram(const std::string& vs_str, cons
       char logbuffer[1000];
       glGetProgramInfoLog(shader_prog, sizeof(logbuffer), &loglen, logbuffer);
       // FIXME: Use OpenCAD log to error instead of stderr
-      fprintf(stderr, __FILE__ ": OpenGL Program Validation results:\n%.*s\n\n", loglen, logbuffer);
+      fprintf(stderr, __FILE__ ": OpenGL Program Validation results:\n%.*s\n\n",
+              loglen, logbuffer);
       return {};
     }
   }
 
   return {
-    .shader_program = shader_prog,
-    .vertex_shader = vertex_shader,
-    .fragment_shader = fragment_shader,
+      .shader_program = shader_prog,
+      .vertex_shader = vertex_shader,
+      .fragment_shader = fragment_shader,
   };
 }
 
-}  // namespace RendererUtils
+} // namespace RendererUtils
 
-Renderer::Renderer()
-{
+Renderer::Renderer() {
   PRINTD("Renderer() start");
 
   // Setup default colors
@@ -148,8 +157,8 @@ Renderer::Renderer()
   PRINTD("Renderer() end");
 }
 
-bool Renderer::getColorSchemeColor(Renderer::ColorMode colormode, Color4f& outcolor) const
-{
+bool Renderer::getColorSchemeColor(Renderer::ColorMode colormode,
+                                   Color4f &outcolor) const {
   if (const auto it = colormap_.find(colormode); it != colormap_.end()) {
     outcolor = it->second;
     return true;
@@ -157,52 +166,80 @@ bool Renderer::getColorSchemeColor(Renderer::ColorMode colormode, Color4f& outco
   return false;
 }
 
-bool Renderer::getShaderColor(Renderer::ColorMode colormode, const Color4f& object_color,
-                              Color4f& outcolor) const
-{
-  // If an object was colored, use any set components from that color, except in pure highlight mode
-  if ((colormode == ColorMode::BACKGROUND || colormode != ColorMode::HIGHLIGHT)) {
-    if (object_color.hasRgb()) outcolor.setRgb(object_color.r(), object_color.g(), object_color.b());
-    if (object_color.hasAlpha()) outcolor.setAlpha(object_color.a());
-    if (outcolor.isValid()) return true;
+bool Renderer::getShaderColor(Renderer::ColorMode colormode,
+                              const Color4f &object_color,
+                              Color4f &outcolor) const {
+  // If an object was colored, use any set components from that color, except in
+  // pure highlight mode
+  if ((colormode == ColorMode::BACKGROUND ||
+       colormode != ColorMode::HIGHLIGHT)) {
+    if (object_color.hasRgb())
+      outcolor.setRgb(object_color.r(), object_color.g(), object_color.b());
+    if (object_color.hasAlpha())
+      outcolor.setAlpha(object_color.a());
+    if (outcolor.isValid())
+      return true;
   }
 
   // Fill in missing components with the color from the colorscheme
   Color4f basecol;
   if (Renderer::getColorSchemeColor(colormode, basecol)) {
-    if (!outcolor.hasRgb()) outcolor.setRgb(basecol.r(), basecol.g(), basecol.b());
-    if (!outcolor.hasAlpha()) outcolor.setAlpha(basecol.a());
+    if (!outcolor.hasRgb())
+      outcolor.setRgb(basecol.r(), basecol.g(), basecol.b());
+    if (!outcolor.hasAlpha())
+      outcolor.setAlpha(basecol.a());
     return true;
   }
 
   return false;
 }
 
-
-
 /* fill colormap_ with matching entries from the colorscheme. note
    this does not change Highlight or Background colors as they are not
    represented in the colorscheme (yet). Also edgecolors are currently the
    same for CGAL & OpenCSG */
-void Renderer::setColorScheme(const ColorScheme& cs) {
+void Renderer::setColorScheme(const ColorScheme &cs) {
   PRINTD("setColorScheme");
-  colormap_[ColorMode::MATERIAL] = ColorMap::getColor(cs, RenderColor::OPENCSG_FACE_FRONT_COLOR);
-  colormap_[ColorMode::CUTOUT] = ColorMap::getColor(cs, RenderColor::OPENCSG_FACE_BACK_COLOR);
-  colormap_[ColorMode::MATERIAL_EDGES] = ColorMap::getColor(cs, RenderColor::CGAL_EDGE_FRONT_COLOR);
-  colormap_[ColorMode::CUTOUT_EDGES] = ColorMap::getColor(cs, RenderColor::CGAL_EDGE_BACK_COLOR);
-  colormap_[ColorMode::EMPTY_SPACE] = ColorMap::getColor(cs, RenderColor::BACKGROUND_COLOR);
+  colormap_[ColorMode::MATERIAL] =
+      ColorMap::getColor(cs, RenderColor::OPENCSG_FACE_FRONT_COLOR);
+  colormap_[ColorMode::CUTOUT] =
+      ColorMap::getColor(cs, RenderColor::OPENCSG_FACE_BACK_COLOR);
+  colormap_[ColorMode::MATERIAL_EDGES] =
+      ColorMap::getColor(cs, RenderColor::CGAL_EDGE_FRONT_COLOR);
+  colormap_[ColorMode::CUTOUT_EDGES] =
+      ColorMap::getColor(cs, RenderColor::CGAL_EDGE_BACK_COLOR);
+  colormap_[ColorMode::EMPTY_SPACE] =
+      ColorMap::getColor(cs, RenderColor::BACKGROUND_COLOR);
   colorscheme_ = &cs;
 }
 
-
-std::vector<SelectedObject> Renderer::findModelObject(const Vector3d& /*near_pt*/, const Vector3d& /*far_pt*/, int /*mouse_x*/, int /*mouse_y*/, double /*tolerance*/) { return {}; }
-#else //NULLGL
+std::vector<SelectedObject>
+Renderer::findModelObject(const Vector3d & /*near_pt*/,
+                          const Vector3d & /*far_pt*/, int /*mouse_x*/,
+                          int /*mouse_y*/, double /*tolerance*/) {
+  return {};
+}
+#else // NULLGL
 
 Renderer::Renderer() : colorscheme_(nullptr) {}
-bool Renderer::getColorSchemeColor(Renderer::ColorMode colormode, Color4f& outcolor) const {return false; }
-bool Renderer::getShaderColor(Renderer::ColorMode colormode, const Color4f& object_color, Color4f& outcolor) const { return false; }
-std::string ShaderUtils::loadShaderSource(const std::string& name) { return ""; }
-void Renderer::setColorScheme(const ColorScheme& cs) {}
-std::vector<SelectedObject> Renderer::findModelObject(const Vector3d& /*near_pt*/, const Vector3d& /*far_pt*/, int /*mouse_x*/, int /*mouse_y*/, double /*tolerance*/) { return {}; }
+bool Renderer::getColorSchemeColor(Renderer::ColorMode colormode,
+                                   Color4f &outcolor) const {
+  return false;
+}
+bool Renderer::getShaderColor(Renderer::ColorMode colormode,
+                              const Color4f &object_color,
+                              Color4f &outcolor) const {
+  return false;
+}
+std::string ShaderUtils::loadShaderSource(const std::string &name) {
+  return "";
+}
+void Renderer::setColorScheme(const ColorScheme &cs) {}
+std::vector<SelectedObject>
+Renderer::findModelObject(const Vector3d & /*near_pt*/,
+                          const Vector3d & /*far_pt*/, int /*mouse_x*/,
+                          int /*mouse_y*/, double /*tolerance*/) {
+  return {};
+}
 
-#endif //NULLGL
+#endif // NULLGL
diff --git a/src/glview/Renderer.h b/src/glview/Renderer.h
index 78d41edd2..e83febccd 100644
--- a/src/glview/Renderer.h
+++ b/src/glview/Renderer.h
@@ -1,14 +1,14 @@
 #pragma once
 
+#include "core/Selection.h"
+#include "core/enums.h"
 #include "geometry/linalg.h"
-#include "glview/ShaderUtils.h"
 #include "glview/ColorMap.h"
-#include "core/enums.h"
-#include "core/Selection.h"
+#include "glview/ShaderUtils.h"
 
 #ifdef _MSC_VER // NULL
-#include <map>
 #include <cstdlib>
+#include <map>
 #endif
 
 #include <vector>
@@ -18,30 +18,30 @@ namespace RendererUtils {
 #define CSGMODE_DIFFERENCE_FLAG 0x10
 
 enum CSGMode {
-  CSGMODE_NONE                  = 0x00,
-  CSGMODE_NORMAL                = 0x01,
-  CSGMODE_DIFFERENCE            = CSGMODE_NORMAL | CSGMODE_DIFFERENCE_FLAG,
-  CSGMODE_BACKGROUND            = 0x02,
+  CSGMODE_NONE = 0x00,
+  CSGMODE_NORMAL = 0x01,
+  CSGMODE_DIFFERENCE = CSGMODE_NORMAL | CSGMODE_DIFFERENCE_FLAG,
+  CSGMODE_BACKGROUND = 0x02,
   CSGMODE_BACKGROUND_DIFFERENCE = CSGMODE_BACKGROUND | CSGMODE_DIFFERENCE_FLAG,
-  CSGMODE_HIGHLIGHT             = 0x03,
-  CSGMODE_HIGHLIGHT_DIFFERENCE  = CSGMODE_HIGHLIGHT | CSGMODE_DIFFERENCE_FLAG
+  CSGMODE_HIGHLIGHT = 0x03,
+  CSGMODE_HIGHLIGHT_DIFFERENCE = CSGMODE_HIGHLIGHT | CSGMODE_DIFFERENCE_FLAG
 };
 
-CSGMode getCsgMode(const bool highlight_mode, const bool background_mode, const OpenSCADOperator type = OpenSCADOperator::UNION);
+CSGMode getCsgMode(const bool highlight_mode, const bool background_mode,
+                   const OpenSCADOperator type = OpenSCADOperator::UNION);
 
 } // namespace RendererUtils
 
-class Renderer
-{
+class Renderer {
 public:
   Renderer();
   virtual ~Renderer() = default;
 
   virtual void prepare(const ShaderUtils::ShaderInfo *shaderinfo) = 0;
-  virtual void draw(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const = 0;
+  virtual void draw(bool showedges,
+                    const ShaderUtils::ShaderInfo *shaderinfo) const = 0;
   [[nodiscard]] virtual BoundingBox getBoundingBox() const = 0;
 
-
   enum class ColorMode {
     NONE,
     MATERIAL,
@@ -57,11 +57,15 @@ public:
     EMPTY_SPACE
   };
 
-  bool getColorSchemeColor(ColorMode colormode, Color4f& outcolor) const;
-  bool getShaderColor(Renderer::ColorMode colormode, const Color4f& object_color, Color4f& outcolor) const;
-  virtual void setColorScheme(const ColorScheme& cs);
+  bool getColorSchemeColor(ColorMode colormode, Color4f &outcolor) const;
+  bool getShaderColor(Renderer::ColorMode colormode,
+                      const Color4f &object_color, Color4f &outcolor) const;
+  virtual void setColorScheme(const ColorScheme &cs);
 
-  virtual std::vector<SelectedObject> findModelObject(const Vector3d& near_pt, const Vector3d& far_pt, int mouse_x, int mouse_y, double tolerance);
+  virtual std::vector<SelectedObject> findModelObject(const Vector3d &near_pt,
+                                                      const Vector3d &far_pt,
+                                                      int mouse_x, int mouse_y,
+                                                      double tolerance);
 
 protected:
   std::map<ColorMode, Color4f> colormap_;
diff --git a/src/glview/ShaderUtils.cc b/src/glview/ShaderUtils.cc
index 207462928..be2ead16a 100644
--- a/src/glview/ShaderUtils.cc
+++ b/src/glview/ShaderUtils.cc
@@ -1,14 +1,14 @@
 #include "glview/ShaderUtils.h"
 
+#include <fstream>
 #include <sstream>
 #include <string>
-#include <fstream>
 
 #include "platform/PlatformUtils.h"
 
 namespace {
 
-GLuint compileShader(const std::string& name, GLuint shader_type) {
+GLuint compileShader(const std::string &name, GLuint shader_type) {
   auto shader_source = ShaderUtils::loadShaderSource(name);
   const GLuint shader = glCreateShader(shader_type);
   auto *c_source = shader_source.c_str();
@@ -26,23 +26,26 @@ GLuint compileShader(const std::string& name, GLuint shader_type) {
   return shader;
 }
 
-}  // namespace
+} // namespace
 
 namespace ShaderUtils {
 
-std::string loadShaderSource(const std::string& name) {
-  std::string shaderPath = (PlatformUtils::resourcePath("shaders") / name).string();
+std::string loadShaderSource(const std::string &name) {
+  std::string shaderPath =
+      (PlatformUtils::resourcePath("shaders") / name).string();
   std::ostringstream buffer;
   const std::ifstream f(shaderPath);
   if (f.is_open()) {
     buffer << f.rdbuf();
   } else {
-    LOG(message_group::UI_Error, "Cannot open shader source file: '%1$s'", shaderPath);
+    LOG(message_group::UI_Error, "Cannot open shader source file: '%1$s'",
+        shaderPath);
   }
   return buffer.str();
 }
 
-ShaderResource compileShaderProgram(const std::string& vs_str, const std::string& fs_str) {
+ShaderResource compileShaderProgram(const std::string &vs_str,
+                                    const std::string &fs_str) {
   int shaderstatus;
   const char *vs_source = vs_str.c_str();
   const char *fs_source = fs_str.c_str();
@@ -56,7 +59,8 @@ ShaderResource compileShaderProgram(const std::string& vs_str, const std::string
     char logbuffer[1000];
     glGetShaderInfoLog(vertex_shader, sizeof(logbuffer), &loglen, logbuffer);
     // FIXME: Use OpenCAD log to error instead of stderr
-    fprintf(stderr, __FILE__ ": OpenGL vertex shader Error:\n%.*s\n\n", loglen, logbuffer);
+    fprintf(stderr, __FILE__ ": OpenGL vertex shader Error:\n%.*s\n\n", loglen,
+            logbuffer);
     return {};
   }
 
@@ -69,7 +73,8 @@ ShaderResource compileShaderProgram(const std::string& vs_str, const std::string
     char logbuffer[1000];
     glGetShaderInfoLog(fragment_shader, sizeof(logbuffer), &loglen, logbuffer);
     // FIXME: Use OpenCAD log to error instead of stderr
-    fprintf(stderr, __FILE__ ": OpenGL fragment shader Error:\n%.*s\n\n", loglen, logbuffer);
+    fprintf(stderr, __FILE__ ": OpenGL fragment shader Error:\n%.*s\n\n",
+            loglen, logbuffer);
     return {};
   }
 
@@ -86,7 +91,8 @@ ShaderResource compileShaderProgram(const std::string& vs_str, const std::string
     char logbuffer[1000];
     glGetProgramInfoLog(shader_prog, sizeof(logbuffer), &loglen, logbuffer);
     // FIXME: Use OpenCAD log to error instead of stderr
-    fprintf(stderr, __FILE__ ": OpenGL Program Linker Error:\n%.*s\n\n", loglen, logbuffer);
+    fprintf(stderr, __FILE__ ": OpenGL Program Linker Error:\n%.*s\n\n", loglen,
+            logbuffer);
     return {};
   } else {
     glValidateProgram(shader_prog);
@@ -96,16 +102,17 @@ ShaderResource compileShaderProgram(const std::string& vs_str, const std::string
       char logbuffer[1000];
       glGetProgramInfoLog(shader_prog, sizeof(logbuffer), &loglen, logbuffer);
       // FIXME: Use OpenCAD log to error instead of stderr
-      fprintf(stderr, __FILE__ ": OpenGL Program Validation results:\n%.*s\n\n", loglen, logbuffer);
+      fprintf(stderr, __FILE__ ": OpenGL Program Validation results:\n%.*s\n\n",
+              loglen, logbuffer);
       return {};
     }
   }
 
   return {
-    .shader_program = shader_prog,
-    .vertex_shader = vertex_shader,
-    .fragment_shader = fragment_shader,
+      .shader_program = shader_prog,
+      .vertex_shader = vertex_shader,
+      .fragment_shader = fragment_shader,
   };
 }
 
-}  // namespace ShaderUtils
+} // namespace ShaderUtils
diff --git a/src/glview/ShaderUtils.h b/src/glview/ShaderUtils.h
index 2fcb29d55..f087d36dd 100644
--- a/src/glview/ShaderUtils.h
+++ b/src/glview/ShaderUtils.h
@@ -1,8 +1,8 @@
 #pragma once
 
-#include <unordered_map>
-#include <string>
 #include "glview/system-gl.h"
+#include <string>
+#include <unordered_map>
 
 namespace ShaderUtils {
 
@@ -26,7 +26,8 @@ struct ShaderInfo {
   std::unordered_map<std::string, int> attributes;
 };
 
-std::string loadShaderSource(const std::string& name);
-ShaderResource compileShaderProgram(const std::string& vs_str, const std::string& fs_str);
+std::string loadShaderSource(const std::string &name);
+ShaderResource compileShaderProgram(const std::string &vs_str,
+                                    const std::string &fs_str);
 
 } // namespace ShaderUtils
diff --git a/src/glview/VBOBuilder.cc b/src/glview/VBOBuilder.cc
index d5831d0b4..1474251d7 100644
--- a/src/glview/VBOBuilder.cc
+++ b/src/glview/VBOBuilder.cc
@@ -1,26 +1,26 @@
 #include "glview/VBOBuilder.h"
 
-#include <unordered_map>
-#include <cstring>
-#include <cassert>
 #include <array>
+#include <cassert>
+#include <cstdio>
+#include <cstring>
+#include <memory>
+#include <unordered_map>
 #include <utility>
 #include <vector>
-#include <memory>
-#include <cstdio>
 
-#include "geometry/linalg.h"
 #include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
+#include "utils/hash.h" // IWYU pragma: keep
 #include "utils/printutils.h"
-#include "utils/hash.h"  // IWYU pragma: keep
 
 namespace {
 
-// Since we transform each verted on the CPU, we cache already transformed vertices in the same PolySet
-// to avoid redundantly transforming the same vertex value twice, while we process non-indexed PolySets.
-Vector3d uniqueMultiply(std::unordered_map<Vector3d, Vector3d>& vert_mult_map, const Vector3d& in_vert,
-                        const Transform3d& m)
-{
+// Since we transform each verted on the CPU, we cache already transformed
+// vertices in the same PolySet to avoid redundantly transforming the same
+// vertex value twice, while we process non-indexed PolySets.
+Vector3d uniqueMultiply(std::unordered_map<Vector3d, Vector3d> &vert_mult_map,
+                        const Vector3d &in_vert, const Transform3d &m) {
   auto entry = vert_mult_map.find(in_vert);
   if (entry == vert_mult_map.end()) {
     Vector3d out_vert = m * in_vert;
@@ -30,62 +30,68 @@ Vector3d uniqueMultiply(std::unordered_map<Vector3d, Vector3d>& vert_mult_map, c
   return entry->second;
 }
 
-}  // namespace
+} // namespace
 
-void addAttributeValues(IAttributeData&) {}
+void addAttributeValues(IAttributeData &) {}
 
-void VertexData::getLastVertex(std::vector<GLbyte>& interleaved_buffer) const
-{
+void VertexData::getLastVertex(std::vector<GLbyte> &interleaved_buffer) const {
   GLbyte *dst_start = interleaved_buffer.data();
-  for (const auto& data : attributes_) {
+  for (const auto &data : attributes_) {
     size_t size = data->sizeofAttribute();
     GLbyte *dst = dst_start;
-    const GLbyte *src = data->toBytes() + data->sizeInBytes() - data->sizeofAttribute();
+    const GLbyte *src =
+        data->toBytes() + data->sizeInBytes() - data->sizeofAttribute();
     std::memcpy((void *)dst, (void *)src, size);
     dst_start += size;
   }
 }
 
-void VertexData::remove(size_t count)
-{
-  for (const auto& data : attributes_) {
+void VertexData::remove(size_t count) {
+  for (const auto &data : attributes_) {
     data->remove(count);
   }
 }
 
 // Adds attributes needed for regular 3D polygon rendering:
 // position, normal, color
-void VBOBuilder::addSurfaceData()
-{
+void VBOBuilder::addSurfaceData() {
   auto vertex_data = std::make_shared<VertexData>();
-  vertex_data->addPositionData(std::make_shared<AttributeData<GLfloat, 3, GL_FLOAT>>());
-  vertex_data->addNormalData(std::make_shared<AttributeData<GLfloat, 3, GL_FLOAT>>());
-  vertex_data->addColorData(std::make_shared<AttributeData<GLfloat, 4, GL_FLOAT>>());
+  vertex_data->addPositionData(
+      std::make_shared<AttributeData<GLfloat, 3, GL_FLOAT>>());
+  vertex_data->addNormalData(
+      std::make_shared<AttributeData<GLfloat, 3, GL_FLOAT>>());
+  vertex_data->addColorData(
+      std::make_shared<AttributeData<GLfloat, 4, GL_FLOAT>>());
   surface_index_ = vertices_.size();
   vertices_.emplace_back(std::move(vertex_data));
 }
 
-void VBOBuilder::addEdgeData()
-{
+void VBOBuilder::addEdgeData() {
   auto vertex_data = std::make_shared<VertexData>();
-  vertex_data->addPositionData(std::make_shared<AttributeData<GLfloat, 3, GL_FLOAT>>());
-  vertex_data->addColorData(std::make_shared<AttributeData<GLfloat, 4, GL_FLOAT>>());
+  vertex_data->addPositionData(
+      std::make_shared<AttributeData<GLfloat, 3, GL_FLOAT>>());
+  vertex_data->addColorData(
+      std::make_shared<AttributeData<GLfloat, 4, GL_FLOAT>>());
   edge_index_ = vertices_.size();
   vertices_.emplace_back(std::move(vertex_data));
 }
 
-void VBOBuilder::createVertex(const std::array<Vector3d, 3>& points,
-                              const std::array<Vector3d, 3>& normals,
-                              const Color4f& color,
-                              size_t active_point_index, size_t primitive_index,
-                              size_t shape_size, bool outlines, bool /*mirror*/)
-{
-  addAttributeValues(*(data()->positionData()), points[active_point_index][0], points[active_point_index][1], points[active_point_index][2]);
+void VBOBuilder::createVertex(const std::array<Vector3d, 3> &points,
+                              const std::array<Vector3d, 3> &normals,
+                              const Color4f &color, size_t active_point_index,
+                              size_t primitive_index, size_t shape_size,
+                              bool outlines, bool /*mirror*/) {
+  addAttributeValues(*(data()->positionData()), points[active_point_index][0],
+                     points[active_point_index][1],
+                     points[active_point_index][2]);
   if (data()->hasNormalData()) {
-    addAttributeValues(*(data()->normalData()), normals[active_point_index][0], normals[active_point_index][1], normals[active_point_index][2]);
+    addAttributeValues(*(data()->normalData()), normals[active_point_index][0],
+                       normals[active_point_index][1],
+                       normals[active_point_index][2]);
   }
   if (data()->hasColorData()) {
-    addAttributeValues(*(data()->colorData()), color.r(), color.g(), color.b(), color.a());
+    addAttributeValues(*(data()->colorData()), color.r(), color.g(), color.b(),
+                       color.a());
   }
 
   if (useElements()) {
@@ -97,7 +103,8 @@ void VBOBuilder::createVertex(const std::array<Vector3d, 3>& points,
     if (entry.first == elements_map_.end()) {
       // append vertex data if this is a new element
       if (!interleaved_buffer_.empty()) {
-        memcpy(interleaved_buffer_.data() + vertices_offset_, interleaved_vertex.data(), interleaved_vertex.size());
+        memcpy(interleaved_buffer_.data() + vertices_offset_,
+               interleaved_vertex.data(), interleaved_vertex.size());
         data()->clear();
       }
       vertices_offset_ += interleaved_vertex.size();
@@ -133,16 +140,16 @@ void VBOBuilder::createVertex(const std::array<Vector3d, 3>& points,
       std::vector<GLbyte> interleaved_vertex;
       interleaved_vertex.resize(data()->stride());
       data()->getLastVertex(interleaved_vertex);
-      memcpy(interleaved_buffer_.data() + vertices_offset_, interleaved_vertex.data(), interleaved_vertex.size());
+      memcpy(interleaved_buffer_.data() + vertices_offset_,
+             interleaved_vertex.data(), interleaved_vertex.size());
       vertices_offset_ += interleaved_vertex.size();
       data()->clear();
     }
   }
 }
 
-void VBOBuilder::createInterleavedVBOs()
-{
-  for (const auto& state : vertex_state_container_.states()) {
+void VBOBuilder::createInterleavedVBOs() {
+  for (const auto &state : vertex_state_container_.states()) {
     state->setDrawOffset(this->indexOffset(state->drawOffset()));
   }
 
@@ -150,16 +157,20 @@ void VBOBuilder::createInterleavedVBOs()
   size_t total_size = this->sizeInBytes();
   // If VertexArray is not empty, and initial size is zero
   if (interleaved_buffer_.empty() && total_size) {
-    GL_TRACE("glBindBuffer(GL_ARRAY_BUFFER, %d)", vertex_state_container_.verticesVBO());
-    GL_CHECKD(glBindBuffer(GL_ARRAY_BUFFER, vertex_state_container_.verticesVBO()));
-    GL_TRACE("glBufferData(GL_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)", total_size % (void *)nullptr);
-    GL_CHECKD(glBufferData(GL_ARRAY_BUFFER, total_size, nullptr, GL_STATIC_DRAW));
+    GL_TRACE("glBindBuffer(GL_ARRAY_BUFFER, %d)",
+             vertex_state_container_.verticesVBO());
+    GL_CHECKD(
+        glBindBuffer(GL_ARRAY_BUFFER, vertex_state_container_.verticesVBO()));
+    GL_TRACE("glBufferData(GL_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)",
+             total_size % (void *)nullptr);
+    GL_CHECKD(
+        glBufferData(GL_ARRAY_BUFFER, total_size, nullptr, GL_STATIC_DRAW));
 
     size_t dst_start = 0;
-    for (const auto& vertex_data : vertices_) {
+    for (const auto &vertex_data : vertices_) {
       // All attribute vectors need to be the same size to interleave
       size_t idx = 0, last_size = 0, stride = vertex_data->stride();
-      for (const auto& data : vertex_data->attributes()) {
+      for (const auto &data : vertex_data->attributes()) {
         size_t size = data->sizeofAttribute();
         const GLbyte *src = data->toBytes();
         size_t dst = dst_start;
@@ -167,7 +178,9 @@ void VBOBuilder::createInterleavedVBOs()
         if (src) {
           if (idx != 0) {
             if (last_size != data->size() / data->count()) {
-              PRINTDB("attribute data for vertex incorrect size at index %d = %d", idx % (data->size() / data->count()));
+              PRINTDB(
+                  "attribute data for vertex incorrect size at index %d = %d",
+                  idx % (data->size() / data->count()));
               PRINTDB("last_size = %d", last_size);
               assert(false);
             }
@@ -175,7 +188,8 @@ void VBOBuilder::createInterleavedVBOs()
           last_size = data->size() / data->count();
           for (size_t i = 0; i < last_size; ++i) {
             // This path is chosen in vertex-object-renderers non-direct mode
-            GL_TRACE("A glBufferSubData(GL_ARRAY_BUFFER, %p, %d, %p)", (void *)dst % size % (void *)src);
+            GL_TRACE("A glBufferSubData(GL_ARRAY_BUFFER, %p, %d, %p)",
+                     (void *)dst % size % (void *)src);
             GL_CHECKD(glBufferSubData(GL_ARRAY_BUFFER, dst, size, src));
             src += size;
             dst += stride;
@@ -190,26 +204,37 @@ void VBOBuilder::createInterleavedVBOs()
     GL_TRACE0("glBindBuffer(GL_ARRAY_BUFFER, 0)");
     GL_CHECKD(glBindBuffer(GL_ARRAY_BUFFER, 0));
   } else if (!interleaved_buffer_.empty()) {
-    GL_TRACE("glBindBuffer(GL_ARRAY_BUFFER, %d)", vertex_state_container_.verticesVBO());
-    GL_CHECKD(glBindBuffer(GL_ARRAY_BUFFER, vertex_state_container_.verticesVBO()));
-    GL_TRACE("glBufferData(GL_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)", interleaved_buffer_.size() % (void *)interleaved_buffer_.data());
-    GL_CHECKD(glBufferData(GL_ARRAY_BUFFER, interleaved_buffer_.size(), interleaved_buffer_.data(), GL_STATIC_DRAW));
+    GL_TRACE("glBindBuffer(GL_ARRAY_BUFFER, %d)",
+             vertex_state_container_.verticesVBO());
+    GL_CHECKD(
+        glBindBuffer(GL_ARRAY_BUFFER, vertex_state_container_.verticesVBO()));
+    GL_TRACE("glBufferData(GL_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)",
+             interleaved_buffer_.size() % (void *)interleaved_buffer_.data());
+    GL_CHECKD(glBufferData(GL_ARRAY_BUFFER, interleaved_buffer_.size(),
+                           interleaved_buffer_.data(), GL_STATIC_DRAW));
     GL_TRACE0("glBindBuffer(GL_ARRAY_BUFFER, 0)");
     GL_CHECKD(glBindBuffer(GL_ARRAY_BUFFER, 0));
   }
 
-  PRINTDB("useElements() = %d, elements_size_ = %d", useElements() % elements_size_);
+  PRINTDB("useElements() = %d, elements_size_ = %d",
+          useElements() % elements_size_);
   if (useElements()) {
-    GL_TRACE("glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, %d)", vertex_state_container_.elementsVBO());
-    GL_CHECKD(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vertex_state_container_.elementsVBO()));
+    GL_TRACE("glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, %d)",
+             vertex_state_container_.elementsVBO());
+    GL_CHECKD(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,
+                           vertex_state_container_.elementsVBO()));
     if (elements_size_ == 0) {
-      GL_TRACE("glBufferData(GL_ELEMENT_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)", elements_.sizeInBytes() % (void *)nullptr);
-      GL_CHECKD(glBufferData(GL_ELEMENT_ARRAY_BUFFER, elements_.sizeInBytes(), nullptr, GL_STATIC_DRAW));
+      GL_TRACE("glBufferData(GL_ELEMENT_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)",
+               elements_.sizeInBytes() % (void *)nullptr);
+      GL_CHECKD(glBufferData(GL_ELEMENT_ARRAY_BUFFER, elements_.sizeInBytes(),
+                             nullptr, GL_STATIC_DRAW));
     }
     size_t last_size = 0;
-    for (const auto& e : elements_.attributes()) {
-      GL_TRACE("glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, %d, %d, %p)", last_size % e->sizeInBytes() % (void *)e->toBytes());
-      GL_CHECKD(glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, last_size, e->sizeInBytes(), e->toBytes()));
+    for (const auto &e : elements_.attributes()) {
+      GL_TRACE("glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, %d, %d, %p)",
+               last_size % e->sizeInBytes() % (void *)e->toBytes());
+      GL_CHECKD(glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, last_size,
+                                e->sizeInBytes(), e->toBytes()));
       last_size += e->sizeInBytes();
     }
     GL_TRACE0("glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0)");
@@ -217,30 +242,35 @@ void VBOBuilder::createInterleavedVBOs()
   }
 }
 
-void VBOBuilder::addAttributePointers(size_t start_offset)
-{
-  if (!this->data()) return;
+void VBOBuilder::addAttributePointers(size_t start_offset) {
+  if (!this->data())
+    return;
 
   std::shared_ptr<VertexData> vertex_data = this->data();
-  std::shared_ptr<VertexState> vertex_state = vertex_state_container_.states().back();
+  std::shared_ptr<VertexState> vertex_state =
+      vertex_state_container_.states().back();
 
   GLsizei count = vertex_data->positionData()->count();
   GLenum type = vertex_data->positionData()->glType();
   GLsizei stride = vertex_data->stride();
-  size_t offset = start_offset + vertex_data->interleavedOffset(vertex_data->positionIndex());
-  // Note: Some code, like OpenCSGRenderer::createVBOPrimitive() relies on this order of
-  // glBegin/glEnd functions for unlit/uncolored vertex rendering.
+  size_t offset = start_offset +
+                  vertex_data->interleavedOffset(vertex_data->positionIndex());
+  // Note: Some code, like OpenCSGRenderer::createVBOPrimitive() relies on this
+  // order of glBegin/glEnd functions for unlit/uncolored vertex rendering.
   vertex_state->glBegin().emplace_back([]() {
     GL_TRACE0("glEnableClientState(GL_VERTEX_ARRAY)");
     GL_CHECKD(glEnableClientState(GL_VERTEX_ARRAY));
   });
-  vertex_state->glBegin().emplace_back([count, type, stride, offset, vs_ptr = std::weak_ptr<VertexState>(vertex_state)]() {
+  vertex_state->glBegin().emplace_back([count, type, stride, offset,
+                                        vs_ptr = std::weak_ptr<VertexState>(
+                                            vertex_state)]() {
     auto vs = vs_ptr.lock();
     if (vs) {
       // NOLINTBEGIN(performance-no-int-to-ptr)
       GL_TRACE("glVertexPointer(%d, %d, %d, %p)",
                count % type % stride % (GLvoid *)(vs->drawOffset() + offset));
-      GL_CHECKD(glVertexPointer(count, type, stride, (GLvoid *)(vs->drawOffset() + offset)));
+      GL_CHECKD(glVertexPointer(count, type, stride,
+                                (GLvoid *)(vs->drawOffset() + offset)));
       // NOLINTEND(performance-no-int-to-ptr)
     }
   });
@@ -251,20 +281,25 @@ void VBOBuilder::addAttributePointers(size_t start_offset)
 
   if (vertex_data->hasNormalData()) {
     type = vertex_data->normalData()->glType();
-    size_t offset = start_offset + vertex_data->interleavedOffset(vertex_data->normalIndex());
+    size_t offset = start_offset +
+                    vertex_data->interleavedOffset(vertex_data->normalIndex());
     vertex_state->glBegin().emplace_back([]() {
       GL_TRACE0("glEnableClientState(GL_NORMAL_ARRAY)");
       GL_CHECKD(glEnableClientState(GL_NORMAL_ARRAY));
     });
-    vertex_state->glBegin().emplace_back([type, stride, offset, vs_ptr = std::weak_ptr<VertexState>(vertex_state)]() {
-      auto vs = vs_ptr.lock();
-      if (vs) {
-        // NOLINTBEGIN(performance-no-int-to-ptr)
-        GL_TRACE("glNormalPointer(%d, %d, %p)", type % stride % (GLvoid *)(vs->drawOffset() + offset));
-        GL_CHECKD(glNormalPointer(type, stride, (GLvoid *)(vs->drawOffset() + offset)));
-        // NOLINTEND(performance-no-int-to-ptr)
-      }
-    });
+    vertex_state->glBegin().emplace_back(
+        [type, stride, offset,
+         vs_ptr = std::weak_ptr<VertexState>(vertex_state)]() {
+          auto vs = vs_ptr.lock();
+          if (vs) {
+            // NOLINTBEGIN(performance-no-int-to-ptr)
+            GL_TRACE("glNormalPointer(%d, %d, %p)",
+                     type % stride % (GLvoid *)(vs->drawOffset() + offset));
+            GL_CHECKD(glNormalPointer(type, stride,
+                                      (GLvoid *)(vs->drawOffset() + offset)));
+            // NOLINTEND(performance-no-int-to-ptr)
+          }
+        });
     vertex_state->glEnd().emplace_back([]() {
       GL_TRACE0("glDisableClientState(GL_NORMAL_ARRAY)");
       GL_CHECKD(glDisableClientState(GL_NORMAL_ARRAY));
@@ -273,17 +308,22 @@ void VBOBuilder::addAttributePointers(size_t start_offset)
   if (vertex_data->hasColorData()) {
     count = vertex_data->colorData()->count();
     type = vertex_data->colorData()->glType();
-    size_t offset = start_offset + vertex_data->interleavedOffset(vertex_data->colorIndex());
+    size_t offset = start_offset +
+                    vertex_data->interleavedOffset(vertex_data->colorIndex());
     vertex_state->glBegin().emplace_back([]() {
       GL_TRACE0("glEnableClientState(GL_COLOR_ARRAY)");
       GL_CHECKD(glEnableClientState(GL_COLOR_ARRAY));
     });
-    vertex_state->glBegin().emplace_back([count, type, stride, offset, vs_ptr = std::weak_ptr<VertexState>(vertex_state)]() {
+    vertex_state->glBegin().emplace_back([count, type, stride, offset,
+                                          vs_ptr = std::weak_ptr<VertexState>(
+                                              vertex_state)]() {
       auto vs = vs_ptr.lock();
       if (vs) {
         // NOLINTBEGIN(performance-no-int-to-ptr)
-        GL_TRACE("glColorPointer(%d, %d, %d, %p)", count % type % stride % (GLvoid *)(vs->drawOffset() + offset));
-        GL_CHECKD(glColorPointer(count, type, stride, (GLvoid *)(vs->drawOffset() + offset)));
+        GL_TRACE("glColorPointer(%d, %d, %d, %p)",
+                 count % type % stride % (GLvoid *)(vs->drawOffset() + offset));
+        GL_CHECKD(glColorPointer(count, type, stride,
+                                 (GLvoid *)(vs->drawOffset() + offset)));
         // NOLINTEND(performance-no-int-to-ptr)
       }
     });
@@ -299,41 +339,55 @@ void VBOBuilder::addAttributePointers(size_t start_offset)
 void VBOBuilder::allocateBuffers(size_t num_vertices) {
   size_t vbo_buffer_size = num_vertices * stride();
   interleaved_buffer_.resize(vbo_buffer_size);
-  GL_TRACE("glBindBuffer(GL_ARRAY_BUFFER, %d)", vertex_state_container_.verticesVBO());
-  GL_CHECKD(glBindBuffer(GL_ARRAY_BUFFER, vertex_state_container_.verticesVBO()));
-  GL_TRACE("glBufferData(GL_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)", vbo_buffer_size % (void *)nullptr);
-  GL_CHECKD(glBufferData(GL_ARRAY_BUFFER, vbo_buffer_size, nullptr, GL_STATIC_DRAW));
+  GL_TRACE("glBindBuffer(GL_ARRAY_BUFFER, %d)",
+           vertex_state_container_.verticesVBO());
+  GL_CHECKD(
+      glBindBuffer(GL_ARRAY_BUFFER, vertex_state_container_.verticesVBO()));
+  GL_TRACE("glBufferData(GL_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)",
+           vbo_buffer_size % (void *)nullptr);
+  GL_CHECKD(
+      glBufferData(GL_ARRAY_BUFFER, vbo_buffer_size, nullptr, GL_STATIC_DRAW));
   if (Feature::ExperimentalVxORenderersIndexing.is_enabled()) {
     // Use smallest possible index data type
     if (num_vertices <= 0xff) {
-      addElementsData(std::make_shared<AttributeData<GLubyte, 1, GL_UNSIGNED_BYTE>>());
+      addElementsData(
+          std::make_shared<AttributeData<GLubyte, 1, GL_UNSIGNED_BYTE>>());
     } else if (num_vertices <= 0xffff) {
-      addElementsData(std::make_shared<AttributeData<GLushort, 1, GL_UNSIGNED_SHORT>>());
+      addElementsData(
+          std::make_shared<AttributeData<GLushort, 1, GL_UNSIGNED_SHORT>>());
     } else {
-      addElementsData(std::make_shared<AttributeData<GLuint, 1, GL_UNSIGNED_INT>>());
+      addElementsData(
+          std::make_shared<AttributeData<GLuint, 1, GL_UNSIGNED_INT>>());
     }
     // FIXME: How do we know how much to allocate?
-    // FIXME: Should we preallocate so we don't have to make a bunch of glBufferSubData() calls?
+    // FIXME: Should we preallocate so we don't have to make a bunch of
+    // glBufferSubData() calls?
     size_t elements_size = num_vertices * elements_.stride();
     setElementsSize(elements_size);
-    GL_TRACE("glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, %d)", vertex_state_container_.elementsVBO());
-    GL_CHECKD(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vertex_state_container_.elementsVBO()));
-    GL_TRACE("glBufferData(GL_ELEMENT_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)", elements_size % (void *)nullptr);
-    GL_CHECKD(glBufferData(GL_ELEMENT_ARRAY_BUFFER, elements_size, nullptr, GL_STATIC_DRAW));
+    GL_TRACE("glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, %d)",
+             vertex_state_container_.elementsVBO());
+    GL_CHECKD(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,
+                           vertex_state_container_.elementsVBO()));
+    GL_TRACE("glBufferData(GL_ELEMENT_ARRAY_BUFFER, %d, %p, GL_STATIC_DRAW)",
+             elements_size % (void *)nullptr);
+    GL_CHECKD(glBufferData(GL_ELEMENT_ARRAY_BUFFER, elements_size, nullptr,
+                           GL_STATIC_DRAW));
   }
 }
 
-// FIXME: This specifically adds barycentric vertex attributes, so document/rename accordingly
-void VBOBuilder::addShaderData()
-{
+// FIXME: This specifically adds barycentric vertex attributes, so
+// document/rename accordingly
+void VBOBuilder::addShaderData() {
   const std::shared_ptr<VertexData> vertex_data = data();
   shader_attributes_index_ = vertex_data->attributes().size();
-  vertex_data->addAttributeData(std::make_shared<AttributeData<GLubyte, 4, GL_UNSIGNED_BYTE>>()); // barycentric
+  vertex_data->addAttributeData(
+      std::make_shared<
+          AttributeData<GLubyte, 4, GL_UNSIGNED_BYTE>>()); // barycentric
 }
 
 void VBOBuilder::add_barycentric_attribute(size_t active_point_index,
-                                           size_t primitive_index, size_t shape_size, bool outlines)
-{
+                                           size_t primitive_index,
+                                           size_t shape_size, bool outlines) {
   const std::shared_ptr<VertexData> vertex_data = data();
 
   // Get edge states
@@ -365,14 +419,16 @@ void VBOBuilder::add_barycentric_attribute(size_t active_point_index,
   barycentric_flags[active_point_index] = 1;
 
   addAttributeValues(
-    *(vertex_data->attributes()[shader_attributes_index_ + BARYCENTRIC_ATTRIB]),
-    barycentric_flags[0], barycentric_flags[1], barycentric_flags[2], 0);
+      *(vertex_data
+            ->attributes()[shader_attributes_index_ + BARYCENTRIC_ATTRIB]),
+      barycentric_flags[0], barycentric_flags[1], barycentric_flags[2], 0);
 }
 
-void VBOBuilder::create_triangle(const Color4f& color, const Vector3d& p0,
-                                 const Vector3d& p1, const Vector3d& p2, size_t primitive_index,
-                                 size_t shape_size, bool outlines, bool enable_barycentric, bool mirror)
-{
+void VBOBuilder::create_triangle(const Color4f &color, const Vector3d &p0,
+                                 const Vector3d &p1, const Vector3d &p2,
+                                 size_t primitive_index, size_t shape_size,
+                                 bool outlines, bool enable_barycentric,
+                                 bool mirror) {
   const double ax = p1[0] - p0[0], bx = p1[0] - p2[0];
   const double ay = p1[1] - p0[1], by = p1[1] - p2[1];
   const double az = p1[2] - p0[2], bz = p1[2] - p2[2];
@@ -382,7 +438,8 @@ void VBOBuilder::create_triangle(const Color4f& color, const Vector3d& p0,
   const double nl = sqrt(nx * nx + ny * ny + nz * nz);
   const Vector3d n = Vector3d(nx / nl, ny / nl, nz / nl);
 
-  if (!data()) return;
+  if (!data())
+    return;
 
   if (enable_barycentric) {
     add_barycentric_attribute(0, primitive_index, shape_size, outlines);
@@ -394,29 +451,30 @@ void VBOBuilder::create_triangle(const Color4f& color, const Vector3d& p0,
     if (enable_barycentric) {
       add_barycentric_attribute(1, primitive_index, shape_size, outlines);
     }
-    createVertex({p0, p1, p2}, {n, n, n}, color, 1, primitive_index, shape_size, outlines,
-                 mirror);
+    createVertex({p0, p1, p2}, {n, n, n}, color, 1, primitive_index, shape_size,
+                 outlines, mirror);
   }
   if (enable_barycentric) {
     add_barycentric_attribute(2, primitive_index, shape_size, outlines);
   }
-  createVertex({p0, p1, p2}, {n, n, n}, color, 2, primitive_index, shape_size, outlines,
-               mirror);
+  createVertex({p0, p1, p2}, {n, n, n}, color, 2, primitive_index, shape_size,
+               outlines, mirror);
   if (mirror) {
     if (enable_barycentric) {
       add_barycentric_attribute(1, primitive_index, shape_size, outlines);
     }
-    createVertex({p0, p1, p2}, {n, n, n}, color, 1, primitive_index, shape_size, outlines,
-                 mirror);
+    createVertex({p0, p1, p2}, {n, n, n}, color, 1, primitive_index, shape_size,
+                 outlines, mirror);
   }
 }
 
 // Creates a VBO "surface" from the PolySet.
 // This will usually create a new VertexState and append it to our
 // vertex states
-void VBOBuilder::create_surface(const PolySet& ps, const Transform3d& m,
-                                const Color4f& default_color, bool enable_barycentric, bool force_default_color)
-{
+void VBOBuilder::create_surface(const PolySet &ps, const Transform3d &m,
+                                const Color4f &default_color,
+                                bool enable_barycentric,
+                                bool force_default_color) {
   const std::shared_ptr<VertexData> vertex_data = data();
 
   if (!vertex_data) {
@@ -438,94 +496,114 @@ void VBOBuilder::create_surface(const PolySet& ps, const Transform3d& m,
   auto has_colors = !ps.color_indices.empty();
 
   for (int i = 0, n = ps.indices.size(); i < n; i++) {
-    const auto& poly = ps.indices[i];
-    const auto color_index = has_colors && i < ps.color_indices.size() ? ps.color_indices[i] : -1;
-    const auto& color = !force_default_color && color_index >= 0 && color_index < ps.colors.size() &&
-      ps.colors[color_index].isValid()
-                          ? ps.colors[color_index]
-                          : default_color;
+    const auto &poly = ps.indices[i];
+    const auto color_index =
+        has_colors && i < ps.color_indices.size() ? ps.color_indices[i] : -1;
+    const auto &color = !force_default_color && color_index >= 0 &&
+                                color_index < ps.colors.size() &&
+                                ps.colors[color_index].isValid()
+                            ? ps.colors[color_index]
+                            : default_color;
     if (poly.size() == 3) {
-      const Vector3d p0 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(0)], m);
-      const Vector3d p1 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(1)], m);
-      const Vector3d p2 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(2)], m);
-
-      create_triangle(color, p0, p1, p2, 0, poly.size(), false, enable_barycentric, mirrored);
+      const Vector3d p0 =
+          uniqueMultiply(vert_mult_map, ps.vertices[poly.at(0)], m);
+      const Vector3d p1 =
+          uniqueMultiply(vert_mult_map, ps.vertices[poly.at(1)], m);
+      const Vector3d p2 =
+          uniqueMultiply(vert_mult_map, ps.vertices[poly.at(2)], m);
+
+      create_triangle(color, p0, p1, p2, 0, poly.size(), false,
+                      enable_barycentric, mirrored);
       triangle_count++;
     } else if (poly.size() == 4) {
-      const Vector3d p0 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(0)], m);
-      const Vector3d p1 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(1)], m);
-      const Vector3d p2 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(2)], m);
-      const Vector3d p3 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(3)], m);
-
-      create_triangle(color, p0, p1, p3, 0, poly.size(), false, enable_barycentric, mirrored);
-      create_triangle(color, p2, p3, p1, 1, poly.size(), false, enable_barycentric, mirrored);
+      const Vector3d p0 =
+          uniqueMultiply(vert_mult_map, ps.vertices[poly.at(0)], m);
+      const Vector3d p1 =
+          uniqueMultiply(vert_mult_map, ps.vertices[poly.at(1)], m);
+      const Vector3d p2 =
+          uniqueMultiply(vert_mult_map, ps.vertices[poly.at(2)], m);
+      const Vector3d p3 =
+          uniqueMultiply(vert_mult_map, ps.vertices[poly.at(3)], m);
+
+      create_triangle(color, p0, p1, p3, 0, poly.size(), false,
+                      enable_barycentric, mirrored);
+      create_triangle(color, p2, p3, p1, 1, poly.size(), false,
+                      enable_barycentric, mirrored);
       triangle_count += 2;
     } else {
       Vector3d center = Vector3d::Zero();
-      for (const auto& idx : poly) {
+      for (const auto &idx : poly) {
         center += ps.vertices[idx];
       }
       center /= poly.size();
       for (size_t i = 1; i <= poly.size(); i++) {
         const Vector3d p0 = uniqueMultiply(vert_mult_map, center, m);
-        const Vector3d p1 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(i % poly.size())], m);
-        const Vector3d p2 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(i - 1)], m);
+        const Vector3d p1 = uniqueMultiply(
+            vert_mult_map, ps.vertices[poly.at(i % poly.size())], m);
+        const Vector3d p2 =
+            uniqueMultiply(vert_mult_map, ps.vertices[poly.at(i - 1)], m);
 
-        create_triangle(color, p0, p2, p1, i - 1, poly.size(), false, enable_barycentric, mirrored);
+        create_triangle(color, p0, p2, p1, i - 1, poly.size(), false,
+                        enable_barycentric, mirrored);
         triangle_count++;
       }
     }
   }
 
   GLenum elements_type = 0;
-  if (useElements()) elements_type = elementsData()->glType();
-  std::shared_ptr<VertexState> vertex_state = createVertexState(
-    GL_TRIANGLES, triangle_count * 3, elements_type, writeIndex(), elements_offset);
+  if (useElements())
+    elements_type = elementsData()->glType();
+  std::shared_ptr<VertexState> vertex_state =
+      createVertexState(GL_TRIANGLES, triangle_count * 3, elements_type,
+                        writeIndex(), elements_offset);
   vertex_state_container_.states().emplace_back(std::move(vertex_state));
   addAttributePointers(last_size);
 }
 
-void VBOBuilder::create_edges(const Polygon2d& polygon,
-                              const Transform3d& m,
-                              const Color4f& color)
-{
+void VBOBuilder::create_edges(const Polygon2d &polygon, const Transform3d &m,
+                              const Color4f &color) {
   const std::shared_ptr<VertexData> vertex_data = data();
 
-  if (!vertex_data) return;
+  if (!vertex_data)
+    return;
 
-  auto& vertex_states = states();
+  auto &vertex_states = states();
   std::unordered_map<Vector3d, Vector3d> vert_mult_map;
 
   // Render only outlines
-  for (const Outline2d& o : polygon.outlines()) {
+  for (const Outline2d &o : polygon.outlines()) {
     const auto last_size = verticesOffset();
     size_t elements_offset = 0;
     if (useElements()) {
       elements_offset = elementsOffset();
       elementsMap().clear();
     }
-    for (const Vector2d& v : o.vertices) {
-      const Vector3d p0 = uniqueMultiply(vert_mult_map, Vector3d(v[0], v[1], 0.0), m);
+    for (const Vector2d &v : o.vertices) {
+      const Vector3d p0 =
+          uniqueMultiply(vert_mult_map, Vector3d(v[0], v[1], 0.0), m);
       createVertex({p0}, {}, color, 0, 0, o.vertices.size(), true, false);
     }
 
     GLenum elements_type = 0;
-    if (useElements()) elements_type = elementsData()->glType();
-    std::shared_ptr<VertexState> line_loop = createVertexState(
-      GL_LINE_LOOP, o.vertices.size(), elements_type, writeIndex(), elements_offset);
+    if (useElements())
+      elements_type = elementsData()->glType();
+    std::shared_ptr<VertexState> line_loop =
+        createVertexState(GL_LINE_LOOP, o.vertices.size(), elements_type,
+                          writeIndex(), elements_offset);
     vertex_states.emplace_back(std::move(line_loop));
     addAttributePointers(last_size);
   }
 }
 
-void VBOBuilder::create_polygons(const PolySet& ps, const Transform3d& m, const Color4f& color)
-{
+void VBOBuilder::create_polygons(const PolySet &ps, const Transform3d &m,
+                                 const Color4f &color) {
   assert(ps.getDimension() == 2);
   const std::shared_ptr<VertexData> vertex_data = data();
 
-  if (!vertex_data) return;
+  if (!vertex_data)
+    return;
 
-  auto& vertex_states = states();
+  auto &vertex_states = states();
   std::unordered_map<Vector3d, Vector3d> vert_mult_map;
 
   PRINTD("create_polygons 2D");
@@ -538,26 +616,36 @@ void VBOBuilder::create_polygons(const PolySet& ps, const Transform3d& m, const
     elementsMap().clear();
   }
 
-  for (const auto& poly : ps.indices) {
+  for (const auto &poly : ps.indices) {
     if (poly.size() == 3) {
-      const Vector3d p0 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(0)], m);
-      const Vector3d p1 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(1)], m);
-      const Vector3d p2 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(2)], m);
-
-      create_triangle(color, p0, p1, p2, 0, poly.size(), false, false, mirrored);
+      const Vector3d p0 =
+          uniqueMultiply(vert_mult_map, ps.vertices[poly.at(0)], m);
+      const Vector3d p1 =
+          uniqueMultiply(vert_mult_map, ps.vertices[poly.at(1)], m);
+      const Vector3d p2 =
+          uniqueMultiply(vert_mult_map, ps.vertices[poly.at(2)], m);
+
+      create_triangle(color, p0, p1, p2, 0, poly.size(), false, false,
+                      mirrored);
       triangle_count++;
     } else if (poly.size() == 4) {
-      const Vector3d p0 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(0)], m);
-      const Vector3d p1 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(1)], m);
-      const Vector3d p2 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(2)], m);
-      const Vector3d p3 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(3)], m);
-
-      create_triangle(color, p0, p1, p3, 0, poly.size(), false, false, mirrored);
-      create_triangle(color, p2, p3, p1, 1, poly.size(), false, false, mirrored);
+      const Vector3d p0 =
+          uniqueMultiply(vert_mult_map, ps.vertices[poly.at(0)], m);
+      const Vector3d p1 =
+          uniqueMultiply(vert_mult_map, ps.vertices[poly.at(1)], m);
+      const Vector3d p2 =
+          uniqueMultiply(vert_mult_map, ps.vertices[poly.at(2)], m);
+      const Vector3d p3 =
+          uniqueMultiply(vert_mult_map, ps.vertices[poly.at(3)], m);
+
+      create_triangle(color, p0, p1, p3, 0, poly.size(), false, false,
+                      mirrored);
+      create_triangle(color, p2, p3, p1, 1, poly.size(), false, false,
+                      mirrored);
       triangle_count += 2;
     } else {
       Vector3d center = Vector3d::Zero();
-      for (const auto& point : poly) {
+      for (const auto &point : poly) {
         center[0] += ps.vertices[point][0];
         center[1] += ps.vertices[point][1];
       }
@@ -566,20 +654,24 @@ void VBOBuilder::create_polygons(const PolySet& ps, const Transform3d& m, const
 
       for (size_t i = 1; i <= poly.size(); i++) {
         const Vector3d p0 = uniqueMultiply(vert_mult_map, center, m);
-        const Vector3d p1 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(i % poly.size())], m);
-        const Vector3d p2 = uniqueMultiply(vert_mult_map, ps.vertices[poly.at(i - 1)], m);
+        const Vector3d p1 = uniqueMultiply(
+            vert_mult_map, ps.vertices[poly.at(i % poly.size())], m);
+        const Vector3d p2 =
+            uniqueMultiply(vert_mult_map, ps.vertices[poly.at(i - 1)], m);
 
-        create_triangle(color, p0, p2, p1, i - 1, poly.size(), false, false, mirrored);
+        create_triangle(color, p0, p2, p1, i - 1, poly.size(), false, false,
+                        mirrored);
         triangle_count++;
       }
     }
   }
 
   GLenum elements_type = 0;
-  if (useElements()) elements_type = elementsData()->glType();
-  std::shared_ptr<VertexState> vs = createVertexState(
-    GL_TRIANGLES, triangle_count * 3, elements_type, writeIndex(), elements_offset);
+  if (useElements())
+    elements_type = elementsData()->glType();
+  std::shared_ptr<VertexState> vs =
+      createVertexState(GL_TRIANGLES, triangle_count * 3, elements_type,
+                        writeIndex(), elements_offset);
   vertex_states.emplace_back(std::move(vs));
   addAttributePointers(last_size);
 }
-
diff --git a/src/glview/VBOBuilder.h b/src/glview/VBOBuilder.h
index 3a2f30c82..2020c3cd3 100644
--- a/src/glview/VBOBuilder.h
+++ b/src/glview/VBOBuilder.h
@@ -1,42 +1,40 @@
 #pragma once
 
 #include <array>
+#include <boost/functional/hash.hpp>
+#include <cstddef>
 #include <functional>
 #include <memory>
-#include <cstddef>
 #include <unordered_map>
-#include <boost/functional/hash.hpp>
 #include <utility>
 #include <vector>
 
+#include "Feature.h"
 #include "geometry/PolySet.h"
 #include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 #include "glview/Renderer.h"
+#include "glview/VertexState.h"
 #include "glview/system-gl.h"
 #include "utils/printutils.h"
-#include "geometry/linalg.h"
-#include "Feature.h"
-#include "glview/VertexState.h"
 
-enum ShaderAttribIndex {
-  BARYCENTRIC_ATTRIB
-};
+enum ShaderAttribIndex { BARYCENTRIC_ATTRIB };
 
 // Hash function for opengl vertex data.
-template <typename T>
-struct vertex_hash {
-  std::size_t operator()(T const& vertex) const {
+template <typename T> struct vertex_hash {
+  std::size_t operator()(T const &vertex) const {
     size_t seed = 0;
-    for (size_t i = 0; i < vertex.size(); ++i) boost::hash_combine(seed, vertex.data()[i]);
+    for (size_t i = 0; i < vertex.size(); ++i)
+      boost::hash_combine(seed, vertex.data()[i]);
     return seed;
   }
 };
 
-using ElementsMap = std::unordered_map<std::vector<GLbyte>, GLuint, vertex_hash<std::vector<GLbyte>>>;
+using ElementsMap = std::unordered_map<std::vector<GLbyte>, GLuint,
+                                       vertex_hash<std::vector<GLbyte>>>;
 
 // Interface class for basic attribute data that will be loaded into VBO
-class IAttributeData
-{
+class IAttributeData {
 public:
   IAttributeData() = default;
   virtual ~IAttributeData() = default;
@@ -71,40 +69,49 @@ public:
 };
 
 // Helper function to finish recursion in addAttributeValues call
-void addAttributeValues(IAttributeData&);
+void addAttributeValues(IAttributeData &);
 // Template helper function to load multiple attribute values in one call
-template <typename T, typename ... Args>
-void addAttributeValues(IAttributeData& attrib, T value, Args... values) {
+template <typename T, typename... Args>
+void addAttributeValues(IAttributeData &attrib, T value, Args... values) {
   attrib.addData(value);
-  addAttributeValues(attrib, values ...);
+  addAttributeValues(attrib, values...);
 }
 
-// Template helper function to load multiple copies of the same multiple attribute values in one call.
-// Used to add the same normal and colors to multiple triangle points.
-template <typename T, typename ... Args>
-void addAttributeValues(size_t copies, IAttributeData& attrib, T value, Args... values) {
+// Template helper function to load multiple copies of the same multiple
+// attribute values in one call. Used to add the same normal and colors to
+// multiple triangle points.
+template <typename T, typename... Args>
+void addAttributeValues(size_t copies, IAttributeData &attrib, T value,
+                        Args... values) {
   if (copies > 0) {
-    addAttributeValues(attrib, value, values ...);
-    addAttributeValues(copies - 1, attrib, value, values ...);
+    addAttributeValues(attrib, value, values...);
+    addAttributeValues(copies - 1, attrib, value, values...);
   }
 }
 
 // Template class for implementing IAttributeData interface abstract class
 template <typename T, size_t C, GLenum E>
-class AttributeData : public IAttributeData
-{
+class AttributeData : public IAttributeData {
 public:
   AttributeData() : data_() {}
 
   [[nodiscard]] inline size_t count() const override { return C; }
   [[nodiscard]] inline size_t size() const override { return data_.size(); }
   [[nodiscard]] inline size_t sizeofType() const override { return sizeof(T); }
-  [[nodiscard]] inline size_t sizeofAttribute() const override { return sizeof(T) * C; }
-  [[nodiscard]] inline size_t sizeInBytes() const override { return data_.size() * sizeof(T); }
+  [[nodiscard]] inline size_t sizeofAttribute() const override {
+    return sizeof(T) * C;
+  }
+  [[nodiscard]] inline size_t sizeInBytes() const override {
+    return data_.size() * sizeof(T);
+  }
   [[nodiscard]] inline GLenum glType() const override { return E; }
   void clear() override { data_.clear(); }
-  void remove(size_t count) override { data_.erase(data_.end() - (count * C), data_.end()); }
-  [[nodiscard]] inline const GLbyte *toBytes() const override { return (GLbyte *)(data_.data()); }
+  void remove(size_t count) override {
+    data_.erase(data_.end() - (count * C), data_.end());
+  }
+  [[nodiscard]] inline const GLbyte *toBytes() const override {
+    return (GLbyte *)(data_.data());
+  }
 
   inline void addData(GLbyte value) override { add_data((T)value); }
   inline void addData(GLshort value) override { add_data((T)value); }
@@ -115,7 +122,9 @@ public:
   inline void addData(GLdouble value) override { add_data((T)value); }
 
   // Return the template type element vector
-  [[nodiscard]] inline std::shared_ptr<std::vector<T>> getData() const { return std::shared_ptr<std::vector<T>>(data_); }
+  [[nodiscard]] inline std::shared_ptr<std::vector<T>> getData() const {
+    return std::shared_ptr<std::vector<T>>(data_);
+  }
 
 private:
   // Internal method to add data of template type to element vector
@@ -125,71 +134,96 @@ private:
 };
 
 // Storage and access class for multiple AttributeData that make up one vertex.
-class VertexData
-{
+class VertexData {
 public:
-  VertexData() : position_data_(nullptr), normal_data_(nullptr), color_data_(nullptr) {}
+  VertexData()
+      : position_data_(nullptr), normal_data_(nullptr), color_data_(nullptr) {}
   virtual ~VertexData() = default;
 
   // Add generic attribute data to vertex vector
-  void addAttributeData(std::shared_ptr<IAttributeData> data)
-  {
+  void addAttributeData(std::shared_ptr<IAttributeData> data) {
     stride_ += data->sizeofAttribute();
     attributes_.emplace_back(data);
   }
 
   // Add position attribute data to vertex vector
-  void addPositionData(std::shared_ptr<IAttributeData> data)
-  {
+  void addPositionData(std::shared_ptr<IAttributeData> data) {
     position_index_ = attributes_.size();
     stride_ += data->sizeofAttribute();
     position_data_ = attributes_.emplace_back(std::move(data));
   }
   // Add normal attribute data to vertex vector
-  void addNormalData(std::shared_ptr<IAttributeData> data)
-  {
+  void addNormalData(std::shared_ptr<IAttributeData> data) {
     normal_index_ = attributes_.size();
     stride_ += data->sizeofAttribute();
     normal_data_ = attributes_.emplace_back(std::move(data));
   }
   // Add color attribute data to vertex vector
-  void addColorData(std::shared_ptr<IAttributeData> data)
-  {
+  void addColorData(std::shared_ptr<IAttributeData> data) {
     color_index_ = attributes_.size();
     stride_ += data->sizeofAttribute();
     color_data_ = attributes_.emplace_back(std::move(data));
   }
 
-  void clear() { for (auto& a : attributes_) a->clear(); }
+  void clear() {
+    for (auto &a : attributes_)
+      a->clear();
+  }
   // Remove the last n interleaved vertices
   void remove(size_t count = 1);
 
   // Return reference to internal IAttributeData vector
-  [[nodiscard]] inline const std::vector<std::shared_ptr<IAttributeData>>& attributes() const { return attributes_; }
-  // Return reference to the last added IAttributeData. This is typically where elements data is stored.
-  [[nodiscard]] inline const std::shared_ptr<IAttributeData> attributeData() const { if (attributes_.size()) return attributes_.back(); else return nullptr; }
+  [[nodiscard]] inline const std::vector<std::shared_ptr<IAttributeData>> &
+  attributes() const {
+    return attributes_;
+  }
+  // Return reference to the last added IAttributeData. This is typically where
+  // elements data is stored.
+  [[nodiscard]] inline const std::shared_ptr<IAttributeData>
+  attributeData() const {
+    if (attributes_.size())
+      return attributes_.back();
+    else
+      return nullptr;
+  }
   // Return reference to position attribute data
-  [[nodiscard]] inline const std::shared_ptr<IAttributeData>& positionData() const { return position_data_; }
+  [[nodiscard]] inline const std::shared_ptr<IAttributeData> &
+  positionData() const {
+    return position_data_;
+  }
   // Return reference to normal attribute data
-  [[nodiscard]] inline const std::shared_ptr<IAttributeData>& normalData() const { return normal_data_; }
+  [[nodiscard]] inline const std::shared_ptr<IAttributeData> &
+  normalData() const {
+    return normal_data_;
+  }
   // Return reference to color data
-  [[nodiscard]] inline const std::shared_ptr<IAttributeData>& colorData() const { return color_data_; }
+  [[nodiscard]] inline const std::shared_ptr<IAttributeData> &
+  colorData() const {
+    return color_data_;
+  }
   // Check if VertexData has position data
-  [[nodiscard]] inline bool hasPositionData() const { return (position_data_ != nullptr); }
+  [[nodiscard]] inline bool hasPositionData() const {
+    return (position_data_ != nullptr);
+  }
   // Return position attribute data vector index
   [[nodiscard]] inline size_t positionIndex() const { return position_index_; }
   // Check if VertexData has normal data
-  [[nodiscard]] inline bool hasNormalData() const { return (normal_data_ != nullptr); }
+  [[nodiscard]] inline bool hasNormalData() const {
+    return (normal_data_ != nullptr);
+  }
   // Return normal attribute data vector index
   [[nodiscard]] inline size_t normalIndex() const { return normal_index_; }
   // Check if VertexData has color data
-  [[nodiscard]] inline bool hasColorData() const { return (color_data_ != nullptr); }
+  [[nodiscard]] inline bool hasColorData() const {
+    return (color_data_ != nullptr);
+  }
   // Return color attribute data vector index
   [[nodiscard]] inline size_t colorIndex() const { return color_index_; }
   // Return stride of VertexData
   [[nodiscard]] inline size_t stride() const { return stride_; }
 
-  // Calculate the offset of interleaved attribute data based on VertexData index
+  // Calculate the offset of interleaved attribute data based on VertexData
+  // index
   [[nodiscard]] size_t interleavedOffset(size_t index) const {
     if (index && attributes_.size()) {
       --index;
@@ -198,13 +232,21 @@ public:
     return 0;
   }
   // Calculate the total size of the buffer in bytes
-  [[nodiscard]] size_t sizeInBytes() const { size_t size = 0; for (const auto& data : attributes_) size += data->sizeInBytes(); return size; }
+  [[nodiscard]] size_t sizeInBytes() const {
+    size_t size = 0;
+    for (const auto &data : attributes_)
+      size += data->sizeInBytes();
+    return size;
+  }
   // Calculate the total number of items in buffer
   [[nodiscard]] inline size_t size() const {
     if (stride_) {
       return sizeInBytes() / stride();
     } else {
-      size_t size = 0; for (const auto& data : attributes_) size += data->size(); return size;
+      size_t size = 0;
+      for (const auto &data : attributes_)
+        size += data->size();
+      return size;
     }
   }
   [[nodiscard]] inline bool empty() const { return attributes_.empty(); }
@@ -212,7 +254,7 @@ public:
   void allocateBuffers(size_t num_vertices);
 
   // Get the last interleaved vertex
-  void getLastVertex(std::vector<GLbyte>& interleaved_buffer) const;
+  void getLastVertex(std::vector<GLbyte> &interleaved_buffer) const;
   // Create an interleaved buffer in the provided vbo.
   // If the vbo does not exist it will be created and returned.
   // void createInterleavedVBO(GLuint& vbo) const;
@@ -229,13 +271,12 @@ private:
 };
 
 // Combine vertex data with vertex states. Creates VBOs.
-class VBOBuilder
-{
+class VBOBuilder {
 public:
-  VBOBuilder(std::unique_ptr<VertexStateFactory> factory, VertexStateContainer& vertex_state_container)
-    : factory_(std::move(factory)), vertex_state_container_(vertex_state_container)
-  {
-  }
+  VBOBuilder(std::unique_ptr<VertexStateFactory> factory,
+             VertexStateContainer &vertex_state_container)
+      : factory_(std::move(factory)),
+        vertex_state_container_(vertex_state_container) {}
 
   virtual ~VBOBuilder() {
     if (Feature::ExperimentalVxORenderersIndexing.is_enabled()) {
@@ -256,30 +297,41 @@ public:
   }
 
   // Clear all data from the VertexArray
-  void clear() { for (auto& v : vertices_) v->clear(); }
+  void clear() {
+    for (auto &v : vertices_)
+      v->clear();
+  }
 
   // Create a single vertex in the VertexArray
   // The method parameters provide a common interface to pass all data
   // necessary to create a complete vertex
-  void createVertex(const std::array<Vector3d, 3>& points,
-                    const std::array<Vector3d, 3>& normals,
-                    const Color4f& color,
-                    size_t active_point_index = 0, size_t primitive_index = 0,
-                    size_t shape_size = 0,
+  void createVertex(const std::array<Vector3d, 3> &points,
+                    const std::array<Vector3d, 3> &normals,
+                    const Color4f &color, size_t active_point_index = 0,
+                    size_t primitive_index = 0, size_t shape_size = 0,
                     bool outlines = false, bool mirror = false);
 
   // Return reference to the VertexStates
-  inline std::vector<std::shared_ptr<VertexState>>& states() { return vertex_state_container_.states(); }
+  inline std::vector<std::shared_ptr<VertexState>> &states() {
+    return vertex_state_container_.states();
+  }
   // Return reference to VertexData at current internal write index
   inline std::shared_ptr<VertexData> data() { return vertices_[write_index_]; }
   // Return reference to elements
-  inline VertexData& elements() { return elements_; }
+  inline VertexData &elements() { return elements_; }
   // Return reference to elements data if it exists
-  inline std::shared_ptr<IAttributeData> elementsData() { return elements_.attributeData(); }
+  inline std::shared_ptr<IAttributeData> elementsData() {
+    return elements_.attributeData();
+  }
   // Return the number of VertexData in the array
   inline size_t size() const { return vertices_.size(); }
   // Calculate the total size of the buffer in bytes
-  inline size_t sizeInBytes() const { size_t size = 0; for (const auto& data : vertices_) size += data->sizeInBytes(); return size; }
+  inline size_t sizeInBytes() const {
+    size_t size = 0;
+    for (const auto &data : vertices_)
+      size += data->sizeInBytes();
+    return size;
+  }
   // Return the current internal write index
   inline size_t writeIndex() const { return write_index_; }
   // Set the internal write index to the surface index
@@ -288,7 +340,8 @@ public:
   inline void writeEdge() { write_index_ = edge_index_; }
   // Return the total stride for all buffers
   inline size_t stride() const {
-    size_t stride = 0; for (const auto& v : vertices_) {
+    size_t stride = 0;
+    for (const auto &v : vertices_) {
       stride += v->stride();
     }
     return stride;
@@ -304,9 +357,13 @@ public:
   }
 
   // Use VertexStateFactory to create a new VertexState object
-  std::shared_ptr<VertexState> createVertexState(GLenum draw_mode, size_t draw_size, GLenum draw_type, size_t draw_offset, size_t element_offset) const {
-    return factory_->createVertexState(draw_mode, draw_size, draw_type, draw_offset, element_offset,
-                                       vertex_state_container_.verticesVBO(), vertex_state_container_.elementsVBO());
+  std::shared_ptr<VertexState>
+  createVertexState(GLenum draw_mode, size_t draw_size, GLenum draw_type,
+                    size_t draw_offset, size_t element_offset) const {
+    return factory_->createVertexState(draw_mode, draw_size, draw_type,
+                                       draw_offset, element_offset,
+                                       vertex_state_container_.verticesVBO(),
+                                       vertex_state_container_.elementsVBO());
   }
 
   void allocateBuffers(size_t num_vertices);
@@ -314,39 +371,53 @@ public:
   // Create an interleaved VBO from the VertexData in the array.
   void createInterleavedVBOs();
 
-  // Method adds begin/end states that enable and point to the VertexData in the array
+  // Method adds begin/end states that enable and point to the VertexData in the
+  // array
   void addAttributePointers(size_t start_offset = 0);
 
-  inline GLuint verticesVBO() const { return vertex_state_container_.verticesVBO(); }
+  inline GLuint verticesVBO() const {
+    return vertex_state_container_.verticesVBO();
+  }
   inline size_t verticesOffset() const { return vertices_offset_; }
 
   // Return whether this Vertex Array uses elements (indexed rendering)
-  inline bool useElements() const { return vertex_state_container_.elementsVBO() != 0; }
-  inline GLuint elementsVBO() const { return vertex_state_container_.elementsVBO(); }
+  inline bool useElements() const {
+    return vertex_state_container_.elementsVBO() != 0;
+  }
+  inline GLuint elementsVBO() const {
+    return vertex_state_container_.elementsVBO();
+  }
   inline size_t elementsOffset() const { return elements_offset_; }
   inline void setElementsOffset(size_t offset) { elements_offset_ = offset; }
 
   // Return the internal unique vertex/element map
-  inline ElementsMap& elementsMap() { return elements_map_; }
+  inline ElementsMap &elementsMap() { return elements_map_; }
 
   size_t shader_attributes_index_{0};
   void addShaderData();
 
   void add_barycentric_attribute(size_t active_point_index,
-                                 size_t primitive_index, size_t shape_size, bool outlines);
-  void create_triangle(const Color4f& color, const Vector3d& p0,
-                       const Vector3d& p1, const Vector3d& p2, size_t primitive_index,
-                       size_t shape_size, bool outlines, bool enable_barycentric, bool mirror);
-  void create_surface(const PolySet& ps, const Transform3d& m,
-                      const Color4f& default_color, bool enable_barycentric, bool force_default_color = false);
-  void create_edges(const Polygon2d& polygon, const Transform3d& m, const Color4f& color);
-  void create_polygons(const PolySet& ps, const Transform3d& m, const Color4f& color);
+                                 size_t primitive_index, size_t shape_size,
+                                 bool outlines);
+  void create_triangle(const Color4f &color, const Vector3d &p0,
+                       const Vector3d &p1, const Vector3d &p2,
+                       size_t primitive_index, size_t shape_size, bool outlines,
+                       bool enable_barycentric, bool mirror);
+  void create_surface(const PolySet &ps, const Transform3d &m,
+                      const Color4f &default_color, bool enable_barycentric,
+                      bool force_default_color = false);
+  void create_edges(const Polygon2d &polygon, const Transform3d &m,
+                    const Color4f &color);
+  void create_polygons(const PolySet &ps, const Transform3d &m,
+                       const Color4f &color);
 
 private:
-  inline void setElementsSize(size_t elements_size) { elements_size_ = elements_size; }
+  inline void setElementsSize(size_t elements_size) {
+    elements_size_ = elements_size;
+  }
 
   std::unique_ptr<VertexStateFactory> factory_;
-  VertexStateContainer& vertex_state_container_;
+  VertexStateContainer &vertex_state_container_;
   size_t write_index_{0};
   size_t surface_index_{0};
   size_t edge_index_{0};
diff --git a/src/glview/VBORenderer.cc b/src/glview/VBORenderer.cc
index 36c8d8089..b82196a87 100644
--- a/src/glview/VBORenderer.cc
+++ b/src/glview/VBORenderer.cc
@@ -25,64 +25,65 @@
  */
 
 #include "glview/VBORenderer.h"
-#include "geometry/linalg.h"
-#include "geometry/Polygon2d.h"
-#include "geometry/PolySet.h"
 #include "core/CSGNode.h"
+#include "geometry/PolySet.h"
+#include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
+#include "utils/hash.h" // IWYU pragma: keep
 #include "utils/printutils.h"
-#include "utils/hash.h"  // IWYU pragma: keep
 
-#include <cassert>
 #include <array>
+#include <cassert>
+#include <cstddef>
+#include <memory>
 #include <unordered_map>
 #include <utility>
-#include <memory>
-#include <cstddef>
 
 namespace VBOUtils {
 
-void shader_attribs_enable(const ShaderUtils::ShaderInfo& shaderinfo)
-{
-  for (const auto& [name, location] : shaderinfo.attributes) {
+void shader_attribs_enable(const ShaderUtils::ShaderInfo &shaderinfo) {
+  for (const auto &[name, location] : shaderinfo.attributes) {
     GL_TRACE("glEnableVertexAttribArray(%d)", location);
     GL_CHECKD(glEnableVertexAttribArray(location));
   }
 }
 
-void shader_attribs_disable(const ShaderUtils::ShaderInfo& shaderinfo)
-{
-  for (const auto& [name, location] : shaderinfo.attributes) {
+void shader_attribs_disable(const ShaderUtils::ShaderInfo &shaderinfo) {
+  for (const auto &[name, location] : shaderinfo.attributes) {
     GL_TRACE("glEnableVertexAttribArray(%d)", location);
     GL_CHECKD(glDisableVertexAttribArray(location));
   }
 }
 
-}  // namespace VBOUtils
+} // namespace VBOUtils
 
 VBORenderer::VBORenderer() : Renderer() {}
 
-size_t VBORenderer::calcNumVertices(const std::shared_ptr<CSGProducts>& products,
-                                    bool unique_geometry) const
-{
+size_t
+VBORenderer::calcNumVertices(const std::shared_ptr<CSGProducts> &products,
+                             bool unique_geometry) const {
   size_t buffer_size = 0;
-  if (unique_geometry) this->geom_visit_mark_.clear();
+  if (unique_geometry)
+    this->geom_visit_mark_.clear();
 
-  for (const auto& product : products->products) {
-    for (const auto& csgobj : product.intersections) {
+  for (const auto &product : products->products) {
+    for (const auto &csgobj : product.intersections) {
       buffer_size += calcNumVertices(csgobj);
     }
-    for (const auto& csgobj : product.subtractions) {
+    for (const auto &csgobj : product.subtractions) {
       buffer_size += calcNumVertices(csgobj);
     }
   }
   return buffer_size;
 }
 
-size_t VBORenderer::calcNumVertices(const CSGChainObject& csgobj, bool unique_geometry) const
-{
+size_t VBORenderer::calcNumVertices(const CSGChainObject &csgobj,
+                                    bool unique_geometry) const {
   size_t buffer_size = 0;
   if (unique_geometry &&
-      this->geom_visit_mark_[std::make_pair(csgobj.leaf->polyset.get(), &csgobj.leaf->matrix)]++ > 0)return 0;
+      this->geom_visit_mark_[std::make_pair(csgobj.leaf->polyset.get(),
+                                            &csgobj.leaf->matrix)]++ > 0)
+    return 0;
 
   if (csgobj.leaf->polyset) {
     buffer_size += calcNumVertices(*csgobj.leaf->polyset);
@@ -90,10 +91,9 @@ size_t VBORenderer::calcNumVertices(const CSGChainObject& csgobj, bool unique_ge
   return buffer_size;
 }
 
-size_t VBORenderer::calcNumVertices(const PolySet& polyset) const
-{
+size_t VBORenderer::calcNumVertices(const PolySet &polyset) const {
   size_t buffer_size = 0;
-  for (const auto& poly : polyset.indices) {
+  for (const auto &poly : polyset.indices) {
     if (poly.size() == 3) {
       buffer_size++;
     } else if (poly.size() == 4) {
@@ -107,56 +107,63 @@ size_t VBORenderer::calcNumVertices(const PolySet& polyset) const
   return buffer_size * 3;
 }
 
-size_t VBORenderer::calcNumEdgeVertices(const PolySet& polyset) const
-{
+size_t VBORenderer::calcNumEdgeVertices(const PolySet &polyset) const {
   size_t buffer_size = 0;
-  for (const auto& polygon : polyset.indices) {
+  for (const auto &polygon : polyset.indices) {
     buffer_size += polygon.size();
   }
   return buffer_size;
 }
 
-size_t VBORenderer::calcNumEdgeVertices(const Polygon2d& polygon) const
-{
+size_t VBORenderer::calcNumEdgeVertices(const Polygon2d &polygon) const {
   size_t buffer_size = 0;
   // Render only outlines
-  for (const Outline2d& o : polygon.outlines()) {
+  for (const Outline2d &o : polygon.outlines()) {
     buffer_size += o.vertices.size();
   }
   return buffer_size;
 }
 
-void VBORenderer::add_shader_pointers(VBOBuilder& vbo_builder, const ShaderUtils::ShaderInfo *shaderinfo)
-{
+void VBORenderer::add_shader_pointers(
+    VBOBuilder &vbo_builder, const ShaderUtils::ShaderInfo *shaderinfo) {
   const std::shared_ptr<VertexData> vertex_data = vbo_builder.data();
 
-  if (!vertex_data) return;
+  if (!vertex_data)
+    return;
 
   const auto start_offset = vbo_builder.verticesOffset();
 
   std::shared_ptr<VertexState> ss = std::make_shared<VBOShaderVertexState>(
-    vbo_builder.writeIndex(), 0, vbo_builder.verticesVBO(), vbo_builder.elementsVBO());
+      vbo_builder.writeIndex(), 0, vbo_builder.verticesVBO(),
+      vbo_builder.elementsVBO());
   GLsizei count = 0, stride = 0;
   GLenum type = 0;
   size_t offset = 0;
 
   GLuint attribute_index = shaderinfo->attributes.at("barycentric");
   if (attribute_index > 0) {
-    count =
-      vertex_data->attributes()[vbo_builder.shader_attributes_index_ + BARYCENTRIC_ATTRIB]->count();
-    type =
-      vertex_data->attributes()[vbo_builder.shader_attributes_index_ + BARYCENTRIC_ATTRIB]->glType();
+    count = vertex_data
+                ->attributes()[vbo_builder.shader_attributes_index_ +
+                               BARYCENTRIC_ATTRIB]
+                ->count();
+    type = vertex_data
+               ->attributes()[vbo_builder.shader_attributes_index_ +
+                              BARYCENTRIC_ATTRIB]
+               ->glType();
     stride = vertex_data->stride();
     offset = start_offset +
-      vertex_data->interleavedOffset(vbo_builder.shader_attributes_index_ + BARYCENTRIC_ATTRIB);
-    ss->glBegin().emplace_back(
-      [attribute_index, count, type, stride, offset, ss_ptr = std::weak_ptr<VertexState>(ss)]() {
+             vertex_data->interleavedOffset(
+                 vbo_builder.shader_attributes_index_ + BARYCENTRIC_ATTRIB);
+    ss->glBegin().emplace_back([attribute_index, count, type, stride, offset,
+                                ss_ptr = std::weak_ptr<VertexState>(ss)]() {
       auto ss = ss_ptr.lock();
       if (ss) {
         // NOLINTBEGIN(performance-no-int-to-ptr)
         GL_TRACE("glVertexAttribPointer(%d, %d, %d, GL_FALSE, %d, %p)",
-                 attribute_index % count % type % stride % (GLvoid *)(ss->drawOffset() + offset));
-        GL_CHECKD(glVertexAttribPointer(attribute_index, count, type, GL_FALSE, stride,
+                 attribute_index % count % type % stride %
+                     (GLvoid *)(ss->drawOffset() + offset));
+        GL_CHECKD(glVertexAttribPointer(attribute_index, count, type, GL_FALSE,
+                                        stride,
                                         (GLvoid *)(ss->drawOffset() + offset)));
         // NOLINTEND(performance-no-int-to-ptr)
       }
diff --git a/src/glview/VBORenderer.h b/src/glview/VBORenderer.h
index 4270383ca..41353d94e 100644
--- a/src/glview/VBORenderer.h
+++ b/src/glview/VBORenderer.h
@@ -1,54 +1,61 @@
 #pragma once
 
-#include <array>
-#include <utility>
-#include <memory>
-#include <cstddef>
-#include "glview/Renderer.h"
-#include "geometry/linalg.h"
 #include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
+#include "glview/Renderer.h"
 #include "glview/system-gl.h"
+#include <array>
+#include <cstddef>
+#include <memory>
+#include <utility>
 #ifdef ENABLE_OPENCSG
 #include <opencsg.h>
 #endif
 #include "core/CSGNode.h"
 #include "glview/VBOBuilder.h"
-#include <unordered_map>
 #include <boost/functional/hash.hpp>
+#include <unordered_map>
 
 namespace VBOUtils {
 
-void shader_attribs_enable(const ShaderUtils::ShaderInfo& shaderinfo);
-void shader_attribs_disable(const ShaderUtils::ShaderInfo& shaderinfo);
+void shader_attribs_enable(const ShaderUtils::ShaderInfo &shaderinfo);
+void shader_attribs_disable(const ShaderUtils::ShaderInfo &shaderinfo);
 
-}  // namespace VBOUtils
+} // namespace VBOUtils
 
-class VBOShaderVertexState : public VertexState
-{
+class VBOShaderVertexState : public VertexState {
 public:
-  VBOShaderVertexState(size_t draw_offset, size_t element_offset, GLuint vertices_vbo, GLuint elements_vbo)
-    : VertexState(0, 0, 0, draw_offset, element_offset, vertices_vbo, elements_vbo) {}
+  VBOShaderVertexState(size_t draw_offset, size_t element_offset,
+                       GLuint vertices_vbo, GLuint elements_vbo)
+      : VertexState(0, 0, 0, draw_offset, element_offset, vertices_vbo,
+                    elements_vbo) {}
 };
 
-class VBORenderer : public Renderer
-{
+class VBORenderer : public Renderer {
 public:
   VBORenderer();
-  virtual size_t calcNumVertices(const std::shared_ptr<CSGProducts>& products, bool unique_geometry = false) const;
-  virtual size_t calcNumVertices(const CSGChainObject& csgobj, bool unique_geometry = false) const;
-  virtual size_t calcNumVertices(const PolySet& polyset) const;
-  virtual size_t calcNumEdgeVertices(const PolySet& polyset) const;
-  virtual size_t calcNumEdgeVertices(const Polygon2d& polygon) const;
-
-  void add_shader_pointers(VBOBuilder& vbo_builder, const ShaderUtils::ShaderInfo *shaderinfo); // This could stay protected, were it not for VertexStateManager
+  virtual size_t calcNumVertices(const std::shared_ptr<CSGProducts> &products,
+                                 bool unique_geometry = false) const;
+  virtual size_t calcNumVertices(const CSGChainObject &csgobj,
+                                 bool unique_geometry = false) const;
+  virtual size_t calcNumVertices(const PolySet &polyset) const;
+  virtual size_t calcNumEdgeVertices(const PolySet &polyset) const;
+  virtual size_t calcNumEdgeVertices(const Polygon2d &polygon) const;
+
+  void add_shader_pointers(VBOBuilder &vbo_builder,
+                           const ShaderUtils::ShaderInfo
+                               *shaderinfo); // This could stay protected, were
+                                             // it not for VertexStateManager
 
 protected:
-  void add_shader_data(VBOBuilder& vbo_builder);
-  void shader_attribs_enable(const ShaderUtils::ShaderInfo&) const;
-  void shader_attribs_disable(const ShaderUtils::ShaderInfo&) const;
-
-  mutable std::unordered_map<std::pair<const PolySet *, const Transform3d *>, int,
-                             boost::hash<std::pair<const PolySet *, const Transform3d *>>> geom_visit_mark_;
+  void add_shader_data(VBOBuilder &vbo_builder);
+  void shader_attribs_enable(const ShaderUtils::ShaderInfo &) const;
+  void shader_attribs_disable(const ShaderUtils::ShaderInfo &) const;
+
+  mutable std::unordered_map<
+      std::pair<const PolySet *, const Transform3d *>, int,
+      boost::hash<std::pair<const PolySet *, const Transform3d *>>>
+      geom_visit_mark_;
 
 private:
 };
diff --git a/src/glview/VertexState.cc b/src/glview/VertexState.cc
index 858ca9f92..ac7b50d22 100644
--- a/src/glview/VertexState.cc
+++ b/src/glview/VertexState.cc
@@ -1,7 +1,6 @@
 #include "glview/VertexState.h"
 
-void VertexState::draw() const
-{
+void VertexState::draw() const {
   if (vertices_vbo_) {
     GL_TRACE("glBindBuffer(GL_ARRAY_BUFFER, %d)", vertices_vbo_);
     GL_CHECKD(glBindBuffer(GL_ARRAY_BUFFER, vertices_vbo_));
@@ -10,46 +9,50 @@ void VertexState::draw() const
     GL_TRACE("glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, %d)", elements_vbo_);
     GL_CHECKD(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, elements_vbo_));
   }
-  for (const auto& gl_func : gl_begin_) {
+  for (const auto &gl_func : gl_begin_) {
     gl_func();
   }
   if (draw_size_ > 0) {
     if (elements_vbo_) {
       GL_TRACE("glDrawElements(%s, %d, %s, %d)",
-               (draw_mode_ == GL_POINTS ? "GL_POINTS" :
-                draw_mode_ == GL_LINES ? "GL_LINES" :
-                draw_mode_ == GL_LINE_LOOP ? "GL_LINE_LOOP" :
-                draw_mode_ == GL_LINE_STRIP ? "GL_LINE_STRIP" :
-                draw_mode_ == GL_TRIANGLES ? "GL_TRIANGLES" :
-                draw_mode_ == GL_TRIANGLE_STRIP ? "GL_TRIANGLE_STRIP" :
-                draw_mode_ == GL_TRIANGLE_FAN ? "GL_TRIANGLE_FAN" :
-                draw_mode_ == GL_QUADS ? "GL_QUADS" :
-                draw_mode_ == GL_QUAD_STRIP ? "GL_QUAD_STRIP" :
-                draw_mode_ == GL_POLYGON ? "GL_POLYGON" :
-                "UNKNOWN") % draw_size_ %
-               (draw_type_ == GL_UNSIGNED_BYTE ? "GL_UNSIGNED_BYTE" :
-                draw_type_ == GL_UNSIGNED_SHORT ? "GL_UNSIGNED_SHORT" :
-                draw_type_ == GL_UNSIGNED_INT ? "GL_UNSIGNED_INT" :
-                "UNKNOWN") % element_offset_);
+               (draw_mode_ == GL_POINTS           ? "GL_POINTS"
+                : draw_mode_ == GL_LINES          ? "GL_LINES"
+                : draw_mode_ == GL_LINE_LOOP      ? "GL_LINE_LOOP"
+                : draw_mode_ == GL_LINE_STRIP     ? "GL_LINE_STRIP"
+                : draw_mode_ == GL_TRIANGLES      ? "GL_TRIANGLES"
+                : draw_mode_ == GL_TRIANGLE_STRIP ? "GL_TRIANGLE_STRIP"
+                : draw_mode_ == GL_TRIANGLE_FAN   ? "GL_TRIANGLE_FAN"
+                : draw_mode_ == GL_QUADS          ? "GL_QUADS"
+                : draw_mode_ == GL_QUAD_STRIP     ? "GL_QUAD_STRIP"
+                : draw_mode_ == GL_POLYGON        ? "GL_POLYGON"
+                                                  : "UNKNOWN") %
+                   draw_size_ %
+                   (draw_type_ == GL_UNSIGNED_BYTE    ? "GL_UNSIGNED_BYTE"
+                    : draw_type_ == GL_UNSIGNED_SHORT ? "GL_UNSIGNED_SHORT"
+                    : draw_type_ == GL_UNSIGNED_INT   ? "GL_UNSIGNED_INT"
+                                                      : "UNKNOWN") %
+                   element_offset_);
       // NOLINTNEXTLINE(performance-no-int-to-ptr)
-      glDrawElements(draw_mode_, draw_size_, draw_type_, (GLvoid *)element_offset_);
+      glDrawElements(draw_mode_, draw_size_, draw_type_,
+                     (GLvoid *)element_offset_);
     } else {
       GL_TRACE("glDrawArrays(%s, 0, %d)",
-               (draw_mode_ == GL_POINTS ? "GL_POINTS" :
-                draw_mode_ == GL_LINES ? "GL_LINES" :
-                draw_mode_ == GL_LINE_LOOP ? "GL_LINE_LOOP" :
-                draw_mode_ == GL_LINE_STRIP ? "GL_LINE_STRIP" :
-                draw_mode_ == GL_TRIANGLES ? "GL_TRIANGLES" :
-                draw_mode_ == GL_TRIANGLE_STRIP ? "GL_TRIANGLE_STRIP" :
-                draw_mode_ == GL_TRIANGLE_FAN ? "GL_TRIANGLE_FAN" :
-                draw_mode_ == GL_QUADS ? "GL_QUADS" :
-                draw_mode_ == GL_QUAD_STRIP ? "GL_QUAD_STRIP" :
-                draw_mode_ == GL_POLYGON ? "GL_POLYGON" :
-                "UNKNOWN") % draw_size_);
+               (draw_mode_ == GL_POINTS           ? "GL_POINTS"
+                : draw_mode_ == GL_LINES          ? "GL_LINES"
+                : draw_mode_ == GL_LINE_LOOP      ? "GL_LINE_LOOP"
+                : draw_mode_ == GL_LINE_STRIP     ? "GL_LINE_STRIP"
+                : draw_mode_ == GL_TRIANGLES      ? "GL_TRIANGLES"
+                : draw_mode_ == GL_TRIANGLE_STRIP ? "GL_TRIANGLE_STRIP"
+                : draw_mode_ == GL_TRIANGLE_FAN   ? "GL_TRIANGLE_FAN"
+                : draw_mode_ == GL_QUADS          ? "GL_QUADS"
+                : draw_mode_ == GL_QUAD_STRIP     ? "GL_QUAD_STRIP"
+                : draw_mode_ == GL_POLYGON        ? "GL_POLYGON"
+                                                  : "UNKNOWN") %
+                   draw_size_);
       glDrawArrays(draw_mode_, 0, draw_size_);
     }
   }
-  for (const auto& gl_func : gl_end_) {
+  for (const auto &gl_func : gl_end_) {
     gl_func();
   }
   if (elements_vbo_) {
diff --git a/src/glview/VertexState.h b/src/glview/VertexState.h
index 04549a5da..f41f5800d 100644
--- a/src/glview/VertexState.h
+++ b/src/glview/VertexState.h
@@ -1,43 +1,52 @@
 #pragma once
 
-#include <utility>
-#include <memory>
 #include <cstddef>
 #include <functional>
+#include <memory>
+#include <utility>
 #include <vector>
 
-#include "glview/system-gl.h"
 #include "Feature.h"
+#include "glview/system-gl.h"
 
 #define GL_TRACE_ENABLE
 #ifdef GL_TRACE_ENABLE
 // NOLINTBEGIN(bugprone-macro-parentheses)
-#define GL_TRACE(fmt_, args) do { \
-          if (OpenSCAD::debug != "") PRINTDB("%d : " fmt_, __LINE__ % args); \
-} while (0)
+#define GL_TRACE(fmt_, args)                                                   \
+  do {                                                                         \
+    if (OpenSCAD::debug != "")                                                 \
+      PRINTDB("%d : " fmt_, __LINE__ % args);                                  \
+  } while (0)
 // NOLINTEND(bugprone-macro-parentheses)
-#define GL_TRACE0(fmt_) do { \
-          if (OpenSCAD::debug != "") PRINTDB("%d : " fmt_, __LINE__); \
-} while (0)
+#define GL_TRACE0(fmt_)                                                        \
+  do {                                                                         \
+    if (OpenSCAD::debug != "")                                                 \
+      PRINTDB("%d : " fmt_, __LINE__);                                         \
+  } while (0)
 #else // GL_TRACE_ENABLE
-#define GL_TRACE(fmt_, args) do {} while (0)
-#define GL_TRACE0(fmt_) do {} while (0)
+#define GL_TRACE(fmt_, args)                                                   \
+  do {                                                                         \
+  } while (0)
+#define GL_TRACE0(fmt_)                                                        \
+  do {                                                                         \
+  } while (0)
 #endif // GL_TRACE_ENABLE
 
 // Storage for minimum state information necessary to draw VBO.
 // This class is also used to encapsulate other state;
-// Example: VBOShaderVertexState will not render anything, but will use glBegin() to e.g. manage shader uniforms.
-class VertexState
-{
+// Example: VBOShaderVertexState will not render anything, but will use
+// glBegin() to e.g. manage shader uniforms.
+class VertexState {
 public:
   VertexState()
-    : draw_mode_(GL_TRIANGLES), draw_size_(0), draw_type_(0), draw_offset_(0),
-    element_offset_(0), vertices_vbo_(0), elements_vbo_(0)
-  {}
-  VertexState(GLenum draw_mode, GLsizei draw_size, GLenum draw_type, size_t draw_offset, size_t element_offset, GLuint vertices_vbo, GLuint elements_vbo)
-    : draw_mode_(draw_mode), draw_size_(draw_size), draw_type_(draw_type), draw_offset_(draw_offset),
-    element_offset_(element_offset), vertices_vbo_(vertices_vbo), elements_vbo_(elements_vbo)
-  {}
+      : draw_mode_(GL_TRIANGLES), draw_size_(0), draw_type_(0), draw_offset_(0),
+        element_offset_(0), vertices_vbo_(0), elements_vbo_(0) {}
+  VertexState(GLenum draw_mode, GLsizei draw_size, GLenum draw_type,
+              size_t draw_offset, size_t element_offset, GLuint vertices_vbo,
+              GLuint elements_vbo)
+      : draw_mode_(draw_mode), draw_size_(draw_size), draw_type_(draw_type),
+        draw_offset_(draw_offset), element_offset_(element_offset),
+        vertices_vbo_(vertices_vbo), elements_vbo_(elements_vbo) {}
   virtual ~VertexState() = default;
 
   // Return the OpenGL mode for glDrawArrays/glDrawElements call
@@ -59,14 +68,18 @@ public:
   // Return the Element VBO offset for glDrawElements call
   [[nodiscard]] inline size_t elementOffset() const { return element_offset_; }
   // Set the Element VBO offset for glDrawElements call
-  inline void setElementOffset(size_t element_offset) { element_offset_ = element_offset; }
+  inline void setElementOffset(size_t element_offset) {
+    element_offset_ = element_offset;
+  }
 
-  // Wrap glDrawArrays/glDrawElements call and use gl_begin/gl_end state information
+  // Wrap glDrawArrays/glDrawElements call and use gl_begin/gl_end state
+  // information
   virtual void draw() const;
 
-  // Mimic VAO state functionality. Lambda functions used to hold OpenGL state calls.
-  inline std::vector<std::function<void()>>& glBegin() { return gl_begin_; }
-  inline std::vector<std::function<void()>>& glEnd() { return gl_end_; }
+  // Mimic VAO state functionality. Lambda functions used to hold OpenGL state
+  // calls.
+  inline std::vector<std::function<void()>> &glBegin() { return gl_begin_; }
+  inline std::vector<std::function<void()>> &glEnd() { return gl_end_; }
 
   [[nodiscard]] inline GLuint verticesVBO() const { return vertices_vbo_; }
   inline void setVerticesVBO(GLuint vbo) { vertices_vbo_ = vbo; }
@@ -88,20 +101,23 @@ private:
 // Allows Renderers to override VertexState objects with their own derived
 // type. VertexArray will create the appropriate type for creating
 // a VertexState object.
-class VertexStateFactory
-{
+class VertexStateFactory {
 public:
   VertexStateFactory() = default;
   virtual ~VertexStateFactory() = default;
 
   // Create and return a VertexState object
-  [[nodiscard]] virtual std::shared_ptr<VertexState> createVertexState(GLenum draw_mode, size_t draw_size, GLenum draw_type, size_t draw_offset, size_t element_offset, GLuint vertices_vbo, GLuint elements_vbo) const {
-    return std::make_shared<VertexState>(draw_mode, draw_size, draw_type, draw_offset, element_offset, vertices_vbo, elements_vbo);
+  [[nodiscard]] virtual std::shared_ptr<VertexState>
+  createVertexState(GLenum draw_mode, size_t draw_size, GLenum draw_type,
+                    size_t draw_offset, size_t element_offset,
+                    GLuint vertices_vbo, GLuint elements_vbo) const {
+    return std::make_shared<VertexState>(draw_mode, draw_size, draw_type,
+                                         draw_offset, element_offset,
+                                         vertices_vbo, elements_vbo);
   }
 };
 
-class VertexStateContainer
-{
+class VertexStateContainer {
 public:
   VertexStateContainer() {
     GL_TRACE("glGenBuffers(1, %p)", &vertices_vbo_);
@@ -111,8 +127,8 @@ public:
       GL_CHECKD(glGenBuffers(1, &elements_vbo_));
     }
   }
-  VertexStateContainer(const VertexStateContainer& o) = delete;
-  VertexStateContainer(VertexStateContainer&& o) noexcept {
+  VertexStateContainer(const VertexStateContainer &o) = delete;
+  VertexStateContainer(VertexStateContainer &&o) noexcept {
     vertices_vbo_ = o.vertices_vbo_;
     elements_vbo_ = o.elements_vbo_;
     vertex_states_ = std::move(o.vertex_states_);
@@ -134,8 +150,10 @@ public:
   GLuint verticesVBO() const { return vertices_vbo_; }
   GLuint elementsVBO() const { return elements_vbo_; }
 
-  std::vector<std::shared_ptr<VertexState>>& states() { return vertex_states_; }
-  const std::vector<std::shared_ptr<VertexState>>& states() const { return vertex_states_; }
+  std::vector<std::shared_ptr<VertexState>> &states() { return vertex_states_; }
+  const std::vector<std::shared_ptr<VertexState>> &states() const {
+    return vertex_states_;
+  }
 
 private:
   GLuint vertices_vbo_;
diff --git a/src/glview/cgal/CGALRenderUtils.cc b/src/glview/cgal/CGALRenderUtils.cc
index 57e9917e4..b22a3f30a 100644
--- a/src/glview/cgal/CGALRenderUtils.cc
+++ b/src/glview/cgal/CGALRenderUtils.cc
@@ -1,19 +1,21 @@
-#include "geometry/linalg.h"
 #include "glview/cgal/CGALRenderUtils.h"
+#include "geometry/linalg.h"
 
 #include <algorithm>
 
-
 // this function resolves a 3x3 linear eqauation system
 /*
  * res[0] * v1 + res[1] *v2 + res[2] * vf3 = pt
  */
 
-bool linsystem(Vector3d v1, Vector3d v2, Vector3d v3, Vector3d pt, Vector3d& res, double *detptr)
-{
+bool linsystem(Vector3d v1, Vector3d v2, Vector3d v3, Vector3d pt,
+               Vector3d &res, double *detptr) {
   double det, ad11, ad12, ad13, ad21, ad22, ad23, ad31, ad32, ad33;
-  det = v1[0] * (v2[1] * v3[2] - v3[1] * v2[2]) - v1[1] * (v2[0] * v3[2] - v3[0] * v2[2]) + v1[2] * (v2[0] * v3[1] - v3[0] * v2[1]);
-  if (detptr != nullptr) *detptr = det;
+  det = v1[0] * (v2[1] * v3[2] - v3[1] * v2[2]) -
+        v1[1] * (v2[0] * v3[2] - v3[0] * v2[2]) +
+        v1[2] * (v2[0] * v3[1] - v3[0] * v2[1]);
+  if (detptr != nullptr)
+    *detptr = det;
   ad11 = v2[1] * v3[2] - v3[1] * v2[2];
   ad12 = v3[0] * v2[2] - v2[0] * v3[2];
   ad13 = v2[0] * v3[1] - v3[0] * v2[1];
@@ -24,7 +26,8 @@ bool linsystem(Vector3d v1, Vector3d v2, Vector3d v3, Vector3d pt, Vector3d& res
   ad32 = v2[0] * v1[2] - v1[0] * v2[2];
   ad33 = v1[0] * v2[1] - v2[0] * v1[1];
 
-  if (fabs(det) < 0.00001)return true;
+  if (fabs(det) < 0.00001)
+    return true;
 
   res[0] = (ad11 * pt[0] + ad12 * pt[1] + ad13 * pt[2]) / det;
   res[1] = (ad21 * pt[0] + ad22 * pt[1] + ad23 * pt[2]) / det;
@@ -32,7 +35,8 @@ bool linsystem(Vector3d v1, Vector3d v2, Vector3d v3, Vector3d pt, Vector3d& res
   return false;
 }
 
-double calculateLinePointDistance(const Vector3d& l1, const Vector3d& l2, const Vector3d& pt, double& dist_lat) {
+double calculateLinePointDistance(const Vector3d &l1, const Vector3d &l2,
+                                  const Vector3d &pt, double &dist_lat) {
   Vector3d d = (l2 - l1);
   double l = d.norm();
   d.normalize();
@@ -40,8 +44,9 @@ double calculateLinePointDistance(const Vector3d& l1, const Vector3d& l2, const
   return (l1 + d * dist_lat - pt).norm();
 }
 
-double calculateLineLineDistance(const Vector3d& l1b, const Vector3d& l1e, const Vector3d& l2b, const Vector3d& l2e, double& dist_lat)
-{
+double calculateLineLineDistance(const Vector3d &l1b, const Vector3d &l1e,
+                                 const Vector3d &l2b, const Vector3d &l2e,
+                                 double &dist_lat) {
   double d;
   Vector3d v1 = l1e - l1b;
   Vector3d v2 = l2e - l2b;
@@ -56,8 +61,9 @@ double calculateLineLineDistance(const Vector3d& l1b, const Vector3d& l1e, const
   return d;
 }
 
-double calculateSegSegDistance(const Vector3d& l1b, const Vector3d& l1e, const Vector3d& l2b, const Vector3d& l2e, double& dist_lat)
-{
+double calculateSegSegDistance(const Vector3d &l1b, const Vector3d &l1e,
+                               const Vector3d &l2b, const Vector3d &l2e,
+                               double &dist_lat) {
   double d;
   Vector3d v1 = l1e - l1b;
   Vector3d v2 = l2e - l2b;
@@ -66,7 +72,8 @@ double calculateSegSegDistance(const Vector3d& l1b, const Vector3d& l1e, const V
   if (n.norm() < 1e-6) {
     return calculateLinePointDistance(l1b, l1e, l2b, d);
   }
-  if (linsystem(v1, n, v2, l2e - l1b, res, nullptr))return NAN;
+  if (linsystem(v1, n, v2, l2e - l1b, res, nullptr))
+    return NAN;
   double d1 = std::clamp(res[0], 0.0, 1.0);
   double d2 = std::clamp(res[2], 0.0, 1.0);
   Vector3d dist = (l2e - v2 * d2) - (l1b + v1 * d1);
diff --git a/src/glview/cgal/CGALRenderUtils.h b/src/glview/cgal/CGALRenderUtils.h
index fa651143d..0d1069491 100644
--- a/src/glview/cgal/CGALRenderUtils.h
+++ b/src/glview/cgal/CGALRenderUtils.h
@@ -2,5 +2,8 @@
 
 #include "geometry/linalg.h"
 
-double calculateLinePointDistance(const Vector3d& l1, const Vector3d& l2, const Vector3d& pt, double& dist_lat);
-double calculateLineLineDistance(const Vector3d& l1b, const Vector3d& l1e, const Vector3d& l2b, const Vector3d& l2e, double& dist_lat);
+double calculateLinePointDistance(const Vector3d &l1, const Vector3d &l2,
+                                  const Vector3d &pt, double &dist_lat);
+double calculateLineLineDistance(const Vector3d &l1b, const Vector3d &l1e,
+                                 const Vector3d &l2b, const Vector3d &l2e,
+                                 double &dist_lat);
diff --git a/src/glview/cgal/CGALRenderer.cc b/src/glview/cgal/CGALRenderer.cc
index 1c169d878..e840aec24 100644
--- a/src/glview/cgal/CGALRenderer.cc
+++ b/src/glview/cgal/CGALRenderer.cc
@@ -27,9 +27,9 @@
 #include "glview/cgal/CGALRenderer.h"
 
 #include <cassert>
-#include <utility>
-#include <memory>
 #include <cstddef>
+#include <memory>
+#include <utility>
 #include <vector>
 
 #ifdef _MSC_VER
@@ -37,41 +37,41 @@
 #include <mpfr.h>
 #endif
 
-#include "geometry/cgal/cgal.h"
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetUtils.h"
+#include "geometry/cgal/cgal.h"
+#include "geometry/linalg.h"
 #include "glview/ColorMap.h"
 #include "glview/Renderer.h"
 #include "glview/ShaderUtils.h"
-#include "glview/system-gl.h"
 #include "glview/VBOBuilder.h"
 #include "glview/VertexState.h"
+#include "glview/system-gl.h"
 #include "utils/printutils.h"
 
 #ifdef ENABLE_CGAL
-#include <CGAL/Bbox_3.h>
 #include "CGAL/OGL_helper.h"
 #include "glview/cgal/VBOPolyhedron.h"
+#include <CGAL/Bbox_3.h>
 #endif
 #ifdef ENABLE_MANIFOLD
 #include "geometry/manifold/ManifoldGeometry.h"
 #endif
 
-
-CGALRenderer::CGALRenderer(const std::shared_ptr<const class Geometry>& geom) {
+CGALRenderer::CGALRenderer(const std::shared_ptr<const class Geometry> &geom) {
   this->addGeometry(geom);
   PRINTD("CGALRenderer::CGALRenderer() -> createPolyhedrons()");
 #ifdef ENABLE_CGAL
-  if (!this->nefPolyhedrons_.empty() && this->polyhedrons_.empty())createPolyhedrons();
+  if (!this->nefPolyhedrons_.empty() && this->polyhedrons_.empty())
+    createPolyhedrons();
 #endif
 }
 
-void CGALRenderer::addGeometry(const std::shared_ptr<const Geometry>& geom) {
+void CGALRenderer::addGeometry(const std::shared_ptr<const Geometry> &geom) {
   if (const auto geomlist =
-        std::dynamic_pointer_cast<const GeometryList>(geom)) {
-    for (const auto& item : geomlist->getChildren()) {
+          std::dynamic_pointer_cast<const GeometryList>(geom)) {
+    for (const auto &item : geomlist->getChildren()) {
       this->addGeometry(item.second);
     }
   } else if (const auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
@@ -81,12 +81,12 @@ void CGALRenderer::addGeometry(const std::shared_ptr<const Geometry>& geom) {
     // tests/data/scad/3D/features/polyhedron-concave-test.scad
     this->polysets_.push_back(PolySetUtils::tessellate_faces(*ps));
   } else if (const auto poly =
-               std::dynamic_pointer_cast<const Polygon2d>(geom)) {
+                 std::dynamic_pointer_cast<const Polygon2d>(geom)) {
     this->polygons_.emplace_back(
-      poly, std::shared_ptr<const PolySet>(poly->tessellate()));
+        poly, std::shared_ptr<const PolySet>(poly->tessellate()));
 #ifdef ENABLE_CGAL
   } else if (const auto new_N =
-               std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
+                 std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
     assert(new_N->getDimension() == 3);
     if (!new_N->isEmpty()) {
       this->nefPolyhedrons_.push_back(new_N);
@@ -94,7 +94,7 @@ void CGALRenderer::addGeometry(const std::shared_ptr<const Geometry>& geom) {
 #endif
 #ifdef ENABLE_MANIFOLD
   } else if (const auto mani =
-               std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
+                 std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
     this->polysets_.push_back(mani->toPolySet());
 #endif
   } else {
@@ -102,17 +102,16 @@ void CGALRenderer::addGeometry(const std::shared_ptr<const Geometry>& geom) {
   }
 }
 
-CGALRenderer::~CGALRenderer() {
-}
+CGALRenderer::~CGALRenderer() {}
 
 #ifdef ENABLE_CGAL
 void CGALRenderer::createPolyhedrons() {
   PRINTD("createPolyhedrons");
   this->polyhedrons_.clear();
-  for (const auto& N : this->nefPolyhedrons_) {
+  for (const auto &N : this->nefPolyhedrons_) {
     auto p = std::make_shared<VBOPolyhedron>(*colorscheme_);
     CGAL::OGL::Nef3_Converter<CGAL_Nef_polyhedron3>::convert_to_OGLPolyhedron(
-      *N->p3, p.get());
+        *N->p3, p.get());
     // CGAL_NEF3_MARKED_FACET_COLOR <- CGAL_FACE_BACK_COLOR
     // CGAL_NEF3_UNMARKED_FACET_COLOR <- CGAL_FACE_FRONT_COLOR
     p->init();
@@ -123,13 +122,13 @@ void CGALRenderer::createPolyhedrons() {
 #endif // ifdef ENABLE_CGAL
 
 // Overridden from Renderer
-void CGALRenderer::setColorScheme(const ColorScheme& cs) {
+void CGALRenderer::setColorScheme(const ColorScheme &cs) {
   PRINTD("setColorScheme");
   Renderer::setColorScheme(cs);
   colormap_[ColorMode::CGAL_FACE_2D_COLOR] =
-    ColorMap::getColor(cs, RenderColor::CGAL_FACE_2D_COLOR);
+      ColorMap::getColor(cs, RenderColor::CGAL_FACE_2D_COLOR);
   colormap_[ColorMode::CGAL_EDGE_2D_COLOR] =
-    ColorMap::getColor(cs, RenderColor::CGAL_EDGE_2D_COLOR);
+      ColorMap::getColor(cs, RenderColor::CGAL_EDGE_2D_COLOR);
 #ifdef ENABLE_CGAL
   this->polyhedrons_.clear(); // Mark as dirty
 #endif
@@ -140,19 +139,21 @@ void CGALRenderer::setColorScheme(const ColorScheme& cs) {
 void CGALRenderer::createPolySetStates() {
   PRINTD("createPolySetStates() polyset");
 
-  VertexStateContainer& vertex_state_container = vertex_state_containers_.emplace_back();
+  VertexStateContainer &vertex_state_container =
+      vertex_state_containers_.emplace_back();
 
-  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(), vertex_state_container);
+  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(),
+                         vertex_state_container);
 
   vbo_builder.addSurfaceData(); // position, normal, color
 
   size_t num_vertices = 0;
-  for (const auto& polyset : this->polysets_) {
+  for (const auto &polyset : this->polysets_) {
     num_vertices += calcNumVertices(*polyset);
   }
   vbo_builder.allocateBuffers(num_vertices);
 
-  for (const auto& polyset : this->polysets_) {
+  for (const auto &polyset : this->polysets_) {
     Color4f color;
     getColorSchemeColor(ColorMode::MATERIAL, color);
     vbo_builder.writeSurface();
@@ -168,12 +169,14 @@ void CGALRenderer::createPolygonStates() {
 }
 
 void CGALRenderer::createPolygonSurfaceStates() {
-  VertexStateContainer& vertex_state_container = vertex_state_containers_.emplace_back();
-  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(), vertex_state_container);
+  VertexStateContainer &vertex_state_container =
+      vertex_state_containers_.emplace_back();
+  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(),
+                         vertex_state_container);
   vbo_builder.addSurfaceData();
 
   size_t num_vertices = 0;
-  for (const auto&[_, polyset] : this->polygons_) {
+  for (const auto &[_, polyset] : this->polygons_) {
     num_vertices += calcNumVertices(*polyset);
   }
 
@@ -186,7 +189,7 @@ void CGALRenderer::createPolygonSurfaceStates() {
   });
   vertex_state_container.states().emplace_back(std::move(init_state));
 
-  for (const auto&[polygon, polyset] : this->polygons_) {
+  for (const auto &[polygon, polyset] : this->polygons_) {
     Color4f color;
     getColorSchemeColor(ColorMode::CGAL_FACE_2D_COLOR, color);
     vbo_builder.create_polygons(*polyset, Transform3d::Identity(), color);
@@ -198,13 +201,15 @@ void CGALRenderer::createPolygonSurfaceStates() {
 void CGALRenderer::createPolygonEdgeStates() {
   PRINTD("createPolygonStates()");
 
-  VertexStateContainer& vertex_state_container = vertex_state_containers_.emplace_back();
-  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(), vertex_state_container);
+  VertexStateContainer &vertex_state_container =
+      vertex_state_containers_.emplace_back();
+  VBOBuilder vbo_builder(std::make_unique<VertexStateFactory>(),
+                         vertex_state_container);
 
   vbo_builder.addEdgeData();
 
   size_t num_vertices = 0;
-  for (const auto&[polygon, _] : this->polygons_) {
+  for (const auto &[polygon, _] : this->polygons_) {
     num_vertices += calcNumEdgeVertices(*polygon);
   }
 
@@ -219,7 +224,7 @@ void CGALRenderer::createPolygonEdgeStates() {
   });
   vertex_state_container.states().emplace_back(std::move(edge_state));
 
-  for (const auto&[polygon, _] : this->polygons_) {
+  for (const auto &[polygon, _] : this->polygons_) {
     Color4f color;
     getColorSchemeColor(ColorMode::CGAL_EDGE_2D_COLOR, color);
     vbo_builder.writeEdge();
@@ -240,7 +245,8 @@ void CGALRenderer::prepare(const ShaderUtils::ShaderInfo * /*shaderinfo*/) {
   PRINTD("prepare()");
   if (!vertex_state_containers_.size()) {
     if (!this->polysets_.empty() && !this->polygons_.empty()) {
-      LOG(message_group::Error, "CGALRenderer::prepare() called with both polysets and polygons");
+      LOG(message_group::Error,
+          "CGALRenderer::prepare() called with both polysets and polygons");
     } else if (!this->polysets_.empty()) {
       createPolySetStates();
     } else if (!this->polygons_.empty()) {
@@ -249,15 +255,17 @@ void CGALRenderer::prepare(const ShaderUtils::ShaderInfo * /*shaderinfo*/) {
   }
 
 #ifdef ENABLE_CGAL
-  if (!this->nefPolyhedrons_.empty() && this->polyhedrons_.empty())createPolyhedrons();
+  if (!this->nefPolyhedrons_.empty() && this->polyhedrons_.empty())
+    createPolyhedrons();
 #endif
 
   PRINTD("prepare() end");
 }
 
-void CGALRenderer::draw(bool showedges, const ShaderUtils::ShaderInfo * /*shaderinfo*/) const {
+void CGALRenderer::draw(bool showedges,
+                        const ShaderUtils::ShaderInfo * /*shaderinfo*/) const {
   PRINTD("draw()");
-// grab current state to restore after
+  // grab current state to restore after
   GLfloat current_point_size, current_line_width;
   const GLboolean origVertexArrayState = glIsEnabled(GL_VERTEX_ARRAY);
   const GLboolean origNormalArrayState = glIsEnabled(GL_NORMAL_ARRAY);
@@ -266,9 +274,10 @@ void CGALRenderer::draw(bool showedges, const ShaderUtils::ShaderInfo * /*shader
   GL_CHECKD(glGetFloatv(GL_POINT_SIZE, &current_point_size));
   GL_CHECKD(glGetFloatv(GL_LINE_WIDTH, &current_line_width));
 
-  for (const auto& container : vertex_state_containers_) {
-    for (const auto& vertex_state : container.states()) {
-      if (vertex_state)vertex_state->draw();
+  for (const auto &container : vertex_state_containers_) {
+    for (const auto &vertex_state : container.states()) {
+      if (vertex_state)
+        vertex_state->draw();
     }
   }
 
@@ -278,12 +287,15 @@ void CGALRenderer::draw(bool showedges, const ShaderUtils::ShaderInfo * /*shader
   GL_TRACE("glLineWidth(%d)", current_line_width);
   GL_CHECKD(glLineWidth(current_line_width));
 
-  if (!origVertexArrayState)glDisableClientState(GL_VERTEX_ARRAY);
-  if (!origNormalArrayState)glDisableClientState(GL_NORMAL_ARRAY);
-  if (!origColorArrayState)glDisableClientState(GL_COLOR_ARRAY);
+  if (!origVertexArrayState)
+    glDisableClientState(GL_VERTEX_ARRAY);
+  if (!origNormalArrayState)
+    glDisableClientState(GL_NORMAL_ARRAY);
+  if (!origColorArrayState)
+    glDisableClientState(GL_COLOR_ARRAY);
 
 #ifdef ENABLE_CGAL
-  for (const auto& p : this->getPolyhedrons()) {
+  for (const auto &p : this->getPolyhedrons()) {
     p->draw(showedges);
   }
 #endif
@@ -295,19 +307,18 @@ BoundingBox CGALRenderer::getBoundingBox() const {
   BoundingBox bbox;
 
 #ifdef ENABLE_CGAL
-  for (const auto& p : this->getPolyhedrons()) {
+  for (const auto &p : this->getPolyhedrons()) {
     const CGAL::Bbox_3 cgalbbox = p->bbox();
     bbox.extend(BoundingBox(
-                  Vector3d(cgalbbox.xmin(), cgalbbox.ymin(), cgalbbox.zmin()),
-                  Vector3d(cgalbbox.xmax(), cgalbbox.ymax(), cgalbbox.zmax())));
+        Vector3d(cgalbbox.xmin(), cgalbbox.ymin(), cgalbbox.zmin()),
+        Vector3d(cgalbbox.xmax(), cgalbbox.ymax(), cgalbbox.zmax())));
   }
 #endif
-  for (const auto& ps : this->polysets_) {
+  for (const auto &ps : this->polysets_) {
     bbox.extend(ps->getBoundingBox());
   }
-  for (const auto&[polygon, polyset] : this->polygons_) {
+  for (const auto &[polygon, polyset] : this->polygons_) {
     bbox.extend(polygon->getBoundingBox());
   }
   return bbox;
 }
-
diff --git a/src/glview/cgal/CGALRenderer.h b/src/glview/cgal/CGALRenderer.h
index c7afea62d..50bf7ce3a 100644
--- a/src/glview/cgal/CGALRenderer.h
+++ b/src/glview/cgal/CGALRenderer.h
@@ -1,46 +1,52 @@
 #pragma once
 
-#include <utility>
 #include <memory>
+#include <utility>
 #include <vector>
 
-#include "glview/VBORenderer.h"
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
 #include "geometry/Polygon2d.h"
-#include "glview/ShaderUtils.h"
+#include "geometry/linalg.h"
 #include "glview/ColorMap.h"
+#include "glview/ShaderUtils.h"
+#include "glview/VBORenderer.h"
 #include "glview/VertexState.h"
 #ifdef ENABLE_CGAL
 #include "geometry/cgal/CGALNefGeometry.h"
 #endif
 
-class CGALRenderer : public VBORenderer
-{
+class CGALRenderer : public VBORenderer {
 public:
-  CGALRenderer(const std::shared_ptr<const class Geometry>& geom);
+  CGALRenderer(const std::shared_ptr<const class Geometry> &geom);
   ~CGALRenderer() override;
   void prepare(const ShaderUtils::ShaderInfo *shaderinfo = nullptr) override;
-  void draw(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo = nullptr) const override;
-  void setColorScheme(const ColorScheme& cs) override;
+  void draw(bool showedges,
+            const ShaderUtils::ShaderInfo *shaderinfo = nullptr) const override;
+  void setColorScheme(const ColorScheme &cs) override;
   BoundingBox getBoundingBox() const override;
 
 private:
-  void addGeometry(const std::shared_ptr<const class Geometry>& geom);
+  void addGeometry(const std::shared_ptr<const class Geometry> &geom);
 #ifdef ENABLE_CGAL
-  const std::vector<std::shared_ptr<class VBOPolyhedron>>& getPolyhedrons() const { return this->polyhedrons_; }
+  const std::vector<std::shared_ptr<class VBOPolyhedron>> &
+  getPolyhedrons() const {
+    return this->polyhedrons_;
+  }
   void createPolyhedrons();
 #endif
 
-  // FIXME: PolySet and Polygon2d features are only needed for the lazy-union feature,
-  // when a GeometryList may contain a mixture of CGAL and Polygon2d/PolySet geometries.
+  // FIXME: PolySet and Polygon2d features are only needed for the lazy-union
+  // feature, when a GeometryList may contain a mixture of CGAL and
+  // Polygon2d/PolySet geometries.
   void createPolySetStates();
   void createPolygonStates();
   void createPolygonSurfaceStates();
   void createPolygonEdgeStates();
 
   std::vector<std::shared_ptr<const class PolySet>> polysets_;
-  std::vector<std::pair<std::shared_ptr<const Polygon2d>, std::shared_ptr<const PolySet>>> polygons_;
+  std::vector<std::pair<std::shared_ptr<const Polygon2d>,
+                        std::shared_ptr<const PolySet>>>
+      polygons_;
 #ifdef ENABLE_CGAL
   std::vector<std::shared_ptr<class VBOPolyhedron>> polyhedrons_;
   std::vector<std::shared_ptr<const CGALNefGeometry>> nefPolyhedrons_;
diff --git a/src/glview/cgal/VBOPolyhedron.h b/src/glview/cgal/VBOPolyhedron.h
index aecab992f..476f90050 100644
--- a/src/glview/cgal/VBOPolyhedron.h
+++ b/src/glview/cgal/VBOPolyhedron.h
@@ -27,23 +27,21 @@
 #pragma once
 
 #include <cassert>
-#include <utility>
-#include <memory>
 #include <cstdlib>
+#include <memory>
+#include <utility>
 #include <vector>
 
 #include <CGAL/IO/Color.h>
 
 #include "CGAL/OGL_helper.h"
 #include "glview/ColorMap.h"
+#include "glview/VBOBuilder.h"
 #include "glview/VertexState.h"
 #include "glview/system-gl.h"
-#include "glview/VBOBuilder.h"
-#include "glview/ColorMap.h"
 #include "utils/printutils.h"
 
-class VBOPolyhedron : public CGAL::OGL::Polyhedron
-{
+class VBOPolyhedron : public CGAL::OGL::Polyhedron {
 public:
   enum CGALColorIndex {
     MARKED_VERTEX_COLOR = 0,
@@ -55,43 +53,41 @@ public:
     NUM_COLORS
   };
 
-  VBOPolyhedron(const ColorScheme& cs) {
+  VBOPolyhedron(const ColorScheme &cs) {
     // Set default colors.
     setColor(CGALColorIndex::MARKED_VERTEX_COLOR, {0xb7, 0xe8, 0x5c});
     setColor(CGALColorIndex::UNMARKED_VERTEX_COLOR, {0xff, 0xf6, 0x7c});
-    setColor(CGALColorIndex::MARKED_FACET_COLOR, ColorMap::getColor(cs, RenderColor::CGAL_FACE_BACK_COLOR));
-    setColor(CGALColorIndex::UNMARKED_FACET_COLOR, ColorMap::getColor(cs, RenderColor::CGAL_FACE_FRONT_COLOR));
-    setColor(CGALColorIndex::MARKED_EDGE_COLOR, ColorMap::getColor(cs, RenderColor::CGAL_EDGE_BACK_COLOR));
-    setColor(CGALColorIndex::UNMARKED_EDGE_COLOR, ColorMap::getColor(cs, RenderColor::CGAL_EDGE_FRONT_COLOR));
+    setColor(CGALColorIndex::MARKED_FACET_COLOR,
+             ColorMap::getColor(cs, RenderColor::CGAL_FACE_BACK_COLOR));
+    setColor(CGALColorIndex::UNMARKED_FACET_COLOR,
+             ColorMap::getColor(cs, RenderColor::CGAL_FACE_FRONT_COLOR));
+    setColor(CGALColorIndex::MARKED_EDGE_COLOR,
+             ColorMap::getColor(cs, RenderColor::CGAL_EDGE_BACK_COLOR));
+    setColor(CGALColorIndex::UNMARKED_EDGE_COLOR,
+             ColorMap::getColor(cs, RenderColor::CGAL_EDGE_FRONT_COLOR));
   }
 
   ~VBOPolyhedron() override = default;
 
-  void draw(Vertex_iterator v, VBOBuilder& vbo_builder) const {
+  void draw(Vertex_iterator v, VBOBuilder &vbo_builder) const {
     PRINTD("draw(Vertex_iterator)");
 
     CGAL::Color c = getVertexColor(v);
-    vbo_builder.createVertex({Vector3d(v->x(), v->y(), v->z())},
-                             {},
-                             Color4f(c.red(), c.green(), c.blue()),
-                             0, 0, 1);
+    vbo_builder.createVertex({Vector3d(v->x(), v->y(), v->z())}, {},
+                             Color4f(c.red(), c.green(), c.blue()), 0, 0, 1);
   }
 
-  void draw(Edge_iterator e, VBOBuilder& vbo_builder) const {
+  void draw(Edge_iterator e, VBOBuilder &vbo_builder) const {
     PRINTD("draw(Edge_iterator)");
 
     const Double_point p = e->source(), q = e->target();
     const CGAL::Color c = getEdgeColor(e);
     const Color4f color(c.red(), c.green(), c.blue());
 
-    vbo_builder.createVertex({Vector3d(p.x(), p.y(), p.z())},
-                             {},
-                             color,
-                             0, 0, true);
-    vbo_builder.createVertex({Vector3d(q.x(), q.y(), q.z())},
-                             {},
-                             color,
-                             0, 1, true);
+    vbo_builder.createVertex({Vector3d(p.x(), p.y(), p.z())}, {}, color, 0, 0,
+                             true);
+    vbo_builder.createVertex({Vector3d(q.x(), q.y(), q.z())}, {}, color, 0, 1,
+                             true);
   }
 
   struct TessUserData {
@@ -103,10 +99,11 @@ public:
     size_t last_size;
     size_t draw_size;
     size_t elements_offset;
-    VBOBuilder& vbo_builder;
+    VBOBuilder &vbo_builder;
   };
 
-  static inline void CGAL_GLU_TESS_CALLBACK beginCallback(GLenum which, GLvoid *user) {
+  static inline void CGAL_GLU_TESS_CALLBACK beginCallback(GLenum which,
+                                                          GLvoid *user) {
     auto *tess(static_cast<TessUserData *>(user));
     // Create separate vertex set since "which" could be different draw type
     tess->which = which;
@@ -117,7 +114,8 @@ public:
     if (tess->vbo_builder.useElements()) {
       tess->elements_offset = tess->vbo_builder.elements().sizeInBytes();
       // this can vary size if polyset provides triangles
-      tess->vbo_builder.addElementsData(std::make_shared<AttributeData<GLuint, 1, GL_UNSIGNED_INT>>());
+      tess->vbo_builder.addElementsData(
+          std::make_shared<AttributeData<GLuint, 1, GL_UNSIGNED_INT>>());
       tess->vbo_builder.elementsMap().clear();
     }
   }
@@ -126,10 +124,11 @@ public:
     auto *tess(static_cast<TessUserData *>(user));
 
     GLenum elements_type = 0;
-    if (tess->vbo_builder.useElements()) elements_type = tess->vbo_builder.elementsData()->glType();
+    if (tess->vbo_builder.useElements())
+      elements_type = tess->vbo_builder.elementsData()->glType();
     std::shared_ptr<VertexState> vs = tess->vbo_builder.createVertexState(
-      tess->which, tess->draw_size, elements_type,
-      tess->vbo_builder.writeIndex(), tess->elements_offset);
+        tess->which, tess->draw_size, elements_type,
+        tess->vbo_builder.writeIndex(), tess->elements_offset);
     tess->vbo_builder.states().emplace_back(std::move(vs));
     tess->vbo_builder.addAttributePointers(tess->last_size);
     tess->primitive_index++;
@@ -142,7 +141,8 @@ public:
     std::exit(0);
   }
 
-  static inline void CGAL_GLU_TESS_CALLBACK vertexCallback(GLvoid *vertex_arg, GLvoid *user_arg) {
+  static inline void CGAL_GLU_TESS_CALLBACK vertexCallback(GLvoid *vertex_arg,
+                                                           GLvoid *user_arg) {
     auto *vertex(static_cast<GLdouble *>(vertex_arg));
     auto *tess(static_cast<TessUserData *>(user_arg));
     size_t shape_size = 0;
@@ -161,16 +161,18 @@ public:
       break;
     }
 
-
-    tess->vbo_builder.createVertex({Vector3d(vertex)},
-                                   {Vector3d(tess->normal)},
-                                   Color4f(tess->color.red(), tess->color.green(), tess->color.blue()),
-                                   0, 0, shape_size);
+    tess->vbo_builder.createVertex(
+        {Vector3d(vertex)}, {Vector3d(tess->normal)},
+        Color4f(tess->color.red(), tess->color.green(), tess->color.blue()), 0,
+        0, shape_size);
     tess->draw_size++;
     tess->active_point_index++;
   }
 
-  static inline void CGAL_GLU_TESS_CALLBACK combineCallback(GLdouble coords[3], GLvoid *[4], GLfloat [4], GLvoid **dataOut) {
+  static inline void CGAL_GLU_TESS_CALLBACK combineCallback(GLdouble coords[3],
+                                                            GLvoid *[4],
+                                                            GLfloat[4],
+                                                            GLvoid **dataOut) {
     static std::vector<std::unique_ptr<Vector3d>> vertexCache;
     if (dataOut) {
       vertexCache.push_back(std::make_unique<Vector3d>(coords));
@@ -180,36 +182,38 @@ public:
     }
   }
 
-  void draw(Halffacet_iterator f, VBOBuilder& vbo_builder) const {
+  void draw(Halffacet_iterator f, VBOBuilder &vbo_builder) const {
     PRINTD("draw(Halffacet_iterator)");
 
     GLUtesselator *tess_ = gluNewTess();
-    gluTessCallback(tess_, GLenum(GLU_TESS_VERTEX_DATA),
-                    (GLvoid(CGAL_GLU_TESS_CALLBACK *)(CGAL_GLU_TESS_DOTS)) & vertexCallback);
-    gluTessCallback(tess_, GLenum(GLU_TESS_COMBINE),
-                    (GLvoid(CGAL_GLU_TESS_CALLBACK *)(CGAL_GLU_TESS_DOTS)) & combineCallback);
-    gluTessCallback(tess_, GLenum(GLU_TESS_BEGIN_DATA),
-                    (GLvoid(CGAL_GLU_TESS_CALLBACK *)(CGAL_GLU_TESS_DOTS)) & beginCallback);
-    gluTessCallback(tess_, GLenum(GLU_TESS_END_DATA),
-                    (GLvoid(CGAL_GLU_TESS_CALLBACK *)(CGAL_GLU_TESS_DOTS)) & endCallback);
-    gluTessCallback(tess_, GLenum(GLU_TESS_ERROR),
-                    (GLvoid(CGAL_GLU_TESS_CALLBACK *)(CGAL_GLU_TESS_DOTS)) & errorCallback);
+    gluTessCallback(
+        tess_, GLenum(GLU_TESS_VERTEX_DATA),
+        (GLvoid(CGAL_GLU_TESS_CALLBACK *)(CGAL_GLU_TESS_DOTS))&vertexCallback);
+    gluTessCallback(
+        tess_, GLenum(GLU_TESS_COMBINE),
+        (GLvoid(CGAL_GLU_TESS_CALLBACK *)(CGAL_GLU_TESS_DOTS))&combineCallback);
+    gluTessCallback(
+        tess_, GLenum(GLU_TESS_BEGIN_DATA),
+        (GLvoid(CGAL_GLU_TESS_CALLBACK *)(CGAL_GLU_TESS_DOTS))&beginCallback);
+    gluTessCallback(
+        tess_, GLenum(GLU_TESS_END_DATA),
+        (GLvoid(CGAL_GLU_TESS_CALLBACK *)(CGAL_GLU_TESS_DOTS))&endCallback);
+    gluTessCallback(
+        tess_, GLenum(GLU_TESS_ERROR),
+        (GLvoid(CGAL_GLU_TESS_CALLBACK *)(CGAL_GLU_TESS_DOTS))&errorCallback);
     gluTessProperty(tess_, GLenum(GLU_TESS_WINDING_RULE),
                     GLU_TESS_WINDING_POSITIVE);
 
     CGAL::OGL::DFacet::Coord_const_iterator cit;
-    TessUserData tess_data = {
-      0, f->normal(), getFacetColor(f),
-      0, 0, 0, 0, 0, vbo_builder
-    };
+    TessUserData tess_data = {0, f->normal(), getFacetColor(f), 0, 0, 0,
+                              0, 0,           vbo_builder};
 
     gluTessBeginPolygon(tess_, &tess_data);
     // forall facet cycles of f:
     for (unsigned i = 0; i < f->number_of_facet_cycles(); ++i) {
       gluTessBeginContour(tess_);
       // put all vertices in facet cycle into contour:
-      for (cit = f->facet_cycle_begin(i);
-           cit != f->facet_cycle_end(i); ++cit) {
+      for (cit = f->facet_cycle_begin(i); cit != f->facet_cycle_end(i); ++cit) {
         gluTessVertex(tess_, *cit, *cit);
       }
       gluTessEndContour(tess_);
@@ -224,14 +228,16 @@ public:
 
     points_edges_container_ = std::make_unique<VertexStateContainer>();
 
-    VBOBuilder points_edges_builder(std::make_unique<VertexStateFactory>(), *points_edges_container_.get());
+    VBOBuilder points_edges_builder(std::make_unique<VertexStateFactory>(),
+                                    *points_edges_container_.get());
 
     points_edges_builder.addEdgeData();
     points_edges_builder.writeEdge();
     size_t last_size = 0;
     size_t elements_offset = 0;
 
-    const size_t num_vertices = vertices_.size() + edges_.size() * 2, elements_size = 0;
+    const size_t num_vertices = vertices_.size() + edges_.size() * 2,
+                 elements_size = 0;
     points_edges_builder.allocateBuffers(num_vertices);
 
     // Points
@@ -256,10 +262,11 @@ public:
       draw(v, points_edges_builder);
 
     GLenum elements_type = 0;
-    if (points_edges_builder.useElements()) elements_type = points_edges_builder.elementsData()->glType();
+    if (points_edges_builder.useElements())
+      elements_type = points_edges_builder.elementsData()->glType();
     std::shared_ptr<VertexState> vs = points_edges_builder.createVertexState(
-      GL_POINTS, vertices_.size(), elements_type,
-      points_edges_builder.writeIndex(), elements_offset);
+        GL_POINTS, vertices_.size(), elements_type,
+        points_edges_builder.writeIndex(), elements_offset);
     points_edges_container_->states().emplace_back(std::move(vs));
     points_edges_builder.addAttributePointers(last_size);
 
@@ -286,12 +293,12 @@ public:
     for (e = edges_.begin(); e != edges_.end(); ++e)
       draw(e, points_edges_builder);
 
-
     elements_type = 0;
-    if (points_edges_builder.useElements()) elements_type = points_edges_builder.elementsData()->glType();
+    if (points_edges_builder.useElements())
+      elements_type = points_edges_builder.elementsData()->glType();
     vs = points_edges_builder.createVertexState(
-      GL_LINES, edges_.size() * 2, elements_type,
-      points_edges_builder.writeIndex(), elements_offset);
+        GL_LINES, edges_.size() * 2, elements_type,
+        points_edges_builder.writeIndex(), elements_offset);
     points_edges_container_->states().emplace_back(std::move(vs));
     points_edges_builder.addAttributePointers(last_size);
 
@@ -300,8 +307,11 @@ public:
     // Halffacets
     halffacets_container_ = std::make_unique<VertexStateContainer>();
 
-    // FIXME: We don't know the size of this VertexArray in advanced, so we have to deal with some fallback mechanism for filling in the data. This complicates code quite a bit
-    VBOBuilder halffacets_builder(std::make_unique<VertexStateFactory>(), *halffacets_container_.get());
+    // FIXME: We don't know the size of this VertexArray in advanced, so we have
+    // to deal with some fallback mechanism for filling in the data. This
+    // complicates code quite a bit
+    VBOBuilder halffacets_builder(std::make_unique<VertexStateFactory>(),
+                                  *halffacets_container_.get());
     halffacets_builder.addSurfaceData();
     halffacets_builder.writeSurface();
 
@@ -346,13 +356,15 @@ public:
     GL_CHECKD(glGetFloatv(GL_POINT_SIZE, &current_point_size));
     GL_CHECKD(glGetFloatv(GL_LINE_WIDTH, &current_line_width));
 
-    for (const auto& halffacet : halffacets_container_->states()) {
-      if (halffacet) halffacet->draw();
+    for (const auto &halffacet : halffacets_container_->states()) {
+      if (halffacet)
+        halffacet->draw();
     }
 
     if (showedges) {
-      for (const auto& point_edge : points_edges_container_->states()) {
-        if (point_edge) point_edge->draw();
+      for (const auto &point_edge : points_edges_container_->states()) {
+        if (point_edge)
+          point_edge->draw();
       }
     }
 
@@ -362,39 +374,46 @@ public:
     GL_TRACE("glLineWidth(%d)", current_line_width);
     GL_CHECKD(glLineWidth(current_line_width));
 
-    if (!origVertexArrayState) glDisableClientState(GL_VERTEX_ARRAY);
-    if (!origNormalArrayState) glDisableClientState(GL_NORMAL_ARRAY);
-    if (!origColorArrayState) glDisableClientState(GL_COLOR_ARRAY);
+    if (!origVertexArrayState)
+      glDisableClientState(GL_VERTEX_ARRAY);
+    if (!origNormalArrayState)
+      glDisableClientState(GL_NORMAL_ARRAY);
+    if (!origColorArrayState)
+      glDisableClientState(GL_COLOR_ARRAY);
 
     PRINTD("VBO draw() end");
   }
 
-
   // overrides function in OGL_helper.h
   [[nodiscard]] CGAL::Color getVertexColor(Vertex_iterator v) const override {
     PRINTD("getVertexColor");
-    CGAL::Color c = v->mark() ? colors[CGALColorIndex::UNMARKED_VERTEX_COLOR] : colors[CGALColorIndex::MARKED_VERTEX_COLOR];
+    CGAL::Color c = v->mark() ? colors[CGALColorIndex::UNMARKED_VERTEX_COLOR]
+                              : colors[CGALColorIndex::MARKED_VERTEX_COLOR];
     return c;
   }
 
   // overrides function in OGL_helper.h
   [[nodiscard]] CGAL::Color getEdgeColor(Edge_iterator e) const override {
     PRINTD("getEdgeColor");
-    CGAL::Color c = e->mark() ? colors[CGALColorIndex::UNMARKED_EDGE_COLOR] : colors[CGALColorIndex::MARKED_EDGE_COLOR];
+    CGAL::Color c = e->mark() ? colors[CGALColorIndex::UNMARKED_EDGE_COLOR]
+                              : colors[CGALColorIndex::MARKED_EDGE_COLOR];
     return c;
   }
 
   // overrides function in OGL_helper.h
   [[nodiscard]] CGAL::Color getFacetColor(Halffacet_iterator f) const override {
-    CGAL::Color c = f->mark() ? colors[CGALColorIndex::UNMARKED_FACET_COLOR] : colors[CGALColorIndex::MARKED_FACET_COLOR];
+    CGAL::Color c = f->mark() ? colors[CGALColorIndex::UNMARKED_FACET_COLOR]
+                              : colors[CGALColorIndex::MARKED_FACET_COLOR];
     return c;
   }
 
-  void setColor(CGALColorIndex color_index, const Color4f& c) {
-    // Note: Not setting alpha here as none of our built-in colors currently have an alpha component
-    // This _may_ yield unexpected results for user-defined colors with alpha components.
+  void setColor(CGALColorIndex color_index, const Color4f &c) {
+    // Note: Not setting alpha here as none of our built-in colors currently
+    // have an alpha component This _may_ yield unexpected results for
+    // user-defined colors with alpha components.
     PRINTDB("setColor %i %f %f %f", color_index % c.r() % c.g() % c.b());
-    this->colors[color_index] = CGAL::Color(c.r() * 255, c.g() * 255, c.b() * 255);
+    this->colors[color_index] =
+        CGAL::Color(c.r() * 255, c.g() * 255, c.b() * 255);
   }
 
 protected:
diff --git a/src/glview/fbo.cc b/src/glview/fbo.cc
index 08c6bc309..06309c227 100644
--- a/src/glview/fbo.cc
+++ b/src/glview/fbo.cc
@@ -48,7 +48,7 @@ bool checkFBOStatus() {
   return false;
 }
 
-}  // namespace
+} // namespace
 
 std::unique_ptr<FBO> createFBO(int width, int height) {
   if (hasGLExtension(ARB_framebuffer_object)) {
@@ -61,7 +61,8 @@ std::unique_ptr<FBO> createFBO(int width, int height) {
   }
 }
 
-FBO::FBO(int width, int height, bool useEXT) : width_(width), height_(height), use_ext_(useEXT) {
+FBO::FBO(int width, int height, bool useEXT)
+    : width_(width), height_(height), use_ext_(useEXT) {
   // Generate and bind FBO
   GL_CHECKD(glGenFramebuffers(1, &this->fbo_id_));
   this->bind();
@@ -71,14 +72,16 @@ FBO::FBO(int width, int height, bool useEXT) : width_(width), height_(height), u
   GL_CHECKD(glGenRenderbuffers(1, &this->renderbuf_id_));
 
   // Create buffers with correct size
-  if (!this->resize(width, height)) return;
+  if (!this->resize(width, height))
+    return;
 
   // Attach render and depth buffers
   GL_CHECKD(glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
                                       GL_RENDERBUFFER, this->renderbuf_id_));
 
   if (!checkFBOStatus()) {
-    LOG(message_group::Error, "Problem with OpenGL framebuffer after specifying color render buffer.");
+    LOG(message_group::Error, "Problem with OpenGL framebuffer after "
+                              "specifying color render buffer.");
     return;
   }
 
@@ -90,15 +93,15 @@ FBO::FBO(int width, int height, bool useEXT) : width_(width), height_(height), u
                                       GL_RENDERBUFFER, this->depthbuf_id_));
 
   if (!checkFBOStatus()) {
-    LOG(message_group::Error, "Problem with OpenGL framebuffer after specifying depth render buffer.");
+    LOG(message_group::Error, "Problem with OpenGL framebuffer after "
+                              "specifying depth render buffer.");
     return;
   }
 
   this->complete_ = true;
 }
 
-bool FBO::resize(size_t width, size_t height)
-{
+bool FBO::resize(size_t width, size_t height) {
   if (this->use_ext_) {
     GL_CHECKD(glBindRenderbufferEXT(GL_RENDERBUFFER, this->renderbuf_id_));
   } else {
@@ -110,7 +113,8 @@ bool FBO::resize(size_t width, size_t height)
   } else {
     GL_CHECKD(glBindRenderbuffer(GL_RENDERBUFFER, this->depthbuf_id_));
   }
-  GL_CHECKD(glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, width, height));
+  GL_CHECKD(glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, width,
+                                  height));
 
   width_ = width;
   height_ = height;
@@ -119,9 +123,9 @@ bool FBO::resize(size_t width, size_t height)
 }
 
 // Bind this VBO. Returs the old FBO id.
-GLuint FBO::bind()
-{
-  glGetIntegerv(GL_FRAMEBUFFER_BINDING, reinterpret_cast<GLint *>(&this->old_fbo_id_));
+GLuint FBO::bind() {
+  glGetIntegerv(GL_FRAMEBUFFER_BINDING,
+                reinterpret_cast<GLint *>(&this->old_fbo_id_));
   if (this->use_ext_) {
     GL_CHECKD(glBindFramebufferEXT(GL_FRAMEBUFFER, this->fbo_id_));
   } else {
@@ -131,8 +135,7 @@ GLuint FBO::bind()
 }
 
 // Unbind this VBO, and bind the previous FBO id.
-void FBO::unbind()
-{
+void FBO::unbind() {
   if (this->use_ext_) {
     GL_CHECKD(glBindFramebufferEXT(GL_FRAMEBUFFER, this->old_fbo_id_));
   } else {
@@ -141,8 +144,7 @@ void FBO::unbind()
   this->old_fbo_id_ = 0;
 }
 
-void FBO::destroy()
-{
+void FBO::destroy() {
   this->unbind();
   if (this->depthbuf_id_ != 0) {
     GL_CHECKD(glDeleteRenderbuffers(1, &this->depthbuf_id_));
diff --git a/src/glview/fbo.h b/src/glview/fbo.h
index 901cf0b48..b44a3ef4a 100644
--- a/src/glview/fbo.h
+++ b/src/glview/fbo.h
@@ -5,8 +5,7 @@
 
 #include "glview/system-gl.h"
 
-class FBO
-{
+class FBO {
 public:
   FBO(int width, int height, bool useEXT);
   ~FBO() { destroy(); }
diff --git a/src/glview/hershey.cc b/src/glview/hershey.cc
index 56a5e6292..900f3a771 100644
--- a/src/glview/hershey.cc
+++ b/src/glview/hershey.cc
@@ -16,12 +16,12 @@ struct HersheyGlyph {
   } operations[55];
 };
 extern const HersheyGlyph hershey_simplex[];
-}  // namespace
+} // namespace
 
 namespace hershey {
 float TextWidth(std::string_view str, float size) {
   float longest_line = 0;
-  size /= 25.0f;  // The actual coordinates are roughly in the range 0..25
+  size /= 25.0f; // The actual coordinates are roughly in the range 0..25
 
   float w = 0;
   for (char c : str) {
@@ -29,8 +29,9 @@ float TextWidth(std::string_view str, float size) {
       longest_line = std::max(longest_line, w);
       w = 0;
     }
-    if (c < 32 || c > 126) continue;
-    const HersheyGlyph& glyph = hershey_simplex[c - 32];
+    if (c < 32 || c > 126)
+      continue;
+    const HersheyGlyph &glyph = hershey_simplex[c - 32];
     w += size * glyph.width;
   }
   return std::max(longest_line, w);
@@ -38,22 +39,25 @@ float TextWidth(std::string_view str, float size) {
 
 void DrawText(std::string_view str, float tx, float ty, TextAlign align,
               float size,
-              const std::function<void(bool do_line, float x, float y)>& draw) {
+              const std::function<void(bool do_line, float x, float y)> &draw) {
   float dx = 0;
-  if (align == TextAlign::kRight)dx = -TextWidth(str, size);
-  else if (align == TextAlign::kCenter)dx = -TextWidth(str, size) / 2;
-  size /= 25.0f;  // The actual coordinates are roughly in the range 0..25
+  if (align == TextAlign::kRight)
+    dx = -TextWidth(str, size);
+  else if (align == TextAlign::kCenter)
+    dx = -TextWidth(str, size) / 2;
+  size /= 25.0f; // The actual coordinates are roughly in the range 0..25
   float x = 0, y = 0;
   for (char c : str) {
     if (c == '\n') {
       y -= 30 * size;
       x = 0;
     }
-    if (c < 32 || c > 126) continue;
-    const HersheyGlyph& glyph = hershey_simplex[c - 32];
+    if (c < 32 || c > 126)
+      continue;
+    const HersheyGlyph &glyph = hershey_simplex[c - 32];
     bool pen_up = true;
     for (int op = 0; op < glyph.number_of_ops; ++op) {
-      const auto& coor = glyph.operations[op];
+      const auto &coor = glyph.operations[op];
       if (coor.x == -1 && coor.y == -1) {
         pen_up = true;
         continue;
@@ -360,4 +364,4 @@ const HersheyGlyph hershey_simplex[] = {
 };
 /* *INDENT-ON* */
 /* clang-format on */
-}  // namespace
+} // namespace
diff --git a/src/glview/hershey.h b/src/glview/hershey.h
index d6a24c3d7..00fa60ea8 100644
--- a/src/glview/hershey.h
+++ b/src/glview/hershey.h
@@ -22,5 +22,5 @@ enum class TextAlign { kLeft, kCenter, kRight };
 // adapt in any environment including 3D projection.
 void DrawText(std::string_view str, float tx, float ty, TextAlign align,
               float size,
-              const std::function<void(bool pen_down, float x, float y)>& draw);
-}  // namespace hershey
+              const std::function<void(bool pen_down, float x, float y)> &draw);
+} // namespace hershey
diff --git a/src/glview/offscreen-old/OffscreenContextEGL.cc b/src/glview/offscreen-old/OffscreenContextEGL.cc
index 60b9602ff..f509b1682 100644
--- a/src/glview/offscreen-old/OffscreenContextEGL.cc
+++ b/src/glview/offscreen-old/OffscreenContextEGL.cc
@@ -25,10 +25,10 @@
  */
 #include "glview/offscreen-old/OffscreenContextEGL.h"
 
-#include <iostream>
+#include <EGL/egl.h>
 #include <cstdint>
+#include <iostream>
 #include <memory>
-#include <EGL/egl.h>
 #define EGL_EGLEXT_PROTOTYPES
 #include <EGL/eglext.h>
 
@@ -43,10 +43,10 @@
 
 namespace {
 
-class OffscreenContextEGL : public OffscreenContext
-{
+class OffscreenContextEGL : public OffscreenContext {
 public:
-  OffscreenContextEGL(uint32_t width, uint32_t height) : OffscreenContext(width, height) {}
+  OffscreenContextEGL(uint32_t width, uint32_t height)
+      : OffscreenContext(width, height) {}
   ~OffscreenContextEGL() {
     if (this->display != nullptr) {
       eglTerminate(this->display);
@@ -71,7 +71,8 @@ public:
   }
 
   bool makeCurrent() const override {
-    return eglMakeCurrent(this->display, this->surface, this->surface, this->context);
+    return eglMakeCurrent(this->display, this->surface, this->surface,
+                          this->context);
   }
 
   EGLContext context{nullptr};
@@ -79,27 +80,27 @@ public:
   EGLSurface surface{EGL_NO_SURFACE};
 };
 
-static bool create_egl_dummy_context(OffscreenContextEGL& ctx)
-{
-  static const EGLint configAttribs[] = {
-    EGL_SURFACE_TYPE, EGL_PBUFFER_BIT,
-    EGL_BLUE_SIZE, 8,
-    EGL_GREEN_SIZE, 8,
-    EGL_RED_SIZE, 8,
-    EGL_ALPHA_SIZE, 8,
-    EGL_DEPTH_SIZE, 24,
-    EGL_CONFORMANT, EGL_OPENGL_BIT,
-    EGL_NONE
-  };
+static bool create_egl_dummy_context(OffscreenContextEGL &ctx) {
+  static const EGLint configAttribs[] = {EGL_SURFACE_TYPE, EGL_PBUFFER_BIT,
+                                         EGL_BLUE_SIZE,    8,
+                                         EGL_GREEN_SIZE,   8,
+                                         EGL_RED_SIZE,     8,
+                                         EGL_ALPHA_SIZE,   8,
+                                         EGL_DEPTH_SIZE,   24,
+                                         EGL_CONFORMANT,   EGL_OPENGL_BIT,
+                                         EGL_NONE};
 
   const EGLint pbufferAttribs[] = {
-    EGL_WIDTH, static_cast<EGLint>(ctx.width()),
-    EGL_HEIGHT, static_cast<EGLint>(ctx.height()),
-    EGL_NONE,
+      EGL_WIDTH,  static_cast<EGLint>(ctx.width()),
+      EGL_HEIGHT, static_cast<EGLint>(ctx.height()),
+      EGL_NONE,
   };
 
-  PFNEGLQUERYDEVICESEXTPROC eglQueryDevicesEXT = (PFNEGLQUERYDEVICESEXTPROC) eglGetProcAddress("eglQueryDevicesEXT");
-  PFNEGLGETPLATFORMDISPLAYEXTPROC eglGetPlatformDisplayEXT = (PFNEGLGETPLATFORMDISPLAYEXTPROC) eglGetProcAddress("eglGetPlatformDisplayEXT");
+  PFNEGLQUERYDEVICESEXTPROC eglQueryDevicesEXT =
+      (PFNEGLQUERYDEVICESEXTPROC)eglGetProcAddress("eglQueryDevicesEXT");
+  PFNEGLGETPLATFORMDISPLAYEXTPROC eglGetPlatformDisplayEXT =
+      (PFNEGLGETPLATFORMDISPLAYEXTPROC)eglGetProcAddress(
+          "eglGetPlatformDisplayEXT");
   if (eglQueryDevicesEXT && eglGetPlatformDisplayEXT) {
     const int MAX_DEVICES = 10;
     EGLDeviceEXT eglDevs[MAX_DEVICES];
@@ -108,7 +109,8 @@ static bool create_egl_dummy_context(OffscreenContextEGL& ctx)
     eglQueryDevicesEXT(MAX_DEVICES, eglDevs, &numDevices);
     PRINTDB("Found %d EGL devices.", numDevices);
     for (int idx = 0; idx < numDevices; idx++) {
-      EGLDisplay disp = eglGetPlatformDisplayEXT(EGL_PLATFORM_DEVICE_EXT, eglDevs[idx], nullptr);
+      EGLDisplay disp = eglGetPlatformDisplayEXT(EGL_PLATFORM_DEVICE_EXT,
+                                                 eglDevs[idx], nullptr);
       if (disp != EGL_NO_DISPLAY) {
         ctx.display = disp;
         break;
@@ -124,7 +126,9 @@ static bool create_egl_dummy_context(OffscreenContextEGL& ctx)
     return false;
   }
 
-  PFNEGLGETDISPLAYDRIVERNAMEPROC eglGetDisplayDriverName = (PFNEGLGETDISPLAYDRIVERNAMEPROC) eglGetProcAddress("eglGetDisplayDriverName");
+  PFNEGLGETDISPLAYDRIVERNAMEPROC eglGetDisplayDriverName =
+      (PFNEGLGETDISPLAYDRIVERNAMEPROC)eglGetProcAddress(
+          "eglGetDisplayDriverName");
   if (eglGetDisplayDriverName) {
     const char *name = eglGetDisplayDriverName(ctx.display);
     PRINTDB("Got EGL display with driver name '%s'", name);
@@ -136,12 +140,14 @@ static bool create_egl_dummy_context(OffscreenContextEGL& ctx)
     return false;
   }
 
-  PRINTDB("EGL Version: %d.%d (%s)", major % minor % eglQueryString(ctx.display, EGL_VENDOR));
+  PRINTDB("EGL Version: %d.%d (%s)",
+          major % minor % eglQueryString(ctx.display, EGL_VENDOR));
 
   EGLint numConfigs;
   EGLConfig config;
   if (!eglChooseConfig(ctx.display, configAttribs, &config, 1, &numConfigs)) {
-    std::cerr << "Failed to choose config (eglError: " << std::hex << eglGetError() << ")" << std::endl;
+    std::cerr << "Failed to choose config (eglError: " << std::hex
+              << eglGetError() << ")" << std::endl;
     return false;
   }
   if (!eglBindAPI(EGL_OPENGL_API)) {
@@ -150,33 +156,36 @@ static bool create_egl_dummy_context(OffscreenContextEGL& ctx)
   }
   ctx.surface = eglCreatePbufferSurface(ctx.display, config, pbufferAttribs);
   if (ctx.surface == EGL_NO_SURFACE) {
-    std::cerr << "Unable to create EGL surface (eglError: " << eglGetError() << ")" << std::endl;
+    std::cerr << "Unable to create EGL surface (eglError: " << eglGetError()
+              << ")" << std::endl;
     return false;
   }
 
-  EGLint ctxattr[] = {
-    EGL_CONTEXT_MAJOR_VERSION, 2,
-    EGL_CONTEXT_MINOR_VERSION, 0,
-    EGL_CONTEXT_OPENGL_PROFILE_MASK, EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT,
-    EGL_NONE
-  };
+  EGLint ctxattr[] = {EGL_CONTEXT_MAJOR_VERSION,
+                      2,
+                      EGL_CONTEXT_MINOR_VERSION,
+                      0,
+                      EGL_CONTEXT_OPENGL_PROFILE_MASK,
+                      EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT,
+                      EGL_NONE};
   ctx.context = eglCreateContext(ctx.display, config, EGL_NO_CONTEXT, ctxattr);
   if (ctx.context == EGL_NO_CONTEXT) {
-    std::cerr << "Unable to create EGL context (eglError: " << eglGetError() << ")" << std::endl;
+    std::cerr << "Unable to create EGL context (eglError: " << eglGetError()
+              << ")" << std::endl;
     return false;
   }
 
   return true;
 }
 
-}  // namespace
+} // namespace
 
 namespace offscreen_old {
 
-std::shared_ptr<OffscreenContext> CreateOffscreenContextEGL(
-  uint32_t width, uint32_t height, uint32_t majorGLVersion,
-  uint32_t minorGLVersion, bool gles, bool compatibilityProfile)
-{
+std::shared_ptr<OffscreenContext>
+CreateOffscreenContextEGL(uint32_t width, uint32_t height,
+                          uint32_t majorGLVersion, uint32_t minorGLVersion,
+                          bool gles, bool compatibilityProfile) {
   auto ctx = std::make_shared<OffscreenContextEGL>(width, height);
 
   if (!create_egl_dummy_context(*ctx)) {
@@ -185,4 +194,4 @@ std::shared_ptr<OffscreenContext> CreateOffscreenContextEGL(
   return ctx;
 }
 
-}  // namespace offscreen_old
+} // namespace offscreen_old
diff --git a/src/glview/offscreen-old/OffscreenContextEGL.h b/src/glview/offscreen-old/OffscreenContextEGL.h
index 6eb5f60c3..2f154a87c 100644
--- a/src/glview/offscreen-old/OffscreenContextEGL.h
+++ b/src/glview/offscreen-old/OffscreenContextEGL.h
@@ -7,8 +7,9 @@
 
 namespace offscreen_old {
 
-std::shared_ptr<OffscreenContext> CreateOffscreenContextEGL(
-  uint32_t width, uint32_t height, uint32_t majorGLVersion,
-  uint32_t minorGLVersion, bool gles, bool compatibilityProfile);
+std::shared_ptr<OffscreenContext>
+CreateOffscreenContextEGL(uint32_t width, uint32_t height,
+                          uint32_t majorGLVersion, uint32_t minorGLVersion,
+                          bool gles, bool compatibilityProfile);
 
-}  // namespace offscreen_old
+} // namespace offscreen_old
diff --git a/src/glview/offscreen-old/OffscreenContextGLX.cc b/src/glview/offscreen-old/OffscreenContextGLX.cc
index 08c74c22b..423ce2326 100644
--- a/src/glview/offscreen-old/OffscreenContextGLX.cc
+++ b/src/glview/offscreen-old/OffscreenContextGLX.cc
@@ -36,13 +36,12 @@
  */
 #include "glview/offscreen-old/OffscreenContextGLX.h"
 
-
 #include "glview/system-gl.h"
-#include <iostream>
-#include <cstdint>
-#include <memory>
 #include <GL/gl.h>
 #include <GL/glx.h>
+#include <cstdint>
+#include <iostream>
+#include <memory>
 
 #include <cassert>
 #include <sstream>
@@ -53,14 +52,17 @@
 
 namespace {
 
-class OffscreenContextGLX : public OffscreenContext
-{
+class OffscreenContextGLX : public OffscreenContext {
 public:
-  OffscreenContextGLX(uint32_t width, uint32_t height) : OffscreenContext(width, height) {}
+  OffscreenContextGLX(uint32_t width, uint32_t height)
+      : OffscreenContext(width, height) {}
   ~OffscreenContextGLX() {
-    if (this->xwindow) XDestroyWindow(this->xdisplay, this->xwindow);
-    if (this->openGLContext) glXDestroyContext(this->xdisplay, this->openGLContext);
-    if (this->xdisplay) XCloseDisplay(this->xdisplay);
+    if (this->xwindow)
+      XDestroyWindow(this->xdisplay, this->xwindow);
+    if (this->openGLContext)
+      glXDestroyContext(this->xdisplay, this->openGLContext);
+    if (this->xdisplay)
+      XCloseDisplay(this->xdisplay);
   }
 
   std::string getInfo() const override {
@@ -81,7 +83,8 @@ public:
   }
 
   bool makeCurrent() const override {
-    return glXMakeContextCurrent(this->xdisplay, this->xwindow, this->xwindow, this->openGLContext);
+    return glXMakeContextCurrent(this->xdisplay, this->xwindow, this->xwindow,
+                                 this->openGLContext);
   }
 
   GLXContext openGLContext{nullptr};
@@ -91,8 +94,7 @@ public:
 
 static XErrorHandler original_xlib_handler = nullptr;
 static auto XCreateWindow_failed = false;
-static int XCreateWindow_error(Display *dpy, XErrorEvent *event)
-{
+static int XCreateWindow_error(Display *dpy, XErrorEvent *event) {
   std::cerr << "XCreateWindow failed: XID: " << event->resourceid
             << " request: " << static_cast<int>(event->request_code)
             << " minor: " << static_cast<int>(event->minor_code) << "\n";
@@ -113,25 +115,33 @@ static int XCreateWindow_error(Display *dpy, XErrorEvent *event)
 
    This function will alter ctx.openGLContext and ctx.xwindow if successful
  */
-bool create_glx_dummy_window(OffscreenContextGLX& ctx)
-{
-  int attributes[] = {
-    GLX_DRAWABLE_TYPE, GLX_WINDOW_BIT | GLX_PIXMAP_BIT | GLX_PBUFFER_BIT, //support all 3, for OpenCSG
-    GLX_RENDER_TYPE,   GLX_RGBA_BIT,
-    GLX_RED_SIZE, 8,
-    GLX_GREEN_SIZE, 8,
-    GLX_BLUE_SIZE, 8,
-    GLX_ALPHA_SIZE, 8,
-    GLX_DEPTH_SIZE, 24, // depth-stencil for OpenCSG
-    GLX_STENCIL_SIZE, 8,
-    GLX_DOUBLEBUFFER, true,
-    None
-  };
+bool create_glx_dummy_window(OffscreenContextGLX &ctx) {
+  int attributes[] = {GLX_DRAWABLE_TYPE,
+                      GLX_WINDOW_BIT | GLX_PIXMAP_BIT |
+                          GLX_PBUFFER_BIT, // support all 3, for OpenCSG
+                      GLX_RENDER_TYPE,
+                      GLX_RGBA_BIT,
+                      GLX_RED_SIZE,
+                      8,
+                      GLX_GREEN_SIZE,
+                      8,
+                      GLX_BLUE_SIZE,
+                      8,
+                      GLX_ALPHA_SIZE,
+                      8,
+                      GLX_DEPTH_SIZE,
+                      24, // depth-stencil for OpenCSG
+                      GLX_STENCIL_SIZE,
+                      8,
+                      GLX_DOUBLEBUFFER,
+                      true,
+                      None};
 
   auto dpy = ctx.xdisplay;
 
   int num_returned = 0;
-  auto fbconfigs = glXChooseFBConfig(dpy, DefaultScreen(dpy), attributes, &num_returned);
+  auto fbconfigs =
+      glXChooseFBConfig(dpy, DefaultScreen(dpy), attributes, &num_returned);
   if (fbconfigs == nullptr) {
     std::cerr << "glXChooseFBConfig failed\n";
     return false;
@@ -144,7 +154,8 @@ bool create_glx_dummy_window(OffscreenContextGLX& ctx)
     return false;
   }
 
-  // can't depend on xWin==nullptr at failure. use a custom Xlib error handler instead.
+  // can't depend on xWin==nullptr at failure. use a custom Xlib error handler
+  // instead.
   original_xlib_handler = XSetErrorHandler(XCreateWindow_error);
 
   auto root = DefaultRootWindow(dpy);
@@ -156,13 +167,14 @@ bool create_glx_dummy_window(OffscreenContextGLX& ctx)
   xwin_attr.border_pixel = 0;
   xwin_attr.colormap = XCreateColormap(dpy, root, visinfo->visual, AllocNone);
   xwin_attr.event_mask = StructureNotifyMask | ExposureMask | KeyPressMask;
-  unsigned long int mask = CWBackPixel | CWBorderPixel | CWColormap | CWEventMask;
+  unsigned long int mask =
+      CWBackPixel | CWBorderPixel | CWColormap | CWEventMask;
 
-  auto xWin = XCreateWindow(dpy, root, 0, 0, width, height,
-                            0, visinfo->depth, InputOutput,
-                            visinfo->visual, mask, &xwin_attr);
+  auto xWin = XCreateWindow(dpy, root, 0, 0, width, height, 0, visinfo->depth,
+                            InputOutput, visinfo->visual, mask, &xwin_attr);
 
-  // Window xWin = XCreateSimpleWindow( dpy, DefaultRootWindow(dpy), 0,0,42,42, 0,0,0 );
+  // Window xWin = XCreateSimpleWindow( dpy, DefaultRootWindow(dpy), 0,0,42,42,
+  // 0,0,0 );
 
   XSync(dpy, false);
   if (XCreateWindow_failed) {
@@ -172,10 +184,11 @@ bool create_glx_dummy_window(OffscreenContextGLX& ctx)
   }
   XSetErrorHandler(original_xlib_handler);
 
-  // Most programs would call XMapWindow here. But we don't, to keep the window hidden
-  // XMapWindow( dpy, xWin );
+  // Most programs would call XMapWindow here. But we don't, to keep the window
+  // hidden XMapWindow( dpy, xWin );
 
-  auto context = glXCreateNewContext(dpy, fbconfigs[0], GLX_RGBA_TYPE, nullptr, true);
+  auto context =
+      glXCreateNewContext(dpy, fbconfigs[0], GLX_RGBA_TYPE, nullptr, true);
   if (context == nullptr) {
     std::cerr << "glXCreateNewContext failed\n";
     XDestroyWindow(dpy, xWin);
@@ -184,7 +197,7 @@ bool create_glx_dummy_window(OffscreenContextGLX& ctx)
     return false;
   }
 
-  //GLXWindow glxWin = glXCreateWindow( dpy, fbconfigs[0], xWin, nullptr );
+  // GLXWindow glxWin = glXCreateWindow( dpy, fbconfigs[0], xWin, nullptr );
 
   ctx.openGLContext = context;
   ctx.xwindow = xWin;
@@ -195,11 +208,10 @@ bool create_glx_dummy_window(OffscreenContextGLX& ctx)
   return true;
 }
 
-
 #pragma GCC diagnostic ignored "-Waddress"
-bool create_glx_dummy_context(OffscreenContextGLX& ctx)
-{
-  // This will alter ctx.openGLContext and ctx.xdisplay and ctx.xwindow if successful
+bool create_glx_dummy_context(OffscreenContextGLX &ctx) {
+  // This will alter ctx.openGLContext and ctx.xdisplay and ctx.xwindow if
+  // successful
   int major;
   int minor;
   auto result = false;
@@ -208,7 +220,7 @@ bool create_glx_dummy_context(OffscreenContextGLX& ctx)
   if (ctx.xdisplay == nullptr) {
     std::cerr << "Unable to open a connection to the X server.\n";
     auto dpyenv = getenv("DISPLAY");
-    std::cerr << "DISPLAY=" << (dpyenv?dpyenv:"") << "\n";
+    std::cerr << "DISPLAY=" << (dpyenv ? dpyenv : "") << "\n";
     return false;
   }
 
@@ -223,18 +235,19 @@ bool create_glx_dummy_context(OffscreenContextGLX& ctx)
     result = create_glx_dummy_window(ctx);
   }
 
-  if (!result) XCloseDisplay(ctx.xdisplay);
+  if (!result)
+    XCloseDisplay(ctx.xdisplay);
   return result;
 }
 
-}  // namespace
+} // namespace
 
 namespace offscreen_old {
 
-std::shared_ptr<OffscreenContext> CreateOffscreenContextGLX(
-  uint32_t width, uint32_t height, uint32_t majorGLVersion,
-  uint32_t minorGLVersion, bool gles, bool compatibilityProfile)
-{
+std::shared_ptr<OffscreenContext>
+CreateOffscreenContextGLX(uint32_t width, uint32_t height,
+                          uint32_t majorGLVersion, uint32_t minorGLVersion,
+                          bool gles, bool compatibilityProfile) {
   auto ctx = std::make_shared<OffscreenContextGLX>(width, height);
 
   // before an FBO can be setup, a GLX context must be created
@@ -247,4 +260,4 @@ std::shared_ptr<OffscreenContext> CreateOffscreenContextGLX(
   return ctx;
 }
 
-}  // namespace offscreen_old
+} // namespace offscreen_old
diff --git a/src/glview/offscreen-old/OffscreenContextGLX.h b/src/glview/offscreen-old/OffscreenContextGLX.h
index ed36b43a0..d7de08e7c 100644
--- a/src/glview/offscreen-old/OffscreenContextGLX.h
+++ b/src/glview/offscreen-old/OffscreenContextGLX.h
@@ -7,8 +7,9 @@
 
 namespace offscreen_old {
 
-std::shared_ptr<OffscreenContext> CreateOffscreenContextGLX(
-  uint32_t width, uint32_t height, uint32_t majorGLVersion,
-  uint32_t minorGLVersion, bool gles, bool compatibilityProfile);
+std::shared_ptr<OffscreenContext>
+CreateOffscreenContextGLX(uint32_t width, uint32_t height,
+                          uint32_t majorGLVersion, uint32_t minorGLVersion,
+                          bool gles, bool compatibilityProfile);
 
-}  // namespace offscreen_old
+} // namespace offscreen_old
diff --git a/src/glview/offscreen-old/OffscreenContextNSOpenGL.h b/src/glview/offscreen-old/OffscreenContextNSOpenGL.h
index bb4d985ba..9f1b8f189 100644
--- a/src/glview/offscreen-old/OffscreenContextNSOpenGL.h
+++ b/src/glview/offscreen-old/OffscreenContextNSOpenGL.h
@@ -7,8 +7,9 @@
 
 namespace offscreen_old {
 
-std::shared_ptr<OffscreenContext> CreateOffscreenContextNSOpenGL(
-  uint32_t width, uint32_t height, uint32_t majorGLVersion,
-  uint32_t minorGLVersion);
+std::shared_ptr<OffscreenContext>
+CreateOffscreenContextNSOpenGL(uint32_t width, uint32_t height,
+                               uint32_t majorGLVersion,
+                               uint32_t minorGLVersion);
 
-}  // namespace offscreen_old
+} // namespace offscreen_old
diff --git a/src/glview/offscreen-old/OffscreenContextWGL.cc b/src/glview/offscreen-old/OffscreenContextWGL.cc
index 7111b0757..1f4f8fa9b 100644
--- a/src/glview/offscreen-old/OffscreenContextWGL.cc
+++ b/src/glview/offscreen-old/OffscreenContextWGL.cc
@@ -13,24 +13,23 @@
 #include "glview/offscreen-old/OffscreenContextWGL.h"
 
 #undef NOGDI
-#include <iostream>
 #include <cstdint>
+#include <iostream>
 #include <memory>
 #include <windows.h>
 
-#include <string>
-#include <sstream>
-#include "utils/printutils.h"
 #include "glview/system-gl.h"
+#include "utils/printutils.h"
 #include <GL/gl.h> // must be included after glew.h
-
+#include <sstream>
+#include <string>
 
 namespace {
 
-class OffscreenContextWGL : public OffscreenContext
-{
+class OffscreenContextWGL : public OffscreenContext {
 public:
-  OffscreenContextWGL(uint32_t width, uint32_t height) : OffscreenContext(width, height) {}
+  OffscreenContextWGL(uint32_t width, uint32_t height)
+      : OffscreenContext(width, height) {}
   ~OffscreenContextWGL() {
     wglMakeCurrent(nullptr, nullptr);
     wglDeleteContext(this->openGLContext);
@@ -55,13 +54,12 @@ public:
   HGLRC openGLContext{nullptr};
 };
 
-LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam)
-{
+LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wparam,
+                         LPARAM lparam) {
   return DefWindowProc(hwnd, message, wparam, lparam);
 }
 
-bool create_wgl_dummy_context(OffscreenContextWGL& ctx)
-{
+bool create_wgl_dummy_context(OffscreenContextWGL &ctx) {
   // this function alters ctx->window and ctx->openGLContext
   //  and ctx->dev_context if successful
 
@@ -70,7 +68,7 @@ bool create_wgl_dummy_context(OffscreenContextWGL& ctx)
 
   HINSTANCE inst = GetModuleHandleW(0);
   WNDCLASSW wc;
-  ZeroMemory(&wc, sizeof(wc) );
+  ZeroMemory(&wc, sizeof(wc));
   wc.style = CS_OWNDC;
   wc.lpfnWndProc = WndProc;
   wc.hInstance = inst;
@@ -97,8 +95,8 @@ bool create_wgl_dummy_context(OffscreenContextWGL& ctx)
   HINSTANCE hInstance = inst;
   LPVOID lpParam = nullptr;
 
-  HWND window = CreateWindowW(lpClassName, lpWindowName, dwStyle, x, y,
-                              nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
+  HWND window = CreateWindowW(lpClassName, lpWindowName, dwStyle, x, y, nWidth,
+                              nHeight, hWndParent, hMenu, hInstance, lpParam);
 
   if (window == nullptr) {
     std::cerr << "MS GDI - CreateWindow failed\n";
@@ -117,10 +115,11 @@ bool create_wgl_dummy_context(OffscreenContextWGL& ctx)
     return false;
   }
 
-  ZeroMemory(&pixformat, sizeof(pixformat) );
+  ZeroMemory(&pixformat, sizeof(pixformat));
   pixformat.nSize = sizeof(pixformat);
   pixformat.nVersion = 1;
-  pixformat.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;
+  pixformat.dwFlags =
+      PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;
   pixformat.iPixelType = PFD_TYPE_RGBA;
   pixformat.cGreenBits = 8;
   pixformat.cRedBits = 8;
@@ -158,14 +157,14 @@ bool create_wgl_dummy_context(OffscreenContextWGL& ctx)
   return true;
 }
 
-}  // namespace
+} // namespace
 
 namespace offscreen_old {
 
-std::shared_ptr<OffscreenContext> CreateOffscreenContextWGL(
-  uint32_t width, uint32_t height, uint32_t majorGLVersion,
-  uint32_t minorGLVersion, bool compatibilityProfile)
-{
+std::shared_ptr<OffscreenContext>
+CreateOffscreenContextWGL(uint32_t width, uint32_t height,
+                          uint32_t majorGLVersion, uint32_t minorGLVersion,
+                          bool compatibilityProfile) {
   auto ctx = std::make_shared<OffscreenContextWGL>(width, height);
 
   // Before an FBO can be setup, a WGL context must be created.
@@ -178,4 +177,4 @@ std::shared_ptr<OffscreenContext> CreateOffscreenContextWGL(
   return ctx;
 }
 
-}  // namespace offscreen_old
+} // namespace offscreen_old
diff --git a/src/glview/offscreen-old/OffscreenContextWGL.h b/src/glview/offscreen-old/OffscreenContextWGL.h
index 1b32a31b4..7dd617994 100644
--- a/src/glview/offscreen-old/OffscreenContextWGL.h
+++ b/src/glview/offscreen-old/OffscreenContextWGL.h
@@ -7,8 +7,9 @@
 
 namespace offscreen_old {
 
-std::shared_ptr<OffscreenContext> CreateOffscreenContextWGL(
-  uint32_t width, uint32_t height, uint32_t majorGLVersion,
-  uint32_t minorGLVersion, bool compatibilityProfile);
+std::shared_ptr<OffscreenContext>
+CreateOffscreenContextWGL(uint32_t width, uint32_t height,
+                          uint32_t majorGLVersion, uint32_t minorGLVersion,
+                          bool compatibilityProfile);
 
-}  // namespace offscreen_old
+} // namespace offscreen_old
diff --git a/src/glview/preview/CSGTreeNormalizer.cc b/src/glview/preview/CSGTreeNormalizer.cc
index a7dddaea0..91caf649c 100644
--- a/src/glview/preview/CSGTreeNormalizer.cc
+++ b/src/glview/preview/CSGTreeNormalizer.cc
@@ -1,9 +1,9 @@
 #include "glview/preview/CSGTreeNormalizer.h"
 
 #include <cassert>
-#include <utility>
 #include <memory>
 #include <stack>
+#include <utility>
 
 #include "core/CSGNode.h"
 #include "utils/printutils.h"
@@ -21,10 +21,11 @@ static bool validate_tree(const std::shared_ptr<CSGNode>& node)
 #endif
 
 /*!
-   NB! for e.g. empty intersections, this can normalize a tree to nothing and return nullptr.
+   NB! for e.g. empty intersections, this can normalize a tree to nothing and
+   return nullptr.
  */
-std::shared_ptr<CSGNode> CSGTreeNormalizer::normalize(const std::shared_ptr<CSGNode>& root)
-{
+std::shared_ptr<CSGNode>
+CSGTreeNormalizer::normalize(const std::shared_ptr<CSGNode> &root) {
   this->aborted = false;
   this->nodecount = 0;
   std::shared_ptr<CSGNode> temp = root;
@@ -39,33 +40,40 @@ std::shared_ptr<CSGNode> CSGTreeNormalizer::normalize(const std::shared_ptr<CSGN
    This will search for nullptr children an recursively repair the corresponding
    subtree.
  */
-std::shared_ptr<CSGNode> CSGTreeNormalizer::cleanup_term(std::shared_ptr<CSGNode>& t)
-{
-  if (std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation>(t)) {
-    if (op->left()) op->left() = cleanup_term(op->left());
-    if (op->right()) op->right() = cleanup_term(op->right());
+std::shared_ptr<CSGNode>
+CSGTreeNormalizer::cleanup_term(std::shared_ptr<CSGNode> &t) {
+  if (std::shared_ptr<CSGOperation> op =
+          std::dynamic_pointer_cast<CSGOperation>(t)) {
+    if (op->left())
+      op->left() = cleanup_term(op->left());
+    if (op->right())
+      op->right() = cleanup_term(op->right());
     return collapse_null_terms(op);
   }
   return t;
 }
 
-static bool isUnion(const std::shared_ptr<CSGNode>& node) {
-  std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation>(node);
+static bool isUnion(const std::shared_ptr<CSGNode> &node) {
+  std::shared_ptr<CSGOperation> op =
+      std::dynamic_pointer_cast<CSGOperation>(node);
   return op && op->getType() == OpenSCADOperator::UNION;
 }
 
-static bool hasRightNonLeaf(const std::shared_ptr<CSGNode>& node) {
-  std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation>(node);
-  return op->right() && (std::dynamic_pointer_cast<CSGLeaf>(op->right()) == nullptr);
+static bool hasRightNonLeaf(const std::shared_ptr<CSGNode> &node) {
+  std::shared_ptr<CSGOperation> op =
+      std::dynamic_pointer_cast<CSGOperation>(node);
+  return op->right() &&
+         (std::dynamic_pointer_cast<CSGLeaf>(op->right()) == nullptr);
 }
 
-static bool hasLeftUnion(const std::shared_ptr<CSGNode>& node) {
-  std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation>(node);
+static bool hasLeftUnion(const std::shared_ptr<CSGNode> &node) {
+  std::shared_ptr<CSGOperation> op =
+      std::dynamic_pointer_cast<CSGOperation>(node);
   return op && isUnion(op->left());
 }
 
-std::shared_ptr<CSGNode> CSGTreeNormalizer::normalizePass(std::shared_ptr<CSGNode> node)
-{
+std::shared_ptr<CSGNode>
+CSGTreeNormalizer::normalizePass(std::shared_ptr<CSGNode> node) {
   // This function implements the CSG normalization
   // Reference:
   // Goldfeather, J., Molnar, S., Turk, G., and Fuchs, H. Near
@@ -74,43 +82,51 @@ std::shared_ptr<CSGNode> CSGTreeNormalizer::normalizePass(std::shared_ptr<CSGNod
   // 1989.
   // http://www.cc.gatech.edu/~turk/my_papers/pxpl_csg.pdf
 
-  // Iterative tree traversal used to workaround stack limits for very large inputs.
-  // This uses dreaded goto calls but is easily verifiable to be
+  // Iterative tree traversal used to workaround stack limits for very large
+  // inputs. This uses dreaded goto calls but is easily verifiable to be
   // functionally equivalent to the original recursive function,
   // compared to the previous attempt.
   // See Issue #2883 for problem with previous iterative implementation
-  // See Pull Request #2343 for the initial reasons for making this not recursive.
+  // See Pull Request #2343 for the initial reasons for making this not
+  // recursive.
 
   // stores current node and bool indicating if it was a left or right call;
   using stackframe_t = std::pair<std::shared_ptr<CSGOperation>, bool>;
   std::stack<stackframe_t> callstack;
 
 entrypoint:
-  if (std::dynamic_pointer_cast<CSGLeaf>(node)) goto return_node;
+  if (std::dynamic_pointer_cast<CSGLeaf>(node))
+    goto return_node;
   do {
     while (node && match_and_replace(node)) {
     }
     this->nodecount++;
     if (nodecount > this->limit) {
-      LOG(message_group::Warning, "Normalized tree is growing past %1$d elements. Aborting normalization.\n", this->limit);
+      LOG(message_group::Warning,
+          "Normalized tree is growing past %1$d elements. Aborting "
+          "normalization.\n",
+          this->limit);
       this->aborted = true;
       return {};
     }
-    if (!node || std::dynamic_pointer_cast<CSGLeaf>(node)) goto return_node;
+    if (!node || std::dynamic_pointer_cast<CSGLeaf>(node))
+      goto return_node;
     goto normalize_left_if_op;
-cont_left:;
-  } while (!this->aborted && !isUnion(node) && (hasRightNonLeaf(node) || hasLeftUnion(node)));
+  cont_left:;
+  } while (!this->aborted && !isUnion(node) &&
+           (hasRightNonLeaf(node) || hasLeftUnion(node)));
 
   if (!this->aborted) {
     goto normalize_right;
-cont_right:;
+  cont_right:;
   }
 
   // FIXME: Do we need to take into account any transformation of item here?
   node = collapse_null_terms(node);
 
   if (this->aborted) {
-    if (node) node = cleanup_term(node);
+    if (node)
+      node = cleanup_term(node);
   }
 
 return_node:
@@ -130,97 +146,118 @@ return_node:
     }
   }
 normalize_left_if_op:
-  if (std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation>(node)) {
+  if (std::shared_ptr<CSGOperation> op =
+          std::dynamic_pointer_cast<CSGOperation>(node)) {
     callstack.emplace(op, true);
     node = op->left();
     goto entrypoint;
   }
   goto cont_left;
 normalize_right:
-  std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation>(node);
+  std::shared_ptr<CSGOperation> op =
+      std::dynamic_pointer_cast<CSGOperation>(node);
   assert(op);
   callstack.emplace(op, false);
   node = op->right();
   goto entrypoint;
 }
 
-std::shared_ptr<CSGNode> CSGTreeNormalizer::collapse_null_terms(const std::shared_ptr<CSGNode>& node)
-{
-  std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation>(node);
+std::shared_ptr<CSGNode>
+CSGTreeNormalizer::collapse_null_terms(const std::shared_ptr<CSGNode> &node) {
+  std::shared_ptr<CSGOperation> op =
+      std::dynamic_pointer_cast<CSGOperation>(node);
   if (op) {
     if (!op->right()) {
       this->nodecount--;
-      if (op->getType() == OpenSCADOperator::UNION || op->getType() == OpenSCADOperator::DIFFERENCE) return op->left();
-      else return op->right();
+      if (op->getType() == OpenSCADOperator::UNION ||
+          op->getType() == OpenSCADOperator::DIFFERENCE)
+        return op->left();
+      else
+        return op->right();
     }
     if (!op->left()) {
       this->nodecount--;
-      if (op->getType() == OpenSCADOperator::UNION) return op->right();
-      else return op->left();
+      if (op->getType() == OpenSCADOperator::UNION)
+        return op->right();
+      else
+        return op->left();
     }
   }
   return node;
 }
 
-bool CSGTreeNormalizer::match_and_replace(std::shared_ptr<CSGNode>& node)
-{
-  std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation>(node);
-  if (!op) return false;
-  if (op->getType() == OpenSCADOperator::UNION) return false;
+bool CSGTreeNormalizer::match_and_replace(std::shared_ptr<CSGNode> &node) {
+  std::shared_ptr<CSGOperation> op =
+      std::dynamic_pointer_cast<CSGOperation>(node);
+  if (!op)
+    return false;
+  if (op->getType() == OpenSCADOperator::UNION)
+    return false;
 
   // Part A: The 'x . (y . z)' expressions
 
-  std::shared_ptr<CSGOperation> rightop = std::dynamic_pointer_cast<CSGOperation>(op->right());
+  std::shared_ptr<CSGOperation> rightop =
+      std::dynamic_pointer_cast<CSGOperation>(op->right());
   if (rightop) {
     std::shared_ptr<CSGNode> x = op->left();
     std::shared_ptr<CSGNode> y = rightop->left();
     std::shared_ptr<CSGNode> z = rightop->right();
 
     // 1.  x - (y + z) -> (x - y) - z
-    if (op->getType() == OpenSCADOperator::DIFFERENCE && rightop->getType() == OpenSCADOperator::UNION) {
-      node = CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE,
-                                         CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, x, y),
-                                         z);
+    if (op->getType() == OpenSCADOperator::DIFFERENCE &&
+        rightop->getType() == OpenSCADOperator::UNION) {
+      node = CSGOperation::createCSGNode(
+          OpenSCADOperator::DIFFERENCE,
+          CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, x, y), z);
       return true;
     }
     // 2.  x * (y + z) -> (x * y) + (x * z)
-    else if (op->getType() == OpenSCADOperator::INTERSECTION && rightop->getType() == OpenSCADOperator::UNION) {
-      node = CSGOperation::createCSGNode(OpenSCADOperator::UNION,
-                                         CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, y),
-                                         CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, z));
+    else if (op->getType() == OpenSCADOperator::INTERSECTION &&
+             rightop->getType() == OpenSCADOperator::UNION) {
+      node = CSGOperation::createCSGNode(
+          OpenSCADOperator::UNION,
+          CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, y),
+          CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, z));
       return true;
     }
     // 3.  x - (y * z) -> (x - y) + (x - z)
-    else if (op->getType() == OpenSCADOperator::DIFFERENCE && rightop->getType() == OpenSCADOperator::INTERSECTION) {
-      node = CSGOperation::createCSGNode(OpenSCADOperator::UNION,
-                                         CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, x, y),
-                                         CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, x, z));
+    else if (op->getType() == OpenSCADOperator::DIFFERENCE &&
+             rightop->getType() == OpenSCADOperator::INTERSECTION) {
+      node = CSGOperation::createCSGNode(
+          OpenSCADOperator::UNION,
+          CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, x, y),
+          CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, x, z));
       return true;
     }
     // 4.  x * (y * z) -> (x * y) * z
-    else if (op->getType() == OpenSCADOperator::INTERSECTION && rightop->getType() == OpenSCADOperator::INTERSECTION) {
-      node = CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION,
-                                         CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, y),
-                                         z);
+    else if (op->getType() == OpenSCADOperator::INTERSECTION &&
+             rightop->getType() == OpenSCADOperator::INTERSECTION) {
+      node = CSGOperation::createCSGNode(
+          OpenSCADOperator::INTERSECTION,
+          CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, y), z);
       return true;
     }
     // 5.  x - (y - z) -> (x - y) + (x * z)
-    else if (op->getType() == OpenSCADOperator::DIFFERENCE && rightop->getType() == OpenSCADOperator::DIFFERENCE) {
-      node = CSGOperation::createCSGNode(OpenSCADOperator::UNION,
-                                         CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, x, y),
-                                         CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, z));
+    else if (op->getType() == OpenSCADOperator::DIFFERENCE &&
+             rightop->getType() == OpenSCADOperator::DIFFERENCE) {
+      node = CSGOperation::createCSGNode(
+          OpenSCADOperator::UNION,
+          CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, x, y),
+          CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, z));
       return true;
     }
     // 6.  x * (y - z) -> (x * y) - z
-    else if (op->getType() == OpenSCADOperator::INTERSECTION && rightop->getType() == OpenSCADOperator::DIFFERENCE) {
-      node = CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE,
-                                         CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, y),
-                                         z);
+    else if (op->getType() == OpenSCADOperator::INTERSECTION &&
+             rightop->getType() == OpenSCADOperator::DIFFERENCE) {
+      node = CSGOperation::createCSGNode(
+          OpenSCADOperator::DIFFERENCE,
+          CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, y), z);
       return true;
     }
   }
 
-  std::shared_ptr<CSGOperation> leftop = std::dynamic_pointer_cast<CSGOperation>(op->left());
+  std::shared_ptr<CSGOperation> leftop =
+      std::dynamic_pointer_cast<CSGOperation>(op->left());
   if (leftop) {
     // Part B: The '(x . y) . z' expressions
     std::shared_ptr<CSGNode> x = leftop->left();
@@ -228,24 +265,29 @@ bool CSGTreeNormalizer::match_and_replace(std::shared_ptr<CSGNode>& node)
     std::shared_ptr<CSGNode> z = op->right();
 
     // 7. (x - y) * z  -> (x * z) - y
-    if (leftop->getType() == OpenSCADOperator::DIFFERENCE && op->getType() == OpenSCADOperator::INTERSECTION) {
-      node = CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE,
-                                         CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, z),
-                                         y);
+    if (leftop->getType() == OpenSCADOperator::DIFFERENCE &&
+        op->getType() == OpenSCADOperator::INTERSECTION) {
+      node = CSGOperation::createCSGNode(
+          OpenSCADOperator::DIFFERENCE,
+          CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, z), y);
       return true;
     }
     // 8. (x + y) - z  -> (x - z) + (y - z)
-    else if (leftop->getType() == OpenSCADOperator::UNION && op->getType() == OpenSCADOperator::DIFFERENCE) {
-      node = CSGOperation::createCSGNode(OpenSCADOperator::UNION,
-                                         CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, x, z),
-                                         CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, y, z));
+    else if (leftop->getType() == OpenSCADOperator::UNION &&
+             op->getType() == OpenSCADOperator::DIFFERENCE) {
+      node = CSGOperation::createCSGNode(
+          OpenSCADOperator::UNION,
+          CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, x, z),
+          CSGOperation::createCSGNode(OpenSCADOperator::DIFFERENCE, y, z));
       return true;
     }
     // 9. (x + y) * z  -> (x * z) + (y * z)
-    else if (leftop->getType() == OpenSCADOperator::UNION && op->getType() == OpenSCADOperator::INTERSECTION) {
-      node = CSGOperation::createCSGNode(OpenSCADOperator::UNION,
-                                         CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, z),
-                                         CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, y, z));
+    else if (leftop->getType() == OpenSCADOperator::UNION &&
+             op->getType() == OpenSCADOperator::INTERSECTION) {
+      node = CSGOperation::createCSGNode(
+          OpenSCADOperator::UNION,
+          CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, x, z),
+          CSGOperation::createCSGNode(OpenSCADOperator::INTERSECTION, y, z));
       return true;
     }
   }
@@ -253,9 +295,10 @@ bool CSGTreeNormalizer::match_and_replace(std::shared_ptr<CSGNode>& node)
 }
 
 // Counts all non-leaf nodes
-unsigned int CSGTreeNormalizer::count(const std::shared_ptr<CSGNode>& node) const
-{
-  if (std::shared_ptr<CSGOperation> op = std::dynamic_pointer_cast<CSGOperation>(node)) {
+unsigned int
+CSGTreeNormalizer::count(const std::shared_ptr<CSGNode> &node) const {
+  if (std::shared_ptr<CSGOperation> op =
+          std::dynamic_pointer_cast<CSGOperation>(node)) {
     return 1 + count(op->left()) + count(op->right());
   }
   return 0;
diff --git a/src/glview/preview/CSGTreeNormalizer.h b/src/glview/preview/CSGTreeNormalizer.h
index 7fd02b5d1..19cb2150e 100644
--- a/src/glview/preview/CSGTreeNormalizer.h
+++ b/src/glview/preview/CSGTreeNormalizer.h
@@ -3,19 +3,20 @@
 #include <cstddef>
 #include <memory>
 
-class CSGTreeNormalizer
-{
+class CSGTreeNormalizer {
 public:
   CSGTreeNormalizer(size_t limit) : limit(limit) {}
 
-  std::shared_ptr<class CSGNode> normalize(const std::shared_ptr<CSGNode>& term);
+  std::shared_ptr<class CSGNode>
+  normalize(const std::shared_ptr<CSGNode> &term);
 
 private:
   std::shared_ptr<CSGNode> normalizePass(std::shared_ptr<CSGNode> term);
-  bool match_and_replace(std::shared_ptr<class CSGNode>& term);
-  std::shared_ptr<CSGNode> collapse_null_terms(const std::shared_ptr<CSGNode>& term);
-  std::shared_ptr<CSGNode> cleanup_term(std::shared_ptr<CSGNode>& t);
-  [[nodiscard]] unsigned int count(const std::shared_ptr<CSGNode>& term) const;
+  bool match_and_replace(std::shared_ptr<class CSGNode> &term);
+  std::shared_ptr<CSGNode>
+  collapse_null_terms(const std::shared_ptr<CSGNode> &term);
+  std::shared_ptr<CSGNode> cleanup_term(std::shared_ptr<CSGNode> &t);
+  [[nodiscard]] unsigned int count(const std::shared_ptr<CSGNode> &term) const;
 
   bool aborted{false};
   size_t limit;
diff --git a/src/glview/preview/OpenCSGRenderer.cc b/src/glview/preview/OpenCSGRenderer.cc
index a211c28e1..23a2976d6 100644
--- a/src/glview/preview/OpenCSGRenderer.cc
+++ b/src/glview/preview/OpenCSGRenderer.cc
@@ -25,17 +25,17 @@
  */
 
 #include "glview/preview/OpenCSGRenderer.h"
+#include "geometry/linalg.h"
 #include "glview/Renderer.h"
 #include "glview/ShaderUtils.h"
 #include "glview/VertexState.h"
-#include "geometry/linalg.h"
 #include "glview/system-gl.h"
 
 #include "Feature.h"
 #include <cassert>
-#include <memory>
-#include <memory.h>
 #include <cstddef>
+#include <memory.h>
+#include <memory>
 #include <utility>
 #include <vector>
 
@@ -43,18 +43,18 @@
 
 namespace {
 
-class OpenCSGVBOPrim : public OpenCSG::Primitive
-{
+class OpenCSGVBOPrim : public OpenCSG::Primitive {
 public:
   OpenCSGVBOPrim(OpenCSG::Operation operation, unsigned int convexity,
                  std::unique_ptr<VertexState> vertex_state)
-    : OpenCSG::Primitive(operation, convexity),
-    vertex_state(std::move(vertex_state)) {}
+      : OpenCSG::Primitive(operation, convexity),
+        vertex_state(std::move(vertex_state)) {}
   void render() override {
     if (vertex_state != nullptr) {
       vertex_state->draw();
     } else {
-      if (OpenSCAD::debug != "") PRINTD("OpenCSGVBOPrim vertex_state was null");
+      if (OpenSCAD::debug != "")
+        PRINTD("OpenCSGVBOPrim vertex_state was null");
     }
   }
 
@@ -65,14 +65,15 @@ private:
 // Primitive for drawing using OpenCSG
 // Makes a copy of the given VertexState enabling just unlit/uncolored vertex
 // rendering
-OpenCSGVBOPrim *createVBOPrimitive(
-  const std::shared_ptr<OpenCSGVertexState>& vertex_state,
-  const OpenCSG::Operation operation, const unsigned int convexity) {
+OpenCSGVBOPrim *
+createVBOPrimitive(const std::shared_ptr<OpenCSGVertexState> &vertex_state,
+                   const OpenCSG::Operation operation,
+                   const unsigned int convexity) {
   std::unique_ptr<VertexState> opencsg_vs = std::make_unique<VertexState>(
-    vertex_state->drawMode(), vertex_state->drawSize(),
-    vertex_state->drawType(), vertex_state->drawOffset(),
-    vertex_state->elementOffset(), vertex_state->verticesVBO(),
-    vertex_state->elementsVBO());
+      vertex_state->drawMode(), vertex_state->drawSize(),
+      vertex_state->drawType(), vertex_state->drawOffset(),
+      vertex_state->elementOffset(), vertex_state->verticesVBO(),
+      vertex_state->elementsVBO());
   // First two glBegin entries are the vertex position calls
   opencsg_vs->glBegin().insert(opencsg_vs->glBegin().begin(),
                                vertex_state->glBegin().begin(),
@@ -85,17 +86,17 @@ OpenCSGVBOPrim *createVBOPrimitive(
   return new OpenCSGVBOPrim(operation, convexity, std::move(opencsg_vs));
 }
 
-}  // namespace
+} // namespace
 
 #endif // ENABLE_OPENCSG
 
 OpenCSGRenderer::OpenCSGRenderer(
-  std::shared_ptr<CSGProducts> root_products,
-  std::shared_ptr<CSGProducts> highlights_products,
-  std::shared_ptr<CSGProducts> background_products)
-  : root_products_(std::move(root_products)),
-  highlights_products_(std::move(highlights_products)),
-  background_products_(std::move(background_products)) {
+    std::shared_ptr<CSGProducts> root_products,
+    std::shared_ptr<CSGProducts> highlights_products,
+    std::shared_ptr<CSGProducts> background_products)
+    : root_products_(std::move(root_products)),
+      highlights_products_(std::move(highlights_products)),
+      background_products_(std::move(background_products)) {
   opencsg_vertex_shader_code_ = ShaderUtils::loadShaderSource("OpenCSG.vert");
 }
 
@@ -113,18 +114,23 @@ void OpenCSGRenderer::prepare(const ShaderUtils::ShaderInfo *shaderinfo) {
   }
 }
 
-void OpenCSGRenderer::draw(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const {
+void OpenCSGRenderer::draw(bool showedges,
+                           const ShaderUtils::ShaderInfo *shaderinfo) const {
 #ifdef ENABLE_OPENCSG
   // Only use shader if select rendering or showedges
-  bool enable_shader = shaderinfo && (
-    shaderinfo->type == ShaderUtils::ShaderType::EDGE_RENDERING && showedges ||
-    shaderinfo->type == ShaderUtils::ShaderType::SELECT_RENDERING);
+  bool enable_shader =
+      shaderinfo &&
+      (shaderinfo->type == ShaderUtils::ShaderType::EDGE_RENDERING &&
+           showedges ||
+       shaderinfo->type == ShaderUtils::ShaderType::SELECT_RENDERING);
 
-  for (const auto& product : vertex_state_containers_) {
+  for (const auto &product : vertex_state_containers_) {
     if (product->primitives().size() > 1) {
 #if OPENCSG_VERSION >= 0x0180
-      if (enable_shader)OpenCSG::setVertexShader(opencsg_vertex_shader_code_);
-      else OpenCSG::setVertexShader({});
+      if (enable_shader)
+        OpenCSG::setVertexShader(opencsg_vertex_shader_code_);
+      else
+        OpenCSG::setVertexShader({});
 #endif
       GL_CHECKD(OpenCSG::render(product->primitives()));
       GL_TRACE0("glDepthFunc(GL_EQUAL)");
@@ -137,21 +143,26 @@ void OpenCSGRenderer::draw(bool showedges, const ShaderUtils::ShaderInfo *shader
       VBOUtils::shader_attribs_enable(*shaderinfo);
     }
 
-    for (const auto& vertex_state : product->states()) {
+    for (const auto &vertex_state : product->states()) {
       // Specify ID color if we're using select rendering
-      if (shaderinfo && shaderinfo->type == ShaderUtils::ShaderType::SELECT_RENDERING) {
-        if (const auto csg_vs = std::dynamic_pointer_cast<OpenCSGVertexState>(vertex_state)) {
-          GL_TRACE("glUniform3f(%d, %f, %f, %f)", shaderinfo->uniforms.at("frag_idcolor") %
-                   (((csg_vs->csgObjectIndex() >> 0) & 0xff) / 255.0f) %
-                   (((csg_vs->csgObjectIndex() >> 8) & 0xff) / 255.0f) %
-                   (((csg_vs->csgObjectIndex() >> 16) & 0xff) / 255.0f));
-          GL_CHECKD(glUniform3f(shaderinfo->uniforms.at("frag_idcolor"),
-                                ((csg_vs->csgObjectIndex() >> 0) & 0xff) / 255.0f,
-                                ((csg_vs->csgObjectIndex() >> 8) & 0xff) / 255.0f,
-                                ((csg_vs->csgObjectIndex() >> 16) & 0xff) / 255.0f));
+      if (shaderinfo &&
+          shaderinfo->type == ShaderUtils::ShaderType::SELECT_RENDERING) {
+        if (const auto csg_vs =
+                std::dynamic_pointer_cast<OpenCSGVertexState>(vertex_state)) {
+          GL_TRACE("glUniform3f(%d, %f, %f, %f)",
+                   shaderinfo->uniforms.at("frag_idcolor") %
+                       (((csg_vs->csgObjectIndex() >> 0) & 0xff) / 255.0f) %
+                       (((csg_vs->csgObjectIndex() >> 8) & 0xff) / 255.0f) %
+                       (((csg_vs->csgObjectIndex() >> 16) & 0xff) / 255.0f));
+          GL_CHECKD(
+              glUniform3f(shaderinfo->uniforms.at("frag_idcolor"),
+                          ((csg_vs->csgObjectIndex() >> 0) & 0xff) / 255.0f,
+                          ((csg_vs->csgObjectIndex() >> 8) & 0xff) / 255.0f,
+                          ((csg_vs->csgObjectIndex() >> 16) & 0xff) / 255.0f));
         }
       }
-      const auto shader_vs = std::dynamic_pointer_cast<VBOShaderVertexState>(vertex_state);
+      const auto shader_vs =
+          std::dynamic_pointer_cast<VBOShaderVertexState>(vertex_state);
       if (!shader_vs || (showedges && shader_vs)) {
         vertex_state->draw();
       }
@@ -176,27 +187,31 @@ void OpenCSGRenderer::draw(bool showedges, const ShaderUtils::ShaderInfo *shader
 // Note: This function can be called multiple times for different products.
 // Each call will add to vbo_vertex_products_.
 void OpenCSGRenderer::createCSGVBOProducts(
-  const CSGProducts& products, bool highlight_mode, bool background_mode, const ShaderUtils::ShaderInfo *shaderinfo) {
+    const CSGProducts &products, bool highlight_mode, bool background_mode,
+    const ShaderUtils::ShaderInfo *shaderinfo) {
 #ifdef ENABLE_OPENCSG
   bool enable_barycentric = true;
-  for (const auto& product : products.products) {
-    std::unique_ptr<OpenCSGVBOProduct> vertex_state_container = std::make_unique<OpenCSGVBOProduct>();
+  for (const auto &product : products.products) {
+    std::unique_ptr<OpenCSGVBOProduct> vertex_state_container =
+        std::make_unique<OpenCSGVBOProduct>();
 
     Color4f last_color;
-    std::vector<OpenCSG::Primitive *>& primitives = vertex_state_container->primitives();
-    auto& vertex_states = vertex_state_container->states();
-    VBOBuilder vbo_builder(std::make_unique<OpenCSGVertexStateFactory>(), *vertex_state_container.get());
+    std::vector<OpenCSG::Primitive *> &primitives =
+        vertex_state_container->primitives();
+    auto &vertex_states = vertex_state_container->states();
+    VBOBuilder vbo_builder(std::make_unique<OpenCSGVertexStateFactory>(),
+                           *vertex_state_container.get());
     vbo_builder.addSurfaceData();
     vbo_builder.writeSurface();
     vbo_builder.addShaderData(); // Always enable barycentric coordinates
 
     size_t num_vertices = 0;
-    for (const auto& csgobj : product.intersections) {
+    for (const auto &csgobj : product.intersections) {
       if (csgobj.leaf->polyset) {
         num_vertices += calcNumVertices(csgobj);
       }
     }
-    for (const auto& csgobj : product.subtractions) {
+    for (const auto &csgobj : product.subtractions) {
       if (csgobj.leaf->polyset) {
         num_vertices += calcNumVertices(csgobj);
       }
@@ -204,10 +219,11 @@ void OpenCSGRenderer::createCSGVBOProducts(
 
     vbo_builder.allocateBuffers(num_vertices);
 
-    for (const auto& csgobj : product.intersections) {
+    for (const auto &csgobj : product.intersections) {
       if (csgobj.leaf->polyset) {
-        const Color4f& c = csgobj.leaf->color;
-        const auto csgmode = RendererUtils::getCsgMode(highlight_mode, background_mode);
+        const Color4f &c = csgobj.leaf->color;
+        const auto csgmode =
+            RendererUtils::getCsgMode(highlight_mode, background_mode);
 
         ColorMode colormode = ColorMode::NONE;
         bool override_color;
@@ -231,33 +247,37 @@ void OpenCSGRenderer::createCSGVBOProducts(
 
         if (color.a() == 1.0f) {
           // object is opaque, draw normally
-          vbo_builder.create_surface(*csgobj.leaf->polyset,
-                                     csgobj.leaf->matrix, last_color, enable_barycentric, override_color);
+          vbo_builder.create_surface(*csgobj.leaf->polyset, csgobj.leaf->matrix,
+                                     last_color, enable_barycentric,
+                                     override_color);
           if (const auto csg_vs = std::dynamic_pointer_cast<OpenCSGVertexState>(
-                vertex_states.back())) {
+                  vertex_states.back())) {
             csg_vs->setCsgObjectIndex(csgobj.leaf->index);
             primitives.emplace_back(
-              createVBOPrimitive(csg_vs, OpenCSG::Intersection,
-                                 csgobj.leaf->polyset->getConvexity()));
+                createVBOPrimitive(csg_vs, OpenCSG::Intersection,
+                                   csgobj.leaf->polyset->getConvexity()));
           }
         } else {
           // object is transparent, so draw rear faces first.  Issue #1496
           std::shared_ptr<VertexState> cull = std::make_shared<VertexState>();
           cull->glBegin().emplace_back([]() {
-            GL_TRACE0("glEnable(GL_CULL_FACE)"); glEnable(GL_CULL_FACE);
-            GL_TRACE0("glCullFace(GL_FRONT)"); glCullFace(GL_FRONT);
+            GL_TRACE0("glEnable(GL_CULL_FACE)");
+            glEnable(GL_CULL_FACE);
+            GL_TRACE0("glCullFace(GL_FRONT)");
+            glCullFace(GL_FRONT);
           });
           vertex_states.emplace_back(std::move(cull));
 
-          vbo_builder.create_surface(*csgobj.leaf->polyset,
-                                     csgobj.leaf->matrix, last_color, enable_barycentric, override_color);
+          vbo_builder.create_surface(*csgobj.leaf->polyset, csgobj.leaf->matrix,
+                                     last_color, enable_barycentric,
+                                     override_color);
           if (const auto csg_vs = std::dynamic_pointer_cast<OpenCSGVertexState>(
-                vertex_states.back())) {
+                  vertex_states.back())) {
             csg_vs->setCsgObjectIndex(csgobj.leaf->index);
 
             primitives.emplace_back(
-              createVBOPrimitive(csg_vs, OpenCSG::Intersection,
-                                 csgobj.leaf->polyset->getConvexity()));
+                createVBOPrimitive(csg_vs, OpenCSG::Intersection,
+                                   csgobj.leaf->polyset->getConvexity()));
 
             cull = std::make_shared<VertexState>();
             cull->glBegin().emplace_back([]() {
@@ -281,11 +301,11 @@ void OpenCSGRenderer::createCSGVBOProducts(
       }
     }
 
-    for (const auto& csgobj : product.subtractions) {
+    for (const auto &csgobj : product.subtractions) {
       if (csgobj.leaf->polyset) {
-        const Color4f& c = csgobj.leaf->color;
-        const auto csgmode = RendererUtils::getCsgMode(highlight_mode, background_mode,
-                                                       OpenSCADOperator::DIFFERENCE);
+        const Color4f &c = csgobj.leaf->color;
+        const auto csgmode = RendererUtils::getCsgMode(
+            highlight_mode, background_mode, OpenSCADOperator::DIFFERENCE);
 
         ColorMode colormode = ColorMode::NONE;
         bool override_color;
@@ -320,17 +340,18 @@ void OpenCSGRenderer::createCSGVBOProducts(
         vertex_states.emplace_back(std::move(cull));
         Transform3d tmp = csgobj.leaf->matrix;
         if (csgobj.leaf->polyset->getDimension() == 2) {
-          // Scale 2D negative objects 10% in the Z direction to avoid z fighting
+          // Scale 2D negative objects 10% in the Z direction to avoid z
+          // fighting
           tmp *= Eigen::Scaling(1.0, 1.0, 1.1);
         }
-        vbo_builder.create_surface(*csgobj.leaf->polyset, tmp,
-                                   last_color, enable_barycentric, override_color);
+        vbo_builder.create_surface(*csgobj.leaf->polyset, tmp, last_color,
+                                   enable_barycentric, override_color);
         if (const auto csg_vs = std::dynamic_pointer_cast<OpenCSGVertexState>(
-              vertex_states.back())) {
+                vertex_states.back())) {
           csg_vs->setCsgObjectIndex(csgobj.leaf->index);
           primitives.emplace_back(
-            createVBOPrimitive(csg_vs, OpenCSG::Subtraction,
-                               csgobj.leaf->polyset->getConvexity()));
+              createVBOPrimitive(csg_vs, OpenCSG::Subtraction,
+                                 csgobj.leaf->polyset->getConvexity()));
         } else {
           assert(false && "Subtraction surface state was nullptr");
         }
@@ -353,7 +374,6 @@ void OpenCSGRenderer::createCSGVBOProducts(
 
     vbo_builder.createInterleavedVBOs();
     vertex_state_containers_.push_back(std::move(vertex_state_container));
-
   }
 #endif // ENABLE_OPENCSG
 }
diff --git a/src/glview/preview/OpenCSGRenderer.h b/src/glview/preview/OpenCSGRenderer.h
index 5584089b2..5a3a0875e 100644
--- a/src/glview/preview/OpenCSGRenderer.h
+++ b/src/glview/preview/OpenCSGRenderer.h
@@ -1,8 +1,8 @@
 #pragma once
 
-#include "glview/VertexState.h"
 #include "geometry/linalg.h"
 #include "glview/Renderer.h"
+#include "glview/VertexState.h"
 #include "glview/system-gl.h"
 #include <memory>
 #ifdef ENABLE_OPENCSG
@@ -16,45 +16,51 @@
 #include <string>
 #include <vector>
 
-class OpenCSGVertexState : public VertexState
-{
+class OpenCSGVertexState : public VertexState {
 public:
   OpenCSGVertexState(size_t csg_object_index = 0)
-    : csg_object_index_(csg_object_index) {}
+      : csg_object_index_(csg_object_index) {}
   OpenCSGVertexState(GLenum draw_mode, GLsizei draw_size, GLenum draw_type,
-                     size_t draw_offset, size_t element_offset, GLuint vertices_vbo, GLuint elements_vbo,
+                     size_t draw_offset, size_t element_offset,
+                     GLuint vertices_vbo, GLuint elements_vbo,
                      size_t csg_object_index = 0)
-    : VertexState(draw_mode, draw_size, draw_type, draw_offset, element_offset, vertices_vbo, elements_vbo),
-    csg_object_index_(csg_object_index) {}
+      : VertexState(draw_mode, draw_size, draw_type, draw_offset,
+                    element_offset, vertices_vbo, elements_vbo),
+        csg_object_index_(csg_object_index) {}
 
   [[nodiscard]] size_t csgObjectIndex() const { return csg_object_index_; }
-  void setCsgObjectIndex(size_t csg_object_index) { csg_object_index_ = csg_object_index; }
+  void setCsgObjectIndex(size_t csg_object_index) {
+    csg_object_index_ = csg_object_index;
+  }
 
 private:
   size_t csg_object_index_;
 };
 
-class OpenCSGVertexStateFactory : public VertexStateFactory
-{
+class OpenCSGVertexStateFactory : public VertexStateFactory {
 public:
   OpenCSGVertexStateFactory() = default;
 
-  [[nodiscard]] std::shared_ptr<VertexState> createVertexState(GLenum draw_mode, size_t draw_size, GLenum draw_type,
-                                                               size_t draw_offset, size_t element_offset,
-                                                               GLuint vertices_vbo, GLuint elements_vbo) const override {
-    return std::make_shared<OpenCSGVertexState>(draw_mode, draw_size, draw_type, draw_offset, element_offset, vertices_vbo, elements_vbo);
+  [[nodiscard]] std::shared_ptr<VertexState>
+  createVertexState(GLenum draw_mode, size_t draw_size, GLenum draw_type,
+                    size_t draw_offset, size_t element_offset,
+                    GLuint vertices_vbo, GLuint elements_vbo) const override {
+    return std::make_shared<OpenCSGVertexState>(draw_mode, draw_size, draw_type,
+                                                draw_offset, element_offset,
+                                                vertices_vbo, elements_vbo);
   }
 };
 
-class OpenCSGVBOProduct : public VertexStateContainer
-{
+class OpenCSGVBOProduct : public VertexStateContainer {
 public:
   OpenCSGVBOProduct() = default;
-  OpenCSGVBOProduct(const OpenCSGVBOProduct& o) = delete;
-  OpenCSGVBOProduct(OpenCSGVBOProduct&& o) = delete;
+  OpenCSGVBOProduct(const OpenCSGVBOProduct &o) = delete;
+  OpenCSGVBOProduct(OpenCSGVBOProduct &&o) = delete;
   virtual ~OpenCSGVBOProduct() = default;
 
-  [[nodiscard]] std::vector<OpenCSG::Primitive *>& primitives() { return primitives_; }
+  [[nodiscard]] std::vector<OpenCSG::Primitive *> &primitives() {
+    return primitives_;
+  }
 
 private:
   // primitives_ is used to create the OpenCSG depth buffer (unlit rendering).
@@ -63,19 +69,22 @@ private:
   std::vector<OpenCSG::Primitive *> primitives_;
 };
 
-class OpenCSGRenderer : public VBORenderer
-{
+class OpenCSGRenderer : public VBORenderer {
 public:
   OpenCSGRenderer(std::shared_ptr<CSGProducts> root_products,
                   std::shared_ptr<CSGProducts> highlights_products,
                   std::shared_ptr<CSGProducts> background_products);
   ~OpenCSGRenderer() override = default;
   void prepare(const ShaderUtils::ShaderInfo *shaderinfo = nullptr) override;
-  void draw(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo = nullptr) const override;
+  void draw(bool showedges,
+            const ShaderUtils::ShaderInfo *shaderinfo = nullptr) const override;
 
   BoundingBox getBoundingBox() const override;
+
 private:
-  void createCSGVBOProducts(const CSGProducts& products, bool highlight_mode, bool background_mode, const ShaderUtils::ShaderInfo *shaderinfo);
+  void createCSGVBOProducts(const CSGProducts &products, bool highlight_mode,
+                            bool background_mode,
+                            const ShaderUtils::ShaderInfo *shaderinfo);
 
   std::vector<std::unique_ptr<OpenCSGVBOProduct>> vertex_state_containers_;
   std::shared_ptr<CSGProducts> root_products_;
diff --git a/src/glview/preview/ThrownTogetherRenderer.cc b/src/glview/preview/ThrownTogetherRenderer.cc
index 82d69633f..d87913475 100644
--- a/src/glview/preview/ThrownTogetherRenderer.cc
+++ b/src/glview/preview/ThrownTogetherRenderer.cc
@@ -32,21 +32,22 @@
 
 #include <Eigen/Geometry>
 
+#include "core/CSGNode.h"
 #include "core/enums.h"
 #include "geometry/linalg.h"
-#include "glview/system-gl.h"
-#include "glview/VertexState.h"
 #include "glview/Renderer.h"
-#include "utils/printutils.h"
-#include "core/CSGNode.h"
 #include "glview/ShaderUtils.h"
 #include "glview/VBOBuilder.h"
 #include "glview/VBORenderer.h"
+#include "glview/VertexState.h"
+#include "glview/system-gl.h"
+#include "utils/printutils.h"
 
 namespace {
 
-Renderer::ColorMode getColorMode(const CSGNode::Flag& flags, bool highlight_mode,
-                                 bool background_mode, bool fberror, OpenSCADOperator type) {
+Renderer::ColorMode getColorMode(const CSGNode::Flag &flags,
+                                 bool highlight_mode, bool background_mode,
+                                 bool fberror, OpenSCADOperator type) {
   Renderer::ColorMode colormode = Renderer::ColorMode::NONE;
 
   if (highlight_mode) {
@@ -74,47 +75,60 @@ Renderer::ColorMode getColorMode(const CSGNode::Flag& flags, bool highlight_mode
   return colormode;
 }
 
-}  // namespace
+} // namespace
 
-ThrownTogetherRenderer::ThrownTogetherRenderer(std::shared_ptr<CSGProducts> root_products,
-                                               std::shared_ptr<CSGProducts> highlight_products,
-                                               std::shared_ptr<CSGProducts> background_products)
-  : root_products_(std::move(root_products)), highlight_products_(std::move(highlight_products)), background_products_(std::move(background_products))
-{
-}
+ThrownTogetherRenderer::ThrownTogetherRenderer(
+    std::shared_ptr<CSGProducts> root_products,
+    std::shared_ptr<CSGProducts> highlight_products,
+    std::shared_ptr<CSGProducts> background_products)
+    : root_products_(std::move(root_products)),
+      highlight_products_(std::move(highlight_products)),
+      background_products_(std::move(background_products)) {}
 
-void ThrownTogetherRenderer::prepare(const ShaderUtils::ShaderInfo *shaderinfo)
-{
+void ThrownTogetherRenderer::prepare(
+    const ShaderUtils::ShaderInfo *shaderinfo) {
   PRINTD("Thrown prepare");
   if (vertex_state_containers_.empty()) {
-    VertexStateContainer& vertex_state_container = vertex_state_containers_.emplace_back();
+    VertexStateContainer &vertex_state_container =
+        vertex_state_containers_.emplace_back();
 
-    VBOBuilder vbo_builder(std::make_unique<TTRVertexStateFactory>(), vertex_state_container);
+    VBOBuilder vbo_builder(std::make_unique<TTRVertexStateFactory>(),
+                           vertex_state_container);
     vbo_builder.addSurfaceData();
     vbo_builder.addShaderData(); // Always enable barycentric coordinates
 
     size_t num_vertices = 0;
-    if (this->root_products_) num_vertices += (calcNumVertices(this->root_products_, true) * 2);
-    if (this->background_products_) num_vertices += calcNumVertices(this->background_products_, true);
-    if (this->highlight_products_) num_vertices += calcNumVertices(this->highlight_products_, true);
+    if (this->root_products_)
+      num_vertices += (calcNumVertices(this->root_products_, true) * 2);
+    if (this->background_products_)
+      num_vertices += calcNumVertices(this->background_products_, true);
+    if (this->highlight_products_)
+      num_vertices += calcNumVertices(this->highlight_products_, true);
 
     vbo_builder.allocateBuffers(num_vertices);
 
-    if (this->root_products_) createCSGProducts(*this->root_products_, vertex_state_container, vbo_builder, false, false, shaderinfo);
-    if (this->background_products_) createCSGProducts(*this->background_products_, vertex_state_container, vbo_builder, false, true, shaderinfo);
-    if (this->highlight_products_) createCSGProducts(*this->highlight_products_, vertex_state_container, vbo_builder, true, false, shaderinfo);
+    if (this->root_products_)
+      createCSGProducts(*this->root_products_, vertex_state_container,
+                        vbo_builder, false, false, shaderinfo);
+    if (this->background_products_)
+      createCSGProducts(*this->background_products_, vertex_state_container,
+                        vbo_builder, false, true, shaderinfo);
+    if (this->highlight_products_)
+      createCSGProducts(*this->highlight_products_, vertex_state_container,
+                        vbo_builder, true, false, shaderinfo);
 
     vbo_builder.createInterleavedVBOs();
   }
 }
 
-
-void ThrownTogetherRenderer::draw(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const
-{
+void ThrownTogetherRenderer::draw(
+    bool showedges, const ShaderUtils::ShaderInfo *shaderinfo) const {
   // Only use shader if select rendering or showedges
-  const bool enable_shader = shaderinfo && (
-    shaderinfo->type == ShaderUtils::ShaderType::EDGE_RENDERING && showedges ||
-    shaderinfo->type == ShaderUtils::ShaderType::SELECT_RENDERING);
+  const bool enable_shader =
+      shaderinfo &&
+      (shaderinfo->type == ShaderUtils::ShaderType::EDGE_RENDERING &&
+           showedges ||
+       shaderinfo->type == ShaderUtils::ShaderType::SELECT_RENDERING);
   if (enable_shader) {
     GL_TRACE("glUseProgram(%d)", shaderinfo->resource.shader_program);
     GL_CHECKD(glUseProgram(shaderinfo->resource.shader_program));
@@ -123,23 +137,27 @@ void ThrownTogetherRenderer::draw(bool showedges, const ShaderUtils::ShaderInfo
 
   GL_TRACE0("glDepthFunc(GL_LEQUAL)");
   GL_CHECKD(glDepthFunc(GL_LEQUAL));
-  for (const auto& container : vertex_state_containers_) {
-    for (const auto& vertex_state : container.states()) {
+  for (const auto &container : vertex_state_containers_) {
+    for (const auto &vertex_state : container.states()) {
       // Specify ID color if we're using select rendering
-      if (shaderinfo && shaderinfo->type == ShaderUtils::ShaderType::SELECT_RENDERING) {
-        if (const auto ttr_vs = std::dynamic_pointer_cast<TTRVertexState>(vertex_state)) {
+      if (shaderinfo &&
+          shaderinfo->type == ShaderUtils::ShaderType::SELECT_RENDERING) {
+        if (const auto ttr_vs =
+                std::dynamic_pointer_cast<TTRVertexState>(vertex_state)) {
           GL_TRACE("glUniform3f(%d, %f, %f, %f)",
                    shaderinfo->uniforms.at("frag_idcolor") %
-                   (((ttr_vs->csgObjectIndex() >> 0) & 0xff) / 255.0f) %
-                   (((ttr_vs->csgObjectIndex() >> 8) & 0xff) / 255.0f) %
-                   (((ttr_vs->csgObjectIndex() >> 16) & 0xff) / 255.0f));
-          GL_CHECKD(glUniform3f(shaderinfo->uniforms.at("frag_idcolor"),
-                                ((ttr_vs->csgObjectIndex() >> 0) & 0xff) / 255.0f,
-                                ((ttr_vs->csgObjectIndex() >> 8) & 0xff) / 255.0f,
-                                ((ttr_vs->csgObjectIndex() >> 16) & 0xff) / 255.0f));
+                       (((ttr_vs->csgObjectIndex() >> 0) & 0xff) / 255.0f) %
+                       (((ttr_vs->csgObjectIndex() >> 8) & 0xff) / 255.0f) %
+                       (((ttr_vs->csgObjectIndex() >> 16) & 0xff) / 255.0f));
+          GL_CHECKD(
+              glUniform3f(shaderinfo->uniforms.at("frag_idcolor"),
+                          ((ttr_vs->csgObjectIndex() >> 0) & 0xff) / 255.0f,
+                          ((ttr_vs->csgObjectIndex() >> 8) & 0xff) / 255.0f,
+                          ((ttr_vs->csgObjectIndex() >> 16) & 0xff) / 255.0f));
         }
       }
-      const auto shader_vs = std::dynamic_pointer_cast<VBOShaderVertexState>(vertex_state);
+      const auto shader_vs =
+          std::dynamic_pointer_cast<VBOShaderVertexState>(vertex_state);
       if (!shader_vs || (shader_vs && showedges)) {
         vertex_state->draw();
       }
@@ -152,34 +170,39 @@ void ThrownTogetherRenderer::draw(bool showedges, const ShaderUtils::ShaderInfo
   }
 }
 
-void ThrownTogetherRenderer::createChainObject(VertexStateContainer& container, VBOBuilder& vbo_builder,
-                                               const CSGChainObject& csgobj, bool highlight_mode,
-                                               bool background_mode, OpenSCADOperator type, const ShaderUtils::ShaderInfo *shaderinfo)
-{
+void ThrownTogetherRenderer::createChainObject(
+    VertexStateContainer &container, VBOBuilder &vbo_builder,
+    const CSGChainObject &csgobj, bool highlight_mode, bool background_mode,
+    OpenSCADOperator type, const ShaderUtils::ShaderInfo *shaderinfo) {
   if (!csgobj.leaf->polyset ||
-      this->geom_visit_mark_[std::make_pair(csgobj.leaf->polyset.get(), &csgobj.leaf->matrix)]++ > 0) {
+      this->geom_visit_mark_[std::make_pair(csgobj.leaf->polyset.get(),
+                                            &csgobj.leaf->matrix)]++ > 0) {
     return;
   }
 
   const bool enable_barycentric = true;
 
-  const auto& leaf_color = csgobj.leaf->color;
+  const auto &leaf_color = csgobj.leaf->color;
 
   vbo_builder.writeSurface();
 
   Color4f color;
   if (highlight_mode || background_mode) {
-    const ColorMode colormode = getColorMode(csgobj.flags, highlight_mode, background_mode, false, type);
+    const ColorMode colormode = getColorMode(csgobj.flags, highlight_mode,
+                                             background_mode, false, type);
     getShaderColor(colormode, leaf_color, color);
 
     add_shader_pointers(vbo_builder, shaderinfo);
 
-    vbo_builder.create_surface(*csgobj.leaf->polyset, csgobj.leaf->matrix, color, enable_barycentric);
-    if (const auto ttr_vs = std::dynamic_pointer_cast<TTRVertexState>(vbo_builder.states().back())) {
+    vbo_builder.create_surface(*csgobj.leaf->polyset, csgobj.leaf->matrix,
+                               color, enable_barycentric);
+    if (const auto ttr_vs = std::dynamic_pointer_cast<TTRVertexState>(
+            vbo_builder.states().back())) {
       ttr_vs->setCsgObjectIndex(csgobj.leaf->index);
     }
   } else { // root mode
-    ColorMode colormode = getColorMode(csgobj.flags, highlight_mode, background_mode, false, type);
+    ColorMode colormode = getColorMode(csgobj.flags, highlight_mode,
+                                       background_mode, false, type);
     getShaderColor(colormode, leaf_color, color);
 
     add_shader_pointers(vbo_builder, shaderinfo);
@@ -194,18 +217,22 @@ void ThrownTogetherRenderer::createChainObject(VertexStateContainer& container,
     container.states().emplace_back(std::move(cull));
 
     Transform3d mat = csgobj.leaf->matrix;
-    if (csgobj.leaf->polyset->getDimension() == 2 && type == OpenSCADOperator::DIFFERENCE) {
+    if (csgobj.leaf->polyset->getDimension() == 2 &&
+        type == OpenSCADOperator::DIFFERENCE) {
       // Scale 2D negative objects 10% in the Z direction to avoid z fighting
       mat *= Eigen::Scaling(1.0, 1.0, 1.1);
     }
-    vbo_builder.create_surface(*csgobj.leaf->polyset, mat, color, enable_barycentric);
-    if (auto ttr_vs = std::dynamic_pointer_cast<TTRVertexState>(vbo_builder.states().back())) {
+    vbo_builder.create_surface(*csgobj.leaf->polyset, mat, color,
+                               enable_barycentric);
+    if (auto ttr_vs = std::dynamic_pointer_cast<TTRVertexState>(
+            vbo_builder.states().back())) {
       ttr_vs->setCsgObjectIndex(csgobj.leaf->index);
     }
 
     color.setRgb(1.0f, 0.0f, 1.0f); // override leaf color on front/back error
 
-    colormode = getColorMode(csgobj.flags, highlight_mode, background_mode, true, type);
+    colormode =
+        getColorMode(csgobj.flags, highlight_mode, background_mode, true, type);
     getShaderColor(colormode, leaf_color, color);
 
     add_shader_pointers(vbo_builder, shaderinfo);
@@ -217,8 +244,10 @@ void ThrownTogetherRenderer::createChainObject(VertexStateContainer& container,
     });
     container.states().emplace_back(std::move(cull));
 
-    vbo_builder.create_surface(*csgobj.leaf->polyset, csgobj.leaf->matrix, color, enable_barycentric);
-    if (auto ttr_vs = std::dynamic_pointer_cast<TTRVertexState>(vbo_builder.states().back())) {
+    vbo_builder.create_surface(*csgobj.leaf->polyset, csgobj.leaf->matrix,
+                               color, enable_barycentric);
+    if (auto ttr_vs = std::dynamic_pointer_cast<TTRVertexState>(
+            vbo_builder.states().back())) {
       ttr_vs->setCsgObjectIndex(csgobj.leaf->index);
     }
 
@@ -229,24 +258,28 @@ void ThrownTogetherRenderer::createChainObject(VertexStateContainer& container,
   }
 }
 
-void ThrownTogetherRenderer::createCSGProducts(const CSGProducts& products, VertexStateContainer& container, VBOBuilder& vbo_builder,
-                                               bool highlight_mode, bool background_mode, const ShaderUtils::ShaderInfo *shaderinfo)
-{
+void ThrownTogetherRenderer::createCSGProducts(
+    const CSGProducts &products, VertexStateContainer &container,
+    VBOBuilder &vbo_builder, bool highlight_mode, bool background_mode,
+    const ShaderUtils::ShaderInfo *shaderinfo) {
   PRINTD("Thrown renderCSGProducts");
   this->geom_visit_mark_.clear();
 
-  for (const auto& product : products.products) {
-    for (const auto& csgobj : product.intersections) {
-      createChainObject(container, vbo_builder, csgobj, highlight_mode, background_mode, OpenSCADOperator::INTERSECTION, shaderinfo);
+  for (const auto &product : products.products) {
+    for (const auto &csgobj : product.intersections) {
+      createChainObject(container, vbo_builder, csgobj, highlight_mode,
+                        background_mode, OpenSCADOperator::INTERSECTION,
+                        shaderinfo);
     }
-    for (const auto& csgobj : product.subtractions) {
-      createChainObject(container, vbo_builder, csgobj, highlight_mode, background_mode, OpenSCADOperator::DIFFERENCE, shaderinfo);
+    for (const auto &csgobj : product.subtractions) {
+      createChainObject(container, vbo_builder, csgobj, highlight_mode,
+                        background_mode, OpenSCADOperator::DIFFERENCE,
+                        shaderinfo);
     }
   }
 }
 
-BoundingBox ThrownTogetherRenderer::getBoundingBox() const
-{
+BoundingBox ThrownTogetherRenderer::getBoundingBox() const {
   BoundingBox bbox;
   if (this->root_products_) {
     bbox = this->root_products_->getBoundingBox(true);
diff --git a/src/glview/preview/ThrownTogetherRenderer.h b/src/glview/preview/ThrownTogetherRenderer.h
index dbe881493..bdda6a5a8 100644
--- a/src/glview/preview/ThrownTogetherRenderer.h
+++ b/src/glview/preview/ThrownTogetherRenderer.h
@@ -7,66 +7,79 @@
 #include "core/CSGNode.h"
 #include "core/enums.h"
 #include "geometry/linalg.h"
-#include "glview/system-gl.h"
-#include "glview/VBORenderer.h"
-#include "glview/VertexState.h"
 #include "glview/ShaderUtils.h"
 #include "glview/VBOBuilder.h"
+#include "glview/VBORenderer.h"
+#include "glview/VertexState.h"
+#include "glview/system-gl.h"
 
 class CSGProducts;
 class CSGChainObject;
 
-class TTRVertexState : public VertexState
-{
+class TTRVertexState : public VertexState {
 public:
   TTRVertexState(size_t csg_object_index = 0)
-    : csg_object_index_(csg_object_index) {}
+      : csg_object_index_(csg_object_index) {}
   TTRVertexState(GLenum draw_mode, GLsizei draw_size, GLenum draw_type,
-                 size_t draw_offset, size_t element_offset, GLuint vertices_vbo, GLuint elements_vbo,
-                 size_t csg_object_index = 0)
-    : VertexState(draw_mode, draw_size, draw_type, draw_offset, element_offset, vertices_vbo, elements_vbo), csg_object_index_(csg_object_index)
-  {}
+                 size_t draw_offset, size_t element_offset, GLuint vertices_vbo,
+                 GLuint elements_vbo, size_t csg_object_index = 0)
+      : VertexState(draw_mode, draw_size, draw_type, draw_offset,
+                    element_offset, vertices_vbo, elements_vbo),
+        csg_object_index_(csg_object_index) {}
 
   [[nodiscard]] size_t csgObjectIndex() const { return csg_object_index_; }
-  void setCsgObjectIndex(size_t csg_object_index) { csg_object_index_ = csg_object_index; }
+  void setCsgObjectIndex(size_t csg_object_index) {
+    csg_object_index_ = csg_object_index;
+  }
 
 private:
   size_t csg_object_index_;
 };
 
-class TTRVertexStateFactory : public VertexStateFactory
-{
+class TTRVertexStateFactory : public VertexStateFactory {
 public:
   TTRVertexStateFactory() = default;
 
-  [[nodiscard]] std::shared_ptr<VertexState> createVertexState(GLenum draw_mode, size_t draw_size, GLenum draw_type,
-                                                               size_t draw_offset, size_t element_offset,
-                                                               GLuint vertices_vbo, GLuint elements_vbo) const override {
-    return std::make_shared<TTRVertexState>(draw_mode, draw_size, draw_type, draw_offset, element_offset, vertices_vbo, elements_vbo);
+  [[nodiscard]] std::shared_ptr<VertexState>
+  createVertexState(GLenum draw_mode, size_t draw_size, GLenum draw_type,
+                    size_t draw_offset, size_t element_offset,
+                    GLuint vertices_vbo, GLuint elements_vbo) const override {
+    return std::make_shared<TTRVertexState>(draw_mode, draw_size, draw_type,
+                                            draw_offset, element_offset,
+                                            vertices_vbo, elements_vbo);
   }
 };
 
-class ThrownTogetherRenderer : public VBORenderer
-{
+class ThrownTogetherRenderer : public VBORenderer {
 public:
   ThrownTogetherRenderer(std::shared_ptr<CSGProducts> root_products,
                          std::shared_ptr<CSGProducts> highlight_products,
                          std::shared_ptr<CSGProducts> background_products);
   ~ThrownTogetherRenderer() override = default;
   void prepare(const ShaderUtils::ShaderInfo *shaderinfo = nullptr) override;
-  void draw(bool showedges, const ShaderUtils::ShaderInfo *shaderinfo = nullptr) const override;
+  void draw(bool showedges,
+            const ShaderUtils::ShaderInfo *shaderinfo = nullptr) const override;
 
   BoundingBox getBoundingBox() const override;
+
 private:
-  void renderCSGProducts(const std::shared_ptr<CSGProducts>& products, bool showedges = false,
+  void renderCSGProducts(const std::shared_ptr<CSGProducts> &products,
+                         bool showedges = false,
                          const ShaderUtils::ShaderInfo *shaderinfo = nullptr,
-                         bool highlight_mode = false, bool background_mode = false,
+                         bool highlight_mode = false,
+                         bool background_mode = false,
                          bool fberror = false) const;
 
-  void createCSGProducts(const CSGProducts& products, VertexStateContainer& container, VBOBuilder& vbo_builder,
-                         bool highlight_mode, bool background_mode, const ShaderUtils::ShaderInfo *shaderinfo);
-  void createChainObject(VertexStateContainer& container, VBOBuilder& vbo_builder, const CSGChainObject& csgobj,
-                         bool highlight_mode, bool background_mode, OpenSCADOperator type, const ShaderUtils::ShaderInfo *shaderinfo);
+  void createCSGProducts(const CSGProducts &products,
+                         VertexStateContainer &container,
+                         VBOBuilder &vbo_builder, bool highlight_mode,
+                         bool background_mode,
+                         const ShaderUtils::ShaderInfo *shaderinfo);
+  void createChainObject(VertexStateContainer &container,
+                         VBOBuilder &vbo_builder, const CSGChainObject &csgobj,
+                         bool highlight_mode, bool background_mode,
+                         OpenSCADOperator type,
+                         const ShaderUtils::ShaderInfo *shaderinfo);
 
   std::shared_ptr<CSGProducts> root_products_;
   std::shared_ptr<CSGProducts> highlight_products_;
diff --git a/src/glview/system-gl.cc b/src/glview/system-gl.cc
index fddc5f0fb..491a8f00b 100644
--- a/src/glview/system-gl.cc
+++ b/src/glview/system-gl.cc
@@ -13,15 +13,14 @@
 
 #include <algorithm>
 #include <iostream>
-#include <vector>
 #include <sstream>
 #include <string>
+#include <vector>
 
 #include <boost/algorithm/string.hpp>
 #include <boost/format.hpp>
 
-static double gl_version()
-{
+static double gl_version() {
   std::string tmp((const char *)glGetString(GL_VERSION));
   std::vector<std::string> strs;
   boost::split(strs, tmp, boost::is_any_of("."));
@@ -36,32 +35,30 @@ static double gl_version()
   return d;
 }
 
-std::string gl_extensions_dump()
-{
+std::string gl_extensions_dump() {
   std::string tmp;
   if (gl_version() >= 3.0) {
     GLint numexts = 0;
     glGetIntegerv(GL_NUM_EXTENSIONS, &numexts);
     for (int i = 0; i < numexts; ++i) {
-      tmp += (const char *) glGetStringi(GL_EXTENSIONS, i);
+      tmp += (const char *)glGetStringi(GL_EXTENSIONS, i);
       tmp += " ";
     }
   } else {
-    tmp = (const char *) glGetString(GL_EXTENSIONS);
+    tmp = (const char *)glGetString(GL_EXTENSIONS);
   }
   std::vector<std::string> extensions;
   boost::split(extensions, tmp, boost::is_any_of(" "));
   std::sort(extensions.begin(), extensions.end());
   std::ostringstream out;
   out << "GL Extensions:";
-  for (auto& extension : extensions) {
+  for (auto &extension : extensions) {
     out << extension << "\n";
   }
   return out.str();
 }
 
-std::string gl_dump()
-{
+std::string gl_dump() {
   GLint rbits, gbits, bbits, abits, dbits, sbits;
   glGetIntegerv(GL_RED_BITS, &rbits);
   glGetIntegerv(GL_GREEN_BITS, &gbits);
@@ -80,14 +77,13 @@ std::string gl_dump()
   out << "\nOpenGL Version: " << (const char *)glGetString(GL_VERSION)
       << "\nGL Renderer: " << (const char *)glGetString(GL_RENDERER)
       << "\nGL Vendor: " << (const char *)glGetString(GL_VENDOR)
-      << boost::format("\nRGBA(%d%d%d%d), depth(%d), stencil(%d)") %
-    rbits % gbits % bbits % abits % dbits % sbits;
+      << boost::format("\nRGBA(%d%d%d%d), depth(%d), stencil(%d)") % rbits %
+             gbits % bbits % abits % dbits % sbits;
   out << "\nGL_ARB_framebuffer_object: "
       << (hasGLExtension(ARB_framebuffer_object) ? "yes" : "no")
       << "\nGL_EXT_framebuffer_object: "
       << (hasGLExtension(EXT_framebuffer_object) ? "yes" : "no")
       << "\nGL_EXT_packed_depth_stencil: "
-      << (hasGLExtension(EXT_packed_depth_stencil) ? "yes" : "no")
-      << "\n";
+      << (hasGLExtension(EXT_packed_depth_stencil) ? "yes" : "no") << "\n";
   return out.str();
 }
diff --git a/src/glview/system-gl.h b/src/glview/system-gl.h
index 07aecfd38..455eb1812 100644
--- a/src/glview/system-gl.h
+++ b/src/glview/system-gl.h
@@ -6,42 +6,43 @@
 #include <GL/glew.h>
 #endif
 #ifdef USE_GLAD
-  #ifdef _WIN32
-  #define NORESOURCE // To avoid picking up DIFFERENCE from winuser.h, conflicting with OpenSCADOperator::DIFFERENCE
-  #include <windows.h>
-  #endif
+#ifdef _WIN32
+#define NORESOURCE // To avoid picking up DIFFERENCE from winuser.h, conflicting
+                   // with OpenSCADOperator::DIFFERENCE
+#include <windows.h>
+#endif
 #include "glad/gl.h"
 #endif
 
 #ifdef __APPLE__
- #include <OpenGL/glu.h>  // IWYU pragma: export
+#include <OpenGL/glu.h> // IWYU pragma: export
 #else
- #include <GL/glu.h>
+#include <GL/glu.h>
 #endif
 
-#include <string>
 #include "utils/printutils.h"
+#include <string>
 
 namespace {
 
 // Returns true on OK, false on error
-[[maybe_unused]] bool glCheck(const char *stmt, const char *file, int line)
-{
+[[maybe_unused]] bool glCheck(const char *stmt, const char *file, int line) {
   if (const auto err = glGetError(); err != GL_NO_ERROR) {
     LOG(message_group::Error, Location::NONE, "",
         "OpenGL error: %1$s (0x%2$04x) in %3$s:%4$d\n"
-        "              %5$s\n", gluErrorString(err), err, file, line, stmt);
+        "              %5$s\n",
+        gluErrorString(err), err, file, line, stmt);
     return false;
   }
   return true;
 }
 
 // Returns true on OK, false on error
-[[maybe_unused]] bool glCheckd(const char *stmt, const char *file, int line)
-{
+[[maybe_unused]] bool glCheckd(const char *stmt, const char *file, int line) {
   if (const auto err = glGetError(); err != GL_NO_ERROR) {
     PRINTDB("OpenGL error: %s (0x%04x) in %s:%d\n"
-            "              %s\n", gluErrorString(err) % err % file % line % stmt);
+            "              %s\n",
+            gluErrorString(err) % err % file % line % stmt);
     return false;
   }
   return true;
@@ -65,36 +66,47 @@ namespace {
 //   This is fast in release mode (executes statement only).
 
 // GL_CHECK(statement);
-// Use this for important error output causes output on error, also in release mode.
+// Use this for important error output causes output on error, also in release
+// mode.
 //
 // This example will print an error if glClear() fails:
 // GL_CHECK(glClear());
-#define GL_CHECK(stmt) stmt; glCheck(#stmt, __FILE__, __LINE__)
+#define GL_CHECK(stmt)                                                         \
+  stmt;                                                                        \
+  glCheck(#stmt, __FILE__, __LINE__)
 
 // IF_GL_CHECK(statement) then_statement;
-// Use this for important error handling which always causes an error, also in release mode
+// Use this for important error handling which always causes an error, also in
+// release mode
 //
 // This example will print an error and return false if glClear() fails:
 // IF_GL_CHECK(glClear()) return false;
-#define IF_GL_CHECK(stmt) stmt; if (!glCheck(#stmt, __FILE__, __LINE__))
+#define IF_GL_CHECK(stmt)                                                      \
+  stmt;                                                                        \
+  if (!glCheck(#stmt, __FILE__, __LINE__))
 
 // GL_CHECKD(statement);
-// Use this for OpenGL debug error output which should make it into the release build
-// Enable debug output at runtime using --enable=
-// Note: This always checks glGetError(), so it will have performance implications.
+// Use this for OpenGL debug error output which should make it into the release
+// build Enable debug output at runtime using --enable= Note: This always checks
+// glGetError(), so it will have performance implications.
 //
-// This example will print an error if glClear() fails, and if --debug is specified:
-// GL_CHECKD(glClear());
-#define GL_CHECKD(stmt) stmt; glCheckd(#stmt, __FILE__, __LINE__)
+// This example will print an error if glClear() fails, and if --debug is
+// specified: GL_CHECKD(glClear());
+#define GL_CHECKD(stmt)                                                        \
+  stmt;                                                                        \
+  glCheckd(#stmt, __FILE__, __LINE__)
 
 // GL_DEBUG_CHECKD(statement)
 // Use this for OpenGL debug output which needs to be fast in release mode
-// Debug output is only available for debug build and only when using --enable= at runtime
+// Debug output is only available for debug build and only when using --enable=
+// at runtime
 //
-// This example will print an error if glClear() fails if --debug is specified, but yields just glClear in release mode.
-// GL_DEBUG_CHECKD(glClear());
+// This example will print an error if glClear() fails if --debug is specified,
+// but yields just glClear in release mode. GL_DEBUG_CHECKD(glClear());
 #ifdef DEBUG
-#define GL_DEBUG_CHECKD(stmt) stmt; glCheckd(#stmt, __FILE__, __LINE__)
+#define GL_DEBUG_CHECKD(stmt)                                                  \
+  stmt;                                                                        \
+  glCheckd(#stmt, __FILE__, __LINE__)
 #else
 #define GL_DEBUG_CHECKD(stmt) stmt
 #endif
@@ -112,7 +124,7 @@ inline void glColor4fv(float *c) {}
 #define hasGLExtension(ext) glewIsSupported("GL_" #ext)
 #endif
 #ifdef USE_GLAD
-#define hasGLExtension(ext) GLAD_GL_ ## ext
+#define hasGLExtension(ext) GLAD_GL_##ext
 #endif
 
 std::string gl_dump();
diff --git a/src/gui/AboutDialog.h b/src/gui/AboutDialog.h
index 3f61029da..44a02d358 100644
--- a/src/gui/AboutDialog.h
+++ b/src/gui/AboutDialog.h
@@ -1,18 +1,19 @@
 #pragma once
 
+#include "gui/qtgettext.h"
+#include "ui_AboutDialog.h"
 #include "version.h"
 #include <QDialog>
 #include <QWidget>
-#include "gui/qtgettext.h"
-#include "ui_AboutDialog.h"
 
-class AboutDialog : public QDialog, public Ui::AboutDialog
-{
+class AboutDialog : public QDialog, public Ui::AboutDialog {
   Q_OBJECT;
+
 public:
   AboutDialog(QWidget *) {
     setupUi(this);
-    this->setWindowTitle(QString(_("About OpenSCAD")) + " " + openscad_shortversionnumber.c_str());
+    this->setWindowTitle(QString(_("About OpenSCAD")) + " " +
+                         openscad_shortversionnumber.c_str());
     QString tmp = this->aboutText->toHtml();
     tmp.replace("__VERSION__", openscad_detailedversionnumber.c_str());
     this->aboutText->setHtml(tmp);
diff --git a/src/gui/Animate.cc b/src/gui/Animate.cc
index 44b18e069..e81871ba4 100644
--- a/src/gui/Animate.cc
+++ b/src/gui/Animate.cc
@@ -1,38 +1,38 @@
 #include "gui/Animate.h"
 
-#include <string>
 #include <QAction>
 #include <QBoxLayout>
+#include <QFormLayout>
 #include <QIcon>
 #include <QList>
 #include <QPushButton>
 #include <QResizeEvent>
 #include <QTimer>
 #include <QWidget>
-#include <iostream>
 #include <filesystem>
-#include <QFormLayout>
+#include <iostream>
+#include <string>
 
-#include "utils/printutils.h"
 #include "gui/MainWindow.h"
 #include "gui/UIUtils.h"
 #include "openscad_gui.h"
+#include "utils/printutils.h"
 
-Animate::Animate(QWidget *parent) : QWidget(parent)
-{
+Animate::Animate(QWidget *parent) : QWidget(parent) {
   setupUi(this);
   initGUI();
 
   const auto width = groupBoxParameter->minimumSizeHint().width();
   const auto margins = layout()->contentsMargins();
-  const auto scrollMargins = scrollAreaWidgetContents->layout()->contentsMargins();
+  const auto scrollMargins =
+      scrollAreaWidgetContents->layout()->contentsMargins();
   const auto parameterMargins = groupBoxParameter->layout()->contentsMargins();
-  initMinWidth = width + margins.left() + margins.right() + scrollMargins.left() + scrollMargins.right()
-    + parameterMargins.left() + parameterMargins.right();
+  initMinWidth = width + margins.left() + margins.right() +
+                 scrollMargins.left() + scrollMargins.right() +
+                 parameterMargins.left() + parameterMargins.right();
 }
 
-void Animate::initGUI()
-{
+void Animate::initGUI() {
   this->animStep = 0;
   this->animNumSteps = 0;
   this->animTVal = 0.0;
@@ -46,14 +46,16 @@ void Animate::initGUI()
   animateTimer = new QTimer(this);
   connect(animateTimer, &QTimer::timeout, this, &Animate::incrementTVal);
 
-  connect(this->e_tval, &QLineEdit::textChanged, this, &Animate::updatedAnimTval);
-  connect(this->e_fps, &QLineEdit::textChanged, this, &Animate::updatedAnimFpsAndAnimSteps);
-  connect(this->e_fsteps, &QLineEdit::textChanged, this, &Animate::updatedAnimFpsAndAnimSteps);
+  connect(this->e_tval, &QLineEdit::textChanged, this,
+          &Animate::updatedAnimTval);
+  connect(this->e_fps, &QLineEdit::textChanged, this,
+          &Animate::updatedAnimFpsAndAnimSteps);
+  connect(this->e_fsteps, &QLineEdit::textChanged, this,
+          &Animate::updatedAnimFpsAndAnimSteps);
   connect(this->e_dump, &QCheckBox::toggled, this, &Animate::updatedAnimDump);
 }
 
-void Animate::setMainWindow(MainWindow *mainWindow)
-{
+void Animate::setMainWindow(MainWindow *mainWindow) {
   this->mainWindow = mainWindow;
 
   connectAction(this->actionAnimationPauseUnpause, pauseButton);
@@ -64,14 +66,12 @@ void Animate::setMainWindow(MainWindow *mainWindow)
   updatePauseButtonIcon();
 }
 
-void Animate::connectAction(QAction *action, QPushButton *button)
-{
+void Animate::connectAction(QAction *action, QPushButton *button) {
   connect(action, &QAction::triggered, button, &QPushButton::click);
   this->actionList.append(action);
 }
 
-void Animate::updatedAnimTval()
-{
+void Animate::updatedAnimTval() {
   double t = this->e_tval->text().toDouble(&this->tOK);
   // Clamp t to 0-1
   if (this->tOK) {
@@ -86,8 +86,7 @@ void Animate::updatedAnimTval()
   updatePauseButtonIcon();
 }
 
-void Animate::updatedAnimFpsAndAnimSteps()
-{
+void Animate::updatedAnimFpsAndAnimSteps() {
   animateTimer->stop();
 
   int numsteps = this->e_fsteps->text().toInt(&this->steps_ok);
@@ -101,7 +100,8 @@ void Animate::updatedAnimFpsAndAnimSteps()
   double fps = this->e_fps->text().toDouble(&this->fpsOK);
   animateTimer->stop();
   if (this->fpsOK && fps > 0 && this->animNumSteps > 0) {
-    this->animStep = int(this->animTVal * this->animNumSteps) % this->animNumSteps;
+    this->animStep =
+        int(this->animTVal * this->animNumSteps) % this->animNumSteps;
     animateTimer->setSingleShot(false);
     animateTimer->setInterval(int(1000 / fps));
     animateTimer->start();
@@ -109,7 +109,8 @@ void Animate::updatedAnimFpsAndAnimSteps()
 
   QPalette defaultPalette;
   const auto bgColor = defaultPalette.base().color().toRgb();
-  QString redStyleSheet = UIUtils::blendForBackgroundColorStyleSheet(bgColor, errorBlendColor);
+  QString redStyleSheet =
+      UIUtils::blendForBackgroundColorStyleSheet(bgColor, errorBlendColor);
 
   if (this->steps_ok || this->e_fsteps->text() == "") {
     this->e_fsteps->setStyleSheet("");
@@ -126,21 +127,21 @@ void Animate::updatedAnimFpsAndAnimSteps()
   updatePauseButtonIcon();
 }
 
-
-void Animate::updatedAnimDump(bool checked)
-{
-  if (!checked) this->animDumping = false;
+void Animate::updatedAnimDump(bool checked) {
+  if (!checked)
+    this->animDumping = false;
 
   updatePauseButtonIcon();
 }
 
 // Only called from animate_timer
-void Animate::incrementTVal()
-{
-  if (this->animNumSteps == 0) return;
+void Animate::incrementTVal() {
+  if (this->animNumSteps == 0)
+    return;
 
   if (mainWindow->parameterDock->isVisible()) {
-    if (mainWindow->activeEditor->parameterWidget->childHasFocus()) return;
+    if (mainWindow->activeEditor->parameterWidget->childHasFocus())
+      return;
   }
 
   if (this->animNumSteps > 1) {
@@ -157,9 +158,9 @@ void Animate::incrementTVal()
   updatePauseButtonIcon();
 }
 
-void Animate::updateTVal()
-{
-  if (this->animNumSteps == 0) return;
+void Animate::updateTVal() {
+  if (this->animNumSteps == 0)
+    return;
 
   if (this->animStep < 0) {
     this->animStep = this->animNumSteps - this->animStep - 2;
@@ -179,13 +180,12 @@ void Animate::updateTVal()
   updatePauseButtonIcon();
 }
 
-void Animate::pauseAnimation(){
+void Animate::pauseAnimation() {
   animateTimer->stop();
   updatePauseButtonIcon();
 }
 
-void Animate::on_pauseButton_pressed()
-{
+void Animate::on_pauseButton_pressed() {
   if (animateTimer->isActive()) {
     animateTimer->stop();
     updatePauseButtonIcon();
@@ -194,32 +194,30 @@ void Animate::on_pauseButton_pressed()
   }
 }
 
-void Animate::updatePauseButtonIcon()
-{
+void Animate::updatePauseButtonIcon() {
   if (animateTimer->isActive()) {
     pauseButton->setIcon(this->iconPause);
-    pauseButton->setToolTip(_("press to pause animation") );
+    pauseButton->setToolTip(_("press to pause animation"));
   } else {
     if (this->fpsOK && this->steps_ok) {
       pauseButton->setIcon(this->iconRun);
-      pauseButton->setToolTip(_("press to start animation") );
+      pauseButton->setToolTip(_("press to start animation"));
     } else {
       pauseButton->setIcon(this->iconDisabled);
-      pauseButton->setToolTip(_("incorrect values") );
+      pauseButton->setToolTip(_("incorrect values"));
     }
   }
 }
 
-void Animate::cameraChanged(){
-  this->animateUpdate(); //for now so that we do not change the behavior
+void Animate::cameraChanged() {
+  this->animateUpdate(); // for now so that we do not change the behavior
 }
 
-void Animate::editorContentChanged(){
-  this->animateUpdate(); //for now so that we do not change the behavior
+void Animate::editorContentChanged() {
+  this->animateUpdate(); // for now so that we do not change the behavior
 }
 
-void Animate::animateUpdate()
-{
+void Animate::animateUpdate() {
   if (mainWindow->animateDockContents->isVisible()) {
     double fps = this->e_fps->text().toDouble(&this->fpsOK);
     if (this->fpsOK && fps <= 0 && !animateTimer->isActive()) {
@@ -231,11 +229,11 @@ void Animate::animateUpdate()
   }
 }
 
-bool Animate::dumpPictures(){
+bool Animate::dumpPictures() {
   return this->e_dump->isChecked() && this->animateTimer->isActive();
 }
 
-int Animate::nextFrame(){
+int Animate::nextFrame() {
   if (animDumping && animDumpStartStep == animStep) {
     animDumping = false;
     e_dump->setChecked(false);
@@ -248,9 +246,9 @@ int Animate::nextFrame(){
   return animStep;
 }
 
-void Animate::resizeEvent(QResizeEvent *event)
-{
-  auto layoutParameters = dynamic_cast<QBoxLayout *>(groupBoxParameter->layout());
+void Animate::resizeEvent(QResizeEvent *event) {
+  auto layoutParameters =
+      dynamic_cast<QBoxLayout *>(groupBoxParameter->layout());
   auto layoutButtons = dynamic_cast<QBoxLayout *>(groupBoxButtons->layout());
 
   if (layoutParameters && layoutButtons) {
@@ -272,14 +270,12 @@ void Animate::resizeEvent(QResizeEvent *event)
   QWidget::resizeEvent(event);
 }
 
-const QList<QAction *>& Animate::actions(){
-  return actionList;
-}
+const QList<QAction *> &Animate::actions() { return actionList; }
 
-void Animate::onActionEvent(InputEventAction *event)
-{
+void Animate::onActionEvent(InputEventAction *event) {
   const std::string actionString = event->action;
-  const std::string actionName = actionString.substr(actionString.find("::") + 2, std::string::npos);
+  const std::string actionName =
+      actionString.substr(actionString.find("::") + 2, std::string::npos);
   for (auto action : actionList) {
     if (actionName == action->objectName().toStdString()) {
       action->trigger();
@@ -287,29 +283,27 @@ void Animate::onActionEvent(InputEventAction *event)
   }
 }
 
-double Animate::getAnimTval(){
-  return animTVal;
-}
+double Animate::getAnimTval() { return animTVal; }
 
-void Animate::on_pushButton_MoveToBeginning_clicked(){
+void Animate::on_pushButton_MoveToBeginning_clicked() {
   pauseAnimation();
   this->animStep = 0;
   this->updateTVal();
 }
 
-void Animate::on_pushButton_StepBack_clicked(){
+void Animate::on_pushButton_StepBack_clicked() {
   pauseAnimation();
   this->animStep -= 1;
   this->updateTVal();
 }
 
-void Animate::on_pushButton_StepForward_clicked(){
+void Animate::on_pushButton_StepForward_clicked() {
   pauseAnimation();
   this->animStep += 1;
   this->updateTVal();
 }
 
-void Animate::on_pushButton_MoveToEnd_clicked(){
+void Animate::on_pushButton_MoveToEnd_clicked() {
   pauseAnimation();
   this->animStep = this->animNumSteps - 1;
   this->updateTVal();
diff --git a/src/gui/Animate.h b/src/gui/Animate.h
index ea2a29094..caa642ec4 100644
--- a/src/gui/Animate.h
+++ b/src/gui/Animate.h
@@ -8,23 +8,22 @@
 #include <QWidget>
 #include <string>
 
+#include "gui/input/InputDriverEvent.h"
 #include "gui/qtgettext.h"
 #include "ui_Animate.h"
 #include <QIcon>
-#include "gui/input/InputDriverEvent.h"
 
 class MainWindow;
 
-class Animate : public QWidget, public Ui::AnimateWidget
-{
+class Animate : public QWidget, public Ui::AnimateWidget {
   Q_OBJECT
 
 public:
   Animate(QWidget *parent = nullptr);
-  Animate(const Animate& source) = delete;
-  Animate(Animate&& source) = delete;
-  Animate& operator=(const Animate& source) = delete;
-  Animate& operator=(Animate&& source) = delete;
+  Animate(const Animate &source) = delete;
+  Animate(Animate &&source) = delete;
+  Animate &operator=(const Animate &source) = delete;
+  Animate &operator=(Animate &&source) = delete;
   ~Animate() override = default;
 
   void initGUI();
@@ -35,7 +34,7 @@ public:
 
   void setMainWindow(MainWindow *mainWindow);
 
-  const QList<QAction *>& actions();
+  const QList<QAction *> &actions();
   double getAnimTval();
 
 public slots:
@@ -53,7 +52,6 @@ public slots:
 protected:
   void resizeEvent(QResizeEvent *event) override;
 
-
 private:
   MainWindow *mainWindow;
 
diff --git a/src/gui/AppleEvents.cc b/src/gui/AppleEvents.cc
index c5c0205e1..beb538d7e 100644
--- a/src/gui/AppleEvents.cc
+++ b/src/gui/AppleEvents.cc
@@ -1,21 +1,21 @@
 #include "gui/AppleEvents.h"
-#include <MacTypes.h>
+#include "gui/MainWindow.h"
 #include <AssertMacros.h>
 #include <CoreServices/CoreServices.h>
+#include <MacTypes.h>
 #include <QApplication>
-#include "gui/MainWindow.h"
 
 extern "C" {
 OSErr eventHandler(const AppleEvent *ev, AppleEvent *reply, SRefCon refcon);
 }
 
-OSErr eventHandler(const AppleEvent *, AppleEvent *, SRefCon)
-{
-// FIXME: Ugly hack; just using the first MainWindow we can find
+OSErr eventHandler(const AppleEvent *, AppleEvent *, SRefCon) {
+  // FIXME: Ugly hack; just using the first MainWindow we can find
   MainWindow *mainwin = nullptr;
-  for (auto& w : QApplication::topLevelWidgets()) {
+  for (auto &w : QApplication::topLevelWidgets()) {
     mainwin = qobject_cast<MainWindow *>(w);
-    if (mainwin) break;
+    if (mainwin)
+      break;
   }
   if (mainwin) {
     mainwin->actionReloadRenderPreview();
@@ -23,10 +23,10 @@ OSErr eventHandler(const AppleEvent *, AppleEvent *, SRefCon)
   return noErr;
 }
 
-void installAppleEventHandlers()
-{
+void installAppleEventHandlers() {
   // Reload handler
-  auto err = AEInstallEventHandler('SCAD', 'relo', NewAEEventHandlerUPP(eventHandler), nullptr, true);
+  auto err = AEInstallEventHandler(
+      'SCAD', 'relo', NewAEEventHandlerUPP(eventHandler), nullptr, true);
   __Require_noErr(err, CantInstallAppleEventHandler);
   return;
 
diff --git a/src/gui/AutoUpdater.cc b/src/gui/AutoUpdater.cc
index 92279e24c..55fed68a5 100644
--- a/src/gui/AutoUpdater.cc
+++ b/src/gui/AutoUpdater.cc
@@ -4,8 +4,7 @@
 
 AutoUpdater *AutoUpdater::updater_instance = nullptr;
 
-void AutoUpdater::init()
-{
+void AutoUpdater::init() {
 #ifdef OPENSCAD_UPDATER
   if (!this->updateAction) {
     auto mb = new QMenuBar();
@@ -14,10 +13,10 @@ void AutoUpdater::init()
     // Add to application menu
     this->updateAction->setMenuRole(QAction::ApplicationSpecificRole);
     this->updateAction->setEnabled(true);
-    this->connect(this->updateAction, &AutoUpdater::triggered, this, &AutoUpdater::checkForUpdates);
+    this->connect(this->updateAction, &AutoUpdater::triggered, this,
+                  &AutoUpdater::checkForUpdates);
 
     this->updateMenu->addAction(this->updateAction);
-
   }
 #endif // ifdef OPENSCAD_UPDATER
 }
diff --git a/src/gui/AutoUpdater.h b/src/gui/AutoUpdater.h
index 8df135493..fe10b91cc 100644
--- a/src/gui/AutoUpdater.h
+++ b/src/gui/AutoUpdater.h
@@ -1,13 +1,12 @@
 #pragma once
 
-#include <QString>
 #include <QObject>
+#include <QString>
 
 class QAction;
 class QMenu;
 
-class AutoUpdater : public QObject
-{
+class AutoUpdater : public QObject {
   Q_OBJECT;
 
 public:
@@ -26,7 +25,6 @@ public:
 public slots:
   virtual void checkForUpdates() = 0;
 
-
 public:
   QAction *updateAction{nullptr};
   QMenu *updateMenu{nullptr};
diff --git a/src/gui/CGALWorker.cc b/src/gui/CGALWorker.cc
index c229e46dc..23b937846 100644
--- a/src/gui/CGALWorker.cc
+++ b/src/gui/CGALWorker.cc
@@ -1,38 +1,34 @@
 #include "gui/CGALWorker.h"
+#include <QThread>
 #include <exception>
 #include <memory>
-#include <QThread>
 
 #ifdef ENABLE_MANIFOLD
 #include "geometry/manifold/ManifoldGeometry.h"
 #endif
 
 #include "core/Tree.h"
-#include "geometry/GeometryEvaluator.h"
 #include "core/progress.h"
-#include "utils/printutils.h"
+#include "geometry/GeometryEvaluator.h"
 #include "utils/exceptions.h"
+#include "utils/printutils.h"
 
 #ifdef ENABLE_PYTHON
 #include "python/python_public.h"
 #endif
 
-CGALWorker::CGALWorker()
-{
+CGALWorker::CGALWorker() {
   this->tree = nullptr;
   this->thread = new QThread();
-  if (this->thread->stackSize() < 1024 * 1024) this->thread->setStackSize(1024 * 1024);
+  if (this->thread->stackSize() < 1024 * 1024)
+    this->thread->setStackSize(1024 * 1024);
   connect(this->thread, &QThread::started, this, &CGALWorker::work);
   moveToThread(this->thread);
 }
 
-CGALWorker::~CGALWorker()
-{
-  delete this->thread;
-}
+CGALWorker::~CGALWorker() { delete this->thread; }
 
-void CGALWorker::start(const Tree& tree)
-{
+void CGALWorker::start(const Tree &tree) {
 #ifdef ENABLE_PYTHON
   python_unlock();
 #endif
@@ -40,9 +36,9 @@ void CGALWorker::start(const Tree& tree)
   this->thread->start();
 }
 
-void CGALWorker::work()
-{
-  // this is a worker thread: we don't want any exceptions escaping and crashing the app.
+void CGALWorker::work() {
+  // this is a worker thread: we don't want any exceptions escaping and crashing
+  // the app.
 #ifdef ENABLE_PYTHON
   python_lock();
 #endif
@@ -52,25 +48,30 @@ void CGALWorker::work()
     root_geom = evaluator.evaluateGeometry(*this->tree->root(), true);
 
 #ifdef ENABLE_MANIFOLD
-    if (auto manifold = std::dynamic_pointer_cast<const ManifoldGeometry>(root_geom)) {
+    if (auto manifold =
+            std::dynamic_pointer_cast<const ManifoldGeometry>(root_geom)) {
       // calling status forces evaluation
       // we should complete evaluation within the worker thread, so computation
       // will not block the GUI.
-      if (manifold->getManifold().Status() != manifold::Manifold::Error::NoError)LOG(message_group::Error, "Rendering cancelled due to unknown manifold error.");
+      if (manifold->getManifold().Status() !=
+          manifold::Manifold::Error::NoError)
+        LOG(message_group::Error,
+            "Rendering cancelled due to unknown manifold error.");
     }
 #endif
-  } catch (const ProgressCancelException& e) {
+  } catch (const ProgressCancelException &e) {
     LOG("Rendering cancelled.");
-  } catch (const HardWarningException& e) {
+  } catch (const HardWarningException &e) {
     LOG("Rendering cancelled on first warning.");
-  } catch (const std::exception& e) {
-    LOG(message_group::Error, "Rendering cancelled by exception %1$s", e.what());
+  } catch (const std::exception &e) {
+    LOG(message_group::Error, "Rendering cancelled by exception %1$s",
+        e.what());
   } catch (...) {
     LOG(message_group::Error, "Rendering cancelled by unknown exception.");
   }
- #ifdef ENABLE_PYTHON
+#ifdef ENABLE_PYTHON
   python_unlock();
- #endif
+#endif
   emit done(root_geom);
   thread->quit();
 }
diff --git a/src/gui/CGALWorker.h b/src/gui/CGALWorker.h
index 7bb4f85fc..b26d1114a 100644
--- a/src/gui/CGALWorker.h
+++ b/src/gui/CGALWorker.h
@@ -5,15 +5,15 @@
 
 class Tree;
 
-class CGALWorker : public QObject
-{
+class CGALWorker : public QObject {
   Q_OBJECT;
+
 public:
   CGALWorker();
   ~CGALWorker() override;
 
 public slots:
-  void start(const Tree& tree);
+  void start(const Tree &tree);
 
 protected slots:
   void work();
@@ -22,7 +22,6 @@ signals:
   void done(std::shared_ptr<const class Geometry>);
 
 protected:
-
   class QThread *thread;
   const class Tree *tree;
 };
diff --git a/src/gui/Console.cc b/src/gui/Console.cc
index d69cee757..a556f1cc1 100644
--- a/src/gui/Console.cc
+++ b/src/gui/Console.cc
@@ -26,91 +26,93 @@
 
 #include "gui/Console.h"
 
+#include "gui/MainWindow.h"
+#include "gui/Preferences.h"
+#include "gui/UIUtils.h"
+#include "utils/printutils.h"
 #include <QBrush>
 #include <QColor>
 #include <QContextMenuEvent>
+#include <QFileDialog>
+#include <QFileInfo>
 #include <QFocusEvent>
+#include <QMenu>
 #include <QPlainTextEdit>
+#include <QRegularExpression>
+#include <QString>
 #include <QStringLiteral>
 #include <QTextCharFormat>
+#include <QTextStream>
 #include <QWidget>
 #include <cassert>
-#include <QMenu>
-#include <QFileInfo>
-#include <QFileDialog>
-#include <QTextStream>
-#include <QRegularExpression>
-#include <QString>
-#include "gui/MainWindow.h"
-#include "utils/printutils.h"
-#include "gui/Preferences.h"
-#include "gui/UIUtils.h"
 
-Console::Console(QWidget *parent) : QPlainTextEdit(parent)
-{
+Console::Console(QWidget *parent) : QPlainTextEdit(parent) {
   setupUi(this);
-  connect(this->actionClear, &QAction::triggered, this, &Console::actionClearConsole_triggered);
-  connect(this->actionSaveAs, &QAction::triggered, this, &Console::actionSaveAs_triggered);
+  connect(this->actionClear, &QAction::triggered, this,
+          &Console::actionClearConsole_triggered);
+  connect(this->actionSaveAs, &QAction::triggered, this,
+          &Console::actionSaveAs_triggered);
   connect(this, &Console::linkActivated, this, &Console::hyperlinkClicked);
   this->setUndoRedoEnabled(false);
   this->appendCursor = this->textCursor();
 }
 
-void Console::focusInEvent(QFocusEvent * /*event*/)
-{
+void Console::focusInEvent(QFocusEvent * /*event*/) {
   QWidget *current = this;
   MainWindow *mw;
   while (current && !(mw = dynamic_cast<MainWindow *>(current->window()))) {
     current = current->parentWidget();
   }
   assert(mw);
-  if (mw) mw->setLastFocus(this);
+  if (mw)
+    mw->setLastFocus(this);
 }
 
-void Console::addMessage(const Message& msg)
-{
+void Console::addMessage(const Message &msg) {
   // Messages with links to source must be inserted separately,
   // since anchor href is set via the "format" argument of:
-  //    QTextCursor::insertText(const QString &text, const QTextCharFormat &format)
-  // But if no link, and matching colors, then concat message strings with newline in between.
-  // This results in less calls to insertText in Console::update(), and much better performance.
-  if (!this->msgBuffer.empty() && msg.loc.isNone() && this->msgBuffer.back().link.isEmpty() &&
-      (getGroupColor(msg.group) == getGroupColor(this->msgBuffer.back().group)) ) {
-    auto& lastmsg = this->msgBuffer.back().message;
+  //    QTextCursor::insertText(const QString &text, const QTextCharFormat
+  //    &format)
+  // But if no link, and matching colors, then concat message strings with
+  // newline in between. This results in less calls to insertText in
+  // Console::update(), and much better performance.
+  if (!this->msgBuffer.empty() && msg.loc.isNone() &&
+      this->msgBuffer.back().link.isEmpty() &&
+      (getGroupColor(msg.group) ==
+       getGroupColor(this->msgBuffer.back().group))) {
+    auto &lastmsg = this->msgBuffer.back().message;
     lastmsg += QChar('\n');
     lastmsg += QString::fromStdString(msg.str());
   } else {
     this->msgBuffer.push_back(
-    {
-      QString::fromStdString(msg.str()),
-      (getGroupTextPlain(msg.group) || msg.loc.isNone()) ?
-      QString() :
-      QString("%1,%2").arg(msg.loc.firstLine()).arg(QString::fromStdString(msg.loc.fileName())),
-      msg.group
-    }
-      );
+        {QString::fromStdString(msg.str()),
+         (getGroupTextPlain(msg.group) || msg.loc.isNone())
+             ? QString()
+             : QString("%1,%2")
+                   .arg(msg.loc.firstLine())
+                   .arg(QString::fromStdString(msg.loc.fileName())),
+         msg.group});
   }
 }
 
 // Slow due to HTML parsing required, only used for initial Console header.
-void Console::addHtml(const QString& html)
-{
+void Console::addHtml(const QString &html) {
   this->appendHtml(html + QStringLiteral("&nbsp;"));
   this->appendCursor.movePosition(QTextCursor::End);
   this->setTextCursor(this->appendCursor);
 }
 
-void Console::setFont(const QString& fontFamily, uint ptSize) {
+void Console::setFont(const QString &fontFamily, uint ptSize) {
   this->document()->setDefaultFont(QFont(fontFamily, ptSize));
 }
 
-void Console::update()
-{
+void Console::update() {
   // Faster to ignore block count until group of messages are done inserting.
   this->setMaximumBlockCount(0);
-  for (const auto& line : this->msgBuffer) {
+  for (const auto &line : this->msgBuffer) {
     QTextCharFormat charFormat;
-    if (line.group != message_group::NONE && line.group != message_group::Echo) charFormat.setForeground(QBrush(QColor("#000000")));
+    if (line.group != message_group::NONE && line.group != message_group::Echo)
+      charFormat.setForeground(QBrush(QColor("#000000")));
     charFormat.setBackground(QBrush(QColor(getGroupColor(line.group).c_str())));
     if (!line.link.isEmpty()) {
       charFormat.setAnchor(true);
@@ -120,27 +122,27 @@ void Console::update()
     // TODO insert timestamp as tooltip? (see #3570)
     //   may have to get rid of concatenation feature of Console::addMessage,
     //   or just live with grouped messages using the same timestamp
-    //charFormat.setToolTip(timestr);
+    // charFormat.setToolTip(timestr);
 
     appendCursor.insertBlock();
     appendCursor.insertText(line.message, charFormat);
   }
   msgBuffer.clear();
   this->setTextCursor(appendCursor);
-  this->setMaximumBlockCount(GlobalPreferences::inst()->getValue("advanced/consoleMaxLines").toUInt());
+  this->setMaximumBlockCount(
+      GlobalPreferences::inst()->getValue("advanced/consoleMaxLines").toUInt());
 }
 
-void Console::actionClearConsole_triggered()
-{
+void Console::actionClearConsole_triggered() {
   this->msgBuffer.clear();
   this->document()->clear();
   this->appendCursor = this->textCursor();
 }
 
-void Console::actionSaveAs_triggered()
-{
-  const auto& text = this->document()->toPlainText();
-  const auto fileName = QFileDialog::getSaveFileName(this, _("Save console content"));
+void Console::actionSaveAs_triggered() {
+  const auto &text = this->document()->toPlainText();
+  const auto fileName =
+      QFileDialog::getSaveFileName(this, _("Save console content"));
   QFile file(fileName);
   if (file.open(QIODevice::ReadWrite)) {
     QTextStream stream(&file);
@@ -150,8 +152,7 @@ void Console::actionSaveAs_triggered()
   }
 }
 
-void Console::contextMenuEvent(QContextMenuEvent *event)
-{
+void Console::contextMenuEvent(QContextMenuEvent *event) {
   // Clear leaves characterCount() at 1, not 0
   const bool hasContent = this->document()->characterCount() > 1;
   this->actionClear->setEnabled(hasContent);
@@ -164,8 +165,7 @@ void Console::contextMenuEvent(QContextMenuEvent *event)
   delete menu;
 }
 
-void Console::hyperlinkClicked(const QString& url)
-{
+void Console::hyperlinkClicked(const QString &url) {
   if (url.startsWith("http://") || url.startsWith("https://")) {
     UIUtils::openURL(url);
     return;
diff --git a/src/gui/Console.h b/src/gui/Console.h
index d822b154e..8423d7944 100644
--- a/src/gui/Console.h
+++ b/src/gui/Console.h
@@ -26,15 +26,15 @@
 
 #pragma once
 
-#include <QTextCursor>
-#include <QWidget>
-#include <QPlainTextEdit>
+#include "gui/qtgettext.h" // IWYU pragma: keep
+#include "ui_Console.h"
+#include "utils/printutils.h"
 #include <QMouseEvent>
+#include <QPlainTextEdit>
 #include <QString>
+#include <QTextCursor>
+#include <QWidget>
 #include <vector>
-#include "utils/printutils.h"
-#include "gui/qtgettext.h" // IWYU pragma: keep
-#include "ui_Console.h"
 
 struct ConsoleMessageBlock {
   QString message;
@@ -42,8 +42,7 @@ struct ConsoleMessageBlock {
   message_group group;
 };
 
-class Console : public QPlainTextEdit, public Ui::Console
-{
+class Console : public QPlainTextEdit, public Ui::Console {
   Q_OBJECT
 
 private:
@@ -56,14 +55,13 @@ public:
   QString clickedAnchor;
   void contextMenuEvent(QContextMenuEvent *event) override;
 
-  void mousePressEvent(QMouseEvent *e) override
-  {
-    clickedAnchor = (e->button() & Qt::LeftButton) ? anchorAt(e->pos()) : QString();
+  void mousePressEvent(QMouseEvent *e) override {
+    clickedAnchor =
+        (e->button() & Qt::LeftButton) ? anchorAt(e->pos()) : QString();
     QPlainTextEdit::mousePressEvent(e);
   }
 
-  void mouseReleaseEvent(QMouseEvent *e) override
-  {
+  void mouseReleaseEvent(QMouseEvent *e) override {
     if (e->button() & Qt::LeftButton && !clickedAnchor.isEmpty() &&
         anchorAt(e->pos()) == clickedAnchor) {
       emit linkActivated(clickedAnchor);
@@ -73,8 +71,8 @@ public:
   }
 
   void focusInEvent(QFocusEvent *event) override;
-  void addMessage(const Message& msg);
-  void addHtml(const QString& html);
+  void addMessage(const Message &msg);
+  void addHtml(const QString &html);
 
 signals:
   void linkActivated(QString);
@@ -83,7 +81,7 @@ signals:
 public slots:
   void actionClearConsole_triggered();
   void actionSaveAs_triggered();
-  void hyperlinkClicked(const QString& loc);
-  void setFont(const QString& fontFamily, uint ptSize);
+  void hyperlinkClicked(const QString &loc);
+  void setFont(const QString &fontFamily, uint ptSize);
   void update();
 };
diff --git a/src/gui/Dock.cc b/src/gui/Dock.cc
index f05847beb..100f31cd1 100644
--- a/src/gui/Dock.cc
+++ b/src/gui/Dock.cc
@@ -1,47 +1,38 @@
 #include "gui/Dock.h"
 
+#include "gui/QSettingsCached.h"
 #include <QDockWidget>
 #include <QWidget>
-#include "gui/QSettingsCached.h"
-
 
-Dock::Dock(QWidget *parent) : QDockWidget(parent)
-{
-  connect(this, &QDockWidget::topLevelChanged, this, &Dock::onTopLevelStatusChanged);
-  connect(this, &QDockWidget::visibilityChanged, this, &Dock::onVisibilityChanged);
+Dock::Dock(QWidget *parent) : QDockWidget(parent) {
+  connect(this, &QDockWidget::topLevelChanged, this,
+          &Dock::onTopLevelStatusChanged);
+  connect(this, &QDockWidget::visibilityChanged, this,
+          &Dock::onVisibilityChanged);
 
   dockTitleWidget = new QWidget();
 }
 
-Dock::~Dock()
-{
-  delete dockTitleWidget;
-}
+Dock::~Dock() { delete dockTitleWidget; }
 
-void Dock::disableSettingsUpdate()
-{
-  updateSettings = false;
-}
+void Dock::disableSettingsUpdate() { updateSettings = false; }
 
-void Dock::onVisibilityChanged(bool isDockVisible)
-{
+void Dock::onVisibilityChanged(bool isDockVisible) {
   if (updateSettings) {
     QSettingsCached settings;
     settings.setValue(configKey, !isVisible());
   }
 }
 
-void Dock::setTitleBarVisibility(bool isVisible)
-{
-  setTitleBarWidget(isVisible? dockTitleWidget : nullptr);
+void Dock::setTitleBarVisibility(bool isVisible) {
+  setTitleBarWidget(isVisible ? dockTitleWidget : nullptr);
 }
 
-void Dock::setConfigKey(const QString& configKey)
-{
+void Dock::setConfigKey(const QString &configKey) {
   this->configKey = configKey;
 }
 
-void Dock::updateTitle(){
+void Dock::updateTitle() {
   QString title(name);
   if (isFloating() && !namesuffix.isEmpty()) {
     title += " (" + namesuffix + ")";
@@ -49,27 +40,25 @@ void Dock::updateTitle(){
   setWindowTitle(title);
 }
 
-void Dock::setName(const QString& name_) {
+void Dock::setName(const QString &name_) {
   name = name_;
   updateTitle();
 }
 
-QString Dock::getName() const {
-  return name;
-}
+QString Dock::getName() const { return name; }
 
-void Dock::setNameSuffix(const QString& namesuffix_) {
+void Dock::setNameSuffix(const QString &namesuffix_) {
   namesuffix = namesuffix_;
   updateTitle();
 }
 
-void Dock::onTopLevelStatusChanged(bool isTopLevel)
-{
-  // update the title of the window so it contains the title suffix (in general filename)
-  // also update the flags and visibility to provide interactive feedback on the user action
-  // while it is moving the dock in topLevel=true state. The purpose of such setting
-  // on Qt::Window flag is to allow the dock to be floating behind the main window,
-  // something which isn't supported for regular QDockWidgets.
+void Dock::onTopLevelStatusChanged(bool isTopLevel) {
+  // update the title of the window so it contains the title suffix (in general
+  // filename) also update the flags and visibility to provide interactive
+  // feedback on the user action while it is moving the dock in topLevel=true
+  // state. The purpose of such setting on Qt::Window flag is to allow the dock
+  // to be floating behind the main window, something which isn't supported for
+  // regular QDockWidgets.
   Qt::WindowFlags flags = (windowFlags() & ~Qt::WindowType_Mask) | Qt::Window;
   if (isTopLevel) {
     setWindowFlags(flags);
diff --git a/src/gui/Dock.h b/src/gui/Dock.h
index 37d14df49..8974920ed 100644
--- a/src/gui/Dock.h
+++ b/src/gui/Dock.h
@@ -1,24 +1,23 @@
 #pragma once
 
-#include <QString>
 #include <QAction>
 #include <QDockWidget>
+#include <QString>
 
-class Dock : public QDockWidget
-{
+class Dock : public QDockWidget {
   Q_OBJECT
 
 public:
   Dock(QWidget *parent = nullptr);
   virtual ~Dock();
 
-  void setConfigKey(const QString& configKey);
+  void setConfigKey(const QString &configKey);
   void disableSettingsUpdate();
 
-  void setName(const QString& name_);
+  void setName(const QString &name_);
   [[nodiscard]] QString getName() const;
 
-  void setNameSuffix(const QString& namesuffix_);
+  void setNameSuffix(const QString &namesuffix_);
   void setTitleBarVisibility(bool isVisible);
   void updateTitle();
 
diff --git a/src/gui/Editor.cc b/src/gui/Editor.cc
index 20e73ad38..62f0bc041 100644
--- a/src/gui/Editor.cc
+++ b/src/gui/Editor.cc
@@ -1,16 +1,18 @@
 #include "gui/Editor.h"
-#include <QWheelEvent>
-#include <QWidget>
 #include "gui/Preferences.h"
 #include "gui/QSettingsCached.h"
+#include <QWheelEvent>
+#include <QWidget>
 
-void EditorInterface::wheelEvent(QWheelEvent *event)
-{
+void EditorInterface::wheelEvent(QWheelEvent *event) {
   QSettingsCached settings;
-  bool wheelzoom_enabled = GlobalPreferences::inst()->getValue("editor/ctrlmousewheelzoom").toBool();
+  bool wheelzoom_enabled =
+      GlobalPreferences::inst()->getValue("editor/ctrlmousewheelzoom").toBool();
   if ((event->modifiers() == Qt::ControlModifier) && wheelzoom_enabled) {
-    if (event->angleDelta().y() > 0) zoomIn();
-    else if (event->angleDelta().y() < 0) zoomOut();
+    if (event->angleDelta().y() > 0)
+      zoomIn();
+    else if (event->angleDelta().y() < 0)
+      zoomOut();
   } else {
     QWidget::wheelEvent(event);
   }
diff --git a/src/gui/Editor.h b/src/gui/Editor.h
index f91937df3..3051ea683 100644
--- a/src/gui/Editor.h
+++ b/src/gui/Editor.h
@@ -1,53 +1,58 @@
 #pragma once
 
-#include <QStringList>
+#include "core/IndicatorData.h"
+#include "gui/parameter/ParameterWidget.h"
 #include <QObject>
-#include <QString>
-#include <QWidget>
-#include <QWheelEvent>
 #include <QScrollBar>
+#include <QString>
+#include <QStringList>
 #include <QTextEdit>
-#include "core/IndicatorData.h"
-#include "gui/parameter/ParameterWidget.h"
+#include <QWheelEvent>
+#include <QWidget>
 
 #include <string>
 #include <vector>
 
-enum class EditorSelectionIndicatorStatus
-{
-  SELECTED,
-  IMPACTED
-};
+enum class EditorSelectionIndicatorStatus { SELECTED, IMPACTED };
 
-class EditorInterface : public QWidget
-{
+class EditorInterface : public QWidget {
   Q_OBJECT
 public:
   EditorInterface(QWidget *parent) : QWidget(parent) {}
-  QSize sizeHint() const override { QSize size; return size;}
-  virtual void setInitialSizeHint(const QSize&) { }
+  QSize sizeHint() const override {
+    QSize size;
+    return size;
+  }
+  virtual void setInitialSizeHint(const QSize &) {}
   void wheelEvent(QWheelEvent *) override;
   virtual QString toPlainText() = 0;
-  virtual QTextDocument *document(){auto *t = new QTextDocument; return t;}
+  virtual QTextDocument *document() {
+    auto *t = new QTextDocument;
+    return t;
+  }
   virtual QString selectedText() = 0;
-  virtual int updateFindIndicators(const QString& findText, bool visibility = true) = 0;
-  virtual bool find(const QString&, bool findNext = false, bool findBackwards = false) = 0;
-  virtual void replaceSelectedText(const QString& newText) = 0;
-  virtual void replaceAll(const QString& findText, const QString& replaceText) = 0;
+  virtual int updateFindIndicators(const QString &findText,
+                                   bool visibility = true) = 0;
+  virtual bool find(const QString &, bool findNext = false,
+                    bool findBackwards = false) = 0;
+  virtual void replaceSelectedText(const QString &newText) = 0;
+  virtual void replaceAll(const QString &findText,
+                          const QString &replaceText) = 0;
   virtual QStringList colorSchemes() = 0;
   virtual bool canUndo() = 0;
   virtual void addTemplate() = 0;
   virtual void resetHighlighting() = 0;
-  virtual void setIndicator(const std::vector<IndicatorData>& indicatorData) = 0;
+  virtual void
+  setIndicator(const std::vector<IndicatorData> &indicatorData) = 0;
   virtual QMenu *createStandardContextMenu() = 0;
-  virtual QPoint mapToGlobal(const QPoint&) = 0;
+  virtual QPoint mapToGlobal(const QPoint &) = 0;
   virtual void setCursorPosition(int /*line*/, int /*col*/) {}
   virtual void setFocus() = 0;
 
 signals:
   void contentsChanged();
   void modificationChanged(EditorInterface *);
-  void showContextMenuEvent(const QPoint& pos);
+  void showContextMenuEvent(const QPoint &pos);
   void focusIn();
   void escapePressed();
 
@@ -60,20 +65,23 @@ public slots:
   virtual void unindentSelection() = 0;
   virtual void commentSelection() = 0;
   virtual void uncommentSelection() = 0;
-  virtual void setPlainText(const QString&) = 0;
-  virtual void setSelectionIndicatorStatus(EditorSelectionIndicatorStatus status, int level, int lineFrom, int colFrom, int lineTo, int colTo) = 0;
+  virtual void setPlainText(const QString &) = 0;
+  virtual void
+  setSelectionIndicatorStatus(EditorSelectionIndicatorStatus status, int level,
+                              int lineFrom, int colFrom, int lineTo,
+                              int colTo) = 0;
   virtual void clearAllSelectionIndicators() = 0;
   virtual void highlightError(int) = 0;
   virtual void unhighlightLastError() = 0;
-  virtual void setHighlightScheme(const QString&) = 0;
-  virtual void insert(const QString&) = 0;
-  virtual void setText(const QString&) = 0;
+  virtual void setHighlightScheme(const QString &) = 0;
+  virtual void insert(const QString &) = 0;
+  virtual void setText(const QString &) = 0;
   virtual void undo() = 0;
   virtual void redo() = 0;
   virtual void cut() = 0;
   virtual void copy() = 0;
   virtual void paste() = 0;
-  virtual void initFont(const QString&, uint) = 0;
+  virtual void initFont(const QString &, uint) = 0;
   virtual void displayTemplates() = 0;
   virtual void foldUnfold() = 0;
   virtual void toggleBookmark() = 0;
@@ -85,7 +93,8 @@ private:
   QSize initialSizeHint;
 
 public:
-  bool contentsRendered; // Set if the source code has changes since the last render (F6)
+  bool contentsRendered; // Set if the source code has changes since the last
+                         // render (F6)
   int findState;
   QString filepath;
   std::string autoReloadId;
diff --git a/src/gui/ErrorLog.cc b/src/gui/ErrorLog.cc
index 962f0b57b..fb6a44036 100644
--- a/src/gui/ErrorLog.cc
+++ b/src/gui/ErrorLog.cc
@@ -10,16 +10,16 @@
 #include <QWidget>
 #include <filesystem>
 
-ErrorLog::ErrorLog(QWidget *parent) : QWidget(parent)
-{
+ErrorLog::ErrorLog(QWidget *parent) : QWidget(parent) {
   setupUi(this);
   initGUI();
 }
 
-void ErrorLog::initGUI()
-{
+void ErrorLog::initGUI() {
   row = 0;
-  QList<QString> labels = QList<QString>() << QString("Group") << QString("File") << QString("Line") << QString("Info");
+  QList<QString> labels = QList<QString>()
+                          << QString("Group") << QString("File")
+                          << QString("Line") << QString("Info");
 
   const int numColumns = labels.count();
   this->errorLogModel = new QStandardItemModel(row, numColumns, logTable);
@@ -32,40 +32,46 @@ void ErrorLog::initGUI()
   logTable->setColumnWidth(errorLog_column::file, 200);
   logTable->setColumnWidth(errorLog_column::lineNo, 80);
   logTable->addAction(actionRowSelected);
-  //last column will stretch itself
+  // last column will stretch itself
 
-  connect(logTable->horizontalHeader(), &QHeaderView::sectionResized, this, &ErrorLog::onSectionResized);
+  connect(logTable->horizontalHeader(), &QHeaderView::sectionResized, this,
+          &ErrorLog::onSectionResized);
 }
 
-void ErrorLog::toErrorLog(const Message& logMsg)
-{
+void ErrorLog::toErrorLog(const Message &logMsg) {
   lastMessages.push_back(logMsg);
   QString currGroup = errorLogComboBox->currentText();
 
-  //handle combobox
-  if (errorLogComboBox->currentIndex() == 0);
-  else if (currGroup.toStdString() != getGroupName(logMsg.group)) return;
+  // handle combobox
+  if (errorLogComboBox->currentIndex() == 0)
+    ;
+  else if (currGroup.toStdString() != getGroupName(logMsg.group))
+    return;
 
   showtheErrorInGUI(logMsg);
 }
 
-void ErrorLog::showtheErrorInGUI(const Message& logMsg)
-{
-  auto *groupName = new QStandardItem(QString::fromStdString(getGroupName(logMsg.group)));
+void ErrorLog::showtheErrorInGUI(const Message &logMsg) {
+  auto *groupName =
+      new QStandardItem(QString::fromStdString(getGroupName(logMsg.group)));
   groupName->setEditable(false);
 
-  if (logMsg.group == message_group::Error) groupName->setForeground(QColor::fromRgb(255, 0, 0)); //make this item red.
-  else if (logMsg.group == message_group::Warning) groupName->setForeground(QColor::fromRgb(252, 211, 3)); //make this item yellow
+  if (logMsg.group == message_group::Error)
+    groupName->setForeground(QColor::fromRgb(255, 0, 0)); // make this item red.
+  else if (logMsg.group == message_group::Warning)
+    groupName->setForeground(
+        QColor::fromRgb(252, 211, 3)); // make this item yellow
 
   errorLogModel->setItem(row, errorLog_column::group, groupName);
 
   QStandardItem *fileName;
   QStandardItem *lineNo;
   if (!logMsg.loc.isNone()) {
-    const auto& filePath = logMsg.loc.filePath();
+    const auto &filePath = logMsg.loc.filePath();
     if (is_regular_file(filePath)) {
       const auto path = QString::fromStdString(filePath.generic_string());
-      fileName = new QStandardItem(QString::fromStdString(filePath.filename().generic_string()));
+      fileName = new QStandardItem(
+          QString::fromStdString(filePath.filename().generic_string()));
       fileName->setToolTip(path);
       fileName->setData(path, Qt::UserRole);
     } else {
@@ -94,38 +100,32 @@ void ErrorLog::showtheErrorInGUI(const Message& logMsg)
   }
 }
 
-void ErrorLog::resize()
-{
-  logTable->resizeRowsToContents();
-}
+void ErrorLog::resize() { logTable->resizeRowsToContents(); }
 
-void ErrorLog::onSectionResized(int /*logicalIndex*/, int /*oldSize*/, int /*newSize*/){
+void ErrorLog::onSectionResized(int /*logicalIndex*/, int /*oldSize*/,
+                                int /*newSize*/) {
   this->resize();
 }
 
-void ErrorLog::resizeEvent(QResizeEvent *event)
-{
+void ErrorLog::resizeEvent(QResizeEvent *event) {
   QWidget::resizeEvent(event);
   this->resize();
 }
 
-void ErrorLog::clearModel()
-{
+void ErrorLog::clearModel() {
   errorLogModel->clear();
   initGUI();
   lastMessages.clear();
 }
 
-int ErrorLog::getLine(int row, int col)
-{
+int ErrorLog::getLine(int row, int col) {
   return logTable->model()->index(row, col).data().toInt();
 }
 
-void ErrorLog::on_errorLogComboBox_currentTextChanged(const QString& group)
-{
+void ErrorLog::on_errorLogComboBox_currentTextChanged(const QString &group) {
   errorLogModel->clear();
   initGUI();
-  for (auto& lastMessage : lastMessages) {
+  for (auto &lastMessage : lastMessages) {
     if (group == QString::fromStdString("All") ||
         group == QString::fromStdString(getGroupName(lastMessage.group))) {
       showtheErrorInGUI(lastMessage);
@@ -133,25 +133,25 @@ void ErrorLog::on_errorLogComboBox_currentTextChanged(const QString& group)
   }
 }
 
-void ErrorLog::on_logTable_doubleClicked(const QModelIndex& index)
-{
+void ErrorLog::on_logTable_doubleClicked(const QModelIndex &index) {
   onIndexSelected(index);
 }
 
-void ErrorLog::on_actionRowSelected_triggered(bool)
-{
+void ErrorLog::on_actionRowSelected_triggered(bool) {
   const auto indexes = logTable->selectionModel()->selectedRows(0);
   if (indexes.size() == 1) {
     onIndexSelected(indexes.first());
   }
 }
 
-void ErrorLog::onIndexSelected(const QModelIndex& index)
-{
+void ErrorLog::onIndexSelected(const QModelIndex &index) {
   if (index.isValid()) {
     const int r = index.row();
     const int line = getLine(r, errorLog_column::lineNo);
-    const auto path = logTable->model()->index(r, errorLog_column::file).data(Qt::UserRole).toString();
+    const auto path = logTable->model()
+                          ->index(r, errorLog_column::file)
+                          .data(Qt::UserRole)
+                          .toString();
     emit openFile(path, line - 1);
   }
 }
diff --git a/src/gui/ErrorLog.h b/src/gui/ErrorLog.h
index 485ae90a9..5fecc2b6e 100644
--- a/src/gui/ErrorLog.h
+++ b/src/gui/ErrorLog.h
@@ -6,28 +6,25 @@
 #include <QHash>
 #include <QModelIndex>
 #include <QResizeEvent>
+#include <QStandardItemModel>
 #include <QWidget>
 #include <list>
-#include <QStandardItemModel>
 
-enum errorLog_column {
-  group = 0, file, lineNo, message
-};
+enum errorLog_column { group = 0, file, lineNo, message };
 
-class ErrorLog : public QWidget, public Ui::errorLogWidget
-{
+class ErrorLog : public QWidget, public Ui::errorLogWidget {
   Q_OBJECT
 
 public:
   ErrorLog(QWidget *parent = nullptr);
-  ErrorLog(const ErrorLog& source) = delete;
-  ErrorLog(ErrorLog&& source) = delete;
-  ErrorLog& operator=(const ErrorLog& source) = delete;
-  ErrorLog& operator=(ErrorLog&& source) = delete;
+  ErrorLog(const ErrorLog &source) = delete;
+  ErrorLog(ErrorLog &&source) = delete;
+  ErrorLog &operator=(const ErrorLog &source) = delete;
+  ErrorLog &operator=(ErrorLog &&source) = delete;
   ~ErrorLog() override = default;
   void initGUI();
-  void toErrorLog(const Message& logMsg);
-  void showtheErrorInGUI(const Message& logMsg);
+  void toErrorLog(const Message &logMsg);
+  void showtheErrorInGUI(const Message &logMsg);
   void clearModel();
   int getLine(int row, int col);
   QStandardItemModel *errorLogModel;
@@ -38,7 +35,7 @@ protected:
   void resizeEvent(QResizeEvent *event) override;
 
 private:
-  void onIndexSelected(const QModelIndex& index);
+  void onIndexSelected(const QModelIndex &index);
   void resize();
 
 private:
@@ -48,8 +45,8 @@ signals:
   void openFile(const QString, int);
 
 private slots:
-  void on_logTable_doubleClicked(const QModelIndex& index);
-  void on_errorLogComboBox_currentTextChanged(const QString& arg1);
+  void on_logTable_doubleClicked(const QModelIndex &index);
+  void on_errorLogComboBox_currentTextChanged(const QString &arg1);
   void on_actionRowSelected_triggered(bool);
   void onSectionResized(int, int, int);
 };
diff --git a/src/gui/EventFilter.h b/src/gui/EventFilter.h
index d172b7545..eab13ae3c 100644
--- a/src/gui/EventFilter.h
+++ b/src/gui/EventFilter.h
@@ -1,22 +1,22 @@
 #pragma once
 
-#include <QObject>
-#include <QFileOpenEvent>
-#include "gui/OpenSCADApp.h"
 #include "gui/LaunchingScreen.h"
+#include "gui/OpenSCADApp.h"
+#include <QFileOpenEvent>
+#include <QObject>
 
-class SCADEventFilter : public QObject
-{
+class SCADEventFilter : public QObject {
   Q_OBJECT;
 
 public:
   SCADEventFilter(QObject *parent) : QObject(parent) {}
+
 protected:
   bool eventFilter(QObject *obj, QEvent *event) override {
     // Handle Apple event for opening files, only available on OS X
     if (event->type() == QEvent::FileOpen) {
       QFileOpenEvent *foe = static_cast<QFileOpenEvent *>(event);
-      const QString& filename = foe->file();
+      const QString &filename = foe->file();
       if (LaunchingScreen *ls = LaunchingScreen::getDialog()) {
         // We need to invoke the method since, apparently, we receive
         // this event in another thread.
diff --git a/src/gui/Export3mfDialog.cc b/src/gui/Export3mfDialog.cc
index ed3392975..f4ced9ea1 100644
--- a/src/gui/Export3mfDialog.cc
+++ b/src/gui/Export3mfDialog.cc
@@ -26,61 +26,72 @@
 
 #include "gui/Export3mfDialog.h"
 
-#include <string>
-#include <QString>
 #include <QCheckBox>
 #include <QColor>
-#include <QDialog>
 #include <QColorDialog>
+#include <QDialog>
 #include <QLineEdit>
+#include <QString>
+#include <string>
 
-#include "io/export.h"
-#include "io/lib3mf_utils.h"
 #include "core/Settings.h"
-#include "gui/UIUtils.h"
 #include "gui/SettingsWriter.h"
+#include "gui/UIUtils.h"
+#include "io/export.h"
+#include "io/lib3mf_utils.h"
 
 using S = Settings::SettingsExport3mf;
 using SEBool = Settings::SettingsEntryBool;
 using SEString = Settings::SettingsEntryString;
 
-Export3mfDialog::Export3mfDialog()
-{
+Export3mfDialog::Export3mfDialog() {
   setupUi(this);
-  this->checkBoxAlwaysShowDialog->setChecked(S::export3mfAlwaysShowDialog.value());
+  this->checkBoxAlwaysShowDialog->setChecked(
+      S::export3mfAlwaysShowDialog.value());
   initButtonGroup(this->buttonGroupColors, S::export3mfColorMode);
   initButtonGroup(this->buttonGroupUnit, S::export3mfUnit);
   this->color = QColor(QString::fromStdString(S::export3mfColor.value()));
-  this->labelColorsSelected->setStyleSheet(UIUtils::getBackgroundColorStyleSheet(this->color));
+  this->labelColorsSelected->setStyleSheet(
+      UIUtils::getBackgroundColorStyleSheet(this->color));
   this->spinBoxDecimalPrecision->setValue(S::export3mfDecimalPrecision.value());
   initComboBox(this->comboBoxMaterialType, S::export3mfMaterialType);
 
   groupMetaData->setChecked(S::export3mfAddMetaData.value());
-  initMetaData(nullptr, this->lineEditMetaDataTitle, nullptr, S::export3mfMetaDataTitle);
-  initMetaData(this->checkBoxMetaDataDesigner, this->lineEditMetaDataDesigner, &S::export3mfAddMetaDataDesigner, S::export3mfMetaDataDesigner);
-  initMetaData(this->checkBoxMetaDataDescription, this->lineEditMetaDataDescription, &S::export3mfAddMetaDataDescription, S::export3mfMetaDataDescription);
-  initMetaData(this->checkBoxMetaDataCopyright, this->lineEditMetaDataCopyright, &S::export3mfAddMetaDataCopyright, S::export3mfMetaDataCopyright);
-  initMetaData(this->checkBoxMetaDataLicenseTerms, this->lineEditMetaDataLicenseTerms, &S::export3mfAddMetaDataLicenseTerms, S::export3mfMetaDataLicenseTerms);
-  initMetaData(this->checkBoxMetaDataRating, this->lineEditMetaDataRating, &S::export3mfAddMetaDataRating, S::export3mfMetaDataRating);
+  initMetaData(nullptr, this->lineEditMetaDataTitle, nullptr,
+               S::export3mfMetaDataTitle);
+  initMetaData(this->checkBoxMetaDataDesigner, this->lineEditMetaDataDesigner,
+               &S::export3mfAddMetaDataDesigner, S::export3mfMetaDataDesigner);
+  initMetaData(
+      this->checkBoxMetaDataDescription, this->lineEditMetaDataDescription,
+      &S::export3mfAddMetaDataDescription, S::export3mfMetaDataDescription);
+  initMetaData(this->checkBoxMetaDataCopyright, this->lineEditMetaDataCopyright,
+               &S::export3mfAddMetaDataCopyright,
+               S::export3mfMetaDataCopyright);
+  initMetaData(
+      this->checkBoxMetaDataLicenseTerms, this->lineEditMetaDataLicenseTerms,
+      &S::export3mfAddMetaDataLicenseTerms, S::export3mfMetaDataLicenseTerms);
+  initMetaData(this->checkBoxMetaDataRating, this->lineEditMetaDataRating,
+               &S::export3mfAddMetaDataRating, S::export3mfMetaDataRating);
 
   const auto library_version = get_lib3mf_version();
   if (library_version.compare(0, 2, "1.") == 0) {
     this->spinBoxDecimalPrecision->setEnabled(false);
     this->toolButtonDecimalPrecisionReset->setEnabled(false);
     this->labelDecimalPrecision->setEnabled(false);
-    this->spinBoxDecimalPrecision->setToolTip(_("This OpenSCAD build uses lib3mf version 1. Setting the decimal precision for export needs version 2 or later."));
+    this->spinBoxDecimalPrecision->setToolTip(
+        _("This OpenSCAD build uses lib3mf version 1. Setting the decimal "
+          "precision for export needs version 2 or later."));
     this->toolButtonDecimalPrecisionReset->setToolTip("");
   }
 }
 
-void Export3mfDialog::updateColor(const QColor& color)
-{
+void Export3mfDialog::updateColor(const QColor &color) {
   this->color = color;
-  this->labelColorsSelected->setStyleSheet(UIUtils::getBackgroundColorStyleSheet(this->color));
+  this->labelColorsSelected->setStyleSheet(
+      UIUtils::getBackgroundColorStyleSheet(this->color));
 }
 
-int Export3mfDialog::exec()
-{
+int Export3mfDialog::exec() {
   bool showDialog = this->checkBoxAlwaysShowDialog->isChecked();
   if ((QApplication::keyboardModifiers() & Qt::ShiftModifier) != 0) {
     showDialog = true;
@@ -89,36 +100,47 @@ int Export3mfDialog::exec()
   const auto result = showDialog ? QDialog::exec() : QDialog::Accepted;
 
   if (result == QDialog::Accepted) {
-    S::export3mfAlwaysShowDialog.setValue(this->checkBoxAlwaysShowDialog->isChecked());
+    S::export3mfAlwaysShowDialog.setValue(
+        this->checkBoxAlwaysShowDialog->isChecked());
     applyButtonGroup(this->buttonGroupColors, S::export3mfColorMode);
     applyButtonGroup(this->buttonGroupUnit, S::export3mfUnit);
     S::export3mfColor.setValue(this->color.toRgb().name().toStdString());
-    S::export3mfMaterialType.setIndex(this->comboBoxMaterialType->currentIndex());
-    S::export3mfDecimalPrecision.setValue(this->spinBoxDecimalPrecision->value());
+    S::export3mfMaterialType.setIndex(
+        this->comboBoxMaterialType->currentIndex());
+    S::export3mfDecimalPrecision.setValue(
+        this->spinBoxDecimalPrecision->value());
     S::export3mfAddMetaData.setValue(this->groupMetaData->isChecked());
-    applyMetaData(nullptr, this->lineEditMetaDataTitle, nullptr, S::export3mfMetaDataTitle);
-    applyMetaData(this->checkBoxMetaDataDesigner, this->lineEditMetaDataDesigner, &S::export3mfAddMetaDataDesigner, S::export3mfMetaDataDesigner);
-    applyMetaData(this->checkBoxMetaDataDescription, this->lineEditMetaDataDescription, &S::export3mfAddMetaDataDescription, S::export3mfMetaDataDescription);
-    applyMetaData(this->checkBoxMetaDataCopyright, this->lineEditMetaDataCopyright, &S::export3mfAddMetaDataCopyright, S::export3mfMetaDataCopyright);
-    applyMetaData(this->checkBoxMetaDataLicenseTerms, this->lineEditMetaDataLicenseTerms, &S::export3mfAddMetaDataLicenseTerms, S::export3mfMetaDataLicenseTerms);
-    applyMetaData(this->checkBoxMetaDataRating, this->lineEditMetaDataRating, &S::export3mfAddMetaDataRating, S::export3mfMetaDataRating);
+    applyMetaData(nullptr, this->lineEditMetaDataTitle, nullptr,
+                  S::export3mfMetaDataTitle);
+    applyMetaData(
+        this->checkBoxMetaDataDesigner, this->lineEditMetaDataDesigner,
+        &S::export3mfAddMetaDataDesigner, S::export3mfMetaDataDesigner);
+    applyMetaData(
+        this->checkBoxMetaDataDescription, this->lineEditMetaDataDescription,
+        &S::export3mfAddMetaDataDescription, S::export3mfMetaDataDescription);
+    applyMetaData(
+        this->checkBoxMetaDataCopyright, this->lineEditMetaDataCopyright,
+        &S::export3mfAddMetaDataCopyright, S::export3mfMetaDataCopyright);
+    applyMetaData(
+        this->checkBoxMetaDataLicenseTerms, this->lineEditMetaDataLicenseTerms,
+        &S::export3mfAddMetaDataLicenseTerms, S::export3mfMetaDataLicenseTerms);
+    applyMetaData(this->checkBoxMetaDataRating, this->lineEditMetaDataRating,
+                  &S::export3mfAddMetaDataRating, S::export3mfMetaDataRating);
     Settings::Settings::visit(SettingsWriter());
   }
 
   return result;
 }
 
-void Export3mfDialog::on_toolButtonColorsSelected_clicked()
-{
+void Export3mfDialog::on_toolButtonColorsSelected_clicked() {
   updateColor(QColorDialog::getColor(this->color));
 }
 
-void Export3mfDialog::on_toolButtonColorsSelectedReset_clicked()
-{
+void Export3mfDialog::on_toolButtonColorsSelectedReset_clicked() {
   updateColor(QColor(QString::fromStdString(S::export3mfColor.defaultValue())));
 }
 
-void Export3mfDialog::on_toolButtonDecimalPrecisionReset_clicked()
-{
-  this->spinBoxDecimalPrecision->setValue(S::export3mfDecimalPrecision.defaultValue());
+void Export3mfDialog::on_toolButtonDecimalPrecisionReset_clicked() {
+  this->spinBoxDecimalPrecision->setValue(
+      S::export3mfDecimalPrecision.defaultValue());
 }
diff --git a/src/gui/Export3mfDialog.h b/src/gui/Export3mfDialog.h
index d579aeeee..bf68ecb81 100644
--- a/src/gui/Export3mfDialog.h
+++ b/src/gui/Export3mfDialog.h
@@ -26,20 +26,21 @@
 
 #pragma once
 
-#include <memory>
 #include <QDialog>
+#include <memory>
 
 #include "core/Settings.h"
+#include "gui/InitConfigurator.h"
 #include "gui/qtgettext.h" // IWYU pragma: keep
 #include "io/export.h"
 #include "ui_Export3mfDialog.h"
-#include "gui/InitConfigurator.h"
 
 using SEBool = Settings::SettingsEntryBool;
 using SEString = Settings::SettingsEntryString;
 
-class Export3mfDialog : public QDialog, public Ui::Export3mfDialog, public InitConfigurator
-{
+class Export3mfDialog : public QDialog,
+                        public Ui::Export3mfDialog,
+                        public InitConfigurator {
   Q_OBJECT;
 
 public:
@@ -57,7 +58,7 @@ private slots:
   void on_toolButtonDecimalPrecisionReset_clicked();
 
 private:
-  void updateColor(const QColor& color);
+  void updateColor(const QColor &color);
 
   QColor color;
 };
diff --git a/src/gui/ExportPdfDialog.cc b/src/gui/ExportPdfDialog.cc
index 859525f26..d48137766 100644
--- a/src/gui/ExportPdfDialog.cc
+++ b/src/gui/ExportPdfDialog.cc
@@ -26,21 +26,21 @@
 
 #include "gui/ExportPdfDialog.h"
 
-#include <QString>
-#include <QDialog>
 #include <QColorDialog>
+#include <QDialog>
+#include <QString>
 
-#include "io/export.h"
 #include "core/Settings.h"
-#include "gui/UIUtils.h"
 #include "gui/SettingsWriter.h"
+#include "gui/UIUtils.h"
+#include "io/export.h"
 
 using S = Settings::SettingsExportPdf;
 
-ExportPdfDialog::ExportPdfDialog()
-{
+ExportPdfDialog::ExportPdfDialog() {
   setupUi(this);
-  this->checkBoxAlwaysShowDialog->setChecked(S::exportPdfAlwaysShowDialog.value());
+  this->checkBoxAlwaysShowDialog->setChecked(
+      S::exportPdfAlwaysShowDialog.value());
 
   initButtonGroup(this->buttonGroupPaperSize, S::exportPdfPaperSize);
   initButtonGroup(this->buttonGroupOrientation, S::exportPdfOrientation);
@@ -48,7 +48,8 @@ ExportPdfDialog::ExportPdfDialog()
   // Get current settings or defaults
   this->checkBoxShowFilename->setChecked(S::exportPdfShowFilename.value());
   this->groupScale->setChecked(S::exportPdfShowScale.value());
-  this->checkBoxShowScaleMessage->setChecked(S::exportPdfShowScaleMessage.value());
+  this->checkBoxShowScaleMessage->setChecked(
+      S::exportPdfShowScaleMessage.value());
   this->groupGrid->setChecked(S::exportPdfShowGrid.value());
 
   // Initialize grid size from settings
@@ -62,26 +63,31 @@ ExportPdfDialog::ExportPdfDialog()
 
   // Fill settings
   this->checkBoxEnableFill->setChecked(S::exportPdfFill.value());
-  this->fillColor = QColor(QString::fromStdString(S::exportPdfFillColor.value()));
+  this->fillColor =
+      QColor(QString::fromStdString(S::exportPdfFillColor.value()));
   updateFillColor(this->fillColor);
   updateFillControlsEnabled();
 
   // Stroke settings
   this->checkBoxEnableStroke->setChecked(S::exportPdfStroke.value());
-  this->strokeColor = QColor(QString::fromStdString(S::exportPdfStrokeColor.value()));
+  this->strokeColor =
+      QColor(QString::fromStdString(S::exportPdfStrokeColor.value()));
   this->doubleSpinBoxStrokeWidth->setValue(S::exportPdfStrokeWidth.value());
   updateStrokeColor(this->strokeColor);
   updateStrokeControlsEnabled();
 
   groupMetaData->setChecked(S::exportPdfAddMetaData.value());
-  initMetaData(nullptr, this->lineEditMetaDataTitle, nullptr, S::exportPdfMetaDataTitle);
-  initMetaData(this->checkBoxMetaDataAuthor, this->lineEditMetaDataAuthor, &S::exportPdfAddMetaDataAuthor, S::exportPdfMetaDataAuthor);
-  initMetaData(this->checkBoxMetaDataSubject, this->lineEditMetaDataSubject, &S::exportPdfAddMetaDataSubject, S::exportPdfMetaDataSubject);
-  initMetaData(this->checkBoxMetaDataKeywords, this->lineEditMetaDataKeywords, &S::exportPdfAddMetaDataKeywords, S::exportPdfMetaDataKeywords);
+  initMetaData(nullptr, this->lineEditMetaDataTitle, nullptr,
+               S::exportPdfMetaDataTitle);
+  initMetaData(this->checkBoxMetaDataAuthor, this->lineEditMetaDataAuthor,
+               &S::exportPdfAddMetaDataAuthor, S::exportPdfMetaDataAuthor);
+  initMetaData(this->checkBoxMetaDataSubject, this->lineEditMetaDataSubject,
+               &S::exportPdfAddMetaDataSubject, S::exportPdfMetaDataSubject);
+  initMetaData(this->checkBoxMetaDataKeywords, this->lineEditMetaDataKeywords,
+               &S::exportPdfAddMetaDataKeywords, S::exportPdfMetaDataKeywords);
 }
 
-int ExportPdfDialog::exec()
-{
+int ExportPdfDialog::exec() {
   bool showDialog = this->checkBoxAlwaysShowDialog->isChecked();
   if ((QApplication::keyboardModifiers() & Qt::ShiftModifier) != 0) {
     showDialog = true;
@@ -90,12 +96,14 @@ int ExportPdfDialog::exec()
   const auto result = showDialog ? QDialog::exec() : QDialog::Accepted;
 
   if (result == QDialog::Accepted) {
-    S::exportPdfAlwaysShowDialog.setValue(this->checkBoxAlwaysShowDialog->isChecked());
+    S::exportPdfAlwaysShowDialog.setValue(
+        this->checkBoxAlwaysShowDialog->isChecked());
     applyButtonGroup(this->buttonGroupPaperSize, S::exportPdfPaperSize);
     applyButtonGroup(this->buttonGroupOrientation, S::exportPdfOrientation);
     S::exportPdfShowFilename.setValue(this->checkBoxShowFilename->isChecked());
     S::exportPdfShowScale.setValue(this->groupScale->isChecked());
-    S::exportPdfShowScaleMessage.setValue(this->checkBoxShowScaleMessage->isChecked());
+    S::exportPdfShowScaleMessage.setValue(
+        this->checkBoxShowScaleMessage->isChecked());
     S::exportPdfShowGrid.setValue(this->groupGrid->isChecked());
     S::exportPdfGridSize.setValue(getGridSize());
     S::exportPdfFill.setValue(this->checkBoxEnableFill->isChecked());
@@ -104,46 +112,48 @@ int ExportPdfDialog::exec()
     S::exportPdfStrokeColor.setValue(this->strokeColor.name().toStdString());
     S::exportPdfStrokeWidth.setValue(this->doubleSpinBoxStrokeWidth->value());
     S::exportPdfAddMetaData.setValue(this->groupMetaData->isChecked());
-    applyMetaData(nullptr, this->lineEditMetaDataTitle, nullptr, S::exportPdfMetaDataTitle);
-    applyMetaData(this->checkBoxMetaDataAuthor, this->lineEditMetaDataAuthor, &S::exportPdfAddMetaDataAuthor, S::exportPdfMetaDataAuthor);
-    applyMetaData(this->checkBoxMetaDataSubject, this->lineEditMetaDataSubject, &S::exportPdfAddMetaDataSubject, S::exportPdfMetaDataSubject);
-    applyMetaData(this->checkBoxMetaDataKeywords, this->lineEditMetaDataKeywords, &S::exportPdfAddMetaDataKeywords, S::exportPdfMetaDataKeywords);
+    applyMetaData(nullptr, this->lineEditMetaDataTitle, nullptr,
+                  S::exportPdfMetaDataTitle);
+    applyMetaData(this->checkBoxMetaDataAuthor, this->lineEditMetaDataAuthor,
+                  &S::exportPdfAddMetaDataAuthor, S::exportPdfMetaDataAuthor);
+    applyMetaData(this->checkBoxMetaDataSubject, this->lineEditMetaDataSubject,
+                  &S::exportPdfAddMetaDataSubject, S::exportPdfMetaDataSubject);
+    applyMetaData(
+        this->checkBoxMetaDataKeywords, this->lineEditMetaDataKeywords,
+        &S::exportPdfAddMetaDataKeywords, S::exportPdfMetaDataKeywords);
     Settings::Settings::visit(SettingsWriter());
   }
 
   return result;
 }
 
-double ExportPdfDialog::getGridSize() const
-{
+double ExportPdfDialog::getGridSize() const {
   const auto button = buttonGroupGridSize->checkedButton();
   return button ? button->property("_selected_value").toDouble() : 10.0;
 }
 
-void ExportPdfDialog::updateFillColor(const QColor& color)
-{
+void ExportPdfDialog::updateFillColor(const QColor &color) {
   this->fillColor = color;
-  QString styleSheet = QString("QLabel { background-color: %1; }").arg(color.name());
+  QString styleSheet =
+      QString("QLabel { background-color: %1; }").arg(color.name());
   this->labelFillColor->setStyleSheet(styleSheet);
 }
 
-void ExportPdfDialog::updateStrokeColor(const QColor& color)
-{
+void ExportPdfDialog::updateStrokeColor(const QColor &color) {
   this->strokeColor = color;
-  QString styleSheet = QString("QLabel { background-color: %1; }").arg(color.name());
+  QString styleSheet =
+      QString("QLabel { background-color: %1; }").arg(color.name());
   this->labelStrokeColor->setStyleSheet(styleSheet);
 }
 
-void ExportPdfDialog::updateFillControlsEnabled()
-{
+void ExportPdfDialog::updateFillControlsEnabled() {
   bool enabled = this->checkBoxEnableFill->isChecked();
   this->labelFillColor->setEnabled(enabled);
   this->toolButtonFillColor->setEnabled(enabled);
   this->toolButtonFillColorReset->setEnabled(enabled);
 }
 
-void ExportPdfDialog::updateStrokeControlsEnabled()
-{
+void ExportPdfDialog::updateStrokeControlsEnabled() {
   bool enabled = this->checkBoxEnableStroke->isChecked();
   this->labelStrokeColor->setEnabled(enabled);
   this->toolButtonStrokeColor->setEnabled(enabled);
@@ -153,43 +163,38 @@ void ExportPdfDialog::updateStrokeControlsEnabled()
   this->toolButtonStrokeWidthReset->setEnabled(enabled);
 }
 
-void ExportPdfDialog::on_toolButtonFillColor_clicked()
-{
+void ExportPdfDialog::on_toolButtonFillColor_clicked() {
   QColor color = QColorDialog::getColor(this->fillColor, this);
   if (color.isValid()) {
     updateFillColor(color);
   }
 }
 
-void ExportPdfDialog::on_toolButtonStrokeColor_clicked()
-{
+void ExportPdfDialog::on_toolButtonStrokeColor_clicked() {
   QColor color = QColorDialog::getColor(this->strokeColor, this);
   if (color.isValid()) {
     updateStrokeColor(color);
   }
 }
 
-void ExportPdfDialog::on_toolButtonFillColorReset_clicked()
-{
-  updateFillColor(QColor(QString::fromStdString(S::exportPdfFillColor.defaultValue())));
+void ExportPdfDialog::on_toolButtonFillColorReset_clicked() {
+  updateFillColor(
+      QColor(QString::fromStdString(S::exportPdfFillColor.defaultValue())));
 }
 
-void ExportPdfDialog::on_toolButtonStrokeColorReset_clicked()
-{
-  updateStrokeColor(QColor(QString::fromStdString(S::exportPdfStrokeColor.defaultValue())));
+void ExportPdfDialog::on_toolButtonStrokeColorReset_clicked() {
+  updateStrokeColor(
+      QColor(QString::fromStdString(S::exportPdfStrokeColor.defaultValue())));
 }
 
-void ExportPdfDialog::on_toolButtonStrokeWidthReset_clicked()
-{
+void ExportPdfDialog::on_toolButtonStrokeWidthReset_clicked() {
   this->doubleSpinBoxStrokeWidth->setValue(this->defaultStrokeWidth);
 }
 
-void ExportPdfDialog::on_checkBoxEnableFill_toggled(bool checked)
-{
+void ExportPdfDialog::on_checkBoxEnableFill_toggled(bool checked) {
   updateFillControlsEnabled();
 }
 
-void ExportPdfDialog::on_checkBoxEnableStroke_toggled(bool checked)
-{
+void ExportPdfDialog::on_checkBoxEnableStroke_toggled(bool checked) {
   updateStrokeControlsEnabled();
 }
diff --git a/src/gui/ExportPdfDialog.h b/src/gui/ExportPdfDialog.h
index f04d42f29..9a0fc464a 100644
--- a/src/gui/ExportPdfDialog.h
+++ b/src/gui/ExportPdfDialog.h
@@ -26,17 +26,18 @@
 
 #pragma once
 
-#include <memory>
-#include <QDialog>
 #include <QColor>
+#include <QDialog>
+#include <memory>
 
+#include "gui/InitConfigurator.h"
 #include "gui/qtgettext.h" // IWYU pragma: keep
 #include "io/export.h"
 #include "ui_ExportPdfDialog.h"
-#include "gui/InitConfigurator.h"
 
-class ExportPdfDialog : public QDialog, public Ui::ExportPdfDialog, public InitConfigurator
-{
+class ExportPdfDialog : public QDialog,
+                        public Ui::ExportPdfDialog,
+                        public InitConfigurator {
   Q_OBJECT;
 
 public:
@@ -61,17 +62,12 @@ private slots:
   void on_toolButtonStrokeWidthReset_clicked();
 
 private:
-  void updateFillColor(const QColor& color);
+  void updateFillColor(const QColor &color);
   void updateFillControlsEnabled();
-  void updateStrokeColor(const QColor& color);
+  void updateStrokeColor(const QColor &color);
   void updateStrokeControlsEnabled();
 
   QColor fillColor;
   QColor strokeColor;
   double defaultStrokeWidth = 0.35;
 };
-
-
-
-
-
diff --git a/src/gui/ExternalToolInterface.cc b/src/gui/ExternalToolInterface.cc
index 4b817f18d..676bbee13 100644
--- a/src/gui/ExternalToolInterface.cc
+++ b/src/gui/ExternalToolInterface.cc
@@ -26,25 +26,24 @@
 
 #include "gui/ExternalToolInterface.h"
 
-#include <functional>
-#include <memory>
 #include <QDir>
-#include <QString>
 #include <QFileInfo>
+#include <QString>
 #include <QStringList>
 #include <QTemporaryFile>
+#include <functional>
+#include <memory>
 
 #include "core/Settings.h"
+#include "geometry/Geometry.h"
 #include "gui/OctoPrint.h"
 #include "io/export.h"
-#include "geometry/Geometry.h"
 
 namespace {
 
-QString getArgValue(const Settings::LocalAppParameter& arg,
-                    const std::string& exportedFilename,
-                    const std::string& sourceFilename)
-{
+QString getArgValue(const Settings::LocalAppParameter &arg,
+                    const std::string &exportedFilename,
+                    const std::string &sourceFilename) {
   const QFileInfo info(QString::fromStdString(exportedFilename));
   switch (arg.type) {
   case Settings::LocalAppParameterType::string:
@@ -58,22 +57,24 @@ QString getArgValue(const Settings::LocalAppParameter& arg,
   case Settings::LocalAppParameterType::source:
     return QString::fromStdString(sourceFilename);
   case Settings::LocalAppParameterType::sourcedir:
-    return QFileInfo(QString::fromStdString(sourceFilename)).absoluteDir().path();
+    return QFileInfo(QString::fromStdString(sourceFilename))
+        .absoluteDir()
+        .path();
   default:
     return {};
   }
 }
 
-}  // namespace
+} // namespace
 
-bool ExternalToolInterface::exportTemporaryFile(const std::shared_ptr<const Geometry>& rootGeometry,
-                                                const QString& sourceFileName, const Camera *const camera)
-{
+bool ExternalToolInterface::exportTemporaryFile(
+    const std::shared_ptr<const Geometry> &rootGeometry,
+    const QString &sourceFileName, const Camera *const camera) {
   // FIXME: Remove original suffix first
   QTemporaryFile exportFile{getTempDir().filePath(
-                              QString("%1.XXXXXX.%2").
-                              arg(QString::fromStdString(sourceFileName.toStdString())).
-                              arg(QString::fromStdString(fileformat::toSuffix(exportFormat_))))};
+      QString("%1.XXXXXX.%2")
+          .arg(QString::fromStdString(sourceFileName.toStdString()))
+          .arg(QString::fromStdString(fileformat::toSuffix(exportFormat_))))};
   // FIXME: When is it safe to remove the file?
   // * Octoprint: After uploading?
   // * PrintService: After uploading?
@@ -87,60 +88,69 @@ bool ExternalToolInterface::exportTemporaryFile(const std::shared_ptr<const Geom
 
   sourceFilename_ = sourceFileName.toStdString();
   exportedFilename_ = exportFileName.toStdString();
-  ExportInfo exportInfo = createExportInfo(exportFormat_, fileformat::info(exportFormat_), sourceFileName.toStdString(), camera, {});
+  ExportInfo exportInfo =
+      createExportInfo(exportFormat_, fileformat::info(exportFormat_),
+                       sourceFileName.toStdString(), camera, {});
   const bool ok = exportFileByName(rootGeometry, exportedFilename_, exportInfo);
   LOG("Exported temporary file %1$s", exportedFilename_);
   return ok;
 }
 
-bool OctoPrintService::process(const std::string& displayName, std::function<bool (double)> progress_cb)
-{
+bool OctoPrintService::process(const std::string &displayName,
+                               std::function<bool(double)> progress_cb) {
   const OctoPrint octoPrint;
 
   try {
-    const QString fileUrl = octoPrint.upload(QString::fromStdString(exportedFilename_), QString::fromStdString(displayName), progress_cb);
+    const QString fileUrl =
+        octoPrint.upload(QString::fromStdString(exportedFilename_),
+                         QString::fromStdString(displayName), progress_cb);
     if (this->action == "upload") {
       return true;
     }
 
-    const QString slicer = QString::fromStdString(Settings::Settings::octoPrintSlicerEngine.value());
-    const QString profile = QString::fromStdString(Settings::Settings::octoPrintSlicerProfile.value());
-    octoPrint.slice(fileUrl, slicer, profile, action != "slice", action == "print");
-  } catch (const NetworkException& e) {
+    const QString slicer = QString::fromStdString(
+        Settings::Settings::octoPrintSlicerEngine.value());
+    const QString profile = QString::fromStdString(
+        Settings::Settings::octoPrintSlicerProfile.value());
+    octoPrint.slice(fileUrl, slicer, profile, action != "slice",
+                    action == "print");
+  } catch (const NetworkException &e) {
     LOG(message_group::Error, "%1$s", e.getErrorMessage());
   }
   return true;
 }
 
-QDir LocalProgramService::getTempDir() const
-{
-  const auto& tempDirConfig = Settings::Settings::localAppTempDir.value();
+QDir LocalProgramService::getTempDir() const {
+  const auto &tempDirConfig = Settings::Settings::localAppTempDir.value();
   if (tempDirConfig.empty()) {
     return QDir::temp();
   }
   const auto tempDir = QDir{QString::fromStdString(tempDirConfig)};
   if (!tempDir.exists()) {
-    LOG(message_group::Warning, "Configured temporary directory does not exist: '%1$s'", tempDirConfig);
+    LOG(message_group::Warning,
+        "Configured temporary directory does not exist: '%1$s'", tempDirConfig);
     return QDir::temp();
   }
   return tempDir;
 }
 
-bool LocalProgramService::process(const std::string& displayName, std::function<bool (double)> progress_cb)
-{
+bool LocalProgramService::process(const std::string &displayName,
+                                  std::function<bool(double)> progress_cb) {
   QProcess process;
   process.setProcessChannelMode(QProcess::MergedChannels);
 
-  const QString application = QString::fromStdString(Settings::Settings::localAppExecutable.value());
+  const QString application =
+      QString::fromStdString(Settings::Settings::localAppExecutable.value());
 
   if (application.trimmed().isEmpty()) {
-    LOG(message_group::Error, "No application configured, check Preferences -> 3D Print -> Local Application");
+    LOG(message_group::Error, "No application configured, check Preferences -> "
+                              "3D Print -> Local Application");
     return false;
   }
 
 #ifdef Q_OS_MACOS
   QStringList fileArgs, otherArgs;
-  for (const auto& arg : Settings::Settings::localAppParameterList.value()) {
+  for (const auto &arg : Settings::Settings::localAppParameterList.value()) {
     if (arg.type == Settings::LocalAppParameterType::file) {
       fileArgs << getArgValue(arg, exportedFilename_, sourceFilename_);
     } else {
@@ -157,13 +167,15 @@ bool LocalProgramService::process(const std::string& displayName, std::function<
   if (!process.startDetached("open", commandArgs)) {
 #else
   QStringList args;
-  for (const auto& arg : Settings::Settings::localAppParameterList.value()) {
+  for (const auto &arg : Settings::Settings::localAppParameterList.value()) {
     args << getArgValue(arg, exportedFilename_, sourceFilename_);
   }
-  PRINTD("Executing: " + application.toStdString() + " " + args.join(" ").toStdString());
+  PRINTD("Executing: " + application.toStdString() + " " +
+         args.join(" ").toStdString());
   if (!process.startDetached(application, args)) {
 #endif // ifdef Q_OS_MACOS
-    LOG(message_group::Error, "Could not start local application '%1$s': %2$s", application.toStdString(), process.errorString().toStdString());
+    LOG(message_group::Error, "Could not start local application '%1$s': %2$s",
+        application.toStdString(), process.errorString().toStdString());
     const auto output = process.readAll();
     if (output.length() > 0) {
       LOG(message_group::Error, "Output: %1$s", output.toStdString());
@@ -172,8 +184,8 @@ bool LocalProgramService::process(const std::string& displayName, std::function<
   return true;
 }
 
-bool ExternalPrintService::process(const std::string& displayName, std::function<bool (double)> progress_cb)
-{
+bool ExternalPrintService::process(const std::string &displayName,
+                                   std::function<bool(double)> progress_cb) {
   QFile file(QString::fromStdString(exportedFilename_));
   if (!file.open(QIODevice::ReadOnly)) {
     LOG(message_group::Error, "Unable to open exported STL file.");
@@ -182,39 +194,46 @@ bool ExternalPrintService::process(const std::string& displayName, std::function
   const QString fileContentBase64 = file.readAll().toBase64();
 
   if (fileContentBase64.length() > printService->getFileSizeLimit()) {
-    const auto msg = QString{_("Exported design exceeds the service upload limit of (%1 MB).")}.arg(printService->getFileSizeLimitMB());
+    const auto msg =
+        QString{
+            _("Exported design exceeds the service upload limit of (%1 MB).")}
+            .arg(printService->getFileSizeLimitMB());
     // FIXME: Move back to MainWindow
-//    QMessageBox::warning(this, _("Upload Error"), msg, QMessageBox::Ok);
-    //LOG(message_group::Error, "%1$s", msg.toStdString());
+    //    QMessageBox::warning(this, _("Upload Error"), msg, QMessageBox::Ok);
+    // LOG(message_group::Error, "%1$s", msg.toStdString());
     return false;
   }
   try {
-    const QString partUrl = printService->upload(QString::fromStdString(displayName), fileContentBase64, progress_cb);
+    const QString partUrl = printService->upload(
+        QString::fromStdString(displayName), fileContentBase64, progress_cb);
     this->url = partUrl.toStdString();
-  } catch (const NetworkException& e) {
+  } catch (const NetworkException &e) {
     LOG(message_group::Error, "%1$s", e.getErrorMessage());
   }
   return true;
 }
 
-std::unique_ptr<ExternalPrintService> createExternalPrintService(const PrintService *printService, FileFormat fileFormat) {
+std::unique_ptr<ExternalPrintService>
+createExternalPrintService(const PrintService *printService,
+                           FileFormat fileFormat) {
   return std::make_unique<ExternalPrintService>(fileFormat, printService);
 }
 
-std::unique_ptr<OctoPrintService> createOctoPrintService(FileFormat fileFormat)
-{
+std::unique_ptr<OctoPrintService>
+createOctoPrintService(FileFormat fileFormat) {
   auto octoPrintService = std::make_unique<OctoPrintService>(fileFormat);
 
-
-// TODO: set action, slicerEngine, slicerAction
-//    const std::string& action = Settings::Settings::octoPrintAction.value();
-// const QString slicer = QString::fromStdString(Settings::Settings::octoPrintSlicerEngine.value());
-// const QString profile = QString::fromStdString(Settings::Settings::octoPrintSlicerProfile.value());
-
+  // TODO: set action, slicerEngine, slicerAction
+  //    const std::string& action = Settings::Settings::octoPrintAction.value();
+  // const QString slicer =
+  // QString::fromStdString(Settings::Settings::octoPrintSlicerEngine.value());
+  // const QString profile =
+  // QString::fromStdString(Settings::Settings::octoPrintSlicerProfile.value());
 
   return octoPrintService;
 }
 
-std::unique_ptr<LocalProgramService> createLocalProgramService(FileFormat fileFormat) {
+std::unique_ptr<LocalProgramService>
+createLocalProgramService(FileFormat fileFormat) {
   return std::make_unique<LocalProgramService>(fileFormat);
 }
diff --git a/src/gui/ExternalToolInterface.h b/src/gui/ExternalToolInterface.h
index 6744db775..9afe5231e 100644
--- a/src/gui/ExternalToolInterface.h
+++ b/src/gui/ExternalToolInterface.h
@@ -27,55 +27,61 @@
 #pragma once
 
 #include <functional>
-#include <string>
 #include <memory>
+#include <string>
 
 #include <QDir>
 #include <QString>
 
-#include "gui/PrintService.h"
-#include "geometry/Geometry.h"
 #include "core/Settings.h"
+#include "geometry/Geometry.h"
+#include "gui/PrintService.h"
 #include "io/export.h"
 
-class ExternalToolInterface
-{
+class ExternalToolInterface {
 public:
   ExternalToolInterface(FileFormat fileFormat) : exportFormat_(fileFormat) {}
   virtual ~ExternalToolInterface() = default;
 
-  virtual bool exportTemporaryFile(const std::shared_ptr<const Geometry>& rootGeometry, const QString& sourceFileName, const Camera *const camera);
-  virtual bool process(const std::string& displayName, std::function<bool (double)>) = 0;
+  virtual bool
+  exportTemporaryFile(const std::shared_ptr<const Geometry> &rootGeometry,
+                      const QString &sourceFileName,
+                      const Camera *const camera);
+  virtual bool process(const std::string &displayName,
+                       std::function<bool(double)>) = 0;
 
   FileFormat fileFormat() const { return exportFormat_; }
   virtual std::string getURL() const { return ""; }
   virtual QDir getTempDir() const { return QDir::temp(); }
+
 protected:
   std::string sourceFilename_;
   FileFormat exportFormat_;
   std::string exportedFilename_;
 };
 
-
-class ExternalPrintService : public ExternalToolInterface
-{
+class ExternalPrintService : public ExternalToolInterface {
 public:
-  ExternalPrintService(FileFormat fileFormat, const PrintService *printService) : ExternalToolInterface(fileFormat), printService(printService) {}
-  bool process(const std::string& displayName, std::function<bool (double)>) override;
-  std::string getURL() const override {return url;}
+  ExternalPrintService(FileFormat fileFormat, const PrintService *printService)
+      : ExternalToolInterface(fileFormat), printService(printService) {}
+  bool process(const std::string &displayName,
+               std::function<bool(double)>) override;
+  std::string getURL() const override { return url; }
 
 private:
   std::string url;
   const PrintService *printService;
 };
 
-std::unique_ptr<ExternalPrintService> createExternalPrintService(const PrintService *printService, FileFormat fileFormat);
+std::unique_ptr<ExternalPrintService>
+createExternalPrintService(const PrintService *printService,
+                           FileFormat fileFormat);
 
-class OctoPrintService : public ExternalToolInterface
-{
+class OctoPrintService : public ExternalToolInterface {
 public:
   OctoPrintService(FileFormat fileFormat) : ExternalToolInterface(fileFormat) {}
-  bool process(const std::string& displayName, std::function<bool (double)>) override;
+  bool process(const std::string &displayName,
+               std::function<bool(double)>) override;
 
 private:
   std::string action;
@@ -85,12 +91,14 @@ private:
 
 std::unique_ptr<OctoPrintService> createOctoPrintService(FileFormat fileFormat);
 
-class LocalProgramService : public ExternalToolInterface
-{
+class LocalProgramService : public ExternalToolInterface {
 public:
-  LocalProgramService(FileFormat fileFormat) : ExternalToolInterface(fileFormat) {}
-  bool process(const std::string& displayName, std::function<bool (double)>) override;
+  LocalProgramService(FileFormat fileFormat)
+      : ExternalToolInterface(fileFormat) {}
+  bool process(const std::string &displayName,
+               std::function<bool(double)>) override;
   QDir getTempDir() const override;
 };
 
-std::unique_ptr<LocalProgramService> createLocalProgramService(FileFormat fileFormat);
+std::unique_ptr<LocalProgramService>
+createLocalProgramService(FileFormat fileFormat);
diff --git a/src/gui/FontList.cc b/src/gui/FontList.cc
index b25a1aa6e..e99fa9d48 100644
--- a/src/gui/FontList.cc
+++ b/src/gui/FontList.cc
@@ -6,60 +6,46 @@
 #include <vector>
 
 #include <QAbstractItemView>
+#include <QAction>
 #include <QApplication>
+#include <QClipboard>
+#include <QDesktopServices>
+#include <QDir>
+#include <QFileInfo>
+#include <QFontMetrics>
+#include <QHeaderView>
+#include <QItemSelectionModel>
+#include <QLineEdit>
+#include <QMenu>
 #include <QModelIndex>
 #include <QPainter>
 #include <QPoint>
+#include <QRegularExpression>
 #include <QResizeEvent>
 #include <QSize>
 #include <QSortFilterProxyModel>
+#include <QSpinBox>
 #include <QString>
-#include <QStyledItemDelegate>
 #include <QStyleOptionViewItem>
-#include <QItemSelectionModel>
-#include <QClipboard>
-#include <QRegularExpression>
-#include <QFileInfo>
-#include <QFontMetrics>
-#include <QMenu>
-#include <QDir>
+#include <QStyledItemDelegate>
 #include <QUrl>
-#include <QDesktopServices>
-#include <QAction>
-#include <QHeaderView>
-#include <QItemSelectionModel>
-#include <QSpinBox>
-#include <QLineEdit>
 
 #include "FontCache.h"
 #include "utils/printutils.h"
 
-FontItemDelegate::FontItemDelegate(QObject *parent) : QStyledItemDelegate(parent)
-{
-}
+FontItemDelegate::FontItemDelegate(QObject *parent)
+    : QStyledItemDelegate(parent) {}
 
-int FontItemDelegate::fontSize() const
-{
-  return _fontSize;
-}
+int FontItemDelegate::fontSize() const { return _fontSize; }
 
-void FontItemDelegate::setFontSize(int fontSize)
-{
-  _fontSize = fontSize;
-}
+void FontItemDelegate::setFontSize(int fontSize) { _fontSize = fontSize; }
 
-QString FontItemDelegate::text() const
-{
-  return _text;
-}
+QString FontItemDelegate::text() const { return _text; }
 
-void FontItemDelegate::setText(const QString& text)
-{
-  _text = text;
-}
+void FontItemDelegate::setText(const QString &text) { _text = text; }
 
-void FontItemDelegate::initStyleOption(QStyleOptionViewItem *opt, const QModelIndex& idx) const
-{
+void FontItemDelegate::initStyleOption(QStyleOptionViewItem *opt,
+                                       const QModelIndex &idx) const {
   QStyledItemDelegate::initStyleOption(opt, idx);
 
   opt->font.setStyleStrategy(QFont::NoFontMerging);
@@ -67,13 +53,13 @@ void FontItemDelegate::initStyleOption(QStyleOptionViewItem *opt, const QModelIn
   opt->textElideMode = Qt::ElideNone;
 }
 
-QWidget *FontItemDelegate::createEditor(QWidget *, const QStyleOptionViewItem&, const QModelIndex&) const
-{
+QWidget *FontItemDelegate::createEditor(QWidget *, const QStyleOptionViewItem &,
+                                        const QModelIndex &) const {
   return nullptr;
 }
 
-QSize FontItemDelegate::sizeHint(const QStyleOptionViewItem& option, const QModelIndex& idx) const
-{
+QSize FontItemDelegate::sizeHint(const QStyleOptionViewItem &option,
+                                 const QModelIndex &idx) const {
   QStyleOptionViewItem opt = option;
   initStyleOption(&opt, idx);
 
@@ -86,8 +72,9 @@ QSize FontItemDelegate::sizeHint(const QStyleOptionViewItem& option, const QMode
   return {4 * fm.height() + fm.horizontalAdvance(text), fm.height()};
 }
 
-void FontItemDelegate::paint(QPainter *painter, const QStyleOptionViewItem& option, const QModelIndex& idx) const
-{
+void FontItemDelegate::paint(QPainter *painter,
+                             const QStyleOptionViewItem &option,
+                             const QModelIndex &idx) const {
   QStyleOptionViewItem opt = option;
   initStyleOption(&opt, idx);
 
@@ -101,64 +88,67 @@ void FontItemDelegate::paint(QPainter *painter, const QStyleOptionViewItem& opti
   QStyledItemDelegate::paint(painter, opt, idx);
 }
 
-FontSortFilterProxyModel::FontSortFilterProxyModel(QObject *parent) : QSortFilterProxyModel(parent)
-{
-}
+FontSortFilterProxyModel::FontSortFilterProxyModel(QObject *parent)
+    : QSortFilterProxyModel(parent) {}
 
-void FontSortFilterProxyModel::clearFilter()
-{
-  filterHashes.clear();
-}
+void FontSortFilterProxyModel::clearFilter() { filterHashes.clear(); }
 
-void FontSortFilterProxyModel::appendFilterHashes(const std::vector<uint32_t>& hashes)
-{
+void FontSortFilterProxyModel::appendFilterHashes(
+    const std::vector<uint32_t> &hashes) {
   for (const auto hash : hashes) {
     filterHashes.insert(QString::number(hash, 16));
   }
 }
 
-bool FontSortFilterProxyModel::filterAcceptsRow(int sourceRow, const QModelIndex& sourceParent) const
-{
-  const bool parentResult = QSortFilterProxyModel::filterAcceptsRow(sourceRow, sourceParent);
+bool FontSortFilterProxyModel::filterAcceptsRow(
+    int sourceRow, const QModelIndex &sourceParent) const {
+  const bool parentResult =
+      QSortFilterProxyModel::filterAcceptsRow(sourceRow, sourceParent);
   if (filterHashes.empty()) {
     return parentResult;
   }
 
-  const auto idx = sourceModel()->index(sourceRow, FontList::COL_HASH, sourceParent);
-  const auto& data = sourceModel()->data(idx);
+  const auto idx =
+      sourceModel()->index(sourceRow, FontList::COL_HASH, sourceParent);
+  const auto &data = sourceModel()->data(idx);
   const bool result = filterHashes.contains(data.toString());
   return parentResult && result;
 }
 
-FontList::FontList(QWidget *parent) : QWidget(parent), model(nullptr), proxy(nullptr)
-{
+FontList::FontList(QWidget *parent)
+    : QWidget(parent), model(nullptr), proxy(nullptr) {
   setupUi(this);
-  lineEditSampleText->addAction(actionResetSampleText, QLineEdit::TrailingPosition);
+  lineEditSampleText->addAction(actionResetSampleText,
+                                QLineEdit::TrailingPosition);
   actionResetSampleText->trigger();
-  lineEditFontNameSelected->addAction(actionCopyFontName, QLineEdit::TrailingPosition);
-  lineEditFontPathSelected->addAction(actionOpenFolder, QLineEdit::TrailingPosition);
-  lineEditFontPathSelected->addAction(actionCopyFullPath, QLineEdit::TrailingPosition);
-  lineEditFcStyleSelected->addAction(actionCopyStyle, QLineEdit::TrailingPosition);
+  lineEditFontNameSelected->addAction(actionCopyFontName,
+                                      QLineEdit::TrailingPosition);
+  lineEditFontPathSelected->addAction(actionOpenFolder,
+                                      QLineEdit::TrailingPosition);
+  lineEditFontPathSelected->addAction(actionCopyFullPath,
+                                      QLineEdit::TrailingPosition);
+  lineEditFcStyleSelected->addAction(actionCopyStyle,
+                                     QLineEdit::TrailingPosition);
   spinBoxFontSize->setValue(tableView->fontInfo().pointSize());
   selection_changed({}, {});
 
   tableView->horizontalHeader()->setContextMenuPolicy(Qt::CustomContextMenu);
-  connect(tableView->horizontalHeader(), &QHeaderView::customContextMenuRequested, this, &FontList::customHeaderContexMenuRequested);
+  connect(tableView->horizontalHeader(),
+          &QHeaderView::customContextMenuRequested, this,
+          &FontList::customHeaderContexMenuRequested);
 }
 
-void FontList::on_lineEditFontName_textChanged(const QString& text)
-{
+void FontList::on_lineEditFontName_textChanged(const QString &text) {
   updateFilter(comboBoxSearchType->currentIndex(), text);
 }
 
-void FontList::on_comboBoxSearchType_currentIndexChanged(int idx)
-{
+void FontList::on_comboBoxSearchType_currentIndexChanged(int idx) {
   updateFilter(idx, lineEditFontName->text());
 }
 
-void FontList::updateFilter(int searchTypeIdx, const QString& text)
-{
-  const auto regExp = QRegularExpression(text, QRegularExpression::CaseInsensitiveOption);
+void FontList::updateFilter(int searchTypeIdx, const QString &text) {
+  const auto regExp =
+      QRegularExpression(text, QRegularExpression::CaseInsensitiveOption);
 
   switch (searchTypeIdx) {
   case 0:
@@ -171,21 +161,19 @@ void FontList::updateFilter(int searchTypeIdx, const QString& text)
     proxy->setFilterRegularExpression(regExp);
     break;
   }
-  groupBoxFilter->setTitle(QString("Filter (%1 fonts found)").arg(proxy->rowCount()));
+  groupBoxFilter->setTitle(
+      QString("Filter (%1 fonts found)").arg(proxy->rowCount()));
 }
 
-void FontList::on_comboBoxCharFilterType_currentIndexChanged(int idx)
-{
+void FontList::on_comboBoxCharFilterType_currentIndexChanged(int idx) {
   updateCharFilter(idx, lineEditChars->text());
 }
 
-void FontList::on_lineEditChars_textChanged(const QString& text)
-{
+void FontList::on_lineEditChars_textChanged(const QString &text) {
   updateCharFilter(comboBoxCharFilterType->currentIndex(), text);
 }
 
-void FontList::updateCharFilter(int charFilterType, const QString& text)
-{
+void FontList::updateCharFilter(int charFilterType, const QString &text) {
   proxy->clearFilter();
   if (text.length() > 0) {
     if (charFilterType == 0) {
@@ -201,27 +189,24 @@ void FontList::updateCharFilter(int charFilterType, const QString& text)
     }
   }
   proxy->invalidate();
-  groupBoxFilter->setTitle(QString("Filter (%1 fonts found)").arg(proxy->rowCount()));
+  groupBoxFilter->setTitle(
+      QString("Filter (%1 fonts found)").arg(proxy->rowCount()));
 }
 
-void FontList::on_actionResetSampleText_triggered()
-{
+void FontList::on_actionResetSampleText_triggered() {
   lineEditSampleText->setText(SAMPLE_TEXT_DEFAULT);
   lineEditSampleText->setCursorPosition(0);
 }
 
-void FontList::on_lineEditSampleText_textChanged(const QString& text)
-{
+void FontList::on_lineEditSampleText_textChanged(const QString &text) {
   updateSampleText(text, spinBoxFontSize->value());
 }
 
-void FontList::on_spinBoxFontSize_valueChanged(int value)
-{
+void FontList::on_spinBoxFontSize_valueChanged(int value) {
   updateSampleText(lineEditSampleText->text(), value);
 }
 
-void FontList::updateSampleText(const QString& text, int fontSize)
-{
+void FontList::updateSampleText(const QString &text, int fontSize) {
   delegate.setText(text);
   delegate.setFontSize(fontSize);
 
@@ -240,8 +225,7 @@ void FontList::updateSampleText(const QString& text, int fontSize)
   }
 }
 
-void FontList::customHeaderContexMenuRequested(const QPoint& pos)
-{
+void FontList::customHeaderContexMenuRequested(const QPoint &pos) {
   auto *menu = new QMenu(this);
   menu->addAction(actionShowFontNameColumn);
   menu->addAction(actionShowStyledFontNameColumn);
@@ -261,38 +245,31 @@ void FontList::showColumn(int column, bool show) {
   }
 }
 
-void FontList::on_actionShowFontNameColumn_toggled(bool show)
-{
+void FontList::on_actionShowFontNameColumn_toggled(bool show) {
   showColumn(COL_FONT_NAME, show);
 }
 
-void FontList::on_actionShowStyledFontNameColumn_toggled(bool show)
-{
+void FontList::on_actionShowStyledFontNameColumn_toggled(bool show) {
   showColumn(COL_STYLED_FONT_NAME, show);
 }
 
-void FontList::on_actionShowFontStyleColumn_toggled(bool show)
-{
+void FontList::on_actionShowFontStyleColumn_toggled(bool show) {
   showColumn(COL_FONT_STYLE, show);
 }
 
-void FontList::on_actionShowFontSampleColumn_toggled(bool show)
-{
+void FontList::on_actionShowFontSampleColumn_toggled(bool show) {
   showColumn(COL_SAMPLE, show);
 }
 
-void FontList::on_actionShowFileNameColumn_toggled(bool show)
-{
+void FontList::on_actionShowFileNameColumn_toggled(bool show) {
   showColumn(COL_FILE_NAME, show);
 }
 
-void FontList::on_actionShowFilePathColumn_toggled(bool show)
-{
+void FontList::on_actionShowFilePathColumn_toggled(bool show) {
   showColumn(COL_FILE_PATH, show);
 }
 
-void FontList::on_actionResetColumns_triggered()
-{
+void FontList::on_actionResetColumns_triggered() {
   actionShowFontNameColumn->setChecked(true);
   actionShowStyledFontNameColumn->setChecked(false);
   actionShowFontStyleColumn->setChecked(true);
@@ -307,8 +284,7 @@ void FontList::on_actionResetColumns_triggered()
   tableView->hideColumn(COL_HASH);
 }
 
-void FontList::on_tableView_customContextMenuRequested(const QPoint& pos)
-{
+void FontList::on_tableView_customContextMenuRequested(const QPoint &pos) {
   auto *menu = new QMenu(this);
   menu->addAction(actionCopyStyle);
   menu->addSeparator();
@@ -320,49 +296,41 @@ void FontList::on_tableView_customContextMenuRequested(const QPoint& pos)
   menu->popup(tableView->viewport()->mapToGlobal(pos));
 }
 
-const QModelIndex FontList::currentIndex() const
-{
+const QModelIndex FontList::currentIndex() const {
   return tableView->selectionModel()->currentIndex();
 }
 
-void FontList::on_actionCopyFontName_triggered()
-{
+void FontList::on_actionCopyFontName_triggered() {
   QApplication::clipboard()->setText(colStr(currentIndex(), COL_FONT_NAME));
 }
 
-void FontList::on_actionCopyStyle_triggered()
-{
+void FontList::on_actionCopyStyle_triggered() {
   font_selected(selection);
   QApplication::clipboard()->setText(selection);
 }
 
-void FontList::on_actionCopyFolder_triggered()
-{
+void FontList::on_actionCopyFolder_triggered() {
   const QFileInfo fileInfo(colStr(currentIndex(), COL_FILE_PATH));
   QApplication::clipboard()->setText(fileInfo.dir().canonicalPath());
 }
 
-void FontList::on_actionCopyFullPath_triggered()
-{
+void FontList::on_actionCopyFullPath_triggered() {
   QApplication::clipboard()->setText(colStr(currentIndex(), COL_FILE_PATH));
 }
 
-void FontList::on_actionOpenFolder_triggered()
-{
+void FontList::on_actionOpenFolder_triggered() {
   const QFileInfo fileInfo(colStr(currentIndex(), COL_FILE_PATH));
   if (fileInfo.dir().exists()) {
-    QDesktopServices::openUrl(QUrl::fromLocalFile(fileInfo.dir().absolutePath()));
+    QDesktopServices::openUrl(
+        QUrl::fromLocalFile(fileInfo.dir().absolutePath()));
   }
 }
 
-void FontList::selection_changed(const QItemSelection& current, const QItemSelection&)
-{
+void FontList::selection_changed(const QItemSelection &current,
+                                 const QItemSelection &) {
   const std::array<QAction *, 5> actions = {
-    actionCopyFontName,
-    actionCopyStyle,
-    actionCopyFolder,
-    actionCopyFullPath,
-    actionOpenFolder,
+      actionCopyFontName, actionCopyStyle,  actionCopyFolder,
+      actionCopyFullPath, actionOpenFolder,
   };
 
   const bool disabled = current.count() == 0;
@@ -379,22 +347,23 @@ void FontList::selection_changed(const QItemSelection& current, const QItemSelec
     return;
   }
 
-  const auto& idx = proxy->mapToSource(current.indexes().at(0));
+  const auto &idx = proxy->mapToSource(current.indexes().at(0));
   const auto name = model->item(idx.row(), COL_FONT_NAME)->text();
   const auto path = model->item(idx.row(), COL_FILE_PATH)->text();
   const auto style = model->item(idx.row(), COL_FONT_STYLE)->text();
-  const auto fcStyle = QString("%1:style=%2").arg(quote(name)).arg(quote(style));
+  const auto fcStyle =
+      QString("%1:style=%2").arg(quote(name)).arg(quote(style));
   this->selection = "\"" + fcStyle + "\"";
   tableView->setDragText(this->selection);
   lineEditFontNameSelected->setText(name);
   lineEditFontNameSelected->setCursorPosition(0);
-  lineEditFontPathSelected->setText(path); // keep cursor at the end to prefer the file name
+  lineEditFontPathSelected->setText(
+      path); // keep cursor at the end to prefer the file name
   lineEditFcStyleSelected->setText(fcStyle);
   lineEditFcStyleSelected->setCursorPosition(0);
 }
 
-void FontList::update_font_list()
-{
+void FontList::update_font_list() {
   if (proxy) {
     delete proxy;
     proxy = nullptr;
@@ -406,29 +375,40 @@ void FontList::update_font_list()
 
   const FontInfoList *list = FontCache::instance()->list_fonts();
   model = new QStandardItemModel(list->size(), COL_COUNT, this);
-  model->setHorizontalHeaderItem(COL_FONT_NAME, new QStandardItem(_("Font name")));
-  model->setHorizontalHeaderItem(COL_STYLED_FONT_NAME, new QStandardItem(_("Styled font name")));
-  model->setHorizontalHeaderItem(COL_FONT_STYLE, new QStandardItem(_("Font style")));
-  model->setHorizontalHeaderItem(COL_SAMPLE, new QStandardItem(_("Sample text"))); // text handled by delegate
-  model->setHorizontalHeaderItem(COL_FILE_NAME, new QStandardItem(_("File name")));
-  model->setHorizontalHeaderItem(COL_FILE_PATH, new QStandardItem(_("File path")));
+  model->setHorizontalHeaderItem(COL_FONT_NAME,
+                                 new QStandardItem(_("Font name")));
+  model->setHorizontalHeaderItem(COL_STYLED_FONT_NAME,
+                                 new QStandardItem(_("Styled font name")));
+  model->setHorizontalHeaderItem(COL_FONT_STYLE,
+                                 new QStandardItem(_("Font style")));
+  model->setHorizontalHeaderItem(
+      COL_SAMPLE,
+      new QStandardItem(_("Sample text"))); // text handled by delegate
+  model->setHorizontalHeaderItem(COL_FILE_NAME,
+                                 new QStandardItem(_("File name")));
+  model->setHorizontalHeaderItem(COL_FILE_PATH,
+                                 new QStandardItem(_("File path")));
   model->setHorizontalHeaderItem(COL_HASH, new QStandardItem(_("Hash")));
 
-  const QString toolTip = R"(<table style="white-space:pre"><tr><td>Name:</td><td><b>%1</b></td></tr><tr><td>Style:</td><td>%2</td></tr></table>)";
+  const QString toolTip =
+      R"(<table style="white-space:pre"><tr><td>Name:</td><td><b>%1</b></td></tr><tr><td>Style:</td><td>%2</td></tr></table>)";
 
   int idx = 0;
   for (auto it = list->begin(); it != list->end(); it++, idx++) {
-    const FontInfo& font_info = (*it);
+    const FontInfo &font_info = (*it);
 
-    auto *family = new QStandardItem(QString::fromStdString(font_info.get_family()));
+    auto *family =
+        new QStandardItem(QString::fromStdString(font_info.get_family()));
     family->setEditable(false);
     model->setItem(idx, COL_FONT_NAME, family);
 
-    auto *style = new QStandardItem(QString::fromStdString(font_info.get_style()));
+    auto *style =
+        new QStandardItem(QString::fromStdString(font_info.get_style()));
     style->setEditable(false);
     model->setItem(idx, COL_FONT_STYLE, style);
 
-    auto *styledFamily = new QStandardItem(QString::fromStdString(font_info.get_family()));
+    auto *styledFamily =
+        new QStandardItem(QString::fromStdString(font_info.get_family()));
     styledFamily->setEditable(false);
     styledFamily->setToolTip(toolTip.arg(family->text()).arg(style->text()));
     model->setItem(idx, COL_STYLED_FONT_NAME, styledFamily);
@@ -450,7 +430,8 @@ void FontList::update_font_list()
   proxy = new FontSortFilterProxyModel(this);
   proxy->setSourceModel(model);
   proxy->setFilterCaseSensitivity(Qt::CaseInsensitive);
-  groupBoxFilter->setTitle(QString("Filter (%1 fonts found)").arg(proxy->rowCount()));
+  groupBoxFilter->setTitle(
+      QString("Filter (%1 fonts found)").arg(proxy->rowCount()));
 
   this->tableView->setModel(proxy);
   on_actionResetColumns_triggered();
@@ -462,15 +443,13 @@ void FontList::update_font_list()
   this->tableView->resizeColumnsToContents();
   this->tableView->setSortingEnabled(true);
 
-  connect(tableView->selectionModel(), &QItemSelectionModel::selectionChanged, this, &FontList::selection_changed);
+  connect(tableView->selectionModel(), &QItemSelectionModel::selectionChanged,
+          this, &FontList::selection_changed);
 
   delete list;
 }
 
-void FontList::resizeEvent(QResizeEvent *event)
-{
-  QWidget::resizeEvent(event);
-}
+void FontList::resizeEvent(QResizeEvent *event) { QWidget::resizeEvent(event); }
 
 /**
  * Quote a string according to the requirements of font-config.
@@ -485,26 +464,22 @@ void FontList::resizeEvent(QResizeEvent *event)
  * @param text unquoted string
  * @return quoted text
  */
-QString FontList::quote(const QString& text)
-{
+QString FontList::quote(const QString &text) {
   QString result = text;
   result.replace('\\', R"(\\\\)")
-  .replace('-', "\\\\-")
-  .replace(':', "\\\\:")
-  .replace(',', "\\\\,")
-  .replace('=', "\\\\=")
-  .replace('_', "\\\\_");
+      .replace('-', "\\\\-")
+      .replace(':', "\\\\:")
+      .replace(',', "\\\\,")
+      .replace('=', "\\\\=")
+      .replace('_', "\\\\_");
   return result;
 }
 
-const QModelIndex FontList::colIdx(const QModelIndex& idx, int column)
-{
+const QModelIndex FontList::colIdx(const QModelIndex &idx, int column) {
   return idx.model()->index(idx.row(), column, idx.parent());
 }
 
-const QString FontList::colStr(const QModelIndex& idx, int column)
-{
-  return idx.model() ?
-         idx.model()->data(colIdx(idx, column)).toString() :
-         QString{};
+const QString FontList::colStr(const QModelIndex &idx, int column) {
+  return idx.model() ? idx.model()->data(colIdx(idx, column)).toString()
+                     : QString{};
 }
diff --git a/src/gui/FontList.h b/src/gui/FontList.h
index 5b9162219..1ba6ca446 100644
--- a/src/gui/FontList.h
+++ b/src/gui/FontList.h
@@ -12,16 +12,15 @@
 #include <cstdint>
 #include <vector>
 
-#include <QWidget>
+#include <QSortFilterProxyModel>
 #include <QStandardItemModel>
 #include <QStyledItemDelegate>
-#include <QSortFilterProxyModel>
+#include <QWidget>
 
 #include "gui/qtgettext.h"
 #include "ui_FontList.h"
 
-class FontItemDelegate : public QStyledItemDelegate
-{
+class FontItemDelegate : public QStyledItemDelegate {
   Q_OBJECT
 
 public:
@@ -29,47 +28,51 @@ public:
   int fontSize() const;
   void setFontSize(int fontSize);
   QString text() const;
-  void setText(const QString&);
-  QSize sizeHint(const QStyleOptionViewItem& option, const QModelIndex& index) const override;
-  void paint(QPainter *painter, const QStyleOptionViewItem& option, const QModelIndex& index) const override;
+  void setText(const QString &);
+  QSize sizeHint(const QStyleOptionViewItem &option,
+                 const QModelIndex &index) const override;
+  void paint(QPainter *painter, const QStyleOptionViewItem &option,
+             const QModelIndex &index) const override;
 
 protected:
-  void initStyleOption(QStyleOptionViewItem *option, const QModelIndex& index) const override;
-  QWidget *createEditor(QWidget *parent, const QStyleOptionViewItem& option, const QModelIndex& index) const override;
+  void initStyleOption(QStyleOptionViewItem *option,
+                       const QModelIndex &index) const override;
+  QWidget *createEditor(QWidget *parent, const QStyleOptionViewItem &option,
+                        const QModelIndex &index) const override;
 
 private:
   int _fontSize;
   QString _text;
 };
 
-class FontSortFilterProxyModel : public QSortFilterProxyModel
-{
+class FontSortFilterProxyModel : public QSortFilterProxyModel {
   Q_OBJECT
 
 public:
   FontSortFilterProxyModel(QObject *parent = nullptr);
 
   void clearFilter();
-  void appendFilterHashes(const std::vector<uint32_t>&);
+  void appendFilterHashes(const std::vector<uint32_t> &);
 
 protected:
-  bool filterAcceptsRow(int sourceRow, const QModelIndex& sourceParent) const override;
+  bool filterAcceptsRow(int sourceRow,
+                        const QModelIndex &sourceParent) const override;
 
 private:
   QSet<QString> filterHashes;
 };
 
-class FontList : public QWidget, public Ui::FontListWidget
-{
+class FontList : public QWidget, public Ui::FontListWidget {
   Q_OBJECT
-  static constexpr char SAMPLE_TEXT_DEFAULT[] = "abcdef ABCDEF 012345 0O5S8B 1Iil !$%&/()#";
+  static constexpr char SAMPLE_TEXT_DEFAULT[] =
+      "abcdef ABCDEF 012345 0O5S8B 1Iil !$%&/()#";
 
 public:
   FontList(QWidget *parent = nullptr);
-  FontList(const FontList& source) = delete;
-  FontList(FontList&& source) = delete;
-  FontList& operator=(const FontList& source) = delete;
-  FontList& operator=(FontList&& source) = delete;
+  FontList(const FontList &source) = delete;
+  FontList(FontList &&source) = delete;
+  FontList &operator=(const FontList &source) = delete;
+  FontList &operator=(FontList &&source) = delete;
   ~FontList() override = default;
 
   void initGUI();
@@ -85,27 +88,27 @@ public:
   static constexpr int COL_COUNT = 7;
 
 public slots:
-  void on_lineEditFontName_textChanged(const QString&);
+  void on_lineEditFontName_textChanged(const QString &);
   void on_comboBoxSearchType_currentIndexChanged(int);
-  void updateFilter(int, const QString&);
+  void updateFilter(int, const QString &);
 
   void on_comboBoxCharFilterType_currentIndexChanged(int);
-  void on_lineEditChars_textChanged(const QString&);
-  void updateCharFilter(int, const QString&);
+  void on_lineEditChars_textChanged(const QString &);
+  void updateCharFilter(int, const QString &);
 
   void on_actionResetSampleText_triggered();
-  void on_lineEditSampleText_textChanged(const QString&);
+  void on_lineEditSampleText_textChanged(const QString &);
   void on_spinBoxFontSize_valueChanged(int);
-  void updateSampleText(const QString&, int);
+  void updateSampleText(const QString &, int);
 
-  void customHeaderContexMenuRequested(const QPoint&);
-  void on_tableView_customContextMenuRequested(const QPoint&);
+  void customHeaderContexMenuRequested(const QPoint &);
+  void on_tableView_customContextMenuRequested(const QPoint &);
   void on_actionCopyFontName_triggered();
   void on_actionCopyStyle_triggered();
   void on_actionCopyFolder_triggered();
   void on_actionCopyFullPath_triggered();
   void on_actionOpenFolder_triggered();
-  void selection_changed(const QItemSelection&, const QItemSelection&);
+  void selection_changed(const QItemSelection &, const QItemSelection &);
 
   void showColumn(int, bool);
   void on_actionShowFontNameColumn_toggled(bool);
@@ -116,8 +119,8 @@ public slots:
   void on_actionShowFilePathColumn_toggled(bool);
   void on_actionResetColumns_triggered();
 
-  static const QModelIndex colIdx(const QModelIndex& idx, int column);
-  static const QString colStr(const QModelIndex& idx, int column);
+  static const QModelIndex colIdx(const QModelIndex &idx, int column);
+  static const QString colStr(const QModelIndex &idx, int column);
 
 signals:
   void font_selected(const QString font);
@@ -127,7 +130,7 @@ protected:
   void resizeEvent(QResizeEvent *event) override;
 
 private:
-  QString quote(const QString& text);
+  QString quote(const QString &text);
 
   QString selection;
   FontItemDelegate delegate;
diff --git a/src/gui/FontListDialog.cc b/src/gui/FontListDialog.cc
index 933971d1a..90d9996c5 100644
--- a/src/gui/FontListDialog.cc
+++ b/src/gui/FontListDialog.cc
@@ -28,43 +28,40 @@
 
 #include <QAbstractItemView>
 #include <QApplication>
+#include <QClipboard>
 #include <QItemSelection>
 #include <QModelIndex>
-#include <QClipboard>
 #include <QSortFilterProxyModel>
 
 #include "FontCache.h"
 
-FontListDialog::FontListDialog()
-{
+FontListDialog::FontListDialog() {
   model = nullptr;
   proxy = nullptr;
   setupUi(this);
   connect(this->okButton, &QPushButton::clicked, this, &FontListDialog::accept);
 }
 
-void FontListDialog::on_copyButton_clicked()
-{
+void FontListDialog::on_copyButton_clicked() {
   font_selected(selection);
 
   QClipboard *clipboard = QApplication::clipboard();
   clipboard->setText(selection);
 }
 
-void FontListDialog::on_filterLineEdit_textChanged(const QString& text)
-{
+void FontListDialog::on_filterLineEdit_textChanged(const QString &text) {
   proxy->setFilterWildcard(text);
 }
 
-void FontListDialog::selection_changed(const QItemSelection& current, const QItemSelection&)
-{
+void FontListDialog::selection_changed(const QItemSelection &current,
+                                       const QItemSelection &) {
   if (current.count() == 0) {
     copyButton->setEnabled(false);
     tableView->setDragText("");
     return;
   }
 
-  const QModelIndex& idx = proxy->mapToSource(current.indexes().at(0));
+  const QModelIndex &idx = proxy->mapToSource(current.indexes().at(0));
   const QString name = model->item(idx.row(), 0)->text();
   const QString style = model->item(idx.row(), 1)->text();
   selection = QString("\"%1:style=%2\"").arg(quote(name)).arg(quote(style));
@@ -72,8 +69,7 @@ void FontListDialog::selection_changed(const QItemSelection& current, const QIte
   tableView->setDragText(selection);
 }
 
-void FontListDialog::updateFontList()
-{
+void FontListDialog::updateFontList() {
   copyButton->setEnabled(false);
 
   if (proxy) {
@@ -93,7 +89,7 @@ void FontListDialog::updateFontList()
 
   int idx = 0;
   for (auto it = list->begin(); it != list->end(); it++, idx++) {
-    const FontInfo& font_info = (*it);
+    const FontInfo &font_info = (*it);
     auto *family = new QStandardItem(QString(font_info.get_family().c_str()));
     family->setEditable(false);
     model->setItem(idx, 0, family);
@@ -115,7 +111,8 @@ void FontListDialog::updateFontList()
   this->tableView->resizeColumnsToContents();
   this->tableView->setSortingEnabled(true);
 
-  connect(tableView->selectionModel(), &QItemSelectionModel::selectionChanged, this, &FontListDialog::selection_changed);
+  connect(tableView->selectionModel(), &QItemSelectionModel::selectionChanged,
+          this, &FontListDialog::selection_changed);
 
   delete list;
 }
@@ -133,14 +130,13 @@ void FontListDialog::updateFontList()
  * @param text unquoted string
  * @return quoted text
  */
-QString FontListDialog::quote(const QString& text)
-{
+QString FontListDialog::quote(const QString &text) {
   QString result = text;
   result.replace('\\', R"(\\\\)")
-  .replace('-', "\\\\-")
-  .replace(':', "\\\\:")
-  .replace(',', "\\\\,")
-  .replace('=', "\\\\=")
-  .replace('_', "\\\\_");
+      .replace('-', "\\\\-")
+      .replace(':', "\\\\:")
+      .replace(',', "\\\\,")
+      .replace('=', "\\\\=")
+      .replace('_', "\\\\_");
   return result;
 }
diff --git a/src/gui/FontListDialog.h b/src/gui/FontListDialog.h
index 89f540b51..f7533d866 100644
--- a/src/gui/FontListDialog.h
+++ b/src/gui/FontListDialog.h
@@ -2,16 +2,16 @@
 
 #include <QDialog>
 #include <QItemSelection>
-#include <QString>
-#include <QStandardItemModel>
 #include <QSortFilterProxyModel>
+#include <QStandardItemModel>
+#include <QString>
 
 #include "gui/qtgettext.h"
 #include "ui_FontListDialog.h"
 
-class FontListDialog : public QDialog, public Ui::FontListDialog
-{
+class FontListDialog : public QDialog, public Ui::FontListDialog {
   Q_OBJECT;
+
 public:
   FontListDialog();
 
@@ -19,14 +19,14 @@ public:
 
 public slots:
   void on_copyButton_clicked();
-  void on_filterLineEdit_textChanged(const QString&);
-  void selection_changed(const QItemSelection&, const QItemSelection&);
+  void on_filterLineEdit_textChanged(const QString &);
+  void selection_changed(const QItemSelection &, const QItemSelection &);
 
 signals:
   void font_selected(const QString font);
 
 private:
-  QString quote(const QString& text);
+  QString quote(const QString &text);
 
   QString selection;
   QStandardItemModel *model;
diff --git a/src/gui/FontListTableView.cc b/src/gui/FontListTableView.cc
index 00bf5291b..7a7199b29 100644
--- a/src/gui/FontListTableView.cc
+++ b/src/gui/FontListTableView.cc
@@ -25,27 +25,24 @@
  */
 #include "gui/FontListTableView.h"
 
-#include <QRect>
-#include <QString>
-#include <QWidget>
 #include <QDrag>
-#include <QPixmap>
-#include <QPainter>
 #include <QMimeData>
+#include <QPainter>
+#include <QPixmap>
+#include <QRect>
+#include <QString>
 #include <QTableView>
+#include <QWidget>
 
-FontListTableView::FontListTableView(QWidget *parent) : QTableView(parent)
-{
-}
+FontListTableView::FontListTableView(QWidget *parent) : QTableView(parent) {}
 
-void FontListTableView::setDragText(const QString& text)
-{
+void FontListTableView::setDragText(const QString &text) {
   this->text = text.trimmed();
 }
 
-void FontListTableView::startDrag(Qt::DropActions supportedActions)
-{
-  if (text.isEmpty()) return;
+void FontListTableView::startDrag(Qt::DropActions supportedActions) {
+  if (text.isEmpty())
+    return;
 
   auto mimeData = new QMimeData;
   mimeData->setText(text);
diff --git a/src/gui/FontListTableView.h b/src/gui/FontListTableView.h
index f2f0b4496..a9a409ac1 100644
--- a/src/gui/FontListTableView.h
+++ b/src/gui/FontListTableView.h
@@ -1,16 +1,15 @@
 #pragma once
 
 #include <QString>
-#include <QWidget>
 #include <QTableView>
+#include <QWidget>
 
-class FontListTableView : public QTableView
-{
+class FontListTableView : public QTableView {
   Q_OBJECT;
 
 public:
   FontListTableView(QWidget *parent = nullptr);
-  void setDragText(const QString& text);
+  void setDragText(const QString &text);
 
 protected:
   void startDrag(Qt::DropActions supportedActions) override;
diff --git a/src/gui/IgnoreWheelWhenNotFocused.cc b/src/gui/IgnoreWheelWhenNotFocused.cc
index fc12a915b..bd996484c 100644
--- a/src/gui/IgnoreWheelWhenNotFocused.cc
+++ b/src/gui/IgnoreWheelWhenNotFocused.cc
@@ -1,18 +1,19 @@
 #include "gui/IgnoreWheelWhenNotFocused.h"
+#include <QComboBox>
+#include <QDoubleSpinBox>
 #include <QEvent>
 #include <QObject>
-#include <QWidget>
-#include <QComboBox>
 #include <QSpinBox>
-#include <QDoubleSpinBox>
+#include <QWidget>
 
-void installIgnoreWheelWhenNotFocused(QWidget *parent){
+void installIgnoreWheelWhenNotFocused(QWidget *parent) {
   auto comboBoxes = parent->findChildren<QComboBox *>();
   auto spinBoxes = parent->findChildren<QSpinBox *>();
   auto spinDoubleBoxes = parent->findChildren<QDoubleSpinBox *>();
 
-  if (comboBoxes.size() == 0 && spinBoxes.size() == 0 && spinDoubleBoxes.size() == 0){
-    return; //nothing do
+  if (comboBoxes.size() == 0 && spinBoxes.size() == 0 &&
+      spinDoubleBoxes.size() == 0) {
+    return; // nothing do
   }
 
   auto *ignoreWheelWhenNotFocused = new IgnoreWheelWhenNotFocused(parent);
@@ -22,7 +23,7 @@ void installIgnoreWheelWhenNotFocused(QWidget *parent){
     comboBox->setFocusPolicy(Qt::StrongFocus);
   }
 
-  for (const auto& spinBox : spinBoxes){
+  for (const auto &spinBox : spinBoxes) {
     spinBox->installEventFilter(ignoreWheelWhenNotFocused);
     spinBox->setFocusPolicy(Qt::StrongFocus);
   }
@@ -32,15 +33,13 @@ void installIgnoreWheelWhenNotFocused(QWidget *parent){
     spinDoubleBox->setFocusPolicy(Qt::StrongFocus);
   }
 
-}  // NOLINT(clang-analyzer-cplusplus.NewDeleteLeaks): False positive
+} // NOLINT(clang-analyzer-cplusplus.NewDeleteLeaks): False positive
 
-IgnoreWheelWhenNotFocused::IgnoreWheelWhenNotFocused(QWidget *parent) : QObject(parent)
-{
-}
+IgnoreWheelWhenNotFocused::IgnoreWheelWhenNotFocused(QWidget *parent)
+    : QObject(parent) {}
 
-//https://stackoverflow.com/questions/5821802/qspinbox-inside-a-qscrollarea-how-to-prevent-spin-box-from-stealing-focus-when
-bool IgnoreWheelWhenNotFocused::eventFilter(QObject *obj, QEvent *event)
-{
+// https://stackoverflow.com/questions/5821802/qspinbox-inside-a-qscrollarea-how-to-prevent-spin-box-from-stealing-focus-when
+bool IgnoreWheelWhenNotFocused::eventFilter(QObject *obj, QEvent *event) {
   if (event->type() == QEvent::Wheel) {
     if (!((QWidget *)obj)->hasFocus()) {
       return true;
@@ -51,4 +50,3 @@ bool IgnoreWheelWhenNotFocused::eventFilter(QObject *obj, QEvent *event)
     return QObject::eventFilter(obj, event);
   }
 }
-
diff --git a/src/gui/IgnoreWheelWhenNotFocused.h b/src/gui/IgnoreWheelWhenNotFocused.h
index 192b80d77..0e4917713 100644
--- a/src/gui/IgnoreWheelWhenNotFocused.h
+++ b/src/gui/IgnoreWheelWhenNotFocused.h
@@ -1,26 +1,25 @@
-//This event filter ignores Mouse Wheel events when the object is not focused.
-//A lot of elements in OpenSCAD are in Scroll Areas.
-//This causes a conflict, as some elements within the Scroll Areas are
-//also reacting to the mousewheel.
-//Especially in the settings, where the user might spend a considerable
-//amount of time to get it just right, it is annoying when simply
-//scrowling down unintentionally changes various settings.
+// This event filter ignores Mouse Wheel events when the object is not focused.
+// A lot of elements in OpenSCAD are in Scroll Areas.
+// This causes a conflict, as some elements within the Scroll Areas are
+// also reacting to the mousewheel.
+// Especially in the settings, where the user might spend a considerable
+// amount of time to get it just right, it is annoying when simply
+// scrowling down unintentionally changes various settings.
 
-//for reference:
-//https://stackoverflow.com/questions/5821802/qspinbox-inside-a-qscrollarea-how-to-prevent-spin-box-from-stealing-focus-when
-//http://doc.qt.io/archives/qt-4.8/qobject.html#installEventFilter
+// for reference:
+// https://stackoverflow.com/questions/5821802/qspinbox-inside-a-qscrollarea-how-to-prevent-spin-box-from-stealing-focus-when
+// http://doc.qt.io/archives/qt-4.8/qobject.html#installEventFilter
 
 #pragma once
 
 #include <QEvent>
+#include <QMouseEvent>
 #include <QObject>
 #include <QWidget>
-#include <QMouseEvent>
 
 void installIgnoreWheelWhenNotFocused(QWidget *parent);
 
-class IgnoreWheelWhenNotFocused : public QObject
-{
+class IgnoreWheelWhenNotFocused : public QObject {
   Q_OBJECT
 public:
   IgnoreWheelWhenNotFocused(QWidget *parent);
@@ -28,4 +27,3 @@ public:
 protected:
   bool eventFilter(QObject *obj, QEvent *event) override;
 };
-
diff --git a/src/gui/ImportUtils.cc b/src/gui/ImportUtils.cc
index 25097a58d..ab26d1ee4 100644
--- a/src/gui/ImportUtils.cc
+++ b/src/gui/ImportUtils.cc
@@ -2,7 +2,7 @@
 
 QMap<QString, QString> Importer::knownFileExtensions;
 
-int Importer::init(){
+int Importer::init() {
   const QString importStatement = "import(\"%1\");\n";
   const QString surfaceStatement = "surface(\"%1\");\n";
   const QString importFunction = "data = import(\"%1\");\n";
diff --git a/src/gui/ImportUtils.h b/src/gui/ImportUtils.h
index f186ad3c8..e5090e32a 100644
--- a/src/gui/ImportUtils.h
+++ b/src/gui/ImportUtils.h
@@ -3,8 +3,7 @@
 #include <QMap>
 #include <QString>
 
-class Importer
-{
+class Importer {
 public:
   static int init();
   static QMap<QString, QString> knownFileExtensions;
diff --git a/src/gui/InitConfigurator.cc b/src/gui/InitConfigurator.cc
index 14ed64320..cdfa8cb22 100644
--- a/src/gui/InitConfigurator.cc
+++ b/src/gui/InitConfigurator.cc
@@ -1,45 +1,46 @@
 
 #include "gui/InitConfigurator.h"
 
-#include <QListWidget>
 #include <QCheckBox>
 #include <QComboBox>
 #include <QDoubleSpinBox>
+#include <QGroupBox>
+#include <QLineEdit>
+#include <QListWidget>
 #include <QRadioButton>
+#include <QSettings>
 #include <QSpinBox>
 #include <QString>
-#include <QSettings>
-#include <QLineEdit>
-#include <QGroupBox>
 
 #include "core/Settings.h"
 #include "gui/SettingsWriter.h"
 
 #include <string>
 
-void InitConfigurator::writeSettings()
-{
+void InitConfigurator::writeSettings() {
   Settings::Settings::visit(SettingsWriter());
 }
 
-void InitConfigurator::initUpdateCheckBox(const BlockSignals<QCheckBox *>& checkBox, const Settings::SettingsEntryBool& entry)
-{
+void InitConfigurator::initUpdateCheckBox(
+    const BlockSignals<QCheckBox *> &checkBox,
+    const Settings::SettingsEntryBool &entry) {
   checkBox->setChecked(entry.value());
 }
 
-void InitConfigurator::initIntSpinBox(const BlockSignals<QSpinBox *>& spinBox, const Settings::SettingsEntryInt& entry)
-{
+void InitConfigurator::initIntSpinBox(const BlockSignals<QSpinBox *> &spinBox,
+                                      const Settings::SettingsEntryInt &entry) {
   spinBox->setMinimum(entry.minimum());
   spinBox->setMaximum(entry.maximum());
 }
 
-void InitConfigurator::updateIntSpinBox(const BlockSignals<QSpinBox *>& spinBox, const Settings::SettingsEntryInt& entry)
-{
+void InitConfigurator::updateIntSpinBox(
+    const BlockSignals<QSpinBox *> &spinBox,
+    const Settings::SettingsEntryInt &entry) {
   spinBox->setValue(entry.value());
 }
 
-void InitConfigurator::initUpdateDoubleSpinBox(QDoubleSpinBox *spinBox, const Settings::SettingsEntryDouble& entry)
-{
+void InitConfigurator::initUpdateDoubleSpinBox(
+    QDoubleSpinBox *spinBox, const Settings::SettingsEntryDouble &entry) {
   spinBox->blockSignals(true);
   spinBox->setSingleStep(entry.step());
   spinBox->setMinimum(entry.minimum());
@@ -48,28 +49,37 @@ void InitConfigurator::initUpdateDoubleSpinBox(QDoubleSpinBox *spinBox, const Se
   spinBox->blockSignals(false);
 }
 
-void InitConfigurator::initListBox(QListWidget *listBox, const Settings::SettingsEntryList<Settings::LocalAppParameter>& list)
-{
+void InitConfigurator::initListBox(
+    QListWidget *listBox,
+    const Settings::SettingsEntryList<Settings::LocalAppParameter> &list) {
   listBox->blockSignals(true);
   listBox->clear();
-  for (const auto& listitem : list.value()) {
+  for (const auto &listitem : list.value()) {
     if (listitem.type == Settings::LocalAppParameterType::string) {
-      const auto item = createListItem(Settings::LocalAppParameterType(Settings::LocalAppParameterType::string), QString::fromStdString(listitem.value));
+      const auto item =
+          createListItem(Settings::LocalAppParameterType(
+                             Settings::LocalAppParameterType::string),
+                         QString::fromStdString(listitem.value));
       listBox->insertItem(listBox->count(), item);
     } else if (listitem.type == Settings::LocalAppParameterType::file) {
-      const auto item = createListItem(Settings::LocalAppParameterType(Settings::LocalAppParameterType::file));
+      const auto item = createListItem(Settings::LocalAppParameterType(
+          Settings::LocalAppParameterType::file));
       listBox->insertItem(listBox->count(), item);
     } else if (listitem.type == Settings::LocalAppParameterType::dir) {
-      const auto item = createListItem(Settings::LocalAppParameterType(Settings::LocalAppParameterType::dir));
+      const auto item = createListItem(Settings::LocalAppParameterType(
+          Settings::LocalAppParameterType::dir));
       listBox->insertItem(listBox->count(), item);
     } else if (listitem.type == Settings::LocalAppParameterType::extension) {
-      const auto item = createListItem(Settings::LocalAppParameterType(Settings::LocalAppParameterType::extension));
+      const auto item = createListItem(Settings::LocalAppParameterType(
+          Settings::LocalAppParameterType::extension));
       listBox->insertItem(listBox->count(), item);
     } else if (listitem.type == Settings::LocalAppParameterType::source) {
-      const auto item = createListItem(Settings::LocalAppParameterType(Settings::LocalAppParameterType::source));
+      const auto item = createListItem(Settings::LocalAppParameterType(
+          Settings::LocalAppParameterType::source));
       listBox->insertItem(listBox->count(), item);
     } else if (listitem.type == Settings::LocalAppParameterType::sourcedir) {
-      const auto item = createListItem(Settings::LocalAppParameterType(Settings::LocalAppParameterType::sourcedir));
+      const auto item = createListItem(Settings::LocalAppParameterType(
+          Settings::LocalAppParameterType::sourcedir));
       listBox->insertItem(listBox->count(), item);
     }
   }
@@ -77,8 +87,8 @@ void InitConfigurator::initListBox(QListWidget *listBox, const Settings::Setting
   listBox->blockSignals(false);
 }
 
-void InitConfigurator::updateComboBox(const BlockSignals<QComboBox *>& comboBox, const std::string& value)
-{
+void InitConfigurator::updateComboBox(const BlockSignals<QComboBox *> &comboBox,
+                                      const std::string &value) {
   int index = comboBox->findData(QString::fromStdString(value));
   if (index >= 0) {
     comboBox->setCurrentIndex(index);
@@ -87,14 +97,20 @@ void InitConfigurator::updateComboBox(const BlockSignals<QComboBox *>& comboBox,
   }
 }
 
-void InitConfigurator::initMetaData(QCheckBox *checkBox, QLineEdit *lineEdit, Settings::SettingsEntryBool *settingsEntryFlag, Settings::SettingsEntryString& settingsEntry) {
+void InitConfigurator::initMetaData(
+    QCheckBox *checkBox, QLineEdit *lineEdit,
+    Settings::SettingsEntryBool *settingsEntryFlag,
+    Settings::SettingsEntryString &settingsEntry) {
   lineEdit->setText(QString::fromStdString(settingsEntry.value()));
   if (checkBox && settingsEntryFlag) {
     checkBox->setChecked(settingsEntryFlag->value());
   }
 }
 
-void InitConfigurator::applyMetaData(const QCheckBox *checkBox, const QLineEdit *lineEdit, Settings::SettingsEntryBool *settingsEntryFlag, Settings::SettingsEntryString& settingsEntry) {
+void InitConfigurator::applyMetaData(
+    const QCheckBox *checkBox, const QLineEdit *lineEdit,
+    Settings::SettingsEntryBool *settingsEntryFlag,
+    Settings::SettingsEntryString &settingsEntry) {
   if (checkBox && settingsEntryFlag) {
     settingsEntryFlag->setValue(checkBox->isChecked());
   }
diff --git a/src/gui/InitConfigurator.h b/src/gui/InitConfigurator.h
index 10557128c..a5c8ae167 100644
--- a/src/gui/InitConfigurator.h
+++ b/src/gui/InitConfigurator.h
@@ -1,72 +1,89 @@
 #pragma once
 
-#include <QSettings>
-#include <QObject>
-#include <QComboBox>
-#include <QSpinBox>
+#include <QButtonGroup>
 #include <QCheckBox>
+#include <QComboBox>
 #include <QListWidget>
-#include <QButtonGroup>
+#include <QObject>
+#include <QSettings>
+#include <QSpinBox>
 #include <cstdint>
 #include <string>
 
 #include "core/Settings.h"
 
-template <class WidgetPtr>
-class BlockSignals
-{
+template <class WidgetPtr> class BlockSignals {
 public:
   BlockSignals(WidgetPtr w) : w(w) { w->blockSignals(true); }
   ~BlockSignals() { w->blockSignals(false); }
   WidgetPtr operator->() const { return w; }
 
-  BlockSignals(const BlockSignals&) = delete;
-  BlockSignals& operator=(BlockSignals const&) = delete;
+  BlockSignals(const BlockSignals &) = delete;
+  BlockSignals &operator=(BlockSignals const &) = delete;
 
 private:
   WidgetPtr w;
 };
 
-class InitConfigurator
-{
+class InitConfigurator {
 protected:
   void writeSettings();
   /** Set checkbox status from the settings value */
-  void initUpdateCheckBox(const BlockSignals<QCheckBox *>& checkBox, const Settings::SettingsEntryBool& entry);
+  void initUpdateCheckBox(const BlockSignals<QCheckBox *> &checkBox,
+                          const Settings::SettingsEntryBool &entry);
   /** Initialize spinbox min/max values from the settings range values */
-  void initIntSpinBox(const BlockSignals<QSpinBox *>& spinBox, const Settings::SettingsEntryInt& entry);
+  void initIntSpinBox(const BlockSignals<QSpinBox *> &spinBox,
+                      const Settings::SettingsEntryInt &entry);
   /** Set spinbox value from the settings value */
-  void updateIntSpinBox(const BlockSignals<QSpinBox *>& spinBox, const Settings::SettingsEntryInt& entry);
+  void updateIntSpinBox(const BlockSignals<QSpinBox *> &spinBox,
+                        const Settings::SettingsEntryInt &entry);
   /** Set spinbox value and min/max/step from the settings value */
-  void initUpdateDoubleSpinBox(QDoubleSpinBox *spinBox, const Settings::SettingsEntryDouble& entry);
+  void initUpdateDoubleSpinBox(QDoubleSpinBox *spinBox,
+                               const Settings::SettingsEntryDouble &entry);
   /** Initialize specialized list box */
-  void initListBox(QListWidget *listBox, const Settings::SettingsEntryList<Settings::LocalAppParameter>& list);
+  void initListBox(
+      QListWidget *listBox,
+      const Settings::SettingsEntryList<Settings::LocalAppParameter> &list);
   /** Initialize combobox list values from the settings range values */
   template <typename enum_type>
-  void initComboBox(QComboBox *comboBox, const Settings::SettingsEntryEnum<enum_type>& entry);
+  void initComboBox(QComboBox *comboBox,
+                    const Settings::SettingsEntryEnum<enum_type> &entry);
   /** Update combobox from current settings */
   template <typename enum_type>
-  void updateComboBox(const BlockSignals<QComboBox *>& comboBox, const Settings::SettingsEntryEnum<enum_type>& entry);
+  void updateComboBox(const BlockSignals<QComboBox *> &comboBox,
+                      const Settings::SettingsEntryEnum<enum_type> &entry);
   /** Update combobox from current settings */
-  void updateComboBox(const BlockSignals<QComboBox *>& comboBox, const std::string& value);
-  /** Init a button group with an enum setting, this needs a custom property on the radio buttons */
+  void updateComboBox(const BlockSignals<QComboBox *> &comboBox,
+                      const std::string &value);
+  /** Init a button group with an enum setting, this needs a custom property on
+   * the radio buttons */
   template <typename enum_type>
-  void initButtonGroup(const BlockSignals<QButtonGroup *>& buttonGroup, const Settings::SettingsEntryEnum<enum_type>& entry);
-  /** Apply selected value from button to settings, this needs a custom property on the radio buttons */
+  void initButtonGroup(const BlockSignals<QButtonGroup *> &buttonGroup,
+                       const Settings::SettingsEntryEnum<enum_type> &entry);
+  /** Apply selected value from button to settings, this needs a custom property
+   * on the radio buttons */
   template <typename enum_type>
-  void applyButtonGroup(const BlockSignals<QButtonGroup *>& buttonGroup, Settings::SettingsEntryEnum<enum_type>& entry);
+  void applyButtonGroup(const BlockSignals<QButtonGroup *> &buttonGroup,
+                        Settings::SettingsEntryEnum<enum_type> &entry);
 
-  void initMetaData(QCheckBox *, QLineEdit *, Settings::SettingsEntryBool *, Settings::SettingsEntryString&);
-  void applyMetaData(const QCheckBox *, const QLineEdit *, Settings::SettingsEntryBool *, Settings::SettingsEntryString&);
+  void initMetaData(QCheckBox *, QLineEdit *, Settings::SettingsEntryBool *,
+                    Settings::SettingsEntryString &);
+  void applyMetaData(const QCheckBox *, const QLineEdit *,
+                     Settings::SettingsEntryBool *,
+                     Settings::SettingsEntryString &);
 
   template <typename item_type>
-  QListWidgetItem *createListItem(const item_type& itemType, const QString& text = "", bool editable = false) {
+  QListWidgetItem *createListItem(const item_type &itemType,
+                                  const QString &text = "",
+                                  bool editable = false) {
     const auto icon = QIcon::fromTheme(QString::fromStdString(itemType.icon()));
     std::string description = itemType.description();
-    const auto itemText = description.empty() ? text : QString::fromStdString(description);
-    const auto listItem = new QListWidgetItem(icon, itemText,
-                                              nullptr,
-                                              static_cast<int>(QListWidgetItem::UserType) + static_cast<int>(itemType));
+    const auto itemText =
+        description.empty() ? text : QString::fromStdString(description);
+    const auto listItem =
+        new QListWidgetItem(icon, itemText, nullptr,
+                            static_cast<int>(QListWidgetItem::UserType) +
+                                static_cast<int>(itemType));
     if (editable) {
       listItem->setFlags(listItem->flags() | Qt::ItemIsEditable);
     }
@@ -75,26 +92,30 @@ protected:
 };
 
 template <typename enum_type>
-void InitConfigurator::initComboBox(QComboBox *comboBox, const Settings::SettingsEntryEnum<enum_type>& entry)
-{
+void InitConfigurator::initComboBox(
+    QComboBox *comboBox, const Settings::SettingsEntryEnum<enum_type> &entry) {
   comboBox->clear();
-  for (const auto& item : entry.items()) {
-    comboBox->addItem(QString::fromStdString(item.description), QString::fromStdString(item.name));
+  for (const auto &item : entry.items()) {
+    comboBox->addItem(QString::fromStdString(item.description),
+                      QString::fromStdString(item.name));
   }
   updateComboBox(comboBox, entry);
 }
 
 template <typename enum_type>
-void InitConfigurator::updateComboBox(const BlockSignals<QComboBox *>& comboBox, const Settings::SettingsEntryEnum<enum_type>& entry)
-{
+void InitConfigurator::updateComboBox(
+    const BlockSignals<QComboBox *> &comboBox,
+    const Settings::SettingsEntryEnum<enum_type> &entry) {
   comboBox->setCurrentIndex(entry.index());
 }
 
 template <typename enum_type>
-void InitConfigurator::initButtonGroup(const BlockSignals<QButtonGroup *>& buttonGroup, const Settings::SettingsEntryEnum<enum_type>& entry)
-{
+void InitConfigurator::initButtonGroup(
+    const BlockSignals<QButtonGroup *> &buttonGroup,
+    const Settings::SettingsEntryEnum<enum_type> &entry) {
   for (const auto button : buttonGroup->buttons()) {
-    const auto settingsValue = button->property(Settings::PROPERTY_NAME).toString().toStdString();
+    const auto settingsValue =
+        button->property(Settings::PROPERTY_NAME).toString().toStdString();
     if (settingsValue == entry.item().name) {
       button->setChecked(true);
     }
@@ -102,11 +123,13 @@ void InitConfigurator::initButtonGroup(const BlockSignals<QButtonGroup *>& butto
 }
 
 template <typename enum_type>
-void InitConfigurator::applyButtonGroup(const BlockSignals<QButtonGroup *>& buttonGroup, Settings::SettingsEntryEnum<enum_type>& entry)
-{
+void InitConfigurator::applyButtonGroup(
+    const BlockSignals<QButtonGroup *> &buttonGroup,
+    Settings::SettingsEntryEnum<enum_type> &entry) {
   const auto button = buttonGroup->checkedButton();
   if (button) {
-    const auto settingsValue = button->property(Settings::PROPERTY_NAME).toString().toStdString();
+    const auto settingsValue =
+        button->property(Settings::PROPERTY_NAME).toString().toStdString();
     entry.setValue(entry.decode(settingsValue));
   }
 }
diff --git a/src/gui/LaunchingScreen.cc b/src/gui/LaunchingScreen.cc
index adc36e103..1f920ef62 100644
--- a/src/gui/LaunchingScreen.cc
+++ b/src/gui/LaunchingScreen.cc
@@ -1,45 +1,44 @@
 #include "gui/LaunchingScreen.h"
 
 #include <QDialog>
+#include <QFileInfo>
+#include <QListWidgetItem>
 #include <QModelIndex>
 #include <QStringList>
 #include <QVariant>
 #include <QWidget>
-#include <QFileInfo>
-#include <QListWidgetItem>
 
-#include "version.h"
-#include "ui_LaunchingScreen.h"
 #include "gui/QSettingsCached.h"
+#include "ui_LaunchingScreen.h"
+#include "version.h"
 
 #include "gui/UIUtils.h"
 
 LaunchingScreen *LaunchingScreen::inst = nullptr;
 
-LaunchingScreen *LaunchingScreen::getDialog() {
-  return LaunchingScreen::inst;
-}
+LaunchingScreen *LaunchingScreen::getDialog() { return LaunchingScreen::inst; }
 
 // Called (possibly multiple times) by EventFilter on MacOS, e.g.
 // when the user opens files from Finder.
-void LaunchingScreen::openFile(const QString& filename)
-{
+void LaunchingScreen::openFile(const QString &filename) {
   QVariant v(filename);
   this->checkOpen(v, false);
   this->done(QDialog::Accepted);
 }
 
-LaunchingScreen::LaunchingScreen(QWidget *parent) : QDialog(parent)
-{
+LaunchingScreen::LaunchingScreen(QWidget *parent) : QDialog(parent) {
   LaunchingScreen::inst = this;
   setupUi(this);
 
-  this->setStyleSheet("QDialog {background-image:url(':/icons/background.png')} QPushButton {color:white;}");
+  this->setStyleSheet(
+      "QDialog {background-image:url(':/icons/background.png')} QPushButton "
+      "{color:white;}");
 
-  this->versionNumberLabel->setText("OpenSCAD " + QString::fromStdString(openscad_displayversionnumber));
+  this->versionNumberLabel->setText(
+      "OpenSCAD " + QString::fromStdString(openscad_displayversionnumber));
 
   QStringList recentFiles = UIUtils::recentFiles();
-  for (const auto& recentFile : recentFiles) {
+  for (const auto &recentFile : recentFiles) {
     QFileInfo fileInfo(recentFile);
     auto item = new QListWidgetItem(fileInfo.fileName());
     item->setData(Qt::ToolTipRole, fileInfo.canonicalPath());
@@ -47,14 +46,16 @@ LaunchingScreen::LaunchingScreen(QWidget *parent) : QDialog(parent)
     this->recentList->addItem(item);
   }
 
-  for (const auto& category : UIUtils::exampleCategories()) {
+  for (const auto &category : UIUtils::exampleCategories()) {
     auto examples = UIUtils::exampleFiles(category.name);
-    auto categoryItem = new QTreeWidgetItem(QStringList(gettext(category.name.toStdString().c_str())));
+    auto categoryItem = new QTreeWidgetItem(
+        QStringList(gettext(category.name.toStdString().c_str())));
     if (!category.tooltip.trimmed().isEmpty()) {
-      categoryItem->setToolTip(0, gettext(category.tooltip.toStdString().c_str()));
+      categoryItem->setToolTip(0,
+                               gettext(category.tooltip.toStdString().c_str()));
     }
 
-    for (const auto& example : examples) {
+    for (const auto &example : examples) {
       auto exampleItem = new QTreeWidgetItem(QStringList(example.fileName()));
       exampleItem->setData(0, Qt::UserRole, example.canonicalFilePath());
       categoryItem->addChild(exampleItem);
@@ -63,43 +64,46 @@ LaunchingScreen::LaunchingScreen(QWidget *parent) : QDialog(parent)
     this->treeWidget->addTopLevelItem(categoryItem);
   }
 
-  connect(this->pushButtonNew, &QPushButton::clicked, this, &LaunchingScreen::accept);
-  connect(this->pushButtonOpen, &QPushButton::clicked, this, &LaunchingScreen::openUserFile);
-  connect(this->pushButtonHelp, &QPushButton::clicked, this, &LaunchingScreen::openUserManualURL);
-  connect(this->recentList->selectionModel(), &QItemSelectionModel::currentRowChanged, this, &LaunchingScreen::enableRecentButton);
-
-  connect(this->recentList, &QListWidget::itemDoubleClicked, this, &LaunchingScreen::openRecent);
-  connect(this->treeWidget, &QTreeWidget::currentItemChanged, this, &LaunchingScreen::enableExampleButton);
-
-  connect(this->treeWidget, &QTreeWidget::itemDoubleClicked, this, &LaunchingScreen::openExample);
-  connect(this->openRecentButton, &QPushButton::clicked, this, &LaunchingScreen::openRecent);
-  connect(this->openExampleButton, &QPushButton::clicked, this, &LaunchingScreen::openExample);
-  connect(this->checkBox, &QCheckBox::toggled, this, &LaunchingScreen::checkboxState);
+  connect(this->pushButtonNew, &QPushButton::clicked, this,
+          &LaunchingScreen::accept);
+  connect(this->pushButtonOpen, &QPushButton::clicked, this,
+          &LaunchingScreen::openUserFile);
+  connect(this->pushButtonHelp, &QPushButton::clicked, this,
+          &LaunchingScreen::openUserManualURL);
+  connect(this->recentList->selectionModel(),
+          &QItemSelectionModel::currentRowChanged, this,
+          &LaunchingScreen::enableRecentButton);
+
+  connect(this->recentList, &QListWidget::itemDoubleClicked, this,
+          &LaunchingScreen::openRecent);
+  connect(this->treeWidget, &QTreeWidget::currentItemChanged, this,
+          &LaunchingScreen::enableExampleButton);
+
+  connect(this->treeWidget, &QTreeWidget::itemDoubleClicked, this,
+          &LaunchingScreen::openExample);
+  connect(this->openRecentButton, &QPushButton::clicked, this,
+          &LaunchingScreen::openRecent);
+  connect(this->openExampleButton, &QPushButton::clicked, this,
+          &LaunchingScreen::openExample);
+  connect(this->checkBox, &QCheckBox::toggled, this,
+          &LaunchingScreen::checkboxState);
 }
 
-LaunchingScreen::~LaunchingScreen()
-{
-  LaunchingScreen::inst = nullptr;
-}
+LaunchingScreen::~LaunchingScreen() { LaunchingScreen::inst = nullptr; }
 
-QStringList LaunchingScreen::selectedFiles() const
-{
-  return this->files;
-}
+QStringList LaunchingScreen::selectedFiles() const { return this->files; }
 
-bool LaunchingScreen::isForceShowEditor() const
-{
+bool LaunchingScreen::isForceShowEditor() const {
   return this->forceShowEditor || this->files.isEmpty();
 }
 
-void LaunchingScreen::enableRecentButton(const QModelIndex&, const QModelIndex&)
-{
+void LaunchingScreen::enableRecentButton(const QModelIndex &,
+                                         const QModelIndex &) {
   this->openRecentButton->setEnabled(true);
   this->openRecentButton->setDefault(true);
 }
 
-void LaunchingScreen::openRecent()
-{
+void LaunchingScreen::openRecent() {
   QListWidgetItem *item = this->recentList->currentItem();
   if (item == nullptr) {
     return;
@@ -108,15 +112,14 @@ void LaunchingScreen::openRecent()
   checkOpen(item->data(Qt::UserRole), false);
 }
 
-void LaunchingScreen::enableExampleButton(QTreeWidgetItem *current, QTreeWidgetItem *)
-{
+void LaunchingScreen::enableExampleButton(QTreeWidgetItem *current,
+                                          QTreeWidgetItem *) {
   const bool enable = current->childCount() == 0;
   this->openExampleButton->setEnabled(enable);
   this->openExampleButton->setDefault(true);
 }
 
-void LaunchingScreen::openExample()
-{
+void LaunchingScreen::openExample() {
   QTreeWidgetItem *item = this->treeWidget->currentItem();
   if (item == nullptr) {
     return;
@@ -125,8 +128,7 @@ void LaunchingScreen::openExample()
   checkOpen(item->data(0, Qt::UserRole), true);
 }
 
-void LaunchingScreen::checkOpen(const QVariant& data, bool forceShowEditor)
-{
+void LaunchingScreen::checkOpen(const QVariant &data, bool forceShowEditor) {
   const QString path = data.toString();
   if (path.isEmpty()) {
     return;
@@ -137,8 +139,7 @@ void LaunchingScreen::checkOpen(const QVariant& data, bool forceShowEditor)
   accept();
 }
 
-void LaunchingScreen::openUserFile()
-{
+void LaunchingScreen::openUserFile() {
   QFileInfo fileInfo = UIUtils::openFile(this);
   if (fileInfo.exists()) {
     this->forceShowEditor = false;
@@ -147,13 +148,11 @@ void LaunchingScreen::openUserFile()
   }
 }
 
-void LaunchingScreen::checkboxState(bool state) const
-{
+void LaunchingScreen::checkboxState(bool state) const {
   QSettingsCached settings;
   settings.setValue("launcher/showOnStartup", !state);
 }
 
-void LaunchingScreen::openUserManualURL() const
-{
+void LaunchingScreen::openUserManualURL() const {
   UIUtils::openUserManualURL();
 }
diff --git a/src/gui/LaunchingScreen.h b/src/gui/LaunchingScreen.h
index dba08efa9..f0756ec55 100644
--- a/src/gui/LaunchingScreen.h
+++ b/src/gui/LaunchingScreen.h
@@ -1,18 +1,17 @@
 #pragma once
 
+#include <QDialog>
 #include <QModelIndex>
+#include <QString>
 #include <QStringList>
+#include <QTreeWidgetItem>
 #include <QVariant>
 #include <QWidget>
-#include <QString>
-#include <QDialog>
-#include <QTreeWidgetItem>
 
 #include "gui/qtgettext.h" // IWYU pragma: keep
 #include "ui_LaunchingScreen.h"
 
-class LaunchingScreen : public QDialog, public Ui::LaunchingScreen
-{
+class LaunchingScreen : public QDialog, public Ui::LaunchingScreen {
   Q_OBJECT
 
 public:
@@ -23,11 +22,12 @@ public:
   bool isForceShowEditor() const;
 
 public slots:
-  void openFile(const QString& filename);
+  void openFile(const QString &filename);
 
 private slots:
   void checkboxState(bool state) const;
-  void enableRecentButton(const QModelIndex& current, const QModelIndex& previous);
+  void enableRecentButton(const QModelIndex &current,
+                          const QModelIndex &previous);
   void enableExampleButton(QTreeWidgetItem *current, QTreeWidgetItem *previous);
   void openUserFile();
   void openRecent();
@@ -35,7 +35,7 @@ private slots:
   void openUserManualURL() const;
 
 private:
-  void checkOpen(const QVariant& data, bool forceShowEditor);
+  void checkOpen(const QVariant &data, bool forceShowEditor);
 
   QStringList files;
   bool forceShowEditor{true};
diff --git a/src/gui/LibraryInfoDialog.cc b/src/gui/LibraryInfoDialog.cc
index 9742125a9..d63bc9975 100644
--- a/src/gui/LibraryInfoDialog.cc
+++ b/src/gui/LibraryInfoDialog.cc
@@ -1,25 +1,24 @@
 
 #include "gui/LibraryInfoDialog.h"
 
+#include "LibraryInfo.h"
 #include <QString>
 #include <QStringRef>
 #include <QTextEdit>
-#include "LibraryInfo.h"
 
-LibraryInfoDialog::LibraryInfoDialog(const QString& rendererInfo)
-{
+LibraryInfoDialog::LibraryInfoDialog(const QString &rendererInfo) {
   setupUi(this);
-  connect(this->okButton, &QPushButton::clicked, this, &LibraryInfoDialog::accept);
+  connect(this->okButton, &QPushButton::clicked, this,
+          &LibraryInfoDialog::accept);
   updateLibraryInfo(rendererInfo);
 }
 
-void LibraryInfoDialog::updateLibraryInfo(const QString& rendererInfo)
-{
-  //Get library infos
+void LibraryInfoDialog::updateLibraryInfo(const QString &rendererInfo) {
+  // Get library infos
   QString info(LibraryInfo::info().c_str());
   info += rendererInfo;
 
-  //Parse infos and make it html
+  // Parse infos and make it html
   info = info.replace("<", "&lt;").replace(">", "&gt;").replace("\n", "<br/>");
 
   auto end = false;
@@ -27,13 +26,13 @@ void LibraryInfoDialog::updateLibraryInfo(const QString& rendererInfo)
   while (!end) {
     int endIndex = info.indexOf(":", startIndex);
     if (endIndex != -1) {
-      //add bold to property name
+      // add bold to property name
       info = info.insert(startIndex, "<b>");
       endIndex += 3;
       info = info.replace(endIndex, 1, ":</b>");
       startIndex = info.indexOf("<br/>", endIndex);
 
-      //handle property with multiple lines
+      // handle property with multiple lines
       auto endInd = info.indexOf(":", startIndex);
       if (endInd != -1) {
         QStringRef lines(&info, startIndex, endInd - startIndex);
diff --git a/src/gui/LibraryInfoDialog.h b/src/gui/LibraryInfoDialog.h
index c7f6c8fa4..a853d92de 100644
--- a/src/gui/LibraryInfoDialog.h
+++ b/src/gui/LibraryInfoDialog.h
@@ -6,12 +6,11 @@
 #include "gui/qtgettext.h" // IWYU pragma: keep
 #include "ui_LibraryInfoDialog.h"
 
-class LibraryInfoDialog : public QDialog, public Ui::LibraryInfoDialog
-{
+class LibraryInfoDialog : public QDialog, public Ui::LibraryInfoDialog {
   Q_OBJECT;
 
 public:
-  LibraryInfoDialog(const QString& rendererInfo);
+  LibraryInfoDialog(const QString &rendererInfo);
 
-  void updateLibraryInfo(const QString& rendererInfo);
+  void updateLibraryInfo(const QString &rendererInfo);
 };
diff --git a/src/gui/MainWindow.cc b/src/gui/MainWindow.cc
index 9bb195a24..6e59982ba 100644
--- a/src/gui/MainWindow.cc
+++ b/src/gui/MainWindow.cc
@@ -26,27 +26,23 @@
 
 #include "gui/MainWindow.h"
 
+#include <algorithm>
+#include <cassert>
+#include <cstdio>
 #include <cstring>
-#include <filesystem>
 #include <deque>
-#include <cassert>
-#include <functional>
 #include <exception>
-#include <sstream>
+#include <filesystem>
+#include <fstream>
+#include <functional>
 #include <iostream>
 #include <memory>
+#include <sstream>
 #include <string>
-#include <vector>
-#include <cstdio>
-#include <memory>
-#include <utility>
-#include <memory>
-#include <string>
-#include <fstream>
-#include <algorithm>
 #include <sys/stat.h>
+#include <utility>
+#include <vector>
 
-#include <boost/version.hpp>
 #include <QApplication>
 #include <QClipboard>
 #include <QDesktopServices>
@@ -89,43 +85,42 @@
 #include <QUrl>
 #include <QVBoxLayout>
 #include <QWidget>
+#include <boost/version.hpp>
 
 #include "core/AST.h"
 #include "core/BuiltinContext.h"
 #include "core/Builtins.h"
 #include "core/CSGNode.h"
 #include "core/Context.h"
-#include "core/customizer/CommentParser.h"
 #include "core/EvaluationSession.h"
 #include "core/Expression.h"
-#include "core/node.h"
-#include "core/parsersettings.h"
-#include "core/progress.h"
 #include "core/RenderVariables.h"
 #include "core/ScopeContext.h"
 #include "core/Settings.h"
 #include "core/SourceFileCache.h"
+#include "core/customizer/CommentParser.h"
+#include "core/node.h"
+#include "core/parsersettings.h"
+#include "core/progress.h"
 #include "geometry/Geometry.h"
 #include "geometry/GeometryCache.h"
 #include "geometry/GeometryEvaluator.h"
 #include "glview/PolySetRenderer.h"
+#include "glview/RenderSettings.h"
 #include "glview/cgal/CGALRenderer.h"
 #include "glview/preview/CSGTreeNormalizer.h"
 #include "glview/preview/ThrownTogetherRenderer.h"
-#include "glview/RenderSettings.h"
 #include "gui/AboutDialog.h"
 #include "gui/CGALWorker.h"
-#include "gui/Editor.h"
 #include "gui/Dock.h"
-#include "gui/Measurement.h"
+#include "gui/Editor.h"
 #include "gui/Export3mfDialog.h"
 #include "gui/ExportPdfDialog.h"
 #include "gui/ExternalToolInterface.h"
 #include "gui/FontListDialog.h"
 #include "gui/ImportUtils.h"
-#include "gui/input/InputDriverEvent.h"
-#include "gui/input/InputDriverManager.h"
 #include "gui/LibraryInfoDialog.h"
+#include "gui/Measurement.h"
 #include "gui/OpenSCADApp.h"
 #include "gui/Preferences.h"
 #include "gui/PrintInitDialog.h"
@@ -133,10 +128,12 @@
 #include "gui/QGLView.h"
 #include "gui/QSettingsCached.h"
 #include "gui/QWordSearchField.h"
-#include "gui/SettingsWriter.h"
 #include "gui/ScintillaEditor.h"
+#include "gui/SettingsWriter.h"
 #include "gui/TabManager.h"
 #include "gui/UIUtils.h"
+#include "gui/input/InputDriverEvent.h"
+#include "gui/input/InputDriverManager.h"
 #include "io/dxfdim.h"
 #include "io/export.h"
 #include "io/fileutils.h"
@@ -147,13 +144,13 @@
 #include "version.h"
 
 #ifdef ENABLE_CGAL
-#include "geometry/cgal/cgal.h"
 #include "geometry/cgal/CGALCache.h"
 #include "geometry/cgal/CGALNefGeometry.h"
+#include "geometry/cgal/cgal.h"
 #endif // ENABLE_CGAL
 #ifdef ENABLE_MANIFOLD
-#include "geometry/manifold/manifoldutils.h"
 #include "geometry/manifold/ManifoldGeometry.h"
+#include "geometry/manifold/manifoldutils.h"
 #endif // ENABLE_MANIFOLD
 #ifdef ENABLE_OPENCSG
 #include "core/CSGTreeEvaluator.h"
@@ -165,16 +162,16 @@
 #endif
 
 #ifdef ENABLE_PYTHON
-#include "python/python_public.h"
-#include "nettle/sha2.h"
 #include "nettle/base64.h"
+#include "nettle/sha2.h"
+#include "python/python_public.h"
 
-std::string SHA256HashString(std::string aString){
+std::string SHA256HashString(std::string aString) {
   uint8_t digest[SHA256_DIGEST_SIZE];
   sha256_ctx sha256_ctx;
 
   sha256_init(&sha256_ctx);
-  sha256_update(&sha256_ctx, aString.length(), (uint8_t *) aString.c_str());
+  sha256_update(&sha256_ctx, aString.length(), (uint8_t *)aString.c_str());
   sha256_digest(&sha256_ctx, SHA256_DIGEST_SIZE, digest);
 
   base64_encode_ctx base64_ctx;
@@ -191,7 +188,6 @@ std::string SHA256HashString(std::string aString){
 
 #include "gui/PrintService.h"
 
-
 // Global application state
 unsigned int GuiLocker::guiLocked = 0;
 
@@ -204,49 +200,52 @@ namespace {
 
 const int autoReloadPollingPeriodMS = 200;
 const char copyrighttext[] =
-  "<p>Copyright (C) 2009-2025 The OpenSCAD Developers</p>"
-  "<p>This program is free software; you can redistribute it and/or modify "
-  "it under the terms of the GNU General Public License as published by "
-  "the Free Software Foundation; either version 2 of the License, or "
-  "(at your option) any later version.<p>";
+    "<p>Copyright (C) 2009-2025 The OpenSCAD Developers</p>"
+    "<p>This program is free software; you can redistribute it and/or modify "
+    "it under the terms of the GNU General Public License as published by "
+    "the Free Software Foundation; either version 2 of the License, or "
+    "(at your option) any later version.<p>";
 
 struct DockFocus {
   Dock *widget;
   std::function<void(MainWindow *)> focus;
 };
 
-QAction *findAction(const QList<QAction *>& actions, const std::string& name)
-{
+QAction *findAction(const QList<QAction *> &actions, const std::string &name) {
   for (const auto action : actions) {
     if (action->objectName().toStdString() == name) {
       return action;
     }
     if (action->menu()) {
       auto foundAction = findAction(action->menu()->actions(), name);
-      if (foundAction) return foundAction;
+      if (foundAction)
+        return foundAction;
     }
   }
   return nullptr;
 }
 
-void fileExportedMessage(const QString& format, const QString& filename) {
-  LOG("%1$s export finished: %2$s", format.toUtf8().constData(), filename.toUtf8().constData());
+void fileExportedMessage(const QString &format, const QString &filename) {
+  LOG("%1$s export finished: %2$s", format.toUtf8().constData(),
+      filename.toUtf8().constData());
 }
 
 void removeExportActions(QToolBar *toolbar, QAction *action) {
   int idx = toolbar->actions().indexOf(action);
   while (idx > 0) {
     QAction *a = toolbar->actions().at(idx - 1);
-    if (a->objectName().isEmpty())     // separator
+    if (a->objectName().isEmpty()) // separator
       break;
     toolbar->removeAction(a);
     idx--;
   }
 }
 
-void addExportActions(const MainWindow *mainWindow, QToolBar *toolbar, QAction *action) {
-  for (const std::string& identifier : {Settings::Settings::toolbarExport3D.value(),
-                                        Settings::Settings::toolbarExport2D.value()}) {
+void addExportActions(const MainWindow *mainWindow, QToolBar *toolbar,
+                      QAction *action) {
+  for (const std::string &identifier :
+       {Settings::Settings::toolbarExport3D.value(),
+        Settings::Settings::toolbarExport2D.value()}) {
     FileFormat format;
     fileformat::fromIdentifier(identifier, format);
     const auto it = mainWindow->exportMap.find(format);
@@ -257,16 +256,17 @@ void addExportActions(const MainWindow *mainWindow, QToolBar *toolbar, QAction *
   }
 }
 
-std::unique_ptr<ExternalToolInterface> createExternalToolService(
-  print_service_t serviceType, const QString& serviceName, FileFormat fileFormat)
-{
+std::unique_ptr<ExternalToolInterface>
+createExternalToolService(print_service_t serviceType,
+                          const QString &serviceName, FileFormat fileFormat) {
   switch (serviceType) {
   case print_service_t::NONE:
     // TODO: Print warning
     return nullptr;
     break;
   case print_service_t::PRINT_SERVICE: {
-    if (const auto printService = PrintService::getPrintService(serviceName.toStdString())) {
+    if (const auto printService =
+            PrintService::getPrintService(serviceName.toStdString())) {
       return createExternalPrintService(printService, fileFormat);
     }
     LOG("Unknown print service \"%1$s\"", serviceName.toStdString());
@@ -285,9 +285,7 @@ std::unique_ptr<ExternalToolInterface> createExternalToolService(
 
 } // namespace
 
-MainWindow::MainWindow(const QStringList& filenames) :
-  rubberBandManager(this)
-{
+MainWindow::MainWindow(const QStringList &filenames) : rubberBandManager(this) {
   installEventFilter(this);
   setupUi(this);
 
@@ -301,15 +299,13 @@ MainWindow::MainWindow(const QStringList& filenames) :
   this->addAction(editActionInsertTemplate);
   this->addAction(editActionFoldAll);
 
-  docks = {
-    {editorDock, QString(_("Editor"))},
-    {consoleDock, QString(_("Console"))},
-    {parameterDock, QString(_("Customizer"))},
-    {errorLogDock, QString(_("Error-Log"))},
-    {animateDock, QString(_("Animate"))},
-    {fontListDock, QString(_("Font Lists"))},
-    {viewportControlDock, QString(_("Viewport-Control"))}
-  };
+  docks = {{editorDock, QString(_("Editor"))},
+           {consoleDock, QString(_("Console"))},
+           {parameterDock, QString(_("Customizer"))},
+           {errorLogDock, QString(_("Error-Log"))},
+           {animateDock, QString(_("Animate"))},
+           {fontListDock, QString(_("Font Lists"))},
+           {viewportControlDock, QString(_("Viewport-Control"))}};
 
   this->editorDock->setConfigKey("view/hideEditor");
   this->consoleDock->setConfigKey("view/hideConsole");
@@ -319,7 +315,8 @@ MainWindow::MainWindow(const QStringList& filenames) :
   this->fontListDock->setConfigKey("view/hideFontList");
   this->viewportControlDock->setConfigKey("view/hideViewportControl");
 
-  this->versionLabel = nullptr;   // must be initialized before calling updateStatusBar()
+  this->versionLabel =
+      nullptr; // must be initialized before calling updateStatusBar()
   updateStatusBar(nullptr);
 
   renderCompleteSoundEffect = new QSoundEffect();
@@ -330,62 +327,101 @@ MainWindow::MainWindow(const QStringList& filenames) :
   absoluteRootNode = nullptr;
 
   // Open Recent
-  for (auto& recent : this->actionRecentFile) {
+  for (auto &recent : this->actionRecentFile) {
     recent = new QAction(this);
     recent->setVisible(false);
     this->menuOpenRecent->addAction(recent);
     connect(recent, &QAction::triggered, this, &MainWindow::actionOpenRecent);
   }
 
-  // Preferences initialization happens on first tab creation, and depends on colorschemes from editor.
-  // Any code dependent on Preferences must come after the TabManager instantiation
-  tabManager = new TabManager(this, filenames.isEmpty() ? QString() : filenames[0]);
+  // Preferences initialization happens on first tab creation, and depends on
+  // colorschemes from editor. Any code dependent on Preferences must come after
+  // the TabManager instantiation
+  tabManager =
+      new TabManager(this, filenames.isEmpty() ? QString() : filenames[0]);
   editorDockContents->layout()->addWidget(tabManager->getTabContent());
 
-  connect(this, &MainWindow::highlightError, tabManager, &TabManager::highlightError);
-  connect(this, &MainWindow::unhighlightLastError, tabManager, &TabManager::unhighlightLastError);
-
-  connect(this->editActionUndo, &QAction::triggered, tabManager, &TabManager::undo);
-  connect(this->editActionRedo, &QAction::triggered, tabManager, &TabManager::redo);
-  connect(this->editActionRedo_2, &QAction::triggered, tabManager, &TabManager::redo);
-  connect(this->editActionCut, &QAction::triggered, tabManager, &TabManager::cut);
-  connect(this->editActionPaste, &QAction::triggered, tabManager, &TabManager::paste);
-
-  connect(this->editActionIndent, &QAction::triggered, tabManager, &TabManager::indentSelection);
-  connect(this->editActionUnindent, &QAction::triggered, tabManager, &TabManager::unindentSelection);
-  connect(this->editActionComment, &QAction::triggered, tabManager, &TabManager::commentSelection);
-  connect(this->editActionUncomment, &QAction::triggered, tabManager, &TabManager::uncommentSelection);
-
-  connect(this->editActionToggleBookmark, &QAction::triggered, tabManager, &TabManager::toggleBookmark);
-  connect(this->editActionNextBookmark, &QAction::triggered, tabManager, &TabManager::nextBookmark);
-  connect(this->editActionPrevBookmark, &QAction::triggered, tabManager, &TabManager::prevBookmark);
-  connect(this->editActionJumpToNextError, &QAction::triggered, tabManager, &TabManager::jumpToNextError);
-
-  connect(tabManager, &TabManager::editorAboutToClose, this, &MainWindow::onTabManagerAboutToCloseEditor);
-  connect(tabManager, &TabManager::currentEditorChanged, this, &MainWindow::onTabManagerEditorChanged);
-  connect(tabManager, &TabManager::editorContentReloaded, this, &MainWindow::onTabManagerEditorContentReloaded);
-
-  connect(GlobalPreferences::inst(), &Preferences::consoleFontChanged, this->console, &Console::setFont);
-
-  const QString version = QString("<b>OpenSCAD %1</b>").arg(QString::fromStdString(openscad_versionnumber));
-  const QString weblink = "<a href=\"https://www.openscad.org/\">https://www.openscad.org/</a><br>";
+  connect(this, &MainWindow::highlightError, tabManager,
+          &TabManager::highlightError);
+  connect(this, &MainWindow::unhighlightLastError, tabManager,
+          &TabManager::unhighlightLastError);
+
+  connect(this->editActionUndo, &QAction::triggered, tabManager,
+          &TabManager::undo);
+  connect(this->editActionRedo, &QAction::triggered, tabManager,
+          &TabManager::redo);
+  connect(this->editActionRedo_2, &QAction::triggered, tabManager,
+          &TabManager::redo);
+  connect(this->editActionCut, &QAction::triggered, tabManager,
+          &TabManager::cut);
+  connect(this->editActionPaste, &QAction::triggered, tabManager,
+          &TabManager::paste);
+
+  connect(this->editActionIndent, &QAction::triggered, tabManager,
+          &TabManager::indentSelection);
+  connect(this->editActionUnindent, &QAction::triggered, tabManager,
+          &TabManager::unindentSelection);
+  connect(this->editActionComment, &QAction::triggered, tabManager,
+          &TabManager::commentSelection);
+  connect(this->editActionUncomment, &QAction::triggered, tabManager,
+          &TabManager::uncommentSelection);
+
+  connect(this->editActionToggleBookmark, &QAction::triggered, tabManager,
+          &TabManager::toggleBookmark);
+  connect(this->editActionNextBookmark, &QAction::triggered, tabManager,
+          &TabManager::nextBookmark);
+  connect(this->editActionPrevBookmark, &QAction::triggered, tabManager,
+          &TabManager::prevBookmark);
+  connect(this->editActionJumpToNextError, &QAction::triggered, tabManager,
+          &TabManager::jumpToNextError);
+
+  connect(tabManager, &TabManager::editorAboutToClose, this,
+          &MainWindow::onTabManagerAboutToCloseEditor);
+  connect(tabManager, &TabManager::currentEditorChanged, this,
+          &MainWindow::onTabManagerEditorChanged);
+  connect(tabManager, &TabManager::editorContentReloaded, this,
+          &MainWindow::onTabManagerEditorContentReloaded);
+
+  connect(GlobalPreferences::inst(), &Preferences::consoleFontChanged,
+          this->console, &Console::setFont);
+
+  const QString version =
+      QString("<b>OpenSCAD %1</b>")
+          .arg(QString::fromStdString(openscad_versionnumber));
+  const QString weblink =
+      "<a href=\"https://www.openscad.org/\">https://www.openscad.org/</a><br>";
   this->console->setFont(
-    GlobalPreferences::inst()->getValue("advanced/consoleFontFamily").toString(),
-    GlobalPreferences::inst()->getValue("advanced/consoleFontSize").toUInt()
-    );
+      GlobalPreferences::inst()
+          ->getValue("advanced/consoleFontFamily")
+          .toString(),
+      GlobalPreferences::inst()->getValue("advanced/consoleFontSize").toUInt());
 
   consoleOutputRaw(version);
   consoleOutputRaw(weblink);
   consoleOutputRaw(copyrighttext);
-  this->consoleUpdater->start(0);   // Show "Loaded Design" message from TabManager
-
-  connect(this->errorLogWidget, &ErrorLog::openFile, this, &MainWindow::openFileFromPath);
-  connect(this->console, &Console::openFile, this, &MainWindow::openFileFromPath);
-
-  connect(GlobalPreferences::inst()->ButtonConfig, &ButtonConfigWidget::inputMappingChanged, InputDriverManager::instance(), &InputDriverManager::onInputMappingUpdated, Qt::UniqueConnection);
-  connect(GlobalPreferences::inst()->AxisConfig, &AxisConfigWidget::inputMappingChanged, InputDriverManager::instance(), &InputDriverManager::onInputMappingUpdated, Qt::UniqueConnection);
-  connect(GlobalPreferences::inst()->AxisConfig, &AxisConfigWidget::inputCalibrationChanged, InputDriverManager::instance(), &InputDriverManager::onInputCalibrationUpdated, Qt::UniqueConnection);
-  connect(GlobalPreferences::inst()->AxisConfig, &AxisConfigWidget::inputGainChanged, InputDriverManager::instance(), &InputDriverManager::onInputGainUpdated, Qt::UniqueConnection);
+  this->consoleUpdater->start(
+      0); // Show "Loaded Design" message from TabManager
+
+  connect(this->errorLogWidget, &ErrorLog::openFile, this,
+          &MainWindow::openFileFromPath);
+  connect(this->console, &Console::openFile, this,
+          &MainWindow::openFileFromPath);
+
+  connect(GlobalPreferences::inst()->ButtonConfig,
+          &ButtonConfigWidget::inputMappingChanged,
+          InputDriverManager::instance(),
+          &InputDriverManager::onInputMappingUpdated, Qt::UniqueConnection);
+  connect(GlobalPreferences::inst()->AxisConfig,
+          &AxisConfigWidget::inputMappingChanged,
+          InputDriverManager::instance(),
+          &InputDriverManager::onInputMappingUpdated, Qt::UniqueConnection);
+  connect(GlobalPreferences::inst()->AxisConfig,
+          &AxisConfigWidget::inputCalibrationChanged,
+          InputDriverManager::instance(),
+          &InputDriverManager::onInputCalibrationUpdated, Qt::UniqueConnection);
+  connect(GlobalPreferences::inst()->AxisConfig,
+          &AxisConfigWidget::inputGainChanged, InputDriverManager::instance(),
+          &InputDriverManager::onInputGainUpdated, Qt::UniqueConnection);
 
   setCorner(Qt::TopLeftCorner, Qt::LeftDockWidgetArea);
   setCorner(Qt::TopRightCorner, Qt::RightDockWidgetArea);
@@ -397,7 +433,8 @@ MainWindow::MainWindow(const QStringList& filenames) :
   scadApp->windowManager.add(this);
 
   this->cgalworker = new CGALWorker();
-  connect(this->cgalworker, &CGALWorker::done, this, &MainWindow::actionRenderDone);
+  connect(this->cgalworker, &CGALWorker::done, this,
+          &MainWindow::actionRenderDone);
 
   rootNode = nullptr;
 
@@ -406,8 +443,10 @@ MainWindow::MainWindow(const QStringList& filenames) :
   statusBar()->addWidget(this->qglview->statusLabel);
 
   const QSettingsCached settings;
-  this->qglview->setMouseCentricZoom(Settings::Settings::mouseCentricZoom.value());
-  this->qglview->setMouseSwapButtons(Settings::Settings::mouseSwapButtons.value());
+  this->qglview->setMouseCentricZoom(
+      Settings::Settings::mouseCentricZoom.value());
+  this->qglview->setMouseSwapButtons(
+      Settings::Settings::mouseSwapButtons.value());
   this->meas.setView(qglview);
   this->designActionMeasureDist->setEnabled(false);
   this->designActionMeasureAngle->setEnabled(false);
@@ -415,46 +454,68 @@ MainWindow::MainWindow(const QStringList& filenames) :
   autoReloadTimer = new QTimer(this);
   autoReloadTimer->setSingleShot(false);
   autoReloadTimer->setInterval(autoReloadPollingPeriodMS);
-  connect(autoReloadTimer, &QTimer::timeout, this, &MainWindow::checkAutoReload);
+  connect(autoReloadTimer, &QTimer::timeout, this,
+          &MainWindow::checkAutoReload);
 
   this->exportFormatMapper = new QSignalMapper(this);
 #if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
-  connect(this->exportFormatMapper, &QSignalMapper::mappedInt, this, &MainWindow::actionExportFileFormat);
+  connect(this->exportFormatMapper, &QSignalMapper::mappedInt, this,
+          &MainWindow::actionExportFileFormat);
 #else
-  connect(this->exportFormatMapper, static_cast<void (QSignalMapper::*)(int)>(&QSignalMapper::mapped), this, &MainWindow::actionExportFileFormat);
+  connect(this->exportFormatMapper,
+          static_cast<void (QSignalMapper::*)(int)>(&QSignalMapper::mapped),
+          this, &MainWindow::actionExportFileFormat);
 #endif
 
   waitAfterReloadTimer = new QTimer(this);
   waitAfterReloadTimer->setSingleShot(true);
   waitAfterReloadTimer->setInterval(autoReloadPollingPeriodMS);
-  connect(waitAfterReloadTimer, &QTimer::timeout, this, &MainWindow::waitAfterReload);
-  connect(GlobalPreferences::inst(), &Preferences::ExperimentalChanged, this, &MainWindow::changeParameterWidget);
+  connect(waitAfterReloadTimer, &QTimer::timeout, this,
+          &MainWindow::waitAfterReload);
+  connect(GlobalPreferences::inst(), &Preferences::ExperimentalChanged, this,
+          &MainWindow::changeParameterWidget);
 
   progressThrottle->start();
 
   this->hideFind();
   frameCompileResult->hide();
   this->labelCompileResultMessage->setOpenExternalLinks(false);
-  connect(this->labelCompileResultMessage, &QLabel::linkActivated, this, &MainWindow::showLink);
+  connect(this->labelCompileResultMessage, &QLabel::linkActivated, this,
+          &MainWindow::showLink);
 
   // File menu
-  connect(this->fileActionNewWindow, &QAction::triggered, this, &MainWindow::actionNewWindow);
-  connect(this->fileActionNew, &QAction::triggered, tabManager, &TabManager::actionNew);
-  connect(this->fileActionOpenWindow, &QAction::triggered, this, &MainWindow::actionOpenWindow);
-  connect(this->fileActionOpen, &QAction::triggered, this, &MainWindow::actionOpen);
-  connect(this->fileActionSave, &QAction::triggered, this, &MainWindow::actionSave);
-  connect(this->fileActionSaveAs, &QAction::triggered, this, &MainWindow::actionSaveAs);
-  connect(this->fileActionSaveACopy, &QAction::triggered, this, &MainWindow::actionSaveACopy);
-  connect(this->fileActionSaveAll, &QAction::triggered, tabManager, &TabManager::saveAll);
-  connect(this->fileActionReload, &QAction::triggered, this, &MainWindow::actionReload);
-  connect(this->fileActionClose, &QAction::triggered, tabManager, &TabManager::closeCurrentTab);
-  connect(this->fileActionQuit, &QAction::triggered, scadApp, &OpenSCADApp::quit, Qt::QueuedConnection);
-  connect(this->fileShowLibraryFolder, &QAction::triggered, this, &MainWindow::actionShowLibraryFolder);
+  connect(this->fileActionNewWindow, &QAction::triggered, this,
+          &MainWindow::actionNewWindow);
+  connect(this->fileActionNew, &QAction::triggered, tabManager,
+          &TabManager::actionNew);
+  connect(this->fileActionOpenWindow, &QAction::triggered, this,
+          &MainWindow::actionOpenWindow);
+  connect(this->fileActionOpen, &QAction::triggered, this,
+          &MainWindow::actionOpen);
+  connect(this->fileActionSave, &QAction::triggered, this,
+          &MainWindow::actionSave);
+  connect(this->fileActionSaveAs, &QAction::triggered, this,
+          &MainWindow::actionSaveAs);
+  connect(this->fileActionSaveACopy, &QAction::triggered, this,
+          &MainWindow::actionSaveACopy);
+  connect(this->fileActionSaveAll, &QAction::triggered, tabManager,
+          &TabManager::saveAll);
+  connect(this->fileActionReload, &QAction::triggered, this,
+          &MainWindow::actionReload);
+  connect(this->fileActionClose, &QAction::triggered, tabManager,
+          &TabManager::closeCurrentTab);
+  connect(this->fileActionQuit, &QAction::triggered, scadApp,
+          &OpenSCADApp::quit, Qt::QueuedConnection);
+  connect(this->fileShowLibraryFolder, &QAction::triggered, this,
+          &MainWindow::actionShowLibraryFolder);
 
 #ifdef ENABLE_PYTHON
-  connect(this->fileActionPythonRevoke, &QAction::triggered, this, &MainWindow::actionPythonRevokeTrustedFiles);
-  connect(this->fileActionPythonCreateVenv, &QAction::triggered, this, &MainWindow::actionPythonCreateVenv);
-  connect(this->fileActionPythonSelectVenv, &QAction::triggered, this, &MainWindow::actionPythonSelectVenv);
+  connect(this->fileActionPythonRevoke, &QAction::triggered, this,
+          &MainWindow::actionPythonRevokeTrustedFiles);
+  connect(this->fileActionPythonCreateVenv, &QAction::triggered, this,
+          &MainWindow::actionPythonCreateVenv);
+  connect(this->fileActionPythonSelectVenv, &QAction::triggered, this,
+          &MainWindow::actionPythonSelectVenv);
 #else
   this->menuPython->menuAction()->setVisible(false);
 #endif
@@ -469,43 +530,70 @@ MainWindow::MainWindow(const QStringList& filenames) :
 
   this->menuOpenRecent->addSeparator();
   this->menuOpenRecent->addAction(this->fileActionClearRecent);
-  connect(this->fileActionClearRecent, &QAction::triggered, this, &MainWindow::clearRecentFiles);
+  connect(this->fileActionClearRecent, &QAction::triggered, this,
+          &MainWindow::clearRecentFiles);
 
   show_examples();
 
-  connect(this->editActionNextTab, &QAction::triggered, tabManager, &TabManager::nextTab);
-  connect(this->editActionPrevTab, &QAction::triggered, tabManager, &TabManager::prevTab);
-
-  connect(this->editActionCopy, &QAction::triggered, this, &MainWindow::copyText);
-  connect(this->editActionCopyViewport, &QAction::triggered, this, &MainWindow::actionCopyViewport);
-  connect(this->editActionConvertTabsToSpaces, &QAction::triggered, this, &MainWindow::convertTabsToSpaces);
-  connect(this->editActionCopyVPT, &QAction::triggered, this, &MainWindow::copyViewportTranslation);
-  connect(this->editActionCopyVPR, &QAction::triggered, this, &MainWindow::copyViewportRotation);
-  connect(this->editActionCopyVPD, &QAction::triggered, this, &MainWindow::copyViewportDistance);
-  connect(this->editActionCopyVPF, &QAction::triggered, this, &MainWindow::copyViewportFov);
-  connect(this->editActionPreferences, &QAction::triggered, this, &MainWindow::preferences);
+  connect(this->editActionNextTab, &QAction::triggered, tabManager,
+          &TabManager::nextTab);
+  connect(this->editActionPrevTab, &QAction::triggered, tabManager,
+          &TabManager::prevTab);
+
+  connect(this->editActionCopy, &QAction::triggered, this,
+          &MainWindow::copyText);
+  connect(this->editActionCopyViewport, &QAction::triggered, this,
+          &MainWindow::actionCopyViewport);
+  connect(this->editActionConvertTabsToSpaces, &QAction::triggered, this,
+          &MainWindow::convertTabsToSpaces);
+  connect(this->editActionCopyVPT, &QAction::triggered, this,
+          &MainWindow::copyViewportTranslation);
+  connect(this->editActionCopyVPR, &QAction::triggered, this,
+          &MainWindow::copyViewportRotation);
+  connect(this->editActionCopyVPD, &QAction::triggered, this,
+          &MainWindow::copyViewportDistance);
+  connect(this->editActionCopyVPF, &QAction::triggered, this,
+          &MainWindow::copyViewportFov);
+  connect(this->editActionPreferences, &QAction::triggered, this,
+          &MainWindow::preferences);
   // Edit->Find
-  connect(this->editActionFind, &QAction::triggered, this, &MainWindow::actionShowFind);
-  connect(this->editActionFindAndReplace, &QAction::triggered, this, &MainWindow::actionShowFindAndReplace);
+  connect(this->editActionFind, &QAction::triggered, this,
+          &MainWindow::actionShowFind);
+  connect(this->editActionFindAndReplace, &QAction::triggered, this,
+          &MainWindow::actionShowFindAndReplace);
 #ifdef Q_OS_WIN
   this->editActionFindAndReplace->setShortcut(QKeySequence("Ctrl+Shift+F"));
 #endif
-  connect(this->editActionFindNext, &QAction::triggered, this, &MainWindow::findNext);
-  connect(this->editActionFindPrevious, &QAction::triggered, this, &MainWindow::findPrev);
-  connect(this->editActionUseSelectionForFind, &QAction::triggered, this, &MainWindow::useSelectionForFind);
+  connect(this->editActionFindNext, &QAction::triggered, this,
+          &MainWindow::findNext);
+  connect(this->editActionFindPrevious, &QAction::triggered, this,
+          &MainWindow::findPrev);
+  connect(this->editActionUseSelectionForFind, &QAction::triggered, this,
+          &MainWindow::useSelectionForFind);
 
   // Design menu
-  connect(this->designActionAutoReload, &QAction::toggled, this, &MainWindow::autoReloadSet);
-  connect(this->designActionReloadAndPreview, &QAction::triggered, this, &MainWindow::actionReloadRenderPreview);
-  connect(this->designActionPreview, &QAction::triggered, this, &MainWindow::actionRenderPreview);
-  connect(this->designActionRender, &QAction::triggered, this, &MainWindow::actionRender);
-  connect(this->designActionMeasureDist, &QAction::triggered, this, &MainWindow::actionMeasureDistance);
-  connect(this->designActionMeasureAngle, &QAction::triggered, this, &MainWindow::actionMeasureAngle);
-  connect(this->designAction3DPrint, &QAction::triggered, this, &MainWindow::action3DPrint);
-  connect(this->designCheckValidity, &QAction::triggered, this, &MainWindow::actionCheckValidity);
-  connect(this->designActionDisplayAST, &QAction::triggered, this, &MainWindow::actionDisplayAST);
-  connect(this->designActionDisplayCSGTree, &QAction::triggered, this, &MainWindow::actionDisplayCSGTree);
-  connect(this->designActionDisplayCSGProducts, &QAction::triggered, this, &MainWindow::actionDisplayCSGProducts);
+  connect(this->designActionAutoReload, &QAction::toggled, this,
+          &MainWindow::autoReloadSet);
+  connect(this->designActionReloadAndPreview, &QAction::triggered, this,
+          &MainWindow::actionReloadRenderPreview);
+  connect(this->designActionPreview, &QAction::triggered, this,
+          &MainWindow::actionRenderPreview);
+  connect(this->designActionRender, &QAction::triggered, this,
+          &MainWindow::actionRender);
+  connect(this->designActionMeasureDist, &QAction::triggered, this,
+          &MainWindow::actionMeasureDistance);
+  connect(this->designActionMeasureAngle, &QAction::triggered, this,
+          &MainWindow::actionMeasureAngle);
+  connect(this->designAction3DPrint, &QAction::triggered, this,
+          &MainWindow::action3DPrint);
+  connect(this->designCheckValidity, &QAction::triggered, this,
+          &MainWindow::actionCheckValidity);
+  connect(this->designActionDisplayAST, &QAction::triggered, this,
+          &MainWindow::actionDisplayAST);
+  connect(this->designActionDisplayCSGTree, &QAction::triggered, this,
+          &MainWindow::actionDisplayCSGTree);
+  connect(this->designActionDisplayCSGProducts, &QAction::triggered, this,
+          &MainWindow::actionDisplayCSGProducts);
 
   exportMap[FileFormat::BINARY_STL] = this->fileActionExportBinarySTL;
   exportMap[FileFormat::ASCII_STL] = this->fileActionExportAsciiSTL;
@@ -521,12 +609,14 @@ MainWindow::MainWindow(const QStringList& filenames) :
   exportMap[FileFormat::CSG] = this->fileActionExportCSG;
   exportMap[FileFormat::PNG] = this->fileActionExportImage;
 
-  for (auto& [format, action] : exportMap) {
-    connect(action, &QAction::triggered, this->exportFormatMapper, QOverload<>::of(&QSignalMapper::map));
+  for (auto &[format, action] : exportMap) {
+    connect(action, &QAction::triggered, this->exportFormatMapper,
+            QOverload<>::of(&QSignalMapper::map));
     this->exportFormatMapper->setMapping(action, int(format));
   }
 
-  connect(this->designActionFlushCaches, &QAction::triggered, this, &MainWindow::actionFlushCaches);
+  connect(this->designActionFlushCaches, &QAction::triggered, this,
+          &MainWindow::actionFlushCaches);
 
 #ifndef ENABLE_LIB3MF
   this->fileActionExport3MF->setVisible(false);
@@ -543,57 +633,89 @@ MainWindow::MainWindow(const QStringList& filenames) :
     this->viewActionThrownTogether->setChecked(true);
   }
 
-  connect(this->viewActionPreview, &QAction::triggered, this, &MainWindow::viewModePreview);
-  connect(this->viewActionThrownTogether, &QAction::triggered, this, &MainWindow::viewModeThrownTogether);
-  connect(this->viewActionShowEdges, &QAction::triggered, this, &MainWindow::viewModeShowEdges);
-  connect(this->viewActionShowAxes, &QAction::triggered, this, &MainWindow::viewModeShowAxes);
-  connect(this->viewActionShowCrosshairs, &QAction::triggered, this, &MainWindow::viewModeShowCrosshairs);
-  connect(this->viewActionShowScaleProportional, &QAction::triggered, this, &MainWindow::viewModeShowScaleProportional);
-  connect(this->viewActionTop, &QAction::triggered, this, &MainWindow::viewAngleTop);
-  connect(this->viewActionBottom, &QAction::triggered, this, &MainWindow::viewAngleBottom);
-  connect(this->viewActionLeft, &QAction::triggered, this, &MainWindow::viewAngleLeft);
-  connect(this->viewActionRight, &QAction::triggered, this, &MainWindow::viewAngleRight);
-  connect(this->viewActionFront, &QAction::triggered, this, &MainWindow::viewAngleFront);
-  connect(this->viewActionBack, &QAction::triggered, this, &MainWindow::viewAngleBack);
-  connect(this->viewActionDiagonal, &QAction::triggered, this, &MainWindow::viewAngleDiagonal);
-  connect(this->viewActionCenter, &QAction::triggered, this, &MainWindow::viewCenter);
-  connect(this->viewActionResetView, &QAction::triggered, this, &MainWindow::viewResetView);
-  connect(this->viewActionViewAll, &QAction::triggered, this, &MainWindow::viewAll);
-  connect(this->viewActionPerspective, &QAction::triggered, this, &MainWindow::viewPerspective);
-  connect(this->viewActionOrthogonal, &QAction::triggered, this, &MainWindow::viewOrthogonal);
-  connect(this->viewActionZoomIn, &QAction::triggered, qglview, &QGLView::ZoomIn);
-  connect(this->viewActionZoomOut, &QAction::triggered, qglview, &QGLView::ZoomOut);
-  connect(this->viewActionHideEditorToolBar, &QAction::triggered, this, &MainWindow::hideEditorToolbar);
-  connect(this->viewActionHide3DViewToolBar, &QAction::triggered, this, &MainWindow::hide3DViewToolbar);
+  connect(this->viewActionPreview, &QAction::triggered, this,
+          &MainWindow::viewModePreview);
+  connect(this->viewActionThrownTogether, &QAction::triggered, this,
+          &MainWindow::viewModeThrownTogether);
+  connect(this->viewActionShowEdges, &QAction::triggered, this,
+          &MainWindow::viewModeShowEdges);
+  connect(this->viewActionShowAxes, &QAction::triggered, this,
+          &MainWindow::viewModeShowAxes);
+  connect(this->viewActionShowCrosshairs, &QAction::triggered, this,
+          &MainWindow::viewModeShowCrosshairs);
+  connect(this->viewActionShowScaleProportional, &QAction::triggered, this,
+          &MainWindow::viewModeShowScaleProportional);
+  connect(this->viewActionTop, &QAction::triggered, this,
+          &MainWindow::viewAngleTop);
+  connect(this->viewActionBottom, &QAction::triggered, this,
+          &MainWindow::viewAngleBottom);
+  connect(this->viewActionLeft, &QAction::triggered, this,
+          &MainWindow::viewAngleLeft);
+  connect(this->viewActionRight, &QAction::triggered, this,
+          &MainWindow::viewAngleRight);
+  connect(this->viewActionFront, &QAction::triggered, this,
+          &MainWindow::viewAngleFront);
+  connect(this->viewActionBack, &QAction::triggered, this,
+          &MainWindow::viewAngleBack);
+  connect(this->viewActionDiagonal, &QAction::triggered, this,
+          &MainWindow::viewAngleDiagonal);
+  connect(this->viewActionCenter, &QAction::triggered, this,
+          &MainWindow::viewCenter);
+  connect(this->viewActionResetView, &QAction::triggered, this,
+          &MainWindow::viewResetView);
+  connect(this->viewActionViewAll, &QAction::triggered, this,
+          &MainWindow::viewAll);
+  connect(this->viewActionPerspective, &QAction::triggered, this,
+          &MainWindow::viewPerspective);
+  connect(this->viewActionOrthogonal, &QAction::triggered, this,
+          &MainWindow::viewOrthogonal);
+  connect(this->viewActionZoomIn, &QAction::triggered, qglview,
+          &QGLView::ZoomIn);
+  connect(this->viewActionZoomOut, &QAction::triggered, qglview,
+          &QGLView::ZoomOut);
+  connect(this->viewActionHideEditorToolBar, &QAction::triggered, this,
+          &MainWindow::hideEditorToolbar);
+  connect(this->viewActionHide3DViewToolBar, &QAction::triggered, this,
+          &MainWindow::hide3DViewToolbar);
 
   // Create the docks and connect corresponding action
-  for (auto& [dock, title] : docks) {
+  for (auto &[dock, title] : docks) {
     dock->setName(title);
     dock->setFocusPolicy(Qt::FocusPolicy::StrongFocus);
 
-    // It is neede to have the event filter installed in each dock so that the events are
-    // correctly processed when the dock are floating (is in a different window that the mainwindow)
+    // It is neede to have the event filter installed in each dock so that the
+    // events are correctly processed when the dock are floating (is in a
+    // different window that the mainwindow)
     dock->installEventFilter(this);
 
     menuWindow->addAction(dock->toggleViewAction());
   }
 
   // Help menu
-  connect(this->helpActionAbout, &QAction::triggered, this, &MainWindow::helpAbout);
-  connect(this->helpActionHomepage, &QAction::triggered, this, &MainWindow::helpHomepage);
-  connect(this->helpActionManual, &QAction::triggered, this, &MainWindow::helpManual);
-  connect(this->helpActionCheatSheet, &QAction::triggered, this, &MainWindow::helpCheatSheet);
-  connect(this->helpActionLibraryInfo, &QAction::triggered, this, &MainWindow::helpLibrary);
-  connect(this->helpActionFontInfo, &QAction::triggered, this, &MainWindow::helpFontInfo);
-
-  // Checks if the Documentation has been downloaded and hides the Action otherwise
+  connect(this->helpActionAbout, &QAction::triggered, this,
+          &MainWindow::helpAbout);
+  connect(this->helpActionHomepage, &QAction::triggered, this,
+          &MainWindow::helpHomepage);
+  connect(this->helpActionManual, &QAction::triggered, this,
+          &MainWindow::helpManual);
+  connect(this->helpActionCheatSheet, &QAction::triggered, this,
+          &MainWindow::helpCheatSheet);
+  connect(this->helpActionLibraryInfo, &QAction::triggered, this,
+          &MainWindow::helpLibrary);
+  connect(this->helpActionFontInfo, &QAction::triggered, this,
+          &MainWindow::helpFontInfo);
+
+  // Checks if the Documentation has been downloaded and hides the Action
+  // otherwise
   if (UIUtils::hasOfflineUserManual()) {
-    connect(this->helpActionOfflineManual, &QAction::triggered, this, &MainWindow::helpOfflineManual);
+    connect(this->helpActionOfflineManual, &QAction::triggered, this,
+            &MainWindow::helpOfflineManual);
   } else {
     this->helpActionOfflineManual->setVisible(false);
   }
   if (UIUtils::hasOfflineCheatSheet()) {
-    connect(this->helpActionOfflineCheatSheet, &QAction::triggered, this, &MainWindow::helpOfflineCheatSheet);
+    connect(this->helpActionOfflineCheatSheet, &QAction::triggered, this,
+            &MainWindow::helpOfflineCheatSheet);
   } else {
     this->helpActionOfflineCheatSheet->setVisible(false);
   }
@@ -601,76 +723,111 @@ MainWindow::MainWindow(const QStringList& filenames) :
   this->menuBar()->addMenu(AutoUpdater::updater()->updateMenu);
 #endif
 
-  connect(this->qglview, &QGLView::cameraChanged, animateWidget, &Animate::cameraChanged);
-  connect(this->qglview, &QGLView::cameraChanged, viewportControlWidget, &ViewportControl::cameraChanged);
-  connect(this->qglview, &QGLView::resized, viewportControlWidget, &ViewportControl::viewResized);
+  connect(this->qglview, &QGLView::cameraChanged, animateWidget,
+          &Animate::cameraChanged);
+  connect(this->qglview, &QGLView::cameraChanged, viewportControlWidget,
+          &ViewportControl::cameraChanged);
+  connect(this->qglview, &QGLView::resized, viewportControlWidget,
+          &ViewportControl::viewResized);
   connect(this->qglview, &QGLView::doRightClick, this, &MainWindow::rightClick);
   connect(this->qglview, &QGLView::doLeftClick, this, &MainWindow::leftClick);
 
-  connect(GlobalPreferences::inst(), &Preferences::requestRedraw, this->qglview, QOverload<>::of(&QGLView::update));
-  connect(GlobalPreferences::inst(), &Preferences::updateMouseCentricZoom, this->qglview, &QGLView::setMouseCentricZoom);
-  connect(GlobalPreferences::inst(), &Preferences::updateMouseSwapButtons, this->qglview, &QGLView::setMouseSwapButtons);
-  connect(GlobalPreferences::inst(), &Preferences::updateReorderMode, this, &MainWindow::updateReorderMode);
-  connect(GlobalPreferences::inst(), &Preferences::updateUndockMode, this, &MainWindow::updateUndockMode);
-  connect(GlobalPreferences::inst(), &Preferences::openCSGSettingsChanged, this, &MainWindow::openCSGSettingsChanged);
-  connect(GlobalPreferences::inst(), &Preferences::colorSchemeChanged, this, &MainWindow::setColorScheme);
-  connect(GlobalPreferences::inst(), &Preferences::toolbarExportChanged, this, &MainWindow::updateExportActions);
-
-  GlobalPreferences::inst()->apply_win();   // not sure if to be commented, checked must not be commented(done some changes in apply())
-
-  const QString cs = GlobalPreferences::inst()->getValue("3dview/colorscheme").toString();
+  connect(GlobalPreferences::inst(), &Preferences::requestRedraw, this->qglview,
+          QOverload<>::of(&QGLView::update));
+  connect(GlobalPreferences::inst(), &Preferences::updateMouseCentricZoom,
+          this->qglview, &QGLView::setMouseCentricZoom);
+  connect(GlobalPreferences::inst(), &Preferences::updateMouseSwapButtons,
+          this->qglview, &QGLView::setMouseSwapButtons);
+  connect(GlobalPreferences::inst(), &Preferences::updateReorderMode, this,
+          &MainWindow::updateReorderMode);
+  connect(GlobalPreferences::inst(), &Preferences::updateUndockMode, this,
+          &MainWindow::updateUndockMode);
+  connect(GlobalPreferences::inst(), &Preferences::openCSGSettingsChanged, this,
+          &MainWindow::openCSGSettingsChanged);
+  connect(GlobalPreferences::inst(), &Preferences::colorSchemeChanged, this,
+          &MainWindow::setColorScheme);
+  connect(GlobalPreferences::inst(), &Preferences::toolbarExportChanged, this,
+          &MainWindow::updateExportActions);
+
+  GlobalPreferences::inst()
+      ->apply_win(); // not sure if to be commented, checked must not be
+                     // commented(done some changes in apply())
+
+  const QString cs =
+      GlobalPreferences::inst()->getValue("3dview/colorscheme").toString();
   this->setColorScheme(cs);
 
-  //find and replace panel
-  connect(this->findTypeComboBox, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &MainWindow::actionSelectFind);
-  connect(this->findInputField, &QWordSearchField::textChanged, this, &MainWindow::findString);
-  connect(this->findInputField, &QWordSearchField::returnPressed, this->findNextButton, [this] {
-    this->findNextButton->animateClick();
-  });
+  // find and replace panel
+  connect(this->findTypeComboBox,
+          QOverload<int>::of(&QComboBox::currentIndexChanged), this,
+          &MainWindow::actionSelectFind);
+  connect(this->findInputField, &QWordSearchField::textChanged, this,
+          &MainWindow::findString);
+  connect(this->findInputField, &QWordSearchField::returnPressed,
+          this->findNextButton,
+          [this] { this->findNextButton->animateClick(); });
   find_panel->installEventFilter(this);
   if (QApplication::clipboard()->supportsFindBuffer()) {
-    connect(this->findInputField, &QWordSearchField::textChanged, this, &MainWindow::updateFindBuffer);
-    connect(QApplication::clipboard(), &QClipboard::findBufferChanged, this, &MainWindow::findBufferChanged);
-    // With Qt 4.8.6, there seems to be a bug that often gives an incorrect findbuffer content when
-    // the app receives focus for the first time
-    this->findInputField->setText(QApplication::clipboard()->text(QClipboard::FindBuffer));
-  }
-
-  connect(this->findPrevButton, &QPushButton::clicked, this, &MainWindow::findPrev);
-  connect(this->findNextButton, &QPushButton::clicked, this, &MainWindow::findNext);
-  connect(this->cancelButton, &QPushButton::clicked, this, &MainWindow::hideFind);
-  connect(this->replaceButton, &QPushButton::clicked, this, &MainWindow::replace);
-  connect(this->replaceAllButton, &QPushButton::clicked, this, &MainWindow::replaceAll);
-  connect(this->replaceInputField, &QLineEdit::returnPressed, this->replaceButton, [this] {
-    this->replaceButton->animateClick();
-  });
+    connect(this->findInputField, &QWordSearchField::textChanged, this,
+            &MainWindow::updateFindBuffer);
+    connect(QApplication::clipboard(), &QClipboard::findBufferChanged, this,
+            &MainWindow::findBufferChanged);
+    // With Qt 4.8.6, there seems to be a bug that often gives an incorrect
+    // findbuffer content when the app receives focus for the first time
+    this->findInputField->setText(
+        QApplication::clipboard()->text(QClipboard::FindBuffer));
+  }
+
+  connect(this->findPrevButton, &QPushButton::clicked, this,
+          &MainWindow::findPrev);
+  connect(this->findNextButton, &QPushButton::clicked, this,
+          &MainWindow::findNext);
+  connect(this->cancelButton, &QPushButton::clicked, this,
+          &MainWindow::hideFind);
+  connect(this->replaceButton, &QPushButton::clicked, this,
+          &MainWindow::replace);
+  connect(this->replaceAllButton, &QPushButton::clicked, this,
+          &MainWindow::replaceAll);
+  connect(this->replaceInputField, &QLineEdit::returnPressed,
+          this->replaceButton, [this] { this->replaceButton->animateClick(); });
   addKeyboardShortCut(this->viewerToolBar->actions());
   addKeyboardShortCut(this->editortoolbar->actions());
 
   Preferences *instance = GlobalPreferences::inst();
 
-  InputDriverManager::instance()->registerActions(this->menuBar()->actions(), "", "");
-  InputDriverManager::instance()->registerActions(this->animateWidget->actions(), "animation", "animate");
+  InputDriverManager::instance()->registerActions(this->menuBar()->actions(),
+                                                  "", "");
+  InputDriverManager::instance()->registerActions(
+      this->animateWidget->actions(), "animation", "animate");
   instance->ButtonConfig->init();
 
   // fetch window states to be restored after restoreState() call
-  const bool isConsoldDockVisible = !settings.value("view/hideConsole").toBool();
+  const bool isConsoldDockVisible =
+      !settings.value("view/hideConsole").toBool();
   const bool isEditorDockVisible = !settings.value("view/hideEditor").toBool();
-  bool isCustomizerDockVisible = !settings.value("view/hideCustomizer").toBool();
+  bool isCustomizerDockVisible =
+      !settings.value("view/hideCustomizer").toBool();
   const bool isErrorLogVisible = !settings.value("view/hideErrorLog").toBool();
-  const bool isAnimateDockVisible = !settings.value("view/hideAnimate").toBool();
-  const bool isFontListDockVisible = !settings.value("view/hideFontList").toBool();
-  bool isViewportControlVisible = !settings.value("view/hideViewportControl").toBool();
-  const bool isEditorToolbarVisible = !settings.value("view/hideEditorToolbar").toBool();
-  const bool is3DViewToolbarVisible = !settings.value("view/hide3DViewToolbar").toBool();
+  const bool isAnimateDockVisible =
+      !settings.value("view/hideAnimate").toBool();
+  const bool isFontListDockVisible =
+      !settings.value("view/hideFontList").toBool();
+  bool isViewportControlVisible =
+      !settings.value("view/hideViewportControl").toBool();
+  const bool isEditorToolbarVisible =
+      !settings.value("view/hideEditorToolbar").toBool();
+  const bool is3DViewToolbarVisible =
+      !settings.value("view/hide3DViewToolbar").toBool();
 
   // make sure it looks nice..
-  const auto windowState = settings.value("window/state", QByteArray()).toByteArray();
-  restoreGeometry(settings.value("window/geometry", QByteArray()).toByteArray());
+  const auto windowState =
+      settings.value("window/state", QByteArray()).toByteArray();
+  restoreGeometry(
+      settings.value("window/geometry", QByteArray()).toByteArray());
 #if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
-  // Workaround for a Qt bug (possible QTBUG-46620, but it's still there in Qt-6.5.3)
-  // Blindly restoring a maximized window to a different screen resolution causes a crash
-  // on the next move/resize operation on macOS:
+  // Workaround for a Qt bug (possible QTBUG-46620, but it's still there in
+  // Qt-6.5.3) Blindly restoring a maximized window to a different screen
+  // resolution causes a crash on the next move/resize operation on macOS:
   // https://github.com/openscad/openscad/issues/5486
   if (isMaximized()) {
     setGeometry(screen()->availableGeometry());
@@ -707,7 +864,9 @@ MainWindow::MainWindow(const QStringList& filenames) :
     // On Windows that causes the main window to open in a not
     // easily reachable place.
     auto primaryScreen = QApplication::primaryScreen();
-    auto desktopRect = primaryScreen->availableGeometry().adjusted(250, 150, -250, -150).normalized();
+    auto desktopRect = primaryScreen->availableGeometry()
+                           .adjusted(250, 150, -250, -150)
+                           .normalized();
     auto windowRect = frameGeometry();
     if (!desktopRect.intersects(windowRect)) {
       windowRect.moveCenter(desktopRect.center());
@@ -718,58 +877,71 @@ MainWindow::MainWindow(const QStringList& filenames) :
 #endif // ifdef Q_OS_WIN
   }
 
-  updateWindowSettings(isConsoldDockVisible, isEditorDockVisible, isCustomizerDockVisible, isErrorLogVisible, isEditorToolbarVisible, is3DViewToolbarVisible, isAnimateDockVisible, isFontListDockVisible, isViewportControlVisible);
+  updateWindowSettings(
+      isConsoldDockVisible, isEditorDockVisible, isCustomizerDockVisible,
+      isErrorLogVisible, isEditorToolbarVisible, is3DViewToolbarVisible,
+      isAnimateDockVisible, isFontListDockVisible, isViewportControlVisible);
 
-  // Connect the menu "Windows/Navigation" to slot that process it by opening in a pop menu
-  // the navigationMenu.
-  connect(windowActionJumpTo, &QAction::triggered, this, &MainWindow::onNavigationOpenContextMenu);
+  // Connect the menu "Windows/Navigation" to slot that process it by opening in
+  // a pop menu the navigationMenu.
+  connect(windowActionJumpTo, &QAction::triggered, this,
+          &MainWindow::onNavigationOpenContextMenu);
 
   // Create the popup menu to navigate between the docks by keyboard.
   navigationMenu = new QMenu();
-  for (auto& [dock, title] : docks) {
+  for (auto &[dock, title] : docks) {
     auto action2 = navigationMenu->addAction(title);
     action2->setProperty("id", QVariant::fromValue(dock));
-    connect(action2, &QAction::triggered, this, &MainWindow::onNavigationTriggerContextMenuEntry);
-    connect(action2, &QAction::hovered, this, &MainWindow::onNavigationHoveredContextMenuEntry);
-  }
-  connect(navigationMenu, &QMenu::aboutToHide, this, &MainWindow::onNavigationCloseContextMenu);
-  connect(menuWindow, &QMenu::aboutToHide, this, &MainWindow::onNavigationCloseContextMenu);
+    connect(action2, &QAction::triggered, this,
+            &MainWindow::onNavigationTriggerContextMenuEntry);
+    connect(action2, &QAction::hovered, this,
+            &MainWindow::onNavigationHoveredContextMenuEntry);
+  }
+  connect(navigationMenu, &QMenu::aboutToHide, this,
+          &MainWindow::onNavigationCloseContextMenu);
+  connect(menuWindow, &QMenu::aboutToHide, this,
+          &MainWindow::onNavigationCloseContextMenu);
   windowActionJumpTo->setMenu(navigationMenu);
 
   // connect the signal of next/prev windowAction and the dedicated slot
-  // hovering is connected to rubberband activation while triggering is for actual
-  // activation of the corresponding dock.
-  const std::vector<QAction *> actions = {windowActionNextWindow, windowActionPreviousWindow};
-  for (auto& action : actions) {
-    connect(action, &QAction::hovered, this, &MainWindow::onWindowActionNextPrevHovered);
-    connect(action, &QAction::triggered, this, &MainWindow::onWindowActionNextPrevTriggered);
+  // hovering is connected to rubberband activation while triggering is for
+  // actual activation of the corresponding dock.
+  const std::vector<QAction *> actions = {windowActionNextWindow,
+                                          windowActionPreviousWindow};
+  for (auto &action : actions) {
+    connect(action, &QAction::hovered, this,
+            &MainWindow::onWindowActionNextPrevHovered);
+    connect(action, &QAction::triggered, this,
+            &MainWindow::onWindowActionNextPrevTriggered);
   }
 
   // Adds shortcut for the prev/next window switching
   shortcutNextWindow = new QShortcut(QKeySequence(Qt::CTRL + Qt::Key_K), this);
-  QObject::connect(shortcutNextWindow,    &QShortcut::activated,
-                   this,        &MainWindow::onWindowShortcutNextPrevActivated);
-  shortcutPreviousWindow = new QShortcut(QKeySequence(Qt::CTRL + Qt::Key_H), this);
-  QObject::connect(shortcutPreviousWindow,    &QShortcut::activated,
-                   this,        &MainWindow::onWindowShortcutNextPrevActivated);
+  QObject::connect(shortcutNextWindow, &QShortcut::activated, this,
+                   &MainWindow::onWindowShortcutNextPrevActivated);
+  shortcutPreviousWindow =
+      new QShortcut(QKeySequence(Qt::CTRL + Qt::Key_H), this);
+  QObject::connect(shortcutPreviousWindow, &QShortcut::activated, this,
+                   &MainWindow::onWindowShortcutNextPrevActivated);
 
   // Adds dock specific behavior on visibility change
-  QObject::connect(editorDock,  &Dock::visibilityChanged,
-                   this,        &MainWindow::onEditorDockVisibilityChanged);
-  QObject::connect(consoleDock,  &Dock::visibilityChanged,
-                   this,        &MainWindow::onConsoleDockVisibilityChanged);
-  QObject::connect(errorLogDock,  &Dock::visibilityChanged,
-                   this,        &MainWindow::onErrorLogDockVisibilityChanged);
-  QObject::connect(animateDock,  &Dock::visibilityChanged,
-                   this,        &MainWindow::onAnimateDockVisibilityChanged);
-  QObject::connect(fontListDock,  &Dock::visibilityChanged,
-                   this,        &MainWindow::onFontListDockVisibilityChanged);
-  QObject::connect(viewportControlDock,  &Dock::visibilityChanged,
-                   this,        &MainWindow::onViewportControlDockVisibilityChanged);
-  QObject::connect(parameterDock,  &Dock::visibilityChanged,
-                   this,        &MainWindow::onParametersDockVisibilityChanged);
-
-  connect(this->activeEditor, &EditorInterface::escapePressed, this, &MainWindow::measureFinished);
+  QObject::connect(editorDock, &Dock::visibilityChanged, this,
+                   &MainWindow::onEditorDockVisibilityChanged);
+  QObject::connect(consoleDock, &Dock::visibilityChanged, this,
+                   &MainWindow::onConsoleDockVisibilityChanged);
+  QObject::connect(errorLogDock, &Dock::visibilityChanged, this,
+                   &MainWindow::onErrorLogDockVisibilityChanged);
+  QObject::connect(animateDock, &Dock::visibilityChanged, this,
+                   &MainWindow::onAnimateDockVisibilityChanged);
+  QObject::connect(fontListDock, &Dock::visibilityChanged, this,
+                   &MainWindow::onFontListDockVisibilityChanged);
+  QObject::connect(viewportControlDock, &Dock::visibilityChanged, this,
+                   &MainWindow::onViewportControlDockVisibilityChanged);
+  QObject::connect(parameterDock, &Dock::visibilityChanged, this,
+                   &MainWindow::onParametersDockVisibilityChanged);
+
+  connect(this->activeEditor, &EditorInterface::escapePressed, this,
+          &MainWindow::measureFinished);
   // display this window and check for OpenGL 2.0 (OpenCSG) support
   viewModeThrownTogether();
   show();
@@ -797,7 +969,8 @@ MainWindow::MainWindow(const QStringList& filenames) :
   // Configure the highlighting color scheme from the active editor one.
   // This is done only one time at creation of the first MainWindow instance
   auto preferences = GlobalPreferences::inst();
-  if (!preferences->hasHighlightingColorScheme())preferences->setHighlightingColorSchemes(activeEditor->colorSchemes());
+  if (!preferences->hasHighlightingColorScheme())
+    preferences->setHighlightingColorSchemes(activeEditor->colorSchemes());
 
   onTabManagerEditorChanged(activeEditor);
 
@@ -809,13 +982,12 @@ void MainWindow::onNavigationOpenContextMenu() {
   navigationMenu->exec(QCursor::pos());
 }
 
-void MainWindow::onNavigationCloseContextMenu() {
-  rubberBandManager.hide();
-}
+void MainWindow::onNavigationCloseContextMenu() { rubberBandManager.hide(); }
 
-void MainWindow::onNavigationTriggerContextMenuEntry(){
+void MainWindow::onNavigationTriggerContextMenuEntry() {
   auto *action = qobject_cast<QAction *>(sender());
-  if (!action || !action->property("id").isValid()) return;
+  if (!action || !action->property("id").isValid())
+    return;
 
   Dock *dock = action->property("id").value<Dock *>();
   assert(dock != nullptr);
@@ -830,16 +1002,18 @@ void MainWindow::onNavigationTriggerContextMenuEntry(){
   }
 }
 
-void MainWindow::onNavigationHoveredContextMenuEntry(){
+void MainWindow::onNavigationHoveredContextMenuEntry() {
   auto *action = qobject_cast<QAction *>(sender());
-  if (!action || !action->property("id").isValid()) return;
+  if (!action || !action->property("id").isValid())
+    return;
 
   Dock *dock = action->property("id").value<Dock *>();
   assert(dock != nullptr);
 
   // Hover signal is emitted at each mouse move, to avoid excessive
   // load we only raise/emphasize if it is not yet done.
-  if (rubberBandManager.isEmphasized(dock)) return;
+  if (rubberBandManager.isEmphasized(dock))
+    return;
 
   dock->raise();
   rubberBandManager.emphasize(dock);
@@ -849,37 +1023,39 @@ void MainWindow::updateExportActions() {
   removeExportActions(editortoolbar, this->designAction3DPrint);
   addExportActions(this, editortoolbar, this->designAction3DPrint);
 
-  //handle the hide/show of export action in view toolbar according to the visibility of editor dock
+  // handle the hide/show of export action in view toolbar according to the
+  // visibility of editor dock
   removeExportActions(viewerToolBar, this->viewActionViewAll);
   if (!editorDock->isVisible()) {
     addExportActions(this, viewerToolBar, this->viewActionViewAll);
   }
 }
 
-void MainWindow::openFileFromPath(const QString& path, int line)
-{
+void MainWindow::openFileFromPath(const QString &path, int line) {
   if (editorDock->isVisible()) {
     activeEditor->setFocus();
-    if (!path.isEmpty()) tabManager->open(path);
+    if (!path.isEmpty())
+      tabManager->open(path);
     activeEditor->setFocus();
     activeEditor->setCursorPosition(line, 0);
   }
 }
 
-void MainWindow::addKeyboardShortCut(const QList<QAction *>& actions)
-{
-  for (auto& action : actions) {
+void MainWindow::addKeyboardShortCut(const QList<QAction *> &actions) {
+  for (auto &action : actions) {
     // prevent adding shortcut twice if action is added to multiple toolbars
     if (action->toolTip().contains("&nbsp;")) {
       continue;
     }
 
-    const QString shortCut(action->shortcut().toString(QKeySequence::NativeText));
+    const QString shortCut(
+        action->shortcut().toString(QKeySequence::NativeText));
     if (shortCut.isEmpty()) {
       continue;
     }
 
-    const QString toolTip("%1 &nbsp;<span style=\"color: gray; font-size: small; font-style: italic\">%2</span>");
+    const QString toolTip("%1 &nbsp;<span style=\"color: gray; font-size: "
+                          "small; font-style: italic\">%2</span>");
     action->setToolTip(toolTip.arg(action->toolTip(), shortCut));
   }
 }
@@ -889,16 +1065,11 @@ void MainWindow::addKeyboardShortCut(const QList<QAction *>& actions)
  * Qt call. So the values are loaded before the call and restored here
  * regardless of the (potential outdated) serialized state.
  */
-void MainWindow::updateWindowSettings(bool isConsoleVisible,
-                                      bool isEditorVisible,
-                                      bool isCustomizerVisible,
-                                      bool isErrorLogVisible,
-                                      bool isEditorToolbarVisible,
-                                      bool isViewToolbarVisible,
-                                      bool isAnimateVisible,
-                                      bool isFontListVisible,
-                                      bool isViewportControlVisible)
-{
+void MainWindow::updateWindowSettings(
+    bool isConsoleVisible, bool isEditorVisible, bool isCustomizerVisible,
+    bool isErrorLogVisible, bool isEditorToolbarVisible,
+    bool isViewToolbarVisible, bool isAnimateVisible, bool isFontListVisible,
+    bool isViewportControlVisible) {
   editorDock->setVisible(isEditorVisible);
   consoleDock->setVisible(isConsoleVisible);
   errorLogDock->setVisible(isErrorLogVisible);
@@ -913,39 +1084,30 @@ void MainWindow::updateWindowSettings(bool isConsoleVisible,
   hide3DViewToolbar();
 }
 
-void MainWindow::onAxisChanged(InputEventAxisChanged *)
-{
-
-}
-
-void MainWindow::onButtonChanged(InputEventButtonChanged *)
-{
+void MainWindow::onAxisChanged(InputEventAxisChanged *) {}
 
-}
+void MainWindow::onButtonChanged(InputEventButtonChanged *) {}
 
-void MainWindow::onTranslateEvent(InputEventTranslate *event)
-{
+void MainWindow::onTranslateEvent(InputEventTranslate *event) {
   const double zoomFactor = 0.001 * qglview->cam.zoomValue();
 
   if (event->viewPortRelative) {
     qglview->translate(event->x, event->y, event->z, event->relative, true);
   } else {
-    qglview->translate(zoomFactor * event->x, event->y, zoomFactor * event->z, event->relative, false);
+    qglview->translate(zoomFactor * event->x, event->y, zoomFactor * event->z,
+                       event->relative, false);
   }
 }
 
-void MainWindow::onRotateEvent(InputEventRotate *event)
-{
+void MainWindow::onRotateEvent(InputEventRotate *event) {
   qglview->rotate(event->x, event->y, event->z, event->relative);
 }
 
-void MainWindow::onRotate2Event(InputEventRotate2 *event)
-{
+void MainWindow::onRotate2Event(InputEventRotate2 *event) {
   qglview->rotate2(event->x, event->y, event->z);
 }
 
-void MainWindow::onActionEvent(InputEventAction *event)
-{
+void MainWindow::onActionEvent(InputEventAction *event) {
   const std::string actionName = event->action;
   if (actionName.find("::") == std::string::npos) {
     QAction *action = findAction(this->menuBar()->actions(), actionName);
@@ -964,12 +1126,11 @@ void MainWindow::onActionEvent(InputEventAction *event)
   }
 }
 
-void MainWindow::onZoomEvent(InputEventZoom *event)
-{
+void MainWindow::onZoomEvent(InputEventZoom *event) {
   qglview->zoom(event->zoom, event->relative);
 }
 
-void MainWindow::loadViewSettings(){
+void MainWindow::loadViewSettings() {
   const QSettingsCached settings;
 
   if (settings.value("view/showEdges").toBool()) {
@@ -994,83 +1155,102 @@ void MainWindow::loadViewSettings(){
     viewPerspective();
   }
 
-  updateUndockMode(GlobalPreferences::inst()->getValue("advanced/undockableWindows").toBool());
-  updateReorderMode(GlobalPreferences::inst()->getValue("advanced/reorderWindows").toBool());
+  updateUndockMode(GlobalPreferences::inst()
+                       ->getValue("advanced/undockableWindows")
+                       .toBool());
+  updateReorderMode(
+      GlobalPreferences::inst()->getValue("advanced/reorderWindows").toBool());
 }
 
-void MainWindow::loadDesignSettings()
-{
+void MainWindow::loadDesignSettings() {
   const QSettingsCached settings;
   if (settings.value("design/autoReload", false).toBool()) {
     designActionAutoReload->setChecked(true);
   }
-  auto polySetCacheSizeMB = GlobalPreferences::inst()->getValue("advanced/polysetCacheSizeMB").toUInt();
+  auto polySetCacheSizeMB = GlobalPreferences::inst()
+                                ->getValue("advanced/polysetCacheSizeMB")
+                                .toUInt();
   GeometryCache::instance()->setMaxSizeMB(polySetCacheSizeMB);
-  auto cgalCacheSizeMB = GlobalPreferences::inst()->getValue("advanced/cgalCacheSizeMB").toUInt();
+  auto cgalCacheSizeMB =
+      GlobalPreferences::inst()->getValue("advanced/cgalCacheSizeMB").toUInt();
   CGALCache::instance()->setMaxSizeMB(cgalCacheSizeMB);
-  auto backend3D = GlobalPreferences::inst()->getValue("advanced/renderBackend3D").toString().toStdString();
+  auto backend3D = GlobalPreferences::inst()
+                       ->getValue("advanced/renderBackend3D")
+                       .toString()
+                       .toStdString();
   RenderSettings::inst()->backend3D = renderBackend3DFromString(backend3D);
 }
 
-void MainWindow::updateUndockMode(bool undockMode)
-{
+void MainWindow::updateUndockMode(bool undockMode) {
   MainWindow::undockMode = undockMode;
   if (undockMode) {
-    editorDock->setFeatures(editorDock->features() | QDockWidget::DockWidgetFloatable);
-    consoleDock->setFeatures(consoleDock->features() | QDockWidget::DockWidgetFloatable);
-    parameterDock->setFeatures(parameterDock->features() | QDockWidget::DockWidgetFloatable);
-    errorLogDock->setFeatures(errorLogDock->features() | QDockWidget::DockWidgetFloatable);
-    animateDock->setFeatures(animateDock->features() | QDockWidget::DockWidgetFloatable);
-    fontListDock->setFeatures(fontListDock->features() | QDockWidget::DockWidgetFloatable);
-    viewportControlDock->setFeatures(viewportControlDock->features() | QDockWidget::DockWidgetFloatable);
+    editorDock->setFeatures(editorDock->features() |
+                            QDockWidget::DockWidgetFloatable);
+    consoleDock->setFeatures(consoleDock->features() |
+                             QDockWidget::DockWidgetFloatable);
+    parameterDock->setFeatures(parameterDock->features() |
+                               QDockWidget::DockWidgetFloatable);
+    errorLogDock->setFeatures(errorLogDock->features() |
+                              QDockWidget::DockWidgetFloatable);
+    animateDock->setFeatures(animateDock->features() |
+                             QDockWidget::DockWidgetFloatable);
+    fontListDock->setFeatures(fontListDock->features() |
+                              QDockWidget::DockWidgetFloatable);
+    viewportControlDock->setFeatures(viewportControlDock->features() |
+                                     QDockWidget::DockWidgetFloatable);
   } else {
     if (editorDock->isFloating()) {
       editorDock->setFloating(false);
     }
-    editorDock->setFeatures(editorDock->features() & ~QDockWidget::DockWidgetFloatable);
+    editorDock->setFeatures(editorDock->features() &
+                            ~QDockWidget::DockWidgetFloatable);
 
     if (consoleDock->isFloating()) {
       consoleDock->setFloating(false);
     }
-    consoleDock->setFeatures(consoleDock->features() & ~QDockWidget::DockWidgetFloatable);
+    consoleDock->setFeatures(consoleDock->features() &
+                             ~QDockWidget::DockWidgetFloatable);
 
     if (parameterDock->isFloating()) {
       parameterDock->setFloating(false);
     }
-    parameterDock->setFeatures(parameterDock->features() & ~QDockWidget::DockWidgetFloatable);
+    parameterDock->setFeatures(parameterDock->features() &
+                               ~QDockWidget::DockWidgetFloatable);
 
     if (errorLogDock->isFloating()) {
       errorLogDock->setFloating(false);
     }
-    errorLogDock->setFeatures(errorLogDock->features() & ~QDockWidget::DockWidgetFloatable);
+    errorLogDock->setFeatures(errorLogDock->features() &
+                              ~QDockWidget::DockWidgetFloatable);
 
     if (animateDock->isFloating()) {
       animateDock->setFloating(false);
     }
-    animateDock->setFeatures(animateDock->features() & ~QDockWidget::DockWidgetFloatable);
+    animateDock->setFeatures(animateDock->features() &
+                             ~QDockWidget::DockWidgetFloatable);
 
     if (fontListDock->isFloating()) {
       fontListDock->setFloating(false);
     }
-    fontListDock->setFeatures(fontListDock->features() & ~QDockWidget::DockWidgetFloatable);
+    fontListDock->setFeatures(fontListDock->features() &
+                              ~QDockWidget::DockWidgetFloatable);
 
     if (viewportControlDock->isFloating()) {
       viewportControlDock->setFloating(false);
     }
-    viewportControlDock->setFeatures(viewportControlDock->features() & ~QDockWidget::DockWidgetFloatable);
+    viewportControlDock->setFeatures(viewportControlDock->features() &
+                                     ~QDockWidget::DockWidgetFloatable);
   }
 }
 
-void MainWindow::updateReorderMode(bool reorderMode)
-{
+void MainWindow::updateReorderMode(bool reorderMode) {
   MainWindow::reorderMode = reorderMode;
-  for (auto& [dock, name] : docks) {
+  for (auto &[dock, name] : docks) {
     dock->setTitleBarVisibility(!reorderMode);
   }
 }
 
-MainWindow::~MainWindow()
-{
+MainWindow::~MainWindow() {
   // If root_file is not null then it will be the same as parsed_file,
   // so no need to delete it.
   delete parsedFile;
@@ -1082,13 +1262,12 @@ MainWindow::~MainWindow()
   }
 }
 
-void MainWindow::showProgress()
-{
+void MainWindow::showProgress() {
   updateStatusBar(qobject_cast<ProgressWidget *>(sender()));
 }
 
-void MainWindow::report_func(const std::shared_ptr<const AbstractNode>&, void *vp, int mark)
-{
+void MainWindow::report_func(const std::shared_ptr<const AbstractNode> &,
+                             void *vp, int mark) {
   // limit to progress bar update calls to 5 per second
   static const qint64 MIN_TIMEOUT = 200;
   if (progressThrottle->hasExpired(MIN_TIMEOUT)) {
@@ -1098,34 +1277,35 @@ void MainWindow::report_func(const std::shared_ptr<const AbstractNode>&, void *v
     auto v = static_cast<int>((mark * 1000.0) / progress_report_count);
     auto permille = v < 1000 ? v : 999;
     if (permille > thisp->progresswidget->value()) {
-      QMetaObject::invokeMethod(thisp->progresswidget, "setValue", Qt::QueuedConnection,
-                                Q_ARG(int, permille));
+      QMetaObject::invokeMethod(thisp->progresswidget, "setValue",
+                                Qt::QueuedConnection, Q_ARG(int, permille));
       QApplication::processEvents();
     }
 
     // FIXME: Check if cancel was requested by e.g. Application quit
-    if (thisp->progresswidget->wasCanceled()) throw ProgressCancelException();
+    if (thisp->progresswidget->wasCanceled())
+      throw ProgressCancelException();
   }
 }
 
-bool MainWindow::network_progress_func(const double permille)
-{
-  QMetaObject::invokeMethod(this->progresswidget, "setValue", Qt::QueuedConnection, Q_ARG(int, (int)permille));
+bool MainWindow::network_progress_func(const double permille) {
+  QMetaObject::invokeMethod(this->progresswidget, "setValue",
+                            Qt::QueuedConnection, Q_ARG(int, (int)permille));
   return (progresswidget && progresswidget->wasCanceled());
 }
 
-void MainWindow::updateRecentFiles(const QString& FileSavedOrOpened)
-{
+void MainWindow::updateRecentFiles(const QString &FileSavedOrOpened) {
   // Check that the canonical file path exists - only update recent files
   // if it does. Should prevent empty list items on initial open etc.
-  QSettingsCached settings;   // already set up properly via main.cpp
+  QSettingsCached settings; // already set up properly via main.cpp
   auto files = settings.value("recentFileList").toStringList();
   files.removeAll(FileSavedOrOpened);
   files.prepend(FileSavedOrOpened);
-  while (files.size() > UIUtils::maxRecentFiles) files.removeLast();
+  while (files.size() > UIUtils::maxRecentFiles)
+    files.removeLast();
   settings.setValue("recentFileList", files);
 
-  for (auto& widget : QApplication::topLevelWidgets()) {
+  for (auto &widget : QApplication::topLevelWidgets()) {
     auto mainWin = qobject_cast<MainWindow *>(widget);
     if (mainWin) {
       mainWin->updateRecentFileActions();
@@ -1136,15 +1316,24 @@ void MainWindow::updateRecentFiles(const QString& FileSavedOrOpened)
 /*!
    compiles the design. Calls compileDone() if anything was compiled
  */
-void MainWindow::compile(bool reload, bool forcedone)
-{
-  OpenSCAD::hardwarnings = GlobalPreferences::inst()->getValue("advanced/enableHardwarnings").toBool();
-  OpenSCAD::traceDepth = GlobalPreferences::inst()->getValue("advanced/traceDepth").toUInt();
-  OpenSCAD::traceUsermoduleParameters = GlobalPreferences::inst()->getValue("advanced/enableTraceUsermoduleParameters").toBool();
-  OpenSCAD::parameterCheck = GlobalPreferences::inst()->getValue("advanced/enableParameterCheck").toBool();
-  OpenSCAD::rangeCheck = GlobalPreferences::inst()->getValue("advanced/enableParameterRangeCheck").toBool();
-
-  try{
+void MainWindow::compile(bool reload, bool forcedone) {
+  OpenSCAD::hardwarnings = GlobalPreferences::inst()
+                               ->getValue("advanced/enableHardwarnings")
+                               .toBool();
+  OpenSCAD::traceDepth =
+      GlobalPreferences::inst()->getValue("advanced/traceDepth").toUInt();
+  OpenSCAD::traceUsermoduleParameters =
+      GlobalPreferences::inst()
+          ->getValue("advanced/enableTraceUsermoduleParameters")
+          .toBool();
+  OpenSCAD::parameterCheck = GlobalPreferences::inst()
+                                 ->getValue("advanced/enableParameterCheck")
+                                 .toBool();
+  OpenSCAD::rangeCheck = GlobalPreferences::inst()
+                             ->getValue("advanced/enableParameterRangeCheck")
+                             .toBool();
+
+  try {
     bool shouldcompiletoplevel = false;
     bool didcompile = false;
 
@@ -1153,18 +1342,23 @@ void MainWindow::compile(bool reload, bool forcedone)
 
     this->renderStatistic.start();
 
-    // Reload checks the timestamp of the toplevel file and refreshes if necessary,
+    // Reload checks the timestamp of the toplevel file and refreshes if
+    // necessary,
     if (reload) {
       // Refresh files if it has changed on disk
       if (fileChangedOnDisk() && checkEditorModified()) {
-        shouldcompiletoplevel = tabManager->refreshDocument();         // don't compile if we couldn't open the file
-        if (shouldcompiletoplevel && GlobalPreferences::inst()->getValue("advanced/autoReloadRaise").toBool()) {
+        shouldcompiletoplevel =
+            tabManager->refreshDocument(); // don't compile if we couldn't open
+                                           // the file
+        if (shouldcompiletoplevel && GlobalPreferences::inst()
+                                         ->getValue("advanced/autoReloadRaise")
+                                         .toBool()) {
           // reloading the 'same' document brings the 'old' one to front.
           this->raise();
         }
       }
-      // If the file has some content and there is no currently compiled content,
-      // then we force the top level compilation.
+      // If the file has some content and there is no currently compiled
+      // content, then we force the top level compilation.
       else {
         auto current_doc = activeEditor->toPlainText();
         if (current_doc.size() && lastCompiledDoc.size() == 0) {
@@ -1183,23 +1377,29 @@ void MainWindow::compile(bool reload, bool forcedone)
       }
     }
 
-    // Parsing and dependency handling must run to completion even with stop on errors to prevent auto
-    // reload picking up where it left off, thwarting the stop, so we turn off exceptions in PRINT.
+    // Parsing and dependency handling must run to completion even with stop on
+    // errors to prevent auto reload picking up where it left off, thwarting the
+    // stop, so we turn off exceptions in PRINT.
     no_exceptions_for_warnings();
     if (shouldcompiletoplevel) {
       initialize_rng();
       this->errorLogWidget->clearModel();
-      if (GlobalPreferences::inst()->getValue("advanced/consoleAutoClear").toBool()) {
+      if (GlobalPreferences::inst()
+              ->getValue("advanced/consoleAutoClear")
+              .toBool()) {
         this->console->actionClearConsole_triggered();
       }
-      if (activeEditor->isContentModified()) saveBackup();
+      if (activeEditor->isContentModified())
+        saveBackup();
       parseTopLevelDocument();
       didcompile = true;
     }
 
     if (didcompile && parser_error_pos != lastParserErrorPos) {
-      if (lastParserErrorPos >= 0) emit unhighlightLastError();
-      if (parser_error_pos >= 0) emit highlightError(parser_error_pos);
+      if (lastParserErrorPos >= 0)
+        emit unhighlightLastError();
+      if (parser_error_pos >= 0)
+        emit highlightError(parser_error_pos);
       lastParserErrorPos = parser_error_pos;
     }
 
@@ -1207,15 +1407,17 @@ void MainWindow::compile(bool reload, bool forcedone)
       auto mtime = this->rootFile->handleDependencies();
       if (mtime > this->depsMTime) {
         this->depsMTime = mtime;
-        LOG("Used file cache size: %1$d files", SourceFileCache::instance()->size());
+        LOG("Used file cache size: %1$d files",
+            SourceFileCache::instance()->size());
         didcompile = true;
       }
     }
 
     // Had any errors in the parse that would have caused exceptions via PRINT.
-    if (would_have_thrown()) throw HardWarningException("");
-    // If we're auto-reloading, listen for a cascade of changes by starting a timer
-    // if something changed _and_ there are any external dependencies
+    if (would_have_thrown())
+      throw HardWarningException("");
+    // If we're auto-reloading, listen for a cascade of changes by starting a
+    // timer if something changed _and_ there are any external dependencies
     if (reload && didcompile && this->rootFile) {
       if (this->rootFile->hasIncludes() || this->rootFile->usesLibraries()) {
         this->waitAfterReloadTimer->start();
@@ -1225,35 +1427,34 @@ void MainWindow::compile(bool reload, bool forcedone)
     }
 
     compileDone(didcompile | forcedone);
-  } catch (const HardWarningException&) {
+  } catch (const HardWarningException &) {
     exceptionCleanup();
-  } catch (const std::exception& ex) {
+  } catch (const std::exception &ex) {
     UnknownExceptionCleanup(ex.what());
   } catch (...) {
     UnknownExceptionCleanup();
   }
 }
 
-void MainWindow::waitAfterReload()
-{
+void MainWindow::waitAfterReload() {
   no_exceptions_for_warnings();
   auto mtime = this->rootFile->handleDependencies();
   auto stop = would_have_thrown();
-  if (mtime > this->depsMTime) this->depsMTime = mtime;
+  if (mtime > this->depsMTime)
+    this->depsMTime = mtime;
   else if (!stop) {
-    compile(true, true);     // In case file itself or top-level includes changed during dependency updates
+    compile(true, true); // In case file itself or top-level includes changed
+                         // during dependency updates
     return;
   }
   this->waitAfterReloadTimer->start();
 }
 
-void MainWindow::on_toolButtonCompileResultClose_clicked()
-{
+void MainWindow::on_toolButtonCompileResultClose_clicked() {
   frameCompileResult->hide();
 }
 
-void MainWindow::updateCompileResult()
-{
+void MainWindow::updateCompileResult() {
   if ((compileErrors == 0) && (compileWarnings == 0)) {
     frameCompileResult->hide();
     return;
@@ -1271,11 +1472,15 @@ void MainWindow::updateCompileResult()
       const QFileInfo fileInfo(activeEditor->filepath);
       msg = QString(_("Error while compiling '%1'.")).arg(fileInfo.fileName());
     }
-    toolButtonCompileResultIcon->setIcon(QIcon(QString::fromUtf8(":/icons/information-icons-error.png")));
+    toolButtonCompileResultIcon->setIcon(
+        QIcon(QString::fromUtf8(":/icons/information-icons-error.png")));
   } else {
-    const char *fmt = ngettext("Compilation generated %1 warning.", "Compilation generated %1 warnings.", compileWarnings);
+    const char *fmt =
+        ngettext("Compilation generated %1 warning.",
+                 "Compilation generated %1 warnings.", compileWarnings);
     msg = QString(fmt).arg(compileWarnings);
-    toolButtonCompileResultIcon->setIcon(QIcon(QString::fromUtf8(":/icons/information-icons-warning.png")));
+    toolButtonCompileResultIcon->setIcon(
+        QIcon(QString::fromUtf8(":/icons/information-icons-warning.png")));
   }
   const QFontMetrics fm(labelCompileResultMessage->font());
   const int sizeIcon = std::max(12, std::min(32, fm.height()));
@@ -1283,15 +1488,17 @@ void MainWindow::updateCompileResult()
   toolButtonCompileResultIcon->setIconSize(QSize(sizeIcon, sizeIcon));
   toolButtonCompileResultClose->setIconSize(QSize(sizeClose, sizeClose));
 
-  msg += _(R"( For details see the <a href="#errorlog">error log</a> and <a href="#console">console window</a>.)");
+  msg += _(
+      R"( For details see the <a href="#errorlog">error log</a> and <a href="#console">console window</a>.)");
   labelCompileResultMessage->setText(msg);
   frameCompileResult->show();
 }
 
-void MainWindow::compileDone(bool didchange)
-{
-  OpenSCAD::hardwarnings = GlobalPreferences::inst()->getValue("advanced/enableHardwarnings").toBool();
-  try{
+void MainWindow::compileDone(bool didchange) {
+  OpenSCAD::hardwarnings = GlobalPreferences::inst()
+                               ->getValue("advanced/enableHardwarnings")
+                               .toBool();
+  try {
     const char *callslot;
     if (didchange) {
       instantiateRoot();
@@ -1303,37 +1510,38 @@ void MainWindow::compileDone(bool didchange)
 
     this->procevents = false;
     QMetaObject::invokeMethod(this, callslot);
-  } catch (const HardWarningException&) {
+  } catch (const HardWarningException &) {
     exceptionCleanup();
   }
 }
 
-void MainWindow::compileEnded()
-{
+void MainWindow::compileEnded() {
   clearCurrentOutput();
   GuiLocker::unlock();
-  if (designActionAutoReload->isChecked()) autoReloadTimer->start();
+  if (designActionAutoReload->isChecked())
+    autoReloadTimer->start();
 #ifdef ENABLE_GUI_TESTS
   emit compilationDone(this->rootFile);
 #endif
 }
 
 #ifdef ENABLE_GUI_TESTS
-std::shared_ptr<AbstractNode> MainWindow::instantiateRootFromSource(SourceFile *file)
-{
+std::shared_ptr<AbstractNode>
+MainWindow::instantiateRootFromSource(SourceFile *file) {
   EvaluationSession session{file->getFullpath()};
-  ContextHandle<BuiltinContext> builtin_context{Context::create<BuiltinContext>(&session)};
+  ContextHandle<BuiltinContext> builtin_context{
+      Context::create<BuiltinContext>(&session)};
   setRenderVariables(builtin_context);
 
   std::shared_ptr<const FileContext> file_context;
-  std::shared_ptr<AbstractNode> node = this->rootFile->instantiate(*builtin_context, &file_context);
+  std::shared_ptr<AbstractNode> node =
+      this->rootFile->instantiate(*builtin_context, &file_context);
 
   return node;
 }
 #endif // ifdef ENABLE_GUI_TESTS
 
-void MainWindow::instantiateRoot()
-{
+void MainWindow::instantiateRoot() {
   // Go on and instantiate root_node, then call the continuation slot
 
   // Invalidate renderers before we kill the CSG tree
@@ -1366,15 +1574,18 @@ void MainWindow::instantiateRoot()
     AbstractNode::resetIndexCounter();
 
     EvaluationSession session{doc.parent_path().string()};
-    ContextHandle<BuiltinContext> builtin_context{Context::create<BuiltinContext>(&session)};
+    ContextHandle<BuiltinContext> builtin_context{
+        Context::create<BuiltinContext>(&session)};
     setRenderVariables(builtin_context);
 
     std::shared_ptr<const FileContext> file_context;
 #ifdef ENABLE_PYTHON
-    if (python_result_node != NULL && this->python_active) this->absoluteRootNode = python_result_node;
+    if (python_result_node != NULL && this->python_active)
+      this->absoluteRootNode = python_result_node;
     else
 #endif
-    this->absoluteRootNode = this->rootFile->instantiate(*builtin_context, &file_context);
+      this->absoluteRootNode =
+          this->rootFile->instantiate(*builtin_context, &file_context);
     if (file_context) {
       this->qglview->cam.updateView(file_context, false);
       viewportControlWidget->cameraChanged();
@@ -1383,21 +1594,25 @@ void MainWindow::instantiateRoot()
     if (this->absoluteRootNode) {
       // Do we have an explicit root node (! modifier)?
       const Location *nextLocation = nullptr;
-      if (!(this->rootNode = find_root_tag(this->absoluteRootNode, &nextLocation))) {
+      if (!(this->rootNode =
+                find_root_tag(this->absoluteRootNode, &nextLocation))) {
         this->rootNode = this->absoluteRootNode;
       }
       if (nextLocation) {
-        LOG(message_group::NONE, *nextLocation, builtin_context->documentRoot(), "More than one Root Modifier (!)");
+        LOG(message_group::NONE, *nextLocation, builtin_context->documentRoot(),
+            "More than one Root Modifier (!)");
       }
 
-      // FIXME: Consider giving away ownership of root_node to the Tree, or use reference counted pointers
+      // FIXME: Consider giving away ownership of root_node to the Tree, or use
+      // reference counted pointers
       this->tree.setRoot(this->rootNode);
     }
   }
 
   if (!this->rootNode) {
     if (parser_error_pos < 0) {
-      LOG(message_group::Error, "Compilation failed! (no top level object found)");
+      LOG(message_group::Error,
+          "Compilation failed! (no top level object found)");
     } else {
       LOG(message_group::Error, "Compilation failed!");
     }
@@ -1408,27 +1623,32 @@ void MainWindow::instantiateRoot()
 
 /*!
    Generates CSG tree for OpenCSG evaluation.
-   Assumes that the design has been parsed and evaluated (this->root_node is set)
+   Assumes that the design has been parsed and evaluated (this->root_node is
+   set)
  */
-void MainWindow::compileCSG()
-{
-  OpenSCAD::hardwarnings = GlobalPreferences::inst()->getValue("advanced/enableHardwarnings").toBool();
-  try{
+void MainWindow::compileCSG() {
+  OpenSCAD::hardwarnings = GlobalPreferences::inst()
+                               ->getValue("advanced/enableHardwarnings")
+                               .toBool();
+  try {
     assert(this->rootNode);
     LOG("Compiling design (CSG Products generation)...");
     this->processEvents();
 
     // Main CSG evaluation
     this->progresswidget = new ProgressWidget(this);
-    connect(this->progresswidget, &ProgressWidget::requestShow, this, &MainWindow::showProgress);
+    connect(this->progresswidget, &ProgressWidget::requestShow, this,
+            &MainWindow::showProgress);
 
     GeometryEvaluator geomevaluator(this->tree);
 #ifdef ENABLE_OPENCSG
     CSGTreeEvaluator csgrenderer(this->tree, &geomevaluator);
 #endif
 
-    if (!isClosing) progress_report_prep(this->rootNode, report_func, this);
-    else return;
+    if (!isClosing)
+      progress_report_prep(this->rootNode, report_func, this);
+    else
+      return;
     try {
 #ifdef ENABLE_OPENCSG
       this->processEvents();
@@ -1436,9 +1656,9 @@ void MainWindow::compileCSG()
 #endif
       renderStatistic.printCacheStatistic();
       this->processEvents();
-    } catch (const ProgressCancelException&) {
+    } catch (const ProgressCancelException &) {
       LOG("CSG generation cancelled.");
-    } catch (const HardWarningException&) {
+    } catch (const HardWarningException &) {
       LOG("CSG generation cancelled due to hardwarning being enabled.");
     }
     progress_report_fin();
@@ -1447,7 +1667,9 @@ void MainWindow::compileCSG()
     LOG("Compiling design (CSG Products normalization)...");
     this->processEvents();
 
-    const size_t normalizelimit = 2ul * GlobalPreferences::inst()->getValue("advanced/openCSGLimit").toUInt();
+    const size_t normalizelimit =
+        2ul *
+        GlobalPreferences::inst()->getValue("advanced/openCSGLimit").toUInt();
     CSGTreeNormalizer normalizer(normalizelimit);
 
     if (this->csgRoot) {
@@ -1457,18 +1679,20 @@ void MainWindow::compileCSG()
         this->rootProduct->import(this->normalizedRoot);
       } else {
         this->rootProduct.reset();
-        LOG(message_group::Warning, "CSG normalization resulted in an empty tree");
+        LOG(message_group::Warning,
+            "CSG normalization resulted in an empty tree");
         this->processEvents();
       }
     }
 
-    const std::vector<std::shared_ptr<CSGNode>>& highlight_terms = csgrenderer.getHighlightNodes();
+    const std::vector<std::shared_ptr<CSGNode>> &highlight_terms =
+        csgrenderer.getHighlightNodes();
     if (highlight_terms.size() > 0) {
       LOG("Compiling highlights (%1$d CSG Trees)...", highlight_terms.size());
       this->processEvents();
 
       this->highlightsProducts = std::make_shared<CSGProducts>();
-      for (const auto& highlight_term : highlight_terms) {
+      for (const auto &highlight_term : highlight_terms) {
         auto nterm = normalizer.normalize(highlight_term);
         if (nterm) {
           this->highlightsProducts->import(nterm);
@@ -1478,13 +1702,13 @@ void MainWindow::compileCSG()
       this->highlightsProducts.reset();
     }
 
-    const auto& background_terms = csgrenderer.getBackgroundNodes();
+    const auto &background_terms = csgrenderer.getBackgroundNodes();
     if (background_terms.size() > 0) {
       LOG("Compiling background (%1$d CSG Trees)...", background_terms.size());
       this->processEvents();
 
       this->backgroundProducts = std::make_shared<CSGProducts>();
-      for (const auto& background_term : background_terms) {
+      for (const auto &background_term : background_terms) {
         auto nterm = normalizer.normalize(background_term);
         if (nterm) {
           this->backgroundProducts->import(nterm);
@@ -1495,35 +1719,35 @@ void MainWindow::compileCSG()
     }
 
     if (this->rootProduct &&
-        (this->rootProduct->size() >
-         GlobalPreferences::inst()->getValue("advanced/openCSGLimit").toUInt())) {
-      LOG(message_group::UI_Warning, "Normalized tree has %1$d elements!", this->rootProduct->size());
+        (this->rootProduct->size() > GlobalPreferences::inst()
+                                         ->getValue("advanced/openCSGLimit")
+                                         .toUInt())) {
+      LOG(message_group::UI_Warning, "Normalized tree has %1$d elements!",
+          this->rootProduct->size());
       LOG(message_group::UI_Warning, "OpenCSG rendering has been disabled.");
     }
 #ifdef ENABLE_OPENCSG
     else {
       LOG("Normalized tree has %1$d elements!",
           (this->rootProduct ? this->rootProduct->size() : 0));
-      this->previewRenderer = std::make_shared<OpenCSGRenderer>(this->rootProduct,
-                                                                this->highlightsProducts,
-                                                                this->backgroundProducts);
+      this->previewRenderer = std::make_shared<OpenCSGRenderer>(
+          this->rootProduct, this->highlightsProducts,
+          this->backgroundProducts);
     }
 #endif // ifdef ENABLE_OPENCSG
-    this->thrownTogetherRenderer = std::make_shared<ThrownTogetherRenderer>(this->rootProduct,
-                                                                            this->highlightsProducts,
-                                                                            this->backgroundProducts);
+    this->thrownTogetherRenderer = std::make_shared<ThrownTogetherRenderer>(
+        this->rootProduct, this->highlightsProducts, this->backgroundProducts);
     LOG("Compile and preview finished.");
     renderStatistic.printRenderingTime();
     this->processEvents();
-  } catch (const HardWarningException&) {
+  } catch (const HardWarningException &) {
     exceptionCleanup();
   }
 }
 
-void MainWindow::actionOpen()
-{
+void MainWindow::actionOpen() {
   auto fileInfoList = UIUtils::openFiles(this);
-  for (auto& i : fileInfoList) {
+  for (auto &i : fileInfoList) {
     if (!i.exists()) {
       return;
     }
@@ -1531,15 +1755,11 @@ void MainWindow::actionOpen()
   }
 }
 
-void MainWindow::actionNewWindow()
-{
-  new MainWindow(QStringList());
-}
+void MainWindow::actionNewWindow() { new MainWindow(QStringList()); }
 
-void MainWindow::actionOpenWindow()
-{
+void MainWindow::actionOpenWindow() {
   auto fileInfoList = UIUtils::openFiles(this);
-  for (auto& i : fileInfoList) {
+  for (auto &i : fileInfoList) {
     if (!i.exists()) {
       return;
     }
@@ -1547,15 +1767,13 @@ void MainWindow::actionOpenWindow()
   }
 }
 
-void MainWindow::actionOpenRecent()
-{
+void MainWindow::actionOpenRecent() {
   auto action = qobject_cast<QAction *>(sender());
   tabManager->open(action->data().toString());
 }
 
-void MainWindow::clearRecentFiles()
-{
-  QSettingsCached settings;   // already set up properly via main.cpp
+void MainWindow::clearRecentFiles() {
+  QSettingsCached settings; // already set up properly via main.cpp
   const QStringList files;
   settings.setValue("recentFileList", files);
 
@@ -1564,12 +1782,12 @@ void MainWindow::clearRecentFiles()
 
 // Updates the content of the recent files menu entries
 // by iterating over the recently opened files.
-void MainWindow::updateRecentFileActions()
-{
+void MainWindow::updateRecentFileActions() {
   auto files = UIUtils::recentFiles();
 
   for (int i = 0; i < files.size(); ++i) {
-    this->actionRecentFile[i]->setText(QFileInfo(files[i]).fileName().replace("&", "&&"));
+    this->actionRecentFile[i]->setText(
+        QFileInfo(files[i]).fileName().replace("&", "&&"));
     this->actionRecentFile[i]->setData(files[i]);
     this->actionRecentFile[i]->setVisible(true);
   }
@@ -1578,21 +1796,22 @@ void MainWindow::updateRecentFileActions()
   }
 }
 
-void MainWindow::show_examples()
-{
+void MainWindow::show_examples() {
   bool found_example = false;
 
-  for (const auto& cat : UIUtils::exampleCategories()) {
+  for (const auto &cat : UIUtils::exampleCategories()) {
     auto examples = UIUtils::exampleFiles(cat.name);
-    auto menu = this->menuExamples->addMenu(gettext(cat.name.toStdString().c_str()));
+    auto menu =
+        this->menuExamples->addMenu(gettext(cat.name.toStdString().c_str()));
     if (!cat.tooltip.trimmed().isEmpty()) {
       menu->setToolTip(gettext(cat.tooltip.toStdString().c_str()));
       menu->setToolTipsVisible(true);
     }
 
-    for (const auto& ex : examples) {
+    for (const auto &ex : examples) {
       auto openAct = new QAction(ex.fileName().replace("&", "&&"), this);
-      connect(openAct, &QAction::triggered, this, &MainWindow::actionOpenExample);
+      connect(openAct, &QAction::triggered, this,
+              &MainWindow::actionOpenExample);
       menu->addAction(openAct);
       openAct->setData(ex.canonicalFilePath());
       found_example = true;
@@ -1605,17 +1824,15 @@ void MainWindow::show_examples()
   }
 }
 
-void MainWindow::actionOpenExample()
-{
+void MainWindow::actionOpenExample() {
   const auto action = qobject_cast<QAction *>(sender());
   if (action) {
-    const auto& path = action->data().toString();
+    const auto &path = action->data().toString();
     tabManager->open(path);
   }
 }
 
-void MainWindow::writeBackup(QFile *file)
-{
+void MainWindow::writeBackup(QFile *file) {
   // see MainWindow::saveBackup()
   file->resize(0);
   QTextStream writer(file);
@@ -1628,8 +1845,7 @@ void MainWindow::writeBackup(QFile *file)
   LOG("Saved backup file: %1$s", file->fileName().toUtf8().constData());
 }
 
-void MainWindow::saveBackup()
-{
+void MainWindow::saveBackup() {
   auto path = PlatformUtils::backupPath();
   if ((!fs::exists(path)) && (!PlatformUtils::createBackupPath())) {
     LOG(message_group::UI_Warning, "Cannot create backup path: %1$s", path);
@@ -1637,7 +1853,8 @@ void MainWindow::saveBackup()
   }
 
   auto backupPath = QString::fromLocal8Bit(path.c_str());
-  if (!backupPath.endsWith("/")) backupPath.append("/");
+  if (!backupPath.endsWith("/"))
+    backupPath.append("/");
 
   QString basename = "unsaved";
   if (!activeEditor->filepath.isEmpty()) {
@@ -1651,7 +1868,8 @@ void MainWindow::saveBackup()
 #else
     const QString suffix = "scad";
 #endif
-    this->tempFile = new QTemporaryFile(backupPath.append(basename + "-backup-XXXXXXXX." + suffix));
+    this->tempFile = new QTemporaryFile(
+        backupPath.append(basename + "-backup-XXXXXXXX." + suffix));
   }
 
   if ((!this->tempFile->isOpen()) && (!this->tempFile->open())) {
@@ -1661,31 +1879,25 @@ void MainWindow::saveBackup()
   return writeBackup(this->tempFile);
 }
 
-void MainWindow::actionSave()
-{
-  tabManager->save(activeEditor);
-}
+void MainWindow::actionSave() { tabManager->save(activeEditor); }
 
-void MainWindow::actionSaveAs()
-{
-  tabManager->saveAs(activeEditor);
-}
+void MainWindow::actionSaveAs() { tabManager->saveAs(activeEditor); }
 
-void MainWindow::actionPythonRevokeTrustedFiles()
-{
+void MainWindow::actionPythonRevokeTrustedFiles() {
   QSettingsCached settings;
 #ifdef ENABLE_PYTHON
   python_trusted = false;
   this->trusted_edit_document_name = "";
 #endif
   settings.remove("python_hash");
-  QMessageBox::information(this, _("Trusted Files"), "All trusted python files revoked", QMessageBox::Ok);
+  QMessageBox::information(this, _("Trusted Files"),
+                           "All trusted python files revoked", QMessageBox::Ok);
 }
 
-void MainWindow::actionPythonCreateVenv()
-{
+void MainWindow::actionPythonCreateVenv() {
 #ifdef ENABLE_PYTHON
-  const QString selectedDir = QFileDialog::getExistingDirectory(this, "Create Virtual Environment");
+  const QString selectedDir =
+      QFileDialog::getExistingDirectory(this, "Create Virtual Environment");
   if (selectedDir.isEmpty()) {
     return;
   }
@@ -1693,20 +1905,22 @@ void MainWindow::actionPythonCreateVenv()
   const QDir venvDir{selectedDir};
   if (!venvDir.exists()) {
     // Should not happen, but just in case double check...
-    QMessageBox::critical(this, _("Create Virtual Environment"),
-                          "Directory does not exist. Can't create virtual environment.",
-                          QMessageBox::Ok);
+    QMessageBox::critical(
+        this, _("Create Virtual Environment"),
+        "Directory does not exist. Can't create virtual environment.",
+        QMessageBox::Ok);
     return;
   }
 
   if (!venvDir.isEmpty()) {
-    QMessageBox::critical(this, _("Create Virtual Environment"),
-                          "Directory is not empty. Can't create virtual environment.",
-                          QMessageBox::Ok);
+    QMessageBox::critical(
+        this, _("Create Virtual Environment"),
+        "Directory is not empty. Can't create virtual environment.",
+        QMessageBox::Ok);
     return;
   }
 
-  const auto& path = venvDir.absolutePath().toStdString();
+  const auto &path = venvDir.absolutePath().toStdString();
   LOG("Creating Python virtual environment in '%1$s'...", path);
   int result = pythonCreateVenv(path);
 
@@ -1714,9 +1928,10 @@ void MainWindow::actionPythonCreateVenv()
     Settings::SettingsPython::pythonVirtualEnv.setValue(path);
     Settings::Settings::visit(SettingsWriter());
     LOG("Python virtual environment creation successfull.");
-    QMessageBox::information(this, _("Create Virtual Environment"),
-                             "Virtual environment created, please restart OpenSCAD to activate.",
-                             QMessageBox::Ok);
+    QMessageBox::information(
+        this, _("Create Virtual Environment"),
+        "Virtual environment created, please restart OpenSCAD to activate.",
+        QMessageBox::Ok);
   } else {
     LOG("Python virtual environment creation failed.");
     QMessageBox::critical(this, _("Create Virtual Environment"),
@@ -1726,10 +1941,10 @@ void MainWindow::actionPythonCreateVenv()
 #endif // ifdef ENABLE_PYTHON
 }
 
-void MainWindow::actionPythonSelectVenv()
-{
+void MainWindow::actionPythonSelectVenv() {
 #ifdef ENABLE_PYTHON
-  const QString venvDir = QFileDialog::getExistingDirectory(this, "Select Virtual Environment");
+  const QString venvDir =
+      QFileDialog::getExistingDirectory(this, "Select Virtual Environment");
   if (venvDir.isEmpty()) {
     return;
   }
@@ -1737,23 +1952,21 @@ void MainWindow::actionPythonSelectVenv()
   if (fileInfo.exists()) {
     Settings::SettingsPython::pythonVirtualEnv.setValue(venvDir.toStdString());
     Settings::Settings::visit(SettingsWriter());
-    QMessageBox::information(this, _("Select Virtual Environment"),
-                             "Virtual environment selected, please restart OpenSCAD to activate.",
-                             QMessageBox::Ok);
+    QMessageBox::information(
+        this, _("Select Virtual Environment"),
+        "Virtual environment selected, please restart OpenSCAD to activate.",
+        QMessageBox::Ok);
   }
 #endif // ifdef ENABLE_PYTHON
 }
 
-void MainWindow::actionSaveACopy()
-{
-  tabManager->saveACopy(activeEditor);
-}
+void MainWindow::actionSaveACopy() { tabManager->saveACopy(activeEditor); }
 
-void MainWindow::actionShowLibraryFolder()
-{
+void MainWindow::actionShowLibraryFolder() {
   auto path = PlatformUtils::userLibraryPath();
   if (!fs::exists(path)) {
-    LOG(message_group::UI_Warning, "Library path %1$s doesn't exist. Creating", path);
+    LOG(message_group::UI_Warning, "Library path %1$s doesn't exist. Creating",
+        path);
     if (!PlatformUtils::createUserLibraryPath()) {
       LOG(message_group::UI_Error, "Cannot create library path: %1$s", path);
     }
@@ -1763,48 +1976,42 @@ void MainWindow::actionShowLibraryFolder()
   QDesktopServices::openUrl(QUrl::fromLocalFile(url));
 }
 
-void MainWindow::actionReload()
-{
+void MainWindow::actionReload() {
   if (checkEditorModified()) {
-    fileChangedOnDisk();     // force cached autoReloadId to update
-    (void)tabManager->refreshDocument();     // ignore errors opening the file
+    fileChangedOnDisk();                 // force cached autoReloadId to update
+    (void)tabManager->refreshDocument(); // ignore errors opening the file
   }
 }
 
-void MainWindow::copyViewportTranslation()
-{
+void MainWindow::copyViewportTranslation() {
   const auto vpt = qglview->cam.getVpt();
   const QString txt = QString("[ %1, %2, %3 ]")
-    .arg(vpt.x(), 0, 'f', 2)
-    .arg(vpt.y(), 0, 'f', 2)
-    .arg(vpt.z(), 0, 'f', 2);
+                          .arg(vpt.x(), 0, 'f', 2)
+                          .arg(vpt.y(), 0, 'f', 2)
+                          .arg(vpt.z(), 0, 'f', 2);
   QApplication::clipboard()->setText(txt);
 }
 
-void MainWindow::copyViewportRotation()
-{
+void MainWindow::copyViewportRotation() {
   const auto vpr = qglview->cam.getVpr();
   const QString txt = QString("[ %1, %2, %3 ]")
-    .arg(vpr.x(), 0, 'f', 2)
-    .arg(vpr.y(), 0, 'f', 2)
-    .arg(vpr.z(), 0, 'f', 2);
+                          .arg(vpr.x(), 0, 'f', 2)
+                          .arg(vpr.y(), 0, 'f', 2)
+                          .arg(vpr.z(), 0, 'f', 2);
   QApplication::clipboard()->setText(txt);
 }
 
-void MainWindow::copyViewportDistance()
-{
+void MainWindow::copyViewportDistance() {
   const QString txt = QString::number(qglview->cam.zoomValue(), 'f', 2);
   QApplication::clipboard()->setText(txt);
 }
 
-void MainWindow::copyViewportFov()
-{
+void MainWindow::copyViewportFov() {
   const QString txt = QString::number(qglview->cam.fovValue(), 'f', 2);
   QApplication::clipboard()->setText(txt);
 }
 
-QList<double> MainWindow::getTranslation() const
-{
+QList<double> MainWindow::getTranslation() const {
   QList<double> ret;
   ret.append(qglview->cam.object_trans.x());
   ret.append(qglview->cam.object_trans.y());
@@ -1812,8 +2019,7 @@ QList<double> MainWindow::getTranslation() const
   return ret;
 }
 
-QList<double> MainWindow::getRotation() const
-{
+QList<double> MainWindow::getRotation() const {
   QList<double> ret;
   ret.append(qglview->cam.object_rot.x());
   ret.append(qglview->cam.object_rot.y());
@@ -1821,25 +2027,25 @@ QList<double> MainWindow::getRotation() const
   return ret;
 }
 
-void MainWindow::hideFind()
-{
+void MainWindow::hideFind() {
   find_panel->hide();
   activeEditor->findState = TabManager::FIND_HIDDEN;
   editActionFindNext->setEnabled(false);
   editActionFindPrevious->setEnabled(false);
-  this->findInputField->setFindCount(activeEditor->updateFindIndicators(this->findInputField->text(), false));
+  this->findInputField->setFindCount(
+      activeEditor->updateFindIndicators(this->findInputField->text(), false));
   this->processEvents();
 }
 
 // Prepare the UI for the find (and replace if requested)
-// Among other thing it makes the text field and replacement field visible and well as it configures the
-// activeEditor to appropriate search mode.
-void MainWindow::showFind(bool doFindAndReplace)
-{
-  findInputField->setFindCount(activeEditor->updateFindIndicators(findInputField->text()));
+// Among other thing it makes the text field and replacement field visible and
+// well as it configures the activeEditor to appropriate search mode.
+void MainWindow::showFind(bool doFindAndReplace) {
+  findInputField->setFindCount(
+      activeEditor->updateFindIndicators(findInputField->text()));
   processEvents();
 
-  if (doFindAndReplace){
+  if (doFindAndReplace) {
     findTypeComboBox->setCurrentIndex(1);
     replaceInputField->show();
     replaceButton->show();
@@ -1863,42 +2069,33 @@ void MainWindow::showFind(bool doFindAndReplace)
   findInputField->selectAll();
 }
 
-void MainWindow::actionShowFind()
-{
-  showFind(false);
-}
+void MainWindow::actionShowFind() { showFind(false); }
 
-void MainWindow::findString(const QString& textToFind)
-{
-  this->findInputField->setFindCount(activeEditor->updateFindIndicators(textToFind));
+void MainWindow::findString(const QString &textToFind) {
+  this->findInputField->setFindCount(
+      activeEditor->updateFindIndicators(textToFind));
   this->processEvents();
   activeEditor->find(textToFind);
 }
 
-void MainWindow::actionShowFindAndReplace()
-{
-  showFind(true);
-}
+void MainWindow::actionShowFindAndReplace() { showFind(true); }
 
-void MainWindow::actionSelectFind(int type)
-{
+void MainWindow::actionSelectFind(int type) {
   // If type is one, then we shows the find and replace UI component
   showFind(type == 1);
 }
 
-void MainWindow::replace()
-{
+void MainWindow::replace() {
   activeEditor->replaceSelectedText(this->replaceInputField->text());
   activeEditor->find(this->findInputField->text());
 }
 
-void MainWindow::replaceAll()
-{
-  activeEditor->replaceAll(this->findInputField->text(), this->replaceInputField->text());
+void MainWindow::replaceAll() {
+  activeEditor->replaceAll(this->findInputField->text(),
+                           this->replaceInputField->text());
 }
 
-void MainWindow::convertTabsToSpaces()
-{
+void MainWindow::convertTabsToSpaces() {
   const auto text = activeEditor->toPlainText();
 
   QString converted;
@@ -1920,30 +2117,26 @@ void MainWindow::convertTabsToSpaces()
   activeEditor->setText(converted);
 }
 
-void MainWindow::findNext()
-{
+void MainWindow::findNext() {
   activeEditor->find(this->findInputField->text(), true);
 }
 
-void MainWindow::findPrev()
-{
+void MainWindow::findPrev() {
   activeEditor->find(this->findInputField->text(), true, true);
 }
 
-void MainWindow::useSelectionForFind()
-{
+void MainWindow::useSelectionForFind() {
   findInputField->setText(activeEditor->selectedText());
 }
 
-void MainWindow::updateFindBuffer(const QString& s)
-{
+void MainWindow::updateFindBuffer(const QString &s) {
   QApplication::clipboard()->setText(s, QClipboard::FindBuffer);
 }
 
-void MainWindow::findBufferChanged()
-{
+void MainWindow::findBufferChanged() {
   auto t = QApplication::clipboard()->text(QClipboard::FindBuffer);
-  // The convention seems to be to not update the search field if the findbuffer is empty
+  // The convention seems to be to not update the search field if the findbuffer
+  // is empty
   if (!t.isEmpty()) {
     findInputField->setText(t);
   }
@@ -1961,8 +2154,7 @@ bool MainWindow::event(QEvent *event) {
   return QMainWindow::event(event);
 }
 
-bool MainWindow::eventFilter(QObject *obj, QEvent *event)
-{
+bool MainWindow::eventFilter(QObject *obj, QEvent *event) {
   if (rubberBandManager.isVisible()) {
     if (event->type() == QEvent::KeyRelease) {
       auto keyEvent = static_cast<QKeyEvent *>(event);
@@ -1986,28 +2178,28 @@ bool MainWindow::eventFilter(QObject *obj, QEvent *event)
   return QMainWindow::eventFilter(obj, event);
 }
 
-void MainWindow::setRenderVariables(ContextHandle<BuiltinContext>& context)
-{
+void MainWindow::setRenderVariables(ContextHandle<BuiltinContext> &context) {
   const RenderVariables r = {
-    .preview = this->isPreview,
-    .time = this->animateWidget->getAnimTval(),
-    .camera = qglview->cam,
+      .preview = this->isPreview,
+      .time = this->animateWidget->getAnimTval(),
+      .camera = qglview->cam,
   };
   r.applyToContext(context);
 }
 
 /*!
-   Returns true if the current document is a file on disk and that file has new content.
-   Returns false if a file on disk has disappeared or if we haven't yet saved.
+   Returns true if the current document is a file on disk and that file has new
+   content. Returns false if a file on disk has disappeared or if we haven't yet
+   saved.
  */
-bool MainWindow::fileChangedOnDisk()
-{
+bool MainWindow::fileChangedOnDisk() {
   if (!activeEditor->filepath.isEmpty()) {
     struct stat st;
     memset(&st, 0, sizeof(struct stat));
     const bool valid = (stat(activeEditor->filepath.toLocal8Bit(), &st) == 0);
     // If file isn't there, just return and use current editor text
-    if (!valid) return false;
+    if (!valid)
+      return false;
 
     auto newid = str(boost::format("%x.%x") % st.st_mtime % st.st_size);
     if (newid != activeEditor->autoReloadId) {
@@ -2023,27 +2215,32 @@ bool MainWindow::fileChangedOnDisk()
  */
 
 #ifdef ENABLE_PYTHON
-bool MainWindow::trust_python_file(const std::string& file,  const std::string& content) {
+bool MainWindow::trust_python_file(const std::string &file,
+                                   const std::string &content) {
   QSettingsCached settings;
   char setting_key[256];
-  if (python_trusted) return true;
+  if (python_trusted)
+    return true;
 
   std::string act_hash, ref_hash;
-  snprintf(setting_key, sizeof(setting_key) - 1, "python_hash/%s", file.c_str());
+  snprintf(setting_key, sizeof(setting_key) - 1, "python_hash/%s",
+           file.c_str());
   act_hash = SHA256HashString(content);
 
-  if (file == this->untrusted_edit_document_name) return false;
+  if (file == this->untrusted_edit_document_name)
+    return false;
 
   if (file == this->trusted_edit_document_name) {
     settings.setValue(setting_key, act_hash.c_str());
     return true;
   }
 
-  if (content.size() <= 1) {   // 1st character already typed
+  if (content.size() <= 1) { // 1st character already typed
     this->trusted_edit_document_name = file;
     return true;
   }
-  if (content.rfind("from openscad import", 0) == 0) {   // 1st character already typed
+  if (content.rfind("from openscad import", 0) ==
+      0) { // 1st character already typed
     this->trusted_edit_document_name = file;
     return true;
   }
@@ -2059,9 +2256,11 @@ bool MainWindow::trust_python_file(const std::string& file,  const std::string&
     return true;
   }
 
-  auto ret = QMessageBox::warning(this, "Application",
-                                  _("Python files can potentially contain harmful stuff.\n"
-                                    "Do you trust this file ?\n"), QMessageBox::Yes | QMessageBox::YesAll | QMessageBox::No);
+  auto ret = QMessageBox::warning(
+      this, "Application",
+      _("Python files can potentially contain harmful stuff.\n"
+        "Do you trust this file ?\n"),
+      QMessageBox::Yes | QMessageBox::YesAll | QMessageBox::No);
   if (ret == QMessageBox::YesAll) {
     python_trusted = true;
     return true;
@@ -2080,13 +2279,12 @@ bool MainWindow::trust_python_file(const std::string& file,  const std::string&
 }
 #endif // ifdef ENABLE_PYTHON
 
-
-SourceFile *MainWindow::parseDocument(EditorInterface *editor)
-{
+SourceFile *MainWindow::parseDocument(EditorInterface *editor) {
   resetSuppressedMessages();
 
   auto document = editor->toPlainText();
-  auto fulltext = std::string(document.toUtf8().constData()) + "\n\x03\n" + commandline_commands;
+  auto fulltext = std::string(document.toUtf8().constData()) + "\n\x03\n" +
+                  commandline_commands;
   auto fnameba = editor->filepath.toLocal8Bit();
 
   const char *fname = editor->filepath.isEmpty() ? "" : fnameba.constData();
@@ -2094,40 +2292,44 @@ SourceFile *MainWindow::parseDocument(EditorInterface *editor)
   this->python_active = false;
   if (fname != NULL) {
     if (boost::algorithm::ends_with(fname, ".py")) {
-      std::string content = std::string(this->lastCompiledDoc.toUtf8().constData());
-      if (
-        Feature::ExperimentalPythonEngine.is_enabled()
-        && trust_python_file(std::string(fname), content)) this->python_active = true;
-      else LOG(message_group::Warning, Location::NONE, "", "Python is not enabled");
+      std::string content =
+          std::string(this->lastCompiledDoc.toUtf8().constData());
+      if (Feature::ExperimentalPythonEngine.is_enabled() &&
+          trust_python_file(std::string(fname), content))
+        this->python_active = true;
+      else
+        LOG(message_group::Warning, Location::NONE, "",
+            "Python is not enabled");
     }
   }
 
   if (this->python_active) {
-    auto fulltext_py =
-      std::string(this->lastCompiledDoc.toUtf8().constData());
+    auto fulltext_py = std::string(this->lastCompiledDoc.toUtf8().constData());
 
-    const auto& venv = venvBinDirFromSettings();
-    const auto& binDir = venv.empty() ? PlatformUtils::applicationPath() : venv;
+    const auto &venv = venvBinDirFromSettings();
+    const auto &binDir = venv.empty() ? PlatformUtils::applicationPath() : venv;
     initPython(binDir, this->animateWidget->getAnimTval());
 
     if (venv.empty()) {
       LOG("Running %1$s without venv.", python_version());
     } else {
-      const auto& v = Settings::SettingsPython::pythonVirtualEnv.value();
+      const auto &v = Settings::SettingsPython::pythonVirtualEnv.value();
       LOG("Running %1$s in venv '%2$s'.", python_version(), v);
     }
     auto error = evaluatePython(fulltext_py, false);
-    if (error.size() > 0) LOG(message_group::Error, Location::NONE, "", error.c_str());
+    if (error.size() > 0)
+      LOG(message_group::Error, Location::NONE, "", error.c_str());
     fulltext = "\n";
   }
 #endif // ifdef ENABLE_PYTHON
 
   SourceFile *sourceFile;
-  sourceFile = parse(sourceFile, fulltext, fname, fname, false) ? sourceFile : nullptr;
+  sourceFile =
+      parse(sourceFile, fulltext, fname, fname, false) ? sourceFile : nullptr;
 
   editor->resetHighlighting();
   if (sourceFile) {
-    //add parameters as annotation in AST
+    // add parameters as annotation in AST
     CommentParser::collectParameters(fulltext, sourceFile);
     editor->parameterWidget->setParameters(sourceFile, fulltext);
     editor->parameterWidget->applyParameters(sourceFile);
@@ -2140,8 +2342,7 @@ SourceFile *MainWindow::parseDocument(EditorInterface *editor)
   return sourceFile;
 }
 
-void MainWindow::parseTopLevelDocument()
-{
+void MainWindow::parseTopLevelDocument() {
   resetSuppressedMessages();
 
   this->lastCompiledDoc = activeEditor->toPlainText();
@@ -2151,20 +2352,15 @@ void MainWindow::parseTopLevelDocument()
   this->parsedFile = this->rootFile;
 }
 
-void MainWindow::changeParameterWidget()
-{
-  parameterDock->setVisible(true);
-}
+void MainWindow::changeParameterWidget() { parameterDock->setVisible(true); }
 
-void MainWindow::checkAutoReload()
-{
+void MainWindow::checkAutoReload() {
   if (!activeEditor->filepath.isEmpty()) {
     actionReloadRenderPreview();
   }
 }
 
-void MainWindow::autoReloadSet(bool on)
-{
+void MainWindow::autoReloadSet(bool on) {
   QSettingsCached settings;
   settings.setValue("design/autoReload", designActionAutoReload->isChecked());
   if (on) {
@@ -2174,8 +2370,7 @@ void MainWindow::autoReloadSet(bool on)
   }
 }
 
-bool MainWindow::checkEditorModified()
-{
+bool MainWindow::checkEditorModified() {
   if (activeEditor->isContentModified()) {
     auto ret = QMessageBox::warning(this, _("Application"),
                                     _("The document has been modified.\n"
@@ -2188,9 +2383,9 @@ bool MainWindow::checkEditorModified()
   return true;
 }
 
-void MainWindow::actionReloadRenderPreview()
-{
-  if (GuiLocker::isLocked()) return;
+void MainWindow::actionReloadRenderPreview() {
+  if (GuiLocker::isLocked())
+    return;
   GuiLocker::lock();
   autoReloadTimer->stop();
   setCurrentOutput();
@@ -2201,9 +2396,9 @@ void MainWindow::actionReloadRenderPreview()
   compile(true);
 }
 
-void MainWindow::csgReloadRender()
-{
-  if (this->rootNode) compileCSG();
+void MainWindow::csgReloadRender() {
+  if (this->rootNode)
+    compileCSG();
 
   // Go to non-CGAL view mode
   if (viewActionThrownTogether->isChecked()) {
@@ -2218,8 +2413,8 @@ void MainWindow::csgReloadRender()
   compileEnded();
 }
 
-void MainWindow::prepareCompile(const char *afterCompileSlot, bool procevents, bool preview)
-{
+void MainWindow::prepareCompile(const char *afterCompileSlot, bool procevents,
+                                bool preview) {
   autoReloadTimer->stop();
   setCurrentOutput();
   LOG(" ");
@@ -2230,12 +2425,12 @@ void MainWindow::prepareCompile(const char *afterCompileSlot, bool procevents, b
   this->isPreview = preview;
 }
 
-void MainWindow::actionRenderPreview()
-{
+void MainWindow::actionRenderPreview() {
   static bool preview_requested;
   preview_requested = true;
 
-  if (GuiLocker::isLocked()) return;
+  if (GuiLocker::isLocked())
+    return;
 
   GuiLocker::lock();
   preview_requested = false;
@@ -2247,17 +2442,17 @@ void MainWindow::actionRenderPreview()
   compile(false, false);
 
   if (preview_requested) {
-    // if the action was called when the gui was locked, we must request it one more time
-    // however, it's not possible to call it directly NOR make the loop
-    // it must be called from the mainloop
+    // if the action was called when the gui was locked, we must request it one
+    // more time however, it's not possible to call it directly NOR make the
+    // loop it must be called from the mainloop
     QTimer::singleShot(0, this, &MainWindow::actionRenderPreview);
     return;
   }
 }
 
-void MainWindow::csgRender()
-{
-  if (this->rootNode) compileCSG();
+void MainWindow::csgRender() {
+  if (this->rootNode)
+    compileCSG();
 
   // Go to non-CGAL view mode
   if (viewActionThrownTogether->isChecked()) {
@@ -2270,36 +2465,43 @@ void MainWindow::csgRender()
 #endif
   }
 
-  if (animateWidget->dumpPictures() ) {
+  if (animateWidget->dumpPictures()) {
     const int steps = animateWidget->nextFrame();
     const QImage img = this->qglview->grabFrame();
-    const QString filename = QString("frame%1.png").arg(steps, 5, 10, QChar('0'));
+    const QString filename =
+        QString("frame%1.png").arg(steps, 5, 10, QChar('0'));
     img.save(filename, "PNG");
   }
 
   compileEnded();
 }
 
-void MainWindow::sendToExternalTool(ExternalToolInterface& externalToolService)
-{
+void MainWindow::sendToExternalTool(
+    ExternalToolInterface &externalToolService) {
   const QFileInfo activeFile(activeEditor->filepath);
   QString activeFileName = activeFile.fileName();
-  if (activeFileName.isEmpty()) activeFileName = "Untitled.scad";
+  if (activeFileName.isEmpty())
+    activeFileName = "Untitled.scad";
   // TODO: Replace suffix to match exported file format?
 
-  activeFileName = activeFileName + QString::fromStdString("." + fileformat::toSuffix(externalToolService.fileFormat()));
+  activeFileName =
+      activeFileName +
+      QString::fromStdString(
+          "." + fileformat::toSuffix(externalToolService.fileFormat()));
 
-  const bool export_status = externalToolService.exportTemporaryFile(rootGeom, activeFileName, &qglview->cam);
+  const bool export_status = externalToolService.exportTemporaryFile(
+      rootGeom, activeFileName, &qglview->cam);
   if (!export_status) {
     return;
   }
 
   this->progresswidget = new ProgressWidget(this);
-  connect(this->progresswidget, &ProgressWidget::requestShow, this, &MainWindow::showProgress);
+  connect(this->progresswidget, &ProgressWidget::requestShow, this,
+          &MainWindow::showProgress);
 
-  const bool process_status = externalToolService.process(activeFileName.toStdString(), [this](double permille) {
-    return network_progress_func(permille);
-  });
+  const bool process_status = externalToolService.process(
+      activeFileName.toStdString(),
+      [this](double permille) { return network_progress_func(permille); });
   updateStatusBar(nullptr);
   if (!process_status) {
     return;
@@ -2311,16 +2513,17 @@ void MainWindow::sendToExternalTool(ExternalToolInterface& externalToolService)
   }
 }
 
-void MainWindow::action3DPrint()
-{
-  if (GuiLocker::isLocked()) return;
+void MainWindow::action3DPrint() {
+  if (GuiLocker::isLocked())
+    return;
   const GuiLocker lock;
 
   setCurrentOutput();
 
-  //Make sure we can export:
+  // Make sure we can export:
   const unsigned int dim = 3;
-  if (!canExport(dim)) return;
+  if (!canExport(dim))
+    return;
 
   PrintInitDialog printInitDialog;
   const auto status = printInitDialog.exec();
@@ -2333,26 +2536,28 @@ void MainWindow::action3DPrint()
     LOG("Selected File format: %1$s", fileformat::info(fileFormat).description);
 
     GlobalPreferences::inst()->updateGUI();
-    const auto externalToolService = createExternalToolService(serviceType, serviceName, fileFormat);
+    const auto externalToolService =
+        createExternalToolService(serviceType, serviceName, fileFormat);
     if (!externalToolService) {
-      LOG("Error: Unable to create service: %1$d %2$s %3$d", static_cast<int>(serviceType), serviceName.toStdString(), static_cast<int>(fileFormat));
+      LOG("Error: Unable to create service: %1$d %2$s %3$d",
+          static_cast<int>(serviceType), serviceName.toStdString(),
+          static_cast<int>(fileFormat));
       return;
     }
     sendToExternalTool(*externalToolService);
   }
 }
 
-void MainWindow::actionRender()
-{
-  if (GuiLocker::isLocked()) return;
+void MainWindow::actionRender() {
+  if (GuiLocker::isLocked())
+    return;
   GuiLocker::lock();
 
   prepareCompile("cgalRender", true, false);
   compile(false);
 }
 
-void MainWindow::cgalRender()
-{
+void MainWindow::cgalRender() {
   if (!this->rootFile || !this->rootNode) {
     compileEnded();
     return;
@@ -2366,16 +2571,19 @@ void MainWindow::cgalRender()
       renderBackend3DToString(RenderSettings::inst()->backend3D).c_str());
 
   this->progresswidget = new ProgressWidget(this);
-  connect(this->progresswidget, &ProgressWidget::requestShow, this, &MainWindow::showProgress);
+  connect(this->progresswidget, &ProgressWidget::requestShow, this,
+          &MainWindow::showProgress);
 
-  if (!isClosing) progress_report_prep(this->rootNode, report_func, this);
-  else return;
+  if (!isClosing)
+    progress_report_prep(this->rootNode, report_func, this);
+  else
+    return;
 
   this->cgalworker->start(this->tree);
 }
 
-void MainWindow::actionRenderDone(const std::shared_ptr<const Geometry>& root_geom)
-{
+void MainWindow::actionRenderDone(
+    const std::shared_ptr<const Geometry> &root_geom) {
 #ifdef ENABLE_PYTHON
   python_lock();
 #endif
@@ -2395,8 +2603,8 @@ void MainWindow::actionRenderDone(const std::shared_ptr<const Geometry>& root_ge
     LOG("Rendering finished.");
 
     this->rootGeom = root_geom;
-    // Choose PolySetRenderer for PolySet and Polygon2d, and for Manifold since we
-    // know that all geometries are convertible to PolySet.
+    // Choose PolySetRenderer for PolySet and Polygon2d, and for Manifold since
+    // we know that all geometries are convertible to PolySet.
     if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend ||
         std::dynamic_pointer_cast<const PolySet>(this->rootGeom) ||
         std::dynamic_pointer_cast<const Polygon2d>(this->rootGeom)) {
@@ -2417,9 +2625,16 @@ void MainWindow::actionRenderDone(const std::shared_ptr<const Geometry>& root_ge
 
   updateStatusBar(nullptr);
 
-  const bool renderSoundEnabled = GlobalPreferences::inst()->getValue("advanced/enableSoundNotification").toBool();
-  const uint soundThreshold = GlobalPreferences::inst()->getValue("advanced/timeThresholdOnRenderCompleteSound").toUInt();
-  if (renderSoundEnabled && soundThreshold <= renderStatistic.ms().count() / 1000) {
+  const bool renderSoundEnabled =
+      GlobalPreferences::inst()
+          ->getValue("advanced/enableSoundNotification")
+          .toBool();
+  const uint soundThreshold =
+      GlobalPreferences::inst()
+          ->getValue("advanced/timeThresholdOnRenderCompleteSound")
+          .toUInt();
+  if (renderSoundEnabled &&
+      soundThreshold <= renderStatistic.ms().count() / 1000) {
     renderCompleteSoundEffect->play();
   }
 
@@ -2428,18 +2643,11 @@ void MainWindow::actionRenderDone(const std::shared_ptr<const Geometry>& root_ge
   compileEnded();
 }
 
-void MainWindow::actionMeasureDistance()
-{
-  meas.startMeasureDist();
-}
+void MainWindow::actionMeasureDistance() { meas.startMeasureDist(); }
 
-void MainWindow::actionMeasureAngle()
-{
-  meas.startMeasureAngle();
-}
+void MainWindow::actionMeasureAngle() { meas.startMeasureAngle(); }
 
-void MainWindow::leftClick(QPoint mouse)
-{
+void MainWindow::leftClick(QPoint mouse) {
   const QString str = meas.statemachine(mouse);
   if (str.size() > 0) {
     this->qglview->measure_state = MEASURE_IDLE;
@@ -2453,10 +2661,10 @@ void MainWindow::leftClick(QPoint mouse)
 /**
  * Call the mouseselection to determine the id of the clicked-on object.
  * Use the generated ID and try to find it within the list of products
- * And finally move the cursor to the beginning of the selected object in the editor
+ * And finally move the cursor to the beginning of the selected object in the
+ * editor
  */
-void MainWindow::rightClick(QPoint position)
-{
+void MainWindow::rightClick(QPoint position) {
   // selecting without a renderer?!
   if (!this->qglview->renderer) {
     return;
@@ -2469,13 +2677,14 @@ void MainWindow::rightClick(QPoint position)
   // Select the object at mouse coordinates
   const int index = this->qglview->pickObject(position);
   std::deque<std::shared_ptr<const AbstractNode>> path;
-  const std::shared_ptr<const AbstractNode> result = this->rootNode->getNodeByID(index, path);
+  const std::shared_ptr<const AbstractNode> result =
+      this->rootNode->getNodeByID(index, path);
 
   if (result) {
     // Create context menu with the backtrace
     QMenu tracemenu(this);
     std::stringstream ss;
-    for (auto& step : path) {
+    for (auto &step : path) {
       // Skip certain node types
       if (step->name() == "root") {
         continue;
@@ -2483,13 +2692,17 @@ void MainWindow::rightClick(QPoint position)
       auto location = step->modinst->location();
       ss.str("");
 
-      // Remove the "module" prefix if any as it induce confusion between the module declaration and instanciation
-      const int first_position = (step->verbose_name().find("module") == std::string::npos)? 0 : 7;
+      // Remove the "module" prefix if any as it induce confusion between the
+      // module declaration and instanciation
+      const int first_position =
+          (step->verbose_name().find("module") == std::string::npos) ? 0 : 7;
       std::string name = step->verbose_name().substr(first_position);
 
-      // It happens that the verbose_name is empty (eg: in for loops), when this happens instead of letting
-      // empty entry in the menu we prefer using the name in the modinstanciation.
-      if (step->verbose_name().empty()) name = step->modinst->name();
+      // It happens that the verbose_name is empty (eg: in for loops), when this
+      // happens instead of letting empty entry in the menu we prefer using the
+      // name in the modinstanciation.
+      if (step->verbose_name().empty())
+        name = step->modinst->name();
 
       // Check if the path is contained in a library (using parsersettings.h)
       const fs::path libpath = get_library_for_path(location.filePath());
@@ -2498,31 +2711,39 @@ void MainWindow::rightClick(QPoint position)
         ss << name << " (library "
            << location.fileName().substr(libpath.string().length() + 1) << ":"
            << location.firstLine() << ")";
-      } else if (renderedEditor->filepath.toStdString() == location.fileName()) {
-        // removes the "module" prefix if any as it makes it not clear if it is module declaration or call.
+      } else if (renderedEditor->filepath.toStdString() ==
+                 location.fileName()) {
+        // removes the "module" prefix if any as it makes it not clear if it is
+        // module declaration or call.
         ss << name << " (" << location.filePath().filename().string() << ":"
            << location.firstLine() << ")";
       } else {
-        auto relative_filename = fs_uncomplete(location.filePath(), fs::path(renderedEditor->filepath.toStdString()).parent_path())
-          .generic_string();
+        auto relative_filename =
+            fs_uncomplete(
+                location.filePath(),
+                fs::path(renderedEditor->filepath.toStdString()).parent_path())
+                .generic_string();
 
         // Set the displayed name relative to the active editor window
-        ss << name << " (" << relative_filename << ":" << location.firstLine() << ")";
+        ss << name << " (" << relative_filename << ":" << location.firstLine()
+           << ")";
       }
       // Prepare the action to be sent
       auto action = tracemenu.addAction(QString::fromStdString(ss.str()));
       if (editorDock->isVisible()) {
         action->setProperty("id", step->idx);
-        connect(action, &QAction::hovered, this, &MainWindow::onHoveredObjectInSelectionMenu);
+        connect(action, &QAction::hovered, this,
+                &MainWindow::onHoveredObjectInSelectionMenu);
       }
     }
 
-    // Before starting we need to lock the GUI to avoid interferance with reload/update
-    // triggered by other part of the application (eg: changing the renderedEditor)
+    // Before starting we need to lock the GUI to avoid interferance with
+    // reload/update triggered by other part of the application (eg: changing
+    // the renderedEditor)
     GuiLocker::lock();
 
     // Execute this lambda function when the selection menu is closing.
-    connect(&tracemenu, &QMenu::aboutToHide, [this](){
+    connect(&tracemenu, &QMenu::aboutToHide, [this]() {
       // remove the visual hints in the editor
       renderedEditor->clearAllSelectionIndicators();
       // unlock the GUI so the other part of the interface can now be updated.
@@ -2535,18 +2756,15 @@ void MainWindow::rightClick(QPoint position)
   }
 }
 
-void MainWindow::measureFinished()
-{
-  meas.stopMeasure();
-}
+void MainWindow::measureFinished() { meas.stopMeasure(); }
 
-void MainWindow::clearAllSelectionIndicators()
-{
+void MainWindow::clearAllSelectionIndicators() {
   this->activeEditor->clearAllSelectionIndicators();
 }
 
-void MainWindow::setSelectionIndicatorStatus(EditorInterface *editor, int nodeIndex, EditorSelectionIndicatorStatus status)
-{
+void MainWindow::setSelectionIndicatorStatus(
+    EditorInterface *editor, int nodeIndex,
+    EditorSelectionIndicatorStatus status) {
   std::deque<std::shared_ptr<const AbstractNode>> stack;
   this->rootNode->getNodeByID(nodeIndex, stack);
 
@@ -2556,23 +2774,24 @@ void MainWindow::setSelectionIndicatorStatus(EditorInterface *editor, int nodeIn
   // ends at size - 1 because we are not doing anything for the root node.
   // starts at 1 because we will process this one after later
   for (int i = 1; i < stack.size() - 1; i++) {
-    const auto& node = stack[i];
+    const auto &node = stack[i];
 
-    auto& location = node->modinst->location();
+    auto &location = node->modinst->location();
     if (location.filePath().compare(editor->filepath.toStdString()) != 0) {
       level++;
       continue;
     }
 
-    if (node->verbose_name().rfind("module", 0) == 0 || node->modinst->name() == "children") {
+    if (node->verbose_name().rfind("module", 0) == 0 ||
+        node->modinst->name() == "children") {
       editor->setSelectionIndicatorStatus(
-        status, level,
-        location.firstLine() - 1, location.firstColumn() - 1, location.lastLine() - 1, location.lastColumn() - 1);
+          status, level, location.firstLine() - 1, location.firstColumn() - 1,
+          location.lastLine() - 1, location.lastColumn() - 1);
       level++;
     }
   }
 
-  auto& node = stack[0];
+  auto &node = stack[0];
   auto location = node->modinst->location();
   auto line = location.firstLine();
   auto column = location.firstColumn();
@@ -2582,18 +2801,21 @@ void MainWindow::setSelectionIndicatorStatus(EditorInterface *editor, int nodeIn
   // Update the location returned by location to cover the whole section.
   node->getCodeLocation(0, 0, &line, &column, &lastLine, &lastColumn, 0);
 
-  editor->setSelectionIndicatorStatus(status, 0, line - 1, column - 1, lastLine - 1, lastColumn - 1);
+  editor->setSelectionIndicatorStatus(status, 0, line - 1, column - 1,
+                                      lastLine - 1, lastColumn - 1);
 }
 
-void MainWindow::setSelection(int index)
-{
+void MainWindow::setSelection(int index) {
   assert(renderedEditor != nullptr);
-  if (currentlySelectedObject == index) return;
+  if (currentlySelectedObject == index)
+    return;
 
   std::deque<std::shared_ptr<const AbstractNode>> path;
-  const std::shared_ptr<const AbstractNode> selected_node = rootNode->getNodeByID(index, path);
+  const std::shared_ptr<const AbstractNode> selected_node =
+      rootNode->getNodeByID(index, path);
 
-  if (!selected_node) return;
+  if (!selected_node)
+    return;
 
   currentlySelectedObject = index;
 
@@ -2602,8 +2824,8 @@ void MainWindow::setSelection(int index)
   auto line = location.firstLine();
   auto column = location.firstColumn();
 
-  // Unsaved files do have the pwd as current path, therefore we will not open a new
-  // tab on click
+  // Unsaved files do have the pwd as current path, therefore we will not open a
+  // new tab on click
   if (!fs::is_directory(fs::path(file))) {
     tabManager->open(QString::fromStdString(file));
   }
@@ -2615,16 +2837,20 @@ void MainWindow::setSelection(int index)
   std::vector<std::shared_ptr<const AbstractNode>> nodesSameModule{};
   rootNode->findNodesWithSameMod(selected_node, nodesSameModule);
 
-  // highlight in the text editor all the text fragment of the hierarchy of object with same mode.
-  for (const auto& element : nodesSameModule) {
+  // highlight in the text editor all the text fragment of the hierarchy of
+  // object with same mode.
+  for (const auto &element : nodesSameModule) {
     if (element->index() != currentlySelectedObject) {
-      setSelectionIndicatorStatus(renderedEditor, element->index(), EditorSelectionIndicatorStatus::IMPACTED);
+      setSelectionIndicatorStatus(renderedEditor, element->index(),
+                                  EditorSelectionIndicatorStatus::IMPACTED);
     }
   }
 
-  // highlight in the text editor only the fragment correponding to the selected stack.
-  // this step must be done after all the impacted element have been marked.
-  setSelectionIndicatorStatus(renderedEditor, currentlySelectedObject, EditorSelectionIndicatorStatus::SELECTED);
+  // highlight in the text editor only the fragment correponding to the selected
+  // stack. this step must be done after all the impacted element have been
+  // marked.
+  setSelectionIndicatorStatus(renderedEditor, currentlySelectedObject,
+                              EditorSelectionIndicatorStatus::SELECTED);
 
   renderedEditor->setCursorPosition(line - 1, column - 1);
 }
@@ -2632,8 +2858,7 @@ void MainWindow::setSelection(int index)
 /**
  * Expects the sender to have properties "id" defined
  */
-void MainWindow::onHoveredObjectInSelectionMenu()
-{
+void MainWindow::onHoveredObjectInSelectionMenu() {
   assert(renderedEditor != nullptr);
   auto *action = qobject_cast<QAction *>(sender());
   if (!action || !action->property("id").isValid()) {
@@ -2643,9 +2868,7 @@ void MainWindow::onHoveredObjectInSelectionMenu()
   setSelection(action->property("id").toInt());
 }
 
-void MainWindow::setLastFocus(QWidget *widget) {
-  this->lastFocus = widget;
-}
+void MainWindow::setLastFocus(QWidget *widget) { this->lastFocus = widget; }
 
 /**
  * Switch version label and progress widget. When switching to the progress
@@ -2657,8 +2880,7 @@ void MainWindow::setLastFocus(QWidget *widget) {
  * @param progressWidget a pointer to the progress widget to show or nullptr in
  * case the display should switch back to the version label.
  */
-void MainWindow::updateStatusBar(ProgressWidget *progressWidget)
-{
+void MainWindow::updateStatusBar(ProgressWidget *progressWidget) {
   auto sb = this->statusBar();
   if (progressWidget == nullptr) {
     if (this->progresswidget != nullptr) {
@@ -2667,7 +2889,8 @@ void MainWindow::updateStatusBar(ProgressWidget *progressWidget)
       this->progresswidget = nullptr;
     }
     if (versionLabel == nullptr) {
-      versionLabel = new QLabel("OpenSCAD " + QString::fromStdString(openscad_displayversionnumber));
+      versionLabel = new QLabel(
+          "OpenSCAD " + QString::fromStdString(openscad_displayversionnumber));
       sb->addPermanentWidget(this->versionLabel);
     }
   } else {
@@ -2680,15 +2903,16 @@ void MainWindow::updateStatusBar(ProgressWidget *progressWidget)
   }
 }
 
-void MainWindow::exceptionCleanup(){
+void MainWindow::exceptionCleanup() {
   LOG("Execution aborted");
   LOG(" ");
   GuiLocker::unlock();
-  if (designActionAutoReload->isChecked()) autoReloadTimer->start();
+  if (designActionAutoReload->isChecked())
+    autoReloadTimer->start();
 }
 
-void MainWindow::UnknownExceptionCleanup(std::string msg){
-  setCurrentOutput();   // we need to show this error
+void MainWindow::UnknownExceptionCleanup(std::string msg) {
+  setCurrentOutput(); // we need to show this error
   if (msg.size() == 0) {
     LOG(message_group::Error, "Compilation aborted by unknown exception");
   } else {
@@ -2696,56 +2920,61 @@ void MainWindow::UnknownExceptionCleanup(std::string msg){
   }
   LOG(" ");
   GuiLocker::unlock();
-  if (designActionAutoReload->isChecked()) autoReloadTimer->start();
+  if (designActionAutoReload->isChecked())
+    autoReloadTimer->start();
 }
 
-void MainWindow::showTextInWindow(const QString& type, const QString& content)
-{
+void MainWindow::showTextInWindow(const QString &type, const QString &content) {
   auto e = new QTextEdit(this);
   e->setAttribute(Qt::WA_DeleteOnClose);
   e->setWindowFlags(Qt::Window);
   e->setTabStopDistance(tabStopWidth);
   e->setWindowTitle(type + " Dump");
-  if (content.isEmpty())e->setPlainText("No " + type + " to dump. Please try compiling first...");
-  else e->setPlainText(content);
+  if (content.isEmpty())
+    e->setPlainText("No " + type + " to dump. Please try compiling first...");
+  else
+    e->setPlainText(content);
 
   e->setReadOnly(true);
   e->resize(600, 400);
   e->show();
 }
 
-void MainWindow::actionDisplayAST()
-{
+void MainWindow::actionDisplayAST() {
   setCurrentOutput();
-  QString text = (rootFile)? QString::fromStdString(rootFile->dump("")) : "";
+  QString text = (rootFile) ? QString::fromStdString(rootFile->dump("")) : "";
   showTextInWindow("AST", text);
   clearCurrentOutput();
 }
 
-void MainWindow::actionDisplayCSGTree()
-{
+void MainWindow::actionDisplayCSGTree() {
   setCurrentOutput();
-  QString text = (rootNode)? QString::fromStdString(tree.getString(*rootNode, "  ")) : "";
+  QString text =
+      (rootNode) ? QString::fromStdString(tree.getString(*rootNode, "  ")) : "";
   showTextInWindow("CSG", text);
   clearCurrentOutput();
 }
 
-void MainWindow::actionDisplayCSGProducts()
-{
+void MainWindow::actionDisplayCSGProducts() {
   setCurrentOutput();
   // a small lambda to avoid code duplication
-  auto constexpr dump = [](auto node){
-      return QString::fromStdString(node? node->dump() : "N/A");
-    };
-  auto text = QString("\nCSG before normalization:\n%1\n\n\nCSG after normalization:\n%2\n\n\nCSG rendering chain:\n%3\n\n\nHighlights CSG rendering chain:\n%4\n\n\nBackground CSG rendering chain:\n%5\n")
-    .arg(dump(csgRoot), dump(normalizedRoot), dump(rootProduct), dump(highlightsProducts), dump(backgroundProducts));
+  auto constexpr dump = [](auto node) {
+    return QString::fromStdString(node ? node->dump() : "N/A");
+  };
+  auto text =
+      QString(
+          "\nCSG before normalization:\n%1\n\n\nCSG after "
+          "normalization:\n%2\n\n\nCSG rendering chain:\n%3\n\n\nHighlights "
+          "CSG rendering chain:\n%4\n\n\nBackground CSG rendering chain:\n%5\n")
+          .arg(dump(csgRoot), dump(normalizedRoot), dump(rootProduct),
+               dump(highlightsProducts), dump(backgroundProducts));
   showTextInWindow("CSG Products Dump", text);
   clearCurrentOutput();
 }
 
-void MainWindow::actionCheckValidity()
-{
-  if (GuiLocker::isLocked()) return;
+void MainWindow::actionCheckValidity() {
+  if (GuiLocker::isLocked())
+    return;
   const GuiLocker lock;
   setCurrentOutput();
 
@@ -2764,11 +2993,13 @@ void MainWindow::actionCheckValidity()
   bool valid = true;
 #ifdef ENABLE_CGAL
   if (auto N = std::dynamic_pointer_cast<const CGALNefGeometry>(rootGeom)) {
-    valid = N->p3 ? const_cast<CGAL_Nef_polyhedron3&>(*N->p3).is_valid() : false;
+    valid =
+        N->p3 ? const_cast<CGAL_Nef_polyhedron3 &>(*N->p3).is_valid() : false;
   } else
 #endif
 #ifdef ENABLE_MANIFOLD
-  if (auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(rootGeom)) {
+      if (auto mani =
+              std::dynamic_pointer_cast<const ManifoldGeometry>(rootGeom)) {
     valid = mani->isValid();
   }
 #endif
@@ -2776,22 +3007,23 @@ void MainWindow::actionCheckValidity()
   clearCurrentOutput();
 }
 
-//Returns if we can export (true) or not(false) (bool)
-//Separated into it's own function for re-use.
-bool MainWindow::canExport(unsigned int dim)
-{
+// Returns if we can export (true) or not(false) (bool)
+// Separated into it's own function for re-use.
+bool MainWindow::canExport(unsigned int dim) {
   if (!rootGeom) {
-    LOG(message_group::Error, "Nothing to export! Try rendering first (press F6)");
+    LOG(message_group::Error,
+        "Nothing to export! Try rendering first (press F6)");
     clearCurrentOutput();
     return false;
   }
 
   // editor has changed since last render
   if (!activeEditor->contentsRendered) {
-    auto ret = QMessageBox::warning(this, "Application",
-                                    "The current tab has been modified since its last render (F6).\n"
-                                    "Do you really want to export the previous content?",
-                                    QMessageBox::Yes | QMessageBox::No);
+    auto ret = QMessageBox::warning(
+        this, "Application",
+        "The current tab has been modified since its last render (F6).\n"
+        "Do you really want to export the previous content?",
+        QMessageBox::Yes | QMessageBox::No);
     if (ret != QMessageBox::Yes) {
       return false;
     }
@@ -2799,17 +3031,19 @@ bool MainWindow::canExport(unsigned int dim)
 
   // other tab contents most recently rendered
   if (renderedEditor != activeEditor) {
-    auto ret = QMessageBox::warning(this, "Application",
-                                    "The rendered data is of different tab.\n"
-                                    "Do you really want to export the another tab's content?",
-                                    QMessageBox::Yes | QMessageBox::No);
+    auto ret = QMessageBox::warning(
+        this, "Application",
+        "The rendered data is of different tab.\n"
+        "Do you really want to export the another tab's content?",
+        QMessageBox::Yes | QMessageBox::No);
     if (ret != QMessageBox::Yes) {
       return false;
     }
   }
 
   if (rootGeom->getDimension() != dim) {
-    LOG(message_group::UI_Error, "Current top level object is not a %1$dD object.", dim);
+    LOG(message_group::UI_Error,
+        "Current top level object is not a %1$dD object.", dim);
     clearCurrentOutput();
     return false;
   }
@@ -2823,14 +3057,20 @@ bool MainWindow::canExport(unsigned int dim)
 #ifdef ENABLE_CGAL
   auto N = dynamic_cast<const CGALNefGeometry *>(rootGeom.get());
   if (N && !N->p3->is_simple()) {
-    LOG(message_group::UI_Warning, "Object may not be a valid 2-manifold and may need repair! See https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/STL_Import_and_Export");
+    LOG(message_group::UI_Warning,
+        "Object may not be a valid 2-manifold and may need repair! See "
+        "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/"
+        "STL_Import_and_Export");
   }
 #endif
 #ifdef ENABLE_MANIFOLD
   auto manifold = dynamic_cast<const ManifoldGeometry *>(rootGeom.get());
-  if (manifold && !manifold->isValid() ) {
-    LOG(message_group::UI_Warning, "Object may not be a valid manifold and may need repair! "
-        "Error message: %1$s. See https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/STL_Import_and_Export",
+  if (manifold && !manifold->isValid()) {
+    LOG(message_group::UI_Warning,
+        "Object may not be a valid manifold and may need repair! "
+        "Error message: %1$s. See "
+        "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/"
+        "STL_Import_and_Export",
         ManifoldUtils::statusToString(manifold->getManifold().Status()));
   }
 #endif
@@ -2838,45 +3078,49 @@ bool MainWindow::canExport(unsigned int dim)
   return true;
 }
 
-void MainWindow::actionExport(unsigned int dim, ExportInfo& exportInfo)
-{
+void MainWindow::actionExport(unsigned int dim, ExportInfo &exportInfo) {
   const auto type_name = QString::fromStdString(exportInfo.info.description);
   const auto suffix = QString::fromStdString(exportInfo.info.suffix);
 
-  //Setting filename skips the file selection dialog and uses the path provided instead.
-  if (GuiLocker::isLocked()) return;
+  // Setting filename skips the file selection dialog and uses the path provided
+  // instead.
+  if (GuiLocker::isLocked())
+    return;
   const GuiLocker lock;
 
   setCurrentOutput();
 
-  //Return if something is wrong and we can't export.
-  if (!canExport(dim)) return;
+  // Return if something is wrong and we can't export.
+  if (!canExport(dim))
+    return;
 
   auto title = QString(_("Export %1 File")).arg(type_name);
   auto filter = QString(_("%1 Files (*%2)")).arg(type_name, suffix);
-  auto exportFilename = QFileDialog::getSaveFileName(this, title, exportPath(suffix), filter);
+  auto exportFilename =
+      QFileDialog::getSaveFileName(this, title, exportPath(suffix), filter);
   if (exportFilename.isEmpty()) {
     clearCurrentOutput();
     return;
   }
   this->exportPaths[suffix] = exportFilename;
 
-  const bool exportResult = exportFileByName(rootGeom, exportFilename.toStdString(), exportInfo);
+  const bool exportResult =
+      exportFileByName(rootGeom, exportFilename.toStdString(), exportInfo);
 
-  if (exportResult) fileExportedMessage(type_name, exportFilename);
+  if (exportResult)
+    fileExportedMessage(type_name, exportFilename);
   clearCurrentOutput();
 }
 
-void MainWindow::actionExportFileFormat(int fmt)
-{
+void MainWindow::actionExportFileFormat(int fmt) {
   const auto format = static_cast<FileFormat>(fmt);
-  const FileFormatInfo& info = fileformat::info(format);
+  const FileFormatInfo &info = fileformat::info(format);
 
-  ExportInfo exportInfo = createExportInfo(format, info, activeEditor->filepath.toStdString(), &qglview->cam, {});
+  ExportInfo exportInfo = createExportInfo(
+      format, info, activeEditor->filepath.toStdString(), &qglview->cam, {});
 
   switch (format) {
-  case FileFormat::PDF:
-  {
+  case FileFormat::PDF: {
     ExportPdfDialog exportPdfDialog;
     if (exportPdfDialog.exec() == QDialog::Rejected) {
       return;
@@ -2884,10 +3128,8 @@ void MainWindow::actionExportFileFormat(int fmt)
 
     exportInfo.optionsPdf = exportPdfDialog.getOptions();
     actionExport(2, exportInfo);
-  }
-  break;
-  case FileFormat::_3MF:
-  {
+  } break;
+  case FileFormat::_3MF: {
     Export3mfDialog export3mfDialog;
     if (export3mfDialog.exec() == QDialog::Rejected) {
       return;
@@ -2895,20 +3137,19 @@ void MainWindow::actionExportFileFormat(int fmt)
 
     exportInfo.options3mf = export3mfDialog.getOptions();
     actionExport(3, exportInfo);
-  }
-  break;
-  case FileFormat::CSG:
-  {
+  } break;
+  case FileFormat::CSG: {
     setCurrentOutput();
 
     if (!this->rootNode) {
-      LOG(message_group::Error, "Nothing to export. Please try compiling first.");
+      LOG(message_group::Error,
+          "Nothing to export. Please try compiling first.");
       clearCurrentOutput();
       return;
     }
     const QString suffix = "csg";
-    auto csg_filename = QFileDialog::getSaveFileName(this,
-                                                     _("Export CSG File"), exportPath(suffix), _("CSG Files (*.csg)"));
+    auto csg_filename = QFileDialog::getSaveFileName(
+        this, _("Export CSG File"), exportPath(suffix), _("CSG Files (*.csg)"));
 
     if (csg_filename.isEmpty()) {
       clearCurrentOutput();
@@ -2917,7 +3158,8 @@ void MainWindow::actionExportFileFormat(int fmt)
 
     std::ofstream fstream(csg_filename.toLocal8Bit());
     if (!fstream.is_open()) {
-      LOG("Can't open file \"%1$s\" for export", csg_filename.toLocal8Bit().constData());
+      LOG("Can't open file \"%1$s\" for export",
+          csg_filename.toLocal8Bit().constData());
     } else {
       fstream << this->tree.getString(*this->rootNode, "\t") << "\n";
       fstream.close();
@@ -2926,34 +3168,36 @@ void MainWindow::actionExportFileFormat(int fmt)
     }
 
     clearCurrentOutput();
-  }      break;
-  case FileFormat::PNG:
-  {
+  } break;
+  case FileFormat::PNG: {
     // Grab first to make sure dialog box isn't part of the grabbed image
     qglview->grabFrame();
     const QString suffix = "png";
-    auto img_filename = QFileDialog::getSaveFileName(this,
-                                                     _("Export Image"), exportPath(suffix), _("PNG Files (*.png)"));
+    auto img_filename = QFileDialog::getSaveFileName(
+        this, _("Export Image"), exportPath(suffix), _("PNG Files (*.png)"));
     if (!img_filename.isEmpty()) {
-      const bool saveResult = qglview->save(img_filename.toLocal8Bit().constData());
+      const bool saveResult =
+          qglview->save(img_filename.toLocal8Bit().constData());
       if (saveResult) {
         this->exportPaths[suffix] = img_filename;
         setCurrentOutput();
         fileExportedMessage("PNG", img_filename);
         clearCurrentOutput();
       } else {
-        LOG("Can't open file \"%1$s\" for export image", img_filename.toLocal8Bit().constData());
+        LOG("Can't open file \"%1$s\" for export image",
+            img_filename.toLocal8Bit().constData());
       }
     }
-  }
-  break;
+  } break;
   default:
-    actionExport(fileformat::is3D(format) ? 3 : fileformat::is2D(format) ? 2 : 0, exportInfo);
+    actionExport(fileformat::is3D(format)   ? 3
+                 : fileformat::is2D(format) ? 2
+                                            : 0,
+                 exportInfo);
   }
 }
 
-void MainWindow::copyText()
-{
+void MainWindow::copyText() {
   auto *c = dynamic_cast<Console *>(lastFocus);
   if (c) {
     c->copy();
@@ -2962,15 +3206,13 @@ void MainWindow::copyText()
   }
 }
 
-void MainWindow::actionCopyViewport()
-{
-  const auto& image = qglview->grabFrame();
+void MainWindow::actionCopyViewport() {
+  const auto &image = qglview->grabFrame();
   auto clipboard = QApplication::clipboard();
   clipboard->setImage(image);
 }
 
-void MainWindow::actionFlushCaches()
-{
+void MainWindow::actionFlushCaches() {
   GeometryCache::instance()->clear();
   CGALCache::instance()->clear();
   dxf_dim_cache.clear();
@@ -2981,16 +3223,14 @@ void MainWindow::actionFlushCaches()
   LOG("Caches Flushed");
 }
 
-void MainWindow::viewModeActionsUncheck()
-{
+void MainWindow::viewModeActionsUncheck() {
   viewActionPreview->setChecked(false);
   viewActionThrownTogether->setChecked(false);
 }
 
 #ifdef ENABLE_OPENCSG
 
-void MainWindow::viewModeRender()
-{
+void MainWindow::viewModeRender() {
   viewActionThrownTogether->setEnabled(false);
   viewActionPreview->setEnabled(false);
   this->qglview->setRenderer(this->geomRenderer);
@@ -3002,14 +3242,15 @@ void MainWindow::viewModeRender()
    Go to the OpenCSG view mode.
    Falls back to thrown together mode if OpenCSG is not available
  */
-void MainWindow::viewModePreview()
-{
+void MainWindow::viewModePreview() {
   viewActionThrownTogether->setEnabled(true);
   viewActionPreview->setEnabled(this->qglview->hasOpenCSGSupport());
   if (this->qglview->hasOpenCSGSupport()) {
     viewActionPreview->setChecked(true);
     viewActionThrownTogether->setChecked(false);
-    this->qglview->setRenderer(this->previewRenderer ? this->previewRenderer : this->thrownTogetherRenderer);
+    this->qglview->setRenderer(this->previewRenderer
+                                   ? this->previewRenderer
+                                   : this->thrownTogetherRenderer);
     this->qglview->updateColorScheme();
     this->qglview->update();
   } else {
@@ -3019,8 +3260,7 @@ void MainWindow::viewModePreview()
 
 #endif /* ENABLE_OPENCSG */
 
-void MainWindow::viewModeThrownTogether()
-{
+void MainWindow::viewModeThrownTogether() {
   viewActionThrownTogether->setEnabled(true);
   viewActionPreview->setEnabled(this->qglview->hasOpenCSGSupport());
   viewActionThrownTogether->setChecked(true);
@@ -3030,16 +3270,14 @@ void MainWindow::viewModeThrownTogether()
   this->qglview->update();
 }
 
-void MainWindow::viewModeShowEdges()
-{
+void MainWindow::viewModeShowEdges() {
   QSettingsCached settings;
   settings.setValue("view/showEdges", viewActionShowEdges->isChecked());
   this->qglview->setShowEdges(viewActionShowEdges->isChecked());
   this->qglview->update();
 }
 
-void MainWindow::viewModeShowAxes()
-{
+void MainWindow::viewModeShowAxes() {
   const bool showaxes = viewActionShowAxes->isChecked();
   QSettingsCached settings;
   settings.setValue("view/showAxes", showaxes);
@@ -3048,29 +3286,26 @@ void MainWindow::viewModeShowAxes()
   this->qglview->update();
 }
 
-void MainWindow::viewModeShowCrosshairs()
-{
+void MainWindow::viewModeShowCrosshairs() {
   QSettingsCached settings;
-  settings.setValue("view/showCrosshairs", viewActionShowCrosshairs->isChecked());
+  settings.setValue("view/showCrosshairs",
+                    viewActionShowCrosshairs->isChecked());
   this->qglview->setShowCrosshairs(viewActionShowCrosshairs->isChecked());
   this->qglview->update();
 }
 
-void MainWindow::viewModeShowScaleProportional()
-{
+void MainWindow::viewModeShowScaleProportional() {
   QSettingsCached settings;
-  settings.setValue("view/showScaleProportional", viewActionShowScaleProportional->isChecked());
-  this->qglview->setShowScaleProportional(viewActionShowScaleProportional->isChecked());
+  settings.setValue("view/showScaleProportional",
+                    viewActionShowScaleProportional->isChecked());
+  this->qglview->setShowScaleProportional(
+      viewActionShowScaleProportional->isChecked());
   this->qglview->update();
 }
 
-bool MainWindow::isEmpty()
-{
-  return activeEditor->toPlainText().isEmpty();
-}
+bool MainWindow::isEmpty() { return activeEditor->toPlainText().isEmpty(); }
 
-void MainWindow::editorContentChanged()
-{
+void MainWindow::editorContentChanged() {
   // this slot is called when the content of the active editor changed.
   // it rely on the activeEditor member to pick the new data.
 
@@ -3083,56 +3318,47 @@ void MainWindow::editorContentChanged()
   }
 }
 
-void MainWindow::viewAngleTop()
-{
+void MainWindow::viewAngleTop() {
   qglview->cam.object_rot << 90, 0, 0;
   this->qglview->update();
 }
 
-void MainWindow::viewAngleBottom()
-{
+void MainWindow::viewAngleBottom() {
   qglview->cam.object_rot << 270, 0, 0;
   this->qglview->update();
 }
 
-void MainWindow::viewAngleLeft()
-{
+void MainWindow::viewAngleLeft() {
   qglview->cam.object_rot << 0, 0, 90;
   this->qglview->update();
 }
 
-void MainWindow::viewAngleRight()
-{
+void MainWindow::viewAngleRight() {
   qglview->cam.object_rot << 0, 0, 270;
   this->qglview->update();
 }
 
-void MainWindow::viewAngleFront()
-{
+void MainWindow::viewAngleFront() {
   qglview->cam.object_rot << 0, 0, 0;
   this->qglview->update();
 }
 
-void MainWindow::viewAngleBack()
-{
+void MainWindow::viewAngleBack() {
   qglview->cam.object_rot << 0, 0, 180;
   this->qglview->update();
 }
 
-void MainWindow::viewAngleDiagonal()
-{
+void MainWindow::viewAngleDiagonal() {
   qglview->cam.object_rot << 35, 0, -25;
   this->qglview->update();
 }
 
-void MainWindow::viewCenter()
-{
+void MainWindow::viewCenter() {
   qglview->cam.object_trans << 0, 0, 0;
   this->qglview->update();
 }
 
-void MainWindow::setProjectionType(ProjectionType mode)
-{
+void MainWindow::setProjectionType(ProjectionType mode) {
   bool isOrthogonal = ProjectionType::ORTHOGONAL == mode;
   QSettingsCached settings;
   settings.setValue("view/orthogonalProjection", isOrthogonal);
@@ -3142,37 +3368,32 @@ void MainWindow::setProjectionType(ProjectionType mode)
   qglview->update();
 }
 
-void MainWindow::viewPerspective()
-{
+void MainWindow::viewPerspective() {
   setProjectionType(ProjectionType::PERSPECTIVE);
 }
 
-void MainWindow::viewOrthogonal()
-{
+void MainWindow::viewOrthogonal() {
   setProjectionType(ProjectionType::ORTHOGONAL);
 }
 
-void MainWindow::viewTogglePerspective()
-{
+void MainWindow::viewTogglePerspective() {
   const QSettingsCached settings;
   bool isOrtho = settings.value("view/orthogonalProjection").toBool();
-  setProjectionType(isOrtho?ProjectionType::PERSPECTIVE:ProjectionType::ORTHOGONAL);
+  setProjectionType(isOrtho ? ProjectionType::PERSPECTIVE
+                            : ProjectionType::ORTHOGONAL);
 }
 
-void MainWindow::viewResetView()
-{
+void MainWindow::viewResetView() {
   this->qglview->resetView();
   this->qglview->update();
 }
 
-void MainWindow::viewAll()
-{
+void MainWindow::viewAll() {
   this->qglview->viewAll();
   this->qglview->update();
 }
 
-void MainWindow::hideEditorToolbar()
-{
+void MainWindow::hideEditorToolbar() {
   QSettingsCached settings;
   const bool shouldHide = viewActionHideEditorToolBar->isChecked();
   settings.setValue("view/hideEditorToolbar", shouldHide);
@@ -3184,8 +3405,7 @@ void MainWindow::hideEditorToolbar()
   }
 }
 
-void MainWindow::hide3DViewToolbar()
-{
+void MainWindow::hide3DViewToolbar() {
   QSettingsCached settings;
   const bool shouldHide = viewActionHide3DViewToolBar->isChecked();
   settings.setValue("view/hide3DViewToolbar", shouldHide);
@@ -3197,8 +3417,7 @@ void MainWindow::hide3DViewToolbar()
   }
 }
 
-void MainWindow::showLink(const QString& link)
-{
+void MainWindow::showLink(const QString &link) {
   if (link == "#console") {
     consoleDock->show();
   } else if (link == "#errorlog") {
@@ -3206,9 +3425,8 @@ void MainWindow::showLink(const QString& link)
   }
 }
 
-void MainWindow::onEditorDockVisibilityChanged(bool isVisible)
-{
-  auto e = (ScintillaEditor *) this->activeEditor;
+void MainWindow::onEditorDockVisibilityChanged(bool isVisible) {
+  auto e = (ScintillaEditor *)this->activeEditor;
   if (isVisible) {
     e->qsci->setReadOnly(false);
     e->setupAutoComplete(false);
@@ -3226,8 +3444,7 @@ void MainWindow::onEditorDockVisibilityChanged(bool isVisible)
   updateExportActions();
 }
 
-void MainWindow::onConsoleDockVisibilityChanged(bool isVisible)
-{
+void MainWindow::onConsoleDockVisibilityChanged(bool isVisible) {
   if (isVisible) {
     frameCompileResult->hide();
     consoleDock->raise();
@@ -3235,8 +3452,7 @@ void MainWindow::onConsoleDockVisibilityChanged(bool isVisible)
   }
 }
 
-void MainWindow::onErrorLogDockVisibilityChanged(bool isVisible)
-{
+void MainWindow::onErrorLogDockVisibilityChanged(bool isVisible) {
   if (isVisible) {
     frameCompileResult->hide();
     errorLogDock->raise();
@@ -3244,16 +3460,14 @@ void MainWindow::onErrorLogDockVisibilityChanged(bool isVisible)
   }
 }
 
-void MainWindow::onAnimateDockVisibilityChanged(bool isVisible)
-{
+void MainWindow::onAnimateDockVisibilityChanged(bool isVisible) {
   if (isVisible) {
     animateDock->raise();
     animateWidget->setFocus();
   }
 }
 
-void MainWindow::onFontListDockVisibilityChanged(bool isVisible)
-{
+void MainWindow::onFontListDockVisibilityChanged(bool isVisible) {
   if (isVisible) {
     fontListWidget->update_font_list();
     fontListWidget->setFocus();
@@ -3261,16 +3475,14 @@ void MainWindow::onFontListDockVisibilityChanged(bool isVisible)
   }
 }
 
-void MainWindow::onViewportControlDockVisibilityChanged(bool isVisible)
-{
+void MainWindow::onViewportControlDockVisibilityChanged(bool isVisible) {
   if (isVisible) {
     viewportControlDock->raise();
     viewportControlWidget->setFocus();
   }
 }
 
-void MainWindow::onParametersDockVisibilityChanged(bool isVisible)
-{
+void MainWindow::onParametersDockVisibilityChanged(bool isVisible) {
   if (isVisible) {
     parameterDock->raise();
     activeEditor->parameterWidget->scrollArea->setFocus();
@@ -3280,8 +3492,7 @@ void MainWindow::onParametersDockVisibilityChanged(bool isVisible)
 // Use the sender's to detect if we are moving forward/backward in docks
 // and search for the next dock to "activate" or "emphasize"
 // If no dock can be found, returns the first one.
-Dock *MainWindow::getNextDockFromSender(QObject *sender)
-{
+Dock *MainWindow::getNextDockFromSender(QObject *sender) {
   int direction = 0;
 
   auto *action = qobject_cast<QAction *>(sender);
@@ -3295,64 +3506,64 @@ Dock *MainWindow::getNextDockFromSender(QObject *sender)
   return findVisibleDockToActivate(direction);
 }
 
-void MainWindow::onWindowActionNextPrevHovered()
-{
+void MainWindow::onWindowActionNextPrevHovered() {
   auto dock = getNextDockFromSender(sender());
 
   // This can happens if there is no visible dock at all
-  if (dock == nullptr) return;
+  if (dock == nullptr)
+    return;
 
   // Hover signal is emitted at each mouse move, to avoid excessive
   // load we only raise/emphasize if it is not yet done.
-  if (rubberBandManager.isEmphasized(dock)) return;
+  if (rubberBandManager.isEmphasized(dock))
+    return;
 
   dock->raise();
   rubberBandManager.emphasize(dock);
 }
 
-void MainWindow::onWindowActionNextPrevTriggered()
-{
+void MainWindow::onWindowActionNextPrevTriggered() {
   auto dock = getNextDockFromSender(sender());
 
   // This can happens if there is no visible dock at all
-  if (dock == nullptr) return;
+  if (dock == nullptr)
+    return;
 
   activateDock(dock);
 }
 
-void MainWindow::onWindowShortcutNextPrevActivated()
-{
+void MainWindow::onWindowShortcutNextPrevActivated() {
   auto dock = getNextDockFromSender(sender());
 
   // This can happens if there is no visible dock at all
-  if (dock == nullptr) return;
+  if (dock == nullptr)
+    return;
 
   activateDock(dock);
   rubberBandManager.emphasize(dock);
 }
 
-void MainWindow::on_editActionInsertTemplate_triggered()
-{
+void MainWindow::on_editActionInsertTemplate_triggered() {
   activeEditor->displayTemplates();
 }
 
-void MainWindow::on_editActionFoldAll_triggered()
-{
+void MainWindow::on_editActionFoldAll_triggered() {
   activeEditor->foldUnfold();
 }
 
-QString MainWindow::getCurrentFileName() const
-{
-  if (activeEditor == nullptr) return {};
+QString MainWindow::getCurrentFileName() const {
+  if (activeEditor == nullptr)
+    return {};
 
   const QFileInfo fileInfo(activeEditor->filepath);
   QString fname = _("Untitled.scad");
-  if (!fileInfo.fileName().isEmpty()) fname = fileInfo.fileName();
+  if (!fileInfo.fileName().isEmpty())
+    fname = fileInfo.fileName();
   return fname.replace("&", "&&");
 }
 
-void MainWindow::onTabManagerAboutToCloseEditor(EditorInterface *closingEditor)
-{
+void MainWindow::onTabManagerAboutToCloseEditor(
+    EditorInterface *closingEditor) {
   // This slots is in charge of closing properly the preview when the
   // associated editor is about to close.
   if (closingEditor == renderedEditor) {
@@ -3360,9 +3571,9 @@ void MainWindow::onTabManagerAboutToCloseEditor(EditorInterface *closingEditor)
 
     // Invalidate renderers before we kill the CSG tree
     this->qglview->setRenderer(nullptr);
-       #ifdef ENABLE_OPENCSG
+#ifdef ENABLE_OPENCSG
     this->previewRenderer = nullptr;
-       #endif
+#endif
     this->thrownTogetherRenderer = nullptr;
 
     // Remove previous CSG tree
@@ -3378,31 +3589,31 @@ void MainWindow::onTabManagerAboutToCloseEditor(EditorInterface *closingEditor)
   }
 }
 
-void MainWindow::onTabManagerEditorContentReloaded(EditorInterface *reloadedEditor)
-{
+void MainWindow::onTabManagerEditorContentReloaded(
+    EditorInterface *reloadedEditor) {
   try {
-    // when a new editor is created, it is important to compile the initial geometry
-    // so the customizer panels are ok.
+    // when a new editor is created, it is important to compile the initial
+    // geometry so the customizer panels are ok.
     parseDocument(reloadedEditor);
-  } catch (const HardWarningException&) {
+  } catch (const HardWarningException &) {
     exceptionCleanup();
-  } catch (const std::exception& ex) {
+  } catch (const std::exception &ex) {
     UnknownExceptionCleanup(ex.what());
   } catch (...) {
     UnknownExceptionCleanup();
   }
 
   // updates the content of the Recents Files menu to integrate the one possibly
-  // associated with the created editor. The reason is that an editor can be created
-  // or updated without a file associated with it.
+  // associated with the created editor. The reason is that an editor can be
+  // created or updated without a file associated with it.
   updateRecentFileActions();
 }
 
-void MainWindow::onTabManagerEditorChanged(EditorInterface *newEditor)
-{
+void MainWindow::onTabManagerEditorChanged(EditorInterface *newEditor) {
   activeEditor = newEditor;
 
-  if (newEditor == nullptr) return;
+  if (newEditor == nullptr)
+    return;
 
   parameterDock->setWidget(newEditor->parameterWidget);
   editActionUndo->setEnabled(newEditor->canUndo());
@@ -3422,17 +3633,17 @@ void MainWindow::onTabManagerEditorChanged(EditorInterface *newEditor)
   }
 }
 
-Dock *MainWindow::findVisibleDockToActivate(int offset) const
-{
+Dock *MainWindow::findVisibleDockToActivate(int offset) const {
   const unsigned int dockCount = docks.size();
 
   int focusedDockIndice = -1;
 
   // search among the docks the one that is having the focus. This is done by
-  // traversing the widget hierarchy from the focused widget up to the docks that
-  // contains it.
+  // traversing the widget hierarchy from the focused widget up to the docks
+  // that contains it.
   const auto focusWidget = QApplication::focusWidget();
-  for (auto widget = focusWidget; widget != nullptr; widget = widget->parentWidget()) {
+  for (auto widget = focusWidget; widget != nullptr;
+       widget = widget->parentWidget()) {
     for (unsigned int index = 0; index < dockCount; ++index) {
       auto dock = std::get<0>(docks[index]);
       if (dock == focusWidget) {
@@ -3447,10 +3658,11 @@ Dock *MainWindow::findVisibleDockToActivate(int offset) const
 
   for (int o = 1; o < dockCount; ++o) {
     // starting from dockCount + focusedDockIndice move left or right (o*offset)
-    // to find the first visible one. dockCount is there so there is no situation in which
+    // to find the first visible one. dockCount is there so there is no
+    // situation in which
     // (-1) % dockCount
     const int target = (dockCount + focusedDockIndice + o * offset) % dockCount;
-    const auto& dock = std::get<0>(docks.at(target));
+    const auto &dock = std::get<0>(docks.at(target));
 
     if (dock->isVisible()) {
       return dock;
@@ -3459,38 +3671,38 @@ Dock *MainWindow::findVisibleDockToActivate(int offset) const
   return nullptr;
 }
 
-void MainWindow::activateDock(Dock *dock)
-{
-  if (dock == nullptr) return;
+void MainWindow::activateDock(Dock *dock) {
+  if (dock == nullptr)
+    return;
 
   // We always need to activate the window.
-  if (dock->isFloating()) dock->activateWindow();
-  else QMainWindow::activateWindow();
+  if (dock->isFloating())
+    dock->activateWindow();
+  else
+    QMainWindow::activateWindow();
 
   dock->raise();
   dock->setFocus();
 }
 
-void MainWindow::dragEnterEvent(QDragEnterEvent *event)
-{
+void MainWindow::dragEnterEvent(QDragEnterEvent *event) {
   if (event->mimeData()->hasUrls()) {
     event->acceptProposedAction();
   }
 }
 
-void MainWindow::dropEvent(QDropEvent *event)
-{
+void MainWindow::dropEvent(QDropEvent *event) {
   setCurrentOutput();
   const QList<QUrl> urls = event->mimeData()->urls();
-  for (const auto& url : urls) {
+  for (const auto &url : urls) {
     handleFileDrop(url);
   }
   clearCurrentOutput();
 }
 
-void MainWindow::handleFileDrop(const QUrl& url)
-{
-  if (url.scheme() != "file") return;
+void MainWindow::handleFileDrop(const QUrl &url) {
+  if (url.scheme() != "file")
+    return;
   const auto fileName = url.toLocalFile();
   const auto fileInfo = QFileInfo{fileName};
   const auto suffix = fileInfo.suffix().toLower();
@@ -3502,41 +3714,24 @@ void MainWindow::handleFileDrop(const QUrl& url)
   }
 }
 
-void MainWindow::helpAbout()
-{
+void MainWindow::helpAbout() {
   qApp->setWindowIcon(QApplication::windowIcon());
   auto dialog = new AboutDialog(this);
   dialog->exec();
   dialog->deleteLater();
 }
 
-void MainWindow::helpHomepage()
-{
-  UIUtils::openHomepageURL();
-}
+void MainWindow::helpHomepage() { UIUtils::openHomepageURL(); }
 
-void MainWindow::helpManual()
-{
-  UIUtils::openUserManualURL();
-}
+void MainWindow::helpManual() { UIUtils::openUserManualURL(); }
 
-void MainWindow::helpOfflineManual()
-{
-  UIUtils::openOfflineUserManual();
-}
+void MainWindow::helpOfflineManual() { UIUtils::openOfflineUserManual(); }
 
-void MainWindow::helpCheatSheet()
-{
-  UIUtils::openCheatSheetURL();
-}
+void MainWindow::helpCheatSheet() { UIUtils::openCheatSheetURL(); }
 
-void MainWindow::helpOfflineCheatSheet()
-{
-  UIUtils::openOfflineCheatSheet();
-}
+void MainWindow::helpOfflineCheatSheet() { UIUtils::openOfflineCheatSheet(); }
 
-void MainWindow::helpLibrary()
-{
+void MainWindow::helpLibrary() {
   if (!this->libraryInfoDialog) {
     const QString rendererInfo(qglview->getRendererInfo().c_str());
     auto dialog = new LibraryInfoDialog(rendererInfo);
@@ -3545,8 +3740,7 @@ void MainWindow::helpLibrary()
   this->libraryInfoDialog->show();
 }
 
-void MainWindow::helpFontInfo()
-{
+void MainWindow::helpFontInfo() {
   if (!this->fontListDialog) {
     auto dialog = new FontListDialog();
     this->fontListDialog = dialog;
@@ -3555,8 +3749,7 @@ void MainWindow::helpFontInfo()
   this->fontListDialog->show();
 }
 
-void MainWindow::closeEvent(QCloseEvent *event)
-{
+void MainWindow::closeEvent(QCloseEvent *event) {
   if (tabManager->shouldClose()) {
     isClosing = true;
     progress_report_fin();
@@ -3580,103 +3773,103 @@ void MainWindow::closeEvent(QCloseEvent *event)
   }
 }
 
-void MainWindow::preferences()
-{
+void MainWindow::preferences() {
   GlobalPreferences::inst()->update();
   GlobalPreferences::inst()->show();
   GlobalPreferences::inst()->activateWindow();
   GlobalPreferences::inst()->raise();
 }
 
-void MainWindow::setColorScheme(const QString& scheme)
-{
+void MainWindow::setColorScheme(const QString &scheme) {
   RenderSettings::inst()->colorscheme = scheme.toStdString();
   this->qglview->setColorScheme(scheme.toStdString());
   this->qglview->update();
 }
 
-void MainWindow::setFont(const QString& family, uint size)
-{
+void MainWindow::setFont(const QString &family, uint size) {
   QFont font;
-  if (!family.isEmpty()) font.setFamily(family);
-  else font.setFixedPitch(true);
-  if (size > 0) font.setPointSize(size);
+  if (!family.isEmpty())
+    font.setFamily(family);
+  else
+    font.setFixedPitch(true);
+  if (size > 0)
+    font.setPointSize(size);
   font.setStyleHint(QFont::TypeWriter);
   activeEditor->setFont(font);
 }
 
-void MainWindow::consoleOutput(const Message& msgObj, void *userdata)
-{
+void MainWindow::consoleOutput(const Message &msgObj, void *userdata) {
   // Invoke the method in the main thread in case the output
   // originates in a worker thread.
   auto thisp = static_cast<MainWindow *>(userdata);
   QMetaObject::invokeMethod(thisp, "consoleOutput", Q_ARG(Message, msgObj));
 }
 
-void MainWindow::consoleOutput(const Message& msgObj)
-{
+void MainWindow::consoleOutput(const Message &msgObj) {
   this->console->addMessage(msgObj);
-  if (msgObj.group == message_group::Warning || msgObj.group == message_group::Deprecated) {
+  if (msgObj.group == message_group::Warning ||
+      msgObj.group == message_group::Deprecated) {
     ++this->compileWarnings;
   } else if (msgObj.group == message_group::Error) {
     ++this->compileErrors;
   }
-  // FIXME: scad parsing/evaluation should be done on separate thread so as not to block the gui.
-  // Then processEvents should no longer be needed here.
+  // FIXME: scad parsing/evaluation should be done on separate thread so as not
+  // to block the gui. Then processEvents should no longer be needed here.
   this->processEvents();
   if (consoleUpdater && !consoleUpdater->isActive()) {
-    consoleUpdater->start(50);     // Limit console updates to 20 FPS
+    consoleUpdater->start(50); // Limit console updates to 20 FPS
   }
 }
 
-void MainWindow::consoleOutputRaw(const QString& html)
-{
+void MainWindow::consoleOutputRaw(const QString &html) {
   this->console->addHtml(html);
   this->processEvents();
 }
 
-void MainWindow::errorLogOutput(const Message& log_msg, void *userdata)
-{
+void MainWindow::errorLogOutput(const Message &log_msg, void *userdata) {
   auto thisp = static_cast<MainWindow *>(userdata);
   QMetaObject::invokeMethod(thisp, "errorLogOutput", Q_ARG(Message, log_msg));
 }
 
-void MainWindow::errorLogOutput(const Message& log_msg)
-{
+void MainWindow::errorLogOutput(const Message &log_msg) {
   this->errorLogWidget->toErrorLog(log_msg);
 }
 
-void MainWindow::setCurrentOutput()
-{
-  set_output_handler(&MainWindow::consoleOutput, &MainWindow::errorLogOutput, this);
+void MainWindow::setCurrentOutput() {
+  set_output_handler(&MainWindow::consoleOutput, &MainWindow::errorLogOutput,
+                     this);
 }
 
-void MainWindow::hideCurrentOutput()
-{
-  set_output_handler(&MainWindow::noOutputConsole, &MainWindow::noOutputErrorLog, this);
+void MainWindow::hideCurrentOutput() {
+  set_output_handler(&MainWindow::noOutputConsole,
+                     &MainWindow::noOutputErrorLog, this);
 }
 
-void MainWindow::clearCurrentOutput()
-{
+void MainWindow::clearCurrentOutput() {
   set_output_handler(nullptr, nullptr, nullptr);
 }
 
-void MainWindow::openCSGSettingsChanged()
-{
+void MainWindow::openCSGSettingsChanged() {
 #ifdef ENABLE_OPENCSG
-  OpenCSG::setOption(OpenCSG::AlgorithmSetting, GlobalPreferences::inst()->getValue("advanced/forceGoldfeather").toBool() ?
-                     OpenCSG::Goldfeather : OpenCSG::Automatic);
+  OpenCSG::setOption(
+      OpenCSG::AlgorithmSetting,
+      GlobalPreferences::inst()->getValue("advanced/forceGoldfeather").toBool()
+          ? OpenCSG::Goldfeather
+          : OpenCSG::Automatic);
 #endif
 }
 
-void MainWindow::processEvents()
-{
-  if (this->procevents) QApplication::processEvents();
+void MainWindow::processEvents() {
+  if (this->procevents)
+    QApplication::processEvents();
 }
 
-QString MainWindow::exportPath(const QString& suffix) {
+QString MainWindow::exportPath(const QString &suffix) {
   const auto path_it = this->exportPaths.find(suffix);
-  const auto basename = activeEditor->filepath.isEmpty() ? "Untitled" : QFileInfo(activeEditor->filepath).completeBaseName();
+  const auto basename =
+      activeEditor->filepath.isEmpty()
+          ? "Untitled"
+          : QFileInfo(activeEditor->filepath).completeBaseName();
   QString dir;
   if (path_it != exportPaths.end()) {
     dir = QFileInfo(path_it->second).absolutePath();
@@ -3688,7 +3881,6 @@ QString MainWindow::exportPath(const QString& suffix) {
   return QString("%1/%2.%3").arg(dir, basename, suffix);
 }
 
-void MainWindow::jumpToLine(int line, int col)
-{
+void MainWindow::jumpToLine(int line, int col) {
   this->activeEditor->setCursorPosition(line, col);
 }
diff --git a/src/gui/MainWindow.h b/src/gui/MainWindow.h
index 5f46b993c..b5aebf8a9 100644
--- a/src/gui/MainWindow.h
+++ b/src/gui/MainWindow.h
@@ -1,41 +1,41 @@
 #pragma once
 
 #include <ctime>
-#include <tuple>
-#include <unordered_map>
 #include <memory>
 #include <string>
+#include <tuple>
+#include <unordered_map>
 #include <vector>
 
+#include "core/Context.h"
+#include "core/SourceFile.h"
+#include "glview/Renderer.h"
 #include <QAction>
 #include <QCloseEvent>
 #include <QDragEnterEvent>
 #include <QDropEvent>
+#include <QElapsedTimer>
 #include <QEvent>
 #include <QFile>
+#include <QIODevice>
+#include <QIcon>
 #include <QLabel>
 #include <QList>
+#include <QMainWindow>
 #include <QMap>
+#include <QMutex>
 #include <QObject>
 #include <QPoint>
+#include <QShortcut>
+#include <QSignalMapper>
+#include <QSoundEffect>
 #include <QString>
 #include <QStringList>
 #include <QTemporaryFile>
+#include <QTime>
 #include <QTimer>
 #include <QUrl>
 #include <QWidget>
-#include <QMainWindow>
-#include <QElapsedTimer>
-#include <QIcon>
-#include <QIODevice>
-#include <QMutex>
-#include <QSoundEffect>
-#include <QTime>
-#include <QSignalMapper>
-#include <QShortcut>
-#include "core/Context.h"
-#include "glview/Renderer.h"
-#include "core/SourceFile.h"
 #ifdef STATIC_QT_SVG_PLUGIN
 #include <QtPlugin>
 Q_IMPORT_PLUGIN(QSvgPlugin)
@@ -51,26 +51,26 @@ class Preferences;
 class ProgressWidget;
 class ThrownTogetherRenderer;
 
+#include "RenderStatistic.h"
 #include "core/Tree.h"
 #include "geometry/Geometry.h"
 #include "gui/Editor.h"
-#include "gui/input/InputDriverEvent.h"
 #include "gui/Measurement.h"
-#include "gui/qt-obsolete.h" // IWYU pragma: keep
-#include "gui/qtgettext.h" // IWYU pragma: keep
 #include "gui/RubberBandManager.h"
 #include "gui/TabManager.h"
 #include "gui/UIUtils.h"
-#include "io/export_enums.h"
-#include "io/export.h"
+#include "gui/input/InputDriverEvent.h"
+#include "gui/qt-obsolete.h" // IWYU pragma: keep
+#include "gui/qtgettext.h"   // IWYU pragma: keep
 #include "io/export.h"
-#include "RenderStatistic.h"
+#include "io/export_enums.h"
 #include "ui_MainWindow.h"
 #include "utils/printutils.h"
 
 class UXTest;
-class MainWindow : public QMainWindow, public Ui::MainWindow, public InputEventHandler
-{
+class MainWindow : public QMainWindow,
+                   public Ui::MainWindow,
+                   public InputEventHandler {
   Q_OBJECT
 
   friend UXTest;
@@ -86,15 +86,16 @@ public:
   QTimer *waitAfterReloadTimer;
   RenderStatistic renderStatistic;
 
-  SourceFile *rootFile; // Result of parsing
-  SourceFile *parsedFile; // Last parse for include list
+  SourceFile *rootFile;                           // Result of parsing
+  SourceFile *parsedFile;                         // Last parse for include list
   std::shared_ptr<AbstractNode> absoluteRootNode; // Result of tree evaluation
-  std::shared_ptr<AbstractNode> rootNode; // Root if the root modifier (!) is used
+  std::shared_ptr<AbstractNode>
+      rootNode; // Root if the root modifier (!) is used
 #ifdef ENABLE_PYTHON
   bool python_active;
   std::string trusted_edit_document_name;
   std::string untrusted_edit_document_name;
-  bool trust_python_file(const std::string& file, const std::string& content);
+  bool trust_python_file(const std::string &file, const std::string &content);
 #endif
   Tree tree;
   EditorInterface *activeEditor;
@@ -120,7 +121,7 @@ public:
   int compileErrors;
   int compileWarnings;
 
-  MainWindow(const QStringList& filenames);
+  MainWindow(const QStringList &filenames);
   ~MainWindow() override;
 
 private:
@@ -129,9 +130,10 @@ private:
   std::vector<std::tuple<Dock *, QString>> docks;
 
   volatile bool isClosing = false;
-  void consoleOutputRaw(const QString& msg);
+  void consoleOutputRaw(const QString &msg);
   void clearAllSelectionIndicators();
-  void setSelectionIndicatorStatus(EditorInterface *editor, int nodeIndex, EditorSelectionIndicatorStatus status);
+  void setSelectionIndicatorStatus(EditorInterface *editor, int nodeIndex,
+                                   EditorSelectionIndicatorStatus status);
 
 protected:
   void closeEvent(QCloseEvent *event) override;
@@ -139,19 +141,20 @@ protected:
 private slots:
   void updateUndockMode(bool undockMode);
   void updateReorderMode(bool reorderMode);
-  void setFont(const QString& family, uint size);
-  void setColorScheme(const QString& cs);
+  void setFont(const QString &family, uint size);
+  void setColorScheme(const QString &cs);
   void showProgress();
   void openCSGSettingsChanged();
-  void consoleOutput(const Message& msgObj);
+  void consoleOutput(const Message &msgObj);
   void setSelection(int index);
 
   // implements the actions to be done when the selection menu is closing
-  // the seclection menu is the one that show up when right click on the geometry in the 3d view.
+  // the seclection menu is the one that show up when right click on the
+  // geometry in the 3d view.
   void onHoveredObjectInSelectionMenu();
 
   void measureFinished();
-  void errorLogOutput(const Message& log_msg);
+  void errorLogOutput(const Message &log_msg);
   void onNavigationOpenContextMenu();
   void onNavigationCloseContextMenu();
   void onNavigationHoveredContextMenuEntry();
@@ -170,15 +173,15 @@ private slots:
   void onTabManagerEditorContentReloaded(EditorInterface *reloadedEditor);
 
 public:
-  static void consoleOutput(const Message& msgObj, void *userdata);
-  static void errorLogOutput(const Message& log_msg, void *userdata);
-  static void noOutputConsole(const Message&, void *) {} // /dev/null
-  static void noOutputErrorLog(const Message&, void *) {} // /dev/null
+  static void consoleOutput(const Message &msgObj, void *userdata);
+  static void errorLogOutput(const Message &log_msg, void *userdata);
+  static void noOutputConsole(const Message &, void *) {}  // /dev/null
+  static void noOutputErrorLog(const Message &, void *) {} // /dev/null
 
   bool fileChangedOnDisk();
 
-  // Parse the document contained in the editor, update the editors's parameters and returns a SourceFile object
-  // if parsing suceeded. Nullptr otherwise.
+  // Parse the document contained in the editor, update the editors's parameters
+  // and returns a SourceFile object if parsing suceeded. Nullptr otherwise.
   SourceFile *parseDocument(EditorInterface *editor);
 
   void parseTopLevelDocument();
@@ -190,16 +193,17 @@ public:
 private:
   [[nodiscard]] QString getCurrentFileName() const;
 
-  void setRenderVariables(ContextHandle<BuiltinContext>& context);
+  void setRenderVariables(ContextHandle<BuiltinContext> &context);
   void updateCompileResult();
   void compile(bool reload, bool forcedone = false);
   void compileCSG();
   bool checkEditorModified();
-  QString dumpCSGTree(const std::shared_ptr<AbstractNode>& root);
+  QString dumpCSGTree(const std::shared_ptr<AbstractNode> &root);
 
-  // Opens an independent windows with a text area showing the text given in argument
-  // The "type" is used to specify the type of content with the title of the window,
-  void showTextInWindow(const QString& type, const QString& textToShow);
+  // Opens an independent windows with a text area showing the text given in
+  // argument The "type" is used to specify the type of content with the title
+  // of the window,
+  void showTextInWindow(const QString &type, const QString &textToShow);
 
   // Change the perspective mode of the 3D view.
   typedef Camera::ProjectionType ProjectionType;
@@ -207,12 +211,16 @@ private:
 
   void loadViewSettings();
   void loadDesignSettings();
-  void prepareCompile(const char *afterCompileSlot, bool procevents, bool preview);
-  void updateWindowSettings(bool console, bool editor, bool customizer, bool errorLog, bool editorToolbar, bool viewToolbar, bool animate, bool fontList, bool ViewportControlWidget);
+  void prepareCompile(const char *afterCompileSlot, bool procevents,
+                      bool preview);
+  void updateWindowSettings(bool console, bool editor, bool customizer,
+                            bool errorLog, bool editorToolbar, bool viewToolbar,
+                            bool animate, bool fontList,
+                            bool ViewportControlWidget);
   void saveBackup();
   void writeBackup(QFile *file);
   void show_examples();
-  void addKeyboardShortCut(const QList<QAction *>& actions);
+  void addKeyboardShortCut(const QList<QAction *> &actions);
   void updateStatusBar(ProgressWidget *progressWidget);
   void activateDock(Dock *);
   Dock *findVisibleDockToActivate(int offset) const;
@@ -224,9 +232,9 @@ private:
 
 public slots:
   void updateExportActions();
-  void updateRecentFiles(const QString& FileSavedOrOpened);
+  void updateRecentFiles(const QString &FileSavedOrOpened);
   void updateRecentFileActions();
-  void handleFileDrop(const QUrl& url);
+  void handleFileDrop(const QUrl &url);
 
 private slots:
   void actionOpen();
@@ -259,13 +267,14 @@ private slots:
   void preferences();
   void hideEditorToolbar();
   void hide3DViewToolbar();
-  void showLink(const QString&);
+  void showLink(const QString &);
 
-  // Handle the Next/Prev dock menu action when the is hovered, currently this activate the rubberband
+  // Handle the Next/Prev dock menu action when the is hovered, currently this
+  // activate the rubberband
   void onWindowActionNextPrevHovered();
 
-  // Handle the Next/Prev dock menu action when the is validatee, currently switch to the targetted dock
-  // and remove the rubberband
+  // Handle the Next/Prev dock menu action when the is validatee, currently
+  // switch to the targetted dock and remove the rubberband
   void onWindowActionNextPrevTriggered();
 
   // Handle the Next/Prev shortcut, currently switch to the targetted dock
@@ -290,7 +299,7 @@ public slots:
 
 private slots:
   void actionSelectFind(int);
-  void findString(const QString&);
+  void findString(const QString &);
   void findNext();
   void findPrev();
   void useSelectionForFind();
@@ -299,8 +308,9 @@ private slots:
 
   // Mac OSX FindBuffer support
   void findBufferChanged();
-  void updateFindBuffer(const QString&);
+  void updateFindBuffer(const QString &);
   bool event(QEvent *event) override;
+
 protected:
   bool eventFilter(QObject *obj, QEvent *event) override;
 
@@ -312,7 +322,7 @@ private slots:
   void action3DPrint();
   void sendToExternalTool(class ExternalToolInterface &externalToolService);
   void actionRender();
-  void actionRenderDone(const std::shared_ptr<const Geometry>&);
+  void actionRenderDone(const std::shared_ptr<const Geometry> &);
   void cgalRender();
   void actionMeasureDistance();
   void actionMeasureAngle();
@@ -321,7 +331,7 @@ private slots:
   void actionDisplayCSGTree();
   void actionDisplayCSGProducts();
   bool canExport(unsigned int dim);
-  void actionExport(unsigned int dim, ExportInfo& exportInfo);
+  void actionExport(unsigned int dim, ExportInfo &exportInfo);
   void actionExportFileFormat(int fmt);
   void actionCopyViewport();
   void actionFlushCaches();
@@ -351,7 +361,7 @@ public slots:
   void on_toolButtonCompileResultClose_clicked();
   void processEvents();
   void jumpToLine(int, int);
-  void openFileFromPath(const QString&, int);
+  void openFileFromPath(const QString &, int);
 
   void viewModeRender();
 #ifdef ENABLE_OPENCSG
@@ -394,19 +404,21 @@ public slots:
 
 private:
   bool network_progress_func(const double permille);
-  static void report_func(const std::shared_ptr<const AbstractNode>&, void *vp, int mark);
+  static void report_func(const std::shared_ptr<const AbstractNode> &, void *vp,
+                          int mark);
   static bool undockMode;
   static bool reorderMode;
   static const int tabStopWidth;
   static QElapsedTimer *progressThrottle;
-  QWidget *lastFocus; // keep track of active copyable widget (Editor|Console) for global menu action Edit->Copy
+  QWidget *lastFocus; // keep track of active copyable widget (Editor|Console)
+                      // for global menu action Edit->Copy
 
-  std::shared_ptr<CSGNode> csgRoot; // Result of the CSGTreeEvaluator
+  std::shared_ptr<CSGNode> csgRoot;        // Result of the CSGTreeEvaluator
   std::shared_ptr<CSGNode> normalizedRoot; // Normalized CSG tree
   std::shared_ptr<CSGProducts> rootProduct;
   std::shared_ptr<CSGProducts> highlightsProducts;
   std::shared_ptr<CSGProducts> backgroundProducts;
-  int currentlySelectedObject {-1};
+  int currentlySelectedObject{-1};
 
   char const *afterCompileSlot;
   bool procevents{false};
@@ -414,15 +426,18 @@ private:
   ProgressWidget *progresswidget{nullptr};
   CGALWorker *cgalworker;
   QMutex consolemutex;
-  EditorInterface *renderedEditor; // stores pointer to editor which has been most recently rendered
-  time_t includesMTime{0}; // latest include mod time
-  time_t depsMTime{0}; // latest dependency mod time
-  std::unordered_map<QString, QString> exportPaths; // for each file type, where it was exported to last
-  QString exportPath(const QString& suffix); // look up the last export path and generate one if not found
-  int lastParserErrorPos{-1}; // last highlighted error position
+  EditorInterface *renderedEditor; // stores pointer to editor which has been
+                                   // most recently rendered
+  time_t includesMTime{0};         // latest include mod time
+  time_t depsMTime{0};             // latest dependency mod time
+  std::unordered_map<QString, QString>
+      exportPaths; // for each file type, where it was exported to last
+  QString exportPath(const QString &suffix); // look up the last export path and
+                                             // generate one if not found
+  int lastParserErrorPos{-1};                // last highlighted error position
   int tabCount = 0;
-  ExportPdfPaperSize sizeString2Enum(const QString& current);
-  ExportPdfPaperOrientation orientationsString2Enum(const QString& current);
+  ExportPdfPaperSize sizeString2Enum(const QString &current);
+  ExportPdfPaperOrientation orientationsString2Enum(const QString &current);
 
   QMenu *navigationMenu{nullptr};
   QSoundEffect *renderCompleteSoundEffect;
@@ -436,29 +451,20 @@ signals:
 public:
   std::shared_ptr<AbstractNode> instantiateRootFromSource(SourceFile *file);
 signals:
-  // This is a new signal introduced while drafting the testing framework, while in experimental mode
-  // we protected it using the #ifdef/endif so it should not be considered as part of the MainWindow API.
+  // This is a new signal introduced while drafting the testing framework, while
+  // in experimental mode we protected it using the #ifdef/endif so it should
+  // not be considered as part of the MainWindow API.
   void compilationDone(SourceFile *);
 #endif //
-
 };
 
-class GuiLocker
-{
+class GuiLocker {
 public:
-  GuiLocker() {
-    GuiLocker::lock();
-  }
-  ~GuiLocker() {
-    GuiLocker::unlock();
-  }
+  GuiLocker() { GuiLocker::lock(); }
+  ~GuiLocker() { GuiLocker::unlock(); }
   static bool isLocked() { return guiLocked > 0; }
-  static void lock() {
-    guiLocked++;
-  }
-  static void unlock() {
-    guiLocked--;
-  }
+  static void lock() { guiLocked++; }
+  static void unlock() { guiLocked--; }
 
 private:
   static unsigned int guiLocked;
diff --git a/src/gui/Measurement.cc b/src/gui/Measurement.cc
index 579e51478..9555126cb 100644
--- a/src/gui/Measurement.cc
+++ b/src/gui/Measurement.cc
@@ -24,65 +24,69 @@
  *
  */
 
-#include "geometry/linalg.h"
 #include "gui/Measurement.h"
+#include "geometry/linalg.h"
 
 #include <QPoint>
 #include <QString>
 #include <cmath>
 #include <sstream>
 
-Measurement::Measurement()
-{
-}
+Measurement::Measurement() {}
 
 void Measurement::setView(QGLView *qglview) {
   this->qglview = qglview;
   this->qglview->measure_state = MEASURE_IDLE;
 }
 
-void Measurement::startMeasureDist(void)
-{
+void Measurement::startMeasureDist(void) {
   this->qglview->selected_obj.clear();
   this->qglview->update();
   this->qglview->measure_state = MEASURE_DIST1;
 }
 
-void Measurement::startMeasureAngle(void)
-{
+void Measurement::startMeasureAngle(void) {
   this->qglview->selected_obj.clear();
   this->qglview->update();
   this->qglview->measure_state = MEASURE_ANG1;
 }
 
-void Measurement::stopMeasure()
-{
+void Measurement::stopMeasure() {
   qglview->selected_obj.clear();
   qglview->shown_obj.clear();
   qglview->update();
   qglview->measure_state = MEASURE_IDLE;
 }
 
-QString Measurement::statemachine(QPoint mouse)
-{
-  if (qglview->measure_state == MEASURE_IDLE)return "";
+QString Measurement::statemachine(QPoint mouse) {
+  if (qglview->measure_state == MEASURE_IDLE)
+    return "";
   qglview->selectPoint(mouse.x(), mouse.y());
   double ang = NAN;
   double dist = NAN;
   SelectedObject obj1, obj2, obj3;
   switch (qglview->measure_state) {
   case MEASURE_DIST1:
-    if (qglview->selected_obj.size() == 1) qglview->measure_state = MEASURE_DIST2;
+    if (qglview->selected_obj.size() == 1)
+      qglview->measure_state = MEASURE_DIST2;
     break;
   case MEASURE_DIST2:
-    if (qglview->selected_obj.size() == 2){
+    if (qglview->selected_obj.size() == 2) {
       double lat;
       obj1 = qglview->selected_obj[0];
       obj2 = qglview->selected_obj[1];
-      if (obj1.type == SelectionType::SELECTION_POINT && obj2.type == SelectionType::SELECTION_POINT) dist = (obj2.p1 - obj1.p1).norm();
-      if (obj1.type == SelectionType::SELECTION_POINT && obj2.type == SelectionType::SELECTION_LINE) dist = calculateLinePointDistance(obj2.p1, obj2.p2, obj1.p1, lat);
-      if (obj1.type == SelectionType::SELECTION_LINE && obj2.type == SelectionType::SELECTION_POINT) dist = calculateLinePointDistance(obj1.p1, obj1.p2, obj2.p1, lat);
-      if (obj1.type == SelectionType::SELECTION_LINE && obj2.type == SelectionType::SELECTION_LINE) dist = calculateSegSegDistance(obj1.p1, obj1.p2, obj2.p1, obj2.p2, lat);
+      if (obj1.type == SelectionType::SELECTION_POINT &&
+          obj2.type == SelectionType::SELECTION_POINT)
+        dist = (obj2.p1 - obj1.p1).norm();
+      if (obj1.type == SelectionType::SELECTION_POINT &&
+          obj2.type == SelectionType::SELECTION_LINE)
+        dist = calculateLinePointDistance(obj2.p1, obj2.p2, obj1.p1, lat);
+      if (obj1.type == SelectionType::SELECTION_LINE &&
+          obj2.type == SelectionType::SELECTION_POINT)
+        dist = calculateLinePointDistance(obj1.p1, obj1.p2, obj2.p1, lat);
+      if (obj1.type == SelectionType::SELECTION_LINE &&
+          obj2.type == SelectionType::SELECTION_LINE)
+        dist = calculateSegSegDistance(obj1.p1, obj1.p2, obj2.p1, obj2.p2, lat);
       if (!std::isnan(dist)) {
         return QString("Distance is %1").arg(fabs(dist));
       }
@@ -90,34 +94,42 @@ QString Measurement::statemachine(QPoint mouse)
     }
     break;
   case MEASURE_ANG1:
-    if (qglview->selected_obj.size() == 1) qglview->measure_state = MEASURE_ANG2;
+    if (qglview->selected_obj.size() == 1)
+      qglview->measure_state = MEASURE_ANG2;
     break;
   case MEASURE_ANG2:
-    if (qglview->selected_obj.size() == 2){
+    if (qglview->selected_obj.size() == 2) {
       obj1 = qglview->selected_obj[0];
       obj2 = qglview->selected_obj[1];
       Vector3d side1, side2;
-      if (obj1.type == SelectionType::SELECTION_LINE && obj2.type == SelectionType::SELECTION_POINT){
+      if (obj1.type == SelectionType::SELECTION_LINE &&
+          obj2.type == SelectionType::SELECTION_POINT) {
         side1 = (obj1.p2 - obj1.p1).normalized();
         side2 = (obj1.p2 - obj2.p1).normalized();
         ang = acos(side1.dot(side2)) * 180.0 / 3.14159265359;
         goto display_angle;
-      } else if (obj1.type == SelectionType::SELECTION_POINT && obj2.type == SelectionType::SELECTION_LINE) {
+      } else if (obj1.type == SelectionType::SELECTION_POINT &&
+                 obj2.type == SelectionType::SELECTION_LINE) {
         side1 = (obj2.p2 - obj2.p1).normalized();
         side2 = (obj2.p2 - obj1.p1).normalized();
         ang = acos(side1.dot(side2)) * 180.0 / 3.14159265359;
         goto display_angle;
-      } else if (obj1.type == SelectionType::SELECTION_LINE && obj2.type == SelectionType::SELECTION_LINE) {
-        // Check all 4 permutations of the lines' directions and use the one where the starting points are closest to one another as the corner point for the angle
+      } else if (obj1.type == SelectionType::SELECTION_LINE &&
+                 obj2.type == SelectionType::SELECTION_LINE) {
+        // Check all 4 permutations of the lines' directions and use the one
+        // where the starting points are closest to one another as the corner
+        // point for the angle
         double nearestDist = INFINITY;
-        auto permutation = [&nearestDist, &side1, &side2](const Vector3d& s1s, const Vector3d& s1e, const Vector3d& s2s, const Vector3d& s2e) {
-            double dist = (s1s - s2s).squaredNorm();
-            if (dist < nearestDist) {
-              nearestDist = dist;
-              side1 = (s1e - s1s).normalized();
-              side2 = (s2e - s2s).normalized();
-            }
-          };
+        auto permutation = [&nearestDist, &side1,
+                            &side2](const Vector3d &s1s, const Vector3d &s1e,
+                                    const Vector3d &s2s, const Vector3d &s2e) {
+          double dist = (s1s - s2s).squaredNorm();
+          if (dist < nearestDist) {
+            nearestDist = dist;
+            side1 = (s1e - s1s).normalized();
+            side2 = (s2e - s2s).normalized();
+          }
+        };
 
         permutation(obj1.p1, obj1.p2, obj2.p1, obj2.p2);
         permutation(obj1.p2, obj1.p1, obj2.p1, obj2.p2);
@@ -126,21 +138,24 @@ QString Measurement::statemachine(QPoint mouse)
 
         ang = acos(side1.dot(side2)) * 180.0 / 3.14159265359;
         goto display_angle;
-      } else qglview->measure_state = MEASURE_ANG3;
+      } else
+        qglview->measure_state = MEASURE_ANG3;
     }
     break;
   case MEASURE_ANG3:
-    if (qglview->selected_obj.size() == 3){
+    if (qglview->selected_obj.size() == 3) {
       obj1 = qglview->selected_obj[0];
       obj2 = qglview->selected_obj[1];
       obj3 = qglview->selected_obj[2];
-      if (obj1.type == SelectionType::SELECTION_POINT && obj2.type == SelectionType::SELECTION_POINT && obj3.type == SelectionType::SELECTION_POINT){
+      if (obj1.type == SelectionType::SELECTION_POINT &&
+          obj2.type == SelectionType::SELECTION_POINT &&
+          obj3.type == SelectionType::SELECTION_POINT) {
         Vector3d side1 = (obj2.p1 - obj1.p1).normalized();
         Vector3d side2 = (obj2.p1 - obj3.p1).normalized();
         ang = acos(side1.dot(side2)) * 180.0 / 3.14159265359;
       }
-display_angle:
-      if (!std::isnan(ang)){
+    display_angle:
+      if (!std::isnan(ang)) {
         return QString("Angle  is %1 Degrees").arg(ang);
       }
       stopMeasure();
diff --git a/src/gui/Measurement.h b/src/gui/Measurement.h
index 21254b65a..5e1f48c87 100644
--- a/src/gui/Measurement.h
+++ b/src/gui/Measurement.h
@@ -1,19 +1,31 @@
 
 #pragma once
 
-#include <QPoint>
-#include <QString>
 #include "geometry/linalg.h"
 #include "gui/QGLView.h"
+#include <QPoint>
+#include <QString>
 
-enum { MEASURE_IDLE, MEASURE_DIST1, MEASURE_DIST2, MEASURE_ANG1, MEASURE_ANG2, MEASURE_ANG3 };
+enum {
+  MEASURE_IDLE,
+  MEASURE_DIST1,
+  MEASURE_DIST2,
+  MEASURE_ANG1,
+  MEASURE_ANG2,
+  MEASURE_ANG3
+};
 
-extern double calculateLinePointDistance(const Vector3d& l1, const Vector3d& l2, const Vector3d& pt, double& dist_lat);
-extern double calculateLineLineDistance(const Vector3d& l1b, const Vector3d& l1e, const Vector3d& l2b, const Vector3d& l2e, double& dist_lat);
-extern double calculateSegSegDistance(const Vector3d& l1b, const Vector3d& l1e, const Vector3d& l2b, const Vector3d& l2e, double& dist_lat);
+extern double calculateLinePointDistance(const Vector3d &l1, const Vector3d &l2,
+                                         const Vector3d &pt, double &dist_lat);
+extern double calculateLineLineDistance(const Vector3d &l1b,
+                                        const Vector3d &l1e,
+                                        const Vector3d &l2b,
+                                        const Vector3d &l2e, double &dist_lat);
+extern double calculateSegSegDistance(const Vector3d &l1b, const Vector3d &l1e,
+                                      const Vector3d &l2b, const Vector3d &l2e,
+                                      double &dist_lat);
 
-class Measurement
-{
+class Measurement {
 public:
   Measurement(void);
   void setView(QGLView *qglview);
@@ -21,6 +33,7 @@ public:
   void startMeasureDist(void);
   void startMeasureAngle(void);
   void stopMeasure();
+
 private:
   QGLView *qglview;
 };
diff --git a/src/gui/MouseSelector.cc b/src/gui/MouseSelector.cc
index cbbb5df67..cc895cdf2 100644
--- a/src/gui/MouseSelector.cc
+++ b/src/gui/MouseSelector.cc
@@ -1,27 +1,27 @@
 #include "gui/MouseSelector.h"
 
-#include "glview/system-gl.h"
 #include "glview/fbo.h"
+#include "glview/system-gl.h"
 
 #include <cstdint>
-#include <string>
 #include <memory>
+#include <string>
 /**
- * The selection is making use of a special shader, that renders each object in a color
- * that is derived from its index(), by using the first 24 bits of the identifier as a
- * 3-tuple for color.
+ * The selection is making use of a special shader, that renders each object in
+ * a color that is derived from its index(), by using the first 24 bits of the
+ * identifier as a 3-tuple for color.
  *
- * Roughly at most 1/3rd of the index()-es are rendered, therefore exhausting the keyspace
- * faster than expected.
- * If this ever becomes a problem, the index-mapping can be adjusted to use 10 up to 16 bit
- * per color channel to store the identifier.
- * Increasing this should be done carefully while testing on older graphics cards, they
- * might do "fancy" optimization.
+ * Roughly at most 1/3rd of the index()-es are rendered, therefore exhausting
+ * the keyspace faster than expected. If this ever becomes a problem, the
+ * index-mapping can be adjusted to use 10 up to 16 bit per color channel to
+ * store the identifier. Increasing this should be done carefully while testing
+ * on older graphics cards, they might do "fancy" optimization.
  */
 
 MouseSelector::MouseSelector(GLView *view) {
   this->view = view;
-  if (view) this->reset(view);
+  if (view)
+    this->reset(view);
 }
 
 /**
@@ -37,22 +37,28 @@ void MouseSelector::reset(GLView *view) {
  */
 void MouseSelector::initShader() {
   // Attributes:
-  // frag_idcolor - (uniform) 24 bit of the selected object's id encoded into R/G/B components as float values
+  // frag_idcolor - (uniform) 24 bit of the selected object's id encoded into
+  // R/G/B components as float values
   const auto selectshader = ShaderUtils::compileShaderProgram(
-    ShaderUtils::loadShaderSource("MouseSelector.vert"),
-    ShaderUtils::loadShaderSource("MouseSelector.frag"));
+      ShaderUtils::loadShaderSource("MouseSelector.vert"),
+      ShaderUtils::loadShaderSource("MouseSelector.frag"));
 
-  const GLint frag_idcolor = glGetUniformLocation(selectshader.shader_program, "frag_idcolor");
+  const GLint frag_idcolor =
+      glGetUniformLocation(selectshader.shader_program, "frag_idcolor");
   if (frag_idcolor < 0) {
     // TODO: Surface error better
-    fprintf(stderr, __FILE__ ": OpenGL symbol retrieval went wrong, id is %i\n\n", frag_idcolor);
+    fprintf(stderr,
+            __FILE__ ": OpenGL symbol retrieval went wrong, id is %i\n\n",
+            frag_idcolor);
   }
   this->shaderinfo = {
-    .resource = selectshader,
-    .type = ShaderUtils::ShaderType::SELECT_RENDERING,
-    .uniforms = {
-      {"frag_idcolor", glGetUniformLocation(selectshader.shader_program, "frag_idcolor")},
-    },
+      .resource = selectshader,
+      .type = ShaderUtils::ShaderType::SELECT_RENDERING,
+      .uniforms =
+          {
+              {"frag_idcolor", glGetUniformLocation(selectshader.shader_program,
+                                                    "frag_idcolor")},
+          },
   };
 }
 
@@ -60,8 +66,7 @@ void MouseSelector::initShader() {
  * Resize or create the framebuffer
  */
 void MouseSelector::setupFramebuffer(int width, int height) {
-  if (!this->framebuffer ||
-      this->framebuffer->width() != width ||
+  if (!this->framebuffer || this->framebuffer->width() != width ||
       this->framebuffer->height() != height) {
     this->framebuffer = createFBO(width, height);
     // We bind the framebuffer before initializing shaders since
@@ -74,10 +79,11 @@ void MouseSelector::setupFramebuffer(int width, int height) {
 
 /**
  * Setup the shaders, Projection and Model matrix and call the given renderer.
- * The renderer has to support rendering with ID colors (using the shader we provide),
- * otherwise the selection won't work.
+ * The renderer has to support rendering with ID colors (using the shader we
+ * provide), otherwise the selection won't work.
  *
- * returns index of picked node (AbstractNode::idx) or -1 if no object was found.
+ * returns index of picked node (AbstractNode::idx) or -1 if no object was
+ * found.
  */
 int MouseSelector::select(const Renderer *renderer, int x, int y) {
   // This function should render a frame, as usual, with the following changes:
@@ -87,7 +93,8 @@ int MouseSelector::select(const Renderer *renderer, int x, int y) {
   // * No lighting
   // * No decorations, like axes
 
-  // TODO: Ideally, we should make the above configurable and reduce duplicate render code in this function.
+  // TODO: Ideally, we should make the above configurable and reduce duplicate
+  // render code in this function.
 
   const int width = this->view->cam.pixel_width;
   const int height = this->view->cam.pixel_height;
@@ -96,10 +103,10 @@ int MouseSelector::select(const Renderer *renderer, int x, int y) {
   }
 
   // Initialize GL to draw to texture
-  // Ideally a texture of only 1x1 or 2x2 pixels as a subset of the viewing frustrum
-  // of the currently selected frame.
-  // For now, i will use a texture the same size as the normal viewport
-  // and select the identifier at the mouse coordinates
+  // Ideally a texture of only 1x1 or 2x2 pixels as a subset of the viewing
+  // frustrum of the currently selected frame. For now, i will use a texture the
+  // same size as the normal viewport and select the identifier at the mouse
+  // coordinates
   GL_CHECKD(this->framebuffer->bind());
 
   glClearColor(0, 0, 0, 1.0);
@@ -125,11 +132,12 @@ int MouseSelector::select(const Renderer *renderer, int x, int y) {
   glFinish();
 
   // Grab the color from the framebuffer and convert it back to an identifier
-  GLubyte color[3] = { 0 };
+  GLubyte color[3] = {0};
   // Qt position is originated top-left, so flip y to get GL coordinates.
   GL_CHECKD(glReadPixels(x, height - y, 1, 1, GL_RGB, GL_UNSIGNED_BYTE, color));
 
-  const int index = (uint32_t)color[0] | ((uint32_t)color[1] << 8) | ((uint32_t)color[2] << 16);
+  const int index = (uint32_t)color[0] | ((uint32_t)color[1] << 8) |
+                    ((uint32_t)color[2] << 16);
 
   // Switch the active framebuffer back to the default
   this->framebuffer->unbind();
diff --git a/src/gui/MouseSelector.h b/src/gui/MouseSelector.h
index dbfc6a8b5..af84fe78b 100644
--- a/src/gui/MouseSelector.h
+++ b/src/gui/MouseSelector.h
@@ -9,8 +9,7 @@
 /**
  * Grab the of the Tree element that was rendered at a specific location
  */
-class MouseSelector
-{
+class MouseSelector {
 public:
   MouseSelector(GLView *view);
 
diff --git a/src/gui/Network.h b/src/gui/Network.h
index 70db4f4e5..7aea9769c 100644
--- a/src/gui/Network.h
+++ b/src/gui/Network.h
@@ -30,59 +30,64 @@
 #include <QNetworkAccessManager>
 #include <QNetworkReply>
 #include <QNetworkRequest>
-#include <QTimer>
-#include <algorithm>
-#include <functional>
-#include <exception>
 #include <QObject>
 #include <QString>
+#include <QTimer>
 #include <QtNetwork>
+#include <algorithm>
+#include <exception>
+#include <functional>
 
-#include <utility>
 #include <string>
+#include <utility>
 #include <vector>
 
-#include "utils/printutils.h"
-#include "platform/PlatformUtils.h"
 #include "gui/NetworkSignal.h"
+#include "platform/PlatformUtils.h"
+#include "utils/printutils.h"
 
-class NetworkException : public std::exception
-{
+class NetworkException : public std::exception {
 public:
-  NetworkException(const QNetworkReply::NetworkError& error, const QString& errorMessage) : error(error), errorMessage(errorMessage.toStdString()) { }
+  NetworkException(const QNetworkReply::NetworkError &error,
+                   const QString &errorMessage)
+      : error(error), errorMessage(errorMessage.toStdString()) {}
 
-  const QNetworkReply::NetworkError& getError() const { return error; }
-  const std::string& getErrorMessage() const { return errorMessage; }
+  const QNetworkReply::NetworkError &getError() const { return error; }
+  const std::string &getErrorMessage() const { return errorMessage; }
 
-  const char *what() const noexcept override
-  {
-    return errorMessage.c_str();
-  }
+  const char *what() const noexcept override { return errorMessage.c_str(); }
 
 private:
   QNetworkReply::NetworkError error;
   std::string errorMessage;
 };
 
-using network_progress_func_t = std::function<bool (double)>;
+using network_progress_func_t = std::function<bool(double)>;
 
-template <typename ResultType>
-class NetworkRequest
-{
+template <typename ResultType> class NetworkRequest {
 public:
-  using setup_func_t = std::function<void (QNetworkRequest&)>;
-  using reply_func_t = std::function<QNetworkReply *(QNetworkAccessManager&, QNetworkRequest&)>;
-  using transform_func_t = std::function<ResultType (QNetworkReply *)>;
-  using error_func_t = std::function<ResultType (QNetworkReply *)>;
-
-  NetworkRequest(QUrl url, std::vector<int> accepted_codes, const int timeout_seconds)
-    : url(std::move(url)), accepted_codes(std::move(accepted_codes)), timeout_seconds(timeout_seconds)
-  { }
+  using setup_func_t = std::function<void(QNetworkRequest &)>;
+  using reply_func_t = std::function<QNetworkReply *(QNetworkAccessManager &,
+                                                     QNetworkRequest &)>;
+  using transform_func_t = std::function<ResultType(QNetworkReply *)>;
+  using error_func_t = std::function<ResultType(QNetworkReply *)>;
+
+  NetworkRequest(QUrl url, std::vector<int> accepted_codes,
+                 const int timeout_seconds)
+      : url(std::move(url)), accepted_codes(std::move(accepted_codes)),
+        timeout_seconds(timeout_seconds) {}
   virtual ~NetworkRequest() = default;
 
-  void set_progress_func(const network_progress_func_t& progress_func) { this->progress_func = progress_func; }
-  ResultType execute(const setup_func_t& setup_func, const reply_func_t& reply_func, const transform_func_t& transform_func);
-  ResultType execute(const setup_func_t& setup_func, const reply_func_t& reply_func, const transform_func_t& transform_func, const error_func_t& error_func);
+  void set_progress_func(const network_progress_func_t &progress_func) {
+    this->progress_func = progress_func;
+  }
+  ResultType execute(const setup_func_t &setup_func,
+                     const reply_func_t &reply_func,
+                     const transform_func_t &transform_func);
+  ResultType execute(const setup_func_t &setup_func,
+                     const reply_func_t &reply_func,
+                     const transform_func_t &transform_func,
+                     const error_func_t &error_func);
 
 private:
   QUrl url;
@@ -93,24 +98,24 @@ private:
 
 template <typename ResultType>
 ResultType NetworkRequest<ResultType>::execute(
-  const NetworkRequest::setup_func_t& setup_func,
-  const NetworkRequest::reply_func_t& reply_func,
-  const NetworkRequest::transform_func_t& transform_func)
-{
-  return execute(setup_func, reply_func, transform_func, [](QNetworkReply *reply) -> ResultType {
-    throw NetworkException{reply->error(), reply->errorString()};
-  });
+    const NetworkRequest::setup_func_t &setup_func,
+    const NetworkRequest::reply_func_t &reply_func,
+    const NetworkRequest::transform_func_t &transform_func) {
+  return execute(setup_func, reply_func, transform_func,
+                 [](QNetworkReply *reply) -> ResultType {
+                   throw NetworkException{reply->error(), reply->errorString()};
+                 });
 }
 
 template <typename ResultType>
 ResultType NetworkRequest<ResultType>::execute(
-  const NetworkRequest::setup_func_t& setup_func,
-  const NetworkRequest::reply_func_t& reply_func,
-  const NetworkRequest::transform_func_t& transform_func,
-  const NetworkRequest::error_func_t& error_func)
-{
+    const NetworkRequest::setup_func_t &setup_func,
+    const NetworkRequest::reply_func_t &reply_func,
+    const NetworkRequest::transform_func_t &transform_func,
+    const NetworkRequest::error_func_t &error_func) {
   QNetworkRequest request(url);
-  request.setHeader(QNetworkRequest::UserAgentHeader, QString::fromStdString(PlatformUtils::user_agent()));
+  request.setHeader(QNetworkRequest::UserAgentHeader,
+                    QString::fromStdString(PlatformUtils::user_agent()));
   setup_func(request);
 
   QNetworkAccessManager nam;
@@ -119,7 +124,8 @@ ResultType NetworkRequest<ResultType>::execute(
   QTimer timer;
   QEventLoop loop;
   NetworkSignal forwarder{nullptr, [&](qint64 bytesSent, qint64 bytesTotal) {
-                            const double permille = (1000.0 * bytesSent) / bytesTotal;
+                            const double permille =
+                                (1000.0 * bytesSent) / bytesTotal;
                             timer.start();
                             if (progress_func && progress_func(permille)) {
                               reply->abort();
@@ -127,7 +133,8 @@ ResultType NetworkRequest<ResultType>::execute(
                           }};
   QObject::connect(&timer, &QTimer::timeout, &loop, &QEventLoop::quit);
   QObject::connect(reply, &QNetworkReply::finished, &loop, &QEventLoop::quit);
-  QObject::connect(reply, &QNetworkReply::uploadProgress, &forwarder, &NetworkSignal::network_progress);
+  QObject::connect(reply, &QNetworkReply::uploadProgress, &forwarder,
+                   &NetworkSignal::network_progress);
   timer.setSingleShot(true);
   timer.start(timeout_seconds * 1000);
   loop.exec();
@@ -148,9 +155,13 @@ ResultType NetworkRequest<ResultType>::execute(
   if (reply->error() != QNetworkReply::NoError) {
     return error_func(reply);
   } else {
-    const auto statusCode = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
-    if (std::find(accepted_codes.begin(), accepted_codes.end(), statusCode) == accepted_codes.end()) {
-      QString reason = reply->attribute(QNetworkRequest::HttpReasonPhraseAttribute).toString();
+    const auto statusCode =
+        reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
+    if (std::find(accepted_codes.begin(), accepted_codes.end(), statusCode) ==
+        accepted_codes.end()) {
+      QString reason =
+          reply->attribute(QNetworkRequest::HttpReasonPhraseAttribute)
+              .toString();
       throw NetworkException{QNetworkReply::ProtocolFailure, reason};
     }
   }
diff --git a/src/gui/NetworkSignal.h b/src/gui/NetworkSignal.h
index f51832ed5..26a03e032 100644
--- a/src/gui/NetworkSignal.h
+++ b/src/gui/NetworkSignal.h
@@ -31,15 +31,15 @@
 #include <QObject>
 #include <utility>
 
-using network_progress_func_t = std::function<bool (double)>;
+using network_progress_func_t = std::function<bool(double)>;
 
-class NetworkSignal : public QObject
-{
+class NetworkSignal : public QObject {
   Q_OBJECT;
 
-  using callback_t = std::function<void (qint64, qint64)>;
+  using callback_t = std::function<void(qint64, qint64)>;
 
-  NetworkSignal(QObject *parent, callback_t callback) : QObject(parent), callback(std::move(callback)) { }
+  NetworkSignal(QObject *parent, callback_t callback)
+      : QObject(parent), callback(std::move(callback)) {}
 
 public slots:
   void network_progress(qint64 bytesSent, qint64 bytesTotal) {
diff --git a/src/gui/OctoPrint.cc b/src/gui/OctoPrint.cc
index eed99045d..e16e7567c 100644
--- a/src/gui/OctoPrint.cc
+++ b/src/gui/OctoPrint.cc
@@ -39,65 +39,69 @@
 #include <vector>
 
 #include "core/Settings.h"
-#include "utils/printutils.h"
 #include "platform/PlatformUtils.h"
+#include "utils/printutils.h"
 
-const QString OctoPrint::url() const
-{
+const QString OctoPrint::url() const {
   return QString::fromStdString(Settings::Settings::octoPrintUrl.value());
 }
 
-const std::string OctoPrint::apiKey() const
-{
+const std::string OctoPrint::apiKey() const {
   return Settings::Settings::octoPrintApiKey.value();
 }
 
-const QJsonDocument OctoPrint::getJsonData(const QString& endpoint) const
-{
+const QJsonDocument OctoPrint::getJsonData(const QString &endpoint) const {
   if (url().trimmed().isEmpty()) {
-    throw NetworkException{QNetworkReply::ProtocolFailure, "OctoPrint URL not configured."};
+    throw NetworkException{QNetworkReply::ProtocolFailure,
+                           "OctoPrint URL not configured."};
   }
 
-  auto networkRequest = NetworkRequest<const QJsonDocument>{QUrl{url() + endpoint}, { 200 }, 30};
+  auto networkRequest =
+      NetworkRequest<const QJsonDocument>{QUrl{url() + endpoint}, {200}, 30};
 
   return networkRequest.execute(
-    [&](QNetworkRequest& request) {
-    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
-    request.setRawHeader(QByteArray{"X-Api-Key"}, QByteArray{apiKey().c_str()});
-  },
-    [](QNetworkAccessManager& nam, QNetworkRequest& request) {
-    return nam.get(request);
-  },
-    [](QNetworkReply *reply) -> const QJsonDocument {
-    auto doc = QJsonDocument::fromJson(reply->readAll());
-    PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
-    return doc;
-  }
-    );
+      [&](QNetworkRequest &request) {
+        request.setHeader(QNetworkRequest::ContentTypeHeader,
+                          "application/json");
+        request.setRawHeader(QByteArray{"X-Api-Key"},
+                             QByteArray{apiKey().c_str()});
+      },
+      [](QNetworkAccessManager &nam, QNetworkRequest &request) {
+        return nam.get(request);
+      },
+      [](QNetworkReply *reply) -> const QJsonDocument {
+        auto doc = QJsonDocument::fromJson(reply->readAll());
+        PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
+        return doc;
+      });
 }
 
-const std::vector<std::pair<const QString, const QString>> OctoPrint::getSlicers() const
-{
+const std::vector<std::pair<const QString, const QString>>
+OctoPrint::getSlicers() const {
   const auto obj = getJsonData("/slicing").object();
   std::vector<std::pair<const QString, const QString>> slicers;
-  for (const auto& key : obj.keys()) {
-    slicers.emplace_back(std::make_pair(key, obj[key].toObject().value("displayName").toString()));
+  for (const auto &key : obj.keys()) {
+    slicers.emplace_back(std::make_pair(
+        key, obj[key].toObject().value("displayName").toString()));
   }
   return slicers;
 }
 
-const std::vector<std::pair<const QString, const QString>> OctoPrint::getProfiles(const QString& slicer) const
-{
+const std::vector<std::pair<const QString, const QString>>
+OctoPrint::getProfiles(const QString &slicer) const {
   const auto obj = getJsonData("/slicing").object();
   std::vector<std::pair<const QString, const QString>> profiles;
-  for (const auto& key : obj.keys()) {
+  for (const auto &key : obj.keys()) {
     const auto entry = obj[key].toObject();
     const auto name = entry.value("key").toString();
     const auto isDefault = entry.value("default").toBool();
     if ((slicer == name) || (slicer.isEmpty() && isDefault)) {
       const auto profilesObject = entry.value("profiles").toObject();
-      for (const auto& profileKey : profilesObject.keys()) {
-        const auto displayName = profilesObject[profileKey].toObject().value("displayName").toString();
+      for (const auto &profileKey : profilesObject.keys()) {
+        const auto displayName = profilesObject[profileKey]
+                                     .toObject()
+                                     .value("displayName")
+                                     .toString();
         profiles.emplace_back(std::make_pair(profileKey, displayName));
       }
       break;
@@ -106,8 +110,7 @@ const std::vector<std::pair<const QString, const QString>> OctoPrint::getProfile
   return profiles;
 }
 
-const std::pair<const QString, const QString> OctoPrint::getVersion() const
-{
+const std::pair<const QString, const QString> OctoPrint::getVersion() const {
   const auto obj = getJsonData("/version").object();
   const auto api_version = obj.value("api").toString();
   const auto server_version = obj.value("server").toString();
@@ -115,59 +118,67 @@ const std::pair<const QString, const QString> OctoPrint::getVersion() const
   return result;
 }
 
-const QString OctoPrint::requestApiKey() const
-{
+const QString OctoPrint::requestApiKey() const {
   QJsonObject jsonInput;
   jsonInput.insert("app", QString{"OpenSCAD"});
 
-  auto networkRequest = NetworkRequest<QString>{QUrl{url() + "/../plugin/appkeys/request"}, { 201 }, 30};
+  auto networkRequest = NetworkRequest<QString>{
+      QUrl{url() + "/../plugin/appkeys/request"}, {201}, 30};
   return networkRequest.execute(
-    [&](QNetworkRequest& request) {
-    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
-  },
-    [&](QNetworkAccessManager& nam, QNetworkRequest& request) {
-    return nam.post(request, QJsonDocument(jsonInput).toJson());
-  },
-    [](QNetworkReply *reply) -> QString {
-    const auto doc = QJsonDocument::fromJson(reply->readAll());
-    PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
-    const auto obj = doc.object();
-    const auto token = obj.value("app_token").toString();
-    return token;
-  }
-    );
+      [&](QNetworkRequest &request) {
+        request.setHeader(QNetworkRequest::ContentTypeHeader,
+                          "application/json");
+      },
+      [&](QNetworkAccessManager &nam, QNetworkRequest &request) {
+        return nam.post(request, QJsonDocument(jsonInput).toJson());
+      },
+      [](QNetworkReply *reply) -> QString {
+        const auto doc = QJsonDocument::fromJson(reply->readAll());
+        PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
+        const auto obj = doc.object();
+        const auto token = obj.value("app_token").toString();
+        return token;
+      });
 }
 
-const std::pair<int, QString> OctoPrint::pollApiKeyApproval(const QString& token) const
-{
-  auto networkRequest = NetworkRequest<std::pair<int, QString>>{QUrl{url() + "/../plugin/appkeys/request/" + token}, { 200, 202, 404 }, 30};
+const std::pair<int, QString>
+OctoPrint::pollApiKeyApproval(const QString &token) const {
+  auto networkRequest = NetworkRequest<std::pair<int, QString>>{
+      QUrl{url() + "/../plugin/appkeys/request/" + token}, {200, 202, 404}, 30};
   return networkRequest.execute(
-    [&](QNetworkRequest& request) {
-    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
-  },
-    [&](QNetworkAccessManager& nam, QNetworkRequest& request) {
-    return nam.get(request);
-  },
-    [](QNetworkReply *reply) -> std::pair<int, QString> {
-    const auto code = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
-    PRINTDB("Response Code: %d", code);
-    const auto obj = QJsonDocument::fromJson(reply->readAll()).object();
-    return std::make_pair(code, obj.value("api_key").toString());
-  },
-    [](QNetworkReply *reply) -> std::pair<int, QString> {
-    const auto code = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
-    PRINTDB("Response (Error) Code: %d", code);
-    return std::make_pair(code, "");
-  }
-    );
+      [&](QNetworkRequest &request) {
+        request.setHeader(QNetworkRequest::ContentTypeHeader,
+                          "application/json");
+      },
+      [&](QNetworkAccessManager &nam, QNetworkRequest &request) {
+        return nam.get(request);
+      },
+      [](QNetworkReply *reply) -> std::pair<int, QString> {
+        const auto code =
+            reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
+        PRINTDB("Response Code: %d", code);
+        const auto obj = QJsonDocument::fromJson(reply->readAll()).object();
+        return std::make_pair(code, obj.value("api_key").toString());
+      },
+      [](QNetworkReply *reply) -> std::pair<int, QString> {
+        const auto code =
+            reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
+        PRINTDB("Response (Error) Code: %d", code);
+        return std::make_pair(code, "");
+      });
 }
 
-const QString OctoPrint::upload(const QString& exportFileName, const QString& fileName, const network_progress_func_t& progress_func) const {
+const QString
+OctoPrint::upload(const QString &exportFileName, const QString &fileName,
+                  const network_progress_func_t &progress_func) const {
 
   auto *multiPart = new QHttpMultiPart(QHttpMultiPart::FormDataType);
   QHttpPart filePart;
-  filePart.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant{R"(form-data; name="file"; filename=")" + fileName + "\""});
-  filePart.setHeader(QNetworkRequest::ContentTypeHeader, QVariant{"application/octet-stream"});
+  filePart.setHeader(
+      QNetworkRequest::ContentDispositionHeader,
+      QVariant{R"(form-data; name="file"; filename=")" + fileName + "\""});
+  filePart.setHeader(QNetworkRequest::ContentTypeHeader,
+                     QVariant{"application/octet-stream"});
 
   auto *file = new QFile(exportFileName, multiPart);
   file->open(QIODevice::ReadOnly);
@@ -175,30 +186,34 @@ const QString OctoPrint::upload(const QString& exportFileName, const QString& fi
 
   multiPart->append(filePart);
 
-  auto networkRequest = NetworkRequest<const QString>{QUrl{url() + "/files/local"}, { 200, 201 }, 180};
+  auto networkRequest = NetworkRequest<const QString>{
+      QUrl{url() + "/files/local"}, {200, 201}, 180};
   networkRequest.set_progress_func(progress_func);
   return networkRequest.execute(
-    [&](QNetworkRequest& request) {
-    request.setHeader(QNetworkRequest::UserAgentHeader, QString::fromStdString(PlatformUtils::user_agent()));
-    request.setRawHeader(QByteArray{"X-Api-Key"}, QByteArray{apiKey().c_str()});
-  },
-    [&](QNetworkAccessManager& nam, QNetworkRequest& request) {
-    const auto reply = nam.post(request, multiPart);
-    multiPart->setParent(reply);
-    return reply;
-  },
-    [](QNetworkReply *reply) -> const QString {
-    const auto doc = QJsonDocument::fromJson(reply->readAll());
-    PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
-    auto location = reply->header(QNetworkRequest::LocationHeader).toString();
-    LOG("Uploaded successfully to %1$s", location.toStdString());
-    return location;
-  }
-    );
+      [&](QNetworkRequest &request) {
+        request.setHeader(QNetworkRequest::UserAgentHeader,
+                          QString::fromStdString(PlatformUtils::user_agent()));
+        request.setRawHeader(QByteArray{"X-Api-Key"},
+                             QByteArray{apiKey().c_str()});
+      },
+      [&](QNetworkAccessManager &nam, QNetworkRequest &request) {
+        const auto reply = nam.post(request, multiPart);
+        multiPart->setParent(reply);
+        return reply;
+      },
+      [](QNetworkReply *reply) -> const QString {
+        const auto doc = QJsonDocument::fromJson(reply->readAll());
+        PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
+        auto location =
+            reply->header(QNetworkRequest::LocationHeader).toString();
+        LOG("Uploaded successfully to %1$s", location.toStdString());
+        return location;
+      });
 }
 
-void OctoPrint::slice(const QString& fileUrl, const QString& slicer, const QString& profile, const bool select, const bool print) const
-{
+void OctoPrint::slice(const QString &fileUrl, const QString &slicer,
+                      const QString &profile, const bool select,
+                      const bool print) const {
   QJsonObject jsonInput;
   jsonInput.insert("command", QString{"slice"});
   jsonInput.insert("slicer", slicer);
@@ -206,19 +221,20 @@ void OctoPrint::slice(const QString& fileUrl, const QString& slicer, const QStri
   jsonInput.insert("select", QString{select ? "true" : "false"});
   jsonInput.insert("print", QString{print ? "true" : "false"});
 
-  auto networkRequest = NetworkRequest<void>{QUrl{fileUrl}, { 200, 202 }, 30};
+  auto networkRequest = NetworkRequest<void>{QUrl{fileUrl}, {200, 202}, 30};
   return networkRequest.execute(
-    [&](QNetworkRequest& request) {
-    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
-    request.setRawHeader(QByteArray{"X-Api-Key"}, QByteArray{apiKey().c_str()});
-  },
-    [&](QNetworkAccessManager& nam, QNetworkRequest& request) {
-    return nam.post(request, QJsonDocument(jsonInput).toJson());
-  },
-    [](QNetworkReply *reply) {
-    const auto doc = QJsonDocument::fromJson(reply->readAll());
-    PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
-    LOG("Slice command successfully executed.");
-  }
-    );
+      [&](QNetworkRequest &request) {
+        request.setHeader(QNetworkRequest::ContentTypeHeader,
+                          "application/json");
+        request.setRawHeader(QByteArray{"X-Api-Key"},
+                             QByteArray{apiKey().c_str()});
+      },
+      [&](QNetworkAccessManager &nam, QNetworkRequest &request) {
+        return nam.post(request, QJsonDocument(jsonInput).toJson());
+      },
+      [](QNetworkReply *reply) {
+        const auto doc = QJsonDocument::fromJson(reply->readAll());
+        PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
+        LOG("Slice command successfully executed.");
+      });
 }
diff --git a/src/gui/OctoPrint.h b/src/gui/OctoPrint.h
index b4f39e82c..fc71e1c94 100644
--- a/src/gui/OctoPrint.h
+++ b/src/gui/OctoPrint.h
@@ -26,18 +26,17 @@
 
 #pragma once
 
-#include <utility>
 #include <string>
+#include <utility>
 #include <vector>
 
 #include <QFile>
-#include <QString>
 #include <QJsonDocument>
+#include <QString>
 
 #include "gui/Network.h"
 
-class OctoPrint
-{
+class OctoPrint {
 public:
   OctoPrint() = default;
   virtual ~OctoPrint() = default;
@@ -46,12 +45,15 @@ public:
   const std::string apiKey() const;
   const std::pair<const QString, const QString> getVersion() const;
   const QString requestApiKey() const;
-  const std::pair<int, QString> pollApiKeyApproval(const QString& token) const;
+  const std::pair<int, QString> pollApiKeyApproval(const QString &token) const;
   const std::vector<std::pair<const QString, const QString>> getSlicers() const;
-  const std::vector<std::pair<const QString, const QString>> getProfiles(const QString& slicer) const;
-  const QString upload(const QString& exportFileName, const QString& fileName, const network_progress_func_t& progress_func) const;
-  void slice(const QString& fileUrl, const QString& slicer, const QString& profile, const bool select, const bool print) const;
+  const std::vector<std::pair<const QString, const QString>>
+  getProfiles(const QString &slicer) const;
+  const QString upload(const QString &exportFileName, const QString &fileName,
+                       const network_progress_func_t &progress_func) const;
+  void slice(const QString &fileUrl, const QString &slicer,
+             const QString &profile, const bool select, const bool print) const;
 
 private:
-  const QJsonDocument getJsonData(const QString& endpoint) const;
+  const QJsonDocument getJsonData(const QString &endpoint) const;
 };
diff --git a/src/gui/OctoPrintApiKeyDialog.cc b/src/gui/OctoPrintApiKeyDialog.cc
index 5495bdc68..e82138d4c 100644
--- a/src/gui/OctoPrintApiKeyDialog.cc
+++ b/src/gui/OctoPrintApiKeyDialog.cc
@@ -26,35 +26,36 @@
 
 #include "gui/OctoPrintApiKeyDialog.h"
 
-#include <QString>
 #include <QCheckBox>
 #include <QColor>
-#include <QDialog>
 #include <QColorDialog>
+#include <QDialog>
 #include <QLineEdit>
-#include <QSvgRenderer>
-#include <QPalette>
 #include <QPainter>
+#include <QPalette>
+#include <QString>
+#include <QSvgRenderer>
 
 #include "OctoPrint.h"
 
-OctoPrintApiKeyDialog::OctoPrintApiKeyDialog()
-{
+OctoPrintApiKeyDialog::OctoPrintApiKeyDialog() {
   setupUi(this);
-  QObject::connect(&networkTimer, &QTimer::timeout, this, &OctoPrintApiKeyDialog::timeout);
-  QObject::connect(&animationTimer, &QTimer::timeout, this, &OctoPrintApiKeyDialog::animationUpdate);
+  QObject::connect(&networkTimer, &QTimer::timeout, this,
+                   &OctoPrintApiKeyDialog::timeout);
+  QObject::connect(&animationTimer, &QTimer::timeout, this,
+                   &OctoPrintApiKeyDialog::animationUpdate);
 
   this->iconOk = QIcon::fromTheme("chokusen-circle-checkmark");
   this->iconError = QIcon::fromTheme("chokusen-circle-error");
   this->iconWaiting = QIcon::fromTheme("chokusen-loading");
 }
 
-void OctoPrintApiKeyDialog::startRequest()
-{
+void OctoPrintApiKeyDialog::startRequest() {
   OctoPrint octoPrint;
   this->token = octoPrint.requestApiKey();
   this->apiKey.clear();
-  this->labelMessage->setText(_("API key created, waiting for approval in OctoPrint..."));
+  this->labelMessage->setText(
+      _("API key created, waiting for approval in OctoPrint..."));
   networkTimer.setSingleShot(true);
   networkTimer.start(1000);
   animationTimer.setInterval(100);
@@ -63,22 +64,23 @@ void OctoPrintApiKeyDialog::startRequest()
   this->pushButtonRetry->setEnabled(false);
 }
 
-void OctoPrintApiKeyDialog::paintIcon(const QIcon& icon, const qreal rotation)
-{
+void OctoPrintApiKeyDialog::paintIcon(const QIcon &icon, const qreal rotation) {
   QPalette palette;
-  QImage image(this->labelIcon->width(), this->labelIcon->width(), QImage::Format_ARGB32);
+  QImage image(this->labelIcon->width(), this->labelIcon->width(),
+               QImage::Format_ARGB32);
   image.fill(0x000000ff);
   QPainter painter(&image);
-  painter.translate(QPoint{this->labelIcon->width() / 2, this->labelIcon->width() / 2});
+  painter.translate(
+      QPoint{this->labelIcon->width() / 2, this->labelIcon->width() / 2});
   painter.rotate(rotation);
-  painter.translate(QPoint{-this->labelIcon->width() / 2, -this->labelIcon->width() / 2});
+  painter.translate(
+      QPoint{-this->labelIcon->width() / 2, -this->labelIcon->width() / 2});
   icon.paint(&painter, image.rect());
   QPixmap pixmap = QPixmap::fromImage(image);
   this->labelIcon->setPixmap(QPixmap::fromImage(image));
 }
 
-void OctoPrintApiKeyDialog::timeout()
-{
+void OctoPrintApiKeyDialog::timeout() {
   OctoPrint octoPrint;
   const auto [code, apiKey] = octoPrint.pollApiKeyApproval(this->token);
   switch (code) {
@@ -105,31 +107,22 @@ void OctoPrintApiKeyDialog::timeout()
   }
 }
 
-void OctoPrintApiKeyDialog::animationUpdate()
-{
+void OctoPrintApiKeyDialog::animationUpdate() {
   static qreal rotation = 0.0;
   paintIcon(this->iconWaiting, rotation);
   rotation += 30;
 }
 
-int OctoPrintApiKeyDialog::exec()
-{
+int OctoPrintApiKeyDialog::exec() {
   startRequest();
   return QDialog::exec();
 }
 
-void OctoPrintApiKeyDialog::on_pushButtonRetry_clicked()
-{
-  startRequest();
-}
+void OctoPrintApiKeyDialog::on_pushButtonRetry_clicked() { startRequest(); }
 
-void OctoPrintApiKeyDialog::on_pushButtonOk_clicked()
-{
-  accept();
-}
+void OctoPrintApiKeyDialog::on_pushButtonOk_clicked() { accept(); }
 
-void OctoPrintApiKeyDialog::on_pushButtonCancel_clicked()
-{
+void OctoPrintApiKeyDialog::on_pushButtonCancel_clicked() {
   this->token.clear();
   this->apiKey.clear();
   reject();
diff --git a/src/gui/OctoPrintApiKeyDialog.h b/src/gui/OctoPrintApiKeyDialog.h
index 78b1b3a8a..51ba101d2 100644
--- a/src/gui/OctoPrintApiKeyDialog.h
+++ b/src/gui/OctoPrintApiKeyDialog.h
@@ -26,23 +26,22 @@
 
 #pragma once
 
-#include <QIcon>
-#include <QTimer>
 #include <QDialog>
+#include <QIcon>
 #include <QString>
+#include <QTimer>
 
 #include "gui/qtgettext.h" // IWYU pragma: keep
 #include "ui_OctoPrintApiKeyDialog.h"
 
-class OctoPrintApiKeyDialog : public QDialog, public Ui::OctoPrintApiKeyDialog
-{
+class OctoPrintApiKeyDialog : public QDialog, public Ui::OctoPrintApiKeyDialog {
   Q_OBJECT;
 
 public:
   OctoPrintApiKeyDialog();
 
   int exec() override;
-  const QString& getApiKey() const { return apiKey; }
+  const QString &getApiKey() const { return apiKey; }
 
 private slots:
   void timeout();
@@ -53,7 +52,7 @@ private slots:
 
 private:
   void startRequest();
-  void paintIcon(const QIcon& icon, const qreal rotation = 0.0);
+  void paintIcon(const QIcon &icon, const qreal rotation = 0.0);
 
   QString token;
   QString apiKey;
diff --git a/src/gui/OpenCSGWarningDialog.cc b/src/gui/OpenCSGWarningDialog.cc
index 642f858c1..c76c72b01 100644
--- a/src/gui/OpenCSGWarningDialog.cc
+++ b/src/gui/OpenCSGWarningDialog.cc
@@ -1,20 +1,17 @@
 #include "gui/OpenCSGWarningDialog.h"
+#include "gui/Preferences.h"
 #include <QString>
 #include <QWidget>
-#include "gui/Preferences.h"
 
-OpenCSGWarningDialog::OpenCSGWarningDialog(QWidget *)
-{
+OpenCSGWarningDialog::OpenCSGWarningDialog(QWidget *) {
   setupUi(this);
 
   connect(this->showBox, &QCheckBox::toggled,
           GlobalPreferences::inst()->openCSGWarningBox, &QCheckBox::setChecked);
-  connect(this->showBox, &QCheckBox::toggled,
-          GlobalPreferences::inst(), &Preferences::on_openCSGWarningBox_toggled);
+  connect(this->showBox, &QCheckBox::toggled, GlobalPreferences::inst(),
+          &Preferences::on_openCSGWarningBox_toggled);
 }
 
-void OpenCSGWarningDialog::setText(const QString& text)
-{
+void OpenCSGWarningDialog::setText(const QString &text) {
   this->warningText->setPlainText(text);
 }
-
diff --git a/src/gui/OpenCSGWarningDialog.h b/src/gui/OpenCSGWarningDialog.h
index 0a58e0090..bd0447384 100644
--- a/src/gui/OpenCSGWarningDialog.h
+++ b/src/gui/OpenCSGWarningDialog.h
@@ -1,16 +1,16 @@
 #pragma once
 
 #include "gui/qtgettext.h"
+#include "ui_OpenCSGWarningDialog.h"
 #include <QDialog>
 #include <QWidget>
-#include "ui_OpenCSGWarningDialog.h"
 
-class OpenCSGWarningDialog : public QDialog, public Ui::OpenCSGWarningDialog
-{
+class OpenCSGWarningDialog : public QDialog, public Ui::OpenCSGWarningDialog {
   Q_OBJECT;
+
 public:
   OpenCSGWarningDialog(QWidget *parent);
 
 public slots:
-  void setText(const QString& text);
+  void setText(const QString &text);
 };
diff --git a/src/gui/OpenSCADApp.cc b/src/gui/OpenSCADApp.cc
index 2f9b07ee8..7d72c0447 100644
--- a/src/gui/OpenSCADApp.cc
+++ b/src/gui/OpenSCADApp.cc
@@ -4,52 +4,49 @@
 #include "gui/EventFilter.h"
 #endif
 
+#include "gui/QSettingsCached.h"
 #include <QApplication>
 #include <QEvent>
 #include <QObject>
+#include <QProgressDialog>
 #include <QString>
 #include <QStringList>
+#include <boost/foreach.hpp>
 #include <cassert>
 #include <exception>
-#include <QProgressDialog>
-#include <boost/foreach.hpp>
-#include "gui/QSettingsCached.h"
 
-OpenSCADApp::OpenSCADApp(int& argc, char **argv)
-  : QApplication(argc, argv)
-{
+OpenSCADApp::OpenSCADApp(int &argc, char **argv) : QApplication(argc, argv) {
 #ifdef Q_OS_MACOS
   this->installEventFilter(new SCADEventFilter(this));
 #endif
 }
 
-OpenSCADApp::~OpenSCADApp()
-{
-  delete this->fontCacheDialog;
-}
+OpenSCADApp::~OpenSCADApp() { delete this->fontCacheDialog; }
 
 #include <QMessageBox>
 
-bool OpenSCADApp::notify(QObject *object, QEvent *event)
-{
+bool OpenSCADApp::notify(QObject *object, QEvent *event) {
   QString msg;
   try {
     return QApplication::notify(object, event);
-  } catch (const std::exception& e) {
+  } catch (const std::exception &e) {
     msg = e.what();
   } catch (...) {
     msg = _("Unknown error");
   }
   // This happens when an uncaught exception is thrown in a Qt event handler
-  QMessageBox::critical(nullptr, QString(_("Critical Error")), QString(_("A critical error was caught. The application may have become unstable:\n%1")).arg(QString(msg)));
+  QMessageBox::critical(nullptr, QString(_("Critical Error")),
+                        QString(_("A critical error was caught. The "
+                                  "application may have become unstable:\n%1"))
+                            .arg(QString(msg)));
   return false;
 }
 
 /*!
-   Requests to open a file from an external event, e.g. by double-clicking a filename.
+   Requests to open a file from an external event, e.g. by double-clicking a
+   filename.
  */
-void OpenSCADApp::requestOpenFile(const QString& filename)
-{
+void OpenSCADApp::requestOpenFile(const QString &filename) {
   for (auto win : this->windowManager.getWindows()) {
     // if we have an empty open window, use that one
     if (win->isEmpty()) {
@@ -62,18 +59,19 @@ void OpenSCADApp::requestOpenFile(const QString& filename)
   new MainWindow(QStringList(filename));
 }
 
-void OpenSCADApp::showFontCacheDialog()
-{
-  if (!this->fontCacheDialog) this->fontCacheDialog = new QProgressDialog();
-  this->fontCacheDialog->setLabelText(_("Fontconfig needs to update its font cache.\nThis can take up to a couple of minutes."));
+void OpenSCADApp::showFontCacheDialog() {
+  if (!this->fontCacheDialog)
+    this->fontCacheDialog = new QProgressDialog();
+  this->fontCacheDialog->setLabelText(
+      _("Fontconfig needs to update its font cache.\nThis can take up to a "
+        "couple of minutes."));
   this->fontCacheDialog->setMinimum(0);
   this->fontCacheDialog->setMaximum(0);
   this->fontCacheDialog->setCancelButton(nullptr);
   this->fontCacheDialog->exec();
 }
 
-void OpenSCADApp::hideFontCacheDialog()
-{
+void OpenSCADApp::hideFontCacheDialog() {
   assert(this->fontCacheDialog);
   this->fontCacheDialog->reset();
 }
diff --git a/src/gui/OpenSCADApp.h b/src/gui/OpenSCADApp.h
index 720c2c4a9..cef118401 100644
--- a/src/gui/OpenSCADApp.h
+++ b/src/gui/OpenSCADApp.h
@@ -1,23 +1,22 @@
 #pragma once
 
+#include "gui/WindowManager.h"
+#include <QApplication>
 #include <QEvent>
 #include <QObject>
 #include <QString>
-#include <QApplication>
-#include "gui/WindowManager.h"
 
 class QProgressDialog;
 
-class OpenSCADApp : public QApplication
-{
+class OpenSCADApp : public QApplication {
   Q_OBJECT
 
 public:
-  OpenSCADApp(int& argc, char **argv);
+  OpenSCADApp(int &argc, char **argv);
   ~OpenSCADApp() override;
 
   bool notify(QObject *object, QEvent *event) override;
-  void requestOpenFile(const QString& filename);
+  void requestOpenFile(const QString &filename);
 
 public slots:
   void showFontCacheDialog();
diff --git a/src/gui/Preferences.cc b/src/gui/Preferences.cc
index 35e4e3bac..c5c18a362 100644
--- a/src/gui/Preferences.cc
+++ b/src/gui/Preferences.cc
@@ -26,82 +26,81 @@
 
 #include "gui/Preferences.h"
 
-#include <unordered_map>
-#include <vector>
+#include "Feature.h"
+#include "OctoPrintApiKeyDialog.h"
+#include "core/Settings.h"
+#include "geometry/GeometryCache.h"
+#include "gui/AutoUpdater.h"
+#include "utils/printutils.h"
+#include <QActionGroup>
+#include <QDialog>
+#include <QFileDialog>
 #include <QFont>
 #include <QFontComboBox>
+#include <QFontDatabase>
+#include <QKeyEvent>
+#include <QListWidget>
+#include <QListWidgetItem>
 #include <QMainWindow>
+#include <QMenu>
+#include <QMessageBox>
 #include <QObject>
-#include <QDialog>
+#include <QRegularExpression>
+#include <QRegularExpressionValidator>
+#include <QSettings>
 #include <QSizePolicy>
 #include <QSpacerItem>
+#include <QStatusBar>
 #include <QString>
 #include <QStringList>
+#include <QTextDocument>
 #include <QWidget>
-#include <tuple>
+#include <boost/algorithm/string.hpp>
 #include <cassert>
 #include <list>
-#include <QMenu>
-#include <QActionGroup>
-#include <QMessageBox>
-#include <QFontDatabase>
-#include <QKeyEvent>
-#include <QFileDialog>
-#include <QRegularExpression>
-#include <QRegularExpressionValidator>
-#include <QStatusBar>
-#include <QSettings>
-#include <QTextDocument>
-#include <QListWidget>
-#include <QListWidgetItem>
-#include <boost/algorithm/string.hpp>
-#include "OctoPrintApiKeyDialog.h"
-#include "geometry/GeometryCache.h"
-#include "gui/AutoUpdater.h"
-#include "Feature.h"
-#include "core/Settings.h"
-#include "utils/printutils.h"
+#include <tuple>
+#include <unordered_map>
+#include <vector>
 #ifdef ENABLE_CGAL
 #include "geometry/cgal/CGALCache.h"
 #endif
 #include "glview/ColorMap.h"
 #include "glview/RenderSettings.h"
-#include "gui/QSettingsCached.h"
-#include "gui/SettingsWriter.h"
-#include "gui/OctoPrint.h"
 #include "gui/IgnoreWheelWhenNotFocused.h"
+#include "gui/OctoPrint.h"
 #include "gui/PrintService.h"
+#include "gui/QSettingsCached.h"
+#include "gui/SettingsWriter.h"
 
 #include <string>
 
-
 static const char *featurePropertyName = "FeatureProperty";
 
 using S = Settings::Settings;
 
 Q_DECLARE_METATYPE(Feature *);
 
-class SettingsReader : public Settings::SettingsVisitor
-{
+class SettingsReader : public Settings::SettingsVisitor {
   QSettingsCached settings;
 
-  void handle(Settings::SettingsEntryBase& entry) const override
-  {
+  void handle(Settings::SettingsEntryBase &entry) const override {
     if (settings.contains(QString::fromStdString(entry.key()))) {
-      std::string value = settings.value(QString::fromStdString(entry.key())).toString().toStdString();
+      std::string value = settings.value(QString::fromStdString(entry.key()))
+                              .toString()
+                              .toStdString();
       PRINTDB("SettingsReader R: %s = '%s'", entry.key() % value);
       entry.set(value);
     }
   }
 };
 
-Preferences::Preferences(QWidget *parent) : QMainWindow(parent)
-{
+Preferences::Preferences(QWidget *parent) : QMainWindow(parent) {
   setupUi(this);
 
   std::list<std::string> names = ColorMap::inst()->colorSchemeNames(true);
   QStringList renderColorSchemes;
-  for (const auto& name : names) renderColorSchemes << name.c_str();
+  for (const auto &name : names)
+    renderColorSchemes << name.c_str();
 
   syntaxHighlight->clear();
   colorSchemeChooser->clear();
@@ -143,15 +142,23 @@ void Preferences::init() {
 
   // Setup default settings
   this->defaultmap["advanced/opencsg_show_warning"] = true;
-  this->defaultmap["advanced/polysetCacheSize"] = qulonglong(GeometryCache::instance()->maxSizeMB()) * 1024ul * 1024ul;
-  this->defaultmap["advanced/polysetCacheSizeMB"] = getValue("advanced/polysetCacheSize").toULongLong() / (1024ul * 1024ul); // carry over old settings if they exist
-  this->defaultmap["advanced/cgalCacheSize"] = qulonglong(CGALCache::instance()->maxSizeMB()) * 1024ul * 1024ul;
-  this->defaultmap["advanced/cgalCacheSizeMB"] = getValue("advanced/cgalCacheSize").toULongLong() / (1024ul * 1024ul); // carry over old settings if they exist
-  this->defaultmap["advanced/openCSGLimit"] = RenderSettings::inst()->openCSGTermLimit;
+  this->defaultmap["advanced/polysetCacheSize"] =
+      qulonglong(GeometryCache::instance()->maxSizeMB()) * 1024ul * 1024ul;
+  this->defaultmap["advanced/polysetCacheSizeMB"] =
+      getValue("advanced/polysetCacheSize").toULongLong() /
+      (1024ul * 1024ul); // carry over old settings if they exist
+  this->defaultmap["advanced/cgalCacheSize"] =
+      qulonglong(CGALCache::instance()->maxSizeMB()) * 1024ul * 1024ul;
+  this->defaultmap["advanced/cgalCacheSizeMB"] =
+      getValue("advanced/cgalCacheSize").toULongLong() /
+      (1024ul * 1024ul); // carry over old settings if they exist
+  this->defaultmap["advanced/openCSGLimit"] =
+      RenderSettings::inst()->openCSGTermLimit;
   this->defaultmap["advanced/forceGoldfeather"] = false;
   this->defaultmap["advanced/undockableWindows"] = false;
   this->defaultmap["advanced/reorderWindows"] = true;
-  this->defaultmap["advanced/renderBackend3D"] = QString::fromStdString(renderBackend3DToString(RenderSettings::inst()->backend3D));
+  this->defaultmap["advanced/renderBackend3D"] = QString::fromStdString(
+      renderBackend3DToString(RenderSettings::inst()->backend3D));
   this->defaultmap["launcher/showOnStartup"] = true;
   this->defaultmap["advanced/localization"] = true;
   this->defaultmap["advanced/autoReloadRaise"] = false;
@@ -203,11 +210,15 @@ void Preferences::init() {
   this->defaultmap["3dview/colorscheme"] = "Cornfield";
 
   // Advanced pane
-  const int absolute_max = (sizeof(void *) == 8) ? 1024 * 1024 : 2048; // 1TB for 64bit or 2GB for 32bit
+  const int absolute_max = (sizeof(void *) == 8)
+                               ? 1024 * 1024
+                               : 2048; // 1TB for 64bit or 2GB for 32bit
   QValidator *memvalidator = new QIntValidator(1, absolute_max, this);
   auto *uintValidator = new QIntValidator(this);
   uintValidator->setBottom(0);
-  QValidator *validator1 = new QRegularExpressionValidator(QRegularExpression("[1-9][0-9]{0,1}"), this); // range between 1-99 both inclusive
+  QValidator *validator1 = new QRegularExpressionValidator(
+      QRegularExpression("[1-9][0-9]{0,1}"),
+      this); // range between 1-99 both inclusive
 #ifdef ENABLE_CGAL
   this->cgalCacheSizeMBEdit->setValidator(memvalidator);
 #endif
@@ -231,36 +242,65 @@ void Preferences::init() {
 
   initComboBox(this->comboBoxIndentUsing, Settings::Settings::indentStyle);
   initComboBox(this->comboBoxLineWrap, Settings::Settings::lineWrap);
-  initComboBox(this->comboBoxLineWrapIndentationStyle, Settings::Settings::lineWrapIndentationStyle);
-  initComboBox(this->comboBoxLineWrapVisualizationEnd, Settings::Settings::lineWrapVisualizationEnd);
-  initComboBox(this->comboBoxLineWrapVisualizationStart, Settings::Settings::lineWrapVisualizationBegin);
-  initComboBox(this->comboBoxShowWhitespace, Settings::Settings::showWhitespace);
-  initComboBox(this->comboBoxModifierNumberScrollWheel, Settings::Settings::modifierNumberScrollWheel);
-  initIntSpinBox(this->spinBoxIndentationWidth, Settings::Settings::indentationWidth);
-  initIntSpinBox(this->spinBoxLineWrapIndentationIndent, Settings::Settings::lineWrapIndentation);
-  initIntSpinBox(this->spinBoxShowWhitespaceSize, Settings::Settings::showWhitespaceSize);
+  initComboBox(this->comboBoxLineWrapIndentationStyle,
+               Settings::Settings::lineWrapIndentationStyle);
+  initComboBox(this->comboBoxLineWrapVisualizationEnd,
+               Settings::Settings::lineWrapVisualizationEnd);
+  initComboBox(this->comboBoxLineWrapVisualizationStart,
+               Settings::Settings::lineWrapVisualizationBegin);
+  initComboBox(this->comboBoxShowWhitespace,
+               Settings::Settings::showWhitespace);
+  initComboBox(this->comboBoxModifierNumberScrollWheel,
+               Settings::Settings::modifierNumberScrollWheel);
+  initIntSpinBox(this->spinBoxIndentationWidth,
+                 Settings::Settings::indentationWidth);
+  initIntSpinBox(this->spinBoxLineWrapIndentationIndent,
+                 Settings::Settings::lineWrapIndentation);
+  initIntSpinBox(this->spinBoxShowWhitespaceSize,
+                 Settings::Settings::showWhitespaceSize);
   initIntSpinBox(this->spinBoxTabWidth, Settings::Settings::tabWidth);
 
-  initComboBox(this->comboBoxOctoPrintFileFormat, Settings::Settings::octoPrintFileFormat);
-  initComboBox(this->comboBoxOctoPrintAction, Settings::Settings::octoPrintAction);
-  initComboBox(this->comboBoxLocalAppFileFormat, Settings::Settings::localAppFileFormat);
-  initComboBox(this->comboBoxRenderBackend3D, Settings::Settings::renderBackend3D);
-  initComboBox(this->comboBoxToolbarExport3D, Settings::Settings::toolbarExport3D);
-  initComboBox(this->comboBoxToolbarExport2D, Settings::Settings::toolbarExport2D);
-
-  initListBox(this->listWidgetLocalAppParams, Settings::Settings::localAppParameterList);
-  connect(this->listWidgetLocalAppParams->model(), &QAbstractItemModel::dataChanged, this, &Preferences::listWidgetLocalAppParamsModelDataChanged);
-  connect(this->listWidgetLocalAppParams->model(), &QAbstractItemModel::rowsInserted, this, &Preferences::listWidgetLocalAppParamsModelDataChanged);
-  connect(this->listWidgetLocalAppParams->model(), &QAbstractItemModel::rowsRemoved, this, &Preferences::listWidgetLocalAppParamsModelDataChanged);
+  initComboBox(this->comboBoxOctoPrintFileFormat,
+               Settings::Settings::octoPrintFileFormat);
+  initComboBox(this->comboBoxOctoPrintAction,
+               Settings::Settings::octoPrintAction);
+  initComboBox(this->comboBoxLocalAppFileFormat,
+               Settings::Settings::localAppFileFormat);
+  initComboBox(this->comboBoxRenderBackend3D,
+               Settings::Settings::renderBackend3D);
+  initComboBox(this->comboBoxToolbarExport3D,
+               Settings::Settings::toolbarExport3D);
+  initComboBox(this->comboBoxToolbarExport2D,
+               Settings::Settings::toolbarExport2D);
+
+  initListBox(this->listWidgetLocalAppParams,
+              Settings::Settings::localAppParameterList);
+  connect(this->listWidgetLocalAppParams->model(),
+          &QAbstractItemModel::dataChanged, this,
+          &Preferences::listWidgetLocalAppParamsModelDataChanged);
+  connect(this->listWidgetLocalAppParams->model(),
+          &QAbstractItemModel::rowsInserted, this,
+          &Preferences::listWidgetLocalAppParamsModelDataChanged);
+  connect(this->listWidgetLocalAppParams->model(),
+          &QAbstractItemModel::rowsRemoved, this,
+          &Preferences::listWidgetLocalAppParamsModelDataChanged);
 
   installIgnoreWheelWhenNotFocused(this);
 
-  const QString slicer = QString::fromStdString(Settings::Settings::octoPrintSlicerEngine.value());
-  const QString slicerDesc = QString::fromStdString(Settings::Settings::octoPrintSlicerEngineDesc.value());
-  const QString profile = QString::fromStdString(Settings::Settings::octoPrintSlicerProfile.value());
-  const QString profileDesc = QString::fromStdString(Settings::Settings::octoPrintSlicerProfileDesc.value());
-  BlockSignals<QLineEdit *>(this->lineEditLocalAppExecutable)->setText(QString::fromStdString(Settings::Settings::localAppExecutable.value()));
-  BlockSignals<QLineEdit *>(this->lineEditLocalAppTempDir)->setText(QString::fromStdString(Settings::Settings::localAppTempDir.value()));
+  const QString slicer =
+      QString::fromStdString(Settings::Settings::octoPrintSlicerEngine.value());
+  const QString slicerDesc = QString::fromStdString(
+      Settings::Settings::octoPrintSlicerEngineDesc.value());
+  const QString profile = QString::fromStdString(
+      Settings::Settings::octoPrintSlicerProfile.value());
+  const QString profileDesc = QString::fromStdString(
+      Settings::Settings::octoPrintSlicerProfileDesc.value());
+  BlockSignals<QLineEdit *>(this->lineEditLocalAppExecutable)
+      ->setText(QString::fromStdString(
+          Settings::Settings::localAppExecutable.value()));
+  BlockSignals<QLineEdit *>(this->lineEditLocalAppTempDir)
+      ->setText(
+          QString::fromStdString(Settings::Settings::localAppTempDir.value()));
   this->comboBoxOctoPrintSlicingEngine->clear();
   this->comboBoxOctoPrintSlicingEngine->addItem(_("<Default>"), QVariant{""});
   if (!slicer.isEmpty()) {
@@ -269,22 +309,22 @@ void Preferences::init() {
   this->comboBoxOctoPrintSlicingProfile->clear();
   this->comboBoxOctoPrintSlicingProfile->addItem(_("<Default>"), QVariant{""});
   if (!profile.isEmpty()) {
-    this->comboBoxOctoPrintSlicingProfile->addItem(profileDesc, QVariant{profile});
+    this->comboBoxOctoPrintSlicingProfile->addItem(profileDesc,
+                                                   QVariant{profile});
   }
 
   emit editorConfigChanged();
 }
 
-Preferences::~Preferences()
-{
-  removeDefaultSettings();
-}
+Preferences::~Preferences() { removeDefaultSettings(); }
 
-void Preferences::update()
-{
-  this->checkBoxAlwaysShowExportPdfDialog->setChecked(Settings::SettingsExportPdf::exportPdfAlwaysShowDialog.value());
-  this->checkBoxAlwaysShowExport3mfDialog->setChecked(Settings::SettingsExport3mf::export3mfAlwaysShowDialog.value());
-  this->checkBoxAlwaysShowPrintServiceDialog->setChecked(Settings::Settings::printServiceAlwaysShowDialog.value());
+void Preferences::update() {
+  this->checkBoxAlwaysShowExportPdfDialog->setChecked(
+      Settings::SettingsExportPdf::exportPdfAlwaysShowDialog.value());
+  this->checkBoxAlwaysShowExport3mfDialog->setChecked(
+      Settings::SettingsExport3mf::export3mfAlwaysShowDialog.value());
+  this->checkBoxAlwaysShowPrintServiceDialog->setChecked(
+      Settings::Settings::printServiceAlwaysShowDialog.value());
 }
 
 /**
@@ -298,8 +338,8 @@ void Preferences::update()
  * @param widget The widget that should be shown when the action is triggered.
  *               This must be a child page of the stackedWidget.
  */
-void Preferences::addPrefPage(QActionGroup *group, QAction *action, QWidget *widget)
-{
+void Preferences::addPrefPage(QActionGroup *group, QAction *action,
+                              QWidget *widget) {
   group->addAction(action);
   prefPages[action] = widget;
 }
@@ -309,8 +349,7 @@ void Preferences::addPrefPage(QActionGroup *group, QAction *action, QWidget *wid
  *
  * @param action The action triggered by the user.
  */
-void Preferences::actionTriggered(QAction *action)
-{
+void Preferences::actionTriggered(QAction *action) {
   this->stackedWidget->setCurrentWidget(prefPages[action]);
 }
 
@@ -318,14 +357,13 @@ void Preferences::actionTriggered(QAction *action)
  * Called at least on showing / closing the Preferences dialog
  * and when switching tabs.
  */
-void Preferences::hidePasswords()
-{
+void Preferences::hidePasswords() {
   this->pushButtonOctoPrintApiKey->setChecked(false);
-  this->lineEditOctoPrintApiKey->setEchoMode(QLineEdit::EchoMode::PasswordEchoOnEdit);
+  this->lineEditOctoPrintApiKey->setEchoMode(
+      QLineEdit::EchoMode::PasswordEchoOnEdit);
 }
 
-void Preferences::on_stackedWidget_currentChanged(int)
-{
+void Preferences::on_stackedWidget_currentChanged(int) {
   hidePasswords();
   this->labelOctoPrintCheckConnection->setText("");
   this->AxisConfig->updateStates();
@@ -339,8 +377,7 @@ void Preferences::on_stackedWidget_currentChanged(int)
  *
  * @param state the state of the checkbox.
  */
-void Preferences::featuresCheckBoxToggled(bool state)
-{
+void Preferences::featuresCheckBoxToggled(bool state) {
   const QObject *sender = QObject::sender();
   if (sender == nullptr) {
     return;
@@ -352,7 +389,9 @@ void Preferences::featuresCheckBoxToggled(bool state)
   auto *feature = v.value<Feature *>();
   feature->enable(state);
   QSettingsCached settings;
-  settings.setValue(QString("feature/%1").arg(QString::fromStdString(feature->get_name())), state);
+  settings.setValue(
+      QString("feature/%1").arg(QString::fromStdString(feature->get_name())),
+      state);
   emit ExperimentalChanged();
 }
 
@@ -363,20 +402,23 @@ void Preferences::featuresCheckBoxToggled(bool state)
  * from commandline is ignored. This always uses the value coming from the
  * QSettings.
  */
-void Preferences::setupFeaturesPage()
-{
+void Preferences::setupFeaturesPage() {
   int row = 0;
   for (auto it = Feature::begin(); it != Feature::end(); ++it) {
     Feature *feature = *it;
 
-    QString featurekey = QString("feature/%1").arg(QString::fromStdString(feature->get_name()));
+    QString featurekey =
+        QString("feature/%1").arg(QString::fromStdString(feature->get_name()));
     this->defaultmap[featurekey] = false;
 
     // spacer item between the features, just for some optical separation
-    gridLayoutExperimentalFeatures->addItem(new QSpacerItem(1, 8, QSizePolicy::Expanding, QSizePolicy::Fixed), row, 1, 1, 1, Qt::AlignCenter);
+    gridLayoutExperimentalFeatures->addItem(
+        new QSpacerItem(1, 8, QSizePolicy::Expanding, QSizePolicy::Fixed), row,
+        1, 1, 1, Qt::AlignCenter);
     row++;
 
-    auto *cb = new QCheckBox(QString::fromStdString(feature->get_name()), pageFeatures);
+    auto *cb = new QCheckBox(QString::fromStdString(feature->get_name()),
+                             pageFeatures);
     QFont bold_font(cb->font());
     bold_font.setBold(true);
     cb->setFont(bold_font);
@@ -384,46 +426,56 @@ void Preferences::setupFeaturesPage()
     bool value = getValue(featurekey).toBool();
     feature->enable(value);
     cb->setChecked(value);
-    cb->setProperty(featurePropertyName, QVariant::fromValue<Feature *>(feature));
-    connect(cb, &QCheckBox::toggled, this, &Preferences::featuresCheckBoxToggled);
-    gridLayoutExperimentalFeatures->addWidget(cb, row, 0, 1, 2, Qt::AlignLeading);
+    cb->setProperty(featurePropertyName,
+                    QVariant::fromValue<Feature *>(feature));
+    connect(cb, &QCheckBox::toggled, this,
+            &Preferences::featuresCheckBoxToggled);
+    gridLayoutExperimentalFeatures->addWidget(cb, row, 0, 1, 2,
+                                              Qt::AlignLeading);
     row++;
 
-    auto *l = new QLabel(QString::fromStdString(feature->get_description()), pageFeatures);
+    auto *l = new QLabel(QString::fromStdString(feature->get_description()),
+                         pageFeatures);
     l->setTextFormat(Qt::RichText);
-    gridLayoutExperimentalFeatures->addWidget(l, row, 1, 1, 1, Qt::AlignLeading);
+    gridLayoutExperimentalFeatures->addWidget(l, row, 1, 1, 1,
+                                              Qt::AlignLeading);
     row++;
   }
   // Force fixed indentation, the checkboxes use column span of 2 so
   // first row is not constrained in size by the visible controls. The
   // fixed size space essentially gives the first row the width of the
   // spacer item itself.
-  gridLayoutExperimentalFeatures->addItem(new QSpacerItem(20, 0, QSizePolicy::Fixed, QSizePolicy::Fixed), 1, 0, 1, 1, Qt::AlignLeading);
-}
-
-void Preferences::setup3DPrintPage()
-{
-  const auto& currentPrintService = Settings::Settings::defaultPrintService.value();
-  const auto currentPrintServiceName = QString::fromStdString(Settings::Settings::printServiceName.value());
-  checkBoxEnableRemotePrintServices->setChecked(Settings::Settings::enableRemotePrintServices.value());
+  gridLayoutExperimentalFeatures->addItem(
+      new QSpacerItem(20, 0, QSizePolicy::Fixed, QSizePolicy::Fixed), 1, 0, 1,
+      1, Qt::AlignLeading);
+}
+
+void Preferences::setup3DPrintPage() {
+  const auto &currentPrintService =
+      Settings::Settings::defaultPrintService.value();
+  const auto currentPrintServiceName =
+      QString::fromStdString(Settings::Settings::printServiceName.value());
+  checkBoxEnableRemotePrintServices->setChecked(
+      Settings::Settings::enableRemotePrintServices.value());
   comboBoxDefaultPrintService->clear();
   const std::unordered_map<std::string, QString> services = {
-    {"NONE", _("NONE")},
-    {"OCTOPRINT", _("OctoPrint")},
-    {"LOCAL_APPLICATION", _("Local Application")},
+      {"NONE", _("NONE")},
+      {"OCTOPRINT", _("OctoPrint")},
+      {"LOCAL_APPLICATION", _("Local Application")},
   };
 
   comboBoxDefaultPrintService->addItem(services.at("NONE"),
                                        QStringList{"NONE", ""});
-  for (const auto& printServiceItem : PrintService::getPrintServices()) {
-    const auto& key = printServiceItem.first;
-    const auto& printService = printServiceItem.second;
-    const auto settingValue = QStringList{"PRINT_SERVICE", QString::fromStdString(key)};
+  for (const auto &printServiceItem : PrintService::getPrintServices()) {
+    const auto &key = printServiceItem.first;
+    const auto &printService = printServiceItem.second;
+    const auto settingValue =
+        QStringList{"PRINT_SERVICE", QString::fromStdString(key)};
     const auto displayName = QString(printService->getDisplayName());
     comboBoxDefaultPrintService->addItem(displayName, settingValue);
     if (key == currentPrintServiceName.toStdString()) {
       comboBoxDefaultPrintService->setCurrentText(
-        QString(printService->getDisplayName()));
+          QString(printService->getDisplayName()));
     }
   }
   comboBoxDefaultPrintService->addItem(services.at("OCTOPRINT"),
@@ -437,45 +489,40 @@ void Preferences::setup3DPrintPage()
   }
 }
 
-void Preferences::on_colorSchemeChooser_itemSelectionChanged()
-{
+void Preferences::on_colorSchemeChooser_itemSelectionChanged() {
   QString scheme = this->colorSchemeChooser->currentItem()->text();
   QSettingsCached settings;
   settings.setValue("3dview/colorscheme", scheme);
   emit colorSchemeChanged(scheme);
 }
 
-void Preferences::on_fontChooser_currentFontChanged(const QFont& font)
-{
+void Preferences::on_fontChooser_currentFontChanged(const QFont &font) {
   QSettingsCached settings;
   settings.setValue("editor/fontfamily", font.family());
   emit fontChanged(font.family(), getValue("editor/fontsize").toUInt());
 }
 
-void Preferences::on_fontSize_currentIndexChanged(int index)
-{
+void Preferences::on_fontSize_currentIndexChanged(int index) {
   uint intsize = this->fontSize->itemText(index).toUInt();
   QSettingsCached settings;
   settings.setValue("editor/fontsize", intsize);
   emit fontChanged(getValue("editor/fontfamily").toString(), intsize);
 }
 
-void Preferences::on_syntaxHighlight_currentTextChanged(const QString& s)
-{
+void Preferences::on_syntaxHighlight_currentTextChanged(const QString &s) {
   QSettingsCached settings;
   settings.setValue("editor/syntaxhighlight", s);
   emit syntaxHighlightChanged(s);
 }
 
-void unimplemented_msg()
-{
+void unimplemented_msg() {
   QMessageBox mbox;
-  mbox.setText("Sorry, this feature is not implemented on your Operating System");
+  mbox.setText(
+      "Sorry, this feature is not implemented on your Operating System");
   mbox.exec();
 }
 
-void Preferences::on_updateCheckBox_toggled(bool on)
-{
+void Preferences::on_updateCheckBox_toggled(bool on) {
   if (AutoUpdater *updater = AutoUpdater::updater()) {
     updater->setAutomaticallyChecksForUpdates(on);
   } else {
@@ -483,8 +530,7 @@ void Preferences::on_updateCheckBox_toggled(bool on)
   }
 }
 
-void Preferences::on_snapshotCheckBox_toggled(bool on)
-{
+void Preferences::on_snapshotCheckBox_toggled(bool on) {
   if (AutoUpdater *updater = AutoUpdater::updater()) {
     updater->setEnableSnapshots(on);
   } else {
@@ -492,8 +538,7 @@ void Preferences::on_snapshotCheckBox_toggled(bool on)
   }
 }
 
-void Preferences::on_checkNowButton_clicked()
-{
+void Preferences::on_checkNowButton_clicked() {
   if (AutoUpdater *updater = AutoUpdater::updater()) {
     updater->checkForUpdates();
   } else {
@@ -501,9 +546,7 @@ void Preferences::on_checkNowButton_clicked()
   }
 }
 
-void
-Preferences::on_reorderCheckBox_toggled(bool state)
-{
+void Preferences::on_reorderCheckBox_toggled(bool state) {
   if (!state) {
     undockCheckBox->setChecked(false);
   }
@@ -513,194 +556,169 @@ Preferences::on_reorderCheckBox_toggled(bool state)
   emit updateReorderMode(state);
 }
 
-void
-Preferences::on_undockCheckBox_toggled(bool state)
-{
+void Preferences::on_undockCheckBox_toggled(bool state) {
   QSettingsCached settings;
   settings.setValue("advanced/undockableWindows", state);
   emit updateUndockMode(state);
 }
 
-void
-Preferences::on_openCSGWarningBox_toggled(bool state)
-{
+void Preferences::on_openCSGWarningBox_toggled(bool state) {
   QSettingsCached settings;
   settings.setValue("advanced/opencsg_show_warning", state);
 }
 
-void Preferences::on_cgalCacheSizeMBEdit_textChanged(const QString& text)
-{
+void Preferences::on_cgalCacheSizeMBEdit_textChanged(const QString &text) {
   QSettingsCached settings;
   settings.setValue("advanced/cgalCacheSizeMB", text);
   CGALCache::instance()->setMaxSizeMB(text.toULong());
 }
 
-void Preferences::on_polysetCacheSizeMBEdit_textChanged(const QString& text)
-{
+void Preferences::on_polysetCacheSizeMBEdit_textChanged(const QString &text) {
   QSettingsCached settings;
   settings.setValue("advanced/polysetCacheSizeMB", text);
   GeometryCache::instance()->setMaxSizeMB(text.toULong());
 }
 
-void Preferences::on_opencsgLimitEdit_textChanged(const QString& text)
-{
+void Preferences::on_opencsgLimitEdit_textChanged(const QString &text) {
   QSettingsCached settings;
   settings.setValue("advanced/openCSGLimit", text);
   // FIXME: Set this globally?
 }
 
-void Preferences::on_localizationCheckBox_toggled(bool state)
-{
+void Preferences::on_localizationCheckBox_toggled(bool state) {
   QSettingsCached settings;
   settings.setValue("advanced/localization", state);
 }
 
-void Preferences::on_autoReloadRaiseCheckBox_toggled(bool state)
-{
+void Preferences::on_autoReloadRaiseCheckBox_toggled(bool state) {
   QSettingsCached settings;
   settings.setValue("advanced/autoReloadRaise", state);
 }
 
-void Preferences::on_forceGoldfeatherBox_toggled(bool state)
-{
+void Preferences::on_forceGoldfeatherBox_toggled(bool state) {
   QSettingsCached settings;
   settings.setValue("advanced/forceGoldfeather", state);
   emit openCSGSettingsChanged();
 }
 
-void Preferences::on_mouseWheelZoomBox_toggled(bool state)
-{
+void Preferences::on_mouseWheelZoomBox_toggled(bool state) {
   QSettingsCached settings;
   settings.setValue("editor/ctrlmousewheelzoom", state);
 }
 
-void Preferences::on_launcherBox_toggled(bool state)
-{
+void Preferences::on_launcherBox_toggled(bool state) {
   QSettingsCached settings;
   settings.setValue("launcher/showOnStartup", state);
 }
 
-void Preferences::on_checkBoxShowWarningsIn3dView_toggled(bool val)
-{
+void Preferences::on_checkBoxShowWarningsIn3dView_toggled(bool val) {
   Settings::Settings::showWarningsIn3dView.setValue(val);
   writeSettings();
 }
 
-void Preferences::on_checkBoxMouseCentricZoom_toggled(bool val)
-{
+void Preferences::on_checkBoxMouseCentricZoom_toggled(bool val) {
   Settings::Settings::mouseCentricZoom.setValue(val);
   writeSettings();
   emit updateMouseCentricZoom(val);
 }
 
-void Preferences::on_checkBoxMouseSwapButtons_toggled(bool val)
-{
+void Preferences::on_checkBoxMouseSwapButtons_toggled(bool val) {
   Settings::Settings::mouseSwapButtons.setValue(val);
   writeSettings();
   emit updateMouseSwapButtons(val);
 }
 
-void Preferences::on_spinBoxIndentationWidth_valueChanged(int val)
-{
+void Preferences::on_spinBoxIndentationWidth_valueChanged(int val) {
   Settings::Settings::indentationWidth.setValue(val);
   writeSettings();
 }
 
-void Preferences::on_spinBoxTabWidth_valueChanged(int val)
-{
+void Preferences::on_spinBoxTabWidth_valueChanged(int val) {
   Settings::Settings::tabWidth.setValue(val);
   writeSettings();
 }
 
-void Preferences::on_comboBoxLineWrap_activated(int val)
-{
+void Preferences::on_comboBoxLineWrap_activated(int val) {
   applyComboBox(comboBoxLineWrap, val, Settings::Settings::lineWrap);
 }
 
-void Preferences::on_comboBoxLineWrapIndentationStyle_activated(int val)
-{
-  //Next Line disables the Indent Spin-Box when 'Same' or 'Indented' is chosen from LineWrapIndentationStyle Combo-Box.
-  spinBoxLineWrapIndentationIndent->setDisabled(comboBoxLineWrapIndentationStyle->currentData() == "Same" || comboBoxLineWrapIndentationStyle->currentData() == "Indented");
+void Preferences::on_comboBoxLineWrapIndentationStyle_activated(int val) {
+  // Next Line disables the Indent Spin-Box when 'Same' or 'Indented' is chosen
+  // from LineWrapIndentationStyle Combo-Box.
+  spinBoxLineWrapIndentationIndent->setDisabled(
+      comboBoxLineWrapIndentationStyle->currentData() == "Same" ||
+      comboBoxLineWrapIndentationStyle->currentData() == "Indented");
 
-  applyComboBox(comboBoxLineWrapIndentationStyle, val, Settings::Settings::lineWrapIndentationStyle);
+  applyComboBox(comboBoxLineWrapIndentationStyle, val,
+                Settings::Settings::lineWrapIndentationStyle);
 }
 
-void Preferences::on_spinBoxLineWrapIndentationIndent_valueChanged(int val)
-{
+void Preferences::on_spinBoxLineWrapIndentationIndent_valueChanged(int val) {
   Settings::Settings::lineWrapIndentation.setValue(val);
   writeSettings();
 }
 
-void Preferences::on_comboBoxLineWrapVisualizationStart_activated(int val)
-{
-  applyComboBox(comboBoxLineWrapVisualizationStart, val, Settings::Settings::lineWrapVisualizationBegin);
+void Preferences::on_comboBoxLineWrapVisualizationStart_activated(int val) {
+  applyComboBox(comboBoxLineWrapVisualizationStart, val,
+                Settings::Settings::lineWrapVisualizationBegin);
 }
 
-void Preferences::on_comboBoxLineWrapVisualizationEnd_activated(int val)
-{
-  applyComboBox(comboBoxLineWrapVisualizationEnd, val, Settings::Settings::lineWrapVisualizationEnd);
+void Preferences::on_comboBoxLineWrapVisualizationEnd_activated(int val) {
+  applyComboBox(comboBoxLineWrapVisualizationEnd, val,
+                Settings::Settings::lineWrapVisualizationEnd);
 }
 
-void Preferences::on_comboBoxShowWhitespace_activated(int val)
-{
-  applyComboBox(comboBoxShowWhitespace, val, Settings::Settings::showWhitespace);
+void Preferences::on_comboBoxShowWhitespace_activated(int val) {
+  applyComboBox(comboBoxShowWhitespace, val,
+                Settings::Settings::showWhitespace);
 }
 
-void Preferences::on_spinBoxShowWhitespaceSize_valueChanged(int val)
-{
+void Preferences::on_spinBoxShowWhitespaceSize_valueChanged(int val) {
   Settings::Settings::showWhitespaceSize.setValue(val);
   writeSettings();
 }
 
-void Preferences::on_checkBoxAutoIndent_toggled(bool val)
-{
+void Preferences::on_checkBoxAutoIndent_toggled(bool val) {
   Settings::Settings::autoIndent.setValue(val);
   writeSettings();
 }
 
-void Preferences::on_checkBoxBackspaceUnindents_toggled(bool val)
-{
+void Preferences::on_checkBoxBackspaceUnindents_toggled(bool val) {
   Settings::Settings::backspaceUnindents.setValue(val);
   writeSettings();
 }
 
-void Preferences::on_comboBoxIndentUsing_activated(int val)
-{
+void Preferences::on_comboBoxIndentUsing_activated(int val) {
   applyComboBox(comboBoxIndentUsing, val, Settings::Settings::indentStyle);
 }
 
-void Preferences::on_comboBoxTabKeyFunction_activated(int val)
-{
-  applyComboBox(comboBoxTabKeyFunction, val, Settings::Settings::tabKeyFunction);
+void Preferences::on_comboBoxTabKeyFunction_activated(int val) {
+  applyComboBox(comboBoxTabKeyFunction, val,
+                Settings::Settings::tabKeyFunction);
 }
 
-void Preferences::on_checkBoxHighlightCurrentLine_toggled(bool val)
-{
+void Preferences::on_checkBoxHighlightCurrentLine_toggled(bool val) {
   Settings::Settings::highlightCurrentLine.setValue(val);
   writeSettings();
 }
 
-void Preferences::on_checkBoxEnableBraceMatching_toggled(bool val)
-{
+void Preferences::on_checkBoxEnableBraceMatching_toggled(bool val) {
   Settings::Settings::enableBraceMatching.setValue(val);
   writeSettings();
 }
 
-void Preferences::on_checkBoxEnableLineNumbers_toggled(bool val)
-{
+void Preferences::on_checkBoxEnableLineNumbers_toggled(bool val) {
   Settings::Settings::enableLineNumbers.setValue(val);
   writeSettings();
 }
 
-void Preferences::on_checkBoxEnableNumberScrollWheel_toggled(bool val)
-{
+void Preferences::on_checkBoxEnableNumberScrollWheel_toggled(bool val) {
   Settings::Settings::enableNumberScrollWheel.setValue(val);
   comboBoxModifierNumberScrollWheel->setDisabled(!val);
   writeSettings();
 }
 
-void Preferences::on_enableSoundOnRenderCompleteCheckBox_toggled(bool state)
-{
+void Preferences::on_enableSoundOnRenderCompleteCheckBox_toggled(bool state) {
   QSettingsCached settings;
   settings.setValue("advanced/enableSoundNotification", state);
   this->timeThresholdOnRenderCompleteSoundLabel->setEnabled(state);
@@ -708,56 +726,54 @@ void Preferences::on_enableSoundOnRenderCompleteCheckBox_toggled(bool state)
   this->timeThresholdOnRenderCompleteSoundEdit->setEnabled(state);
 }
 
-void Preferences::on_timeThresholdOnRenderCompleteSoundEdit_textChanged(const QString& text)
-{
+void Preferences::on_timeThresholdOnRenderCompleteSoundEdit_textChanged(
+    const QString &text) {
   QSettingsCached settings;
   settings.setValue("advanced/timeThresholdOnRenderCompleteSound", text);
 }
 
-void Preferences::on_enableClearConsoleCheckBox_toggled(bool state)
-{
+void Preferences::on_enableClearConsoleCheckBox_toggled(bool state) {
   QSettingsCached settings;
   settings.setValue("advanced/consoleAutoClear", state);
 }
 
-void Preferences::on_consoleMaxLinesEdit_textChanged(const QString& text)
-{
+void Preferences::on_consoleMaxLinesEdit_textChanged(const QString &text) {
   QSettingsCached settings;
   settings.setValue("advanced/consoleMaxLines", text);
 }
 
-void Preferences::on_consoleFontChooser_currentFontChanged(const QFont& font)
-{
+void Preferences::on_consoleFontChooser_currentFontChanged(const QFont &font) {
   QSettingsCached settings;
   settings.setValue("advanced/consoleFontFamily", font.family());
-  emit consoleFontChanged(font.family(), getValue("advanced/consoleFontSize").toUInt());
+  emit consoleFontChanged(font.family(),
+                          getValue("advanced/consoleFontSize").toUInt());
 }
 
-void Preferences::on_consoleFontSize_currentIndexChanged(int index)
-{
+void Preferences::on_consoleFontSize_currentIndexChanged(int index) {
   uint intsize = this->consoleFontSize->itemText(index).toUInt();
   QSettingsCached settings;
   settings.setValue("advanced/consoleFontSize", intsize);
-  emit consoleFontChanged(getValue("advanced/consoleFontFamily").toString(), intsize);
+  emit consoleFontChanged(getValue("advanced/consoleFontFamily").toString(),
+                          intsize);
 }
 
-void Preferences::on_customizerFontChooser_currentFontChanged(const QFont& font)
-{
+void Preferences::on_customizerFontChooser_currentFontChanged(
+    const QFont &font) {
   QSettingsCached settings;
   settings.setValue("advanced/customizerFontFamily", font.family());
-  emit customizerFontChanged(font.family(), getValue("advanced/customizerFontSize").toUInt());
+  emit customizerFontChanged(font.family(),
+                             getValue("advanced/customizerFontSize").toUInt());
 }
 
-void Preferences::on_customizerFontSize_currentIndexChanged(int index)
-{
+void Preferences::on_customizerFontSize_currentIndexChanged(int index) {
   uint intsize = this->customizerFontSize->itemText(index).toUInt();
   QSettingsCached settings;
   settings.setValue("advanced/customizerFontSize", intsize);
-  emit customizerFontChanged(getValue("advanced/customizerFontFamily").toString(), intsize);
+  emit customizerFontChanged(
+      getValue("advanced/customizerFontFamily").toString(), intsize);
 }
 
-void Preferences::on_checkBoxEnableAutocomplete_toggled(bool state)
-{
+void Preferences::on_checkBoxEnableAutocomplete_toggled(bool state) {
   QSettingsCached settings;
   settings.setValue("editor/enableAutocomplete", state);
   this->labelCharacterThreshold->setEnabled(state);
@@ -765,166 +781,158 @@ void Preferences::on_checkBoxEnableAutocomplete_toggled(bool state)
   emit autocompleteChanged(state);
 }
 
-void Preferences::on_lineEditCharacterThreshold_textChanged(const QString& text)
-{
+void Preferences::on_lineEditCharacterThreshold_textChanged(
+    const QString &text) {
   QSettingsCached settings;
   settings.setValue("editor/characterThreshold", text);
   emit characterThresholdChanged(text.toInt());
 }
 
-void Preferences::on_lineEditStepSize_textChanged(const QString& text)
-{
+void Preferences::on_lineEditStepSize_textChanged(const QString &text) {
   QSettingsCached settings;
   settings.setValue("editor/stepSize", text);
   emit stepSizeChanged(text.toInt());
 }
 
-void Preferences::on_comboBoxModifierNumberScrollWheel_activated(int val)
-{
-  applyComboBox(comboBoxModifierNumberScrollWheel, val, Settings::Settings::modifierNumberScrollWheel);
+void Preferences::on_comboBoxModifierNumberScrollWheel_activated(int val) {
+  applyComboBox(comboBoxModifierNumberScrollWheel, val,
+                Settings::Settings::modifierNumberScrollWheel);
 }
 
-void Preferences::on_enableHardwarningsCheckBox_toggled(bool state)
-{
+void Preferences::on_enableHardwarningsCheckBox_toggled(bool state) {
   QSettingsCached settings;
   settings.setValue("advanced/enableHardwarnings", state);
 }
 
-void Preferences::on_traceDepthEdit_textChanged(const QString& text)
-{
+void Preferences::on_traceDepthEdit_textChanged(const QString &text) {
   QSettingsCached settings;
   settings.setValue("advanced/traceDepth", text);
 }
 
-void Preferences::on_enableTraceUsermoduleParametersCheckBox_toggled(bool state)
-{
+void Preferences::on_enableTraceUsermoduleParametersCheckBox_toggled(
+    bool state) {
   QSettingsCached settings;
   settings.setValue("advanced/enableTraceUsermoduleParameters", state);
 }
 
-void Preferences::on_enableParameterCheckBox_toggled(bool state)
-{
+void Preferences::on_enableParameterCheckBox_toggled(bool state) {
   QSettingsCached settings;
   settings.setValue("advanced/enableParameterCheck", state);
 }
 
-void Preferences::on_enableRangeCheckBox_toggled(bool state)
-{
+void Preferences::on_enableRangeCheckBox_toggled(bool state) {
   QSettingsCached settings;
   settings.setValue("advanced/enableParameterRangeCheck", state);
 }
 
-void
-Preferences::on_comboBoxRenderBackend3D_activated(int val)
-{
-  applyComboBox(this->comboBoxRenderBackend3D, val, Settings::Settings::renderBackend3D);
+void Preferences::on_comboBoxRenderBackend3D_activated(int val) {
+  applyComboBox(this->comboBoxRenderBackend3D, val,
+                Settings::Settings::renderBackend3D);
   RenderSettings::inst()->backend3D =
-    renderBackend3DFromString(Settings::Settings::renderBackend3D.value());
+      renderBackend3DFromString(Settings::Settings::renderBackend3D.value());
 }
 
-void Preferences::on_comboBoxToolbarExport3D_activated(int val)
-{
-  applyComboBox(this->comboBoxToolbarExport3D, val, Settings::Settings::toolbarExport3D);
+void Preferences::on_comboBoxToolbarExport3D_activated(int val) {
+  applyComboBox(this->comboBoxToolbarExport3D, val,
+                Settings::Settings::toolbarExport3D);
   emit toolbarExportChanged();
 }
 
-void Preferences::on_comboBoxToolbarExport2D_activated(int val)
-{
-  applyComboBox(this->comboBoxToolbarExport2D, val, Settings::Settings::toolbarExport2D);
+void Preferences::on_comboBoxToolbarExport2D_activated(int val) {
+  applyComboBox(this->comboBoxToolbarExport2D, val,
+                Settings::Settings::toolbarExport2D);
   emit toolbarExportChanged();
 }
 
-void Preferences::on_checkBoxSummaryCamera_toggled(bool checked)
-{
+void Preferences::on_checkBoxSummaryCamera_toggled(bool checked) {
   Settings::Settings::summaryCamera.setValue(checked);
   writeSettings();
 }
 
-void Preferences::on_checkBoxSummaryArea_toggled(bool checked)
-{
+void Preferences::on_checkBoxSummaryArea_toggled(bool checked) {
   Settings::Settings::summaryArea.setValue(checked);
   writeSettings();
 }
 
-void Preferences::on_checkBoxSummaryBoundingBox_toggled(bool checked)
-{
+void Preferences::on_checkBoxSummaryBoundingBox_toggled(bool checked) {
   Settings::Settings::summaryBoundingBox.setValue(checked);
   writeSettings();
 }
 
-void Preferences::on_enableHidapiTraceCheckBox_toggled(bool checked)
-{
+void Preferences::on_enableHidapiTraceCheckBox_toggled(bool checked) {
   Settings::Settings::inputEnableDriverHIDAPILog.setValue(checked);
   writeSettings();
 }
 
-void Preferences::on_checkBoxEnableRemotePrintServices_toggled(bool checked)
-{
+void Preferences::on_checkBoxEnableRemotePrintServices_toggled(bool checked) {
   S::enableRemotePrintServices.setValue(checked);
   writeSettings();
 }
 
-void Preferences::on_comboBoxDefaultPrintService_activated(int)
-{
-  QStringList currentPrintServiceList = comboBoxDefaultPrintService->currentData().toStringList();
-  Settings::Settings::defaultPrintService.setValue(currentPrintServiceList[0].toStdString());
-  Settings::Settings::printServiceName.setValue(currentPrintServiceList[1].toStdString());
+void Preferences::on_comboBoxDefaultPrintService_activated(int) {
+  QStringList currentPrintServiceList =
+      comboBoxDefaultPrintService->currentData().toStringList();
+  Settings::Settings::defaultPrintService.setValue(
+      currentPrintServiceList[0].toStdString());
+  Settings::Settings::printServiceName.setValue(
+      currentPrintServiceList[1].toStdString());
   writeSettings();
 }
 
-void Preferences::on_comboBoxOctoPrintAction_activated(int val)
-{
-  applyComboBox(comboBoxOctoPrintAction, val, Settings::Settings::octoPrintAction);
+void Preferences::on_comboBoxOctoPrintAction_activated(int val) {
+  applyComboBox(comboBoxOctoPrintAction, val,
+                Settings::Settings::octoPrintAction);
 }
 
-void Preferences::on_lineEditOctoPrintURL_editingFinished()
-{
-  Settings::Settings::octoPrintUrl.setValue(this->lineEditOctoPrintURL->text().toStdString());
+void Preferences::on_lineEditOctoPrintURL_editingFinished() {
+  Settings::Settings::octoPrintUrl.setValue(
+      this->lineEditOctoPrintURL->text().toStdString());
   writeSettings();
 }
 
-void Preferences::on_lineEditOctoPrintApiKey_editingFinished()
-{
-  Settings::Settings::octoPrintApiKey.setValue(this->lineEditOctoPrintApiKey->text().toStdString());
+void Preferences::on_lineEditOctoPrintApiKey_editingFinished() {
+  Settings::Settings::octoPrintApiKey.setValue(
+      this->lineEditOctoPrintApiKey->text().toStdString());
   writeSettings();
 }
 
-void Preferences::on_pushButtonOctoPrintApiKey_clicked()
-{
-  this->lineEditOctoPrintApiKey->setEchoMode(this->pushButtonOctoPrintApiKey->isChecked() ? QLineEdit::EchoMode::Normal : QLineEdit::EchoMode::PasswordEchoOnEdit);
+void Preferences::on_pushButtonOctoPrintApiKey_clicked() {
+  this->lineEditOctoPrintApiKey->setEchoMode(
+      this->pushButtonOctoPrintApiKey->isChecked()
+          ? QLineEdit::EchoMode::Normal
+          : QLineEdit::EchoMode::PasswordEchoOnEdit);
 }
 
-void Preferences::on_pushButtonOctoPrintRequestApiKey_clicked()
-{
+void Preferences::on_pushButtonOctoPrintRequestApiKey_clicked() {
   OctoPrintApiKeyDialog dialog;
   if (dialog.exec() == QDialog::Accepted) {
-    const auto& apiKey = dialog.getApiKey();
+    const auto &apiKey = dialog.getApiKey();
     this->lineEditOctoPrintApiKey->setText(apiKey);
     S::octoPrintApiKey.setValue(apiKey.toStdString());
     writeSettings();
   }
 }
 
-void Preferences::on_comboBoxOctoPrintFileFormat_activated(int val)
-{
-  applyComboBox(this->comboBoxOctoPrintFileFormat, val, Settings::Settings::octoPrintFileFormat);
+void Preferences::on_comboBoxOctoPrintFileFormat_activated(int val) {
+  applyComboBox(this->comboBoxOctoPrintFileFormat, val,
+                Settings::Settings::octoPrintFileFormat);
 }
 
-void Preferences::on_comboBoxLocalAppFileFormat_activated(int val)
-{
-  applyComboBox(this->comboBoxLocalAppFileFormat, val, Settings::Settings::localAppFileFormat);
+void Preferences::on_comboBoxLocalAppFileFormat_activated(int val) {
+  applyComboBox(this->comboBoxLocalAppFileFormat, val,
+                Settings::Settings::localAppFileFormat);
   writeSettings();
 }
 
-void Preferences::on_lineEditLocalAppExecutable_editingFinished()
-{
-  Settings::Settings::localAppExecutable.setValue(this->lineEditLocalAppExecutable->text().toStdString());
+void Preferences::on_lineEditLocalAppExecutable_editingFinished() {
+  Settings::Settings::localAppExecutable.setValue(
+      this->lineEditLocalAppExecutable->text().toStdString());
   writeSettings();
 }
 
-void Preferences::on_toolButtonLocalAppSelectExecutable_clicked()
-{
-  const QString fileName = QFileDialog::getOpenFileName(this, "Select application");
+void Preferences::on_toolButtonLocalAppSelectExecutable_clicked() {
+  const QString fileName =
+      QFileDialog::getOpenFileName(this, "Select application");
   if (fileName.isEmpty()) {
     return;
   }
@@ -933,15 +941,15 @@ void Preferences::on_toolButtonLocalAppSelectExecutable_clicked()
   on_lineEditLocalAppExecutable_editingFinished();
 }
 
-void Preferences::on_lineEditLocalAppTempDir_editingFinished()
-{
-  Settings::Settings::localAppTempDir.setValue(this->lineEditLocalAppTempDir->text().toStdString());
+void Preferences::on_lineEditLocalAppTempDir_editingFinished() {
+  Settings::Settings::localAppTempDir.setValue(
+      this->lineEditLocalAppTempDir->text().toStdString());
   writeSettings();
 }
 
-void Preferences::on_toolButtonLocalAppSelectTempDir_clicked()
-{
-  const QString tempDir = QFileDialog::getExistingDirectory(this, "Select temporary directory");
+void Preferences::on_toolButtonLocalAppSelectTempDir_clicked() {
+  const QString tempDir =
+      QFileDialog::getExistingDirectory(this, "Select temporary directory");
   if (tempDir.isEmpty()) {
     return;
   }
@@ -950,9 +958,8 @@ void Preferences::on_toolButtonLocalAppSelectTempDir_clicked()
   on_lineEditLocalAppTempDir_editingFinished();
 }
 
-void Preferences::moveListBoxRow(QListWidget *listBox, int offset)
-{
-  const auto& index = listBox->selectionModel()->currentIndex();
+void Preferences::moveListBoxRow(QListWidget *listBox, int offset) {
+  const auto &index = listBox->selectionModel()->currentIndex();
   int newRow = index.row() + offset;
   if (newRow >= 0 && newRow <= listBox->count()) {
     auto item = listBox->takeItem(index.row());
@@ -961,76 +968,98 @@ void Preferences::moveListBoxRow(QListWidget *listBox, int offset)
   }
 }
 
-void Preferences::on_toolButtonLocalAppParameterUp_clicked()
-{
+void Preferences::on_toolButtonLocalAppParameterUp_clicked() {
   moveListBoxRow(this->listWidgetLocalAppParams, -1);
 }
 
-void Preferences::on_toolButtonLocalAppParameterDown_clicked()
-{
+void Preferences::on_toolButtonLocalAppParameterDown_clicked() {
   moveListBoxRow(this->listWidgetLocalAppParams, 1);
 }
 
-void Preferences::on_toolButtonLocalAppParameterRemove_clicked()
-{
-  const auto& index = this->listWidgetLocalAppParams->selectionModel()->currentIndex();
+void Preferences::on_toolButtonLocalAppParameterRemove_clicked() {
+  const auto &index =
+      this->listWidgetLocalAppParams->selectionModel()->currentIndex();
   if (index.row() >= 0) {
     auto item = this->listWidgetLocalAppParams->takeItem(index.row());
     delete item;
   }
 }
 
-void Preferences::insertListItem(QListWidget *listBox, QListWidgetItem *listItem) {
+void Preferences::insertListItem(QListWidget *listBox,
+                                 QListWidgetItem *listItem) {
   const auto hasSelection = listBox->selectionModel()->hasSelection();
-  const auto pos = hasSelection ? listBox->selectionModel()->currentIndex().row() + 1 : listBox->count();
+  const auto pos = hasSelection
+                       ? listBox->selectionModel()->currentIndex().row() + 1
+                       : listBox->count();
   listBox->insertItem(pos, listItem);
   listBox->setCurrentRow(pos);
   listBox->editItem(listItem);
 }
 
-void Preferences::on_toolButtonLocalAppParameterAdd_clicked()
-{
-  auto listItem = createListItem(Settings::LocalAppParameterType(Settings::LocalAppParameterType::string), "", true);
+void Preferences::on_toolButtonLocalAppParameterAdd_clicked() {
+  auto listItem = createListItem(
+      Settings::LocalAppParameterType(Settings::LocalAppParameterType::string),
+      "", true);
   insertListItem(this->listWidgetLocalAppParams, listItem);
 }
 
-void Preferences::addLocalAppParameter(const Settings::LocalAppParameterType& type)
-{
+void Preferences::addLocalAppParameter(
+    const Settings::LocalAppParameterType &type) {
   auto listItem = createListItem(Settings::LocalAppParameterType(type));
   insertListItem(this->listWidgetLocalAppParams, listItem);
 }
 
-void Preferences::on_toolButtonLocalAppParameterAddFile_clicked()
-{
+void Preferences::on_toolButtonLocalAppParameterAddFile_clicked() {
   addLocalAppParameter(Settings::LocalAppParameterType::file);
 }
 
-void Preferences::on_listWidgetLocalAppParams_itemSelectionChanged()
-{
-  const auto hasSelection = this->listWidgetLocalAppParams->selectionModel()->hasSelection();
-  const auto& index = this->listWidgetLocalAppParams->selectionModel()->currentIndex();
+void Preferences::on_listWidgetLocalAppParams_itemSelectionChanged() {
+  const auto hasSelection =
+      this->listWidgetLocalAppParams->selectionModel()->hasSelection();
+  const auto &index =
+      this->listWidgetLocalAppParams->selectionModel()->currentIndex();
   this->toolButtonLocalAppParameterRemove->setEnabled(hasSelection);
-  this->toolButtonLocalAppParameterUp->setEnabled(hasSelection && index.row() > 0);
-  this->toolButtonLocalAppParameterDown->setEnabled(hasSelection && index.row() < this->listWidgetLocalAppParams->count() - 1);
+  this->toolButtonLocalAppParameterUp->setEnabled(hasSelection &&
+                                                  index.row() > 0);
+  this->toolButtonLocalAppParameterDown->setEnabled(
+      hasSelection &&
+      index.row() < this->listWidgetLocalAppParams->count() - 1);
 }
 
-void Preferences::updateLocalAppParams()
-{
+void Preferences::updateLocalAppParams() {
   std::vector<Settings::LocalAppParameter> items;
   for (int idx = 0; idx < this->listWidgetLocalAppParams->count(); ++idx) {
     const auto item = this->listWidgetLocalAppParams->item(idx);
-    if (item->type() == static_cast<int>(QListWidgetItem::UserType) + static_cast<int>(Settings::LocalAppParameterType::string)) {
-      items.emplace_back(Settings::LocalAppParameterType::string, item->text().toStdString());
-    } else if (item->type() == static_cast<int>(QListWidgetItem::UserType) + static_cast<int>(Settings::LocalAppParameterType::file)) {
+    if (item->type() ==
+        static_cast<int>(QListWidgetItem::UserType) +
+            static_cast<int>(Settings::LocalAppParameterType::string)) {
+      items.emplace_back(Settings::LocalAppParameterType::string,
+                         item->text().toStdString());
+    } else if (item->type() ==
+               static_cast<int>(QListWidgetItem::UserType) +
+                   static_cast<int>(Settings::LocalAppParameterType::file)) {
       items.emplace_back(Settings::LocalAppParameterType::file, std::string{});
-    } else if (item->type() == static_cast<int>(QListWidgetItem::UserType) + static_cast<int>(Settings::LocalAppParameterType::dir)) {
+    } else if (item->type() ==
+               static_cast<int>(QListWidgetItem::UserType) +
+                   static_cast<int>(Settings::LocalAppParameterType::dir)) {
       items.emplace_back(Settings::LocalAppParameterType::dir, std::string{});
-    } else if (item->type() == static_cast<int>(QListWidgetItem::UserType) + static_cast<int>(Settings::LocalAppParameterType::extension)) {
-      items.emplace_back(Settings::LocalAppParameterType::extension, std::string{});
-    } else if (item->type() == static_cast<int>(QListWidgetItem::UserType) + static_cast<int>(Settings::LocalAppParameterType::source)) {
-      items.emplace_back(Settings::LocalAppParameterType::source, std::string{});
-    } else if (item->type() == static_cast<int>(QListWidgetItem::UserType) + static_cast<int>(Settings::LocalAppParameterType::sourcedir)) {
-      items.emplace_back(Settings::LocalAppParameterType::sourcedir, std::string{});
+    } else if (item->type() ==
+               static_cast<int>(QListWidgetItem::UserType) +
+                   static_cast<int>(
+                       Settings::LocalAppParameterType::extension)) {
+      items.emplace_back(Settings::LocalAppParameterType::extension,
+                         std::string{});
+    } else if (item->type() ==
+               static_cast<int>(QListWidgetItem::UserType) +
+                   static_cast<int>(Settings::LocalAppParameterType::source)) {
+      items.emplace_back(Settings::LocalAppParameterType::source,
+                         std::string{});
+    } else if (item->type() ==
+               static_cast<int>(QListWidgetItem::UserType) +
+                   static_cast<int>(
+                       Settings::LocalAppParameterType::sourcedir)) {
+      items.emplace_back(Settings::LocalAppParameterType::sourcedir,
+                         std::string{});
     }
   }
   Settings::Settings::localAppParameterList.setValue(items);
@@ -1042,54 +1071,51 @@ void Preferences::on_listWidgetLocalAppParams_itemChanged(QListWidgetItem *) {
   updateLocalAppParams();
 }
 
-void Preferences::listWidgetLocalAppParamsModelDataChanged()
-{
+void Preferences::listWidgetLocalAppParamsModelDataChanged() {
   // called when rows are added or removed
   updateLocalAppParams();
 }
 
-void Preferences::on_actionLocalAppParameterFile_triggered()
-{
+void Preferences::on_actionLocalAppParameterFile_triggered() {
   addLocalAppParameter(Settings::LocalAppParameterType::file);
 }
 
-void Preferences::on_actionLocalAppParameterDir_triggered()
-{
+void Preferences::on_actionLocalAppParameterDir_triggered() {
   addLocalAppParameter(Settings::LocalAppParameterType::dir);
 }
 
-void Preferences::on_actionLocalAppParameterExtension_triggered()
-{
+void Preferences::on_actionLocalAppParameterExtension_triggered() {
   addLocalAppParameter(Settings::LocalAppParameterType::extension);
 }
 
-void Preferences::on_actionLocalAppParameterSource_triggered()
-{
+void Preferences::on_actionLocalAppParameterSource_triggered() {
   addLocalAppParameter(Settings::LocalAppParameterType::source);
 }
 
-void Preferences::on_actionLocalAppParameterSourceDir_triggered()
-{
+void Preferences::on_actionLocalAppParameterSourceDir_triggered() {
   addLocalAppParameter(Settings::LocalAppParameterType::sourcedir);
 }
 
-void Preferences::on_pushButtonOctoPrintCheckConnection_clicked()
-{
+void Preferences::on_pushButtonOctoPrintCheckConnection_clicked() {
   OctoPrint octoPrint;
 
   try {
     QString api_version;
     QString server_version;
     std::tie(api_version, server_version) = octoPrint.getVersion();
-    this->labelOctoPrintCheckConnection->setText(QString{_("Success: Server Version = %2, API Version = %1")}.arg(api_version).arg(server_version));
-  } catch (const NetworkException& e) {
-    QMessageBox::critical(this, _("Error"), QString::fromStdString(e.getErrorMessage()), QMessageBox::Ok);
+    this->labelOctoPrintCheckConnection->setText(
+        QString{_("Success: Server Version = %2, API Version = %1")}
+            .arg(api_version)
+            .arg(server_version));
+  } catch (const NetworkException &e) {
+    QMessageBox::critical(this, _("Error"),
+                          QString::fromStdString(e.getErrorMessage()),
+                          QMessageBox::Ok);
     this->labelOctoPrintCheckConnection->setText("");
   }
 }
 
-void Preferences::on_pushButtonOctoPrintSlicingEngine_clicked()
-{
+void Preferences::on_pushButtonOctoPrintSlicingEngine_clicked() {
   OctoPrint octoPrint;
 
   const QString selection = this->comboBoxOctoPrintSlicingEngine->currentText();
@@ -1098,23 +1124,28 @@ void Preferences::on_pushButtonOctoPrintSlicingEngine_clicked()
     const auto slicers = octoPrint.getSlicers();
     this->comboBoxOctoPrintSlicingEngine->clear();
     this->comboBoxOctoPrintSlicingEngine->addItem(_("<Default>"), QVariant{""});
-    for (const auto& entry : slicers) {
-      this->comboBoxOctoPrintSlicingEngine->addItem(entry.second, QVariant{entry.first});
+    for (const auto &entry : slicers) {
+      this->comboBoxOctoPrintSlicingEngine->addItem(entry.second,
+                                                    QVariant{entry.first});
     }
 
     const int idx = this->comboBoxOctoPrintSlicingEngine->findText(selection);
     if (idx >= 0) {
       this->comboBoxOctoPrintSlicingEngine->setCurrentIndex(idx);
     }
-  } catch (const NetworkException& e) {
-    QMessageBox::critical(this, _("Error"), QString::fromStdString(e.getErrorMessage()), QMessageBox::Ok);
+  } catch (const NetworkException &e) {
+    QMessageBox::critical(this, _("Error"),
+                          QString::fromStdString(e.getErrorMessage()),
+                          QMessageBox::Ok);
   }
 }
 
-void Preferences::on_comboBoxOctoPrintSlicingEngine_activated(int val)
-{
-  const QString text = this->comboBoxOctoPrintSlicingEngine->itemData(val).toString();
-  const QString desc = text.isEmpty() ? QString{} : this->comboBoxOctoPrintSlicingEngine->itemText(val);
+void Preferences::on_comboBoxOctoPrintSlicingEngine_activated(int val) {
+  const QString text =
+      this->comboBoxOctoPrintSlicingEngine->itemData(val).toString();
+  const QString desc =
+      text.isEmpty() ? QString{}
+                     : this->comboBoxOctoPrintSlicingEngine->itemText(val);
   Settings::Settings::octoPrintSlicerEngine.setValue(text.toStdString());
   Settings::Settings::octoPrintSlicerEngineDesc.setValue(desc.toStdString());
   Settings::Settings::octoPrintSlicerProfile.setValue("");
@@ -1123,89 +1154,90 @@ void Preferences::on_comboBoxOctoPrintSlicingEngine_activated(int val)
   this->comboBoxOctoPrintSlicingProfile->setCurrentIndex(0);
 }
 
-void Preferences::on_pushButtonOctoPrintSlicingProfile_clicked()
-{
+void Preferences::on_pushButtonOctoPrintSlicingProfile_clicked() {
   OctoPrint octoPrint;
 
-  const QString selection = this->comboBoxOctoPrintSlicingProfile->currentText();
-  const QString slicer = this->comboBoxOctoPrintSlicingEngine->itemData(this->comboBoxOctoPrintSlicingEngine->currentIndex()).toString();
+  const QString selection =
+      this->comboBoxOctoPrintSlicingProfile->currentText();
+  const QString slicer =
+      this->comboBoxOctoPrintSlicingEngine
+          ->itemData(this->comboBoxOctoPrintSlicingEngine->currentIndex())
+          .toString();
 
   try {
     const auto profiles = octoPrint.getProfiles(slicer);
     this->comboBoxOctoPrintSlicingProfile->clear();
-    this->comboBoxOctoPrintSlicingProfile->addItem(_("<Default>"), QVariant{""});
-    for (const auto& entry : profiles) {
-      this->comboBoxOctoPrintSlicingProfile->addItem(entry.second, QVariant{entry.first});
+    this->comboBoxOctoPrintSlicingProfile->addItem(_("<Default>"),
+                                                   QVariant{""});
+    for (const auto &entry : profiles) {
+      this->comboBoxOctoPrintSlicingProfile->addItem(entry.second,
+                                                     QVariant{entry.first});
     }
 
     const int idx = this->comboBoxOctoPrintSlicingProfile->findText(selection);
     if (idx >= 0) {
       this->comboBoxOctoPrintSlicingProfile->setCurrentIndex(idx);
     }
-  } catch (const NetworkException& e) {
-    QMessageBox::critical(this, _("Error"), QString::fromStdString(e.getErrorMessage()), QMessageBox::Ok);
+  } catch (const NetworkException &e) {
+    QMessageBox::critical(this, _("Error"),
+                          QString::fromStdString(e.getErrorMessage()),
+                          QMessageBox::Ok);
   }
 }
 
-void Preferences::on_comboBoxOctoPrintSlicingProfile_activated(int val)
-{
-  const QString text = this->comboBoxOctoPrintSlicingProfile->itemData(val).toString();
-  const QString desc = text.isEmpty() ? QString{} : this->comboBoxOctoPrintSlicingProfile->itemText(val);
+void Preferences::on_comboBoxOctoPrintSlicingProfile_activated(int val) {
+  const QString text =
+      this->comboBoxOctoPrintSlicingProfile->itemData(val).toString();
+  const QString desc =
+      text.isEmpty() ? QString{}
+                     : this->comboBoxOctoPrintSlicingProfile->itemText(val);
   Settings::Settings::octoPrintSlicerProfile.setValue(text.toStdString());
   Settings::Settings::octoPrintSlicerProfileDesc.setValue(desc.toStdString());
   writeSettings();
 }
 
-void Preferences::on_checkBoxAlwaysShowExportPdfDialog_toggled(bool state)
-{
+void Preferences::on_checkBoxAlwaysShowExportPdfDialog_toggled(bool state) {
   Settings::SettingsExportPdf::exportPdfAlwaysShowDialog.setValue(state);
   writeSettings();
 }
 
-void Preferences::on_checkBoxAlwaysShowExport3mfDialog_toggled(bool state)
-{
+void Preferences::on_checkBoxAlwaysShowExport3mfDialog_toggled(bool state) {
   Settings::SettingsExport3mf::export3mfAlwaysShowDialog.setValue(state);
   writeSettings();
 }
 
-void Preferences::on_checkBoxAlwaysShowPrintServiceDialog_toggled(bool state)
-{
+void Preferences::on_checkBoxAlwaysShowPrintServiceDialog_toggled(bool state) {
   Settings::Settings::printServiceAlwaysShowDialog.setValue(state);
   writeSettings();
 }
 
-void Preferences::writeSettings()
-{
+void Preferences::writeSettings() {
   Settings::Settings::visit(SettingsWriter());
   fireEditorConfigChanged();
 }
 
-void Preferences::fireEditorConfigChanged() const
-{
+void Preferences::fireEditorConfigChanged() const {
   emit editorConfigChanged();
 }
 
-void Preferences::keyPressEvent(QKeyEvent *e)
-{
+void Preferences::keyPressEvent(QKeyEvent *e) {
 #ifdef Q_OS_MACOS
   if (e->modifiers() == Qt::ControlModifier && e->key() == Qt::Key_Period) {
     close();
   } else
 #endif
-  if ((e->modifiers() == Qt::ControlModifier && e->key() == Qt::Key_W) ||
-      e->key() == Qt::Key_Escape) {
+      if ((e->modifiers() == Qt::ControlModifier && e->key() == Qt::Key_W) ||
+          e->key() == Qt::Key_Escape) {
     close();
   }
 }
 
-void Preferences::showEvent(QShowEvent *e)
-{
+void Preferences::showEvent(QShowEvent *e) {
   QMainWindow::showEvent(e);
   hidePasswords();
 }
 
-void Preferences::closeEvent(QCloseEvent *e)
-{
+void Preferences::closeEvent(QCloseEvent *e) {
   hidePasswords();
   QMainWindow::closeEvent(e);
 }
@@ -1214,62 +1246,81 @@ void Preferences::closeEvent(QCloseEvent *e)
    Removes settings that are the same as the default settings to avoid
    overwriting future changes to default settings.
  */
-void Preferences::removeDefaultSettings()
-{
+void Preferences::removeDefaultSettings() {
   QSettingsCached settings;
   for (QSettings::SettingsMap::const_iterator iter = this->defaultmap.begin();
-       iter != this->defaultmap.end();
-       iter++) {
+       iter != this->defaultmap.end(); iter++) {
     if (settings.value(iter.key()) == iter.value()) {
       settings.remove(iter.key());
     }
   }
 }
 
-QVariant Preferences::getValue(const QString& key) const
-{
+QVariant Preferences::getValue(const QString &key) const {
   QSettingsCached settings;
   assert(settings.contains(key) || this->defaultmap.contains(key));
   return settings.value(key, this->defaultmap[key]);
 }
 
-void Preferences::updateGUI()
-{
-  const auto found = this->colorSchemeChooser->findItems(getValue("3dview/colorscheme").toString(), Qt::MatchExactly);
-  if (!found.isEmpty()) BlockSignals<QListWidget *>(this->colorSchemeChooser)->setCurrentItem(found.first());
+void Preferences::updateGUI() {
+  const auto found = this->colorSchemeChooser->findItems(
+      getValue("3dview/colorscheme").toString(), Qt::MatchExactly);
+  if (!found.isEmpty())
+    BlockSignals<QListWidget *>(this->colorSchemeChooser)
+        ->setCurrentItem(found.first());
 
   updateGUIFontFamily(fontChooser, "editor/fontfamily");
   updateGUIFontSize(fontSize, "editor/fontsize");
 
   const auto shighlight = getValue("editor/syntaxhighlight").toString();
   const auto shidx = this->syntaxHighlight->findText(shighlight);
-  const auto sheffidx = shidx >= 0 ? shidx : this->syntaxHighlight->findText("Off");
+  const auto sheffidx =
+      shidx >= 0 ? shidx : this->syntaxHighlight->findText("Off");
   if (sheffidx >= 0) {
     BlockSignals<QComboBox *>(this->syntaxHighlight)->setCurrentIndex(sheffidx);
   }
 
-  BlockSignals<QCheckBox *>(this->mouseWheelZoomBox)->setChecked(getValue("editor/ctrlmousewheelzoom").toBool());
+  BlockSignals<QCheckBox *>(this->mouseWheelZoomBox)
+      ->setChecked(getValue("editor/ctrlmousewheelzoom").toBool());
 
   if (AutoUpdater *updater = AutoUpdater::updater()) {
-    BlockSignals<QCheckBox *>(this->updateCheckBox)->setChecked(updater->automaticallyChecksForUpdates());
-    BlockSignals<QCheckBox *>(this->snapshotCheckBox)->setChecked(updater->enableSnapshots());
-    BlockSignals<QLabel *>(this->lastCheckedLabel)->setText(updater->lastUpdateCheckDate());
+    BlockSignals<QCheckBox *>(this->updateCheckBox)
+        ->setChecked(updater->automaticallyChecksForUpdates());
+    BlockSignals<QCheckBox *>(this->snapshotCheckBox)
+        ->setChecked(updater->enableSnapshots());
+    BlockSignals<QLabel *>(this->lastCheckedLabel)
+        ->setText(updater->lastUpdateCheckDate());
   }
 
-  BlockSignals<QCheckBox *>(this->openCSGWarningBox)->setChecked(getValue("advanced/opencsg_show_warning").toBool());
-  BlockSignals<QLineEdit *>(this->cgalCacheSizeMBEdit)->setText(getValue("advanced/cgalCacheSizeMB").toString());
-  BlockSignals<QLineEdit *>(this->polysetCacheSizeMBEdit)->setText(getValue("advanced/polysetCacheSizeMB").toString());
-  BlockSignals<QLineEdit *>(this->opencsgLimitEdit)->setText(getValue("advanced/openCSGLimit").toString());
-  BlockSignals<QCheckBox *>(this->localizationCheckBox)->setChecked(getValue("advanced/localization").toBool());
-  BlockSignals<QCheckBox *>(this->autoReloadRaiseCheckBox)->setChecked(getValue("advanced/autoReloadRaise").toBool());
-  BlockSignals<QCheckBox *>(this->forceGoldfeatherBox)->setChecked(getValue("advanced/forceGoldfeather").toBool());
-  BlockSignals<QCheckBox *>(this->reorderCheckBox)->setChecked(getValue("advanced/reorderWindows").toBool());
-  BlockSignals<QCheckBox *>(this->undockCheckBox)->setChecked(getValue("advanced/undockableWindows").toBool());
-  BlockSignals<QCheckBox *>(this->launcherBox)->setChecked(getValue("launcher/showOnStartup").toBool());
-  BlockSignals<QCheckBox *>(this->enableSoundOnRenderCompleteCheckBox)->setChecked(getValue("advanced/enableSoundNotification").toBool());
-  BlockSignals<QLineEdit *>(this->timeThresholdOnRenderCompleteSoundEdit)->setText(getValue("advanced/timeThresholdOnRenderCompleteSound").toString());
-  BlockSignals<QCheckBox *>(this->enableClearConsoleCheckBox)->setChecked(getValue("advanced/consoleAutoClear").toBool());
-  BlockSignals<QLineEdit *>(this->consoleMaxLinesEdit)->setText(getValue("advanced/consoleMaxLines").toString());
+  BlockSignals<QCheckBox *>(this->openCSGWarningBox)
+      ->setChecked(getValue("advanced/opencsg_show_warning").toBool());
+  BlockSignals<QLineEdit *>(this->cgalCacheSizeMBEdit)
+      ->setText(getValue("advanced/cgalCacheSizeMB").toString());
+  BlockSignals<QLineEdit *>(this->polysetCacheSizeMBEdit)
+      ->setText(getValue("advanced/polysetCacheSizeMB").toString());
+  BlockSignals<QLineEdit *>(this->opencsgLimitEdit)
+      ->setText(getValue("advanced/openCSGLimit").toString());
+  BlockSignals<QCheckBox *>(this->localizationCheckBox)
+      ->setChecked(getValue("advanced/localization").toBool());
+  BlockSignals<QCheckBox *>(this->autoReloadRaiseCheckBox)
+      ->setChecked(getValue("advanced/autoReloadRaise").toBool());
+  BlockSignals<QCheckBox *>(this->forceGoldfeatherBox)
+      ->setChecked(getValue("advanced/forceGoldfeather").toBool());
+  BlockSignals<QCheckBox *>(this->reorderCheckBox)
+      ->setChecked(getValue("advanced/reorderWindows").toBool());
+  BlockSignals<QCheckBox *>(this->undockCheckBox)
+      ->setChecked(getValue("advanced/undockableWindows").toBool());
+  BlockSignals<QCheckBox *>(this->launcherBox)
+      ->setChecked(getValue("launcher/showOnStartup").toBool());
+  BlockSignals<QCheckBox *>(this->enableSoundOnRenderCompleteCheckBox)
+      ->setChecked(getValue("advanced/enableSoundNotification").toBool());
+  BlockSignals<QLineEdit *>(this->timeThresholdOnRenderCompleteSoundEdit)
+      ->setText(
+          getValue("advanced/timeThresholdOnRenderCompleteSound").toString());
+  BlockSignals<QCheckBox *>(this->enableClearConsoleCheckBox)
+      ->setChecked(getValue("advanced/consoleAutoClear").toBool());
+  BlockSignals<QLineEdit *>(this->consoleMaxLinesEdit)
+      ->setText(getValue("advanced/consoleMaxLines").toString());
 
   updateGUIFontFamily(consoleFontChooser, "advanced/consoleFontFamily");
   updateGUIFontSize(consoleFontSize, "advanced/consoleFontSize");
@@ -1277,95 +1328,144 @@ void Preferences::updateGUI()
   updateGUIFontFamily(customizerFontChooser, "advanced/customizerFontFamily");
   updateGUIFontSize(customizerFontSize, "advanced/customizerFontSize");
 
-  BlockSignals<QCheckBox *>(this->enableHardwarningsCheckBox)->setChecked(getValue("advanced/enableHardwarnings").toBool());
-  BlockSignals<QLineEdit *>(this->traceDepthEdit)->setText(getValue("advanced/traceDepth").toString());
-  BlockSignals<QCheckBox *>(this->enableTraceUsermoduleParametersCheckBox)->setChecked(getValue("advanced/enableTraceUsermoduleParameters").toBool());
-  BlockSignals<QCheckBox *>(this->enableParameterCheckBox)->setChecked(getValue("advanced/enableParameterCheck").toBool());
-  BlockSignals<QCheckBox *>(this->enableRangeCheckBox)->setChecked(getValue("advanced/enableParameterRangeCheck").toBool());
-  updateComboBox(this->comboBoxToolbarExport3D, Settings::Settings::toolbarExport3D);
-  updateComboBox(this->comboBoxToolbarExport2D, Settings::Settings::toolbarExport2D);
-
-  BlockSignals<QCheckBox *>(this->checkBoxSummaryCamera)->setChecked(Settings::Settings::summaryCamera.value());
-  BlockSignals<QCheckBox *>(this->checkBoxSummaryArea)->setChecked(Settings::Settings::summaryArea.value());
-  BlockSignals<QCheckBox *>(this->checkBoxSummaryBoundingBox)->setChecked(Settings::Settings::summaryBoundingBox.value());
-
-  BlockSignals<QCheckBox *>(this->enableHidapiTraceCheckBox)->setChecked(Settings::Settings::inputEnableDriverHIDAPILog.value());
-  BlockSignals<QCheckBox *>(this->checkBoxEnableAutocomplete)->setChecked(getValue("editor/enableAutocomplete").toBool());
-  BlockSignals<QLineEdit *>(this->lineEditCharacterThreshold)->setText(getValue("editor/characterThreshold").toString());
-  BlockSignals<QLineEdit *>(this->lineEditStepSize)->setText(getValue("editor/stepSize").toString());
-
-  this->secLabelOnRenderCompleteSound->setEnabled(getValue("advanced/enableSoundNotification").toBool());
+  BlockSignals<QCheckBox *>(this->enableHardwarningsCheckBox)
+      ->setChecked(getValue("advanced/enableHardwarnings").toBool());
+  BlockSignals<QLineEdit *>(this->traceDepthEdit)
+      ->setText(getValue("advanced/traceDepth").toString());
+  BlockSignals<QCheckBox *>(this->enableTraceUsermoduleParametersCheckBox)
+      ->setChecked(
+          getValue("advanced/enableTraceUsermoduleParameters").toBool());
+  BlockSignals<QCheckBox *>(this->enableParameterCheckBox)
+      ->setChecked(getValue("advanced/enableParameterCheck").toBool());
+  BlockSignals<QCheckBox *>(this->enableRangeCheckBox)
+      ->setChecked(getValue("advanced/enableParameterRangeCheck").toBool());
+  updateComboBox(this->comboBoxToolbarExport3D,
+                 Settings::Settings::toolbarExport3D);
+  updateComboBox(this->comboBoxToolbarExport2D,
+                 Settings::Settings::toolbarExport2D);
+
+  BlockSignals<QCheckBox *>(this->checkBoxSummaryCamera)
+      ->setChecked(Settings::Settings::summaryCamera.value());
+  BlockSignals<QCheckBox *>(this->checkBoxSummaryArea)
+      ->setChecked(Settings::Settings::summaryArea.value());
+  BlockSignals<QCheckBox *>(this->checkBoxSummaryBoundingBox)
+      ->setChecked(Settings::Settings::summaryBoundingBox.value());
+
+  BlockSignals<QCheckBox *>(this->enableHidapiTraceCheckBox)
+      ->setChecked(Settings::Settings::inputEnableDriverHIDAPILog.value());
+  BlockSignals<QCheckBox *>(this->checkBoxEnableAutocomplete)
+      ->setChecked(getValue("editor/enableAutocomplete").toBool());
+  BlockSignals<QLineEdit *>(this->lineEditCharacterThreshold)
+      ->setText(getValue("editor/characterThreshold").toString());
+  BlockSignals<QLineEdit *>(this->lineEditStepSize)
+      ->setText(getValue("editor/stepSize").toString());
+
+  this->secLabelOnRenderCompleteSound->setEnabled(
+      getValue("advanced/enableSoundNotification").toBool());
   this->undockCheckBox->setEnabled(this->reorderCheckBox->isChecked());
-  this->timeThresholdOnRenderCompleteSoundLabel->setEnabled(getValue("advanced/enableSoundNotification").toBool());
-  this->timeThresholdOnRenderCompleteSoundEdit->setEnabled(getValue("advanced/enableSoundNotification").toBool());
-  this->labelCharacterThreshold->setEnabled(getValue("editor/enableAutocomplete").toBool());
-  this->lineEditCharacterThreshold->setEnabled(getValue("editor/enableAutocomplete").toBool());
+  this->timeThresholdOnRenderCompleteSoundLabel->setEnabled(
+      getValue("advanced/enableSoundNotification").toBool());
+  this->timeThresholdOnRenderCompleteSoundEdit->setEnabled(
+      getValue("advanced/enableSoundNotification").toBool());
+  this->labelCharacterThreshold->setEnabled(
+      getValue("editor/enableAutocomplete").toBool());
+  this->lineEditCharacterThreshold->setEnabled(
+      getValue("editor/enableAutocomplete").toBool());
   this->lineEditStepSize->setEnabled(getValue("editor/stepSize").toBool());
 
-  updateComboBox(this->comboBoxRenderBackend3D, Settings::Settings::renderBackend3D);
+  updateComboBox(this->comboBoxRenderBackend3D,
+                 Settings::Settings::renderBackend3D);
   updateComboBox(this->comboBoxLineWrap, Settings::Settings::lineWrap);
-  updateComboBox(this->comboBoxLineWrapIndentationStyle, Settings::Settings::lineWrapIndentationStyle);
-  updateComboBox(this->comboBoxLineWrapVisualizationStart, Settings::Settings::lineWrapVisualizationBegin);
-  updateComboBox(this->comboBoxLineWrapVisualizationEnd, Settings::Settings::lineWrapVisualizationEnd);
-  updateComboBox(this->comboBoxShowWhitespace, Settings::Settings::showWhitespace);
+  updateComboBox(this->comboBoxLineWrapIndentationStyle,
+                 Settings::Settings::lineWrapIndentationStyle);
+  updateComboBox(this->comboBoxLineWrapVisualizationStart,
+                 Settings::Settings::lineWrapVisualizationBegin);
+  updateComboBox(this->comboBoxLineWrapVisualizationEnd,
+                 Settings::Settings::lineWrapVisualizationEnd);
+  updateComboBox(this->comboBoxShowWhitespace,
+                 Settings::Settings::showWhitespace);
   updateComboBox(this->comboBoxIndentUsing, Settings::Settings::indentStyle);
-  updateComboBox(this->comboBoxTabKeyFunction, Settings::Settings::tabKeyFunction);
-  updateComboBox(this->comboBoxModifierNumberScrollWheel, Settings::Settings::modifierNumberScrollWheel);
-  updateIntSpinBox(this->spinBoxIndentationWidth, Settings::Settings::indentationWidth);
+  updateComboBox(this->comboBoxTabKeyFunction,
+                 Settings::Settings::tabKeyFunction);
+  updateComboBox(this->comboBoxModifierNumberScrollWheel,
+                 Settings::Settings::modifierNumberScrollWheel);
+  updateIntSpinBox(this->spinBoxIndentationWidth,
+                   Settings::Settings::indentationWidth);
   updateIntSpinBox(this->spinBoxTabWidth, Settings::Settings::tabWidth);
-  updateIntSpinBox(this->spinBoxLineWrapIndentationIndent, Settings::Settings::lineWrapIndentation);
-  updateIntSpinBox(this->spinBoxShowWhitespaceSize, Settings::Settings::showWhitespaceSize);
+  updateIntSpinBox(this->spinBoxLineWrapIndentationIndent,
+                   Settings::Settings::lineWrapIndentation);
+  updateIntSpinBox(this->spinBoxShowWhitespaceSize,
+                   Settings::Settings::showWhitespaceSize);
   initUpdateCheckBox(this->checkBoxAutoIndent, Settings::Settings::autoIndent);
-  initUpdateCheckBox(this->checkBoxBackspaceUnindents, Settings::Settings::backspaceUnindents);
-  initUpdateCheckBox(this->checkBoxHighlightCurrentLine, Settings::Settings::highlightCurrentLine);
-  initUpdateCheckBox(this->checkBoxEnableBraceMatching, Settings::Settings::enableBraceMatching);
-  initUpdateCheckBox(this->checkBoxEnableNumberScrollWheel, Settings::Settings::enableNumberScrollWheel);
-  initUpdateCheckBox(this->checkBoxShowWarningsIn3dView, Settings::Settings::showWarningsIn3dView);
-  initUpdateCheckBox(this->checkBoxMouseCentricZoom, Settings::Settings::mouseCentricZoom);
-  initUpdateCheckBox(this->checkBoxMouseSwapButtons, Settings::Settings::mouseSwapButtons);
-  initUpdateCheckBox(this->checkBoxEnableLineNumbers, Settings::Settings::enableLineNumbers);
-
-
-
-  /* Next Line disables the Indent Spin-Box,for 'Same' and 'Indented' LineWrapStyle selection from LineWrapIndentationStyle Combo-box, just after launching the openscad application.
-     Removing this line will cause misbehaviour, and will not disable the Indent spin-box until you interact with the LineWrapStyle Combo-Box first-time and choose a style for which disabling has been handled.
-     For normal cases, a similar line, inside the function 'on_comboBoxLineWrapIndentationStyle_activated()' handles the disabling functionality.
+  initUpdateCheckBox(this->checkBoxBackspaceUnindents,
+                     Settings::Settings::backspaceUnindents);
+  initUpdateCheckBox(this->checkBoxHighlightCurrentLine,
+                     Settings::Settings::highlightCurrentLine);
+  initUpdateCheckBox(this->checkBoxEnableBraceMatching,
+                     Settings::Settings::enableBraceMatching);
+  initUpdateCheckBox(this->checkBoxEnableNumberScrollWheel,
+                     Settings::Settings::enableNumberScrollWheel);
+  initUpdateCheckBox(this->checkBoxShowWarningsIn3dView,
+                     Settings::Settings::showWarningsIn3dView);
+  initUpdateCheckBox(this->checkBoxMouseCentricZoom,
+                     Settings::Settings::mouseCentricZoom);
+  initUpdateCheckBox(this->checkBoxMouseSwapButtons,
+                     Settings::Settings::mouseSwapButtons);
+  initUpdateCheckBox(this->checkBoxEnableLineNumbers,
+                     Settings::Settings::enableLineNumbers);
+
+  /* Next Line disables the Indent Spin-Box,for 'Same' and 'Indented'
+     LineWrapStyle selection from LineWrapIndentationStyle Combo-box, just after
+     launching the openscad application. Removing this line will cause
+     misbehaviour, and will not disable the Indent spin-box until you interact
+     with the LineWrapStyle Combo-Box first-time and choose a style for which
+     disabling has been handled. For normal cases, a similar line, inside the
+     function 'on_comboBoxLineWrapIndentationStyle_activated()' handles the
+     disabling functionality.
    */
-  this->spinBoxLineWrapIndentationIndent->setDisabled(comboBoxLineWrapIndentationStyle->currentData() == "Same" || comboBoxLineWrapIndentationStyle->currentData() == "Indented");
-  this->comboBoxModifierNumberScrollWheel->setDisabled(!checkBoxEnableNumberScrollWheel->isChecked());
-  BlockSignals<QLineEdit *>(this->lineEditOctoPrintURL)->setText(QString::fromStdString(Settings::Settings::octoPrintUrl.value()));
-  BlockSignals<QLineEdit *>(this->lineEditOctoPrintApiKey)->setText(QString::fromStdString(Settings::Settings::octoPrintApiKey.value()));
-  updateComboBox(this->comboBoxOctoPrintAction, Settings::Settings::octoPrintAction);
-  updateComboBox(this->comboBoxOctoPrintSlicingEngine, Settings::Settings::octoPrintSlicerEngine.value());
-  updateComboBox(this->comboBoxOctoPrintSlicingProfile, Settings::Settings::octoPrintSlicerProfile.value());
-}
-
-void Preferences::applyComboBox(QComboBox * /*comboBox*/, int val, Settings::SettingsEntryEnum<std::string>& entry)
-{
+  this->spinBoxLineWrapIndentationIndent->setDisabled(
+      comboBoxLineWrapIndentationStyle->currentData() == "Same" ||
+      comboBoxLineWrapIndentationStyle->currentData() == "Indented");
+  this->comboBoxModifierNumberScrollWheel->setDisabled(
+      !checkBoxEnableNumberScrollWheel->isChecked());
+  BlockSignals<QLineEdit *>(this->lineEditOctoPrintURL)
+      ->setText(
+          QString::fromStdString(Settings::Settings::octoPrintUrl.value()));
+  BlockSignals<QLineEdit *>(this->lineEditOctoPrintApiKey)
+      ->setText(
+          QString::fromStdString(Settings::Settings::octoPrintApiKey.value()));
+  updateComboBox(this->comboBoxOctoPrintAction,
+                 Settings::Settings::octoPrintAction);
+  updateComboBox(this->comboBoxOctoPrintSlicingEngine,
+                 Settings::Settings::octoPrintSlicerEngine.value());
+  updateComboBox(this->comboBoxOctoPrintSlicingProfile,
+                 Settings::Settings::octoPrintSlicerProfile.value());
+}
+
+void Preferences::applyComboBox(
+    QComboBox * /*comboBox*/, int val,
+    Settings::SettingsEntryEnum<std::string> &entry) {
   entry.setIndex(val);
   writeSettings();
 }
 
-void Preferences::apply_win() const
-{
+void Preferences::apply_win() const {
   emit requestRedraw();
   emit openCSGSettingsChanged();
 }
 
-bool Preferences::hasHighlightingColorScheme() const
-{
+bool Preferences::hasHighlightingColorScheme() const {
   return BlockSignals<QComboBox *>(syntaxHighlight)->count() != 0;
 }
 
-void Preferences::setHighlightingColorSchemes(const QStringList& colorSchemes)
-{
+void Preferences::setHighlightingColorSchemes(const QStringList &colorSchemes) {
   auto combobox = BlockSignals<QComboBox *>(syntaxHighlight);
   combobox->clear();
   combobox->addItems(colorSchemes);
 }
 
-void Preferences::createFontSizeMenu(QComboBox *boxarg, const QString& setting)
-{
+void Preferences::createFontSizeMenu(QComboBox *boxarg,
+                                     const QString &setting) {
   uint savedsize = getValue(setting).toUInt();
   const QFontDatabase db;
   BlockSignals<QComboBox *> box{boxarg};
@@ -1376,11 +1476,11 @@ void Preferences::createFontSizeMenu(QComboBox *boxarg, const QString& setting)
     }
   }
   // reset GUI fontsize if fontSize->addItem emitted signals that changed it.
-  box->setEditText(QString("%1").arg(savedsize) );
+  box->setEditText(QString("%1").arg(savedsize));
 }
 
-void Preferences::updateGUIFontFamily(QFontComboBox *ffSelector, const QString& setting)
-{
+void Preferences::updateGUIFontFamily(QFontComboBox *ffSelector,
+                                      const QString &setting) {
   const auto fontfamily = getValue(setting).toString();
   const auto fidx = ffSelector->findText(fontfamily, Qt::MatchContains);
   if (fidx >= 0) {
@@ -1388,8 +1488,8 @@ void Preferences::updateGUIFontFamily(QFontComboBox *ffSelector, const QString&
   }
 }
 
-void Preferences::updateGUIFontSize(QComboBox *fsSelector, const QString& setting)
-{
+void Preferences::updateGUIFontSize(QComboBox *fsSelector,
+                                    const QString &setting) {
   const auto fontsize = getValue(setting).toString();
   const auto sidx = fsSelector->findText(fontsize);
   if (sidx >= 0) {
@@ -1399,8 +1499,7 @@ void Preferences::updateGUIFontSize(QComboBox *fsSelector, const QString& settin
   }
 }
 
-Preferences *GlobalPreferences::inst()
-{
+Preferences *GlobalPreferences::inst() {
   static auto *instance = new Preferences();
   return instance;
 }
diff --git a/src/gui/Preferences.h b/src/gui/Preferences.h
index bf70d6088..88369dccd 100644
--- a/src/gui/Preferences.h
+++ b/src/gui/Preferences.h
@@ -8,30 +8,31 @@
 #include <QFontComboBox>
 #include <QHash>
 #include <QKeyEvent>
+#include <QMainWindow>
+#include <QSettings>
 #include <QShowEvent>
 #include <QString>
 #include <QStringList>
 #include <QVariant>
 #include <QWidget>
-#include <QMainWindow>
-#include <QSettings>
 #include <string>
 
+#include "core/Settings.h"
+#include "gui/InitConfigurator.h"
 #include "gui/qtgettext.h" // IWYU pragma: keep
 #include "openscad_gui.h"
 #include "ui_Preferences.h"
-#include "core/Settings.h"
-#include "gui/InitConfigurator.h"
 
 class GlobalPreferences;
-class Preferences : public QMainWindow, public Ui::Preferences, public InitConfigurator
-{
+class Preferences : public QMainWindow,
+                    public Ui::Preferences,
+                    public InitConfigurator {
   Q_OBJECT;
 
 public:
   ~Preferences() override;
 
-  QVariant getValue(const QString& key) const;
+  QVariant getValue(const QString &key) const;
   void init();
   void update();
   void apply_win() const;
@@ -43,20 +44,20 @@ public:
   bool hasHighlightingColorScheme() const;
 
   // Set a new colorScheme.
-  void setHighlightingColorSchemes(const QStringList& colorSchemes);
+  void setHighlightingColorSchemes(const QStringList &colorSchemes);
 
 public slots:
   void actionTriggered(class QAction *);
   void featuresCheckBoxToggled(bool);
   void on_stackedWidget_currentChanged(int);
   void on_colorSchemeChooser_itemSelectionChanged();
-  void on_fontChooser_currentFontChanged(const QFont&);
+  void on_fontChooser_currentFontChanged(const QFont &);
   void on_fontSize_currentIndexChanged(int);
-  void on_syntaxHighlight_currentTextChanged(const QString&);
+  void on_syntaxHighlight_currentTextChanged(const QString &);
   void on_openCSGWarningBox_toggled(bool);
-  void on_cgalCacheSizeMBEdit_textChanged(const QString&);
-  void on_polysetCacheSizeMBEdit_textChanged(const QString&);
-  void on_opencsgLimitEdit_textChanged(const QString&);
+  void on_cgalCacheSizeMBEdit_textChanged(const QString &);
+  void on_polysetCacheSizeMBEdit_textChanged(const QString &);
+  void on_opencsgLimitEdit_textChanged(const QString &);
   void on_forceGoldfeatherBox_toggled(bool);
   void on_mouseWheelZoomBox_toggled(bool);
   void on_localizationCheckBox_toggled(bool);
@@ -69,7 +70,7 @@ public slots:
   void on_launcherBox_toggled(bool);
   void on_enableSoundOnRenderCompleteCheckBox_toggled(bool);
   void on_enableHardwarningsCheckBox_toggled(bool);
-  void on_traceDepthEdit_textChanged(const QString&);
+  void on_traceDepthEdit_textChanged(const QString &);
   void on_enableTraceUsermoduleParametersCheckBox_toggled(bool);
   void on_enableParameterCheckBox_toggled(bool);
   void on_enableRangeCheckBox_toggled(bool);
@@ -83,15 +84,15 @@ public slots:
   void on_checkBoxShowWarningsIn3dView_toggled(bool);
   void on_checkBoxMouseCentricZoom_toggled(bool);
   void on_checkBoxMouseSwapButtons_toggled(bool);
-  void on_timeThresholdOnRenderCompleteSoundEdit_textChanged(const QString&);
+  void on_timeThresholdOnRenderCompleteSoundEdit_textChanged(const QString &);
   void on_enableClearConsoleCheckBox_toggled(bool);
-  void on_consoleMaxLinesEdit_textChanged(const QString&);
-  void on_consoleFontChooser_currentFontChanged(const QFont&);
+  void on_consoleMaxLinesEdit_textChanged(const QString &);
+  void on_consoleFontChooser_currentFontChanged(const QFont &);
   void on_consoleFontSize_currentIndexChanged(int);
-  void on_customizerFontChooser_currentFontChanged(const QFont&);
+  void on_customizerFontChooser_currentFontChanged(const QFont &);
   void on_customizerFontSize_currentIndexChanged(int);
   void on_checkBoxEnableAutocomplete_toggled(bool);
-  void on_lineEditCharacterThreshold_textChanged(const QString&);
+  void on_lineEditCharacterThreshold_textChanged(const QString &);
   //
   // editor settings
   //
@@ -114,7 +115,6 @@ public slots:
   void on_comboBoxLineWrapVisualizationEnd_activated(int);
   void on_comboBoxModifierNumberScrollWheel_activated(int);
 
-
   // Display
   void on_checkBoxHighlightCurrentLine_toggled(bool);
   void on_checkBoxEnableBraceMatching_toggled(bool);
@@ -162,12 +162,12 @@ signals:
   void requestRedraw() const;
   void updateUndockMode(bool undockMode) const;
   void updateReorderMode(bool undockMode) const;
-  void fontChanged(const QString& family, uint size) const;
-  void consoleFontChanged(const QString& family, uint size) const;
-  void customizerFontChanged(const QString& family, uint size) const;
-  void colorSchemeChanged(const QString& scheme) const;
+  void fontChanged(const QString &family, uint size) const;
+  void consoleFontChanged(const QString &family, uint size) const;
+  void customizerFontChanged(const QString &family, uint size) const;
+  void colorSchemeChanged(const QString &scheme) const;
   void openCSGSettingsChanged() const;
-  void syntaxHighlightChanged(const QString& s) const;
+  void syntaxHighlightChanged(const QString &s) const;
   void editorConfigChanged() const;
   void ExperimentalChanged() const;
   void updateMouseCentricZoom(bool state) const;
@@ -178,7 +178,7 @@ signals:
   void toolbarExportChanged() const;
 
 private slots:
-  void on_lineEditStepSize_textChanged(const QString& arg1);
+  void on_lineEditStepSize_textChanged(const QString &arg1);
 
   void on_checkBoxEnableNumberScrollWheel_toggled(bool checked);
 
@@ -194,22 +194,22 @@ private:
   void writeSettings();
   void hidePasswords();
   void addPrefPage(QActionGroup *group, QAction *action, QWidget *widget);
-  void createFontSizeMenu(QComboBox *box, const QString& setting);
-  void updateGUIFontFamily(QFontComboBox *fontSelector, const QString& setting);
-  void updateGUIFontSize(QComboBox *fsSelector, const QString& setting);
+  void createFontSizeMenu(QComboBox *box, const QString &setting);
+  void updateGUIFontFamily(QFontComboBox *fontSelector, const QString &setting);
+  void updateGUIFontSize(QComboBox *fsSelector, const QString &setting);
   void updateLocalAppParams();
-  void addLocalAppParameter(const Settings::LocalAppParameterType&);
+  void addLocalAppParameter(const Settings::LocalAppParameterType &);
   void moveListBoxRow(QListWidget *listBox, int offset);
 
   /** Set value from combobox to settings */
-  void applyComboBox(QComboBox *comboBox, int val, Settings::SettingsEntryEnum<std::string>& entry);
+  void applyComboBox(QComboBox *comboBox, int val,
+                     Settings::SettingsEntryEnum<std::string> &entry);
 
   QSettings::SettingsMap defaultmap;
   QHash<const QAction *, QWidget *> prefPages;
 };
 
-class GlobalPreferences
-{
+class GlobalPreferences {
 public:
   static Preferences *inst();
 };
diff --git a/src/gui/PrintInitDialog.cc b/src/gui/PrintInitDialog.cc
index 197b8273b..9f466f5e8 100644
--- a/src/gui/PrintInitDialog.cc
+++ b/src/gui/PrintInitDialog.cc
@@ -26,16 +26,16 @@
 
 #include "gui/PrintInitDialog.h"
 
-#include <vector>
 #include <string>
+#include <vector>
 
 #include <QDialog>
-#include <QString>
 #include <QPushButton>
+#include <QString>
 
-#include "io/export.h"
 #include "core/Settings.h"
 #include "gui/PrintService.h"
+#include "io/export.h"
 
 using S = Settings::Settings;
 
@@ -54,39 +54,40 @@ QString toString(print_service_t printServiceType) {
   }
 }
 
-print_service_t fromString(const std::string& printServiceType) {
+print_service_t fromString(const std::string &printServiceType) {
   if (printServiceType == "PRINT_SERVICE") {
     return print_service_t::PRINT_SERVICE;
   } else if (printServiceType == "OCTOPRINT") {
     return print_service_t::OCTOPRINT;
   } else if (printServiceType == "LOCAL_APPLICATION") {
     return print_service_t::LOCAL_APPLICATION;
-  } else return print_service_t::NONE;
+  } else
+    return print_service_t::NONE;
 }
 
 } // namespace
 
 void PrintInitDialog::populateFileFormatComboBox(
-  const std::vector<FileFormat>& fileFormats, FileFormat currentFormat) {
+    const std::vector<FileFormat> &fileFormats, FileFormat currentFormat) {
   this->comboBoxFileFormat->clear();
-  for (const auto& fileFormat : fileFormats) {
-    const FileFormatInfo& info = fileformat::info(fileFormat);
+  for (const auto &fileFormat : fileFormats) {
+    const FileFormatInfo &info = fileformat::info(fileFormat);
     this->comboBoxFileFormat->addItem(QString::fromStdString(info.description),
                                       QString::fromStdString(info.identifier));
     if (fileFormat == currentFormat) {
       this->comboBoxFileFormat->setCurrentIndex(
-        this->comboBoxFileFormat->count() - 1);
+          this->comboBoxFileFormat->count() - 1);
     }
   }
 }
 
-PrintInitDialog::PrintInitDialog()
-{
+PrintInitDialog::PrintInitDialog() {
   setupUi(this);
 
   resetSelection();
 
-  this->checkBoxAlwaysShowDialog->setChecked(S::printServiceAlwaysShowDialog.value());
+  this->checkBoxAlwaysShowDialog->setChecked(
+      S::printServiceAlwaysShowDialog.value());
 
   // triggers addRemotePrintServiceButtons() if config value is "true"
   const auto remoteServicesEnabled = S::enableRemotePrintServices.value();
@@ -96,25 +97,23 @@ PrintInitDialog::PrintInitDialog()
     LOG(message_group::UI_Warning, "No external print services found");
   }
 
-  const auto& service = S::defaultPrintService.value();
+  const auto &service = S::defaultPrintService.value();
   const print_service_t printService = fromString(service);
   if (printService != print_service_t::NONE) {
     this->selectedPrintService = printService;
-    const auto& printServiceName = S::printServiceName.value();
+    const auto &printServiceName = S::printServiceName.value();
     this->selectedServiceName = QString::fromStdString(printServiceName);
 
     switch (printService) {
-    case print_service_t::PRINT_SERVICE:
-    {
-      for (const auto& button : this->buttonGroup->buttons()) {
-        const auto& name = button->property(PROPERTY_NAME);
+    case print_service_t::PRINT_SERVICE: {
+      for (const auto &button : this->buttonGroup->buttons()) {
+        const auto &name = button->property(PROPERTY_NAME);
         if (this->selectedServiceName == name.toString()) {
           button->click();
           break;
         }
       }
-    }
-    break;
+    } break;
     case print_service_t::OCTOPRINT:
       on_pushButtonOctoPrint_clicked();
       break;
@@ -127,8 +126,7 @@ PrintInitDialog::PrintInitDialog()
   }
 }
 
-void PrintInitDialog::resetSelection()
-{
+void PrintInitDialog::resetSelection() {
   this->textBrowser->setSource(QUrl{urlDialog});
   this->pushButtonOk->setEnabled(false);
   this->comboBoxFileFormat->setEnabled(false);
@@ -140,11 +138,10 @@ void PrintInitDialog::resetSelection()
   this->buttonGroup->setExclusive(true);
 }
 
-void PrintInitDialog::addRemotePrintServiceButtons()
-{
-  for (const auto& printServiceItem : PrintService::getPrintServices()) {
-    const auto& key = printServiceItem.first;
-    const auto& printService = printServiceItem.second;
+void PrintInitDialog::addRemotePrintServiceButtons() {
+  for (const auto &printServiceItem : PrintService::getPrintServices()) {
+    const auto &key = printServiceItem.first;
+    const auto &printService = printServiceItem.second;
     auto button = new QPushButton(printService->getDisplayName(), this);
     remoteServiceButtons.push_back(button);
     button->setCheckable(true);
@@ -152,12 +149,15 @@ void PrintInitDialog::addRemotePrintServiceButtons()
     button->setFocusPolicy(Qt::FocusPolicy::TabFocus);
     button->setProperty(PROPERTY_NAME, QVariant(QString::fromStdString(key)));
     buttonGroup->addButton(button);
-    this->printServiceLayout->insertWidget(this->printServiceLayout->count(), button);
+    this->printServiceLayout->insertWidget(this->printServiceLayout->count(),
+                                           button);
     connect(button, &QPushButton::clicked, this, [&]() {
       FileFormat currentFormat = FileFormat::ASCII_STL;
-      fileformat::fromIdentifier(S::printServiceFileFormat.value(), currentFormat);
+      fileformat::fromIdentifier(S::printServiceFileFormat.value(),
+                                 currentFormat);
       this->textBrowser->setHtml(printService->getInfoHtml());
-      this->populateFileFormatComboBox(printService->getFileFormats(), currentFormat);
+      this->populateFileFormatComboBox(printService->getFileFormats(),
+                                       currentFormat);
       this->selectedPrintService = print_service_t::PRINT_SERVICE;
       this->selectedServiceName = QString::fromStdString(key);
       this->comboBoxFileFormat->setEnabled(true);
@@ -166,8 +166,8 @@ void PrintInitDialog::addRemotePrintServiceButtons()
   }
 }
 
-void PrintInitDialog::on_checkBoxEnableRemotePrintServices_toggled(bool checked)
-{
+void PrintInitDialog::on_checkBoxEnableRemotePrintServices_toggled(
+    bool checked) {
   S::enableRemotePrintServices.setValue(checked);
   writeSettings();
 
@@ -187,40 +187,41 @@ void PrintInitDialog::on_checkBoxEnableRemotePrintServices_toggled(bool checked)
   resetSelection();
 }
 
-void PrintInitDialog::on_pushButtonOctoPrint_clicked()
-{
+void PrintInitDialog::on_pushButtonOctoPrint_clicked() {
   this->textBrowser->setSource(QUrl{urlOctoPrint});
   initComboBox(this->comboBoxFileFormat, S::octoPrintFileFormat);
-  this->on_comboBoxFileFormat_currentIndexChanged(this->comboBoxFileFormat->currentIndex());
+  this->on_comboBoxFileFormat_currentIndexChanged(
+      this->comboBoxFileFormat->currentIndex());
 
   this->selectedPrintService = print_service_t::OCTOPRINT;
   this->selectedServiceName = "";
 
   this->comboBoxFileFormat->setEnabled(true);
   this->pushButtonOk->setEnabled(true);
-  const auto fileFormatIdentifier = fileformat::info(this->getFileFormat()).identifier;
+  const auto fileFormatIdentifier =
+      fileformat::info(this->getFileFormat()).identifier;
   PRINTDB("OCTOPRINT: %s", fileFormatIdentifier);
 }
 
-void PrintInitDialog::on_pushButtonLocalApplication_clicked()
-{
+void PrintInitDialog::on_pushButtonLocalApplication_clicked() {
   // TODO: Instead of forcing people to use Preferences, we should add UI here
   // to select external program.
   this->textBrowser->setSource(QUrl{urlLocalApp});
 
   initComboBox(this->comboBoxFileFormat, S::localAppFileFormat);
-  this->on_comboBoxFileFormat_currentIndexChanged(this->comboBoxFileFormat->currentIndex());
+  this->on_comboBoxFileFormat_currentIndexChanged(
+      this->comboBoxFileFormat->currentIndex());
   this->selectedPrintService = print_service_t::LOCAL_APPLICATION;
   this->selectedServiceName = "";
 
   this->comboBoxFileFormat->setEnabled(true);
   this->pushButtonOk->setEnabled(true);
-  const auto fileFormatIdentifier = fileformat::info(this->getFileFormat()).identifier;
+  const auto fileFormatIdentifier =
+      fileformat::info(this->getFileFormat()).identifier;
   PRINTDB("LOCAL_APPLICATION: %s", fileFormatIdentifier);
 }
 
-void PrintInitDialog::setFileFormat(const std::string& id)
-{
+void PrintInitDialog::setFileFormat(const std::string &id) {
   FileFormat fileFormat = FileFormat::ASCII_STL;
   if (!fileformat::fromIdentifier(id, fileFormat)) {
     // FIXME: When would this error happen? Do we need to handle it?
@@ -229,21 +230,22 @@ void PrintInitDialog::setFileFormat(const std::string& id)
   this->selectedFileFormat = fileFormat;
 }
 
-void PrintInitDialog::on_comboBoxFileFormat_currentIndexChanged(int index)
-{
+void PrintInitDialog::on_comboBoxFileFormat_currentIndexChanged(int index) {
   if (index >= 0) {
-    const auto id = this->comboBoxFileFormat->currentData().toString().toStdString();
+    const auto id =
+        this->comboBoxFileFormat->currentData().toString().toStdString();
     this->setFileFormat(id);
   }
 }
 
-void PrintInitDialog::on_pushButtonOk_clicked()
-{
-  const QString defaultPrintServiceString = toString(this->selectedPrintService);
+void PrintInitDialog::on_pushButtonOk_clicked() {
+  const QString defaultPrintServiceString =
+      toString(this->selectedPrintService);
   S::defaultPrintService.setValue(defaultPrintServiceString.toStdString());
   S::printServiceName.setValue(this->selectedServiceName.toStdString());
 
-  const auto fileFormatIdentifier = fileformat::info(this->getFileFormat()).identifier;
+  const auto fileFormatIdentifier =
+      fileformat::info(this->getFileFormat()).identifier;
   switch (this->selectedPrintService) {
   case print_service_t::PRINT_SERVICE:
     S::printServiceFileFormat.setValue(fileFormatIdentifier);
@@ -262,13 +264,9 @@ void PrintInitDialog::on_pushButtonOk_clicked()
   accept();
 }
 
-void PrintInitDialog::on_pushButtonCancel_clicked()
-{
-  reject();
-}
+void PrintInitDialog::on_pushButtonCancel_clicked() { reject(); }
 
-int PrintInitDialog::exec()
-{
+int PrintInitDialog::exec() {
   bool showDialog = this->checkBoxAlwaysShowDialog->isChecked();
   if ((QApplication::keyboardModifiers() & Qt::ShiftModifier) != 0 ||
       this->selectedPrintService == print_service_t::NONE) {
@@ -278,24 +276,22 @@ int PrintInitDialog::exec()
   const auto result = showDialog ? QDialog::exec() : QDialog::Accepted;
 
   if (showDialog && result == QDialog::Accepted) {
-    S::printServiceAlwaysShowDialog.setValue(this->checkBoxAlwaysShowDialog->isChecked());
+    S::printServiceAlwaysShowDialog.setValue(
+        this->checkBoxAlwaysShowDialog->isChecked());
     writeSettings();
   }
 
   return result;
 }
 
-print_service_t PrintInitDialog::getServiceType() const
-{
+print_service_t PrintInitDialog::getServiceType() const {
   return this->selectedPrintService;
 }
 
-QString PrintInitDialog::getServiceName() const
-{
+QString PrintInitDialog::getServiceName() const {
   return this->selectedServiceName;
 }
 
-FileFormat PrintInitDialog::getFileFormat() const
-{
+FileFormat PrintInitDialog::getFileFormat() const {
   return this->selectedFileFormat;
 }
diff --git a/src/gui/PrintInitDialog.h b/src/gui/PrintInitDialog.h
index 34e0c722c..eaea4efda 100644
--- a/src/gui/PrintInitDialog.h
+++ b/src/gui/PrintInitDialog.h
@@ -26,30 +26,37 @@
 
 #pragma once
 
-#include "gui/qtgettext.h" // IWYU pragma: keep
+#include "gui/qtgettext.h"      // IWYU pragma: keep
 #include "ui_PrintInitDialog.h" // generated, but needs qtgettext.h
 
 #include <vector>
 
-#include <QList>
 #include <QDialog>
+#include <QList>
 #include <QPushButton>
 
-#include "io/export.h"
 #include "gui/InitConfigurator.h"
+#include "io/export.h"
 
 // Property name for remote print servive buttons
 constexpr inline auto PROPERTY_NAME = "printServiceName";
 
-enum class print_service_t : std::uint8_t { NONE, PRINT_SERVICE, OCTOPRINT, LOCAL_APPLICATION };
+enum class print_service_t : std::uint8_t {
+  NONE,
+  PRINT_SERVICE,
+  OCTOPRINT,
+  LOCAL_APPLICATION
+};
 
-class PrintInitDialog : public QDialog, public Ui::PrintInitDialog, public InitConfigurator
-{
+class PrintInitDialog : public QDialog,
+                        public Ui::PrintInitDialog,
+                        public InitConfigurator {
   constexpr static auto urlDialog = "qrc:/html/PrintInitDialog.html";
   constexpr static auto urlOctoPrint = "qrc:/html/OctoPrintInfo.html";
   constexpr static auto urlLocalApp = "qrc:/html/LocalApplicationInfo.html";
 
   Q_OBJECT;
+
 public:
   PrintInitDialog();
   int exec() override;
@@ -65,12 +72,13 @@ public slots:
   void on_checkBoxEnableRemotePrintServices_toggled(bool);
   void on_pushButtonOk_clicked();
   void on_pushButtonCancel_clicked();
+
 private:
   void resetSelection();
   void addRemotePrintServiceButtons();
-  void populateFileFormatComboBox(const std::vector<FileFormat>& fileFormats,
+  void populateFileFormatComboBox(const std::vector<FileFormat> &fileFormats,
                                   FileFormat currentFormat);
-  void setFileFormat(const std::string& identifier);
+  void setFileFormat(const std::string &identifier);
 
   QString htmlTemplate;
   print_service_t selectedPrintService = print_service_t::NONE;
diff --git a/src/gui/PrintService.cc b/src/gui/PrintService.cc
index b9f703538..c8da0f902 100644
--- a/src/gui/PrintService.cc
+++ b/src/gui/PrintService.cc
@@ -26,11 +26,11 @@
 
 #include "gui/PrintService.h"
 
-#include <mutex>
-#include <utility>
-#include <unordered_map>
 #include <memory>
+#include <mutex>
 #include <string>
+#include <unordered_map>
+#include <utility>
 
 #include <QJsonDocument>
 #include <QNetworkAccessManager>
@@ -38,8 +38,8 @@
 #include <QNetworkRequest>
 #include <QStringList>
 
-#include "io/export.h"
 #include "core/Settings.h"
+#include "io/export.h"
 #include "utils/printutils.h"
 
 using S = Settings::Settings;
@@ -50,9 +50,10 @@ PrintServices PrintService::printServices;
 namespace {
 
 std::unique_ptr<PrintService>
-createPrintService(const QJsonObject& serviceObject) {
+createPrintService(const QJsonObject &serviceObject) {
   auto service = std::make_unique<PrintService>();
-  if (service->init(serviceObject))return service;
+  if (service->init(serviceObject))
+    return service;
   return nullptr;
 }
 
@@ -60,35 +61,36 @@ PrintServices createPrintServices() {
   PrintServices printServices;
   try {
     auto networkRequest = NetworkRequest<void>{
-      QUrl{"https://app.openscad.org/print-service.json"}, {200}, 30};
+        QUrl{"https://app.openscad.org/print-service.json"}, {200}, 30};
     networkRequest.execute(
-      [](QNetworkRequest& request) {
-        request.setHeader(QNetworkRequest::ContentTypeHeader,
-                          "application/json");
-      },
-      [](QNetworkAccessManager& nam, QNetworkRequest& request) {
-        return nam.get(request);
-      },
-      [&](QNetworkReply *reply) {
-        const auto doc = QJsonDocument::fromJson(reply->readAll());
-        PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
-        const QStringList services = doc.object().keys();
-        for (const auto& serviceName : services) {
-          auto printService =
-            createPrintService(doc.object().value(serviceName).toObject());
-          if (printService) {
-            printServices[serviceName.toStdString()] =
-              std::move(printService);
+        [](QNetworkRequest &request) {
+          request.setHeader(QNetworkRequest::ContentTypeHeader,
+                            "application/json");
+        },
+        [](QNetworkAccessManager &nam, QNetworkRequest &request) {
+          return nam.get(request);
+        },
+        [&](QNetworkReply *reply) {
+          const auto doc = QJsonDocument::fromJson(reply->readAll());
+          PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
+          const QStringList services = doc.object().keys();
+          for (const auto &serviceName : services) {
+            auto printService =
+                createPrintService(doc.object().value(serviceName).toObject());
+            if (printService) {
+              printServices[serviceName.toStdString()] =
+                  std::move(printService);
+            }
           }
-        }
-      });
-  } catch (const NetworkException& e) {
+        });
+  } catch (const NetworkException &e) {
     LOG(message_group::Error, "%1$s", e.getErrorMessage());
   }
-  for (const auto& printService : printServices) {
-    const auto& name = printService.second->getDisplayName().toStdString();
-    const auto& limit = printService.second->getFileSizeLimitMB();
-    PRINTDB("External print service available: %1$s (upload limit = %2$d MB)", name % limit);
+  for (const auto &printService : printServices) {
+    const auto &name = printService.second->getDisplayName().toStdString();
+    const auto &limit = printService.second->getFileSizeLimitMB();
+    PRINTDB("External print service available: %1$s (upload limit = %2$d MB)",
+            name % limit);
     // TODO: Log if wanted
   }
 
@@ -97,7 +99,7 @@ PrintServices createPrintServices() {
 
 } // namespace
 
-const PrintServices& PrintService::getPrintServices() {
+const PrintServices &PrintService::getPrintServices() {
   static PrintServices noPrintServices;
 
   std::lock_guard<std::mutex> guard(printServiceMutex);
@@ -113,23 +115,25 @@ const PrintServices& PrintService::getPrintServices() {
   return printServices;
 }
 
-const PrintService *PrintService::getPrintService(const std::string& name) {
-  const auto& printServices = getPrintServices();
+const PrintService *PrintService::getPrintService(const std::string &name) {
+  const auto &printServices = getPrintServices();
   if (const auto it = printServices.find(name); it != printServices.end()) {
     return it->second.get();
   }
   return nullptr;
 }
 
-bool PrintService::init(const QJsonObject& serviceObject) {
+bool PrintService::init(const QJsonObject &serviceObject) {
   displayName = serviceObject.value("displayName").toString();
   apiUrl = serviceObject.value("apiUrl").toString();
   fileSizeLimitMB = serviceObject.value("fileSizeLimitMB").toInt();
   infoHtml = serviceObject.value("infoHtml").toString();
   infoUrl = serviceObject.value("infoUrl").toString();
-  for (const auto& variant : serviceObject.value("fileFormats").toArray().toVariantList()) {
+  for (const auto &variant :
+       serviceObject.value("fileFormats").toArray().toVariantList()) {
     FileFormat fileFormat;
-    if (fileformat::fromIdentifier(variant.toString().toStdString(), fileFormat)) {
+    if (fileformat::fromIdentifier(variant.toString().toStdString(),
+                                   fileFormat)) {
       fileFormats.push_back(fileFormat);
     }
     // TODO: else print warning?
@@ -156,8 +160,8 @@ bool PrintService::init(const QJsonObject& serviceObject) {
  *    The resulting url to go to next to continue the order process.
  */
 const QString
-PrintService::upload(const QString& fileName, const QString& contentBase64,
-                     const network_progress_func_t& progress_func) const {
+PrintService::upload(const QString &fileName, const QString &contentBase64,
+                     const network_progress_func_t &progress_func) const {
   QJsonObject jsonInput;
   jsonInput.insert("fileName", fileName);
   jsonInput.insert("file", contentBase64);
@@ -169,36 +173,36 @@ PrintService::upload(const QString& fileName, const QString& contentBase64,
   // about 96MB data.
   if (jsonInput.value("file") == QJsonValue::Undefined) {
     const QString msg =
-      "Could not encode STL into JSON. Perhaps it is too large of a file? "
-      "Maybe try reducing the model resolution.";
+        "Could not encode STL into JSON. Perhaps it is too large of a file? "
+        "Maybe try reducing the model resolution.";
     throw NetworkException(QNetworkReply::ProtocolFailure, msg);
   }
 
   auto networkRequest =
-    NetworkRequest<const QString>{QUrl{apiUrl}, {200, 201}, 180};
+      NetworkRequest<const QString>{QUrl{apiUrl}, {200, 201}, 180};
   networkRequest.set_progress_func(progress_func);
   return networkRequest.execute(
-    [](QNetworkRequest& request) {
-    request.setHeader(QNetworkRequest::ContentTypeHeader,
-                      "application/json");
-  },
-    [&](QNetworkAccessManager& nam, QNetworkRequest& request) {
-    return nam.post(request, QJsonDocument(jsonInput).toJson());
-  },
-    [](QNetworkReply *reply) {
-    const auto doc = QJsonDocument::fromJson(reply->readAll());
-    PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
-
-    // Extract cartUrl which gives the page to open in a webbrowser to view
-    // uploaded part
-    auto cartUrlValue =
-      doc.object().value("data").toObject().value("cartUrl");
-    auto cartUrl = cartUrlValue.toString();
-    if ((cartUrlValue == QJsonValue::Undefined) || (cartUrl.isEmpty())) {
-      const QString msg = "Could not get data.cartUrl field from response.";
-      throw NetworkException(QNetworkReply::ProtocolFailure, msg);
-    }
-    LOG("Upload finished, opening URL %1$s.", cartUrl.toStdString());
-    return cartUrl;
-  });
+      [](QNetworkRequest &request) {
+        request.setHeader(QNetworkRequest::ContentTypeHeader,
+                          "application/json");
+      },
+      [&](QNetworkAccessManager &nam, QNetworkRequest &request) {
+        return nam.post(request, QJsonDocument(jsonInput).toJson());
+      },
+      [](QNetworkReply *reply) {
+        const auto doc = QJsonDocument::fromJson(reply->readAll());
+        PRINTDB("Response: %s", QString{doc.toJson()}.toStdString());
+
+        // Extract cartUrl which gives the page to open in a webbrowser to view
+        // uploaded part
+        auto cartUrlValue =
+            doc.object().value("data").toObject().value("cartUrl");
+        auto cartUrl = cartUrlValue.toString();
+        if ((cartUrlValue == QJsonValue::Undefined) || (cartUrl.isEmpty())) {
+          const QString msg = "Could not get data.cartUrl field from response.";
+          throw NetworkException(QNetworkReply::ProtocolFailure, msg);
+        }
+        LOG("Upload finished, opening URL %1$s.", cartUrl.toStdString());
+        return cartUrl;
+      });
 }
diff --git a/src/gui/PrintService.h b/src/gui/PrintService.h
index 28f408c3b..47a6bc3bf 100644
--- a/src/gui/PrintService.h
+++ b/src/gui/PrintService.h
@@ -27,23 +27,23 @@
 #pragma once
 
 #include <memory>
-#include <unordered_map>
+#include <mutex>
 #include <string>
+#include <unordered_map>
 #include <vector>
-#include <mutex>
 
+#include <QJsonDocument>
+#include <QJsonObject>
 #include <QString>
 #include <QStringList>
-#include <QJsonObject>
-#include <QJsonDocument>
 
-#include "io/export.h"
 #include "gui/Network.h"
+#include "io/export.h"
 
-using PrintServices = std::unordered_map<std::string, std::unique_ptr<class PrintService>>;
+using PrintServices =
+    std::unordered_map<std::string, std::unique_ptr<class PrintService>>;
 
-class PrintService
-{
+class PrintService {
 public:
   const QString getService() const { return service; }
   const QString getDisplayName() const { return displayName; }
@@ -54,15 +54,15 @@ public:
   const QString getInfoUrl() const { return infoUrl; }
   const std::vector<FileFormat> getFileFormats() const { return fileFormats; }
 
-  const QString upload(const QString& exportFileName, const QString& fileName, const network_progress_func_t& progress_func) const;
+  const QString upload(const QString &exportFileName, const QString &fileName,
+                       const network_progress_func_t &progress_func) const;
 
-  bool init(const QJsonObject& serviceObject);
+  bool init(const QJsonObject &serviceObject);
 
-  static const PrintService *getPrintService(const std::string& name);
-  static const PrintServices& getPrintServices();
+  static const PrintService *getPrintService(const std::string &name);
+  static const PrintServices &getPrintServices();
 
 private:
-
   QString service;
   QString displayName;
   QString apiUrl;
diff --git a/src/gui/ProgressWidget.cc b/src/gui/ProgressWidget.cc
index 24229f9b6..fee8ac2f7 100644
--- a/src/gui/ProgressWidget.cc
+++ b/src/gui/ProgressWidget.cc
@@ -1,49 +1,34 @@
 #include "gui/ProgressWidget.h"
-#include <QWidget>
 #include <QTimer>
+#include <QWidget>
 
-ProgressWidget::ProgressWidget(QWidget *parent)
-  : QWidget(parent)
-{
+ProgressWidget::ProgressWidget(QWidget *parent) : QWidget(parent) {
   setupUi(this);
   setRange(0, 1000);
   setValue(0);
   this->wascanceled = false;
   this->starttime.start();
 
-  connect(this->stopButton, &QPushButton::clicked, this, &ProgressWidget::cancel);
+  connect(this->stopButton, &QPushButton::clicked, this,
+          &ProgressWidget::cancel);
   QTimer::singleShot(1000, this, &ProgressWidget::requestShow);
 }
 
-bool ProgressWidget::wasCanceled() const
-{
-  return this->wascanceled;
-}
+bool ProgressWidget::wasCanceled() const { return this->wascanceled; }
 
 /*!
    Returns milliseconds since this widget was created
  */
-int ProgressWidget::elapsedTime() const
-{
-  return this->starttime.elapsed();
-}
+int ProgressWidget::elapsedTime() const { return this->starttime.elapsed(); }
 
-void ProgressWidget::cancel()
-{
-  this->wascanceled = true;
-}
+void ProgressWidget::cancel() { this->wascanceled = true; }
 
-void ProgressWidget::setRange(int minimum, int maximum)
-{
+void ProgressWidget::setRange(int minimum, int maximum) {
   this->progressBar->setRange(minimum, maximum);
 }
 
-void ProgressWidget::setValue(int progress)
-{
+void ProgressWidget::setValue(int progress) {
   this->progressBar->setValue(progress);
 }
 
-int ProgressWidget::value() const
-{
-  return this->progressBar->value();
-}
+int ProgressWidget::value() const { return this->progressBar->value(); }
diff --git a/src/gui/ProgressWidget.h b/src/gui/ProgressWidget.h
index 6f0723325..65d5df31f 100644
--- a/src/gui/ProgressWidget.h
+++ b/src/gui/ProgressWidget.h
@@ -2,11 +2,10 @@
 
 #include "gui/qtgettext.h"
 #include "ui_ProgressWidget.h"
-#include <QWidget>
 #include <QElapsedTimer>
+#include <QWidget>
 
-class ProgressWidget : public QWidget, public Ui::ProgressWidget
-{
+class ProgressWidget : public QWidget, public Ui::ProgressWidget {
   Q_OBJECT;
   Q_PROPERTY(bool wasCanceled READ wasCanceled);
 
diff --git a/src/gui/QGLView.cc b/src/gui/QGLView.cc
index d8da76924..4ade30b96 100644
--- a/src/gui/QGLView.cc
+++ b/src/gui/QGLView.cc
@@ -28,30 +28,30 @@
 #include <QtCore/qpoint.h>
 
 #include "geometry/linalg.h"
-#include "gui/qtgettext.h"
-#include "gui/Preferences.h"
 #include "glview/Renderer.h"
+#include "gui/Preferences.h"
+#include "gui/qtgettext.h"
 #include "utils/degree_trig.h"
 #include "utils/scope_guard.hpp"
 #if defined(USE_GLEW) || defined(OPENCSG_GLEW)
 #include "glview/glew-utils.h"
 #endif
 
-#include <QImage>
-#include <QOpenGLWidget>
-#include <QWidget>
-#include <iostream>
 #include <QApplication>
-#include <QWheelEvent>
 #include <QCheckBox>
 #include <QDialogButtonBox>
-#include <QMouseEvent>
+#include <QErrorMessage>
+#include <QImage>
 #include <QMessageBox>
+#include <QMouseEvent>
+#include <QOpenGLWidget>
 #include <QPushButton>
-#include <QTimer>
 #include <QTextEdit>
+#include <QTimer>
 #include <QVBoxLayout>
-#include <QErrorMessage>
+#include <QWheelEvent>
+#include <QWidget>
+#include <iostream>
 #ifdef USE_GLAD
 #include <QOpenGLContext>
 #endif
@@ -63,25 +63,20 @@
 #include <vector>
 
 #ifdef ENABLE_OPENCSG
-#  include <opencsg.h>
+#include <opencsg.h>
 #endif
 
-#include "gui/qt-obsolete.h"
 #include "gui/Measurement.h"
+#include "gui/qt-obsolete.h"
 
-QGLView::QGLView(QWidget *parent) : QOpenGLWidget(parent)
-{
-  init();
-}
+QGLView::QGLView(QWidget *parent) : QOpenGLWidget(parent) { init(); }
 
-QGLView::~QGLView()
-{
+QGLView::~QGLView() {
   // Just to make sure we can call GL functions in the supertype destructor
   makeCurrent();
 }
 
-void QGLView::init()
-{
+void QGLView::init() {
   resetView();
 
   this->mouse_drag_active = false;
@@ -90,13 +85,9 @@ void QGLView::init()
   setMouseTracking(true);
 }
 
-void QGLView::resetView()
-{
-  cam.resetView();
-}
+void QGLView::resetView() { cam.resetView(); }
 
-void QGLView::viewAll()
-{
+void QGLView::viewAll() {
   if (auto renderer = this->getRenderer()) {
     auto bbox = renderer->getBoundingBox();
     cam.autocenter = true;
@@ -104,8 +95,7 @@ void QGLView::viewAll()
   }
 }
 
-void QGLView::initializeGL()
-{
+void QGLView::initializeGL() {
 #if defined(USE_GLEW) || defined(OPENCSG_GLEW)
   // Since OpenCSG requires glew, we need to initialize it.
   // ..in a separate compilation unit to avoid duplicate symbols with x.
@@ -113,22 +103,24 @@ void QGLView::initializeGL()
 #endif
 #ifdef USE_GLAD
   // We could ask for gladLoadGLES2UserPtr() here if we want to use GLES2+
-  const auto version = gladLoadGLUserPtr([](void *ctx, const char *name) -> GLADapiproc {
-    return reinterpret_cast<QOpenGLContext *>(ctx)->getProcAddress(name);
-  }, this->context());
+  const auto version = gladLoadGLUserPtr(
+      [](void *ctx, const char *name) -> GLADapiproc {
+        return reinterpret_cast<QOpenGLContext *>(ctx)->getProcAddress(name);
+      },
+      this->context());
   if (version == 0) {
     std::cerr << "Unable to init GLAD" << std::endl;
     return;
   }
-  PRINTDB("GLAD: Loaded OpenGL %d.%d", GLAD_VERSION_MAJOR(version) % GLAD_VERSION_MINOR(version));
+  PRINTDB("GLAD: Loaded OpenGL %d.%d",
+          GLAD_VERSION_MAJOR(version) % GLAD_VERSION_MINOR(version));
 #endif // ifdef USE_GLAD
   GLView::initializeGL();
 
   this->selector = std::make_unique<MouseSelector>(this);
 }
 
-std::string QGLView::getRendererInfo() const
-{
+std::string QGLView::getRendererInfo() const {
   std::ostringstream info;
   info << gl_dump();
   // Don't translate as translated text in the Library Info dialog is not wanted
@@ -140,25 +132,27 @@ std::string QGLView::getRendererInfo() const
   auto abits = qsf.alphaBufferSize();
   auto dbits = qsf.depthBufferSize();
   auto sbits = qsf.stencilBufferSize();
-  info << boost::format("\nQSurfaceFormat: RGBA(%d%d%d%d), depth(%d), stencil(%d)\n\n") %
-    rbits % gbits % bbits % abits % dbits % sbits;
+  info << boost::format(
+              "\nQSurfaceFormat: RGBA(%d%d%d%d), depth(%d), stencil(%d)\n\n") %
+              rbits % gbits % bbits % abits % dbits % sbits;
   info << gl_extensions_dump();
   return info.str();
 }
 
 #ifdef ENABLE_OPENCSG
-void QGLView::display_opencsg_warning()
-{
-  if (GlobalPreferences::inst()->getValue("advanced/opencsg_show_warning").toBool()) {
+void QGLView::display_opencsg_warning() {
+  if (GlobalPreferences::inst()
+          ->getValue("advanced/opencsg_show_warning")
+          .toBool()) {
     QTimer::singleShot(0, this, &QGLView::display_opencsg_warning_dialog);
   }
 }
 
-void QGLView::display_opencsg_warning_dialog()
-{
+void QGLView::display_opencsg_warning_dialog() {
   auto dialog = new OpenCSGWarningDialog(this);
 
-  QString message = _("Warning: Missing OpenGL capabilities for OpenCSG - OpenCSG has been disabled.\n\n");
+  QString message = _("Warning: Missing OpenGL capabilities for OpenCSG - "
+                      "OpenCSG has been disabled.\n\n");
   message += _("It is highly recommended to use OpenSCAD on a system with "
                "OpenGL 2.0 or later.\n"
                "Your renderer information is as follows:\n");
@@ -181,27 +175,24 @@ void QGLView::display_opencsg_warning_dialog()
 }
 #endif // ifdef ENABLE_OPENCSG
 
-void QGLView::resizeGL(int w, int h)
-{
+void QGLView::resizeGL(int w, int h) {
   GLView::resizeGL(w, h);
   emit resized();
 }
 
-void QGLView::paintGL()
-{
+void QGLView::paintGL() {
   GLView::paintGL();
 
   if (statusLabel) {
     auto status = QString("%1 (%2x%3)")
-      .arg(QString::fromStdString(cam.statusText()))
-      .arg(size().rwidth())
-      .arg(size().rheight());
+                      .arg(QString::fromStdString(cam.statusText()))
+                      .arg(size().rwidth())
+                      .arg(size().rheight());
     statusLabel->setText(status);
   }
 }
 
-void QGLView::mousePressEvent(QMouseEvent *event)
-{
+void QGLView::mousePressEvent(QMouseEvent *event) {
   if (!mouse_drag_active) {
     mouse_drag_moved = false;
   }
@@ -214,40 +205,47 @@ void QGLView::mousePressEvent(QMouseEvent *event)
  * Voodoo warning...
  *
  * This function selects the widget's OpenGL context (via this->makeCurrent()).
- * Because it's changing the OpenGL context, it seems polite to save and restore it.
- * That resolution seems correct, independent of the mysteries below.
+ * Because it's changing the OpenGL context, it seems polite to save and restore
+ * it. That resolution seems correct, independent of the mysteries below.
  *
- * Let's call the widget's context W, and the alternate context that we are called with A.
+ * Let's call the widget's context W, and the alternate context that we are
+ * called with A.
  *
- * It's important that A is selected when we return (as it is when we enter), because
- * if it isn't then sometimes the subsequent mouseReleaseEvent is called with W, when it
- * is normally called with A.  When that happens, the object-selection magic in selectObject
- * messes up W, and rendering is forever after broken in that window.
+ * It's important that A is selected when we return (as it is when we enter),
+ * because if it isn't then sometimes the subsequent mouseReleaseEvent is called
+ * with W, when it is normally called with A.  When that happens, the
+ * object-selection magic in selectObject messes up W, and rendering is forever
+ * after broken in that window.
  *
- * However, as hygienic as saving-and-restoring seems, the picture is still unsatisfying.
+ * However, as hygienic as saving-and-restoring seems, the picture is still
+ * unsatisfying.
  *
  * Open questions:
- * - Why are these mouse event functions called with A, rather than being called with W?
- *   It's unsurprising that the selection magic needs its own GL context, but it seems like
- *   it should be the one that needs to explicitly select it, not this function.
+ * - Why are these mouse event functions called with A, rather than being called
+ * with W? It's unsurprising that the selection magic needs its own GL context,
+ * but it seems like it should be the one that needs to explicitly select it,
+ * not this function.
  * - Where did A come from?
  * - Why does a subsequent mouseReleaseEvent call get called with W?
- * - Why does it only sometimes get called with W, and sometimes (correctly) with A?
- * - Why do later mouseReleaseEvent calls revert to being (correctly) called with A?
- * - Why does this only happen with right clicks?  With left clicks, this function
- *   changes the context, but it's OK again on the following mouseReleaseEvent.
- * - Why does this only happen when you click on empty space, and not when you click
- *   on the model?  Double clicks on the model are not detected as double clicks.
- *   Perhaps this is because the first click pops a menu and the second click is
- *   on the menu, not this widget.
+ * - Why does it only sometimes get called with W, and sometimes (correctly)
+ * with A?
+ * - Why do later mouseReleaseEvent calls revert to being (correctly) called
+ * with A?
+ * - Why does this only happen with right clicks?  With left clicks, this
+ * function changes the context, but it's OK again on the following
+ * mouseReleaseEvent.
+ * - Why does this only happen when you click on empty space, and not when you
+ * click on the model?  Double clicks on the model are not detected as double
+ * clicks. Perhaps this is because the first click pops a menu and the second
+ * click is on the menu, not this widget.
  *
- * getGLContext() and setGLContext() are in a separate file, QGLView2.cc, so that this
- * file doesn't need a full declaration of QOpenGLContext.  <QOpenGLContext> is
- * incompatible with GLEW and causes compilation warnings.
+ * getGLContext() and setGLContext() are in a separate file, QGLView2.cc, so
+ * that this file doesn't need a full declaration of QOpenGLContext.
+ * <QOpenGLContext> is incompatible with GLEW and causes compilation warnings.
  *
  * For future attention:
- * - This function should probably only react to left double clicks.  Right double clicks
- *   should probably be ignored.
+ * - This function should probably only react to left double clicks.  Right
+ * double clicks should probably be ignored.
  */
 void QGLView::mouseDoubleClickEvent(QMouseEvent *event) {
   QOpenGLContext *oldContext = getGLContext();
@@ -272,7 +270,8 @@ void QGLView::mouseDoubleClickEvent(QMouseEvent *event) {
   if (const auto glError = glGetError(); glError != GL_NO_ERROR) {
     if (statusLabel) {
       auto status = QString("Center View: OpenGL Error reading Pixel: %s")
-        .arg(QString::fromLocal8Bit((const char *)gluErrorString(glError)));
+                        .arg(QString::fromLocal8Bit(
+                            (const char *)gluErrorString(glError)));
       statusLabel->setText(status);
     }
     setGLContext(oldContext);
@@ -286,7 +285,8 @@ void QGLView::mouseDoubleClickEvent(QMouseEvent *event) {
 
   GLdouble px, py, pz;
 
-  auto success = gluUnProject(x, y, z, modelview, projection, viewport, &px, &py, &pz);
+  auto success =
+      gluUnProject(x, y, z, modelview, projection, viewport, &px, &py, &pz);
 
   if (success == GL_TRUE) {
     cam.object_trans -= Vector3d(px, py, pz);
@@ -296,14 +296,14 @@ void QGLView::mouseDoubleClickEvent(QMouseEvent *event) {
   setGLContext(oldContext);
 }
 
-void QGLView::normalizeAngle(GLdouble& angle)
-{
-  while (angle < 0) angle += 360;
-  while (angle > 360) angle -= 360;
+void QGLView::normalizeAngle(GLdouble &angle) {
+  while (angle < 0)
+    angle += 360;
+  while (angle > 360)
+    angle -= 360;
 }
 
-void QGLView::mouseMoveEvent(QMouseEvent *event)
-{
+void QGLView::mouseMoveEvent(QMouseEvent *event) {
   auto this_mouse = event->globalPos();
   if (measure_state != MEASURE_IDLE) {
     QPoint pt = event->pos();
@@ -314,12 +314,13 @@ void QGLView::mouseMoveEvent(QMouseEvent *event)
   double dy = (this_mouse.y() - last_mouse.y()) * 0.7;
   if (mouse_drag_active) {
     mouse_drag_moved = true;
-    auto button_compare = this->mouseSwapButtons?Qt::RightButton : Qt::LeftButton;
+    auto button_compare =
+        this->mouseSwapButtons ? Qt::RightButton : Qt::LeftButton;
     if (event->buttons() & button_compare
 #ifdef Q_OS_MACOS
         && !(event->modifiers() & Qt::MetaModifier)
 #endif
-        ) {
+    ) {
       // Left button rotates in xz, Shift-left rotates in xy
       // On Mac, Ctrl-Left is handled as right button on other platforms
       if ((QApplication::keyboardModifiers() & Qt::ShiftModifier) != 0) {
@@ -356,13 +357,12 @@ void QGLView::mouseMoveEvent(QMouseEvent *event)
   last_mouse = this_mouse;
 }
 
-void QGLView::mouseReleaseEvent(QMouseEvent *event)
-{
+void QGLView::mouseReleaseEvent(QMouseEvent *event) {
   mouse_drag_active = false;
   releaseMouse();
 
-  auto button_right = this->mouseSwapButtons?Qt::LeftButton : Qt::RightButton;
-  auto button_left = this->mouseSwapButtons?Qt::RightButton : Qt::LeftButton;
+  auto button_right = this->mouseSwapButtons ? Qt::LeftButton : Qt::RightButton;
+  auto button_left = this->mouseSwapButtons ? Qt::RightButton : Qt::LeftButton;
   if (!mouse_drag_moved) {
     if (event->button() == button_right) {
       QPoint point = event->pos();
@@ -376,21 +376,19 @@ void QGLView::mouseReleaseEvent(QMouseEvent *event)
   mouse_drag_moved = false;
 }
 
-const QImage& QGLView::grabFrame()
-{
-  // Force reading from front buffer. Some configurations will read from the back buffer here.
+const QImage &QGLView::grabFrame() {
+  // Force reading from front buffer. Some configurations will read from the
+  // back buffer here.
   glReadBuffer(GL_FRONT);
   this->frame = grabFramebuffer();
   return this->frame;
 }
 
-bool QGLView::save(const char *filename) const
-{
+bool QGLView::save(const char *filename) const {
   return this->frame.save(filename, "PNG");
 }
 
-void QGLView::wheelEvent(QWheelEvent *event)
-{
+void QGLView::wheelEvent(QWheelEvent *event) {
   const auto pos = Q_WHEEL_EVENT_POSITION(event);
   const int v = event->angleDelta().y();
   if (QApplication::keyboardModifiers() & Qt::ShiftModifier) {
@@ -402,32 +400,23 @@ void QGLView::wheelEvent(QWheelEvent *event)
   }
 }
 
-void QGLView::ZoomIn()
-{
-  zoom(120, true);
-}
+void QGLView::ZoomIn() { zoom(120, true); }
 
-void QGLView::ZoomOut()
-{
-  zoom(-120, true);
-}
+void QGLView::ZoomOut() { zoom(-120, true); }
 
-void QGLView::zoom(double v, bool relative)
-{
+void QGLView::zoom(double v, bool relative) {
   this->cam.zoom(v, relative);
   update();
   emit cameraChanged();
 }
 
-void QGLView::zoomFov(double v)
-{
+void QGLView::zoomFov(double v) {
   this->cam.setVpf(this->cam.fovValue() * pow(0.9, v / 120.0));
   update();
   emit cameraChanged();
 }
 
-void QGLView::zoomCursor(int x, int y, int zoom)
-{
+void QGLView::zoomCursor(int x, int y, int zoom) {
   const auto old_dist = cam.zoomValue();
   this->cam.zoom(zoom, true);
   const auto dist = cam.zoomValue();
@@ -441,14 +430,15 @@ void QGLView::zoomCursor(int x, int y, int zoom)
   translate(-mx, 0, -mz, true);
 }
 
-void QGLView::setOrthoMode(bool enabled)
-{
-  if (enabled) this->cam.setProjection(Camera::ProjectionType::ORTHOGONAL);
-  else this->cam.setProjection(Camera::ProjectionType::PERSPECTIVE);
+void QGLView::setOrthoMode(bool enabled) {
+  if (enabled)
+    this->cam.setProjection(Camera::ProjectionType::ORTHOGONAL);
+  else
+    this->cam.setProjection(Camera::ProjectionType::PERSPECTIVE);
 }
 
-void QGLView::translate(double x, double y, double z, bool relative, bool viewPortRelative)
-{
+void QGLView::translate(double x, double y, double z, bool relative,
+                        bool viewPortRelative) {
   Matrix3d aax, aay, aaz;
   aax = angle_axis_degrees(-cam.object_rot.x(), Vector3d::UnitX());
   aay = angle_axis_degrees(-cam.object_rot.y(), Vector3d::UnitY());
@@ -465,12 +455,7 @@ void QGLView::translate(double x, double y, double z, bool relative, bool viewPo
   }
 
   Matrix4d vec;
-  vec <<
-    0, 0, 0, x,
-    0, 0, 0, y,
-    0, 0, 0, z,
-    0, 0, 0, 1
-  ;
+  vec << 0, 0, 0, x, 0, 0, 0, y, 0, 0, 0, z, 0, 0, 0, 1;
   tm = tm * vec;
   double f = relative ? 1 : 0;
   cam.object_trans.x() = f * cam.object_trans.x() + tm(0, 3);
@@ -480,8 +465,7 @@ void QGLView::translate(double x, double y, double z, bool relative, bool viewPo
   emit cameraChanged();
 }
 
-void QGLView::rotate(double x, double y, double z, bool relative)
-{
+void QGLView::rotate(double x, double y, double z, bool relative) {
   double f = relative ? 1 : 0;
   cam.object_rot.x() = f * cam.object_rot.x() + x;
   cam.object_rot.y() = f * cam.object_rot.y() + y;
@@ -493,8 +477,7 @@ void QGLView::rotate(double x, double y, double z, bool relative)
   emit cameraChanged();
 }
 
-void QGLView::rotate2(double x, double y, double z)
-{
+void QGLView::rotate2(double x, double y, double z) {
   // This vector describes the rotation.
   // The direction of the vector is the angle around which to rotate, and
   // the length of the vector is the angle by which to rotate
@@ -515,8 +498,10 @@ void QGLView::rotate2(double x, double y, double z)
   double theta, psi, phi;
   if (abs(rmx(2, 0)) != 1) {
     theta = -asin_degrees(rmx(2, 0));
-    psi = atan2_degrees(rmx(2, 1) / cos_degrees(theta), rmx(2, 2) / cos_degrees(theta));
-    phi = atan2_degrees(rmx(1, 0) / cos_degrees(theta), rmx(0, 0) / cos_degrees(theta));
+    psi = atan2_degrees(rmx(2, 1) / cos_degrees(theta),
+                        rmx(2, 2) / cos_degrees(theta));
+    phi = atan2_degrees(rmx(1, 0) / cos_degrees(theta),
+                        rmx(0, 0) / cos_degrees(theta));
   } else {
     phi = 0;
     if (rmx(2, 0) == -1) {
@@ -540,8 +525,7 @@ void QGLView::rotate2(double x, double y, double z)
   emit cameraChanged();
 }
 
-std::vector<SelectedObject> QGLView::findObject(int mouse_x, int mouse_y)
-{
+std::vector<SelectedObject> QGLView::findObject(int mouse_x, int mouse_y) {
   int viewport[4] = {0, 0, 0, 0};
   double posXF, posYF, posZF;
   double posXN, posYN, posZN;
@@ -551,21 +535,24 @@ std::vector<SelectedObject> QGLView::findObject(int mouse_x, int mouse_y)
   GLdouble winX = mouse_x;
   GLdouble winY = viewport[3] - mouse_y;
 
-  gluUnProject(winX, winY, 1, this->modelview, this->projection, viewport, &posXF, &posYF, &posZF);
-  gluUnProject(winX, winY, -1, this->modelview, this->projection, viewport, &posXN, &posYN, &posZN);
+  gluUnProject(winX, winY, 1, this->modelview, this->projection, viewport,
+               &posXF, &posYF, &posZF);
+  gluUnProject(winX, winY, -1, this->modelview, this->projection, viewport,
+               &posXN, &posYN, &posZN);
   Vector3d far_pt(posXF, posYF, posZF);
   Vector3d near_pt(posXN, posYN, posZN);
 
   Vector3d testpt(0, 0, 0);
   std::vector<SelectedObject> result;
   auto renderer = this->getRenderer();
-  if (renderer == nullptr)return result;
-  result = renderer->findModelObject(near_pt, far_pt, mouse_x, mouse_y, cam.zoomValue() / 300);
+  if (renderer == nullptr)
+    return result;
+  result = renderer->findModelObject(near_pt, far_pt, mouse_x, mouse_y,
+                                     cam.zoomValue() / 300);
   return result;
 }
 
-void QGLView::selectPoint(int mouse_x, int mouse_y)
-{
+void QGLView::selectPoint(int mouse_x, int mouse_y) {
   std::vector<SelectedObject> obj = findObject(mouse_x, mouse_y);
   if (obj.size() == 1) {
     this->selected_obj.push_back(obj[0]);
@@ -573,20 +560,19 @@ void QGLView::selectPoint(int mouse_x, int mouse_y)
   }
 }
 
-int QGLView::pickObject(QPoint position)
-{
-  if (!isValid()) return -1;
+int QGLView::pickObject(QPoint position) {
+  if (!isValid())
+    return -1;
 
   if (this->getRenderer()) {
     this->makeCurrent();
-    auto guard = sg::make_scope_guard([this]() {
-      this->doneCurrent();
-    });
+    auto guard = sg::make_scope_guard([this]() { this->doneCurrent(); });
 
     // Update the selector with the right image size
     this->selector->reset(this);
 
-    return this->selector->select(this->getRenderer(), position.x(), position.y());
+    return this->selector->select(this->getRenderer(), position.x(),
+                                  position.y());
   }
   return -1;
 }
diff --git a/src/gui/QGLView.h b/src/gui/QGLView.h
index df118f067..c2b0178bd 100644
--- a/src/gui/QGLView.h
+++ b/src/gui/QGLView.h
@@ -4,28 +4,28 @@
 #include "gui/MouseSelector.h"
 
 #include <QImage>
+#include <QLabel>
 #include <QMouseEvent>
+#include <QOpenGLWidget>
 #include <QPoint>
 #include <QWheelEvent>
 #include <QWidget>
 #include <QtGlobal>
-#include <QOpenGLWidget>
-#include <QLabel>
 #include <string>
 #include <vector>
 
+#include "glview/GLView.h"
 #include <Eigen/Core>
 #include <Eigen/Geometry>
-#include "glview/GLView.h"
 
-class QGLView : public QOpenGLWidget, public GLView
-{
+class QGLView : public QOpenGLWidget, public GLView {
   Q_OBJECT
   Q_PROPERTY(bool showEdges READ showEdges WRITE setShowEdges);
   Q_PROPERTY(bool showAxes READ showAxes WRITE setShowAxes);
   Q_PROPERTY(bool showCrosshairs READ showCrosshairs WRITE setShowCrosshairs);
   Q_PROPERTY(bool orthoMode READ orthoMode WRITE setOrthoMode);
-  Q_PROPERTY(double showScaleProportional READ showScaleProportional WRITE setShowScaleProportional);
+  Q_PROPERTY(double showScaleProportional READ showScaleProportional WRITE
+                 setShowScaleProportional);
 
 public:
   QGLView(QWidget *parent = nullptr);
@@ -34,14 +34,16 @@ public:
   bool hasOpenCSGSupport() { return this->is_opencsg_capable; }
 #endif
   // Properties
-  bool orthoMode() const { return (this->cam.projection == Camera::ProjectionType::ORTHOGONAL); }
+  bool orthoMode() const {
+    return (this->cam.projection == Camera::ProjectionType::ORTHOGONAL);
+  }
   void setOrthoMode(bool enabled);
   bool showScaleProportional() const { return this->showscale; }
   void setShowScaleProportional(bool enabled) { this->showscale = enabled; }
   std::string getRendererInfo() const override;
   float getDPI() override { return this->devicePixelRatio(); }
 
-  const QImage& grabFrame();
+  const QImage &grabFrame();
   bool save(const char *filename) const override;
   void resetView();
   void viewAll();
@@ -54,12 +56,8 @@ public:
 public slots:
   void ZoomIn();
   void ZoomOut();
-  void setMouseCentricZoom(bool var){
-    this->mouseCentricZoom = var;
-  }
-  void setMouseSwapButtons(bool var){
-    this->mouseSwapButtons = var;
-  }
+  void setMouseCentricZoom(bool var) { this->mouseCentricZoom = var; }
+  void setMouseSwapButtons(bool var) { this->mouseSwapButtons = var; }
 
 public:
   QLabel *statusLabel;
@@ -69,7 +67,8 @@ public:
   void zoomCursor(int x, int y, int zoom);
   void rotate(double x, double y, double z, bool relative);
   void rotate2(double x, double y, double z);
-  void translate(double x, double y, double z, bool relative, bool viewPortRelative = true);
+  void translate(double x, double y, double z, bool relative,
+                 bool viewPortRelative = true);
 
 private:
   void init();
@@ -91,7 +90,7 @@ private:
   void resizeGL(int w, int h) override;
 
   void paintGL() override;
-  void normalizeAngle(GLdouble& angle);
+  void normalizeAngle(GLdouble &angle);
 
 #ifdef ENABLE_OPENCSG
   void display_opencsg_warning() override;
diff --git a/src/gui/QGLView2.cc b/src/gui/QGLView2.cc
index d3ba9f488..e35ce2532 100644
--- a/src/gui/QGLView2.cc
+++ b/src/gui/QGLView2.cc
@@ -24,30 +24,25 @@
  */
 
 /*
- * This file defines two helper functions for saving and restoring OpenGL contexts.
- * They are in a separate file (rather than in the more obvious QGLView.cc) because
- * <QOpenGLContext> is incompatible with GLEW and produces compilation warning messages.
- * Putting them in a separate file in helper functions allows the main file to need
- * only an incomplete declaration of QOpenGLContext, which it already has.
+ * This file defines two helper functions for saving and restoring OpenGL
+ * contexts. They are in a separate file (rather than in the more obvious
+ * QGLView.cc) because <QOpenGLContext> is incompatible with GLEW and produces
+ * compilation warning messages. Putting them in a separate file in helper
+ * functions allows the main file to need only an incomplete declaration of
+ * QOpenGLContext, which it already has.
  *
  * See also the discussion at QGLView::mouseDoubleClickEvent().
  */
 #include <QOpenGLContext>
 
-QOpenGLContext *
-getGLContext()
-{
-  return (QOpenGLContext::currentContext());
-}
+QOpenGLContext *getGLContext() { return (QOpenGLContext::currentContext()); }
 
-void
-setGLContext(QOpenGLContext *ctx)
-{
+void setGLContext(QOpenGLContext *ctx) {
   /*
    * This seems like the simplest way to select QOpenGLContext.
    *
-   * Why isn't there a QOpenGLContext::makeCurrent() that uses the context's assigned
-   * surface?
+   * Why isn't there a QOpenGLContext::makeCurrent() that uses the context's
+   * assigned surface?
    */
   ctx->makeCurrent(ctx->surface());
 }
diff --git a/src/gui/QSettingsCached.cc b/src/gui/QSettingsCached.cc
index a1bcfefdd..9e4e7150b 100644
--- a/src/gui/QSettingsCached.cc
+++ b/src/gui/QSettingsCached.cc
@@ -1,8 +1,8 @@
 #include "gui/QSettingsCached.h"
 
-#include <mutex>
 #include <QSettings>
 #include <memory>
+#include <mutex>
 
 std::unique_ptr<QSettings> QSettingsCached::qsettingsPointer;
 std::mutex QSettingsCached::ctor_mutex;
diff --git a/src/gui/QSettingsCached.h b/src/gui/QSettingsCached.h
index f9f8b3cf0..7bf00d224 100644
--- a/src/gui/QSettingsCached.h
+++ b/src/gui/QSettingsCached.h
@@ -1,17 +1,15 @@
 #pragma once
 
+#include <QSettings>
 #include <QString>
 #include <QVariant>
-#include <QSettings>
 #include <memory>
 #include <mutex>
 
 #include "utils/printutils.h"
 
-class QSettingsCached
-{
+class QSettingsCached {
 public:
-
   QSettingsCached() {
     if (qsettingsPointer.get() == nullptr) {
       std::lock_guard<std::mutex> lock{ctor_mutex};
@@ -21,34 +19,35 @@ public:
     }
   }
 
-  inline void setValue(const QString& key, const QVariant& value) {
-    PRINTDB("QSettings::setValue(): %s = '%s'", key.toStdString() % value.toString().toStdString());
-    qsettingsPointer->setValue(key, value); // It is safe to access qsettings from Multiple sources. it is thread safe
-    // Disabling forced sync to persisted storage on write. Will rely on automatic behavior of QSettings
-    // qsettingsPointer->sync(); // force write to file system on each modification of open scad settings
+  inline void setValue(const QString &key, const QVariant &value) {
+    PRINTDB("QSettings::setValue(): %s = '%s'",
+            key.toStdString() % value.toString().toStdString());
+    qsettingsPointer->setValue(key,
+                               value); // It is safe to access qsettings from
+                                       // Multiple sources. it is thread safe
+    // Disabling forced sync to persisted storage on write. Will rely on
+    // automatic behavior of QSettings qsettingsPointer->sync(); // force write
+    // to file system on each modification of open scad settings
   }
 
-  inline QVariant value(const QString& key, const QVariant& defaultValue = QVariant()) const {
+  inline QVariant value(const QString &key,
+                        const QVariant &defaultValue = QVariant()) const {
     return qsettingsPointer->value(key, defaultValue);
   }
 
-  inline void remove(const QString& key) {
+  inline void remove(const QString &key) {
     qsettingsPointer->remove(key);
-    // Disabling forced sync to persisted storage on write. Will rely on automatic behavior of QSettings
-    // qsettingsPointer->sync();
+    // Disabling forced sync to persisted storage on write. Will rely on
+    // automatic behavior of QSettings qsettingsPointer->sync();
   }
 
-  inline bool contains(const QString& key) const {
+  inline bool contains(const QString &key) const {
     return qsettingsPointer->contains(key);
   }
 
-  void release() {
-    delete qsettingsPointer.release();
-  }
-
+  void release() { delete qsettingsPointer.release(); }
 
 private:
   static std::unique_ptr<QSettings> qsettingsPointer;
   static std::mutex ctor_mutex;
-
 };
diff --git a/src/gui/QWordSearchField.cc b/src/gui/QWordSearchField.cc
index a7439538c..f3ed97bfe 100644
--- a/src/gui/QWordSearchField.cc
+++ b/src/gui/QWordSearchField.cc
@@ -6,8 +6,7 @@
 #include <QString>
 #include <QStyle>
 
-QWordSearchField::QWordSearchField(QFrame *parent) : QLineEdit(parent)
-{
+QWordSearchField::QWordSearchField(QFrame *parent) : QLineEdit(parent) {
   findcount = 0;
   fieldLabel = new QLabel(this);
   fieldLabel->setTextFormat(Qt::PlainText);
@@ -15,34 +14,35 @@ QWordSearchField::QWordSearchField(QFrame *parent) : QLineEdit(parent)
   fieldLabel->setCursor(Qt::ArrowCursor);
   fieldLabel->setStyleSheet("QLabel { border: none; padding: 0px; }");
   fieldLabel->hide();
-  connect(this, &QWordSearchField::findCountChanged, this, &QWordSearchField::updateFieldLabel);
+  connect(this, &QWordSearchField::findCountChanged, this,
+          &QWordSearchField::updateFieldLabel);
   auto frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);
-  setStyleSheet(QString("QLineEdit { padding-right: %1px; } ").arg(fieldLabel->sizeHint().width() + frameWidth + 1));
+  setStyleSheet(QString("QLineEdit { padding-right: %1px; } ")
+                    .arg(fieldLabel->sizeHint().width() + frameWidth + 1));
   auto minsize = minimumSizeHint();
-  setMinimumSize(qMax(minsize.width(), fieldLabel->sizeHint().height() + frameWidth * 2 + 2),
-                 qMax(minsize.height(), fieldLabel->sizeHint().height() + frameWidth * 2 + 2));
+  setMinimumSize(qMax(minsize.width(),
+                      fieldLabel->sizeHint().height() + frameWidth * 2 + 2),
+                 qMax(minsize.height(),
+                      fieldLabel->sizeHint().height() + frameWidth * 2 + 2));
   fieldLabel->setAlignment(Qt::AlignRight);
 }
 
-void QWordSearchField::resizeEvent(QResizeEvent *)
-{
-  resizeSearchField();
-}
+void QWordSearchField::resizeEvent(QResizeEvent *) { resizeSearchField(); }
 
-void QWordSearchField::resizeSearchField()
-{
+void QWordSearchField::resizeSearchField() {
   auto size = fieldLabel->sizeHint();
   auto frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);
-  fieldLabel->move(rect().right() - frameWidth - size.width(), (rect().bottom() + 1 - size.height()) / 2);
+  fieldLabel->move(rect().right() - frameWidth - size.width(),
+                   (rect().bottom() + 1 - size.height()) / 2);
 }
 
-
-void QWordSearchField::updateFieldLabel()
-{
+void QWordSearchField::updateFieldLabel() {
   if (findcount > 0) {
     fieldLabel->setText(QString::number(findcount));
-    //Fixes issue #2962 : Due to that fieldLabel->setText above does not seem to change the size of the field correct (seems to always be to short field to accommodate all digits)
-    //when the field changes many times during several searches, we need to work around that by setting minimum size.
+    // Fixes issue #2962 : Due to that fieldLabel->setText above does not seem
+    // to change the size of the field correct (seems to always be to short
+    // field to accommodate all digits) when the field changes many times during
+    // several searches, we need to work around that by setting minimum size.
     fieldLabel->setMinimumSize(fieldLabel->minimumSizeHint());
     fieldLabel->setVisible(true);
   } else {
@@ -52,8 +52,7 @@ void QWordSearchField::updateFieldLabel()
   resizeSearchField();
 }
 
-void QWordSearchField::setFindCount(int value)
-{
+void QWordSearchField::setFindCount(int value) {
   if (value != findcount) {
     findcount = value;
     emit findCountChanged();
diff --git a/src/gui/QWordSearchField.h b/src/gui/QWordSearchField.h
index ea4ba90f9..3edc5f89a 100644
--- a/src/gui/QWordSearchField.h
+++ b/src/gui/QWordSearchField.h
@@ -2,12 +2,11 @@
 #define QWORDSEARCHFIELD_H
 
 #include <QFrame>
-#include <QResizeEvent>
-#include <QLineEdit>
 #include <QLabel>
+#include <QLineEdit>
+#include <QResizeEvent>
 
-class QWordSearchField : public QLineEdit
-{
+class QWordSearchField : public QLineEdit {
   Q_OBJECT
 
 public:
@@ -33,4 +32,3 @@ private:
 };
 
 #endif /* QWORDSEARCHFIELD_H */
-
diff --git a/src/gui/RubberBandManager.cc b/src/gui/RubberBandManager.cc
index 2bcd4eba2..ff136dead 100644
--- a/src/gui/RubberBandManager.cc
+++ b/src/gui/RubberBandManager.cc
@@ -1,29 +1,26 @@
 #include "RubberBandManager.h"
 
-#include "MainWindow.h"
 #include "Dock.h"
+#include "MainWindow.h"
 
-RubberBandManager::RubberBandManager(MainWindow *w) :
-  rubberBand(QRubberBand::Rectangle)
-{
+RubberBandManager::RubberBandManager(MainWindow *w)
+    : rubberBand(QRubberBand::Rectangle) {
   setParent(w);
   emphasizedDock = nullptr;
 }
 
-void RubberBandManager::hide(){
+void RubberBandManager::hide() {
   rubberBand.hide();
   emphasizedDock = nullptr;
 }
 
-bool RubberBandManager::isEmphasized(Dock *dock){
+bool RubberBandManager::isEmphasized(Dock *dock) {
   return rubberBand.isVisible() && emphasizedDock == dock;
 }
 
-bool RubberBandManager::isVisible(){
-  return rubberBand.isVisible();
-}
+bool RubberBandManager::isVisible() { return rubberBand.isVisible(); }
 
-void RubberBandManager::emphasize(Dock *dock){
+void RubberBandManager::emphasize(Dock *dock) {
   rubberBand.setParent(dock);
   rubberBand.setGeometry(dock->widget()->geometry());
   rubberBand.show();
diff --git a/src/gui/RubberBandManager.h b/src/gui/RubberBandManager.h
index 21dec6f48..7df174c0b 100644
--- a/src/gui/RubberBandManager.h
+++ b/src/gui/RubberBandManager.h
@@ -9,8 +9,7 @@ class MainWindow;
 /// A rubberband is a qt concept to draw an overlay over widgets.
 /// In our case it is used to emphasize which doc is currently selected
 ///
-class RubberBandManager : QObject
-{
+class RubberBandManager : QObject {
   Q_OBJECT
 
 public:
diff --git a/src/gui/ScadApi.cc b/src/gui/ScadApi.cc
index a9d80644f..e00d92c32 100644
--- a/src/gui/ScadApi.cc
+++ b/src/gui/ScadApi.cc
@@ -1,47 +1,46 @@
 #include "gui/ScadApi.h"
 
+#include <QDir>
+#include <QFileInfo>
 #include <QList>
+#include <QRegularExpression>
 #include <QString>
 #include <QStringList>
 #include <string>
-#include <QDir>
-#include <QFileInfo>
-#include <QRegularExpression>
 
 #include "core/Builtins.h"
-#include "gui/ScintillaEditor.h"
 #include "core/parsersettings.h"
+#include "gui/ScintillaEditor.h"
 
 namespace {
 
-bool isInString(const std::u32string& text, const int col)
-{
-  //first see if we are in a string literal. if so, don't allow auto complete
+bool isInString(const std::u32string &text, const int col) {
+  // first see if we are in a string literal. if so, don't allow auto complete
   bool lastWasEscape = false;
   bool inString = false;
   int dx = 0;
   int count = col;
   while (count-- > 0) {
     const char32_t ch = text.at(dx++);
-    if (ch == '\\') lastWasEscape = true; //next character will be literal handle \"
-    else if (lastWasEscape) lastWasEscape = false;
-    else if (ch == '"') //string toggle
+    if (ch == '\\')
+      lastWasEscape = true; // next character will be literal handle \"
+    else if (lastWasEscape)
+      lastWasEscape = false;
+    else if (ch == '"') // string toggle
       inString = !inString;
   }
   return inString;
 }
 
-bool isUseOrInclude(const QString& text, const int col)
-{
+bool isUseOrInclude(const QString &text, const int col) {
   const QRegularExpression re("\\s*(use|include)\\s*<[^>]*$");
   const QRegularExpressionMatch match = re.match(text.left(col));
   return match.hasMatch();
 }
 
-template <typename C>
-QStringList getSorted(const QFileInfoList& list, C cond) {
+template <typename C> QStringList getSorted(const QFileInfoList &list, C cond) {
   QStringList result;
-  for (const auto& info : list) {
+  for (const auto &info : list) {
     if (cond(info)) {
       result << info.fileName();
     }
@@ -52,22 +51,22 @@ QStringList getSorted(const QFileInfoList& list, C cond) {
 
 } // namespace
 
-ScadApi::ScadApi(ScintillaEditor *editor, QsciLexer *lexer) : QsciAbstractAPIs(lexer), editor(editor)
-{
-  for (const auto& iter : Builtins::keywordList) {
+ScadApi::ScadApi(ScintillaEditor *editor, QsciLexer *lexer)
+    : QsciAbstractAPIs(lexer), editor(editor) {
+  for (const auto &iter : Builtins::keywordList) {
     QStringList calltipList;
-    for (const auto& it : iter.second)
+    for (const auto &it : iter.second)
       calltipList.append(QString::fromStdString(it));
 
     funcs.append(ApiFunc(QString::fromStdString(iter.first), calltipList));
   }
 }
 
-void ScadApi::updateAutoCompletionList(const QStringList& context, QStringList& list)
-{
+void ScadApi::updateAutoCompletionList(const QStringList &context,
+                                       QStringList &list) {
   int line, col;
   editor->qsci->getCursorPosition(&line, &col);
-  const auto& text = editor->qsci->text(line);
+  const auto &text = editor->qsci->text(line);
 
   if (isInString(text.toStdU32String(), col)) {
     return;
@@ -78,52 +77,51 @@ void ScadApi::updateAutoCompletionList(const QStringList& context, QStringList&
   }
 }
 
-void ScadApi::autoCompleteFolder(const QStringList& context, const QString& text, const int col, QStringList& list)
-{
+void ScadApi::autoCompleteFolder(const QStringList &context,
+                                 const QString &text, const int col,
+                                 QStringList &list) {
   const QRegularExpression re(R"(\s*(use|include)\s*<\s*)");
   const auto useDir = QFileInfo{text.left(col).replace(re, "")}.dir().path();
 
   QFileInfoList dirs;
   dirs << QFileInfo(editor->filepath);
-  for (const auto& path : get_library_path()) {
+  for (const auto &path : get_library_path()) {
     dirs << QFileInfo(QString::fromStdString(path) + "/");
   }
 
-  for (const auto& info : dirs) {
+  for (const auto &info : dirs) {
     const auto dir = QDir{info.dir().filePath(useDir)};
     if (!dir.exists()) {
       continue;
     }
 
     QFileInfoList result;
-    const auto& prefix = context.last();
-    const auto& infoList = dir.entryInfoList(QDir::Dirs | QDir::Files | QDir::Readable | QDir::NoDotAndDotDot);
-    for (const auto& info : infoList) {
-      if (info.fileName().startsWith(prefix) && (info.isDir() || info.suffix().toLower() == "scad")) {
+    const auto &prefix = context.last();
+    const auto &infoList = dir.entryInfoList(
+        QDir::Dirs | QDir::Files | QDir::Readable | QDir::NoDotAndDotDot);
+    for (const auto &info : infoList) {
+      if (info.fileName().startsWith(prefix) &&
+          (info.isDir() || info.suffix().toLower() == "scad")) {
         result << info;
       }
     }
 
-    list << getSorted(result, [](const QFileInfo& i){
-      return i.isDir();
-    });
-    list << getSorted(result, [](const QFileInfo& i){
-      return i.isFile();
-    });
+    list << getSorted(result, [](const QFileInfo &i) { return i.isDir(); });
+    list << getSorted(result, [](const QFileInfo &i) { return i.isFile(); });
     list.removeDuplicates();
   }
 }
 
-void ScadApi::autoCompleteFunctions(const QStringList& context, QStringList& list)
-{
-  const QString& c = context.last();
+void ScadApi::autoCompleteFunctions(const QStringList &context,
+                                    QStringList &list) {
+  const QString &c = context.last();
   // for now we only auto-complete functions and modules
   if (c.isEmpty()) {
     return;
   }
 
-  for (const auto& func : funcs) {
-    const QString& name = func.get_name();
+  for (const auto &func : funcs) {
+    const QString &name = func.get_name();
     if (name.startsWith(c)) {
       if (!list.contains(name)) {
         list << name;
@@ -132,14 +130,13 @@ void ScadApi::autoCompleteFunctions(const QStringList& context, QStringList& lis
   }
 }
 
-void ScadApi::autoCompletionSelected(const QString& /*selection*/)
-{
-}
+void ScadApi::autoCompletionSelected(const QString & /*selection*/) {}
 
-QStringList ScadApi::callTips(const QStringList& context, int /*commas*/, QsciScintilla::CallTipsStyle /*style*/, QList<int>& /*shifts*/)
-{
+QStringList ScadApi::callTips(const QStringList &context, int /*commas*/,
+                              QsciScintilla::CallTipsStyle /*style*/,
+                              QList<int> & /*shifts*/) {
   QStringList callTips;
-  for (const auto& func : funcs) {
+  for (const auto &func : funcs) {
     if (func.get_name() == context.at(context.size() - 2)) {
       callTips = func.get_params();
       break;
diff --git a/src/gui/ScadApi.h b/src/gui/ScadApi.h
index 412a7b51a..5d4f4d15a 100644
--- a/src/gui/ScadApi.h
+++ b/src/gui/ScadApi.h
@@ -1,36 +1,31 @@
 #pragma once
 
 #include <QList>
-#include <utility>
 #include <QObject>
 #include <QString>
 #include <QStringList>
+#include <utility>
 
 #include <Qsci/qsciapis.h>
 
-class ApiFunc
-{
+class ApiFunc {
 private:
   QString name;
   QStringList params;
 
 public:
-  ApiFunc(QString name, QString param) : name(std::move(name)), params{std::move(param)} { }
-  ApiFunc(QString name, QString param1, QString param2) : name(std::move(name)), params{std::move(param1), std::move(param2)} { }
-  ApiFunc(QString name, QStringList params) : name(std::move(name)), params(std::move(params)) { }
+  ApiFunc(QString name, QString param)
+      : name(std::move(name)), params{std::move(param)} {}
+  ApiFunc(QString name, QString param1, QString param2)
+      : name(std::move(name)), params{std::move(param1), std::move(param2)} {}
+  ApiFunc(QString name, QStringList params)
+      : name(std::move(name)), params(std::move(params)) {}
 
-  const QString& get_name() const
-  {
-    return name;
-  }
+  const QString &get_name() const { return name; }
 
-  const QStringList& get_params() const
-  {
-    return params;
-  }
+  const QStringList &get_params() const { return params; }
 
-  ApiFunc& operator=(const ApiFunc& other)
-  {
+  ApiFunc &operator=(const ApiFunc &other) {
     if (this != &other) {
       this->name = other.name;
       this->params = other.params;
@@ -39,20 +34,19 @@ public:
   }
 };
 
-class ScadTemplate
-{
+class ScadTemplate {
 private:
   QString text;
   int cursor_offset;
-public:
 
-  ScadTemplate() : text(""), cursor_offset(0) { }
-  ScadTemplate(QString text, int cursor_offset) : text(std::move(text)), cursor_offset(cursor_offset) { }
-  const QString& get_text() const { return text; }
+public:
+  ScadTemplate() : text(""), cursor_offset(0) {}
+  ScadTemplate(QString text, int cursor_offset)
+      : text(std::move(text)), cursor_offset(cursor_offset) {}
+  const QString &get_text() const { return text; }
   int get_cursor_offset() const { return cursor_offset; }
 
-  ScadTemplate& operator=(const ScadTemplate& other)
-  {
+  ScadTemplate &operator=(const ScadTemplate &other) {
     if (this != &other) {
       this->text = other.text;
       this->cursor_offset = other.cursor_offset;
@@ -63,8 +57,7 @@ public:
 
 class ScintillaEditor;
 
-class ScadApi : public QsciAbstractAPIs
-{
+class ScadApi : public QsciAbstractAPIs {
   Q_OBJECT
 
 private:
@@ -72,13 +65,17 @@ private:
   QList<ApiFunc> funcs;
 
 protected:
-  void autoCompleteFolder(const QStringList& context, const QString& text, const int col, QStringList& list);
-  void autoCompleteFunctions(const QStringList& context, QStringList& list);
+  void autoCompleteFolder(const QStringList &context, const QString &text,
+                          const int col, QStringList &list);
+  void autoCompleteFunctions(const QStringList &context, QStringList &list);
 
 public:
   ScadApi(ScintillaEditor *editor, QsciLexer *lexer);
 
-  void updateAutoCompletionList(const QStringList& context, QStringList& list) override;
-  void autoCompletionSelected(const QString& selection) override;
-  QStringList callTips(const QStringList& context, int commas, QsciScintilla::CallTipsStyle style, QList<int>& shifts) override;
+  void updateAutoCompletionList(const QStringList &context,
+                                QStringList &list) override;
+  void autoCompletionSelected(const QString &selection) override;
+  QStringList callTips(const QStringList &context, int commas,
+                       QsciScintilla::CallTipsStyle style,
+                       QList<int> &shifts) override;
 };
diff --git a/src/gui/ScadLexer.cc b/src/gui/ScadLexer.cc
index f78caff91..038025066 100644
--- a/src/gui/ScadLexer.cc
+++ b/src/gui/ScadLexer.cc
@@ -11,48 +11,38 @@
 #include <boost/algorithm/string.hpp>
 #include <boost/algorithm/string/split.hpp>
 
-
 #if !ENABLE_LEXERTL
 
-ScadLexer::ScadLexer(QObject *parent) : QsciLexerCPP(parent)
-{
+ScadLexer::ScadLexer(QObject *parent) : QsciLexerCPP(parent) {
   // -> Style: Keyword (lexer.l)
-  keywordSet[0] =
-    "if else let for each module function true false undef "
-    "include use assert";
+  keywordSet[0] = "if else let for each module function true false undef "
+                  "include use assert";
 
   // -> Style: KeywordSet2 (func.cc)
-  keywordSet[1] =
-    "abs sign rands min max sin cos asin acos tan atan atan2 "
-    "round ceil floor pow sqrt exp len log ln str chr ord concat "
-    "is_undef is_list is_num is_bool is_string is_function "
-    "lookup search version version_num norm cross parent_module "
-    "dxf_dim dxf_cross";
+  keywordSet[1] = "abs sign rands min max sin cos asin acos tan atan atan2 "
+                  "round ceil floor pow sqrt exp len log ln str chr ord concat "
+                  "is_undef is_list is_num is_bool is_string is_function "
+                  "lookup search version version_num norm cross parent_module "
+                  "dxf_dim dxf_cross";
 
   // -> used in comments only like /*! \cube */
-  keywordSet[2] =
-    "struct union enum fn var def typedef file namespace package "
-    "interface param see return class brief";
+  keywordSet[2] = "struct union enum fn var def typedef file namespace package "
+                  "interface param see return class brief";
 
   // -> Style: GlobalClass
-  keywordSet[3] =
-    "cube sphere cylinder polyhedron square circle polygon text "
-    "minkowski hull resize child children echo union difference "
-    "intersection linear_extrude rotate_extrude import group "
-    "projection render surface scale rotate mirror translate "
-    "multmatrix color offset intersection_for roof fill";
+  keywordSet[3] = "cube sphere cylinder polyhedron square circle polygon text "
+                  "minkowski hull resize child children echo union difference "
+                  "intersection linear_extrude rotate_extrude import group "
+                  "projection render surface scale rotate mirror translate "
+                  "multmatrix color offset intersection_for roof fill";
 
   setFoldComments(true);
   setFoldAtElse(true);
 }
 
-const char *ScadLexer::language() const
-{
-  return "SCAD";
-}
+const char *ScadLexer::language() const { return "SCAD"; }
 
-void ScadLexer::setKeywords(int set, const std::string& keywords)
-{
+void ScadLexer::setKeywords(int set, const std::string &keywords) {
   if ((set < 1) || (set > 4)) {
     return;
   }
@@ -66,16 +56,14 @@ void ScadLexer::setKeywords(int set, const std::string& keywords)
   keywordSet[set - 1] = trimmedKeywords;
 }
 
-const char *ScadLexer::keywords(int set) const
-{
+const char *ScadLexer::keywords(int set) const {
   if ((set < 1) || (set > 4)) {
     return nullptr;
   }
   return keywordSet[set - 1].c_str();
 }
 
-QStringList ScadLexer::autoCompletionWordSeparators() const
-{
+QStringList ScadLexer::autoCompletionWordSeparators() const {
   QStringList wl;
   wl << "."; // dot notation, not used yet, but preparation for object support
   wl << "<"; // for include/use auto complete
@@ -97,7 +85,7 @@ QStringList ScadLexer::autoCompletionWordSeparators() const
 #include "lexertl/generator.hpp"
 #include "lexertl/lookup.hpp"
 
-//#define DEBUG_LEXERTL   1
+// #define DEBUG_LEXERTL   1
 
 #if DEBUG_LEXERTL
 #include "lexertl/debug.hpp"
@@ -105,10 +93,10 @@ QStringList ScadLexer::autoCompletionWordSeparators() const
 #include <iostream>
 #endif
 
-/// See original attempt at https://github.com/openscad/openscad/tree/lexertl/src
+/// See original attempt at
+/// https://github.com/openscad/openscad/tree/lexertl/src
 
-void Lex::default_rules()
-{
+void Lex::default_rules() {
   rules_.push_state("PATH");
   rules_.push_state("COMMENT");
 
@@ -116,10 +104,12 @@ void Lex::default_rules()
                        "return if else let for each assert");
   defineRules(keywords, ekeyword);
 
-  //include and use have a unique syntax
+  // include and use have a unique syntax
   rules_.push("INITIAL", "use", ekeyword, "PATH");
   rules_.push("INITIAL", "include", ekeyword, "PATH");
-  rules_.push("PATH", ".|\n", etext, "INITIAL"); //leave this state; "use" and "include" can also be used as variable names
+  rules_.push("PATH", ".|\n", etext,
+              "INITIAL"); // leave this state; "use" and "include" can also be
+                          // used as variable names
   rules_.push("PATH", "[ \t\r\n]*<[^>]*>", eQuotedString, "INITIAL");
 
   std::string transformations("translate rotate scale linear_extrude "
@@ -130,14 +120,16 @@ void Lex::default_rules()
   std::string booleans("union difference intersection intersection_for");
   defineRules(booleans, eboolean);
 
-  std::string functions("abs sign rands min max sin cos asin acos tan atan atan2 round "
-                        "ceil floor pow sqrt exp len log ln str chr ord concat lookup "
-                        "search version version_num norm cross parent_module dxf_dim "
-                        "dxf_cross is_undef is_list is_num is_bool is_string "
-                        "is_function is_object");
+  std::string functions(
+      "abs sign rands min max sin cos asin acos tan atan atan2 round "
+      "ceil floor pow sqrt exp len log ln str chr ord concat lookup "
+      "search version version_num norm cross parent_module dxf_dim "
+      "dxf_cross is_undef is_list is_num is_bool is_string "
+      "is_function is_object");
   defineRules(functions, efunction);
 
-  std::string models("sphere cube cylinder polyhedron square polygon text circle surface roof");
+  std::string models("sphere cube cylinder polyhedron square polygon text "
+                     "circle surface roof");
   defineRules(models, emodel);
 
   // Operators and Modifier Characters
@@ -148,34 +140,34 @@ void Lex::default_rules()
 
   std::string values("true false undef PI");
   defineRules(values, enumber);
-  rules_.push("([-+]?((([0-9]+[.]?|([0-9]*[.][0-9]+))([eE][-+]?[0-9]+)?)))", enumber);
+  rules_.push("([-+]?((([0-9]+[.]?|([0-9]*[.][0-9]+))([eE][-+]?[0-9]+)?)))",
+              enumber);
 
   // comments and variables come later, after any custom keywords are added
 }
 
-void Lex::defineRules(const std::string& keyword_list, int id)
-{
+void Lex::defineRules(const std::string &keyword_list, int id) {
   std::string trimmedKeywords(keyword_list);
   boost::algorithm::trim(trimmedKeywords);
-  if (trimmedKeywords.empty()) return;
+  if (trimmedKeywords.empty())
+    return;
 
   std::vector<std::string> words;
   boost::split(words, trimmedKeywords, boost::is_any_of(" "));
-  for (const auto& keyword : words) {
+  for (const auto &keyword : words) {
     rules_.push(keyword, id);
   }
 }
 
 // default and custom rules must be set before this
-void Lex::finalize_rules()
-{
+void Lex::finalize_rules() {
   // These need to come after keywords, so they don't accidentally match.
   // Sadly, order of definition matters, as well as enum.
   rules_.push("[a-zA-Z0-9_]+", evariable);
   rules_.push("[$][a-zA-Z0-9_]+", especialVariable);
 
-  rules_.push("INITIAL", "\"/*\"",  ecomment, "COMMENT");
-  rules_.push("COMMENT", "[^*]+|.", ecomment,  "COMMENT");
+  rules_.push("INITIAL", "\"/*\"", ecomment, "COMMENT");
+  rules_.push("COMMENT", "[^*]+|.", ecomment, "COMMENT");
   rules_.push("COMMENT", "\"*/\"", ecomment, "INITIAL");
   rules_.push("[/][/].*$", ecomment);
 
@@ -190,20 +182,21 @@ void Lex::finalize_rules()
 #endif
 }
 
-void Lex::lex_results(const std::string& input, int start, LexInterface *const obj)
-{
+void Lex::lex_results(const std::string &input, int start,
+                      LexInterface *const obj) {
 #if DEBUG_LEXERTL
   std::cout << "called lexer" << std::endl;
 #endif
   lexertl::smatch results(input.begin(), input.end());
 
-  //The editor can ask to only lex from a starting point.
-  //This can be faster the lexing the whole text,
-  //but requires the lexer to try to restore the lexer state.
-  //We currently handle comments (COMMENT State) pretty well.
-  //We currently do not handle include/use (PATH State).
+  // The editor can ask to only lex from a starting point.
+  // This can be faster the lexing the whole text,
+  // but requires the lexer to try to restore the lexer state.
+  // We currently handle comments (COMMENT State) pretty well.
+  // We currently do not handle include/use (PATH State).
   int isstyle = obj->getStyleAt(start - 1);
-  if (isstyle == ecomment) results.state = rules_.state("COMMENT");
+  if (isstyle == ecomment)
+    results.state = rules_.state("COMMENT");
 
   char *styles = new char[input.size()];
   lexertl::lookup(sm, results);
@@ -214,28 +207,25 @@ void Lex::lex_results(const std::string& input, int start, LexInterface *const o
     lexertl::lookup(sm, results);
   }
   obj->highlightingMultiple(start, input.size(), styles);
-  delete [] styles;
+  delete[] styles;
 }
 
 /***************************************************************/
 
-ScadLexer2::ScadLexer2(QObject *parent) : QsciLexerCustom(parent), LexInterface()
-{
+ScadLexer2::ScadLexer2(QObject *parent)
+    : QsciLexerCustom(parent), LexInterface() {
   my_lexer = new Lex();
   my_lexer->default_rules();
 }
 
-ScadLexer2::~ScadLexer2()
-{
-  delete my_lexer;
-}
+ScadLexer2::~ScadLexer2() { delete my_lexer; }
 
-void ScadLexer2::styleText(int start, int end)
-{
+void ScadLexer2::styleText(int start, int end) {
 #if DEBUG_LEXERTL
   std::cout << "start: " << start << std::endl;
 #endif
-  if (!editor()) return;
+  if (!editor())
+    return;
 
   char *data = new char[end - start + 1];
   editor()->SendScintilla(QsciScintilla::SCI_GETTEXTRANGE, start, end, data);
@@ -250,21 +240,23 @@ void ScadLexer2::styleText(int start, int end)
   my_lexer->lex_results(input, start, this);
   this->fold(start, end);
 
-  delete [] data;
-  if (source.isEmpty()) return;
+  delete[] data;
+  if (source.isEmpty())
+    return;
 }
 
-void ScadLexer2::autoScroll(int error_pos)
-{
+void ScadLexer2::autoScroll(int error_pos) {
   editor()->SendScintilla(QsciScintilla::SCI_GOTOPOS, error_pos);
   editor()->SendScintilla(QsciScintilla::SCI_SCROLLCARET);
 }
 
-void ScadLexer2::fold(int start, int end)
-{
+void ScadLexer2::fold(int start, int end) {
   char chNext = editor()->SendScintilla(QsciScintilla::SCI_GETCHARAT, start);
-  int lineCurrent = editor()->SendScintilla(QsciScintilla::SCI_LINEFROMPOSITION, start);
-  int levelPrev = editor()->SendScintilla(QsciScintilla::SCI_GETFOLDLEVEL, lineCurrent) & QsciScintilla::SC_FOLDLEVELNUMBERMASK;
+  int lineCurrent =
+      editor()->SendScintilla(QsciScintilla::SCI_LINEFROMPOSITION, start);
+  int levelPrev =
+      editor()->SendScintilla(QsciScintilla::SCI_GETFOLDLEVEL, lineCurrent) &
+      QsciScintilla::SC_FOLDLEVELNUMBERMASK;
   int levelCurrent = levelPrev;
   for (int i = start; i < end; i++) {
     char ch = chNext;
@@ -272,19 +264,19 @@ void ScadLexer2::fold(int start, int end)
 
     bool atEOL = ((ch == '\r' && chNext != '\n') || (ch == '\n'));
 
-    int prevStyle = editor()->SendScintilla(QsciScintilla::SCI_GETSTYLEAT, i - 1);
+    int prevStyle =
+        editor()->SendScintilla(QsciScintilla::SCI_GETSTYLEAT, i - 1);
     int currStyle = editor()->SendScintilla(QsciScintilla::SCI_GETSTYLEAT, i);
 
     bool currStyleIsOtherText = (currStyle == OtherText);
     if (currStyleIsOtherText) {
-      if ((ch == '{') || (ch == '[') ) {
+      if ((ch == '{') || (ch == '[')) {
         levelCurrent++;
-      } else if ((ch == '}') || (ch == ']') ) {
+      } else if ((ch == '}') || (ch == ']')) {
         levelCurrent--;
       }
     }
 
-
     bool prevStyleIsComment = (prevStyle == Comment);
     bool currStyleIsComment = (currStyle == Comment);
     bool isStartOfComment = (!prevStyleIsComment) && (currStyleIsComment);
@@ -304,8 +296,10 @@ void ScadLexer2::fold(int start, int end)
         lev |= QsciScintilla::SC_FOLDLEVELHEADERFLAG;
       }
 
-      if (lev != editor()->SendScintilla(QsciScintilla::SCI_GETFOLDLEVEL, lineCurrent)) {
-        editor()->SendScintilla(QsciScintilla::SCI_SETFOLDLEVEL, lineCurrent, lev);
+      if (lev != editor()->SendScintilla(QsciScintilla::SCI_GETFOLDLEVEL,
+                                         lineCurrent)) {
+        editor()->SendScintilla(QsciScintilla::SCI_SETFOLDLEVEL, lineCurrent,
+                                lev);
       }
 
       lineCurrent++;
@@ -313,13 +307,14 @@ void ScadLexer2::fold(int start, int end)
     }
   }
 
-  int flagsNext = editor()->SendScintilla(QsciScintilla::SCI_GETFOLDLEVEL, lineCurrent) & QsciScintilla::SC_FOLDLEVELNUMBERMASK;
-  editor()->SendScintilla(QsciScintilla::SCI_SETFOLDLEVEL, lineCurrent, levelPrev | flagsNext);
+  int flagsNext =
+      editor()->SendScintilla(QsciScintilla::SCI_GETFOLDLEVEL, lineCurrent) &
+      QsciScintilla::SC_FOLDLEVELNUMBERMASK;
+  editor()->SendScintilla(QsciScintilla::SCI_SETFOLDLEVEL, lineCurrent,
+                          levelPrev | flagsNext);
 }
 
-
-int ScadLexer2::getStyleAt(int pos)
-{
+int ScadLexer2::getStyleAt(int pos) {
   int sstyle = editor()->SendScintilla(QsciScintilla::SCI_GETSTYLEAT, pos);
   return sstyle;
 }
@@ -329,8 +324,7 @@ void ScadLexer2::highlightingMultiple(int start, int length, char *styles) {
   editor()->SendScintilla(QsciScintilla::SCI_SETSTYLINGEX, length, styles);
 }
 
-QColor ScadLexer2::defaultColor(int style) const
-{
+QColor ScadLexer2::defaultColor(int style) const {
   switch (style) {
   case Keyword:
     return Qt::blue;
@@ -352,8 +346,7 @@ QColor ScadLexer2::defaultColor(int style) const
   return Qt::black;
 }
 
-QString ScadLexer2::description(int style) const
-{
+QString ScadLexer2::description(int style) const {
   switch (style) {
   case Default:
     return "Default";
@@ -403,13 +396,9 @@ QString ScadLexer2::description(int style) const
   return {QString::number(style)};
 }
 
-const char *ScadLexer2::language() const
-{
-  return "SCAD";
-}
+const char *ScadLexer2::language() const { return "SCAD"; }
 
-QStringList ScadLexer2::autoCompletionWordSeparators() const
-{
+QStringList ScadLexer2::autoCompletionWordSeparators() const {
   QStringList wl;
   wl << "."; // dot notation, not used yet, but preparation for object support
   wl << "<"; // for include/use auto complete
diff --git a/src/gui/ScadLexer.h b/src/gui/ScadLexer.h
index f39504740..02d75952e 100644
--- a/src/gui/ScadLexer.h
+++ b/src/gui/ScadLexer.h
@@ -1,11 +1,11 @@
 #pragma once
 
-#include <QStringList>
 #include <QObject>
+#include <QStringList>
 #include <Qsci/qsciglobal.h>
 #include <string>
 
-#define ENABLE_LEXERTL  1
+#define ENABLE_LEXERTL 1
 
 /***************************************************************/
 
@@ -13,20 +13,19 @@
 
 #include <Qsci/qscilexercpp.h>
 
-class ScadLexer : public QsciLexerCPP
-{
+class ScadLexer : public QsciLexerCPP {
 public:
   ScadLexer(QObject *parent);
   virtual ~ScadLexer() = default;
   const char *language() const override;
   const char *keywords(int set) const override;
 
-  void setKeywords(int set, const std::string& keywords);
+  void setKeywords(int set, const std::string &keywords);
 
 private:
   std::string keywordSet[4];
-  ScadLexer(const ScadLexer&);
-  ScadLexer& operator=(const ScadLexer&);
+  ScadLexer(const ScadLexer &);
+  ScadLexer &operator=(const ScadLexer &);
   QStringList autoCompletionWordSeparators() const override;
 };
 
@@ -38,7 +37,8 @@ private:
 
 #if ENABLE_LEXERTL
 
-/// See original attempt at https://github.com/openscad/openscad/tree/lexertl/src
+/// See original attempt at
+/// https://github.com/openscad/openscad/tree/lexertl/src
 
 #include "lexertl/dot.hpp"
 #include "lexertl/generator.hpp"
@@ -47,34 +47,54 @@ private:
 #include <Qsci/qscilexercustom.h>
 #include <Qsci/qsciscintilla.h>
 
-class LexInterface
-{
+class LexInterface {
 public:
   virtual void highlightingMultiple(int start, int length, char *styles) = 0;
   virtual int getStyleAt(int position) = 0;
 };
 
-class Lex
-{
+class Lex {
 public:
   lexertl::state_machine sm;
   lexertl::rules rules_;
 
-  enum { eEOF, ekeyword, etransformation, eboolean, efunction, emodel, eoperator, eQuotedString, enumber,
-         ecustom1, ecustom2, ecustom3, ecustom4, ecustom5, ecustom6, ecustom7, ecustom8, ecustom9, ecustom10,
-         evariable, especialVariable, ecomment, etext };
+  enum {
+    eEOF,
+    ekeyword,
+    etransformation,
+    eboolean,
+    efunction,
+    emodel,
+    eoperator,
+    eQuotedString,
+    enumber,
+    ecustom1,
+    ecustom2,
+    ecustom3,
+    ecustom4,
+    ecustom5,
+    ecustom6,
+    ecustom7,
+    ecustom8,
+    ecustom9,
+    ecustom10,
+    evariable,
+    especialVariable,
+    ecomment,
+    etext
+  };
 
   Lex() = default;
 
   void default_rules();
-  void defineRules(const std::string& keyword_list, int id);
+  void defineRules(const std::string &keyword_list, int id);
   void finalize_rules();
 
-  void lex_results(const std::string& input, int start, LexInterface *const obj);
+  void lex_results(const std::string &input, int start,
+                   LexInterface *const obj);
 };
 
-class ScadLexer2 : public QsciLexerCustom, public LexInterface
-{
+class ScadLexer2 : public QsciLexerCustom, public LexInterface {
 public:
   enum {
     Default = 0,
@@ -105,8 +125,8 @@ public:
   Lex *my_lexer;
 
   ScadLexer2(QObject *parent);
-  ScadLexer2(const ScadLexer2&) = delete;
-  ScadLexer2& operator=(const ScadLexer2&) = delete;
+  ScadLexer2(const ScadLexer2 &) = delete;
+  ScadLexer2 &operator=(const ScadLexer2 &) = delete;
   ~ScadLexer2() override;
 
   const char *language() const override;
@@ -122,13 +142,10 @@ public:
   QString description(int style) const override;
   QStringList autoCompletionWordSeparators() const override;
 
-  void addKeywords(const std::string& keywords, int id) {
+  void addKeywords(const std::string &keywords, int id) {
     my_lexer->defineRules(keywords, id);
   }
-  void finalizeLexer() {
-    my_lexer->finalize_rules();
-  }
-
+  void finalizeLexer() { my_lexer->finalize_rules(); }
 };
 
 #endif // if ENABLE_LEXERTL
diff --git a/src/gui/ScintillaEditor.cc b/src/gui/ScintillaEditor.cc
index 83616c816..041b6d32e 100644
--- a/src/gui/ScintillaEditor.cc
+++ b/src/gui/ScintillaEditor.cc
@@ -1,58 +1,57 @@
 #include "gui/ScintillaEditor.h"
 
+#include <QChar>
 #include <QColor>
 #include <QCursor>
 #include <QEvent>
 #include <QGuiApplication>
 #include <QMenu>
 #include <QObject>
+#include <QRegularExpression>
+#include <QShortcut>
+#include <QString>
 #include <QTimer>
 #include <QVBoxLayout>
 #include <QWidget>
-#include <functional>
+#include <Qsci/qscicommandset.h>
+#include <algorithm>
+#include <boost/property_tree/json_parser.hpp>
+#include <boost/property_tree/ptree.hpp>
+#include <cstdlib>
 #include <exception>
+#include <filesystem>
+#include <functional>
 #include <memory>
-#include <cstdlib>
 #include <string>
 #include <vector>
-#include <algorithm>
-#include <filesystem>
-#include <boost/property_tree/ptree.hpp>
-#include <boost/property_tree/json_parser.hpp>
-#include <QString>
-#include <QChar>
-#include <QRegularExpression>
-#include <QShortcut>
-#include <Qsci/qscicommandset.h>
 
-#include "gui/Preferences.h"
-#include "platform/PlatformUtils.h"
 #include "core/Settings.h"
+#include "gui/Preferences.h"
 #include "gui/ScadLexer.h"
+#include "platform/PlatformUtils.h"
 
-#include <QWheelEvent>
 #include <QPoint>
 #include <QToolTip>
+#include <QWheelEvent>
 
 namespace fs = std::filesystem;
 
 const QString ScintillaEditor::cursorPlaceHolder = "^~^";
 
-// In setCursorPosition, how many lines should be visible above and below the cursor
+// In setCursorPosition, how many lines should be visible above and below the
+// cursor
 const int setCursorPositionVisibleLines = 3;
 
-
-class SettingsConverter
-{
+class SettingsConverter {
 public:
-  QsciScintilla::WrapMode toWrapMode(const std::string& val);
-  QsciScintilla::WrapVisualFlag toLineWrapVisualization(const std::string& val);
-  QsciScintilla::WrapIndentMode toLineWrapIndentationStyle(const std::string& val);
-  QsciScintilla::WhitespaceVisibility toShowWhitespaces(const std::string& val);
+  QsciScintilla::WrapMode toWrapMode(const std::string &val);
+  QsciScintilla::WrapVisualFlag toLineWrapVisualization(const std::string &val);
+  QsciScintilla::WrapIndentMode
+  toLineWrapIndentationStyle(const std::string &val);
+  QsciScintilla::WhitespaceVisibility toShowWhitespaces(const std::string &val);
 };
 
-QsciScintilla::WrapMode SettingsConverter::toWrapMode(const std::string& val)
-{
+QsciScintilla::WrapMode SettingsConverter::toWrapMode(const std::string &val) {
   if (val == "Char") {
     return QsciScintilla::WrapCharacter;
   } else if (val == "Word") {
@@ -62,8 +61,8 @@ QsciScintilla::WrapMode SettingsConverter::toWrapMode(const std::string& val)
   }
 }
 
-QsciScintilla::WrapVisualFlag SettingsConverter::toLineWrapVisualization(const std::string& val)
-{
+QsciScintilla::WrapVisualFlag
+SettingsConverter::toLineWrapVisualization(const std::string &val) {
   if (val == "Text") {
     return QsciScintilla::WrapFlagByText;
   } else if (val == "Border") {
@@ -77,8 +76,8 @@ QsciScintilla::WrapVisualFlag SettingsConverter::toLineWrapVisualization(const s
   }
 }
 
-QsciScintilla::WrapIndentMode SettingsConverter::toLineWrapIndentationStyle(const std::string& val)
-{
+QsciScintilla::WrapIndentMode
+SettingsConverter::toLineWrapIndentationStyle(const std::string &val) {
   if (val == "Same") {
     return QsciScintilla::WrapIndentSame;
   } else if (val == "Indented") {
@@ -88,8 +87,8 @@ QsciScintilla::WrapIndentMode SettingsConverter::toLineWrapIndentationStyle(cons
   }
 }
 
-QsciScintilla::WhitespaceVisibility SettingsConverter::toShowWhitespaces(const std::string& val)
-{
+QsciScintilla::WhitespaceVisibility
+SettingsConverter::toShowWhitespaces(const std::string &val) {
   if (val == "Always") {
     return QsciScintilla::WsVisible;
   } else if (val == "AfterIndentation") {
@@ -99,48 +98,37 @@ QsciScintilla::WhitespaceVisibility SettingsConverter::toShowWhitespaces(const s
   }
 }
 
-EditorColorScheme::EditorColorScheme(const fs::path& path) : path(path)
-{
+EditorColorScheme::EditorColorScheme(const fs::path &path) : path(path) {
   try {
     boost::property_tree::read_json(path.generic_string(), pt);
     _name = QString::fromStdString(pt.get<std::string>("name"));
     _index = pt.get<int>("index");
-  } catch (const std::exception& e) {
-    LOG("Error reading color scheme file '%1$s': %2$s", path.generic_string(), e.what());
+  } catch (const std::exception &e) {
+    LOG("Error reading color scheme file '%1$s': %2$s", path.generic_string(),
+        e.what());
     _name = "";
     _index = 0;
   }
 }
 
-bool EditorColorScheme::valid() const
-{
-  return !_name.isEmpty();
-}
+bool EditorColorScheme::valid() const { return !_name.isEmpty(); }
 
-const QString& EditorColorScheme::name() const
-{
-  return _name;
-}
+const QString &EditorColorScheme::name() const { return _name; }
 
-int EditorColorScheme::index() const
-{
-  return _index;
-}
+int EditorColorScheme::index() const { return _index; }
 
-const boost::property_tree::ptree& EditorColorScheme::propertyTree() const
-{
+const boost::property_tree::ptree &EditorColorScheme::propertyTree() const {
   return pt;
 }
 
-ScintillaEditor::ScintillaEditor(QWidget *parent) : EditorInterface(parent)
-{
+ScintillaEditor::ScintillaEditor(QWidget *parent) : EditorInterface(parent) {
   api = nullptr;
   lexer = nullptr;
   scintillaLayout = new QVBoxLayout(this);
   qsci = new QsciScintilla(this);
 
   contentsRendered = false;
-  findState = 0; //FIND_HIDDEN
+  findState = 0; // FIND_HIDDEN
   filepath = "";
 
   // Force EOL mode to Unix, since QTextStream will manage local EOL modes.
@@ -153,7 +141,8 @@ ScintillaEditor::ScintillaEditor(QWidget *parent) : EditorInterface(parent)
   QsciCommand *c;
   // NOLINTBEGIN(bugprone-suspicious-enum-usage)
 #ifdef Q_OS_MACOS
-  // Alt-Backspace should delete left word (Alt-Delete already deletes right word)
+  // Alt-Backspace should delete left word (Alt-Delete already deletes right
+  // word)
   c = qsci->standardCommands()->find(QsciCommand::DeleteWordLeft);
   c->setKey(Qt::Key_Backspace | Qt::ALT);
 #endif
@@ -176,15 +165,12 @@ ScintillaEditor::ScintillaEditor(QWidget *parent) : EditorInterface(parent)
 
   QShortcut *shortcutCalltip;
   shortcutCalltip = new QShortcut(modifier | Qt::SHIFT | Qt::Key_Space, this);
-  connect(shortcutCalltip, &QShortcut::activated, [ = ]() {
-    qsci->callTip();
-  });
+  connect(shortcutCalltip, &QShortcut::activated, [=]() { qsci->callTip(); });
 
   QShortcut *shortcutAutocomplete;
   shortcutAutocomplete = new QShortcut(modifier | Qt::Key_Space, this);
-  connect(shortcutAutocomplete, &QShortcut::activated, [ = ]() {
-    qsci->autoCompleteFromAPIs();
-  });
+  connect(shortcutAutocomplete, &QShortcut::activated,
+          [=]() { qsci->autoCompleteFromAPIs(); });
   // NOLINTEND(bugprone-suspicious-enum-usage)
 
   scintillaLayout->setContentsMargins(0, 0, 0, 0);
@@ -196,11 +182,16 @@ ScintillaEditor::ScintillaEditor(QWidget *parent) : EditorInterface(parent)
 
   qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator, errorIndicatorNumber);
   qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator, findIndicatorNumber);
-  qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator, selectionIndicatorIsActiveNumber);
-  qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator, selectionIndicatorIsActiveNumber + 1);
-  qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator, selectionIndicatorIsImpactedNumber);
-  qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator, selectionIndicatorIsImpactedNumber + 1);
-  qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator, selectionIndicatorIsImpactedNumber + 2);
+  qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator,
+                        selectionIndicatorIsActiveNumber);
+  qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator,
+                        selectionIndicatorIsActiveNumber + 1);
+  qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator,
+                        selectionIndicatorIsImpactedNumber);
+  qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator,
+                        selectionIndicatorIsImpactedNumber + 1);
+  qsci->indicatorDefine(QsciScintilla::RoundBoxIndicator,
+                        selectionIndicatorIsImpactedNumber + 2);
 
   qsci->markerDefine(QsciScintilla::Circle, errMarkerNumber);
   qsci->markerDefine(QsciScintilla::Bookmark, bmMarkerNumber);
@@ -212,7 +203,6 @@ ScintillaEditor::ScintillaEditor(QWidget *parent) : EditorInterface(parent)
   qsci->markerDefine('5', selectionMarkerLevelNumber + 4);
   qsci->markerDefine('+', selectionMarkerLevelNumber + 5);
 
-
   qsci->setMarginType(numberMargin, QsciScintilla::NumberMargin);
   qsci->setMarginLineNumbers(numberMargin, true);
   qsci->setMarginMarkerMask(numberMargin, 0);
@@ -220,7 +210,14 @@ ScintillaEditor::ScintillaEditor(QWidget *parent) : EditorInterface(parent)
   qsci->setMarginType(symbolMargin, QsciScintilla::SymbolMargin);
   qsci->setMarginLineNumbers(symbolMargin, false);
   qsci->setMarginWidth(symbolMargin, 0);
-  qsci->setMarginMarkerMask(symbolMargin, 1 << errMarkerNumber | 1 << bmMarkerNumber | 1 << selectionMarkerLevelNumber | 1 << (selectionMarkerLevelNumber + 1) | 1 << (selectionMarkerLevelNumber + 2) | 1 << (selectionMarkerLevelNumber + 3) | 1 << (selectionMarkerLevelNumber + 4) | 1 << (selectionMarkerLevelNumber + 5));
+  qsci->setMarginMarkerMask(symbolMargin,
+                            1 << errMarkerNumber | 1 << bmMarkerNumber |
+                                1 << selectionMarkerLevelNumber |
+                                1 << (selectionMarkerLevelNumber + 1) |
+                                1 << (selectionMarkerLevelNumber + 2) |
+                                1 << (selectionMarkerLevelNumber + 3) |
+                                1 << (selectionMarkerLevelNumber + 4) |
+                                1 << (selectionMarkerLevelNumber + 5));
 
 #if ENABLE_LEXERTL
   auto newLexer = new ScadLexer2(this);
@@ -232,22 +229,31 @@ ScintillaEditor::ScintillaEditor(QWidget *parent) : EditorInterface(parent)
 
   initMargin();
 
-  connect(qsci, &QsciScintilla::textChanged, this, &ScintillaEditor::contentsChanged);
-  connect(qsci, &QsciScintilla::modificationChanged, this, &ScintillaEditor::fireModificationChanged);
-  connect(qsci, &QsciScintilla::userListActivated, this, &ScintillaEditor::onUserListSelected);
+  connect(qsci, &QsciScintilla::textChanged, this,
+          &ScintillaEditor::contentsChanged);
+  connect(qsci, &QsciScintilla::modificationChanged, this,
+          &ScintillaEditor::fireModificationChanged);
+  connect(qsci, &QsciScintilla::userListActivated, this,
+          &ScintillaEditor::onUserListSelected);
   qsci->installEventFilter(this);
   qsci->viewport()->installEventFilter(this);
 
   qsci->setContextMenuPolicy(Qt::CustomContextMenu);
-  connect(qsci, &QsciScintilla::customContextMenuRequested, this, &ScintillaEditor::showContextMenuEvent);
-
-  qsci->indicatorDefine(QsciScintilla::ThinCompositionIndicator, hyperlinkIndicatorNumber);
-  qsci->SendScintilla(QsciScintilla::SCI_INDICSETSTYLE, hyperlinkIndicatorNumber, QsciScintilla::INDIC_HIDDEN);
-  connect(qsci, &QsciScintilla::indicatorClicked, this, &ScintillaEditor::onIndicatorClicked);
-  connect(qsci, &QsciScintilla::indicatorReleased, this, &ScintillaEditor::onIndicatorReleased);
+  connect(qsci, &QsciScintilla::customContextMenuRequested, this,
+          &ScintillaEditor::showContextMenuEvent);
+
+  qsci->indicatorDefine(QsciScintilla::ThinCompositionIndicator,
+                        hyperlinkIndicatorNumber);
+  qsci->SendScintilla(QsciScintilla::SCI_INDICSETSTYLE,
+                      hyperlinkIndicatorNumber, QsciScintilla::INDIC_HIDDEN);
+  connect(qsci, &QsciScintilla::indicatorClicked, this,
+          &ScintillaEditor::onIndicatorClicked);
+  connect(qsci, &QsciScintilla::indicatorReleased, this,
+          &ScintillaEditor::onIndicatorReleased);
 
 #if QSCINTILLA_VERSION >= 0x020b00
-  connect(qsci, &QsciScintilla::SCN_URIDROPPED, this, &ScintillaEditor::uriDropped);
+  connect(qsci, &QsciScintilla::SCN_URIDROPPED, this,
+          &ScintillaEditor::uriDropped);
 #endif
   connect(qsci, &QsciScintilla::SCN_FOCUSIN, this, &ScintillaEditor::focusIn);
 
@@ -255,95 +261,95 @@ ScintillaEditor::ScintillaEditor(QWidget *parent) : EditorInterface(parent)
   qsci->SendScintilla(QsciScintillaBase::SCI_SETBUFFEREDDRAW, false);
 }
 
-QPoint ScintillaEditor::mapToGlobal(const QPoint& pos)
-{
+QPoint ScintillaEditor::mapToGlobal(const QPoint &pos) {
   return qsci->mapToGlobal(pos);
 }
 
-QMenu *ScintillaEditor::createStandardContextMenu()
-{
+QMenu *ScintillaEditor::createStandardContextMenu() {
   return qsci->createStandardContextMenu();
 }
 
-void ScintillaEditor::addTemplate()
-{
+void ScintillaEditor::addTemplate() {
   addTemplate(PlatformUtils::resourceBasePath());
   addTemplate(PlatformUtils::userConfigPath());
-  for (const auto& key: templateMap.keys()) {
+  for (const auto &key : templateMap.keys()) {
     userList.append(key);
   }
 }
 
-void ScintillaEditor::addTemplate(const fs::path& path)
-{
+void ScintillaEditor::addTemplate(const fs::path &path) {
   const auto template_path = path / "templates";
 
   if (fs::exists(template_path) && fs::is_directory(template_path)) {
-    for (const auto& dirEntry : boost::make_iterator_range(fs::directory_iterator{template_path}, {})) {
-      if (!fs::is_regular_file(dirEntry.status())) continue;
+    for (const auto &dirEntry : boost::make_iterator_range(
+             fs::directory_iterator{template_path}, {})) {
+      if (!fs::is_regular_file(dirEntry.status()))
+        continue;
 
-      const auto& path = dirEntry.path();
-      if (!(path.extension() == ".json")) continue;
+      const auto &path = dirEntry.path();
+      if (!(path.extension() == ".json"))
+        continue;
 
       boost::property_tree::ptree pt;
       try {
         boost::property_tree::read_json(path.generic_string().c_str(), pt);
         const QString key = QString::fromStdString(pt.get<std::string>("key"));
-        const QString content = QString::fromStdString(pt.get<std::string>("content"));
+        const QString content =
+            QString::fromStdString(pt.get<std::string>("content"));
         const int cursor_offset = pt.get<int>("offset", -1);
 
         templateMap.insert(key, ScadTemplate(content, cursor_offset));
-      } catch (const std::exception& e) {
-        LOG("Error reading template file '%1$s': %2$s", path.generic_string(), e.what());
+      } catch (const std::exception &e) {
+        LOG("Error reading template file '%1$s': %2$s", path.generic_string(),
+            e.what());
       }
     }
   }
 }
 
-void ScintillaEditor::displayTemplates()
-{
-  qsci->showUserList(1, userList);
-}
+void ScintillaEditor::displayTemplates() { qsci->showUserList(1, userList); }
 
-void ScintillaEditor::foldUnfold()
-{
-  qsci->foldAll();
-}
+void ScintillaEditor::foldUnfold() { qsci->foldAll(); }
 
 /**
  * Apply the settings that are changeable in the preferences. This is also
  * called in the event handler from the preferences.
  */
-void ScintillaEditor::applySettings()
-{
+void ScintillaEditor::applySettings() {
   SettingsConverter conv;
 
   qsci->setIndentationWidth(Settings::Settings::indentationWidth.value());
   qsci->setTabWidth(Settings::Settings::tabWidth.value());
   qsci->setWrapMode(conv.toWrapMode(Settings::Settings::lineWrap.value()));
-  qsci->setWrapIndentMode(conv.toLineWrapIndentationStyle(Settings::Settings::lineWrapIndentationStyle.value()));
-  qsci->setWrapVisualFlags(conv.toLineWrapVisualization(Settings::Settings::lineWrapVisualizationEnd.value()),
-                           conv.toLineWrapVisualization(Settings::Settings::lineWrapVisualizationBegin.value()),
-                           Settings::Settings::lineWrapIndentation.value());
-  qsci->setWhitespaceVisibility(conv.toShowWhitespaces(Settings::Settings::showWhitespace.value()));
+  qsci->setWrapIndentMode(conv.toLineWrapIndentationStyle(
+      Settings::Settings::lineWrapIndentationStyle.value()));
+  qsci->setWrapVisualFlags(
+      conv.toLineWrapVisualization(
+          Settings::Settings::lineWrapVisualizationEnd.value()),
+      conv.toLineWrapVisualization(
+          Settings::Settings::lineWrapVisualizationBegin.value()),
+      Settings::Settings::lineWrapIndentation.value());
+  qsci->setWhitespaceVisibility(
+      conv.toShowWhitespaces(Settings::Settings::showWhitespace.value()));
   qsci->setWhitespaceSize(Settings::Settings::showWhitespaceSize.value());
   qsci->setAutoIndent(Settings::Settings::autoIndent.value());
   qsci->setBackspaceUnindents(Settings::Settings::backspaceUnindents.value());
 
-  const auto& indentStyle = Settings::Settings::indentStyle.value();
+  const auto &indentStyle = Settings::Settings::indentStyle.value();
   qsci->setIndentationsUseTabs(indentStyle == "Tabs");
-  const auto& tabKeyFunction = Settings::Settings::tabKeyFunction.value();
+  const auto &tabKeyFunction = Settings::Settings::tabKeyFunction.value();
   qsci->setTabIndents(tabKeyFunction == "Indent");
 
-  qsci->setBraceMatching(Settings::Settings::enableBraceMatching.value() ? QsciScintilla::SloppyBraceMatch : QsciScintilla::NoBraceMatch);
+  qsci->setBraceMatching(Settings::Settings::enableBraceMatching.value()
+                             ? QsciScintilla::SloppyBraceMatch
+                             : QsciScintilla::NoBraceMatch);
   qsci->setCaretLineVisible(Settings::Settings::highlightCurrentLine.value());
   onTextChanged();
 
   setupAutoComplete(false);
 }
 
-void ScintillaEditor::setupAutoComplete(const bool forceOff)
-{
+void ScintillaEditor::setupAutoComplete(const bool forceOff) {
   if (qsci->isListActive()) {
     qsci->cancelList();
   }
@@ -352,7 +358,8 @@ void ScintillaEditor::setupAutoComplete(const bool forceOff)
     qsci->SendScintilla(QsciScintilla::SCI_CALLTIPCANCEL);
   }
 
-  const bool configValue = GlobalPreferences::inst()->getValue("editor/enableAutocomplete").toBool();
+  const bool configValue =
+      GlobalPreferences::inst()->getValue("editor/enableAutocomplete").toBool();
   const bool enable = configValue && !forceOff;
 
   if (enable) {
@@ -367,40 +374,32 @@ void ScintillaEditor::setupAutoComplete(const bool forceOff)
     qsci->setCallTipsStyle(QsciScintilla::CallTipsNone);
   }
 
-  int val = GlobalPreferences::inst()->getValue("editor/characterThreshold").toInt();
+  int val =
+      GlobalPreferences::inst()->getValue("editor/characterThreshold").toInt();
   qsci->setAutoCompletionThreshold(val <= 0 ? 1 : val);
 }
 
-void ScintillaEditor::fireModificationChanged()
-{
+void ScintillaEditor::fireModificationChanged() {
   emit modificationChanged(this);
 }
 
-void ScintillaEditor::setPlainText(const QString& text)
-{
+void ScintillaEditor::setPlainText(const QString &text) {
   qsci->setText(text);
   setContentModified(false);
 }
 
-QString ScintillaEditor::toPlainText()
-{
-  return qsci->text();
-}
+QString ScintillaEditor::toPlainText() { return qsci->text(); }
 
-void ScintillaEditor::setContentModified(bool modified)
-{
-  // FIXME: Due to an issue with QScintilla, we need to do this on the document itself.
+void ScintillaEditor::setContentModified(bool modified) {
+  // FIXME: Due to an issue with QScintilla, we need to do this on the document
+  // itself.
   qsci->SCN_SAVEPOINTLEFT();
   qsci->setModified(modified);
 }
 
-bool ScintillaEditor::isContentModified()
-{
-  return qsci->isModified();
-}
+bool ScintillaEditor::isContentModified() { return qsci->isModified(); }
 
-void ScintillaEditor::highlightError(int error_pos)
-{
+void ScintillaEditor::highlightError(int error_pos) {
   int line, index;
   qsci->lineIndexFromPosition(error_pos, &line, &index);
   qsci->fillIndicatorRange(line, index, line, index + 1, errorIndicatorNumber);
@@ -408,8 +407,7 @@ void ScintillaEditor::highlightError(int error_pos)
   updateSymbolMarginVisibility();
 }
 
-void ScintillaEditor::unhighlightLastError()
-{
+void ScintillaEditor::unhighlightLastError() {
   auto totalLength = qsci->length();
   int line, index;
   qsci->lineIndexFromPosition(totalLength, &line, &index);
@@ -418,38 +416,39 @@ void ScintillaEditor::unhighlightLastError()
   updateSymbolMarginVisibility();
 }
 
-QColor ScintillaEditor::readColor(const boost::property_tree::ptree& pt, const std::string& name, const QColor& defaultColor)
-{
+QColor ScintillaEditor::readColor(const boost::property_tree::ptree &pt,
+                                  const std::string &name,
+                                  const QColor &defaultColor) {
   try {
     const auto val = pt.get<std::string>(name);
     return {val.c_str()};
-  } catch (const std::exception& e) {
+  } catch (const std::exception &e) {
     return defaultColor;
   }
 }
 
-std::string ScintillaEditor::readString(const boost::property_tree::ptree& pt, const std::string& name, const std::string& defaultValue)
-{
+std::string ScintillaEditor::readString(const boost::property_tree::ptree &pt,
+                                        const std::string &name,
+                                        const std::string &defaultValue) {
   try {
     return pt.get<std::string>(name);
-  } catch (const std::exception& e) {
+  } catch (const std::exception &e) {
     return defaultValue;
   }
 }
 
-int ScintillaEditor::readInt(const boost::property_tree::ptree& pt, const std::string& name, const int defaultValue)
-{
+int ScintillaEditor::readInt(const boost::property_tree::ptree &pt,
+                             const std::string &name, const int defaultValue) {
   try {
     const auto val = pt.get<int>(name);
     return val;
-  } catch (const std::exception& e) {
+  } catch (const std::exception &e) {
     return defaultValue;
   }
 }
 
 #if ENABLE_LEXERTL
-void ScintillaEditor::setLexer(ScadLexer2 *newLexer)
-{
+void ScintillaEditor::setLexer(ScadLexer2 *newLexer) {
   delete this->api;
   this->qsci->setLexer(newLexer);
   this->api = new ScadApi(this, newLexer);
@@ -457,8 +456,7 @@ void ScintillaEditor::setLexer(ScadLexer2 *newLexer)
   this->lexer = newLexer;
 }
 #else
-void ScintillaEditor::setLexer(ScadLexer *newLexer)
-{
+void ScintillaEditor::setLexer(ScadLexer *newLexer) {
   delete this->api;
   this->qsci->setLexer(newLexer);
   this->api = new ScadApi(this, newLexer);
@@ -467,9 +465,8 @@ void ScintillaEditor::setLexer(ScadLexer *newLexer)
 }
 #endif // if ENABLE_LEXERTL
 
-void ScintillaEditor::setColormap(const EditorColorScheme *colorScheme)
-{
-  const auto& pt = colorScheme->propertyTree();
+void ScintillaEditor::setColormap(const EditorColorScheme *colorScheme) {
+  const auto &pt = colorScheme->propertyTree();
 
   try {
     auto font = this->lexer->font(this->lexer->defaultStyle());
@@ -478,23 +475,35 @@ void ScintillaEditor::setColormap(const EditorColorScheme *colorScheme)
 
 #if ENABLE_LEXERTL
 
-/// See original attempt at https://github.com/openscad/openscad/tree/lexertl/src
+    /// See original attempt at
+    /// https://github.com/openscad/openscad/tree/lexertl/src
 
     auto *newLexer = new ScadLexer2(this);
 
     // Custom keywords must be set before the lexer is constructed/finalized
-    boost::optional<const boost::property_tree::ptree&> keywords = pt.get_child_optional("keywords");
+    boost::optional<const boost::property_tree::ptree &> keywords =
+        pt.get_child_optional("keywords");
     if (keywords.is_initialized()) {
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom1", ""), ScadLexer2::Custom1);
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom2", ""), ScadLexer2::Custom2);
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom3", ""), ScadLexer2::Custom3);
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom4", ""), ScadLexer2::Custom4);
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom5", ""), ScadLexer2::Custom5);
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom6", ""), ScadLexer2::Custom6);
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom7", ""), ScadLexer2::Custom7);
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom8", ""), ScadLexer2::Custom8);
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom9", ""), ScadLexer2::Custom9);
-      newLexer->addKeywords(readString(keywords.get(), "keyword-custom10", ""), ScadLexer2::Custom10);
+      newLexer->addKeywords(readString(keywords.get(), "keyword-custom1", ""),
+                            ScadLexer2::Custom1);
+      newLexer->addKeywords(readString(keywords.get(), "keyword-custom2", ""),
+                            ScadLexer2::Custom2);
+      newLexer->addKeywords(readString(keywords.get(), "keyword-custom3", ""),
+                            ScadLexer2::Custom3);
+      newLexer->addKeywords(readString(keywords.get(), "keyword-custom4", ""),
+                            ScadLexer2::Custom4);
+      newLexer->addKeywords(readString(keywords.get(), "keyword-custom5", ""),
+                            ScadLexer2::Custom5);
+      newLexer->addKeywords(readString(keywords.get(), "keyword-custom6", ""),
+                            ScadLexer2::Custom6);
+      newLexer->addKeywords(readString(keywords.get(), "keyword-custom7", ""),
+                            ScadLexer2::Custom7);
+      newLexer->addKeywords(readString(keywords.get(), "keyword-custom8", ""),
+                            ScadLexer2::Custom8);
+      newLexer->addKeywords(readString(keywords.get(), "keyword-custom9", ""),
+                            ScadLexer2::Custom9);
+      newLexer->addKeywords(readString(keywords.get(), "keyword-custom10", ""),
+                            ScadLexer2::Custom10);
     }
 
     newLexer->finalizeLexer();
@@ -506,46 +515,72 @@ void ScintillaEditor::setColormap(const EditorColorScheme *colorScheme)
     newLexer->setColor(textColor);
     newLexer->setPaper(paperColor);
 
-    const auto& colors = pt.get_child("colors");
-
-    newLexer->setColor(readColor(colors, "operator", textColor), ScadLexer2::Operator);
-    newLexer->setColor(readColor(colors, "comment", textColor), ScadLexer2::Comment);
-    newLexer->setColor(readColor(colors, "number", textColor), ScadLexer2::Number);
-    newLexer->setColor(readColor(colors, "string", textColor), ScadLexer2::String);
-    newLexer->setColor(readColor(colors, "variables", textColor), ScadLexer2::Variable);
-    newLexer->setColor(readColor(colors, "keywords", textColor), ScadLexer2::Keyword); // formerly keyword1
-    newLexer->setColor(readColor(colors, "transformations", textColor), ScadLexer2::Transformation); // formerly keyword3
-    newLexer->setColor(readColor(colors, "booleans", textColor), ScadLexer2::Boolean); // formerly keyword3
-    newLexer->setColor(readColor(colors, "functions", textColor), ScadLexer2::Function); // formerly keyword2
-    newLexer->setColor(readColor(colors, "models", textColor), ScadLexer2::Model); // formerly keyword3
-    newLexer->setColor(readColor(colors, "special-variables", textColor), ScadLexer2::SpecialVariable); // formerly keyword1
-
-    newLexer->setColor(readColor(colors, "keyword-custom1", textColor), ScadLexer2::Custom1);
-    newLexer->setColor(readColor(colors, "keyword-custom2", textColor), ScadLexer2::Custom2);
-    newLexer->setColor(readColor(colors, "keyword-custom3", textColor), ScadLexer2::Custom3);
-    newLexer->setColor(readColor(colors, "keyword-custom4", textColor), ScadLexer2::Custom4);
-    newLexer->setColor(readColor(colors, "keyword-custom5", textColor), ScadLexer2::Custom5);
-    newLexer->setColor(readColor(colors, "keyword-custom6", textColor), ScadLexer2::Custom6);
-    newLexer->setColor(readColor(colors, "keyword-custom7", textColor), ScadLexer2::Custom7);
-    newLexer->setColor(readColor(colors, "keyword-custom8", textColor), ScadLexer2::Custom8);
-    newLexer->setColor(readColor(colors, "keyword-custom9", textColor), ScadLexer2::Custom9);
-    newLexer->setColor(readColor(colors, "keyword-custom10", textColor), ScadLexer2::Custom10);
+    const auto &colors = pt.get_child("colors");
+
+    newLexer->setColor(readColor(colors, "operator", textColor),
+                       ScadLexer2::Operator);
+    newLexer->setColor(readColor(colors, "comment", textColor),
+                       ScadLexer2::Comment);
+    newLexer->setColor(readColor(colors, "number", textColor),
+                       ScadLexer2::Number);
+    newLexer->setColor(readColor(colors, "string", textColor),
+                       ScadLexer2::String);
+    newLexer->setColor(readColor(colors, "variables", textColor),
+                       ScadLexer2::Variable);
+    newLexer->setColor(readColor(colors, "keywords", textColor),
+                       ScadLexer2::Keyword); // formerly keyword1
+    newLexer->setColor(readColor(colors, "transformations", textColor),
+                       ScadLexer2::Transformation); // formerly keyword3
+    newLexer->setColor(readColor(colors, "booleans", textColor),
+                       ScadLexer2::Boolean); // formerly keyword3
+    newLexer->setColor(readColor(colors, "functions", textColor),
+                       ScadLexer2::Function); // formerly keyword2
+    newLexer->setColor(readColor(colors, "models", textColor),
+                       ScadLexer2::Model); // formerly keyword3
+    newLexer->setColor(readColor(colors, "special-variables", textColor),
+                       ScadLexer2::SpecialVariable); // formerly keyword1
+
+    newLexer->setColor(readColor(colors, "keyword-custom1", textColor),
+                       ScadLexer2::Custom1);
+    newLexer->setColor(readColor(colors, "keyword-custom2", textColor),
+                       ScadLexer2::Custom2);
+    newLexer->setColor(readColor(colors, "keyword-custom3", textColor),
+                       ScadLexer2::Custom3);
+    newLexer->setColor(readColor(colors, "keyword-custom4", textColor),
+                       ScadLexer2::Custom4);
+    newLexer->setColor(readColor(colors, "keyword-custom5", textColor),
+                       ScadLexer2::Custom5);
+    newLexer->setColor(readColor(colors, "keyword-custom6", textColor),
+                       ScadLexer2::Custom6);
+    newLexer->setColor(readColor(colors, "keyword-custom7", textColor),
+                       ScadLexer2::Custom7);
+    newLexer->setColor(readColor(colors, "keyword-custom8", textColor),
+                       ScadLexer2::Custom8);
+    newLexer->setColor(readColor(colors, "keyword-custom9", textColor),
+                       ScadLexer2::Custom9);
+    newLexer->setColor(readColor(colors, "keyword-custom10", textColor),
+                       ScadLexer2::Custom10);
 
 #else
     auto *newLexer = new ScadLexer(this);
 
     // Keywords must be set before the lexer is attached to QScintilla
     // as they seem to be read and cached at attach time.
-    boost::optional<const boost::property_tree::ptree&> keywords = pt.get_child_optional("keywords");
+    boost::optional<const boost::property_tree::ptree &> keywords =
+        pt.get_child_optional("keywords");
     if (keywords.is_initialized()) {
       newLexer->setKeywords(1, readString(keywords.get(), "keyword-set1", ""));
       newLexer->setKeywords(2, readString(keywords.get(), "keyword-set2", ""));
-      newLexer->setKeywords(3, readString(keywords.get(), "keyword-set-doc", ""));
+      newLexer->setKeywords(3,
+                            readString(keywords.get(), "keyword-set-doc", ""));
       newLexer->setKeywords(4, readString(keywords.get(), "keyword-set3", ""));
     }
 
-    // See https://github.com/openscad/openscad/issues/1172 for details about why we can't do syntax coloring with # lines
-    newLexer->setStylePreprocessor(true); // does not work on first word, but allows remaining words to be syntax colored
+    // See https://github.com/openscad/openscad/issues/1172 for details about
+    // why we can't do syntax coloring with # lines
+    newLexer->setStylePreprocessor(
+        true); // does not work on first word, but allows remaining words to be
+               // syntax colored
 
     setLexer(newLexer);
 
@@ -555,105 +590,216 @@ void ScintillaEditor::setColormap(const EditorColorScheme *colorScheme)
     newLexer->setColor(textColor);
     newLexer->setPaper(paperColor);
 
-    const auto& colors = pt.get_child("colors");
-    newLexer->setColor(readColor(colors, "keyword1", textColor), QsciLexerCPP::Keyword);
-    newLexer->setColor(readColor(colors, "keyword2", textColor), QsciLexerCPP::KeywordSet2);
-    newLexer->setColor(readColor(colors, "keyword3", textColor), QsciLexerCPP::GlobalClass);
-    newLexer->setColor(readColor(colors, "number", textColor), QsciLexerCPP::Number);
-    newLexer->setColor(readColor(colors, "string", textColor), QsciLexerCPP::DoubleQuotedString);
-    newLexer->setColor(readColor(colors, "operator", textColor), QsciLexerCPP::Operator);
-    newLexer->setColor(readColor(colors, "comment", textColor), QsciLexerCPP::Comment);
-    newLexer->setColor(readColor(colors, "commentline", textColor), QsciLexerCPP::CommentLine);
-    newLexer->setColor(readColor(colors, "commentdoc", textColor), QsciLexerCPP::CommentDoc);
-    newLexer->setColor(readColor(colors, "commentdoc", textColor), QsciLexerCPP::CommentLineDoc);
-    newLexer->setColor(readColor(colors, "commentdockeyword", textColor), QsciLexerCPP::CommentDocKeyword);
-
-#endif  // ENABLE_LEXERTL
+    const auto &colors = pt.get_child("colors");
+    newLexer->setColor(readColor(colors, "keyword1", textColor),
+                       QsciLexerCPP::Keyword);
+    newLexer->setColor(readColor(colors, "keyword2", textColor),
+                       QsciLexerCPP::KeywordSet2);
+    newLexer->setColor(readColor(colors, "keyword3", textColor),
+                       QsciLexerCPP::GlobalClass);
+    newLexer->setColor(readColor(colors, "number", textColor),
+                       QsciLexerCPP::Number);
+    newLexer->setColor(readColor(colors, "string", textColor),
+                       QsciLexerCPP::DoubleQuotedString);
+    newLexer->setColor(readColor(colors, "operator", textColor),
+                       QsciLexerCPP::Operator);
+    newLexer->setColor(readColor(colors, "comment", textColor),
+                       QsciLexerCPP::Comment);
+    newLexer->setColor(readColor(colors, "commentline", textColor),
+                       QsciLexerCPP::CommentLine);
+    newLexer->setColor(readColor(colors, "commentdoc", textColor),
+                       QsciLexerCPP::CommentDoc);
+    newLexer->setColor(readColor(colors, "commentdoc", textColor),
+                       QsciLexerCPP::CommentLineDoc);
+    newLexer->setColor(readColor(colors, "commentdockeyword", textColor),
+                       QsciLexerCPP::CommentDocKeyword);
+
+#endif // ENABLE_LEXERTL
 
     // Somehow, the margin font got lost when we deleted the old lexer
     qsci->setMarginsFont(font);
 
-    const auto& caret = pt.get_child("caret");
+    const auto &caret = pt.get_child("caret");
     qsci->setCaretWidth(readInt(caret, "width", 1));
     qsci->setCaretForegroundColor(readColor(caret, "foreground", textColor));
-    qsci->setCaretLineBackgroundColor(readColor(caret, "line-background", paperColor));
-
-    qsci->setMarkerBackgroundColor(readColor(colors, "error-marker", QColor(255, 0, 0, 100)), errMarkerNumber);
-    qsci->setMarkerBackgroundColor(readColor(colors, "bookmark-marker", QColor(150, 200, 255, 100)), bmMarkerNumber); // light blue
-    qsci->setMarkerBackgroundColor(readColor(colors, "reference-marker1", QColor(11, 156, 49, 100)), selectionMarkerLevelNumber);
-    qsci->setMarkerBackgroundColor(readColor(colors, "reference-marker2", QColor(11, 156, 49, 50)), selectionMarkerLevelNumber + 1);
-    qsci->setMarkerBackgroundColor(readColor(colors, "reference-marker3", QColor(11, 156, 49, 50)), selectionMarkerLevelNumber + 2);
-    qsci->setMarkerBackgroundColor(readColor(colors, "reference-marker4", QColor(11, 156, 49, 50)), selectionMarkerLevelNumber + 3);
-    qsci->setMarkerBackgroundColor(readColor(colors, "reference-marker5", QColor(11, 156, 49, 50)), selectionMarkerLevelNumber + 4);
-    qsci->setMarkerBackgroundColor(readColor(colors, "reference-marker6", QColor(11, 156, 49, 50)), selectionMarkerLevelNumber + 5);
-    qsci->setMarkerBackgroundColor(readColor(colors, "bookmark-marker", QColor(150, 200, 255, 50)), bmMarkerNumber); // light blue
-    qsci->setIndicatorForegroundColor(readColor(colors, "selected-highlight-indicator", QColor(11, 156, 49, 100)), selectionIndicatorIsActiveNumber); //light green
-    qsci->setIndicatorOutlineColor(readColor(colors, "selected-highlight-indicator-outline", QColor(11, 156, 49, 100)), selectionIndicatorIsActiveNumber); //light green
-    qsci->setIndicatorForegroundColor(readColor(colors, "selected-highlight1-indicator", QColor(11, 156, 49, 50)), selectionIndicatorIsActiveNumber + 1); //light green
-    qsci->setIndicatorOutlineColor(readColor(colors, "selected-highlight1-indicator-outline", QColor(11, 156, 49, 50)), selectionIndicatorIsActiveNumber + 1); //light green
-    qsci->setIndicatorForegroundColor(readColor(colors, "referenced-highlight0-indicator", QColor(255, 128, 128, 100)), selectionIndicatorIsImpactedNumber); //light green
-    qsci->setIndicatorOutlineColor(readColor(colors, "referenced-highlight0-indicator-outline", QColor(255, 128, 128, 100)), selectionIndicatorIsImpactedNumber); //light green
-    qsci->setIndicatorForegroundColor(readColor(colors, "referenced-highlight1-indicator", QColor(255, 128, 128, 100)), selectionIndicatorIsImpactedNumber + 1); //light green
-    qsci->setIndicatorOutlineColor(readColor(colors, "referenced-highlight1-indicator-outline", QColor(255, 128, 128, 80)), selectionIndicatorIsImpactedNumber + 1); //light green
-    qsci->setIndicatorForegroundColor(readColor(colors, "referenced-highlight2-indicator", QColor(255, 128, 128, 100)), selectionIndicatorIsImpactedNumber + 2); //light green
-    qsci->setIndicatorOutlineColor(readColor(colors, "referenced-highlight2-indicator-outline", QColor(255, 128, 128, 60)), selectionIndicatorIsImpactedNumber + 2); //light green
-    qsci->setIndicatorForegroundColor(readColor(colors, "error-indicator", QColor(255, 0, 0, 100)), errorIndicatorNumber); //red
-    qsci->setIndicatorOutlineColor(readColor(colors, "error-indicator-outline", QColor(255, 0, 0, 100)), errorIndicatorNumber); //red
-    qsci->setIndicatorForegroundColor(readColor(colors, "find-indicator", QColor(255, 255, 0, 100)), findIndicatorNumber); //yellow
-    qsci->setIndicatorOutlineColor(readColor(colors, "find-indicator-outline", QColor(255, 255, 0, 100)), findIndicatorNumber); //yellow
-    qsci->setIndicatorForegroundColor(readColor(colors, "hyperlink-indicator", QColor(139, 24, 168, 100)), hyperlinkIndicatorNumber); //violet
-    qsci->setIndicatorOutlineColor(readColor(colors, "hyperlink-indicator-outline", QColor(139, 24, 168, 100)), hyperlinkIndicatorNumber); //violet
-    qsci->setIndicatorHoverForegroundColor(readColor(colors, "hyperlink-indicator-hover", QColor(139, 24, 168, 100)), hyperlinkIndicatorNumber); //violet
-    qsci->setWhitespaceForegroundColor(readColor(colors, "whitespace-foreground", textColor));
-    qsci->setMarginsBackgroundColor(readColor(colors, "margin-background", paperColor));
-    qsci->setMarginsForegroundColor(readColor(colors, "margin-foreground", textColor));
-    qsci->setFoldMarginColors(readColor(colors, "margin-background", paperColor),
-                              readColor(colors, "margin-background", paperColor));
-    qsci->setMatchedBraceBackgroundColor(readColor(colors, "matched-brace-background", paperColor));
-    qsci->setMatchedBraceForegroundColor(readColor(colors, "matched-brace-foreground", textColor));
-    qsci->setUnmatchedBraceBackgroundColor(readColor(colors, "unmatched-brace-background", paperColor));
-    qsci->setUnmatchedBraceForegroundColor(readColor(colors, "unmatched-brace-foreground", textColor));
-    qsci->setSelectionForegroundColor(readColor(colors, "selection-foreground", paperColor));
-    qsci->setSelectionBackgroundColor(readColor(colors, "selection-background", textColor));
+    qsci->setCaretLineBackgroundColor(
+        readColor(caret, "line-background", paperColor));
+
+    qsci->setMarkerBackgroundColor(
+        readColor(colors, "error-marker", QColor(255, 0, 0, 100)),
+        errMarkerNumber);
+    qsci->setMarkerBackgroundColor(
+        readColor(colors, "bookmark-marker", QColor(150, 200, 255, 100)),
+        bmMarkerNumber); // light blue
+    qsci->setMarkerBackgroundColor(
+        readColor(colors, "reference-marker1", QColor(11, 156, 49, 100)),
+        selectionMarkerLevelNumber);
+    qsci->setMarkerBackgroundColor(
+        readColor(colors, "reference-marker2", QColor(11, 156, 49, 50)),
+        selectionMarkerLevelNumber + 1);
+    qsci->setMarkerBackgroundColor(
+        readColor(colors, "reference-marker3", QColor(11, 156, 49, 50)),
+        selectionMarkerLevelNumber + 2);
+    qsci->setMarkerBackgroundColor(
+        readColor(colors, "reference-marker4", QColor(11, 156, 49, 50)),
+        selectionMarkerLevelNumber + 3);
+    qsci->setMarkerBackgroundColor(
+        readColor(colors, "reference-marker5", QColor(11, 156, 49, 50)),
+        selectionMarkerLevelNumber + 4);
+    qsci->setMarkerBackgroundColor(
+        readColor(colors, "reference-marker6", QColor(11, 156, 49, 50)),
+        selectionMarkerLevelNumber + 5);
+    qsci->setMarkerBackgroundColor(
+        readColor(colors, "bookmark-marker", QColor(150, 200, 255, 50)),
+        bmMarkerNumber); // light blue
+    qsci->setIndicatorForegroundColor(
+        readColor(colors, "selected-highlight-indicator",
+                  QColor(11, 156, 49, 100)),
+        selectionIndicatorIsActiveNumber); // light green
+    qsci->setIndicatorOutlineColor(
+        readColor(colors, "selected-highlight-indicator-outline",
+                  QColor(11, 156, 49, 100)),
+        selectionIndicatorIsActiveNumber); // light green
+    qsci->setIndicatorForegroundColor(
+        readColor(colors, "selected-highlight1-indicator",
+                  QColor(11, 156, 49, 50)),
+        selectionIndicatorIsActiveNumber + 1); // light green
+    qsci->setIndicatorOutlineColor(
+        readColor(colors, "selected-highlight1-indicator-outline",
+                  QColor(11, 156, 49, 50)),
+        selectionIndicatorIsActiveNumber + 1); // light green
+    qsci->setIndicatorForegroundColor(
+        readColor(colors, "referenced-highlight0-indicator",
+                  QColor(255, 128, 128, 100)),
+        selectionIndicatorIsImpactedNumber); // light green
+    qsci->setIndicatorOutlineColor(
+        readColor(colors, "referenced-highlight0-indicator-outline",
+                  QColor(255, 128, 128, 100)),
+        selectionIndicatorIsImpactedNumber); // light green
+    qsci->setIndicatorForegroundColor(
+        readColor(colors, "referenced-highlight1-indicator",
+                  QColor(255, 128, 128, 100)),
+        selectionIndicatorIsImpactedNumber + 1); // light green
+    qsci->setIndicatorOutlineColor(
+        readColor(colors, "referenced-highlight1-indicator-outline",
+                  QColor(255, 128, 128, 80)),
+        selectionIndicatorIsImpactedNumber + 1); // light green
+    qsci->setIndicatorForegroundColor(
+        readColor(colors, "referenced-highlight2-indicator",
+                  QColor(255, 128, 128, 100)),
+        selectionIndicatorIsImpactedNumber + 2); // light green
+    qsci->setIndicatorOutlineColor(
+        readColor(colors, "referenced-highlight2-indicator-outline",
+                  QColor(255, 128, 128, 60)),
+        selectionIndicatorIsImpactedNumber + 2); // light green
+    qsci->setIndicatorForegroundColor(
+        readColor(colors, "error-indicator", QColor(255, 0, 0, 100)),
+        errorIndicatorNumber); // red
+    qsci->setIndicatorOutlineColor(
+        readColor(colors, "error-indicator-outline", QColor(255, 0, 0, 100)),
+        errorIndicatorNumber); // red
+    qsci->setIndicatorForegroundColor(
+        readColor(colors, "find-indicator", QColor(255, 255, 0, 100)),
+        findIndicatorNumber); // yellow
+    qsci->setIndicatorOutlineColor(
+        readColor(colors, "find-indicator-outline", QColor(255, 255, 0, 100)),
+        findIndicatorNumber); // yellow
+    qsci->setIndicatorForegroundColor(
+        readColor(colors, "hyperlink-indicator", QColor(139, 24, 168, 100)),
+        hyperlinkIndicatorNumber); // violet
+    qsci->setIndicatorOutlineColor(readColor(colors,
+                                             "hyperlink-indicator-outline",
+                                             QColor(139, 24, 168, 100)),
+                                   hyperlinkIndicatorNumber); // violet
+    qsci->setIndicatorHoverForegroundColor(
+        readColor(colors, "hyperlink-indicator-hover",
+                  QColor(139, 24, 168, 100)),
+        hyperlinkIndicatorNumber); // violet
+    qsci->setWhitespaceForegroundColor(
+        readColor(colors, "whitespace-foreground", textColor));
+    qsci->setMarginsBackgroundColor(
+        readColor(colors, "margin-background", paperColor));
+    qsci->setMarginsForegroundColor(
+        readColor(colors, "margin-foreground", textColor));
+    qsci->setFoldMarginColors(
+        readColor(colors, "margin-background", paperColor),
+        readColor(colors, "margin-background", paperColor));
+    qsci->setMatchedBraceBackgroundColor(
+        readColor(colors, "matched-brace-background", paperColor));
+    qsci->setMatchedBraceForegroundColor(
+        readColor(colors, "matched-brace-foreground", textColor));
+    qsci->setUnmatchedBraceBackgroundColor(
+        readColor(colors, "unmatched-brace-background", paperColor));
+    qsci->setUnmatchedBraceForegroundColor(
+        readColor(colors, "unmatched-brace-foreground", textColor));
+    qsci->setSelectionForegroundColor(
+        readColor(colors, "selection-foreground", paperColor));
+    qsci->setSelectionBackgroundColor(
+        readColor(colors, "selection-background", textColor));
     qsci->setEdgeColor(readColor(colors, "edge", textColor));
-  } catch (const std::exception& e) {
+  } catch (const std::exception &e) {
     noColor();
   }
 }
 
-void ScintillaEditor::noColor()
-{
+void ScintillaEditor::noColor() {
   this->lexer->setPaper(Qt::white);
   this->lexer->setColor(Qt::black);
   qsci->setCaretWidth(2);
   qsci->setCaretForegroundColor(Qt::black);
   qsci->setMarkerBackgroundColor(QColor(255, 0, 0, 100), errMarkerNumber);
-  qsci->setMarkerBackgroundColor(QColor(150, 200, 255, 100), bmMarkerNumber); // light blue
-  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 100), selectionMarkerLevelNumber);
-  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 50), selectionMarkerLevelNumber + 1);
-  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 50), selectionMarkerLevelNumber + 2);
-  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 50), selectionMarkerLevelNumber + 3);
-  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 50), selectionMarkerLevelNumber + 4);
-  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 50), selectionMarkerLevelNumber + 5);
-  qsci->setMarkerBackgroundColor(QColor(150, 200, 255, 100), bmMarkerNumber); // light blue
-  qsci->setIndicatorForegroundColor(QColor(11, 156, 49, 100), selectionIndicatorIsActiveNumber);
-  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255), selectionIndicatorIsActiveNumber);
-  qsci->setIndicatorForegroundColor(QColor(11, 156, 49, 50), selectionIndicatorIsActiveNumber + 1);
-  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255), selectionIndicatorIsActiveNumber + 1);
-  qsci->setIndicatorForegroundColor(QColor(255, 128, 128, 100), selectionIndicatorIsImpactedNumber);
-  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255), selectionIndicatorIsImpactedNumber);
-  qsci->setIndicatorForegroundColor(QColor(255, 128, 128, 80), selectionIndicatorIsImpactedNumber + 1);
-  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255), selectionIndicatorIsImpactedNumber + 1);
-  qsci->setIndicatorForegroundColor(QColor(255, 128, 128, 60), selectionIndicatorIsImpactedNumber + 2);
-  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255), selectionIndicatorIsImpactedNumber + 2);
-
-  qsci->setIndicatorForegroundColor(QColor(255, 0, 0, 128), errorIndicatorNumber); //red
-  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255), errorIndicatorNumber); // only alpha part is used
-  qsci->setIndicatorForegroundColor(QColor(255, 255, 0, 128), findIndicatorNumber); //yellow
-  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255), findIndicatorNumber); // only alpha part is used
-  qsci->setIndicatorForegroundColor(QColor(139, 24, 168, 128), hyperlinkIndicatorNumber); //violet
-  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255), hyperlinkIndicatorNumber); // only alpha part is used
-  qsci->setIndicatorHoverForegroundColor(QColor(139, 24, 168, 128), hyperlinkIndicatorNumber); //violet
+  qsci->setMarkerBackgroundColor(QColor(150, 200, 255, 100),
+                                 bmMarkerNumber); // light blue
+  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 100),
+                                 selectionMarkerLevelNumber);
+  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 50),
+                                 selectionMarkerLevelNumber + 1);
+  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 50),
+                                 selectionMarkerLevelNumber + 2);
+  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 50),
+                                 selectionMarkerLevelNumber + 3);
+  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 50),
+                                 selectionMarkerLevelNumber + 4);
+  qsci->setMarkerBackgroundColor(QColor(11, 156, 49, 50),
+                                 selectionMarkerLevelNumber + 5);
+  qsci->setMarkerBackgroundColor(QColor(150, 200, 255, 100),
+                                 bmMarkerNumber); // light blue
+  qsci->setIndicatorForegroundColor(QColor(11, 156, 49, 100),
+                                    selectionIndicatorIsActiveNumber);
+  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255),
+                                 selectionIndicatorIsActiveNumber);
+  qsci->setIndicatorForegroundColor(QColor(11, 156, 49, 50),
+                                    selectionIndicatorIsActiveNumber + 1);
+  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255),
+                                 selectionIndicatorIsActiveNumber + 1);
+  qsci->setIndicatorForegroundColor(QColor(255, 128, 128, 100),
+                                    selectionIndicatorIsImpactedNumber);
+  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255),
+                                 selectionIndicatorIsImpactedNumber);
+  qsci->setIndicatorForegroundColor(QColor(255, 128, 128, 80),
+                                    selectionIndicatorIsImpactedNumber + 1);
+  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255),
+                                 selectionIndicatorIsImpactedNumber + 1);
+  qsci->setIndicatorForegroundColor(QColor(255, 128, 128, 60),
+                                    selectionIndicatorIsImpactedNumber + 2);
+  qsci->setIndicatorOutlineColor(QColor(0, 0, 0, 255),
+                                 selectionIndicatorIsImpactedNumber + 2);
+
+  qsci->setIndicatorForegroundColor(QColor(255, 0, 0, 128),
+                                    errorIndicatorNumber); // red
+  qsci->setIndicatorOutlineColor(
+      QColor(0, 0, 0, 255), errorIndicatorNumber); // only alpha part is used
+  qsci->setIndicatorForegroundColor(QColor(255, 255, 0, 128),
+                                    findIndicatorNumber); // yellow
+  qsci->setIndicatorOutlineColor(
+      QColor(0, 0, 0, 255), findIndicatorNumber); // only alpha part is used
+  qsci->setIndicatorForegroundColor(QColor(139, 24, 168, 128),
+                                    hyperlinkIndicatorNumber); // violet
+  qsci->setIndicatorOutlineColor(
+      QColor(0, 0, 0, 255),
+      hyperlinkIndicatorNumber); // only alpha part is used
+  qsci->setIndicatorHoverForegroundColor(QColor(139, 24, 168, 128),
+                                         hyperlinkIndicatorNumber); // violet
   qsci->setCaretLineBackgroundColor(Qt::white);
   qsci->setWhitespaceForegroundColor(Qt::black);
   qsci->setSelectionForegroundColor(Qt::black);
@@ -668,16 +814,19 @@ void ScintillaEditor::noColor()
   qsci->setEdgeColor(Qt::black);
 }
 
-void ScintillaEditor::enumerateColorSchemesInPath(ScintillaEditor::colorscheme_set_t& result_set, const fs::path& path)
-{
+void ScintillaEditor::enumerateColorSchemesInPath(
+    ScintillaEditor::colorscheme_set_t &result_set, const fs::path &path) {
   const auto color_schemes = path / "color-schemes" / "editor";
 
   if (fs::exists(color_schemes) && fs::is_directory(color_schemes)) {
-    for (const auto& dirEntry : boost::make_iterator_range(fs::directory_iterator{color_schemes}, {})) {
-      if (!fs::is_regular_file(dirEntry.status())) continue;
+    for (const auto &dirEntry : boost::make_iterator_range(
+             fs::directory_iterator{color_schemes}, {})) {
+      if (!fs::is_regular_file(dirEntry.status()))
+        continue;
 
-      const auto& path = dirEntry.path();
-      if (!(path.extension() == ".json")) continue;
+      const auto &path = dirEntry.path();
+      if (!(path.extension() == ".json"))
+        continue;
 
       auto colorScheme = std::make_shared<EditorColorScheme>(path);
       if (colorScheme->valid()) {
@@ -687,8 +836,7 @@ void ScintillaEditor::enumerateColorSchemesInPath(ScintillaEditor::colorscheme_s
   }
 }
 
-ScintillaEditor::colorscheme_set_t ScintillaEditor::enumerateColorSchemes()
-{
+ScintillaEditor::colorscheme_set_t ScintillaEditor::enumerateColorSchemes() {
   colorscheme_set_t result_set;
 
   enumerateColorSchemesInPath(result_set, PlatformUtils::resourceBasePath());
@@ -697,10 +845,9 @@ ScintillaEditor::colorscheme_set_t ScintillaEditor::enumerateColorSchemes()
   return result_set;
 }
 
-QStringList ScintillaEditor::colorSchemes()
-{
+QStringList ScintillaEditor::colorSchemes() {
   QStringList colorSchemes;
-  for (const auto& colorSchemeEntry : enumerateColorSchemes()) {
+  for (const auto &colorSchemeEntry : enumerateColorSchemes()) {
     colorSchemes << colorSchemeEntry.second.get()->name();
   }
   colorSchemes << "Off";
@@ -708,14 +855,10 @@ QStringList ScintillaEditor::colorSchemes()
   return colorSchemes;
 }
 
-bool ScintillaEditor::canUndo()
-{
-  return qsci->isUndoAvailable();
-}
+bool ScintillaEditor::canUndo() { return qsci->isUndoAvailable(); }
 
-void ScintillaEditor::setHighlightScheme(const QString& name)
-{
-  for (const auto& colorSchemeEntry : enumerateColorSchemes()) {
+void ScintillaEditor::setHighlightScheme(const QString &name) {
+  for (const auto &colorSchemeEntry : enumerateColorSchemes()) {
     const auto colorScheme = colorSchemeEntry.second.get();
     if (colorScheme->name() == name) {
       setColormap(colorScheme);
@@ -726,54 +869,28 @@ void ScintillaEditor::setHighlightScheme(const QString& name)
   noColor();
 }
 
-void ScintillaEditor::insert(const QString& text)
-{
-  qsci->insert(text);
-}
+void ScintillaEditor::insert(const QString &text) { qsci->insert(text); }
 
-void ScintillaEditor::setText(const QString& text)
-{
+void ScintillaEditor::setText(const QString &text) {
   qsci->selectAll(true);
   qsci->replaceSelectedText(text);
 }
 
-void ScintillaEditor::undo()
-{
-  qsci->undo();
-}
+void ScintillaEditor::undo() { qsci->undo(); }
 
-void ScintillaEditor::redo()
-{
-  qsci->redo();
-}
+void ScintillaEditor::redo() { qsci->redo(); }
 
-void ScintillaEditor::cut()
-{
-  qsci->cut();
-}
+void ScintillaEditor::cut() { qsci->cut(); }
 
-void ScintillaEditor::copy()
-{
-  qsci->copy();
-}
+void ScintillaEditor::copy() { qsci->copy(); }
 
-void ScintillaEditor::paste()
-{
-  qsci->paste();
-}
+void ScintillaEditor::paste() { qsci->paste(); }
 
-void ScintillaEditor::zoomIn()
-{
-  qsci->zoomIn();
-}
+void ScintillaEditor::zoomIn() { qsci->zoomIn(); }
 
-void ScintillaEditor::zoomOut()
-{
-  qsci->zoomOut();
-}
+void ScintillaEditor::zoomOut() { qsci->zoomOut(); }
 
-void ScintillaEditor::initFont(const QString& fontName, uint size)
-{
+void ScintillaEditor::initFont(const QString &fontName, uint size) {
   this->currentFont = QFont(fontName, size);
   this->currentFont.setFixedPitch(true);
   this->lexer->setFont(this->currentFont);
@@ -781,27 +898,28 @@ void ScintillaEditor::initFont(const QString& fontName, uint size)
   onTextChanged(); // Update margin width
 }
 
-void ScintillaEditor::initMargin()
-{
-  connect(qsci, &QsciScintilla::textChanged, this, &ScintillaEditor::onTextChanged);
+void ScintillaEditor::initMargin() {
+  connect(qsci, &QsciScintilla::textChanged, this,
+          &ScintillaEditor::onTextChanged);
 }
 
-void ScintillaEditor::onTextChanged()
-{
+void ScintillaEditor::onTextChanged() {
   auto enableLineNumbers = Settings::Settings::enableLineNumbers.value();
   if (enableLineNumbers) {
-    qsci->setMarginWidth(numberMargin, QString(trunc(log10(qsci->lines()) + 2), '0'));
+    qsci->setMarginWidth(numberMargin,
+                         QString(trunc(log10(qsci->lines()) + 2), '0'));
   } else {
     qsci->setMarginWidth(numberMargin, 6);
   }
   qsci->setMarginLineNumbers(numberMargin, enableLineNumbers);
 }
 
-int ScintillaEditor::updateFindIndicators(const QString& findText, bool visibility)
-{
+int ScintillaEditor::updateFindIndicators(const QString &findText,
+                                          bool visibility) {
   int findwordcount{0};
 
-  qsci->SendScintilla(QsciScintilla::SCI_SETINDICATORCURRENT, findIndicatorNumber);
+  qsci->SendScintilla(QsciScintilla::SCI_SETINDICATORCURRENT,
+                      findIndicatorNumber);
   qsci->SendScintilla(qsci->SCI_INDICATORCLEARRANGE, 0, qsci->length());
 
   const auto txt = qsci->text().toUtf8();
@@ -819,8 +937,8 @@ int ScintillaEditor::updateFindIndicators(const QString& findText, bool visibili
   return findwordcount;
 }
 
-bool ScintillaEditor::find(const QString& expr, bool findNext, bool findBackwards)
-{
+bool ScintillaEditor::find(const QString &expr, bool findNext,
+                           bool findBackwards) {
   int startline = -1, startindex = -1;
 
   // If findNext, start from the end of the current selection
@@ -828,38 +946,39 @@ bool ScintillaEditor::find(const QString& expr, bool findNext, bool findBackward
     int lineFrom, indexFrom, lineTo, indexTo;
     qsci->getSelection(&lineFrom, &indexFrom, &lineTo, &indexTo);
 
-    startline = !(findBackwards xor findNext) ? std::min(lineFrom, lineTo) : std::max(lineFrom, lineTo);
-    startindex = !(findBackwards xor findNext) ? std::min(indexFrom, indexTo) : std::max(indexFrom, indexTo);
+    startline = !(findBackwards xor findNext) ? std::min(lineFrom, lineTo)
+                                              : std::max(lineFrom, lineTo);
+    startindex = !(findBackwards xor findNext) ? std::min(indexFrom, indexTo)
+                                               : std::max(indexFrom, indexTo);
   }
 
-  return qsci->findFirst(expr, false, false, false, true,
-                         !findBackwards, startline, startindex);
+  return qsci->findFirst(expr, false, false, false, true, !findBackwards,
+                         startline, startindex);
 }
 
-void ScintillaEditor::replaceSelectedText(const QString& newText)
-{
-  if ((qsci->selectedText() != newText)&&(qsci->hasSelectedText())) qsci->replaceSelectedText(newText);
+void ScintillaEditor::replaceSelectedText(const QString &newText) {
+  if ((qsci->selectedText() != newText) && (qsci->hasSelectedText()))
+    qsci->replaceSelectedText(newText);
 }
 
-void ScintillaEditor::replaceAll(const QString& findText, const QString& replaceText)
-{
+void ScintillaEditor::replaceAll(const QString &findText,
+                                 const QString &replaceText) {
   // We need to issue a Select All first due to a bug in QScintilla:
-  // It doesn't update the find range when just doing findFirst() + findNext() causing the search
-  // to end prematurely if the replaced string is larger than the selected string.
+  // It doesn't update the find range when just doing findFirst() + findNext()
+  // causing the search to end prematurely if the replaced string is larger than
+  // the selected string.
 #if QSCINTILLA_VERSION >= 0x020903
   // QScintilla bug seems to be fixed in 2.9.3
-  if (qsci->findFirst(findText,
-                      false /*re*/, false /*cs*/, false /*wo*/,
+  if (qsci->findFirst(findText, false /*re*/, false /*cs*/, false /*wo*/,
                       false /*wrap*/, true /*forward*/, 0, 0)) {
 #elif QSCINTILLA_VERSION >= 0x020700
   qsci->selectAll();
-  if (qsci->findFirstInSelection(findText,
-                                 false /*re*/, false /*cs*/, false /*wo*/,
-                                 false /*wrap*/, true /*forward*/)) {
+  if (qsci->findFirstInSelection(findText, false /*re*/, false /*cs*/,
+                                 false /*wo*/, false /*wrap*/,
+                                 true /*forward*/)) {
 #else
   // findFirstInSelection() was introduced in QScintilla 2.7
-  if (qsci->findFirst(findText,
-                      false /*re*/, false /*cs*/, false /*wo*/,
+  if (qsci->findFirst(findText, false /*re*/, false /*cs*/, false /*wo*/,
                       false /*wrap*/, true /*forward*/, 0, 0)) {
 #endif // if QSCINTILLA_VERSION >= 0x020903
     qsci->replace(replaceText);
@@ -869,9 +988,7 @@ void ScintillaEditor::replaceAll(const QString& findText, const QString& replace
   }
 }
 
-
-void ScintillaEditor::getRange(int *lineFrom, int *lineTo)
-{
+void ScintillaEditor::getRange(int *lineFrom, int *lineTo) {
   int indexFrom, indexTo;
   if (qsci->hasSelectedText()) {
     qsci->getSelection(lineFrom, &indexFrom, lineTo, &indexTo);
@@ -884,20 +1001,25 @@ void ScintillaEditor::getRange(int *lineFrom, int *lineTo)
   }
 }
 
-void ScintillaEditor::indentSelection()
-{
+void ScintillaEditor::indentSelection() {
   int lineFrom, lineTo;
   qsci->beginUndoAction();
   getRange(&lineFrom, &lineTo);
   for (int line = lineFrom; line <= lineTo; ++line) {
-    if (qsci->SendScintilla(QsciScintilla::SCI_GETLINEENDPOSITION, line) - qsci->SendScintilla(QsciScintilla::SCI_POSITIONFROMLINE, line) == 0) {
+    if (qsci->SendScintilla(QsciScintilla::SCI_GETLINEENDPOSITION, line) -
+            qsci->SendScintilla(QsciScintilla::SCI_POSITIONFROMLINE, line) ==
+        0) {
       continue;
     }
     qsci->indent(line);
   }
   int nextLine = lineTo + 1;
-  while (qsci->SendScintilla(QsciScintilla::SCI_GETLINEVISIBLE, nextLine) == 0) {
-    if (qsci->SendScintilla(QsciScintilla::SCI_GETLINEENDPOSITION, nextLine) - qsci->SendScintilla(QsciScintilla::SCI_POSITIONFROMLINE, nextLine) == 0) {
+  while (qsci->SendScintilla(QsciScintilla::SCI_GETLINEVISIBLE, nextLine) ==
+         0) {
+    if (qsci->SendScintilla(QsciScintilla::SCI_GETLINEENDPOSITION, nextLine) -
+            qsci->SendScintilla(QsciScintilla::SCI_POSITIONFROMLINE,
+                                nextLine) ==
+        0) {
       nextLine++;
       continue;
     }
@@ -907,20 +1029,25 @@ void ScintillaEditor::indentSelection()
   qsci->endUndoAction();
 }
 
-void ScintillaEditor::unindentSelection()
-{
+void ScintillaEditor::unindentSelection() {
   int lineFrom, lineTo;
   qsci->beginUndoAction();
   getRange(&lineFrom, &lineTo);
   for (int line = lineFrom; line <= lineTo; ++line) {
-    if (qsci->SendScintilla(QsciScintilla::SCI_GETLINEENDPOSITION, line) - qsci->SendScintilla(QsciScintilla::SCI_POSITIONFROMLINE, line) == 0) {
+    if (qsci->SendScintilla(QsciScintilla::SCI_GETLINEENDPOSITION, line) -
+            qsci->SendScintilla(QsciScintilla::SCI_POSITIONFROMLINE, line) ==
+        0) {
       continue;
     }
     qsci->unindent(line);
   }
   int nextLine = lineTo + 1;
-  while (qsci->SendScintilla(QsciScintilla::SCI_GETLINEVISIBLE, nextLine) == 0) {
-    if (qsci->SendScintilla(QsciScintilla::SCI_GETLINEENDPOSITION, nextLine) - qsci->SendScintilla(QsciScintilla::SCI_POSITIONFROMLINE, nextLine) == 0) {
+  while (qsci->SendScintilla(QsciScintilla::SCI_GETLINEVISIBLE, nextLine) ==
+         0) {
+    if (qsci->SendScintilla(QsciScintilla::SCI_GETLINEENDPOSITION, nextLine) -
+            qsci->SendScintilla(QsciScintilla::SCI_POSITIONFROMLINE,
+                                nextLine) ==
+        0) {
       nextLine++;
       continue;
     }
@@ -930,8 +1057,7 @@ void ScintillaEditor::unindentSelection()
   qsci->endUndoAction();
 }
 
-void ScintillaEditor::commentSelection()
-{
+void ScintillaEditor::commentSelection() {
   auto hasSelection = qsci->hasSelectedText();
 
   int lineFrom, lineTo;
@@ -941,12 +1067,12 @@ void ScintillaEditor::commentSelection()
   }
 
   if (hasSelection) {
-    qsci->setSelection(lineFrom, 0, lineTo, std::max(0, qsci->lineLength(lineTo) - 1));
+    qsci->setSelection(lineFrom, 0, lineTo,
+                       std::max(0, qsci->lineLength(lineTo) - 1));
   }
 }
 
-void ScintillaEditor::uncommentSelection()
-{
+void ScintillaEditor::uncommentSelection() {
   auto hasSelection = qsci->hasSelectedText();
 
   int lineFrom, lineTo;
@@ -959,41 +1085,45 @@ void ScintillaEditor::uncommentSelection()
     }
   }
   if (hasSelection) {
-    qsci->setSelection(lineFrom, 0, lineTo, std::max(0, qsci->lineLength(lineTo) - 1));
+    qsci->setSelection(lineFrom, 0, lineTo,
+                       std::max(0, qsci->lineLength(lineTo) - 1));
   }
 }
 
-QString ScintillaEditor::selectedText()
-{
-  return qsci->selectedText();
-}
+QString ScintillaEditor::selectedText() { return qsci->selectedText(); }
 
-bool ScintillaEditor::eventFilter(QObject *obj, QEvent *e)
-{
+bool ScintillaEditor::eventFilter(QObject *obj, QEvent *e) {
   if (e->type() == QEvent::KeyPress) {
     auto keyEvent = static_cast<QKeyEvent *>(e);
     if (keyEvent->key() == Qt::Key_Escape) {
       emit escapePressed();
     }
   }
-  if (QGuiApplication::keyboardModifiers().testFlag(Qt::ControlModifier) || QGuiApplication::keyboardModifiers().testFlag(Qt::AltModifier)) {
+  if (QGuiApplication::keyboardModifiers().testFlag(Qt::ControlModifier) ||
+      QGuiApplication::keyboardModifiers().testFlag(Qt::AltModifier)) {
     if (!this->indicatorsActive) {
       this->indicatorsActive = true;
-      qsci->setIndicatorHoverStyle(QsciScintilla::PlainIndicator, hyperlinkIndicatorNumber);
+      qsci->setIndicatorHoverStyle(QsciScintilla::PlainIndicator,
+                                   hyperlinkIndicatorNumber);
     }
   } else {
     if (this->indicatorsActive) {
       this->indicatorsActive = false;
-      qsci->setIndicatorHoverStyle(QsciScintilla::HiddenIndicator, hyperlinkIndicatorNumber);
+      qsci->setIndicatorHoverStyle(QsciScintilla::HiddenIndicator,
+                                   hyperlinkIndicatorNumber);
     }
   }
 
-  bool enableNumberScrollWheel = Settings::Settings::enableNumberScrollWheel.value();
+  bool enableNumberScrollWheel =
+      Settings::Settings::enableNumberScrollWheel.value();
 
   if (obj == qsci->viewport() && enableNumberScrollWheel) {
     if (e->type() == QEvent::Wheel) {
       auto *wheelEvent = static_cast<QWheelEvent *>(e);
-      PRINTDB("%s - modifier: %s", (e->type() == QEvent::Wheel?"Wheel Event":"") % (wheelEvent->modifiers() & Qt::AltModifier?"Alt":"Other Button"));
+      PRINTDB("%s - modifier: %s",
+              (e->type() == QEvent::Wheel ? "Wheel Event" : "") %
+                  (wheelEvent->modifiers() & Qt::AltModifier ? "Alt"
+                                                             : "Other Button"));
       if (handleWheelEventNavigateNumber(wheelEvent)) {
         qsci->SendScintilla(QsciScintilla::SCI_SETCARETWIDTH, 1);
         return true;
@@ -1004,14 +1134,17 @@ bool ScintillaEditor::eventFilter(QObject *obj, QEvent *e)
     if (e->type() == QEvent::KeyPress || e->type() == QEvent::KeyRelease) {
       auto *keyEvent = static_cast<QKeyEvent *>(e);
 
-      PRINTDB("%10s - modifiers: %s %s %s %s %s %s",
-              (e->type() == QEvent::KeyPress ? "KeyPress" : "KeyRelease") %
+      PRINTDB(
+          "%10s - modifiers: %s %s %s %s %s %s",
+          (e->type() == QEvent::KeyPress ? "KeyPress" : "KeyRelease") %
               (keyEvent->modifiers() & Qt::ShiftModifier ? "SHIFT" : "shift") %
               (keyEvent->modifiers() & Qt::ControlModifier ? "CTRL" : "ctrl") %
               (keyEvent->modifiers() & Qt::AltModifier ? "ALT" : "alt") %
               (keyEvent->modifiers() & Qt::MetaModifier ? "META" : "meta") %
-              (keyEvent->modifiers() & Qt::KeypadModifier ? "KEYPAD" : "keypad") %
-              (keyEvent->modifiers() & Qt::GroupSwitchModifier ? "GROUP" : "group"));
+              (keyEvent->modifiers() & Qt::KeypadModifier ? "KEYPAD"
+                                                          : "keypad") %
+              (keyEvent->modifiers() & Qt::GroupSwitchModifier ? "GROUP"
+                                                               : "group"));
 
       if (handleKeyEventNavigateNumber(keyEvent)) {
         return true;
@@ -1024,13 +1157,13 @@ bool ScintillaEditor::eventFilter(QObject *obj, QEvent *e)
       }
     }
     return false;
-  } else return EditorInterface::eventFilter(obj, e);
+  } else
+    return EditorInterface::eventFilter(obj, e);
 
   return false;
 }
 
-bool ScintillaEditor::handleKeyEventBlockMove(QKeyEvent *keyEvent)
-{
+bool ScintillaEditor::handleKeyEventBlockMove(QKeyEvent *keyEvent) {
   unsigned int modifiers = Qt::ControlModifier | Qt::GroupSwitchModifier;
 
   if (keyEvent->type() != QEvent::KeyRelease) {
@@ -1075,16 +1208,17 @@ bool ScintillaEditor::handleKeyEventBlockMove(QKeyEvent *keyEvent)
     textToMove.append('\n');
   }
   text.insert(up ? text.length() : 0, textToMove);
-  qsci->setSelection(std::min(lineToMove, lineFrom), 0, std::max(lineToMove, lineTo) + 1, 0);
+  qsci->setSelection(std::min(lineToMove, lineFrom), 0,
+                     std::max(lineToMove, lineTo) + 1, 0);
   qsci->replaceSelectedText(text);
   qsci->setCursorPosition(line + directionOffset, index);
-  qsci->setSelection(lineFrom + directionOffset, indexFrom, selectionLineTo + directionOffset, indexTo);
+  qsci->setSelection(lineFrom + directionOffset, indexFrom,
+                     selectionLineTo + directionOffset, indexTo);
   qsci->endUndoAction();
   return true;
 }
 
-bool ScintillaEditor::handleKeyEventBlockCopy(QKeyEvent *keyEvent)
-{
+bool ScintillaEditor::handleKeyEventBlockCopy(QKeyEvent *keyEvent) {
   unsigned int modifiers = Qt::ControlModifier | Qt::ShiftModifier;
 
   if (keyEvent->type() != QEvent::KeyRelease) {
@@ -1133,12 +1267,12 @@ bool ScintillaEditor::handleKeyEventBlockCopy(QKeyEvent *keyEvent)
   return true;
 }
 
-bool ScintillaEditor::handleKeyEventNavigateNumber(QKeyEvent *keyEvent)
-{
+bool ScintillaEditor::handleKeyEventNavigateNumber(QKeyEvent *keyEvent) {
   static bool previewAfterUndo = false;
 
 #ifdef Q_OS_MACOS
-  unsigned int navigateOnNumberModifiers = Qt::AltModifier | Qt::ShiftModifier | Qt::KeypadModifier;
+  unsigned int navigateOnNumberModifiers =
+      Qt::AltModifier | Qt::ShiftModifier | Qt::KeypadModifier;
 #else
   unsigned int navigateOnNumberModifiers = Qt::AltModifier;
 #endif
@@ -1164,18 +1298,21 @@ bool ScintillaEditor::handleKeyEventNavigateNumber(QKeyEvent *keyEvent)
   if (previewAfterUndo && keyEvent->type() == QEvent::KeyPress) {
     int k = keyEvent->key() | keyEvent->modifiers();
     auto *cmd = qsci->standardCommands()->boundTo(k);
-    if (cmd && (cmd->command() == QsciCommand::Undo || cmd->command() == QsciCommand::Redo)) QTimer::singleShot(0, this, &ScintillaEditor::previewRequest);
+    if (cmd && (cmd->command() == QsciCommand::Undo ||
+                cmd->command() == QsciCommand::Redo))
+      QTimer::singleShot(0, this, &ScintillaEditor::previewRequest);
     else if (cmd || !keyEvent->text().isEmpty()) {
-      // any insert or command (but not undo/redo) cancels the preview after undo
+      // any insert or command (but not undo/redo) cancels the preview after
+      // undo
       previewAfterUndo = false;
     }
   }
   return false;
 }
 
-bool ScintillaEditor::handleWheelEventNavigateNumber(QWheelEvent *wheelEvent)
-{
-  const auto& modifierNumberScrollWheel = Settings::Settings::modifierNumberScrollWheel.value();
+bool ScintillaEditor::handleWheelEventNavigateNumber(QWheelEvent *wheelEvent) {
+  const auto &modifierNumberScrollWheel =
+      Settings::Settings::modifierNumberScrollWheel.value();
   bool modifier;
   static bool previewAfterUndo = false;
 
@@ -1184,13 +1321,14 @@ bool ScintillaEditor::handleWheelEventNavigateNumber(QWheelEvent *wheelEvent)
   } else if (modifierNumberScrollWheel == "Left Mouse Button") {
     modifier = wheelEvent->buttons() & Qt::LeftButton;
   } else {
-    modifier = (wheelEvent->buttons() & Qt::LeftButton) | (wheelEvent->modifiers() & Qt::AltModifier);
+    modifier = (wheelEvent->buttons() & Qt::LeftButton) |
+               (wheelEvent->modifiers() & Qt::AltModifier);
   }
 
   if (modifier) {
     int delta = wheelEvent->angleDelta().y() != 0
-      ? wheelEvent->angleDelta().y()
-      : wheelEvent->angleDelta().x();
+                    ? wheelEvent->angleDelta().y()
+                    : wheelEvent->angleDelta().x();
 
     if (delta < 0) {
       if (modifyNumber(Qt::Key_Down)) {
@@ -1209,17 +1347,19 @@ bool ScintillaEditor::handleWheelEventNavigateNumber(QWheelEvent *wheelEvent)
   if (previewAfterUndo) {
     int k = wheelEvent->buttons() & Qt::LeftButton;
     auto *cmd = qsci->standardCommands()->boundTo(k);
-    if (cmd && (cmd->command() == QsciCommand::Undo || cmd->command() == QsciCommand::Redo)) QTimer::singleShot(0, this, &ScintillaEditor::previewRequest);
+    if (cmd && (cmd->command() == QsciCommand::Undo ||
+                cmd->command() == QsciCommand::Redo))
+      QTimer::singleShot(0, this, &ScintillaEditor::previewRequest);
     else if (cmd || wheelEvent->angleDelta().y()) {
-      // any insert or command (but not undo/redo) cancels the preview after undo
+      // any insert or command (but not undo/redo) cancels the preview after
+      // undo
       previewAfterUndo = false;
     }
   }
   return false;
 }
 
-void ScintillaEditor::navigateOnNumber(int key)
-{
+void ScintillaEditor::navigateOnNumber(int key) {
   int line, index;
   qsci->getCursorPosition(&line, &index);
   auto text = qsci->text(line);
@@ -1227,16 +1367,19 @@ void ScintillaEditor::navigateOnNumber(int key)
   auto dotOnLeft = left.contains(QRegularExpression("\\.\\d*$"));
   auto dotJustLeft = index > 1 && text[index - 2] == '.';
   auto dotJustRight = text[index] == '.';
-  auto numOnLeft = left.contains(QRegularExpression("\\d\\.?$")) || left.endsWith("-.");
+  auto numOnLeft =
+      left.contains(QRegularExpression("\\d\\.?$")) || left.endsWith("-.");
   auto numOnRight = text.indexOf(QRegularExpression("\\.?\\d"), index) == index;
 
   switch (key) {
   case Qt::Key_Left:
-    if (numOnLeft) qsci->setCursorPosition(line, index - (dotJustLeft?2:1));
+    if (numOnLeft)
+      qsci->setCursorPosition(line, index - (dotJustLeft ? 2 : 1));
     break;
 
   case Qt::Key_Right:
-    if (numOnRight) qsci->setCursorPosition(line, index + (dotJustRight?2:1));
+    if (numOnRight)
+      qsci->setCursorPosition(line, index + (dotJustRight ? 2 : 1));
     else if (numOnLeft) {
       // add trailing zero
       if (!dotOnLeft) {
@@ -1251,8 +1394,7 @@ void ScintillaEditor::navigateOnNumber(int key)
   }
 }
 
-bool ScintillaEditor::modifyNumber(int key)
-{
+bool ScintillaEditor::modifyNumber(int key) {
   int line, index;
   qsci->getCursorPosition(&line, &index);
   auto text = qsci->text(line);
@@ -1262,44 +1404,64 @@ bool ScintillaEditor::modifyNumber(int key)
   qsci->SendScintilla(QsciScintilla::SCI_SETEMPTYSELECTION);
   qsci->setCursorPosition(line, index);
 
-  auto begin = text.left(index).indexOf(QRegularExpression(R"([-+]?\d*\.?\d*$)"));
+  auto begin =
+      text.left(index).indexOf(QRegularExpression(R"([-+]?\d*\.?\d*$)"));
 
-  QRegularExpression rx(QRegularExpression::anchoredPattern(QString("[_a-zA-Z]")));
+  QRegularExpression rx(
+      QRegularExpression::anchoredPattern(QString("[_a-zA-Z]")));
   auto check = text.mid(begin - 1, 1);
-  if (rx.match(check).hasMatch()) return false;
+  if (rx.match(check).hasMatch())
+    return false;
 
   auto end = text.indexOf(QRegularExpression("[^0-9.]"), index);
-  if (end < 0) end = text.length();
+  if (end < 0)
+    end = text.length();
   auto nr = text.mid(begin, end - begin);
-  if (!(nr.contains(QRegularExpression(R"(^[-+]?\d*\.?\d+$)")) && nr.contains(QRegularExpression("\\d"))) ) return false;
-  auto sign = nr[0] == '+'||nr[0] == '-';
-  if (nr.endsWith('.')) nr = nr.left(nr.length() - 1);
+  if (!(nr.contains(QRegularExpression(R"(^[-+]?\d*\.?\d+$)")) &&
+        nr.contains(QRegularExpression("\\d"))))
+    return false;
+  auto sign = nr[0] == '+' || nr[0] == '-';
+  if (nr.endsWith('.'))
+    nr = nr.left(nr.length() - 1);
   auto curpos = index - begin;
-  if (curpos == 0 || (curpos == 1 && (nr[0] == '+' || nr[0] == '-'))) return false;
+  if (curpos == 0 || (curpos == 1 && (nr[0] == '+' || nr[0] == '-')))
+    return false;
   auto dotpos = nr.indexOf('.');
-  auto decimals = dotpos < 0?0:nr.length() - dotpos - 1;
-  auto number = (dotpos < 0)?nr.toLongLong():(nr.left(dotpos) + nr.mid(dotpos + 1)).toLongLong();
+  auto decimals = dotpos < 0 ? 0 : nr.length() - dotpos - 1;
+  auto number = (dotpos < 0)
+                    ? nr.toLongLong()
+                    : (nr.left(dotpos) + nr.mid(dotpos + 1)).toLongLong();
   auto tail = nr.length() - curpos;
-  auto exponent = tail - ((dotpos >= curpos)?1:0);
-  long long int step = GlobalPreferences::inst()->getValue("editor/stepSize").toInt();
-  for (int i = exponent; i > 0; i--) step *= 10;
+  auto exponent = tail - ((dotpos >= curpos) ? 1 : 0);
+  long long int step =
+      GlobalPreferences::inst()->getValue("editor/stepSize").toInt();
+  for (int i = exponent; i > 0; i--)
+    step *= 10;
 
   switch (key) {
-  case Qt::Key_Up:   number += step; break;
-  case Qt::Key_Down: number -= step; break;
+  case Qt::Key_Up:
+    number += step;
+    break;
+  case Qt::Key_Down:
+    number -= step;
+    break;
   }
   auto negative = number < 0;
-  if (negative) number = -number;
+  if (negative)
+    number = -number;
   auto newnr = QString::number(number);
   if (decimals) {
-    if (newnr.length() <= decimals) newnr.prepend(QString(decimals - newnr.length() + 1, '0'));
+    if (newnr.length() <= decimals)
+      newnr.prepend(QString(decimals - newnr.length() + 1, '0'));
     newnr = newnr.left(newnr.length() - decimals) + "." + newnr.right(decimals);
   }
   if (tail > newnr.length()) {
     newnr.prepend(QString(tail - newnr.length(), '0'));
   }
-  if (negative) newnr.prepend('-');
-  else if (sign) newnr.prepend('+');
+  if (negative)
+    newnr.prepend('-');
+  else if (sign)
+    newnr.prepend('+');
   qsci->beginUndoAction();
   qsci->setSelection(line, begin, line, end);
   qsci->replaceSelectedText(newnr);
@@ -1314,8 +1476,7 @@ bool ScintillaEditor::modifyNumber(int key)
   return true;
 }
 
-void ScintillaEditor::onUserListSelected(const int, const QString& text)
-{
+void ScintillaEditor::onUserListSelected(const int, const QString &text) {
   if (!templateMap.contains(text)) {
     return;
   }
@@ -1326,17 +1487,19 @@ void ScintillaEditor::onUserListSelected(const int, const QString& text)
     tabReplace = QString(spCount, ' ');
   }
 
-  ScadTemplate& t = templateMap[text];
+  ScadTemplate &t = templateMap[text];
   QString content = t.get_text();
   int cursor_offset = t.get_cursor_offset();
 
   if (cursor_offset < 0) {
-    if (tabReplace.size() != 0) content.replace("\t", tabReplace);
+    if (tabReplace.size() != 0)
+      content.replace("\t", tabReplace);
 
     cursor_offset = content.indexOf(ScintillaEditor::cursorPlaceHolder);
     content.remove(cursorPlaceHolder);
 
-    if (cursor_offset == -1) cursor_offset = content.size();
+    if (cursor_offset == -1)
+      cursor_offset = content.size();
   } else {
     if (tabReplace.size() != 0) {
       int tbCount = content.left(cursor_offset).count("\t");
@@ -1359,15 +1522,15 @@ void ScintillaEditor::onUserListSelected(const int, const QString& text)
 
   int lines = t.get_text().count("\n");
   QString indent_char = " ";
-  if (Settings::Settings::indentStyle.value() == "Tabs") indent_char = "\t";
+  if (Settings::Settings::indentStyle.value() == "Tabs")
+    indent_char = "\t";
 
   for (int a = 0; a < lines; ++a) {
     qsci->insertAt(indent_char.repeated(indent_width), indent_line + a + 1, 0);
   }
 }
 
-void ScintillaEditor::onAutocompleteChanged(bool state)
-{
+void ScintillaEditor::onAutocompleteChanged(bool state) {
   if (state) {
     qsci->setAutoCompletionSource(QsciScintilla::AcsAPIs);
     qsci->setAutoCompletionFillupsEnabled(true);
@@ -1380,104 +1543,123 @@ void ScintillaEditor::onAutocompleteChanged(bool state)
   }
 }
 
-void ScintillaEditor::onCharacterThresholdChanged(int val)
-{
+void ScintillaEditor::onCharacterThresholdChanged(int val) {
   qsci->setAutoCompletionThreshold(val <= 0 ? 1 : val);
 }
 
-void ScintillaEditor::resetHighlighting(){
-  qsci->recolor(); //lex and restyle the whole text
+void ScintillaEditor::resetHighlighting() {
+  qsci->recolor(); // lex and restyle the whole text
 
-  //remove all indicators
-  qsci->SendScintilla(QsciScintilla::SCI_SETINDICATORCURRENT, hyperlinkIndicatorNumber);
-  qsci->SendScintilla(QsciScintilla::SCI_INDICATORCLEARRANGE, 0, qsci->length());
+  // remove all indicators
+  qsci->SendScintilla(QsciScintilla::SCI_SETINDICATORCURRENT,
+                      hyperlinkIndicatorNumber);
+  qsci->SendScintilla(QsciScintilla::SCI_INDICATORCLEARRANGE, 0,
+                      qsci->length());
 }
 
-void ScintillaEditor::setIndicator(const std::vector<IndicatorData>& indicatorData)
-{
+void ScintillaEditor::setIndicator(
+    const std::vector<IndicatorData> &indicatorData) {
   this->indicatorData = indicatorData;
 
   int idx = 0;
-  for (const auto& data : indicatorData) {
-    int startPos = qsci->positionFromLineIndex(data.first_line - 1, data.first_col - 1);
-    int stopPos = qsci->positionFromLineIndex(data.last_line - 1, data.last_col - 1);
+  for (const auto &data : indicatorData) {
+    int startPos =
+        qsci->positionFromLineIndex(data.first_line - 1, data.first_col - 1);
+    int stopPos =
+        qsci->positionFromLineIndex(data.last_line - 1, data.last_col - 1);
 
     int nrOfChars = stopPos - startPos;
-    qsci->SendScintilla(QsciScintilla::SCI_SETINDICATORVALUE, idx + hyperlinkIndicatorOffset);
+    qsci->SendScintilla(QsciScintilla::SCI_SETINDICATORVALUE,
+                        idx + hyperlinkIndicatorOffset);
 
-    qsci->SendScintilla(QsciScintilla::SCI_INDICATORFILLRANGE, startPos, nrOfChars);
+    qsci->SendScintilla(QsciScintilla::SCI_INDICATORFILLRANGE, startPos,
+                        nrOfChars);
 
     idx++;
   }
 }
 
-void ScintillaEditor::onIndicatorClicked(int line, int col, Qt::KeyboardModifiers /*state*/)
-{
-  qsci->SendScintilla(QsciScintilla::SCI_SETINDICATORCURRENT, hyperlinkIndicatorNumber);
+void ScintillaEditor::onIndicatorClicked(int line, int col,
+                                         Qt::KeyboardModifiers /*state*/) {
+  qsci->SendScintilla(QsciScintilla::SCI_SETINDICATORCURRENT,
+                      hyperlinkIndicatorNumber);
 
   int pos = qsci->positionFromLineIndex(line, col);
-  int val = qsci->SendScintilla(QsciScintilla::SCI_INDICATORVALUEAT, ScintillaEditor::hyperlinkIndicatorNumber, pos);
+  int val = qsci->SendScintilla(QsciScintilla::SCI_INDICATORVALUEAT,
+                                ScintillaEditor::hyperlinkIndicatorNumber, pos);
 
   // checking if indicator clicked is hyperlinkIndicator
-  if (val >= hyperlinkIndicatorOffset && val <= hyperlinkIndicatorOffset + static_cast<int>(indicatorData.size())) {
+  if (val >= hyperlinkIndicatorOffset &&
+      val <=
+          hyperlinkIndicatorOffset + static_cast<int>(indicatorData.size())) {
     if (indicatorsActive) {
       emit hyperlinkIndicatorClicked(val - hyperlinkIndicatorOffset);
     }
   }
 }
 
-void ScintillaEditor::onIndicatorReleased(int line, int col, Qt::KeyboardModifiers /*state*/)
-{
-  qsci->SendScintilla(QsciScintilla::SCI_SETINDICATORCURRENT, hyperlinkIndicatorNumber);
+void ScintillaEditor::onIndicatorReleased(int line, int col,
+                                          Qt::KeyboardModifiers /*state*/) {
+  qsci->SendScintilla(QsciScintilla::SCI_SETINDICATORCURRENT,
+                      hyperlinkIndicatorNumber);
 
   int pos = qsci->positionFromLineIndex(line, col);
-  int val = qsci->SendScintilla(QsciScintilla::SCI_INDICATORVALUEAT, ScintillaEditor::hyperlinkIndicatorNumber, pos);
+  int val = qsci->SendScintilla(QsciScintilla::SCI_INDICATORVALUEAT,
+                                ScintillaEditor::hyperlinkIndicatorNumber, pos);
 
   // checking if indicator clicked is hyperlinkIndicator
-  if (val >= hyperlinkIndicatorOffset && val <= hyperlinkIndicatorOffset + static_cast<int>(indicatorData.size())) {
+  if (val >= hyperlinkIndicatorOffset &&
+      val <=
+          hyperlinkIndicatorOffset + static_cast<int>(indicatorData.size())) {
     if (!indicatorsActive) {
       QTimer::singleShot(0, this, [this] {
-        QToolTip::showText(QCursor::pos(), "Use <b>CTRL + Click</b> to open the file", this, rect(), toolTipDuration());
+        QToolTip::showText(QCursor::pos(),
+                           "Use <b>CTRL + Click</b> to open the file", this,
+                           rect(), toolTipDuration());
       });
     }
   }
 }
 
-void ScintillaEditor::setCursorPosition(int line, int col)
-{
+void ScintillaEditor::setCursorPosition(int line, int col) {
   qsci->ensureLineVisible(std::max(line - setCursorPositionVisibleLines, 0));
-  qsci->ensureLineVisible(std::min(line + setCursorPositionVisibleLines, qsci->lines() - 1));
+  qsci->ensureLineVisible(
+      std::min(line + setCursorPositionVisibleLines, qsci->lines() - 1));
 
   qsci->setCursorPosition(line, col);
 }
 
-void ScintillaEditor::updateSymbolMarginVisibility()
-{
-  if (qsci->markerFindNext(0, 1 << bmMarkerNumber | 1 << errMarkerNumber | 1 << selectionMarkerLevelNumber |
-                           1 << (selectionMarkerLevelNumber + 1) | 1 << (selectionMarkerLevelNumber + 2) |
-                           1 << (selectionMarkerLevelNumber + 3) | 1 << (selectionMarkerLevelNumber + 4) |
-                           1 << (selectionMarkerLevelNumber + 5)) < 0) {
+void ScintillaEditor::updateSymbolMarginVisibility() {
+  if (qsci->markerFindNext(0, 1 << bmMarkerNumber | 1 << errMarkerNumber |
+                                  1 << selectionMarkerLevelNumber |
+                                  1 << (selectionMarkerLevelNumber + 1) |
+                                  1 << (selectionMarkerLevelNumber + 2) |
+                                  1 << (selectionMarkerLevelNumber + 3) |
+                                  1 << (selectionMarkerLevelNumber + 4) |
+                                  1 << (selectionMarkerLevelNumber + 5)) < 0) {
     qsci->setMarginWidth(symbolMargin, 0);
   } else {
     qsci->setMarginWidth(symbolMargin, "0");
   }
 }
 
-void ScintillaEditor::toggleBookmark()
-{
+void ScintillaEditor::toggleBookmark() {
   int line, index;
   qsci->getCursorPosition(&line, &index);
 
   unsigned int state = qsci->markersAtLine(line);
 
-  if ((state & (1 << bmMarkerNumber)) == 0) qsci->markerAdd(line, bmMarkerNumber);
-  else qsci->markerDelete(line, bmMarkerNumber);
+  if ((state & (1 << bmMarkerNumber)) == 0)
+    qsci->markerAdd(line, bmMarkerNumber);
+  else
+    qsci->markerDelete(line, bmMarkerNumber);
 
   updateSymbolMarginVisibility();
 }
 
-void ScintillaEditor::findMarker(int findStartOffset, int wrapStart, const std::function<int(int)>& findMarkerFunc)
-{
+void ScintillaEditor::findMarker(
+    int findStartOffset, int wrapStart,
+    const std::function<int(int)> &findMarkerFunc) {
   int line, index;
   qsci->getCursorPosition(&line, &index);
   line = findMarkerFunc(line + findStartOffset);
@@ -1492,38 +1674,36 @@ void ScintillaEditor::findMarker(int findStartOffset, int wrapStart, const std::
   }
 }
 
-void ScintillaEditor::nextBookmark()
-{
-  findMarker(1, 0, [this](int line){
+void ScintillaEditor::nextBookmark() {
+  findMarker(1, 0, [this](int line) {
     return qsci->markerFindNext(line, 1 << bmMarkerNumber);
   });
 }
 
-void ScintillaEditor::prevBookmark()
-{
-  findMarker(-1, qsci->lines() - 1, [this](int line){
+void ScintillaEditor::prevBookmark() {
+  findMarker(-1, qsci->lines() - 1, [this](int line) {
     return qsci->markerFindPrevious(line, 1 << bmMarkerNumber);
   });
 }
 
-void ScintillaEditor::jumpToNextError()
-{
-  findMarker(1, 0, [this](int line){
+void ScintillaEditor::jumpToNextError() {
+  findMarker(1, 0, [this](int line) {
     return qsci->markerFindNext(line, 1 << errMarkerNumber);
   });
 }
 
-void ScintillaEditor::setFocus()
-{
+void ScintillaEditor::setFocus() {
   qsci->setFocus();
   qsci->SendScintilla(QsciScintilla::SCI_SETFOCUS, true);
 }
 
 /**
- * @brief Highlights a part of the text according to the limits described in the parameters
+ * @brief Highlights a part of the text according to the limits described in the
+ * parameters
  */
-void ScintillaEditor::setSelectionIndicatorStatus(EditorSelectionIndicatorStatus status, int level, int lineFrom, int colFrom, int lineTo, int colTo)
-{
+void ScintillaEditor::setSelectionIndicatorStatus(
+    EditorSelectionIndicatorStatus status, int level, int lineFrom, int colFrom,
+    int lineTo, int colTo) {
   // replace all the indicators at given lines/column with the new one
   clearSelectionIndicators(lineFrom, colFrom, lineTo, colTo);
 
@@ -1532,19 +1712,22 @@ void ScintillaEditor::setSelectionIndicatorStatus(EditorSelectionIndicatorStatus
   int mark_level = 0;
   if (status == EditorSelectionIndicatorStatus::SELECTED) {
     indicator_base_index = selectionIndicatorIsActiveNumber;
-    mark_level = (level > 5)?5:level;
-    indicator_level = (level > 1)?1:level;
+    mark_level = (level > 5) ? 5 : level;
+    indicator_level = (level > 1) ? 1 : level;
   } else {
     indicator_base_index = selectionIndicatorIsImpactedNumber;
-    indicator_level = (level > 2)?2:level;
+    indicator_level = (level > 2) ? 2 : level;
   }
 
   clearSelectionIndicators(lineFrom, colFrom, lineTo, colTo);
-  qsci->fillIndicatorRange(lineFrom, colFrom, lineTo, colTo,  indicator_base_index + indicator_level);
+  qsci->fillIndicatorRange(lineFrom, colFrom, lineTo, colTo,
+                           indicator_base_index + indicator_level);
 
   if (status == EditorSelectionIndicatorStatus::SELECTED) {
-    qsci->ensureLineVisible(std::max(lineFrom - setCursorPositionVisibleLines, 0));
-    qsci->ensureLineVisible(std::min(lineFrom + setCursorPositionVisibleLines, qsci->lines() - 1));
+    qsci->ensureLineVisible(
+        std::max(lineFrom - setCursorPositionVisibleLines, 0));
+    qsci->ensureLineVisible(
+        std::min(lineFrom + setCursorPositionVisibleLines, qsci->lines() - 1));
 
     // replace the marker at provide line with a new one.
     qsci->markerDelete(lineFrom);
@@ -1557,8 +1740,7 @@ void ScintillaEditor::setSelectionIndicatorStatus(EditorSelectionIndicatorStatus
 /**
  * @brief Unhighlight all the selection indicators.
  */
-void ScintillaEditor::clearAllSelectionIndicators()
-{
+void ScintillaEditor::clearAllSelectionIndicators() {
   // remove all the indicator in the document.
   int line, column;
   qsci->lineIndexFromPosition(qsci->length(), &line, &column);
@@ -1576,12 +1758,17 @@ void ScintillaEditor::clearAllSelectionIndicators()
 /**
  * @brief Unhighlight all the texts for DM
  */
-void ScintillaEditor::clearSelectionIndicators(int lineFrom, int colFrom, int lineTo, int colTo)
-{
-  qsci->clearIndicatorRange(lineFrom, colFrom, lineTo, colTo, selectionIndicatorIsImpactedNumber);
-  qsci->clearIndicatorRange(lineFrom, colFrom, lineTo, colTo, selectionIndicatorIsImpactedNumber + 1);
-  qsci->clearIndicatorRange(lineFrom, colFrom, lineTo, colTo, selectionIndicatorIsImpactedNumber + 2);
-
-  qsci->clearIndicatorRange(lineFrom, colFrom, lineTo, colTo, selectionIndicatorIsActiveNumber);
-  qsci->clearIndicatorRange(lineFrom, colFrom, lineTo, colTo, selectionIndicatorIsActiveNumber + 1);
+void ScintillaEditor::clearSelectionIndicators(int lineFrom, int colFrom,
+                                               int lineTo, int colTo) {
+  qsci->clearIndicatorRange(lineFrom, colFrom, lineTo, colTo,
+                            selectionIndicatorIsImpactedNumber);
+  qsci->clearIndicatorRange(lineFrom, colFrom, lineTo, colTo,
+                            selectionIndicatorIsImpactedNumber + 1);
+  qsci->clearIndicatorRange(lineFrom, colFrom, lineTo, colTo,
+                            selectionIndicatorIsImpactedNumber + 2);
+
+  qsci->clearIndicatorRange(lineFrom, colFrom, lineTo, colTo,
+                            selectionIndicatorIsActiveNumber);
+  qsci->clearIndicatorRange(lineFrom, colFrom, lineTo, colTo,
+                            selectionIndicatorIsActiveNumber + 1);
 }
diff --git a/src/gui/ScintillaEditor.h b/src/gui/ScintillaEditor.h
index 1dde96618..6d59abff8 100644
--- a/src/gui/ScintillaEditor.h
+++ b/src/gui/ScintillaEditor.h
@@ -2,21 +2,20 @@
 
 #include <QStringList>
 #include <filesystem>
-#include <map>
 #include <functional>
+#include <map>
 #include <memory>
 #include <string>
 #include <vector>
 
-#include <boost/property_tree/ptree.hpp>
 #include <boost/property_tree/json_parser.hpp>
+#include <boost/property_tree/ptree.hpp>
 
 #include <QMap>
 #include <QObject>
 #include <QString>
-#include <QWidget>
-#include <QVBoxLayout>
 #include <QVBoxLayout>
+#include <QWidget>
 #include <Qsci/qsciscintilla.h>
 
 #include "gui/Editor.h"
@@ -26,11 +25,9 @@
 class ScadLexer;
 class ScadLexer2;
 
-#define ENABLE_LEXERTL  1
-
+#define ENABLE_LEXERTL 1
 
-class EditorColorScheme
-{
+class EditorColorScheme {
 private:
   const fs::path path;
 
@@ -39,20 +36,20 @@ private:
   int _index;
 
 public:
-  EditorColorScheme(const fs::path& path);
+  EditorColorScheme(const fs::path &path);
   virtual ~EditorColorScheme() = default;
 
-  const QString& name() const;
+  const QString &name() const;
   int index() const;
   bool valid() const;
-  const boost::property_tree::ptree& propertyTree() const;
+  const boost::property_tree::ptree &propertyTree() const;
 };
 
-class ScintillaEditor : public EditorInterface
-{
+class ScintillaEditor : public EditorInterface {
   Q_OBJECT;
 
-  using colorscheme_set_t = std::multimap<int, std::shared_ptr<EditorColorScheme>, std::less<>>;
+  using colorscheme_set_t =
+      std::multimap<int, std::shared_ptr<EditorColorScheme>, std::less<>>;
 
 public:
   ScintillaEditor(QWidget *parent);
@@ -62,22 +59,27 @@ public:
   void initLexer();
 
   QString selectedText() override;
-  int updateFindIndicators(const QString& findText, bool visibility = true) override;
-  bool find(const QString&, bool findNext = false, bool findBackwards = false) override;
-  void replaceSelectedText(const QString&) override;
-  void replaceAll(const QString& findText, const QString& replaceText) override;
+  int updateFindIndicators(const QString &findText,
+                           bool visibility = true) override;
+  bool find(const QString &, bool findNext = false,
+            bool findBackwards = false) override;
+  void replaceSelectedText(const QString &) override;
+  void replaceAll(const QString &findText, const QString &replaceText) override;
   QStringList colorSchemes() override;
   bool canUndo() override;
   void addTemplate() override;
   void resetHighlighting() override;
-  void setIndicator(const std::vector<IndicatorData>& indicatorData) override;
+  void setIndicator(const std::vector<IndicatorData> &indicatorData) override;
   QMenu *createStandardContextMenu() override;
-  QPoint mapToGlobal(const QPoint&) override;
+  QPoint mapToGlobal(const QPoint &) override;
 
   void setCursorPosition(int line, int col) override;
-  void setSelectionIndicatorStatus(EditorSelectionIndicatorStatus satuts, int level, int lineFrom, int colFrom, int lineTo, int colTo) override;
+  void setSelectionIndicatorStatus(EditorSelectionIndicatorStatus satuts,
+                                   int level, int lineFrom, int colFrom,
+                                   int lineTo, int colTo) override;
   void clearAllSelectionIndicators() override;
-  void clearSelectionIndicators(int lineFrom, int colFrom, int lineTo, int colTo);
+  void clearSelectionIndicators(int lineFrom, int colFrom, int lineTo,
+                                int colTo);
 
   void setFocus() override;
   void setupAutoComplete(const bool forceOff = false);
@@ -85,13 +87,15 @@ public:
 private:
   void getRange(int *lineFrom, int *lineTo);
   void setColormap(const EditorColorScheme *colorScheme);
-  int readInt(const boost::property_tree::ptree& pt, const std::string& name,
+  int readInt(const boost::property_tree::ptree &pt, const std::string &name,
               const int defaultValue);
-  std::string readString(const boost::property_tree::ptree& pt, const std::string& name,
-                         const std::string& defaultValue);
-  QColor readColor(const boost::property_tree::ptree& pt, const std::string& name,
-                   const QColor& defaultColor);
-  void enumerateColorSchemesInPath(colorscheme_set_t& result_set, const fs::path& path);
+  std::string readString(const boost::property_tree::ptree &pt,
+                         const std::string &name,
+                         const std::string &defaultValue);
+  QColor readColor(const boost::property_tree::ptree &pt,
+                   const std::string &name, const QColor &defaultColor);
+  void enumerateColorSchemesInPath(colorscheme_set_t &result_set,
+                                   const fs::path &path);
   colorscheme_set_t enumerateColorSchemes();
 
   bool eventFilter(QObject *obj, QEvent *event) override;
@@ -108,37 +112,37 @@ private:
 #else
   void setLexer(ScadLexer *lexer);
 #endif
-  void replaceSelectedText(QString&);
-  void addTemplate(const fs::path& path);
+  void replaceSelectedText(QString &);
+  void addTemplate(const fs::path &path);
   void updateSymbolMarginVisibility();
-  void findMarker(int, int, const std::function<int(int)>&);
+  void findMarker(int, int, const std::function<int(int)> &);
 
 signals:
   void previewRequest();
   void hyperlinkIndicatorClicked(int val);
-  void uriDropped(const QUrl&);
+  void uriDropped(const QUrl &);
 
 public slots:
   void zoomIn() override;
   void zoomOut() override;
-  void setPlainText(const QString&) override;
+  void setPlainText(const QString &) override;
   void setContentModified(bool) override;
   bool isContentModified() override;
   void highlightError(int) override;
   void unhighlightLastError() override;
-  void setHighlightScheme(const QString&) override;
+  void setHighlightScheme(const QString &) override;
   void indentSelection() override;
   void unindentSelection() override;
   void commentSelection() override;
   void uncommentSelection() override;
-  void insert(const QString&) override;
-  void setText(const QString&) override;
+  void insert(const QString &) override;
+  void setText(const QString &) override;
   void undo() override;
   void redo() override;
   void cut() override;
   void copy() override;
   void paste() override;
-  void initFont(const QString&, uint) override;
+  void initFont(const QString &, uint) override;
   void displayTemplates() override;
   void foldUnfold() override;
   void toggleBookmark() override;
@@ -151,7 +155,7 @@ public slots:
 
 private slots:
   void onTextChanged();
-  void onUserListSelected(const int id, const QString& text);
+  void onUserListSelected(const int id, const QString &text);
   void fireModificationChanged();
   void onIndicatorClicked(int line, int col, Qt::KeyboardModifiers state);
   void onIndicatorReleased(int line, int col, Qt::KeyboardModifiers state);
@@ -166,9 +170,12 @@ private:
   static const int hyperlinkIndicatorOffset = 100;
   static const int errMarkerNumber = 2;
   static const int bmMarkerNumber = 3;
-  static const int selectionMarkerLevelNumber = 20; //20 - 25, there is at max 5 level of depth
-  static const int selectionIndicatorIsActiveNumber = 11; //Represents the active selected area text 11 - 12
-  static const int selectionIndicatorIsImpactedNumber = 14; //Represents the impacted selected area text 14-15-16
+  static const int selectionMarkerLevelNumber =
+      20; // 20 - 25, there is at max 5 level of depth
+  static const int selectionIndicatorIsActiveNumber =
+      11; // Represents the active selected area text 11 - 12
+  static const int selectionIndicatorIsImpactedNumber =
+      14; // Represents the impacted selected area text 14-15-16
 
   bool indicatorsActive = false;
 
diff --git a/src/gui/SettingsWriter.cc b/src/gui/SettingsWriter.cc
index 4b7f3e9bd..2ce602f35 100644
--- a/src/gui/SettingsWriter.cc
+++ b/src/gui/SettingsWriter.cc
@@ -30,7 +30,7 @@
 #include <QString>
 #include <string>
 
-void SettingsWriter::handle(Settings::SettingsEntryBase& entry) const {
+void SettingsWriter::handle(Settings::SettingsEntryBase &entry) const {
   QSettingsCached settings;
   std::string key = entry.category() + "/" + entry.name();
   if (entry.isDefault()) {
@@ -38,7 +38,8 @@ void SettingsWriter::handle(Settings::SettingsEntryBase& entry) const {
     PRINTDB("SettingsWriter D: %s", key.c_str());
   } else {
     const auto encoded = entry.encode();
-    settings.setValue(QString::fromStdString(key), QString::fromStdString(encoded));
+    settings.setValue(QString::fromStdString(key),
+                      QString::fromStdString(encoded));
     PRINTDB("SettingsWriter W: %s = '%s'", key.c_str() % encoded.c_str());
   }
 }
diff --git a/src/gui/SettingsWriter.h b/src/gui/SettingsWriter.h
index 25e7e3d99..a24ac0b8b 100644
--- a/src/gui/SettingsWriter.h
+++ b/src/gui/SettingsWriter.h
@@ -27,8 +27,7 @@
 
 #include "core/Settings.h"
 
-class SettingsWriter : public Settings::SettingsVisitor
-{
+class SettingsWriter : public Settings::SettingsVisitor {
 public:
-  void handle(Settings::SettingsEntryBase& entry) const override;
+  void handle(Settings::SettingsEntryBase &entry) const override;
 };
diff --git a/src/gui/SparkleAutoUpdater.h b/src/gui/SparkleAutoUpdater.h
index 297621bdb..c44bc6994 100644
--- a/src/gui/SparkleAutoUpdater.h
+++ b/src/gui/SparkleAutoUpdater.h
@@ -8,9 +8,9 @@
 
 #include "gui/AutoUpdater.h"
 
-class SparkleAutoUpdater : public AutoUpdater
-{
+class SparkleAutoUpdater : public AutoUpdater {
   Q_OBJECT;
+
 public:
   SparkleAutoUpdater();
   ~SparkleAutoUpdater();
diff --git a/src/gui/TabManager.cc b/src/gui/TabManager.cc
index d262057ed..cac843ab1 100644
--- a/src/gui/TabManager.cc
+++ b/src/gui/TabManager.cc
@@ -1,35 +1,34 @@
 #include "gui/TabManager.h"
 
 #include <QApplication>
-#include <QPoint>
-#include <QTabBar>
-#include <QWidget>
-#include <cassert>
-#include <functional>
-#include <exception>
-#include <QFileInfo>
-#include <QFile>
+#include <QClipboard>
+#include <QDesktopServices>
 #include <QDir>
+#include <QFile>
+#include <QFileDialog>
+#include <QFileInfo>
+#include <QMessageBox>
+#include <QPoint>
 #include <QSaveFile>
 #include <QShortcut>
+#include <QTabBar>
 #include <QTextStream>
-#include <QMessageBox>
-#include <QFileDialog>
-#include <QClipboard>
-#include <QDesktopServices>
+#include <QWidget>
 #include <Qsci/qscicommand.h>
 #include <Qsci/qscicommandset.h>
+#include <cassert>
+#include <exception>
+#include <functional>
 
 #include "gui/Editor.h"
 #include "gui/ImportUtils.h"
-#include "gui/ScintillaEditor.h"
-#include "gui/Preferences.h"
 #include "gui/MainWindow.h"
+#include "gui/Preferences.h"
+#include "gui/ScintillaEditor.h"
 
 #include <cstddef>
 
-TabManager::TabManager(MainWindow *o, const QString& filename)
-{
+TabManager::TabManager(MainWindow *o, const QString &filename) {
   par = o;
 
   tabWidget = new QTabWidget();
@@ -37,12 +36,17 @@ TabManager::TabManager(MainWindow *o, const QString& filename)
   tabWidget->setMovable(true);
   tabWidget->setContextMenuPolicy(Qt::CustomContextMenu);
 
-  connect(tabWidget, &QTabWidget::tabCloseRequested, this, &TabManager::closeTabRequested);
-  connect(tabWidget, &QTabWidget::customContextMenuRequested, this, &TabManager::showTabHeaderContextMenu);
+  connect(tabWidget, &QTabWidget::tabCloseRequested, this,
+          &TabManager::closeTabRequested);
+  connect(tabWidget, &QTabWidget::customContextMenuRequested, this,
+          &TabManager::showTabHeaderContextMenu);
 
-  connect(tabWidget, &QTabWidget::currentChanged, this, &TabManager::stopAnimation);
-  connect(tabWidget, &QTabWidget::currentChanged, this, &TabManager::updateFindState);
-  connect(tabWidget, &QTabWidget::currentChanged, this, &TabManager::tabSwitched);
+  connect(tabWidget, &QTabWidget::currentChanged, this,
+          &TabManager::stopAnimation);
+  connect(tabWidget, &QTabWidget::currentChanged, this,
+          &TabManager::updateFindState);
+  connect(tabWidget, &QTabWidget::currentChanged, this,
+          &TabManager::tabSwitched);
 
   createTab(filename);
 
@@ -50,28 +54,27 @@ TabManager::TabManager(MainWindow *o, const QString& filename)
   setTabsCloseButtonVisibility(0, false);
 }
 
-QTabBar::ButtonPosition TabManager::getClosingButtonPosition()
-{
+QTabBar::ButtonPosition TabManager::getClosingButtonPosition() {
   auto bar = tabWidget->tabBar();
-  return (QTabBar::ButtonPosition)bar->style()->styleHint(QStyle::SH_TabBar_CloseButtonPosition, nullptr, bar);
+  return (QTabBar::ButtonPosition)bar->style()->styleHint(
+      QStyle::SH_TabBar_CloseButtonPosition, nullptr, bar);
 }
 
-void TabManager::setTabsCloseButtonVisibility(int indice, bool isVisible)
-{
+void TabManager::setTabsCloseButtonVisibility(int indice, bool isVisible) {
   // Depending on the system the closing button can be on the right or left side
   // of the tab header.
-  auto button = tabWidget->tabBar()->tabButton(indice, getClosingButtonPosition());
-  if (button) button->setVisible(isVisible);
+  auto button =
+      tabWidget->tabBar()->tabButton(indice, getClosingButtonPosition());
+  if (button)
+    button->setVisible(isVisible);
 }
 
-QWidget *TabManager::getTabContent()
-{
+QWidget *TabManager::getTabContent() {
   assert(tabWidget != nullptr);
   return tabWidget;
 }
 
-void TabManager::tabSwitched(int x)
-{
+void TabManager::tabSwitched(int x) {
   assert(tabWidget != nullptr);
 
   editor = (EditorInterface *)tabWidget->widget(x);
@@ -86,10 +89,10 @@ void TabManager::tabSwitched(int x)
   emit currentEditorChanged(editor);
 }
 
-void TabManager::closeTabRequested(int x)
-{
+void TabManager::closeTabRequested(int x) {
   assert(tabWidget != nullptr);
-  if (!maybeSave(x)) return;
+  if (!maybeSave(x))
+    return;
 
   auto *closingEditor = qobject_cast<EditorInterface *>(tabWidget->widget(x));
   assert(closingEditor != nullptr);
@@ -104,60 +107,62 @@ void TabManager::closeTabRequested(int x)
   delete closingEditor;
 }
 
-void TabManager::closeCurrentTab()
-{
+void TabManager::closeCurrentTab() {
   assert(tabWidget != nullptr);
 
   /* Close tab or close the current window if only one tab is open. */
-  if (tabWidget->count() > 1) this->closeTabRequested(tabWidget->currentIndex());
-  else par->close();
+  if (tabWidget->count() > 1)
+    this->closeTabRequested(tabWidget->currentIndex());
+  else
+    par->close();
 }
 
-void TabManager::nextTab()
-{
+void TabManager::nextTab() {
   assert(tabWidget != nullptr);
-  tabWidget->setCurrentIndex((tabWidget->currentIndex() + 1) % tabWidget->count());
+  tabWidget->setCurrentIndex((tabWidget->currentIndex() + 1) %
+                             tabWidget->count());
 }
 
-void TabManager::prevTab()
-{
+void TabManager::prevTab() {
   assert(tabWidget != nullptr);
-  tabWidget->setCurrentIndex((tabWidget->currentIndex() + tabWidget->count() - 1) % tabWidget->count());
+  tabWidget->setCurrentIndex(
+      (tabWidget->currentIndex() + tabWidget->count() - 1) %
+      tabWidget->count());
 }
 
-void TabManager::actionNew()
-{
-  if (!par->editorDock->isVisible()) par->editorDock->setVisible(true);   //if editor hidden, make it visible
+void TabManager::actionNew() {
+  if (!par->editorDock->isVisible())
+    par->editorDock->setVisible(true); // if editor hidden, make it visible
   createTab("");
 }
 
-void TabManager::open(const QString& filename)
-{
+void TabManager::open(const QString &filename) {
   assert(!filename.isEmpty());
 
-  for (auto edt: editorList) {
+  for (auto edt : editorList) {
     if (filename == edt->filepath) {
       tabWidget->setCurrentWidget(edt);
       return;
     }
   }
 
-  if (editor->filepath.isEmpty() && !editor->isContentModified() && !editor->parameterWidget->isModified()) {
+  if (editor->filepath.isEmpty() && !editor->isContentModified() &&
+      !editor->parameterWidget->isModified()) {
     openTabFile(filename);
   } else {
     createTab(filename);
   }
 }
 
-void TabManager::createTab(const QString& filename)
-{
+void TabManager::createTab(const QString &filename) {
   assert(par != nullptr);
 
   auto scintillaEditor = new ScintillaEditor(tabWidget);
   editor = scintillaEditor;
   par->activeEditor = editor;
   editor->parameterWidget = new ParameterWidget(par->parameterDock);
-  connect(editor->parameterWidget, &ParameterWidget::parametersChanged, par, &MainWindow::actionRenderPreview);
+  connect(editor->parameterWidget, &ParameterWidget::parametersChanged, par,
+          &MainWindow::actionRenderPreview);
   par->parameterDock->setWidget(editor->parameterWidget);
 
   // clearing default mapping of keyboard shortcut for font size
@@ -167,36 +172,52 @@ void TabManager::createTab(const QString& filename)
   qcmd = qcmdset->boundTo(Qt::ControlModifier | Qt::Key_Minus);
   qcmd->setKey(0);
 
-  connect(scintillaEditor, &ScintillaEditor::uriDropped, par, &MainWindow::handleFileDrop);
-  connect(scintillaEditor, &ScintillaEditor::previewRequest, par, &MainWindow::actionRenderPreview);
-  connect(editor, &EditorInterface::showContextMenuEvent, this, &TabManager::showContextMenuEvent);
-  connect(editor, &EditorInterface::focusIn, this, [ this ]() {
-    par->setLastFocus(editor);
-  });
-
-  connect(GlobalPreferences::inst(), &Preferences::editorConfigChanged, scintillaEditor, &ScintillaEditor::applySettings);
-  connect(GlobalPreferences::inst(), &Preferences::autocompleteChanged, scintillaEditor, &ScintillaEditor::onAutocompleteChanged);
-  connect(GlobalPreferences::inst(), &Preferences::characterThresholdChanged, scintillaEditor, &ScintillaEditor::onCharacterThresholdChanged);
+  connect(scintillaEditor, &ScintillaEditor::uriDropped, par,
+          &MainWindow::handleFileDrop);
+  connect(scintillaEditor, &ScintillaEditor::previewRequest, par,
+          &MainWindow::actionRenderPreview);
+  connect(editor, &EditorInterface::showContextMenuEvent, this,
+          &TabManager::showContextMenuEvent);
+  connect(editor, &EditorInterface::focusIn, this,
+          [this]() { par->setLastFocus(editor); });
+
+  connect(GlobalPreferences::inst(), &Preferences::editorConfigChanged,
+          scintillaEditor, &ScintillaEditor::applySettings);
+  connect(GlobalPreferences::inst(), &Preferences::autocompleteChanged,
+          scintillaEditor, &ScintillaEditor::onAutocompleteChanged);
+  connect(GlobalPreferences::inst(), &Preferences::characterThresholdChanged,
+          scintillaEditor, &ScintillaEditor::onCharacterThresholdChanged);
   scintillaEditor->applySettings();
   editor->addTemplate();
 
-  connect(par->editActionZoomTextIn, &QAction::triggered, editor, &EditorInterface::zoomIn);
-  connect(par->editActionZoomTextOut, &QAction::triggered, editor, &EditorInterface::zoomOut);
-
-  connect(editor, &EditorInterface::contentsChanged, this, &TabManager::updateActionUndoState);
-  connect(editor, &EditorInterface::contentsChanged, par,  &MainWindow::editorContentChanged);
-  connect(editor, &EditorInterface::contentsChanged, this, &TabManager::setContentRenderState);
-  connect(editor, &EditorInterface::modificationChanged, this, &TabManager::onTabModified);
-  connect(editor->parameterWidget, &ParameterWidget::modificationChanged, [editor = this->editor, this] {
-    onTabModified(editor);
-  });
-
-  connect(GlobalPreferences::inst(), &Preferences::fontChanged, editor, &EditorInterface::initFont);
-  connect(GlobalPreferences::inst(), &Preferences::syntaxHighlightChanged, editor, &EditorInterface::setHighlightScheme);
-  editor->initFont(GlobalPreferences::inst()->getValue("editor/fontfamily").toString(), GlobalPreferences::inst()->getValue("editor/fontsize").toUInt());
-  editor->setHighlightScheme(GlobalPreferences::inst()->getValue("editor/syntaxhighlight").toString());
-
-  connect(scintillaEditor, &ScintillaEditor::hyperlinkIndicatorClicked, this, &TabManager::onHyperlinkIndicatorClicked);
+  connect(par->editActionZoomTextIn, &QAction::triggered, editor,
+          &EditorInterface::zoomIn);
+  connect(par->editActionZoomTextOut, &QAction::triggered, editor,
+          &EditorInterface::zoomOut);
+
+  connect(editor, &EditorInterface::contentsChanged, this,
+          &TabManager::updateActionUndoState);
+  connect(editor, &EditorInterface::contentsChanged, par,
+          &MainWindow::editorContentChanged);
+  connect(editor, &EditorInterface::contentsChanged, this,
+          &TabManager::setContentRenderState);
+  connect(editor, &EditorInterface::modificationChanged, this,
+          &TabManager::onTabModified);
+  connect(editor->parameterWidget, &ParameterWidget::modificationChanged,
+          [editor = this->editor, this] { onTabModified(editor); });
+
+  connect(GlobalPreferences::inst(), &Preferences::fontChanged, editor,
+          &EditorInterface::initFont);
+  connect(GlobalPreferences::inst(), &Preferences::syntaxHighlightChanged,
+          editor, &EditorInterface::setHighlightScheme);
+  editor->initFont(
+      GlobalPreferences::inst()->getValue("editor/fontfamily").toString(),
+      GlobalPreferences::inst()->getValue("editor/fontsize").toUInt());
+  editor->setHighlightScheme(
+      GlobalPreferences::inst()->getValue("editor/syntaxhighlight").toString());
+
+  connect(scintillaEditor, &ScintillaEditor::hyperlinkIndicatorClicked, this,
+          &TabManager::onHyperlinkIndicatorClicked);
 
   // Fill the editor with the content of the file
   if (filename.isEmpty()) {
@@ -215,104 +236,52 @@ void TabManager::createTab(const QString& filename)
   emit tabCountChanged(editorList.size());
 }
 
-size_t TabManager::count()
-{
-  return tabWidget->count();
-}
+size_t TabManager::count() { return tabWidget->count(); }
 
-void TabManager::highlightError(int i)
-{
-  editor->highlightError(i);
-}
+void TabManager::highlightError(int i) { editor->highlightError(i); }
 
-void TabManager::unhighlightLastError()
-{
-  editor->unhighlightLastError();
-}
+void TabManager::unhighlightLastError() { editor->unhighlightLastError(); }
 
-void TabManager::undo()
-{
-  editor->undo();
-}
+void TabManager::undo() { editor->undo(); }
 
-void TabManager::redo()
-{
-  editor->redo();
-}
+void TabManager::redo() { editor->redo(); }
 
-void TabManager::cut()
-{
-  editor->cut();
-}
+void TabManager::cut() { editor->cut(); }
 
-void TabManager::copy()
-{
-  editor->copy();
-}
+void TabManager::copy() { editor->copy(); }
 
-void TabManager::paste()
-{
-  editor->paste();
-}
+void TabManager::paste() { editor->paste(); }
 
-void TabManager::indentSelection()
-{
-  editor->indentSelection();
-}
+void TabManager::indentSelection() { editor->indentSelection(); }
 
-void TabManager::unindentSelection()
-{
-  editor->unindentSelection();
-}
+void TabManager::unindentSelection() { editor->unindentSelection(); }
 
-void TabManager::commentSelection()
-{
-  editor->commentSelection();
-}
+void TabManager::commentSelection() { editor->commentSelection(); }
 
-void TabManager::uncommentSelection()
-{
-  editor->uncommentSelection();
-}
+void TabManager::uncommentSelection() { editor->uncommentSelection(); }
 
-void TabManager::toggleBookmark()
-{
-  editor->toggleBookmark();
-}
+void TabManager::toggleBookmark() { editor->toggleBookmark(); }
 
-void TabManager::nextBookmark()
-{
-  editor->nextBookmark();
-}
+void TabManager::nextBookmark() { editor->nextBookmark(); }
 
-void TabManager::prevBookmark()
-{
-  editor->prevBookmark();
-}
+void TabManager::prevBookmark() { editor->prevBookmark(); }
 
-void TabManager::jumpToNextError()
-{
-  editor->jumpToNextError();
-}
+void TabManager::jumpToNextError() { editor->jumpToNextError(); }
 
-void TabManager::setFocus()
-{
-  editor->setFocus();
-}
+void TabManager::setFocus() { editor->setFocus(); }
 
-void TabManager::updateActionUndoState()
-{
+void TabManager::updateActionUndoState() {
   par->editActionUndo->setEnabled(editor->canUndo());
 }
 
-void TabManager::onHyperlinkIndicatorClicked(int val)
-{
-  const QString filename = QString::fromStdString(editor->indicatorData[val].path);
+void TabManager::onHyperlinkIndicatorClicked(int val) {
+  const QString filename =
+      QString::fromStdString(editor->indicatorData[val].path);
   this->open(filename);
 }
 
-void TabManager::applyAction(QObject *object, const std::function<void(int, EditorInterface *)>& func)
-{
+void TabManager::applyAction(
+    QObject *object, const std::function<void(int, EditorInterface *)> &func) {
   auto *action = dynamic_cast<QAction *>(object);
   if (action == nullptr) {
     return;
@@ -331,25 +300,22 @@ void TabManager::applyAction(QObject *object, const std::function<void(int, Edit
   func(idx, edt);
 }
 
-void TabManager::copyFileName()
-{
-  applyAction(QObject::sender(), [](int, EditorInterface *edt){
+void TabManager::copyFileName() {
+  applyAction(QObject::sender(), [](int, EditorInterface *edt) {
     QClipboard *clipboard = QApplication::clipboard();
     clipboard->setText(QFileInfo(edt->filepath).fileName());
   });
 }
 
-void TabManager::copyFilePath()
-{
-  applyAction(QObject::sender(), [](int, EditorInterface *edt){
+void TabManager::copyFilePath() {
+  applyAction(QObject::sender(), [](int, EditorInterface *edt) {
     QClipboard *clipboard = QApplication::clipboard();
     clipboard->setText(edt->filepath);
   });
 }
 
-void TabManager::openFolder()
-{
-  applyAction(QObject::sender(), [](int, EditorInterface *edt){
+void TabManager::openFolder() {
+  applyAction(QObject::sender(), [](int, EditorInterface *edt) {
     auto dir = QFileInfo(edt->filepath).dir();
     if (dir.exists()) {
       QDesktopServices::openUrl(QUrl::fromLocalFile(dir.absolutePath()));
@@ -357,15 +323,12 @@ void TabManager::openFolder()
   });
 }
 
-void TabManager::closeTab()
-{
-  applyAction(QObject::sender(), [this](int idx, EditorInterface *){
-    closeTabRequested(idx);
-  });
+void TabManager::closeTab() {
+  applyAction(QObject::sender(),
+              [this](int idx, EditorInterface *) { closeTabRequested(idx); });
 }
 
-void TabManager::showContextMenuEvent(const QPoint& pos)
-{
+void TabManager::showContextMenuEvent(const QPoint &pos) {
   auto menu = editor->createStandardContextMenu();
 
   menu->addSeparator();
@@ -380,10 +343,10 @@ void TabManager::showContextMenuEvent(const QPoint& pos)
   delete menu;
 }
 
-void TabManager::showTabHeaderContextMenu(const QPoint& pos)
-{
+void TabManager::showTabHeaderContextMenu(const QPoint &pos) {
   int idx = tabWidget->tabBar()->tabAt(pos);
-  if (idx < 0) return;
+  if (idx < 0)
+    return;
 
   QMenu menu;
   auto *edt = (EditorInterface *)tabWidget->widget(idx);
@@ -392,13 +355,15 @@ void TabManager::showTabHeaderContextMenu(const QPoint& pos)
   copyFileNameAction->setData(idx);
   copyFileNameAction->setEnabled(!edt->filepath.isEmpty());
   copyFileNameAction->setText(_("Copy file name"));
-  connect(copyFileNameAction, &QAction::triggered, this, &TabManager::copyFileName);
+  connect(copyFileNameAction, &QAction::triggered, this,
+          &TabManager::copyFileName);
 
   auto *copyFilePathAction = new QAction(tabWidget);
   copyFilePathAction->setData(idx);
   copyFilePathAction->setEnabled(!edt->filepath.isEmpty());
   copyFilePathAction->setText(_("Copy full path"));
-  connect(copyFilePathAction, &QAction::triggered, this, &TabManager::copyFilePath);
+  connect(copyFilePathAction, &QAction::triggered, this,
+          &TabManager::copyFilePath);
 
   auto *openFolderAction = new QAction(tabWidget);
   openFolderAction->setData(idx);
@@ -412,7 +377,8 @@ void TabManager::showTabHeaderContextMenu(const QPoint& pos)
   connect(closeAction, &QAction::triggered, this, &TabManager::closeTab);
 
   // Don't allow to close the last tab.
-  if (tabWidget->count() <= 1) closeAction->setDisabled(true);
+  if (tabWidget->count() <= 1)
+    closeAction->setDisabled(true);
 
   menu.addAction(copyFileNameAction);
   menu.addAction(copyFilePathAction);
@@ -425,27 +391,27 @@ void TabManager::showTabHeaderContextMenu(const QPoint& pos)
   menu.exec(globalCursorPos);
 }
 
-void TabManager::setContentRenderState() //since last render
+void TabManager::setContentRenderState() // since last render
 {
-  editor->contentsRendered = false;   //since last render
+  editor->contentsRendered = false; // since last render
   editor->parameterWidget->setEnabled(false);
 }
 
-void TabManager::stopAnimation()
-{
+void TabManager::stopAnimation() {
   par->animateWidget->pauseAnimation();
   par->animateWidget->e_tval->setText("");
 }
 
-void TabManager::updateFindState()
-{
-  if (editor->findState == TabManager::FIND_REPLACE_VISIBLE) par->showFind(true);
-  else if (editor->findState == TabManager::FIND_VISIBLE) par->showFind(false);
-  else par->hideFind();
+void TabManager::updateFindState() {
+  if (editor->findState == TabManager::FIND_REPLACE_VISIBLE)
+    par->showFind(true);
+  else if (editor->findState == TabManager::FIND_VISIBLE)
+    par->showFind(false);
+  else
+    par->hideFind();
 }
 
-void TabManager::onTabModified(EditorInterface *edt)
-{
+void TabManager::onTabModified(EditorInterface *edt) {
   // Get the name of the editor and its filepath with the status modifier
   auto [fname, fpath] = getEditorTabNameWithModifier(edt);
 
@@ -453,19 +419,19 @@ void TabManager::onTabModified(EditorInterface *edt)
   setEditorTabName(fname, fpath, edt);
 }
 
-void TabManager::openTabFile(const QString& filename)
-{
+void TabManager::openTabFile(const QString &filename) {
 #ifdef ENABLE_PYTHON
   if (boost::algorithm::ends_with(filename, ".py")) {
     std::string templ = "from openscad import *\n";
   } else
 #endif
-  editor->setPlainText("");
+    editor->setPlainText("");
 
   QFileInfo fileinfo(filename);
   const auto suffix = fileinfo.suffix().toLower();
   const auto knownFileType = Importer::knownFileExtensions.contains(suffix);
-  if (!knownFileType)return;
+  if (!knownFileType)
+    return;
 
   const auto cmd = Importer::knownFileExtensions[suffix];
   if (cmd.isEmpty()) {
@@ -485,8 +451,8 @@ void TabManager::openTabFile(const QString& filename)
   emit editorContentReloaded(editor);
 }
 
-std::tuple<QString, QString> TabManager::getEditorTabName(EditorInterface *edt)
-{
+std::tuple<QString, QString>
+TabManager::getEditorTabName(EditorInterface *edt) {
   QString fname = edt->filepath;
   QString fpath = edt->filepath;
   QFileInfo fileinfo(edt->filepath);
@@ -500,35 +466,35 @@ std::tuple<QString, QString> TabManager::getEditorTabName(EditorInterface *edt)
   return {fname, fpath};
 }
 
-std::tuple<QString, QString> TabManager::getEditorTabNameWithModifier(EditorInterface *edt)
-{
+std::tuple<QString, QString>
+TabManager::getEditorTabNameWithModifier(EditorInterface *edt) {
   auto [fname, fpath] = getEditorTabName(edt);
 
   // Add the "modification" star if it was changed.
-  bool isDirty = edt->isContentModified()
-    || edt->parameterWidget->isModified();
+  bool isDirty = edt->isContentModified() || edt->parameterWidget->isModified();
 
-  if (isDirty) fname += "*";
+  if (isDirty)
+    fname += "*";
 
   return {fname, fpath};
 }
 
-void TabManager::setEditorTabName(const QString& tabName, const QString& tabToolTip,
-                                  EditorInterface *edt)
-{
+void TabManager::setEditorTabName(const QString &tabName,
+                                  const QString &tabToolTip,
+                                  EditorInterface *edt) {
   int index = tabWidget->indexOf(edt);
   tabWidget->setTabText(index, QString(tabName).replace("&", "&&"));
   tabWidget->setTabToolTip(index, tabToolTip);
 }
 
-bool TabManager::refreshDocument()
-{
+bool TabManager::refreshDocument() {
   bool file_opened = false;
   if (!editor->filepath.isEmpty()) {
     QFile file(editor->filepath);
     if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
       LOG("Failed to open file %1$s: %2$s",
-          editor->filepath.toLocal8Bit().constData(), file.errorString().toLocal8Bit().constData());
+          editor->filepath.toLocal8Bit().constData(),
+          file.errorString().toLocal8Bit().constData());
     } else {
       QTextStream reader(&file);
 #if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
@@ -538,7 +504,7 @@ bool TabManager::refreshDocument()
       LOG("Loaded design '%1$s'.", editor->filepath.toLocal8Bit().constData());
       if (editor->toPlainText() != text) {
         editor->setPlainText(text);
-        setContentRenderState();         // since last render
+        setContentRenderState(); // since last render
       }
       file_opened = true;
     }
@@ -546,14 +512,14 @@ bool TabManager::refreshDocument()
   return file_opened;
 }
 
-bool TabManager::maybeSave(int x)
-{
-  auto *edt = (EditorInterface *) tabWidget->widget(x);
+bool TabManager::maybeSave(int x) {
+  auto *edt = (EditorInterface *)tabWidget->widget(x);
   if (edt->isContentModified() || edt->parameterWidget->isModified()) {
     QMessageBox box(par);
     box.setText(_("The document has been modified."));
     box.setInformativeText(_("Do you want to save your changes?"));
-    box.setStandardButtons(QMessageBox::Save | QMessageBox::Discard | QMessageBox::Cancel);
+    box.setStandardButtons(QMessageBox::Save | QMessageBox::Discard |
+                           QMessageBox::Cancel);
     box.setDefaultButton(QMessageBox::Save);
     box.setIcon(QMessageBox::Warning);
     box.setWindowModality(Qt::ApplicationModal);
@@ -562,7 +528,7 @@ bool TabManager::maybeSave(int x)
     box.button(QMessageBox::Discard)->setShortcut(QKeySequence("Ctrl+D"));
     box.button(QMessageBox::Discard)->setShortcutEnabled(true);
 #endif
-    auto ret = (QMessageBox::StandardButton) box.exec();
+    auto ret = (QMessageBox::StandardButton)box.exec();
 
     if (ret == QMessageBox::Save) {
       return save(edt);
@@ -577,15 +543,16 @@ bool TabManager::maybeSave(int x)
  * Called for whole window close, returning false will abort the close
  * operation.
  */
-bool TabManager::shouldClose()
-{
-  foreach(EditorInterface * edt, editorList) {
-    if (!(edt->isContentModified() || edt->parameterWidget->isModified())) continue;
+bool TabManager::shouldClose() {
+  foreach (EditorInterface *edt, editorList) {
+    if (!(edt->isContentModified() || edt->parameterWidget->isModified()))
+      continue;
 
     QMessageBox box(par);
     box.setText(_("Some tabs have unsaved changes."));
     box.setInformativeText(_("Do you want to save all your changes?"));
-    box.setStandardButtons(QMessageBox::SaveAll | QMessageBox::Discard | QMessageBox::Cancel);
+    box.setStandardButtons(QMessageBox::SaveAll | QMessageBox::Discard |
+                           QMessageBox::Cancel);
     box.setDefaultButton(QMessageBox::SaveAll);
     box.setIcon(QMessageBox::Warning);
     box.setWindowModality(Qt::ApplicationModal);
@@ -594,7 +561,7 @@ bool TabManager::shouldClose()
     box.button(QMessageBox::Discard)->setShortcut(QKeySequence("Ctrl+D"));
     box.button(QMessageBox::Discard)->setShortcutEnabled(true);
 #endif
-    auto ret = (QMessageBox::StandardButton) box.exec();
+    auto ret = (QMessageBox::StandardButton)box.exec();
 
     if (ret == QMessageBox::Cancel) {
       return false;
@@ -607,14 +574,16 @@ bool TabManager::shouldClose()
   return true;
 }
 
-void TabManager::saveError(const QIODevice& file, const std::string& msg, const QString& filepath)
-{
+void TabManager::saveError(const QIODevice &file, const std::string &msg,
+                           const QString &filepath) {
   const std::string fileName = filepath.toStdString();
-  LOG("%1$s %2$s (%3$s)", msg.c_str(), fileName, file.errorString().toStdString());
+  LOG("%1$s %2$s (%3$s)", msg.c_str(), fileName,
+      file.errorString().toStdString());
 
   const std::string dialogFormatStr = msg + "\n\"%1\"\n(%2)";
   const QString dialogFormat(dialogFormatStr.c_str());
-  QMessageBox::warning(par, par->windowTitle(), dialogFormat.arg(filepath).arg(file.errorString()));
+  QMessageBox::warning(par, par->windowTitle(),
+                       dialogFormat.arg(filepath).arg(file.errorString()));
 }
 
 /*!
@@ -622,8 +591,7 @@ void TabManager::saveError(const QIODevice& file, const std::string& msg, const
  * Should _always_ write to disk, since this is called by SaveAs - i.e. don't
  * try to be smart and check for document modification here.
  */
-bool TabManager::save(EditorInterface *edt)
-{
+bool TabManager::save(EditorInterface *edt) {
   assert(edt != nullptr);
 
   if (edt->filepath.isEmpty()) {
@@ -633,8 +601,7 @@ bool TabManager::save(EditorInterface *edt)
   }
 }
 
-bool TabManager::save(EditorInterface *edt, const QString& path)
-{
+bool TabManager::save(EditorInterface *edt, const QString &path) {
   par->setCurrentOutput();
 
   // If available (>= Qt 5.1), use QSaveFile to ensure the file is not
@@ -644,7 +611,8 @@ bool TabManager::save(EditorInterface *edt, const QString& path)
   // Checking the QTextStream status flag after flush() seems to catch
   // this condition.
   QSaveFile file(path);
-  if (!file.open(QIODevice::WriteOnly | QIODevice::Truncate | QIODevice::Text)) {
+  if (!file.open(QIODevice::WriteOnly | QIODevice::Truncate |
+                 QIODevice::Text)) {
     saveError(file, _("Failed to open file for writing"), path);
     return false;
   }
@@ -674,12 +642,12 @@ bool TabManager::save(EditorInterface *edt, const QString& path)
   return saveOk;
 }
 
-bool TabManager::saveAs(EditorInterface *edt)
-{
+bool TabManager::saveAs(EditorInterface *edt) {
   assert(edt != nullptr);
 
   const auto dir = edt->filepath.isEmpty() ? _("Untitled.scad") : edt->filepath;
-  auto filename = QFileDialog::getSaveFileName(par, _("Save File"), dir, _("OpenSCAD Designs (*.scad)"));
+  auto filename = QFileDialog::getSaveFileName(par, _("Save File"), dir,
+                                               _("OpenSCAD Designs (*.scad)"));
   if (filename.isEmpty()) {
     return false;
   }
@@ -691,8 +659,12 @@ bool TabManager::saveAs(EditorInterface *edt)
     // defaultSuffix property
     const QFileInfo info(filename);
     if (info.exists()) {
-      const auto text = QString(_("%1 already exists.\nDo you want to replace it?")).arg(info.fileName());
-      if (QMessageBox::warning(par, par->windowTitle(), text, QMessageBox::Yes | QMessageBox::No, QMessageBox::No) != QMessageBox::Yes) {
+      const auto text =
+          QString(_("%1 already exists.\nDo you want to replace it?"))
+              .arg(info.fileName());
+      if (QMessageBox::warning(par, par->windowTitle(), text,
+                               QMessageBox::Yes | QMessageBox::No,
+                               QMessageBox::No) != QMessageBox::Yes) {
         return false;
       }
     }
@@ -701,8 +673,7 @@ bool TabManager::saveAs(EditorInterface *edt)
   return saveAs(edt, filename);
 }
 
-bool TabManager::saveAs(EditorInterface *edt, const QString& filepath)
-{
+bool TabManager::saveAs(EditorInterface *edt, const QString &filepath) {
   bool saveOk = save(edt, filepath);
   if (saveOk) {
     auto [fname, fpath] = getEditorTabNameWithModifier(edt);
@@ -712,12 +683,12 @@ bool TabManager::saveAs(EditorInterface *edt, const QString& filepath)
   return saveOk;
 }
 
-bool TabManager::saveACopy(EditorInterface *edt)
-{
+bool TabManager::saveACopy(EditorInterface *edt) {
   assert(edt != nullptr);
 
   const auto dir = edt->filepath.isEmpty() ? _("Untitled.scad") : edt->filepath;
-  auto filename = QFileDialog::getSaveFileName(par, _("Save a Copy"), dir, _("OpenSCAD Designs (*.scad)"));
+  auto filename = QFileDialog::getSaveFileName(par, _("Save a Copy"), dir,
+                                               _("OpenSCAD Designs (*.scad)"));
   if (filename.isEmpty()) {
     return false;
   }
@@ -729,9 +700,8 @@ bool TabManager::saveACopy(EditorInterface *edt)
   return save(edt, filename);
 }
 
-bool TabManager::saveAll()
-{
-  foreach(EditorInterface * edt, editorList) {
+bool TabManager::saveAll() {
+  foreach (EditorInterface *edt, editorList) {
     if (edt->isContentModified() || edt->parameterWidget->isModified()) {
       if (!save(edt)) {
         return false;
diff --git a/src/gui/TabManager.h b/src/gui/TabManager.h
index 3447829b7..a4bec43f2 100644
--- a/src/gui/TabManager.h
+++ b/src/gui/TabManager.h
@@ -1,26 +1,25 @@
 #pragma once
 
+#include "gui/Editor.h"
+#include <QObject>
+#include <QSet>
 #include <cstddef>
 #include <functional>
 #include <string>
-#include <QObject>
-#include <QSet>
-#include "gui/Editor.h"
 
 class MainWindow; // for circular dependency
 
-class TabManager : public QObject
-{
+class TabManager : public QObject {
   Q_OBJECT
 
 public:
-  TabManager(MainWindow *o, const QString& filename);
+  TabManager(MainWindow *o, const QString &filename);
   QWidget *getTabContent();
   EditorInterface *editor;
   QSet<EditorInterface *> editorList;
 
-  void createTab(const QString& filename);
-  void openTabFile(const QString& filename);
+  void createTab(const QString &filename);
+  void openTabFile(const QString &filename);
 
   // returns the name and tooltip of the tab for the given provided editor
   // if there is a path associated with an editor this is the filepath
@@ -29,18 +28,18 @@ public:
 
   // returns the name and tooltip of the tab for the given provided editor with
   // the extra symbols used to indicate the file has changed.
-  std::tuple<QString, QString> getEditorTabNameWithModifier(EditorInterface *edt);
+  std::tuple<QString, QString>
+  getEditorTabNameWithModifier(EditorInterface *edt);
 
-  void setEditorTabName(const QString& tabName,
-                        const QString& tabTooltip,
+  void setEditorTabName(const QString &tabName, const QString &tabTooltip,
                         EditorInterface *edt = nullptr);
   bool refreshDocument(); // returns false if the file could not be opened
   bool shouldClose();
   bool save(EditorInterface *edt);
   bool saveAs(EditorInterface *edt);
-  bool saveAs(EditorInterface *edt, const QString& filepath);
+  bool saveAs(EditorInterface *edt, const QString &filepath);
   bool saveACopy(EditorInterface *edt);
-  void open(const QString& filename);
+  void open(const QString &filename);
   size_t count();
 
 public:
@@ -49,9 +48,9 @@ public:
   static constexpr const int FIND_REPLACE_VISIBLE = 2;
 
 signals:
-  // emitted when the currently displayed editor is changed and a new one is one focus.
-  // the passed parameter can be nullptr, when the editor changed because of closing of the last
-  // opened on.
+  // emitted when the currently displayed editor is changed and a new one is one
+  // focus. the passed parameter can be nullptr, when the editor changed because
+  // of closing of the last opened on.
   void currentEditorChanged(EditorInterface *editor);
   void editorAboutToClose(EditorInterface *editor);
 
@@ -65,9 +64,11 @@ private:
   QTabWidget *tabWidget;
 
   bool maybeSave(int);
-  bool save(EditorInterface *edt, const QString& path);
-  void saveError(const QIODevice& file, const std::string& msg, const QString& filepath);
-  void applyAction(QObject *object, const std::function<void(int, EditorInterface *)>& func);
+  bool save(EditorInterface *edt, const QString &path);
+  void saveError(const QIODevice &file, const std::string &msg,
+                 const QString &filepath);
+  void applyAction(QObject *object,
+                   const std::function<void(int, EditorInterface *)> &func);
   void setTabsCloseButtonVisibility(int tabIndice, bool isVisible);
 
   QTabBar::ButtonPosition getClosingButtonPosition();
@@ -81,8 +82,8 @@ private slots:
   void openFolder();
   void closeTab();
 
-  void showContextMenuEvent(const QPoint&);
-  void showTabHeaderContextMenu(const QPoint&);
+  void showContextMenuEvent(const QPoint &);
+  void showTabHeaderContextMenu(const QPoint &);
 
   void stopAnimation();
   void updateFindState();
diff --git a/src/gui/UIUtils.cc b/src/gui/UIUtils.cc
index e9fa41827..7b185eb24 100644
--- a/src/gui/UIUtils.cc
+++ b/src/gui/UIUtils.cc
@@ -26,25 +26,25 @@
 
 #include "gui/UIUtils.h"
 
-#include <filesystem>
-#include <QString>
-#include <QStringList>
-#include <QWidget>
-#include <exception>
+#include <QDesktopServices>
 #include <QDir>
-#include <QList>
+#include <QFileDialog>
 #include <QFileInfo>
 #include <QFileInfoList>
-#include <QUrl>
-#include <QFileDialog>
-#include <QDesktopServices>
-#include <QRegularExpression>
-#include <QJsonObject>
 #include <QJsonDocument>
+#include <QJsonObject>
+#include <QList>
+#include <QRegularExpression>
+#include <QString>
+#include <QStringList>
+#include <QUrl>
+#include <QWidget>
+#include <exception>
+#include <filesystem>
 
-#include "version.h"
-#include "platform/PlatformUtils.h"
 #include "gui/QSettingsCached.h"
+#include "platform/PlatformUtils.h"
+#include "version.h"
 
 #include <cstdlib>
 #include <filesystem>
@@ -52,8 +52,7 @@
 
 namespace {
 
-QString fileOpenFilter(const QString& pattern, QStringList extensions)
-{
+QString fileOpenFilter(const QString &pattern, QStringList extensions) {
   if (extensions.isEmpty()) {
     extensions << "scad" << "csg";
 #ifdef ENABLE_PYTHON
@@ -67,9 +66,8 @@ QString fileOpenFilter(const QString& pattern, QStringList extensions)
 QList<UIUtils::ExampleCategory> _exampleCategories;
 QMap<QString, QList<UIUtils::ExampleEntry>> _examples;
 
-bool hasCategory(const QString& name)
-{
-  for (const auto& category : _exampleCategories) {
+bool hasCategory(const QString &name) {
+  for (const auto &category : _exampleCategories) {
     if (category.name == name) {
       return true;
     }
@@ -77,9 +75,9 @@ bool hasCategory(const QString& name)
   return false;
 }
 
-void readExamplesDir(const QJsonObject& obj, const fs::path& dir)
-{
-  QString name = obj["name"].toString(QString::fromStdString(dir.filename().generic_string()));
+void readExamplesDir(const QJsonObject &obj, const fs::path &dir) {
+  QString name = obj["name"].toString(
+      QString::fromStdString(dir.filename().generic_string()));
 
   if (!hasCategory(name)) {
     _exampleCategories.append(UIUtils::ExampleCategory{
@@ -88,35 +86,35 @@ void readExamplesDir(const QJsonObject& obj, const fs::path& dir)
         .tooltip = obj["tooltip"].toString()});
   }
 
-  auto& examples = _examples[name];
-  for (const auto& entry : fs::directory_iterator{dir}) {
+  auto &examples = _examples[name];
+  for (const auto &entry : fs::directory_iterator{dir}) {
     if (!entry.is_regular_file()) {
       continue;
     }
-    const auto& path = entry.path();
+    const auto &path = entry.path();
     if (path.extension() != ".scad") {
       continue;
     }
     examples.append(UIUtils::ExampleEntry{
         .name = QString::fromStdString(path.filename().generic_string()),
-        .fileInfo = QFileInfo(QString::fromStdString(path.generic_string()))
-      });
+        .fileInfo = QFileInfo(QString::fromStdString(path.generic_string()))});
   }
-  std::sort(examples.begin(), examples.end(), [](const UIUtils::ExampleEntry& e1, const UIUtils::ExampleEntry& e2) -> bool {
-      return e1.name < e2.name;
-    });
+  std::sort(examples.begin(), examples.end(),
+            [](const UIUtils::ExampleEntry &e1, const UIUtils::ExampleEntry &e2)
+                -> bool { return e1.name < e2.name; });
 }
 
-void enumerateExamples(const fs::path& dir)
-{
+void enumerateExamples(const fs::path &dir) {
   if (!fs::is_directory(dir)) {
     return;
   }
-  for (const auto& entry : fs::directory_iterator{dir}) {
+  for (const auto &entry : fs::directory_iterator{dir}) {
     if (!entry.is_directory()) {
       continue;
     }
-    auto fileInfo = QFileInfo{QDir{QString::fromStdString(entry.path().generic_string())}, "example-dir.json"};
+    auto fileInfo =
+        QFileInfo{QDir{QString::fromStdString(entry.path().generic_string())},
+                  "example-dir.json"};
     QJsonObject obj;
     if (fileInfo.isReadable()) {
       QFile file;
@@ -126,13 +124,14 @@ void enumerateExamples(const fs::path& dir)
     }
     readExamplesDir(obj, entry.path());
   }
-  std::sort(_exampleCategories.begin(), _exampleCategories.end(), [](const UIUtils::ExampleCategory& c1, const UIUtils::ExampleCategory& c2) -> bool {
-      return c2.sort > c1.sort;
-    });
+  std::sort(_exampleCategories.begin(), _exampleCategories.end(),
+            [](const UIUtils::ExampleCategory &c1,
+               const UIUtils::ExampleCategory &c2) -> bool {
+              return c2.sort > c1.sort;
+            });
 }
 
-const QList<UIUtils::ExampleCategory>& readExamples()
-{
+const QList<UIUtils::ExampleCategory> &readExamples() {
   if (_exampleCategories.empty()) {
     enumerateExamples(fs::path{PlatformUtils::resourceBasePath()} / "examples");
     enumerateExamples(PlatformUtils::userExamplesPath());
@@ -142,13 +141,13 @@ const QList<UIUtils::ExampleCategory>& readExamples()
 
 } // namespace
 
-QFileInfo UIUtils::openFile(QWidget *parent, QStringList extensions)
-{
+QFileInfo UIUtils::openFile(QWidget *parent, QStringList extensions) {
   QSettingsCached settings;
   const auto last_dirname = settings.value("lastOpenDirName").toString();
-  const auto filter = fileOpenFilter("OpenSCAD Designs (%1)", std::move(extensions));
-  const auto filename = QFileDialog::getOpenFileName(parent, "Open File",
-                                                     last_dirname, filter);
+  const auto filter =
+      fileOpenFilter("OpenSCAD Designs (%1)", std::move(extensions));
+  const auto filename =
+      QFileDialog::getOpenFileName(parent, "Open File", last_dirname, filter);
 
   if (filename.isEmpty()) {
     return {};
@@ -159,16 +158,16 @@ QFileInfo UIUtils::openFile(QWidget *parent, QStringList extensions)
   return fileInfo;
 }
 
-QFileInfoList UIUtils::openFiles(QWidget *parent, QStringList extensions)
-{
+QFileInfoList UIUtils::openFiles(QWidget *parent, QStringList extensions) {
   QSettingsCached settings;
   const auto last_dirname = settings.value("lastOpenDirName").toString();
-  const auto filter = fileOpenFilter("OpenSCAD Designs (%1)", std::move(extensions));
-  const auto filenames = QFileDialog::getOpenFileNames(parent, "Open File",
-                                                       last_dirname, filter);
+  const auto filter =
+      fileOpenFilter("OpenSCAD Designs (%1)", std::move(extensions));
+  const auto filenames =
+      QFileDialog::getOpenFileNames(parent, "Open File", last_dirname, filter);
 
   QFileInfoList fileInfoList;
-  for (const QString& filename: filenames) {
+  for (const QString &filename : filenames) {
     if (filename.isEmpty()) {
       continue;
     }
@@ -183,8 +182,7 @@ QFileInfoList UIUtils::openFiles(QWidget *parent, QStringList extensions)
   return fileInfoList;
 }
 
-QStringList UIUtils::recentFiles()
-{
+QStringList UIUtils::recentFiles() {
   QSettingsCached settings; // set up project and program properly in main.cpp
   QStringList files = settings.value("recentFileList").toStringList();
 
@@ -194,7 +192,8 @@ QStringList UIUtils::recentFiles()
   // Now remove any entries which do not exist
   for (int i = files.size() - 1; i >= 0; --i) {
     QFileInfo fileInfo(files[i]);
-    if (!QFile(fileInfo.absoluteFilePath()).exists()) files.removeAt(i);
+    if (!QFile(fileInfo.absoluteFilePath()).exists())
+      files.removeAt(i);
   }
 
   while (files.size() > UIUtils::maxRecentFiles) {
@@ -205,52 +204,45 @@ QStringList UIUtils::recentFiles()
   return files;
 }
 
-const QList<UIUtils::ExampleCategory>& UIUtils::exampleCategories()
-{
+const QList<UIUtils::ExampleCategory> &UIUtils::exampleCategories() {
   return readExamples();
 }
 
-QFileInfoList UIUtils::exampleFiles(const QString& category)
-{
+QFileInfoList UIUtils::exampleFiles(const QString &category) {
   QFileInfoList examples;
   if (!_examples.contains(category)) {
     return examples;
   }
-  for (const auto& e : _examples[category]) {
+  for (const auto &e : _examples[category]) {
     examples << e.fileInfo;
   }
   return examples;
 }
 
-void UIUtils::openURL(const QString& url)
-{
+void UIUtils::openURL(const QString &url) {
   QDesktopServices::openUrl(QUrl(url));
 }
 
-void UIUtils::openHomepageURL()
-{
+void UIUtils::openHomepageURL() {
   QDesktopServices::openUrl(QUrl("https://www.openscad.org/"));
 }
 
-static void openVersionedURL(const QString& url)
-{
+static void openVersionedURL(const QString &url) {
   QDesktopServices::openUrl(QUrl(url.arg(openscad_shortversionnumber.c_str())));
 }
 
-void UIUtils::openUserManualURL()
-{
+void UIUtils::openUserManualURL() {
   openVersionedURL("https://www.openscad.org/documentation.html?version=%1");
 }
 
-fs::path UIUtils::returnOfflineUserManualPath()
-{
+fs::path UIUtils::returnOfflineUserManualPath() {
   fs::path resPath = PlatformUtils::resourcePath("resources");
-  fs::path fullPath = resPath / "docs" / "OpenSCADUserDocs" / "openscad_docs" / "OpenSCAD_User_Manual.html";
+  fs::path fullPath = resPath / "docs" / "OpenSCADUserDocs" / "openscad_docs" /
+                      "OpenSCAD_User_Manual.html";
   return fullPath;
 }
 
-bool UIUtils::hasOfflineUserManual()
-{
+bool UIUtils::hasOfflineUserManual() {
   fs::path fullPath = returnOfflineUserManualPath();
   if (fs::exists(fullPath) && fs::is_regular_file(fullPath)) {
     return true;
@@ -258,8 +250,7 @@ bool UIUtils::hasOfflineUserManual()
   return false;
 }
 
-void UIUtils::openOfflineUserManual()
-{
+void UIUtils::openOfflineUserManual() {
   fs::path fullPath = returnOfflineUserManualPath();
   if (UIUtils::hasOfflineUserManual()) {
     QString docPath = QString::fromStdString(fullPath.string());
@@ -267,24 +258,23 @@ void UIUtils::openOfflineUserManual()
   }
 }
 
-void UIUtils::openCheatSheetURL()
-{
+void UIUtils::openCheatSheetURL() {
 #ifdef OPENSCAD_SNAPSHOT
-  openVersionedURL("https://www.openscad.org/cheatsheet/snapshot.html?version=%1");
+  openVersionedURL(
+      "https://www.openscad.org/cheatsheet/snapshot.html?version=%1");
 #else
   openVersionedURL("https://www.openscad.org/cheatsheet/index.html?version=%1");
 #endif
 }
 
-fs::path UIUtils::returnOfflineCheatSheetPath()
-{
+fs::path UIUtils::returnOfflineCheatSheetPath() {
   fs::path resPath = PlatformUtils::resourcePath("resources");
-  fs::path fullPath = resPath / "docs" / "OpenSCADUserDocs" / "openscad_docs" / "CheatSheet.html";
+  fs::path fullPath = resPath / "docs" / "OpenSCADUserDocs" / "openscad_docs" /
+                      "CheatSheet.html";
   return fullPath;
 }
 
-bool UIUtils::hasOfflineCheatSheet()
-{
+bool UIUtils::hasOfflineCheatSheet() {
   fs::path fullPath = returnOfflineCheatSheetPath();
   if (fs::exists(fullPath) && fs::is_regular_file(fullPath)) {
     return true;
@@ -292,8 +282,7 @@ bool UIUtils::hasOfflineCheatSheet()
   return false;
 }
 
-void UIUtils::openOfflineCheatSheet()
-{
+void UIUtils::openOfflineCheatSheet() {
   fs::path fullPath = returnOfflineCheatSheetPath();
   if (UIUtils::hasOfflineCheatSheet()) {
     QString docPath = QString::fromStdString(fullPath.string());
@@ -301,16 +290,18 @@ void UIUtils::openOfflineCheatSheet()
   }
 }
 
-QString UIUtils::getBackgroundColorStyleSheet(const QColor& color)
-{
+QString UIUtils::getBackgroundColorStyleSheet(const QColor &color) {
   return QString("background-color:%1;").arg(color.toRgb().name());
 }
 
-QString UIUtils::blendForBackgroundColorStyleSheet(const QColor& input, const QColor& blend, float transparency)
-{
+QString UIUtils::blendForBackgroundColorStyleSheet(const QColor &input,
+                                                   const QColor &blend,
+                                                   float transparency) {
   const auto result = QColor(
-    255.0 * (transparency * blend.redF() + (1 - transparency) * input.redF()),
-    255.0 * (transparency * blend.greenF() + (1 - transparency) * input.greenF()),
-    255.0 * (transparency * blend.blueF() + (1 - transparency) * input.blueF()));
+      255.0 * (transparency * blend.redF() + (1 - transparency) * input.redF()),
+      255.0 *
+          (transparency * blend.greenF() + (1 - transparency) * input.greenF()),
+      255.0 *
+          (transparency * blend.blueF() + (1 - transparency) * input.blueF()));
   return getBackgroundColorStyleSheet(result);
 }
diff --git a/src/gui/UIUtils.h b/src/gui/UIUtils.h
index bb59eba5a..779676edb 100644
--- a/src/gui/UIUtils.h
+++ b/src/gui/UIUtils.h
@@ -26,18 +26,17 @@
 #pragma once
 
 #include <QColor>
+#include <QFileInfoList>
 #include <QString>
-#include <QWidget>
 #include <QStringList>
-#include <QFileInfoList>
+#include <QWidget>
 #include <filesystem>
 
 namespace fs = std::filesystem;
 
 namespace UIUtils {
 
-struct ExampleCategory
-{
+struct ExampleCategory {
   constexpr static int DEFAULT_SORT = 10000;
 
   int sort = DEFAULT_SORT;
@@ -45,8 +44,7 @@ struct ExampleCategory
   QString tooltip;
 };
 
-struct ExampleEntry
-{
+struct ExampleEntry {
   constexpr static int DEFAULT_SORT = 10000;
 
   int sort = DEFAULT_SORT;
@@ -62,11 +60,11 @@ QFileInfoList openFiles(QWidget *parent = nullptr, QStringList extensions = {});
 
 QStringList recentFiles();
 
-const QList<UIUtils::ExampleCategory>& exampleCategories();
+const QList<UIUtils::ExampleCategory> &exampleCategories();
 
-QFileInfoList exampleFiles(const QString& category);
+QFileInfoList exampleFiles(const QString &category);
 
-void openURL(const QString& url);
+void openURL(const QString &url);
 
 void openHomepageURL();
 
@@ -86,8 +84,10 @@ bool hasOfflineCheatSheet();
 
 void openOfflineCheatSheet();
 
-QString getBackgroundColorStyleSheet(const QColor& color);
+QString getBackgroundColorStyleSheet(const QColor &color);
 
-QString blendForBackgroundColorStyleSheet(const QColor& input, const QColor& blend, float transparency = 0.2);
+QString blendForBackgroundColorStyleSheet(const QColor &input,
+                                          const QColor &blend,
+                                          float transparency = 0.2);
 
 } // namespace UIUtils
diff --git a/src/gui/ViewportControl.cc b/src/gui/ViewportControl.cc
index b985b31c2..210e6f5ae 100644
--- a/src/gui/ViewportControl.cc
+++ b/src/gui/ViewportControl.cc
@@ -1,74 +1,78 @@
 #include "gui/ViewportControl.h"
 #include <QBoxLayout>
+#include <QDoubleSpinBox>
 #include <QGridLayout>
 #include <QLayoutItem>
 #include <QObject>
 #include <QResizeEvent>
 #include <QString>
 #include <QWidget>
-#include <iostream>
-#include <filesystem>
 #include <cfloat>
-#include <QDoubleSpinBox>
+#include <filesystem>
+#include <iostream>
 
-#include "utils/printutils.h"
 #include "gui/MainWindow.h"
 #include "gui/QGLView.h"
 #include "openscad_gui.h"
+#include "utils/printutils.h"
 
-ViewportControl::ViewportControl(QWidget *parent) : QWidget(parent)
-{
+ViewportControl::ViewportControl(QWidget *parent) : QWidget(parent) {
   setupUi(this);
   initGUI();
   const auto width = scrollAreaWidgetContents->minimumSizeHint().width();
   const auto margins = layout()->contentsMargins();
-  const auto scrollMargins = scrollAreaWidgetContents->layout()->contentsMargins();
-  initMinWidth = width + margins.left() + margins.right() + scrollMargins.left() + scrollMargins.right();
+  const auto scrollMargins =
+      scrollAreaWidgetContents->layout()->contentsMargins();
+  initMinWidth = width + margins.left() + margins.right() +
+                 scrollMargins.left() + scrollMargins.right();
 }
 
-void ViewportControl::initGUI()
-{
-  auto spinDoubleBoxes = this->groupBoxAbsoluteCamera->findChildren<QDoubleSpinBox *>();
+void ViewportControl::initGUI() {
+  auto spinDoubleBoxes =
+      this->groupBoxAbsoluteCamera->findChildren<QDoubleSpinBox *>();
   for (auto spinDoubleBox : spinDoubleBoxes) {
     spinDoubleBox->setMinimum(-DBL_MAX);
     spinDoubleBox->setMaximum(+DBL_MAX);
-    connect(spinDoubleBox, QOverload<double>::of(&QDoubleSpinBox::valueChanged), this, &ViewportControl::updateCamera);
+    connect(spinDoubleBox, QOverload<double>::of(&QDoubleSpinBox::valueChanged),
+            this, &ViewportControl::updateCamera);
   }
 
   spinBoxWidth->setMinimum(1);
   spinBoxHeight->setMinimum(1);
   spinBoxWidth->setMaximum(8192);
   spinBoxHeight->setMaximum(8192);
-  connect(spinBoxWidth, QOverload<int>::of(&QSpinBox::valueChanged), this, &ViewportControl::requestResize);
-  connect(spinBoxHeight, QOverload<int>::of(&QSpinBox::valueChanged), this, &ViewportControl::requestResize);
+  connect(spinBoxWidth, QOverload<int>::of(&QSpinBox::valueChanged), this,
+          &ViewportControl::requestResize);
+  connect(spinBoxHeight, QOverload<int>::of(&QSpinBox::valueChanged), this,
+          &ViewportControl::requestResize);
 }
 
-void ViewportControl::setMainWindow(MainWindow *mainWindow)
-{
+void ViewportControl::setMainWindow(MainWindow *mainWindow) {
   this->mainWindow = mainWindow;
   this->qglview = mainWindow->qglview;
 }
 
-QString ViewportControl::yellowHintBackground()
-{
+QString ViewportControl::yellowHintBackground() {
   QPalette defaultPalette;
   const auto bgColor = defaultPalette.base().color().toRgb();
-  QString styleSheet = UIUtils::blendForBackgroundColorStyleSheet(bgColor, warnBlendColor);
+  QString styleSheet =
+      UIUtils::blendForBackgroundColorStyleSheet(bgColor, warnBlendColor);
   return styleSheet;
 }
 
-QString ViewportControl::redHintBackground()
-{
+QString ViewportControl::redHintBackground() {
   QPalette defaultPalette;
   const auto bgColor = defaultPalette.base().color().toRgb();
-  QString styleSheet = UIUtils::blendForBackgroundColorStyleSheet(bgColor, errorBlendColor);
+  QString styleSheet =
+      UIUtils::blendForBackgroundColorStyleSheet(bgColor, errorBlendColor);
   return styleSheet;
 }
 
-void ViewportControl::resizeEvent(QResizeEvent *event)
-{
-  auto layoutAspectRatio = dynamic_cast<QBoxLayout *>(groupBoxAspectRatio->layout());
-  auto gridLayout = dynamic_cast<QGridLayout *>(groupBoxAbsoluteCamera->layout());
+void ViewportControl::resizeEvent(QResizeEvent *event) {
+  auto layoutAspectRatio =
+      dynamic_cast<QBoxLayout *>(groupBoxAspectRatio->layout());
+  auto gridLayout =
+      dynamic_cast<QGridLayout *>(groupBoxAbsoluteCamera->layout());
 
   QLayoutItem *child;
   if (layoutAspectRatio && gridLayout) {
@@ -122,8 +126,9 @@ void ViewportControl::resizeEvent(QResizeEvent *event)
   QWidget::resizeEvent(event);
 }
 
-void ViewportControl::cameraChanged(){
-  if (!inputMutex.try_lock()) return;
+void ViewportControl::cameraChanged() {
+  if (!inputMutex.try_lock())
+    return;
 
   const auto vpt = qglview->cam.getVpt();
   doubleSpinBox_tx->setValue(vpt.x());
@@ -142,28 +147,23 @@ void ViewportControl::cameraChanged(){
   inputMutex.unlock();
 }
 
-void ViewportControl::updateCamera(){
-  if (!inputMutex.try_lock()) return;
+void ViewportControl::updateCamera() {
+  if (!inputMutex.try_lock())
+    return;
 
-  //viewport translation
-  qglview->cam.setVpt(
-    doubleSpinBox_tx->value(),
-    doubleSpinBox_ty->value(),
-    doubleSpinBox_tz->value()
-    );
+  // viewport translation
+  qglview->cam.setVpt(doubleSpinBox_tx->value(), doubleSpinBox_ty->value(),
+                      doubleSpinBox_tz->value());
 
-  //viewport rotation angles in degrees
-  qglview->cam.setVpr(
-    doubleSpinBox_rx->value(),
-    doubleSpinBox_ry->value(),
-    doubleSpinBox_rz->value()
-    );
+  // viewport rotation angles in degrees
+  qglview->cam.setVpr(doubleSpinBox_rx->value(), doubleSpinBox_ry->value(),
+                      doubleSpinBox_rz->value());
 
-  //viewport camera field of view
+  // viewport camera field of view
   double fov = doubleSpinBox_fov->value();
   qglview->cam.setVpf(fov);
 
-  //camera distance
+  // camera distance
   double d = doubleSpinBox_d->value();
   qglview->cam.setVpd(d);
 
@@ -172,36 +172,38 @@ void ViewportControl::updateCamera(){
   inputMutex.unlock();
 }
 
-void ViewportControl::updateViewportControlHints(){
-  //viewport camera field of view
+void ViewportControl::updateViewportControlHints() {
+  // viewport camera field of view
   double fov = doubleSpinBox_fov->value();
   if (fov < 0 || fov > 180) {
-    doubleSpinBox_fov->setToolTip(_("extreme values might may lead to strange behavior"));
+    doubleSpinBox_fov->setToolTip(
+        _("extreme values might may lead to strange behavior"));
     doubleSpinBox_fov->setStyleSheet(redHintBackground());
   } else if (fov < 5 || fov > 175) {
-    doubleSpinBox_fov->setToolTip(_("extreme values might may lead to strange behavior"));
+    doubleSpinBox_fov->setToolTip(
+        _("extreme values might may lead to strange behavior"));
     doubleSpinBox_fov->setStyleSheet(yellowHintBackground());
   } else {
     doubleSpinBox_fov->setToolTip("");
     doubleSpinBox_fov->setStyleSheet("");
   }
 
-  //camera distance
+  // camera distance
   double d = doubleSpinBox_d->value();
   if (d < 0) {
     doubleSpinBox_d->setToolTip(_("negative distances are not supported"));
     doubleSpinBox_d->setStyleSheet(redHintBackground());
   } else if (d < 5) {
-    doubleSpinBox_d->setToolTip(_("extreme values might may lead to strange behavior"));
+    doubleSpinBox_d->setToolTip(
+        _("extreme values might may lead to strange behavior"));
     doubleSpinBox_d->setStyleSheet(yellowHintBackground());
   } else {
     doubleSpinBox_d->setToolTip("");
     doubleSpinBox_d->setStyleSheet("");
   }
-
 }
 
-void ViewportControl::resizeToRatio(){
+void ViewportControl::resizeToRatio() {
   int w0 = spinBoxWidth->value();
   int h0 = spinBoxHeight->value();
 
@@ -216,8 +218,9 @@ void ViewportControl::resizeToRatio(){
   }
 }
 
-void ViewportControl::viewResized(){
-  if (!resizeMutex.try_lock()) return;
+void ViewportControl::viewResized() {
+  if (!resizeMutex.try_lock())
+    return;
 
   this->maxW = qglview->size().rwidth();
   this->maxH = qglview->size().rheight();
@@ -231,16 +234,17 @@ void ViewportControl::viewResized(){
   resizeMutex.unlock();
 }
 
-void ViewportControl::requestResize(){
-  if (!resizeMutex.try_lock()) return;
+void ViewportControl::requestResize() {
+  if (!resizeMutex.try_lock())
+    return;
 
   resizeToRatio();
 
   resizeMutex.unlock();
 }
 
-bool ViewportControl::focusNextPrevChild(bool next){
-  QWidget::focusNextPrevChild(next);   //tab order is set in the UI File
+bool ViewportControl::focusNextPrevChild(bool next) {
+  QWidget::focusNextPrevChild(next); // tab order is set in the UI File
 
   bool bChildHasFocus = false;
   for (auto child : QObject::findChildren<QWidget *>()) {
@@ -248,7 +252,7 @@ bool ViewportControl::focusNextPrevChild(bool next){
       bChildHasFocus = true;
     }
   }
-  //do not let the focus leave this widget
+  // do not let the focus leave this widget
   if (!bChildHasFocus) {
     if (next) {
       spinBoxWidth->setFocus();
diff --git a/src/gui/ViewportControl.h b/src/gui/ViewportControl.h
index f2a758e97..5ead2728c 100644
--- a/src/gui/ViewportControl.h
+++ b/src/gui/ViewportControl.h
@@ -3,23 +3,22 @@
 #include "gui/qtgettext.h"
 #include "ui_ViewportControl.h"
 #include <QResizeEvent>
-#include <QWidget>
 #include <QStandardItemModel>
+#include <QWidget>
 #include <mutex>
 
 class MainWindow;
 class QGLView;
 
-class ViewportControl : public QWidget, public Ui::ViewportControlWidget
-{
+class ViewportControl : public QWidget, public Ui::ViewportControlWidget {
   Q_OBJECT
 
 public:
   ViewportControl(QWidget *parent = nullptr);
-  ViewportControl(const ViewportControl& source) = delete;
-  ViewportControl(ViewportControl&& source) = delete;
-  ViewportControl& operator=(const ViewportControl& source) = delete;
-  ViewportControl& operator=(ViewportControl&& source) = delete;
+  ViewportControl(const ViewportControl &source) = delete;
+  ViewportControl(ViewportControl &&source) = delete;
+  ViewportControl &operator=(const ViewportControl &source) = delete;
+  ViewportControl &operator=(ViewportControl &&source) = delete;
   ~ViewportControl() override = default;
   void initGUI();
   void setMainWindow(MainWindow *mainWindow);
diff --git a/src/gui/WindowManager.cc b/src/gui/WindowManager.cc
index 4f13c8d67..1f3d7fa42 100644
--- a/src/gui/WindowManager.cc
+++ b/src/gui/WindowManager.cc
@@ -1,18 +1,13 @@
 #include "gui/WindowManager.h"
-#include <QSet>
 #include "gui/MainWindow.h"
+#include <QSet>
 
-void WindowManager::add(MainWindow *mainwin)
-{
-  this->windows.insert(mainwin);
-}
+void WindowManager::add(MainWindow *mainwin) { this->windows.insert(mainwin); }
 
-void WindowManager::remove(MainWindow *mainwin)
-{
+void WindowManager::remove(MainWindow *mainwin) {
   this->windows.remove(mainwin);
 }
 
-const QSet<MainWindow *>& WindowManager::getWindows() const
-{
+const QSet<MainWindow *> &WindowManager::getWindows() const {
   return this->windows;
 }
diff --git a/src/gui/WindowManager.h b/src/gui/WindowManager.h
index 2e7da614d..53ce798a5 100644
--- a/src/gui/WindowManager.h
+++ b/src/gui/WindowManager.h
@@ -3,8 +3,7 @@
 #include <QObject>
 #include <QSet>
 
-class WindowManager : public QObject
-{
+class WindowManager : public QObject {
   Q_OBJECT
 
 public:
@@ -12,7 +11,8 @@ public:
 
   void add(class MainWindow *mainwin);
   void remove(class MainWindow *mainwin);
-  const QSet<MainWindow *>& getWindows() const;
+  const QSet<MainWindow *> &getWindows() const;
+
 private:
   QSet<MainWindow *> windows;
 };
diff --git a/src/gui/input/AxisConfigWidget.cc b/src/gui/input/AxisConfigWidget.cc
index b234af46b..5482b1d79 100644
--- a/src/gui/input/AxisConfigWidget.cc
+++ b/src/gui/input/AxisConfigWidget.cc
@@ -30,40 +30,41 @@
 #include <QDoubleSpinBox>
 #include <QFont>
 #include <QProgressBar>
-#include <cmath>
 #include <QWidget>
+#include <cmath>
 #include <cstddef>
 #include <string>
 
-
 #include "core/Settings.h"
-#include "gui/input/InputDriverManager.h"
-#include "gui/SettingsWriter.h"
 #include "gui/IgnoreWheelWhenNotFocused.h"
 #include "gui/InitConfigurator.h"
+#include "gui/SettingsWriter.h"
+#include "gui/input/InputDriverManager.h"
 #include "gui/input/InputEventMapper.h"
 
-AxisConfigWidget::AxisConfigWidget(QWidget *parent) : QWidget(parent)
-{
+AxisConfigWidget::AxisConfigWidget(QWidget *parent) : QWidget(parent) {
   setupUi(this);
 }
 
 void AxisConfigWidget::AxesChanged(int nr, double val) const {
-  auto *progressBar = this->findChild<QProgressBar *>(QString("progressBarAxis%1").arg(nr));
-  if (progressBar == nullptr) return;
+  auto *progressBar =
+      this->findChild<QProgressBar *>(QString("progressBarAxis%1").arg(nr));
+  if (progressBar == nullptr)
+    return;
 
   int value = val * 100;
-  progressBar->setValue(value); //set where the bar is
+  progressBar->setValue(value); // set where the bar is
 
-  //QProgressBar generates the shown string from the format string.
-  //By setting a format string without a place holder,
-  //we can set arbitrary text, like a custom formatted double.
-  //(Note: QProgressBar internally works on int, so has no formatting for double values)
-  //(Note: The text of a QProgressBar can not be set directly)
+  // QProgressBar generates the shown string from the format string.
+  // By setting a format string without a place holder,
+  // we can set arbitrary text, like a custom formatted double.
+  //(Note: QProgressBar internally works on int, so has no formatting for double
+  //values) (Note: The text of a QProgressBar can not be set directly)
   QString s = QString::number(val, 'f', 2);
   progressBar->setFormat(s);
 
-  auto *deadzone = this->findChild<QDoubleSpinBox *>(QString("doubleSpinBoxDeadzone%1").arg(nr));
+  auto *deadzone = this->findChild<QDoubleSpinBox *>(
+      QString("doubleSpinBoxDeadzone%1").arg(nr));
   if (deadzone) {
     bool active = deadzone->value() < std::abs(val);
     QString style;
@@ -77,22 +78,34 @@ void AxisConfigWidget::AxesChanged(int nr, double val) const {
 }
 
 void AxisConfigWidget::init() {
-  connect(this->pushButtonAxisTrim, &QPushButton::clicked, this, &AxisConfigWidget::on_AxisTrim);
-  connect(this->pushButtonAxisTrimReset, &QPushButton::clicked, this, &AxisConfigWidget::on_AxisTrimReset);
-  connect(this->pushButtonUpdate, &QPushButton::clicked, this, &AxisConfigWidget::updateStates);
-
-  initComboBox(this->comboBoxTranslationX, Settings::Settings::inputTranslationX);
-  initComboBox(this->comboBoxTranslationY, Settings::Settings::inputTranslationY);
-  initComboBox(this->comboBoxTranslationZ, Settings::Settings::inputTranslationZ);
-  initComboBox(this->comboBoxTranslationXVPRel, Settings::Settings::inputTranslationXVPRel);
-  initComboBox(this->comboBoxTranslationYVPRel, Settings::Settings::inputTranslationYVPRel);
-  initComboBox(this->comboBoxTranslationZVPRel, Settings::Settings::inputTranslationZVPRel);
+  connect(this->pushButtonAxisTrim, &QPushButton::clicked, this,
+          &AxisConfigWidget::on_AxisTrim);
+  connect(this->pushButtonAxisTrimReset, &QPushButton::clicked, this,
+          &AxisConfigWidget::on_AxisTrimReset);
+  connect(this->pushButtonUpdate, &QPushButton::clicked, this,
+          &AxisConfigWidget::updateStates);
+
+  initComboBox(this->comboBoxTranslationX,
+               Settings::Settings::inputTranslationX);
+  initComboBox(this->comboBoxTranslationY,
+               Settings::Settings::inputTranslationY);
+  initComboBox(this->comboBoxTranslationZ,
+               Settings::Settings::inputTranslationZ);
+  initComboBox(this->comboBoxTranslationXVPRel,
+               Settings::Settings::inputTranslationXVPRel);
+  initComboBox(this->comboBoxTranslationYVPRel,
+               Settings::Settings::inputTranslationYVPRel);
+  initComboBox(this->comboBoxTranslationZVPRel,
+               Settings::Settings::inputTranslationZVPRel);
   initComboBox(this->comboBoxRotationX, Settings::Settings::inputRotateX);
   initComboBox(this->comboBoxRotationY, Settings::Settings::inputRotateY);
   initComboBox(this->comboBoxRotationZ, Settings::Settings::inputRotateZ);
-  initComboBox(this->comboBoxRotationXVPRel, Settings::Settings::inputRotateXVPRel);
-  initComboBox(this->comboBoxRotationYVPRel, Settings::Settings::inputRotateYVPRel);
-  initComboBox(this->comboBoxRotationZVPRel, Settings::Settings::inputRotateZVPRel);
+  initComboBox(this->comboBoxRotationXVPRel,
+               Settings::Settings::inputRotateXVPRel);
+  initComboBox(this->comboBoxRotationYVPRel,
+               Settings::Settings::inputRotateYVPRel);
+  initComboBox(this->comboBoxRotationZVPRel,
+               Settings::Settings::inputRotateZVPRel);
   initComboBox(this->comboBoxZoom, Settings::Settings::inputZoom);
   initComboBox(this->comboBoxZoom2, Settings::Settings::inputZoom2);
 
@@ -100,68 +113,88 @@ void AxisConfigWidget::init() {
   this->checkBoxHIDAPI->setEnabled(true);
   this->checkBoxHIDAPI->setToolTip(HidApiInputDriverDescription);
 #else
-  this->checkBoxHIDAPI->setToolTip(HidApiInputDriverDescription + "\n\r" + NotEnabledDuringBuild);
+  this->checkBoxHIDAPI->setToolTip(HidApiInputDriverDescription + "\n\r" +
+                                   NotEnabledDuringBuild);
 #endif
 
 #ifdef ENABLE_SPNAV
   this->checkBoxSpaceNav->setEnabled(true);
   this->checkBoxSpaceNav->setToolTip(SpaceNavInputDriverDescription);
 #else
-  this->checkBoxSpaceNav->setToolTip(SpaceNavInputDriverDescription + "\n\r" + NotEnabledDuringBuild);
+  this->checkBoxSpaceNav->setToolTip(SpaceNavInputDriverDescription + "\n\r" +
+                                     NotEnabledDuringBuild);
 #endif
 
 #ifdef ENABLE_JOYSTICK
   this->checkBoxJoystick->setEnabled(true);
   this->checkBoxJoystick->setToolTip(JoystickInputDriverDescription);
 #else
-  this->checkBoxJoystick->setToolTip(JoystickInputDriverDescription + "\n\r" + NotEnabledDuringBuild);
+  this->checkBoxJoystick->setToolTip(JoystickInputDriverDescription + "\n\r" +
+                                     NotEnabledDuringBuild);
 #endif
 
 #ifdef ENABLE_QGAMEPAD
   this->checkBoxQGamepad->setEnabled(true);
   this->checkBoxQGamepad->setToolTip(QGamepadInputDriverDescription);
 #else
-  this->checkBoxQGamepad->setToolTip(QGamepadInputDriverDescription + "\n\r" + NotEnabledDuringBuild);
+  this->checkBoxQGamepad->setToolTip(QGamepadInputDriverDescription + "\n\r" +
+                                     NotEnabledDuringBuild);
 #endif
 
 #ifdef ENABLE_DBUS
   this->checkBoxDBus->setEnabled(true);
   this->checkBoxDBus->setToolTip(DBusInputDriverDescription);
 #else
-  this->checkBoxDBus->setToolTip(DBusInputDriverDescription + "\n\r" + NotEnabledDuringBuild);
+  this->checkBoxDBus->setToolTip(DBusInputDriverDescription + "\n\r" +
+                                 NotEnabledDuringBuild);
 #endif
 
-  initUpdateCheckBox(this->checkBoxHIDAPI,   Settings::Settings::inputEnableDriverHIDAPI);
-  initUpdateCheckBox(this->checkBoxSpaceNav, Settings::Settings::inputEnableDriverSPNAV);
-  initUpdateCheckBox(this->checkBoxJoystick, Settings::Settings::inputEnableDriverJOYSTICK);
-  initUpdateCheckBox(this->checkBoxQGamepad, Settings::Settings::inputEnableDriverQGAMEPAD);
-  initUpdateCheckBox(this->checkBoxDBus,     Settings::Settings::inputEnableDriverDBUS);
+  initUpdateCheckBox(this->checkBoxHIDAPI,
+                     Settings::Settings::inputEnableDriverHIDAPI);
+  initUpdateCheckBox(this->checkBoxSpaceNav,
+                     Settings::Settings::inputEnableDriverSPNAV);
+  initUpdateCheckBox(this->checkBoxJoystick,
+                     Settings::Settings::inputEnableDriverJOYSTICK);
+  initUpdateCheckBox(this->checkBoxQGamepad,
+                     Settings::Settings::inputEnableDriverQGAMEPAD);
+  initUpdateCheckBox(this->checkBoxDBus,
+                     Settings::Settings::inputEnableDriverDBUS);
 
   installIgnoreWheelWhenNotFocused(this);
 
   for (size_t i = 0; i < InputEventMapper::getMaxAxis(); ++i) {
-    auto spinTrim = this->findChild<QDoubleSpinBox *>(QString("doubleSpinBoxTrim%1").arg(i));
+    auto spinTrim = this->findChild<QDoubleSpinBox *>(
+        QString("doubleSpinBoxTrim%1").arg(i));
     if (spinTrim) {
       initUpdateDoubleSpinBox(spinTrim, InputEventMapper::axisTrimSettings(i));
     }
-    auto spinDeadZone = this->findChild<QDoubleSpinBox *>(QString("doubleSpinBoxDeadzone%1").arg(i));
+    auto spinDeadZone = this->findChild<QDoubleSpinBox *>(
+        QString("doubleSpinBoxDeadzone%1").arg(i));
     if (spinDeadZone) {
-      initUpdateDoubleSpinBox(spinDeadZone, InputEventMapper::axisDeadzoneSettings(i));
+      initUpdateDoubleSpinBox(spinDeadZone,
+                              InputEventMapper::axisDeadzoneSettings(i));
     }
   }
 
-  initUpdateDoubleSpinBox(this->doubleSpinBoxTranslationGain, Settings::Settings::inputTranslationGain);
-  initUpdateDoubleSpinBox(this->doubleSpinBoxTranslationVPRelGain, Settings::Settings::inputTranslationVPRelGain);
-  initUpdateDoubleSpinBox(this->doubleSpinBoxRotateGain, Settings::Settings::inputRotateGain);
-  initUpdateDoubleSpinBox(this->doubleSpinBoxRotateVPRelGain, Settings::Settings::inputRotateVPRelGain);
-  initUpdateDoubleSpinBox(this->doubleSpinBoxZoomGain, Settings::Settings::inputZoomGain);
-
-  //use a custom style for the axis indicators,
-  //to prevent getting operating system specific
+  initUpdateDoubleSpinBox(this->doubleSpinBoxTranslationGain,
+                          Settings::Settings::inputTranslationGain);
+  initUpdateDoubleSpinBox(this->doubleSpinBoxTranslationVPRelGain,
+                          Settings::Settings::inputTranslationVPRelGain);
+  initUpdateDoubleSpinBox(this->doubleSpinBoxRotateGain,
+                          Settings::Settings::inputRotateGain);
+  initUpdateDoubleSpinBox(this->doubleSpinBoxRotateVPRelGain,
+                          Settings::Settings::inputRotateVPRelGain);
+  initUpdateDoubleSpinBox(this->doubleSpinBoxZoomGain,
+                          Settings::Settings::inputZoomGain);
+
+  // use a custom style for the axis indicators,
+  // to prevent getting operating system specific
   //(potentially animated) ProgressBars
-  int textLightness = this->progressBarAxis0->palette().text().color().lightness();
+  int textLightness =
+      this->progressBarAxis0->palette().text().color().lightness();
   this->darkModeDetected = textLightness > 165;
-  QString style = (this->darkModeDetected) ? ProgressbarStyleDark : ProgressbarStyleLight;
+  QString style =
+      (this->darkModeDetected) ? ProgressbarStyleDark : ProgressbarStyleLight;
 
   auto progressbars = this->findChildren<QProgressBar *>();
   for (auto progressbar : progressbars) {
@@ -172,256 +205,231 @@ void AxisConfigWidget::init() {
   initialized = true;
 }
 
-void AxisConfigWidget::on_comboBoxTranslationX_activated(int val)
-{
-  applyComboBox(comboBoxTranslationX, val, Settings::Settings::inputTranslationX);
+void AxisConfigWidget::on_comboBoxTranslationX_activated(int val) {
+  applyComboBox(comboBoxTranslationX, val,
+                Settings::Settings::inputTranslationX);
   emit inputMappingChanged();
 }
 
-void AxisConfigWidget::on_comboBoxTranslationY_activated(int val)
-{
-  applyComboBox(comboBoxTranslationY, val, Settings::Settings::inputTranslationY);
+void AxisConfigWidget::on_comboBoxTranslationY_activated(int val) {
+  applyComboBox(comboBoxTranslationY, val,
+                Settings::Settings::inputTranslationY);
   emit inputMappingChanged();
 }
 
-void AxisConfigWidget::on_comboBoxTranslationZ_activated(int val)
-{
-  applyComboBox(comboBoxTranslationZ, val, Settings::Settings::inputTranslationZ);
+void AxisConfigWidget::on_comboBoxTranslationZ_activated(int val) {
+  applyComboBox(comboBoxTranslationZ, val,
+                Settings::Settings::inputTranslationZ);
   emit inputMappingChanged();
 }
 
-void AxisConfigWidget::on_comboBoxTranslationXVPRel_activated(int val)
-{
-  applyComboBox(comboBoxTranslationXVPRel, val, Settings::Settings::inputTranslationXVPRel);
+void AxisConfigWidget::on_comboBoxTranslationXVPRel_activated(int val) {
+  applyComboBox(comboBoxTranslationXVPRel, val,
+                Settings::Settings::inputTranslationXVPRel);
   emit inputMappingChanged();
 }
 
-void AxisConfigWidget::on_comboBoxTranslationYVPRel_activated(int val)
-{
-  applyComboBox(comboBoxTranslationYVPRel, val, Settings::Settings::inputTranslationYVPRel);
+void AxisConfigWidget::on_comboBoxTranslationYVPRel_activated(int val) {
+  applyComboBox(comboBoxTranslationYVPRel, val,
+                Settings::Settings::inputTranslationYVPRel);
   emit inputMappingChanged();
 }
 
-void AxisConfigWidget::on_comboBoxTranslationZVPRel_activated(int val)
-{
-  applyComboBox(comboBoxTranslationZVPRel, val, Settings::Settings::inputTranslationZVPRel);
+void AxisConfigWidget::on_comboBoxTranslationZVPRel_activated(int val) {
+  applyComboBox(comboBoxTranslationZVPRel, val,
+                Settings::Settings::inputTranslationZVPRel);
   emit inputMappingChanged();
 }
-void AxisConfigWidget::on_comboBoxRotationX_activated(int val)
-{
+void AxisConfigWidget::on_comboBoxRotationX_activated(int val) {
   applyComboBox(comboBoxRotationX, val, Settings::Settings::inputRotateX);
   emit inputMappingChanged();
 }
 
-void AxisConfigWidget::on_comboBoxRotationY_activated(int val)
-{
+void AxisConfigWidget::on_comboBoxRotationY_activated(int val) {
   applyComboBox(comboBoxRotationY, val, Settings::Settings::inputRotateY);
   emit inputMappingChanged();
 }
 
-void AxisConfigWidget::on_comboBoxRotationZ_activated(int val)
-{
+void AxisConfigWidget::on_comboBoxRotationZ_activated(int val) {
   applyComboBox(comboBoxRotationZ, val, Settings::Settings::inputRotateZ);
   emit inputMappingChanged();
 }
 
-void AxisConfigWidget::on_comboBoxRotationXVPRel_activated(int val)
-{
-  applyComboBox(comboBoxRotationXVPRel, val, Settings::Settings::inputRotateXVPRel);
+void AxisConfigWidget::on_comboBoxRotationXVPRel_activated(int val) {
+  applyComboBox(comboBoxRotationXVPRel, val,
+                Settings::Settings::inputRotateXVPRel);
   emit inputMappingChanged();
 }
 
-void AxisConfigWidget::on_comboBoxRotationYVPRel_activated(int val)
-{
-  applyComboBox(comboBoxRotationYVPRel, val, Settings::Settings::inputRotateYVPRel);
+void AxisConfigWidget::on_comboBoxRotationYVPRel_activated(int val) {
+  applyComboBox(comboBoxRotationYVPRel, val,
+                Settings::Settings::inputRotateYVPRel);
   emit inputMappingChanged();
 }
 
-void AxisConfigWidget::on_comboBoxRotationZVPRel_activated(int val)
-{
-  applyComboBox(comboBoxRotationZVPRel, val, Settings::Settings::inputRotateZVPRel);
+void AxisConfigWidget::on_comboBoxRotationZVPRel_activated(int val) {
+  applyComboBox(comboBoxRotationZVPRel, val,
+                Settings::Settings::inputRotateZVPRel);
   emit inputMappingChanged();
 }
 
-void AxisConfigWidget::on_comboBoxZoom_activated(int val)
-{
+void AxisConfigWidget::on_comboBoxZoom_activated(int val) {
   applyComboBox(comboBoxZoom, val, Settings::Settings::inputZoom);
   emit inputMappingChanged();
 }
 
-void AxisConfigWidget::on_comboBoxZoom2_activated(int val)
-{
+void AxisConfigWidget::on_comboBoxZoom2_activated(int val) {
   applyComboBox(comboBoxZoom2, val, Settings::Settings::inputZoom2);
   emit inputMappingChanged();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTrim0_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxTrim0_valueChanged(double val) {
   Settings::Settings::axisTrim0.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTrim1_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxTrim1_valueChanged(double val) {
   Settings::Settings::axisTrim1.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTrim2_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxTrim2_valueChanged(double val) {
   Settings::Settings::axisTrim2.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTrim3_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxTrim3_valueChanged(double val) {
   Settings::Settings::axisTrim3.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTrim4_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxTrim4_valueChanged(double val) {
   Settings::Settings::axisTrim4.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTrim5_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxTrim5_valueChanged(double val) {
   Settings::Settings::axisTrim5.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTrim6_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxTrim6_valueChanged(double val) {
   Settings::Settings::axisTrim6.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTrim7_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxTrim7_valueChanged(double val) {
   Settings::Settings::axisTrim7.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTrim8_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxTrim8_valueChanged(double val) {
   Settings::Settings::axisTrim8.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxDeadzone0_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxDeadzone0_valueChanged(double val) {
   Settings::Settings::axisDeadzone0.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxDeadzone1_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxDeadzone1_valueChanged(double val) {
   Settings::Settings::axisDeadzone1.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxDeadzone2_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxDeadzone2_valueChanged(double val) {
   Settings::Settings::axisDeadzone2.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxDeadzone3_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxDeadzone3_valueChanged(double val) {
   Settings::Settings::axisDeadzone3.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxDeadzone4_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxDeadzone4_valueChanged(double val) {
   Settings::Settings::axisDeadzone4.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxDeadzone5_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxDeadzone5_valueChanged(double val) {
   Settings::Settings::axisDeadzone5.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxDeadzone6_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxDeadzone6_valueChanged(double val) {
   Settings::Settings::axisDeadzone6.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxDeadzone7_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxDeadzone7_valueChanged(double val) {
   Settings::Settings::axisDeadzone7.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxDeadzone8_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxDeadzone8_valueChanged(double val) {
   Settings::Settings::axisDeadzone8.setValue(val);
   emit inputCalibrationChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxRotateGain_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxRotateGain_valueChanged(double val) {
   Settings::Settings::inputRotateGain.setValue(val);
   emit inputGainChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxRotateVPRelGain_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxRotateVPRelGain_valueChanged(
+    double val) {
   Settings::Settings::inputRotateVPRelGain.setValue(val);
   emit inputGainChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTranslationGain_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxTranslationGain_valueChanged(
+    double val) {
   Settings::Settings::inputTranslationGain.setValue(val);
   emit inputGainChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxTranslationVPRelGain_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxTranslationVPRelGain_valueChanged(
+    double val) {
   Settings::Settings::inputTranslationVPRelGain.setValue(val);
   emit inputGainChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_doubleSpinBoxZoomGain_valueChanged(double val)
-{
+void AxisConfigWidget::on_doubleSpinBoxZoomGain_valueChanged(double val) {
   Settings::Settings::inputZoomGain.setValue(val);
   emit inputGainChanged();
   writeSettings();
 }
 
-void AxisConfigWidget::on_AxisTrim()
-{
+void AxisConfigWidget::on_AxisTrim() {
   InputEventMapper::instance()->onAxisAutoTrim();
 
   for (size_t i = 0; i < InputEventMapper::getMaxAxis(); ++i) {
-    auto spin = this->findChild<QDoubleSpinBox *>(QString("doubleSpinBoxTrim%1").arg(i));
+    auto spin = this->findChild<QDoubleSpinBox *>(
+        QString("doubleSpinBoxTrim%1").arg(i));
     if (spin) {
       spin->setValue(InputEventMapper::axisTrimSettings(i).value());
     }
@@ -430,11 +438,11 @@ void AxisConfigWidget::on_AxisTrim()
   writeSettings();
 }
 
-void AxisConfigWidget::on_AxisTrimReset()
-{
+void AxisConfigWidget::on_AxisTrimReset() {
   InputEventMapper::instance()->onAxisTrimReset();
   for (size_t i = 0; i < InputEventMapper::getMaxAxis(); ++i) {
-    auto spin = this->findChild<QDoubleSpinBox *>(QString("doubleSpinBoxTrim%1").arg(i));
+    auto spin = this->findChild<QDoubleSpinBox *>(
+        QString("doubleSpinBoxTrim%1").arg(i));
     if (spin) {
       InputEventMapper::axisTrimSettings(i).setValue(0.00);
       spin->setValue(0.00);
@@ -444,8 +452,7 @@ void AxisConfigWidget::on_AxisTrimReset()
   writeSettings();
 }
 
-void AxisConfigWidget::on_checkBoxHIDAPI_toggled(bool val)
-{
+void AxisConfigWidget::on_checkBoxHIDAPI_toggled(bool val) {
   if (initialized) {
     Settings::Settings::inputEnableDriverHIDAPI.setValue(val);
     writeSettings();
@@ -456,8 +463,7 @@ void AxisConfigWidget::on_checkBoxHIDAPI_toggled(bool val)
   }
 }
 
-void AxisConfigWidget::on_checkBoxSpaceNav_toggled(bool val)
-{
+void AxisConfigWidget::on_checkBoxSpaceNav_toggled(bool val) {
   if (initialized) {
     Settings::Settings::inputEnableDriverSPNAV.setValue(val);
     writeSettings();
@@ -467,8 +473,7 @@ void AxisConfigWidget::on_checkBoxSpaceNav_toggled(bool val)
   }
 }
 
-void AxisConfigWidget::on_checkBoxJoystick_toggled(bool val)
-{
+void AxisConfigWidget::on_checkBoxJoystick_toggled(bool val) {
   if (initialized) {
     Settings::Settings::inputEnableDriverJOYSTICK.setValue(val);
     writeSettings();
@@ -478,8 +483,7 @@ void AxisConfigWidget::on_checkBoxJoystick_toggled(bool val)
   }
 }
 
-void AxisConfigWidget::on_checkBoxQGamepad_toggled(bool val)
-{
+void AxisConfigWidget::on_checkBoxQGamepad_toggled(bool val) {
   if (initialized) {
     Settings::Settings::inputEnableDriverQGAMEPAD.setValue(val);
     writeSettings();
@@ -489,8 +493,7 @@ void AxisConfigWidget::on_checkBoxQGamepad_toggled(bool val)
   }
 }
 
-void AxisConfigWidget::on_checkBoxDBus_toggled(bool val)
-{
+void AxisConfigWidget::on_checkBoxDBus_toggled(bool val) {
   if (initialized) {
     Settings::Settings::inputEnableDriverDBUS.setValue(val);
     writeSettings();
@@ -500,24 +503,25 @@ void AxisConfigWidget::on_checkBoxDBus_toggled(bool val)
   }
 }
 
-void AxisConfigWidget::applyComboBox(QComboBox * /*comboBox*/, int val, Settings::SettingsEntryEnum<std::string>& entry)
-{
+void AxisConfigWidget::applyComboBox(
+    QComboBox * /*comboBox*/, int val,
+    Settings::SettingsEntryEnum<std::string> &entry) {
   entry.setIndex(val);
   writeSettings();
 }
 
-void AxisConfigWidget::writeSettings()
-{
+void AxisConfigWidget::writeSettings() {
   Settings::Settings::visit(SettingsWriter());
 }
 
-
-void AxisConfigWidget::updateStates(){
-  if (!initialized) return;
+void AxisConfigWidget::updateStates() {
+  if (!initialized)
+    return;
 
   size_t cnt = InputDriverManager::instance()->getAxisCount();
   for (size_t i = 0; i < InputEventMapper::getMaxAxis(); ++i) {
-    auto progressbar = this->findChild<QProgressBar *>(QString("progressBarAxis%1").arg(i));
+    auto progressbar =
+        this->findChild<QProgressBar *>(QString("progressBarAxis%1").arg(i));
     if (progressbar) {
       if (cnt <= i) {
         progressbar->setEnabled(false);
diff --git a/src/gui/input/AxisConfigWidget.h b/src/gui/input/AxisConfigWidget.h
index 428293721..b46eb571d 100644
--- a/src/gui/input/AxisConfigWidget.h
+++ b/src/gui/input/AxisConfigWidget.h
@@ -1,15 +1,16 @@
 #pragma once
 
+#include "core/Settings.h"
+#include "gui/InitConfigurator.h"
 #include "gui/qtgettext.h"
+#include "ui_AxisConfigWidget.h"
 #include <QComboBox>
 #include <QWidget>
 #include <string>
-#include "core/Settings.h"
-#include "ui_AxisConfigWidget.h"
-#include "gui/InitConfigurator.h"
 
-class AxisConfigWidget : public QWidget, public Ui::Axis, public InitConfigurator
-{
+class AxisConfigWidget : public QWidget,
+                         public Ui::Axis,
+                         public InitConfigurator {
   Q_OBJECT
 
 public:
@@ -78,46 +79,61 @@ signals:
 
 private:
   /** Set value from combobox to settings */
-  void applyComboBox(QComboBox *comboBox, int val, Settings::SettingsEntryEnum<std::string>& entry);
+  void applyComboBox(QComboBox *comboBox, int val,
+                     Settings::SettingsEntryEnum<std::string> &entry);
   void writeSettings();
 
   bool initialized = false;
 
-  QString NotEnabledDuringBuild = _("This driver was not enabled during build time and is thus not available.");
-
-  QString DBusInputDriverDescription = _("The DBUS driver is not for actual devices but for remote control, Linux only.");
-  QString HidApiInputDriverDescription = _("The HIDAPI driver communicates directly with the 3D mice, Windows and macOS.");
-  QString SpaceNavInputDriverDescription = _("The SpaceNav driver enables 3D-input-devices using the spacenavd daemon, Linux only.");
-  QString JoystickInputDriverDescription = _("The Joystick driver uses the Linux joystick device (fixed to /dev/input/js0), Linux only.");
-  QString QGamepadInputDriverDescription = _("The QGAMEPAD driver is for multiplattform Gamepad Support.");
+  QString NotEnabledDuringBuild = _("This driver was not enabled during build "
+                                    "time and is thus not available.");
+
+  QString DBusInputDriverDescription =
+      _("The DBUS driver is not for actual devices but for remote control, "
+        "Linux only.");
+  QString HidApiInputDriverDescription =
+      _("The HIDAPI driver communicates directly with the 3D mice, Windows and "
+        "macOS.");
+  QString SpaceNavInputDriverDescription =
+      _("The SpaceNav driver enables 3D-input-devices using the spacenavd "
+        "daemon, Linux only.");
+  QString JoystickInputDriverDescription =
+      _("The Joystick driver uses the Linux joystick device (fixed to "
+        "/dev/input/js0), Linux only.");
+  QString QGamepadInputDriverDescription =
+      _("The QGAMEPAD driver is for multiplattform Gamepad Support.");
 
   bool darkModeDetected = false;
 
   QString ProgressbarStyleLight =
-    "QProgressBar::chunk {"
-    "background: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1,stop: 0 #66d9ff,stop: 1 #ccf2ff );"
-    "border-radius: 5px;"
-    "border: 1px solid #007399;"
-    "}";
+      "QProgressBar::chunk {"
+      "background: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1,stop: 0 "
+      "#66d9ff,stop: 1 #ccf2ff );"
+      "border-radius: 5px;"
+      "border: 1px solid #007399;"
+      "}";
 
   QString ProgressbarStyleLightActive =
-    "QProgressBar::chunk {"
-    "background: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1,stop: 0 #66ff66,stop: 1 #ccffcc );"
-    "border-radius: 5px;"
-    "border: 1px solid #007399;"
-    "}";
+      "QProgressBar::chunk {"
+      "background: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1,stop: 0 "
+      "#66ff66,stop: 1 #ccffcc );"
+      "border-radius: 5px;"
+      "border: 1px solid #007399;"
+      "}";
 
   QString ProgressbarStyleDark =
-    "QProgressBar::chunk {"
-    "background: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1,stop: 0 #001a33,stop: 1 #0069cc );"
-    "border-radius: 5px;"
-    "border: 1px solid #000d1a;"
-    "}";
+      "QProgressBar::chunk {"
+      "background: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1,stop: 0 "
+      "#001a33,stop: 1 #0069cc );"
+      "border-radius: 5px;"
+      "border: 1px solid #000d1a;"
+      "}";
 
   QString ProgressbarStyleDarkActive =
-    "QProgressBar::chunk {"
-    "background: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1,stop: 0 #00331a,stop: 1 #00cc69 );"
-    "border-radius: 5px;"
-    "border: 1px solid #000d1a;"
-    "}";
+      "QProgressBar::chunk {"
+      "background: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1,stop: 0 "
+      "#00331a,stop: 1 #00cc69 );"
+      "border-radius: 5px;"
+      "border: 1px solid #000d1a;"
+      "}";
 };
diff --git a/src/gui/input/ButtonConfigWidget.cc b/src/gui/input/ButtonConfigWidget.cc
index c4b51af08..1292b224c 100644
--- a/src/gui/input/ButtonConfigWidget.cc
+++ b/src/gui/input/ButtonConfigWidget.cc
@@ -26,28 +26,29 @@
 
 #include "gui/input/ButtonConfigWidget.h"
 
+#include "core/Settings.h"
+#include "gui/IgnoreWheelWhenNotFocused.h"
+#include "gui/SettingsWriter.h"
+#include "gui/input/InputDriverManager.h"
+#include "gui/input/InputEventMapper.h"
 #include <QChar>
 #include <QComboBox>
 #include <QLabel>
 #include <QString>
 #include <QWidget>
 #include <cstddef>
-#include "core/Settings.h"
-#include "gui/input/InputDriverManager.h"
-#include "gui/SettingsWriter.h"
-#include "gui/IgnoreWheelWhenNotFocused.h"
-#include "gui/input/InputEventMapper.h"
 
-ButtonConfigWidget::ButtonConfigWidget(QWidget *parent) : QWidget(parent)
-{
+ButtonConfigWidget::ButtonConfigWidget(QWidget *parent) : QWidget(parent) {
   setupUi(this);
 }
 
 void ButtonConfigWidget::updateButtonState(int nr, bool pressed) const {
-  QString style = pressed ? ButtonConfigWidget::ActiveStyleString : ButtonConfigWidget::EmptyString;
+  QString style = pressed ? ButtonConfigWidget::ActiveStyleString
+                          : ButtonConfigWidget::EmptyString;
 
   auto label = this->findChild<QLabel *>(QString("labelInputButton%1").arg(nr));
-  if (label == nullptr) return;
+  if (label == nullptr)
+    return;
   label->setStyleSheet(style);
 }
 
@@ -64,175 +65,151 @@ void ButtonConfigWidget::init() {
   initialized = true;
 }
 
-void ButtonConfigWidget::on_comboBoxButton0_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton0_activated(int val) {
   applyComboBox(comboBoxButton0, val, Settings::Settings::inputButton0);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton1_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton1_activated(int val) {
   applyComboBox(comboBoxButton1, val, Settings::Settings::inputButton1);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton2_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton2_activated(int val) {
   applyComboBox(comboBoxButton2, val, Settings::Settings::inputButton2);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton3_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton3_activated(int val) {
   applyComboBox(comboBoxButton3, val, Settings::Settings::inputButton3);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton4_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton4_activated(int val) {
   applyComboBox(comboBoxButton4, val, Settings::Settings::inputButton4);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton5_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton5_activated(int val) {
   applyComboBox(comboBoxButton5, val, Settings::Settings::inputButton5);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton6_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton6_activated(int val) {
   applyComboBox(comboBoxButton6, val, Settings::Settings::inputButton6);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton7_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton7_activated(int val) {
   applyComboBox(comboBoxButton7, val, Settings::Settings::inputButton7);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton8_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton8_activated(int val) {
   applyComboBox(comboBoxButton8, val, Settings::Settings::inputButton8);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton9_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton9_activated(int val) {
   applyComboBox(comboBoxButton9, val, Settings::Settings::inputButton9);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton10_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton10_activated(int val) {
   applyComboBox(comboBoxButton10, val, Settings::Settings::inputButton10);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton11_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton11_activated(int val) {
   applyComboBox(comboBoxButton11, val, Settings::Settings::inputButton11);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton12_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton12_activated(int val) {
   applyComboBox(comboBoxButton12, val, Settings::Settings::inputButton12);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton13_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton13_activated(int val) {
   applyComboBox(comboBoxButton13, val, Settings::Settings::inputButton13);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton14_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton14_activated(int val) {
   applyComboBox(comboBoxButton14, val, Settings::Settings::inputButton14);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton15_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton15_activated(int val) {
   applyComboBox(comboBoxButton15, val, Settings::Settings::inputButton15);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton16_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton16_activated(int val) {
   applyComboBox(comboBoxButton16, val, Settings::Settings::inputButton16);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton17_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton17_activated(int val) {
   applyComboBox(comboBoxButton17, val, Settings::Settings::inputButton17);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton18_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton18_activated(int val) {
   applyComboBox(comboBoxButton18, val, Settings::Settings::inputButton18);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton19_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton19_activated(int val) {
   applyComboBox(comboBoxButton19, val, Settings::Settings::inputButton19);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton20_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton20_activated(int val) {
   applyComboBox(comboBoxButton20, val, Settings::Settings::inputButton20);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton21_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton21_activated(int val) {
   applyComboBox(comboBoxButton21, val, Settings::Settings::inputButton21);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton22_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton22_activated(int val) {
   applyComboBox(comboBoxButton22, val, Settings::Settings::inputButton22);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::on_comboBoxButton23_activated(int val)
-{
+void ButtonConfigWidget::on_comboBoxButton23_activated(int val) {
   applyComboBox(comboBoxButton23, val, Settings::Settings::inputButton23);
   emit inputMappingChanged();
 }
 
-void ButtonConfigWidget::applyComboBox(QComboBox *comboBox, int val, Settings::SettingsEntryString& entry)
-{
+void ButtonConfigWidget::applyComboBox(QComboBox *comboBox, int val,
+                                       Settings::SettingsEntryString &entry) {
   entry.setValue(comboBox->itemData(val).toString().toStdString());
   writeSettings();
 }
 
-void ButtonConfigWidget::updateComboBox(QComboBox *comboBox, const Settings::SettingsEntryString& entry)
-{
+void ButtonConfigWidget::updateComboBox(
+    QComboBox *comboBox, const Settings::SettingsEntryString &entry) {
   QString value = QString::fromStdString(entry.value());
   int index = comboBox->findData(value);
   if (index >= 0) {
     comboBox->setCurrentIndex(index);
   } else {
-    comboBox->addItem(QIcon::fromTheme("emblem-unreadable"), value + " " + ("(not supported)"), value);
+    comboBox->addItem(QIcon::fromTheme("emblem-unreadable"),
+                      value + " " + ("(not supported)"), value);
     comboBox->setCurrentIndex(comboBox->count() - 1);
   }
 }
 
-void ButtonConfigWidget::writeSettings()
-{
+void ButtonConfigWidget::writeSettings() {
   Settings::Settings::visit(SettingsWriter());
 }
 
-void ButtonConfigWidget::initActionComboBox(QComboBox *comboBox, const Settings::SettingsEntryString& entry)
-{
+void ButtonConfigWidget::initActionComboBox(
+    QComboBox *comboBox, const Settings::SettingsEntryString &entry) {
   comboBox->clear();
 
   // Create an empty icon, so that all comboboxes have the same alignment
@@ -241,9 +218,10 @@ void ButtonConfigWidget::initActionComboBox(QComboBox *comboBox, const Settings:
   const QIcon emptyIcon = QIcon(map);
 
   comboBox->addItem(emptyIcon, QString::fromStdString(_("None")), "");
-  comboBox->addItem(emptyIcon, QString::fromStdString(_("Toggle Perspective")), "viewActionTogglePerspective");
+  comboBox->addItem(emptyIcon, QString::fromStdString(_("Toggle Perspective")),
+                    "viewActionTogglePerspective");
 
-  for (const auto& action : InputDriverManager::instance()->getActions()) {
+  for (const auto &action : InputDriverManager::instance()->getActions()) {
     const auto icon = action.icon;
     const auto effectiveIcon = icon.isNull() ? emptyIcon : icon;
     const auto desc = QString(action.description).remove(QChar('&'));
@@ -253,14 +231,17 @@ void ButtonConfigWidget::initActionComboBox(QComboBox *comboBox, const Settings:
   updateComboBox(comboBox, entry);
 }
 
-void ButtonConfigWidget::updateStates(){
-  if (!initialized) return;
+void ButtonConfigWidget::updateStates() {
+  if (!initialized)
+    return;
 
   size_t cnt = InputDriverManager::instance()->getButtonCount();
   for (size_t i = 0; i < InputEventMapper::getMaxButtons(); ++i) {
-    auto label = this->findChild<QLabel *>(QString("labelInputButton%1").arg(i));
+    auto label =
+        this->findChild<QLabel *>(QString("labelInputButton%1").arg(i));
     if (label) {
-      QString style = (cnt <= i) ? ButtonConfigWidget::DisabledStyleString : ButtonConfigWidget::EmptyString;
+      QString style = (cnt <= i) ? ButtonConfigWidget::DisabledStyleString
+                                 : ButtonConfigWidget::EmptyString;
       label->setStyleSheet(style);
     }
   }
diff --git a/src/gui/input/ButtonConfigWidget.h b/src/gui/input/ButtonConfigWidget.h
index d811b2b6b..77b43f7c9 100644
--- a/src/gui/input/ButtonConfigWidget.h
+++ b/src/gui/input/ButtonConfigWidget.h
@@ -1,13 +1,12 @@
 #pragma once
 
+#include "core/Settings.h"
 #include "gui/qtgettext.h"
+#include "ui_ButtonConfigWidget.h"
 #include <QComboBox>
 #include <QWidget>
-#include "ui_ButtonConfigWidget.h"
-#include "core/Settings.h"
 
-class ButtonConfigWidget : public QWidget, public Ui::Button
-{
+class ButtonConfigWidget : public QWidget, public Ui::Button {
   Q_OBJECT
 
 public:
@@ -47,11 +46,14 @@ signals:
 
 private:
   /** Initialize combobox list values from the settings range values */
-  void initActionComboBox(QComboBox *comboBox, const Settings::SettingsEntryString& entry);
+  void initActionComboBox(QComboBox *comboBox,
+                          const Settings::SettingsEntryString &entry);
   /** Update combobox from current settings */
-  void updateComboBox(QComboBox *comboBox, const Settings::SettingsEntryString& entry);
+  void updateComboBox(QComboBox *comboBox,
+                      const Settings::SettingsEntryString &entry);
   /** Set value from combobox to settings */
-  void applyComboBox(QComboBox *comboBox, int val, Settings::SettingsEntryString& entry);
+  void applyComboBox(QComboBox *comboBox, int val,
+                     Settings::SettingsEntryString &entry);
   void writeSettings();
 
   const QString EmptyString = QString("");
diff --git a/src/gui/input/DBusInputDriver.cc b/src/gui/input/DBusInputDriver.cc
index b547ffd9d..6a531ca3a 100644
--- a/src/gui/input/DBusInputDriver.cc
+++ b/src/gui/input/DBusInputDriver.cc
@@ -24,36 +24,23 @@
  *
  */
 #include "gui/input/DBusInputDriver.h"
-#include <QDBusConnection>
-#include <QList>
-#include <QStringList>
 #include "gui/input/InputDriverManager.h"
-#include "utils/printutils.h"
 #include "openscad_adaptor.h"
 #include "openscad_interface.h"
+#include "utils/printutils.h"
+#include <QDBusConnection>
+#include <QList>
+#include <QStringList>
 
-void DBusInputDriver::run()
-{
+void DBusInputDriver::run() {}
 
-}
+DBusInputDriver::DBusInputDriver() { name = "DBusInputDriver"; }
 
-DBusInputDriver::DBusInputDriver()
-{
-  name = "DBusInputDriver";
-}
-
-bool DBusInputDriver::openOnce() const
-{
-  return true;
-}
+bool DBusInputDriver::openOnce() const { return true; }
 
-bool DBusInputDriver::isOpen() const
-{
-  return is_open;
-}
+bool DBusInputDriver::isOpen() const { return is_open; }
 
-bool DBusInputDriver::open()
-{
+bool DBusInputDriver::open() {
   if (is_open) {
     return true;
   }
@@ -74,82 +61,73 @@ bool DBusInputDriver::open()
   return true;
 }
 
-void DBusInputDriver::close()
-{
-
-}
+void DBusInputDriver::close() {}
 
-void DBusInputDriver::zoom(double zoom) const
-{
-  InputDriverManager::instance()->sendEvent(new InputEventZoom(zoom, true, false));
+void DBusInputDriver::zoom(double zoom) const {
+  InputDriverManager::instance()->sendEvent(
+      new InputEventZoom(zoom, true, false));
 }
 
-void DBusInputDriver::zoomTo(double zoom) const
-{
-  InputDriverManager::instance()->sendEvent(new InputEventZoom(zoom, false, false));
+void DBusInputDriver::zoomTo(double zoom) const {
+  InputDriverManager::instance()->sendEvent(
+      new InputEventZoom(zoom, false, false));
 }
 
-void DBusInputDriver::rotate(double x, double y, double z) const
-{
-  InputDriverManager::instance()->sendEvent(new InputEventRotate(x, y, z, true, false));
+void DBusInputDriver::rotate(double x, double y, double z) const {
+  InputDriverManager::instance()->sendEvent(
+      new InputEventRotate(x, y, z, true, false));
 }
 
-void DBusInputDriver::rotateTo(double x, double y, double z) const
-{
-  InputDriverManager::instance()->sendEvent(new InputEventRotate(x, y, z, false, false));
+void DBusInputDriver::rotateTo(double x, double y, double z) const {
+  InputDriverManager::instance()->sendEvent(
+      new InputEventRotate(x, y, z, false, false));
 }
 
-void DBusInputDriver::rotateByVector(double x, double y, double z) const
-{
-  InputDriverManager::instance()->sendEvent(new InputEventRotate2(x, y, z, false));
+void DBusInputDriver::rotateByVector(double x, double y, double z) const {
+  InputDriverManager::instance()->sendEvent(
+      new InputEventRotate2(x, y, z, false));
 }
 
-void DBusInputDriver::translate(double x, double y, double z) const
-{
-  InputDriverManager::instance()->sendEvent(new InputEventTranslate(x, y, z, true, false, false));
+void DBusInputDriver::translate(double x, double y, double z) const {
+  InputDriverManager::instance()->sendEvent(
+      new InputEventTranslate(x, y, z, true, false, false));
 }
 
-void DBusInputDriver::translateTo(double x, double y, double z) const
-{
-  InputDriverManager::instance()->sendEvent(new InputEventTranslate(x, y, z, false, false, false));
+void DBusInputDriver::translateTo(double x, double y, double z) const {
+  InputDriverManager::instance()->sendEvent(
+      new InputEventTranslate(x, y, z, false, false, false));
 }
 
-void DBusInputDriver::action(const QString& name) const
-{
-  InputDriverManager::instance()->sendEvent(new InputEventAction(name.toStdString(), false));
+void DBusInputDriver::action(const QString &name) const {
+  InputDriverManager::instance()->sendEvent(
+      new InputEventAction(name.toStdString(), false));
 }
 
-const QStringList DBusInputDriver::getActions() const
-{
+const QStringList DBusInputDriver::getActions() const {
   QStringList ret;
-  for (const auto& action : InputDriverManager::instance()->getActions()) {
+  for (const auto &action : InputDriverManager::instance()->getActions()) {
     ret << action.name;
   }
   return ret;
 }
 
-void DBusInputDriver::buttonPress(uint idx) const
-{
-  InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(idx, true, false));
-  InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(idx, false, false));
+void DBusInputDriver::buttonPress(uint idx) const {
+  InputDriverManager::instance()->sendEvent(
+      new InputEventButtonChanged(idx, true, false));
+  InputDriverManager::instance()->sendEvent(
+      new InputEventButtonChanged(idx, false, false));
 }
 
-const QList<double> DBusInputDriver::getRotation() const
-{
+const QList<double> DBusInputDriver::getRotation() const {
   return InputDriverManager::instance()->getRotation();
 }
 
-const QList<double> DBusInputDriver::getTranslation() const
-{
+const QList<double> DBusInputDriver::getTranslation() const {
   return InputDriverManager::instance()->getTranslation();
 }
 
-const std::string& DBusInputDriver::get_name() const
-{
-  return this->name;
-}
+const std::string &DBusInputDriver::get_name() const { return this->name; }
 
-std::string DBusInputDriver::get_info() const
-{
+std::string DBusInputDriver::get_info() const {
   return STR(get_name(), " ", (isOpen() ? "open" : "not open"));
 }
diff --git a/src/gui/input/DBusInputDriver.h b/src/gui/input/DBusInputDriver.h
index e4cc2fd0a..b749a4652 100644
--- a/src/gui/input/DBusInputDriver.h
+++ b/src/gui/input/DBusInputDriver.h
@@ -25,14 +25,13 @@
  */
 #pragma once
 
+#include "gui/input/InputDriver.h"
 #include <QList>
 #include <QString>
 #include <QStringList>
-#include "gui/input/InputDriver.h"
 #include <string>
 
-class DBusInputDriver : public InputDriver
-{
+class DBusInputDriver : public InputDriver {
   Q_OBJECT
 
   bool is_open{false};
@@ -47,7 +46,7 @@ public:
   bool isOpen() const override;
   bool openOnce() const override;
 
-  const std::string& get_name() const override;
+  const std::string &get_name() const override;
   std::string get_info() const override;
 
 public slots:
@@ -58,7 +57,7 @@ public slots:
   void rotateByVector(double x, double y, double z) const;
   void translate(double x, double y, double z) const;
   void translateTo(double x, double y, double z) const;
-  void action(const QString& action) const;
+  void action(const QString &action) const;
   void buttonPress(uint idx) const;
   const QList<double> getRotation() const;
   const QList<double> getTranslation() const;
diff --git a/src/gui/input/HidApiInputDriver.cc b/src/gui/input/HidApiInputDriver.cc
index b978568e6..feac402b1 100644
--- a/src/gui/input/HidApiInputDriver.cc
+++ b/src/gui/input/HidApiInputDriver.cc
@@ -31,22 +31,22 @@
 
 #include "gui/input/HidApiInputDriver.h"
 
-#include <ios>
-#include <sstream>
-#include <cstdint>
 #include <bitset>
 #include <boost/format.hpp>
 #include <chrono>
 #include <cmath>
 #include <codecvt>
+#include <cstdint>
 #include <fstream>
 #include <iomanip>
+#include <ios>
+#include <sstream>
 #include <string>
 
 #include "core/Settings.h"
-#include "platform/PlatformUtils.h"
 #include "gui/input/InputDriverEvent.h"
 #include "gui/input/InputDriverManager.h"
+#include "platform/PlatformUtils.h"
 #include "utils/printutils.h"
 
 static constexpr int BUFLEN = 64;
@@ -60,44 +60,78 @@ static ch::system_clock::time_point logtime;
 // http://www.linux-usb.org/usb.ids
 // http://www.3dconnexion.eu/nc/service/faq/show_faq/7ece50ed-0b39-b57e-d3b2-4afd9420604e.html
 static const struct device_id device_ids[] = {
-  { 0x046d, 0xc603, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Spacemouse Plus XT"},
-  { 0x046d, 0xc605, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion CADman"},
-  { 0x046d, 0xc606, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Spacemouse Classic"},
-  { 0x046d, 0xc621, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Spaceball 5000"},
-  { 0x046d, 0xc623, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Traveller 3D Mouse"},
-  { 0x046d, 0xc625, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Pilot 3D Mouse"},
-  { 0x046d, 0xc626, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Navigator 3D Mouse"},
-  { 0x046d, 0xc627, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Explorer 3D Mouse"},
-  { 0x046d, 0xc628, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Navigator for Notebooks"},
-  { 0x046d, 0xc629, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion SpacePilot Pro 3D Mouse"},
-  { 0x046d, 0xc62b, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Pro"},
-  { 0x256f, 0xc62e, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Wireless (cabled)"},
-  { 0x256f, 0xc62f, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Wireless"},
-  { 0x256f, 0xc631, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Pro Wireless (cabled)"},
-  { 0x256f, 0xc632, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Pro Wireless"},
-  { 0x256f, 0xc635, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Compact"},
-  { 0x256f, 0xc63a, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Wireless BT"},
-  // This is reported to be used with a 3Dconnexion Space Mouse Wireless 256f:c62e
-  { 0x256f, 0xc652, &HidApiInputDriver::hidapi_decode_axis, &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Universal Receiver"},
-  { -1, -1, nullptr, nullptr, nullptr},
+    {0x046d, 0xc603, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion Spacemouse Plus XT"},
+    {0x046d, 0xc605, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button, "3Dconnexion CADman"},
+    {0x046d, 0xc606, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion Spacemouse Classic"},
+    {0x046d, 0xc621, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Spaceball 5000"},
+    {0x046d, 0xc623, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion Space Traveller 3D Mouse"},
+    {0x046d, 0xc625, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion Space Pilot 3D Mouse"},
+    {0x046d, 0xc626, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion Space Navigator 3D Mouse"},
+    {0x046d, 0xc627, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion Space Explorer 3D Mouse"},
+    {0x046d, 0xc628, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion Space Navigator for Notebooks"},
+    {0x046d, 0xc629, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion SpacePilot Pro 3D Mouse"},
+    {0x046d, 0xc62b, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button, "3Dconnexion Space Mouse Pro"},
+    {0x256f, 0xc62e, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion Space Mouse Wireless (cabled)"},
+    {0x256f, 0xc62f, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion Space Mouse Wireless"},
+    {0x256f, 0xc631, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion Space Mouse Pro Wireless (cabled)"},
+    {0x256f, 0xc632, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion Space Mouse Pro Wireless"},
+    {0x256f, 0xc635, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion Space Mouse Compact"},
+    {0x256f, 0xc63a, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion Space Mouse Wireless BT"},
+    // This is reported to be used with a 3Dconnexion Space Mouse Wireless
+    // 256f:c62e
+    {0x256f, 0xc652, &HidApiInputDriver::hidapi_decode_axis,
+     &HidApiInputDriver::hidapi_decode_button,
+     "3Dconnexion Universal Receiver"},
+    {-1, -1, nullptr, nullptr, nullptr},
 };
 
 #define HIDAPI_LOG(f) hidapi_log(boost::format(f))
 // NOLINTNEXTLINE(*macro-parentheses)
 #define HIDAPI_LOGP(f, a) hidapi_log(boost::format(f) % a)
-static void hidapi_log(const boost::format& format) {
+static void hidapi_log(const boost::format &format) {
   if (logstream) {
     const ch::system_clock::duration time = ch::system_clock::now() - logtime;
 
-    logstream << ch::duration_cast<ch::milliseconds>(time).count() << ": " << format.str() << std::endl;
+    logstream << ch::duration_cast<ch::milliseconds>(time).count() << ": "
+              << format.str() << std::endl;
     if (logstream.tellp() > MAX_LOG_SIZE) {
       logstream.close();
     }
   }
 }
 
-static void hidapi_log_input(unsigned char *buf, int len)
-{
+static void hidapi_log_input(unsigned char *buf, int len) {
   if (logstream) {
     std::ostringstream s;
 
@@ -109,8 +143,7 @@ static void hidapi_log_input(unsigned char *buf, int len)
   }
 }
 
-static std::string to_string(const wchar_t *wstr)
-{
+static std::string to_string(const wchar_t *wstr) {
   if (wstr) {
     std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> conv;
     return conv.to_bytes(wstr);
@@ -118,28 +151,22 @@ static std::string to_string(const wchar_t *wstr)
   return "<null>";
 }
 
-static const device_id *match_device(const struct hid_device_info *info)
-{
+static const device_id *match_device(const struct hid_device_info *info) {
   for (int idx = 0; device_ids[idx].name != nullptr; ++idx) {
-    if ((device_ids[idx].vendor_id == info->vendor_id) && (device_ids[idx].product_id == info->product_id)) {
+    if ((device_ids[idx].vendor_id == info->vendor_id) &&
+        (device_ids[idx].product_id == info->product_id)) {
       return &device_ids[idx];
     }
   }
   return nullptr;
 }
 
-HidApiInputDriver::HidApiInputDriver()
-{
-  name = "HidApiInputDriver";
-}
+HidApiInputDriver::HidApiInputDriver() { name = "HidApiInputDriver"; }
 
-void HidApiInputDriver::run()
-{
-  hidapi_input(hid_dev);
-}
+void HidApiInputDriver::run() { hidapi_input(hid_dev); }
 
-void HidApiInputDriver::hidapi_decode_axis(const unsigned char *buf, unsigned int len)
-{
+void HidApiInputDriver::hidapi_decode_axis(const unsigned char *buf,
+                                           unsigned int len) {
   if ((buf[0] == 1 || buf[0] == 2) && len == 7) {
     // Values are in the range -10..10 at min. speed and -2595..2595
     // at max. speed.
@@ -153,13 +180,19 @@ void HidApiInputDriver::hidapi_decode_axis(const unsigned char *buf, unsigned in
     const double y = y_value / 350.0;
     const double z = z_value / 350.0;
     if (buf[0] == 1) {
-      InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(0, x));
-      InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(1, y));
-      InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(2, z));
+      InputDriverManager::instance()->sendEvent(
+          new InputEventAxisChanged(0, x));
+      InputDriverManager::instance()->sendEvent(
+          new InputEventAxisChanged(1, y));
+      InputDriverManager::instance()->sendEvent(
+          new InputEventAxisChanged(2, z));
     } else {
-      InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(3, x));
-      InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(4, y));
-      InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(5, z));
+      InputDriverManager::instance()->sendEvent(
+          new InputEventAxisChanged(3, x));
+      InputDriverManager::instance()->sendEvent(
+          new InputEventAxisChanged(4, y));
+      InputDriverManager::instance()->sendEvent(
+          new InputEventAxisChanged(5, z));
     }
   } else if (buf[0] == 1 && len == 13) {
     // Same as above, but all 6 axis is a single 13 byte HID message.
@@ -174,15 +207,15 @@ void HidApiInputDriver::hidapi_decode_axis(const unsigned char *buf, unsigned in
   }
 }
 
-void HidApiInputDriver::hidapi_decode_button(const unsigned char *buf, unsigned int len)
-{
+void HidApiInputDriver::hidapi_decode_button(const unsigned char *buf,
+                                             unsigned int len) {
   if (buf[0] == 3 && len >= 3) {
     // Handle button events, on Linux the packet has a length of 3 but
     // on Windows the length is 13.
     const uint16_t current = buf[1] | buf[2] << 8;
 
     const std::bitset<16> bits_curr{current};
-    const std::bitset<16> bits_last{buttons};  // NOLINT
+    const std::bitset<16> bits_last{buttons}; // NOLINT
 
     for (int i = 0; i < 16; ++i) {
       if (bits_curr.test(i) != bits_last.test(i)) {
@@ -195,8 +228,7 @@ void HidApiInputDriver::hidapi_decode_button(const unsigned char *buf, unsigned
   }
 }
 
-void HidApiInputDriver::hidapi_input(hid_device *hid_dev)
-{
+void HidApiInputDriver::hidapi_input(hid_device *hid_dev) {
   unsigned char buf[BUFLEN];
   unsigned int len;
   while ((len = hid_read(hid_dev, buf, BUFLEN)) > 0) {
@@ -207,19 +239,20 @@ void HidApiInputDriver::hidapi_input(hid_device *hid_dev)
   hid_close(hid_dev);
 }
 
-std::pair<hid_device *, const struct device_id *> HidApiInputDriver::enumerate() const
-{
+std::pair<hid_device *, const struct device_id *>
+HidApiInputDriver::enumerate() const {
   hid_device *ret_hid_dev = nullptr;
   const struct device_id *ret_dev = nullptr;
 
   HIDAPI_LOG("Enumerating HID devices...");
   struct hid_device_info *info = hid_enumerate(0, 0);
   for (; info != nullptr; info = info->next) {
-    HIDAPI_LOGP("D: %04x:%04x | path = %s, serial = %s, manufacturer = %s, product = %s",
-                info->vendor_id % info->product_id % info->path
-                % to_string(info->serial_number)
-                % to_string(info->manufacturer_string)
-                % to_string(info->product_string));
+    HIDAPI_LOGP("D: %04x:%04x | path = %s, serial = %s, manufacturer = %s, "
+                "product = %s",
+                info->vendor_id % info->product_id % info->path %
+                    to_string(info->serial_number) %
+                    to_string(info->manufacturer_string) %
+                    to_string(info->product_string));
     const device_id *dev = match_device(info);
     if (!dev) {
       continue;
@@ -227,18 +260,22 @@ std::pair<hid_device *, const struct device_id *> HidApiInputDriver::enumerate()
 
     hid_device *hid_dev;
 
-    HIDAPI_LOGP("P: %04x:%04x | %s", info->vendor_id % info->product_id % info->path);
+    HIDAPI_LOGP("P: %04x:%04x | %s",
+                info->vendor_id % info->product_id % info->path);
     hid_dev = hid_open_path(info->path);
 
     if (!hid_dev) {
-      HIDAPI_LOGP("O: %04x:%04x | %s", info->vendor_id % info->product_id % to_string(info->serial_number));
-      hid_dev = hid_open(info->vendor_id, info->product_id, info->serial_number);
+      HIDAPI_LOGP("O: %04x:%04x | %s", info->vendor_id % info->product_id %
+                                           to_string(info->serial_number));
+      hid_dev =
+          hid_open(info->vendor_id, info->product_id, info->serial_number);
       if (!hid_dev) {
         continue;
       }
     }
 
-    HIDAPI_LOGP("R: %04x:%04x | %s", info->vendor_id % info->product_id % to_string(info->serial_number));
+    HIDAPI_LOGP("R: %04x:%04x | %s", info->vendor_id % info->product_id %
+                                         to_string(info->serial_number));
     unsigned char buf[BUFLEN];
     const int len = hid_read_timeout(hid_dev, buf, BUFLEN, 100);
     HIDAPI_LOGP("?: %d", len);
@@ -254,12 +291,12 @@ std::pair<hid_device *, const struct device_id *> HidApiInputDriver::enumerate()
     break;
   }
   hid_free_enumeration(info);
-  HIDAPI_LOGP("Done enumerating (status = %s).", (ret_hid_dev != nullptr ? "ok" : "failed"));
+  HIDAPI_LOGP("Done enumerating (status = %s).",
+              (ret_hid_dev != nullptr ? "ok" : "failed"));
   return {ret_hid_dev, ret_dev};
 }
 
-bool HidApiInputDriver::open()
-{
+bool HidApiInputDriver::open() {
   if (Settings::Settings::inputEnableDriverHIDAPILog.value()) {
     logtime = ch::system_clock::now();
     logstream.open(PlatformUtils::backupPath() + "/hidapi.log");
@@ -274,9 +311,8 @@ bool HidApiInputDriver::open()
 
   std::tie(this->hid_dev, this->dev) = enumerate();
   if (this->dev) {
-    name = STR(std::setfill('0'), std::setw(4), std::hex,
-               "HidApiInputDriver (", dev->vendor_id, ":", dev->product_id,
-               " - ", dev->name, ")");
+    name = STR(std::setfill('0'), std::setw(4), std::hex, "HidApiInputDriver (",
+               dev->vendor_id, ":", dev->product_id, " - ", dev->name, ")");
     start();
     HIDAPI_LOGP("HidApiInputDriver::open(): %s", name);
     return true;
@@ -286,8 +322,7 @@ bool HidApiInputDriver::open()
   return false;
 }
 
-void HidApiInputDriver::close()
-{
+void HidApiInputDriver::close() {
   this->dev = nullptr;
   this->hid_dev = nullptr;
   this->name = "HidApiInputDriver";
@@ -295,13 +330,9 @@ void HidApiInputDriver::close()
   logstream.close();
 }
 
-const std::string& HidApiInputDriver::get_name() const
-{
-  return name;
-}
+const std::string &HidApiInputDriver::get_name() const { return name; }
 
-std::string HidApiInputDriver::get_info() const
-{
+std::string HidApiInputDriver::get_info() const {
   std::ostringstream stream;
   stream << get_name() << " ";
   if (isOpen()) {
diff --git a/src/gui/input/HidApiInputDriver.h b/src/gui/input/HidApiInputDriver.h
index 7bb8171c2..3a5ab6e6b 100644
--- a/src/gui/input/HidApiInputDriver.h
+++ b/src/gui/input/HidApiInputDriver.h
@@ -27,20 +27,19 @@
 #pragma once
 
 #include <cstddef>
-#include <string>
 #include <hidapi.h>
+#include <string>
 
 #include "core/Settings.h"
 #include "gui/input/InputDriver.h"
 
-class HidApiInputDriver : public InputDriver
-{
+class HidApiInputDriver : public InputDriver {
   Q_OBJECT
 
   std::string name;
   unsigned int buttons{0};
   hid_device *hid_dev{nullptr};
-  const struct device_id *dev {nullptr};
+  const struct device_id *dev{nullptr};
 
 public:
   HidApiInputDriver();
@@ -48,18 +47,14 @@ public:
   bool open() override;
   void close() override;
 
-  const std::string& get_name() const override;
+  const std::string &get_name() const override;
   std::string get_info() const override;
 
   void hidapi_decode_axis(const unsigned char *buf, unsigned int len);
   void hidapi_decode_button(const unsigned char *buf, unsigned int len);
 
-  size_t getButtonCount() const override {
-    return Settings::max_buttons;
-  }
-  size_t getAxisCount() const override {
-    return Settings::max_axis;
-  }
+  size_t getButtonCount() const override { return Settings::max_buttons; }
+  size_t getAxisCount() const override { return Settings::max_axis; }
 
 private:
   std::pair<hid_device *, const struct device_id *> enumerate() const;
@@ -69,7 +64,9 @@ private:
 struct device_id {
   int vendor_id;
   int product_id;
-  void (HidApiInputDriver::*axis_decoder)(const unsigned char *buf, unsigned int len);
-  void (HidApiInputDriver::*button_decoder)(const unsigned char *buf, unsigned int len);
+  void (HidApiInputDriver::*axis_decoder)(const unsigned char *buf,
+                                          unsigned int len);
+  void (HidApiInputDriver::*button_decoder)(const unsigned char *buf,
+                                            unsigned int len);
   const char *name;
 };
diff --git a/src/gui/input/InputDriver.cc b/src/gui/input/InputDriver.cc
index 976e71585..e11dbc1c0 100644
--- a/src/gui/input/InputDriver.cc
+++ b/src/gui/input/InputDriver.cc
@@ -24,22 +24,15 @@
  *
  */
 #include "gui/input/InputDriver.h"
-#include <QEvent>
 #include "gui/input/InputDriverEvent.h"
+#include <QEvent>
 
-const QEvent::Type InputEvent::eventType = static_cast<QEvent::Type>(QEvent::registerEventType());
-
-InputEvent::InputEvent(const bool activeOnly) : QEvent(eventType), activeOnly(activeOnly)
-{
+const QEvent::Type InputEvent::eventType =
+    static_cast<QEvent::Type>(QEvent::registerEventType());
 
-}
+InputEvent::InputEvent(const bool activeOnly)
+    : QEvent(eventType), activeOnly(activeOnly) {}
 
-bool InputDriver::isOpen() const
-{
-  return isRunning();
-}
+bool InputDriver::isOpen() const { return isRunning(); }
 
-bool InputDriver::openOnce() const
-{
-  return false;
-}
+bool InputDriver::openOnce() const { return false; }
diff --git a/src/gui/input/InputDriver.h b/src/gui/input/InputDriver.h
index cccde19d3..f87e70180 100644
--- a/src/gui/input/InputDriver.h
+++ b/src/gui/input/InputDriver.h
@@ -29,12 +29,11 @@
 #include <cstddef>
 #include <string>
 
-class InputDriver : public QThread
-{
+class InputDriver : public QThread {
 public:
   InputDriver() = default;
 
-  virtual const std::string& get_name() const = 0;
+  virtual const std::string &get_name() const = 0;
   virtual std::string get_info() const = 0;
 
   virtual bool open() = 0;
@@ -52,6 +51,6 @@ public:
    */
   virtual bool openOnce() const;
 
-  virtual size_t getButtonCount() const {return 0;}
-  virtual size_t getAxisCount() const {return 0;}
+  virtual size_t getButtonCount() const { return 0; }
+  virtual size_t getAxisCount() const { return 0; }
 };
diff --git a/src/gui/input/InputDriverEvent.h b/src/gui/input/InputDriverEvent.h
index db88c1d98..5c603ae86 100644
--- a/src/gui/input/InputDriverEvent.h
+++ b/src/gui/input/InputDriverEvent.h
@@ -25,14 +25,12 @@
  */
 #pragma once
 
-#include <utility>
 #include <QEvent>
 #include <string>
+#include <utility>
 
-class InputEventHandler
-{
+class InputEventHandler {
 public:
-
   virtual ~InputEventHandler() = default;
 
   virtual void onAxisChanged(class InputEventAxisChanged *event) = 0;
@@ -45,8 +43,7 @@ public:
   virtual void onZoomEvent(class InputEventZoom *event) = 0;
 };
 
-class InputEvent : public QEvent
-{
+class InputEvent : public QEvent {
 public:
   const bool activeOnly;
 
@@ -57,10 +54,9 @@ public:
   static const QEvent::Type eventType;
 };
 
-class GenericInputEvent : public InputEvent
-{
+class GenericInputEvent : public InputEvent {
 public:
-  GenericInputEvent(const bool activeOnly = true) : InputEvent(activeOnly) { }
+  GenericInputEvent(const bool activeOnly = true) : InputEvent(activeOnly) {}
 };
 
 /**
@@ -68,16 +64,16 @@ public:
  * one axis. The value is assumed to be an absolute value in the
  * range -1.0 to 1.0.
  */
-class InputEventAxisChanged : public GenericInputEvent
-{
+class InputEventAxisChanged : public GenericInputEvent {
 public:
   const unsigned int axis;
   const double value;
 
-  InputEventAxisChanged(const unsigned int axis, const double value, const bool activeOnly = true) : GenericInputEvent(activeOnly), axis(axis), value(value) { }
+  InputEventAxisChanged(const unsigned int axis, const double value,
+                        const bool activeOnly = true)
+      : GenericInputEvent(activeOnly), axis(axis), value(value) {}
 
-  void deliver(InputEventHandler *receiver) override
-  {
+  void deliver(InputEventHandler *receiver) override {
     receiver->onAxisChanged(this);
   }
 };
@@ -86,16 +82,16 @@ public:
  * Generic event for use by input drivers to report button press
  * and button release events.
  */
-class InputEventButtonChanged : public GenericInputEvent
-{
+class InputEventButtonChanged : public GenericInputEvent {
 public:
   const unsigned int button;
   const bool down;
 
-  InputEventButtonChanged(const unsigned int button, const bool down, const bool activeOnly = true) : GenericInputEvent(activeOnly), button(button), down(down) { }
+  InputEventButtonChanged(const unsigned int button, const bool down,
+                          const bool activeOnly = true)
+      : GenericInputEvent(activeOnly), button(button), down(down) {}
 
-  void deliver(InputEventHandler *receiver) override
-  {
+  void deliver(InputEventHandler *receiver) override {
     receiver->onButtonChanged(this);
   }
 };
@@ -107,76 +103,78 @@ public:
  * type in the driver itself (e.g. the DBus driver uses this to report
  * calls to the translate method).
  */
-class InputEventTranslate : public InputEvent
-{
+class InputEventTranslate : public InputEvent {
 public:
   const double x;
   const double y;
   const double z;
   const bool relative;
   const bool viewPortRelative;
-  InputEventTranslate(const double x, const double y, const double z, const bool relative = true, const bool viewPortRelative = false, const bool activeOnly = true) : InputEvent(activeOnly), x(x), y(y), z(z), relative(relative), viewPortRelative(viewPortRelative) { }
-
-  void deliver(InputEventHandler *receiver) override
-  {
+  InputEventTranslate(const double x, const double y, const double z,
+                      const bool relative = true,
+                      const bool viewPortRelative = false,
+                      const bool activeOnly = true)
+      : InputEvent(activeOnly), x(x), y(y), z(z), relative(relative),
+        viewPortRelative(viewPortRelative) {}
+
+  void deliver(InputEventHandler *receiver) override {
     receiver->onTranslateEvent(this);
   }
 };
 
-class InputEventRotate : public InputEvent
-{
+class InputEventRotate : public InputEvent {
 public:
   const double x;
   const double y;
   const double z;
   const bool relative;
 
-  InputEventRotate(const double x, const double y, const double z, const bool relative = true, const bool activeOnly = true) : InputEvent(activeOnly), x(x), y(y), z(z), relative(relative) { }
+  InputEventRotate(const double x, const double y, const double z,
+                   const bool relative = true, const bool activeOnly = true)
+      : InputEvent(activeOnly), x(x), y(y), z(z), relative(relative) {}
 
-  void deliver(InputEventHandler *receiver) override
-  {
+  void deliver(InputEventHandler *receiver) override {
     receiver->onRotateEvent(this);
   }
 };
 
-class InputEventRotate2 : public InputEvent
-{
+class InputEventRotate2 : public InputEvent {
 public:
   const double x;
   const double y;
   const double z;
 
-  InputEventRotate2(const double x, const double y, const double z, const bool activeOnly = true) : InputEvent(activeOnly), x(x), y(y), z(z) { }
+  InputEventRotate2(const double x, const double y, const double z,
+                    const bool activeOnly = true)
+      : InputEvent(activeOnly), x(x), y(y), z(z) {}
 
-  void deliver(InputEventHandler *receiver) override
-  {
+  void deliver(InputEventHandler *receiver) override {
     receiver->onRotate2Event(this);
   }
 };
 
-class InputEventZoom : public InputEvent
-{
+class InputEventZoom : public InputEvent {
 public:
   const double zoom;
   const bool relative;
 
-  InputEventZoom(const double zoom, const bool relative = true, const bool activeOnly = true) : InputEvent(activeOnly), zoom(zoom), relative(relative) { }
+  InputEventZoom(const double zoom, const bool relative = true,
+                 const bool activeOnly = true)
+      : InputEvent(activeOnly), zoom(zoom), relative(relative) {}
 
-  void deliver(InputEventHandler *receiver) override
-  {
+  void deliver(InputEventHandler *receiver) override {
     receiver->onZoomEvent(this);
   }
 };
 
-class InputEventAction : public InputEvent
-{
+class InputEventAction : public InputEvent {
 public:
   const std::string action;
 
-  InputEventAction(std::string action, const bool activeOnly = true) : InputEvent(activeOnly), action(std::move(action)) { }
+  InputEventAction(std::string action, const bool activeOnly = true)
+      : InputEvent(activeOnly), action(std::move(action)) {}
 
-  void deliver(InputEventHandler *receiver) override
-  {
+  void deliver(InputEventHandler *receiver) override {
     receiver->onActionEvent(this);
   }
 };
diff --git a/src/gui/input/InputDriverManager.cc b/src/gui/input/InputDriverManager.cc
index 7d4d855bd..8f6063f1d 100644
--- a/src/gui/input/InputDriverManager.cc
+++ b/src/gui/input/InputDriverManager.cc
@@ -25,19 +25,19 @@
  */
 #include "gui/input/InputDriverManager.h"
 
-#include "gui/input/InputDriverEvent.h"
 #include "gui/MainWindow.h"
+#include "gui/input/InputDriverEvent.h"
+#include <QAction>
+#include <QApplication>
+#include <QCoreApplication>
 #include <QList>
+#include <QMenu>
 #include <QString>
 #include <QTimer>
 #include <algorithm>
+#include <cstddef>
 #include <list>
 #include <sstream>
-#include <QAction>
-#include <QMenu>
-#include <QApplication>
-#include <QCoreApplication>
-#include <cstddef>
 #include <string>
 
 InputDriverManager *InputDriverManager::self = nullptr;
@@ -46,29 +46,31 @@ InputDriverManager *InputDriverManager::self = nullptr;
  * This can be called from non-GUI context, so no Qt initialization is done
  * at this point.
  */
-InputDriverManager *InputDriverManager::instance()
-{
+InputDriverManager *InputDriverManager::instance() {
   if (!self) {
     self = new InputDriverManager();
   }
   return self;
 }
 
-void InputDriverManager::registerDriver(InputDriver *driver)
-{
+void InputDriverManager::registerDriver(InputDriver *driver) {
   this->drivers.push_back(driver);
 }
 
-void InputDriverManager::unregisterDriver(InputDriver *driver)
-{
+void InputDriverManager::unregisterDriver(InputDriver *driver) {
   this->drivers.remove(driver);
 }
 
-void InputDriverManager::registerActions(const QList<QAction *>& actions, const QString& parent, const QString& target)
-{
+void InputDriverManager::registerActions(const QList<QAction *> &actions,
+                                         const QString &parent,
+                                         const QString &target) {
   const QString emptyQString("");
   for (const auto action : actions) {
-    const auto description = ((parent == emptyQString) ? emptyQString : (parent + QString::fromUtf8(u8" \u2192 "))) + action->text();
+    const auto description =
+        ((parent == emptyQString)
+             ? emptyQString
+             : (parent + QString::fromUtf8(u8" \u2192 "))) +
+        action->text();
     if (!action->objectName().isEmpty()) {
       QString actionName = action->objectName();
       if ("" != target) {
@@ -82,18 +84,17 @@ void InputDriverManager::registerActions(const QList<QAction *>& actions, const
   }
 }
 
-void InputDriverManager::init()
-{
+void InputDriverManager::init() {
   timer = new QTimer(this);
-  connect(qApp, &QApplication::focusChanged, this, &InputDriverManager::onFocusChanged);
+  connect(qApp, &QApplication::focusChanged, this,
+          &InputDriverManager::onFocusChanged);
 
   doOpen(true);
   connect(timer, &QTimer::timeout, this, &InputDriverManager::onTimeout);
   timer->start(10 * 1000);
 }
 
-void InputDriverManager::onTimeout()
-{
+void InputDriverManager::onTimeout() {
   for (auto driver : drivers) {
     if (driver->openOnce()) {
       continue;
@@ -105,8 +106,7 @@ void InputDriverManager::onTimeout()
   doOpen(false);
 }
 
-void InputDriverManager::doOpen(bool firstOpen)
-{
+void InputDriverManager::doOpen(bool firstOpen) {
   for (auto driver : drivers) {
     if (driver->openOnce()) {
       continue;
@@ -125,8 +125,7 @@ void InputDriverManager::doOpen(bool firstOpen)
   }
 }
 
-std::string InputDriverManager::listDrivers() const
-{
+std::string InputDriverManager::listDrivers() const {
   std::ostringstream stream;
   const char *sep = "";
   for (auto driver : drivers) {
@@ -139,8 +138,7 @@ std::string InputDriverManager::listDrivers() const
   return stream.str();
 }
 
-std::string InputDriverManager::listDriverInfos() const
-{
+std::string InputDriverManager::listDriverInfos() const {
   std::ostringstream stream;
   const char *sep = "";
   for (auto driver : drivers) {
@@ -150,8 +148,7 @@ std::string InputDriverManager::listDriverInfos() const
   return stream.str();
 }
 
-void InputDriverManager::closeDrivers()
-{
+void InputDriverManager::closeDrivers() {
   if (timer != nullptr) {
     timer->stop();
   }
@@ -162,26 +159,23 @@ void InputDriverManager::closeDrivers()
   }
 }
 
-void InputDriverManager::sendEvent(InputEvent *event)
-{
+void InputDriverManager::sendEvent(InputEvent *event) {
   event->deliver(&mapper);
 }
 
-void InputDriverManager::postEvent(InputEvent *event)
-{
-  QWidget *window = event->activeOnly ? QApplication::activeWindow() : currentWindow;
+void InputDriverManager::postEvent(InputEvent *event) {
+  QWidget *window =
+      event->activeOnly ? QApplication::activeWindow() : currentWindow;
   if (window) {
     QCoreApplication::postEvent(window, event);
   }
 }
 
-const std::list<ActionStruct>& InputDriverManager::getActions() const
-{
+const std::list<ActionStruct> &InputDriverManager::getActions() const {
   return actions;
 }
 
-QList<double> InputDriverManager::getTranslation() const
-{
+QList<double> InputDriverManager::getTranslation() const {
   const MainWindow *window = currentWindow;
   if (window) {
     return window->getTranslation();
@@ -189,8 +183,7 @@ QList<double> InputDriverManager::getTranslation() const
   return QList<double>({0.0, 0.0, 0.0});
 }
 
-QList<double> InputDriverManager::getRotation() const
-{
+QList<double> InputDriverManager::getRotation() const {
   const MainWindow *window = currentWindow;
   if (window) {
     return window->getRotation();
@@ -198,27 +191,21 @@ QList<double> InputDriverManager::getRotation() const
   return QList<double>({0.0, 0.0, 0.0});
 }
 
-void InputDriverManager::onFocusChanged(QWidget *, QWidget *current)
-{
+void InputDriverManager::onFocusChanged(QWidget *, QWidget *current) {
   if (current) {
     currentWindow = dynamic_cast<MainWindow *>(current->window());
   }
 }
 
-void InputDriverManager::onInputMappingUpdated()
-{
+void InputDriverManager::onInputMappingUpdated() {
   mapper.onInputMappingUpdated();
 }
 
-void InputDriverManager::onInputCalibrationUpdated()
-{
+void InputDriverManager::onInputCalibrationUpdated() {
   mapper.onInputCalibrationUpdated();
 }
 
-void InputDriverManager::onInputGainUpdated()
-{
-  mapper.onInputGainUpdated();
-}
+void InputDriverManager::onInputGainUpdated() { mapper.onInputGainUpdated(); }
 
 size_t InputDriverManager::getButtonCount() const {
   size_t max = 0;
diff --git a/src/gui/input/InputDriverManager.h b/src/gui/input/InputDriverManager.h
index 6e7f42d6d..19d5075cd 100644
--- a/src/gui/input/InputDriverManager.h
+++ b/src/gui/input/InputDriverManager.h
@@ -25,14 +25,14 @@
  */
 #pragma once
 
+#include <QIcon>
 #include <QList>
 #include <QObject>
 #include <QString>
-#include <list>
-#include <QWidget>
 #include <QThread>
 #include <QTimer>
-#include <QIcon>
+#include <QWidget>
+#include <list>
 
 #include <cstddef>
 #include <string>
@@ -48,8 +48,7 @@ struct ActionStruct {
   QIcon icon;
 };
 
-class InputDriverManager : public QObject
-{
+class InputDriverManager : public QObject {
   Q_OBJECT
 private:
   using drivers_t = std::list<InputDriver *>;
@@ -79,11 +78,13 @@ public:
   void registerDriver(InputDriver *driver);
   void unregisterDriver(InputDriver *driver);
   void closeDrivers();
-  void registerActions(const QList<QAction *>& actions, const QString& parent = QString(""), const QString& target = QString(""));
+  void registerActions(const QList<QAction *> &actions,
+                       const QString &parent = QString(""),
+                       const QString &target = QString(""));
 
   static InputDriverManager *instance();
 
-  const std::list<ActionStruct>& getActions() const;
+  const std::list<ActionStruct> &getActions() const;
   QList<double> getTranslation() const;
   QList<double> getRotation() const;
 
diff --git a/src/gui/input/InputEventMapper.cc b/src/gui/input/InputEventMapper.cc
index ecc0a99e6..595e27294 100644
--- a/src/gui/input/InputEventMapper.cc
+++ b/src/gui/input/InputEventMapper.cc
@@ -24,25 +24,24 @@
  *
  */
 #include "gui/input/InputEventMapper.h"
-#include "gui/input/InputDriverManager.h"
 #include "core/Settings.h"
 #include "gui/Preferences.h"
 #include "gui/input/AxisConfigWidget.h"
 #include "gui/input/ButtonConfigWidget.h"
-#include <array>
+#include "gui/input/InputDriverManager.h"
 #include <QMetaObject>
+#include <QSettings>
 #include <QTimer>
+#include <array>
+#include <cmath>
 #include <cstddef>
 #include <string>
-#include <cmath>
-#include <QSettings>
 
 using S = Settings::Settings;
 
 InputEventMapper *InputEventMapper::self = nullptr;
 
-InputEventMapper::InputEventMapper()
-{
+InputEventMapper::InputEventMapper() {
   stopRequest = false;
 
   for (size_t a = 0; a < getMaxAxis(); ++a) {
@@ -72,8 +71,7 @@ InputEventMapper::InputEventMapper()
   self = this;
 }
 
-InputEventMapper *InputEventMapper::instance()
-{
+InputEventMapper *InputEventMapper::instance() {
   if (!self) {
     self = new InputEventMapper();
   }
@@ -85,40 +83,39 @@ InputEventMapper *InputEventMapper::instance()
     0 -> 0
     1 ->  10.72
  */
-double InputEventMapper::scale(double val)
-{
+double InputEventMapper::scale(double val) {
   double x = 4 * val;
   double xx = x < 0 ? -exp(-x) + 1 : exp(x) - 1;
   return xx / 5.0;
 }
 
-double InputEventMapper::getAxisValue(int config)
-{
-  if (config == 0)    // avoid indexing by -1 when using default settings (and causing bizarre behavior)
+double InputEventMapper::getAxisValue(int config) {
+  if (config == 0) // avoid indexing by -1 when using default settings (and
+                   // causing bizarre behavior)
     return scale(0);
 
   int idx = abs(config) - 1;
-  if (idx > 8)        // avoid reading over end of arrays (and causing segfaults)
+  if (idx > 8) // avoid reading over end of arrays (and causing segfaults)
     return scale(0);
 
   bool neg = config < 0;
   double trimmedVal = axisRawValue[idx] + axisTrimValue[idx];
   double val = neg ? -trimmedVal : trimmedVal;
-  if (val < axisDeadzone[idx] and - val < axisDeadzone[idx]) {
+  if (val < axisDeadzone[idx] and -val < axisDeadzone[idx]) {
     val = 0;
   }
   return scale(val);
 }
 
-bool InputEventMapper::generateDeferredEvents()
-{
+bool InputEventMapper::generateDeferredEvents() {
   bool any = false;
   const double threshold = 0.01;
 
   double tx = getAxisValue(translate[0]) * translationGain;
   double ty = getAxisValue(translate[1]) * translationGain;
   double tz = getAxisValue(translate[2]) * translationGain;
-  if ((fabs(tx) > threshold) || (fabs(ty) > threshold) || (fabs(tz) > threshold)) {
+  if ((fabs(tx) > threshold) || (fabs(ty) > threshold) ||
+      (fabs(tz) > threshold)) {
     InputEvent *inputEvent = new InputEventTranslate(tx, ty, tz);
     InputDriverManager::instance()->postEvent(inputEvent);
     any = true;
@@ -127,8 +124,10 @@ bool InputEventMapper::generateDeferredEvents()
   double txVPRel = getAxisValue(translate[3]) * translationVPRelGain;
   double tyVPRel = getAxisValue(translate[4]) * translationVPRelGain;
   double tzVPRel = getAxisValue(translate[5]) * translationVPRelGain;
-  if ((fabs(txVPRel) > threshold) || (fabs(tyVPRel) > threshold) || (fabs(tzVPRel) > threshold)) {
-    InputEvent *inputEvent = new InputEventTranslate(txVPRel, tyVPRel, tzVPRel, true, true, false);
+  if ((fabs(txVPRel) > threshold) || (fabs(tyVPRel) > threshold) ||
+      (fabs(tzVPRel) > threshold)) {
+    InputEvent *inputEvent =
+        new InputEventTranslate(txVPRel, tyVPRel, tzVPRel, true, true, false);
     InputDriverManager::instance()->postEvent(inputEvent);
     any = true;
   }
@@ -136,7 +135,8 @@ bool InputEventMapper::generateDeferredEvents()
   double rx = getAxisValue(rotate[0]) * rotateGain;
   double ry = getAxisValue(rotate[1]) * rotateGain;
   double rz = getAxisValue(rotate[2]) * rotateGain;
-  if ((fabs(rx) > threshold) || (fabs(ry) > threshold) || (fabs(rz) > threshold)) {
+  if ((fabs(rx) > threshold) || (fabs(ry) > threshold) ||
+      (fabs(rz) > threshold)) {
     InputEvent *inputEvent = new InputEventRotate(rx, ry, rz);
     InputDriverManager::instance()->postEvent(inputEvent);
     any = true;
@@ -145,7 +145,8 @@ bool InputEventMapper::generateDeferredEvents()
   double rxVPRel = getAxisValue(rotate[3]) * rotateVPRelGain;
   double ryVPRel = getAxisValue(rotate[4]) * rotateVPRelGain;
   double rzVPRel = getAxisValue(rotate[5]) * rotateVPRelGain;
-  if ((fabs(rxVPRel) > threshold) || (fabs(ryVPRel) > threshold) || (fabs(rzVPRel) > threshold)) {
+  if ((fabs(rxVPRel) > threshold) || (fabs(ryVPRel) > threshold) ||
+      (fabs(rzVPRel) > threshold)) {
     InputEvent *inputEvent = new InputEventRotate2(rxVPRel, ryVPRel, rzVPRel);
     InputDriverManager::instance()->postEvent(inputEvent);
     any = true;
@@ -161,26 +162,28 @@ bool InputEventMapper::generateDeferredEvents()
   return any;
 }
 
-void InputEventMapper::considerGeneratingDeferredEvents()
-{
+void InputEventMapper::considerGeneratingDeferredEvents() {
   if (!timer->isActive()) {
-    QMetaObject::invokeMethod(timer, "start", Qt::QueuedConnection, Q_ARG(int, 30));
+    QMetaObject::invokeMethod(timer, "start", Qt::QueuedConnection,
+                              Q_ARG(int, 30));
   }
 }
 
-void InputEventMapper::onTimer()
-{
+void InputEventMapper::onTimer() {
   bool generated_any_events = generateDeferredEvents();
 
-  //update the UI on time, NOT on event as a joystick can fire a high rate of events
+  // update the UI on time, NOT on event as a joystick can fire a high rate of
+  // events
   for (size_t i = 0; i < getMaxButtons(); ++i) {
     if (button_state[i] != button_state_last[i]) {
       button_state_last[i] = button_state[i];
-      GlobalPreferences::inst()->ButtonConfig->updateButtonState(i, button_state[i]);
+      GlobalPreferences::inst()->ButtonConfig->updateButtonState(
+          i, button_state[i]);
     }
   }
   for (size_t i = 0; i < getMaxAxis(); ++i) {
-    GlobalPreferences::inst()->AxisConfig->AxesChanged(i, axisRawValue[i] + axisTrimValue[i]);
+    GlobalPreferences::inst()->AxisConfig->AxesChanged(i, axisRawValue[i] +
+                                                              axisTrimValue[i]);
   }
 
   if (!generated_any_events) {
@@ -190,14 +193,12 @@ void InputEventMapper::onTimer()
   }
 }
 
-void InputEventMapper::onAxisChanged(InputEventAxisChanged *event)
-{
+void InputEventMapper::onAxisChanged(InputEventAxisChanged *event) {
   axisRawValue[event->axis] = event->value;
   considerGeneratingDeferredEvents();
 }
 
-void InputEventMapper::onButtonChanged(InputEventButtonChanged *event)
-{
+void InputEventMapper::onButtonChanged(InputEventButtonChanged *event) {
   unsigned int button = event->button;
 
   if (button < getMaxButtons()) {
@@ -220,51 +221,50 @@ void InputEventMapper::onButtonChanged(InputEventButtonChanged *event)
   considerGeneratingDeferredEvents();
 }
 
-void InputEventMapper::onTranslateEvent(InputEventTranslate *event)
-{
+void InputEventMapper::onTranslateEvent(InputEventTranslate *event) {
   InputDriverManager::instance()->postEvent(event);
 }
 
-void InputEventMapper::onRotateEvent(InputEventRotate *event)
-{
+void InputEventMapper::onRotateEvent(InputEventRotate *event) {
   InputDriverManager::instance()->postEvent(event);
 }
 
-void InputEventMapper::onRotate2Event(InputEventRotate2 *event)
-{
+void InputEventMapper::onRotate2Event(InputEventRotate2 *event) {
   InputDriverManager::instance()->postEvent(event);
 }
 
-void InputEventMapper::onActionEvent(InputEventAction *event)
-{
+void InputEventMapper::onActionEvent(InputEventAction *event) {
   InputDriverManager::instance()->postEvent(event);
 }
 
-void InputEventMapper::onZoomEvent(InputEventZoom *event)
-{
+void InputEventMapper::onZoomEvent(InputEventZoom *event) {
   InputDriverManager::instance()->postEvent(event);
 }
 
-int InputEventMapper::parseSettingValue(const std::string& val)
-{
+int InputEventMapper::parseSettingValue(const std::string &val) {
   if (val.length() != 2) {
     return 0;
   }
   return atoi(val.c_str());
 }
 
-void InputEventMapper::onInputMappingUpdated()
-{
+void InputEventMapper::onInputMappingUpdated() {
   for (size_t i = 0; i < getMaxButtons(); ++i) {
     actions[i] = QString::fromStdString(inputButtonSettings(i).value());
   }
 
-  translate[0] = parseSettingValue(Settings::Settings::inputTranslationX.value());
-  translate[1] = parseSettingValue(Settings::Settings::inputTranslationY.value());
-  translate[2] = parseSettingValue(Settings::Settings::inputTranslationZ.value());
-  translate[3] = parseSettingValue(Settings::Settings::inputTranslationXVPRel.value());
-  translate[4] = parseSettingValue(Settings::Settings::inputTranslationYVPRel.value());
-  translate[5] = parseSettingValue(Settings::Settings::inputTranslationZVPRel.value());
+  translate[0] =
+      parseSettingValue(Settings::Settings::inputTranslationX.value());
+  translate[1] =
+      parseSettingValue(Settings::Settings::inputTranslationY.value());
+  translate[2] =
+      parseSettingValue(Settings::Settings::inputTranslationZ.value());
+  translate[3] =
+      parseSettingValue(Settings::Settings::inputTranslationXVPRel.value());
+  translate[4] =
+      parseSettingValue(Settings::Settings::inputTranslationYVPRel.value());
+  translate[5] =
+      parseSettingValue(Settings::Settings::inputTranslationZVPRel.value());
   rotate[0] = parseSettingValue(Settings::Settings::inputRotateX.value());
   rotate[1] = parseSettingValue(Settings::Settings::inputRotateY.value());
   rotate[2] = parseSettingValue(Settings::Settings::inputRotateZ.value());
@@ -276,8 +276,7 @@ void InputEventMapper::onInputMappingUpdated()
   considerGeneratingDeferredEvents();
 }
 
-void InputEventMapper::onInputGainUpdated()
-{
+void InputEventMapper::onInputGainUpdated() {
   translationGain = Settings::Settings::inputTranslationGain.value();
   translationVPRelGain = Settings::Settings::inputTranslationVPRelGain.value();
   rotateGain = Settings::Settings::inputRotateGain.value();
@@ -287,8 +286,7 @@ void InputEventMapper::onInputGainUpdated()
   considerGeneratingDeferredEvents();
 }
 
-void InputEventMapper::onInputCalibrationUpdated()
-{
+void InputEventMapper::onInputCalibrationUpdated() {
   for (size_t i = 0; i < getMaxAxis(); ++i) {
     axisTrimValue[i] = axisTrimSettings(i).value();
     axisDeadzone[i] = axisDeadzoneSettings(i).value();
@@ -296,8 +294,7 @@ void InputEventMapper::onInputCalibrationUpdated()
   considerGeneratingDeferredEvents();
 }
 
-void InputEventMapper::onAxisAutoTrim()
-{
+void InputEventMapper::onAxisAutoTrim() {
   for (size_t i = 0; i < getMaxAxis(); ++i) {
     axisTrimValue[i] = -axisRawValue[i];
     axisTrimSettings(i).setValue(axisTrimValue[i]);
@@ -305,8 +302,7 @@ void InputEventMapper::onAxisAutoTrim()
   considerGeneratingDeferredEvents();
 }
 
-void InputEventMapper::onAxisTrimReset()
-{
+void InputEventMapper::onAxisTrimReset() {
   for (size_t i = 0; i < getMaxAxis(); ++i) {
     axisTrimValue[i] = 0.00;
     axisTrimSettings(i).setValue(axisTrimValue[i]);
@@ -314,44 +310,40 @@ void InputEventMapper::onAxisTrimReset()
   considerGeneratingDeferredEvents();
 }
 
-void InputEventMapper::stop(){
+void InputEventMapper::stop() {
   stopRequest = true;
   timer->stop();
 }
 
-Settings::SettingsEntryString& InputEventMapper::inputButtonSettings(size_t id)
-{
-  const std::array<Settings::SettingsEntryString *, getMaxButtons()> entries {
-    &S::inputButton0,  &S::inputButton1,  &S::inputButton2,  &S::inputButton3,
-    &S::inputButton4,  &S::inputButton5,  &S::inputButton6,  &S::inputButton7,
-    &S::inputButton8,  &S::inputButton9,  &S::inputButton10, &S::inputButton11,
-    &S::inputButton12, &S::inputButton13, &S::inputButton14, &S::inputButton15,
-    &S::inputButton16, &S::inputButton17, &S::inputButton18, &S::inputButton19,
-    &S::inputButton20, &S::inputButton21, &S::inputButton22, &S::inputButton23
-  };
+Settings::SettingsEntryString &
+InputEventMapper::inputButtonSettings(size_t id) {
+  const std::array<Settings::SettingsEntryString *, getMaxButtons()> entries{
+      &S::inputButton0,  &S::inputButton1,  &S::inputButton2,
+      &S::inputButton3,  &S::inputButton4,  &S::inputButton5,
+      &S::inputButton6,  &S::inputButton7,  &S::inputButton8,
+      &S::inputButton9,  &S::inputButton10, &S::inputButton11,
+      &S::inputButton12, &S::inputButton13, &S::inputButton14,
+      &S::inputButton15, &S::inputButton16, &S::inputButton17,
+      &S::inputButton18, &S::inputButton19, &S::inputButton20,
+      &S::inputButton21, &S::inputButton22, &S::inputButton23};
   assert(id >= 0 && id < entries.size());
   return *entries[id];
 }
 
-Settings::SettingsEntryDouble& InputEventMapper::axisTrimSettings(size_t id)
-{
-  const std::array<Settings::SettingsEntryDouble *, getMaxAxis()> entries {
-    &S::axisTrim0, &S::axisTrim1, &S::axisTrim2,
-    &S::axisTrim3, &S::axisTrim4, &S::axisTrim5,
-    &S::axisTrim6, &S::axisTrim7, &S::axisTrim8
-  };
+Settings::SettingsEntryDouble &InputEventMapper::axisTrimSettings(size_t id) {
+  const std::array<Settings::SettingsEntryDouble *, getMaxAxis()> entries{
+      &S::axisTrim0, &S::axisTrim1, &S::axisTrim2, &S::axisTrim3, &S::axisTrim4,
+      &S::axisTrim5, &S::axisTrim6, &S::axisTrim7, &S::axisTrim8};
   assert(id >= 0 && id < entries.size());
   return *entries[id];
 }
 
-Settings::SettingsEntryDouble& InputEventMapper::axisDeadzoneSettings(size_t id)
-{
-  const std::array<Settings::SettingsEntryDouble *, getMaxAxis()> entries {
-    &S::axisDeadzone0, &S::axisDeadzone1, &S::axisDeadzone2,
-    &S::axisDeadzone3, &S::axisDeadzone4, &S::axisDeadzone5,
-    &S::axisDeadzone6, &S::axisDeadzone7, &S::axisDeadzone8
-  };
+Settings::SettingsEntryDouble &
+InputEventMapper::axisDeadzoneSettings(size_t id) {
+  const std::array<Settings::SettingsEntryDouble *, getMaxAxis()> entries{
+      &S::axisDeadzone0, &S::axisDeadzone1, &S::axisDeadzone2,
+      &S::axisDeadzone3, &S::axisDeadzone4, &S::axisDeadzone5,
+      &S::axisDeadzone6, &S::axisDeadzone7, &S::axisDeadzone8};
   assert(id >= 0 && id < entries.size());
   return *entries[id];
 }
-
diff --git a/src/gui/input/InputEventMapper.h b/src/gui/input/InputEventMapper.h
index 6d53613a5..016c433f0 100644
--- a/src/gui/input/InputEventMapper.h
+++ b/src/gui/input/InputEventMapper.h
@@ -25,20 +25,21 @@
  */
 #pragma once
 
-#include <QTimer>
 #include <QObject>
+#include <QTimer>
 
-#include <cstddef>
-#include <string>
 #include "core/Settings.h"
 #include "gui/input/InputDriverEvent.h"
+#include <cstddef>
+#include <string>
 
-class InputEventMapper : public QObject, public InputEventHandler
-{
+class InputEventMapper : public QObject, public InputEventHandler {
   Q_OBJECT
 
 public:
-  constexpr static inline size_t getMaxButtons() { return Settings::max_buttons; }
+  constexpr static inline size_t getMaxButtons() {
+    return Settings::max_buttons;
+  }
   constexpr static inline size_t getMaxAxis() { return Settings::max_axis; }
 
 private:
@@ -55,7 +56,7 @@ private:
 
   double scale(double val);
   double getAxisValue(int config);
-  int parseSettingValue(const std::string& val);
+  int parseSettingValue(const std::string &val);
   bool generateDeferredEvents();
   void considerGeneratingDeferredEvents();
   bool button_state[Settings::max_buttons];
@@ -92,9 +93,9 @@ public:
 
   static InputEventMapper *instance();
 
-  static Settings::SettingsEntryString& inputButtonSettings(size_t id);
-  static Settings::SettingsEntryDouble& axisTrimSettings(size_t id);
-  static Settings::SettingsEntryDouble& axisDeadzoneSettings(size_t id);
+  static Settings::SettingsEntryString &inputButtonSettings(size_t id);
+  static Settings::SettingsEntryDouble &axisTrimSettings(size_t id);
+  static Settings::SettingsEntryDouble &axisDeadzoneSettings(size_t id);
 
 private slots:
   void onTimer();
diff --git a/src/gui/input/JoystickInputDriver.cc b/src/gui/input/JoystickInputDriver.cc
index 99b081567..5328b1276 100644
--- a/src/gui/input/JoystickInputDriver.cc
+++ b/src/gui/input/JoystickInputDriver.cc
@@ -25,22 +25,21 @@
  */
 #include "gui/input/JoystickInputDriver.h"
 
-#include <string>
+#include <boost/format.hpp>
 #include <fcntl.h>
-#include <sys/types.h>
+#include <string>
 #include <sys/stat.h>
-#include <boost/format.hpp>
+#include <sys/types.h>
 #include <utility>
 
 #include "gui/input/InputDriverManager.h"
 #include "utils/printutils.h"
 
-#include <unistd.h>
 #include <linux/input.h>
 #include <linux/joystick.h>
+#include <unistd.h>
 
-void JoystickInputDriver::run()
-{
+void JoystickInputDriver::run() {
   struct js_event js;
 
   while (!stopRequest) {
@@ -53,18 +52,19 @@ void JoystickInputDriver::run()
     }
     switch (js.type & ~JS_EVENT_INIT) {
     case JS_EVENT_BUTTON:
-      InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(js.number, js.value != 0));
+      InputDriverManager::instance()->sendEvent(
+          new InputEventButtonChanged(js.number, js.value != 0));
       break;
     case JS_EVENT_AXIS:
-      InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(js.number, js.value / 32767.0));
+      InputDriverManager::instance()->sendEvent(
+          new InputEventAxisChanged(js.number, js.value / 32767.0));
       break;
     }
   }
   ::close(fd);
 }
 
-bool JoystickInputDriver::open()
-{
+bool JoystickInputDriver::open() {
   stopRequest = false;
 
   auto path = boost::format("/dev/input/js%d") % this->nr;
@@ -88,28 +88,19 @@ bool JoystickInputDriver::open()
   return true;
 }
 
-void JoystickInputDriver::close()
-{
-  stopRequest = true;
-}
+void JoystickInputDriver::close() { stopRequest = true; }
 
-const std::string& JoystickInputDriver::get_name() const
-{
+const std::string &JoystickInputDriver::get_name() const {
   static std::string name = "JoystickInputDriver";
   return name;
 }
 
-std::string JoystickInputDriver::get_info() const
-{
-  return STR(
-    get_name(), " ", (isOpen() ? "open" : "not open"), " ",
-    "Name: ", name, " ",
-    "Axis: ", (int) axes, " ",
-    "Buttons: ", (int) buttons, " "
-    );
+std::string JoystickInputDriver::get_info() const {
+  return STR(get_name(), " ", (isOpen() ? "open" : "not open"), " ",
+             "Name: ", name, " ", "Axis: ", (int)axes, " ",
+             "Buttons: ", (int)buttons, " ");
 }
 
-void JoystickInputDriver::setJoystickNr(std::string jnr)
-{
+void JoystickInputDriver::setJoystickNr(std::string jnr) {
   this->nr = std::move(jnr);
 }
diff --git a/src/gui/input/JoystickInputDriver.h b/src/gui/input/JoystickInputDriver.h
index ebe97ce84..80928d771 100644
--- a/src/gui/input/JoystickInputDriver.h
+++ b/src/gui/input/JoystickInputDriver.h
@@ -30,23 +30,18 @@
 #include <cstddef>
 #include <string>
 
-class JoystickInputDriver : public InputDriver
-{
+class JoystickInputDriver : public InputDriver {
 public:
   JoystickInputDriver() = default;
   void run() override;
   bool open() override;
   void close() override;
-  const std::string& get_name() const override;
+  const std::string &get_name() const override;
   std::string get_info() const override;
   void setJoystickNr(std::string jnr);
 
-  size_t getButtonCount() const override {
-    return buttons;
-  }
-  size_t getAxisCount() const override {
-    return axes;
-  }
+  size_t getButtonCount() const override { return buttons; }
+  size_t getAxisCount() const override { return axes; }
 
 private:
   int fd{-1};
diff --git a/src/gui/input/QGamepadInputDriver.cc b/src/gui/input/QGamepadInputDriver.cc
index d2c27a7d2..2b8c84db6 100644
--- a/src/gui/input/QGamepadInputDriver.cc
+++ b/src/gui/input/QGamepadInputDriver.cc
@@ -30,16 +30,11 @@
 
 #include <string>
 
-void QGamepadInputDriver::run()
-{
-}
+void QGamepadInputDriver::run() {}
 
-QGamepadInputDriver::QGamepadInputDriver() : gamepad(nullptr)
-{
-}
+QGamepadInputDriver::QGamepadInputDriver() : gamepad(nullptr) {}
 
-bool QGamepadInputDriver::open()
-{
+bool QGamepadInputDriver::open() {
   if (gamepad) {
     return false;
   }
@@ -51,99 +46,137 @@ bool QGamepadInputDriver::open()
 
   this->gamepad.reset(new QGamepad(*gamepads.begin(), this));
 
-  connect(this->gamepad.get(), &QGamepad::axisLeftXChanged, this, [](double value){
-    InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(0, value));
-  });
-  connect(this->gamepad.get(), &QGamepad::axisLeftYChanged, this, [](double value){
-    InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(1, value));
-  });
-  connect(this->gamepad.get(), &QGamepad::axisRightXChanged, this, [](double value){
-    InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(2, value));
-  });
-  connect(this->gamepad.get(), &QGamepad::axisRightYChanged, this, [](double value){
-    InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(3, value));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonL2Changed, this, [](double value){
-    InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(4, value));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonR2Changed, this, [](double value){
-    InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(5, value));
-  });
-
-  connect(this->gamepad.get(), &QGamepad::buttonAChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(0, pressed));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonBChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(1, pressed));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonXChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(2, pressed));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonYChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(3, pressed));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonL1Changed, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(4, pressed));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonR1Changed, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(5, pressed));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonSelectChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(6, pressed));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonStartChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(7, pressed));
-  });
-
-  connect(this->gamepad.get(), &QGamepad::buttonL3Changed, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(8, pressed));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonR3Changed, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(9, pressed));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonCenterChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(10, pressed));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonUpChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(11, pressed));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonDownChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(12, pressed));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonLeftChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(13, pressed));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonRightChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(14, pressed));
-  });
-  connect(this->gamepad.get(), &QGamepad::buttonGuideChanged, this, [](bool pressed){
-    InputDriverManager::instance()->sendEvent(new InputEventButtonChanged(15, pressed));
-  });
+  connect(this->gamepad.get(), &QGamepad::axisLeftXChanged, this,
+          [](double value) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventAxisChanged(0, value));
+          });
+  connect(this->gamepad.get(), &QGamepad::axisLeftYChanged, this,
+          [](double value) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventAxisChanged(1, value));
+          });
+  connect(this->gamepad.get(), &QGamepad::axisRightXChanged, this,
+          [](double value) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventAxisChanged(2, value));
+          });
+  connect(this->gamepad.get(), &QGamepad::axisRightYChanged, this,
+          [](double value) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventAxisChanged(3, value));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonL2Changed, this,
+          [](double value) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventAxisChanged(4, value));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonR2Changed, this,
+          [](double value) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventAxisChanged(5, value));
+          });
+
+  connect(this->gamepad.get(), &QGamepad::buttonAChanged, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(0, pressed));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonBChanged, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(1, pressed));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonXChanged, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(2, pressed));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonYChanged, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(3, pressed));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonL1Changed, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(4, pressed));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonR1Changed, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(5, pressed));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonSelectChanged, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(6, pressed));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonStartChanged, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(7, pressed));
+          });
+
+  connect(this->gamepad.get(), &QGamepad::buttonL3Changed, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(8, pressed));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonR3Changed, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(9, pressed));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonCenterChanged, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(10, pressed));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonUpChanged, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(11, pressed));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonDownChanged, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(12, pressed));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonLeftChanged, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(13, pressed));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonRightChanged, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(14, pressed));
+          });
+  connect(this->gamepad.get(), &QGamepad::buttonGuideChanged, this,
+          [](bool pressed) {
+            InputDriverManager::instance()->sendEvent(
+                new InputEventButtonChanged(15, pressed));
+          });
 
   return true;
 }
 
-void QGamepadInputDriver::close()
-{
-  gamepad.reset();
-}
+void QGamepadInputDriver::close() { gamepad.reset(); }
 
-const std::string& QGamepadInputDriver::get_name() const
-{
+const std::string &QGamepadInputDriver::get_name() const {
   static std::string name = "QGamepadInputDriver";
   return name;
 }
 
-bool QGamepadInputDriver::isOpen() const
-{
+bool QGamepadInputDriver::isOpen() const {
   return this->gamepad ? this->gamepad->isConnected() : false;
 }
 
-std::string QGamepadInputDriver::get_info() const
-{
-  const auto status = isOpen()
-      ? std::string{"connected: "} + this->gamepad->name().toUtf8().constData()
-      : std::string{"not connected"};
+std::string QGamepadInputDriver::get_info() const {
+  const auto status = isOpen() ? std::string{"connected: "} +
+                                     this->gamepad->name().toUtf8().constData()
+                               : std::string{"not connected"};
 
   return get_name() + " " + status;
 }
diff --git a/src/gui/input/QGamepadInputDriver.h b/src/gui/input/QGamepadInputDriver.h
index a41fd425f..f605f1904 100644
--- a/src/gui/input/QGamepadInputDriver.h
+++ b/src/gui/input/QGamepadInputDriver.h
@@ -28,12 +28,11 @@
 #include "core/Settings.h"
 #include "gui/input/InputDriver.h"
 
+#include <QtGamepad/QGamepad>
 #include <cstddef>
 #include <string>
-#include <QtGamepad/QGamepad>
 
-class QGamepadInputDriver : public InputDriver
-{
+class QGamepadInputDriver : public InputDriver {
 public:
   QGamepadInputDriver();
   void run() override;
@@ -41,15 +40,11 @@ public:
   void close() override;
   bool isOpen() const override;
 
-  const std::string& get_name() const override;
+  const std::string &get_name() const override;
   std::string get_info() const override;
 
-  size_t getButtonCount() const override {
-    return Settings::max_buttons;
-  }
-  size_t getAxisCount() const override {
-    return Settings::max_axis;
-  }
+  size_t getButtonCount() const override { return Settings::max_buttons; }
+  size_t getAxisCount() const override { return Settings::max_axis; }
 
 private:
   std::unique_ptr<QGamepad> gamepad;
diff --git a/src/gui/input/SpaceNavInputDriver.cc b/src/gui/input/SpaceNavInputDriver.cc
index c55959c24..306635d3f 100644
--- a/src/gui/input/SpaceNavInputDriver.cc
+++ b/src/gui/input/SpaceNavInputDriver.cc
@@ -35,11 +35,10 @@
 
 #include <QThread>
 #include <spnav.h>
-#include <unistd.h>
 #include <string>
+#include <unistd.h>
 
-void SpaceNavInputDriver::run()
-{
+void SpaceNavInputDriver::run() {
   while (spnav_input()) {
     QThread::msleep(20);
     spnav_remove_events(SPNAV_EVENT_MOTION);
@@ -51,8 +50,7 @@ void SpaceNavInputDriver::run()
  * one event is available and then processes all events until the queue is
  * empty.
  */
-bool SpaceNavInputDriver::spnav_input()
-{
+bool SpaceNavInputDriver::spnav_input() {
   spnav_event ev;
 
   // The low level driver seems to inhibit events in the dead zone, so if we
@@ -83,63 +81,102 @@ bool SpaceNavInputDriver::spnav_input()
     if (ev.type == SPNAV_EVENT_MOTION) {
 #ifdef DEBUG
       if ((ev.motion.x != 0) || (ev.motion.y != 0) || (ev.motion.z != 0)) {
-        PRINTDB("Translate Event: x = %d, y = %d, z = %d", ev.motion.x % ev.motion.y % ev.motion.z);
+        PRINTDB("Translate Event: x = %d, y = %d, z = %d",
+                ev.motion.x % ev.motion.y % ev.motion.z);
       }
       if ((ev.motion.rx != 0) || (ev.motion.ry != 0) || (ev.motion.rz != 0)) {
-        PRINTDB("Rotate Event: rx = %d, ry = %d, rz = %d", ev.motion.rx % ev.motion.ry % ev.motion.rz);
+        PRINTDB("Rotate Event: rx = %d, ry = %d, rz = %d",
+                ev.motion.rx % ev.motion.ry % ev.motion.rz);
       }
 #endif
 
       if (this->dominantAxisOnly) {
         // dominant axis only
         int m = ev.motion.x;
-        if (abs(m) < abs(ev.motion.y)) m = ev.motion.y;
-        if (abs(m) < abs(ev.motion.z)) m = ev.motion.z;
-        if (abs(m) < abs(ev.motion.rx)) m = ev.motion.rx;
-        if (abs(m) < abs(ev.motion.ry)) m = ev.motion.ry;
-        if (abs(m) < abs(ev.motion.rz)) m = ev.motion.rz;
+        if (abs(m) < abs(ev.motion.y))
+          m = ev.motion.y;
+        if (abs(m) < abs(ev.motion.z))
+          m = ev.motion.z;
+        if (abs(m) < abs(ev.motion.rx))
+          m = ev.motion.rx;
+        if (abs(m) < abs(ev.motion.ry))
+          m = ev.motion.ry;
+        if (abs(m) < abs(ev.motion.rz))
+          m = ev.motion.rz;
 
         if (ev.motion.x == m) {
-          ev.motion.y = 0; ev.motion.z = 0; ev.motion.rx = 0; ev.motion.ry = 0; ev.motion.rz = 0;
+          ev.motion.y = 0;
+          ev.motion.z = 0;
+          ev.motion.rx = 0;
+          ev.motion.ry = 0;
+          ev.motion.rz = 0;
         }
         if (ev.motion.y == m) {
-          ev.motion.x = 0;                ev.motion.z = 0; ev.motion.rx = 0; ev.motion.ry = 0; ev.motion.rz = 0;
+          ev.motion.x = 0;
+          ev.motion.z = 0;
+          ev.motion.rx = 0;
+          ev.motion.ry = 0;
+          ev.motion.rz = 0;
         }
         if (ev.motion.z == m) {
-          ev.motion.x = 0; ev.motion.y = 0;                ev.motion.rx = 0; ev.motion.ry = 0; ev.motion.rz = 0;
+          ev.motion.x = 0;
+          ev.motion.y = 0;
+          ev.motion.rx = 0;
+          ev.motion.ry = 0;
+          ev.motion.rz = 0;
         }
         if (ev.motion.rx == m) {
-          ev.motion.x = 0; ev.motion.y = 0; ev.motion.z = 0;                 ev.motion.ry = 0; ev.motion.rz = 0;
+          ev.motion.x = 0;
+          ev.motion.y = 0;
+          ev.motion.z = 0;
+          ev.motion.ry = 0;
+          ev.motion.rz = 0;
         }
         if (ev.motion.ry == m) {
-          ev.motion.x = 0; ev.motion.y = 0; ev.motion.z = 0; ev.motion.rx = 0;                 ev.motion.rz = 0;
+          ev.motion.x = 0;
+          ev.motion.y = 0;
+          ev.motion.z = 0;
+          ev.motion.rx = 0;
+          ev.motion.rz = 0;
         }
         if (ev.motion.rz == m) {
-          ev.motion.x = 0; ev.motion.y = 0; ev.motion.z = 0; ev.motion.rx = 0; ev.motion.ry = 0;
+          ev.motion.x = 0;
+          ev.motion.y = 0;
+          ev.motion.z = 0;
+          ev.motion.rx = 0;
+          ev.motion.ry = 0;
         }
       }
 
       if (ev.motion.x != 0) {
-        InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(0, ev.motion.x / 500.0));
+        InputDriverManager::instance()->sendEvent(
+            new InputEventAxisChanged(0, ev.motion.x / 500.0));
       }
       if (ev.motion.y != 0) {
-        InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(1, ev.motion.y / 500.0));
+        InputDriverManager::instance()->sendEvent(
+            new InputEventAxisChanged(1, ev.motion.y / 500.0));
       }
       if (ev.motion.z != 0) {
-        InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(2, ev.motion.z / 500.0));
+        InputDriverManager::instance()->sendEvent(
+            new InputEventAxisChanged(2, ev.motion.z / 500.0));
       }
       if (ev.motion.rx != 0) {
-        InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(3, ev.motion.rx / 500.0));
+        InputDriverManager::instance()->sendEvent(
+            new InputEventAxisChanged(3, ev.motion.rx / 500.0));
       }
       if (ev.motion.ry != 0) {
-        InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(4, ev.motion.ry / 500.0));
+        InputDriverManager::instance()->sendEvent(
+            new InputEventAxisChanged(4, ev.motion.ry / 500.0));
       }
       if (ev.motion.rz != 0) {
-        InputDriverManager::instance()->sendEvent(new InputEventAxisChanged(5, ev.motion.rz / 500.0));
+        InputDriverManager::instance()->sendEvent(
+            new InputEventAxisChanged(5, ev.motion.rz / 500.0));
       }
     } else if (ev.type == SPNAV_EVENT_BUTTON) {
-      PRINTDB("Button Event: num = %d, %s", ev.button.bnum % (ev.button.press ? "pressed" : "released"));
-      InputEvent *event = new InputEventButtonChanged(ev.button.bnum, ev.button.press);
+      PRINTDB("Button Event: num = %d, %s",
+              ev.button.bnum % (ev.button.press ? "pressed" : "released"));
+      InputEvent *event =
+          new InputEventButtonChanged(ev.button.bnum, ev.button.press);
       InputDriverManager::instance()->sendEvent(event);
     }
   } while (spnav_poll_event(&ev));
@@ -147,8 +184,7 @@ bool SpaceNavInputDriver::spnav_input()
   return true;
 }
 
-bool SpaceNavInputDriver::open()
-{
+bool SpaceNavInputDriver::open() {
   if (spnav_open() < 0) {
     return false;
   }
@@ -156,22 +192,17 @@ bool SpaceNavInputDriver::open()
   return true;
 }
 
-void SpaceNavInputDriver::close()
-{
-
-}
+void SpaceNavInputDriver::close() {}
 
-void SpaceNavInputDriver::setDominantAxisOnly(bool var){
+void SpaceNavInputDriver::setDominantAxisOnly(bool var) {
   this->dominantAxisOnly = var;
 }
 
-const std::string& SpaceNavInputDriver::get_name() const
-{
+const std::string &SpaceNavInputDriver::get_name() const {
   static std::string name = "SpaceNavInputDriver";
   return name;
 }
 
-std::string SpaceNavInputDriver::get_info() const
-{
+std::string SpaceNavInputDriver::get_info() const {
   return STR(get_name(), " ", (isOpen() ? "open" : "not open"), " ");
 }
diff --git a/src/gui/input/SpaceNavInputDriver.h b/src/gui/input/SpaceNavInputDriver.h
index 58eca0585..2f5e7b6bf 100644
--- a/src/gui/input/SpaceNavInputDriver.h
+++ b/src/gui/input/SpaceNavInputDriver.h
@@ -26,13 +26,12 @@
 
 #pragma once
 
-#include <cstddef>
-#include <string>
 #include "core/Settings.h"
 #include "gui/input/InputDriver.h"
+#include <cstddef>
+#include <string>
 
-class SpaceNavInputDriver : public InputDriver
-{
+class SpaceNavInputDriver : public InputDriver {
   Q_OBJECT
 
 public:
@@ -42,15 +41,11 @@ public:
   void close() override;
   void setDominantAxisOnly(bool var);
 
-  const std::string& get_name() const override;
+  const std::string &get_name() const override;
   std::string get_info() const override;
 
-  size_t getButtonCount() const override {
-    return Settings::max_buttons;
-  }
-  size_t getAxisCount() const override {
-    return Settings::max_axis;
-  }
+  size_t getButtonCount() const override { return Settings::max_buttons; }
+  size_t getAxisCount() const override { return Settings::max_axis; }
 
 private:
   bool spnav_input();
diff --git a/src/gui/parameter/GroupWidget.cc b/src/gui/parameter/GroupWidget.cc
index 042167e9d..c018ea55c 100644
--- a/src/gui/parameter/GroupWidget.cc
+++ b/src/gui/parameter/GroupWidget.cc
@@ -1,13 +1,13 @@
 #include "gui/parameter/GroupWidget.h"
 
+#include <QLineEdit>
 #include <QObject>
 #include <QSizePolicy>
 #include <QString>
 #include <QWidget>
-#include <QLineEdit>
 
-GroupWidget::GroupWidget(const QString& title, QWidget *parent) : QWidget(parent)
-{
+GroupWidget::GroupWidget(const QString &title, QWidget *parent)
+    : QWidget(parent) {
   this->toggleButton.setText(title);
   this->toggleButton.setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Maximum);
   this->toggleButton.setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
@@ -28,16 +28,15 @@ GroupWidget::GroupWidget(const QString& title, QWidget *parent) : QWidget(parent
   setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Maximum);
   setLayout(&mainLayout);
 
-  QObject::connect(&toggleButton, &QToolButton::toggled, this, &GroupWidget::setExpanded);
+  QObject::connect(&toggleButton, &QToolButton::toggled, this,
+                   &GroupWidget::setExpanded);
 }
 
-void GroupWidget::addWidget(QWidget *widget)
-{
+void GroupWidget::addWidget(QWidget *widget) {
   contentLayout.addWidget(widget);
 }
 
-void GroupWidget::setExpanded(bool expanded)
-{
+void GroupWidget::setExpanded(bool expanded) {
   toggleButton.setChecked(expanded);
   toggleButton.setArrowType(expanded ? Qt::DownArrow : Qt::RightArrow);
   if (expanded) {
diff --git a/src/gui/parameter/GroupWidget.h b/src/gui/parameter/GroupWidget.h
index 86cba49e1..a2f0e23d9 100644
--- a/src/gui/parameter/GroupWidget.h
+++ b/src/gui/parameter/GroupWidget.h
@@ -1,13 +1,12 @@
 #pragma once
 
-#include <QString>
 #include <QGridLayout>
+#include <QString>
 #include <QToolButton>
 #include <QVBoxLayout>
 #include <QWidget>
 
-class GroupWidget : public QWidget
-{
+class GroupWidget : public QWidget {
   Q_OBJECT
 private:
   QGridLayout mainLayout;
@@ -16,7 +15,7 @@ private:
   QVBoxLayout contentLayout;
 
 public:
-  GroupWidget(const QString& title, QWidget *parent = nullptr);
+  GroupWidget(const QString &title, QWidget *parent = nullptr);
   void addWidget(QWidget *widget);
 
   bool isExpanded() const { return toggleButton.isChecked(); }
diff --git a/src/gui/parameter/ParameterCheckBox.cc b/src/gui/parameter/ParameterCheckBox.cc
index 6f11edad2..e29dae577 100644
--- a/src/gui/parameter/ParameterCheckBox.cc
+++ b/src/gui/parameter/ParameterCheckBox.cc
@@ -1,29 +1,25 @@
-#include <QWidget>
 #include "gui/parameter/ParameterCheckBox.h"
+#include <QWidget>
 
-ParameterCheckBox::ParameterCheckBox(QWidget *parent, BoolParameter *parameter, DescriptionStyle descriptionStyle) :
-  ParameterVirtualWidget(parent, parameter),
-  parameter(parameter)
-{
+ParameterCheckBox::ParameterCheckBox(QWidget *parent, BoolParameter *parameter,
+                                     DescriptionStyle descriptionStyle)
+    : ParameterVirtualWidget(parent, parameter), parameter(parameter) {
   setupUi(this);
   descriptionWidget->setDescription(parameter, descriptionStyle);
 
   if (descriptionStyle == DescriptionStyle::ShowDetails) {
-    //large checkbox, when we have the space
-    checkBox->setStyleSheet("QCheckBox::indicator { width: 20px; height: 20px; } QCheckBox { spacing: 0px; }");
+    // large checkbox, when we have the space
+    checkBox->setStyleSheet("QCheckBox::indicator { width: 20px; height: 20px; "
+                            "} QCheckBox { spacing: 0px; }");
   }
 
   connect(checkBox, &QCheckBox::clicked, this, &ParameterCheckBox::onChanged);
   ParameterCheckBox::setValue();
 }
 
-void ParameterCheckBox::onChanged()
-{
+void ParameterCheckBox::onChanged() {
   parameter->value = checkBox->isChecked();
   emit changed(true);
 }
 
-void ParameterCheckBox::setValue()
-{
-  checkBox->setChecked(parameter->value);
-}
+void ParameterCheckBox::setValue() { checkBox->setChecked(parameter->value); }
diff --git a/src/gui/parameter/ParameterCheckBox.h b/src/gui/parameter/ParameterCheckBox.h
index 55c8078d3..9efcf3010 100644
--- a/src/gui/parameter/ParameterCheckBox.h
+++ b/src/gui/parameter/ParameterCheckBox.h
@@ -1,15 +1,15 @@
 #pragma once
 
 #include "gui/parameter/ParameterVirtualWidget.h"
-#include <QWidget>
 #include "ui_ParameterCheckBox.h"
+#include <QWidget>
 
-class ParameterCheckBox : public ParameterVirtualWidget, Ui::ParameterCheckBox
-{
+class ParameterCheckBox : public ParameterVirtualWidget, Ui::ParameterCheckBox {
   Q_OBJECT
 
 public:
-  ParameterCheckBox(QWidget *parent, BoolParameter *parameter, DescriptionStyle descriptionStyle);
+  ParameterCheckBox(QWidget *parent, BoolParameter *parameter,
+                    DescriptionStyle descriptionStyle);
   void setValue() override;
 
 protected slots:
diff --git a/src/gui/parameter/ParameterComboBox.cc b/src/gui/parameter/ParameterComboBox.cc
index 9d6fc286a..1c5c5beeb 100644
--- a/src/gui/parameter/ParameterComboBox.cc
+++ b/src/gui/parameter/ParameterComboBox.cc
@@ -1,35 +1,33 @@
 #include "gui/parameter/ParameterComboBox.h"
+#include "gui/IgnoreWheelWhenNotFocused.h"
 #include <QString>
 #include <QWidget>
-#include "gui/IgnoreWheelWhenNotFocused.h"
 
-ParameterComboBox::ParameterComboBox(QWidget *parent, EnumParameter *parameter, DescriptionStyle descriptionStyle) :
-  ParameterVirtualWidget(parent, parameter),
-  parameter(parameter)
-{
+ParameterComboBox::ParameterComboBox(QWidget *parent, EnumParameter *parameter,
+                                     DescriptionStyle descriptionStyle)
+    : ParameterVirtualWidget(parent, parameter), parameter(parameter) {
   setupUi(this);
   descriptionWidget->setDescription(parameter, descriptionStyle);
 
   auto *ignoreWheelWhenNotFocused = new IgnoreWheelWhenNotFocused(this);
   comboBox->installEventFilter(ignoreWheelWhenNotFocused);
 
-  for (const auto& item : parameter->items) {
+  for (const auto &item : parameter->items) {
     comboBox->addItem(QString::fromStdString(item.key));
   }
 
-  connect(comboBox, QOverload<int>::of(&QComboBox::activated), this, &ParameterComboBox::onChanged);
+  connect(comboBox, QOverload<int>::of(&QComboBox::activated), this,
+          &ParameterComboBox::onChanged);
   ParameterComboBox::setValue();
 }
 
-void ParameterComboBox::onChanged(int index)
-{
+void ParameterComboBox::onChanged(int index) {
   if (parameter->valueIndex != index) {
     parameter->valueIndex = index;
     emit changed(true);
   }
 }
 
-void ParameterComboBox::setValue()
-{
+void ParameterComboBox::setValue() {
   comboBox->setCurrentIndex(parameter->valueIndex);
 }
diff --git a/src/gui/parameter/ParameterComboBox.h b/src/gui/parameter/ParameterComboBox.h
index 387f8f4af..cad3de7d3 100644
--- a/src/gui/parameter/ParameterComboBox.h
+++ b/src/gui/parameter/ParameterComboBox.h
@@ -1,15 +1,15 @@
 #pragma once
 
 #include "gui/parameter/ParameterVirtualWidget.h"
-#include <QWidget>
 #include "ui_ParameterComboBox.h"
+#include <QWidget>
 
-class ParameterComboBox : public ParameterVirtualWidget, Ui::ParameterComboBox
-{
+class ParameterComboBox : public ParameterVirtualWidget, Ui::ParameterComboBox {
   Q_OBJECT
 
 public:
-  ParameterComboBox(QWidget *parent, EnumParameter *parameter, DescriptionStyle descriptionStyle);
+  ParameterComboBox(QWidget *parent, EnumParameter *parameter,
+                    DescriptionStyle descriptionStyle);
   void setValue() override;
 
 protected slots:
diff --git a/src/gui/parameter/ParameterSlider.cc b/src/gui/parameter/ParameterSlider.cc
index 46d26604c..4ed6ba783 100644
--- a/src/gui/parameter/ParameterSlider.cc
+++ b/src/gui/parameter/ParameterSlider.cc
@@ -1,14 +1,13 @@
 #include "gui/parameter/ParameterSlider.h"
+#include "gui/IgnoreWheelWhenNotFocused.h"
 #include <QWidget>
-#include <cmath>
 #include <cassert>
+#include <cmath>
 #include <limits>
-#include "gui/IgnoreWheelWhenNotFocused.h"
 
-ParameterSlider::ParameterSlider(QWidget *parent, NumberParameter *parameter, DescriptionStyle descriptionStyle) :
-  ParameterVirtualWidget(parent, parameter),
-  parameter(parameter)
-{
+ParameterSlider::ParameterSlider(QWidget *parent, NumberParameter *parameter,
+                                 DescriptionStyle descriptionStyle)
+    : ParameterVirtualWidget(parent, parameter), parameter(parameter) {
   setupUi(this);
   descriptionWidget->setDescription(parameter, descriptionStyle);
 
@@ -24,23 +23,23 @@ ParameterSlider::ParameterSlider(QWidget *parent, NumberParameter *parameter, De
   this->minimum = *parameter->minimum;
   if (parameter->step) {
     this->step = *parameter->step;
-    decimals = decimalsRequired({
-      this->minimum,
-      parameter->defaultValue,
-      this->step
-    });
+    decimals =
+        decimalsRequired({this->minimum, parameter->defaultValue, this->step});
   } else {
-    decimals = decimalsRequired({
-      this->minimum,
-      parameter->defaultValue
-    });
+    decimals = decimalsRequired({this->minimum, parameter->defaultValue});
     this->step = pow(0.1, decimals);
   }
 
-  static constexpr auto maxSteps = static_cast<double>(std::numeric_limits<int>::max());
-  // Use nextafter to compensate for possible floating point inaccurary where result is just below a whole number.
-  double tempSteps = std::nextafter((*parameter->maximum - this->minimum) / this->step, maxSteps) + 1.0;
-  int numSteps = tempSteps >= maxSteps ? std::numeric_limits<int>::max() : static_cast<int>(tempSteps);
+  static constexpr auto maxSteps =
+      static_cast<double>(std::numeric_limits<int>::max());
+  // Use nextafter to compensate for possible floating point inaccurary where
+  // result is just below a whole number.
+  double tempSteps =
+      std::nextafter((*parameter->maximum - this->minimum) / this->step,
+                     maxSteps) +
+      1.0;
+  int numSteps = tempSteps >= maxSteps ? std::numeric_limits<int>::max()
+                                       : static_cast<int>(tempSteps);
   // Truncate end value to full steps, same as Thingiverse customizer.
   // This also makes sure the step size of the spin box does not go to
   // invalid values.
@@ -52,35 +51,32 @@ ParameterSlider::ParameterSlider(QWidget *parent, NumberParameter *parameter, De
   doubleSpinBox->setRange(this->minimum, maximumValue);
   doubleSpinBox->setSingleStep(this->step);
 
-  //connect(slider, &QSlider::sliderPressed, this, &ParameterSlider::onSliderPressed);
-  connect(slider, &QSlider::sliderReleased, this, &ParameterSlider::onSliderReleased);
+  // connect(slider, &QSlider::sliderPressed, this,
+  // &ParameterSlider::onSliderPressed);
+  connect(slider, &QSlider::sliderReleased, this,
+          &ParameterSlider::onSliderReleased);
   connect(slider, &QSlider::sliderMoved, this, &ParameterSlider::onSliderMoved);
-  connect(slider, &QSlider::valueChanged, this, &ParameterSlider::onSliderChanged);
+  connect(slider, &QSlider::valueChanged, this,
+          &ParameterSlider::onSliderChanged);
 
-  connect(doubleSpinBox, QOverload<double>::of(&QDoubleSpinBox::valueChanged), this, &ParameterSlider::onSpinBoxChanged);
-  connect(doubleSpinBox, &QDoubleSpinBox::editingFinished, this, &ParameterSlider::onSpinBoxEditingFinished);
+  connect(doubleSpinBox, QOverload<double>::of(&QDoubleSpinBox::valueChanged),
+          this, &ParameterSlider::onSpinBoxChanged);
+  connect(doubleSpinBox, &QDoubleSpinBox::editingFinished, this,
+          &ParameterSlider::onSpinBoxEditingFinished);
 
   ParameterSlider::setValue();
 }
 
-void ParameterSlider::valueApplied() {
-  lastApplied = lastSent;
-}
+void ParameterSlider::valueApplied() { lastApplied = lastSent; }
 
 // slider handle grabbed
-void ParameterSlider::onSliderPressed()
-{
-}
+void ParameterSlider::onSliderPressed() {}
 
 // slider handle released
-void ParameterSlider::onSliderReleased()
-{
-  this->commitChange(true);
-}
+void ParameterSlider::onSliderReleased() { this->commitChange(true); }
 
 // slider handle dragged
-void ParameterSlider::onSliderMoved(int position)
-{
+void ParameterSlider::onSliderMoved(int position) {
   double value = parameterValue(position);
   doubleSpinBox->blockSignals(true);
   doubleSpinBox->setValue(value);
@@ -88,9 +84,9 @@ void ParameterSlider::onSliderMoved(int position)
 }
 
 // slider track clicked
-// changes by pageStep or sets absolute position, depending on platform or specific mouse button
-void ParameterSlider::onSliderChanged(int position)
-{
+// changes by pageStep or sets absolute position, depending on platform or
+// specific mouse button
+void ParameterSlider::onSliderChanged(int position) {
   double value = parameterValue(position);
   doubleSpinBox->blockSignals(true);
   doubleSpinBox->setValue(value);
@@ -99,8 +95,7 @@ void ParameterSlider::onSliderChanged(int position)
 }
 
 // spin button click or arrow keypress
-void ParameterSlider::onSpinBoxChanged(double value)
-{
+void ParameterSlider::onSpinBoxChanged(double value) {
   int position = sliderPosition(value);
   slider->blockSignals(true);
   slider->setValue(position);
@@ -109,39 +104,36 @@ void ParameterSlider::onSpinBoxChanged(double value)
 }
 
 // Enter key pressed or spinbox focus lost
-void ParameterSlider::onSpinBoxEditingFinished()
-{
-  commitChange(true);
-}
+void ParameterSlider::onSpinBoxEditingFinished() { commitChange(true); }
 
 void ParameterSlider::commitChange(bool immediate) {
   double value = parameterValue(slider->sliderPosition());
 #ifdef DEBUG
-  PRINTD(STR("[commit] value=", value, ", parameter->value=", parameter->value, ", lastSent=", lastSent, ", lastApplied=", lastApplied));
+  PRINTD(STR("[commit] value=", value, ", parameter->value=", parameter->value,
+             ", lastSent=", lastSent, ", lastApplied=", lastApplied));
 #endif
-  if ((immediate && lastApplied != value) || (!immediate && lastSent != value) ) {
+  if ((immediate && lastApplied != value) ||
+      (!immediate && lastSent != value)) {
     lastSent = parameter->value = value;
     emit changed(immediate);
   }
 }
 
 // Called when populating parameter presets
-void ParameterSlider::setValue()
-{
+void ParameterSlider::setValue() {
 #ifdef DEBUG
-  PRINTD(STR("[setValue] parameter->value=", parameter->value, ", lastSent=", lastSent, ", lastApplied=", lastApplied));
+  PRINTD(STR("[setValue] parameter->value=", parameter->value,
+             ", lastSent=", lastSent, ", lastApplied=", lastApplied));
 #endif
   int position = sliderPosition(parameter->value);
   lastApplied = lastSent = parameter->value;
   slider->setValue(position);
 }
 
-int ParameterSlider::sliderPosition(double value)
-{
+int ParameterSlider::sliderPosition(double value) {
   return static_cast<int>(std::round((value - this->minimum) / this->step));
 }
 
-double ParameterSlider::parameterValue(int sliderPosition)
-{
+double ParameterSlider::parameterValue(int sliderPosition) {
   return this->minimum + sliderPosition * this->step;
 }
diff --git a/src/gui/parameter/ParameterSlider.h b/src/gui/parameter/ParameterSlider.h
index a92e5ed48..b7b5c579f 100644
--- a/src/gui/parameter/ParameterSlider.h
+++ b/src/gui/parameter/ParameterSlider.h
@@ -1,15 +1,15 @@
 #pragma once
 
 #include "gui/parameter/ParameterVirtualWidget.h"
-#include <QWidget>
 #include "ui_ParameterSlider.h"
+#include <QWidget>
 
-class ParameterSlider : public ParameterVirtualWidget, Ui::ParameterSlider
-{
+class ParameterSlider : public ParameterVirtualWidget, Ui::ParameterSlider {
   Q_OBJECT
 
 public:
-  ParameterSlider(QWidget *parent, NumberParameter *parameter, DescriptionStyle descriptionStyle);
+  ParameterSlider(QWidget *parent, NumberParameter *parameter,
+                  DescriptionStyle descriptionStyle);
   void setValue() override;
   void valueApplied() override;
 
diff --git a/src/gui/parameter/ParameterSpinBox.cc b/src/gui/parameter/ParameterSpinBox.cc
index 61edc37d9..0c8d93565 100644
--- a/src/gui/parameter/ParameterSpinBox.cc
+++ b/src/gui/parameter/ParameterSpinBox.cc
@@ -1,13 +1,12 @@
 #include "gui/parameter/ParameterSpinBox.h"
+#include "gui/IgnoreWheelWhenNotFocused.h"
 #include <QWidget>
 #include <algorithm>
 #include <limits>
-#include "gui/IgnoreWheelWhenNotFocused.h"
 
-ParameterSpinBox::ParameterSpinBox(QWidget *parent, NumberParameter *parameter, DescriptionStyle descriptionStyle) :
-  ParameterVirtualWidget(parent, parameter),
-  parameter(parameter)
-{
+ParameterSpinBox::ParameterSpinBox(QWidget *parent, NumberParameter *parameter,
+                                   DescriptionStyle descriptionStyle)
+    : ParameterVirtualWidget(parent, parameter), parameter(parameter) {
   setupUi(this);
   descriptionWidget->setDescription(parameter, descriptionStyle);
 
@@ -45,19 +44,19 @@ ParameterSpinBox::ParameterSpinBox(QWidget *parent, NumberParameter *parameter,
   doubleSpinBox->setRange(minimum, maximum);
   doubleSpinBox->setSingleStep(step);
 
-  connect(doubleSpinBox, QOverload<double>::of(&QDoubleSpinBox::valueChanged), this, &ParameterSpinBox::onChanged);
-  connect(doubleSpinBox, &QDoubleSpinBox::editingFinished, this, &ParameterSpinBox::onEditingFinished);
+  connect(doubleSpinBox, QOverload<double>::of(&QDoubleSpinBox::valueChanged),
+          this, &ParameterSpinBox::onChanged);
+  connect(doubleSpinBox, &QDoubleSpinBox::editingFinished, this,
+          &ParameterSpinBox::onEditingFinished);
   ParameterSpinBox::setValue();
 }
 
-void ParameterSpinBox::valueApplied() {
-  lastApplied = lastSent;
-}
+void ParameterSpinBox::valueApplied() { lastApplied = lastSent; }
 
-void ParameterSpinBox::onChanged(double value)
-{
+void ParameterSpinBox::onChanged(double value) {
 #ifdef DEBUG
-  PRINTD(STR("[changed] value=", value, ", parameter->value=", parameter->value, ", lastSent=", lastSent, ", lastApplied=", lastApplied));
+  PRINTD(STR("[changed] value=", value, ", parameter->value=", parameter->value,
+             ", lastSent=", lastSent, ", lastApplied=", lastApplied));
 #endif
   parameter->value = value;
   if (lastSent != value) {
@@ -66,10 +65,10 @@ void ParameterSpinBox::onChanged(double value)
   }
 }
 
-void ParameterSpinBox::onEditingFinished()
-{
+void ParameterSpinBox::onEditingFinished() {
 #ifdef DEBUG
-  PRINTD(STR("[finished] parameter->value=", parameter->value, ", lastSent=", lastSent, ", lastApplied=", lastApplied));
+  PRINTD(STR("[finished] parameter->value=", parameter->value,
+             ", lastSent=", lastSent, ", lastApplied=", lastApplied));
 #endif
   if (lastApplied != parameter->value) {
     lastSent = parameter->value;
@@ -77,8 +76,7 @@ void ParameterSpinBox::onEditingFinished()
   }
 }
 
-void ParameterSpinBox::setValue()
-{
+void ParameterSpinBox::setValue() {
   lastApplied = lastSent = parameter->value;
   doubleSpinBox->setValue(parameter->value);
 }
diff --git a/src/gui/parameter/ParameterSpinBox.h b/src/gui/parameter/ParameterSpinBox.h
index 5a39dc80c..7d2dd759d 100644
--- a/src/gui/parameter/ParameterSpinBox.h
+++ b/src/gui/parameter/ParameterSpinBox.h
@@ -1,15 +1,15 @@
 #pragma once
 
 #include "gui/parameter/ParameterVirtualWidget.h"
-#include <QWidget>
 #include "ui_ParameterSpinBox.h"
+#include <QWidget>
 
-class ParameterSpinBox : public ParameterVirtualWidget, Ui::ParameterSpinBox
-{
+class ParameterSpinBox : public ParameterVirtualWidget, Ui::ParameterSpinBox {
   Q_OBJECT
 
 public:
-  ParameterSpinBox(QWidget *parent, NumberParameter *parameter, DescriptionStyle descriptionStyle);
+  ParameterSpinBox(QWidget *parent, NumberParameter *parameter,
+                   DescriptionStyle descriptionStyle);
   void setValue() override;
   void valueApplied() override;
 
@@ -21,5 +21,4 @@ private:
   NumberParameter *parameter;
   boost::optional<double> lastSent;
   boost::optional<double> lastApplied;
-
 };
diff --git a/src/gui/parameter/ParameterText.cc b/src/gui/parameter/ParameterText.cc
index 65c731c8b..4732a1105 100644
--- a/src/gui/parameter/ParameterText.cc
+++ b/src/gui/parameter/ParameterText.cc
@@ -4,10 +4,9 @@
 #include <QWidget>
 #include <string>
 
-ParameterText::ParameterText(QWidget *parent, StringParameter *parameter, DescriptionStyle descriptionStyle) :
-  ParameterVirtualWidget(parent, parameter),
-  parameter(parameter)
-{
+ParameterText::ParameterText(QWidget *parent, StringParameter *parameter,
+                             DescriptionStyle descriptionStyle)
+    : ParameterVirtualWidget(parent, parameter), parameter(parameter) {
   setupUi(this);
   descriptionWidget->setDescription(parameter, descriptionStyle);
 
@@ -16,16 +15,14 @@ ParameterText::ParameterText(QWidget *parent, StringParameter *parameter, Descri
   }
 
   connect(lineEdit, &QLineEdit::textEdited, this, &ParameterText::onEdit);
-  connect(lineEdit, &QLineEdit::editingFinished, this, &ParameterText::onEditingFinished);
+  connect(lineEdit, &QLineEdit::editingFinished, this,
+          &ParameterText::onEditingFinished);
   ParameterText::setValue();
 }
 
-void ParameterText::valueApplied() {
-  lastApplied = lastSent;
-}
+void ParameterText::valueApplied() { lastApplied = lastSent; }
 
-void ParameterText::onEdit(const QString& text)
-{
+void ParameterText::onEdit(const QString &text) {
 #ifdef DEBUG
   PRINTD("edit");
 #endif
@@ -46,8 +43,7 @@ void ParameterText::onEditingFinished() {
   }
 }
 
-void ParameterText::setValue()
-{
+void ParameterText::setValue() {
   lastApplied = lastSent = parameter->value;
   lineEdit->setText(QString::fromStdString(parameter->value));
 }
diff --git a/src/gui/parameter/ParameterText.h b/src/gui/parameter/ParameterText.h
index 729a04ef0..fb65d669e 100644
--- a/src/gui/parameter/ParameterText.h
+++ b/src/gui/parameter/ParameterText.h
@@ -7,17 +7,17 @@
 #include <QWidget>
 #include <string>
 
-class ParameterText : public ParameterVirtualWidget, Ui::ParameterText
-{
+class ParameterText : public ParameterVirtualWidget, Ui::ParameterText {
   Q_OBJECT
 
 public:
-  ParameterText(QWidget *parent, StringParameter *parameter, DescriptionStyle descriptionStyle);
+  ParameterText(QWidget *parent, StringParameter *parameter,
+                DescriptionStyle descriptionStyle);
   void setValue() override;
   void valueApplied() override;
 
 protected slots:
-  void onEdit(const QString& text);
+  void onEdit(const QString &text);
   void onEditingFinished();
 
 private:
diff --git a/src/gui/parameter/ParameterVector.cc b/src/gui/parameter/ParameterVector.cc
index 8e390fbb3..e76c25a77 100644
--- a/src/gui/parameter/ParameterVector.cc
+++ b/src/gui/parameter/ParameterVector.cc
@@ -1,16 +1,15 @@
 #include "gui/parameter/ParameterVector.h"
 
+#include "gui/IgnoreWheelWhenNotFocused.h"
 #include <QWidget>
 #include <algorithm>
 #include <cassert>
-#include <limits>
 #include <cstddef>
-#include "gui/IgnoreWheelWhenNotFocused.h"
+#include <limits>
 
-ParameterVector::ParameterVector(QWidget *parent, VectorParameter *parameter, DescriptionStyle descriptionStyle) :
-  ParameterVirtualWidget(parent, parameter),
-  parameter(parameter)
-{
+ParameterVector::ParameterVector(QWidget *parent, VectorParameter *parameter,
+                                 DescriptionStyle descriptionStyle)
+    : ParameterVirtualWidget(parent, parameter), parameter(parameter) {
   setupUi(this);
   descriptionWidget->setDescription(parameter, descriptionStyle);
 
@@ -38,9 +37,10 @@ ParameterVector::ParameterVector(QWidget *parent, VectorParameter *parameter, De
     doubleSpinBox4->hide();
   }
 
-  // clang generates a bogus warning that ignoreWheelWhenNotFocused may be leaked
-  // NOLINTBEGIN(*NewDeleteLeaks)
-  if (spinboxes.size() > 0) { // only allocate if there are spinboxes to use the function
+  // clang generates a bogus warning that ignoreWheelWhenNotFocused may be
+  // leaked NOLINTBEGIN(*NewDeleteLeaks)
+  if (spinboxes.size() >
+      0) { // only allocate if there are spinboxes to use the function
     // The parent (this) takes ownership of the object
     auto *ignoreWheelWhenNotFocused = new IgnoreWheelWhenNotFocused(this);
     for (auto spinbox : spinboxes) {
@@ -80,19 +80,18 @@ ParameterVector::ParameterVector(QWidget *parent, VectorParameter *parameter, De
     spinbox->setRange(minimum, maximum);
     spinbox->setSingleStep(step);
     spinbox->show();
-    connect(spinbox, QOverload<double>::of(&QDoubleSpinBox::valueChanged), this, &ParameterVector::onChanged);
-    connect(spinbox, &QDoubleSpinBox::editingFinished, this, &ParameterVector::onEditingFinished);
+    connect(spinbox, QOverload<double>::of(&QDoubleSpinBox::valueChanged), this,
+            &ParameterVector::onChanged);
+    connect(spinbox, &QDoubleSpinBox::editingFinished, this,
+            &ParameterVector::onEditingFinished);
   }
 
   ParameterVector::setValue();
 }
 
-void ParameterVector::valueApplied() {
-  lastApplied = lastSent;
-}
+void ParameterVector::valueApplied() { lastApplied = lastSent; }
 
-void ParameterVector::onChanged()
-{
+void ParameterVector::onChanged() {
   for (size_t i = 0; i < spinboxes.size(); i++) {
     parameter->value[i] = spinboxes[i]->value();
   }
@@ -102,16 +101,14 @@ void ParameterVector::onChanged()
   }
 }
 
-void ParameterVector::onEditingFinished()
-{
+void ParameterVector::onEditingFinished() {
   if (lastApplied != parameter->value) {
     lastSent = parameter->value;
     emit changed(true);
   }
 }
 
-void ParameterVector::setValue()
-{
+void ParameterVector::setValue() {
 #ifdef DEBUG
   PRINTD("setValue");
 #endif
diff --git a/src/gui/parameter/ParameterVector.h b/src/gui/parameter/ParameterVector.h
index b24372aad..50bcc7266 100644
--- a/src/gui/parameter/ParameterVector.h
+++ b/src/gui/parameter/ParameterVector.h
@@ -7,12 +7,12 @@
 #include <QWidget>
 #include <vector>
 
-class ParameterVector : public ParameterVirtualWidget, Ui::ParameterVector
-{
+class ParameterVector : public ParameterVirtualWidget, Ui::ParameterVector {
   Q_OBJECT
 
 public:
-  ParameterVector(QWidget *parent, VectorParameter *parameter, DescriptionStyle descriptionStyle);
+  ParameterVector(QWidget *parent, VectorParameter *parameter,
+                  DescriptionStyle descriptionStyle);
   void setValue() override;
   void valueApplied() override;
 
diff --git a/src/gui/parameter/ParameterVirtualWidget.cc b/src/gui/parameter/ParameterVirtualWidget.cc
index 0f38e6607..9f2e686e1 100644
--- a/src/gui/parameter/ParameterVirtualWidget.cc
+++ b/src/gui/parameter/ParameterVirtualWidget.cc
@@ -1,22 +1,22 @@
 #include "gui/parameter/ParameterVirtualWidget.h"
 
+#include <QRegularExpression>
 #include <QSizePolicy>
 #include <QWidget>
 #include <algorithm>
-#include <cmath>
 #include <cassert>
-#include <QRegularExpression>
+#include <cmath>
 #include <vector>
 
-ParameterDescriptionWidget::ParameterDescriptionWidget(QWidget *parent) :
-  QWidget(parent)
-{
+ParameterDescriptionWidget::ParameterDescriptionWidget(QWidget *parent)
+    : QWidget(parent) {
   setupUi(this);
 }
 
-void ParameterDescriptionWidget::setDescription(ParameterObject *parameter, DescriptionStyle descriptionStyle)
-{
-  labelParameter->setText(QString::fromStdString(parameter->name()).replace(QRegularExpression("([_]+)"), " "));
+void ParameterDescriptionWidget::setDescription(
+    ParameterObject *parameter, DescriptionStyle descriptionStyle) {
+  labelParameter->setText(QString::fromStdString(parameter->name())
+                              .replace(QRegularExpression("([_]+)"), " "));
   if (parameter->description().empty()) {
     labelDescription->hide();
     labelInline->setText("");
@@ -25,7 +25,8 @@ void ParameterDescriptionWidget::setDescription(ParameterObject *parameter, Desc
     labelInline->setText("");
   } else if (descriptionStyle == DescriptionStyle::Inline) {
     labelDescription->hide();
-    labelInline->setText(QString(" - ") + QString::fromStdString(parameter->description()));
+    labelInline->setText(QString(" - ") +
+                         QString::fromStdString(parameter->description()));
   } else if (descriptionStyle == DescriptionStyle::HideDetails) {
     labelDescription->hide();
     labelInline->setText("");
@@ -39,10 +40,9 @@ void ParameterDescriptionWidget::setDescription(ParameterObject *parameter, Desc
   }
 }
 
-ParameterVirtualWidget::ParameterVirtualWidget(QWidget *parent, ParameterObject *parameter) :
-  QWidget(parent),
-  parameter(parameter)
-{
+ParameterVirtualWidget::ParameterVirtualWidget(QWidget *parent,
+                                               ParameterObject *parameter)
+    : QWidget(parent), parameter(parameter) {
   QSizePolicy policy;
   policy.setHorizontalPolicy(QSizePolicy::Ignored);
   policy.setVerticalPolicy(QSizePolicy::Maximum);
@@ -53,8 +53,7 @@ ParameterVirtualWidget::ParameterVirtualWidget(QWidget *parent, ParameterObject
   setContentsMargins(4, 0, 4, 0);
 }
 
-int ParameterVirtualWidget::decimalsRequired(double value)
-{
+int ParameterVirtualWidget::decimalsRequired(double value) {
   int decimals = 0;
   value = std::abs(value);
   while (std::floor(value) < std::ceil(value) && decimals < 7) {
@@ -64,8 +63,8 @@ int ParameterVirtualWidget::decimalsRequired(double value)
   return decimals;
 }
 
-int ParameterVirtualWidget::decimalsRequired(const std::vector<double>& values)
-{
+int ParameterVirtualWidget::decimalsRequired(
+    const std::vector<double> &values) {
   assert(!values.empty());
   int decimals = 0;
   for (double value : values) {
diff --git a/src/gui/parameter/ParameterVirtualWidget.h b/src/gui/parameter/ParameterVirtualWidget.h
index b1c9b2457..24b5f1e5f 100644
--- a/src/gui/parameter/ParameterVirtualWidget.h
+++ b/src/gui/parameter/ParameterVirtualWidget.h
@@ -4,24 +4,28 @@
 #include <boost/optional.hpp>
 #include <vector>
 
+#include "core/customizer/ParameterObject.h"
 #include "gui/qtgettext.h"
 #include "ui_ParameterDescriptionWidget.h"
-#include "core/customizer/ParameterObject.h"
 
-enum class DescriptionStyle { ShowDetails, Inline, HideDetails, DescriptionOnly };
+enum class DescriptionStyle {
+  ShowDetails,
+  Inline,
+  HideDetails,
+  DescriptionOnly
+};
 
-class ParameterDescriptionWidget : public QWidget, public Ui::ParameterDescriptionWidget
-{
+class ParameterDescriptionWidget : public QWidget,
+                                   public Ui::ParameterDescriptionWidget {
   Q_OBJECT
 
 public:
-
   ParameterDescriptionWidget(QWidget *parent);
-  void setDescription(ParameterObject *parameter, DescriptionStyle descriptionStyle);
+  void setDescription(ParameterObject *parameter,
+                      DescriptionStyle descriptionStyle);
 };
 
-class ParameterVirtualWidget : public QWidget
-{
+class ParameterVirtualWidget : public QWidget {
   Q_OBJECT
 
 public:
@@ -31,8 +35,9 @@ public:
   // Parent container (ParameterWidget) notifies when preview is updated,
   // so that widgets with immediate AND delayed changes can keep track
   // and avoid emitting excess changed() signals.
-  virtual void valueApplied() { }
-  // Widgets which are immediate only (combobox and checkbox) don't need to keep track.
+  virtual void valueApplied() {}
+  // Widgets which are immediate only (combobox and checkbox) don't need to keep
+  // track.
 
 signals:
   // immediate tells customizer auto preview to skip timeout
@@ -43,5 +48,5 @@ private:
 
 protected:
   static int decimalsRequired(double value);
-  static int decimalsRequired(const std::vector<double>& values);
+  static int decimalsRequired(const std::vector<double> &values);
 };
diff --git a/src/gui/parameter/ParameterWidget.cc b/src/gui/parameter/ParameterWidget.cc
index 65ba4609a..334eefcea 100644
--- a/src/gui/parameter/ParameterWidget.cc
+++ b/src/gui/parameter/ParameterWidget.cc
@@ -27,22 +27,21 @@
 
 #include <QLayoutItem>
 #include <QString>
-#include <stdexcept>
+#include <QWidget>
 #include <cassert>
 #include <map>
-#include <set>
 #include <memory>
-#include <QWidget>
-
+#include <set>
+#include <stdexcept>
 
+#include "gui/Preferences.h"
 #include "gui/parameter/GroupWidget.h"
-#include "gui/parameter/ParameterSpinBox.h"
+#include "gui/parameter/ParameterCheckBox.h"
 #include "gui/parameter/ParameterComboBox.h"
 #include "gui/parameter/ParameterSlider.h"
-#include "gui/parameter/ParameterCheckBox.h"
+#include "gui/parameter/ParameterSpinBox.h"
 #include "gui/parameter/ParameterText.h"
 #include "gui/parameter/ParameterVector.h"
-#include "gui/Preferences.h"
 
 #include <filesystem>
 
@@ -53,54 +52,61 @@
 #include <utility>
 #include <vector>
 
-ParameterWidget::ParameterWidget(QWidget *parent) : QWidget(parent)
-{
+ParameterWidget::ParameterWidget(QWidget *parent) : QWidget(parent) {
   setupUi(this);
   scrollAreaWidgetContents->layout()->setAlignment(Qt::AlignTop);
 
   autoPreviewTimer.setInterval(1000);
   autoPreviewTimer.setSingleShot(true);
 
-  connect(&autoPreviewTimer, &QTimer::timeout, this, &ParameterWidget::emitParametersChanged);
-  connect(checkBoxAutoPreview, &QCheckBox::toggled, [this]() {
-    this->autoPreview(true);
-  });
-  connect(comboBoxDetails, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &ParameterWidget::rebuildWidgets);
-  connect(comboBoxPreset, QOverload<int>::of(&QComboBox::activated), this, &ParameterWidget::onSetChanged);
-  //connect(comboBoxPreset, &QComboBox::editTextChanged, this, &ParameterWidget::onSetNameChanged);
+  connect(&autoPreviewTimer, &QTimer::timeout, this,
+          &ParameterWidget::emitParametersChanged);
+  connect(checkBoxAutoPreview, &QCheckBox::toggled,
+          [this]() { this->autoPreview(true); });
+  connect(comboBoxDetails, QOverload<int>::of(&QComboBox::currentIndexChanged),
+          this, &ParameterWidget::rebuildWidgets);
+  connect(comboBoxPreset, QOverload<int>::of(&QComboBox::activated), this,
+          &ParameterWidget::onSetChanged);
+  // connect(comboBoxPreset, &QComboBox::editTextChanged, this,
+  // &ParameterWidget::onSetNameChanged);
   connect(addButton, &QPushButton::clicked, this, &ParameterWidget::onSetAdd);
-  connect(deleteButton, &QPushButton::clicked, this, &ParameterWidget::onSetDelete);
-
-  QString fontfamily = GlobalPreferences::inst()->getValue("advanced/customizerFontFamily").toString();
-  uint fontsize = GlobalPreferences::inst()->getValue("advanced/customizerFontSize").toUInt();
+  connect(deleteButton, &QPushButton::clicked, this,
+          &ParameterWidget::onSetDelete);
+
+  QString fontfamily = GlobalPreferences::inst()
+                           ->getValue("advanced/customizerFontFamily")
+                           .toString();
+  uint fontsize = GlobalPreferences::inst()
+                      ->getValue("advanced/customizerFontSize")
+                      .toUInt();
   setFontFamilySize(fontfamily, fontsize);
 
-  connect(GlobalPreferences::inst(), &Preferences::customizerFontChanged, this, &ParameterWidget::setFontFamilySize);
+  connect(GlobalPreferences::inst(), &Preferences::customizerFontChanged, this,
+          &ParameterWidget::setFontFamilySize);
 }
 
 // Can only be called before the initial setParameters().
-void ParameterWidget::readFile(const QString& scadFile)
-{
+void ParameterWidget::readFile(const QString &scadFile) {
   assert(sets.empty());
   assert(parameters.empty());
   assert(widgets.empty());
 
   QString jsonFile = getJsonFile(scadFile);
-  if (!std::filesystem::exists(jsonFile.toStdString()) || this->sets.readFile(jsonFile.toStdString())) {
+  if (!std::filesystem::exists(jsonFile.toStdString()) ||
+      this->sets.readFile(jsonFile.toStdString())) {
     this->invalidJsonFile = QString();
   } else {
     this->invalidJsonFile = jsonFile;
   }
 
-  for (const auto& set : this->sets) {
+  for (const auto &set : this->sets) {
     comboBoxPreset->addItem(QString::fromStdString(set.name()));
   }
 }
 
 // Write the json file if the parameter sets are not empty.
 // This prevents creating unnecessary json files.
-void ParameterWidget::saveFile(const QString& scadFile)
-{
+void ParameterWidget::saveFile(const QString &scadFile) {
   if (sets.empty()) {
     return;
   }
@@ -109,7 +115,10 @@ void ParameterWidget::saveFile(const QString& scadFile)
   if (jsonFile == this->invalidJsonFile) {
     QMessageBox msgBox;
     msgBox.setWindowTitle(_("Saving presets"));
-    msgBox.setText(QString(_("%1 was found, but was unreadable. Do you want to overwrite %1?")).arg(this->invalidJsonFile));
+    msgBox.setText(
+        QString(
+            _("%1 was found, but was unreadable. Do you want to overwrite %1?"))
+            .arg(this->invalidJsonFile));
     msgBox.setStandardButtons(QMessageBox::Save | QMessageBox::Cancel);
     msgBox.setDefaultButton(QMessageBox::Cancel);
     if (msgBox.exec() == QMessageBox::Cancel) {
@@ -121,8 +130,7 @@ void ParameterWidget::saveFile(const QString& scadFile)
   sets.writeFile(jsonFile.toStdString());
 }
 
-void ParameterWidget::saveBackupFile(const QString& scadFile)
-{
+void ParameterWidget::saveBackupFile(const QString &scadFile) {
   if (sets.empty()) {
     return;
   }
@@ -130,8 +138,8 @@ void ParameterWidget::saveBackupFile(const QString& scadFile)
   sets.writeFile(getJsonFile(scadFile).toStdString());
 }
 
-void ParameterWidget::setParameters(const SourceFile *sourceFile, const std::string& source)
-{
+void ParameterWidget::setParameters(const SourceFile *sourceFile,
+                                    const std::string &source) {
   if (this->source == source) {
     return;
   }
@@ -142,13 +150,11 @@ void ParameterWidget::setParameters(const SourceFile *sourceFile, const std::str
   loadSet(comboBoxPreset->currentIndex());
 }
 
-void ParameterWidget::applyParameters(SourceFile *sourceFile)
-{
+void ParameterWidget::applyParameters(SourceFile *sourceFile) {
   this->parameters.apply(sourceFile);
 }
 
-bool ParameterWidget::childHasFocus()
-{
+bool ParameterWidget::childHasFocus() {
   if (this->hasFocus()) {
     return true;
   }
@@ -161,8 +167,7 @@ bool ParameterWidget::childHasFocus()
   return false;
 }
 
-void ParameterWidget::setModified(bool modified)
-{
+void ParameterWidget::setModified(bool modified) {
   if (this->modified != modified) {
     this->modified = modified;
     emit modificationChanged();
@@ -170,7 +175,7 @@ void ParameterWidget::setModified(bool modified)
 }
 
 void ParameterWidget::emitParametersChanged() {
-  for (const auto& kvp : widgets) {
+  for (const auto &kvp : widgets) {
     for (ParameterVirtualWidget *widget : kvp.second) {
       widget->valueApplied();
     }
@@ -178,8 +183,7 @@ void ParameterWidget::emitParametersChanged() {
   emit parametersChanged();
 }
 
-void ParameterWidget::autoPreview(bool immediate)
-{
+void ParameterWidget::autoPreview(bool immediate) {
   autoPreviewTimer.stop();
   if (checkBoxAutoPreview->isChecked()) {
     if (immediate) {
@@ -190,31 +194,25 @@ void ParameterWidget::autoPreview(bool immediate)
   }
 }
 
-void ParameterWidget::onSetChanged(int index)
-{
+void ParameterWidget::onSetChanged(int index) {
   loadSet(index);
   autoPreview(true);
 }
 
-void ParameterWidget::onSetNameChanged()
-{
+void ParameterWidget::onSetNameChanged() {
   assert(static_cast<size_t>(comboBoxPreset->count()) == sets.size() + 1);
-  comboBoxPreset->setItemText(comboBoxPreset->currentIndex(), comboBoxPreset->lineEdit()->text());
-  sets[comboBoxPreset->currentIndex() - 1].setName(comboBoxPreset->currentText().toStdString());
+  comboBoxPreset->setItemText(comboBoxPreset->currentIndex(),
+                              comboBoxPreset->lineEdit()->text());
+  sets[comboBoxPreset->currentIndex() - 1].setName(
+      comboBoxPreset->currentText().toStdString());
   setModified();
 }
 
-void ParameterWidget::onSetAdd()
-{
+void ParameterWidget::onSetAdd() {
   bool ok = true;
-  QString result = QInputDialog::getText(
-    this,
-    _("Create new set of parameter"),
-    _("Enter name of the parameter set"),
-    QLineEdit::Normal,
-    "",
-    &ok
-    );
+  QString result = QInputDialog::getText(this, _("Create new set of parameter"),
+                                         _("Enter name of the parameter set"),
+                                         QLineEdit::Normal, "", &ok);
 
   if (ok) {
     createSet(result.trimmed());
@@ -222,8 +220,7 @@ void ParameterWidget::onSetAdd()
   setModified();
 }
 
-void ParameterWidget::onSetDelete()
-{
+void ParameterWidget::onSetDelete() {
   int index = comboBoxPreset->currentIndex();
   assert(index > 0);
   int newIndex;
@@ -241,20 +238,19 @@ void ParameterWidget::onSetDelete()
   autoPreview(true);
 }
 
-void ParameterWidget::parameterModified(bool immediate)
-{
+void ParameterWidget::parameterModified(bool immediate) {
   auto *widget = (ParameterVirtualWidget *)sender();
   ParameterObject *parameter = widget->getParameter();
 
   // When attempting to modify the design default, create a new set to edit.
   if (comboBoxPreset->currentIndex() == 0) {
     std::set<std::string> setNames;
-    for (const auto& set : this->sets) {
+    for (const auto &set : this->sets) {
       setNames.insert(set.name());
     }
 
     QString name;
-    for (int i = 1; ; i++) {
+    for (int i = 1;; i++) {
       name = _("New set ") + QString::number(i);
       if (setNames.count(name.toStdString()) == 0) {
         break;
@@ -278,8 +274,7 @@ void ParameterWidget::parameterModified(bool immediate)
   autoPreview(immediate);
 }
 
-void ParameterWidget::loadSet(size_t index)
-{
+void ParameterWidget::loadSet(size_t index) {
   assert(index <= sets.size());
   if (index == 0) {
     parameters.reset();
@@ -289,37 +284,35 @@ void ParameterWidget::loadSet(size_t index)
 
   updateSetEditability();
 
-  for (const auto& pair : widgets) {
+  for (const auto &pair : widgets) {
     for (ParameterVirtualWidget *widget : pair.second) {
       widget->setValue();
     }
   }
 }
 
-void ParameterWidget::createSet(const QString& name)
-{
+void ParameterWidget::createSet(const QString &name) {
   sets.push_back(parameters.exportValues(name.toStdString()));
   comboBoxPreset->addItem(name);
   comboBoxPreset->setCurrentIndex(comboBoxPreset->count() - 1);
   updateSetEditability();
 }
 
-void ParameterWidget::updateSetEditability()
-{
+void ParameterWidget::updateSetEditability() {
   if (comboBoxPreset->currentIndex() == 0) {
     comboBoxPreset->setEditable(false);
     deleteButton->setEnabled(false);
   } else {
     if (!comboBoxPreset->isEditable()) {
       comboBoxPreset->setEditable(true);
-      connect(comboBoxPreset->lineEdit(), &QLineEdit::textEdited, this, &ParameterWidget::onSetNameChanged);
+      connect(comboBoxPreset->lineEdit(), &QLineEdit::textEdited, this,
+              &ParameterWidget::onSetNameChanged);
     }
     deleteButton->setEnabled(true);
   }
 }
 
-void ParameterWidget::rebuildWidgets()
-{
+void ParameterWidget::rebuildWidgets() {
   std::map<QString, bool> expandedGroups;
   for (GroupWidget *groupWidget : this->findChildren<GroupWidget *>()) {
     expandedGroups.emplace(groupWidget->title(), groupWidget->isExpanded());
@@ -333,13 +326,16 @@ void ParameterWidget::rebuildWidgets()
     delete child;
   }
 
-  auto descriptionStyle = static_cast<DescriptionStyle>(comboBoxDetails->currentIndex());
+  auto descriptionStyle =
+      static_cast<DescriptionStyle>(comboBoxDetails->currentIndex());
   std::vector<ParameterGroup> parameterGroups = getParameterGroups();
-  for (const auto& group : parameterGroups) {
+  for (const auto &group : parameterGroups) {
     auto *groupWidget = new GroupWidget(group.name);
     for (ParameterObject *parameter : group.parameters) {
-      ParameterVirtualWidget *parameterWidget = createParameterWidget(parameter, descriptionStyle);
-      connect(parameterWidget, &ParameterVirtualWidget::changed, this, &ParameterWidget::parameterModified);
+      ParameterVirtualWidget *parameterWidget =
+          createParameterWidget(parameter, descriptionStyle);
+      connect(parameterWidget, &ParameterVirtualWidget::changed, this,
+              &ParameterWidget::parameterModified);
       if (!widgets.count(parameter)) {
         widgets[parameter] = {};
       }
@@ -352,13 +348,13 @@ void ParameterWidget::rebuildWidgets()
   }
 }
 
-std::vector<ParameterWidget::ParameterGroup> ParameterWidget::getParameterGroups()
-{
+std::vector<ParameterWidget::ParameterGroup>
+ParameterWidget::getParameterGroups() {
   std::vector<ParameterWidget::ParameterGroup> output;
   std::map<std::string, size_t> groupIndices;
   std::vector<ParameterObject *> globalParameters;
 
-  for (const std::unique_ptr<ParameterObject>& parameter : parameters) {
+  for (const std::unique_ptr<ParameterObject> &parameter : parameters) {
     std::string group = parameter->group();
     if (group == "Global") {
       globalParameters.push_back(parameter.get());
@@ -379,20 +375,24 @@ std::vector<ParameterWidget::ParameterGroup> ParameterWidget::getParameterGroups
     global.parameters = std::move(globalParameters);
     output.push_back(std::move(global));
   } else {
-    for (auto& group : output) {
-      group.parameters.insert(group.parameters.end(), globalParameters.begin(), globalParameters.end());
+    for (auto &group : output) {
+      group.parameters.insert(group.parameters.end(), globalParameters.begin(),
+                              globalParameters.end());
     }
   }
 
   return output;
 }
 
-ParameterVirtualWidget *ParameterWidget::createParameterWidget(ParameterObject *parameter, DescriptionStyle descriptionStyle)
-{
+ParameterVirtualWidget *
+ParameterWidget::createParameterWidget(ParameterObject *parameter,
+                                       DescriptionStyle descriptionStyle) {
   if (parameter->type() == ParameterObject::ParameterType::Bool) {
-    return new ParameterCheckBox(this, static_cast<BoolParameter *>(parameter), descriptionStyle);
+    return new ParameterCheckBox(this, static_cast<BoolParameter *>(parameter),
+                                 descriptionStyle);
   } else if (parameter->type() == ParameterObject::ParameterType::String) {
-    return new ParameterText(this, static_cast<StringParameter *>(parameter), descriptionStyle);
+    return new ParameterText(this, static_cast<StringParameter *>(parameter),
+                             descriptionStyle);
   } else if (parameter->type() == ParameterObject::ParameterType::Number) {
     auto *numberParameter = static_cast<NumberParameter *>(parameter);
     if (numberParameter->minimum && numberParameter->maximum) {
@@ -401,31 +401,31 @@ ParameterVirtualWidget *ParameterWidget::createParameterWidget(ParameterObject *
       return new ParameterSpinBox(this, numberParameter, descriptionStyle);
     }
   } else if (parameter->type() == ParameterObject::ParameterType::Vector) {
-    return new ParameterVector(this, static_cast<VectorParameter *>(parameter), descriptionStyle);
+    return new ParameterVector(this, static_cast<VectorParameter *>(parameter),
+                               descriptionStyle);
   } else if (parameter->type() == ParameterObject::ParameterType::Enum) {
-    return new ParameterComboBox(this, static_cast<EnumParameter *>(parameter), descriptionStyle);
+    return new ParameterComboBox(this, static_cast<EnumParameter *>(parameter),
+                                 descriptionStyle);
   } else {
     assert(false);
     throw std::runtime_error("Unsupported parameter widget type");
   }
 }
 
-QString ParameterWidget::getJsonFile(const QString& scadFile)
-{
+QString ParameterWidget::getJsonFile(const QString &scadFile) {
   std::filesystem::path p = scadFile.toStdString();
   return QString::fromStdString(p.replace_extension(".json").string());
 }
 
 // Remove set values that do not correspond to a parameter,
 // or that cannot be parsed as such.
-void ParameterWidget::cleanSets()
-{
+void ParameterWidget::cleanSets() {
   std::map<std::string, ParameterObject *> namedParameters;
-  for (const auto& parameter : parameters) {
+  for (const auto &parameter : parameters) {
     namedParameters[parameter->name()] = parameter.get();
   }
 
-  for (ParameterSet& set : sets) {
+  for (ParameterSet &set : sets) {
     for (auto it = set.begin(); it != set.end();) {
       if (!namedParameters.count(it->first)) {
         it = set.erase(it);
@@ -440,7 +440,9 @@ void ParameterWidget::cleanSets()
   }
 }
 
-void ParameterWidget::setFontFamilySize(const QString& fontFamily, uint fontSize)
-{
-  scrollArea->setStyleSheet(QString("font-family: \"%1\"; font-size: %2pt;").arg(fontFamily).arg(fontSize));
+void ParameterWidget::setFontFamilySize(const QString &fontFamily,
+                                        uint fontSize) {
+  scrollArea->setStyleSheet(QString("font-family: \"%1\"; font-size: %2pt;")
+                                .arg(fontFamily)
+                                .arg(fontSize));
 }
diff --git a/src/gui/parameter/ParameterWidget.h b/src/gui/parameter/ParameterWidget.h
index 7e12786da..b219422d3 100644
--- a/src/gui/parameter/ParameterWidget.h
+++ b/src/gui/parameter/ParameterWidget.h
@@ -26,21 +26,20 @@
 #pragma once
 
 #include <QString>
-#include <QWidget>
 #include <QTimer>
+#include <QWidget>
 #include <cstddef>
 #include <map>
 #include <string>
 #include <vector>
 
-#include "gui/qtgettext.h" // IWYU pragma: keep
-#include "ui_ParameterWidget.h"
 #include "core/customizer/ParameterObject.h"
 #include "core/customizer/ParameterSet.h"
 #include "gui/parameter/ParameterVirtualWidget.h"
+#include "gui/qtgettext.h" // IWYU pragma: keep
+#include "ui_ParameterWidget.h"
 
-class ParameterWidget : public QWidget, public Ui::ParameterWidget
-{
+class ParameterWidget : public QWidget, public Ui::ParameterWidget {
   Q_OBJECT
 private:
   ParameterSets sets;
@@ -48,23 +47,24 @@ private:
   ParameterObjects parameters;
   std::map<ParameterObject *, std::vector<ParameterVirtualWidget *>> widgets;
 
-  QString invalidJsonFile; // set if a json file was read that could not be parsed
+  QString
+      invalidJsonFile; // set if a json file was read that could not be parsed
   QTimer autoPreviewTimer;
   bool modified = false;
 
 public:
   ParameterWidget(QWidget *parent = nullptr);
-  void readFile(const QString& scadFile);
-  void saveFile(const QString& scadFile);
-  void saveBackupFile(const QString& scadFile);
-  void setParameters(const SourceFile *sourceFile, const std::string& source);
+  void readFile(const QString &scadFile);
+  void saveFile(const QString &scadFile);
+  void saveBackupFile(const QString &scadFile);
+  void setParameters(const SourceFile *sourceFile, const std::string &source);
   void applyParameters(SourceFile *sourceFile);
   bool childHasFocus();
   bool isModified() const { return modified; }
 
 public slots:
   void setModified(bool modified = true);
-  void setFontFamilySize(const QString& fontfamily, uint fontsize);
+  void setFontFamilySize(const QString &fontfamily, uint fontsize);
 
 protected slots:
   void autoPreview(bool immediate = false);
@@ -75,7 +75,7 @@ protected slots:
   void onSetDelete();
   void parameterModified(bool immediate);
   void loadSet(size_t index);
-  void createSet(const QString& name);
+  void createSet(const QString &name);
   void updateSetEditability();
   void rebuildWidgets();
 
@@ -88,13 +88,14 @@ signals:
   void modificationChanged();
 
 protected:
-  struct ParameterGroup
-  {
+  struct ParameterGroup {
     QString name;
     std::vector<ParameterObject *> parameters;
   };
   std::vector<ParameterGroup> getParameterGroups();
-  ParameterVirtualWidget *createParameterWidget(ParameterObject *parameter, DescriptionStyle descriptionStyle);
-  QString getJsonFile(const QString& scadFile);
+  ParameterVirtualWidget *
+  createParameterWidget(ParameterObject *parameter,
+                        DescriptionStyle descriptionStyle);
+  QString getJsonFile(const QString &scadFile);
   void cleanSets();
 };
diff --git a/src/gui/qt-obsolete.h b/src/gui/qt-obsolete.h
index ccda5d70c..3d253af4a 100644
--- a/src/gui/qt-obsolete.h
+++ b/src/gui/qt-obsolete.h
@@ -9,9 +9,9 @@
 #if (QT_VERSION < QT_VERSION_CHECK(5, 15, 0))
 namespace std {
 template <> struct hash<QString> {
-  std::size_t operator()(const QString& s) const noexcept {
-    return (size_t) qHash(s);
+  std::size_t operator()(const QString &s) const noexcept {
+    return (size_t)qHash(s);
   }
 };
-}
+} // namespace std
 #endif
diff --git a/src/gui/qtgettext.h b/src/gui/qtgettext.h
index 6671ac674..6f419af29 100644
--- a/src/gui/qtgettext.h
+++ b/src/gui/qtgettext.h
@@ -10,13 +10,9 @@
 #define sprintf sprintf
 #endif
 
-#include <QString>
 #include "utils/printutils.h"
+#include <QString>
 
-inline QString q_(const char *msgid, const char *msgctxt)
-{
-  return QString::fromUtf8(msgctxt ?
-                           _(msgid, msgctxt):
-                           _(msgid)
-                           );
+inline QString q_(const char *msgid, const char *msgctxt) {
+  return QString::fromUtf8(msgctxt ? _(msgid, msgctxt) : _(msgid));
 }
diff --git a/src/guitests/TestMainWindow.cc b/src/guitests/TestMainWindow.cc
index 1dd34d187..755d567a6 100644
--- a/src/guitests/TestMainWindow.cc
+++ b/src/guitests/TestMainWindow.cc
@@ -1,13 +1,13 @@
-#include <QTest>
-#include <QStringList>
 #include "TestMainWindow.h"
 #include "platform/PlatformUtils.h"
+#include <QStringList>
+#include <QTest>
 
-void TestMainWindow::checkOpenTabPropagateToWindow()
-{
+void TestMainWindow::checkOpenTabPropagateToWindow() {
   restoreWindowInitialState();
 
-  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) + "/tests/basic-ux/empty.scad";
+  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) +
+                     "/tests/basic-ux/empty.scad";
 
   // When we open a new file,
   window->tabManager->open(filename);
@@ -15,7 +15,8 @@ void TestMainWindow::checkOpenTabPropagateToWindow()
   // The window title must also have the name of open file
   QCOMPARE(window->windowTitle(), QFileInfo(filename).fileName());
 
-  filename = QString::fromStdString(PlatformUtils::resourceBasePath()) + "/tests/basic-ux/empty2.scad";
+  filename = QString::fromStdString(PlatformUtils::resourceBasePath()) +
+             "/tests/basic-ux/empty2.scad";
 
   // When we open a new file,
   window->tabManager->open(filename);
@@ -24,11 +25,11 @@ void TestMainWindow::checkOpenTabPropagateToWindow()
   QCOMPARE(window->windowTitle(), QFileInfo(filename).fileName());
 }
 
-void TestMainWindow::checkSaveToShouldUpdateWindowTitle()
-{
+void TestMainWindow::checkSaveToShouldUpdateWindowTitle() {
   restoreWindowInitialState();
 
-  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) + "/tests/basic-ux/empty.scad";
+  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) +
+                     "/tests/basic-ux/empty.scad";
 
   // When we open a new file,
   window->tabManager->open(filename);
diff --git a/src/guitests/TestMainWindow.h b/src/guitests/TestMainWindow.h
index fb4cc7265..7d6bd1a5d 100644
--- a/src/guitests/TestMainWindow.h
+++ b/src/guitests/TestMainWindow.h
@@ -2,8 +2,7 @@
 
 #include "UXTest.h"
 
-class TestMainWindow : public UXTest
-{
+class TestMainWindow : public UXTest {
   Q_OBJECT;
 private slots:
   void checkOpenTabPropagateToWindow();
diff --git a/src/guitests/TestModuleCache.cc b/src/guitests/TestModuleCache.cc
index 1b307acd0..1d303d226 100644
--- a/src/guitests/TestModuleCache.cc
+++ b/src/guitests/TestModuleCache.cc
@@ -1,63 +1,66 @@
-#include <QTest>
-#include <QStringList>
 #include "TestModuleCache.h"
 #include "platform/PlatformUtils.h"
+#include <QStringList>
+#include <QTest>
 
-void touchFile(const QString& filename)
-{
+void touchFile(const QString &filename) {
   auto timeStamp = QDateTime::currentDateTime();
 
   QFileInfo fileInfo(filename);
   QFile file(filename);
   file.open(QIODevice::WriteOnly);
-  if (file.isOpen()){
+  if (file.isOpen()) {
     file.setFileTime(timeStamp, QFileDevice::FileModificationTime);
     file.setFileTime(timeStamp, QFileDevice::FileAccessTime);
   }
 }
 
-void TestModuleCache::testBasicCache()
-{
+void TestModuleCache::testBasicCache() {
   restoreWindowInitialState();
 
   QString filename = QString::fromStdString("test-tmp.scad");
   SourceFile *previousFile{nullptr};
   SourceFile *currentFile{nullptr};
-  connect(window, &MainWindow::compilationDone, [&currentFile](SourceFile *file){
-    currentFile = file;
-  });
+  connect(window, &MainWindow::compilationDone,
+          [&currentFile](SourceFile *file) { currentFile = file; });
 
-  window->designActionAutoReload->setChecked(false);   // Disable auto-reload  & preview
-  window->tabManager->open(filename);                  // Open use.scad
-  window->actionReloadRenderPreview();                 // F5
+  window->designActionAutoReload->setChecked(
+      false);                          // Disable auto-reload  & preview
+  window->tabManager->open(filename);  // Open use.scad
+  window->actionReloadRenderPreview(); // F5
 
-  QVERIFY2(currentFile != nullptr, "The file 'test-tmp.scad' should be loaded.");
-  previousFile = currentFile;                          // save the loaded Source from the
+  QVERIFY2(currentFile != nullptr,
+           "The file 'test-tmp.scad' should be loaded.");
+  previousFile = currentFile; // save the loaded Source from the
 
   window->actionReloadRenderPreview();
-  QVERIFY2(previousFile == currentFile, "The file should be the same as the file cache should have done its work.");
+  QVERIFY2(previousFile == currentFile,
+           "The file should be the same as the file cache should have done its "
+           "work.");
   sleep(1);
 
   touchFile(filename);
   window->actionReloadRenderPreview();
-  QVERIFY2(previousFile != currentFile, "The file should *not* be the same as the file cache should have detected the timestamp change.");
+  QVERIFY2(previousFile != currentFile,
+           "The file should *not* be the same as the file cache should have "
+           "detected the timestamp change.");
 }
 
-std::vector<std::string>& findNode(std::shared_ptr<AbstractNode> node, std::vector<std::string>& path)
-{
+std::vector<std::string> &findNode(std::shared_ptr<AbstractNode> node,
+                                   std::vector<std::string> &path) {
   path.push_back(node->verbose_name());
   for (auto child : node->getChildren())
     return findNode(child, path);
   return path;
 }
 
-void TestModuleCache::testMCAD()
-{
+void TestModuleCache::testMCAD() {
   restoreWindowInitialState();
 
-  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) + "/tests/modulecache-tests/use-mcad.scad";
-  window->tabManager->open(filename);             // Open use-mcad.scad
-  window->actionReloadRenderPreview();            // F5
+  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) +
+                     "/tests/modulecache-tests/use-mcad.scad";
+  window->tabManager->open(filename);  // Open use-mcad.scad
+  window->actionReloadRenderPreview(); // F5
 
   auto node = window->instantiateRootFromSource(window->rootFile);
   QVERIFY2(node->verbose_name().empty(), "Root node name must be empty");
diff --git a/src/guitests/TestModuleCache.h b/src/guitests/TestModuleCache.h
index 056b9577b..029901328 100644
--- a/src/guitests/TestModuleCache.h
+++ b/src/guitests/TestModuleCache.h
@@ -2,8 +2,7 @@
 
 #include "UXTest.h"
 
-class TestModuleCache : public UXTest
-{
+class TestModuleCache : public UXTest {
   Q_OBJECT;
 
 private slots:
diff --git a/src/guitests/TestTabManager.cc b/src/guitests/TestTabManager.cc
index 5833a0ac3..8827cabf5 100644
--- a/src/guitests/TestTabManager.cc
+++ b/src/guitests/TestTabManager.cc
@@ -1,19 +1,19 @@
-#include <QTest>
-#include <QStringList>
-#include "platform/PlatformUtils.h"
 #include "TestTabManager.h"
+#include "platform/PlatformUtils.h"
+#include <QStringList>
+#include <QTest>
 
-void TestTabManager::initTestCase()
-{
-}
+void TestTabManager::initTestCase() {}
 
-void TestTabManager::checkOpenClose()
-{
+void TestTabManager::checkOpenClose() {
   // The window has only one editor with file default.scad
   restoreWindowInitialState();
 
-  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) + "/tests/basic-ux/empty.scad";
-  QString filename2 = QString::fromStdString(PlatformUtils::resourceBasePath()) + "/tests/basic-ux/empty2.scad";
+  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) +
+                     "/tests/basic-ux/empty.scad";
+  QString filename2 =
+      QString::fromStdString(PlatformUtils::resourceBasePath()) +
+      "/tests/basic-ux/empty2.scad";
 
   window->tabManager->open(filename);
   // The active editor must have a filepath equal to the loaded file
@@ -33,18 +33,19 @@ void TestTabManager::checkOpenClose()
   QCOMPARE(window->tabManager->count(), 1);
 }
 
-void TestTabManager::checkReOpen()
-{
+void TestTabManager::checkReOpen() {
   restoreWindowInitialState();
 
-  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) + "/tests/basic-ux/empty.scad";
+  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) +
+                     "/tests/basic-ux/empty.scad";
   auto numPanel = window->tabManager->count();
 
   // When we open a new file,
   window->tabManager->open(filename);
   QCOMPARE(numPanel + 1, window->tabManager->count());
 
-  // When we re-open a new file, nothing should happens as the file is already there
+  // When we re-open a new file, nothing should happens as the file is already
+  // there
   window->tabManager->open(filename);
   QCOMPARE(numPanel + 1, window->tabManager->count());
 
diff --git a/src/guitests/TestTabManager.h b/src/guitests/TestTabManager.h
index 194024062..168fdeccd 100644
--- a/src/guitests/TestTabManager.h
+++ b/src/guitests/TestTabManager.h
@@ -1,8 +1,7 @@
 #pragma once
 #include "UXTest.h"
 
-class TestTabManager : public UXTest
-{
+class TestTabManager : public UXTest {
   Q_OBJECT;
 private slots:
   void initTestCase();
diff --git a/src/guitests/UXTest.cc b/src/guitests/UXTest.cc
index 5e67bf9f0..64c860040 100644
--- a/src/guitests/UXTest.cc
+++ b/src/guitests/UXTest.cc
@@ -1,15 +1,17 @@
 #include "UXTest.h"
 #include "platform/PlatformUtils.h"
 
-void UXTest::setWindow(MainWindow *window_){ window = window_; }
+void UXTest::setWindow(MainWindow *window_) { window = window_; }
 
-void UXTest::restoreWindowInitialState(){
-  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) + "/tests/basic-ux/default.scad";
+void UXTest::restoreWindowInitialState() {
+  QString filename = QString::fromStdString(PlatformUtils::resourceBasePath()) +
+                     "/tests/basic-ux/default.scad";
   window->tabManager->open(filename);
 
-  while (window->tabCount > 1){
+  while (window->tabCount > 1) {
     window->tabManager->closeCurrentTab();
   }
 
-  window->designActionAutoReload->setChecked(true);   // Enable auto-reload  & preview
+  window->designActionAutoReload->setChecked(
+      true); // Enable auto-reload  & preview
 }
diff --git a/src/guitests/UXTest.h b/src/guitests/UXTest.h
index 88282efa8..a4752ba9a 100644
--- a/src/guitests/UXTest.h
+++ b/src/guitests/UXTest.h
@@ -1,10 +1,9 @@
 #pragma once
 
-#include <QObject>
 #include "gui/MainWindow.h"
+#include <QObject>
 
-class UXTest : public QObject
-{
+class UXTest : public QObject {
   Q_OBJECT;
 
 public:
diff --git a/src/guitests/guitests.cc b/src/guitests/guitests.cc
index 7399bbc01..6418a4658 100644
--- a/src/guitests/guitests.cc
+++ b/src/guitests/guitests.cc
@@ -1,28 +1,27 @@
-#include "TestModuleCache.h"
 #include "TestMainWindow.h"
+#include "TestModuleCache.h"
 #include "TestTabManager.h"
 
 #include <QTest>
 
-template <typename TestClass>
-int runTests(MainWindow *window)
-{
+template <typename TestClass> int runTests(MainWindow *window) {
   TestClass tc;
   tc.setWindow(window);
   return QTest::qExec(&tc);
   return 0;
 }
 
-int runAllTest(MainWindow *window)
-{
+int runAllTest(MainWindow *window) {
   int totalTestFailures = 0;
-  std::cout << "******************************* RUN UX TESTS ********************************" << std::endl;
+  std::cout << "******************************* RUN UX TESTS "
+               "********************************"
+            << std::endl;
   totalTestFailures += runTests<TestTabManager>(window);
   totalTestFailures += runTests<TestMainWindow>(window);
   totalTestFailures += runTests<TestModuleCache>(window);
-  std::cout << "********************************** RESULTS *********************************" << std::endl;
+  std::cout << "********************************** RESULTS "
+               "*********************************"
+            << std::endl;
   std::cout << "Failures: " << totalTestFailures << std::endl;
   return totalTestFailures;
 }
-
-
diff --git a/src/handle_dep.cc b/src/handle_dep.cc
index b3cf27679..709fbbc3a 100644
--- a/src/handle_dep.cc
+++ b/src/handle_dep.cc
@@ -24,28 +24,31 @@ namespace {
 
 std::unordered_set<std::string> dependencies;
 
-}  // namespace
+} // namespace
 
-void handle_dep(const std::string& filename)
-{
+void handle_dep(const std::string &filename) {
   const fs::path filepath(filename);
-  const std::string dep = boost::regex_replace(filepath.generic_string(), boost::regex("\\ "), "\\\\ ");
+  const std::string dep = boost::regex_replace(filepath.generic_string(),
+                                               boost::regex("\\ "), "\\\\ ");
   if (dependencies.find(dep) != dependencies.end()) {
-    return; // included and used files are very likely to be added many times by the parser
+    return; // included and used files are very likely to be added many times by
+            // the parser
   }
   dependencies.insert(dep);
 
   if (make_command && !fs::exists(filepath)) {
     // This should only happen from command-line execution.
     // If changed, add an alternate error-reporting process.
-    auto cmd = STR(make_command, " '", boost::regex_replace(filename, boost::regex("'"), "'\\''"), "'");
+    auto cmd =
+        STR(make_command, " '",
+            boost::regex_replace(filename, boost::regex("'"), "'\\''"), "'");
     errno = 0;
     int res = system(cmd.c_str());
 
     // Could not launch system() correctly
 #ifdef _WIN32
     if ((res == 0 || res == -1) && errno != 0) {
-#else // NOT _WIN32
+#else  // NOT _WIN32
     if (res == -1 && errno != 0) {
 #endif // _WIN32 / NOT _WIN32
       perror("ERROR: system(make_cmd) failed");
@@ -62,31 +65,32 @@ void handle_dep(const std::string& filename)
     // Error code from process.
 #ifdef _WIN32
     else if (0 != res) {
-#else // NOT _WIN32
+#else  // NOT _WIN32
     else if (0 != (res = WEXITSTATUS(res))) {
 #endif // _WIN32 / NOT _WIN32
-      std::cerr << "ERROR: " << cmd.c_str() << ": Exit status "
-                << res << std::endl;
+      std::cerr << "ERROR: " << cmd.c_str() << ": Exit status " << res
+                << std::endl;
     }
 
     // Otherwise, success!
   }
 }
 
-bool write_deps(const std::string& filename, const std::vector<std::string>& output_files)
-{
+bool write_deps(const std::string &filename,
+                const std::vector<std::string> &output_files) {
   FILE *fp = fopen(filename.c_str(), "wt");
   if (!fp) {
-    fprintf(stderr, "Can't open dependencies file `%s' for writing!\n", filename.c_str());
+    fprintf(stderr, "Can't open dependencies file `%s' for writing!\n",
+            filename.c_str());
     return false;
   }
-  for (const auto& output_file : output_files) {
+  for (const auto &output_file : output_files) {
     fprintf(fp, "%s ", output_file.c_str());
   }
   fseek(fp, -1, SEEK_CUR);
   fprintf(fp, ":");
 
-  for (const auto& str : dependencies) {
+  for (const auto &str : dependencies) {
     fprintf(fp, " \\\n\t%s", str.c_str());
   }
   fprintf(fp, "\n");
diff --git a/src/handle_dep.h b/src/handle_dep.h
index da426173c..8a2429c4d 100644
--- a/src/handle_dep.h
+++ b/src/handle_dep.h
@@ -4,5 +4,6 @@
 #include <vector>
 
 extern const char *make_command;
-void handle_dep(const std::string& filename);
-bool write_deps(const std::string& filename, const std::vector<std::string>& output_files);
+void handle_dep(const std::string &filename);
+bool write_deps(const std::string &filename,
+                const std::vector<std::string> &output_files);
diff --git a/src/io/DxfData.cc b/src/io/DxfData.cc
index a90944a5b..1749b270d 100644
--- a/src/io/DxfData.cc
+++ b/src/io/DxfData.cc
@@ -44,13 +44,12 @@
 
 #include "core/Value.h"
 #include "geometry/Grid.h"
-#include "geometry/linalg.h"
 #include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 #include "io/fileutils.h"
 #include "utils/calc.h"
 #include "utils/degree_trig.h"
 #include "utils/printutils.h"
-#include "utils/printutils.h"
 
 namespace fs = std::filesystem;
 
@@ -61,9 +60,9 @@ namespace fs = std::filesystem;
 
    1) Read DXF file from disk
    2) Store contents of DXF files as points, paths and dims
-   3) Store 2D polygons, both from the polygon() module and from 2D CSG operations.
-     Used for tessellation into triangles
-   4) Store 2D polygons before exporting to DXF
+   3) Store 2D polygons, both from the polygon() module and from 2D CSG
+   operations. Used for tessellation into triangles 4) Store 2D polygons before
+   exporting to DXF
 
 
  */
@@ -72,16 +71,15 @@ struct Line {
   int idx[2] = {-1, -1}; // indices into DxfData::points
   bool disabled{false};
   Line() = default;
-  Line(int i1, int i2) : idx{i1, i2} { }
+  Line(int i1, int i2) : idx{i1, i2} {}
 };
 
 /*!
    Reads a layer from the given file, or all layers if layername.empty()
  */
-DxfData::DxfData(double fn, double fs, double fa,
-                 const std::string& filename, const std::string& layername,
-                 double xorigin, double yorigin, double scale)
-{
+DxfData::DxfData(double fn, double fs, double fa, const std::string &filename,
+                 const std::string &layername, double xorigin, double yorigin,
+                 double scale) {
   std::ifstream stream(filename.c_str());
   if (!stream.good()) {
     LOG(message_group::Warning, "Can't open DXF file '%1$s'.", filename);
@@ -89,31 +87,31 @@ DxfData::DxfData(double fn, double fs, double fa,
   }
 
   Grid2d<std::vector<int>> grid(GRID_COARSE);
-  std::vector<Line> lines;                 // Global lines
-  std::unordered_map<std::string, std::vector<Line>> blockdata; // Lines in blocks
+  std::vector<Line> lines; // Global lines
+  std::unordered_map<std::string, std::vector<Line>>
+      blockdata; // Lines in blocks
 
   auto in_entities_section = false;
   auto in_blocks_section = false;
   std::string current_block;
 
-#define ADD_LINE(_x1, _y1, _x2, _y2) do {                   \
-          double _p1x = (_x1), _p1y = (_y1), _p2x = (_x2), _p2y = (_y2); \
-          if (!in_entities_section && !in_blocks_section)         \
-          break;                                                \
-          if (in_entities_section &&                              \
-              !(layername.empty() || layername == layer))         \
-          break;                                                \
-          grid.align(_p1x, _p1y);                                 \
-          grid.align(_p2x, _p2y);                                 \
-          grid.data(_p1x, _p1y).push_back(lines.size());          \
-          grid.data(_p2x, _p2y).push_back(lines.size());          \
-          if (in_entities_section)                                \
-          lines.emplace_back(                                   \
-            addPoint(_p1x, _p1y), addPoint(_p2x, _p2y));        \
-          if (in_blocks_section && !current_block.empty())        \
-          blockdata[current_block].emplace_back(                \
-            addPoint(_p1x, _p1y), addPoint(_p2x, _p2y));        \
-} while (0)
+#define ADD_LINE(_x1, _y1, _x2, _y2)                                           \
+  do {                                                                         \
+    double _p1x = (_x1), _p1y = (_y1), _p2x = (_x2), _p2y = (_y2);             \
+    if (!in_entities_section && !in_blocks_section)                            \
+      break;                                                                   \
+    if (in_entities_section && !(layername.empty() || layername == layer))     \
+      break;                                                                   \
+    grid.align(_p1x, _p1y);                                                    \
+    grid.align(_p2x, _p2y);                                                    \
+    grid.data(_p1x, _p1y).push_back(lines.size());                             \
+    grid.data(_p2x, _p2y).push_back(lines.size());                             \
+    if (in_entities_section)                                                   \
+      lines.emplace_back(addPoint(_p1x, _p1y), addPoint(_p2x, _p2y));          \
+    if (in_blocks_section && !current_block.empty())                           \
+      blockdata[current_block].emplace_back(addPoint(_p1x, _p1y),              \
+                                            addPoint(_p2x, _p2y));             \
+  } while (0)
 
   std::string mode, layer, name, iddata;
   int dimtype = 0;
@@ -124,8 +122,8 @@ DxfData::DxfData(double fn, double fs, double fa,
   double arc_start_angle = 0, arc_stop_angle = 0;
   double ellipse_start_angle = 0, ellipse_stop_angle = 0;
 
-  for (auto& coord : coords) {
-    for (double& j : coord) {
+  for (auto &coord : coords) {
+    for (double &j : coord) {
       j = 0;
     }
   }
@@ -146,9 +144,10 @@ DxfData::DxfData(double fn, double fs, double fa,
     int id;
     try {
       id = boost::lexical_cast<int>(id_str);
-    } catch (const boost::bad_lexical_cast& blc) {
+    } catch (const boost::bad_lexical_cast &blc) {
       if (!stream.eof()) {
-        LOG(message_group::Warning, "Illegal ID '%1$s' in `%2$s'", id_str, filename);
+        LOG(message_group::Warning, "Illegal ID '%1$s' in `%2$s'", id_str,
+            filename);
       }
       break;
     }
@@ -159,7 +158,8 @@ DxfData::DxfData(double fn, double fs, double fa,
         } else if (id == 11 || id == 12 || id == 16) {
           coords[id - 10][0] = boost::lexical_cast<double>(data) * scale;
         } else {
-          coords[id - 10][0] = (boost::lexical_cast<double>(data) - xorigin) * scale;
+          coords[id - 10][0] =
+              (boost::lexical_cast<double>(data) - xorigin) * scale;
         }
       }
 
@@ -169,7 +169,8 @@ DxfData::DxfData(double fn, double fs, double fa,
         } else if (id == 21 || id == 22 || id == 26) {
           coords[id - 20][1] = boost::lexical_cast<double>(data) * scale;
         } else {
-          coords[id - 20][1] = (boost::lexical_cast<double>(data) - yorigin) * scale;
+          coords[id - 20][1] =
+              (boost::lexical_cast<double>(data) - yorigin) * scale;
         }
       }
 
@@ -182,14 +183,17 @@ DxfData::DxfData(double fn, double fs, double fa,
           ADD_LINE(xverts.at(0), yverts.at(0), xverts.at(1), yverts.at(1));
         } else if (mode == "LWPOLYLINE") {
           // assert(xverts.size() == yverts.size());
-          // Get maximum to enforce managed exception if xverts.size() != yverts.size()
+          // Get maximum to enforce managed exception if xverts.size() !=
+          // yverts.size()
           const int numverts = std::max(xverts.size(), yverts.size());
           for (int i = 1; i < numverts; ++i) {
-            ADD_LINE(xverts.at(i - 1), yverts.at(i - 1), xverts.at(i % numverts), yverts.at(i % numverts));
+            ADD_LINE(xverts.at(i - 1), yverts.at(i - 1),
+                     xverts.at(i % numverts), yverts.at(i % numverts));
           }
           // polyline flag is stored in 'dimtype'
           if (dimtype & 0x01) { // closed polyline
-            ADD_LINE(xverts.at(numverts - 1), yverts.at(numverts - 1), xverts.at(0), yverts.at(0));
+            ADD_LINE(xverts.at(numverts - 1), yverts.at(numverts - 1),
+                     xverts.at(0), yverts.at(0));
           }
         } else if (mode == "CIRCLE") {
           const int n = Calc::get_fragments_from_r(radius, fn, fs, fa);
@@ -197,8 +201,10 @@ DxfData::DxfData(double fn, double fs, double fa,
           for (int i = 0; i < n; ++i) {
             const double a1 = (360.0 * i) / n;
             const double a2 = (360.0 * (i + 1)) / n;
-            ADD_LINE(cos_degrees(a1) * radius + center[0], sin_degrees(a1) * radius + center[1],
-                     cos_degrees(a2) * radius + center[0], sin_degrees(a2) * radius + center[1]);
+            ADD_LINE(cos_degrees(a1) * radius + center[0],
+                     sin_degrees(a1) * radius + center[1],
+                     cos_degrees(a2) * radius + center[0],
+                     sin_degrees(a2) * radius + center[1]);
           }
         } else if (mode == "ARC") {
           Vector2d center(xverts.at(0), yverts.at(0));
@@ -211,69 +217,90 @@ DxfData::DxfData(double fn, double fs, double fa,
           for (int i = 0; i < n; ++i) {
             const double a1 = arc_start_angle + arc_angle * i / n;
             const double a2 = arc_start_angle + arc_angle * (i + 1) / n;
-            ADD_LINE(cos_degrees(a1) * radius + center[0], sin_degrees(a1) * radius + center[1],
-                     cos_degrees(a2) * radius + center[0], sin_degrees(a2) * radius + center[1]);
+            ADD_LINE(cos_degrees(a1) * radius + center[0],
+                     sin_degrees(a1) * radius + center[1],
+                     cos_degrees(a2) * radius + center[0],
+                     sin_degrees(a2) * radius + center[1]);
           }
         } else if (mode == "ELLIPSE") {
           // Commented code is meant as documentation of vector math
-          while (ellipse_start_angle > ellipse_stop_angle) ellipse_stop_angle += 2 * M_PI;
-//				Vector2d center(xverts[0], yverts[0]);
+          while (ellipse_start_angle > ellipse_stop_angle)
+            ellipse_stop_angle += 2 * M_PI;
+          //				Vector2d center(xverts[0], yverts[0]);
           Vector2d center(xverts.at(0), yverts.at(0));
-//				Vector2d ce(xverts[1], yverts[1]);
+          //				Vector2d ce(xverts[1], yverts[1]);
           Vector2d ce(xverts.at(1), yverts.at(1));
-//				double r_major = ce.length();
+          //				double r_major = ce.length();
           const double r_major = sqrt(ce[0] * ce[0] + ce[1] * ce[1]);
-//				double rot_angle = ce.angle();
+          //				double rot_angle = ce.angle();
           double rot_angle;
           {
-//					double dot = ce.dot(Vector2d(1.0, 0.0));
+            //					double dot =
+            //ce.dot(Vector2d(1.0, 0.0));
             const double dot = ce[0];
             double cosval = dot / r_major;
-            if (cosval > 1.0) cosval = 1.0;
-            if (cosval < -1.0) cosval = -1.0;
+            if (cosval > 1.0)
+              cosval = 1.0;
+            if (cosval < -1.0)
+              cosval = -1.0;
             rot_angle = acos(cosval);
-            if (ce[1] < 0.0) rot_angle = 2 * M_PI - rot_angle;
+            if (ce[1] < 0.0)
+              rot_angle = 2 * M_PI - rot_angle;
           }
 
-          // the ratio stored in 'radius; due to the parser code not checking entity type
+          // the ratio stored in 'radius; due to the parser code not checking
+          // entity type
           const double r_minor = r_major * radius;
           const double sweep_angle = ellipse_stop_angle - ellipse_start_angle;
           int n = Calc::get_fragments_from_r(r_major, fn, fs, fa);
           n = static_cast<int>(ceil(n * sweep_angle / (2 * M_PI)));
-//				Vector2d p1;
+          //				Vector2d p1;
           Vector2d p1{0.0, 0.0};
           for (int i = 0; i <= n; ++i) {
             const double a = (ellipse_start_angle + sweep_angle * i / n);
-//					Vector2d p2(cos(a)*r_major, sin(a)*r_minor);
+            //					Vector2d p2(cos(a)*r_major,
+            //sin(a)*r_minor);
             Vector2d p2(cos(a) * r_major, sin(a) * r_minor);
-//					p2.rotate(rot_angle);
+            //					p2.rotate(rot_angle);
             Vector2d p2_rot(cos(rot_angle) * p2[0] - sin(rot_angle) * p2[1],
                             sin(rot_angle) * p2[0] + cos(rot_angle) * p2[1]);
-//					p2 += center;
+            //					p2 += center;
             p2_rot[0] += center[0];
             p2_rot[1] += center[1];
             if (i > 0) {
-//            ADD_LINE(p1[0], p1[1], p2[0], p2[1]);
+              //            ADD_LINE(p1[0], p1[1], p2[0], p2[1]);
               ADD_LINE(p1[0], p1[1], p2_rot[0], p2_rot[1]);
             }
-//					p1 = p2;
+            //					p1 = p2;
             p1[0] = p2_rot[0];
             p1[1] = p2_rot[1];
           }
         } else if (mode == "INSERT") {
-          // scale is stored in ellipse_start|stop_angle, rotation in arc_start_angle;
-          // due to the parser code not checking entity type
+          // scale is stored in ellipse_start|stop_angle, rotation in
+          // arc_start_angle; due to the parser code not checking entity type
           const int n = blockdata[iddata].size();
           for (int i = 0; i < n; ++i) {
             const double a = arc_start_angle;
-            const double lx1 = this->points[blockdata[iddata][i].idx[0]][0] * ellipse_start_angle;
-            const double ly1 = this->points[blockdata[iddata][i].idx[0]][1] * ellipse_stop_angle;
-            const double lx2 = this->points[blockdata[iddata][i].idx[1]][0] * ellipse_start_angle;
-            const double ly2 = this->points[blockdata[iddata][i].idx[1]][1] * ellipse_stop_angle;
-            const double px1 = (cos_degrees(a) * lx1 - sin_degrees(a) * ly1) * scale + xverts.at(0);
-            const double py1 = (sin_degrees(a) * lx1 + cos_degrees(a) * ly1) * scale + yverts.at(0);
-            const double px2 = (cos_degrees(a) * lx2 - sin_degrees(a) * ly2) * scale + xverts.at(0);
-            const double py2 = (sin_degrees(a) * lx2 + cos_degrees(a) * ly2) * scale + yverts.at(0);
+            const double lx1 = this->points[blockdata[iddata][i].idx[0]][0] *
+                               ellipse_start_angle;
+            const double ly1 = this->points[blockdata[iddata][i].idx[0]][1] *
+                               ellipse_stop_angle;
+            const double lx2 = this->points[blockdata[iddata][i].idx[1]][0] *
+                               ellipse_start_angle;
+            const double ly2 = this->points[blockdata[iddata][i].idx[1]][1] *
+                               ellipse_stop_angle;
+            const double px1 =
+                (cos_degrees(a) * lx1 - sin_degrees(a) * ly1) * scale +
+                xverts.at(0);
+            const double py1 =
+                (sin_degrees(a) * lx1 + cos_degrees(a) * ly1) * scale +
+                yverts.at(0);
+            const double px2 =
+                (cos_degrees(a) * lx2 - sin_degrees(a) * ly2) * scale +
+                xverts.at(0);
+            const double py2 =
+                (sin_degrees(a) * lx2 + cos_degrees(a) * ly2) * scale +
+                yverts.at(0);
             ADD_LINE(px1, py1, px2, py2);
           }
         } else if (mode == "DIMENSION" &&
@@ -293,8 +320,9 @@ DxfData::DxfData(double fn, double fs, double fa,
         } else if (mode == "ENDBLK") {
           current_block.erase();
         } else if (mode == "ENDSEC") {
-        } else if (in_blocks_section || (in_entities_section &&
-                                         (layername.empty() || layername == layer))) {
+        } else if (in_blocks_section ||
+                   (in_entities_section &&
+                    (layername.empty() || layername == layer))) {
           unsupported_entities_list[mode]++;
         }
         mode = data;
@@ -302,8 +330,8 @@ DxfData::DxfData(double fn, double fs, double fa,
         name.erase();
         iddata.erase();
         dimtype = 0;
-        for (auto& coord : coords) {
-          for (double& j : coord) {
+        for (auto &coord : coords) {
+          for (double &j : coord) {
             j = 0;
           }
         }
@@ -324,20 +352,24 @@ DxfData::DxfData(double fn, double fs, double fa,
       case 8:
         layer = data;
         break;
-      case 10: [[fallthrough]];
+      case 10:
+        [[fallthrough]];
       case 11:
         if (in_blocks_section) {
           xverts.push_back((boost::lexical_cast<double>(data)));
         } else {
-          xverts.push_back((boost::lexical_cast<double>(data) - xorigin) * scale);
+          xverts.push_back((boost::lexical_cast<double>(data) - xorigin) *
+                           scale);
         }
         break;
-      case 20: [[fallthrough]];
+      case 20:
+        [[fallthrough]];
       case 21:
         if (in_blocks_section) {
           yverts.push_back((boost::lexical_cast<double>(data)));
         } else {
-          yverts.push_back((boost::lexical_cast<double>(data) - yorigin) * scale);
+          yverts.push_back((boost::lexical_cast<double>(data) - yorigin) *
+                           scale);
         }
         break;
       case 40:
@@ -345,7 +377,8 @@ DxfData::DxfData(double fn, double fs, double fa,
         // ELLIPSE: minor to major ratio
         // DIMENSION (radial, diameter): Leader length
         radius = boost::lexical_cast<double>(data);
-        if (!in_blocks_section) radius *= scale;
+        if (!in_blocks_section)
+          radius *= scale;
         break;
       case 41:
         // ELLIPSE: start_angle
@@ -372,20 +405,26 @@ DxfData::DxfData(double fn, double fs, double fa,
         dimtype = boost::lexical_cast<int>(data);
         break;
       }
-    } catch (boost::bad_lexical_cast& blc) {
-      LOG(message_group::Warning, "Illegal value '%1$s'in `%2$s'", data, filename);
-    } catch (const std::out_of_range& oor) {
-      LOG(message_group::Warning, "Not enough input values for %1$s. in '%2$s'", data, filename);
+    } catch (boost::bad_lexical_cast &blc) {
+      LOG(message_group::Warning, "Illegal value '%1$s'in `%2$s'", data,
+          filename);
+    } catch (const std::out_of_range &oor) {
+      LOG(message_group::Warning, "Not enough input values for %1$s. in '%2$s'",
+          data, filename);
     }
   }
 
-  for (const auto& i : unsupported_entities_list) {
+  for (const auto &i : unsupported_entities_list) {
     if (layername.empty()) {
       LOG(message_group::Warning,
-          "Unsupported DXF Entity '%1$s' (%2$x) in %3$s.", i.first, i.second, QuotedString(fs_uncomplete(filename, fs::current_path()).generic_string()));
+          "Unsupported DXF Entity '%1$s' (%2$x) in %3$s.", i.first, i.second,
+          QuotedString(
+              fs_uncomplete(filename, fs::current_path()).generic_string()));
     } else {
       LOG(message_group::Warning,
-          "Unsupported DXF Entity '%1$s' (%2$x) in layer '%3$s' of %4$s", i.first, i.second, layername, fs_uncomplete(filename, fs::current_path()).generic_string());
+          "Unsupported DXF Entity '%1$s' (%2$x) in layer '%3$s' of %4$s",
+          i.first, i.second, layername,
+          fs_uncomplete(filename, fs::current_path()).generic_string());
     }
   }
 
@@ -401,61 +440,69 @@ DxfData::DxfData(double fn, double fs, double fa,
   while (enabled_lines.size() > 0) {
     int current_line, current_point;
 
-    for (const auto& l : enabled_lines) {
+    for (const auto &l : enabled_lines) {
       const int idx = l.second;
       for (int j = 0; j < 2; ++j) {
-        auto lv = grid.data(this->points[lines[idx].idx[j]][0], this->points[lines[idx].idx[j]][1]);
+        auto lv = grid.data(this->points[lines[idx].idx[j]][0],
+                            this->points[lines[idx].idx[j]][1]);
         for (const int k : lv) {
           if (k < 0 || static_cast<unsigned int>(k) >= lines.size()) {
-            LOG(message_group::Warning,
-                "Bad DXF line index in %1$s.", QuotedString(fs_uncomplete(filename, fs::current_path()).generic_string()));
+            LOG(message_group::Warning, "Bad DXF line index in %1$s.",
+                QuotedString(fs_uncomplete(filename, fs::current_path())
+                                 .generic_string()));
             continue;
           }
-          if (k == idx || lines[k].disabled) continue;
+          if (k == idx || lines[k].disabled)
+            continue;
           goto next_open_path_j;
         }
         current_line = idx;
         current_point = j;
         goto create_open_path;
-next_open_path_j:;
+      next_open_path_j:;
       }
     }
 
     break;
 
-create_open_path:
+  create_open_path:
     this->paths.emplace_back();
     Path *this_path = &this->paths.back();
 
     this_path->indices.push_back(lines[current_line].idx[current_point]);
     while (true) {
       this_path->indices.push_back(lines[current_line].idx[!current_point]);
-      const auto& ref_point = this->points[lines[current_line].idx[!current_point]];
+      const auto &ref_point =
+          this->points[lines[current_line].idx[!current_point]];
       lines[current_line].disabled = true;
       enabled_lines.erase(current_line);
       auto lv = grid.data(ref_point[0], ref_point[1]);
       for (const int k : lv) {
         if (k < 0 || static_cast<unsigned int>(k) >= lines.size()) {
-          LOG(message_group::Warning,
-              "Bad DXF line index in %1$s.", QuotedString(fs_uncomplete(filename, fs::current_path()).generic_string()));
+          LOG(message_group::Warning, "Bad DXF line index in %1$s.",
+              QuotedString(fs_uncomplete(filename, fs::current_path())
+                               .generic_string()));
           continue;
         }
-        if (lines[k].disabled) continue;
+        if (lines[k].disabled)
+          continue;
         auto idk0 = lines[k].idx[0]; // make it easier to read and debug
         auto idk1 = lines[k].idx[1];
-        if (grid.eq(ref_point[0], ref_point[1], this->points[idk0][0], this->points[idk0][1])) {
+        if (grid.eq(ref_point[0], ref_point[1], this->points[idk0][0],
+                    this->points[idk0][1])) {
           current_line = k;
           current_point = 0;
           goto found_next_line_in_open_path;
         }
-        if (grid.eq(ref_point[0], ref_point[1], this->points[idk1][0], this->points[idk1][1])) {
+        if (grid.eq(ref_point[0], ref_point[1], this->points[idk1][0],
+                    this->points[idk1][1])) {
           current_line = k;
           current_point = 1;
           goto found_next_line_in_open_path;
         }
       }
       break;
-found_next_line_in_open_path:;
+    found_next_line_in_open_path:;
     }
   }
 
@@ -465,38 +512,43 @@ found_next_line_in_open_path:;
     int current_point = 0;
 
     this->paths.emplace_back();
-    auto& this_path = this->paths.back();
+    auto &this_path = this->paths.back();
     this_path.is_closed = true;
 
     this_path.indices.push_back(lines[current_line].idx[current_point]);
     while (true) {
       this_path.indices.push_back(lines[current_line].idx[!current_point]);
-      const auto& ref_point = this->points[lines[current_line].idx[!current_point]];
+      const auto &ref_point =
+          this->points[lines[current_line].idx[!current_point]];
       lines[current_line].disabled = true;
       enabled_lines.erase(current_line);
       auto lv = grid.data(ref_point[0], ref_point[1]);
       for (const int k : lv) {
         if (k < 0 || static_cast<unsigned int>(k) >= lines.size()) {
-          LOG(message_group::Warning,
-              "Bad DXF line index in %1$s.", QuotedString(fs_uncomplete(filename, fs::current_path()).generic_string()));
+          LOG(message_group::Warning, "Bad DXF line index in %1$s.",
+              QuotedString(fs_uncomplete(filename, fs::current_path())
+                               .generic_string()));
           continue;
         }
-        if (lines[k].disabled) continue;
+        if (lines[k].disabled)
+          continue;
         auto idk0 = lines[k].idx[0]; // make it easier to read and debug
         auto idk1 = lines[k].idx[1];
-        if (grid.eq(ref_point[0], ref_point[1], this->points[idk0][0], this->points[idk0][1])) {
+        if (grid.eq(ref_point[0], ref_point[1], this->points[idk0][0],
+                    this->points[idk0][1])) {
           current_line = k;
           current_point = 0;
           goto found_next_line_in_closed_path;
         }
-        if (grid.eq(ref_point[0], ref_point[1], this->points[idk1][0], this->points[idk1][1])) {
+        if (grid.eq(ref_point[0], ref_point[1], this->points[idk1][0],
+                    this->points[idk1][1])) {
           current_line = k;
           current_point = 1;
           goto found_next_line_in_closed_path;
         }
       }
       break;
-found_next_line_in_closed_path:;
+    found_next_line_in_closed_path:;
     }
   }
 
@@ -518,10 +570,10 @@ found_next_line_in_closed_path:;
    Ensures that all paths have the same vertex ordering.
    FIXME: CW or CCW?
  */
-void DxfData::fixup_path_direction()
-{
-  for (auto& path : this->paths) {
-    if (!path.is_closed) break;
+void DxfData::fixup_path_direction() {
+  for (auto &path : this->paths) {
+    if (!path.is_closed)
+      break;
     path.is_inner = true;
     double min_x = this->points[path.indices[0]][0];
     size_t min_x_point = 0;
@@ -535,17 +587,22 @@ void DxfData::fixup_path_direction()
     const size_t b = min_x_point;
     const size_t a = b == 0 ? path.indices.size() - 2 : b - 1;
     const size_t c = b == path.indices.size() - 1 ? 1 : b + 1;
-    const double ax = this->points[path.indices[a]][0] - this->points[path.indices[b]][0];
-    const double ay = this->points[path.indices[a]][1] - this->points[path.indices[b]][1];
-    const double cx = this->points[path.indices[c]][0] - this->points[path.indices[b]][0];
-    const double cy = this->points[path.indices[c]][1] - this->points[path.indices[b]][1];
+    const double ax =
+        this->points[path.indices[a]][0] - this->points[path.indices[b]][0];
+    const double ay =
+        this->points[path.indices[a]][1] - this->points[path.indices[b]][1];
+    const double cx =
+        this->points[path.indices[c]][0] - this->points[path.indices[b]][0];
+    const double cy =
+        this->points[path.indices[c]][1] - this->points[path.indices[b]][1];
 #if 0
     printf("Rotate check:\n");
     printf("  a/b/c indices = %d %d %d\n", a, b, c);
     printf("  b->a vector = %f %f (%f)\n", ax, ay, atan2(ax, ay));
     printf("  b->c vector = %f %f (%f)\n", cx, cy, atan2(cx, cy));
 #endif
-    // FIXME: atan2() usually takes y,x. This variant probably makes the path clockwise..
+    // FIXME: atan2() usually takes y,x. This variant probably makes the path
+    // clockwise..
     if (atan2(ax, ay) < atan2(cx, cy)) {
       std::reverse(path.indices.begin(), path.indices.end());
     }
@@ -555,27 +612,22 @@ void DxfData::fixup_path_direction()
 /*!
    Adds a vertex and returns the index into DxfData::points
  */
-int DxfData::addPoint(double x, double y)
-{
+int DxfData::addPoint(double x, double y) {
   this->points.emplace_back(x, y);
   return this->points.size() - 1;
 }
 
-std::string DxfData::dump() const
-{
+std::string DxfData::dump() const {
   std::ostringstream out;
   out << "DxfData"
-      << "\n num points: " << points.size()
-      << "\n num paths: " << paths.size()
-      << "\n num dims: " << dims.size()
-      << "\n points: ";
-  for (const auto& point : points) {
+      << "\n num points: " << points.size() << "\n num paths: " << paths.size()
+      << "\n num dims: " << dims.size() << "\n points: ";
+  for (const auto &point : points) {
     out << "\n  x y: " << point.transpose();
   }
   out << "\n paths: ";
   for (size_t i = 0; i < paths.size(); ++i) {
-    out << "\n  path:" << i
-        << "\n  is_closed: " << paths[i].is_closed
+    out << "\n  path:" << i << "\n  is_closed: " << paths[i].is_closed
         << "\n  is_inner: " << paths[i].is_inner;
     DxfData::Path path = paths[i];
     for (size_t j = 0; j < path.indices.size(); ++j) {
@@ -589,16 +641,18 @@ std::string DxfData::dump() const
 /*
     May return an empty polygon, but will not return nullptr
  */
-std::unique_ptr<Polygon2d> DxfData::toPolygon2d() const
-{
+std::unique_ptr<Polygon2d> DxfData::toPolygon2d() const {
   auto poly = std::make_unique<Polygon2d>();
-  for (const auto& path : this->paths) {
+  for (const auto &path : this->paths) {
     Outline2d outline;
     size_t endidx = path.indices.size();
-    // We don't support open paths; closing them to be compatible with existing behavior
-    if (!path.is_closed) endidx++;
+    // We don't support open paths; closing them to be compatible with existing
+    // behavior
+    if (!path.is_closed)
+      endidx++;
     for (size_t j = 1; j < endidx; ++j) {
-      outline.vertices.push_back(this->points[path.indices[path.indices.size() - j]]);
+      outline.vertices.push_back(
+          this->points[path.indices[path.indices.size() - j]]);
     }
     poly->addOutline(outline);
   }
diff --git a/src/io/DxfData.h b/src/io/DxfData.h
index bf136ecd0..40cb390c0 100644
--- a/src/io/DxfData.h
+++ b/src/io/DxfData.h
@@ -6,8 +6,7 @@
 
 #include "geometry/linalg.h"
 
-class DxfData
-{
+class DxfData {
 public:
   struct Path {
     std::vector<int> indices; // indices into DxfData::points
@@ -21,8 +20,8 @@ public:
     double length;
     std::string name;
     Dim() {
-      for (auto& coord : coords) {
-        for (double& j : coord) {
+      for (auto &coord : coords) {
+        for (double &j : coord) {
           j = 0;
         }
       }
@@ -37,9 +36,9 @@ public:
   std::vector<Dim> dims;
 
   DxfData() = default;
-  DxfData(double fn, double fs, double fa,
-          const std::string& filename, const std::string& layername = "",
-          double xorigin = 0.0, double yorigin = 0.0, double scale = 1.0);
+  DxfData(double fn, double fs, double fa, const std::string &filename,
+          const std::string &layername = "", double xorigin = 0.0,
+          double yorigin = 0.0, double scale = 1.0);
 
   int addPoint(double x, double y);
 
diff --git a/src/io/dxfdim.cc b/src/io/dxfdim.cc
index 91b876b7a..e03c2f500 100644
--- a/src/io/dxfdim.cc
+++ b/src/io/dxfdim.cc
@@ -37,9 +37,9 @@
 
 #include "core/AST.h"
 #include "core/Builtins.h"
-#include "core/function.h"
 #include "core/Parameters.h"
 #include "core/Value.h"
+#include "core/function.h"
 #include "handle_dep.h"
 #include "io/DxfData.h"
 #include "io/fileutils.h"
@@ -50,15 +50,17 @@ std::unordered_map<std::string, double> dxf_dim_cache;
 std::unordered_map<std::string, std::vector<double>> dxf_cross_cache;
 namespace fs = std::filesystem;
 
-static Value builtin_dxf_dim(Arguments arguments, const Location& loc)
-{
-  const Parameters parameters = Parameters::parse(std::move(arguments), loc, {}, {"file", "layer", "origin", "scale", "name"});
+static Value builtin_dxf_dim(Arguments arguments, const Location &loc) {
+  const Parameters parameters =
+      Parameters::parse(std::move(arguments), loc, {},
+                        {"file", "layer", "origin", "scale", "name"});
 
   std::string rawFilename;
   std::string filename;
   if (parameters.contains("file")) {
     rawFilename = parameters["file"].toString();
-    filename = lookup_file(rawFilename, loc.filePath().parent_path().string(), parameters.documentRoot());
+    filename = lookup_file(rawFilename, loc.filePath().parent_path().string(),
+                           parameters.documentRoot());
   }
   double xorigin = 0;
   double yorigin = 0;
@@ -66,7 +68,9 @@ static Value builtin_dxf_dim(Arguments arguments, const Location& loc)
     bool originOk = parameters["origin"].getVec2(xorigin, yorigin);
     originOk &= std::isfinite(xorigin) && std::isfinite(yorigin);
     if (!originOk) {
-      LOG(message_group::Warning, loc, parameters.documentRoot(), "dxf_dim(..., origin=%1$s) could not be converted", parameters["origin"].toEchoString());
+      LOG(message_group::Warning, loc, parameters.documentRoot(),
+          "dxf_dim(..., origin=%1$s) could not be converted",
+          parameters["origin"].toEchoString());
     }
   }
   std::string layername = parameters.get("layer", "");
@@ -82,19 +86,22 @@ static Value builtin_dxf_dim(Arguments arguments, const Location& loc)
       lastwritetime = fs_timestamp(filepath);
     }
   } else {
-    LOG(message_group::Warning, loc, parameters.documentRoot(), "Can't open DXF file '%1$s'!", rawFilename);
+    LOG(message_group::Warning, loc, parameters.documentRoot(),
+        "Can't open DXF file '%1$s'!", rawFilename);
     return Value::undefined.clone();
   }
-  const std::string key = STR(filename, "|", layername, "|", name, "|", xorigin,
-                              "|", yorigin, "|", scale, "|", lastwritetime,
-                              "|", filesize);
+  const std::string key =
+      STR(filename, "|", layername, "|", name, "|", xorigin, "|", yorigin, "|",
+          scale, "|", lastwritetime, "|", filesize);
   auto result = dxf_dim_cache.find(key);
-  if (result != dxf_dim_cache.end()) return {result->second};
+  if (result != dxf_dim_cache.end())
+    return {result->second};
   handle_dep(filepath.string());
   DxfData dxf(36, 0, 0, filename, layername, xorigin, yorigin, scale);
 
-  for (auto& dim : dxf.dims) {
-    if (!name.empty() && dim.name != name) continue;
+  for (auto &dim : dxf.dims) {
+    if (!name.empty() && dim.name != name)
+      continue;
 
     DxfData::Dim *d = &dim;
     const int type = d->type & 7;
@@ -104,7 +111,8 @@ static Value builtin_dxf_dim(Arguments arguments, const Location& loc)
       const double x = d->coords[4][0] - d->coords[3][0];
       const double y = d->coords[4][1] - d->coords[3][1];
       const double angle = d->angle;
-      const double distance_projected_on_line = std::fabs(x * cos_degrees(angle) + y * sin_degrees(angle));
+      const double distance_projected_on_line =
+          std::fabs(x * cos_degrees(angle) + y * sin_degrees(angle));
       dxf_dim_cache.emplace(key, distance_projected_on_line);
       return {distance_projected_on_line};
     } else if (type == 1) {
@@ -116,8 +124,10 @@ static Value builtin_dxf_dim(Arguments arguments, const Location& loc)
       return {value};
     } else if (type == 2) {
       // Angular
-      const double a1 = atan2_degrees(d->coords[0][0] - d->coords[5][0], d->coords[0][1] - d->coords[5][1]);
-      const double a2 = atan2_degrees(d->coords[4][0] - d->coords[3][0], d->coords[4][1] - d->coords[3][1]);
+      const double a1 = atan2_degrees(d->coords[0][0] - d->coords[5][0],
+                                      d->coords[0][1] - d->coords[5][1]);
+      const double a2 = atan2_degrees(d->coords[4][0] - d->coords[3][0],
+                                      d->coords[4][1] - d->coords[3][1]);
       const double value = std::fabs(a1 - a2);
       dxf_dim_cache.emplace(key, value);
       return {value};
@@ -137,25 +147,31 @@ static Value builtin_dxf_dim(Arguments arguments, const Location& loc)
       return {value};
     }
 
-    LOG(message_group::Warning, loc, parameters.documentRoot(), "Dimension '%1$s' in '%2$s', layer '%3$s' has unsupported type!", name, rawFilename, layername);
+    LOG(message_group::Warning, loc, parameters.documentRoot(),
+        "Dimension '%1$s' in '%2$s', layer '%3$s' has unsupported type!", name,
+        rawFilename, layername);
     return Value::undefined.clone();
   }
 
-  LOG(message_group::Warning, loc, parameters.documentRoot(), "Can't find dimension '%1$s' in '%2$s', layer '%3$s'!", name, rawFilename, layername);
+  LOG(message_group::Warning, loc, parameters.documentRoot(),
+      "Can't find dimension '%1$s' in '%2$s', layer '%3$s'!", name, rawFilename,
+      layername);
 
   return Value::undefined.clone();
 }
 
-static Value builtin_dxf_cross(Arguments arguments, const Location& loc)
-{
+static Value builtin_dxf_cross(Arguments arguments, const Location &loc) {
   auto *session = arguments.session();
-  const Parameters parameters = Parameters::parse(std::move(arguments), loc, {}, {"file", "layer", "origin", "scale", "name"});
+  const Parameters parameters =
+      Parameters::parse(std::move(arguments), loc, {},
+                        {"file", "layer", "origin", "scale", "name"});
 
   std::string rawFilename;
   std::string filename;
   if (parameters.contains("file")) {
     rawFilename = parameters["file"].toString();
-    filename = lookup_file(rawFilename, loc.filePath().parent_path().string(), parameters.documentRoot());
+    filename = lookup_file(rawFilename, loc.filePath().parent_path().string(),
+                           parameters.documentRoot());
   }
   double xorigin = 0;
   double yorigin = 0;
@@ -163,7 +179,9 @@ static Value builtin_dxf_cross(Arguments arguments, const Location& loc)
     bool originOk = parameters["origin"].getVec2(xorigin, yorigin);
     originOk &= std::isfinite(xorigin) && std::isfinite(yorigin);
     if (!originOk) {
-      LOG(message_group::Warning, loc, parameters.documentRoot(), "dxf_cross(..., origin=%1$s) could not be converted", parameters["origin"].toEchoString());
+      LOG(message_group::Warning, loc, parameters.documentRoot(),
+          "dxf_cross(..., origin=%1$s) could not be converted",
+          parameters["origin"].toEchoString());
     }
   }
   std::string layername = parameters.get("layer", "");
@@ -178,13 +196,14 @@ static Value builtin_dxf_cross(Arguments arguments, const Location& loc)
       lastwritetime = fs_timestamp(filepath);
     }
   } else {
-    LOG(message_group::Warning, loc, parameters.documentRoot(), "Can't open DXF file '%1$s'!", rawFilename);
+    LOG(message_group::Warning, loc, parameters.documentRoot(),
+        "Can't open DXF file '%1$s'!", rawFilename);
     return Value::undefined.clone();
   }
 
-  const std::string key = STR(filename, "|", layername, "|", xorigin, "|", yorigin,
-                              "|", scale, "|", lastwritetime,
-                              "|", filesize);
+  const std::string key =
+      STR(filename, "|", layername, "|", xorigin, "|", yorigin, "|", scale, "|",
+          lastwritetime, "|", filesize);
 
   auto result = dxf_cross_cache.find(key);
   if (result != dxf_cross_cache.end()) {
@@ -201,7 +220,8 @@ static Value builtin_dxf_cross(Arguments arguments, const Location& loc)
   double coords[4][2];
 
   for (size_t i = 0, j = 0; i < dxf.paths.size(); ++i) {
-    if (dxf.paths[i].indices.size() != 2) continue;
+    if (dxf.paths[i].indices.size() != 2)
+      continue;
     coords[j][0] = dxf.points[dxf.paths[i].indices[0]][0];
     coords[j++][1] = dxf.points[dxf.paths[i].indices[0]][1];
     coords[j][0] = dxf.points[dxf.paths[i].indices[1]][0];
@@ -213,7 +233,8 @@ static Value builtin_dxf_cross(Arguments arguments, const Location& loc)
       const double x3 = coords[2][0], y3 = coords[2][1];
       const double x4 = coords[3][0], y4 = coords[3][1];
       const double dem = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
-      if (dem == 0) break;
+      if (dem == 0)
+        break;
       const double ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / dem;
       // double ub = ((x2 - x1)*(y1 - y3) - (y2 - y1)*(x1 - x3)) / dem;
       const double x = x1 + ua * (x2 - x1);
@@ -229,19 +250,19 @@ static Value builtin_dxf_cross(Arguments arguments, const Location& loc)
     }
   }
 
-  LOG(message_group::Warning, loc, parameters.documentRoot(), "Can't find cross in '%1$s', layer '%2$s'!", rawFilename, layername);
+  LOG(message_group::Warning, loc, parameters.documentRoot(),
+      "Can't find cross in '%1$s', layer '%2$s'!", rawFilename, layername);
   return Value::undefined.clone();
 }
 
-void initialize_builtin_dxf_dim()
-{
+void initialize_builtin_dxf_dim() {
   Builtins::init("dxf_dim", new BuiltinFunction(&builtin_dxf_dim),
-  {
-    "dxf_dim()",
-  });
+                 {
+                     "dxf_dim()",
+                 });
 
   Builtins::init("dxf_cross", new BuiltinFunction(&builtin_dxf_cross),
-  {
-    "dxf_cross()",
-  });
+                 {
+                     "dxf_cross()",
+                 });
 }
diff --git a/src/io/export.cc b/src/io/export.cc
index 9a3dfd14a..a6909279e 100644
--- a/src/io/export.cc
+++ b/src/io/export.cc
@@ -44,21 +44,20 @@
 #include <vector>
 
 #ifdef _WIN32
-#include <io.h>
 #include <fcntl.h>
+#include <io.h>
 #endif
 
 #include "geometry/Geometry.h"
 #include "geometry/GeometryUtils.h"
-#include "geometry/linalg.h"
 #include "geometry/PolySet.h"
+#include "geometry/linalg.h"
 #include "glview/Camera.h"
 #include "glview/ColorMap.h"
 #include "glview/RenderSettings.h"
 #include "utils/printutils.h"
 
-
-#define QUOTE(x__) # x__
+#define QUOTE(x__) #x__
 #define QUOTED(x__) QUOTE(x__)
 
 namespace {
@@ -68,59 +67,60 @@ struct Containers {
   std::map<FileFormat, FileFormatInfo> fileFormatToInfo;
 };
 
-void add_item(Containers& containers, const FileFormatInfo& info) {
+void add_item(Containers &containers, const FileFormatInfo &info) {
   containers.identifierToInfo[info.identifier] = info;
   containers.fileFormatToInfo[info.format] = info;
 }
 
-Containers& containers() {
-  static std::unique_ptr<Containers> containers = [](){
-      auto containers = std::make_unique<Containers>();
-
-      add_item(*containers, {FileFormat::ASCII_STL, "asciistl", "stl", "STL (ascii)"});
-      add_item(*containers, {FileFormat::BINARY_STL, "binstl", "stl", "STL (binary)"});
-      add_item(*containers, {FileFormat::OBJ, "obj", "obj", "OBJ"});
-      add_item(*containers, {FileFormat::OFF, "off", "off", "OFF"});
-      add_item(*containers, {FileFormat::WRL, "wrl", "wrl", "VRML"});
-      add_item(*containers, {FileFormat::AMF, "amf", "amf", "AMF"});
-      add_item(*containers, {FileFormat::_3MF, "3mf", "3mf", "3MF"});
-      add_item(*containers, {FileFormat::DXF, "dxf", "dxf", "DXF"});
-      add_item(*containers, {FileFormat::SVG, "svg", "svg", "SVG"});
-      add_item(*containers, {FileFormat::NEFDBG, "nefdbg", "nefdbg", "nefdbg"});
-      add_item(*containers, {FileFormat::NEF3, "nef3", "nef3", "nef3"});
-      add_item(*containers, {FileFormat::CSG, "csg", "csg", "CSG"});
-      add_item(*containers, {FileFormat::PARAM, "param", "param", "param"});
-      add_item(*containers, {FileFormat::AST, "ast", "ast", "AST"});
-      add_item(*containers, {FileFormat::TERM, "term", "term", "term"});
-      add_item(*containers, {FileFormat::ECHO, "echo", "echo", "echo"});
-      add_item(*containers, {FileFormat::PNG, "png", "png", "PNG"});
-      add_item(*containers, {FileFormat::PDF, "pdf", "pdf", "PDF"});
-      add_item(*containers, {FileFormat::POV, "pov", "pov", "POV"});
-
-      // Alias
-      containers->identifierToInfo["stl"] = containers->identifierToInfo["asciistl"];
-      return containers;
-    }();
+Containers &containers() {
+  static std::unique_ptr<Containers> containers = []() {
+    auto containers = std::make_unique<Containers>();
+
+    add_item(*containers,
+             {FileFormat::ASCII_STL, "asciistl", "stl", "STL (ascii)"});
+    add_item(*containers,
+             {FileFormat::BINARY_STL, "binstl", "stl", "STL (binary)"});
+    add_item(*containers, {FileFormat::OBJ, "obj", "obj", "OBJ"});
+    add_item(*containers, {FileFormat::OFF, "off", "off", "OFF"});
+    add_item(*containers, {FileFormat::WRL, "wrl", "wrl", "VRML"});
+    add_item(*containers, {FileFormat::AMF, "amf", "amf", "AMF"});
+    add_item(*containers, {FileFormat::_3MF, "3mf", "3mf", "3MF"});
+    add_item(*containers, {FileFormat::DXF, "dxf", "dxf", "DXF"});
+    add_item(*containers, {FileFormat::SVG, "svg", "svg", "SVG"});
+    add_item(*containers, {FileFormat::NEFDBG, "nefdbg", "nefdbg", "nefdbg"});
+    add_item(*containers, {FileFormat::NEF3, "nef3", "nef3", "nef3"});
+    add_item(*containers, {FileFormat::CSG, "csg", "csg", "CSG"});
+    add_item(*containers, {FileFormat::PARAM, "param", "param", "param"});
+    add_item(*containers, {FileFormat::AST, "ast", "ast", "AST"});
+    add_item(*containers, {FileFormat::TERM, "term", "term", "term"});
+    add_item(*containers, {FileFormat::ECHO, "echo", "echo", "echo"});
+    add_item(*containers, {FileFormat::PNG, "png", "png", "PNG"});
+    add_item(*containers, {FileFormat::PDF, "pdf", "pdf", "PDF"});
+    add_item(*containers, {FileFormat::POV, "pov", "pov", "POV"});
+
+    // Alias
+    containers->identifierToInfo["stl"] =
+        containers->identifierToInfo["asciistl"];
+    return containers;
+  }();
   return *containers;
 }
 
-}  // namespace
+} // namespace
 
 namespace fileformat {
 
-std::vector<FileFormat> all()
-{
+std::vector<FileFormat> all() {
   std::vector<FileFormat> allFileFormats;
-  for (const auto& item : containers().fileFormatToInfo) {
+  for (const auto &item : containers().fileFormatToInfo) {
     allFileFormats.push_back(item.first);
   }
   return allFileFormats;
 }
 
-std::vector<FileFormat> all2D()
-{
+std::vector<FileFormat> all2D() {
   std::vector<FileFormat> all2DFormats;
-  for (const auto& item : containers().fileFormatToInfo) {
+  for (const auto &item : containers().fileFormatToInfo) {
     if (is2D(item.first)) {
       all2DFormats.push_back(item.first);
     }
@@ -128,10 +128,9 @@ std::vector<FileFormat> all2D()
   return all2DFormats;
 }
 
-std::vector<FileFormat> all3D()
-{
+std::vector<FileFormat> all3D() {
   std::vector<FileFormat> all3DFormats;
-  for (const auto& item : containers().fileFormatToInfo) {
+  for (const auto &item : containers().fileFormatToInfo) {
     if (is3D(item.first)) {
       all3DFormats.push_back(item.first);
     }
@@ -139,65 +138,58 @@ std::vector<FileFormat> all3D()
   return all3DFormats;
 }
 
-const FileFormatInfo& info(FileFormat fileFormat)
-{
+const FileFormatInfo &info(FileFormat fileFormat) {
   return containers().fileFormatToInfo[fileFormat];
 }
 
-bool fromIdentifier(const std::string& identifier, FileFormat& format)
-{
+bool fromIdentifier(const std::string &identifier, FileFormat &format) {
   auto it = containers().identifierToInfo.find(identifier);
-  if (it == containers().identifierToInfo.end()) return false;
+  if (it == containers().identifierToInfo.end())
+    return false;
   format = it->second.format;
   return true;
 }
 
-const std::string& toSuffix(FileFormat format)
-{
+const std::string &toSuffix(FileFormat format) {
   return containers().fileFormatToInfo[format].suffix;
 }
 
 bool canPreview(FileFormat format) {
-  return (format == FileFormat::AST ||
-          format == FileFormat::CSG ||
-          format == FileFormat::PARAM ||
-          format == FileFormat::ECHO ||
-          format == FileFormat::TERM ||
-          format == FileFormat::PNG);
+  return (format == FileFormat::AST || format == FileFormat::CSG ||
+          format == FileFormat::PARAM || format == FileFormat::ECHO ||
+          format == FileFormat::TERM || format == FileFormat::PNG);
 }
 
 bool is3D(FileFormat format) {
-  return format == FileFormat::ASCII_STL ||
-         format == FileFormat::BINARY_STL ||
-         format == FileFormat::OBJ ||
-         format == FileFormat::OFF ||
-         format == FileFormat::WRL ||
-         format == FileFormat::AMF ||
-         format == FileFormat::_3MF ||
-         format == FileFormat::NEFDBG ||
-         format == FileFormat::NEF3 ||
-         format == FileFormat::POV;
+  return format == FileFormat::ASCII_STL || format == FileFormat::BINARY_STL ||
+         format == FileFormat::OBJ || format == FileFormat::OFF ||
+         format == FileFormat::WRL || format == FileFormat::AMF ||
+         format == FileFormat::_3MF || format == FileFormat::NEFDBG ||
+         format == FileFormat::NEF3 || format == FileFormat::POV;
 }
 
 bool is2D(FileFormat format) {
-  return format == FileFormat::DXF ||
-         format == FileFormat::SVG ||
+  return format == FileFormat::DXF || format == FileFormat::SVG ||
          format == FileFormat::PDF;
 }
 
-}  // namespace FileFormat
+} // namespace fileformat
 
-ExportInfo createExportInfo(const FileFormat& format, const FileFormatInfo& info, const std::string& filepath, const Camera *camera, const CmdLineExportOptions& cmdLineOptions)
-{
-  const auto colorScheme = ColorMap::inst()->findColorScheme(RenderSettings::inst()->colorscheme);
+ExportInfo createExportInfo(const FileFormat &format,
+                            const FileFormatInfo &info,
+                            const std::string &filepath, const Camera *camera,
+                            const CmdLineExportOptions &cmdLineOptions) {
+  const auto colorScheme =
+      ColorMap::inst()->findColorScheme(RenderSettings::inst()->colorscheme);
   auto exportInfo = ExportInfo{
-    .format = format,
-    .info = info,
-    .title = std::filesystem::path(filepath).filename().string(),
-    .sourceFilePath = filepath,
-    .camera = camera,
-    .defaultColor = ColorMap::getColor(*colorScheme, RenderColor::CGAL_FACE_FRONT_COLOR),
-    .colorScheme = colorScheme,
+      .format = format,
+      .info = info,
+      .title = std::filesystem::path(filepath).filename().string(),
+      .sourceFilePath = filepath,
+      .camera = camera,
+      .defaultColor =
+          ColorMap::getColor(*colorScheme, RenderColor::CGAL_FACE_FRONT_COLOR),
+      .colorScheme = colorScheme,
   };
 
   if (format == FileFormat::_3MF) {
@@ -209,8 +201,8 @@ ExportInfo createExportInfo(const FileFormat& format, const FileFormatInfo& info
   return exportInfo;
 }
 
-static void exportFile(const std::shared_ptr<const Geometry>& root_geom, std::ostream& output, const ExportInfo& exportInfo)
-{
+static void exportFile(const std::shared_ptr<const Geometry> &root_geom,
+                       std::ostream &output, const ExportInfo &exportInfo) {
   switch (exportInfo.format) {
   case FileFormat::ASCII_STL:
     export_stl(root_geom, output, false);
@@ -258,8 +250,8 @@ static void exportFile(const std::shared_ptr<const Geometry>& root_geom, std::os
   }
 }
 
-bool exportFileStdOut(const std::shared_ptr<const Geometry>& root_geom, const ExportInfo& exportInfo)
-{
+bool exportFileStdOut(const std::shared_ptr<const Geometry> &root_geom,
+                      const ExportInfo &exportInfo) {
 #ifdef _WIN32
   _setmode(_fileno(stdout), _O_BINARY);
 #endif
@@ -267,10 +259,13 @@ bool exportFileStdOut(const std::shared_ptr<const Geometry>& root_geom, const Ex
   return true;
 }
 
-bool exportFileByName(const std::shared_ptr<const Geometry>& root_geom, const std::string& filename, const ExportInfo& exportInfo)
-{
+bool exportFileByName(const std::shared_ptr<const Geometry> &root_geom,
+                      const std::string &filename,
+                      const ExportInfo &exportInfo) {
   std::ios::openmode mode = std::ios::out | std::ios::trunc;
-  if (exportInfo.format == FileFormat::_3MF || exportInfo.format == FileFormat::BINARY_STL || exportInfo.format == FileFormat::PDF) {
+  if (exportInfo.format == FileFormat::_3MF ||
+      exportInfo.format == FileFormat::BINARY_STL ||
+      exportInfo.format == FileFormat::PDF) {
     mode |= std::ios::binary;
   }
   const std::filesystem::path path(filename);
@@ -283,16 +278,17 @@ bool exportFileByName(const std::shared_ptr<const Geometry>& root_geom, const st
     fstream.exceptions(std::ios::badbit | std::ios::failbit);
     try {
       exportFile(root_geom, fstream, exportInfo);
-    } catch (std::ios::failure&) {
+    } catch (std::ios::failure &) {
       onerror = true;
     }
     try { // make sure file closed - resources released
       fstream.close();
-    } catch (std::ios::failure&) {
+    } catch (std::ios::failure &) {
       onerror = true;
     }
     if (onerror) {
-      LOG(message_group::Error, _("\"%1$s\" write error. (Disk full?)"), filename);
+      LOG(message_group::Error, _("\"%1$s\" write error. (Disk full?)"),
+          filename);
     }
     return !onerror;
   }
@@ -300,31 +296,30 @@ bool exportFileByName(const std::shared_ptr<const Geometry>& root_geom, const st
 
 namespace {
 
-double remove_negative_zero(double x) {
-  return x == -0 ? 0 : x;
-}
+double remove_negative_zero(double x) { return x == -0 ? 0 : x; }
 
-Vector3d remove_negative_zero(const Vector3d& pt) {
+Vector3d remove_negative_zero(const Vector3d &pt) {
   return {
-    remove_negative_zero(pt[0]),
-    remove_negative_zero(pt[1]),
-    remove_negative_zero(pt[2]),
+      remove_negative_zero(pt[0]),
+      remove_negative_zero(pt[1]),
+      remove_negative_zero(pt[2]),
   };
 }
 
 #if EIGEN_VERSION_AT_LEAST(3, 4, 0)
 // Eigen 3.4.0 added begin()/end()
 struct LexographicLess {
-  template <class T>
-  bool operator()(T const& lhs, T const& rhs) const {
-    return std::lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end(), std::less{});
+  template <class T> bool operator()(T const &lhs, T const &rhs) const {
+    return std::lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(),
+                                        rhs.end(), std::less{});
   }
 };
 #else
 struct LexographicLess {
-  template <class T>
-  bool operator()(T const& lhs, T const& rhs) const {
-    return std::lexicographical_compare(lhs.data(), lhs.data() + lhs.size(), rhs.data(), rhs.data() + rhs.size(), std::less{});
+  template <class T> bool operator()(T const &lhs, T const &rhs) const {
+    return std::lexicographical_compare(lhs.data(), lhs.data() + lhs.size(),
+                                        rhs.data(), rhs.data() + rhs.size(),
+                                        std::less{});
   }
 };
 #endif // if EIGEN_VERSION_AT_LEAST(3, 4, 0)
@@ -334,21 +329,23 @@ struct LexographicLess {
 std::string get_current_iso8601_date_time_utc() {
   auto now = std::chrono::system_clock::now();
   auto time = std::chrono::system_clock::to_time_t(now);
-  return STR(std::put_time(gmtime(&time), "%Y-%m-%dT%H:%M:%SZ")); // %F/%T not fully supported everywhere
+  return STR(std::put_time(
+      gmtime(&time),
+      "%Y-%m-%dT%H:%M:%SZ")); // %F/%T not fully supported everywhere
 }
 
-std::unique_ptr<PolySet> createSortedPolySet(const PolySet& ps)
-{
+std::unique_ptr<PolySet> createSortedPolySet(const PolySet &ps) {
   auto out = std::make_unique<PolySet>(ps.getDimension(), ps.convexValue());
   out->setTriangular(ps.isTriangular());
   out->setConvexity(ps.getConvexity());
 
   std::map<Vector3d, int, LexographicLess> vertexMap;
 
-  for (const auto& poly : ps.indices) {
+  for (const auto &poly : ps.indices) {
     IndexedFace face;
     for (const auto idx : poly) {
-      auto pos = vertexMap.emplace(remove_negative_zero(ps.vertices[idx]), vertexMap.size());
+      auto pos = vertexMap.emplace(remove_negative_zero(ps.vertices[idx]),
+                                   vertexMap.size());
       face.push_back(pos.first->second);
     }
     out->indices.push_back(face);
@@ -359,17 +356,19 @@ std::unique_ptr<PolySet> createSortedPolySet(const PolySet& ps)
   std::vector<int> indexTranslationMap(vertexMap.size());
   out->vertices.reserve(vertexMap.size());
 
-  for (const auto& [v, i] : vertexMap) {
+  for (const auto &[v, i] : vertexMap) {
     indexTranslationMap[i] = out->vertices.size();
     out->vertices.push_back(v);
   }
 
-  for (auto& poly : out->indices) {
+  for (auto &poly : out->indices) {
     IndexedFace polygon;
     for (const auto idx : poly) {
       polygon.push_back(indexTranslationMap[idx]);
     }
-    std::rotate(polygon.begin(), std::min_element(polygon.begin(), polygon.end()), polygon.end());
+    std::rotate(polygon.begin(),
+                std::min_element(polygon.begin(), polygon.end()),
+                polygon.end());
     poly = polygon;
   }
   if (ps.color_indices.empty()) {
@@ -384,11 +383,12 @@ std::unique_ptr<PolySet> createSortedPolySet(const PolySet& ps)
     for (size_t i = 0, n = ps.indices.size(); i < n; i++) {
       faces.push_back({out->indices[i], out->color_indices[i]});
     }
-    std::sort(faces.begin(), faces.end(), [](const ColoredFace& a, const ColoredFace& b) {
-      return a.face < b.face;
-    });
+    std::sort(faces.begin(), faces.end(),
+              [](const ColoredFace &a, const ColoredFace &b) {
+                return a.face < b.face;
+              });
     for (size_t i = 0, n = faces.size(); i < n; i++) {
-      auto& face = faces[i];
+      auto &face = faces[i];
       out->indices[i] = face.face;
       out->color_indices[i] = face.color_index;
     }
diff --git a/src/io/export.h b/src/io/export.h
index 7b4086e92..1170d93d6 100644
--- a/src/io/export.h
+++ b/src/io/export.h
@@ -9,12 +9,12 @@
 #include <unordered_map>
 #include <vector>
 
-#include <boost/range/algorithm.hpp>
 #include <boost/range/adaptor/map.hpp>
+#include <boost/range/algorithm.hpp>
 
 #include "core/Settings.h"
-#include "core/Tree.h"
 #include "core/SourceFile.h"
+#include "core/Tree.h"
 #include "geometry/Geometry.h"
 #include "geometry/linalg.h"
 #include "glview/Camera.h"
@@ -63,25 +63,28 @@ std::vector<FileFormat> all();
 std::vector<FileFormat> all2D();
 std::vector<FileFormat> all3D();
 
-const FileFormatInfo& info(FileFormat fileFormat);
-bool fromIdentifier(const std::string& identifier, FileFormat& format);
-const std::string& toSuffix(FileFormat format);
+const FileFormatInfo &info(FileFormat fileFormat);
+bool fromIdentifier(const std::string &identifier, FileFormat &format);
+const std::string &toSuffix(FileFormat format);
 bool canPreview(FileFormat format);
 bool is3D(FileFormat format);
 bool is2D(FileFormat format);
 
-}  // namespace FileFormat
+} // namespace fileformat
 
-using CmdLineExportOptions = std::unordered_map<std::string, std::unordered_map<std::string, std::string>>;
+using CmdLineExportOptions =
+    std::unordered_map<std::string,
+                       std::unordered_map<std::string, std::string>>;
 
 template <typename settings_entry_type>
-auto set_cmd_line_option(const CmdLineExportOptions& cmdLineOptions, const std::string& section, const settings_entry_type& se)
-{
+auto set_cmd_line_option(const CmdLineExportOptions &cmdLineOptions,
+                         const std::string &section,
+                         const settings_entry_type &se) {
   if (cmdLineOptions.count(section) == 0) {
     return se.defaultValue();
   }
 
-  const auto& o = cmdLineOptions.at(section);
+  const auto &o = cmdLineOptions.at(section);
   if (o.count(se.name()) == 0) {
     return se.defaultValue();
   }
@@ -110,47 +113,88 @@ struct ExportPdfOptions {
   std::string strokeColor = "black";
   double strokeWidth = 1;
 
-  static std::shared_ptr<const ExportPdfOptions> withOptions(const CmdLineExportOptions& cmdLineOptions) {
+  static std::shared_ptr<const ExportPdfOptions>
+  withOptions(const CmdLineExportOptions &cmdLineOptions) {
     return std::make_shared<const ExportPdfOptions>(ExportPdfOptions{
-      .showScale = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfShowScale),
-      .showScaleMsg = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfShowScaleMessage),
-      .showGrid = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfShowGrid),
-      .gridSize = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfGridSize),
-      .showDesignFilename = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfShowFilename),
-      .orientation = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfOrientation),
-      .paperSize = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfPaperSize),
-      .addMetaData = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfAddMetaData),
-      .metaDataTitle = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfMetaDataTitle),
-      .metaDataAuthor = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfMetaDataAuthor),
-      .metaDataSubject = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfMetaDataSubject),
-      .metaDataKeywords = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfMetaDataKeywords),
-      .fill = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfFill),
-      .fillColor = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfFillColor),
-      .stroke = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfStroke),
-      .strokeColor = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfStrokeColor),
-      .strokeWidth = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF, Settings::SettingsExportPdf::exportPdfStrokeWidth),
+        .showScale = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+            Settings::SettingsExportPdf::exportPdfShowScale),
+        .showScaleMsg = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+            Settings::SettingsExportPdf::exportPdfShowScaleMessage),
+        .showGrid =
+            set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+                                Settings::SettingsExportPdf::exportPdfShowGrid),
+        .gridSize =
+            set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+                                Settings::SettingsExportPdf::exportPdfGridSize),
+        .showDesignFilename = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+            Settings::SettingsExportPdf::exportPdfShowFilename),
+        .orientation = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+            Settings::SettingsExportPdf::exportPdfOrientation),
+        .paperSize = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+            Settings::SettingsExportPdf::exportPdfPaperSize),
+        .addMetaData = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+            Settings::SettingsExportPdf::exportPdfAddMetaData),
+        .metaDataTitle = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+            Settings::SettingsExportPdf::exportPdfMetaDataTitle),
+        .metaDataAuthor = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+            Settings::SettingsExportPdf::exportPdfMetaDataAuthor),
+        .metaDataSubject = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+            Settings::SettingsExportPdf::exportPdfMetaDataSubject),
+        .metaDataKeywords = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+            Settings::SettingsExportPdf::exportPdfMetaDataKeywords),
+        .fill =
+            set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+                                Settings::SettingsExportPdf::exportPdfFill),
+        .fillColor = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+            Settings::SettingsExportPdf::exportPdfFillColor),
+        .stroke =
+            set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+                                Settings::SettingsExportPdf::exportPdfStroke),
+        .strokeColor = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+            Settings::SettingsExportPdf::exportPdfStrokeColor),
+        .strokeWidth = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_PDF,
+            Settings::SettingsExportPdf::exportPdfStrokeWidth),
     });
   }
 
   static const std::shared_ptr<const ExportPdfOptions> fromSettings() {
     return std::make_shared<const ExportPdfOptions>(ExportPdfOptions{
-      .showScale = SPDF::exportPdfShowScale.value(),
-      .showScaleMsg = SPDF::exportPdfShowScaleMessage.value(),
-      .showGrid = SPDF::exportPdfShowGrid.value(),
-      .gridSize = SPDF::exportPdfGridSize.value(),
-      .showDesignFilename = SPDF::exportPdfShowFilename.value(),
-      .orientation = SPDF::exportPdfOrientation.value(),
-      .paperSize = SPDF::exportPdfPaperSize.value(),
-      .addMetaData = SPDF::exportPdfAddMetaData.value(),
-      .metaDataTitle = SPDF::exportPdfMetaDataTitle.value(),
-      .metaDataAuthor = SPDF::exportPdfAddMetaDataAuthor.value() ? SPDF::exportPdfMetaDataAuthor.value() : "",
-      .metaDataSubject = SPDF::exportPdfAddMetaDataSubject.value() ? SPDF::exportPdfMetaDataSubject.value() : "",
-      .metaDataKeywords = SPDF::exportPdfAddMetaDataKeywords.value() ? SPDF::exportPdfMetaDataKeywords.value() : "",
-      .fill = SPDF::exportPdfFill.value(),
-      .fillColor = SPDF::exportPdfFillColor.value(),
-      .stroke = SPDF::exportPdfStroke.value(),
-      .strokeColor = SPDF::exportPdfStrokeColor.value(),
-      .strokeWidth = SPDF::exportPdfStrokeWidth.value(),
+        .showScale = SPDF::exportPdfShowScale.value(),
+        .showScaleMsg = SPDF::exportPdfShowScaleMessage.value(),
+        .showGrid = SPDF::exportPdfShowGrid.value(),
+        .gridSize = SPDF::exportPdfGridSize.value(),
+        .showDesignFilename = SPDF::exportPdfShowFilename.value(),
+        .orientation = SPDF::exportPdfOrientation.value(),
+        .paperSize = SPDF::exportPdfPaperSize.value(),
+        .addMetaData = SPDF::exportPdfAddMetaData.value(),
+        .metaDataTitle = SPDF::exportPdfMetaDataTitle.value(),
+        .metaDataAuthor = SPDF::exportPdfAddMetaDataAuthor.value()
+                              ? SPDF::exportPdfMetaDataAuthor.value()
+                              : "",
+        .metaDataSubject = SPDF::exportPdfAddMetaDataSubject.value()
+                               ? SPDF::exportPdfMetaDataSubject.value()
+                               : "",
+        .metaDataKeywords = SPDF::exportPdfAddMetaDataKeywords.value()
+                                ? SPDF::exportPdfMetaDataKeywords.value()
+                                : "",
+        .fill = SPDF::exportPdfFill.value(),
+        .fillColor = SPDF::exportPdfFillColor.value(),
+        .stroke = SPDF::exportPdfStroke.value(),
+        .strokeColor = SPDF::exportPdfStrokeColor.value(),
+        .strokeWidth = SPDF::exportPdfStrokeWidth.value(),
     });
   }
 };
@@ -169,37 +213,73 @@ struct Export3mfOptions {
   std::string metaDataLicenseTerms;
   std::string metaDataRating;
 
-  static const std::shared_ptr<const Export3mfOptions> withOptions(const CmdLineExportOptions& cmdLineOptions) {
+  static const std::shared_ptr<const Export3mfOptions>
+  withOptions(const CmdLineExportOptions &cmdLineOptions) {
     return std::make_shared<const Export3mfOptions>(Export3mfOptions{
-      .colorMode = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfColorMode),
-      .unit = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfUnit),
-      .color = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfColor),
-      .materialType = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfMaterialType),
-      .decimalPrecision = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfDecimalPrecision),
-      .addMetaData = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfAddMetaData),
-      .metaDataTitle = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfMetaDataTitle),
-      .metaDataDesigner = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfMetaDataDesigner),
-      .metaDataDescription = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfMetaDataDescription),
-      .metaDataCopyright = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfMetaDataCopyright),
-      .metaDataLicenseTerms = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfMetaDataLicenseTerms),
-      .metaDataRating = set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF, Settings::SettingsExport3mf::export3mfMetaDataRating),
+        .colorMode = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_3MF,
+            Settings::SettingsExport3mf::export3mfColorMode),
+        .unit =
+            set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF,
+                                Settings::SettingsExport3mf::export3mfUnit),
+        .color =
+            set_cmd_line_option(cmdLineOptions, Settings::SECTION_EXPORT_3MF,
+                                Settings::SettingsExport3mf::export3mfColor),
+        .materialType = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_3MF,
+            Settings::SettingsExport3mf::export3mfMaterialType),
+        .decimalPrecision = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_3MF,
+            Settings::SettingsExport3mf::export3mfDecimalPrecision),
+        .addMetaData = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_3MF,
+            Settings::SettingsExport3mf::export3mfAddMetaData),
+        .metaDataTitle = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_3MF,
+            Settings::SettingsExport3mf::export3mfMetaDataTitle),
+        .metaDataDesigner = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_3MF,
+            Settings::SettingsExport3mf::export3mfMetaDataDesigner),
+        .metaDataDescription = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_3MF,
+            Settings::SettingsExport3mf::export3mfMetaDataDescription),
+        .metaDataCopyright = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_3MF,
+            Settings::SettingsExport3mf::export3mfMetaDataCopyright),
+        .metaDataLicenseTerms = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_3MF,
+            Settings::SettingsExport3mf::export3mfMetaDataLicenseTerms),
+        .metaDataRating = set_cmd_line_option(
+            cmdLineOptions, Settings::SECTION_EXPORT_3MF,
+            Settings::SettingsExport3mf::export3mfMetaDataRating),
     });
   }
 
   static const std::shared_ptr<const Export3mfOptions> fromSettings() {
     return std::make_shared<const Export3mfOptions>(Export3mfOptions{
-      .colorMode = S3MF::export3mfColorMode.value(),
-      .unit = S3MF::export3mfUnit.value(),
-      .color = S3MF::export3mfColor.value(),
-      .materialType = S3MF::export3mfMaterialType.value(),
-      .decimalPrecision = S3MF::export3mfDecimalPrecision.value(),
-      .addMetaData = S3MF::export3mfAddMetaData.value(),
-      .metaDataTitle = S3MF::export3mfMetaDataTitle.value(),
-      .metaDataDesigner = S3MF::export3mfAddMetaDataDesigner.value() ? S3MF::export3mfMetaDataDesigner.value() : "",
-      .metaDataDescription = S3MF::export3mfAddMetaDataDescription.value() ? S3MF::export3mfMetaDataDescription.value() : "",
-      .metaDataCopyright = S3MF::export3mfAddMetaDataCopyright.value() ? S3MF::export3mfMetaDataCopyright.value() : "",
-      .metaDataLicenseTerms = S3MF::export3mfAddMetaDataLicenseTerms.value() ? S3MF::export3mfMetaDataLicenseTerms.value() : "",
-      .metaDataRating = S3MF::export3mfAddMetaDataRating.value() ? S3MF::export3mfMetaDataRating.value() : "",
+        .colorMode = S3MF::export3mfColorMode.value(),
+        .unit = S3MF::export3mfUnit.value(),
+        .color = S3MF::export3mfColor.value(),
+        .materialType = S3MF::export3mfMaterialType.value(),
+        .decimalPrecision = S3MF::export3mfDecimalPrecision.value(),
+        .addMetaData = S3MF::export3mfAddMetaData.value(),
+        .metaDataTitle = S3MF::export3mfMetaDataTitle.value(),
+        .metaDataDesigner = S3MF::export3mfAddMetaDataDesigner.value()
+                                ? S3MF::export3mfMetaDataDesigner.value()
+                                : "",
+        .metaDataDescription = S3MF::export3mfAddMetaDataDescription.value()
+                                   ? S3MF::export3mfMetaDataDescription.value()
+                                   : "",
+        .metaDataCopyright = S3MF::export3mfAddMetaDataCopyright.value()
+                                 ? S3MF::export3mfMetaDataCopyright.value()
+                                 : "",
+        .metaDataLicenseTerms =
+            S3MF::export3mfAddMetaDataLicenseTerms.value()
+                ? S3MF::export3mfMetaDataLicenseTerms.value()
+                : "",
+        .metaDataRating = S3MF::export3mfAddMetaDataRating.value()
+                              ? S3MF::export3mfMetaDataRating.value()
+                              : "",
     });
   }
 };
@@ -217,32 +297,48 @@ struct ExportInfo {
   std::shared_ptr<const Export3mfOptions> options3mf;
 };
 
-ExportInfo createExportInfo(const FileFormat& format, const FileFormatInfo& info, const std::string& filepath, const Camera *camera, const CmdLineExportOptions& cmdLineOptions);
-
-bool exportFileByName(const std::shared_ptr<const class Geometry>& root_geom, const std::string& filename, const ExportInfo& exportInfo);
-bool exportFileStdOut(const std::shared_ptr<const class Geometry>& root_geom, const ExportInfo& exportInfo);
-
-void export_stl(const std::shared_ptr<const Geometry>& geom, std::ostream& output,
-                bool binary = true);
-void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& output, const ExportInfo& exportInfo);
-void export_obj(const std::shared_ptr<const Geometry>& geom, std::ostream& output);
-void export_off(const std::shared_ptr<const Geometry>& geom, std::ostream& output);
-void export_wrl(const std::shared_ptr<const Geometry>& geom, std::ostream& output);
-void export_amf(const std::shared_ptr<const Geometry>& geom, std::ostream& output);
-void export_dxf(const std::shared_ptr<const Geometry>& geom, std::ostream& output);
-void export_svg(const std::shared_ptr<const Geometry>& geom, std::ostream& output);
-void export_pov(const std::shared_ptr<const Geometry>& geom, std::ostream& output, const ExportInfo& exportInfo);
-void export_pdf(const std::shared_ptr<const Geometry>& geom, std::ostream& output, const ExportInfo& exportInfo);
-void export_nefdbg(const std::shared_ptr<const Geometry>& geom, std::ostream& output);
-void export_nef3(const std::shared_ptr<const Geometry>& geom, std::ostream& output);
-
+ExportInfo createExportInfo(const FileFormat &format,
+                            const FileFormatInfo &info,
+                            const std::string &filepath, const Camera *camera,
+                            const CmdLineExportOptions &cmdLineOptions);
+
+bool exportFileByName(const std::shared_ptr<const class Geometry> &root_geom,
+                      const std::string &filename,
+                      const ExportInfo &exportInfo);
+bool exportFileStdOut(const std::shared_ptr<const class Geometry> &root_geom,
+                      const ExportInfo &exportInfo);
+
+void export_stl(const std::shared_ptr<const Geometry> &geom,
+                std::ostream &output, bool binary = true);
+void export_3mf(const std::shared_ptr<const Geometry> &geom,
+                std::ostream &output, const ExportInfo &exportInfo);
+void export_obj(const std::shared_ptr<const Geometry> &geom,
+                std::ostream &output);
+void export_off(const std::shared_ptr<const Geometry> &geom,
+                std::ostream &output);
+void export_wrl(const std::shared_ptr<const Geometry> &geom,
+                std::ostream &output);
+void export_amf(const std::shared_ptr<const Geometry> &geom,
+                std::ostream &output);
+void export_dxf(const std::shared_ptr<const Geometry> &geom,
+                std::ostream &output);
+void export_svg(const std::shared_ptr<const Geometry> &geom,
+                std::ostream &output);
+void export_pov(const std::shared_ptr<const Geometry> &geom,
+                std::ostream &output, const ExportInfo &exportInfo);
+void export_pdf(const std::shared_ptr<const Geometry> &geom,
+                std::ostream &output, const ExportInfo &exportInfo);
+void export_nefdbg(const std::shared_ptr<const Geometry> &geom,
+                   std::ostream &output);
+void export_nef3(const std::shared_ptr<const Geometry> &geom,
+                 std::ostream &output);
 
 enum class Previewer { OPENCSG, THROWNTOGETHER };
 enum class RenderType { GEOMETRY, BACKEND_SPECIFIC, OPENCSG, THROWNTOGETHER };
 
 struct ViewOption {
   const std::string name;
-  bool& value;
+  bool &value;
 };
 
 struct ViewOptions {
@@ -250,10 +346,10 @@ struct ViewOptions {
   RenderType renderer{RenderType::OPENCSG};
 
   std::map<std::string, bool> flags{
-    {"axes", false},
-    {"scales", false},
-    {"edges", false},
-    {"crosshairs", false},
+      {"axes", false},
+      {"scales", false},
+      {"edges", false},
+      {"crosshairs", false},
   };
 
   const std::vector<std::string> names() {
@@ -262,23 +358,21 @@ struct ViewOptions {
     return names;
   }
 
-  bool& operator[](const std::string& name) {
-    return flags.at(name);
-  }
-
-  bool operator[](const std::string& name) const {
-    return flags.at(name);
-  }
+  bool &operator[](const std::string &name) { return flags.at(name); }
 
+  bool operator[](const std::string &name) const { return flags.at(name); }
 };
 
 class OffscreenView;
 
 std::string get_current_iso8601_date_time_utc();
 
-std::unique_ptr<OffscreenView> prepare_preview(Tree& tree, const ViewOptions& options, Camera& camera);
-bool export_png(const std::shared_ptr<const class Geometry>& root_geom, const ViewOptions& options, Camera& camera, std::ostream& output);
-bool export_png(const OffscreenView& glview, std::ostream& output);
-bool export_param(SourceFile *root, const fs::path& path, std::ostream& output);
+std::unique_ptr<OffscreenView>
+prepare_preview(Tree &tree, const ViewOptions &options, Camera &camera);
+bool export_png(const std::shared_ptr<const class Geometry> &root_geom,
+                const ViewOptions &options, Camera &camera,
+                std::ostream &output);
+bool export_png(const OffscreenView &glview, std::ostream &output);
+bool export_param(SourceFile *root, const fs::path &path, std::ostream &output);
 
-std::unique_ptr<PolySet> createSortedPolySet(const PolySet& ps);
+std::unique_ptr<PolySet> createSortedPolySet(const PolySet &ps);
diff --git a/src/io/export_3mf_dummy.cc b/src/io/export_3mf_dummy.cc
index 50580be45..5a1dd7803 100644
--- a/src/io/export_3mf_dummy.cc
+++ b/src/io/export_3mf_dummy.cc
@@ -24,13 +24,13 @@
  *
  */
 
-#include <memory>
-#include <ostream>
-#include "io/export.h"
 #include "geometry/Geometry.h"
+#include "io/export.h"
 #include "utils/printutils.h"
+#include <memory>
+#include <ostream>
 
-void export_3mf(const std::shared_ptr<const class Geometry>&, std::ostream&, const ExportInfo&)
-{
+void export_3mf(const std::shared_ptr<const class Geometry> &, std::ostream &,
+                const ExportInfo &) {
   LOG("Export to 3MF format was not enabled when building the application.");
 }
diff --git a/src/io/export_3mf_v1.cc b/src/io/export_3mf_v1.cc
index 94191757b..fc9d1ec67 100644
--- a/src/io/export_3mf_v1.cc
+++ b/src/io/export_3mf_v1.cc
@@ -39,9 +39,9 @@
 #include "core/ColorUtil.h"
 #include "export_enums.h"
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetUtils.h"
+#include "geometry/linalg.h"
 #include "utils/printutils.h"
 
 #ifdef ENABLE_MANIFOLD
@@ -49,8 +49,8 @@
 #endif
 
 #ifdef ENABLE_CGAL
-#include "geometry/cgal/cgalutils.h"
 #include "geometry/cgal/CGALNefGeometry.h"
+#include "geometry/cgal/cgalutils.h"
 #endif
 
 #undef BOOL
@@ -69,24 +69,22 @@ struct ExportContext {
   Color4f defaultColor;
   DWORD defaultColorId = 0;
   std::vector<DWORD> materialids;
-  const ExportInfo& info;
+  const ExportInfo &info;
   const std::shared_ptr<const Export3mfOptions> options;
 };
 
-uint32_t lib3mf_write_callback(const char *data, uint32_t bytes, std::ostream *stream)
-{
+uint32_t lib3mf_write_callback(const char *data, uint32_t bytes,
+                               std::ostream *stream) {
   stream->write(data, bytes);
   return !(*stream);
 }
 
-uint32_t lib3mf_seek_callback(uint64_t pos, std::ostream *stream)
-{
+uint32_t lib3mf_seek_callback(uint64_t pos, std::ostream *stream) {
   stream->seekp(pos);
   return !(*stream);
 }
 
-void export_3mf_error(std::string msg, PLib3MFModel *& model)
-{
+void export_3mf_error(std::string msg, PLib3MFModel *&model) {
   LOG(message_group::Export_Error, std::move(msg));
   if (model) {
     lib3mf_release(model);
@@ -94,7 +92,7 @@ void export_3mf_error(std::string msg, PLib3MFModel *& model)
   }
 }
 
-int count_mesh_objects(PLib3MFModel *& model) {
+int count_mesh_objects(PLib3MFModel *&model) {
   PLib3MFModelResourceIterator *it;
   if (lib3mf_model_getmeshobjects(model, &it) != LIB3MF_OK) {
     return 0;
@@ -115,8 +113,10 @@ int count_mesh_objects(PLib3MFModel *& model) {
   return count;
 }
 
-bool handle_triangle_color(PLib3MFPropertyHandler *propertyhandler, const std::unique_ptr<PolySet>& ps, int triangle_index, int color_index, ExportContext& ctx)
-{
+bool handle_triangle_color(PLib3MFPropertyHandler *propertyhandler,
+                           const std::unique_ptr<PolySet> &ps,
+                           int triangle_index, int color_index,
+                           ExportContext &ctx) {
   if (color_index < 0) {
     return true;
   }
@@ -131,13 +131,17 @@ bool handle_triangle_color(PLib3MFPropertyHandler *propertyhandler, const std::u
   }
 
   if (ctx.basematerial) {
-    if (lib3mf_propertyhandler_setbasematerial(propertyhandler, triangle_index, ctx.basematerialid, ctx.materialids[color_index]) != LIB3MF_OK) {
+    if (lib3mf_propertyhandler_setbasematerial(
+            propertyhandler, triangle_index, ctx.basematerialid,
+            ctx.materialids[color_index]) != LIB3MF_OK) {
       export_3mf_error("Can't set triangle base material.", ctx.model);
       return false;
     }
   } else if (ctx.usecolors) {
-    const auto& col = ps->colors[color_index];
-    if (lib3mf_propertyhandler_setsinglecolorfloatrgba(propertyhandler, triangle_index, col.r(), col.g(), col.b(), col.a()) != LIB3MF_OK) {
+    const auto &col = ps->colors[color_index];
+    if (lib3mf_propertyhandler_setsinglecolorfloatrgba(
+            propertyhandler, triangle_index, col.r(), col.g(), col.b(),
+            col.a()) != LIB3MF_OK) {
       export_3mf_error("Can't set triangle color.", ctx.model);
       return false;
     }
@@ -146,12 +150,11 @@ bool handle_triangle_color(PLib3MFPropertyHandler *propertyhandler, const std::u
   return true;
 }
 
-
 /*
  * PolySet must be triangulated.
  */
-bool append_polyset(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx)
-{
+bool append_polyset(const std::shared_ptr<const PolySet> &ps,
+                    ExportContext &ctx) {
   PLib3MFModelMeshObject *mesh = nullptr;
   if (lib3mf_model_addmeshobject(ctx.model, &mesh) != LIB3MF_OK) {
     export_3mf_error("Can't add mesh to 3MF model.", ctx.model);
@@ -171,42 +174,41 @@ bool append_polyset(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx
     return false;
   }
 
-  auto vertexFunc = [&](const Vector3d& coords) -> bool {
-      const auto f = coords.cast<float>();
-      MODELMESHVERTEX v{f[0], f[1], f[2]};
-      return lib3mf_meshobject_addvertex(mesh, &v, nullptr) == LIB3MF_OK;
-    };
+  auto vertexFunc = [&](const Vector3d &coords) -> bool {
+    const auto f = coords.cast<float>();
+    MODELMESHVERTEX v{f[0], f[1], f[2]};
+    return lib3mf_meshobject_addvertex(mesh, &v, nullptr) == LIB3MF_OK;
+  };
 
-  auto triangleFunc = [&](const IndexedFace& indices) -> bool {
-      MODELMESHTRIANGLE t{(DWORD)indices[0], (DWORD)indices[1], (DWORD)indices[2]};
-      return lib3mf_meshobject_addtriangle(mesh, &t, nullptr) == LIB3MF_OK;
-    };
+  auto triangleFunc = [&](const IndexedFace &indices) -> bool {
+    MODELMESHTRIANGLE t{(DWORD)indices[0], (DWORD)indices[1],
+                        (DWORD)indices[2]};
+    return lib3mf_meshobject_addtriangle(mesh, &t, nullptr) == LIB3MF_OK;
+  };
 
-  auto materialFunc = [&](int idx, const Color4f& col) -> DWORD {
-      const auto colname = "Color " + std::to_string(idx);
+  auto materialFunc = [&](int idx, const Color4f &col) -> DWORD {
+    const auto colname = "Color " + std::to_string(idx);
 
-      DWORD id = 0;
-      uint8_t r, g, b, a;
-      if (!col.getRgba(r, g, b, a)) {
-        LOG(message_group::Warning, "Invalid color in 3MF export");
-      }
-      lib3mf_basematerial_addmaterialutf8(ctx.basematerial,
-                                          colname.c_str(),
-                                          r, g, b,
-                                          &id);
-      return id;
-    };
+    DWORD id = 0;
+    uint8_t r, g, b, a;
+    if (!col.getRgba(r, g, b, a)) {
+      LOG(message_group::Warning, "Invalid color in 3MF export");
+    }
+    lib3mf_basematerial_addmaterialutf8(ctx.basematerial, colname.c_str(), r, g,
+                                        b, &id);
+    return id;
+  };
 
   auto sorted_ps = createSortedPolySet(*ps);
 
-  for (const auto& v : sorted_ps->vertices) {
+  for (const auto &v : sorted_ps->vertices) {
     if (!vertexFunc(v)) {
       export_3mf_error("Can't add vertex to 3MF model.", ctx.model);
       return false;
     }
   }
 
-  for (const auto& poly : sorted_ps->indices) {
+  for (const auto &poly : sorted_ps->indices) {
     if (!triangleFunc(poly)) {
       export_3mf_error("Can't add triangle to 3MF model.", ctx.model);
       return false;
@@ -220,7 +222,8 @@ bool append_polyset(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx
       while (true) {
         BOOL hasNext = false;
         if (lib3mf_resourceiterator_movenext(it, &hasNext) != LIB3MF_OK) {
-          export_3mf_error("Can't move to next base material iterator value.", ctx.model);
+          export_3mf_error("Can't move to next base material iterator value.",
+                           ctx.model);
           return false;
         }
         if (!hasNext) {
@@ -229,7 +232,9 @@ bool append_polyset(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx
 
         PLib3MFModelResource *resource = nullptr;
         if (lib3mf_resourceiterator_getcurrent(it, &resource) != LIB3MF_OK) {
-          export_3mf_error("Can't get current value from base material iterator.", ctx.model);
+          export_3mf_error(
+              "Can't get current value from base material iterator.",
+              ctx.model);
           return false;
         } else {
           DWORD count = 0;
@@ -241,12 +246,14 @@ bool append_polyset(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx
 
     ctx.materialids.reserve(sorted_ps->colors.size());
     for (int i = 0; i < sorted_ps->colors.size(); i++) {
-      ctx.materialids.push_back(materialFunc(materials + i, sorted_ps->colors[i]));
+      ctx.materialids.push_back(
+          materialFunc(materials + i, sorted_ps->colors[i]));
     }
   }
 
   PLib3MFPropertyHandler *propertyhandler = nullptr;
-  if (lib3mf_meshobject_createpropertyhandler(mesh, &propertyhandler) != LIB3MF_OK) {
+  if (lib3mf_meshobject_createpropertyhandler(mesh, &propertyhandler) !=
+      LIB3MF_OK) {
     export_3mf_error("Can't create property handler for 3MF model.", ctx.model);
     return false;
   }
@@ -261,29 +268,35 @@ bool append_polyset(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx
   lib3mf_release(propertyhandler);
 
   PLib3MFPropertyHandler *defaultpropertyhandler = nullptr;
-  if (lib3mf_object_createdefaultpropertyhandler(mesh, &defaultpropertyhandler) != LIB3MF_OK) {
-    export_3mf_error("Can't create default property handler for 3MF model.", ctx.model);
+  if (lib3mf_object_createdefaultpropertyhandler(
+          mesh, &defaultpropertyhandler) != LIB3MF_OK) {
+    export_3mf_error("Can't create default property handler for 3MF model.",
+                     ctx.model);
     return false;
   }
 
   if (ctx.basematerial) {
-    lib3mf_defaultpropertyhandler_setbasematerial(defaultpropertyhandler, ctx.basematerialid, ctx.defaultColorId);
+    lib3mf_defaultpropertyhandler_setbasematerial(
+        defaultpropertyhandler, ctx.basematerialid, ctx.defaultColorId);
   } else if (ctx.usecolors) {
     uint8_t r, g, b, a;
     if (!ctx.defaultColor.getRgba(r, g, b, a)) {
       LOG(message_group::Warning, "Invalid color in 3MF export");
     }
-    lib3mf_defaultpropertyhandler_setcolorrgba(defaultpropertyhandler, r, g, b, a);
+    lib3mf_defaultpropertyhandler_setcolorrgba(defaultpropertyhandler, r, g, b,
+                                               a);
   }
 
   lib3mf_release(defaultpropertyhandler);
 
   PLib3MFModelBuildItem *builditem = nullptr;
-  if (lib3mf_model_addbuilditem(ctx.model, mesh, nullptr, &builditem) != LIB3MF_OK) {
+  if (lib3mf_model_addbuilditem(ctx.model, mesh, nullptr, &builditem) !=
+      LIB3MF_OK) {
     export_3mf_error("Can't add build item to 3MF model.", ctx.model);
     return false;
   }
-  if (!partname.empty() && lib3mf_builditem_setpartnumberutf8(builditem, partname.c_str()) != LIB3MF_OK) {
+  if (!partname.empty() && lib3mf_builditem_setpartnumberutf8(
+                               builditem, partname.c_str()) != LIB3MF_OK) {
     export_3mf_error("Can't set part name of build item.", ctx.model);
     return false;
   }
@@ -295,19 +308,19 @@ bool append_polyset(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx
 }
 
 #ifdef ENABLE_CGAL
-bool append_nef(const CGALNefGeometry& root_N, ExportContext& ctx)
-{
+bool append_nef(const CGALNefGeometry &root_N, ExportContext &ctx) {
   if (!root_N.p3) {
     LOG(message_group::Export_Error, "Export failed, empty geometry.");
     return false;
   }
 
   if (!root_N.p3->is_simple()) {
-    LOG(message_group::Export_Warning, "Exported object may not be a valid 2-manifold and may need repair");
+    LOG(message_group::Export_Warning,
+        "Exported object may not be a valid 2-manifold and may need repair");
   }
 
-
-  if (std::shared_ptr<PolySet> ps = CGALUtils::createPolySetFromNefPolyhedron3(*root_N.p3)) {
+  if (std::shared_ptr<PolySet> ps =
+          CGALUtils::createPolySetFromNefPolyhedron3(*root_N.p3)) {
     return append_polyset(ps, ctx);
   }
 
@@ -316,24 +329,29 @@ bool append_nef(const CGALNefGeometry& root_N, ExportContext& ctx)
 }
 #endif // ifdef ENABLE_CGAL
 
-static bool append_3mf(const std::shared_ptr<const Geometry>& geom, ExportContext& ctx)
-{
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
+static bool append_3mf(const std::shared_ptr<const Geometry> &geom,
+                       ExportContext &ctx) {
+  if (const auto geomlist =
+          std::dynamic_pointer_cast<const GeometryList>(geom)) {
     ctx.modelcount = geomlist->getChildren().size();
-    for (const auto& item : geomlist->getChildren()) {
-      if (!append_3mf(item.second, ctx)) return false;
+    for (const auto &item : geomlist->getChildren()) {
+      if (!append_3mf(item.second, ctx))
+        return false;
     }
 #ifdef ENABLE_CGAL
-  } else if (const auto N = std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
+  } else if (const auto N =
+                 std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
     return append_nef(*N, ctx);
 #endif
 #ifdef ENABLE_MANIFOLD
-  } else if (const auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
+  } else if (const auto mani =
+                 std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
     return append_polyset(mani->toPolySet(), ctx);
 #endif
   } else if (const auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
     return append_polyset(PolySetUtils::tessellate_faces(*ps), ctx);
-  } else if (std::dynamic_pointer_cast<const Polygon2d>(geom)) { // NOLINT(bugprone-branch-clone)
+  } else if (std::dynamic_pointer_cast<const Polygon2d>(
+                 geom)) { // NOLINT(bugprone-branch-clone)
     assert(false && "Unsupported file format");
   } else { // NOLINT(bugprone-branch-clone)
     assert(false && "Not implemented");
@@ -342,7 +360,8 @@ static bool append_3mf(const std::shared_ptr<const Geometry>& geom, ExportContex
   return true;
 }
 
-void add_meta_data(PLib3MFModelMeshObject *& model, const std::string& name, const std::string& value, const std::string& value2 = "") {
+void add_meta_data(PLib3MFModelMeshObject *&model, const std::string &name,
+                   const std::string &value, const std::string &value2 = "") {
   const std::string v = value.empty() ? value2 : value;
   if (v.empty()) {
     return;
@@ -357,17 +376,23 @@ void add_meta_data(PLib3MFModelMeshObject *& model, const std::string& name, con
     Saves the current 3D Geometry as 3MF to the given file.
     The file must be open.
  */
-void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& output, const ExportInfo& exportInfo)
-{
+void export_3mf(const std::shared_ptr<const Geometry> &geom,
+                std::ostream &output, const ExportInfo &exportInfo) {
   DWORD interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro;
-  HRESULT result = lib3mf_getinterfaceversion(&interfaceVersionMajor, &interfaceVersionMinor, &interfaceVersionMicro);
+  HRESULT result = lib3mf_getinterfaceversion(
+      &interfaceVersionMajor, &interfaceVersionMinor, &interfaceVersionMicro);
   if (result != LIB3MF_OK) {
     LOG(message_group::Export_Error, "Error reading 3MF library version");
     return;
   }
 
   if ((interfaceVersionMajor != NMR_APIVERSION_INTERFACE_MAJOR)) {
-    LOG(message_group::Export_Error, "Invalid 3MF library major version %1$d.%2$d.%3$d, expected %4$d.%5$d.%6$d", interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro, NMR_APIVERSION_INTERFACE_MAJOR, NMR_APIVERSION_INTERFACE_MINOR, NMR_APIVERSION_INTERFACE_MICRO);
+    LOG(message_group::Export_Error,
+        "Invalid 3MF library major version %1$d.%2$d.%3$d, expected "
+        "%4$d.%5$d.%6$d",
+        interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro,
+        NMR_APIVERSION_INTERFACE_MAJOR, NMR_APIVERSION_INTERFACE_MINOR,
+        NMR_APIVERSION_INTERFACE_MICRO);
     return;
   }
 
@@ -378,7 +403,9 @@ void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
     return;
   }
 
-  const auto& options3mf = exportInfo.options3mf ? exportInfo.options3mf : std::make_shared<Export3mfOptions>();
+  const auto &options3mf = exportInfo.options3mf
+                               ? exportInfo.options3mf
+                               : std::make_shared<Export3mfOptions>();
   switch (options3mf->unit) {
   case Export3mfUnit::micron:
     lib3mf_model_setunit(model, eModelUnit::MODELUNIT_MICROMETER);
@@ -411,14 +438,17 @@ void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
       // use default color that ultimately should come from the color scheme
       defaultColor = exportInfo.defaultColor;
     } else {
-      defaultColor = OpenSCAD::getColor(options3mf->color, exportInfo.defaultColor);
+      defaultColor =
+          OpenSCAD::getColor(options3mf->color, exportInfo.defaultColor);
     }
     if (options3mf->materialType == Export3mfMaterialType::basematerial) {
-      if (lib3mf_model_addbasematerialgroup(model, &basematerial) != LIB3MF_OK) {
+      if (lib3mf_model_addbasematerialgroup(model, &basematerial) !=
+          LIB3MF_OK) {
         export_3mf_error("Can't create base material group.", model);
         return;
       }
-      if (lib3mf_resource_getresourceid(basematerial, &basematerialid) != LIB3MF_OK) {
+      if (lib3mf_resource_getresourceid(basematerial, &basematerialid) !=
+          LIB3MF_OK) {
         export_3mf_error("Can't get base material resource id.", model);
         return;
       }
@@ -426,8 +456,7 @@ void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
       if (!defaultColor.getRgba(r, g, b, a)) {
         LOG(message_group::Warning, "Invalid color in 3MF export");
       }
-      if (lib3mf_basematerial_addmaterialutf8(basematerial, "Default",
-                                              r, g, b,
+      if (lib3mf_basematerial_addmaterialutf8(basematerial, "Default", r, g, b,
                                               &defaultColorId) != LIB3MF_OK) {
         export_3mf_error("Can't add default material color.", model);
         return;
@@ -448,20 +477,19 @@ void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
     add_meta_data(model, "Rating", options3mf->metaDataRating);
   }
 
-  ExportContext ctx{
-    .model = model,
-    .basematerial = basematerial,
-    .basematerialid = basematerialid,
-    .usecolors = usecolors,
-    .modelcount = 1,
-    .defaultColor = defaultColor,
-    .defaultColorId = defaultColorId,
-    .info = exportInfo,
-    .options = options3mf
-  };
+  ExportContext ctx{.model = model,
+                    .basematerial = basematerial,
+                    .basematerialid = basematerialid,
+                    .usecolors = usecolors,
+                    .modelcount = 1,
+                    .defaultColor = defaultColor,
+                    .defaultColorId = defaultColorId,
+                    .info = exportInfo,
+                    .options = options3mf};
 
   if (!append_3mf(geom, ctx)) {
-    if (model) lib3mf_release(model);
+    if (model)
+      lib3mf_release(model);
     return;
   }
 
@@ -471,13 +499,12 @@ void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
     return;
   }
 
-  result = lib3mf_writer_writetocallback(writer, (void *)lib3mf_write_callback, (void *)lib3mf_seek_callback, &output);
+  result = lib3mf_writer_writetocallback(writer, (void *)lib3mf_write_callback,
+                                         (void *)lib3mf_seek_callback, &output);
   output.flush();
   lib3mf_release(writer);
   lib3mf_release(model);
   if (result != LIB3MF_OK) {
     LOG(message_group::Export_Error, "Error writing 3MF model.");
   }
-
-
 }
diff --git a/src/io/export_3mf_v2.cc b/src/io/export_3mf_v2.cc
index cdbe65c0b..4a4ffdea0 100644
--- a/src/io/export_3mf_v2.cc
+++ b/src/io/export_3mf_v2.cc
@@ -27,8 +27,8 @@
 #include "io/export.h"
 
 #include <algorithm>
-#include <cstddef>
 #include <cassert>
+#include <cstddef>
 #include <cstdint>
 #include <memory>
 #include <ostream>
@@ -42,14 +42,14 @@
 #include "export_enums.h"
 #include "geometry/Geometry.h"
 #include "geometry/GeometryUtils.h"
-#include "geometry/linalg.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetUtils.h"
+#include "geometry/linalg.h"
 #include "utils/printutils.h"
 
 #ifdef ENABLE_CGAL
-#include "geometry/cgal/cgalutils.h"
 #include "geometry/cgal/CGALNefGeometry.h"
+#include "geometry/cgal/cgalutils.h"
 #endif
 #ifdef ENABLE_MANIFOLD
 #include "geometry/manifold/ManifoldGeometry.h"
@@ -67,35 +67,36 @@ struct ExportContext {
   int modelcount;
   ExportColorMap colors;
   Color4f selectedColor;
-  const ExportInfo& info;
+  const ExportInfo &info;
   const std::shared_ptr<const Export3mfOptions> options;
 };
 
-uint32_t lib3mf_write_callback(const char *data, uint32_t bytes, std::ostream *stream)
-{
+uint32_t lib3mf_write_callback(const char *data, uint32_t bytes,
+                               std::ostream *stream) {
   stream->write(data, bytes);
   return !(*stream);
 }
 
-uint32_t lib3mf_seek_callback(uint64_t pos, std::ostream *stream)
-{
+uint32_t lib3mf_seek_callback(uint64_t pos, std::ostream *stream) {
   stream->seekp(pos);
   return !(*stream);
 }
 
-void export_3mf_error(std::string msg)
-{
+void export_3mf_error(std::string msg) {
   LOG(message_group::Export_Error, std::move(msg));
 }
 
-int count_mesh_objects(const Lib3MF::PModel& model) {
+int count_mesh_objects(const Lib3MF::PModel &model) {
   const auto mesh_object_it = model->GetMeshObjects();
   int count = 0;
-  while (mesh_object_it->MoveNext()) ++count;
+  while (mesh_object_it->MoveNext())
+    ++count;
   return count;
 }
 
-void handle_triangle_color(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx, Lib3MF::PMeshObject& mesh, Lib3MF_uint32 triangle, int color_index) {
+void handle_triangle_color(const std::shared_ptr<const PolySet> &ps,
+                           ExportContext &ctx, Lib3MF::PMeshObject &mesh,
+                           Lib3MF_uint32 triangle, int color_index) {
   if (color_index < 0) {
     return;
   }
@@ -115,11 +116,14 @@ void handle_triangle_color(const std::shared_ptr<const PolySet>& ps, ExportConte
   Lib3MF_uint32 col_idx = 0;
   if (col_it == ctx.colors.end()) {
     Lib3MF::sColor materialcolor;
-    if (!col.getRgba(materialcolor.m_Red, materialcolor.m_Green, materialcolor.m_Blue, materialcolor.m_Alpha)) {
+    if (!col.getRgba(materialcolor.m_Red, materialcolor.m_Green,
+                     materialcolor.m_Blue, materialcolor.m_Alpha)) {
       LOG(message_group::Warning, "Invalid color in 3MF export");
     }
     if (ctx.basematerialgroup) {
-      col_idx = ctx.basematerialgroup->AddMaterial("Color " + std::to_string(ctx.basematerialgroup->GetCount()), materialcolor);
+      col_idx = ctx.basematerialgroup->AddMaterial(
+          "Color " + std::to_string(ctx.basematerialgroup->GetCount()),
+          materialcolor);
     } else if (ctx.colorgroup) {
       col_idx = ctx.colorgroup->AddColor(materialcolor);
     }
@@ -136,70 +140,69 @@ void handle_triangle_color(const std::shared_ptr<const PolySet>& ps, ExportConte
   }
 
   if (res_id > 0) {
-    mesh->SetTriangleProperties(triangle, {
-        res_id,
-        {
-          col_idx,
-          col_idx,
-          col_idx
-        }
-      });
+    mesh->SetTriangleProperties(triangle,
+                                {res_id, {col_idx, col_idx, col_idx}});
   }
 }
 
 /*
  * PolySet must be triangulated.
  */
-bool append_polyset(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx)
-{
+bool append_polyset(const std::shared_ptr<const PolySet> &ps,
+                    ExportContext &ctx) {
   try {
     auto mesh = ctx.model->AddMeshObject();
-    if (!mesh) return false;
+    if (!mesh)
+      return false;
 
     const int mesh_count = count_mesh_objects(ctx.model);
-    const auto modelname = ctx.modelcount == 1 ? "OpenSCAD Model" : "OpenSCAD Model " + std::to_string(mesh_count);
-    const auto partname = ctx.modelcount == 1 ? "" : "Part " + std::to_string(mesh_count);
+    const auto modelname = ctx.modelcount == 1
+                               ? "OpenSCAD Model"
+                               : "OpenSCAD Model " + std::to_string(mesh_count);
+    const auto partname =
+        ctx.modelcount == 1 ? "" : "Part " + std::to_string(mesh_count);
     mesh->SetName(modelname);
     if (ctx.basematerialgroup) {
-      mesh->SetObjectLevelProperty(ctx.basematerialgroup->GetUniqueResourceID(), 1);
+      mesh->SetObjectLevelProperty(ctx.basematerialgroup->GetUniqueResourceID(),
+                                   1);
     } else if (ctx.colorgroup) {
       mesh->SetObjectLevelProperty(ctx.colorgroup->GetUniqueResourceID(), 1);
     }
 
-    auto vertexFunc = [&](const Vector3d& coords) -> bool {
-        const auto f = coords.cast<float>();
-        try {
-          const Lib3MF::sPosition v{f[0], f[1], f[2]};
-          mesh->AddVertex(v);
-        } catch (Lib3MF::ELib3MFException& e) {
-          export_3mf_error(e.what());
-          return false;
-        }
-        return true;
-      };
-
-    auto triangleFunc = [&](const IndexedFace& indices, int color_index) -> bool {
-        try {
-          const auto triangle = mesh->AddTriangle({
-            static_cast<Lib3MF_uint32>(indices[0]),
-            static_cast<Lib3MF_uint32>(indices[1]),
-            static_cast<Lib3MF_uint32>(indices[2])
-          });
-
-          handle_triangle_color(ps, ctx, mesh, triangle, color_index);
-        } catch (Lib3MF::ELib3MFException& e) {
-          export_3mf_error(e.what());
-          return false;
-        }
-        return true;
-      };
+    auto vertexFunc = [&](const Vector3d &coords) -> bool {
+      const auto f = coords.cast<float>();
+      try {
+        const Lib3MF::sPosition v{f[0], f[1], f[2]};
+        mesh->AddVertex(v);
+      } catch (Lib3MF::ELib3MFException &e) {
+        export_3mf_error(e.what());
+        return false;
+      }
+      return true;
+    };
+
+    auto triangleFunc = [&](const IndexedFace &indices,
+                            int color_index) -> bool {
+      try {
+        const auto triangle =
+            mesh->AddTriangle({static_cast<Lib3MF_uint32>(indices[0]),
+                               static_cast<Lib3MF_uint32>(indices[1]),
+                               static_cast<Lib3MF_uint32>(indices[2])});
+
+        handle_triangle_color(ps, ctx, mesh, triangle, color_index);
+      } catch (Lib3MF::ELib3MFException &e) {
+        export_3mf_error(e.what());
+        return false;
+      }
+      return true;
+    };
 
     std::shared_ptr<const PolySet> out_ps = ps;
     if (Feature::ExperimentalPredictibleOutput.is_enabled()) {
       out_ps = createSortedPolySet(*ps);
     }
 
-    for (const auto& v : out_ps->vertices) {
+    for (const auto &v : out_ps->vertices) {
       if (!vertexFunc(v)) {
         export_3mf_error("Can't add vertex to 3MF model.");
         return false;
@@ -207,7 +210,8 @@ bool append_polyset(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx
     }
 
     for (size_t i = 0; i < out_ps->indices.size(); i++) {
-      auto color_index = i < out_ps->color_indices.size() ? out_ps->color_indices[i] : -1;
+      auto color_index =
+          i < out_ps->color_indices.size() ? out_ps->color_indices[i] : -1;
       if (!triangleFunc(out_ps->indices[i], color_index)) {
         export_3mf_error("Can't add triangle to 3MF model.");
         return false;
@@ -215,14 +219,15 @@ bool append_polyset(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx
     }
 
     try {
-      auto builditem = ctx.model->AddBuildItem(mesh.get(), ctx.wrapper->GetIdentityTransform());
+      auto builditem = ctx.model->AddBuildItem(
+          mesh.get(), ctx.wrapper->GetIdentityTransform());
       if (!partname.empty()) {
         builditem->SetPartNumber(partname);
       }
-    } catch (Lib3MF::ELib3MFException& e) {
+    } catch (Lib3MF::ELib3MFException &e) {
       export_3mf_error(e.what());
     }
-  } catch (Lib3MF::ELib3MFException& e) {
+  } catch (Lib3MF::ELib3MFException &e) {
     export_3mf_error(e.what());
     return false;
   }
@@ -230,18 +235,19 @@ bool append_polyset(const std::shared_ptr<const PolySet>& ps, ExportContext& ctx
 }
 
 #ifdef ENABLE_CGAL
-bool append_nef(const CGALNefGeometry& root_N, ExportContext& ctx)
-{
+bool append_nef(const CGALNefGeometry &root_N, ExportContext &ctx) {
   if (!root_N.p3) {
     LOG(message_group::Export_Error, "Export failed, empty geometry.");
     return false;
   }
 
   if (!root_N.p3->is_simple()) {
-    LOG(message_group::Export_Warning, "Exported object may not be a valid 2-manifold and may need repair");
+    LOG(message_group::Export_Warning,
+        "Exported object may not be a valid 2-manifold and may need repair");
   }
 
-  if (const std::shared_ptr<const PolySet> ps = CGALUtils::createPolySetFromNefPolyhedron3(*root_N.p3)) {
+  if (const std::shared_ptr<const PolySet> ps =
+          CGALUtils::createPolySetFromNefPolyhedron3(*root_N.p3)) {
     return append_polyset(ps, ctx);
   }
   export_3mf_error("Error converting NEF Polyhedron.");
@@ -249,19 +255,23 @@ bool append_nef(const CGALNefGeometry& root_N, ExportContext& ctx)
 }
 #endif // ifdef ENABLE_CGAL
 
-bool append_3mf(const std::shared_ptr<const Geometry>& geom, ExportContext& ctx)
-{
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
+bool append_3mf(const std::shared_ptr<const Geometry> &geom,
+                ExportContext &ctx) {
+  if (const auto geomlist =
+          std::dynamic_pointer_cast<const GeometryList>(geom)) {
     ctx.modelcount = geomlist->getChildren().size();
-    for (const auto& item : geomlist->getChildren()) {
-      if (!append_3mf(item.second, ctx)) return false;
+    for (const auto &item : geomlist->getChildren()) {
+      if (!append_3mf(item.second, ctx))
+        return false;
     }
 #ifdef ENABLE_CGAL
-  } else if (const auto N = std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
+  } else if (const auto N =
+                 std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
     return append_nef(*N, ctx);
 #endif
 #ifdef ENABLE_MANIFOLD
-  } else if (const auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
+  } else if (const auto mani =
+                 std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
     return append_polyset(mani->toPolySet(), ctx);
 #endif
   } else if (const auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
@@ -275,7 +285,9 @@ bool append_3mf(const std::shared_ptr<const Geometry>& geom, ExportContext& ctx)
   return true;
 }
 
-void add_meta_data(Lib3MF::PMetaDataGroup& metadatagroup, const std::string& name, const std::string& value, const std::string& value2 = "") {
+void add_meta_data(Lib3MF::PMetaDataGroup &metadatagroup,
+                   const std::string &name, const std::string &value,
+                   const std::string &value2 = "") {
   const std::string v = value.empty() ? value2 : value;
   if (v.empty()) {
     return;
@@ -290,27 +302,35 @@ void add_meta_data(Lib3MF::PMetaDataGroup& metadatagroup, const std::string& nam
     Saves the current 3D Geometry as 3MF to the given file.
     The file must be open.
  */
-void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& output, const ExportInfo& exportInfo)
-{
-  Lib3MF_uint32 interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro;
+void export_3mf(const std::shared_ptr<const Geometry> &geom,
+                std::ostream &output, const ExportInfo &exportInfo) {
+  Lib3MF_uint32 interfaceVersionMajor, interfaceVersionMinor,
+      interfaceVersionMicro;
   Lib3MF::PWrapper wrapper;
 
   try {
     wrapper = Lib3MF::CWrapper::loadLibrary();
-    wrapper->GetLibraryVersion(interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro);
+    wrapper->GetLibraryVersion(interfaceVersionMajor, interfaceVersionMinor,
+                               interfaceVersionMicro);
     if (interfaceVersionMajor != LIB3MF_VERSION_MAJOR) {
-      LOG(message_group::Error, "Invalid 3MF library major version %1$d.%2$d.%3$d, expected %4$d.%5$d.%6$d",
+      LOG(message_group::Error,
+          "Invalid 3MF library major version %1$d.%2$d.%3$d, expected "
+          "%4$d.%5$d.%6$d",
           interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro,
           LIB3MF_VERSION_MAJOR, LIB3MF_VERSION_MINOR, LIB3MF_VERSION_MICRO);
       return;
     }
-  } catch (Lib3MF::ELib3MFException& e) {
+  } catch (Lib3MF::ELib3MFException &e) {
     LOG(message_group::Export_Error, e.what());
     return;
   }
 
   if ((interfaceVersionMajor != LIB3MF_VERSION_MAJOR)) {
-    LOG(message_group::Export_Error, "Invalid 3MF library major version %1$d.%2$d.%3$d, expected %4$d.%5$d.%6$d", interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro, LIB3MF_VERSION_MAJOR, LIB3MF_VERSION_MINOR, LIB3MF_VERSION_MICRO);
+    LOG(message_group::Export_Error,
+        "Invalid 3MF library major version %1$d.%2$d.%3$d, expected "
+        "%4$d.%5$d.%6$d",
+        interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro,
+        LIB3MF_VERSION_MAJOR, LIB3MF_VERSION_MINOR, LIB3MF_VERSION_MICRO);
     return;
   }
 
@@ -321,12 +341,14 @@ void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
       LOG(message_group::Export_Error, "Can't create 3MF model.");
       return;
     }
-  } catch (Lib3MF::ELib3MFException& e) {
+  } catch (Lib3MF::ELib3MFException &e) {
     LOG(message_group::Export_Error, e.what());
     return;
   }
 
-  const auto& options3mf = exportInfo.options3mf ? exportInfo.options3mf : std::make_shared<Export3mfOptions>();
+  const auto &options3mf = exportInfo.options3mf
+                               ? exportInfo.options3mf
+                               : std::make_shared<Export3mfOptions>();
   switch (options3mf->unit) {
   case Export3mfUnit::micron:
     model->SetUnit(Lib3MF::eModelUnit::MicroMeter);
@@ -355,13 +377,15 @@ void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
   Lib3MF::PBaseMaterialGroup basematerialgroup;
   if (options3mf->colorMode != Export3mfColorMode::none) {
     if (options3mf->colorMode != Export3mfColorMode::model) {
-      // use color selected in the export dialog and stored in settings (if valid)
+      // use color selected in the export dialog and stored in settings (if
+      // valid)
       color = OpenSCAD::getColor(options3mf->color, exportInfo.defaultColor);
     }
     if (options3mf->materialType == Export3mfMaterialType::basematerial) {
       basematerialgroup = model->AddBaseMaterialGroup();
       Lib3MF::sColor materialcolor;
-      if (!color.getRgba(materialcolor.m_Red, materialcolor.m_Green, materialcolor.m_Blue, materialcolor.m_Alpha)) {
+      if (!color.getRgba(materialcolor.m_Red, materialcolor.m_Green,
+                         materialcolor.m_Blue, materialcolor.m_Alpha)) {
         LOG(message_group::Warning, "Invalid color in 3MF export");
       }
       materialcolor.m_Alpha = 0xff;
@@ -369,7 +393,8 @@ void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
     } else if (options3mf->materialType == Export3mfMaterialType::color) {
       colorgroup = model->AddColorGroup();
       Lib3MF::sColor groupcolor;
-      if (!color.getRgba(groupcolor.m_Red, groupcolor.m_Green, groupcolor.m_Blue, groupcolor.m_Alpha)) {
+      if (!color.getRgba(groupcolor.m_Red, groupcolor.m_Green,
+                         groupcolor.m_Blue, groupcolor.m_Alpha)) {
         LOG(message_group::Warning, "Invalid color in 3MF export");
       }
       colorgroup->AddColor(groupcolor);
@@ -378,26 +403,28 @@ void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
 
   if (options3mf->addMetaData) {
     auto metadatagroup = model->GetMetaDataGroup();
-    add_meta_data(metadatagroup, "Title", options3mf->metaDataTitle, exportInfo.title);
+    add_meta_data(metadatagroup, "Title", options3mf->metaDataTitle,
+                  exportInfo.title);
     add_meta_data(metadatagroup, "Application", EXPORT_CREATOR);
-    add_meta_data(metadatagroup, "CreationDate", get_current_iso8601_date_time_utc());
+    add_meta_data(metadatagroup, "CreationDate",
+                  get_current_iso8601_date_time_utc());
     add_meta_data(metadatagroup, "Designer", options3mf->metaDataDesigner);
-    add_meta_data(metadatagroup, "Description", options3mf->metaDataDescription);
+    add_meta_data(metadatagroup, "Description",
+                  options3mf->metaDataDescription);
     add_meta_data(metadatagroup, "Copyright", options3mf->metaDataCopyright);
-    add_meta_data(metadatagroup, "LicenseTerms", options3mf->metaDataLicenseTerms);
+    add_meta_data(metadatagroup, "LicenseTerms",
+                  options3mf->metaDataLicenseTerms);
     add_meta_data(metadatagroup, "Rating", options3mf->metaDataRating);
   }
 
-  ExportContext ctx{
-    .wrapper = wrapper,
-    .model = model,
-    .colorgroup = colorgroup,
-    .basematerialgroup = basematerialgroup,
-    .modelcount = 1,
-    .selectedColor = color,
-    .info = exportInfo,
-    .options = options3mf
-  };
+  ExportContext ctx{.wrapper = wrapper,
+                    .model = model,
+                    .colorgroup = colorgroup,
+                    .basematerialgroup = basematerialgroup,
+                    .modelcount = 1,
+                    .selectedColor = color,
+                    .info = exportInfo,
+                    .options = options3mf};
 
   if (!append_3mf(geom, ctx)) {
     return;
@@ -410,20 +437,23 @@ void export_3mf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
       export_3mf_error("Can't get writer for 3MF model.");
       return;
     }
-  } catch (Lib3MF::ELib3MFException& e) {
+  } catch (Lib3MF::ELib3MFException &e) {
     export_3mf_error("Can't get writer for 3MF model.");
     return;
   }
 
   try {
     writer->SetDecimalPrecision(ctx.options->decimalPrecision);
-  } catch (Lib3MF::ELib3MFException& e) {
-    LOG(message_group::Export_Error, "Error setting decimal precision for export: %1$s", e.what());
+  } catch (Lib3MF::ELib3MFException &e) {
+    LOG(message_group::Export_Error,
+        "Error setting decimal precision for export: %1$s", e.what());
   }
 
   try {
-    writer->WriteToCallback((Lib3MF::WriteCallback)lib3mf_write_callback, (Lib3MF::SeekCallback)lib3mf_seek_callback, &output);
-  } catch (Lib3MF::ELib3MFException& e) {
+    writer->WriteToCallback((Lib3MF::WriteCallback)lib3mf_write_callback,
+                            (Lib3MF::SeekCallback)lib3mf_seek_callback,
+                            &output);
+  } catch (Lib3MF::ELib3MFException &e) {
     LOG(message_group::Export_Error, e.what());
   }
   output.flush();
diff --git a/src/io/export_amf.cc b/src/io/export_amf.cc
index 891fd308a..7d7225f07 100644
--- a/src/io/export_amf.cc
+++ b/src/io/export_amf.cc
@@ -29,27 +29,27 @@
 #include "geometry/Geometry.h"
 
 #ifdef ENABLE_CGAL
+#include "geometry/cgal/CGALNefGeometry.h"
 #include "geometry/cgal/cgal.h"
 #include "geometry/cgal/cgalutils.h"
-#include "geometry/cgal/CGALNefGeometry.h"
 #endif
 
 #include <algorithm>
-#include <iterator>
 #include <cassert>
+#include <cstddef>
 #include <exception>
-#include <ostream>
+#include <iterator>
 #include <memory>
-#include <cstddef>
+#include <ostream>
 #include <string>
 #include <vector>
 
-#define QUOTE(x__) # x__
+#define QUOTE(x__) #x__
 #define QUOTED(x__) QUOTE(x__)
 
 struct vertex_str {
   std::string x, y, z;
-  bool operator==(const vertex_str& rhs) {
+  bool operator==(const vertex_str &rhs) {
     return x == rhs.x && y == rhs.y && z == rhs.z;
   }
 };
@@ -70,7 +70,7 @@ struct triangle {
 static int objectid;
 
 #ifdef ENABLE_CGAL
-static size_t add_vertex(std::vector<vertex_str>& vertices, const Point& p) {
+static size_t add_vertex(std::vector<vertex_str> &vertices, const Point &p) {
   double x = CGAL::to_double(p.x());
   double y = CGAL::to_double(p.y());
   double z = CGAL::to_double(p.z());
@@ -88,10 +88,10 @@ static size_t add_vertex(std::vector<vertex_str>& vertices, const Point& p) {
     Saves the current 3D CGAL Nef polyhedron as AMF to the given file.
     The file must be open.
  */
-static void append_amf(const CGALNefGeometry& root_N, std::ostream& output)
-{
+static void append_amf(const CGALNefGeometry &root_N, std::ostream &output) {
   if (!root_N.p3->is_simple()) {
-    LOG(message_group::Export_Warning, "Export failed, the object isn't a valid 2-manifold.");
+    LOG(message_group::Export_Warning,
+        "Export failed, the object isn't a valid 2-manifold.");
     return;
   }
   try {
@@ -116,8 +116,8 @@ static void append_amf(const CGALNefGeometry& root_N, std::ostream& output)
         if (vi1 != vi2 && vi1 != vi3 && vi2 != vi3) {
           // The above condition ensures that there are 3 distinct vertices, but
           // they may be collinear. If they are, the unit normal is meaningless
-          // so the default value of "1 0 0" can be used. If the vertices are not
-          // collinear then the unit normal must be calculated from the
+          // so the default value of "1 0 0" can be used. If the vertices are
+          // not collinear then the unit normal must be calculated from the
           // components.
           triangles.push_back({vi1, vi2, vi3});
         }
@@ -127,7 +127,7 @@ static void append_amf(const CGALNefGeometry& root_N, std::ostream& output)
     output << " <object id=\"" << objectid++ << "\">\r\n"
            << "  <mesh>\r\n";
     output << "   <vertices>\r\n";
-    for (const auto& s : vertices) {
+    for (const auto &s : vertices) {
       output << "    <vertex><coordinates>\r\n";
       output << "     <x>" << s.x << "</x>\r\n";
       output << "     <y>" << s.y << "</y>\r\n";
@@ -146,22 +146,26 @@ static void append_amf(const CGALNefGeometry& root_N, std::ostream& output)
     output << "   </volume>\r\n";
     output << "  </mesh>\r\n"
            << " </object>\r\n";
-  } catch (std::exception& e) {
-    LOG(message_group::Export_Error, "CGAL error in CGAL_Nef_polyhedron3::convert_to_polyhedron(): %1$s", e.what());
+  } catch (std::exception &e) {
+    LOG(message_group::Export_Error,
+        "CGAL error in CGAL_Nef_polyhedron3::convert_to_polyhedron(): %1$s",
+        e.what());
   }
 }
 #endif // ifdef ENABLE_CGAL
 
-static void append_amf(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
-    for (const auto& item : geomlist->getChildren()) {
+static void append_amf(const std::shared_ptr<const Geometry> &geom,
+                       std::ostream &output) {
+  if (const auto geomlist =
+          std::dynamic_pointer_cast<const GeometryList>(geom)) {
+    for (const auto &item : geomlist->getChildren()) {
       append_amf(item.second, output);
     }
 #ifdef ENABLE_CGAL
   } else if (auto N = CGALUtils::getNefPolyhedronFromGeometry(geom)) {
     // FIXME: Implement this without creating a Nef polyhedron
-    if (!N->isEmpty()) append_amf(*N, output);
+    if (!N->isEmpty())
+      append_amf(*N, output);
 #endif
   } else if (geom->getDimension() != 3) { // NOLINT(bugprone-branch-clone)
     assert(false && "Unsupported file format");
@@ -170,18 +174,19 @@ static void append_amf(const std::shared_ptr<const Geometry>& geom, std::ostream
   }
 }
 
-void export_amf(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
-  LOG(message_group::Deprecated, "AMF export is deprecated. Please use 3MF instead.");
+void export_amf(const std::shared_ptr<const Geometry> &geom,
+                std::ostream &output) {
+  LOG(message_group::Deprecated,
+      "AMF export is deprecated. Please use 3MF instead.");
   setlocale(LC_NUMERIC, "C"); // Ensure radix is . (not ,) in output
 
   output << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n"
          << "<amf unit=\"millimeter\">\r\n"
          << " <metadata type=\"producer\">OpenSCAD " << QUOTED(OPENSCAD_VERSION)
 #ifdef OPENSCAD_COMMIT
-    << " (git " << QUOTED(OPENSCAD_COMMIT) << ")"
+         << " (git " << QUOTED(OPENSCAD_COMMIT) << ")"
 #endif
-    << "</metadata>\r\n";
+         << "</metadata>\r\n";
 
   objectid = 0;
   append_amf(geom, output);
diff --git a/src/io/export_dxf.cc b/src/io/export_dxf.cc
index 3f7b4c002..978d6faef 100644
--- a/src/io/export_dxf.cc
+++ b/src/io/export_dxf.cc
@@ -32,15 +32,16 @@
 #include <ostream>
 
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
-#include "geometry/Polygon2d.h"
 #include "geometry/PolySet.h"
+#include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 
 /*!
     Saves the current Polygon2d as DXF to the given absolute filename.
  */
 
-static void export_dxf_header(std::ostream& output, double xMin, double yMin, double xMax, double yMax) {
+static void export_dxf_header(std::ostream &output, double xMin, double yMin,
+                              double xMax, double yMax) {
 
   // https://dxfwrite.readthedocs.io/en/latest/headervars.html
   // http://paulbourke.net/dataformats/dxf/min3d.html
@@ -56,8 +57,7 @@ static void export_dxf_header(std::ostream& output, double xMin, double yMin, do
   // - https://sharecad.org
   // - generic cutters
 
-  output
-    << "999\n" << "DXF from OpenSCAD\n";
+  output << "999\n" << "DXF from OpenSCAD\n";
 
   //
   // SECTION 1
@@ -65,116 +65,153 @@ static void export_dxf_header(std::ostream& output, double xMin, double yMin, do
 
   /* --- START --- */
 
-  output
-    << "  0\n" << "SECTION\n"
-    << "  2\n" << "HEADER\n"
-    << "  9\n" << "$ACADVER\n"
-    << "  1\n" << "AC1006\n"
-    << "  9\n" << "$INSBASE\n"
-    << " 10\n" << "0.0\n"
-    << " 20\n" << "0.0\n"
-    << " 30\n" << "0.0\n"
-  ;
+  output << "  0\n"
+         << "SECTION\n"
+         << "  2\n"
+         << "HEADER\n"
+         << "  9\n"
+         << "$ACADVER\n"
+         << "  1\n"
+         << "AC1006\n"
+         << "  9\n"
+         << "$INSBASE\n"
+         << " 10\n"
+         << "0.0\n"
+         << " 20\n"
+         << "0.0\n"
+         << " 30\n"
+         << "0.0\n";
 
   /* --- LIMITS --- */
 
-  output
-    << "  9\n" << "$EXTMIN\n"
-    << " 10\n" << xMin << "\n"
-    << " 20\n" << yMin << "\n"
-    << "  9\n" << "$EXTMAX\n"
-    << " 10\n" << xMax << "\n"
-    << " 20\n" << yMax << "\n";
-
-  output
-    << "  9\n" << "$LINMIN\n"
-    << " 10\n" << xMin << "\n"
-    << " 20\n" << yMin << "\n"
-    << "  9\n" << "$LINMAX\n"
-    << " 10\n" << xMax << "\n"
-    << " 20\n" << yMax << "\n";
-
-  output
-    << "  0\n" << "ENDSEC\n";
+  output << "  9\n"
+         << "$EXTMIN\n"
+         << " 10\n"
+         << xMin << "\n"
+         << " 20\n"
+         << yMin << "\n"
+         << "  9\n"
+         << "$EXTMAX\n"
+         << " 10\n"
+         << xMax << "\n"
+         << " 20\n"
+         << yMax << "\n";
+
+  output << "  9\n"
+         << "$LINMIN\n"
+         << " 10\n"
+         << xMin << "\n"
+         << " 20\n"
+         << yMin << "\n"
+         << "  9\n"
+         << "$LINMAX\n"
+         << " 10\n"
+         << xMax << "\n"
+         << " 20\n"
+         << yMax << "\n";
+
+  output << "  0\n" << "ENDSEC\n";
 
   //
   // SECTION 2
   //
 
-  output
-    << "  0\n" << "SECTION\n";
+  output << "  0\n" << "SECTION\n";
 
-  output
-    << "  2\n" << "TABLES\n";
+  output << "  2\n" << "TABLES\n";
 
   /* --- LINETYPE --- */
 
-  output
-    << "  0\n" << "TABLE\n"
-    << "  2\n" << "LTYPE\n"
-    << " 70\n" << "1\n"
-
-    << "  0\n" << "LTYPE\n"
-    << "  2\n" << "CONTINUOUS\n"       // linetype name
-    << " 70\n" << "64\n"
-    << "  3\n" << "Solid line\n"       // descriptive text
-    << " 72\n" << "65\n"       // always 65
-    << " 73\n" << "0\n"        // number of linetype elements
-    << " 40\n" << "0.000000\n"       // total pattern length
-
-    << "  0\n" << "ENDTAB\n";
+  output << "  0\n"
+         << "TABLE\n"
+         << "  2\n"
+         << "LTYPE\n"
+         << " 70\n"
+         << "1\n"
+
+         << "  0\n"
+         << "LTYPE\n"
+         << "  2\n"
+         << "CONTINUOUS\n" // linetype name
+         << " 70\n"
+         << "64\n"
+         << "  3\n"
+         << "Solid line\n" // descriptive text
+         << " 72\n"
+         << "65\n" // always 65
+         << " 73\n"
+         << "0\n" // number of linetype elements
+         << " 40\n"
+         << "0.000000\n" // total pattern length
+
+         << "  0\n"
+         << "ENDTAB\n";
 
   /* --- LAYERS --- */
 
-  output
-    << "  0\n" << "TABLE\n"
-    << "  2\n" << "LAYER\n"
-    << " 70\n" << "6\n"
-
-    << "  0\n" << "LAYER\n"
-    << "  2\n" << "0\n"         // layer name
-    << " 70\n" << "64\n"
-    << " 62\n" << "7\n"         // color
-    << "  6\n" << "CONTINUOUS\n"
-
-    << "  0\n" << "ENDTAB\n";
+  output << "  0\n"
+         << "TABLE\n"
+         << "  2\n"
+         << "LAYER\n"
+         << " 70\n"
+         << "6\n"
+
+         << "  0\n"
+         << "LAYER\n"
+         << "  2\n"
+         << "0\n" // layer name
+         << " 70\n"
+         << "64\n"
+         << " 62\n"
+         << "7\n" // color
+         << "  6\n"
+         << "CONTINUOUS\n"
+
+         << "  0\n"
+         << "ENDTAB\n";
 
   /* --- STYLE --- */
 
-  output
-    << "  0\n" << "TABLE\n"
-    << "  2\n" << "STYLE\n"
-    << " 70\n" << "0\n"
-    << "  0\n" << "ENDTAB\n";
+  output << "  0\n"
+         << "TABLE\n"
+         << "  2\n"
+         << "STYLE\n"
+         << " 70\n"
+         << "0\n"
+         << "  0\n"
+         << "ENDTAB\n";
 
-  output
-    << "  0\n" << "ENDSEC\n";
+  output << "  0\n" << "ENDSEC\n";
 
   //
   // SECTION 3
   //
 
-  output
-    << "  0\n" << "SECTION\n"
-    << "  2\n" << "BLOCKS\n"
-    << "  0\n" << "ENDSEC\n";
-
+  output << "  0\n"
+         << "SECTION\n"
+         << "  2\n"
+         << "BLOCKS\n"
+         << "  0\n"
+         << "ENDSEC\n";
 }
 
-static void export_dxf(const Polygon2d& poly, std::ostream& output)
-{
+static void export_dxf(const Polygon2d &poly, std::ostream &output) {
   setlocale(LC_NUMERIC, "C"); // Ensure radix is . (not ,) in output
 
   // find limits
   double xMin, yMin, xMax, yMax;
   xMin = yMin = std::numeric_limits<double>::max(),
   xMax = yMax = std::numeric_limits<double>::min();
-  for (const auto& o : poly.outlines()) {
-    for (const auto& p : o.vertices) {
-      if (xMin > p[0]) xMin = p[0];
-      if (xMax < p[0]) xMax = p[0];
-      if (yMin > p[1]) yMin = p[1];
-      if (yMax < p[1]) yMax = p[1];
+  for (const auto &o : poly.outlines()) {
+    for (const auto &p : o.vertices) {
+      if (xMin > p[0])
+        xMin = p[0];
+      if (xMax < p[0])
+        xMax = p[0];
+      if (yMin > p[1])
+        yMin = p[1];
+      if (yMax < p[1])
+        yMax = p[1];
     }
   }
 
@@ -190,47 +227,72 @@ static void export_dxf(const Polygon2d& poly, std::ostream& output)
   // DXF Format
   //    https://documentation.help/AutoCAD-DXF/WSfacf1429558a55de185c428100849a0ab7-5f35.htm
 
-  output << "  0\n" << "SECTION\n"
-         << "  2\n" << "ENTITIES\n";
+  output << "  0\n"
+         << "SECTION\n"
+         << "  2\n"
+         << "ENTITIES\n";
 
-  for (const auto& o : poly.outlines()) {
-    switch (o.vertices.size() ) {
+  for (const auto &o : poly.outlines()) {
+    switch (o.vertices.size()) {
     case 1: {
       // POINT: just in case it's supported in the future
-      const Vector2d& p = o.vertices[0];
-      output << "  0\n" << "POINT\n"
-             << "100\n" << "AcDbEntity\n"
-             << "  8\n" << "0\n" // layer 0
-             << "100\n" << "AcDbPoint\n"
-             << " 10\n" << p[0] << "\n" // x
-             << " 20\n" << p[1] << "\n"; // y
+      const Vector2d &p = o.vertices[0];
+      output << "  0\n"
+             << "POINT\n"
+             << "100\n"
+             << "AcDbEntity\n"
+             << "  8\n"
+             << "0\n" // layer 0
+             << "100\n"
+             << "AcDbPoint\n"
+             << " 10\n"
+             << p[0] << "\n" // x
+             << " 20\n"
+             << p[1] << "\n"; // y
     } break;
     case 2: {
       // LINE: just in case it's supported in the future
       // The [X1 Y1 X2 Y2] order is the most common and can be parsed linearly.
-      // Some libraries, like the python libraries dxfgrabber and ezdxf, cannot open [X1 X2 Y1 Y2] order.
-      const Vector2d& p1 = o.vertices[0];
-      const Vector2d& p2 = o.vertices[1];
-      output << "  0\n" << "LINE\n"
-             << "100\n" << "AcDbEntity\n"
-             << "  8\n" << "0\n" // layer 0
-             << "100\n" << "AcDbLine\n"
-             << " 10\n" << p1[0] << "\n" // x1
-             << " 20\n" << p1[1] << "\n" // y1
-             << " 11\n" << p2[0] << "\n" // x2
-             << " 21\n" << p2[1] << "\n"; // y2
+      // Some libraries, like the python libraries dxfgrabber and ezdxf, cannot
+      // open [X1 X2 Y1 Y2] order.
+      const Vector2d &p1 = o.vertices[0];
+      const Vector2d &p2 = o.vertices[1];
+      output << "  0\n"
+             << "LINE\n"
+             << "100\n"
+             << "AcDbEntity\n"
+             << "  8\n"
+             << "0\n" // layer 0
+             << "100\n"
+             << "AcDbLine\n"
+             << " 10\n"
+             << p1[0] << "\n" // x1
+             << " 20\n"
+             << p1[1] << "\n" // y1
+             << " 11\n"
+             << p2[0] << "\n" // x2
+             << " 21\n"
+             << p2[1] << "\n"; // y2
     } break;
     default:
       // LWPOLYLINE
-      output << "  0\n" << "LWPOLYLINE\n"
-             << "100\n" << "AcDbEntity\n"
-             << "  8\n" << "0\n"      // layer 0
-             << "100\n" << "AcDbPolyline\n"
-             << " 90\n" << o.vertices.size() << "\n" // number of vertices
-             << " 70\n" << "1\n";         // closed = 1
-      for (const auto& p : o.vertices) {
-        output << " 10\n" << p[0] << "\n"
-               << " 20\n" << p[1] << "\n";
+      output << "  0\n"
+             << "LWPOLYLINE\n"
+             << "100\n"
+             << "AcDbEntity\n"
+             << "  8\n"
+             << "0\n" // layer 0
+             << "100\n"
+             << "AcDbPolyline\n"
+             << " 90\n"
+             << o.vertices.size() << "\n" // number of vertices
+             << " 70\n"
+             << "1\n"; // closed = 1
+      for (const auto &p : o.vertices) {
+        output << " 10\n"
+               << p[0] << "\n"
+               << " 20\n"
+               << p[1] << "\n";
       }
       break;
     }
@@ -242,15 +304,18 @@ static void export_dxf(const Polygon2d& poly, std::ostream& output)
   setlocale(LC_NUMERIC, ""); // set default locale
 }
 
-void export_dxf(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
-    for (const auto& item : geomlist->getChildren()) {
+void export_dxf(const std::shared_ptr<const Geometry> &geom,
+                std::ostream &output) {
+  if (const auto geomlist =
+          std::dynamic_pointer_cast<const GeometryList>(geom)) {
+    for (const auto &item : geomlist->getChildren()) {
       export_dxf(item.second, output);
     }
-  } else if (const auto poly = std::dynamic_pointer_cast<const Polygon2d>(geom)) {
+  } else if (const auto poly =
+                 std::dynamic_pointer_cast<const Polygon2d>(geom)) {
     export_dxf(*poly, output);
-  } else if (std::dynamic_pointer_cast<const PolySet>(geom)) { // NOLINT(bugprone-branch-clone)
+  } else if (std::dynamic_pointer_cast<const PolySet>(
+                 geom)) { // NOLINT(bugprone-branch-clone)
     assert(false && "Unsupported file format");
   } else { // NOLINT(bugprone-branch-clone)
     assert(false && "Export as DXF for this geometry type is not supported");
diff --git a/src/io/export_nef.cc b/src/io/export_nef.cc
index 71aee7d06..2987592d0 100644
--- a/src/io/export_nef.cc
+++ b/src/io/export_nef.cc
@@ -36,8 +36,8 @@
 #include "geometry/cgal/cgal.h"
 #include "geometry/cgal/cgalutils.h"
 
-void export_nefdbg(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
+void export_nefdbg(const std::shared_ptr<const Geometry> &geom,
+                   std::ostream &output) {
   if (auto N = CGALUtils::getNefPolyhedronFromGeometry(geom)) {
     output << N->dump();
   } else {
@@ -45,10 +45,11 @@ void export_nefdbg(const std::shared_ptr<const Geometry>& geom, std::ostream& ou
   }
 }
 
-void export_nef3(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
+void export_nef3(const std::shared_ptr<const Geometry> &geom,
+                 std::ostream &output) {
   if (auto N = CGALUtils::getNefPolyhedronFromGeometry(geom)) {
-    output << const_cast<CGAL_Nef_polyhedron3&>(*N->p3); // NOLINT(clang-analyzer-cplusplus.NewDeleteLeaks)
+    output << const_cast<CGAL_Nef_polyhedron3 &>(
+        *N->p3); // NOLINT(clang-analyzer-cplusplus.NewDeleteLeaks)
   } else {
     LOG("Not a CGALNefPoly. Add some CSG ops?");
   }
diff --git a/src/io/export_obj.cc b/src/io/export_obj.cc
index 27e25d848..d3b5a4771 100644
--- a/src/io/export_obj.cc
+++ b/src/io/export_obj.cc
@@ -27,15 +27,15 @@
 
 #include "io/export.h"
 
-#include <ostream>
 #include <memory>
+#include <ostream>
 
 #include "geometry/Geometry.h"
-#include "geometry/PolySetUtils.h"
 #include "geometry/PolySet.h"
+#include "geometry/PolySetUtils.h"
 
-void export_obj(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
+void export_obj(const std::shared_ptr<const Geometry> &geom,
+                std::ostream &output) {
   // FIXME: In lazy union mode, should we export multiple objects?
 
   std::shared_ptr<const PolySet> out = PolySetUtils::getGeometryAsPolySet(geom);
@@ -54,11 +54,11 @@ void export_obj(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
 
   output << "# OpenSCAD obj exporter\n";
 
-  for (const auto& v : out->vertices) {
+  for (const auto &v : out->vertices) {
     output << "v " << v[0] << " " << v[1] << " " << v[2] << "\n";
   }
 
-  for (const auto& poly : out->indices) {
+  for (const auto &poly : out->indices) {
     output << "f ";
     for (const auto idx : poly) {
       output << " " << idx + 1;
diff --git a/src/io/export_off.cc b/src/io/export_off.cc
index e39c01f7a..7f1d788b5 100644
--- a/src/io/export_off.cc
+++ b/src/io/export_off.cc
@@ -27,26 +27,25 @@
 
 #include "io/export.h"
 
-#include <ostream>
-#include <memory>
 #include <cstddef>
 #include <cstdint>
+#include <memory>
+#include <ostream>
 
 #include "Feature.h"
 #include "geometry/Geometry.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetUtils.h"
 
-void export_off(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
+void export_off(const std::shared_ptr<const Geometry> &geom,
+                std::ostream &output) {
   auto ps = PolySetUtils::getGeometryAsPolySet(geom);
   if (Feature::ExperimentalPredictibleOutput.is_enabled()) {
     ps = createSortedPolySet(*ps);
   }
-  const auto& v = ps->vertices;
+  const auto &v = ps->vertices;
   const size_t numverts = v.size();
 
-
   output << "OFF " << numverts << " " << ps->indices.size() << " 0\n";
   for (size_t i = 0; i < numverts; ++i) {
     output << v[i][0] << " " << v[i][1] << " " << v[i][2] << " " << "\n";
@@ -57,7 +56,8 @@ void export_off(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
   for (size_t i = 0; i < ps->indices.size(); ++i) {
     const size_t nverts = ps->indices[i].size();
     output << nverts;
-    for (size_t n = 0; n < nverts; ++n) output << " " << ps->indices[i][n];
+    for (size_t n = 0; n < nverts; ++n)
+      output << " " << ps->indices[i][n];
     if (has_color) {
       auto color_index = ps->color_indices[i];
       if (color_index >= 0) {
@@ -68,7 +68,8 @@ void export_off(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
         }
         output << " " << r << " " << g << " " << b;
         // Alpha channel is read by apps like MeshLab.
-        if (a != 255) output << " " << a;
+        if (a != 255)
+          output << " " << a;
       }
     }
     output << "\n";
diff --git a/src/io/export_param.cc b/src/io/export_param.cc
index 3561e8660..ecb128397 100644
--- a/src/io/export_param.cc
+++ b/src/io/export_param.cc
@@ -24,23 +24,24 @@
  *
  */
 
+#include "json/json.hpp"
+#include <boost/property_tree/json_parser.hpp>
 #include <filesystem>
 #include <iostream>
 #include <string>
-#include "json/json.hpp"
-#include <boost/property_tree/json_parser.hpp>
 
-#include "io/export.h"
 #include "core/customizer/ParameterObject.h"
+#include "io/export.h"
 
 using json = nlohmann::json;
 
-bool export_param(SourceFile *sourceFile, const fs::path& path, std::ostream& output)
-{
-  const ParameterObjects parameters = ParameterObjects::fromSourceFile(sourceFile);
+bool export_param(SourceFile *sourceFile, const fs::path &path,
+                  std::ostream &output) {
+  const ParameterObjects parameters =
+      ParameterObjects::fromSourceFile(sourceFile);
 
   json params;
-  for (auto& param : parameters) {
+  for (auto &param : parameters) {
     const std::string description = param->description();
     const std::string group = param->group();
 
@@ -57,7 +58,8 @@ bool export_param(SourceFile *sourceFile, const fs::path& path, std::ostream& ou
   }
 
   json paramFile;
-  paramFile["title"] = path.has_stem() ? path.stem().generic_string() : "Unnamed";
+  paramFile["title"] =
+      path.has_stem() ? path.stem().generic_string() : "Unnamed";
   if (params.size() > 0) {
     paramFile["parameters"] = params;
   }
diff --git a/src/io/export_pdf.cc b/src/io/export_pdf.cc
index 1da26cd7a..6abb2d1f0 100644
--- a/src/io/export_pdf.cc
+++ b/src/io/export_pdf.cc
@@ -1,33 +1,32 @@
 #include "io/export.h"
 
 #include <cassert>
-#include <ostream>
+#include <cmath>
 #include <memory>
+#include <ostream>
 #include <string>
-#include <cmath>
 
 #include <Eigen/Core>
 
 #include "core/ColorUtil.h"
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
-#include "geometry/Polygon2d.h"
 #include "geometry/PolySet.h"
+#include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 #include "io/export_enums.h"
 #include "utils/printutils.h"
 #include "utils/version_helper.h"
 
 #ifdef ENABLE_CAIRO
 
-#include <cairo.h>
 #include <cairo-pdf.h>
+#include <cairo.h>
 
 constexpr inline auto FONT = "Liberation Sans";
 constexpr double MARGIN = 30.0;
 constexpr double PTS_IN_MM = 2.834645656693;
 
-std::string get_cairo_version()
-{
+std::string get_cairo_version() {
   return OpenSCAD::get_version(CAIRO_VERSION_STRING, cairo_version_string());
 }
 
@@ -38,18 +37,19 @@ namespace {
 // rows map to paperSizes enums
 // columns are Width, Height
 const int paperDimensions[7][2] = {
-  {298, 420},   // A6
-  {420, 595},   // A5
-  {595, 842},   // A4
-  {842, 1190},  // A3
-  {612, 792},   // Letter
-  {612, 1008},  // Legal
-  {792, 1224},  // Tabloid
+    {298, 420},  // A6
+    {420, 595},  // A5
+    {595, 842},  // A4
+    {842, 1190}, // A3
+    {612, 792},  // Letter
+    {612, 1008}, // Legal
+    {792, 1224}, // Tabloid
 };
 
-void draw_text(const char *text, cairo_t *cr, double x, double y, double fontSize)
-{
-  cairo_select_font_face(cr, FONT, CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
+void draw_text(const char *text, cairo_t *cr, double x, double y,
+               double fontSize) {
+  cairo_select_font_face(cr, FONT, CAIRO_FONT_SLANT_NORMAL,
+                         CAIRO_FONT_WEIGHT_NORMAL);
   cairo_set_font_size(cr, fontSize);
   cairo_move_to(cr, x, y);
   cairo_show_text(cr, text);
@@ -59,9 +59,10 @@ double mm_to_points(double mm) { return mm * PTS_IN_MM; }
 
 double points_to_mm(double pts) { return pts / PTS_IN_MM; }
 
-void draw_grid(cairo_t *cr, double left, double right, double bottom, double top, double gridSize)
-{
-  if (gridSize < 1.) gridSize = 2.0;
+void draw_grid(cairo_t *cr, double left, double right, double bottom,
+               double top, double gridSize) {
+  if (gridSize < 1.)
+    gridSize = 2.0;
   const double darkerLine = 0.36;
   const double lightLine = 0.24;
   const int major = (gridSize > 10.0 ? gridSize : int(10.0 / gridSize));
@@ -106,11 +107,11 @@ void draw_grid(cairo_t *cr, double left, double right, double bottom, double top
 }
 
 // New draw_axes (renamed from axis since it draws both).
-void draw_axes(cairo_t *cr, double left, double right, double bottom, double top)
-{
+void draw_axes(cairo_t *cr, double left, double right, double bottom,
+               double top) {
   const double darkerLine = 0.36;
   const double offset = mm_to_points(5.);
-  double pts = 0.;  // for iteration across page
+  double pts = 0.; // for iteration across page
 
   cairo_set_line_width(cr, darkerLine);
   cairo_set_source_rgba(cr, 0., 0., 0., 0.6);
@@ -156,17 +157,16 @@ void draw_axes(cairo_t *cr, double left, double right, double bottom, double top
 }
 
 // Draws a single 2D polygon.
-void draw_geom(const Polygon2d& poly, cairo_t *cr)
-{
-  for (const auto& o : poly.outlines()) {
+void draw_geom(const Polygon2d &poly, cairo_t *cr) {
+  for (const auto &o : poly.outlines()) {
     if (o.vertices.empty()) {
       continue;
     }
-    const Eigen::Vector2d& p0 = o.vertices[0];
+    const Eigen::Vector2d &p0 = o.vertices[0];
     // Move to the first vertice.  Note Y is inverted in Cairo.
     cairo_move_to(cr, mm_to_points(p0.x()), mm_to_points(-p0.y()));
     for (unsigned int idx = 1; idx < o.vertices.size(); idx++) {
-      const Eigen::Vector2d& p = o.vertices[idx];
+      const Eigen::Vector2d &p = o.vertices[idx];
       cairo_line_to(cr, mm_to_points(p.x()), mm_to_points(-p.y()));
     }
     // Draw a line from the last vertice to the first vertice.
@@ -175,31 +175,32 @@ void draw_geom(const Polygon2d& poly, cairo_t *cr)
 }
 
 // Main entry:  draw geometry that consists of 2D polygons.  Walks the tree...
-void draw_geom(const std::shared_ptr<const Geometry>& geom, cairo_t *cr)
-{
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
-    for (const auto& item : geomlist->getChildren()) {
+void draw_geom(const std::shared_ptr<const Geometry> &geom, cairo_t *cr) {
+  if (const auto geomlist =
+          std::dynamic_pointer_cast<const GeometryList>(geom)) {
+    for (const auto &item : geomlist->getChildren()) {
       draw_geom(item.second, cr);
     }
   } else if (std::dynamic_pointer_cast<const PolySet>(geom)) {
     assert(false && "Unsupported file format");
-  } else if (const auto poly = std::dynamic_pointer_cast<const Polygon2d>(geom)) {
+  } else if (const auto poly =
+                 std::dynamic_pointer_cast<const Polygon2d>(geom)) {
     draw_geom(*poly, cr);
   } else {
     assert(false && "Export as PDF for this geometry type is not supported");
   }
 }
 
-cairo_status_t export_pdf_write(void *closure, const unsigned char *data, unsigned int length)
-{
+cairo_status_t export_pdf_write(void *closure, const unsigned char *data,
+                                unsigned int length) {
   auto *stream = static_cast<std::ostream *>(closure);
   stream->write(reinterpret_cast<const char *>(data), length);
   return !(*stream) ? CAIRO_STATUS_WRITE_ERROR : CAIRO_STATUS_SUCCESS;
 }
 
-void add_meta_data(cairo_surface_t *surface, const cairo_pdf_metadata_t metadata,
-                   const std::string& value, const std::string& value2 = "")
-{
+void add_meta_data(cairo_surface_t *surface,
+                   const cairo_pdf_metadata_t metadata,
+                   const std::string &value, const std::string &value2 = "") {
   const std::string v = value.empty() ? value2 : value;
   if (v.empty()) {
     return;
@@ -208,11 +209,10 @@ void add_meta_data(cairo_surface_t *surface, const cairo_pdf_metadata_t metadata
   cairo_pdf_surface_set_metadata(surface, metadata, v.c_str());
 }
 
-}  // namespace
+} // namespace
 
-void export_pdf(const std::shared_ptr<const Geometry>& geom, std::ostream& output,
-                const ExportInfo& exportInfo)
-{
+void export_pdf(const std::shared_ptr<const Geometry> &geom,
+                std::ostream &output, const ExportInfo &exportInfo) {
   // Extract the options.  This will change when options becomes a variant.
   const ExportPdfOptions *options;
   const ExportPdfOptions defaultPdfOptions;
@@ -241,7 +241,8 @@ void export_pdf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
   const int centerY = mm_to_points(miny) + spanY / 2.0;
 
   // Set orientation and paper size.
-  if ((options->orientation == ExportPdfPaperOrientation::AUTO && spanX > spanY) ||
+  if ((options->orientation == ExportPdfPaperOrientation::AUTO &&
+       spanX > spanY) ||
       (options->orientation == ExportPdfPaperOrientation::LANDSCAPE)) {
     pdfX = paperDimensions[static_cast<int>(options->paperSize)][1];
     pdfY = paperDimensions[static_cast<int>(options->paperSize)][0];
@@ -253,43 +254,54 @@ void export_pdf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
   // Does it fit? (in points)
   const bool inpaper = (spanX <= pdfX - MARGIN) && (spanY <= pdfY - MARGIN);
   if (!inpaper) {
-    LOG(message_group::Export_Warning, "Geometry is too large to fit into selected size.");
+    LOG(message_group::Export_Warning,
+        "Geometry is too large to fit into selected size.");
   }
 
   //  Center on page.  Still in points.
   // Note Cairo inverts the Y axis, with zero at the top, positive going down.
   // Compute translation and auxiliary numbers in lieu of transform matrices.
   const double tcX = pdfX / 2.0 - centerX;
-  const double tcY = (pdfY / 2.0 + centerY);  // Note Geometry Y will still need to be inverted.
+  const double tcY =
+      (pdfY / 2.0 + centerY); // Note Geometry Y will still need to be inverted.
   // Shifted exact margins
-  const double Mlx = centerX - pdfX / 2.0 + MARGIN;     // Left margin, X axis
-  const double Mrx = centerX + pdfX / 2.0 - MARGIN;     // Right margin, X axis
-  const double Mty = -(centerY - pdfY / 2.0 + MARGIN);  // INVERTED Top margin, Y axis
-  const double Mby = -(centerY + pdfY / 2.0 - MARGIN);  // INVERTED Bottom margin, Y axis
+  const double Mlx = centerX - pdfX / 2.0 + MARGIN; // Left margin, X axis
+  const double Mrx = centerX + pdfX / 2.0 - MARGIN; // Right margin, X axis
+  const double Mty =
+      -(centerY - pdfY / 2.0 + MARGIN); // INVERTED Top margin, Y axis
+  const double Mby =
+      -(centerY + pdfY / 2.0 - MARGIN); // INVERTED Bottom margin, Y axis
 
   // Initialize Cairo Surface and PDF
-  cairo_surface_t *surface = cairo_pdf_surface_create_for_stream(export_pdf_write, &output, pdfX, pdfY);
-  if (cairo_surface_status(surface) == cairo_status_t::CAIRO_STATUS_NULL_POINTER) {
+  cairo_surface_t *surface = cairo_pdf_surface_create_for_stream(
+      export_pdf_write, &output, pdfX, pdfY);
+  if (cairo_surface_status(surface) ==
+      cairo_status_t::CAIRO_STATUS_NULL_POINTER) {
     cairo_surface_destroy(surface);
     return;
   }
 
 #if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 16, 0)
   if (options->addMetaData) {
-    add_meta_data(surface, CAIRO_PDF_METADATA_TITLE, options->metaDataTitle, exportInfo.title);
+    add_meta_data(surface, CAIRO_PDF_METADATA_TITLE, options->metaDataTitle,
+                  exportInfo.title);
     add_meta_data(surface, CAIRO_PDF_METADATA_CREATOR, EXPORT_CREATOR);
-    add_meta_data(surface, CAIRO_PDF_METADATA_CREATE_DATE, get_current_iso8601_date_time_utc());
+    add_meta_data(surface, CAIRO_PDF_METADATA_CREATE_DATE,
+                  get_current_iso8601_date_time_utc());
     add_meta_data(surface, CAIRO_PDF_METADATA_MOD_DATE, "");
     add_meta_data(surface, CAIRO_PDF_METADATA_AUTHOR, options->metaDataAuthor);
-    add_meta_data(surface, CAIRO_PDF_METADATA_SUBJECT, options->metaDataSubject);
-    add_meta_data(surface, CAIRO_PDF_METADATA_KEYWORDS, options->metaDataKeywords);
+    add_meta_data(surface, CAIRO_PDF_METADATA_SUBJECT,
+                  options->metaDataSubject);
+    add_meta_data(surface, CAIRO_PDF_METADATA_KEYWORDS,
+                  options->metaDataKeywords);
   }
 #endif
 
   cairo_t *cr = cairo_create(surface);
 
-  // Note Y axis + is DOWN.  Drawings have to invert Y, but these translations account for that.
-  cairo_translate(cr, tcX, tcY);  // Center page on geometry;
+  // Note Y axis + is DOWN.  Drawings have to invert Y, but these translations
+  // account for that.
+  cairo_translate(cr, tcX, tcY); // Center page on geometry;
 
   const Color4f black = Color4f(0.0f, 0.0f, 0.0f);
 
@@ -298,13 +310,15 @@ void export_pdf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
 
   if (options->fill) {
     Color4f fillColor = OpenSCAD::getColor(options->fillColor, black);
-    cairo_set_source_rgba(cr, fillColor.r(), fillColor.g(), fillColor.b(), fillColor.a());
+    cairo_set_source_rgba(cr, fillColor.r(), fillColor.g(), fillColor.b(),
+                          fillColor.a());
     cairo_fill_preserve(cr);
   }
 
   if (options->stroke) {
     Color4f strokeColor = OpenSCAD::getColor(options->strokeColor, black);
-    cairo_set_source_rgba(cr, strokeColor.r(), strokeColor.g(), strokeColor.b(), strokeColor.a());
+    cairo_set_source_rgba(cr, strokeColor.r(), strokeColor.g(), strokeColor.b(),
+                          strokeColor.a());
     cairo_set_line_width(cr, mm_to_points(options->strokeWidth));
     cairo_stroke_preserve(cr);
   }
@@ -314,18 +328,21 @@ void export_pdf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
 
   // Set Annotations
   const std::string about =
-    "Scale is to calibrate actual printed dimension. Check both X and Y. "
-    "Measure between tick 0 and last tick";
+      "Scale is to calibrate actual printed dimension. Check both X and Y. "
+      "Measure between tick 0 and last tick";
   cairo_set_source_rgba(cr, 0.0, 0.0, 0.0, 0.48);
   // Design Filename
-  if (options->showDesignFilename) draw_text(exportInfo.sourceFilePath.c_str(), cr, Mlx, Mby, 10.0);
+  if (options->showDesignFilename)
+    draw_text(exportInfo.sourceFilePath.c_str(), cr, Mlx, Mby, 10.0);
   // Scale
   if (options->showScale) {
     draw_axes(cr, Mlx, Mrx, Mty, Mby);
     // Scale Message
-    if (options->showScaleMsg) draw_text(about.c_str(), cr, Mlx + 1, Mty - 1, 5.0);
+    if (options->showScaleMsg)
+      draw_text(about.c_str(), cr, Mlx + 1, Mty - 1, 5.0);
     // Grid
-    if (options->showGrid) draw_grid(cr, Mlx, Mrx, Mty, Mby, options->gridSize);
+    if (options->showGrid)
+      draw_grid(cr, Mlx, Mrx, Mty, Mby, options->gridSize);
   }
 
   cairo_show_page(cr);
@@ -333,17 +350,17 @@ void export_pdf(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
   cairo_destroy(cr);
 }
 
-#else  // ENABLE_CAIRO
+#else // ENABLE_CAIRO
 
-const std::string get_cairo_version()
-{
+const std::string get_cairo_version() {
   const std::string cairo_version = "(not enabled)";
   return cairo_version;
 }
 
-void export_pdf(const std::shared_ptr<const Geometry>&, std::ostream&, const ExportInfo&)
-{
-  LOG(message_group::Error, "Export to PDF format was not enabled when building the application.");
+void export_pdf(const std::shared_ptr<const Geometry> &, std::ostream &,
+                const ExportInfo &) {
+  LOG(message_group::Error,
+      "Export to PDF format was not enabled when building the application.");
 }
 
-#endif  // ENABLE_CAIRO
+#endif // ENABLE_CAIRO
diff --git a/src/io/export_png.cc b/src/io/export_png.cc
index b12e4380b..932f64f3b 100644
--- a/src/io/export_png.cc
+++ b/src/io/export_png.cc
@@ -1,8 +1,8 @@
 #include "io/export.h"
 
-#include <ostream>
 #include <cstdio>
 #include <memory>
+#include <ostream>
 
 #include "core/Tree.h"
 #include "geometry/Geometry.h"
@@ -10,38 +10,40 @@
 #include "glview/Camera.h"
 #include "glview/CsgInfo.h"
 #include "glview/OffscreenView.h"
-#include "glview/Renderer.h"
 #include "glview/RenderSettings.h"
+#include "glview/Renderer.h"
 #include "utils/printutils.h"
 
 #ifndef NULLGL
-#include "glview/cgal/CGALRenderer.h"
 #include "glview/PolySetRenderer.h"
+#include "glview/cgal/CGALRenderer.h"
 
 #ifdef ENABLE_OPENCSG
 #include "glview/preview/OpenCSGRenderer.h"
 #include <opencsg.h>
-#endif  // ENABLE_OPENCSG
+#endif // ENABLE_OPENCSG
 
 #include "glview/preview/ThrownTogetherRenderer.h"
 
 namespace {
 
-void setupCamera(Camera& cam, const BoundingBox& bbox)
-{
-  if (cam.viewall) cam.viewAll(bbox);
+void setupCamera(Camera &cam, const BoundingBox &bbox) {
+  if (cam.viewall)
+    cam.viewAll(bbox);
 }
 
-}  // namespace
+} // namespace
 
-bool export_png(const std::shared_ptr<const Geometry>& root_geom, const ViewOptions& options, Camera& camera, std::ostream& output)
-{
+bool export_png(const std::shared_ptr<const Geometry> &root_geom,
+                const ViewOptions &options, Camera &camera,
+                std::ostream &output) {
   assert(root_geom != nullptr);
   PRINTD("export_png geom");
   std::unique_ptr<OffscreenView> glview;
   try {
-    glview = std::make_unique<OffscreenView>(camera.pixel_width, camera.pixel_height);
-  } catch (const OffscreenViewException& ex) {
+    glview = std::make_unique<OffscreenView>(camera.pixel_width,
+                                             camera.pixel_height);
+  } catch (const OffscreenViewException &ex) {
     fprintf(stderr, "Can't create OffscreenView: %s.\n", ex.what());
     return false;
   }
@@ -50,7 +52,7 @@ bool export_png(const std::shared_ptr<const Geometry>& root_geom, const ViewOpti
   // know that all geometries are convertible to PolySet.
   if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend ||
       std::dynamic_pointer_cast<const PolySet>(root_geom) ||
-      std::dynamic_pointer_cast<const Polygon2d>(root_geom)){
+      std::dynamic_pointer_cast<const Polygon2d>(root_geom)) {
     geomRenderer = std::make_shared<PolySetRenderer>(root_geom);
   } else {
     geomRenderer = std::make_shared<CGALRenderer>(root_geom);
@@ -70,16 +72,17 @@ bool export_png(const std::shared_ptr<const Geometry>& root_geom, const ViewOpti
   return true;
 }
 
-std::unique_ptr<OffscreenView> prepare_preview(Tree& tree, const ViewOptions& options, Camera& camera)
-{
+std::unique_ptr<OffscreenView>
+prepare_preview(Tree &tree, const ViewOptions &options, Camera &camera) {
   PRINTD("prepare_preview_common");
   CsgInfo csgInfo = CsgInfo();
   csgInfo.compile_products(tree);
 
   std::unique_ptr<OffscreenView> glview;
   try {
-    glview = std::make_unique<OffscreenView>(camera.pixel_width, camera.pixel_height);
-  } catch (const OffscreenViewException& ex) {
+    glview = std::make_unique<OffscreenView>(camera.pixel_width,
+                                             camera.pixel_height);
+  } catch (const OffscreenViewException &ex) {
     LOG("Can't create OffscreenView: %1$s.", ex.what());
     return nullptr;
   }
@@ -88,19 +91,22 @@ std::unique_ptr<OffscreenView> prepare_preview(Tree& tree, const ViewOptions& op
   if (options.previewer == Previewer::OPENCSG) {
 #ifdef ENABLE_OPENCSG
     PRINTD("Initializing OpenCSGRenderer");
-    renderer = std::make_shared<OpenCSGRenderer>(csgInfo.root_products, csgInfo.highlights_products, csgInfo.background_products);
+    renderer = std::make_shared<OpenCSGRenderer>(csgInfo.root_products,
+                                                 csgInfo.highlights_products,
+                                                 csgInfo.background_products);
 #else
     fprintf(stderr, "This openscad was built without OpenCSG support\n");
     return 0;
 #endif
   } else {
     PRINTD("Initializing ThrownTogetherRenderer");
-    renderer = std::make_shared<ThrownTogetherRenderer>(csgInfo.root_products, csgInfo.highlights_products, csgInfo.background_products);
+    renderer = std::make_shared<ThrownTogetherRenderer>(
+        csgInfo.root_products, csgInfo.highlights_products,
+        csgInfo.background_products);
   }
 
   glview->setRenderer(renderer);
 
-
 #ifdef ENABLE_OPENCSG
   const BoundingBox bbox = glview->getRenderer()->getBoundingBox();
   setupCamera(camera, bbox);
@@ -117,8 +123,7 @@ std::unique_ptr<OffscreenView> prepare_preview(Tree& tree, const ViewOptions& op
   return glview;
 }
 
-bool export_png(const OffscreenView& glview, std::ostream& output)
-{
+bool export_png(const OffscreenView &glview, std::ostream &output) {
   PRINTD("export_png_preview_common");
   glview.save(output);
   return true;
@@ -126,8 +131,17 @@ bool export_png(const OffscreenView& glview, std::ostream& output)
 
 #else // NULLGL
 
-bool export_png(const std::shared_ptr<const Geometry>& root_geom, const ViewOptions& options, Camera& camera, std::ostream& output) { return false; }
-std::unique_ptr<OffscreenView> prepare_preview(Tree& tree, const ViewOptions& options, Camera& camera) { return nullptr; }
-bool export_png(const OffscreenView& glview, std::ostream& output) { return false; }
+bool export_png(const std::shared_ptr<const Geometry> &root_geom,
+                const ViewOptions &options, Camera &camera,
+                std::ostream &output) {
+  return false;
+}
+std::unique_ptr<OffscreenView>
+prepare_preview(Tree &tree, const ViewOptions &options, Camera &camera) {
+  return nullptr;
+}
+bool export_png(const OffscreenView &glview, std::ostream &output) {
+  return false;
+}
 
 #endif // NULLGL
diff --git a/src/io/export_pov.cc b/src/io/export_pov.cc
index 176a9e661..aef1f4862 100644
--- a/src/io/export_pov.cc
+++ b/src/io/export_pov.cc
@@ -36,9 +36,8 @@
 #include "geometry/PolySetUtils.h"
 #include "geometry/linalg.h"
 
-
-void export_pov(const std::shared_ptr<const Geometry>& geom, std::ostream& output, const ExportInfo& exportInfo)
-{
+void export_pov(const std::shared_ptr<const Geometry> &geom,
+                std::ostream &output, const ExportInfo &exportInfo) {
   std::shared_ptr<const PolySet> ps = PolySetUtils::getGeometryAsPolySet(geom);
   if (Feature::ExperimentalPredictibleOutput.is_enabled()) {
     ps = createSortedPolySet(*ps);
@@ -50,22 +49,28 @@ void export_pov(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
 
   output << "#version 3.7;\n";
   output << "global_settings { assumed_gamma 1.0 }\n";
-  output << "#declare MATERIAL=finish { specular 0.5 roughness 0.001 reflection{0 0.63 fresnel} ambient 0 diffuse 0.6 conserve_energy }\n";
+  output
+      << "#declare MATERIAL=finish { specular 0.5 roughness 0.001 reflection{0 "
+         "0.63 fresnel} ambient 0 diffuse 0.6 conserve_energy }\n";
   output << "#declare MATERIAL_INT=interior{ior 1.32}\n";
 
   auto has_color = !ps->color_indices.empty();
 
-  for (size_t polygon_index = 0; polygon_index < ps->indices.size(); polygon_index++) {
-    const auto& polygon = ps->indices[polygon_index];
+  for (size_t polygon_index = 0; polygon_index < ps->indices.size();
+       polygon_index++) {
+    const auto &polygon = ps->indices[polygon_index];
     output << "polygon { " << polygon.size() + 1 << ", \n";
     for (size_t i = 0; i < polygon.size(); i++) {
-      if (i)output << ", ";
-      const auto& x = ps->vertices[polygon[i]].x();
-      const auto& y = ps->vertices[polygon[i]].y();
-      const auto& z = ps->vertices[polygon[i]].z();
+      if (i)
+        output << ", ";
+      const auto &x = ps->vertices[polygon[i]].x();
+      const auto &y = ps->vertices[polygon[i]].y();
+      const auto &z = ps->vertices[polygon[i]].z();
       output << "<" << x << ", " << y << ", " << z << ">";
     }
-    output << ", <" << ps->vertices[polygon[0]].x() << ", " << ps->vertices[polygon[0]].y() << ", " << ps->vertices[polygon[0]].z() << ">";
+    output << ", <" << ps->vertices[polygon[0]].x() << ", "
+           << ps->vertices[polygon[0]].y() << ", "
+           << ps->vertices[polygon[0]].z() << ">";
     float r = exportInfo.defaultColor.r();
     float g = exportInfo.defaultColor.g();
     float b = exportInfo.defaultColor.b();
@@ -81,36 +86,42 @@ void export_pov(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
       }
     }
     output << "\n";
-    output << "texture { pigment { color rgbf <" << r << ", " << g << ", " << b << ", " << f << "> } }\n";
+    output << "texture { pigment { color rgbf <" << r << ", " << g << ", " << b
+           << ", " << f << "> } }\n";
     output << "finish { MATERIAL } interior { MATERIAL_INT }\n";
     output << "}\n";
   }
 
   BoundingBox bbox = geom->getBoundingBox();
 
-  auto& min_x = bbox.min().x();
-  auto& min_y = bbox.min().y();
-  auto& min_z = bbox.min().z();
+  auto &min_x = bbox.min().x();
+  auto &min_y = bbox.min().y();
+  auto &min_z = bbox.min().z();
 
-  auto& max_x = bbox.max().x();
-  auto& max_y = bbox.max().y();
-  auto& max_z = bbox.max().z();
+  auto &max_x = bbox.max().x();
+  auto &max_y = bbox.max().y();
+  auto &max_z = bbox.max().z();
 
   const double dx = max_x - min_x;
   const double dy = max_y - min_y;
   const double dz = max_z - min_z;
 
   constexpr double move_away_factor = 2.;
-  const std::vector<double> lx { min_x - dx * move_away_factor, bbox.center().x(), max_x + dx * move_away_factor };
-  const std::vector<double> ly { min_y - dy * move_away_factor, bbox.center().y(), max_y + dy * move_away_factor };
-  const std::vector<double> lz { min_z - dz * move_away_factor, bbox.center().z(), max_z + dz * move_away_factor };
-
-  constexpr float brightness = 0.2;  // 1.0 is way too bright
-
-  for (auto cur_lx: lx) {
-    for (auto cur_ly: ly) {
-      for (auto cur_lz: lz)
-        output << "light_source { <" << cur_lx << ", " << cur_ly << ", " << cur_lz << "> color rgb <" << brightness << ", " << brightness << ", " << brightness << "> }\n";
+  const std::vector<double> lx{min_x - dx * move_away_factor, bbox.center().x(),
+                               max_x + dx * move_away_factor};
+  const std::vector<double> ly{min_y - dy * move_away_factor, bbox.center().y(),
+                               max_y + dy * move_away_factor};
+  const std::vector<double> lz{min_z - dz * move_away_factor, bbox.center().z(),
+                               max_z + dz * move_away_factor};
+
+  constexpr float brightness = 0.2; // 1.0 is way too bright
+
+  for (auto cur_lx : lx) {
+    for (auto cur_ly : ly) {
+      for (auto cur_lz : lz)
+        output << "light_source { <" << cur_lx << ", " << cur_ly << ", "
+               << cur_lz << "> color rgb <" << brightness << ", " << brightness
+               << ", " << brightness << "> }\n";
     }
   }
 
@@ -122,18 +133,36 @@ void export_pov(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
     auto yaw = vpr.y();
     auto roll = vpr.z();
 
-    output << "camera { look_at <" << 0 << ", " << 0 << ", " << 0 << ">\n "
-      "location <" << 0 << ", " << 0 << ", " << exportInfo.camera->viewer_distance << ">\n "
-      "angle " << exportInfo.camera->fov << " up <0, 1, 0> right <1, 0, 0> sky <0, 1, 0> right -x*image_width/image_height\n"
-      "translate <" << vpt.x() << ", " << vpt.y() << ", " << vpt.z() << ">\n"
-      "rotate <" << pitch << ", " << yaw << " + clock * 3, " << roll << " + clock>\n"
-      "}\n";
+    output << "camera { look_at <" << 0 << ", " << 0 << ", " << 0
+           << ">\n "
+              "location <"
+           << 0 << ", " << 0 << ", " << exportInfo.camera->viewer_distance
+           << ">\n "
+              "angle "
+           << exportInfo.camera->fov
+           << " up <0, 1, 0> right <1, 0, 0> sky <0, 1, 0> right "
+              "-x*image_width/image_height\n"
+              "translate <"
+           << vpt.x() << ", " << vpt.y() << ", " << vpt.z()
+           << ">\n"
+              "rotate <"
+           << pitch << ", " << yaw << " + clock * 3, " << roll
+           << " + clock>\n"
+              "}\n";
   } else {
-    output << "camera { look_at <" << bbox.center().x() << ", " << bbox.center().y() << ", " << bbox.center().z() << "> "
-      "location <" << min_x + dx * move_away_factor << ", " << min_y - dy * move_away_factor << ", " << min_z + dz * move_away_factor << "> "
-      "up <0, 0, 1> right <1, 0, 0> sky <0, 0, 1> rotate <-55, clock * 3, clock + 25> right x*image_width/image_height }\n";
+    output << "camera { look_at <" << bbox.center().x() << ", "
+           << bbox.center().y() << ", " << bbox.center().z()
+           << "> "
+              "location <"
+           << min_x + dx * move_away_factor << ", "
+           << min_y - dy * move_away_factor << ", "
+           << min_z + dz * move_away_factor
+           << "> "
+              "up <0, 0, 1> right <1, 0, 0> sky <0, 0, 1> rotate <-55, clock * "
+              "3, clock + 25> right x*image_width/image_height }\n";
   }
 
   output << "#include \"rad_def.inc\"\n";
-  output << "global_settings { photons { count 20000 autostop 0 jitter .4 } radiosity { Rad_Settings(Radiosity_Normal, off, off) } }\n";
+  output << "global_settings { photons { count 20000 autostop 0 jitter .4 } "
+            "radiosity { Rad_Settings(Radiosity_Normal, off, off) } }\n";
 }
diff --git a/src/io/export_stl.cc b/src/io/export_stl.cc
index cda164f78..dd6dd7ba9 100644
--- a/src/io/export_stl.cc
+++ b/src/io/export_stl.cc
@@ -42,9 +42,9 @@
 #include <double-conversion/double-conversion.h>
 
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetUtils.h"
+#include "geometry/linalg.h"
 #include "utils/printutils.h"
 
 #ifdef ENABLE_MANIFOLD
@@ -67,12 +67,10 @@ namespace {
 #define DC_MAX_LEADING_ZEROES (5)
 #define DC_MAX_TRAILING_ZEROES (0)
 
-std::string toString(const Vector3d& v)
-{
+std::string toString(const Vector3d &v) {
   const double_conversion::DoubleToStringConverter dc(
-    DC_FLAGS, DC_INF, DC_NAN, DC_EXP,
-    DC_DECIMAL_LOW_EXP, DC_DECIMAL_HIGH_EXP, DC_MAX_LEADING_ZEROES, DC_MAX_TRAILING_ZEROES
-    );
+      DC_FLAGS, DC_INF, DC_NAN, DC_EXP, DC_DECIMAL_LOW_EXP, DC_DECIMAL_HIGH_EXP,
+      DC_MAX_LEADING_ZEROES, DC_MAX_TRAILING_ZEROES);
 
   char buffer[DC_BUFFER_SIZE];
 
@@ -88,18 +86,19 @@ std::string toString(const Vector3d& v)
 }
 
 int32_t flipEndianness(int32_t x) {
-  return
-    ((x << 24) & 0xff000000) | ((x >> 24) & 0xff) |
-    ((x << 8) & 0xff0000) | ((x >> 8) & 0xff00);
+  return ((x << 24) & 0xff000000) | ((x >> 24) & 0xff) | ((x << 8) & 0xff0000) |
+         ((x >> 8) & 0xff00);
 }
 
 template <size_t N>
-void write_floats(std::ostream& output, const std::array<float, N>& data) {
+void write_floats(std::ostream &output, const std::array<float, N> &data) {
   static constexpr uint16_t test = 0x0001;
-  static const bool isLittleEndian = *reinterpret_cast<const char *>(&test) == 1;
+  static const bool isLittleEndian =
+      *reinterpret_cast<const char *>(&test) == 1;
 
   if (isLittleEndian) {
-    output.write(reinterpret_cast<char *>(const_cast<float *>(&data[0])), N * sizeof(float));
+    output.write(reinterpret_cast<char *>(const_cast<float *>(&data[0])),
+                 N * sizeof(float));
   } else {
     std::array<float, N> copy(data);
 
@@ -112,9 +111,8 @@ void write_floats(std::ostream& output, const std::array<float, N>& data) {
   }
 }
 
-
-uint64_t append_stl(const std::shared_ptr<const PolySet>& polyset, std::ostream& output, bool binary)
-{
+uint64_t append_stl(const std::shared_ptr<const PolySet> &polyset,
+                    std::ostream &output, bool binary) {
   static_assert(sizeof(float) == 4, "Need 32 bit float");
 
   std::shared_ptr<const PolySet> ps = polyset;
@@ -131,19 +129,18 @@ uint64_t append_stl(const std::shared_ptr<const PolySet>& polyset, std::ostream&
   std::vector<std::string> vertexStrings;
   if (!binary) {
     vertexStrings.resize(ps->vertices.size());
-    std::transform(ps->vertices.begin(), ps->vertices.end(), vertexStrings.begin(),
-                   [](const auto& p) {
-        return toString(p);
-      });
+    std::transform(ps->vertices.begin(), ps->vertices.end(),
+                   vertexStrings.begin(),
+                   [](const auto &p) { return toString(p); });
   }
 
   // Used for binary mode only
   std::array<float, 4lu * 3> coords;
 
-  for (const auto& t : ps->indices) {
-    const auto& p0 = ps->vertices[t[0]];
-    const auto& p1 = ps->vertices[t[1]];
-    const auto& p2 = ps->vertices[t[2]];
+  for (const auto &t : ps->indices) {
+    const auto &p0 = ps->vertices[t[0]];
+    const auto &p1 = ps->vertices[t[1]];
+    const auto &p2 = ps->vertices[t[2]];
 
     // Tessellation already eliminated these cases.
     assert(p0 != p1 && p0 != p2 && p1 != p2);
@@ -155,10 +152,10 @@ uint64_t append_stl(const std::shared_ptr<const PolySet>& polyset, std::ostream&
 
     if (binary) {
       auto coords_offset = 0;
-      auto addCoords = [&](const auto& v) {
-          for (auto i : {0, 1, 2})
-            coords[coords_offset++] = v[i];
-        };
+      auto addCoords = [&](const auto &v) {
+        for (auto i : {0, 1, 2})
+          coords[coords_offset++] = v[i];
+      };
       addCoords(normal);
       addCoords(p0);
       addCoords(p1);
@@ -168,9 +165,9 @@ uint64_t append_stl(const std::shared_ptr<const PolySet>& polyset, std::ostream&
       char attrib[2] = {0, 0};
       output.write(attrib, 2);
     } else {
-      const auto& s0 = vertexStrings[t[0]];
-      const auto& s1 = vertexStrings[t[1]];
-      const auto& s2 = vertexStrings[t[2]];
+      const auto &s0 = vertexStrings[t[0]];
+      const auto &s1 = vertexStrings[t[1]];
+      const auto &s2 = vertexStrings[t[2]];
 
       // Since the points are different, the precision we use to
       // format them to string should guarantee the strings are
@@ -197,15 +194,16 @@ uint64_t append_stl(const std::shared_ptr<const PolySet>& polyset, std::ostream&
     Saves the current 3D CGAL Nef polyhedron as STL to the given file.
     The file must be open.
  */
-uint64_t append_stl(const CGALNefGeometry& root_N, std::ostream& output,
-                    bool binary)
-{
+uint64_t append_stl(const CGALNefGeometry &root_N, std::ostream &output,
+                    bool binary) {
   uint64_t triangle_count = 0;
   if (!root_N.p3->is_simple()) {
-    LOG(message_group::Export_Warning, "Exported object may not be a valid 2-manifold and may need repair");
+    LOG(message_group::Export_Warning,
+        "Exported object may not be a valid 2-manifold and may need repair");
   }
 
-  if (const std::shared_ptr<PolySet> ps = CGALUtils::createPolySetFromNefPolyhedron3(*(root_N.p3))) {
+  if (const std::shared_ptr<PolySet> ps =
+          CGALUtils::createPolySetFromNefPolyhedron3(*(root_N.p3))) {
     triangle_count += append_stl(ps, output, binary);
   } else {
     LOG(message_group::Export_Error, "Nef->PolySet failed");
@@ -214,19 +212,19 @@ uint64_t append_stl(const CGALNefGeometry& root_N, std::ostream& output,
   return triangle_count;
 }
 
-#endif  // ENABLE_CGAL
+#endif // ENABLE_CGAL
 
 #ifdef ENABLE_MANIFOLD
 /*!
    Saves the current 3D Manifold geometry as STL to the given file.
    The file must be open.
  */
-uint64_t append_stl(const ManifoldGeometry& mani, std::ostream& output,
-                    bool binary)
-{
+uint64_t append_stl(const ManifoldGeometry &mani, std::ostream &output,
+                    bool binary) {
   uint64_t triangle_count = 0;
   if (!mani.isManifold()) {
-    LOG(message_group::Export_Warning, "Exported object may not be a valid 2-manifold and may need repair");
+    LOG(message_group::Export_Warning,
+        "Exported object may not be a valid 2-manifold and may need repair");
   }
 
   const auto ps = mani.toPolySet();
@@ -238,30 +236,32 @@ uint64_t append_stl(const ManifoldGeometry& mani, std::ostream& output,
 
   return triangle_count;
 }
-#endif  // ENABLE_MANIFOLD
-
+#endif // ENABLE_MANIFOLD
 
-uint64_t append_stl(const std::shared_ptr<const Geometry>& geom, std::ostream& output,
-                    bool binary)
-{
+uint64_t append_stl(const std::shared_ptr<const Geometry> &geom,
+                    std::ostream &output, bool binary) {
   uint64_t triangle_count = 0;
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
-    for (const Geometry::GeometryItem& item : geomlist->getChildren()) {
+  if (const auto geomlist =
+          std::dynamic_pointer_cast<const GeometryList>(geom)) {
+    for (const Geometry::GeometryItem &item : geomlist->getChildren()) {
       triangle_count += append_stl(item.second, output, binary);
     }
   } else if (const auto ps = std::dynamic_pointer_cast<const PolySet>(geom)) {
     triangle_count += append_stl(ps, output, binary);
 #ifdef ENABLE_CGAL
-  } else if (const auto N = std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
+  } else if (const auto N =
+                 std::dynamic_pointer_cast<const CGALNefGeometry>(geom)) {
     triangle_count += append_stl(*N, output, binary);
 #endif
 #ifdef ENABLE_MANIFOLD
-  } else if (const auto mani = std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
+  } else if (const auto mani =
+                 std::dynamic_pointer_cast<const ManifoldGeometry>(geom)) {
     triangle_count += append_stl(*mani, output, binary);
 #endif
-  } else if (std::dynamic_pointer_cast<const Polygon2d>(geom)) { //NOLINT(bugprone-branch-clone)
+  } else if (std::dynamic_pointer_cast<const Polygon2d>(
+                 geom)) { // NOLINT(bugprone-branch-clone)
     assert(false && "Unsupported file format");
-  } else { //NOLINT(bugprone-branch-clone)
+  } else { // NOLINT(bugprone-branch-clone)
     assert(false && "Not implemented");
   }
 
@@ -270,9 +270,8 @@ uint64_t append_stl(const std::shared_ptr<const Geometry>& geom, std::ostream& o
 
 } // namespace
 
-void export_stl(const std::shared_ptr<const Geometry>& geom, std::ostream& output,
-                bool binary)
-{
+void export_stl(const std::shared_ptr<const Geometry> &geom,
+                std::ostream &output, bool binary) {
   // FIXME: In lazy union mode, should we export multiple solids?
   if (binary) {
     std::ostringstream buffer; // Using a memory buffer
@@ -288,15 +287,16 @@ void export_stl(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
     triangle_count = append_stl(geom, buffer, binary);
 
     if (triangle_count > 4294967295) {
-      LOG(message_group::Export_Error, "Triangle count exceeded 4294967295, so the STL file is not valid");
+      LOG(message_group::Export_Error,
+          "Triangle count exceeded 4294967295, so the STL file is not valid");
     }
 
     // Updating the triangle count in the buffer
     char triangle_count_bytes[4] = {
-      static_cast<char>(triangle_count & 0xff),
-      static_cast<char>((triangle_count >> 8) & 0xff),
-      static_cast<char>((triangle_count >> 16) & 0xff),
-      static_cast<char>((triangle_count >> 24) & 0xff)};
+        static_cast<char>(triangle_count & 0xff),
+        static_cast<char>((triangle_count >> 8) & 0xff),
+        static_cast<char>((triangle_count >> 16) & 0xff),
+        static_cast<char>((triangle_count >> 24) & 0xff)};
     buffer.seekp(80, std::ios_base::beg);
     buffer.write(triangle_count_bytes, 4);
 
diff --git a/src/io/export_svg.cc b/src/io/export_svg.cc
index f4ec111cf..1f18b686e 100644
--- a/src/io/export_svg.cc
+++ b/src/io/export_svg.cc
@@ -32,22 +32,21 @@
 #include <ostream>
 
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
-#include "geometry/Polygon2d.h"
 #include "geometry/PolySet.h"
+#include "geometry/Polygon2d.h"
+#include "geometry/linalg.h"
 
-static void append_svg(const Polygon2d& poly, std::ostream& output)
-{
+static void append_svg(const Polygon2d &poly, std::ostream &output) {
   output << "<path d=\"\n";
-  for (const auto& o : poly.outlines()) {
+  for (const auto &o : poly.outlines()) {
     if (o.vertices.empty()) {
       continue;
     }
 
-    const Eigen::Vector2d& p0 = o.vertices[0];
+    const Eigen::Vector2d &p0 = o.vertices[0];
     output << "M " << p0.x() << "," << -p0.y();
     for (unsigned int idx = 1; idx < o.vertices.size(); ++idx) {
-      const Eigen::Vector2d& p = o.vertices[idx];
+      const Eigen::Vector2d &p = o.vertices[idx];
       output << " L " << p.x() << "," << -p.y();
       if ((idx % 6) == 5) {
         output << "\n";
@@ -56,26 +55,28 @@ static void append_svg(const Polygon2d& poly, std::ostream& output)
     output << " z\n";
   }
   output << "\" stroke=\"black\" fill=\"lightgray\" stroke-width=\"0.5\"/>\n";
-
 }
 
-static void append_svg(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
-  if (const auto geomlist = std::dynamic_pointer_cast<const GeometryList>(geom)) {
-    for (const auto& item : geomlist->getChildren()) {
+static void append_svg(const std::shared_ptr<const Geometry> &geom,
+                       std::ostream &output) {
+  if (const auto geomlist =
+          std::dynamic_pointer_cast<const GeometryList>(geom)) {
+    for (const auto &item : geomlist->getChildren()) {
       append_svg(item.second, output);
     }
-  } else if (const auto poly = std::dynamic_pointer_cast<const Polygon2d>(geom)) {
+  } else if (const auto poly =
+                 std::dynamic_pointer_cast<const Polygon2d>(geom)) {
     append_svg(*poly, output);
-  } else if (std::dynamic_pointer_cast<const PolySet>(geom)) { // NOLINT(bugprone-branch-clone)
+  } else if (std::dynamic_pointer_cast<const PolySet>(
+                 geom)) { // NOLINT(bugprone-branch-clone)
     assert(false && "Unsupported file format");
   } else { // NOLINT(bugprone-branch-clone)
     assert(false && "Export as SVG for this geometry type is not supported");
   }
 }
 
-void export_svg(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
+void export_svg(const std::shared_ptr<const Geometry> &geom,
+                std::ostream &output) {
   setlocale(LC_NUMERIC, "C"); // Ensure radix is . (not ,) in output
 
   BoundingBox bbox = geom->getBoundingBox();
@@ -86,13 +87,14 @@ void export_svg(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
   const int width = maxx - minx;
   const int height = maxy - miny;
 
-  output
-    << "<?xml version=\"1.0\" standalone=\"no\"?>\n"
-    << "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n"
-    << "<svg width=\"" << width << "mm\" height=\"" << height
-    << "mm\" viewBox=\"" << minx << " " << miny << " " << width << " " << height
-    << "\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">\n"
-    << "<title>OpenSCAD Model</title>\n";
+  output << "<?xml version=\"1.0\" standalone=\"no\"?>\n"
+         << "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" "
+            "\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n"
+         << "<svg width=\"" << width << "mm\" height=\"" << height
+         << "mm\" viewBox=\"" << minx << " " << miny << " " << width << " "
+         << height
+         << "\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">\n"
+         << "<title>OpenSCAD Model</title>\n";
 
   append_svg(geom, output);
 
diff --git a/src/io/export_wrl.cc b/src/io/export_wrl.cc
index 2e747340c..2abdac07f 100644
--- a/src/io/export_wrl.cc
+++ b/src/io/export_wrl.cc
@@ -25,16 +25,16 @@
 
 #include "io/export.h"
 
-#include <ostream>
-#include <memory>
 #include <cstddef>
+#include <memory>
+#include <ostream>
 
 #include "geometry/Geometry.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetUtils.h"
 
-void export_wrl(const std::shared_ptr<const Geometry>& geom, std::ostream& output)
-{
+void export_wrl(const std::shared_ptr<const Geometry> &geom,
+                std::ostream &output) {
   // FIXME: In lazy union mode, should we export multiple IndexedFaceSets?
   auto ps = PolySetUtils::getGeometryAsPolySet(geom);
   if (Feature::ExperimentalPredictibleOutput.is_enabled()) {
@@ -57,7 +57,7 @@ void export_wrl(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
   output << "creaseAngle 0.5\n\n";
 
   output << "coord Coordinate { point [\n";
-  const auto& v = ps->vertices;
+  const auto &v = ps->vertices;
   const size_t numverts = v.size();
   for (size_t i = 0; i < numverts; ++i) {
     output << v[i][0] << " " << v[i][1] << " " << v[i][2];
@@ -71,7 +71,7 @@ void export_wrl(const std::shared_ptr<const Geometry>& geom, std::ostream& outpu
   output << "coordIndex [\n";
   const size_t numindices = ps->indices.size();
   for (size_t i = 0; i < numindices; ++i) {
-    const auto& poly = ps->indices[i];
+    const auto &poly = ps->indices[i];
     for (size_t j = 0; j < poly.size(); j++) {
       output << poly[j];
       output << ",";
diff --git a/src/io/fileutils.cc b/src/io/fileutils.cc
index 97fc25b03..79ef7f19d 100644
--- a/src/io/fileutils.cc
+++ b/src/io/fileutils.cc
@@ -14,19 +14,23 @@ namespace fs = std::filesystem;
    If the file isn't found in the given path, the fallback path will be
    used to be backwards compatible with <= 2013.01 (see issue #217).
  */
-std::string lookup_file(const std::string& filename,
-                        const std::string& path, const std::string& fallbackpath)
-{
+std::string lookup_file(const std::string &filename, const std::string &path,
+                        const std::string &fallbackpath) {
   std::string resultfile;
   if (!filename.empty() && !fs::path(filename).is_absolute()) {
     fs::path absfile;
-    if (!path.empty()) absfile = fs::absolute(fs::path(path) / filename);
+    if (!path.empty())
+      absfile = fs::absolute(fs::path(path) / filename);
     fs::path absfile_fallback;
-    if (!fallbackpath.empty()) absfile_fallback = fs::absolute(fs::path(fallbackpath) / filename);
+    if (!fallbackpath.empty())
+      absfile_fallback = fs::absolute(fs::path(fallbackpath) / filename);
 
     if (!fs::exists(absfile) && fs::exists(absfile_fallback)) {
       resultfile = absfile_fallback.string();
-      LOG(message_group::Deprecated, "Imported file (%1$s) found in document root instead of relative to the importing module. This behavior is deprecated", std::string(filename));
+      LOG(message_group::Deprecated,
+          "Imported file (%1$s) found in document root instead of relative to "
+          "the importing module. This behavior is deprecated",
+          std::string(filename));
     } else {
       resultfile = absfile.string();
     }
@@ -36,9 +40,9 @@ std::string lookup_file(const std::string& filename,
   return resultfile;
 }
 
-fs::path fs_uncomplete(fs::path const& p, fs::path const& base)
-{
-  if (p == fs::path{}) return p;
+fs::path fs_uncomplete(fs::path const &p, fs::path const &base) {
+  if (p == fs::path{})
+    return p;
 #ifndef __EMSCRIPTEN__
   return fs::relative(p, base == fs::path{} ? fs::path{"."} : base);
 #else
@@ -46,12 +50,13 @@ fs::path fs_uncomplete(fs::path const& p, fs::path const& base)
 #endif
 }
 
-int64_t fs_timestamp(fs::path const& path) {
+int64_t fs_timestamp(fs::path const &path) {
   int64_t seconds = 0;
   if (fs::exists(path)) {
     const auto t = fs::last_write_time(path);
     const auto duration = t.time_since_epoch();
-    seconds = std::chrono::duration_cast<std::chrono::seconds>(duration).count();
+    seconds =
+        std::chrono::duration_cast<std::chrono::seconds>(duration).count();
   }
   return seconds;
 }
\ No newline at end of file
diff --git a/src/io/fileutils.h b/src/io/fileutils.h
index 1419fd69c..af1231594 100644
--- a/src/io/fileutils.h
+++ b/src/io/fileutils.h
@@ -6,9 +6,8 @@
 
 namespace fs = std::filesystem;
 
-std::string lookup_file(const std::string& filename,
-                        const std::string& path, const std::string& fallbackpath);
+std::string lookup_file(const std::string &filename, const std::string &path,
+                        const std::string &fallbackpath);
 
-
-fs::path fs_uncomplete(fs::path const& p, fs::path const& base);
-int64_t fs_timestamp(fs::path const& path);
\ No newline at end of file
+fs::path fs_uncomplete(fs::path const &p, fs::path const &base);
+int64_t fs_timestamp(fs::path const &path);
\ No newline at end of file
diff --git a/src/io/imageutils-lodepng.cc b/src/io/imageutils-lodepng.cc
index 61803dce2..c0bb58bb0 100644
--- a/src/io/imageutils-lodepng.cc
+++ b/src/io/imageutils-lodepng.cc
@@ -5,8 +5,8 @@
 
 #include "lodepng/lodepng.h"
 
-bool write_png(std::ostream& output, unsigned char *pixels, int width, int height)
-{
+bool write_png(std::ostream &output, unsigned char *pixels, int width,
+               int height) {
   std::vector<unsigned char> dataout;
   lodepng::State state;
   state.encoder.auto_convert = false;
@@ -14,8 +14,10 @@ bool write_png(std::ostream& output, unsigned char *pixels, int width, int heigh
   state.info_png.color.colortype = LCT_RGB;
   state.info_png.color.bitdepth = 8;
   const auto err = lodepng::encode(dataout, pixels, width, height, state);
-  if (err) return false;
+  if (err)
+    return false;
   output.write(reinterpret_cast<const char *>(&dataout[0]), dataout.size());
-  if (output.bad() ) std::cerr << "Error writing to ostream\n";
+  if (output.bad())
+    std::cerr << "Error writing to ostream\n";
   return output.good();
 }
diff --git a/src/io/imageutils-macosx.cc b/src/io/imageutils-macosx.cc
index daaa78f19..1f0fb1e10 100644
--- a/src/io/imageutils-macosx.cc
+++ b/src/io/imageutils-macosx.cc
@@ -1,15 +1,15 @@
 #include "io/imageutils.h"
 
-#include <iostream>
 #include <cassert>
 #include <cstddef>
+#include <iostream>
 
 #include <ApplicationServices/ApplicationServices.h>
 
 static CGDataConsumerCallbacks dc_callbacks;
 
-static size_t write_bytes_to_ostream(void *info, const void *buffer, size_t count)
-{
+static size_t write_bytes_to_ostream(void *info, const void *buffer,
+                                     size_t count) {
   assert(info && buffer);
   auto *output = (std::ostream *)info;
   const size_t startpos = output->tellp();
@@ -17,30 +17,32 @@ static size_t write_bytes_to_ostream(void *info, const void *buffer, size_t coun
   try {
     output->write((const char *)buffer, count);
     endpos = output->tellp();
-  } catch (const std::ios_base::failure& e) {
+  } catch (const std::ios_base::failure &e) {
     std::cerr << "Error writing to ostream:" << e.what() << "\n";
   }
   return (endpos - startpos);
 }
 
-static CGDataConsumerRef CGDataConsumerCreateWithOstream(std::ostream& output)
-{
+static CGDataConsumerRef CGDataConsumerCreateWithOstream(std::ostream &output) {
   dc_callbacks.putBytes = write_bytes_to_ostream;
-  dc_callbacks.releaseConsumer = nullptr; // ostream closed by caller of write_png
-  CGDataConsumerRef dc = CGDataConsumerCreate( (void *)(&output), &dc_callbacks);
+  dc_callbacks.releaseConsumer =
+      nullptr; // ostream closed by caller of write_png
+  CGDataConsumerRef dc = CGDataConsumerCreate((void *)(&output), &dc_callbacks);
   return dc;
 }
 
-bool write_png(std::ostream& output, unsigned char *pixels, int width, int height)
-{
+bool write_png(std::ostream &output, unsigned char *pixels, int width,
+               int height) {
   const size_t rowBytes = static_cast<size_t>(width) * 4;
-//  CGColorSpaceRef colorSpace = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);
+  //  CGColorSpaceRef colorSpace =
+  //  CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);
   CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
-  const CGBitmapInfo bitmapInfo = kCGImageAlphaNoneSkipLast | kCGBitmapByteOrder32Big; // BGRA
+  const CGBitmapInfo bitmapInfo =
+      kCGImageAlphaNoneSkipLast | kCGBitmapByteOrder32Big; // BGRA
   const int bitsPerComponent = 8;
-  CGContextRef contextRef = CGBitmapContextCreate(pixels, width, height,
-                                                  bitsPerComponent, rowBytes,
-                                                  colorSpace, bitmapInfo);
+  CGContextRef contextRef =
+      CGBitmapContextCreate(pixels, width, height, bitsPerComponent, rowBytes,
+                            colorSpace, bitmapInfo);
   if (!contextRef) {
     std::cerr << "Unable to create CGContextRef.";
     CGColorSpaceRelease(colorSpace);
@@ -57,12 +59,11 @@ bool write_png(std::ostream& output, unsigned char *pixels, int width, int heigh
 
   CGDataConsumerRef dataconsumer = CGDataConsumerCreateWithOstream(output);
   /*
-     CFStringRef fname = CFStringCreateWithCString(kCFAllocatorDefault, filename, kCFStringEncodingUTF8);
-     CFURLRef fileURL = CFURLCreateWithFileSystemPath(kCFAllocatorDefault,
-                                                   fname, kCFURLPOSIXPathStyle, false);
-     if (!fileURL) {
-     std::cerr << "Unable to create file URL ref.";
-     return false;
+     CFStringRef fname = CFStringCreateWithCString(kCFAllocatorDefault,
+     filename, kCFStringEncodingUTF8); CFURLRef fileURL =
+     CFURLCreateWithFileSystemPath(kCFAllocatorDefault, fname,
+     kCFURLPOSIXPathStyle, false); if (!fileURL) { std::cerr << "Unable to
+     create file URL ref."; return false;
      }
 
      CGDataConsumerRef dataconsumer = CGDataConsumerCreateWithURL(fileURL);
@@ -72,10 +73,8 @@ bool write_png(std::ostream& output, unsigned char *pixels, int width, int heigh
   CFMutableDictionaryRef fileDict = nullptr;
   CFStringRef fileUTType = kUTTypePNG;
   // Create an image destination opaque reference for authoring an image file
-  CGImageDestinationRef imageDest = CGImageDestinationCreateWithDataConsumer(dataconsumer,
-                                                                             fileUTType,
-                                                                             fileImageIndex,
-                                                                             fileDict);
+  CGImageDestinationRef imageDest = CGImageDestinationCreateWithDataConsumer(
+      dataconsumer, fileUTType, fileImageIndex, fileDict);
   if (!imageDest) {
     std::cerr << "Unable to create CGImageDestinationRef.";
     CFRelease(dataconsumer);
@@ -86,18 +85,16 @@ bool write_png(std::ostream& output, unsigned char *pixels, int width, int heigh
   }
 
   const CFIndex capacity = 1;
-  CFMutableDictionaryRef imageProps =
-    CFDictionaryCreateMutable(kCFAllocatorDefault,
-                              capacity,
-                              &kCFTypeDictionaryKeyCallBacks,
-                              &kCFTypeDictionaryValueCallBacks);
+  CFMutableDictionaryRef imageProps = CFDictionaryCreateMutable(
+      kCFAllocatorDefault, capacity, &kCFTypeDictionaryKeyCallBacks,
+      &kCFTypeDictionaryValueCallBacks);
   CGImageDestinationAddImage(imageDest, imageRef, imageProps);
   CGImageDestinationFinalize(imageDest);
 
   CFRelease(imageDest);
   CFRelease(dataconsumer);
-  //CFRelease(fileURL);
-  //CFRelease(fname);
+  // CFRelease(fileURL);
+  // CFRelease(fname);
   CFRelease(imageProps);
   CGImageRelease(imageRef);
   CFRelease(contextRef);
diff --git a/src/io/imageutils.cc b/src/io/imageutils.cc
index abcd320b0..8df235420 100644
--- a/src/io/imageutils.cc
+++ b/src/io/imageutils.cc
@@ -1,12 +1,12 @@
 #include "io/imageutils.h"
 
-#include <iostream>
 #include <cassert>
 #include <cstring>
 #include <fstream>
+#include <iostream>
 
-void flip_image(const unsigned char *src, unsigned char *dst, size_t pixelsize, size_t width, size_t height)
-{
+void flip_image(const unsigned char *src, unsigned char *dst, size_t pixelsize,
+                size_t width, size_t height) {
   assert(src && dst);
   auto rowBytes = pixelsize * width;
   for (auto i = 0ul; i < height; ++i) {
@@ -14,8 +14,8 @@ void flip_image(const unsigned char *src, unsigned char *dst, size_t pixelsize,
   }
 }
 
-bool write_png(const char *filename, unsigned char *pixels, int width, int height)
-{
+bool write_png(const char *filename, unsigned char *pixels, int width,
+               int height) {
   assert(filename && pixels);
   std::ofstream fstream(filename, std::ios::binary);
   if (fstream.is_open()) {
diff --git a/src/io/imageutils.h b/src/io/imageutils.h
index b799e6441..0a027323c 100644
--- a/src/io/imageutils.h
+++ b/src/io/imageutils.h
@@ -3,6 +3,9 @@
 #include <cstdlib>
 #include <iostream>
 
-bool write_png(const char *filename, unsigned char *pixels, int width, int height);
-bool write_png(std::ostream& output, unsigned char *pixels, int width, int height);
-void flip_image(const unsigned char *src, unsigned char *dst, size_t pixelsize, size_t width, size_t height);
+bool write_png(const char *filename, unsigned char *pixels, int width,
+               int height);
+bool write_png(std::ostream &output, unsigned char *pixels, int width,
+               int height);
+void flip_image(const unsigned char *src, unsigned char *dst, size_t pixelsize,
+                size_t width, size_t height);
diff --git a/src/io/import.h b/src/io/import.h
index 6e7f823bb..1ffd1db00 100644
--- a/src/io/import.h
+++ b/src/io/import.h
@@ -7,19 +7,27 @@
 
 #include "core/AST.h"
 
-std::unique_ptr<class PolySet> import_stl(const std::string& filename, const Location& loc);
-std::unique_ptr<class PolySet> import_obj(const std::string& filename, const Location& loc);
-std::unique_ptr<class PolySet> import_off(const std::string& filename, const Location& loc);
-std::unique_ptr<class PolySet> import_amf(const std::string&, const Location& loc);
-std::unique_ptr<class PolySet> import_3mf(const std::string&, const Location& loc);
+std::unique_ptr<class PolySet> import_stl(const std::string &filename,
+                                          const Location &loc);
+std::unique_ptr<class PolySet> import_obj(const std::string &filename,
+                                          const Location &loc);
+std::unique_ptr<class PolySet> import_off(const std::string &filename,
+                                          const Location &loc);
+std::unique_ptr<class PolySet> import_amf(const std::string &,
+                                          const Location &loc);
+std::unique_ptr<class PolySet> import_3mf(const std::string &,
+                                          const Location &loc);
 
-std::unique_ptr<class Polygon2d> import_svg(double fn, double fs, double fa,
-                                            const std::string& filename,
-                                            const boost::optional<std::string>& id, const boost::optional<std::string>& layer,
-                                            const double dpi, const bool center, const Location& loc);
+std::unique_ptr<class Polygon2d>
+import_svg(double fn, double fs, double fa, const std::string &filename,
+           const boost::optional<std::string> &id,
+           const boost::optional<std::string> &layer, const double dpi,
+           const bool center, const Location &loc);
 
 #ifdef ENABLE_CGAL
-std::unique_ptr<class CGALNefGeometry> import_nef3(const std::string& filename, const Location& loc);
+std::unique_ptr<class CGALNefGeometry> import_nef3(const std::string &filename,
+                                                   const Location &loc);
 #endif
 
-class Value import_json(const std::string& filename, class EvaluationSession *session, const Location& loc);
+class Value import_json(const std::string &filename,
+                        class EvaluationSession *session, const Location &loc);
diff --git a/src/io/import_3mf_dummy.cc b/src/io/import_3mf_dummy.cc
index fba8fc1fc..2a0113f05 100644
--- a/src/io/import_3mf_dummy.cc
+++ b/src/io/import_3mf_dummy.cc
@@ -24,20 +24,21 @@
  *
  */
 
-#include <memory>
-#include <string>
-#include "io/import.h"
 #include "core/AST.h"
-#include "utils/printutils.h"
 #include "geometry/PolySet.h"
+#include "io/import.h"
 #include "io/lib3mf_utils.h"
+#include "utils/printutils.h"
+#include <memory>
+#include <string>
 
-std::string get_lib3mf_version() {
-  return "(not enabled)";
-}
+std::string get_lib3mf_version() { return "(not enabled)"; }
 
-std::unique_ptr<class PolySet> import_3mf(const std::string&, const Location& loc)
-{
-  LOG(message_group::Warning, "Import from 3MF format was not enabled when building the application, import() at line %1$d", loc.firstLine());
+std::unique_ptr<class PolySet> import_3mf(const std::string &,
+                                          const Location &loc) {
+  LOG(message_group::Warning,
+      "Import from 3MF format was not enabled when building the application, "
+      "import() at line %1$d",
+      loc.firstLine());
   return PolySet::createEmpty();
 }
diff --git a/src/io/import_3mf_v1.cc b/src/io/import_3mf_v1.cc
index 9fe76d045..6ba405a8a 100644
--- a/src/io/import_3mf_v1.cc
+++ b/src/io/import_3mf_v1.cc
@@ -25,26 +25,26 @@
  */
 #include "io/import.h"
 
+#include <algorithm>
 #include <cstddef>
-#include <functional>
 #include <cstdint>
+#include <functional>
+#include <iomanip>
 #include <memory>
 #include <string>
-#include <iomanip>
-#include <algorithm>
 
 #include <Model/COM/NMR_DLLInterfaces.h>
 
+#include "core/AST.h"
+#include "geometry/Geometry.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetBuilder.h"
 #include "geometry/PolySetUtils.h"
-#include "geometry/Geometry.h"
 #include "geometry/linalg.h"
-#include "utils/printutils.h"
-#include "utils/version_helper.h"
-#include "core/AST.h"
 #include "glview/RenderSettings.h"
 #include "io/lib3mf_utils.h"
+#include "utils/printutils.h"
+#include "utils/version_helper.h"
 
 #ifdef ENABLE_CGAL
 #include "geometry/cgal/cgalutils.h"
@@ -60,21 +60,21 @@ std::string get_lib3mf_version() {
   DWORD major, minor, micro;
   NMR::lib3mf_getinterfaceversion(&major, &minor, &micro);
 
-  const OpenSCAD::library_version_number header_version{NMR_APIVERSION_INTERFACE_MAJOR, NMR_APIVERSION_INTERFACE_MINOR, NMR_APIVERSION_INTERFACE_MICRO};
+  const OpenSCAD::library_version_number header_version{
+      NMR_APIVERSION_INTERFACE_MAJOR, NMR_APIVERSION_INTERFACE_MINOR,
+      NMR_APIVERSION_INTERFACE_MICRO};
   const OpenSCAD::library_version_number runtime_version{major, minor, micro};
   return OpenSCAD::get_version_string(header_version, runtime_version);
 }
 
 namespace {
 
-struct MeshObject
-{
+struct MeshObject {
   PLib3MFModelObjectResource *obj;
   Matrix4d transform;
 };
 
-struct ModelMetadata
-{
+struct ModelMetadata {
   std::string title;
   std::string designer;
   std::string description;
@@ -90,44 +90,50 @@ using MeshObjectList = std::list<std::unique_ptr<MeshObject>>;
 
 // lib3mf_propertyhandler_getcolor states:
 // (#00000000) means no property or a different kind of property!
-Color4f get_color(const MODELMESHCOLOR_SRGB& color)
-{
-  if (color.m_Red == 0 && color.m_Green == 0 && color.m_Blue == 0 && color.m_Alpha == 0) {
+Color4f get_color(const MODELMESHCOLOR_SRGB &color) {
+  if (color.m_Red == 0 && color.m_Green == 0 && color.m_Blue == 0 &&
+      color.m_Alpha == 0) {
     return {}; // invalid color
   }
   Color4f c{color.m_Red, color.m_Green, color.m_Blue, color.m_Alpha};
   return c;
 }
 
-Color4f get_color(const MODELMESH_TRIANGLECOLOR_SRGB& color, int idx)
-{
+Color4f get_color(const MODELMESH_TRIANGLECOLOR_SRGB &color, int idx) {
   return get_color(color.m_Colors[idx]);
 }
 
-Matrix4d get_matrix(MODELTRANSFORM& transform)
-{
+Matrix4d get_matrix(MODELTRANSFORM &transform) {
   Matrix4d tm;
-  tm << transform.m_fFields[0][0], transform.m_fFields[0][1], transform.m_fFields[0][2], transform.m_fFields[0][3],
-    transform.m_fFields[1][0], transform.m_fFields[1][1], transform.m_fFields[1][2], transform.m_fFields[1][3],
-    transform.m_fFields[2][0], transform.m_fFields[2][1], transform.m_fFields[2][2], transform.m_fFields[2][3],
-    0,                         0,                         0,                         1;
+  tm << transform.m_fFields[0][0], transform.m_fFields[0][1],
+      transform.m_fFields[0][2], transform.m_fFields[0][3],
+      transform.m_fFields[1][0], transform.m_fFields[1][1],
+      transform.m_fFields[1][2], transform.m_fFields[1][3],
+      transform.m_fFields[2][0], transform.m_fFields[2][1],
+      transform.m_fFields[2][2], transform.m_fFields[2][3], 0, 0, 0, 1;
   return tm;
 }
 
-std::string get_object_type_name(DWORD objecttype)
-{
+std::string get_object_type_name(DWORD objecttype) {
   switch (objecttype) {
-  case MODELOBJECTTYPE_OTHER: return "Other";
-  case MODELOBJECTTYPE_MODEL: return "Model";
-  case MODELOBJECTTYPE_SUPPORT: return "Support";
-  case MODELOBJECTTYPE_SOLIDSUPPORT: return "Solid Support";
-  case MODELOBJECTTYPE_SURFACE: return "Surface";
-  default: return "<Unknown>";
+  case MODELOBJECTTYPE_OTHER:
+    return "Other";
+  case MODELOBJECTTYPE_MODEL:
+    return "Model";
+  case MODELOBJECTTYPE_SUPPORT:
+    return "Support";
+  case MODELOBJECTTYPE_SOLIDSUPPORT:
+    return "Solid Support";
+  case MODELOBJECTTYPE_SURFACE:
+    return "Surface";
+  default:
+    return "<Unknown>";
   }
 }
 
-std::unique_ptr<PolySet> import_3mf_error(PLib3MFModel *model = nullptr, const std::string& errmsg = "", PLib3MFModelBuildItemIterator *it = nullptr)
-{
+std::unique_ptr<PolySet>
+import_3mf_error(PLib3MFModel *model = nullptr, const std::string &errmsg = "",
+                 PLib3MFModelBuildItemIterator *it = nullptr) {
   if (!errmsg.empty()) {
     LOG(message_group::Error, "%1$s", errmsg);
   }
@@ -142,32 +148,43 @@ std::unique_ptr<PolySet> import_3mf_error(PLib3MFModel *model = nullptr, const s
   return PolySet::createEmpty();
 }
 
-std::string collect_mesh_objects(MeshObjectList& object_list, PLib3MFModelObjectResource *object, const Matrix4d& m, const Location& loc, int level = 1)
-{
+std::string collect_mesh_objects(MeshObjectList &object_list,
+                                 PLib3MFModelObjectResource *object,
+                                 const Matrix4d &m, const Location &loc,
+                                 int level = 1) {
   BOOL is_mesh_object = false;
   if (lib3mf_object_ismeshobject(object, &is_mesh_object) != LIB3MF_OK) {
     return "Could not check for mesh object type";
   }
   BOOL is_components_object = false;
-  if (lib3mf_object_iscomponentsobject(object, &is_components_object) != LIB3MF_OK) {
+  if (lib3mf_object_iscomponentsobject(object, &is_components_object) !=
+      LIB3MF_OK) {
     return "Could not check for component object type";
   }
   DWORD objecttype;
   if (lib3mf_object_gettype(object, &objecttype) != LIB3MF_OK) {
     return "Could not read object type";
   }
-  char number[4096] = {0, };
+  char number[4096] = {
+      0,
+  };
   ULONG numberlen;
-  if (lib3mf_object_getpartnumberutf8(object, &number[0], sizeof(number), &numberlen) != LIB3MF_OK) {
+  if (lib3mf_object_getpartnumberutf8(object, &number[0], sizeof(number),
+                                      &numberlen) != LIB3MF_OK) {
     return "Could not read part number of object";
   }
-  char name[4096] = {0, };
+  char name[4096] = {
+      0,
+  };
   ULONG namelen;
-  if (lib3mf_object_getnameutf8(object, &name[0], sizeof(name), &namelen) != LIB3MF_OK) {
+  if (lib3mf_object_getnameutf8(object, &name[0], sizeof(name), &namelen) !=
+      LIB3MF_OK) {
     return "Could not read name of object";
   }
   BOOL hasuuid = false;
-  char uuid[40] = {0, };
+  char uuid[40] = {
+      0,
+  };
   if (lib3mf_object_getuuidutf8(object, &hasuuid, &uuid[0]) != LIB3MF_OK) {
     return "Could not read UUID of object";
   }
@@ -177,42 +194,59 @@ std::string collect_mesh_objects(MeshObjectList& object_list, PLib3MFModelObject
     return "Could not check object validity";
   }
   if (!is_valid_object) {
-    LOG(message_group::Warning, "Object '%1$s' with UUID '%2$s' is not valid, import() at line %3$d", name, uuid, loc.firstLine());
+    LOG(message_group::Warning,
+        "Object '%1$s' with UUID '%2$s' is not valid, import() at line %3$d",
+        name, uuid, loc.firstLine());
   }
 
   if (is_mesh_object) {
-    PRINTDB("%smesh type = %s, number = '%s', name = '%s' (%s)", boost::io::group(std::setw(2 * level), "") % get_object_type_name(objecttype) % number % name % (hasuuid ? uuid : "<no uuid>"));
+    PRINTDB("%smesh type = %s, number = '%s', name = '%s' (%s)",
+            boost::io::group(std::setw(2 * level), "") %
+                get_object_type_name(objecttype) % number % name %
+                (hasuuid ? uuid : "<no uuid>"));
     object_list.push_back(std::make_unique<MeshObject>(MeshObject{object, m}));
     return "";
   }
   if (is_components_object) {
     DWORD componentcount;
-    if (lib3mf_componentsobject_getcomponentcount(object, &componentcount) != LIB3MF_OK) {
+    if (lib3mf_componentsobject_getcomponentcount(object, &componentcount) !=
+        LIB3MF_OK) {
       return "Could not get object component count";
     }
-    PRINTDB("%sobject (%d components) type = %s, number = '%s', name = '%s' (%s)", boost::io::group(std::setw(2 * level), "") % componentcount % get_object_type_name(objecttype) % number % name % (hasuuid ? uuid : "<no uuid>"));
+    PRINTDB(
+        "%sobject (%d components) type = %s, number = '%s', name = '%s' (%s)",
+        boost::io::group(std::setw(2 * level), "") % componentcount %
+            get_object_type_name(objecttype) % number % name %
+            (hasuuid ? uuid : "<no uuid>"));
     for (DWORD idx = 0; idx < componentcount; ++idx) {
       PLib3MFModelComponent *component = nullptr;
-      if (lib3mf_componentsobject_getcomponent(object, idx, &component) != LIB3MF_OK) {
+      if (lib3mf_componentsobject_getcomponent(object, idx, &component) !=
+          LIB3MF_OK) {
         return "Could not get object component";
       }
       BOOL has_transform = false;
-      if (lib3mf_component_hastransform(component, &has_transform) != LIB3MF_OK) {
+      if (lib3mf_component_hastransform(component, &has_transform) !=
+          LIB3MF_OK) {
         return "Could not check for component transform";
       }
-      MODELTRANSFORM transform{ .m_fFields = {{ 1, 0, 0, 0 }, { 0, 1, 0, 0 }, { 0, 0, 1, 0 } } };
-      if (has_transform && lib3mf_component_gettransform(component, &transform) != LIB3MF_OK) {
+      MODELTRANSFORM transform{
+          .m_fFields = {{1, 0, 0, 0}, {0, 1, 0, 0}, {0, 0, 1, 0}}};
+      if (has_transform &&
+          lib3mf_component_gettransform(component, &transform) != LIB3MF_OK) {
         return "Could not read transform of component";
       }
       PLib3MFModelObjectResource *componentobject = nullptr;
-      if (lib3mf_component_getobjectresource(component, &componentobject) != LIB3MF_OK) {
+      if (lib3mf_component_getobjectresource(component, &componentobject) !=
+          LIB3MF_OK) {
         return "Could not read object resource of component";
       }
       const Matrix4d cm = get_matrix(transform);
       if (has_transform) {
-        PRINTDB("%scomponent transform matrix\n%s", boost::io::group(std::setw(2 * level), "") % cm);
+        PRINTDB("%scomponent transform matrix\n%s",
+                boost::io::group(std::setw(2 * level), "") % cm);
       }
-      auto errmsg = collect_mesh_objects(object_list, componentobject, cm * m, loc, level + 1);
+      auto errmsg = collect_mesh_objects(object_list, componentobject, cm * m,
+                                         loc, level + 1);
       if (!errmsg.empty()) {
         return errmsg;
       }
@@ -222,12 +256,14 @@ std::string collect_mesh_objects(MeshObjectList& object_list, PLib3MFModelObject
   return "Unhandled object type, expected one of: mesh, component";
 }
 
-Color4f get_triangle_color_from_basematerial(PLib3MFModel *model, PLib3MFPropertyHandler *propertyhandler, int idx)
-{
+Color4f get_triangle_color_from_basematerial(
+    PLib3MFModel *model, PLib3MFPropertyHandler *propertyhandler, int idx) {
   DWORD materialIndex = 0;
   DWORD materialGroupID = 0;
 
-  if (lib3mf_propertyhandler_getbasematerial(propertyhandler, idx, &materialGroupID, &materialIndex) != LIB3MF_OK) {
+  if (lib3mf_propertyhandler_getbasematerial(propertyhandler, idx,
+                                             &materialGroupID,
+                                             &materialIndex) != LIB3MF_OK) {
     return {};
   }
   if (materialGroupID == 0) {
@@ -235,12 +271,14 @@ Color4f get_triangle_color_from_basematerial(PLib3MFModel *model, PLib3MFPropert
   }
 
   PLib3MFModelBaseMaterial *basematerial;
-  if (lib3mf_model_getbasematerialbyid(model, materialGroupID, &basematerial) != LIB3MF_OK) {
+  if (lib3mf_model_getbasematerialbyid(model, materialGroupID, &basematerial) !=
+      LIB3MF_OK) {
     return {};
   }
 
   BYTE r = 0, g = 0, b = 0, a = 0;
-  if (lib3mf_basematerial_getdisplaycolor(basematerial, materialIndex, &r, &g, &b, &a) != LIB3MF_OK) {
+  if (lib3mf_basematerial_getdisplaycolor(basematerial, materialIndex, &r, &g,
+                                          &b, &a) != LIB3MF_OK) {
     return {};
   }
 
@@ -248,31 +286,26 @@ Color4f get_triangle_color_from_basematerial(PLib3MFModel *model, PLib3MFPropert
   return col;
 }
 
-Color4f get_triangle_color(PLib3MFPropertyHandler *propertyhandler, int idx)
-{
-  MODELMESH_TRIANGLECOLOR_SRGB color = { .m_Colors = {
-                                           { 0, 0, 0 },
-                                           { 0, 0, 0 },
-                                           { 0, 0, 0 }
-                                         } };
-  if (lib3mf_propertyhandler_getcolor(propertyhandler, idx, &color) == LIB3MF_OK) {
+Color4f get_triangle_color(PLib3MFPropertyHandler *propertyhandler, int idx) {
+  MODELMESH_TRIANGLECOLOR_SRGB color = {
+      .m_Colors = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}}};
+  if (lib3mf_propertyhandler_getcolor(propertyhandler, idx, &color) ==
+      LIB3MF_OK) {
     const Color4f col0 = get_color(color, 0);
     const Color4f col1 = get_color(color, 1);
     const Color4f col2 = get_color(color, 2);
     if (col0.isValid() && col1.isValid() && col2.isValid()) {
-      return {
-        std::clamp((col0.r() + col1.r() + col2.r()) / 3, 0.0f, 1.0f),
-        std::clamp((col0.g() + col1.g() + col2.g()) / 3, 0.0f, 1.0f),
-        std::clamp((col0.b() + col1.b() + col2.b()) / 3, 0.0f, 1.0f),
-        std::clamp((col0.a() + col1.a() + col2.a()) / 3, 0.0f, 1.0f)
-      };
+      return {std::clamp((col0.r() + col1.r() + col2.r()) / 3, 0.0f, 1.0f),
+              std::clamp((col0.g() + col1.g() + col2.g()) / 3, 0.0f, 1.0f),
+              std::clamp((col0.b() + col1.b() + col2.b()) / 3, 0.0f, 1.0f),
+              std::clamp((col0.a() + col1.a() + col2.a()) / 3, 0.0f, 1.0f)};
     }
   }
   return {};
 }
 
-Color4f get_triangle_color(PLib3MFModel *model, PLib3MFPropertyHandler *propertyhandler, int idx)
-{
+Color4f get_triangle_color(PLib3MFModel *model,
+                           PLib3MFPropertyHandler *propertyhandler, int idx) {
   eModelPropertyType propertytype = MODELPROPERTYTYPE_NONE;
   lib3mf_propertyhandler_getpropertytype(propertyhandler, idx, &propertytype);
   if (propertytype == MODELPROPERTYTYPE_BASEMATERIALS) {
@@ -284,24 +317,30 @@ Color4f get_triangle_color(PLib3MFModel *model, PLib3MFPropertyHandler *property
   return {};
 }
 
-std::string import_3mf_mesh(const std::string& filename, unsigned int mesh_idx, PLib3MFModel *model, std::unique_ptr<MeshObject>& mo, std::unique_ptr<PolySet>& ps)
-{
+std::string import_3mf_mesh(const std::string &filename, unsigned int mesh_idx,
+                            PLib3MFModel *model,
+                            std::unique_ptr<MeshObject> &mo,
+                            std::unique_ptr<PolySet> &ps) {
   DWORD vertex_count = 0;
   if (lib3mf_meshobject_getvertexcount(mo->obj, &vertex_count) != LIB3MF_OK) {
     return "Could not read vertex count";
   }
   DWORD triangle_count = 0;
-  if (lib3mf_meshobject_gettrianglecount(mo->obj, &triangle_count) != LIB3MF_OK) {
+  if (lib3mf_meshobject_gettrianglecount(mo->obj, &triangle_count) !=
+      LIB3MF_OK) {
     return "Could not read triangle count";
   }
   DWORD object_type = 0;
   if (lib3mf_object_gettype(mo->obj, &object_type) != LIB3MF_OK) {
     return "Could not read object type";
   }
-  PRINTDB("%s: mesh %d, type: %s, vertex count: %lu, triangle count: %lu", filename.c_str() % mesh_idx % get_object_type_name(object_type) % vertex_count % triangle_count);
+  PRINTDB("%s: mesh %d, type: %s, vertex count: %lu, triangle count: %lu",
+          filename.c_str() % mesh_idx % get_object_type_name(object_type) %
+              vertex_count % triangle_count);
 
   PLib3MFPropertyHandler *propertyhandler = nullptr;
-  if (lib3mf_meshobject_createpropertyhandler(mo->obj, &propertyhandler) != LIB3MF_OK) {
+  if (lib3mf_meshobject_createpropertyhandler(mo->obj, &propertyhandler) !=
+      LIB3MF_OK) {
     return "Could not create property handler";
   }
 
@@ -314,7 +353,9 @@ std::string import_3mf_mesh(const std::string& filename, unsigned int mesh_idx,
     if (lib3mf_meshobject_getvertex(mo->obj, idx, &vertex) != LIB3MF_OK) {
       return "Could not read vertex from object";
     }
-    const Vector4d v = mo->transform * Vector4d(vertex.m_fPosition[0], vertex.m_fPosition[1], vertex.m_fPosition[2], 1);
+    const Vector4d v =
+        mo->transform * Vector4d(vertex.m_fPosition[0], vertex.m_fPosition[1],
+                                 vertex.m_fPosition[2], 1);
     ps->vertices.push_back(v.head(3));
   }
 
@@ -354,8 +395,7 @@ std::string import_3mf_mesh(const std::string& filename, unsigned int mesh_idx,
   return "";
 }
 
-std::string read_metadata(PLib3MFModel *model)
-{
+std::string read_metadata(PLib3MFModel *model) {
   DWORD metadatacount;
   if (lib3mf_model_getmetadatacount(model, &metadatacount) != LIB3MF_OK) {
     return "Could not retrieve metadata";
@@ -363,14 +403,20 @@ std::string read_metadata(PLib3MFModel *model)
 
   ModelMetadata mmd;
   for (DWORD idx = 0; idx < metadatacount; ++idx) {
-    char key[4096] = { 0, };
+    char key[4096] = {
+        0,
+    };
     ULONG keylen = 0;
-    if (lib3mf_model_getmetadatakeyutf8(model, idx, &key[0], sizeof(key), &keylen) != LIB3MF_OK) {
+    if (lib3mf_model_getmetadatakeyutf8(model, idx, &key[0], sizeof(key),
+                                        &keylen) != LIB3MF_OK) {
       return "Could not retrieve metadata key";
     }
-    char value[4096] = { 0, };
+    char value[4096] = {
+        0,
+    };
     ULONG valuelen = 0;
-    if (lib3mf_model_getmetadatavalueutf8(model, idx, &value[0], sizeof(value), &valuelen) != LIB3MF_OK) {
+    if (lib3mf_model_getmetadatavalueutf8(model, idx, &value[0], sizeof(value),
+                                          &valuelen) != LIB3MF_OK) {
       return "Could not retrieve metadata value";
     }
     PRINTDB("METADATA[%d]: %s = '%s'", idx % key % value);
@@ -406,19 +452,23 @@ std::string read_metadata(PLib3MFModel *model)
 
 } // namespace
 
-std::unique_ptr<PolySet> import_3mf(const std::string& filename, const Location& loc)
-{
+std::unique_ptr<PolySet> import_3mf(const std::string &filename,
+                                    const Location &loc) {
   DWORD interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro;
-  HRESULT result = lib3mf_getinterfaceversion(&interfaceVersionMajor, &interfaceVersionMinor, &interfaceVersionMicro);
+  HRESULT result = lib3mf_getinterfaceversion(
+      &interfaceVersionMajor, &interfaceVersionMinor, &interfaceVersionMicro);
   if (result != LIB3MF_OK) {
     LOG(message_group::Error, "Error reading 3MF library version");
     return PolySet::createEmpty();
   }
 
   if ((interfaceVersionMajor != NMR_APIVERSION_INTERFACE_MAJOR)) {
-    LOG(message_group::Error, "Invalid 3MF library major version %1$d.%2$d.%3$d, expected %4$d.%5$d.%6$d",
+    LOG(message_group::Error,
+        "Invalid 3MF library major version %1$d.%2$d.%3$d, expected "
+        "%4$d.%5$d.%6$d",
         interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro,
-        NMR_APIVERSION_INTERFACE_MAJOR, NMR_APIVERSION_INTERFACE_MINOR, NMR_APIVERSION_INTERFACE_MICRO);
+        NMR_APIVERSION_INTERFACE_MAJOR, NMR_APIVERSION_INTERFACE_MINOR,
+        NMR_APIVERSION_INTERFACE_MICRO);
     return PolySet::createEmpty();
   }
 
@@ -439,7 +489,9 @@ std::unique_ptr<PolySet> import_3mf(const std::string& filename, const Location&
   result = lib3mf_reader_readfromfileutf8(reader, filename.c_str());
   lib3mf_release(reader);
   if (result != LIB3MF_OK) {
-    LOG(message_group::Warning, "Could not read file '%1$s', import() at line %2$d", filename.c_str(), loc.firstLine());
+    LOG(message_group::Warning,
+        "Could not read file '%1$s', import() at line %2$d", filename.c_str(),
+        loc.firstLine());
     return import_3mf_error(model);
   }
 
@@ -453,47 +505,67 @@ std::unique_ptr<PolySet> import_3mf(const std::string& filename, const Location&
   std::list<std::unique_ptr<PolySet>> meshes;
   while (true) {
     BOOL has_next = false;
-    if (lib3mf_builditemiterator_movenext(builditem_it, &has_next) != LIB3MF_OK) {
-      return import_3mf_error(model, "Error iterating over build items", builditem_it);
+    if (lib3mf_builditemiterator_movenext(builditem_it, &has_next) !=
+        LIB3MF_OK) {
+      return import_3mf_error(model, "Error iterating over build items",
+                              builditem_it);
     }
     if (!has_next) {
       break;
     }
 
     PLib3MFModelBuildItem *builditem = nullptr;
-    if (lib3mf_builditemiterator_getcurrent(builditem_it, &builditem) != LIB3MF_OK) {
+    if (lib3mf_builditemiterator_getcurrent(builditem_it, &builditem) !=
+        LIB3MF_OK) {
       return import_3mf_error(model, "Could not read build item", builditem_it);
     }
     DWORD builditemhandle;
     if (lib3mf_builditem_gethandle(builditem, &builditemhandle) != LIB3MF_OK) {
-      return import_3mf_error(model, "Could not get handle of build item", builditem_it);
+      return import_3mf_error(model, "Could not get handle of build item",
+                              builditem_it);
     }
-    char partnumber[4096] = {0, };
+    char partnumber[4096] = {
+        0,
+    };
     ULONG partnumberlen = 0;
-    if (lib3mf_builditem_getpartnumberutf8(builditem, &partnumber[0], sizeof(partnumber), &partnumberlen) != LIB3MF_OK) {
-      return import_3mf_error(model, "Could not get part number of build item", builditem_it);
+    if (lib3mf_builditem_getpartnumberutf8(builditem, &partnumber[0],
+                                           sizeof(partnumber),
+                                           &partnumberlen) != LIB3MF_OK) {
+      return import_3mf_error(model, "Could not get part number of build item",
+                              builditem_it);
     }
     BOOL hasuuid = false;
-    char uuid[40] = {0, };
-    if (lib3mf_builditem_getuuidutf8(builditem, &hasuuid, &uuid[0]) != LIB3MF_OK) {
-      return import_3mf_error(model, "Could not get uuid of build item", builditem_it);
+    char uuid[40] = {
+        0,
+    };
+    if (lib3mf_builditem_getuuidutf8(builditem, &hasuuid, &uuid[0]) !=
+        LIB3MF_OK) {
+      return import_3mf_error(model, "Could not get uuid of build item",
+                              builditem_it);
     }
     PLib3MFModelObjectResource *object = nullptr;
     if (lib3mf_builditem_getobjectresource(builditem, &object) != LIB3MF_OK) {
-      return import_3mf_error(model, "Could not read object resource of build item", builditem_it);
+      return import_3mf_error(
+          model, "Could not read object resource of build item", builditem_it);
     }
 
     BOOL has_transform = false;
-    if (lib3mf_builditem_hasobjecttransform(builditem, &has_transform) != LIB3MF_OK) {
-      return import_3mf_error(model, "Could not check for build item transform", builditem_it);
+    if (lib3mf_builditem_hasobjecttransform(builditem, &has_transform) !=
+        LIB3MF_OK) {
+      return import_3mf_error(model, "Could not check for build item transform",
+                              builditem_it);
     }
-    MODELTRANSFORM transform{ .m_fFields = {{ 1, 0, 0, 0 }, { 0, 1, 0, 0 }, { 0, 0, 1, 0 } } };
-    if (has_transform && lib3mf_builditem_getobjecttransform(builditem, &transform) != LIB3MF_OK) {
-      return import_3mf_error(model, "Could not read build item transform", builditem_it);
+    MODELTRANSFORM transform{
+        .m_fFields = {{1, 0, 0, 0}, {0, 1, 0, 0}, {0, 0, 1, 0}}};
+    if (has_transform && lib3mf_builditem_getobjecttransform(
+                             builditem, &transform) != LIB3MF_OK) {
+      return import_3mf_error(model, "Could not read build item transform",
+                              builditem_it);
     }
     const Matrix4d m = get_matrix(transform);
 
-    PRINTDB("build item %d, part number = '%s' (%s)", builditemhandle % partnumber % (hasuuid ? uuid : "<no uuid>"));
+    PRINTDB("build item %d, part number = '%s' (%s)",
+            builditemhandle % partnumber % (hasuuid ? uuid : "<no uuid>"));
     if (has_transform) {
       PRINTDB("build item transform matrix\n%s", m);
     }
@@ -501,12 +573,14 @@ std::unique_ptr<PolySet> import_3mf(const std::string& filename, const Location&
     MeshObjectList object_list;
     std::string errmsg = collect_mesh_objects(object_list, object, m, loc);
     if (!errmsg.empty()) {
-      return import_3mf_error(model, "Error collecting meshes: " + errmsg, builditem_it);
+      return import_3mf_error(model, "Error collecting meshes: " + errmsg,
+                              builditem_it);
     }
 
-    for (auto& mo : object_list) {
+    for (auto &mo : object_list) {
       auto ps = PolySet::createEmpty();
-      std::string errmsg = import_3mf_mesh(filename, meshes.size(), model, mo, ps);
+      std::string errmsg =
+          import_3mf_mesh(filename, meshes.size(), model, mo, ps);
       if (errmsg.empty()) {
         if (ps->isEmpty()) {
           continue;
@@ -530,12 +604,16 @@ std::unique_ptr<PolySet> import_3mf(const std::string& filename, const Location&
     std::unique_ptr<PolySet> p;
     Geometry::Geometries children;
     while (!meshes.empty()) {
-      children.emplace_back(std::shared_ptr<AbstractNode>(), std::shared_ptr<const Geometry>(std::move(meshes.front())));
+      children.emplace_back(
+          std::shared_ptr<AbstractNode>(),
+          std::shared_ptr<const Geometry>(std::move(meshes.front())));
       meshes.pop_front();
     }
 #ifdef ENABLE_MANIFOLD
     if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
-      if (auto ps = PolySetUtils::getGeometryAsPolySet(ManifoldUtils::applyOperator3DManifold(children, OpenSCADOperator::UNION))) {
+      if (auto ps = PolySetUtils::getGeometryAsPolySet(
+              ManifoldUtils::applyOperator3DManifold(
+                  children, OpenSCADOperator::UNION))) {
         p = std::make_unique<PolySet>(*ps);
       } else {
         p = PolySet::createEmpty();
@@ -544,7 +622,8 @@ std::unique_ptr<PolySet> import_3mf(const std::string& filename, const Location&
 #endif // ifdef ENABLE_MANIFOLD
     {
 #ifdef ENABLE_CGAL
-      if (auto ps = PolySetUtils::getGeometryAsPolySet(CGALUtils::applyUnion3D(children.begin(), children.end()))) {
+      if (auto ps = PolySetUtils::getGeometryAsPolySet(
+              CGALUtils::applyUnion3D(children.begin(), children.end()))) {
         p = std::make_unique<PolySet>(*ps);
       } else {
         p = PolySet::createEmpty();
diff --git a/src/io/import_3mf_v2.cc b/src/io/import_3mf_v2.cc
index 6b62538a8..bc319116e 100644
--- a/src/io/import_3mf_v2.cc
+++ b/src/io/import_3mf_v2.cc
@@ -37,25 +37,23 @@
 
 #include "core/AST.h"
 #include "geometry/Geometry.h"
-#include "geometry/linalg.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetBuilder.h"
 #include "geometry/PolySetUtils.h"
+#include "geometry/linalg.h"
 #include "glview/RenderSettings.h"
+#include "io/lib3mf_utils.h"
 #include "utils/printutils.h"
 #include "utils/version_helper.h"
-#include "io/lib3mf_utils.h"
 
 namespace {
 
-struct MeshObject
-{
+struct MeshObject {
   const Lib3MF::PMeshObject obj;
   const Matrix4d transform;
 };
 
-struct ModelMetadata
-{
+struct ModelMetadata {
   std::string title;
   std::string designer;
   std::string description;
@@ -69,29 +67,37 @@ struct ModelMetadata
 
 using MeshObjectList = std::list<std::unique_ptr<MeshObject>>;
 
-std::string get_object_type_name(const Lib3MF::eObjectType objecttype)
-{
+std::string get_object_type_name(const Lib3MF::eObjectType objecttype) {
   switch (objecttype) {
-  case Lib3MF::eObjectType::Other: return "Other";
-  case Lib3MF::eObjectType::Model: return "Model";
-  case Lib3MF::eObjectType::Support: return "Support";
-  case Lib3MF::eObjectType::SolidSupport: return "Solid Support";
-  default: return "<Unknown>";
+  case Lib3MF::eObjectType::Other:
+    return "Other";
+  case Lib3MF::eObjectType::Model:
+    return "Model";
+  case Lib3MF::eObjectType::Support:
+    return "Support";
+  case Lib3MF::eObjectType::SolidSupport:
+    return "Solid Support";
+  default:
+    return "<Unknown>";
   }
 }
 
-Matrix4d get_matrix(Lib3MF::sTransform& transform)
-{
+Matrix4d get_matrix(Lib3MF::sTransform &transform) {
   Matrix4d tm;
-  tm << transform.m_Fields[0][0], transform.m_Fields[1][0], transform.m_Fields[2][0], transform.m_Fields[3][0],
-    transform.m_Fields[0][1], transform.m_Fields[1][1], transform.m_Fields[2][1], transform.m_Fields[3][1],
-    transform.m_Fields[0][2], transform.m_Fields[1][2], transform.m_Fields[2][2], transform.m_Fields[3][2],
-    0,                        0,                        0,                        1;
+  tm << transform.m_Fields[0][0], transform.m_Fields[1][0],
+      transform.m_Fields[2][0], transform.m_Fields[3][0],
+      transform.m_Fields[0][1], transform.m_Fields[1][1],
+      transform.m_Fields[2][1], transform.m_Fields[3][1],
+      transform.m_Fields[0][2], transform.m_Fields[1][2],
+      transform.m_Fields[2][2], transform.m_Fields[3][2], 0, 0, 0, 1;
   return tm;
 }
 
-std::string collect_mesh_objects(const Lib3MF::PModel& model, MeshObjectList& object_list, const Lib3MF::PObject& object, const Matrix4d& m, const Location& loc, int level = 1)
-{
+std::string collect_mesh_objects(const Lib3MF::PModel &model,
+                                 MeshObjectList &object_list,
+                                 const Lib3MF::PObject &object,
+                                 const Matrix4d &m, const Location &loc,
+                                 int level = 1) {
   const bool is_mesh_object = object->IsMeshObject();
   const bool is_components_object = object->IsComponentsObject();
   const auto objecttype = object->GetType();
@@ -111,29 +117,42 @@ std::string collect_mesh_objects(const Lib3MF::PModel& model, MeshObjectList& ob
 #endif
 
   if (is_mesh_object) {
-    const auto meshobject = model->GetMeshObjectByID(object->GetUniqueResourceID());
-    PRINTDB("%smesh type = %s, number = '%s', name = '%s' (%s)", boost::io::group(std::setw(2 * level), "") % get_object_type_name(objecttype) % partnumber % name % (hasuuid ? uuid : "<no uuid>"));
-    object_list.push_back(std::make_unique<MeshObject>(MeshObject{meshobject, m}));
+    const auto meshobject =
+        model->GetMeshObjectByID(object->GetUniqueResourceID());
+    PRINTDB("%smesh type = %s, number = '%s', name = '%s' (%s)",
+            boost::io::group(std::setw(2 * level), "") %
+                get_object_type_name(objecttype) % partnumber % name %
+                (hasuuid ? uuid : "<no uuid>"));
+    object_list.push_back(
+        std::make_unique<MeshObject>(MeshObject{meshobject, m}));
     return "";
   }
   if (is_components_object) {
-    const auto componentsobject = model->GetComponentsObjectByID(object->GetUniqueResourceID());
+    const auto componentsobject =
+        model->GetComponentsObjectByID(object->GetUniqueResourceID());
     const int componentcount = componentsobject->GetComponentCount();
-    PRINTDB("%sobject (%d components) type = %s, number = '%s', name = '%s' (%s)", boost::io::group(std::setw(2 * level), "") % componentcount % get_object_type_name(objecttype) % partnumber % name % (hasuuid ? uuid : "<no uuid>"));
+    PRINTDB(
+        "%sobject (%d components) type = %s, number = '%s', name = '%s' (%s)",
+        boost::io::group(std::setw(2 * level), "") % componentcount %
+            get_object_type_name(objecttype) % partnumber % name %
+            (hasuuid ? uuid : "<no uuid>"));
 
     for (int idx = 0; idx < componentcount; ++idx) {
       const auto component = componentsobject->GetComponent(idx);
       const bool has_transform = component->HasTransform();
-      Lib3MF::sTransform transform{ .m_Fields = {{ 1, 0, 0 }, { 0, 1, 0 }, { 0, 0, 1 }, { 0, 0, 1 } } };
+      Lib3MF::sTransform transform{
+          .m_Fields = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}, {0, 0, 1}}};
       if (has_transform) {
         transform = component->GetTransform();
       }
       const auto componentobject = component->GetObjectResource();
       const Matrix4d cm = get_matrix(transform);
       if (has_transform) {
-        PRINTDB("%scomponent transform matrix\n%s", boost::io::group(std::setw(2 * level), "") % cm);
+        PRINTDB("%scomponent transform matrix\n%s",
+                boost::io::group(std::setw(2 * level), "") % cm);
       }
-      auto errmsg = collect_mesh_objects(model, object_list, componentobject, cm * m, loc, level + 1);
+      auto errmsg = collect_mesh_objects(model, object_list, componentobject,
+                                         cm * m, loc, level + 1);
       if (!errmsg.empty()) {
         return errmsg;
       }
@@ -145,50 +164,59 @@ std::string collect_mesh_objects(const Lib3MF::PModel& model, MeshObjectList& ob
 
 // lib3mf_propertyhandler_getcolor states:
 // (#00000000) means no property or a different kind of property!
-Color4f get_color(const Lib3MF::PColorGroup& colorgroup, const Lib3MF_uint32 propertyid)
-{
+Color4f get_color(const Lib3MF::PColorGroup &colorgroup,
+                  const Lib3MF_uint32 propertyid) {
   const auto color = colorgroup->GetColor(propertyid);
-  if (color.m_Red == 0 && color.m_Green == 0 && color.m_Blue == 0 && color.m_Alpha == 0) {
+  if (color.m_Red == 0 && color.m_Green == 0 && color.m_Blue == 0 &&
+      color.m_Alpha == 0) {
     return {}; // invalid color
   }
   Color4f c{color.m_Red, color.m_Green, color.m_Blue, color.m_Alpha};
   return c;
 }
 
-Color4f get_triangle_color(const Lib3MF::PModel& model, const Lib3MF::sTriangleProperties triangle_properties)
-{
-  const auto colorgroup = model->GetColorGroupByID(triangle_properties.m_ResourceID);
-  const Color4f col0 = get_color(colorgroup, triangle_properties.m_PropertyIDs[0]);
-  const Color4f col1 = get_color(colorgroup, triangle_properties.m_PropertyIDs[1]);
-  const Color4f col2 = get_color(colorgroup, triangle_properties.m_PropertyIDs[2]);
+Color4f
+get_triangle_color(const Lib3MF::PModel &model,
+                   const Lib3MF::sTriangleProperties triangle_properties) {
+  const auto colorgroup =
+      model->GetColorGroupByID(triangle_properties.m_ResourceID);
+  const Color4f col0 =
+      get_color(colorgroup, triangle_properties.m_PropertyIDs[0]);
+  const Color4f col1 =
+      get_color(colorgroup, triangle_properties.m_PropertyIDs[1]);
+  const Color4f col2 =
+      get_color(colorgroup, triangle_properties.m_PropertyIDs[2]);
   if (col0.isValid() && col1.isValid() && col2.isValid()) {
-    return {
-      std::clamp((col0.r() + col1.r() + col2.r()) / 3, 0.0f, 1.0f),
-      std::clamp((col0.g() + col1.g() + col2.g()) / 3, 0.0f, 1.0f),
-      std::clamp((col0.b() + col1.b() + col2.b()) / 3, 0.0f, 1.0f),
-      std::clamp((col0.a() + col1.a() + col2.a()) / 3, 0.0f, 1.0f)
-    };
+    return {std::clamp((col0.r() + col1.r() + col2.r()) / 3, 0.0f, 1.0f),
+            std::clamp((col0.g() + col1.g() + col2.g()) / 3, 0.0f, 1.0f),
+            std::clamp((col0.b() + col1.b() + col2.b()) / 3, 0.0f, 1.0f),
+            std::clamp((col0.a() + col1.a() + col2.a()) / 3, 0.0f, 1.0f)};
   }
   return {};
 }
 
-Color4f get_triangle_color_from_basematerial(const Lib3MF::PModel& model, const Lib3MF::sTriangleProperties triangle_properties)
-{
-  const auto basematerialgroup = model->GetBaseMaterialGroupByID(triangle_properties.m_ResourceID);
-  const auto displaycolor = basematerialgroup->GetDisplayColor(triangle_properties.m_PropertyIDs[0]);
-  Color4f col{displaycolor.m_Red, displaycolor.m_Green, displaycolor.m_Blue, 255};
+Color4f get_triangle_color_from_basematerial(
+    const Lib3MF::PModel &model,
+    const Lib3MF::sTriangleProperties triangle_properties) {
+  const auto basematerialgroup =
+      model->GetBaseMaterialGroupByID(triangle_properties.m_ResourceID);
+  const auto displaycolor =
+      basematerialgroup->GetDisplayColor(triangle_properties.m_PropertyIDs[0]);
+  Color4f col{displaycolor.m_Red, displaycolor.m_Green, displaycolor.m_Blue,
+              255};
   return col;
 }
 
-Color4f get_triangle_color(const Lib3MF::PModel& model, const Lib3MF::PMeshObject& object, int idx)
-{
+Color4f get_triangle_color(const Lib3MF::PModel &model,
+                           const Lib3MF::PMeshObject &object, int idx) {
   Lib3MF::sTriangleProperties triangle_properties;
   object->GetTriangleProperties(idx, triangle_properties);
   if (triangle_properties.m_ResourceID == 0) {
     return {};
   }
 
-  const auto propertytype = model->GetPropertyTypeByID(triangle_properties.m_ResourceID);
+  const auto propertytype =
+      model->GetPropertyTypeByID(triangle_properties.m_ResourceID);
   switch (propertytype) {
   case Lib3MF::ePropertyType::BaseMaterial:
     return get_triangle_color_from_basematerial(model, triangle_properties);
@@ -199,8 +227,10 @@ Color4f get_triangle_color(const Lib3MF::PModel& model, const Lib3MF::PMeshObjec
   }
 }
 
-std::string import_3mf_mesh(const std::string& filename, unsigned int mesh_idx, const Lib3MF::PModel& model, const std::unique_ptr<MeshObject>& mo, std::unique_ptr<PolySet>& ps)
-{
+std::string import_3mf_mesh(const std::string &filename, unsigned int mesh_idx,
+                            const Lib3MF::PModel &model,
+                            const std::unique_ptr<MeshObject> &mo,
+                            std::unique_ptr<PolySet> &ps) {
   const auto object = mo->obj;
   const auto vertex_count = object->GetVertexCount();
   const auto triangle_count = object->GetTriangleCount();
@@ -210,7 +240,9 @@ std::string import_3mf_mesh(const std::string& filename, unsigned int mesh_idx,
 
   const auto object_type = get_object_type_name(object->GetType());
 
-  PRINTDB("%s: mesh %d, type: %s, vertex count: %lu, triangle count: %lu", filename.c_str() % mesh_idx % object_type % vertex_count % triangle_count);
+  PRINTDB("%s: mesh %d, type: %s, vertex count: %lu, triangle count: %lu",
+          filename.c_str() % mesh_idx % object_type % vertex_count %
+              triangle_count);
 
   ps->vertices.reserve(vertex_count);
   ps->indices.reserve(triangle_count);
@@ -218,8 +250,10 @@ std::string import_3mf_mesh(const std::string& filename, unsigned int mesh_idx,
 
   std::vector<Lib3MF::sPosition> all_vertices;
   object->GetVertices(all_vertices);
-  for (const auto& vertex : all_vertices) {
-    const Vector4d v = mo->transform * Vector4d(vertex.m_Coordinates[0], vertex.m_Coordinates[1], vertex.m_Coordinates[2], 1);
+  for (const auto &vertex : all_vertices) {
+    const Vector4d v = mo->transform * Vector4d(vertex.m_Coordinates[0],
+                                                vertex.m_Coordinates[1],
+                                                vertex.m_Coordinates[2], 1);
     ps->vertices.push_back(v.head(3));
   }
 
@@ -227,7 +261,7 @@ std::string import_3mf_mesh(const std::string& filename, unsigned int mesh_idx,
   for (Lib3MF_uint32 idx = 0; idx < triangle_count; ++idx) {
     const auto triangle = object->GetTriangle(idx);
     ps->indices.emplace_back();
-    for (const auto& idx : triangle.m_Indices) {
+    for (const auto &idx : triangle.m_Indices) {
       ps->indices.back().push_back(idx);
     }
 
@@ -255,8 +289,7 @@ std::string import_3mf_mesh(const std::string& filename, unsigned int mesh_idx,
   return "";
 }
 
-std::string read_metadata(const Lib3MF::PModel& model)
-{
+std::string read_metadata(const Lib3MF::PModel &model) {
   const auto metadatagroup = model->GetMetaDataGroup();
   const auto metadatacount = metadatagroup->GetMetaDataCount();
 
@@ -267,7 +300,7 @@ std::string read_metadata(const Lib3MF::PModel& model)
     const auto value = metadata->GetValue();
     PRINTDB("METADATA[%d]: %s = '%s'", idx % key % value);
 
-    const std::string& name = key;
+    const std::string &name = key;
     if (name == "Title") {
       mmd.title = value;
     } else if (name == "Designer") {
@@ -299,18 +332,22 @@ std::string read_metadata(const Lib3MF::PModel& model)
 } // namespace
 
 std::string get_lib3mf_version() {
-  Lib3MF_uint32 interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro;
+  Lib3MF_uint32 interfaceVersionMajor, interfaceVersionMinor,
+      interfaceVersionMicro;
   Lib3MF::PWrapper wrapper;
 
   try {
     wrapper = Lib3MF::CWrapper::loadLibrary();
-    wrapper->GetLibraryVersion(interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro);
-  } catch (const Lib3MF::ELib3MFException& e) {
+    wrapper->GetLibraryVersion(interfaceVersionMajor, interfaceVersionMinor,
+                               interfaceVersionMicro);
+  } catch (const Lib3MF::ELib3MFException &e) {
     LOG(message_group::Export_Error, e.what());
   }
 
-  const OpenSCAD::library_version_number header_version{LIB3MF_VERSION_MAJOR, LIB3MF_VERSION_MINOR, LIB3MF_VERSION_MICRO};
-  const OpenSCAD::library_version_number runtime_version{interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro};
+  const OpenSCAD::library_version_number header_version{
+      LIB3MF_VERSION_MAJOR, LIB3MF_VERSION_MINOR, LIB3MF_VERSION_MICRO};
+  const OpenSCAD::library_version_number runtime_version{
+      interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro};
   return OpenSCAD::get_version_string(header_version, runtime_version);
 }
 
@@ -321,21 +358,25 @@ std::string get_lib3mf_version() {
 #include "geometry/manifold/manifoldutils.h"
 #endif
 
-std::unique_ptr<PolySet> import_3mf(const std::string& filename, const Location& loc)
-{
+std::unique_ptr<PolySet> import_3mf(const std::string &filename,
+                                    const Location &loc) {
   Lib3MF::PWrapper wrapper;
 
   try {
     wrapper = Lib3MF::CWrapper::loadLibrary();
-    Lib3MF_uint32 interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro;
-    wrapper->GetLibraryVersion(interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro);
+    Lib3MF_uint32 interfaceVersionMajor, interfaceVersionMinor,
+        interfaceVersionMicro;
+    wrapper->GetLibraryVersion(interfaceVersionMajor, interfaceVersionMinor,
+                               interfaceVersionMicro);
     if (interfaceVersionMajor != LIB3MF_VERSION_MAJOR) {
-      LOG(message_group::Error, "Invalid 3MF library major version %1$d.%2$d.%3$d, expected %4$d.%5$d.%6$d",
+      LOG(message_group::Error,
+          "Invalid 3MF library major version %1$d.%2$d.%3$d, expected "
+          "%4$d.%5$d.%6$d",
           interfaceVersionMajor, interfaceVersionMinor, interfaceVersionMicro,
           LIB3MF_VERSION_MAJOR, LIB3MF_VERSION_MINOR, LIB3MF_VERSION_MICRO);
       return PolySet::createEmpty();
     }
-  } catch (const Lib3MF::ELib3MFException& e) {
+  } catch (const Lib3MF::ELib3MFException &e) {
     LOG(message_group::Export_Error, e.what());
     return PolySet::createEmpty();
   }
@@ -347,7 +388,7 @@ std::unique_ptr<PolySet> import_3mf(const std::string& filename, const Location&
       LOG(message_group::Error, "Could not create model");
       return PolySet::createEmpty();
     }
-  } catch (const Lib3MF::ELib3MFException& e) {
+  } catch (const Lib3MF::ELib3MFException &e) {
     LOG(message_group::Export_Error, e.what());
     return PolySet::createEmpty();
   }
@@ -359,15 +400,19 @@ std::unique_ptr<PolySet> import_3mf(const std::string& filename, const Location&
       LOG(message_group::Error, "Could not create 3MF reader");
       return PolySet::createEmpty();
     }
-  } catch (const Lib3MF::ELib3MFException& e) {
-    LOG(message_group::Export_Error, "Could create 3MF reader, import() at line %1$d: %2$s", loc.firstLine(), e.what());
+  } catch (const Lib3MF::ELib3MFException &e) {
+    LOG(message_group::Export_Error,
+        "Could create 3MF reader, import() at line %1$d: %2$s", loc.firstLine(),
+        e.what());
     return PolySet::createEmpty();
   }
 
   try {
     reader->ReadFromFile(filename);
-  } catch (const Lib3MF::ELib3MFException& e) {
-    LOG(message_group::Warning, "Could not read file '%1$s', import() at line %2$d: %3$s", filename.c_str(), loc.firstLine(), e.what());
+  } catch (const Lib3MF::ELib3MFException &e) {
+    LOG(message_group::Warning,
+        "Could not read file '%1$s', import() at line %2$d: %3$s",
+        filename.c_str(), loc.firstLine(), e.what());
     return PolySet::createEmpty();
   }
 
@@ -376,7 +421,9 @@ std::unique_ptr<PolySet> import_3mf(const std::string& filename, const Location&
   try {
     Lib3MF::PBuildItemIterator builditem_it = model->GetBuildItems();
     if (!builditem_it) {
-      LOG(message_group::Warning, "Could not retrieve build items, import() at line %2$d", filename.c_str(), loc.firstLine());
+      LOG(message_group::Warning,
+          "Could not retrieve build items, import() at line %2$d",
+          filename.c_str(), loc.firstLine());
       return PolySet::createEmpty();
     }
 
@@ -387,34 +434,41 @@ std::unique_ptr<PolySet> import_3mf(const std::string& filename, const Location&
       const auto partnumber = builditem->GetPartNumber();
       bool hasuuid = false;
       const auto uuid = builditem->GetUUID(hasuuid);
-      Lib3MF::sTransform transform{ .m_Fields = {{ 1, 0, 0 }, { 0, 1, 0 }, { 0, 0, 1 }, { 0, 0, 0 } } };
+      Lib3MF::sTransform transform{
+          .m_Fields = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}, {0, 0, 0}}};
       if (builditem->HasObjectTransform()) {
         transform = builditem->GetObjectTransform();
       }
       const auto object = builditem->GetObjectResource();
       const Matrix4d m = get_matrix(transform);
 
-      PRINTDB("build item %d, part number = '%s' (%s)", builditemhandle % partnumber % (hasuuid ? uuid : "<no uuid>"));
+      PRINTDB("build item %d, part number = '%s' (%s)",
+              builditemhandle % partnumber % (hasuuid ? uuid : "<no uuid>"));
       if (builditem->HasObjectTransform()) {
         PRINTDB("build item transform matrix\n%s", m);
       }
 
       MeshObjectList object_list;
-      std::string errmsg = collect_mesh_objects(model, object_list, object, m, loc);
+      std::string errmsg =
+          collect_mesh_objects(model, object_list, object, m, loc);
       if (!errmsg.empty()) {
-        LOG(message_group::Warning, "Error collecting meshes, import() at line %2$d", filename.c_str(), loc.firstLine());
+        LOG(message_group::Warning,
+            "Error collecting meshes, import() at line %2$d", filename.c_str(),
+            loc.firstLine());
         return PolySet::createEmpty();
       }
 
-      for (const auto& mo : object_list) {
+      for (const auto &mo : object_list) {
         auto ps = PolySet::createEmpty();
-        std::string errmsg = import_3mf_mesh(filename, meshes.size(), model, mo, ps);
+        std::string errmsg =
+            import_3mf_mesh(filename, meshes.size(), model, mo, ps);
         if (errmsg.empty()) {
           if (ps->isEmpty()) {
             continue;
           }
         } else {
-          LOG(message_group::Warning, "%1$s, import() at line %2$d", errmsg, loc.firstLine());
+          LOG(message_group::Warning, "%1$s, import() at line %2$d", errmsg,
+              loc.firstLine());
           return PolySet::createEmpty();
         }
 
@@ -430,32 +484,38 @@ std::unique_ptr<PolySet> import_3mf(const std::string& filename, const Location&
       std::unique_ptr<PolySet> p;
       Geometry::Geometries children;
       while (!meshes.empty()) {
-        children.emplace_back(std::shared_ptr<AbstractNode>(), std::shared_ptr<const Geometry>(std::move(meshes.front())));
+        children.emplace_back(
+            std::shared_ptr<AbstractNode>(),
+            std::shared_ptr<const Geometry>(std::move(meshes.front())));
         meshes.pop_front();
       }
-  #ifdef ENABLE_MANIFOLD
-      if (RenderSettings::inst()->backend3D == RenderBackend3D::ManifoldBackend) {
-        if (auto ps = PolySetUtils::getGeometryAsPolySet(ManifoldUtils::applyOperator3DManifold(children, OpenSCADOperator::UNION))) {
+#ifdef ENABLE_MANIFOLD
+      if (RenderSettings::inst()->backend3D ==
+          RenderBackend3D::ManifoldBackend) {
+        if (auto ps = PolySetUtils::getGeometryAsPolySet(
+                ManifoldUtils::applyOperator3DManifold(
+                    children, OpenSCADOperator::UNION))) {
           p = std::make_unique<PolySet>(*ps);
         } else {
           p = PolySet::createEmpty();
         }
       } else
-  #endif // ifdef ENABLE_MANIFOLD
+#endif // ifdef ENABLE_MANIFOLD
       {
-  #ifdef ENABLE_CGAL
-        if (auto ps = PolySetUtils::getGeometryAsPolySet(CGALUtils::applyUnion3D(children.begin(), children.end()))) {
+#ifdef ENABLE_CGAL
+        if (auto ps = PolySetUtils::getGeometryAsPolySet(
+                CGALUtils::applyUnion3D(children.begin(), children.end()))) {
           p = std::make_unique<PolySet>(*ps);
         } else {
           p = PolySet::createEmpty();
         }
-  #else
+#else
         p = PolySet::createEmpty();
-  #endif // ifdef ENABLE_CGAL
+#endif // ifdef ENABLE_CGAL
       }
       return p;
     }
-  } catch (const Lib3MF::ELib3MFException& e) {
+  } catch (const Lib3MF::ELib3MFException &e) {
     LOG(message_group::Error, e.what());
     return nullptr;
   }
diff --git a/src/io/import_amf.cc b/src/io/import_amf.cc
index 63c0ef261..7b4be7870 100644
--- a/src/io/import_amf.cc
+++ b/src/io/import_amf.cc
@@ -24,35 +24,36 @@
  *
  */
 
-#include "geometry/PolySet.h"
+#include "core/AST.h"
+#include "core/Assignment.h"
+#include "core/CsgOpNode.h"
+#include "core/ModuleInstantiation.h"
 #include "geometry/Geometry.h"
+#include "geometry/PolySet.h"
 #include "geometry/PolySetBuilder.h"
 #include "geometry/PolySetUtils.h"
 #include "utils/printutils.h"
-#include "core/AST.h"
-#include "core/Assignment.h"
-#include "core/ModuleInstantiation.h"
-#include "core/CsgOpNode.h"
 
 #ifdef ENABLE_CGAL
 #include "geometry/cgal/cgalutils.h"
 #endif
 
-#include <utility>
-#include <memory>
-#include <sys/types.h>
+#include <boost/lexical_cast.hpp>
+#include <cassert>
 #include <cstddef>
+#include <filesystem>
+#include <libxml/xmlreader.h>
 #include <map>
-#include <cassert>
+#include <memory>
 #include <string>
+#include <sys/types.h>
+#include <utility>
 #include <vector>
-#include <libxml/xmlreader.h>
-#include <filesystem>
-#include <boost/lexical_cast.hpp>
 
 static const std::string text_node("#text");
 static const std::string object("/amf/object");
-static const std::string coordinates("/amf/object/mesh/vertices/vertex/coordinates");
+static const std::string
+    coordinates("/amf/object/mesh/vertices/vertex/coordinates");
 static const std::string coordinates_x = coordinates + "/x";
 static const std::string coordinates_y = coordinates + "/y";
 static const std::string coordinates_z = coordinates + "/z";
@@ -61,8 +62,7 @@ static const std::string triangle_v1 = triangle + "/v1";
 static const std::string triangle_v2 = triangle + "/v2";
 static const std::string triangle_v3 = triangle + "/v3";
 
-class AmfImporter
-{
+class AmfImporter {
 private:
   std::string xpath; // element nesting stack
 
@@ -94,90 +94,80 @@ private:
   void processNode(xmlTextReaderPtr reader);
 
 protected:
-  const Location& loc;
+  const Location &loc;
 
 public:
-  AmfImporter(const Location& loc);
+  AmfImporter(const Location &loc);
   virtual ~AmfImporter() = default;
-  std::unique_ptr<PolySet> read(const std::string& filename);
+  std::unique_ptr<PolySet> read(const std::string &filename);
 
   virtual xmlTextReaderPtr createXmlReader(const char *filename);
 };
 
-AmfImporter::AmfImporter(const Location& loc) : loc(loc)
-{
-}
+AmfImporter::AmfImporter(const Location &loc) : loc(loc) {}
 
-void AmfImporter::set_x(AmfImporter *importer, const xmlChar *value)
-{
+void AmfImporter::set_x(AmfImporter *importer, const xmlChar *value) {
   importer->x = boost::lexical_cast<double>(std::string((const char *)value));
 }
 
-void AmfImporter::set_y(AmfImporter *importer, const xmlChar *value)
-{
+void AmfImporter::set_y(AmfImporter *importer, const xmlChar *value) {
   importer->y = boost::lexical_cast<double>(std::string((const char *)value));
 }
 
-void AmfImporter::set_z(AmfImporter *importer, const xmlChar *value)
-{
+void AmfImporter::set_z(AmfImporter *importer, const xmlChar *value) {
   importer->z = boost::lexical_cast<double>(std::string((const char *)value));
 }
 
-void AmfImporter::set_v1(AmfImporter *importer, const xmlChar *value)
-{
+void AmfImporter::set_v1(AmfImporter *importer, const xmlChar *value) {
   importer->idx_v1 = boost::lexical_cast<int>(std::string((const char *)value));
 }
 
-void AmfImporter::set_v2(AmfImporter *importer, const xmlChar *value)
-{
+void AmfImporter::set_v2(AmfImporter *importer, const xmlChar *value) {
   importer->idx_v2 = boost::lexical_cast<int>(std::string((const char *)value));
 }
 
-void AmfImporter::set_v3(AmfImporter *importer, const xmlChar *value)
-{
+void AmfImporter::set_v3(AmfImporter *importer, const xmlChar *value) {
   importer->idx_v3 = boost::lexical_cast<int>(std::string((const char *)value));
 }
 
-void AmfImporter::start_object(AmfImporter *importer, const xmlChar *)
-{
+void AmfImporter::start_object(AmfImporter *importer, const xmlChar *) {
   importer->builder = std::make_unique<PolySetBuilder>(0, 0);
 }
 
-void AmfImporter::end_object(AmfImporter *importer, const xmlChar *)
-{
+void AmfImporter::end_object(AmfImporter *importer, const xmlChar *) {
   PRINTDB("AMF: add object %d", importer->polySets.size());
   importer->polySets.push_back(importer->builder->build());
   importer->vertex_list.clear();
   importer->builder.reset(nullptr);
 }
 
-void AmfImporter::end_vertex(AmfImporter *importer, const xmlChar *)
-{
-  PRINTDB("AMF: add vertex %d - (%.2f, %.2f, %.2f)", importer->vertex_list.size() % importer->x % importer->y % importer->z);
+void AmfImporter::end_vertex(AmfImporter *importer, const xmlChar *) {
+  PRINTDB("AMF: add vertex %d - (%.2f, %.2f, %.2f)",
+          importer->vertex_list.size() % importer->x % importer->y %
+              importer->z);
   importer->vertex_list.emplace_back(importer->x, importer->y, importer->z);
 }
 
-void AmfImporter::end_triangle(AmfImporter *importer, const xmlChar *)
-{
+void AmfImporter::end_triangle(AmfImporter *importer, const xmlChar *) {
   int idx[3] = {importer->idx_v1, importer->idx_v2, importer->idx_v3};
-  PRINTDB("AMF: add triangle %d - (%.2f, %.2f, %.2f)", importer->vertex_list.size() % idx[0] % idx[1] % idx[2]);
+  PRINTDB("AMF: add triangle %d - (%.2f, %.2f, %.2f)",
+          importer->vertex_list.size() % idx[0] % idx[1] % idx[2]);
 
-  std::vector<Eigen::Vector3d>& v = importer->vertex_list;
+  std::vector<Eigen::Vector3d> &v = importer->vertex_list;
 
   importer->builder->beginPolygon(3);
-  for (auto i : idx)// TODO set vertex array first
+  for (auto i : idx) // TODO set vertex array first
     importer->builder->addVertex(Vector3d(v[i].x(), v[i].y(), v[i].z()));
 }
 
-void AmfImporter::processNode(xmlTextReaderPtr reader)
-{
+void AmfImporter::processNode(xmlTextReaderPtr reader) {
   const char *name = reinterpret_cast<const char *>(xmlTextReaderName(reader));
-  if (name == nullptr) name = reinterpret_cast<const char *>(xmlStrdup(BAD_CAST "--"));
+  if (name == nullptr)
+    name = reinterpret_cast<const char *>(xmlStrdup(BAD_CAST "--"));
   xmlChar *value = xmlTextReaderValue(reader);
   int node_type = xmlTextReaderNodeType(reader);
   switch (node_type) {
-  case XML_READER_TYPE_ELEMENT:
-  {
+  case XML_READER_TYPE_ELEMENT: {
     xpath += '/';
     xpath += name;
     cb_func startFunc = start_funcs[xpath];
@@ -185,47 +175,45 @@ void AmfImporter::processNode(xmlTextReaderPtr reader)
       PRINTDB("AMF: start %s", xpath);
       startFunc(this, nullptr);
     }
-  }
-  break;
-  case XML_READER_TYPE_END_ELEMENT:
-  {
+  } break;
+  case XML_READER_TYPE_END_ELEMENT: {
     cb_func endFunc = end_funcs[xpath];
     if (endFunc) {
       PRINTDB("AMF: end   %s", xpath);
       endFunc(this, value);
     }
     size_t pos = xpath.find_last_of('/');
-    if (pos != std::string::npos) xpath.erase(pos);
-  }
-  break;
-  case XML_READER_TYPE_TEXT:
-  {
+    if (pos != std::string::npos)
+      xpath.erase(pos);
+  } break;
+  case XML_READER_TYPE_TEXT: {
     cb_func textFunc = funcs[xpath];
     if (textFunc) {
       PRINTDB("AMF: text  %s - '%s'", xpath % value);
       textFunc(this, value);
     }
-  }
-  break;
+  } break;
   }
 
   xmlFree(value);
-  xmlFree((void *) (name));
+  xmlFree((void *)(name));
 }
 
-xmlTextReaderPtr AmfImporter::createXmlReader(const char *filename)
-{
-  return xmlReaderForFile(filename, nullptr, XML_PARSE_NOENT | XML_PARSE_NOERROR | XML_PARSE_NOWARNING);
+xmlTextReaderPtr AmfImporter::createXmlReader(const char *filename) {
+  return xmlReaderForFile(filename, nullptr,
+                          XML_PARSE_NOENT | XML_PARSE_NOERROR |
+                              XML_PARSE_NOWARNING);
 }
 
-int AmfImporter::streamFile(const char *filename)
-{
+int AmfImporter::streamFile(const char *filename) {
   int ret;
 
   xmlTextReaderPtr reader = createXmlReader(filename);
 
   if (reader == nullptr) {
-    LOG(message_group::Warning, "Can't open import file '%1$s', import() at line %2$d", filename, this->loc.firstLine());
+    LOG(message_group::Warning,
+        "Can't open import file '%1$s', import() at line %2$d", filename,
+        this->loc.firstLine());
     return 1;
   }
 
@@ -237,17 +225,18 @@ int AmfImporter::streamFile(const char *filename)
       ret = xmlTextReaderRead(reader);
     }
     xmlFreeTextReader(reader);
-  } catch (boost::bad_lexical_cast&) {
+  } catch (boost::bad_lexical_cast &) {
     ret = -1;
   }
   if (ret != 0) {
-    LOG(message_group::Warning, "Failed to parse file '%1$s', import() at line %2$d", filename, this->loc.firstLine());
+    LOG(message_group::Warning,
+        "Failed to parse file '%1$s', import() at line %2$d", filename,
+        this->loc.firstLine());
   }
   return ret;
 }
 
-std::unique_ptr<PolySet> AmfImporter::read(const std::string& filename)
-{
+std::unique_ptr<PolySet> AmfImporter::read(const std::string &filename) {
   funcs[coordinates_x] = set_x;
   funcs[coordinates_y] = set_y;
   funcs[coordinates_z] = set_z;
@@ -269,18 +258,22 @@ std::unique_ptr<PolySet> AmfImporter::read(const std::string& filename)
   }
   if (polySets.size() > 1) {
     Geometry::Geometries children;
-    for (auto& polySet : polySets) {
-      children.push_back(std::make_pair(std::shared_ptr<AbstractNode>(), std::move(polySet)));
+    for (auto &polySet : polySets) {
+      children.push_back(
+          std::make_pair(std::shared_ptr<AbstractNode>(), std::move(polySet)));
     }
 
 #ifdef ENABLE_CGAL
-    std::unique_ptr<const Geometry> geom = CGALUtils::applyUnion3D(children.begin(), children.end());
+    std::unique_ptr<const Geometry> geom =
+        CGALUtils::applyUnion3D(children.begin(), children.end());
     if (auto ps = PolySetUtils::getGeometryAsPolySet(std::move(geom))) {
       // FIXME: Unnecessary copy
       return std::make_unique<PolySet>(*ps);
     } else
 #endif // ENABLE_CGAL
-    LOG(message_group::Error, "Error importing multi-object AMF file '%1$s', import() at line %2$d", filename, this->loc.firstLine());
+      LOG(message_group::Error,
+          "Error importing multi-object AMF file '%1$s', import() at line %2$d",
+          filename, this->loc.firstLine());
   }
   return PolySet::createEmpty();
 }
@@ -289,57 +282,58 @@ std::unique_ptr<PolySet> AmfImporter::read(const std::string& filename)
 
 #include <zip.h>
 
-class AmfImporterZIP : public AmfImporter
-{
+class AmfImporterZIP : public AmfImporter {
 private:
-  struct zip *archive {nullptr};
-  struct zip_file *zipfile {nullptr};
+  struct zip *archive{nullptr};
+  struct zip_file *zipfile{nullptr};
 
   static int read_callback(void *context, char *buffer, int len);
   static int close_callback(void *context);
 
 public:
-  AmfImporterZIP(const Location& loc);
+  AmfImporterZIP(const Location &loc);
 
   xmlTextReaderPtr createXmlReader(const char *filename) override;
 };
 
-AmfImporterZIP::AmfImporterZIP(const Location& loc) : AmfImporter(loc)
-{
-}
+AmfImporterZIP::AmfImporterZIP(const Location &loc) : AmfImporter(loc) {}
 
-int AmfImporterZIP::read_callback(void *context, char *buffer, int len)
-{
+int AmfImporterZIP::read_callback(void *context, char *buffer, int len) {
   auto *importer = (AmfImporterZIP *)context;
   return zip_fread(importer->zipfile, buffer, len);
 }
 
-int AmfImporterZIP::close_callback(void *context)
-{
+int AmfImporterZIP::close_callback(void *context) {
   auto *importer = (AmfImporterZIP *)context;
   return zip_fclose(importer->zipfile);
 }
 
-xmlTextReaderPtr AmfImporterZIP::createXmlReader(const char *filepath)
-{
+xmlTextReaderPtr AmfImporterZIP::createXmlReader(const char *filepath) {
   archive = zip_open(filepath, 0, nullptr);
   if (archive) {
-    // Separate the filename without using filesystem::path because that gives wide result on Windows TM
+    // Separate the filename without using filesystem::path because that gives
+    // wide result on Windows TM
     const char *last_slash = strrchr(filepath, '/');
     const char *last_bslash = strrchr(filepath, '\\');
-    if (last_bslash > last_slash) last_slash = last_bslash;
+    if (last_bslash > last_slash)
+      last_slash = last_bslash;
     const char *filename = last_slash ? last_slash + 1 : filepath;
     zipfile = zip_fopen(archive, filename, ZIP_FL_NODIR);
     if (zipfile == nullptr) {
-      LOG(message_group::Warning, "Can't read file '%1$s' from zipped AMF '%2$s', import() at line %3$d", filename, filepath, this->loc.firstLine());
+      LOG(message_group::Warning,
+          "Can't read file '%1$s' from zipped AMF '%2$s', import() at line "
+          "%3$d",
+          filename, filepath, this->loc.firstLine());
     }
     if ((zipfile == nullptr) && (zip_get_num_entries(archive, 0) == 1)) {
-      LOG(message_group::Warning, "Trying to read single entry '%1$s'", zip_get_name(archive, 0, 0));
+      LOG(message_group::Warning, "Trying to read single entry '%1$s'",
+          zip_get_name(archive, 0, 0));
       zipfile = zip_fopen_index(archive, 0, 0);
     }
     if (zipfile) {
-      return xmlReaderForIO(read_callback, close_callback, this, filename, nullptr,
-                            XML_PARSE_NOENT | XML_PARSE_NOERROR | XML_PARSE_NOWARNING);
+      return xmlReaderForIO(
+          read_callback, close_callback, this, filename, nullptr,
+          XML_PARSE_NOENT | XML_PARSE_NOERROR | XML_PARSE_NOWARNING);
     } else {
       zip_close(archive);
       zipfile = nullptr;
@@ -350,16 +344,20 @@ xmlTextReaderPtr AmfImporterZIP::createXmlReader(const char *filepath)
   }
 }
 
-std::unique_ptr<PolySet> import_amf(const std::string& filename, const Location& loc) {
-  LOG(message_group::Deprecated, "AMF import is deprecated. Please use 3MF instead.");
+std::unique_ptr<PolySet> import_amf(const std::string &filename,
+                                    const Location &loc) {
+  LOG(message_group::Deprecated,
+      "AMF import is deprecated. Please use 3MF instead.");
   AmfImporterZIP importer(loc);
   return importer.read(filename);
 }
 
 #else
 
-std::unique_ptr<PolySet> import_amf(const std::string& filename, const Location& loc) {
-  LOG(message_group::Deprecated, "AMF import is deprecated. Please use 3MF instead.");
+std::unique_ptr<PolySet> import_amf(const std::string &filename,
+                                    const Location &loc) {
+  LOG(message_group::Deprecated,
+      "AMF import is deprecated. Please use 3MF instead.");
   AmfImporter importer(loc);
   return importer.read(filename);
 }
diff --git a/src/io/import_json.cc b/src/io/import_json.cc
index e0e0e4460..cb72cf2ad 100644
--- a/src/io/import_json.cc
+++ b/src/io/import_json.cc
@@ -41,10 +41,9 @@ using json = nlohmann::json;
 
 namespace {
 
-ObjectType to_obj(const json& j, EvaluationSession *session);
+ObjectType to_obj(const json &j, EvaluationSession *session);
 
-Value to_value(const json& j, EvaluationSession *session)
-{
+Value to_value(const json &j, EvaluationSession *session) {
   if (j.is_string()) {
     return Value{j.get<std::string>()};
   } else if (j.is_number()) {
@@ -55,7 +54,7 @@ Value to_value(const json& j, EvaluationSession *session)
     return Value{to_obj(j, session)};
   } else if (j.is_array()) {
     Value::VectorType vec{session};
-    for (const auto& elem : j) {
+    for (const auto &elem : j) {
       vec.emplace_back(to_value(elem, session));
     }
     return std::move(vec);
@@ -63,10 +62,9 @@ Value to_value(const json& j, EvaluationSession *session)
   return Value::undefined.clone();
 }
 
-ObjectType to_obj(const json& j, EvaluationSession *session)
-{
+ObjectType to_obj(const json &j, EvaluationSession *session) {
   ObjectType obj{session};
-  for (const auto& item : j.items()) {
+  for (const auto &item : j.items()) {
     obj.set(item.key(), to_value(item.value(), session));
   }
   return obj;
@@ -74,8 +72,8 @@ ObjectType to_obj(const json& j, EvaluationSession *session)
 
 } // namespace
 
-Value import_json(const std::string& filename, EvaluationSession *session, const Location& loc)
-{
+Value import_json(const std::string &filename, EvaluationSession *session,
+                  const Location &loc) {
   std::ifstream i(filename);
 
   try {
@@ -84,10 +82,12 @@ Value import_json(const std::string& filename, EvaluationSession *session, const
       i >> j;
       return Value{to_value(j, session)};
     } else {
-      LOG(message_group::Warning, loc, "", "Could not read file '%1$s'", filename);
+      LOG(message_group::Warning, loc, "", "Could not read file '%1$s'",
+          filename);
     }
-  } catch (const std::exception& e) {
-    LOG(message_group::Warning, loc, "", "Failed to parse file '%1$s': %s", filename, e.what());
+  } catch (const std::exception &e) {
+    LOG(message_group::Warning, loc, "", "Failed to parse file '%1$s': %s",
+        filename, e.what());
   }
 
   return Value::undefined.clone();
diff --git a/src/io/import_nef.cc b/src/io/import_nef.cc
index de4c41e35..fdfa0149d 100644
--- a/src/io/import_nef.cc
+++ b/src/io/import_nef.cc
@@ -9,16 +9,18 @@
 #include "utils/printutils.h"
 
 #ifdef ENABLE_CGAL
-#include "geometry/cgal/cgal.h"
 #include "geometry/cgal/CGALNefGeometry.h"
+#include "geometry/cgal/cgal.h"
 #include <CGAL/IO/Nef_polyhedron_iostream_3.h>
 
-std::unique_ptr<CGALNefGeometry> import_nef3(const std::string& filename, const Location& loc)
-{
+std::unique_ptr<CGALNefGeometry> import_nef3(const std::string &filename,
+                                             const Location &loc) {
   // Open file and position at the end
   std::ifstream f(filename.c_str(), std::ios::in | std::ios::binary);
   if (!f.good()) {
-    LOG(message_group::Warning, "Can't open import file '%1$s', import() at line %2$d", filename, loc.firstLine());
+    LOG(message_group::Warning,
+        "Can't open import file '%1$s', import() at line %2$d", filename,
+        loc.firstLine());
     return std::make_unique<CGALNefGeometry>();
   }
 
@@ -26,8 +28,10 @@ std::unique_ptr<CGALNefGeometry> import_nef3(const std::string& filename, const
     auto nef = std::make_shared<CGAL_Nef_polyhedron3>();
     f >> *nef;
     return std::make_unique<CGALNefGeometry>(nef);
-  } catch (const CGAL::Failure_exception& e) {
-    LOG(message_group::Warning, "Failure trying to import '%1$s', import() at line %2$d", filename, loc.firstLine());
+  } catch (const CGAL::Failure_exception &e) {
+    LOG(message_group::Warning,
+        "Failure trying to import '%1$s', import() at line %2$d", filename,
+        loc.firstLine());
     LOG(e.what());
     return std::make_unique<CGALNefGeometry>();
   }
diff --git a/src/io/import_obj.cc b/src/io/import_obj.cc
index 1e2ecb993..f6bae17e7 100644
--- a/src/io/import_obj.cc
+++ b/src/io/import_obj.cc
@@ -13,19 +13,20 @@
 #include <boost/regex.hpp>
 
 #include "core/AST.h"
-#include "geometry/linalg.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetBuilder.h"
+#include "geometry/linalg.h"
 #include "utils/printutils.h"
 
-std::unique_ptr<PolySet> import_obj(const std::string& filename, const Location& loc) {
+std::unique_ptr<PolySet> import_obj(const std::string &filename,
+                                    const Location &loc) {
   PolySetBuilder builder;
 
   std::ifstream f(filename.c_str(), std::ios::in | std::ios::binary);
   if (!f.good()) {
     LOG(message_group::Warning,
-        "Can't open import file '%1$s', import() at line %2$d",
-        filename, loc.firstLine());
+        "Can't open import file '%1$s', import() at line %2$d", filename,
+        loc.firstLine());
     return PolySet::createEmpty();
   }
   const boost::regex ex_comment(R"(^\s*#)");
@@ -41,11 +42,11 @@ std::unique_ptr<PolySet> import_obj(const std::string& filename, const Location&
   int lineno = 1;
   std::string line;
 
-  auto AsciiError = [&](const auto& errstr){
-      LOG(message_group::Error, loc, "",
-          "OBJ File line %1$s, %2$s line '%3$s' importing file '%4$s'",
-          lineno, errstr, line, filename);
-    };
+  auto AsciiError = [&](const auto &errstr) {
+    LOG(message_group::Error, loc, "",
+        "OBJ File line %1$s, %2$s line '%3$s' importing file '%4$s'", lineno,
+        errstr, line, filename);
+  };
   std::vector<int> vertex_map;
 
   while (!f.eof()) {
@@ -56,44 +57,53 @@ std::unique_ptr<PolySet> import_obj(const std::string& filename, const Location&
     boost::smatch results;
     if (line.length() == 0 || boost::regex_search(line, ex_comment)) {
       continue;
-    } else if (boost::regex_search(line, results, ex_v) && results.size() >= 4) {
+    } else if (boost::regex_search(line, results, ex_v) &&
+               results.size() >= 4) {
       try {
         Vector3d v;
         for (int i = 0; i < 3; i++) {
           v[i] = boost::lexical_cast<double>(results[i + 1]);
         }
         vertex_map.push_back(builder.vertexIndex(v));
-      } catch (const boost::bad_lexical_cast& blc) {
+      } catch (const boost::bad_lexical_cast &blc) {
         AsciiError("can't parse vertex");
         return PolySet::createEmpty();
       }
-    } else if (boost::regex_search(line, results, ex_f) && results.size() >= 2) {
+    } else if (boost::regex_search(line, results, ex_f) &&
+               results.size() >= 2) {
       std::vector<std::string> words;
       boost::split(words, results[1], boost::is_any_of(" \t"));
       builder.beginPolygon(words.size());
-      for (const std::string& word : words) {
+      for (const std::string &word : words) {
         std::vector<std::string> wordindex;
         boost::split(wordindex, word, boost::is_any_of("/"));
-        if (wordindex.size() < 1)LOG(message_group::Warning, "Invalid Face index in File %1$s in Line %2$d", filename, lineno);
+        if (wordindex.size() < 1)
+          LOG(message_group::Warning,
+              "Invalid Face index in File %1$s in Line %2$d", filename, lineno);
         else {
           const size_t ind = boost::lexical_cast<int>(wordindex[0]);
           if (ind >= 1 && ind <= vertex_map.size()) {
             builder.addVertex(vertex_map[ind - 1]);
           } else {
-            LOG(message_group::Warning, "Index %1$d out of range in Line %2$d", filename, lineno);
+            LOG(message_group::Warning, "Index %1$d out of range in Line %2$d",
+                filename, lineno);
           }
         }
       }
 
-    } else if (boost::regex_search(line, results, ex_vt)) { // ignore texture coords
-    } else if (boost::regex_search(line, results, ex_vn)) { // ignore normal coords
-    } else if (boost::regex_search(line, results, ex_mtllib)) { // ignore material lib
+    } else if (boost::regex_search(line, results,
+                                   ex_vt)) { // ignore texture coords
+    } else if (boost::regex_search(line, results,
+                                   ex_vn)) { // ignore normal coords
+    } else if (boost::regex_search(line, results,
+                                   ex_mtllib)) { // ignore material lib
     } else if (boost::regex_search(line, results, ex_usemtl)) { // ignore usemtl
     } else if (boost::regex_search(line, results, ex_o)) { // ignore object name
     } else if (boost::regex_search(line, results, ex_s)) { // ignore smooting
     } else if (boost::regex_search(line, results, ex_g)) { // ignore group name
     } else {
-      LOG(message_group::Warning, "Unrecognized Line  %1$s in line Line %2$d", line, lineno);
+      LOG(message_group::Warning, "Unrecognized Line  %1$s in line Line %2$d",
+          line, lineno);
     }
   }
   return builder.build();
diff --git a/src/io/import_off.cc b/src/io/import_off.cc
index d57435c14..b23037457 100644
--- a/src/io/import_off.cc
+++ b/src/io/import_off.cc
@@ -5,11 +5,11 @@
 #include <cstdint>
 #include <cstdio>
 #include <fstream>
-#include <locale>
 #include <ios>
-#include <sstream>
+#include <locale>
 #include <map>
 #include <memory>
+#include <sstream>
 #include <string>
 #include <vector>
 
@@ -19,15 +19,15 @@
 #include <boost/regex.hpp>
 
 #include "core/AST.h"
-#include "geometry/linalg.h"
 #include "geometry/PolySet.h"
+#include "geometry/linalg.h"
 #include "utils/printutils.h"
 
 // References:
 // http://www.geomview.org/docs/html/OFF.html
 
-std::unique_ptr<PolySet> import_off(const std::string& filename, const Location& loc)
-{
+std::unique_ptr<PolySet> import_off(const std::string &filename,
+                                    const Location &loc) {
   const boost::regex ex_magic(R"(^(ST)?(C)?(N)?(4)?(n)?OFF( BINARY)? *)");
   // XXX: are ST C N always in order?
   const boost::regex ex_cr(R"(\r$)");
@@ -39,61 +39,61 @@ std::unique_ptr<PolySet> import_off(const std::string& filename, const Location&
   int lineno = 0;
   std::string line;
 
-  auto AsciiError = [&](const auto& errstr){
-      LOG(message_group::Error, loc, "",
-          "OFF File line %1$s, %2$s line '%3$s' importing file '%4$s'",
-          lineno, errstr, line, filename);
-    };
-
-  auto getline_clean = [&](const auto& errstr){
-      do {
-        lineno++;
-        std::getline(f, line);
-        if (line.empty() && f.eof()) {
-          AsciiError(errstr);
-          return false;
-        }
-        // strip DOS line endings
-        if (boost::regex_search(line, results, ex_cr)) {
-          line = line.erase(results.position(), results[0].length());
-        }
-        // strip comments
-        if (boost::regex_search(line, results, ex_comment)) {
-          line = line.erase(results.position(), results[0].length());
-        }
-        boost::trim(line);
-      } while (line.empty());
+  auto AsciiError = [&](const auto &errstr) {
+    LOG(message_group::Error, loc, "",
+        "OFF File line %1$s, %2$s line '%3$s' importing file '%4$s'", lineno,
+        errstr, line, filename);
+  };
+
+  auto getline_clean = [&](const auto &errstr) {
+    do {
+      lineno++;
+      std::getline(f, line);
+      if (line.empty() && f.eof()) {
+        AsciiError(errstr);
+        return false;
+      }
+      // strip DOS line endings
+      if (boost::regex_search(line, results, ex_cr)) {
+        line = line.erase(results.position(), results[0].length());
+      }
+      // strip comments
+      if (boost::regex_search(line, results, ex_comment)) {
+        line = line.erase(results.position(), results[0].length());
+      }
+      boost::trim(line);
+    } while (line.empty());
 
-      return true;
-    };
+    return true;
+  };
 
-  auto getcolor = [&](const auto& word){
-      int c;
-      if (boost::contains(word, ".")) {
-        float f;
+  auto getcolor = [&](const auto &word) {
+    int c;
+    if (boost::contains(word, ".")) {
+      float f;
 #ifdef __cpp_lib_to_chars
-        auto result = std::from_chars(word.data(), word.data() + word.length(), f);
-        if (result.ec != std::errc{}) {
-          AsciiError("Parse error");
-          return 0;
-        }
+      auto result =
+          std::from_chars(word.data(), word.data() + word.length(), f);
+      if (result.ec != std::errc{}) {
+        AsciiError("Parse error");
+        return 0;
+      }
 #else
-        // fall back for pre C++17
-        std::istringstream istr(word);
-        istr.imbue(std::locale("C"));
-        istr >> f;
-        if (istr.peek() != EOF) {
-          AsciiError("Parse error");
-          return 0;
-        }
-#endif // ifdef __cpp_lib_to_chars
-        c = (int)(f * 255);
-      } else {
-        c = boost::lexical_cast<int>(word);
+      // fall back for pre C++17
+      std::istringstream istr(word);
+      istr.imbue(std::locale("C"));
+      istr >> f;
+      if (istr.peek() != EOF) {
+        AsciiError("Parse error");
+        return 0;
       }
-      return c;
-    };
-
+#endif // ifdef __cpp_lib_to_chars
+      c = (int)(f * 255);
+    } else {
+      c = boost::lexical_cast<int>(word);
+    }
+    return c;
+  };
 
   if (!f.good()) {
     AsciiError("File error");
@@ -119,7 +119,8 @@ std::unique_ptr<PolySet> import_off(const std::string& filename, const Location&
     has_color = results[2].matched;
     has_textures = results[1].matched;
     is_binary = results[6].matched;
-    if (results[4].matched)dimension = 4;
+    if (results[4].matched)
+      dimension = 4;
     has_ndim = results[5].matched;
   }
 
@@ -135,7 +136,8 @@ std::unique_ptr<PolySet> import_off(const std::string& filename, const Location&
     if (line.empty() && !getline_clean("bad header: end of file")) {
       return PolySet::createEmpty();
     }
-    boost::split(words, line, boost::is_any_of(" \t"), boost::token_compress_on);
+    boost::split(words, line, boost::is_any_of(" \t"),
+                 boost::token_compress_on);
     if (f.eof() || words.size() < 1) {
       AsciiError("bad header: missing Ndim");
       return PolySet::createEmpty();
@@ -143,16 +145,19 @@ std::unique_ptr<PolySet> import_off(const std::string& filename, const Location&
     line = line.erase(0, words[0].length() + ((words.size() > 1) ? 1 : 0));
     try {
       dimension = boost::lexical_cast<unsigned int>(words[0]) + dimension - 3;
-    } catch (const boost::bad_lexical_cast& blc) {
+    } catch (const boost::bad_lexical_cast &blc) {
       AsciiError("bad header: bad data for Ndim");
       return PolySet::createEmpty();
     }
   }
 
-  PRINTDB("Header flags: N:%d C:%d ST:%d Ndim:%d B:%d", has_normals % has_color % has_textures % dimension % is_binary);
+  PRINTDB("Header flags: N:%d C:%d ST:%d Ndim:%d B:%d",
+          has_normals % has_color % has_textures % dimension % is_binary);
 
   if (dimension != 3) {
-    AsciiError((boost::format("unhandled vertex dimensions (%d)") % dimension).str().c_str());
+    AsciiError((boost::format("unhandled vertex dimensions (%d)") % dimension)
+                   .str()
+                   .c_str());
     return PolySet::createEmpty();
   }
 
@@ -176,7 +181,7 @@ std::unique_ptr<PolySet> import_off(const std::string& filename, const Location&
     faces_count = boost::lexical_cast<unsigned long>(words[1]);
     edges_count = boost::lexical_cast<unsigned long>(words[2]);
     (void)edges_count; // ignored
-  } catch (const boost::bad_lexical_cast& blc) {
+  } catch (const boost::bad_lexical_cast &blc) {
     AsciiError("bad header: bad data");
     return PolySet::createEmpty();
   }
@@ -186,7 +191,8 @@ std::unique_ptr<PolySet> import_off(const std::string& filename, const Location&
     return PolySet::createEmpty();
   }
 
-  PRINTDB("%d vertices, %d faces, %d edges.", vertices_count % faces_count % edges_count);
+  PRINTDB("%d vertices, %d faces, %d edges.",
+          vertices_count % faces_count % edges_count);
 
   auto ps = PolySet::createEmpty();
   ps->vertices.reserve(vertices_count);
@@ -197,7 +203,8 @@ std::unique_ptr<PolySet> import_off(const std::string& filename, const Location&
       return PolySet::createEmpty();
     }
 
-    boost::split(words, line, boost::is_any_of(" \t"), boost::token_compress_on);
+    boost::split(words, line, boost::is_any_of(" \t"),
+                 boost::token_compress_on);
     if (words.size() < 3) {
       AsciiError("can't parse vertex: not enough data");
       return PolySet::createEmpty();
@@ -209,7 +216,7 @@ std::unique_ptr<PolySet> import_off(const std::string& filename, const Location&
       for (i = 0; i < dimension; i++) {
         v[i] = boost::lexical_cast<double>(words[i]);
       }
-      //PRINTDB("Vertex[%ld] = { %f, %f, %f }", vertex % v[0] % v[1] % v[2]);
+      // PRINTDB("Vertex[%ld] = { %f, %f, %f }", vertex % v[0] % v[1] % v[2]);
       if (has_normals) {
         // TODO words[i++]
         i += 0;
@@ -222,7 +229,7 @@ std::unique_ptr<PolySet> import_off(const std::string& filename, const Location&
         // TODO words[i++]
       }
       ps->vertices.push_back(v);
-    } catch (const boost::bad_lexical_cast& blc) {
+    } catch (const boost::bad_lexical_cast &blc) {
       AsciiError("can't parse vertex: bad data");
       return PolySet::createEmpty();
     }
@@ -235,7 +242,8 @@ std::unique_ptr<PolySet> import_off(const std::string& filename, const Location&
       return PolySet::createEmpty();
     }
 
-    boost::split(words, line, boost::is_any_of(" \t"), boost::token_compress_on);
+    boost::split(words, line, boost::is_any_of(" \t"),
+                 boost::token_compress_on);
     if (words.size() < 1) {
       AsciiError("can't parse face: not enough data");
       return PolySet::createEmpty();
@@ -251,17 +259,19 @@ std::unique_ptr<PolySet> import_off(const std::string& filename, const Location&
       }
       const size_t face_idx = ps->indices.size();
       ps->indices.emplace_back().reserve(face_size);
-      //PRINTDB("Index[%d] [%d] = { ", face % n);
+      // PRINTDB("Index[%d] [%d] = { ", face % n);
       for (i = 0; i < face_size; i++) {
         int ind = boost::lexical_cast<int>(words[i + 1]);
-        //PRINTDB("%d, ", ind);
+        // PRINTDB("%d, ", ind);
         if (ind >= 0 && ind < vertices_count) {
           ps->indices.back().push_back(ind);
         } else {
-          AsciiError((boost::format("ignored bad face vertex index: %d") % ind).str().c_str());
+          AsciiError((boost::format("ignored bad face vertex index: %d") % ind)
+                         .str()
+                         .c_str());
         }
       }
-      //PRINTD("}");
+      // PRINTD("}");
       if (words.size() >= face_size + 4) {
         i = face_size + 1;
         // handle optional color info (r g b [a])
@@ -271,12 +281,14 @@ std::unique_ptr<PolySet> import_off(const std::string& filename, const Location&
         const int a = i < words.size() ? getcolor(words[i++]) : 255;
         const Color4f color(r, g, b, a);
 
-        auto iter_pair = color_indices.insert_or_assign(color, ps->colors.size());
-        if (iter_pair.second) ps->colors.push_back(color); // inserted
+        auto iter_pair =
+            color_indices.insert_or_assign(color, ps->colors.size());
+        if (iter_pair.second)
+          ps->colors.push_back(color); // inserted
         ps->color_indices.resize(face_idx, -1);
         ps->color_indices.push_back(iter_pair.first->second);
       }
-    } catch (const boost::bad_lexical_cast& blc) {
+    } catch (const boost::bad_lexical_cast &blc) {
       AsciiError("can't parse face: bad data");
       return PolySet::createEmpty();
     }
@@ -285,6 +297,7 @@ std::unique_ptr<PolySet> import_off(const std::string& filename, const Location&
     ps->color_indices.resize(ps->indices.size(), -1);
   }
 
-  //PRINTDB("PS: %ld vertices, %ld indices", ps->vertices.size() % ps->indices.size());
+  // PRINTDB("PS: %ld vertices, %ld indices", ps->vertices.size() %
+  // ps->indices.size());
   return ps;
 }
diff --git a/src/io/import_stl.cc b/src/io/import_stl.cc
index 8ef70aea0..40ad4ab50 100644
--- a/src/io/import_stl.cc
+++ b/src/io/import_stl.cc
@@ -18,7 +18,8 @@
 #include "geometry/PolySetBuilder.h"
 #include "utils/printutils.h"
 
-#if !defined(BOOST_ENDIAN_BIG_BYTE_AVAILABLE) && !defined(BOOST_ENDIAN_LITTLE_BYTE_AVAILABLE)
+#if !defined(BOOST_ENDIAN_BIG_BYTE_AVAILABLE) &&                               \
+    !defined(BOOST_ENDIAN_LITTLE_BYTE_AVAILABLE)
 #error Byte order undefined or unknown. Currently only BOOST_ENDIAN_BIG_BYTE and BOOST_ENDIAN_LITTLE_BYTE are supported.
 #endif
 
@@ -27,7 +28,7 @@ inline constexpr size_t STL_FACET_NUMBYTES = 4ul * 3ul * 4ul + 2ul;
 // is a 'binary32' aka 'single' standard IEEE 32-bit floating point type
 union stl_facet {
   static_assert(sizeof(unsigned char) == sizeof(uint8_t), "existence check");
-  unsigned char data8[ STL_FACET_NUMBYTES ];
+  unsigned char data8[STL_FACET_NUMBYTES];
   struct facet_data {
     float i, j, k;
     float x1, y1, z1;
@@ -37,29 +38,30 @@ union stl_facet {
   } data;
 };
 
-static_assert(offsetof(stl_facet::facet_data, attribute_byte_count) == 4ul * 3ul * 4ul,
+static_assert(offsetof(stl_facet::facet_data, attribute_byte_count) ==
+                  4ul * 3ul * 4ul,
               "Invalid padding in stl_facet");
 
 #if BOOST_ENDIAN_BIG_BYTE
 static void uint32_byte_swap(unsigned char *p) {
-# if (__GNUC__ >= 4 && __GNUC_MINOR__ >= 3) || defined(__clang__)
-  uint32_t& x = *reinterpret_cast<uint32_t *>(p);
+#if (__GNUC__ >= 4 && __GNUC_MINOR__ >= 3) || defined(__clang__)
+  uint32_t &x = *reinterpret_cast<uint32_t *>(p);
   x = __builtin_bswap32(x);
-# elif defined(_MSC_VER)
-  uint32_t& x = *reinterpret_cast<uint32_t *>(p);
+#elif defined(_MSC_VER)
+  uint32_t &x = *reinterpret_cast<uint32_t *>(p);
   x = _byteswap_ulong(x);
-# else
+#else
   std::swap(*p, *(p + 3));
   std::swap(*(p + 1), *(p + 2));
-# endif
+#endif
 }
 
-static void uint32_byte_swap(uint32_t& x) {
+static void uint32_byte_swap(uint32_t &x) {
   uint32_byte_swap(reinterpret_cast<unsigned char *>(&x));
 }
 #endif // if BOOST_ENDIAN_BIG_BYTE
 
-static void read_stl_facet(std::ifstream& f, stl_facet& facet) {
+static void read_stl_facet(std::ifstream &f, stl_facet &facet) {
   f.read((char *)facet.data8, STL_FACET_NUMBYTES);
   if (static_cast<size_t>(f.gcount()) < STL_FACET_NUMBYTES) {
     throw std::ios_base::failure("facet data truncated");
@@ -72,13 +74,15 @@ static void read_stl_facet(std::ifstream& f, stl_facet& facet) {
 #endif
 }
 
-std::unique_ptr<PolySet> import_stl(const std::string& filename, const Location& loc) {
+std::unique_ptr<PolySet> import_stl(const std::string &filename,
+                                    const Location &loc) {
   // Open file and position at the end
-  std::ifstream f(filename.c_str(), std::ios::in | std::ios::binary | std::ios::ate);
+  std::ifstream f(filename.c_str(),
+                  std::ios::in | std::ios::binary | std::ios::ate);
   if (!f.good()) {
     LOG(message_group::Warning,
-        "Can't open import file '%1$s', import() at line %2$d",
-        filename, loc.firstLine());
+        "Can't open import file '%1$s', import() at line %2$d", filename,
+        loc.firstLine());
     return PolySet::createEmpty();
   }
 
@@ -88,7 +92,7 @@ std::unique_ptr<PolySet> import_stl(const std::string& filename, const Location&
   const boost::regex ex_loopend("^\\s*endloop$");
   const boost::regex ex_vertex("^\\s*vertex");
   const boost::regex ex_vertices(
-    R"(^\s*vertex\s+([^\s]+)\s+([^\s]+)\s+([^\s]+)\s*$)");
+      R"(^\s*vertex\s+([^\s]+)\s+([^\s]+)\s+([^\s]+)\s*$)");
   const boost::regex ex_endsolid("^\\s*endsolid");
 
   bool binary = false;
@@ -103,7 +107,8 @@ std::unique_ptr<PolySet> import_stl(const std::string& filename, const Location&
       binary = true;
     }
   }
-  if (!binary)facenum = 0;
+  if (!binary)
+    facenum = 0;
   PolySetBuilder builder(0, facenum);
   f.seekg(0);
 
@@ -115,11 +120,11 @@ std::unique_ptr<PolySet> import_stl(const std::string& filename, const Location&
     std::array<std::array<double, 3>, 3> vdata;
     std::string line;
 
-    auto AsciiError = [&](const auto& errstr){
-        LOG(message_group::Error, loc, "",
-            "STL line %1$s, %2$s line '%3$s' importing file '%4$s'",
-            lineno, errstr, line, filename);
-      };
+    auto AsciiError = [&](const auto &errstr) {
+      LOG(message_group::Error, loc, "",
+          "STL line %1$s, %2$s line '%3$s' importing file '%4$s'", lineno,
+          errstr, line, filename);
+    };
 
     std::getline(f, line);
     bool reached_end = false;
@@ -154,10 +159,11 @@ std::unique_ptr<PolySet> import_stl(const std::string& filename, const Location&
           if (++i == 3) {
             builder.beginPolygon(3);
             for (int j = 0; j < 3; j++) {
-              builder.addVertex(Vector3d(vdata[j][0], vdata[j][1], vdata[j][2]));
+              builder.addVertex(
+                  Vector3d(vdata[j][0], vdata[j][1], vdata[j][2]));
             }
           }
-        } catch (const boost::bad_lexical_cast& blc) {
+        } catch (const boost::bad_lexical_cast &blc) {
           AsciiError("can't parse vertex");
           return PolySet::createEmpty();
         }
@@ -169,37 +175,39 @@ std::unique_ptr<PolySet> import_stl(const std::string& filename, const Location&
   } else if (binary && !f.eof() && f.good()) {
     try {
       f.ignore(80 - 5 + 4);
-      while (!f.eof() ) {
+      while (!f.eof()) {
         stl_facet facet;
         try {
           read_stl_facet(f, facet);
-        } catch (const std::ios_base::failure& ex) {
-          if (f.eof()) break;
+        } catch (const std::ios_base::failure &ex) {
+          if (f.eof())
+            break;
           throw;
         }
-        builder.appendPolygon({
-          Vector3d(facet.data.x1, facet.data.y1, facet.data.z1),
-          Vector3d(facet.data.x2, facet.data.y2, facet.data.z2),
-          Vector3d(facet.data.x3, facet.data.y3, facet.data.z3)
-        });
+        builder.appendPolygon(
+            {Vector3d(facet.data.x1, facet.data.y1, facet.data.z1),
+             Vector3d(facet.data.x2, facet.data.y2, facet.data.z2),
+             Vector3d(facet.data.x3, facet.data.y3, facet.data.z3)});
       }
-    } catch (const std::ios_base::failure& ex) {
+    } catch (const std::ios_base::failure &ex) {
       int64_t offset = -1;
-      try { offset = f.tellg(); } catch (...) {}
+      try {
+        offset = f.tellg();
+      } catch (...) {
+      }
       if (offset < 0) {
-        LOG(message_group::Error, loc, "",
-            "Binary STL '%1$s' error: %3$s",
+        LOG(message_group::Error, loc, "", "Binary STL '%1$s' error: %3$s",
             filename, ex.what());
       } else {
         LOG(message_group::Error, loc, "",
-            "Binary STL '%1$s' error at byte %2$s: %3$s",
-            filename, offset, ex.what());
+            "Binary STL '%1$s' error at byte %2$s: %3$s", filename, offset,
+            ex.what());
       }
       return PolySet::createEmpty();
     }
   } else {
-    LOG(message_group::Error, loc, "",
-        "STL format not recognized in '%1$s'.", filename);
+    LOG(message_group::Error, loc, "", "STL format not recognized in '%1$s'.",
+        filename);
     return PolySet::createEmpty();
   }
   return builder.build();
diff --git a/src/io/import_svg.cc b/src/io/import_svg.cc
index 8862db569..7cbd35b3a 100644
--- a/src/io/import_svg.cc
+++ b/src/io/import_svg.cc
@@ -39,8 +39,8 @@
 #include "geometry/ClipperUtils.h"
 #include "geometry/Polygon2d.h"
 #include "libsvg/libsvg.h"
-#include "libsvg/svgpage.h"
 #include "libsvg/shape.h"
+#include "libsvg/svgpage.h"
 #include "libsvg/util.h"
 #include "utils/printutils.h"
 
@@ -48,8 +48,8 @@ namespace {
 
 constexpr double INCH_TO_MM = 25.4;
 
-double to_mm(const libsvg::length_t& length, const double viewbox, const bool viewbox_valid, const double dpi)
-{
+double to_mm(const libsvg::length_t &length, const double viewbox,
+             const bool viewbox_valid, const double dpi) {
   switch (length.unit) {
   case libsvg::unit_t::NONE:
     return INCH_TO_MM * length.number / dpi;
@@ -66,7 +66,8 @@ double to_mm(const libsvg::length_t& length, const double viewbox, const bool vi
   case libsvg::unit_t::MM:
     return length.number;
   case libsvg::unit_t::PERCENT:
-    return viewbox_valid ? INCH_TO_MM * length.number / 100.0 * viewbox / dpi : 0.0;
+    return viewbox_valid ? INCH_TO_MM * length.number / 100.0 * viewbox / dpi
+                         : 0.0;
   case libsvg::unit_t::UNDEFINED:
     // If no width/height given, but viewbox is set, then rely on
     // the DPI value (e.g. Adobe Illustrator does that in older
@@ -77,8 +78,8 @@ double to_mm(const libsvg::length_t& length, const double viewbox, const bool vi
   }
 }
 
-double calc_alignment(const libsvg::align_t alignment, double page_mm, double scale, double viewbox)
-{
+double calc_alignment(const libsvg::align_t alignment, double page_mm,
+                      double scale, double viewbox) {
   switch (alignment) {
   case libsvg::align_t::MID:
     return page_mm / 2.0 - scale * viewbox / 2.0;
@@ -91,37 +92,40 @@ double calc_alignment(const libsvg::align_t alignment, double page_mm, double sc
 
 } // namespace
 
-
 std::unique_ptr<Polygon2d> import_svg(double fn, double fs, double fa,
-                                      const std::string& filename,
-                                      const boost::optional<std::string>& id, const boost::optional<std::string>& layer,
-                                      const double dpi, const bool center, const Location& loc)
-{
+                                      const std::string &filename,
+                                      const boost::optional<std::string> &id,
+                                      const boost::optional<std::string> &layer,
+                                      const double dpi, const bool center,
+                                      const Location &loc) {
   try {
     fnContext scadContext(fn, fs, fa);
     if (id) {
       scadContext.selector = [&scadContext, id, layer](const libsvg::shape *s) {
-          bool layer_match = true;
-          if (layer) {
-            layer_match = false;
-            for (const libsvg::shape *shape = s; shape->get_parent() != nullptr; shape = shape->get_parent()) {
-              if (shape->has_layer() && shape->get_layer() == layer.get()) {
-                layer_match = true;
-                break;
-              }
+        bool layer_match = true;
+        if (layer) {
+          layer_match = false;
+          for (const libsvg::shape *shape = s; shape->get_parent() != nullptr;
+               shape = shape->get_parent()) {
+            if (shape->has_layer() && shape->get_layer() == layer.get()) {
+              layer_match = true;
+              break;
             }
           }
-          return scadContext.match(layer_match && s->has_id() && s->get_id() == id.get());
-        };
+        }
+        return scadContext.match(layer_match && s->has_id() &&
+                                 s->get_id() == id.get());
+      };
     } else if (layer) {
       scadContext.selector = [&scadContext, layer](const libsvg::shape *s) {
-          return scadContext.match(s->has_layer() && s->get_layer() == layer.get());
-        };
+        return scadContext.match(s->has_layer() &&
+                                 s->get_layer() == layer.get());
+      };
     } else {
       // no selection means selecting the root
       scadContext.selector = [&scadContext](const libsvg::shape *s) {
-          return scadContext.match(s->get_parent() == nullptr);
-        };
+        return scadContext.match(s->get_parent() == nullptr);
+      };
     }
 
     std::string match_args;
@@ -129,13 +133,16 @@ std::unique_ptr<Polygon2d> import_svg(double fn, double fs, double fa,
       match_args += "id = \"" + id.get() + "\"";
     }
     if (layer) {
-      if (id) match_args += ", ";
+      if (id)
+        match_args += ", ";
       match_args += "layer = \"" + layer.get() + "\"";
     }
 
-    const auto shapes = libsvg::libsvg_read_file(filename.c_str(), (void *) &scadContext);
+    const auto shapes =
+        libsvg::libsvg_read_file(filename.c_str(), (void *)&scadContext);
     if (!match_args.empty() && !scadContext.has_matches()) {
-      LOG(message_group::Warning, loc, "", "import() filter %2$s did not match anything", filename, match_args);
+      LOG(message_group::Warning, loc, "",
+          "import() filter %2$s did not match anything", filename, match_args);
     }
 
     double width_mm = 0.0;
@@ -147,7 +154,7 @@ std::unique_ptr<Polygon2d> import_svg(double fn, double fs, double fa,
     Eigen::Vector2d align{0.0, 0.0};
     Eigen::Vector2d viewbox{0.0, 0.0};
 
-    for (const auto& shape_ptr : *shapes) {
+    for (const auto &shape_ptr : *shapes) {
       const auto page = dynamic_cast<libsvg::svgpage *>(shape_ptr.get());
       if (page) {
         const auto w = page->get_width();
@@ -159,12 +166,14 @@ std::unique_ptr<Polygon2d> import_svg(double fn, double fs, double fa,
         height_mm = to_mm(h, page->get_viewbox().height, viewbox_valid, dpi);
 
         if (viewbox_valid) {
-          const double px = w.unit == libsvg::unit_t::PERCENT ? w.number / 100.0 : 1.0;
-          const double py = h.unit == libsvg::unit_t::PERCENT ? h.number / 100.0 : 1.0;
-          viewbox << px * page->get_viewbox().x, py *page->get_viewbox().y;
+          const double px =
+              w.unit == libsvg::unit_t::PERCENT ? w.number / 100.0 : 1.0;
+          const double py =
+              h.unit == libsvg::unit_t::PERCENT ? h.number / 100.0 : 1.0;
+          viewbox << px * page->get_viewbox().x, py * page->get_viewbox().y;
 
           scale << width_mm / page->get_viewbox().width,
-            height_mm / page->get_viewbox().height;
+              height_mm / page->get_viewbox().height;
 
           if (alignment.x != libsvg::align_t::NONE) {
             double scaling;
@@ -179,16 +188,18 @@ std::unique_ptr<Polygon2d> import_svg(double fn, double fs, double fa,
             }
             scale = Eigen::Vector2d{scaling, scaling};
 
-            align << calc_alignment(alignment.x, width_mm, scale.x(), page->get_viewbox().width),
-              calc_alignment(alignment.y, height_mm, scale.y(), page->get_viewbox().height);
+            align << calc_alignment(alignment.x, width_mm, scale.x(),
+                                    page->get_viewbox().width),
+                calc_alignment(alignment.y, height_mm, scale.y(),
+                               page->get_viewbox().height);
           }
         }
       }
 
       if (!shape_ptr->is_excluded()) {
-        const auto& s = *shape_ptr;
-        for (const auto& p : s.get_path_list()) {
-          for (const auto& v : p) {
+        const auto &s = *shape_ptr;
+        for (const auto &p : s.get_path_list()) {
+          for (const auto &v : p) {
             bbox.extend(Eigen::Vector2d{scale.x() * v.x(), scale.y() * v.y()});
           }
         }
@@ -198,13 +209,13 @@ std::unique_ptr<Polygon2d> import_svg(double fn, double fs, double fa,
     const double cy = center ? bbox.center().y() : height_mm - align.y();
 
     std::vector<std::shared_ptr<const Polygon2d>> polygons;
-    for (const auto& shape_ptr : *shapes) {
+    for (const auto &shape_ptr : *shapes) {
       if (!shape_ptr->is_excluded()) {
         auto poly = std::make_shared<Polygon2d>();
-        const auto& s = *shape_ptr;
-        for (const auto& p : s.get_path_list()) {
+        const auto &s = *shape_ptr;
+        for (const auto &p : s.get_path_list()) {
           Outline2d outline;
-          for (const auto& v : p) {
+          for (const auto &v : p) {
             const double x = scale.x() * (-viewbox.x() + v.x()) - cx;
             const double y = scale.y() * (-viewbox.y() - v.y()) + cy;
             outline.vertices.emplace_back(x, y);
@@ -212,13 +223,15 @@ std::unique_ptr<Polygon2d> import_svg(double fn, double fs, double fa,
           }
           poly->addOutline(outline);
         }
-        if (!poly->isEmpty()) polygons.push_back(poly);
+        if (!poly->isEmpty())
+          polygons.push_back(poly);
       }
     }
     libsvg_free(shapes);
     return ClipperUtils::apply(polygons, Clipper2Lib::ClipType::Union);
-  } catch (const std::exception& e) {
-    LOG(message_group::Error, "%1$s, import() at line %2$d", e.what(), loc.firstLine());
+  } catch (const std::exception &e) {
+    LOG(message_group::Error, "%1$s, import() at line %2$d", e.what(),
+        loc.firstLine());
     return std::make_unique<Polygon2d>();
   }
 }
diff --git a/src/libsvg/circle.cc b/src/libsvg/circle.cc
index 7627c77d9..3fde3d12f 100644
--- a/src/libsvg/circle.cc
+++ b/src/libsvg/circle.cc
@@ -32,9 +32,7 @@ namespace libsvg {
 
 const std::string circle::name("circle");
 
-void
-circle::set_attrs(attr_map_t& attrs, void *context)
-{
+void circle::set_attrs(attr_map_t &attrs, void *context) {
   shape::set_attrs(attrs, context);
   this->x = parse_double(attrs["cx"]);
   this->y = parse_double(attrs["cy"]);
@@ -45,13 +43,9 @@ circle::set_attrs(attr_map_t& attrs, void *context)
   path_list.push_back(path);
 }
 
-const std::string
-circle::dump() const
-{
+const std::string circle::dump() const {
   std::stringstream s;
-  s << get_name()
-    << ": x = " << this->x
-    << ": y = " << this->y
+  s << get_name() << ": x = " << this->x << ": y = " << this->y
     << ": r = " << this->r;
   return s.str();
 }
diff --git a/src/libsvg/circle.h b/src/libsvg/circle.h
index f553e51e8..dcc740d2f 100644
--- a/src/libsvg/circle.h
+++ b/src/libsvg/circle.h
@@ -30,8 +30,7 @@
 
 namespace libsvg {
 
-class circle : public shape
-{
+class circle : public shape {
 protected:
   double r{0};
 
@@ -40,13 +39,15 @@ public:
 
   [[nodiscard]] double get_radius() const { return r; }
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
+  void set_attrs(attr_map_t &attrs, void *context) override;
   [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return circle::name; }
+  [[nodiscard]] const std::string &get_name() const override {
+    return circle::name;
+  }
 
   static const std::string name;
 
   [[nodiscard]] shape *clone() const override { return new circle(*this); }
 };
 
-}
+} // namespace libsvg
diff --git a/src/libsvg/data.cc b/src/libsvg/data.cc
index 98531218b..1ad2a6e25 100644
--- a/src/libsvg/data.cc
+++ b/src/libsvg/data.cc
@@ -31,20 +31,15 @@ namespace libsvg {
 
 const std::string data::name("data");
 
-void
-data::set_attrs(attr_map_t& attrs, void *context)
-{
+void data::set_attrs(attr_map_t &attrs, void *context) {
   shape::set_attrs(attrs, context);
   this->text = attrs["text"];
 }
 
-const std::string
-data::dump() const
-{
+const std::string data::dump() const {
   std::stringstream s;
-  s << get_name()
-    << ": text = '" << this->text << "'";
+  s << get_name() << ": text = '" << this->text << "'";
   return s.str();
 }
 
-}
+} // namespace libsvg
diff --git a/src/libsvg/data.h b/src/libsvg/data.h
index 7b395ce68..a9c800670 100644
--- a/src/libsvg/data.h
+++ b/src/libsvg/data.h
@@ -30,23 +30,24 @@
 
 namespace libsvg {
 
-class data : public shape
-{
+class data : public shape {
 private:
   std::string text;
 
 public:
   data() = default;
 
-  [[nodiscard]] const std::string& get_text() const { return text; }
+  [[nodiscard]] const std::string &get_text() const { return text; }
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
+  void set_attrs(attr_map_t &attrs, void *context) override;
   [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return data::name; }
+  [[nodiscard]] const std::string &get_name() const override {
+    return data::name;
+  }
 
   static const std::string name;
 
   [[nodiscard]] shape *clone() const override { return new data(*this); }
 };
 
-}
+} // namespace libsvg
diff --git a/src/libsvg/ellipse.cc b/src/libsvg/ellipse.cc
index e799f125c..3276f555e 100644
--- a/src/libsvg/ellipse.cc
+++ b/src/libsvg/ellipse.cc
@@ -24,10 +24,10 @@
  */
 #include "libsvg/ellipse.h"
 
-#include <sstream>
 #include <cstdlib>
-#include <string>
 #include <iostream>
+#include <sstream>
+#include <string>
 
 #include "libsvg/util.h"
 
@@ -35,9 +35,7 @@ namespace libsvg {
 
 const std::string ellipse::name("ellipse");
 
-void
-ellipse::set_attrs(attr_map_t& attrs, void *context)
-{
+void ellipse::set_attrs(attr_map_t &attrs, void *context) {
   shape::set_attrs(attrs, context);
   this->x = parse_double(attrs["cx"]);
   this->y = parse_double(attrs["cy"]);
@@ -49,15 +47,10 @@ ellipse::set_attrs(attr_map_t& attrs, void *context)
   path_list.push_back(path);
 }
 
-const std::string
-ellipse::dump() const
-{
+const std::string ellipse::dump() const {
   std::stringstream s;
-  s << get_name()
-    << ": x = " << this->x
-    << ": y = " << this->y
-    << ": rx = " << this->rx
-    << ": ry = " << this->ry;
+  s << get_name() << ": x = " << this->x << ": y = " << this->y
+    << ": rx = " << this->rx << ": ry = " << this->ry;
   return s.str();
 }
 
diff --git a/src/libsvg/ellipse.h b/src/libsvg/ellipse.h
index 0cadda926..aa362e68f 100644
--- a/src/libsvg/ellipse.h
+++ b/src/libsvg/ellipse.h
@@ -30,8 +30,7 @@
 
 namespace libsvg {
 
-class ellipse : public shape
-{
+class ellipse : public shape {
 protected:
   double rx{0};
   double ry{0};
@@ -42,13 +41,15 @@ public:
   [[nodiscard]] double get_radius_x() const { return rx; }
   [[nodiscard]] double get_radius_y() const { return ry; }
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
+  void set_attrs(attr_map_t &attrs, void *context) override;
   [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return ellipse::name; }
+  [[nodiscard]] const std::string &get_name() const override {
+    return ellipse::name;
+  }
 
   static const std::string name;
 
   [[nodiscard]] shape *clone() const override { return new ellipse(*this); }
 };
 
-}
+} // namespace libsvg
diff --git a/src/libsvg/group.cc b/src/libsvg/group.cc
index 7afed16c3..a40bbd74a 100644
--- a/src/libsvg/group.cc
+++ b/src/libsvg/group.cc
@@ -24,30 +24,23 @@
  */
 #include "libsvg/group.h"
 
-#include <sstream>
 #include <cstdlib>
-#include <string>
 #include <iostream>
-
+#include <sstream>
+#include <string>
 
 namespace libsvg {
 
 const std::string group::name("g");
 
-void
-group::set_attrs(attr_map_t& attrs, void *context)
-{
+void group::set_attrs(attr_map_t &attrs, void *context) {
   shape::set_attrs(attrs, context);
 }
 
-const std::string
-group::dump() const
-{
+const std::string group::dump() const {
   std::stringstream s;
-  s << get_name()
-    << ": x = " << this->x
-    << ": y = " << this->y;
+  s << get_name() << ": x = " << this->x << ": y = " << this->y;
   return s.str();
 }
 
-}
+} // namespace libsvg
diff --git a/src/libsvg/group.h b/src/libsvg/group.h
index b5cd59e93..cf7f88953 100644
--- a/src/libsvg/group.h
+++ b/src/libsvg/group.h
@@ -30,22 +30,22 @@
 
 namespace libsvg {
 
-class group : public shape
-{
+class group : public shape {
 protected:
-
 public:
   group() = default;
 
   [[nodiscard]] bool is_container() const override { return true; }
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
+  void set_attrs(attr_map_t &attrs, void *context) override;
   [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return group::name; }
+  [[nodiscard]] const std::string &get_name() const override {
+    return group::name;
+  }
 
   static const std::string name;
 
   [[nodiscard]] shape *clone() const override { return new group(*this); }
 };
 
-}
+} // namespace libsvg
diff --git a/src/libsvg/libsvg.cc b/src/libsvg/libsvg.cc
index ffada68dc..1d25026a6 100644
--- a/src/libsvg/libsvg.cc
+++ b/src/libsvg/libsvg.cc
@@ -24,17 +24,16 @@
  */
 #include "libsvg/libsvg.h"
 
-#include <utility>
-#include <iostream>
-#include <memory>
-#include <map>
-#include <string>
-#include <vector>
 #include <Eigen/Core>
 #include <Eigen/Geometry>
 #include <boost/format.hpp>
+#include <iostream>
 #include <libxml/xmlreader.h>
-
+#include <map>
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
 
 #include "libsvg/shape.h"
 #include "libsvg/use.h"
@@ -54,7 +53,7 @@ static std::string dump_stack() {
   bool first = true;
   std::stringstream s;
   s << "[";
-  for (const auto& shape : stack) {
+  for (const auto &shape : stack) {
     s << (first ? "" : "|") << shape->get_name();
     first = false;
   }
@@ -62,23 +61,25 @@ static std::string dump_stack() {
 }
 #endif // if SVG_DEBUG
 
-attr_map_t read_attributes(xmlTextReaderPtr reader)
-{
+attr_map_t read_attributes(xmlTextReaderPtr reader) {
   attr_map_t attrs;
   int attr_count = xmlTextReaderAttributeCount(reader);
   for (int idx = 0; idx < attr_count; ++idx) {
     xmlTextReaderMoveToAttributeNo(reader, idx);
-    const char *name = reinterpret_cast<const char *>(xmlTextReaderName(reader));
-    const char *value = reinterpret_cast<const char *>(xmlTextReaderValue(reader));
+    const char *name =
+        reinterpret_cast<const char *>(xmlTextReaderName(reader));
+    const char *value =
+        reinterpret_cast<const char *>(xmlTextReaderValue(reader));
     attrs[name] = value;
   }
   return attrs;
 }
 
-void processNode(xmlTextReaderPtr reader, shapes_defs_list_t *defs_lookup_list, shapes_list_t *temp_defs_storage, void *context)
-{
+void processNode(xmlTextReaderPtr reader, shapes_defs_list_t *defs_lookup_list,
+                 shapes_list_t *temp_defs_storage, void *context) {
   const char *name = reinterpret_cast<const char *>(xmlTextReaderName(reader));
-  if (name == nullptr) name = reinterpret_cast<const char *>(xmlStrdup(BAD_CAST "--"));
+  if (name == nullptr)
+    name = reinterpret_cast<const char *>(xmlStrdup(BAD_CAST "--"));
 
   bool isEmpty;
   xmlChar *value = xmlTextReaderValue(reader);
@@ -89,10 +90,8 @@ void processNode(xmlTextReaderPtr reader, shapes_defs_list_t *defs_lookup_list,
     {
 #if SVG_DEBUG
       printf("XML_READER_TYPE_ELEMENT (%s %s): %d %d %s\n",
-             dump_stack().c_str(), name,
-             xmlTextReaderDepth(reader),
-             xmlTextReaderNodeType(reader),
-             value);
+             dump_stack().c_str(), name, xmlTextReaderDepth(reader),
+             xmlTextReaderNodeType(reader), value);
 #endif
 
       if (std::string("defs") == name) {
@@ -110,14 +109,17 @@ void processNode(xmlTextReaderPtr reader, shapes_defs_list_t *defs_lookup_list,
           stack.push_back(s);
         }
 
-        //handle the "use" tag
+        // handle the "use" tag
         if (use::name == s->get_name()) {
           use *currentuse = dynamic_cast<use *>(s.get());
           auto id = currentuse->get_href_id();
-          if (!id.empty() && defs_lookup_list->find(id) != defs_lookup_list->end()) {
+          if (!id.empty() &&
+              defs_lookup_list->find(id) != defs_lookup_list->end()) {
             auto to_clone_child = (*defs_lookup_list)[id];
-            auto cloned_children = currentuse->set_clone_child(to_clone_child.get());
-            shape_list->insert(shape_list->end(), cloned_children.begin(), cloned_children.end());
+            auto cloned_children =
+                currentuse->set_clone_child(to_clone_child.get());
+            shape_list->insert(shape_list->end(), cloned_children.begin(),
+                               cloned_children.end());
           }
         }
 
@@ -135,29 +137,22 @@ void processNode(xmlTextReaderPtr reader, shapes_defs_list_t *defs_lookup_list,
       break;
     }
   /* fall through */
-  case XML_READER_TYPE_END_ELEMENT:
-  {
+  case XML_READER_TYPE_END_ELEMENT: {
     if (std::string("defs") == name) {
       in_defs = false;
     }
 
-    if (std::string("g") == name ||
-        std::string("svg") == name ||
-        std::string("tspan") == name ||
-        std::string("text") == name) {
+    if (std::string("g") == name || std::string("svg") == name ||
+        std::string("tspan") == name || std::string("text") == name) {
       stack.pop_back();
     }
 #if SVG_DEBUG
     printf("XML_READER_TYPE_END_ELEMENT (%s %s): %d %d %s\n",
-           dump_stack().c_str(), name,
-           xmlTextReaderDepth(reader),
-           xmlTextReaderNodeType(reader),
-           value);
+           dump_stack().c_str(), name, xmlTextReaderDepth(reader),
+           xmlTextReaderNodeType(reader), value);
 #endif
-  }
-  break;
-  case XML_READER_TYPE_TEXT:
-  {
+  } break;
+  case XML_READER_TYPE_TEXT: {
     attr_map_t attrs;
     attrs["text"] = reinterpret_cast<const char *>(value);
     auto s = std::shared_ptr<shape>(shape::create_from_name("data"));
@@ -170,18 +165,17 @@ void processNode(xmlTextReaderPtr reader, shapes_defs_list_t *defs_lookup_list,
     } else {
       temp_defs_storage->push_back(s);
     }
-  }
-  break;
+  } break;
   }
 
   xmlFree(value);
-  xmlFree((void *) (name));
+  xmlFree((void *)(name));
 }
 
-int streamFile(const char *filename, void *context)
-{
+int streamFile(const char *filename, void *context) {
   xmlTextReaderPtr reader;
-  // The temp storage is needed for items in a def that don't have an id, but have a parent with an id
+  // The temp storage is needed for items in a def that don't have an id, but
+  // have a parent with an id
   shapes_list_t temp_defs_storage;
   shapes_defs_list_t defs_lookup_list;
 
@@ -196,13 +190,15 @@ int streamFile(const char *filename, void *context)
     }
     xmlFreeTextReader(reader);
     if (ret != 0) {
-      throw SvgException((boost::format("Error parsing file '%1%'") % filename).str());
+      throw SvgException(
+          (boost::format("Error parsing file '%1%'") % filename).str());
     }
   } else {
-    throw SvgException((boost::format("Can't open file '%1%'") % filename).str());
+    throw SvgException(
+        (boost::format("Can't open file '%1%'") % filename).str());
   }
 
-  for (const auto& shape : (*shape_list)) {
+  for (const auto &shape : (*shape_list)) {
     shape->apply_transform();
   }
 
@@ -214,30 +210,24 @@ void dump(int idx, shape *s) {
     std::cout << "  ";
   }
   std::cout << "=> " << s->dump() << std::endl;
-  for (const auto& c : s->get_children()) {
+  for (const auto &c : s->get_children()) {
     dump(idx + 1, c);
   }
 }
 
-shapes_list_t *
-libsvg_read_file(const char *filename, void *context)
-{
+shapes_list_t *libsvg_read_file(const char *filename, void *context) {
   shape_list = new shapes_list_t();
   streamFile(filename, context);
 
-//#ifdef DEBUG
-//	if (!shape_list->empty()) {
-//		dump(0, shape_list->front().get());
-//	}
-//#endif
+  // #ifdef DEBUG
+  //	if (!shape_list->empty()) {
+  //		dump(0, shape_list->front().get());
+  //	}
+  // #endif
 
   return shape_list;
 }
 
-void
-libsvg_free(shapes_list_t *shapes)
-{
-  delete shapes;
-}
+void libsvg_free(shapes_list_t *shapes) { delete shapes; }
 
 } // namespace libsvg
diff --git a/src/libsvg/libsvg.h b/src/libsvg/libsvg.h
index 19910ae45..65dd00446 100644
--- a/src/libsvg/libsvg.h
+++ b/src/libsvg/libsvg.h
@@ -25,22 +25,20 @@
 #pragma once
 
 #include <exception>
-#include <utility>
 #include <memory>
 #include <string>
+#include <utility>
 #include <vector>
 
 #include "libsvg/shape.h"
 
 namespace libsvg {
 
-class SvgException : public std::exception
-{
+class SvgException : public std::exception {
 public:
-  SvgException(std::string message) : message(std::move(message)) { }
+  SvgException(std::string message) : message(std::move(message)) {}
 
-  [[nodiscard]] const char *what() const noexcept override
-  {
+  [[nodiscard]] const char *what() const noexcept override {
     return message.c_str();
   }
 
@@ -50,10 +48,8 @@ private:
 
 using shapes_list_t = std::vector<std::shared_ptr<shape>>;
 
-shapes_list_t *
-libsvg_read_file(const char *filename, void *context);
+shapes_list_t *libsvg_read_file(const char *filename, void *context);
 
-void
-libsvg_free(shapes_list_t *shapes);
+void libsvg_free(shapes_list_t *shapes);
 
-}
+} // namespace libsvg
diff --git a/src/libsvg/line.cc b/src/libsvg/line.cc
index 0c95b18a4..ab398ea35 100644
--- a/src/libsvg/line.cc
+++ b/src/libsvg/line.cc
@@ -24,17 +24,15 @@
  */
 #include "libsvg/line.h"
 
+#include "libsvg/util.h"
 #include <sstream>
 #include <string>
-#include "libsvg/util.h"
 
 namespace libsvg {
 
 const std::string line::name("line");
 
-void
-line::set_attrs(attr_map_t& attrs, void *context)
-{
+void line::set_attrs(attr_map_t &attrs, void *context) {
   shape::set_attrs(attrs, context);
   this->x = parse_double(attrs["x1"]);
   this->y = parse_double(attrs["y1"]);
@@ -47,15 +45,10 @@ line::set_attrs(attr_map_t& attrs, void *context)
   offset_path(path_list, path, get_stroke_width(), get_stroke_linecap());
 }
 
-const std::string
-line::dump() const
-{
+const std::string line::dump() const {
   std::stringstream s;
-  s << get_name()
-    << ": x1 = " << this->x
-    << ": y1 = " << this->y
-    << ": x2 = " << this->x2
-    << ": y2 = " << this->y2;
+  s << get_name() << ": x1 = " << this->x << ": y1 = " << this->y
+    << ": x2 = " << this->x2 << ": y2 = " << this->y2;
   return s.str();
 }
 
diff --git a/src/libsvg/line.h b/src/libsvg/line.h
index c121864fd..5da8d0708 100644
--- a/src/libsvg/line.h
+++ b/src/libsvg/line.h
@@ -24,13 +24,12 @@
  */
 #pragma once
 
-#include <string>
 #include "libsvg/shape.h"
+#include <string>
 
 namespace libsvg {
 
-class line : public shape
-{
+class line : public shape {
 private:
   double x2{0};
   double y2{0};
@@ -38,16 +37,22 @@ private:
 public:
   line() = default;
 
-  [[nodiscard]] double get_x2() const { return x2; } // NOLINT(bugprone-virtual-near-miss)
-  [[nodiscard]] double get_y2() const { return y2; } // NOLINT(bugprone-virtual-near-miss)
+  [[nodiscard]] double get_x2() const {
+    return x2;
+  } // NOLINT(bugprone-virtual-near-miss)
+  [[nodiscard]] double get_y2() const {
+    return y2;
+  } // NOLINT(bugprone-virtual-near-miss)
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
+  void set_attrs(attr_map_t &attrs, void *context) override;
   [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return line::name; }
+  [[nodiscard]] const std::string &get_name() const override {
+    return line::name;
+  }
 
   static const std::string name;
 
   [[nodiscard]] shape *clone() const override { return new line(*this); }
 };
 
-}
+} // namespace libsvg
diff --git a/src/libsvg/path.cc b/src/libsvg/path.cc
index f885c78ee..76d21d4b4 100644
--- a/src/libsvg/path.cc
+++ b/src/libsvg/path.cc
@@ -25,24 +25,23 @@
 #include "libsvg/path.h"
 
 #include <algorithm>
-#include <sstream>
+#include <cctype>
+#include <cmath>
 #include <cstdlib>
-#include <vector>
-#include <string>
 #include <iostream>
-#include <cmath>
-#include <cctype>
+#include <sstream>
 #include <string>
+#include <vector>
 
 #include <Eigen/Core>
 #include <Eigen/Geometry>
 
-#include <boost/tokenizer.hpp>
 #include <boost/algorithm/string.hpp>
+#include <boost/tokenizer.hpp>
 
-#include "utils/degree_trig.h"
-#include "utils/calc.h"
 #include "libsvg/util.h"
+#include "utils/calc.h"
+#include "utils/degree_trig.h"
 
 namespace libsvg {
 
@@ -72,9 +71,7 @@ const std::string path::name("path");
    PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL t
  */
 
-static double
-vector_angle(double ux, double uy, double vx, double vy)
-{
+static double vector_angle(double ux, double uy, double vx, double vy) {
   double angle = atan2_degrees(vy, vx) - atan2_degrees(uy, ux);
   if (angle < 0) {
     angle += 360;
@@ -82,18 +79,18 @@ vector_angle(double ux, double uy, double vx, double vy)
   return angle;
 }
 
-static inline
-unsigned long CalcFn(double fn, unsigned long minimum) {
+static inline unsigned long CalcFn(double fn, unsigned long minimum) {
   unsigned long result = 3;
-  if (fn > 3.0)     // > 0.0 && > 3
+  if (fn > 3.0) // > 0.0 && > 3
     result = static_cast<unsigned long>(fn);
-  if (result < minimum) result = minimum;
+  if (result < minimum)
+    result = minimum;
   return result;
 }
 
-void
-path::arc_to(path_t& path, double x1, double y1, double rx, double ry, double x2, double y2, double angle, bool large, bool sweep, void *context)
-{
+void path::arc_to(path_t &path, double x1, double y1, double rx, double ry,
+                  double x2, double y2, double angle, bool large, bool sweep,
+                  void *context) {
   const auto *fValues = reinterpret_cast<const fnContext *>(context);
 
   // http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
@@ -143,26 +140,31 @@ path::arc_to(path_t& path, double x1, double y1, double rx, double ry, double x2
   }
 
   double rmax = fmax(rx, ry);
-  unsigned long fn = Calc::get_fragments_from_r(rmax, fValues->fn, fValues->fs, fValues->fa);
-  fn = (unsigned long) ceil(fn * fabs(delta) / 360.0); // because we are creating a section of an ellipse, not the full ellipse
+  unsigned long fn =
+      Calc::get_fragments_from_r(rmax, fValues->fn, fValues->fs, fValues->fa);
+  fn = (unsigned long)ceil(fn * fabs(delta) /
+                           360.0); // because we are creating a section of an
+                                   // ellipse, not the full ellipse
   unsigned int steps = (std::fabs(delta) * 10.0 / 180) + 4;
-  if (steps < fn) // use the maximum of calculated steps and user specified steps
+  if (steps <
+      fn) // use the maximum of calculated steps and user specified steps
     steps = fn;
   for (unsigned int a = 0; a <= steps; ++a) {
     double phi = theta + delta * a / steps;
 
-    double xx = cos_rad * cos_degrees(phi) * rx - sin_rad * sin_degrees(phi) * ry;
-    double yy = sin_rad * cos_degrees(phi) * rx + cos_rad * sin_degrees(phi) * ry;
+    double xx =
+        cos_rad * cos_degrees(phi) * rx - sin_rad * sin_degrees(phi) * ry;
+    double yy =
+        sin_rad * cos_degrees(phi) * rx + cos_rad * sin_degrees(phi) * ry;
 
     path.push_back(Eigen::Vector3d(xx + cx, yy + cy, 0));
   }
 }
 
-
-void
-path::curve_to(path_t& path, double x, double y, double cx1, double cy1, double x2, double y2, void *context)
-{
-  // NOTE - this could be done better using a chord length iteration (uniform in space) to implement $fa (lot of work, little gain)
+void path::curve_to(path_t &path, double x, double y, double cx1, double cy1,
+                    double x2, double y2, void *context) {
+  // NOTE - this could be done better using a chord length iteration (uniform in
+  // space) to implement $fa (lot of work, little gain)
   const auto *fValues = reinterpret_cast<const fnContext *>(context);
   unsigned long fn = CalcFn(fValues->fn, 20); // preserve the old minimum
   for (unsigned long idx = 1; idx <= fn; ++idx) {
@@ -173,16 +175,19 @@ path::curve_to(path_t& path, double x, double y, double cx1, double cy1, double
   }
 }
 
-void
-path::curve_to(path_t& path, double x, double y, double cx1, double cy1, double cx2, double cy2, double x2, double y2, void *context)
-{
-  // NOTE - this could be done better using a chord length iteration (uniform in space) to implement $fa (lot of work, little gain)
+void path::curve_to(path_t &path, double x, double y, double cx1, double cy1,
+                    double cx2, double cy2, double x2, double y2,
+                    void *context) {
+  // NOTE - this could be done better using a chord length iteration (uniform in
+  // space) to implement $fa (lot of work, little gain)
   const auto *fValues = reinterpret_cast<const fnContext *>(context);
   unsigned long fn = CalcFn(fValues->fn, 20); // preserve the old minimum
   for (unsigned long idx = 1; idx <= fn; ++idx) {
     const double a = idx * (1.0 / (double)fn);
-    const double xx = x * t(a, 3) + cx1 * 3 * t(a, 2) * a + cx2 * 3 * t(a, 1) * a * a + x2 * a * a * a;
-    const double yy = y * t(a, 3) + cy1 * 3 * t(a, 2) * a + cy2 * 3 * t(a, 1) * a * a + y2 * a * a * a;
+    const double xx = x * t(a, 3) + cx1 * 3 * t(a, 2) * a +
+                      cx2 * 3 * t(a, 1) * a * a + x2 * a * a * a;
+    const double yy = y * t(a, 3) + cy1 * 3 * t(a, 2) * a +
+                      cy2 * 3 * t(a, 1) * a * a + y2 * a * a * a;
     path.push_back(Eigen::Vector3d(xx, yy, 0));
   }
 }
@@ -191,8 +196,7 @@ path::curve_to(path_t& path, double x, double y, double cx1, double cy1, double
  * Workaround for parsing ",1-23.16.88" where the number split
  * happens implicitly at the dot.
  */
-static std::vector<std::string> split_dots(const std::string& str)
-{
+static std::vector<std::string> split_dots(const std::string &str) {
   std::vector<std::string> result;
   const size_t n = std::count(str.begin(), str.end(), '.');
   if (n < 2) {
@@ -205,7 +209,7 @@ static std::vector<std::string> split_dots(const std::string& str)
 
   std::string text;
   bool dot_seen = false;
-  for (const auto& token : tokens) {
+  for (const auto &token : tokens) {
     text += token;
     if (token == ".") {
       dot_seen = true;
@@ -219,9 +223,7 @@ static std::vector<std::string> split_dots(const std::string& str)
   return result;
 }
 
-void
-path::set_attrs(attr_map_t& attrs, void *context)
-{
+void path::set_attrs(attr_map_t &attrs, void *context) {
   std::string commands = "-zmlcqahvstZMLCQAHVST";
 
   shape::set_attrs(attrs, context);
@@ -231,7 +233,7 @@ path::set_attrs(attr_map_t& attrs, void *context)
   tokenizer tokens(this->data, sep);
 
   std::vector<std::string> path_tokens;
-  for (const auto& token : tokens) {
+  for (const auto &token : tokens) {
     const std::vector<std::string> parts = split_dots(token);
     path_tokens.insert(path_tokens.end(), parts.begin(), parts.end());
   }
@@ -258,7 +260,7 @@ path::set_attrs(attr_map_t& attrs, void *context)
   bool path_closed = false;
   std::string pre_exp;
   path_list.push_back(path_t());
-  for (const auto& v : path_tokens) {
+  for (const auto &v : path_tokens) {
 
     double p = 0;
     if ((v.length() == 1) && (commands.find(v) != std::string::npos)) {
@@ -309,7 +311,8 @@ path::set_attrs(attr_map_t& attrs, void *context)
         break;
       case 6:
         yy = cmd == 'a' ? y + p : p;
-        arc_to(path_list.back(), x, y, rx, ry, xx, yy, angle, large, sweep, context);
+        arc_to(path_list.back(), x, y, rx, ry, xx, yy, angle, large, sweep,
+               context);
         x = xx;
         y = yy;
         point = -1;
@@ -375,7 +378,8 @@ path::set_attrs(attr_map_t& attrs, void *context)
         if (last_cmd_cubic_bezier) {
           Eigen::Vector2d old_control_point(cx2, cy2);
           Eigen::Vector2d current_point(x, y);
-          Eigen::Vector2d new_control_point = current_point + (current_point - old_control_point);
+          Eigen::Vector2d new_control_point =
+              current_point + (current_point - old_control_point);
           cx1 = new_control_point.x();
           cy1 = new_control_point.y();
         } else {
@@ -435,7 +439,8 @@ path::set_attrs(attr_map_t& attrs, void *context)
         if (last_cmd_quadratic_bezier) {
           Eigen::Vector2d old_control_point(cx1, cy1);
           Eigen::Vector2d current_point(x, y);
-          Eigen::Vector2d new_control_point = current_point + (current_point - old_control_point);
+          Eigen::Vector2d new_control_point =
+              current_point + (current_point - old_control_point);
           cx1 = new_control_point.x();
           cy1 = new_control_point.y();
         } else {
@@ -469,7 +474,8 @@ path::set_attrs(attr_map_t& attrs, void *context)
         if (!path_list.back().empty()) {
           if (is_open_path(path)) {
             path_list.pop_back();
-            offset_path(path_list, path, get_stroke_width(), get_stroke_linecap());
+            offset_path(path_list, path, get_stroke_width(),
+                        get_stroke_linecap());
           }
           path_list.push_back(path_t());
         }
@@ -537,25 +543,21 @@ path::set_attrs(attr_map_t& attrs, void *context)
   }
 }
 
-bool
-path::is_open_path(path_t& path) const
-{
-  const Eigen::Vector3d& p1 = path[0];
-  const Eigen::Vector3d& p2 = path.back();
-  double distance = pow(pow(p1.x() - p2.x(), 2) + pow(p1.y() - p2.y(), 2) + pow(p1.z() - p2.z(), 2), 0.5);
+bool path::is_open_path(path_t &path) const {
+  const Eigen::Vector3d &p1 = path[0];
+  const Eigen::Vector3d &p2 = path.back();
+  double distance = pow(pow(p1.x() - p2.x(), 2) + pow(p1.y() - p2.y(), 2) +
+                            pow(p1.z() - p2.z(), 2),
+                        0.5);
   return distance > 0.1;
 }
 
-const std::string
-path::dump() const
-{
+const std::string path::dump() const {
   std::stringstream s;
-  s << get_name()
-    << ": x = " << this->x
-    << ", y = " << this->y;
-  for (const auto& p : path_list) {
+  s << get_name() << ": x = " << this->x << ", y = " << this->y;
+  for (const auto &p : path_list) {
     s << "[";
-    for (const auto& v : p) {
+    for (const auto &v : p) {
       s << " (" << v.x() << ", " << v.y() << ")";
     }
     s << "]";
diff --git a/src/libsvg/path.h b/src/libsvg/path.h
index 87afec19b..5f5ed01e8 100644
--- a/src/libsvg/path.h
+++ b/src/libsvg/path.h
@@ -24,14 +24,13 @@
  */
 #pragma once
 
+#include "libsvg/shape.h"
 #include <cmath>
 #include <string>
-#include "libsvg/shape.h"
 
 namespace libsvg {
 
-class path : public shape
-{
+class path : public shape {
 protected:
   std::string data;
 
@@ -40,17 +39,22 @@ private:
     return std::pow(1.0 - t, exp);
   }
 
-  bool is_open_path(path_t& path) const;
-  void arc_to(path_t& path, double x, double y, double rx, double ry, double x2, double y2, double angle, bool large, bool sweep, void *context);
-  void curve_to(path_t& path, double x, double y, double cx1, double cy1, double x2, double y2, void *context);
-  void curve_to(path_t& path, double x, double y, double cx1, double cy1, double cx2, double cy2, double x2, double y2, void *context);
+  bool is_open_path(path_t &path) const;
+  void arc_to(path_t &path, double x, double y, double rx, double ry, double x2,
+              double y2, double angle, bool large, bool sweep, void *context);
+  void curve_to(path_t &path, double x, double y, double cx1, double cy1,
+                double x2, double y2, void *context);
+  void curve_to(path_t &path, double x, double y, double cx1, double cy1,
+                double cx2, double cy2, double x2, double y2, void *context);
 
 public:
   path() = default;
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
+  void set_attrs(attr_map_t &attrs, void *context) override;
   [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return path::name; }
+  [[nodiscard]] const std::string &get_name() const override {
+    return path::name;
+  }
 
   static const std::string name;
 
diff --git a/src/libsvg/polygon.cc b/src/libsvg/polygon.cc
index 4dc8aee04..5b973bd5b 100644
--- a/src/libsvg/polygon.cc
+++ b/src/libsvg/polygon.cc
@@ -34,9 +34,7 @@ namespace libsvg {
 
 const std::string polygon::name("polygon");
 
-void
-polygon::set_attrs(attr_map_t& attrs, void *context)
-{
+void polygon::set_attrs(attr_map_t &attrs, void *context) {
   shape::set_attrs(attrs, context);
   this->points = attrs["points"];
 
@@ -47,7 +45,7 @@ polygon::set_attrs(attr_map_t& attrs, void *context)
   double x = 0.0;
   path_t path;
   bool first = true;
-  for (const auto& v : tokens) {
+  for (const auto &v : tokens) {
     double p = parse_double(v);
 
     if (first) {
diff --git a/src/libsvg/polygon.h b/src/libsvg/polygon.h
index c78299da3..657986edc 100644
--- a/src/libsvg/polygon.h
+++ b/src/libsvg/polygon.h
@@ -24,25 +24,26 @@
  */
 #pragma once
 
-#include <string>
 #include "libsvg/shape.h"
+#include <string>
 
 namespace libsvg {
 
-class polygon : public shape
-{
+class polygon : public shape {
 private:
   std::string points;
 
 public:
   polygon() = default;
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
-  [[nodiscard]] const std::string& get_name() const override { return polygon::name; }
+  void set_attrs(attr_map_t &attrs, void *context) override;
+  [[nodiscard]] const std::string &get_name() const override {
+    return polygon::name;
+  }
 
   static const std::string name;
 
   [[nodiscard]] shape *clone() const override { return new polygon(*this); }
 };
 
-}
+} // namespace libsvg
diff --git a/src/libsvg/polyline.cc b/src/libsvg/polyline.cc
index 00e038448..e506a26d1 100644
--- a/src/libsvg/polyline.cc
+++ b/src/libsvg/polyline.cc
@@ -26,16 +26,14 @@
 
 #include <boost/tokenizer.hpp>
 
-#include <string>
 #include "libsvg/util.h"
+#include <string>
 
 namespace libsvg {
 
 const std::string polyline::name("polyline");
 
-void
-polyline::set_attrs(attr_map_t& attrs, void *context)
-{
+void polyline::set_attrs(attr_map_t &attrs, void *context) {
   shape::set_attrs(attrs, context);
   this->points = attrs["points"];
 
@@ -46,7 +44,7 @@ polyline::set_attrs(attr_map_t& attrs, void *context)
   double x = 0.0;
   path_t path;
   bool first = true;
-  for (const auto& v : tokens) {
+  for (const auto &v : tokens) {
     double p = parse_double(v);
 
     if (first) {
diff --git a/src/libsvg/polyline.h b/src/libsvg/polyline.h
index 56e47e694..91e85bc98 100644
--- a/src/libsvg/polyline.h
+++ b/src/libsvg/polyline.h
@@ -24,25 +24,26 @@
  */
 #pragma once
 
-#include <string>
 #include "libsvg/shape.h"
+#include <string>
 
 namespace libsvg {
 
-class polyline : public shape
-{
+class polyline : public shape {
 private:
   std::string points;
 
 public:
   polyline() = default;
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
-  [[nodiscard]] const std::string& get_name() const override { return polyline::name; }
+  void set_attrs(attr_map_t &attrs, void *context) override;
+  [[nodiscard]] const std::string &get_name() const override {
+    return polyline::name;
+  }
 
   static const std::string name;
 
   [[nodiscard]] shape *clone() const override { return new polyline(*this); }
 };
 
-}
+} // namespace libsvg
diff --git a/src/libsvg/rect.cc b/src/libsvg/rect.cc
index 4732d8907..35a70943e 100644
--- a/src/libsvg/rect.cc
+++ b/src/libsvg/rect.cc
@@ -24,10 +24,10 @@
  */
 #include "libsvg/rect.h"
 
-#include <sstream>
+#include <cmath>
 #include <cstdlib>
 #include <iostream>
-#include <cmath>
+#include <sstream>
 #include <string>
 
 #include <boost/format.hpp>
@@ -63,9 +63,9 @@ const std::string rect::name("rect");
  * rx is the effective value of the ‘rx’ attribute converted to user space
  * and y is the value of the ‘y’ attribute converted to user space
  *
- * 2) perform an absolute horizontal lineto operation to location (x+width-rx,y),
- * where width is the ‘rect’ element's ‘width’ attribute converted to user
- * space
+ * 2) perform an absolute horizontal lineto operation to location
+ * (x+width-rx,y), where width is the ‘rect’ element's ‘width’ attribute
+ * converted to user space
  *
  * 3) perform an absolute elliptical arc operation to coordinate (x+width,y+ry),
  * where the effective values for the ‘rx’ and ‘ry’ attributes on the ‘rect’
@@ -78,7 +78,8 @@ const std::string rect::name("rect");
  * where height is the ‘rect’ element's ‘height’ attribute converted to user
  * space
  *
- * 5) perform an absolute elliptical arc operation to coordinate (x+width-rx,y+height)
+ * 5) perform an absolute elliptical arc operation to coordinate
+ * (x+width-rx,y+height)
  *
  * 6) perform an absolute horizontal lineto to location (x+rx,y+height)
  *
@@ -88,9 +89,7 @@ const std::string rect::name("rect");
  *
  * 9) perform an absolute elliptical arc operation to coordinate (x+rx,y)
  */
-void
-rect::set_attrs(attr_map_t& attrs, void *context)
-{
+void rect::set_attrs(attr_map_t &attrs, void *context) {
   shape::set_attrs(attrs, context); // NOLINT(bugprone-parent-virtual-call)
   this->x = parse_double(attrs["x"]);
   this->y = parse_double(attrs["y"]);
@@ -115,49 +114,40 @@ rect::set_attrs(attr_map_t& attrs, void *context)
       this->ry = this->height / 2;
     }
 
-    std::string path = boost::str(boost::format(""
-                                                "M %1%,%2% "
-                                                "H %3% "
-                                                "A %4%,%5% 0 0,1 %6%,%7% "
-                                                "V %8% "
-                                                "A %9%,%10% 0 0,1 %11%,%12% "
-                                                "H %13% "
-                                                "A %14%,%15% 0 0,1 %16%,%17% "
-                                                "V %18% "
-                                                "A %19%,%20% 0 0,1 %21%,%22% "
-                                                "z")
-                                  % (x + rx) % y
-                                  % (x + width - rx)
-                                  % rx % ry % (x + width) % (y + ry)
-                                  % (y + height - ry)
-                                  % rx % ry % (x + width - rx) % (y + height)
-                                  % (x + rx)
-                                  % rx % ry % x % (y + height - ry)
-                                  % (y + ry)
-                                  % rx % ry % (x + rx) % y
-                                  );
+    std::string path =
+        boost::str(boost::format(""
+                                 "M %1%,%2% "
+                                 "H %3% "
+                                 "A %4%,%5% 0 0,1 %6%,%7% "
+                                 "V %8% "
+                                 "A %9%,%10% 0 0,1 %11%,%12% "
+                                 "H %13% "
+                                 "A %14%,%15% 0 0,1 %16%,%17% "
+                                 "V %18% "
+                                 "A %19%,%20% 0 0,1 %21%,%22% "
+                                 "z") %
+                   (x + rx) % y % (x + width - rx) % rx % ry % (x + width) %
+                   (y + ry) % (y + height - ry) % rx % ry % (x + width - rx) %
+                   (y + height) % (x + rx) % rx % ry % x % (y + height - ry) %
+                   (y + ry) % rx % ry % (x + rx) % y);
     attrs["d"] = path;
     path::set_attrs(attrs, context);
   } else {
     path_t path;
     path.push_back(Eigen::Vector3d(get_x(), get_y(), 0));
     path.push_back(Eigen::Vector3d(get_x() + get_width(), get_y(), 0));
-    path.push_back(Eigen::Vector3d(get_x() + get_width(), get_y() + get_height(), 0));
+    path.push_back(
+        Eigen::Vector3d(get_x() + get_width(), get_y() + get_height(), 0));
     path.push_back(Eigen::Vector3d(get_x(), get_y() + get_height(), 0));
     path.push_back(Eigen::Vector3d(get_x(), get_y(), 0));
     path_list.push_back(path);
   }
 }
 
-const std::string
-rect::dump() const
-{
+const std::string rect::dump() const {
   std::stringstream s;
-  s << get_name()
-    << ": x = " << this->x
-    << ": y = " << this->y
-    << ": width = " << this->width
-    << ": height = " << this->height;
+  s << get_name() << ": x = " << this->x << ": y = " << this->y
+    << ": width = " << this->width << ": height = " << this->height;
   return s.str();
 }
 
diff --git a/src/libsvg/rect.h b/src/libsvg/rect.h
index 7130ea178..4a46a5cae 100644
--- a/src/libsvg/rect.h
+++ b/src/libsvg/rect.h
@@ -24,13 +24,12 @@
  */
 #pragma once
 
-#include <string>
 #include "libsvg/path.h"
+#include <string>
 
 namespace libsvg {
 
-class rect : public path
-{
+class rect : public path {
 protected:
   double width{0};
   double height{0};
@@ -45,11 +44,13 @@ public:
   [[nodiscard]] double get_rx() const { return rx; }
   [[nodiscard]] double get_ry() const { return ry; }
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
+  void set_attrs(attr_map_t &attrs, void *context) override;
   [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return rect::name; }
+  [[nodiscard]] const std::string &get_name() const override {
+    return rect::name;
+  }
 
   static const std::string name;
 };
 
-}
+} // namespace libsvg
diff --git a/src/libsvg/shape.cc b/src/libsvg/shape.cc
index 515aac3c5..c8191ee2b 100644
--- a/src/libsvg/shape.cc
+++ b/src/libsvg/shape.cc
@@ -24,43 +24,41 @@
  */
 #include "libsvg/shape.h"
 
+#include <cmath>
+#include <cstdio>
 #include <iostream>
 #include <memory>
-#include <cstdio>
-#include <cmath>
 #include <string>
 #include <vector>
 
-#include <boost/tokenizer.hpp>
 #include <boost/algorithm/string.hpp>
 #include <boost/spirit/include/qi.hpp>
+#include <boost/tokenizer.hpp>
 
 #include <clipper2/clipper.offset.h>
 
 #include "geometry/ClipperUtils.h"
 #include "libsvg/circle.h"
+#include "libsvg/data.h"
 #include "libsvg/ellipse.h"
+#include "libsvg/group.h"
 #include "libsvg/line.h"
-#include "libsvg/text.h"
-#include "libsvg/tspan.h"
-#include "libsvg/data.h"
+#include "libsvg/path.h"
 #include "libsvg/polygon.h"
 #include "libsvg/polyline.h"
 #include "libsvg/rect.h"
 #include "libsvg/svgpage.h"
-#include "libsvg/path.h"
-#include "libsvg/group.h"
+#include "libsvg/text.h"
+#include "libsvg/tspan.h"
 #include "libsvg/use.h"
 
 #include "libsvg/transformation.h"
-#include "utils/degree_trig.h"
 #include "utils/calc.h"
+#include "utils/degree_trig.h"
 
 namespace libsvg {
 
-shape *
-shape::create_from_name(const char *name)
-{
+shape *shape::create_from_name(const char *name) {
   if (circle::name == name) {
     return new circle();
   } else if (ellipse::name == name) {
@@ -92,9 +90,7 @@ shape::create_from_name(const char *name)
   }
 }
 
-void
-shape::set_attrs(attr_map_t& attrs, void *context)
-{
+void shape::set_attrs(attr_map_t &attrs, void *context) {
   if (attrs.find("id") != attrs.end()) {
     this->id = attrs["id"];
   }
@@ -116,7 +112,8 @@ shape::set_attrs(attr_map_t& attrs, void *context)
   }
 
   const std::string inkscape_groupmode = attrs["inkscape:groupmode"];
-  if (inkscape_groupmode == "layer" && attrs.find("inkscape:label") != attrs.end()) {
+  if (inkscape_groupmode == "layer" &&
+      attrs.find("inkscape:label") != attrs.end()) {
     this->layer = attrs["inkscape:label"];
   }
 
@@ -124,13 +121,11 @@ shape::set_attrs(attr_map_t& attrs, void *context)
   selected = (ctx->selector) ? ctx->selector(this) : false;
 }
 
-const std::string
-shape::get_style(const std::string& name) const
-{
+const std::string shape::get_style(const std::string &name) const {
   std::vector<std::string> styles;
   boost::split(styles, this->style, boost::is_any_of(";"));
 
-  for (const auto& style : styles) {
+  for (const auto &style : styles) {
     std::vector<std::string> values;
     boost::split(values, style, boost::is_any_of(":"));
     if (values.size() != 2) {
@@ -145,9 +140,7 @@ shape::get_style(const std::string& name) const
   return std::string();
 }
 
-double
-shape::get_stroke_width() const
-{
+double shape::get_stroke_width() const {
   double stroke_width;
   if (this->stroke_width.empty()) {
     stroke_width = parse_double(get_style("stroke-width"));
@@ -157,9 +150,7 @@ shape::get_stroke_width() const
   return stroke_width < 0.01 ? 1 : stroke_width;
 }
 
-Clipper2Lib::EndType
-shape::get_stroke_linecap() const
-{
+Clipper2Lib::EndType shape::get_stroke_linecap() const {
   std::string cap;
   if (this->stroke_linecap.empty()) {
     cap = get_style("stroke-linecap");
@@ -177,9 +168,7 @@ shape::get_stroke_linecap() const
   return Clipper2Lib::EndType::Butt;
 }
 
-Clipper2Lib::JoinType
-shape::get_stroke_linejoin() const
-{
+Clipper2Lib::JoinType shape::get_stroke_linejoin() const {
   std::string join;
   if (this->stroke_linejoin.empty()) {
     join = get_style("stroke-linejoin");
@@ -196,9 +185,8 @@ shape::get_stroke_linejoin() const
   return Clipper2Lib::JoinType::Miter;
 }
 
-void
-shape::collect_transform_matrices(std::vector<Eigen::Matrix3d>& matrices, shape *s)
-{
+void shape::collect_transform_matrices(std::vector<Eigen::Matrix3d> &matrices,
+                                       shape *s) {
   std::string transform_arg(s->transform);
 
   boost::replace_all(transform_arg, "matrix", "m");
@@ -216,7 +204,7 @@ shape::collect_transform_matrices(std::vector<Eigen::Matrix3d>& matrices, shape
 
   transformation *t = nullptr;
   std::vector<transformation *> transformations;
-  for (const auto& v : tokens) {
+  for (const auto &v : tokens) {
     if ((v.length() == 1) && (commands.find(v) != std::string::npos)) {
       if (t != nullptr) {
         transformations.push_back(t);
@@ -263,28 +251,26 @@ shape::collect_transform_matrices(std::vector<Eigen::Matrix3d>& matrices, shape
   }
 }
 
-bool
-shape::is_excluded() const
-{
+bool shape::is_excluded() const {
   for (const shape *s = this; s != nullptr; s = s->get_parent()) {
-    if (s->selected) return false;
-    if (s->excluded) return true;
+    if (s->selected)
+      return false;
+    if (s->excluded)
+      return true;
   }
   return true;
 }
 
-void
-shape::apply_transform()
-{
+void shape::apply_transform() {
   std::vector<Eigen::Matrix3d> matrices;
   for (shape *s = this; s->get_parent() != nullptr; s = s->get_parent()) {
     collect_transform_matrices(matrices, s);
   }
 
   path_list_t result_list;
-  for (const auto& p : path_list) {
+  for (const auto &p : path_list) {
     result_list.push_back(path_t());
-    for (const auto& v : p) {
+    for (const auto &v : p) {
       Eigen::Vector3d result(v.x(), v.y(), 1);
       for (auto it3 = matrices.rbegin(); it3 != matrices.rend(); ++it3) {
         result = *it3 * result;
@@ -296,13 +282,14 @@ shape::apply_transform()
   path_list = result_list;
 }
 
-void
-shape::offset_path(path_list_t& path_list, path_t& path, double stroke_width, Clipper2Lib::EndType stroke_linecap) {
+void shape::offset_path(path_list_t &path_list, path_t &path,
+                        double stroke_width,
+                        Clipper2Lib::EndType stroke_linecap) {
   const int scale_bits = ClipperUtils::scaleBitsFromPrecision();
   const double scale = std::ldexp(1.0, scale_bits);
 
   Clipper2Lib::Path64 line;
-  for (const auto& v : path) {
+  for (const auto &v : path) {
     line.emplace_back(v.x() * scale, v.y() * scale);
   }
 
@@ -311,21 +298,25 @@ shape::offset_path(path_list_t& path_list, path_t& path, double stroke_width, Cl
   Clipper2Lib::Paths64 result;
   co.Execute(stroke_width * scale / 2, result);
 
-  for (const auto& p : result) {
+  for (const auto &p : result) {
     path_list.push_back(path_t());
-    for (const auto& point : p) {
-      path_list.back().push_back(Eigen::Vector3d(point.x / scale, point.y / scale, 0));
+    for (const auto &point : p) {
+      path_list.back().push_back(
+          Eigen::Vector3d(point.x / scale, point.y / scale, 0));
     }
-    path_list.back().push_back(Eigen::Vector3d(p[0].x / scale, p[0].y / scale, 0));
+    path_list.back().push_back(
+        Eigen::Vector3d(p[0].x / scale, p[0].y / scale, 0));
   }
 }
 
-void
-shape::draw_ellipse(path_t& path, double x, double y, double rx, double ry, void *context) {
+void shape::draw_ellipse(path_t &path, double x, double y, double rx, double ry,
+                         void *context) {
   const auto *fValues = reinterpret_cast<const fnContext *>(context);
   double rmax = fmax(rx, ry);
-  unsigned long fn = Calc::get_fragments_from_r(rmax, fValues->fn, fValues->fs, fValues->fa);
-  if (fn < 40) fn = 40;   // preserve the old minimum value
+  unsigned long fn =
+      Calc::get_fragments_from_r(rmax, fValues->fn, fValues->fs, fValues->fa);
+  if (fn < 40)
+    fn = 40; // preserve the old minimum value
   for (unsigned long idx = 1; idx <= fn; ++idx) {
     const double a = idx * 360.0 / fn;
     const double xx = rx * sin_degrees(a) + x;
@@ -334,24 +325,24 @@ shape::draw_ellipse(path_t& path, double x, double y, double rx, double ry, void
   }
 }
 
-std::vector<std::shared_ptr<shape>>
-shape::clone_children() {
+std::vector<std::shared_ptr<shape>> shape::clone_children() {
   std::vector<std::shared_ptr<shape>> ret_vector;
   std::vector<shape *> children_backup = this->get_children();
   this->children.clear();
-  for (const auto& c : children_backup) {
+  for (const auto &c : children_backup) {
     shape *clone = c->clone();
     this->add_child(clone);
     auto cloned_children = clone->clone_children();
     ret_vector.push_back(std::shared_ptr<shape>(clone));
-    ret_vector.insert(ret_vector.end(), cloned_children.begin(), cloned_children.end());
+    ret_vector.insert(ret_vector.end(), cloned_children.begin(),
+                      cloned_children.end());
   }
   return ret_vector;
 }
 
-std::ostream& operator<<(std::ostream& os, const shape& s)
-{
-  return os << s.dump() << " | id = '" << s.id.value_or("") << "', transform = '" << s.transform << "'";
+std::ostream &operator<<(std::ostream &os, const shape &s) {
+  return os << s.dump() << " | id = '" << s.id.value_or("")
+            << "', transform = '" << s.transform << "'";
 }
 
 } // namespace libsvg
diff --git a/src/libsvg/shape.h b/src/libsvg/shape.h
index 183bc49b0..4084604a2 100644
--- a/src/libsvg/shape.h
+++ b/src/libsvg/shape.h
@@ -24,12 +24,12 @@
  */
 #pragma once
 
-#include <map>
 #include <atomic>
+#include <functional>
+#include <map>
+#include <memory>
 #include <string>
 #include <vector>
-#include <memory>
-#include <functional>
 
 #include <iostream>
 
@@ -44,18 +44,23 @@ namespace libsvg {
 class shape;
 }
 
-// ccox - I don't like putting this here, but the svg library code did not plan ahead for app customization.
-// And this is one of the few sensible places to put it without adding new header files.
+// ccox - I don't like putting this here, but the svg library code did not plan
+// ahead for app customization. And this is one of the few sensible places to
+// put it without adding new header files.
 struct fnContext {
-  fnContext(double fNN, double fSS, double fAA) : fn(fNN), fs(fSS), fa(fAA) {
+  fnContext(double fNN, double fSS, double fAA) : fn(fNN), fs(fSS), fa(fAA) {}
+  bool match(bool val) {
+    if (val)
+      matches++;
+    return val;
   }
-  bool match(bool val) { if (val) matches++; return val; }
   bool has_matches() { return matches.load() > 0; }
 
   double fn;
   double fs;
   double fa;
-  std::function<bool (const libsvg::shape *)> selector;
+  std::function<bool(const libsvg::shape *)> selector;
+
 private:
   std::atomic<int> matches{0};
 };
@@ -66,8 +71,7 @@ using path_t = std::vector<Eigen::Vector3d>;
 using path_list_t = std::vector<path_t>;
 using attr_map_t = std::map<std::string, std::string>;
 
-class shape
-{
+class shape {
 private:
   shape *parent{nullptr};
   std::vector<shape *> children;
@@ -89,10 +93,13 @@ protected:
   [[nodiscard]] double get_stroke_width() const;
   [[nodiscard]] Clipper2Lib::EndType get_stroke_linecap() const;
   [[nodiscard]] Clipper2Lib::JoinType get_stroke_linejoin() const;
-  [[nodiscard]] const std::string get_style(const std::string& name) const;
-  void draw_ellipse(path_t& path, double x, double y, double rx, double ry, void *context);
-  void offset_path(path_list_t& path_list, path_t& path, double stroke_width, Clipper2Lib::EndType stroke_linecap);
-  void collect_transform_matrices(std::vector<Eigen::Matrix3d>& matrices, shape *s);
+  [[nodiscard]] const std::string get_style(const std::string &name) const;
+  void draw_ellipse(path_t &path, double x, double y, double rx, double ry,
+                    void *context);
+  void offset_path(path_list_t &path_list, path_t &path, double stroke_width,
+                   Clipper2Lib::EndType stroke_linecap);
+  void collect_transform_matrices(std::vector<Eigen::Matrix3d> &matrices,
+                                  shape *s);
 
 public:
   shape() = default;
@@ -100,26 +107,40 @@ public:
 
   [[nodiscard]] virtual shape *get_parent() const { return parent; }
   virtual void set_parent(shape *s) { parent = s; }
-  virtual void add_child(shape *s) { children.push_back(s); s->set_parent(this); }
-  [[nodiscard]] virtual const std::vector<shape *>& get_children() const { return children; }
+  virtual void add_child(shape *s) {
+    children.push_back(s);
+    s->set_parent(this);
+  }
+  [[nodiscard]] virtual const std::vector<shape *> &get_children() const {
+    return children;
+  }
 
   [[nodiscard]] virtual bool has_id() const { return id.is_initialized(); }
-  [[nodiscard]] virtual const std::string& get_id() const { return id.get(); }
-  [[nodiscard]] virtual const std::string get_id_or_default(const std::string& def = "") const { return id.get_value_or(def); }
-  [[nodiscard]] virtual bool has_layer() const { return layer.is_initialized(); }
-  [[nodiscard]] virtual const std::string& get_layer() const { return layer.get(); }
+  [[nodiscard]] virtual const std::string &get_id() const { return id.get(); }
+  [[nodiscard]] virtual const std::string
+  get_id_or_default(const std::string &def = "") const {
+    return id.get_value_or(def);
+  }
+  [[nodiscard]] virtual bool has_layer() const {
+    return layer.is_initialized();
+  }
+  [[nodiscard]] virtual const std::string &get_layer() const {
+    return layer.get();
+  }
   [[nodiscard]] virtual double get_x() const { return x; }
   [[nodiscard]] virtual double get_y() const { return y; }
 
-  [[nodiscard]] virtual const path_list_t& get_path_list() const { return path_list; }
+  [[nodiscard]] virtual const path_list_t &get_path_list() const {
+    return path_list;
+  }
 
   [[nodiscard]] virtual bool is_excluded() const;
   [[nodiscard]] virtual bool is_container() const { return false; }
 
   virtual void apply_transform();
 
-  [[nodiscard]] virtual const std::string& get_name() const = 0;
-  virtual void set_attrs(attr_map_t& attrs, void *context);
+  [[nodiscard]] virtual const std::string &get_name() const = 0;
+  virtual void set_attrs(attr_map_t &attrs, void *context);
   [[nodiscard]] virtual const std::string dump() const { return ""; }
 
   static shape *create_from_name(const char *name);
@@ -128,7 +149,7 @@ public:
   std::vector<std::shared_ptr<shape>> clone_children();
 
 private:
-  friend std::ostream& operator<<(std::ostream& os, const shape& s);
+  friend std::ostream &operator<<(std::ostream &os, const shape &s);
 };
 
 } // namespace libsvg
diff --git a/src/libsvg/svgpage.cc b/src/libsvg/svgpage.cc
index 5401dd64a..8d2dea87c 100644
--- a/src/libsvg/svgpage.cc
+++ b/src/libsvg/svgpage.cc
@@ -24,23 +24,19 @@
  */
 #include "libsvg/svgpage.h"
 
-#include <sstream>
 #include <cstdlib>
-#include <string>
 #include <iostream>
-
+#include <sstream>
+#include <string>
 
 namespace libsvg {
 
 const std::string svgpage::name("svg");
 
-svgpage::svgpage() : width({0.0, unit_t::UNDEFINED}), height({0.0, unit_t::UNDEFINED})
-{
-}
+svgpage::svgpage()
+    : width({0.0, unit_t::UNDEFINED}), height({0.0, unit_t::UNDEFINED}) {}
 
-void
-svgpage::set_attrs(attr_map_t& attrs, void *context)
-{
+void svgpage::set_attrs(attr_map_t &attrs, void *context) {
   this->x = 0;
   this->y = 0;
   this->width = parse_length(attrs["width"]);
@@ -52,22 +48,14 @@ svgpage::set_attrs(attr_map_t& attrs, void *context)
   selected = (ctx->selector) ? ctx->selector(this) : false;
 }
 
-const std::string
-svgpage::dump() const
-{
+const std::string svgpage::dump() const {
   std::stringstream s;
-  s << get_name()
-    << ": x = " << this->x
-    << ": y = " << this->y
-    << ": width = " << this->width
-    << ": height = " << this->height
-    << ": viewbox = " << this->viewbox.x
-    << "," << this->viewbox.y
-    << "," << this->viewbox.width
-    << "," << this->viewbox.height
+  s << get_name() << ": x = " << this->x << ": y = " << this->y
+    << ": width = " << this->width << ": height = " << this->height
+    << ": viewbox = " << this->viewbox.x << "," << this->viewbox.y << ","
+    << this->viewbox.width << "," << this->viewbox.height
     << (this->viewbox.is_valid ? " (valid)" : " (invalid)")
-    << ": alignment = " << this->alignment.x
-    << "," << this->alignment.y
+    << ": alignment = " << this->alignment.x << "," << this->alignment.y
     << (this->alignment.meet ? " meet" : " slice");
   return s.str();
 }
diff --git a/src/libsvg/svgpage.h b/src/libsvg/svgpage.h
index 7f5f76637..a6c78155c 100644
--- a/src/libsvg/svgpage.h
+++ b/src/libsvg/svgpage.h
@@ -24,14 +24,13 @@
  */
 #pragma once
 
-#include <string>
 #include "libsvg/shape.h"
 #include "libsvg/util.h"
+#include <string>
 
 namespace libsvg {
 
-class svgpage : public shape
-{
+class svgpage : public shape {
 protected:
   length_t width;
   length_t height;
@@ -41,19 +40,21 @@ protected:
 public:
   svgpage();
 
-  [[nodiscard]] const length_t& get_width() const { return width; }
-  [[nodiscard]] const length_t& get_height() const { return height; }
-  [[nodiscard]] const viewbox_t& get_viewbox() const { return viewbox; }
-  [[nodiscard]] const alignment_t& get_alignment() const { return alignment; }
+  [[nodiscard]] const length_t &get_width() const { return width; }
+  [[nodiscard]] const length_t &get_height() const { return height; }
+  [[nodiscard]] const viewbox_t &get_viewbox() const { return viewbox; }
+  [[nodiscard]] const alignment_t &get_alignment() const { return alignment; }
   [[nodiscard]] bool is_container() const override { return true; }
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
+  void set_attrs(attr_map_t &attrs, void *context) override;
   [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return svgpage::name; }
+  [[nodiscard]] const std::string &get_name() const override {
+    return svgpage::name;
+  }
 
   static const std::string name;
 
   [[nodiscard]] shape *clone() const override { return new svgpage(*this); }
 };
 
-}
+} // namespace libsvg
diff --git a/src/libsvg/text.cc b/src/libsvg/text.cc
index 0ebad3c89..ec95d3bb6 100644
--- a/src/libsvg/text.cc
+++ b/src/libsvg/text.cc
@@ -24,17 +24,15 @@
  */
 #include "libsvg/text.h"
 
+#include "libsvg/util.h"
 #include <sstream>
 #include <string>
-#include "libsvg/util.h"
 
 namespace libsvg {
 
 const std::string text::name("text");
 
-void
-text::set_attrs(attr_map_t& attrs, void *context)
-{
+void text::set_attrs(attr_map_t &attrs, void *context) {
   shape::set_attrs(attrs, context);
   this->x = parse_double(attrs["x"]);
   this->y = parse_double(attrs["y"]);
@@ -42,15 +40,10 @@ text::set_attrs(attr_map_t& attrs, void *context)
   this->dy = parse_double(attrs["dy"]);
 }
 
-const std::string
-text::dump() const
-{
+const std::string text::dump() const {
   std::stringstream s;
-  s << get_name()
-    << ": x = " << this->x
-    << ": y = " << this->y
-    << ": dx = " << this->dx
-    << ": dy = " << this->dy;
+  s << get_name() << ": x = " << this->x << ": y = " << this->y
+    << ": dx = " << this->dx << ": dy = " << this->dy;
   return s.str();
 }
 
diff --git a/src/libsvg/text.h b/src/libsvg/text.h
index ebf75ab3c..4d3f0fca2 100644
--- a/src/libsvg/text.h
+++ b/src/libsvg/text.h
@@ -24,13 +24,12 @@
  */
 #pragma once
 
-#include <string>
 #include "libsvg/shape.h"
+#include <string>
 
 namespace libsvg {
 
-class text : public shape
-{
+class text : public shape {
 private:
   double dx{0};
   double dy{0};
@@ -44,16 +43,24 @@ public:
 
   [[nodiscard]] bool is_container() const override { return true; }
 
-  [[nodiscard]] double get_dx() const { return dx; } // NOLINT(bugprone-virtual-near-miss)
-  [[nodiscard]] double get_dy() const { return dy; } // NOLINT(bugprone-virtual-near-miss)
+  [[nodiscard]] double get_dx() const {
+    return dx;
+  } // NOLINT(bugprone-virtual-near-miss)
+  [[nodiscard]] double get_dy() const {
+    return dy;
+  } // NOLINT(bugprone-virtual-near-miss)
   [[nodiscard]] double get_rotate() const { return rotate; }
   [[nodiscard]] double get_text_length() const { return text_length; }
-  [[nodiscard]] const std::string& get_font_family() const { return font_family; }
+  [[nodiscard]] const std::string &get_font_family() const {
+    return font_family;
+  }
   [[nodiscard]] int get_font_size() const { return font_size; }
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
+  void set_attrs(attr_map_t &attrs, void *context) override;
   [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return text::name; }
+  [[nodiscard]] const std::string &get_name() const override {
+    return text::name;
+  }
 
   static const std::string name;
 
diff --git a/src/libsvg/transformation.cc b/src/libsvg/transformation.cc
index 49821e063..4ecca3582 100644
--- a/src/libsvg/transformation.cc
+++ b/src/libsvg/transformation.cc
@@ -24,25 +24,22 @@
  */
 #include "libsvg/transformation.h"
 
+#include <iostream>
 #include <sstream>
 #include <string>
 #include <vector>
-#include <iostream>
 
 #include "libsvg/util.h"
 #include "utils/degree_trig.h"
 
 namespace libsvg {
 
-void
-transformation::add_arg(const std::string& arg)
-{
+void transformation::add_arg(const std::string &arg) {
   double d = parse_double(arg);
   args.push_back(d);
 }
 
-const std::string
-transformation::get_args() const {
+const std::string transformation::get_args() const {
   std::ostringstream str;
   for (unsigned int a = 0; a < args.size(); ++a) {
     str << ((a == 0) ? "(" : ", ") << args[a];
@@ -51,45 +48,34 @@ transformation::get_args() const {
   return str.str();
 }
 
-matrix::matrix() : transformation("m", "matrix")
-{
-}
+matrix::matrix() : transformation("m", "matrix") {}
 
 /**
  * matrix(<a> <b> <c> <d> <e> <f>), which specifies a transformation in
  * the form of a transformation matrix of six values. matrix(a,b,c,d,e,f)
  * is equivalent to applying the transformation matrix [a b c d e f].
  */
-std::vector<Eigen::Matrix3d>
-matrix::get_matrices()
-{
+std::vector<Eigen::Matrix3d> matrix::get_matrices() {
   if (args.size() != 6) {
     std::cout << "invalid arguments for matrix" << std::endl;
     return {};
   }
 
   Eigen::Matrix3d m;
-  m <<
-    args[0], args[2], args[4],
-    args[1], args[3], args[5],
-    0, 0, 1;
+  m << args[0], args[2], args[4], args[1], args[3], args[5], 0, 0, 1;
 
   std::vector<Eigen::Matrix3d> result;
   result.push_back(m);
   return result;
 }
 
-translate::translate() : transformation("t", "translate")
-{
-}
+translate::translate() : transformation("t", "translate") {}
 
 /**
  * translate(<tx> [<ty>]), which specifies a translation by tx and ty.
  * If <ty> is not provided, it is assumed to be zero.
  */
-std::vector<Eigen::Matrix3d>
-translate::get_matrices()
-{
+std::vector<Eigen::Matrix3d> translate::get_matrices() {
   if ((args.size() < 1) || (args.size() > 2)) {
     std::cout << "invalid arguments for " << get_name() << std::endl;
     return {};
@@ -99,27 +85,20 @@ translate::get_matrices()
   double ty = args.size() > 1 ? args[1] : 0;
 
   Eigen::Matrix3d m;
-  m <<
-    1, 0, tx,
-    0, 1, ty,
-    0, 0, 1;
+  m << 1, 0, tx, 0, 1, ty, 0, 0, 1;
 
   std::vector<Eigen::Matrix3d> result;
   result.push_back(m);
   return result;
 }
 
-scale::scale() : transformation("s", "scale")
-{
-}
+scale::scale() : transformation("s", "scale") {}
 
 /**
  * scale(<sx> [<sy>]), which specifies a scale operation by sx and sy.
  * If <sy> is not provided, it is assumed to be equal to <sx>.
  */
-std::vector<Eigen::Matrix3d>
-scale::get_matrices()
-{
+std::vector<Eigen::Matrix3d> scale::get_matrices() {
   if ((args.size() < 1) || (args.size() > 2)) {
     std::cout << "invalid arguments for " << get_name() << std::endl;
     return {};
@@ -129,19 +108,14 @@ scale::get_matrices()
   double sy = args.size() > 1 ? args[1] : args[0];
 
   Eigen::Matrix3d m;
-  m <<
-    sx,  0, 0,
-    0, sy, 0,
-    0,  0, 1;
+  m << sx, 0, 0, 0, sy, 0, 0, 0, 1;
 
   std::vector<Eigen::Matrix3d> result;
   result.push_back(m);
   return result;
 }
 
-rotate::rotate() : transformation("r", "rotate")
-{
-}
+rotate::rotate() : transformation("r", "rotate") {}
 
 /**
  * rotate(<rotate-angle> [<cx> <cy>]), which specifies a rotation by
@@ -154,9 +128,7 @@ rotate::rotate() : transformation("r", "rotate")
  * the following specification: translate(<cx>, <cy>) rotate(<rotate-angle>)
  * translate(-<cx>, -<cy>).
  */
-std::vector<Eigen::Matrix3d>
-rotate::get_matrices()
-{
+std::vector<Eigen::Matrix3d> rotate::get_matrices() {
   if ((args.size() != 1) && (args.size() != 3)) {
     std::cout << "invalid arguments for " << get_name() << std::endl;
     return {};
@@ -172,10 +144,7 @@ rotate::get_matrices()
 
   if (has_center) {
     Eigen::Matrix3d t;
-    t <<
-      1, 0, -cx,
-      0, 1, -cy,
-      0, 0, 1;
+    t << 1, 0, -cx, 0, 1, -cy, 0, 0, 1;
     result.push_back(t);
   }
 
@@ -183,26 +152,19 @@ rotate::get_matrices()
 
   if (has_center) {
     Eigen::Matrix3d t;
-    t <<
-      1, 0, cx,
-      0, 1, cy,
-      0, 0, 1;
+    t << 1, 0, cx, 0, 1, cy, 0, 0, 1;
     result.push_back(t);
   }
 
   return result;
 }
 
-skew_x::skew_x() : transformation("x", "skew_x")
-{
-}
+skew_x::skew_x() : transformation("x", "skew_x") {}
 
 /**
  * skewX(<skew-angle>), which specifies a skew transformation along the x-axis.
  */
-std::vector<Eigen::Matrix3d>
-skew_x::get_matrices()
-{
+std::vector<Eigen::Matrix3d> skew_x::get_matrices() {
   if (args.size() != 1) {
     std::cout << "invalid arguments for " << get_name() << std::endl;
     return {};
@@ -211,26 +173,19 @@ skew_x::get_matrices()
   double angle = args[0];
 
   Eigen::Matrix3d m;
-  m <<
-    1, tan_degrees(angle), 0,
-    0, 1,                  0,
-    0, 0,                  1;
+  m << 1, tan_degrees(angle), 0, 0, 1, 0, 0, 0, 1;
 
   std::vector<Eigen::Matrix3d> result;
   result.push_back(m);
   return result;
 }
 
-skew_y::skew_y() : transformation("y", "skew_y")
-{
-}
+skew_y::skew_y() : transformation("y", "skew_y") {}
 
 /**
  * skewY(<skew-angle>), which specifies a skew transformation along the y-axis.
  */
-std::vector<Eigen::Matrix3d>
-skew_y::get_matrices()
-{
+std::vector<Eigen::Matrix3d> skew_y::get_matrices() {
   if (args.size() != 1) {
     std::cout << "invalid arguments for " << get_name() << std::endl;
     return {};
@@ -239,10 +194,7 @@ skew_y::get_matrices()
   double angle = args[0];
 
   Eigen::Matrix3d m;
-  m <<
-    1, 0, 0,
-    tan_degrees(angle), 1, 0,
-    0, 0, 1;
+  m << 1, 0, 0, tan_degrees(angle), 1, 0, 0, 0, 1;
 
   std::vector<Eigen::Matrix3d> result;
   result.push_back(m);
diff --git a/src/libsvg/transformation.h b/src/libsvg/transformation.h
index d1c46a4e0..71b7abf49 100644
--- a/src/libsvg/transformation.h
+++ b/src/libsvg/transformation.h
@@ -24,8 +24,8 @@
  */
 #pragma once
 
-#include <utility>
 #include <string>
+#include <utility>
 #include <vector>
 
 #include <Eigen/Core>
@@ -33,68 +33,63 @@
 
 namespace libsvg {
 
-class transformation
-{
+class transformation {
 private:
   const std::string op;
   const std::string name;
+
 protected:
   std::vector<double> args;
 
 public:
-  transformation(std::string op, std::string name) : op(std::move(op)), name(std::move(name)) { }
+  transformation(std::string op, std::string name)
+      : op(std::move(op)), name(std::move(name)) {}
   virtual ~transformation() = default;
 
-  [[nodiscard]] const std::string& get_op() const { return op; }
-  [[nodiscard]] const std::string& get_name() const { return name; }
+  [[nodiscard]] const std::string &get_op() const { return op; }
+  [[nodiscard]] const std::string &get_name() const { return name; }
   [[nodiscard]] const std::string get_args() const;
 
-  void add_arg(const std::string& arg);
+  void add_arg(const std::string &arg);
   virtual std::vector<Eigen::Matrix3d> get_matrices() = 0;
 };
 
-class matrix : public transformation
-{
+class matrix : public transformation {
 public:
   matrix();
 
   std::vector<Eigen::Matrix3d> get_matrices() override;
 };
 
-class translate : public transformation
-{
+class translate : public transformation {
 public:
   translate();
 
   std::vector<Eigen::Matrix3d> get_matrices() override;
 };
 
-class scale : public transformation
-{
+class scale : public transformation {
 public:
   scale();
 
   std::vector<Eigen::Matrix3d> get_matrices() override;
 };
 
-class rotate : public transformation
-{
+class rotate : public transformation {
 public:
   rotate();
 
   std::vector<Eigen::Matrix3d> get_matrices() override;
 };
 
-class skew_x : public transformation
-{
+class skew_x : public transformation {
 public:
   skew_x();
 
   std::vector<Eigen::Matrix3d> get_matrices() override;
 };
 
-class skew_y : public transformation
-{
+class skew_y : public transformation {
 public:
   skew_y();
 
diff --git a/src/libsvg/tspan.cc b/src/libsvg/tspan.cc
index e54287b14..7c662e8c2 100644
--- a/src/libsvg/tspan.cc
+++ b/src/libsvg/tspan.cc
@@ -33,9 +33,7 @@ namespace libsvg {
 
 const std::string tspan::name("tspan");
 
-void
-tspan::set_attrs(attr_map_t& attrs, void *context)
-{
+void tspan::set_attrs(attr_map_t &attrs, void *context) {
   shape::set_attrs(attrs, context);
   this->x = parse_double(attrs["x"]);
   this->y = parse_double(attrs["y"]);
@@ -43,15 +41,10 @@ tspan::set_attrs(attr_map_t& attrs, void *context)
   this->dy = parse_double(attrs["dy"]);
 }
 
-const std::string
-tspan::dump() const
-{
+const std::string tspan::dump() const {
   std::stringstream s;
-  s << get_name()
-    << ": x = " << this->x
-    << ": y = " << this->y
-    << ": dx = " << this->dx
-    << ": dy = " << this->dy;
+  s << get_name() << ": x = " << this->x << ": y = " << this->y
+    << ": dx = " << this->dx << ": dy = " << this->dy;
   return s.str();
 }
 
diff --git a/src/libsvg/tspan.h b/src/libsvg/tspan.h
index d6ea4a23e..c0edf959b 100644
--- a/src/libsvg/tspan.h
+++ b/src/libsvg/tspan.h
@@ -24,13 +24,12 @@
  */
 #pragma once
 
-#include <string>
 #include "libsvg/shape.h"
+#include <string>
 
 namespace libsvg {
 
-class tspan : public shape
-{
+class tspan : public shape {
 private:
   double dx{0};
   double dy{0};
@@ -44,16 +43,24 @@ public:
 
   [[nodiscard]] bool is_container() const override { return true; }
 
-  [[nodiscard]] double get_dx() const { return dx; } // NOLINT(bugprone-virtual-near-miss)
-  [[nodiscard]] double get_dy() const { return dy; } // NOLINT(bugprone-virtual-near-miss)
+  [[nodiscard]] double get_dx() const {
+    return dx;
+  } // NOLINT(bugprone-virtual-near-miss)
+  [[nodiscard]] double get_dy() const {
+    return dy;
+  } // NOLINT(bugprone-virtual-near-miss)
   [[nodiscard]] double get_rotate() const { return rotate; }
   [[nodiscard]] double get_text_length() const { return text_length; }
-  [[nodiscard]] const std::string& get_font_family() const { return font_family; }
+  [[nodiscard]] const std::string &get_font_family() const {
+    return font_family;
+  }
   [[nodiscard]] int get_font_size() const { return font_size; }
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
+  void set_attrs(attr_map_t &attrs, void *context) override;
   [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return tspan::name; }
+  [[nodiscard]] const std::string &get_name() const override {
+    return tspan::name;
+  }
 
   static const std::string name;
 
diff --git a/src/libsvg/use.cc b/src/libsvg/use.cc
index 50f281f86..44965f75d 100644
--- a/src/libsvg/use.cc
+++ b/src/libsvg/use.cc
@@ -24,10 +24,10 @@
  */
 #include "libsvg/use.h"
 
-#include <sstream>
-#include <memory>
 #include <cstdlib>
 #include <iostream>
+#include <memory>
+#include <sstream>
 #include <string>
 #include <vector>
 
@@ -37,15 +37,14 @@ namespace libsvg {
 
 const std::string use::name("use");
 
-void
-use::set_attrs(attr_map_t& attrs, void *context)
-{
+void use::set_attrs(attr_map_t &attrs, void *context) {
   shape::set_attrs(attrs, context);
   this->x = parse_double(attrs["x"]);
   this->y = parse_double(attrs["y"]);
 
-  //Note: width, and height have no effect on use elements, unless the element referenced has a viewbox - i.e. they only have an effect when use refers to a svg or symbol element.
-  //Lets store them, but I am not going to use them.
+  // Note: width, and height have no effect on use elements, unless the element
+  // referenced has a viewbox - i.e. they only have an effect when use refers to
+  // a svg or symbol element. Lets store them, but I am not going to use them.
   this->width = parse_double(attrs["width"]);
   this->height = parse_double(attrs["height"]);
 
@@ -57,28 +56,26 @@ use::set_attrs(attr_map_t& attrs, void *context)
   if (this->href != temp_href) {
     this->href = temp_href;
     if (href.rfind('#', 0) != 0) {
-      printf("<use> can only use references to ids in the href field (starting with #). Error in element type %s with id: %s\n", this->get_name().c_str(), this->get_id_or_default().c_str());
+      printf("<use> can only use references to ids in the href field (starting "
+             "with #). Error in element type %s with id: %s\n",
+             this->get_name().c_str(), this->get_id_or_default().c_str());
     }
   }
 
-  //apply the x/y coordinates to all the children by using a transform
+  // apply the x/y coordinates to all the children by using a transform
   std::stringstream s;
   s << this->transform << " translate(" << this->x << "," << this->y << ")";
   this->transform = s.str();
 }
 
-const std::string
-use::get_href_id() const
-{
+const std::string use::get_href_id() const {
   if (href.rfind('#', 0) != 0) {
     return {};
   }
-  return href.substr(1); //remove the #
+  return href.substr(1); // remove the #
 }
 
-std::vector<std::shared_ptr<shape>>
-use::set_clone_child(shape *child)
-{
+std::vector<std::shared_ptr<shape>> use::set_clone_child(shape *child) {
   shape *copy = child->clone();
   copy->set_parent(this);
   auto cloned_objects = copy->clone_children();
@@ -86,13 +83,9 @@ use::set_clone_child(shape *child)
   return cloned_objects;
 }
 
-const std::string
-use::dump() const
-{
+const std::string use::dump() const {
   std::stringstream s;
-  s << get_name()
-    << ": x = " << this->x
-    << ": y = " << this->y;
+  s << get_name() << ": x = " << this->x << ": y = " << this->y;
   return s.str();
 }
 
diff --git a/src/libsvg/use.h b/src/libsvg/use.h
index 2e65b742a..f14627412 100644
--- a/src/libsvg/use.h
+++ b/src/libsvg/use.h
@@ -24,15 +24,14 @@
  */
 #pragma once
 
-#include <vector>
-#include <string>
-#include <memory>
 #include "libsvg/shape.h"
+#include <memory>
+#include <string>
+#include <vector>
 
 namespace libsvg {
 
-class use : public shape
-{
+class use : public shape {
 protected:
   std::string href;
   double width;
@@ -43,9 +42,11 @@ public:
 
   [[nodiscard]] bool is_container() const override { return false; }
 
-  void set_attrs(attr_map_t& attrs, void *context) override;
+  void set_attrs(attr_map_t &attrs, void *context) override;
   [[nodiscard]] const std::string dump() const override;
-  [[nodiscard]] const std::string& get_name() const override { return use::name; }
+  [[nodiscard]] const std::string &get_name() const override {
+    return use::name;
+  }
 
   static const std::string name;
 
diff --git a/src/libsvg/util.cc b/src/libsvg/util.cc
index d18db191e..620cd766c 100644
--- a/src/libsvg/util.cc
+++ b/src/libsvg/util.cc
@@ -24,26 +24,25 @@
  */
 #include "libsvg/util.h"
 
-#include <ostream>
 #include <boost/spirit/include/qi.hpp>
+#include <ostream>
 
 #include <string>
 #include <vector>
 
-// include fusion headers for Ubuntu trusty, everything later seems happy without
+// include fusion headers for Ubuntu trusty, everything later seems happy
+// without
 #include <boost/fusion/adapted/struct/adapt_struct.hpp>
 #include <boost/fusion/include/adapt_struct.hpp>
 
-
-BOOST_FUSION_ADAPT_STRUCT(libsvg::length_struct, (double, number)(std::string, unit))
+BOOST_FUSION_ADAPT_STRUCT(libsvg::length_struct,
+                          (double, number)(std::string, unit))
 
 namespace libsvg {
 
 namespace qi = boost::spirit::qi;
 
-double
-parse_double(const std::string& number)
-{
+double parse_double(const std::string &number) {
   std::string::const_iterator iter = number.begin(), end = number.end();
 
   qi::real_parser<double, qi::real_policies<double>> double_parser;
@@ -54,9 +53,7 @@ parse_double(const std::string& number)
   return result && iter == end ? d : 0;
 }
 
-static unit_t
-get_unit(const std::string& value)
-{
+static unit_t get_unit(const std::string &value) {
   if (value == "em") {
     return unit_t::EM;
   } else if (value == "ex") {
@@ -80,9 +77,7 @@ get_unit(const std::string& value)
   }
 }
 
-const length_t
-parse_length(const std::string& value)
-{
+const length_t parse_length(const std::string &value) {
   std::string::const_iterator it = value.begin(), end = value.end();
 
   qi::rule<std::string::const_iterator, length_struct(), qi::space_type> length;
@@ -91,7 +86,9 @@ parse_length(const std::string& value)
 
   length = number >> -unit;
   number = qi::double_;
-  unit = qi::string("em") | qi::string("ex") | qi::string("px") | qi::string("in") | qi::string("cm") | qi::string("mm") | qi::string("pt") | qi::string("pc") | qi::string("%");
+  unit = qi::string("em") | qi::string("ex") | qi::string("px") |
+         qi::string("in") | qi::string("cm") | qi::string("mm") |
+         qi::string("pt") | qi::string("pc") | qi::string("%");
 
   libsvg::length_struct parsed;
   qi::phrase_parse(it, end, length, qi::space, parsed);
@@ -105,12 +102,11 @@ parse_length(const std::string& value)
   return result;
 }
 
-const viewbox_t
-parse_viewbox(const std::string& value)
-{
+const viewbox_t parse_viewbox(const std::string &value) {
   std::string::const_iterator it = value.begin(), end = value.end();
 
-  qi::rule<std::string::const_iterator, std::vector<double>(), qi::space_type> viewbox;
+  qi::rule<std::string::const_iterator, std::vector<double>(), qi::space_type>
+      viewbox;
   qi::rule<std::string::const_iterator, double()> number;
   qi::rule<std::string::const_iterator> sep;
 
@@ -122,7 +118,8 @@ parse_viewbox(const std::string& value)
   qi::phrase_parse(it, end, viewbox, qi::space, parsed);
 
   viewbox_t result{0.0, 0.0, 0.0, 0.0, false};
-  if ((it != value.begin()) && (it == end) && (parsed.size() == 4) && (parsed[2] >= 0.0) && (parsed[3] >= 0.0)) {
+  if ((it != value.begin()) && (it == end) && (parsed.size() == 4) &&
+      (parsed[2] >= 0.0) && (parsed[3] >= 0.0)) {
     result.x = parsed[0];
     result.y = parsed[1];
     result.width = parsed[2];
@@ -133,22 +130,24 @@ parse_viewbox(const std::string& value)
   return result;
 }
 
-const alignment_t
-parse_alignment(const std::string& value)
-{
+const alignment_t parse_alignment(const std::string &value) {
   std::string::const_iterator it = value.begin(), end = value.end();
 
-  qi::rule<std::string::const_iterator, std::vector<std::string>(), qi::space_type> alignment;
+  qi::rule<std::string::const_iterator, std::vector<std::string>(),
+           qi::space_type>
+      alignment;
   qi::rule<std::string::const_iterator, std::vector<char>()> defer;
   qi::rule<std::string::const_iterator, std::vector<char>()> align;
   qi::rule<std::string::const_iterator, std::vector<char>()> meet_or_slice;
 
-  alignment = -qi::as_string[defer] >> qi::as_string[align] >> -qi::as_string[meet_or_slice];
+  alignment = -qi::as_string[defer] >> qi::as_string[align] >>
+              -qi::as_string[meet_or_slice];
   defer = qi::string("defer");
-  align = qi::string("none")
-    | qi::string("xMinYMin") | qi::string("xMidYMin") | qi::string("xMaxYMin")
-    | qi::string("xMinYMid") | qi::string("xMidYMid") | qi::string("xMaxYMid")
-    | qi::string("xMinYMax") | qi::string("xMidYMax") | qi::string("xMaxYMax");
+  align = qi::string("none") | qi::string("xMinYMin") | qi::string("xMidYMin") |
+          qi::string("xMaxYMin") | qi::string("xMinYMid") |
+          qi::string("xMidYMid") | qi::string("xMaxYMid") |
+          qi::string("xMinYMax") | qi::string("xMidYMax") |
+          qi::string("xMaxYMax");
   meet_or_slice = qi::string("meet") | qi::string("slice");
 
   std::vector<std::string> parsed;
@@ -202,8 +201,7 @@ parse_alignment(const std::string& value)
   return result;
 }
 
-std::ostream& operator<<(std::ostream& stream, const unit_t& unit)
-{
+std::ostream &operator<<(std::ostream &stream, const unit_t &unit) {
   switch (unit) {
   case unit_t::EM:
     stream << "em";
@@ -241,14 +239,12 @@ std::ostream& operator<<(std::ostream& stream, const unit_t& unit)
   return stream;
 }
 
-std::ostream& operator<<(std::ostream& stream, const length_t& length)
-{
+std::ostream &operator<<(std::ostream &stream, const length_t &length) {
   stream << length.number << length.unit;
   return stream;
 }
 
-std::ostream& operator<<(std::ostream& stream, const align_t& align)
-{
+std::ostream &operator<<(std::ostream &stream, const align_t &align) {
   switch (align) {
   case align_t::MIN:
     stream << "min";
diff --git a/src/libsvg/util.h b/src/libsvg/util.h
index c8973fd2f..9e1119a93 100644
--- a/src/libsvg/util.h
+++ b/src/libsvg/util.h
@@ -70,13 +70,13 @@ struct alignment_t {
   bool meet;
 };
 
-double parse_double(const std::string& number);
-const length_t parse_length(const std::string& value);
-const viewbox_t parse_viewbox(const std::string& value);
-const alignment_t parse_alignment(const std::string& value);
+double parse_double(const std::string &number);
+const length_t parse_length(const std::string &value);
+const viewbox_t parse_viewbox(const std::string &value);
+const alignment_t parse_alignment(const std::string &value);
 
-std::ostream& operator<<(std::ostream& stream, const unit_t& unit);
-std::ostream& operator<<(std::ostream& stream, const length_t& length);
-std::ostream& operator<<(std::ostream& stream, const align_t& align);
+std::ostream &operator<<(std::ostream &stream, const unit_t &unit);
+std::ostream &operator<<(std::ostream &stream, const length_t &length);
+std::ostream &operator<<(std::ostream &stream, const align_t &align);
 
 } // namespace libsvg
diff --git a/src/openscad.cc b/src/openscad.cc
index b9be46a5b..796bf2b64 100644
--- a/src/openscad.cc
+++ b/src/openscad.cc
@@ -27,8 +27,8 @@
 #include "openscad.h"
 
 #ifdef _WIN32
-#include <io.h>
 #include <fcntl.h>
+#include <io.h>
 #endif
 #include <array>
 #include <clocale>
@@ -75,21 +75,23 @@
 #include <CGAL/assertions_behaviour.h>
 #endif
 
+#include "Feature.h"
+#include "LibraryInfo.h"
+#include "RenderStatistic.h"
 #include "core/AST.h"
 #include "core/BuiltinContext.h"
 #include "core/Builtins.h"
-#include "core/Context.h"
 #include "core/CSGTreeEvaluator.h"
+#include "core/Context.h"
+#include "core/EvaluationSession.h"
+#include "core/RenderVariables.h"
+#include "core/ScopeContext.h"
+#include "core/Settings.h"
 #include "core/customizer/CommentParser.h"
 #include "core/customizer/ParameterObject.h"
 #include "core/customizer/ParameterSet.h"
-#include "core/EvaluationSession.h"
 #include "core/node.h"
 #include "core/parsersettings.h"
-#include "core/RenderVariables.h"
-#include "core/ScopeContext.h"
-#include "core/Settings.h"
-#include "Feature.h"
 #include "geometry/Geometry.h"
 #include "geometry/GeometryEvaluator.h"
 #include "geometry/GeometryUtils.h"
@@ -100,14 +102,12 @@
 #include "glview/RenderSettings.h"
 #include "handle_dep.h"
 #include "io/export.h"
-#include "LibraryInfo.h"
 #include "openscad_gui.h"
 #include "openscad_mimalloc.h"
 #include "platform/PlatformUtils.h"
-#include "RenderStatistic.h"
+#include "utils/StackCheck.h"
 #include "utils/exceptions.h"
 #include "utils/printutils.h"
-#include "utils/StackCheck.h"
 
 #ifdef ENABLE_PYTHON
 #include "python/python_public.h"
@@ -123,31 +123,28 @@ namespace {
 
 bool arg_info = false;
 
-}  // namespace
+} // namespace
 
-class Echostream
-{
+class Echostream {
 public:
-  Echostream(std::ostream& stream) : stream(stream)
-  {
+  Echostream(std::ostream &stream) : stream(stream) {
     set_output_handler(&Echostream::output, nullptr, this);
   }
-  Echostream(const std::string& filename) : fstream(filename), stream(fstream)
-  {
+  Echostream(const std::string &filename) : fstream(filename), stream(fstream) {
     set_output_handler(&Echostream::output, nullptr, this);
   }
-  static void output(const Message& msgObj, void *userdata)
-  {
+  static void output(const Message &msgObj, void *userdata) {
     auto self = static_cast<Echostream *>(userdata);
     self->stream << msgObj.str() << "\n";
   }
   ~Echostream() {
-    if (fstream.is_open()) fstream.close();
+    if (fstream.is_open())
+      fstream.close();
   }
 
 private:
   std::ofstream fstream;
-  std::ostream& stream;
+  std::ostream &stream;
 };
 
 struct AnimateArgs {
@@ -156,19 +153,18 @@ struct AnimateArgs {
   unsigned shard = 1;
 };
 
-struct CommandLine
-{
+struct CommandLine {
   const bool is_stdin;
-  const std::string& filename;
+  const std::string &filename;
   const bool is_stdout;
   std::string output_file;
-  const fs::path& original_path;
-  const std::string& parameterFile;
-  const std::string& setName;
-  const ViewOptions& viewOptions;
-  const Camera& camera;
+  const fs::path &original_path;
+  const std::string &parameterFile;
+  const std::string &setName;
+  const ViewOptions &viewOptions;
+  const Camera &camera;
   const boost::optional<FileFormat> export_format;
-  const CmdLineExportOptions& exportOptions;
+  const CmdLineExportOptions &exportOptions;
   const AnimateArgs animate;
   const std::vector<std::string> summaryOptions;
   const std::string summaryFile;
@@ -180,14 +176,14 @@ namespace {
 #define TOSTRING(x) STRINGIFY(x)
 
 #ifndef OPENSCAD_NOGUI
-bool useGUI()
-{
+bool useGUI() {
 #ifdef Q_OS_X11
   // see <http://qt.nokia.com/doc/4.5/qapplication.html#QApplication-2>:
-  // On X11, the window system is initialized if GUIenabled is true. If GUIenabled
-  // is false, the application does not connect to the X server. On Windows and
-  // Macintosh, currently the window system is always initialized, regardless of the
-  // value of GUIenabled. This may change in future versions of Qt.
+  // On X11, the window system is initialized if GUIenabled is true. If
+  // GUIenabled is false, the application does not connect to the X server. On
+  // Windows and Macintosh, currently the window system is always initialized,
+  // regardless of the value of GUIenabled. This may change in future versions
+  // of Qt.
   return getenv("DISPLAY") != 0;
 #else
   return true;
@@ -195,9 +191,9 @@ bool useGUI()
 }
 #endif // OPENSCAD_NOGUI
 
-bool checkAndExport(const std::shared_ptr<const Geometry>& root_geom, unsigned dimensions,
-                    ExportInfo& exportInfo, const bool is_stdout, const std::string& filename)
-{
+bool checkAndExport(const std::shared_ptr<const Geometry> &root_geom,
+                    unsigned dimensions, ExportInfo &exportInfo,
+                    const bool is_stdout, const std::string &filename) {
   if (root_geom->getDimension() != dimensions) {
     LOG("Current top level object is not a %1$dD object.", dimensions);
     return false;
@@ -215,15 +211,17 @@ bool checkAndExport(const std::shared_ptr<const Geometry>& root_geom, unsigned d
   return true;
 }
 
-void help(const char *arg0, const po::options_description& desc, bool failure = false)
-{
+void help(const char *arg0, const po::options_description &desc,
+          bool failure = false) {
   const fs::path progpath(arg0);
-  LOG("Usage: %1$s [options] file.scad\n%2$s", progpath.filename().string(), desc);
+  LOG("Usage: %1$s [options] file.scad\n%2$s", progpath.filename().string(),
+      desc);
   exit(failure ? 1 : 0);
 }
 
 template <std::size_t size>
-void help_export(const std::array<const Settings::SettingsEntryBase *, size>& options) {
+void help_export(
+    const std::array<const Settings::SettingsEntryBase *, size> &options) {
   LOG("Section '%1$s':", options.at(0)->category());
 
   for (const auto option : options) {
@@ -232,8 +230,7 @@ void help_export(const std::array<const Settings::SettingsEntryBase *, size>& op
   }
 }
 
-void help_export()
-{
+void help_export() {
   LOG("OpenSCAD version %1$s\n", TOSTRING(OPENSCAD_VERSION));
   LOG("List of settings that can be given using the -O option using the");
   LOG("format '<section>/<key>=value', e.g.:");
@@ -243,20 +240,18 @@ void help_export()
   exit(0);
 }
 
-void version()
-{
+void version() {
   LOG("OpenSCAD version %1$s", TOSTRING(OPENSCAD_VERSION));
   exit(0);
 }
 
-int info()
-{
+int info() {
   std::cout << LibraryInfo::info() << "\n\n";
 
   try {
     OffscreenView const glview(512, 512);
     std::cout << glview.getRendererInfo() << "\n";
-  } catch (const OffscreenViewException& ex) {
+  } catch (const OffscreenViewException &ex) {
     LOG("Can't create OpenGL OffscreenView: %1$s. Exiting.\n", ex.what());
     return 1;
   }
@@ -265,11 +260,11 @@ int info()
 }
 
 template <typename F>
-bool with_output(const bool is_stdout, const std::string& filename, const F& f, std::ios::openmode mode = std::ios::out)
-{
+bool with_output(const bool is_stdout, const std::string &filename, const F &f,
+                 std::ios::openmode mode = std::ios::out) {
   if (is_stdout) {
 #ifdef _WIN32
-    if ((mode& std::ios::binary) != 0) {
+    if ((mode & std::ios::binary) != 0) {
       _setmode(_fileno(stdout), _O_BINARY);
     }
 #endif
@@ -286,7 +281,7 @@ bool with_output(const bool is_stdout, const std::string& filename, const F& f,
   }
 }
 
-AnimateArgs get_animate(const po::variables_map& vm) {
+AnimateArgs get_animate(const po::variables_map &vm) {
   AnimateArgs animate;
   if (vm.count("animate")) {
     animate.frames = vm["animate"].as<unsigned>();
@@ -302,7 +297,7 @@ AnimateArgs get_animate(const po::variables_map& vm) {
     try {
       animate.shard = boost::lexical_cast<unsigned>(strs[0]);
       animate.num_shards = boost::lexical_cast<unsigned>(strs[1]);
-    } catch (const boost::bad_lexical_cast&) {
+    } catch (const boost::bad_lexical_cast &) {
       LOG("--animate_sharding parameters need to be positive integers");
       exit(1);
     }
@@ -314,8 +309,7 @@ AnimateArgs get_animate(const po::variables_map& vm) {
   return animate;
 }
 
-Camera get_camera(const po::variables_map& vm)
-{
+Camera get_camera(const po::variables_map &vm) {
   Camera camera;
 
   if (vm.count("camera")) {
@@ -324,15 +318,16 @@ Camera get_camera(const po::variables_map& vm)
     boost::split(strs, vm["camera"].as<std::string>(), boost::is_any_of(","));
     if (strs.size() == 6 || strs.size() == 7) {
       try {
-        for (const auto& s : strs) {
+        for (const auto &s : strs) {
           cam_parameters.push_back(boost::lexical_cast<double>(s));
         }
         camera.setup(cam_parameters);
-      } catch (boost::bad_lexical_cast&) {
+      } catch (boost::bad_lexical_cast &) {
         LOG("Camera setup requires numbers as parameters");
       }
     } else {
-      LOG("Camera setup requires either 7 numbers for Gimbal Camera or 6 numbers for Vector Camera");
+      LOG("Camera setup requires either 7 numbers for Gimbal Camera or 6 "
+          "numbers for Vector Camera");
       exit(1);
     }
   } else {
@@ -372,7 +367,7 @@ Camera get_camera(const po::variables_map& vm)
         int const h = boost::lexical_cast<int>(strs[1]);
         camera.pixel_width = w;
         camera.pixel_height = h;
-      } catch (boost::bad_lexical_cast&) {
+      } catch (boost::bad_lexical_cast &) {
         LOG("Need 2 numbers for imgsize");
       }
     }
@@ -381,18 +376,20 @@ Camera get_camera(const po::variables_map& vm)
   return camera;
 }
 
-int do_export(const CommandLine& cmd, const RenderVariables& render_variables, FileFormat export_format, SourceFile *root_file)
-{
+int do_export(const CommandLine &cmd, const RenderVariables &render_variables,
+              FileFormat export_format, SourceFile *root_file) {
   auto filename_str = fs::path(cmd.output_file).generic_string();
   // Avoid possibility of fs::absolute throwing when passed an empty path
-  auto fpath = cmd.filename.empty() ? fs::current_path() : fs::absolute(fs::path(cmd.filename));
+  auto fpath = cmd.filename.empty() ? fs::current_path()
+                                    : fs::absolute(fs::path(cmd.filename));
   auto fparent = fpath.parent_path();
 
   // set CWD relative to source file
   fs::current_path(fparent);
 
   EvaluationSession session{fparent.string()};
-  ContextHandle<BuiltinContext> builtin_context{Context::create<BuiltinContext>(&session)};
+  ContextHandle<BuiltinContext> builtin_context{
+      Context::create<BuiltinContext>(&session)};
   render_variables.applyToContext(builtin_context);
 
 #ifdef DEBUG
@@ -408,9 +405,10 @@ int do_export(const CommandLine& cmd, const RenderVariables& render_variables, F
     absolute_root_node = python_result_node;
   } else {
 #endif
-  absolute_root_node = root_file->instantiate(*builtin_context, &file_context);
+    absolute_root_node =
+        root_file->instantiate(*builtin_context, &file_context);
 #ifdef ENABLE_PYTHON
-}
+  }
 #endif
 
   Camera camera = cmd.camera;
@@ -428,7 +426,8 @@ int do_export(const CommandLine& cmd, const RenderVariables& render_variables, F
     root_node = absolute_root_node;
   }
   if (nextLocation) {
-    LOG(message_group::Warning, *nextLocation, builtin_context->documentRoot(), "More than one Root Modifier (!)");
+    LOG(message_group::Warning, *nextLocation, builtin_context->documentRoot(),
+        "More than one Root Modifier (!)");
   }
   Tree tree(root_node, fparent.string());
 
@@ -438,31 +437,36 @@ int do_export(const CommandLine& cmd, const RenderVariables& render_variables, F
     // statements become relative. But unfortunately they become relative to
     // the current working dir and neither to the location of the input nor
     // the output.
-    fs::current_path(fparent); // Force exported filenames to be relative to document path
-    with_output(cmd.is_stdout, filename_str, [&tree, root_node](std::ostream& stream) {
-        stream << tree.getString(*root_node, "\t") << "\n";
-      });
+    fs::current_path(
+        fparent); // Force exported filenames to be relative to document path
+    with_output(cmd.is_stdout, filename_str,
+                [&tree, root_node](std::ostream &stream) {
+                  stream << tree.getString(*root_node, "\t") << "\n";
+                });
     fs::current_path(cmd.original_path);
   } else if (export_format == FileFormat::AST) {
-    fs::current_path(fparent); // Force exported filenames to be relative to document path
-    with_output(cmd.is_stdout, filename_str, [root_file](std::ostream& stream) {
-        stream << root_file->dump("");
-      });
+    fs::current_path(
+        fparent); // Force exported filenames to be relative to document path
+    with_output(cmd.is_stdout, filename_str, [root_file](std::ostream &stream) {
+      stream << root_file->dump("");
+    });
     fs::current_path(cmd.original_path);
   } else if (export_format == FileFormat::PARAM) {
-    with_output(cmd.is_stdout, filename_str, [&root_file, &fpath](std::ostream& stream) {
-        export_param(root_file, fpath, stream);
-      });
+    with_output(cmd.is_stdout, filename_str,
+                [&root_file, &fpath](std::ostream &stream) {
+                  export_param(root_file, fpath, stream);
+                });
   } else if (export_format == FileFormat::TERM) {
     CSGTreeEvaluator csgRenderer(tree);
     auto root_raw_term = csgRenderer.buildCSGTree(*root_node);
-    with_output(cmd.is_stdout, filename_str, [root_raw_term](std::ostream& stream) {
-        if (!root_raw_term || root_raw_term->isEmptySet()) {
-          stream << "No top-level CSG object\n";
-        } else {
-          stream << root_raw_term->dump() << "\n";
-        }
-      });
+    with_output(cmd.is_stdout, filename_str,
+                [root_raw_term](std::ostream &stream) {
+                  if (!root_raw_term || root_raw_term->isEmptySet()) {
+                    stream << "No top-level CSG object\n";
+                  } else {
+                    stream << root_raw_term->dump() << "\n";
+                  }
+                });
   } else if (export_format == FileFormat::ECHO) {
     // echo -> don't need to evaluate any geometry
   } else {
@@ -471,23 +475,32 @@ int do_export(const CommandLine& cmd, const RenderVariables& render_variables, F
     GeometryEvaluator geomevaluator(tree);
     std::unique_ptr<OffscreenView> glview;
     std::shared_ptr<const Geometry> root_geom;
-    if ((export_format == FileFormat::ECHO || export_format == FileFormat::PNG) && (cmd.viewOptions.renderer == RenderType::OPENCSG || cmd.viewOptions.renderer == RenderType::THROWNTOGETHER)) {
+    if ((export_format == FileFormat::ECHO ||
+         export_format == FileFormat::PNG) &&
+        (cmd.viewOptions.renderer == RenderType::OPENCSG ||
+         cmd.viewOptions.renderer == RenderType::THROWNTOGETHER)) {
       // OpenCSG or throwntogether png -> just render a preview
       glview = prepare_preview(tree, cmd.viewOptions, camera);
-      if (!glview) return 1;
+      if (!glview)
+        return 1;
     } else {
       // Force creation of concrete geometry (mostly for testing)
-      // FIXME: Consider adding MANIFOLD as a valid --render argument and ViewOption, to be able to distinguish from CGAL
+      // FIXME: Consider adding MANIFOLD as a valid --render argument and
+      // ViewOption, to be able to distinguish from CGAL
 
       constexpr bool allownef = true;
       root_geom = geomevaluator.evaluateGeometry(*tree.root(), allownef);
-      if (!root_geom) root_geom = std::make_shared<PolySet>(3);
-      if (cmd.viewOptions.renderer == RenderType::BACKEND_SPECIFIC && root_geom->getDimension() == 3) {
-        if (auto geomlist = std::dynamic_pointer_cast<const GeometryList>(root_geom)) {
+      if (!root_geom)
+        root_geom = std::make_shared<PolySet>(3);
+      if (cmd.viewOptions.renderer == RenderType::BACKEND_SPECIFIC &&
+          root_geom->getDimension() == 3) {
+        if (auto geomlist =
+                std::dynamic_pointer_cast<const GeometryList>(root_geom)) {
           auto flatlist = geomlist->flatten();
-          for (auto& child : flatlist) {
+          for (auto &child : flatlist) {
             if (child.second->getDimension() == 3) {
-              child.second = GeometryUtils::getBackendSpecificGeometry(child.second);
+              child.second =
+                  GeometryUtils::getBackendSpecificGeometry(child.second);
             }
           }
           root_geom = std::make_shared<GeometryList>(flatlist);
@@ -500,33 +513,42 @@ int do_export(const CommandLine& cmd, const RenderVariables& render_variables, F
     }
 
     const std::string input_filename = cmd.is_stdin ? "<stdin>" : cmd.filename;
-    const int dim = fileformat::is3D(export_format) ? 3 : fileformat::is2D(export_format) ? 2 : 0;
-    ExportInfo exportInfo = createExportInfo(export_format, fileformat::info(export_format), input_filename, &cmd.camera, cmd.exportOptions);
-    if (dim > 0 && !checkAndExport(root_geom, dim, exportInfo, cmd.is_stdout, filename_str)) {
+    const int dim = fileformat::is3D(export_format)   ? 3
+                    : fileformat::is2D(export_format) ? 2
+                                                      : 0;
+    ExportInfo exportInfo =
+        createExportInfo(export_format, fileformat::info(export_format),
+                         input_filename, &cmd.camera, cmd.exportOptions);
+    if (dim > 0 && !checkAndExport(root_geom, dim, exportInfo, cmd.is_stdout,
+                                   filename_str)) {
       return 1;
     }
 
     if (export_format == FileFormat::PNG) {
       bool success = true;
-      bool const wrote = with_output(cmd.is_stdout, filename_str, [&success, &root_geom, &cmd, &camera, &glview](std::ostream& stream) {
-          if (cmd.viewOptions.renderer == RenderType::BACKEND_SPECIFIC || cmd.viewOptions.renderer == RenderType::GEOMETRY) {
-            success = export_png(root_geom, cmd.viewOptions, camera, stream);
-          } else {
-            success = export_png(*glview, stream);
-          }
-        }, std::ios::out | std::ios::binary);
+      bool const wrote = with_output(
+          cmd.is_stdout, filename_str,
+          [&success, &root_geom, &cmd, &camera, &glview](std::ostream &stream) {
+            if (cmd.viewOptions.renderer == RenderType::BACKEND_SPECIFIC ||
+                cmd.viewOptions.renderer == RenderType::GEOMETRY) {
+              success = export_png(root_geom, cmd.viewOptions, camera, stream);
+            } else {
+              success = export_png(*glview, stream);
+            }
+          },
+          std::ios::out | std::ios::binary);
       if (!success || !wrote) {
         return 1;
       }
     }
 
-    renderStatistic.printAll(root_geom, camera, cmd.summaryOptions, cmd.summaryFile);
+    renderStatistic.printAll(root_geom, camera, cmd.summaryOptions,
+                             cmd.summaryFile);
   }
   return 0;
 }
 
-int cmdline(const CommandLine& cmd)
-{
+int cmdline(const CommandLine &cmd) {
   FileFormat export_format;
 
   // Determine output file format and assign it to formatName
@@ -535,11 +557,14 @@ int cmdline(const CommandLine& cmd)
   } else {
     // else extract format from file extension
     const auto path = fs::path(cmd.output_file);
-    std::string suffix = path.has_extension() ? path.extension().generic_string().substr(1) : "";
+    std::string suffix =
+        path.has_extension() ? path.extension().generic_string().substr(1) : "";
     boost::algorithm::to_lower(suffix);
 
     if (!fileformat::fromIdentifier(suffix, export_format)) {
-      LOG("Invalid suffix %1$s. Either add a valid suffix or specify one using the --export-format option.", suffix);
+      LOG("Invalid suffix %1$s. Either add a valid suffix or specify one using "
+          "the --export-format option.",
+          suffix);
       return 1;
     }
   }
@@ -547,11 +572,13 @@ int cmdline(const CommandLine& cmd)
   // Do some minimal checking of output directory before rendering (issue #432)
   auto output_dir = fs::path(cmd.output_file).parent_path();
   if (output_dir.empty()) {
-    // If output_file_str has no directory prefix, set output directory to current directory.
+    // If output_file_str has no directory prefix, set output directory to
+    // current directory.
     output_dir = fs::current_path();
   }
   if (!fs::is_directory(output_dir)) {
-    LOG("\n'%1$s' is not a directory for output file %2$s - Skipping\n", output_dir.generic_string(), cmd.output_file);
+    LOG("\n'%1$s' is not a directory for output file %2$s - Skipping\n",
+        output_dir.generic_string(), cmd.output_file);
     return 1;
   }
 
@@ -559,12 +586,14 @@ int cmdline(const CommandLine& cmd)
 
   std::shared_ptr<Echostream> echostream;
   if (export_format == FileFormat::ECHO) {
-    echostream.reset(cmd.is_stdout ? new Echostream(std::cout) : new Echostream(cmd.output_file));
+    echostream.reset(cmd.is_stdout ? new Echostream(std::cout)
+                                   : new Echostream(cmd.output_file));
   }
 
   std::string text;
   if (cmd.is_stdin) {
-    text = std::string((std::istreambuf_iterator<char>(std::cin)), std::istreambuf_iterator<char>());
+    text = std::string((std::istreambuf_iterator<char>(std::cin)),
+                       std::istreambuf_iterator<char>());
   } else {
     std::ifstream ifs(cmd.filename);
     if (!ifs.is_open()) {
@@ -572,15 +601,18 @@ int cmdline(const CommandLine& cmd)
       return 1;
     }
     handle_dep(cmd.filename);
-    text = std::string((std::istreambuf_iterator<char>(ifs)), std::istreambuf_iterator<char>());
+    text = std::string((std::istreambuf_iterator<char>(ifs)),
+                       std::istreambuf_iterator<char>());
   }
 
 #ifdef ENABLE_PYTHON
   python_active = false;
   if (cmd.filename.c_str() != NULL) {
     if (boost::algorithm::ends_with(cmd.filename, ".py")) {
-      if (python_trusted == true) python_active = true;
-      else LOG("Python is not enabled");
+      if (python_trusted == true)
+        python_active = true;
+      else
+        LOG("Python is not enabled");
     }
   }
 
@@ -588,7 +620,8 @@ int cmdline(const CommandLine& cmd)
     auto fulltext_py = text;
     initPython(PlatformUtils::applicationPath(), 0.0);
     auto error = evaluatePython(fulltext_py, false);
-    if (error.size() > 0)LOG(error.c_str());
+    if (error.size() > 0)
+      LOG(error.c_str());
     text = "\n";
   }
 #endif // ifdef ENABLE_PYTHON
@@ -610,7 +643,7 @@ int cmdline(const CommandLine& cmd)
     ParameterObjects parameters = ParameterObjects::fromSourceFile(root_file);
     ParameterSets sets;
     sets.readFile(cmd.parameterFile);
-    for (const auto& set : sets) {
+    for (const auto &set : sets) {
       if (set.name() == cmd.setName) {
         parameters.importValues(set);
         parameters.apply(root_file);
@@ -622,11 +655,11 @@ int cmdline(const CommandLine& cmd)
   root_file->handleDependencies();
 
   RenderVariables render_variables = {
-    .preview = fileformat::canPreview(export_format)
-      ? (cmd.viewOptions.renderer == RenderType::OPENCSG
-         || cmd.viewOptions.renderer == RenderType::THROWNTOGETHER)
-      : false,
-    .camera = cmd.camera,
+      .preview = fileformat::canPreview(export_format)
+                     ? (cmd.viewOptions.renderer == RenderType::OPENCSG ||
+                        cmd.viewOptions.renderer == RenderType::THROWNTOGETHER)
+                     : false,
+      .camera = cmd.camera,
   };
 
   if (cmd.animate.frames == 0) {
@@ -634,10 +667,10 @@ int cmdline(const CommandLine& cmd)
     return do_export(cmd, render_variables, export_format, root_file);
   } else {
     // export the requested number of animated frames
-    const unsigned start_frame = ((cmd.animate.shard - 1) * cmd.animate.frames)
-      / cmd.animate.num_shards;
-    const unsigned limit_frame = (cmd.animate.shard * cmd.animate.frames)
-      / cmd.animate.num_shards;
+    const unsigned start_frame =
+        ((cmd.animate.shard - 1) * cmd.animate.frames) / cmd.animate.num_shards;
+    const unsigned limit_frame =
+        (cmd.animate.shard * cmd.animate.frames) / cmd.animate.num_shards;
     for (unsigned frame = start_frame; frame < limit_frame; ++frame) {
       render_variables.time = frame * (1.0 / cmd.animate.frames);
 
@@ -656,7 +689,8 @@ int cmdline(const CommandLine& cmd)
       CommandLine frame_cmd = cmd;
       frame_cmd.output_file = frame_str;
 
-      int const r = do_export(frame_cmd, render_variables, export_format, root_file);
+      int const r =
+          do_export(frame_cmd, render_variables, export_format, root_file);
       if (r != 0) {
         return r;
       }
@@ -667,40 +701,42 @@ int cmdline(const CommandLine& cmd)
 }
 
 template <class Seq, typename ToString>
-static std::string str_join(const Seq& seq, const std::string& sep, const ToString& toString)
-{
+static std::string str_join(const Seq &seq, const std::string &sep,
+                            const ToString &toString) {
   return boost::algorithm::join(boost::adaptors::transform(seq, toString), sep);
 }
 
-static bool flagConvert(const std::string& str){
+static bool flagConvert(const std::string &str) {
   if (str == "1" || boost::iequals(str, "on") || boost::iequals(str, "true")) {
     return true;
   }
-  if (str == "0" || boost::iequals(str, "off") || boost::iequals(str, "false")) {
+  if (str == "0" || boost::iequals(str, "off") ||
+      boost::iequals(str, "false")) {
     return false;
   }
   throw std::runtime_error("");
   return false;
 }
 
-static std::tuple<std::string, std::string> simple_split(const std::string& str, const char c)
-{
+static std::tuple<std::string, std::string> simple_split(const std::string &str,
+                                                         const char c) {
   const auto idx = str.find_first_of(c);
-  if (idx == std::string::npos)return {};
+  if (idx == std::string::npos)
+    return {};
   const auto first = str.substr(0, idx);
   const auto second = str.substr(idx + 1);
   return {first, second};
 }
 
-static CmdLineExportOptions convert_export_options(const po::variables_map& vm)
-{
+static CmdLineExportOptions
+convert_export_options(const po::variables_map &vm) {
   if (vm.count("O") == 0) {
     return {};
   }
 
   CmdLineExportOptions map;
-  const auto& options = vm["O"].as<std::vector<std::string>>();
-  for (const auto& option : options) {
+  const auto &options = vm["O"].as<std::vector<std::string>>();
+  for (const auto &option : options) {
     const auto [key, value] = simple_split(option, '=');
     const auto [section, name] = simple_split(key, '/');
     map[section][name] = value;
@@ -710,8 +746,8 @@ static CmdLineExportOptions convert_export_options(const po::variables_map& vm)
 
 } // namespace
 
-void set_render_color_scheme(const std::string& color_scheme, const bool exit_if_not_found)
-{
+void set_render_color_scheme(const std::string &color_scheme,
+                             const bool exit_if_not_found) {
   if (color_scheme.empty()) {
     return;
   }
@@ -726,7 +762,8 @@ void set_render_color_scheme(const std::string& color_scheme, const bool exit_if
 
     exit(1);
   } else {
-    LOG("Unknown color scheme '%1$s', using default '%2$s'.", arg_colorscheme, ColorMap::inst()->defaultColorSchemeName());
+    LOG("Unknown color scheme '%1$s', using default '%2$s'.", arg_colorscheme,
+        ColorMap::inst()->defaultColorSchemeName());
   }
 }
 
@@ -737,7 +774,7 @@ void set_render_color_scheme(const std::string& color_scheme, const bool exit_if
  */
 void localization_init() {
   fs::path const po_dir(PlatformUtils::resourcePath("locale"));
-  const std::string& locale_path(po_dir.string());
+  const std::string &locale_path(po_dir.string());
 
   if (fs::is_directory(locale_path)) {
     setlocale(LC_ALL, "");
@@ -745,19 +782,17 @@ void localization_init() {
     bind_textdomain_codeset("openscad", "UTF-8");
     textdomain("openscad");
   } else {
-    LOG("Could not initialize localization (application path is '%1$s').", PlatformUtils::applicationPath());
+    LOG("Could not initialize localization (application path is '%1$s').",
+        PlatformUtils::applicationPath());
   }
 }
 
-
-
 #ifdef Q_OS_MACOS
-std::pair<std::string, std::string> customSyntax(const std::string& s)
-{
-  if (s.find("-psn_") == 0) return {"psn", s.substr(5)};
+std::pair<std::string, std::string> customSyntax(const std::string &s) {
+  if (s.find("-psn_") == 0)
+    return {"psn", s.substr(5)};
 #else
-std::pair<std::string, std::string> customSyntax(const std::string&)
-{
+std::pair<std::string, std::string> customSyntax(const std::string &) {
 #endif
 
   return {};
@@ -765,24 +800,25 @@ std::pair<std::string, std::string> customSyntax(const std::string&)
 /*!
    This makes boost::program_option parse comma-separated values
  */
-struct CommaSeparatedVector
-{
+struct CommaSeparatedVector {
   std::vector<std::string> values;
 
-  friend std::istream& operator>>(std::istream& in, CommaSeparatedVector& value) {
+  friend std::istream &operator>>(std::istream &in,
+                                  CommaSeparatedVector &value) {
     std::string token;
     in >> token;
-    // NOLINTNEXTLINE(*NewDeleteLeaks) LLVM bug https://github.com/llvm/llvm-project/issues/40486
+    // NOLINTNEXTLINE(*NewDeleteLeaks) LLVM bug
+    // https://github.com/llvm/llvm-project/issues/40486
     boost::split(value.values, token, boost::is_any_of(","));
     return in;
   }
 };
 
 // OpenSCAD
-int main(int argc, char **argv)
-{
+int main(int argc, char **argv) {
 #if defined(ENABLE_CGAL) && defined(USE_MIMALLOC)
-  // call init_mimalloc before any GMP variables are initialized. (defined in src/openscad_mimalloc.h)
+  // call init_mimalloc before any GMP variables are initialized. (defined in
+  // src/openscad_mimalloc.h)
   init_mimalloc();
 #endif
 
@@ -791,16 +827,19 @@ int main(int argc, char **argv)
 
 #ifdef Q_OS_MACOS
   bool isGuiLaunched = getenv("GUI_LAUNCHED") != nullptr;
-  auto nslog = [](const Message& msg, void *userdata) {
-      CocoaUtils::nslog(msg.msg, userdata);
-    };
-  if (isGuiLaunched) set_output_handler(nslog, nullptr, nullptr);
+  auto nslog = [](const Message &msg, void *userdata) {
+    CocoaUtils::nslog(msg.msg, userdata);
+  };
+  if (isGuiLaunched)
+    set_output_handler(nslog, nullptr, nullptr);
 #else
   PlatformUtils::ensureStdIO();
 #endif
 
 #ifndef __EMSCRIPTEN__
-  const auto applicationPath = weakly_canonical(boost::dll::program_location()).parent_path().generic_string();
+  const auto applicationPath = weakly_canonical(boost::dll::program_location())
+                                   .parent_path()
+                                   .generic_string();
 #else
   const auto applicationPath = boost::dll::fs::current_path();
 #endif
@@ -816,7 +855,8 @@ int main(int argc, char **argv)
 #endif
 
 #ifdef ENABLE_CGAL
-  // Always throw exceptions from CGAL, so we can catch instead of crashing on bad geometry.
+  // Always throw exceptions from CGAL, so we can catch instead of crashing on
+  // bad geometry.
   CGAL::set_error_behaviour(CGAL::THROW_EXCEPTION);
   CGAL::set_warning_behaviour(CGAL::THROW_EXCEPTION);
 #endif
@@ -830,71 +870,125 @@ int main(int argc, char **argv)
 
   ViewOptions viewOptions{};
   po::options_description desc("Allowed options");
-  desc.add_options()
-  ("export-format", po::value<std::string> (), "overrides format of exported scad file when using option '-o', arg can be any of its supported file extensions.  For ASCII stl export, specify 'asciistl', and for binary stl export, specify 'binstl'.  ASCII export is the current stl default, but binary stl is planned as the future default so asciistl should be explicitly specified in scripts when needed.\n")
-  ("o,o", po::value<std::vector<std::string>> (), "output specified file instead of running the GUI. The file extension specifies the type: stl, off, wrl, amf, 3mf, csg, dxf, svg, pdf, png, echo, ast, term, nef3, nefdbg, param, pov. May be used multiple times for different exports. Use '-' for stdout.\n")
-  ("O,O", po::value<std::vector<std::string>> (), "pass settings value to the file export using the format section/key=value, e.g export-pdf/paper-size=a3. Use --help-export to list all available settings.")
-  ("D,D", po::value<std::vector<std::string>> (), "var=val -pre-define variables")
-  ("p,p", po::value<std::string> (), "customizer parameter file")
-  ("P,P", po::value<std::string> (), "customizer parameter set")
+  desc.add_options()(
+      "export-format", po::value<std::string>(),
+      "overrides format of exported scad file when using option '-o', arg can "
+      "be any of its supported file extensions.  For ASCII stl export, specify "
+      "'asciistl', and for binary stl export, specify 'binstl'.  ASCII export "
+      "is the current stl default, but binary stl is planned as the future "
+      "default so asciistl should be explicitly specified in scripts when "
+      "needed.\n")(
+      "o,o", po::value<std::vector<std::string>>(),
+      "output specified file instead of running the GUI. The file extension "
+      "specifies the type: stl, off, wrl, amf, 3mf, csg, dxf, svg, pdf, png, "
+      "echo, ast, term, nef3, nefdbg, param, pov. May be used multiple times "
+      "for different exports. Use '-' for stdout.\n")(
+      "O,O", po::value<std::vector<std::string>>(),
+      "pass settings value to the file export using the format "
+      "section/key=value, e.g export-pdf/paper-size=a3. Use --help-export to "
+      "list all available settings.")("D,D",
+                                      po::value<std::vector<std::string>>(),
+                                      "var=val -pre-define variables")(
+      "p,p", po::value<std::string>(), "customizer parameter file")(
+      "P,P", po::value<std::string>(), "customizer parameter set")
 #ifdef ENABLE_EXPERIMENTAL
-  ("enable", po::value<std::vector<std::string>> (), ("enable experimental features (specify 'all' for enabling all available features): " +
-                                                      str_join(boost::make_iterator_range(Feature::begin(), Feature::end()), " | ",
-                                                               [](const Feature *feature) {
-    return feature->get_name();
-  }) +
-                                                               "\n").c_str())
+      ("enable", po::value<std::vector<std::string>>(),
+       ("enable experimental features (specify 'all' for enabling all "
+        "available features): " +
+        str_join(boost::make_iterator_range(Feature::begin(), Feature::end()),
+                 " | ",
+                 [](const Feature *feature) { return feature->get_name(); }) +
+        "\n")
+           .c_str())
 #endif
-  ("help,h", "print this help message and exit")
-    ("help-export", "print list of export parameters and values that can be set via -O")
-    ("version,v", "print the version")
-    ("info", "print information about the build process\n")
-
-    ("camera", po::value<std::string>(), "camera parameters when exporting png: =translate_x,y,z,rot_x,y,z,dist or =eye_x,y,z,center_x,y,z")
-    ("autocenter", "adjust camera to look at object's center")
-    ("viewall", "adjust camera to fit object")
-    ("backend", po::value<std::string>(), "3D rendering backend to use: 'CGAL' (old/slow) [default] or 'Manifold' (new/fast)")
-    ("imgsize", po::value<std::string>(), "=width,height of exported png")
-    ("render", po::value<std::string>()->implicit_value(""), "for full geometry evaluation when exporting png")
-    ("preview", po::value<std::string>()->implicit_value(""), "[=throwntogether] -for ThrownTogether preview png")
-    ("animate", po::value<unsigned>(), "export N animated frames")
-    ("animate_sharding", po::value<std::string>(), "Parameter <shard>/<num_shards> - Divide work into <num_shards> and only output frames for <shard>. E.g. 2/5 only outputs the second 1/5 of frames. Use to parallelize work on multiple cores or machines.")
-    ("view", po::value<CommaSeparatedVector>(), ("=view options: " + boost::algorithm::join(viewOptions.names(), " | ")).c_str())
-    ("projection", po::value<std::string>(), "=(o)rtho or (p)erspective when exporting png")
-    ("csglimit", po::value<unsigned int>(), "=n -stop rendering at n CSG elements when exporting png")
-    ("summary", po::value<std::vector<std::string>>(), "enable additional render summary and statistics: all | cache | time | camera | geometry | bounding-box | area")
-    ("summary-file", po::value<std::string>(), "output summary information in JSON format to the given file, using '-' outputs to stdout")
-    ("colorscheme", po::value<std::string>(), ("=colorscheme: " +
-                                               str_join(ColorMap::inst()->colorSchemeNames(), " | ",
-                                                        [](const std::string& colorScheme) {
-                                                        return (colorScheme == ColorMap::inst()->defaultColorSchemeName() ? "*" : "") + colorScheme;
-    }) +
-                                               "\n").c_str())
-    ("d,d", po::value<std::string>(), "deps_file -generate a dependency file for make")
-    ("m,m", po::value<std::string>(), "make_cmd -runs make_cmd file if file is missing")
-    ("quiet,q", "quiet mode (don't print anything *except* errors)")
-    ("hardwarnings", "Stop on the first warning")
-    ("trace-depth", po::value<unsigned int>(), "=n, maximum number of trace messages")
-    ("trace-usermodule-parameters", po::value<std::string>(), "=true/false, configure the output of user module parameters in a trace")
-    ("check-parameters", po::value<std::string>(), "=true/false, configure the parameter check for user modules and functions")
-    ("check-parameter-ranges", po::value<std::string>(), "=true/false, configure the parameter range check for builtin modules")
-    ("debug", po::value<std::string>(), "special debug info - specify 'all' or a set of source file names")
+          ("help,h", "print this help message and exit")(
+              "help-export", "print list of export parameters and values that "
+                             "can be set via -O")("version,v",
+                                                  "print the version")(
+              "info", "print information about the build process\n")
+
+              ("camera", po::value<std::string>(),
+               "camera parameters when exporting png: "
+               "=translate_x,y,z,rot_x,y,z,dist or =eye_x,y,z,center_x,y,z")(
+                  "autocenter", "adjust camera to look at object's center")(
+                  "viewall", "adjust camera to fit object")(
+                  "backend", po::value<std::string>(),
+                  "3D rendering backend to use: 'CGAL' (old/slow) [default] or "
+                  "'Manifold' (new/fast)")("imgsize", po::value<std::string>(),
+                                           "=width,height of exported png")(
+                  "render", po::value<std::string>()->implicit_value(""),
+                  "for full geometry evaluation when exporting png")(
+                  "preview", po::value<std::string>()->implicit_value(""),
+                  "[=throwntogether] -for ThrownTogether preview png")(
+                  "animate", po::value<unsigned>(), "export N animated frames")(
+                  "animate_sharding", po::value<std::string>(),
+                  "Parameter <shard>/<num_shards> - Divide work into "
+                  "<num_shards> and only output frames for <shard>. E.g. 2/5 "
+                  "only outputs the second 1/5 of frames. Use to parallelize "
+                  "work on multiple cores or machines.")(
+                  "view", po::value<CommaSeparatedVector>(),
+                  ("=view options: " +
+                   boost::algorithm::join(viewOptions.names(), " | "))
+                      .c_str())("projection", po::value<std::string>(),
+                                "=(o)rtho or (p)erspective when exporting png")(
+                  "csglimit", po::value<unsigned int>(),
+                  "=n -stop rendering at n CSG elements when exporting png")(
+                  "summary", po::value<std::vector<std::string>>(),
+                  "enable additional render summary and statistics: all | "
+                  "cache | time | camera | geometry | bounding-box | area")(
+                  "summary-file", po::value<std::string>(),
+                  "output summary information in JSON format to the given "
+                  "file, using '-' outputs to stdout")(
+                  "colorscheme", po::value<std::string>(),
+                  ("=colorscheme: " +
+                   str_join(ColorMap::inst()->colorSchemeNames(), " | ",
+                            [](const std::string &colorScheme) {
+                              return (colorScheme ==
+                                              ColorMap::inst()
+                                                  ->defaultColorSchemeName()
+                                          ? "*"
+                                          : "") +
+                                     colorScheme;
+                            }) +
+                   "\n")
+                      .c_str())(
+                  "d,d", po::value<std::string>(),
+                  "deps_file -generate a dependency file for make")(
+                  "m,m", po::value<std::string>(),
+                  "make_cmd -runs make_cmd file if file is missing")(
+                  "quiet,q",
+                  "quiet mode (don't print anything *except* errors)")(
+                  "hardwarnings", "Stop on the first warning")(
+                  "trace-depth", po::value<unsigned int>(),
+                  "=n, maximum number of trace messages")(
+                  "trace-usermodule-parameters", po::value<std::string>(),
+                  "=true/false, configure the output of user module parameters "
+                  "in a trace")("check-parameters", po::value<std::string>(),
+                                "=true/false, configure the parameter check "
+                                "for user modules and functions")(
+                  "check-parameter-ranges", po::value<std::string>(),
+                  "=true/false, configure the parameter range check for "
+                  "builtin modules")("debug", po::value<std::string>(),
+                                     "special debug info - specify 'all' or a "
+                                     "set of source file names")
 #ifdef ENABLE_PYTHON
-  ("trust-python",  "Trust python")
-    ("python-module", po::value<std::string>(), "=module Call pip python module")
+                  ("trust-python",
+                   "Trust python")("python-module", po::value<std::string>(),
+                                   "=module Call pip python module")
 #endif
-  ;
+      ;
 
 #ifdef ENABLE_GUI_TESTS
-  desc.add_options()("run-all-gui-tests", "special gui testing mode - run all the tests");
+  desc.add_options()("run-all-gui-tests",
+                     "special gui testing mode - run all the tests");
 #endif
 
   po::options_description hidden("Hidden options");
   hidden.add_options()
 #ifdef Q_OS_MACOS
-  ("psn", po::value<std::string>(), "process serial number")
+      ("psn", po::value<std::string>(), "process serial number")
 #endif
-  ("input-file", po::value<std::vector<std::string>>(), "input file");
+          ("input-file", po::value<std::vector<std::string>>(), "input file");
 
   po::positional_options_description p;
   p.add("input-file", -1);
@@ -904,8 +998,13 @@ int main(int argc, char **argv)
 
   po::variables_map vm;
   try {
-    po::store(po::command_line_parser(argc, argv).options(all_options).positional(p).extra_parser(customSyntax).run(), vm);
-  } catch (const std::exception& e) { // Catches e.g. unknown options
+    po::store(po::command_line_parser(argc, argv)
+                  .options(all_options)
+                  .positional(p)
+                  .extra_parser(customSyntax)
+                  .run(),
+              vm);
+  } catch (const std::exception &e) { // Catches e.g. unknown options
     LOG("%1$s\n", e.what());
     help(argv[0], desc, true);
   }
@@ -943,77 +1042,93 @@ int main(int argc, char **argv)
     OpenSCAD::traceDepth = vm["traceDepth"].as<unsigned int>();
   }
   std::map<std::string, bool *> flags;
-  flags.insert(std::make_pair("trace-usermodule-parameters", &OpenSCAD::traceUsermoduleParameters));
+  flags.insert(std::make_pair("trace-usermodule-parameters",
+                              &OpenSCAD::traceUsermoduleParameters));
   flags.insert(std::make_pair("check-parameters", &OpenSCAD::parameterCheck));
   flags.insert(std::make_pair("check-parameter-ranges", &OpenSCAD::rangeCheck));
-  for (const auto& flag : flags) {
+  for (const auto &flag : flags) {
     std::string name = flag.first;
     if (vm.count(name)) {
       std::string opt = vm[name].as<std::string>();
       try {
         (*(flag.second) = flagConvert(opt));
-      } catch (const std::runtime_error& e) {
+      } catch (const std::runtime_error &e) {
         LOG("Could not parse '--%1$s %2$s' as flag", name, opt);
       }
     }
   }
 
-  if (vm.count("help")) help(argv[0], desc);
-  if (vm.count("help-export")) help_export();
-  if (vm.count("version")) version();
-  if (vm.count("info")) arg_info = true;
+  if (vm.count("help"))
+    help(argv[0], desc);
+  if (vm.count("help-export"))
+    help_export();
+  if (vm.count("version"))
+    version();
+  if (vm.count("info"))
+    arg_info = true;
   if (vm.count("backend")) {
-    RenderSettings::inst()->backend3D = renderBackend3DFromString(vm["backend"].as<std::string>());
+    RenderSettings::inst()->backend3D =
+        renderBackend3DFromString(vm["backend"].as<std::string>());
   }
 
   if (vm.count("preview")) {
-    if (vm["preview"].as<std::string>() == "throwntogether") viewOptions.renderer = RenderType::THROWNTOGETHER;
+    if (vm["preview"].as<std::string>() == "throwntogether")
+      viewOptions.renderer = RenderType::THROWNTOGETHER;
   } else if (vm.count("render")) {
-    // Note: "cgal" is here for backwards compatibility, can probably be removed soon
-    if (vm["render"].as<std::string>() == "cgal" || vm["render"].as<std::string>() == "force") {
+    // Note: "cgal" is here for backwards compatibility, can probably be removed
+    // soon
+    if (vm["render"].as<std::string>() == "cgal" ||
+        vm["render"].as<std::string>() == "force") {
       viewOptions.renderer = RenderType::BACKEND_SPECIFIC;
     } else {
       viewOptions.renderer = RenderType::GEOMETRY;
     }
   }
 
-  viewOptions.previewer = (viewOptions.renderer == RenderType::THROWNTOGETHER) ? Previewer::THROWNTOGETHER : Previewer::OPENCSG;
+  viewOptions.previewer = (viewOptions.renderer == RenderType::THROWNTOGETHER)
+                              ? Previewer::THROWNTOGETHER
+                              : Previewer::OPENCSG;
   if (vm.count("view")) {
-    const auto& viewOptionValues = vm["view"].as<CommaSeparatedVector>();
+    const auto &viewOptionValues = vm["view"].as<CommaSeparatedVector>();
 
-    for (const auto& option : viewOptionValues.values) {
+    for (const auto &option : viewOptionValues.values) {
       try {
         viewOptions[option] = true;
-      } catch (const std::out_of_range& e) {
-        LOG("Unknown --view option '%1$s' ignored. Use -h to list available options.", option);
+      } catch (const std::out_of_range &e) {
+        LOG("Unknown --view option '%1$s' ignored. Use -h to list available "
+            "options.",
+            option);
       }
     }
   }
 
   if (vm.count("csglimit")) {
-    RenderSettings::inst()->openCSGTermLimit = vm["csglimit"].as<unsigned int>();
+    RenderSettings::inst()->openCSGTermLimit =
+        vm["csglimit"].as<unsigned int>();
   }
 
   if (vm.count("o")) {
     output_files = vm["o"].as<std::vector<std::string>>();
   }
   if (vm.count("d")) {
-    if (deps_output_file) help(argv[0], desc, true);
+    if (deps_output_file)
+      help(argv[0], desc, true);
     deps_output_file = vm["d"].as<std::string>().c_str();
   }
   if (vm.count("m")) {
-    if (make_command) help(argv[0], desc, true);
+    if (make_command)
+      help(argv[0], desc, true);
     make_command = vm["m"].as<std::string>().c_str();
   }
 
   if (vm.count("D")) {
-    for (const auto& cmd : vm["D"].as<std::vector<std::string>>()) {
+    for (const auto &cmd : vm["D"].as<std::vector<std::string>>()) {
       commandline_commands += cmd;
       commandline_commands += ";\n";
     }
   }
   if (vm.count("enable")) {
-    for (const auto& feature : vm["enable"].as<std::vector<std::string>>()) {
+    for (const auto &feature : vm["enable"].as<std::vector<std::string>>()) {
       if (feature == "all") {
         Feature::enable_all();
         break;
@@ -1054,7 +1169,9 @@ int main(int argc, char **argv)
       export_format.emplace(format);
 
     } else {
-      LOG("Unknown --export-format option '%1$s'.  Use -h to list available options.", format_str);
+      LOG("Unknown --export-format option '%1$s'.  Use -h to list available "
+          "options.",
+          format_str);
       return 1;
     }
   }
@@ -1063,7 +1180,7 @@ int main(int argc, char **argv)
   const Camera camera = get_camera(vm);
 
   if (animate.frames) {
-    for (const auto& filename : output_files) {
+    for (const auto &filename : output_files) {
       if (filename == "-") {
         LOG("Option --animate is not supported when exporting to stdout.");
         return 1;
@@ -1079,49 +1196,52 @@ int main(int argc, char **argv)
   auto cmdlinemode = false;
   if (!output_files.empty()) { // cmd-line mode
     cmdlinemode = true;
-    if (!inputFiles.size()) help(argv[0], desc, true);
+    if (!inputFiles.size())
+      help(argv[0], desc, true);
   }
 
   if (arg_info || cmdlinemode) {
-    if (inputFiles.size() > 1) help(argv[0], desc, true);
+    if (inputFiles.size() > 1)
+      help(argv[0], desc, true);
     try {
       parser_init();
       localization_init();
       if (arg_info) {
         rc = info();
       } else {
-        for (const auto& filename : output_files) {
+        for (const auto &filename : output_files) {
           const bool is_stdin = inputFiles[0] == "-";
           const std::string input_file = is_stdin ? "<stdin>" : inputFiles[0];
           const bool is_stdout = filename == "-";
           const std::string output_file = is_stdout ? "<stdout>" : filename;
           const auto export_options = convert_export_options(vm);
           const CommandLine cmd{
-            is_stdin,
-            input_file,
-            is_stdout,
-            output_file,
-            original_path,
-            parameterFile,
-            parameterSet,
-            viewOptions,
-            camera,
-            export_format,
-            export_options,
-            animate,
-            vm.count("summary") ? vm["summary"].as<std::vector<std::string>>() : std::vector<std::string>{},
-            vm.count("summary-file") ? vm["summary-file"].as<std::string>() : ""
-          };
+              is_stdin,
+              input_file,
+              is_stdout,
+              output_file,
+              original_path,
+              parameterFile,
+              parameterSet,
+              viewOptions,
+              camera,
+              export_format,
+              export_options,
+              animate,
+              vm.count("summary") ? vm["summary"].as<std::vector<std::string>>()
+                                  : std::vector<std::string>{},
+              vm.count("summary-file") ? vm["summary-file"].as<std::string>()
+                                       : ""};
           rc |= cmdline(cmd);
         }
       }
-    } catch (const HardWarningException&) {
+    } catch (const HardWarningException &) {
       rc = 1;
     }
 
     if (deps_output_file) {
       std::string const deps_out(deps_output_file);
-      const std::vector<std::string>& geom_out(output_files);
+      const std::vector<std::string> &geom_out(output_files);
       if (!write_deps(deps_out, geom_out)) {
         LOG("Error writing deps");
         return 1;
@@ -1133,7 +1253,7 @@ int main(int argc, char **argv)
       LOG("Ignoring --export-format option");
     }
     std::string gui_test = "none";
-    if (vm.count("run-all-gui-tests")){
+    if (vm.count("run-all-gui-tests")) {
       gui_test = "all";
     }
     rc = gui(inputFiles, original_path, argc, argv, gui_test);
diff --git a/src/openscad.h b/src/openscad.h
index 44532c01c..82a28d203 100644
--- a/src/openscad.h
+++ b/src/openscad.h
@@ -29,12 +29,15 @@
 #include <string>
 #include <utility>
 
-extern bool parse(class SourceFile *&file, const std::string& text, const std::string& filename, const std::string& mainFile, int debug);
+extern bool parse(class SourceFile *&file, const std::string &text,
+                  const std::string &filename, const std::string &mainFile,
+                  int debug);
 
 extern std::string commandline_commands;
 
 // Custom argument parser
-std::pair<std::string, std::string> customSyntax(const std::string& s);
+std::pair<std::string, std::string> customSyntax(const std::string &s);
 
 void localization_init();
-void set_render_color_scheme(const std::string& color_scheme, const bool exit_if_not_found);
+void set_render_color_scheme(const std::string &color_scheme,
+                             const bool exit_if_not_found);
diff --git a/src/openscad_gui.cc b/src/openscad_gui.cc
index aab0cf49e..be8b12fbf 100644
--- a/src/openscad_gui.cc
+++ b/src/openscad_gui.cc
@@ -25,13 +25,11 @@
  */
 
 #include "openscad_gui.h"
-#include <memory>
 #include <filesystem>
+#include <memory>
 #include <string>
 #include <vector>
 
-#include <QtGlobal>
-#include <Qt>
 #include <QDialog>
 #include <QDir>
 #include <QFileInfo>
@@ -40,13 +38,15 @@
 #include <QIcon>
 #include <QObject>
 #include <QPalette>
-#include <QStyleHints>
 #include <QStringList>
+#include <QStyleHints>
+#include <Qt>
 #include <QtConcurrentRun>
+#include <QtGlobal>
 
-#include "core/parsersettings.h"
-#include "core/Settings.h"
 #include "FontCache.h"
+#include "core/Settings.h"
+#include "core/parsersettings.h"
 #include "geometry/Geometry.h"
 #include "gui/AppleEvents.h"
 #include "gui/input/InputDriverManager.h"
@@ -92,7 +92,8 @@ namespace {
 //
 // For applying a color change, e.g. highlighting the background of an input
 // field, see:
-// UIUtils::blendForBackgroundColorStyleSheet(const QColor& input, const QColor& blend)
+// UIUtils::blendForBackgroundColorStyleSheet(const QColor& input, const QColor&
+// blend)
 
 bool isDarkMode() {
 #if QT_VERSION >= QT_VERSION_CHECK(6, 5, 0)
@@ -100,20 +101,21 @@ bool isDarkMode() {
   return scheme == Qt::ColorScheme::Dark;
 #else
   const QPalette defaultPalette;
-  const auto& text = defaultPalette.color(QPalette::WindowText);
-  const auto& window = defaultPalette.color(QPalette::Window);
+  const auto &text = defaultPalette.color(QPalette::WindowText);
+  const auto &window = defaultPalette.color(QPalette::Window);
   return text.lightness() > window.lightness();
 #endif // QT_VERSION
 }
 
-}
+} // namespace
 
 namespace {
 
 // Only if "fileName" is not absolute, prepend the "absoluteBase".
-QString assemblePath(const std::filesystem::path& absoluteBaseDir,
-                     const std::string& fileName) {
-  if (fileName.empty()) return "";
+QString assemblePath(const std::filesystem::path &absoluteBaseDir,
+                     const std::string &fileName) {
+  if (fileName.empty())
+    return "";
   auto qsDir = QString::fromLocal8Bit(absoluteBaseDir.generic_string().c_str());
   auto qsFile = QString::fromLocal8Bit(fileName.c_str());
   // if qsfile is absolute, dir is ignored. (see documentation of QFileInfo)
@@ -121,30 +123,26 @@ QString assemblePath(const std::filesystem::path& absoluteBaseDir,
   return fileInfo.absoluteFilePath();
 }
 
+void dialogThreadFunc(FontCacheInitializer *initializer) { initializer->run(); }
 
-void dialogThreadFunc(FontCacheInitializer *initializer)
-{
-  initializer->run();
-}
-
-void dialogInitHandler(FontCacheInitializer *initializer, void *)
-{
+void dialogInitHandler(FontCacheInitializer *initializer, void *) {
   QFutureWatcher<void> futureWatcher;
-  QObject::connect(&futureWatcher, &QFutureWatcher<void>::finished, scadApp, &OpenSCADApp::hideFontCacheDialog);
+  QObject::connect(&futureWatcher, &QFutureWatcher<void>::finished, scadApp,
+                   &OpenSCADApp::hideFontCacheDialog);
 
-  auto future = QtConcurrent::run([initializer] {
-      return dialogThreadFunc(initializer);
-    });
+  auto future = QtConcurrent::run(
+      [initializer] { return dialogThreadFunc(initializer); });
   futureWatcher.setFuture(future);
 
   // We don't always get the started() signal, so we start manually
   QMetaObject::invokeMethod(scadApp, "showFontCacheDialog");
 
-  // Block, in case we're in a separate thread, or the dialog was closed by the user
+  // Block, in case we're in a separate thread, or the dialog was closed by the
+  // user
   futureWatcher.waitForFinished();
 
-  // We don't always receive the finished signal. We still need the signal to break
-  // out of the exec() though.
+  // We don't always receive the finished signal. We still need the signal to
+  // break out of the exec() though.
   QMetaObject::invokeMethod(scadApp, "hideFontCacheDialog");
 }
 
@@ -153,15 +151,19 @@ void registerDefaultIcon(QString applicationFilePath) {
   // Not using cached instance here, so this needs to be in a
   // separate scope to ensure the QSettings instance is released
   // directly after use.
-  QSettings reg_setting(QLatin1String("HKEY_CURRENT_USER"), QSettings::NativeFormat);
-  auto appPath = QDir::toNativeSeparators(applicationFilePath + QLatin1String(",1"));
-  reg_setting.setValue(QLatin1String("Software/Classes/OpenSCAD_File/DefaultIcon/Default"), QVariant(appPath));
+  QSettings reg_setting(QLatin1String("HKEY_CURRENT_USER"),
+                        QSettings::NativeFormat);
+  auto appPath =
+      QDir::toNativeSeparators(applicationFilePath + QLatin1String(",1"));
+  reg_setting.setValue(
+      QLatin1String("Software/Classes/OpenSCAD_File/DefaultIcon/Default"),
+      QVariant(appPath));
 }
 #else
-void registerDefaultIcon(const QString&) { }
+void registerDefaultIcon(const QString &) {}
 #endif
 
-}  // namespace
+} // namespace
 
 #ifdef OPENSCAD_SUFFIX
 #define DESKTOP_FILENAME "openscad" OPENSCAD_SUFFIX
@@ -169,14 +171,13 @@ void registerDefaultIcon(const QString&) { }
 #define DESKTOP_FILENAME "openscad"
 #endif
 
-int gui(std::vector<std::string>& inputFiles, const std::filesystem::path& original_path, int argc, char **argv, const std::string& gui_test)
-{
+int gui(std::vector<std::string> &inputFiles,
+        const std::filesystem::path &original_path, int argc, char **argv,
+        const std::string &gui_test) {
   OpenSCADApp app(argc, argv);
   // remove ugly frames in the QStatusBar when using additional widgets
-  app.setStyleSheet(
-    "QStatusBar::item { border: 0px solid black; }"
-    "* { font-size: 9pt }"
-    );
+  app.setStyleSheet("QStatusBar::item { border: 0px solid black; }"
+                    "* { font-size: 9pt }");
   QIcon::setThemeName(isDarkMode() ? "chokusen-dark" : "chokusen");
 
   // set up groups for QSettings
@@ -217,7 +218,8 @@ int gui(std::vector<std::string>& inputFiles, const std::filesystem::path& origi
 #ifdef OPENSCAD_UPDATER
   AutoUpdater *updater = new SparkleAutoUpdater;
   AutoUpdater::setUpdater(updater);
-  if (updater->automaticallyChecksForUpdates()) updater->checkForUpdates();
+  if (updater->automaticallyChecksForUpdates())
+    updater->checkForUpdates();
   updater->init();
 #endif
 
@@ -241,7 +243,7 @@ int gui(std::vector<std::string>& inputFiles, const std::filesystem::path& origi
       // the "" dummy in inputFiles to open an empty MainWindow.
       if (!files.empty()) {
         inputFiles.clear();
-        for (const auto& f : files) {
+        for (const auto &f : files) {
           inputFiles.push_back(f.toStdString());
         }
       }
@@ -251,11 +253,11 @@ int gui(std::vector<std::string>& inputFiles, const std::filesystem::path& origi
   }
 
   QStringList inputFilesList;
-  for (const auto& infile: inputFiles) {
+  for (const auto &infile : inputFiles) {
     inputFilesList.append(assemblePath(original_path, infile));
   }
   new MainWindow(inputFilesList);
-  QObject::connect(&app, &QCoreApplication::aboutToQuit, [](){
+  QObject::connect(&app, &QCoreApplication::aboutToQuit, []() {
     QSettingsCached{}.release();
 #ifdef Q_OS_MACOS
     CocoaUtils::endApplication();
@@ -271,7 +273,8 @@ int gui(std::vector<std::string>& inputFiles, const std::filesystem::path& origi
 #ifdef ENABLE_SPNAV
   if (Settings::Settings::inputEnableDriverSPNAV.value()) {
     auto spaceNavDriver = new SpaceNavInputDriver();
-    bool spaceNavDominantAxisOnly = Settings::Settings::inputEnableDriverHIDAPI.value();
+    bool spaceNavDominantAxisOnly =
+        Settings::Settings::inputEnableDriverHIDAPI.value();
     spaceNavDriver->setDominantAxisOnly(spaceNavDominantAxisOnly);
     InputDriverManager::instance()->registerDriver(spaceNavDriver);
   }
@@ -300,13 +303,13 @@ int gui(std::vector<std::string>& inputFiles, const std::filesystem::path& origi
 #endif
 
 #ifdef ENABLE_GUI_TESTS
-  // Adds a singleshot timer that will be executed when the application will be started.
-  // the timer validates that each mainwindow respects the expected UX behavior.
-  if (gui_test != "none"){
-    QTimer::singleShot(0, [&]()
-    {
+  // Adds a singleshot timer that will be executed when the application will be
+  // started. the timer validates that each mainwindow respects the expected UX
+  // behavior.
+  if (gui_test != "none") {
+    QTimer::singleShot(0, [&]() {
       int failureCount = 0;
-      for (auto w : app.windowManager.getWindows()){
+      for (auto w : app.windowManager.getWindows()) {
         failureCount += runAllTest(w);
       }
       app.exit(failureCount);
diff --git a/src/openscad_gui.h b/src/openscad_gui.h
index fec7c48d6..2c2b936a3 100644
--- a/src/openscad_gui.h
+++ b/src/openscad_gui.h
@@ -31,4 +31,6 @@
 
 #include <filesystem>
 
-int gui(std::vector<std::string>& inputFiles, const std::filesystem::path& original_path, int argc, char **argv, const std::string&);
+int gui(std::vector<std::string> &inputFiles,
+        const std::filesystem::path &original_path, int argc, char **argv,
+        const std::string &);
diff --git a/src/openscad_mimalloc.h b/src/openscad_mimalloc.h
index 562157e26..d49d4a475 100644
--- a/src/openscad_mimalloc.h
+++ b/src/openscad_mimalloc.h
@@ -5,18 +5,23 @@
 #if 0 // defined(_WIN32) && defined(MI_LINK_SHARED)
 // mimalloc doesn't support static override of malloc on Windows.
 // This include causes crashes if mimalloc is statically linked.
-  #include <mimalloc-new-delete.h>
+#include <mimalloc-new-delete.h>
 #else
-  #include <mimalloc.h>
+#include <mimalloc.h>
 #endif
 
 #if defined(ENABLE_CGAL)
 #include <cstddef>
-// gmp requires function signature with extra oldsize parameters for some reason.
-inline void *gmp_realloc(void *ptr, size_t /*oldsize*/, size_t newsize) { return mi_realloc(ptr, newsize); }
+// gmp requires function signature with extra oldsize parameters for some
+// reason.
+inline void *gmp_realloc(void *ptr, size_t /*oldsize*/, size_t newsize) {
+  return mi_realloc(ptr, newsize);
+}
 inline void gmp_free(void *ptr, size_t /*oldsize*/) { mi_free(ptr); }
-  #include <gmp.h>
-inline void init_mimalloc() { mp_set_memory_functions(mi_malloc, gmp_realloc, gmp_free); }
+#include <gmp.h>
+inline void init_mimalloc() {
+  mp_set_memory_functions(mi_malloc, gmp_realloc, gmp_free);
+}
 #endif // ENABLE_CGAL
 
 #endif // USE_MIMALLOC
diff --git a/src/platform/CocoaUtils.h b/src/platform/CocoaUtils.h
index 234622ac7..893c90ad3 100644
--- a/src/platform/CocoaUtils.h
+++ b/src/platform/CocoaUtils.h
@@ -2,9 +2,8 @@
 
 #include <string>
 
-class CocoaUtils
-{
+class CocoaUtils {
 public:
   static void endApplication();
-  static void nslog(const std::string& str, void *userdata);
+  static void nslog(const std::string &str, void *userdata);
 };
diff --git a/src/platform/PlatformUtils-posix.cc b/src/platform/PlatformUtils-posix.cc
index b7c32bb39..e87e58454 100644
--- a/src/platform/PlatformUtils-posix.cc
+++ b/src/platform/PlatformUtils-posix.cc
@@ -1,25 +1,24 @@
-#include <iterator>
+#include <fstream>
 #include <ios>
+#include <iterator>
 #include <mutex>
 #include <string>
-#include <fstream>
-#include <unistd.h>
 #include <sys/resource.h>
 #include <sys/utsname.h>
+#include <unistd.h>
 
-#include <boost/regex.hpp>
 #include <boost/algorithm/string.hpp>
+#include <boost/regex.hpp>
 #include <filesystem>
 
-#include "version.h"
 #include "platform/PlatformUtils.h"
+#include "version.h"
 
 namespace fs = std::filesystem;
 
 static std::mutex user_agent_mutex;
 
-static std::string readText(const std::string& path)
-{
+static std::string readText(const std::string &path) {
   std::ifstream s{path.c_str()};
   s.seekg(0, std::ios::end);
   if (s.fail() || s.tellg() > 4096) {
@@ -27,13 +26,13 @@ static std::string readText(const std::string& path)
   }
   s.seekg(0, std::ios::beg);
 
-  std::string text{(std::istreambuf_iterator<char>(s)), std::istreambuf_iterator<char>()};
+  std::string text{(std::istreambuf_iterator<char>(s)),
+                   std::istreambuf_iterator<char>()};
   return text;
 }
 
 // see http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html
-static fs::path getXdgConfigDir()
-{
+static fs::path getXdgConfigDir() {
   const char *xdg_env = getenv("XDG_CONFIG_HOME");
   if (xdg_env && fs::exists(fs::path{xdg_env})) {
     return fs::path{xdg_env};
@@ -52,8 +51,7 @@ static fs::path getXdgConfigDir()
 // user-dirs.dirs file generated by the xdg-user-dirs-update tool. Missing
 // is any handling of shell style quotes so this may fail with unusual
 // setup.
-static std::string getXdgUserDir(const std::string& dir)
-{
+static std::string getXdgUserDir(const std::string &dir) {
   const fs::path config_dir = getXdgConfigDir() / "user-dirs.dirs";
   const std::string user_dirs{readText(config_dir.generic_string())};
 
@@ -66,13 +64,9 @@ static std::string getXdgUserDir(const std::string& dir)
   return "";
 }
 
-std::string PlatformUtils::pathSeparatorChar()
-{
-  return ":";
-}
+std::string PlatformUtils::pathSeparatorChar() { return ":"; }
 
-std::string PlatformUtils::userDocumentsPath()
-{
+std::string PlatformUtils::userDocumentsPath() {
   fs::path user_documents_path;
 
   const char *xdg_env = getenv("XDG_DOCUMENTS_DIR");
@@ -98,8 +92,7 @@ std::string PlatformUtils::userDocumentsPath()
   return "";
 }
 
-std::string PlatformUtils::documentsPath()
-{
+std::string PlatformUtils::documentsPath() {
   const char *home = getenv("HOME");
   if (home) {
     fs::path docpath(home);
@@ -110,8 +103,7 @@ std::string PlatformUtils::documentsPath()
   }
 }
 
-std::string PlatformUtils::userConfigPath()
-{
+std::string PlatformUtils::userConfigPath() {
   const fs::path config_path{getXdgConfigDir() / OPENSCAD_FOLDER_NAME};
 
   if (fs::is_directory(config_path)) {
@@ -121,8 +113,7 @@ std::string PlatformUtils::userConfigPath()
   return "";
 }
 
-unsigned long PlatformUtils::stackLimit()
-{
+unsigned long PlatformUtils::stackLimit() {
 #ifndef __EMSCRIPTEN__
   struct rlimit limit;
 
@@ -152,8 +143,7 @@ unsigned long PlatformUtils::stackLimit()
  * @see http://www.freedesktop.org/software/systemd/man/os-release.html
  * @return the PRETTY_NAME from the os-release file or an empty string.
  */
-static const std::string checkOsRelease()
-{
+static const std::string checkOsRelease() {
   std::string os_release(readText("/etc/os-release"));
 
   boost::smatch results;
@@ -165,8 +155,7 @@ static const std::string checkOsRelease()
   return "";
 }
 
-static const std::string checkEtcIssue()
-{
+static const std::string checkEtcIssue() {
   std::string issue(readText("/etc/issue"));
 
   boost::regex nl("\n.*$");
@@ -178,8 +167,7 @@ static const std::string checkEtcIssue()
   return issue;
 }
 
-static const std::string detectDistribution()
-{
+static const std::string detectDistribution() {
   std::string osrelease = checkOsRelease();
   if (!osrelease.empty()) {
     return osrelease;
@@ -193,8 +181,7 @@ static const std::string detectDistribution()
   return "";
 }
 
-static const std::string get_distribution(const std::string& separator)
-{
+static const std::string get_distribution(const std::string &separator) {
   std::string result;
   std::string distribution = detectDistribution();
   if (!distribution.empty()) {
@@ -204,8 +191,7 @@ static const std::string get_distribution(const std::string& separator)
   return result;
 }
 
-static const std::string get_system_info(bool extended = true)
-{
+static const std::string get_system_info(bool extended = true) {
   std::string result;
 
   struct utsname osinfo;
@@ -226,8 +212,7 @@ static const std::string get_system_info(bool extended = true)
   return result;
 }
 
-const std::string PlatformUtils::user_agent()
-{
+const std::string PlatformUtils::user_agent() {
   static std::string result;
 
   std::lock_guard<std::mutex> lock(user_agent_mutex);
@@ -244,8 +229,7 @@ const std::string PlatformUtils::user_agent()
   return result;
 }
 
-const std::string PlatformUtils::sysinfo(bool extended)
-{
+const std::string PlatformUtils::sysinfo(bool extended) {
   std::string result;
 
   result += get_system_info(true);
diff --git a/src/platform/PlatformUtils-win.cc b/src/platform/PlatformUtils-win.cc
index 0243ece1d..503d0a431 100644
--- a/src/platform/PlatformUtils-win.cc
+++ b/src/platform/PlatformUtils-win.cc
@@ -2,11 +2,11 @@
 
 #include <filesystem>
 #include <ios>
-#include <string>
 #include <map>
+#include <string>
 
-#include "utils/printutils.h"
 #include "utils/findversion.h"
+#include "utils/printutils.h"
 #ifndef _WIN32_WINNT
 #define _WIN32_WINNT 0x0501
 #endif
@@ -24,14 +24,10 @@
 
 #include "version.h"
 
-std::string PlatformUtils::pathSeparatorChar()
-{
-  return ";";
-}
+std::string PlatformUtils::pathSeparatorChar() { return ";"; }
 
 // convert from windows api w_char strings (usually utf16) to utf8 std::string
-std::string winapi_wstr_to_utf8(std::wstring wstr)
-{
+std::string winapi_wstr_to_utf8(std::wstring wstr) {
   UINT CodePage = CP_UTF8;
   DWORD dwFlags = 0;
   LPCWSTR lpWideCharStr = &wstr[0];
@@ -42,16 +38,19 @@ std::string winapi_wstr_to_utf8(std::wstring wstr)
   LPBOOL lpUsedDefaultChar = nullptr;
 
   int numbytes = WideCharToMultiByte(CodePage, dwFlags, lpWideCharStr,
-                                     cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar);
+                                     cchWideChar, lpMultiByteStr, cbMultiByte,
+                                     lpDefaultChar, lpUsedDefaultChar);
 
-  // LOG(message_group::NONE,,"utf16 to utf8 conversion: numbytes %1$i",numbytes);
+  // LOG(message_group::NONE,,"utf16 to utf8 conversion: numbytes
+  // %1$i",numbytes);
 
   std::string utf8_str(numbytes, 0);
   lpMultiByteStr = &utf8_str[0];
   cbMultiByte = numbytes;
 
   int result = WideCharToMultiByte(CodePage, dwFlags, lpWideCharStr,
-                                   cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar);
+                                   cchWideChar, lpMultiByteStr, cbMultiByte,
+                                   lpDefaultChar, lpUsedDefaultChar);
 
   if (result != numbytes) {
     DWORD errcode = GetLastError();
@@ -62,9 +61,9 @@ std::string winapi_wstr_to_utf8(std::wstring wstr)
   return utf8_str;
 }
 
-// see http://msdn.microsoft.com/en-us/library/windows/desktop/bb762494%28v=vs.85%29.aspx
-static const std::string getFolderPath(int nFolder)
-{
+// see
+// http://msdn.microsoft.com/en-us/library/windows/desktop/bb762494%28v=vs.85%29.aspx
+static const std::string getFolderPath(int nFolder) {
   std::wstring path(MAX_PATH, 0);
 
   HWND hwndOwner = 0;
@@ -75,7 +74,7 @@ static const std::string getFolderPath(int nFolder)
   int result = SHGetFolderPathW(hwndOwner, nFolder, hToken, dwFlags, pszPath);
 
   if (result == S_OK) {
-    path = std::wstring(path.c_str() ); // strip extra nullptrs
+    path = std::wstring(path.c_str()); // strip extra nullptrs
     // Use std::filesystem to decide how to convert from wstring
     // to string. Normally the path encoding is system local and
     // we don't want to force conversion to UTF-8.
@@ -85,18 +84,14 @@ static const std::string getFolderPath(int nFolder)
   return "";
 }
 
-std::string PlatformUtils::userDocumentsPath()
-{
-  return documentsPath();
-}
+std::string PlatformUtils::userDocumentsPath() { return documentsPath(); }
 
 // retrieve the path to 'My Documents' for the current user under windows
 // In XP this is 'c:\documents and settings\username\my documents'
 // In Vista, 7, 8+ this is 'c:\users\username\documents'
 // This code may have problems with unusual dir types in Vista because
 // Mingw does not provide access to the updated SHGetKnownFolderPath
-std::string PlatformUtils::documentsPath()
-{
+std::string PlatformUtils::documentsPath() {
   const std::string retval = getFolderPath(CSIDL_PERSONAL);
   if (retval.empty()) {
     LOG(message_group::Error, "Could not find My Documents location");
@@ -104,8 +99,7 @@ std::string PlatformUtils::documentsPath()
   return retval;
 }
 
-std::string PlatformUtils::userConfigPath()
-{
+std::string PlatformUtils::userConfigPath() {
   const std::string retval = getFolderPath(CSIDL_LOCAL_APPDATA);
   if (retval.empty()) {
     LOG(message_group::Error, "Could not find Local AppData location");
@@ -113,23 +107,21 @@ std::string PlatformUtils::userConfigPath()
   return retval + std::string("/") + PlatformUtils::OPENSCAD_FOLDER_NAME;
 }
 
-unsigned long PlatformUtils::stackLimit()
-{
-  return STACK_LIMIT_DEFAULT;
-}
+unsigned long PlatformUtils::stackLimit() { return STACK_LIMIT_DEFAULT; }
 
 // NOLINTNEXTLINE(modernize-use-using)
-typedef BOOL (WINAPI *LPFN_ISWOW64PROCESS)(HANDLE, PBOOL);
+typedef BOOL(WINAPI *LPFN_ISWOW64PROCESS)(HANDLE, PBOOL);
 
-// see http://msdn.microsoft.com/en-us/library/windows/desktop/ms684139%28v=vs.85%29.aspx
-static BOOL IsWow64()
-{
+// see
+// http://msdn.microsoft.com/en-us/library/windows/desktop/ms684139%28v=vs.85%29.aspx
+static BOOL IsWow64() {
   BOOL bIsWow64 = FALSE;
 
-  //IsWow64Process is not available on all supported versions of Windows.
-  //Use GetModuleHandle to get a handle to the DLL that contains the function
-  //and GetProcAddress to get a pointer to the function if available.
-  LPFN_ISWOW64PROCESS fnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress(GetModuleHandle(TEXT("kernel32")), "IsWow64Process");
+  // IsWow64Process is not available on all supported versions of Windows.
+  // Use GetModuleHandle to get a handle to the DLL that contains the function
+  // and GetProcAddress to get a pointer to the function if available.
+  LPFN_ISWOW64PROCESS fnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress(
+      GetModuleHandle(TEXT("kernel32")), "IsWow64Process");
 
   if (nullptr != fnIsWow64Process) {
     if (!fnIsWow64Process(GetCurrentProcess(), &bIsWow64)) {
@@ -139,8 +131,7 @@ static BOOL IsWow64()
   return bIsWow64;
 }
 
-const std::string PlatformUtils::user_agent()
-{
+const std::string PlatformUtils::user_agent() {
   std::string result;
 
   result += "OpenSCAD/";
@@ -152,8 +143,7 @@ const std::string PlatformUtils::user_agent()
   return result;
 }
 
-const std::string PlatformUtils::sysinfo(bool extended)
-{
+const std::string PlatformUtils::sysinfo(bool extended) {
   std::string result;
 
   SYSTEM_INFO si;
@@ -177,7 +167,8 @@ const std::string PlatformUtils::sysinfo(bool extended)
       majorVersion = 11;
     }
     boost::format fmt("Microsoft Windows %d (%d.%d.%d) %s");
-    fmt % majorVersion % osinfo.dwMajorVersion % osinfo.dwMinorVersion % osinfo.dwBuildNumber % archs[si.wProcessorArchitecture];
+    fmt % majorVersion % osinfo.dwMajorVersion % osinfo.dwMinorVersion %
+        osinfo.dwBuildNumber % archs[si.wProcessorArchitecture];
     result += fmt.str();
   }
 
@@ -207,35 +198,37 @@ const std::string PlatformUtils::sysinfo(bool extended)
   return result;
 }
 
-#include <io.h>
 #include <cstdio>
+#include <io.h>
 
 #ifdef USE_MIMALLOC
 #include <mimalloc.h>
-// mimalloc needs an output handler that references stderr after we mess with it.
-static void mi_output(const char *msg, void *arg) {
-  fputs(msg, stderr);
-}
+// mimalloc needs an output handler that references stderr after we mess with
+// it.
+static void mi_output(const char *msg, void *arg) { fputs(msg, stderr); }
 #endif
 
 // attach to parent console if standard IO handles not available
 // It may be good idea to redirect the output to file(s) here in some future.
-void PlatformUtils::ensureStdIO(void)
-{
+void PlatformUtils::ensureStdIO(void) {
   // Preserve existing handles whenever available.
   // HANDLE hRead = (HANDLE)_get_osfhandle(_fileno(stdin));
   HANDLE hWrite = (HANDLE)_get_osfhandle(_fileno(stdout));
   HANDLE hError = (HANDLE)_get_osfhandle(_fileno(stderr));
 
-  if (/* INVALID_HANDLE_VALUE == hRead || */ INVALID_HANDLE_VALUE == hWrite || INVALID_HANDLE_VALUE == hError) {
+  if (/* INVALID_HANDLE_VALUE == hRead || */ INVALID_HANDLE_VALUE == hWrite ||
+      INVALID_HANDLE_VALUE == hError) {
 
     // I see nothing to do about error(s) here.
     if (AttachConsole(ATTACH_PARENT_PROCESS)) {
 
       // Let CRT machinery performs proper setup.
-      // if (INVALID_HANDLE_VALUE == hRead) (void)_wfreopen(L"CONIN$",  L"rt", stdin);
-      if (INVALID_HANDLE_VALUE == hWrite) (void)_wfreopen(L"CONOUT$",  L"wt", stdout);
-      if (INVALID_HANDLE_VALUE == hError) (void)_wfreopen(L"CONOUT$",  L"wt", stderr);
+      // if (INVALID_HANDLE_VALUE == hRead) (void)_wfreopen(L"CONIN$",  L"rt",
+      // stdin);
+      if (INVALID_HANDLE_VALUE == hWrite)
+        (void)_wfreopen(L"CONOUT$", L"wt", stdout);
+      if (INVALID_HANDLE_VALUE == hError)
+        (void)_wfreopen(L"CONOUT$", L"wt", stderr);
 
       std::ios_base::sync_with_stdio();
     }
diff --git a/src/platform/PlatformUtils.cc b/src/platform/PlatformUtils.cc
index ab43b267a..b9d9b68e4 100644
--- a/src/platform/PlatformUtils.cc
+++ b/src/platform/PlatformUtils.cc
@@ -1,10 +1,10 @@
 #include "platform/PlatformUtils.h"
 
-#include <filesystem>
-#include <stdexcept>
 #include <cstdint>
 #include <cstdlib>
+#include <filesystem>
 #include <iomanip>
+#include <stdexcept>
 #include <string>
 #include <vector>
 
@@ -23,41 +23,37 @@ namespace {
 bool path_initialized = false;
 std::string applicationpath;
 std::string resourcespath;
-}
+} // namespace
 
 const char *PlatformUtils::OPENSCAD_FOLDER_NAME = "OpenSCAD";
 
-static std::string lookupResourcesPath()
-{
+static std::string lookupResourcesPath() {
   fs::path resourcedir(applicationpath);
-  PRINTDB("Looking up resource folder with application path '%s'", resourcedir.generic_string().c_str());
+  PRINTDB("Looking up resource folder with application path '%s'",
+          resourcedir.generic_string().c_str());
 
 #ifdef __APPLE__
   const char *searchpath[] = {
-    "../Resources", // Resources can be bundled on Mac.
-    "../../..", // Dev location
-    "../../../..", // Test location (cmake)
-    "..",   // Test location
-    RESOURCE_FOLDER("../share/openscad"), // Unix mode
-    nullptr
-  };
+      "../Resources",                       // Resources can be bundled on Mac.
+      "../../..",                           // Dev location
+      "../../../..",                        // Test location (cmake)
+      "..",                                 // Test location
+      RESOURCE_FOLDER("../share/openscad"), // Unix mode
+      nullptr};
 #else
 #ifdef _WIN32
   const char *searchpath[] = {
-    ".", // Release location
-    RESOURCE_FOLDER("../share/openscad"), // MSYS2 location
-    "..", // Dev location
-    nullptr
-  };
+      ".",                                  // Release location
+      RESOURCE_FOLDER("../share/openscad"), // MSYS2 location
+      "..",                                 // Dev location
+      nullptr};
 #else
-  const char *searchpath[] = {
-    RESOURCE_FOLDER("../share/openscad"),
-    RESOURCE_FOLDER("../../share/openscad"),
-    ".",
-    "..",
-    "../..",
-    nullptr
-  };
+  const char *searchpath[] = {RESOURCE_FOLDER("../share/openscad"),
+                              RESOURCE_FOLDER("../../share/openscad"),
+                              ".",
+                              "..",
+                              "../..",
+                              nullptr};
 #endif // ifdef _WIN32
 #endif // ifdef __APPLE__
 
@@ -65,8 +61,8 @@ static std::string lookupResourcesPath()
   for (int a = 0; searchpath[a] != nullptr; ++a) {
     tmpdir = resourcedir / searchpath[a];
 
-    // The resource folder is the folder which contains "color-schemes" (as well as
-    // "examples" and "locale", and optionally "libraries" and "fonts")
+    // The resource folder is the folder which contains "color-schemes" (as well
+    // as "examples" and "locale", and optionally "libraries" and "fonts")
     const fs::path checkdir = tmpdir / "color-schemes";
     PRINTDB("Checking '%s'", checkdir.generic_string().c_str());
 
@@ -86,23 +82,21 @@ static std::string lookupResourcesPath()
   return result;
 }
 
-void PlatformUtils::registerApplicationPath(const std::string& apppath)
-{
+void PlatformUtils::registerApplicationPath(const std::string &apppath) {
   applicationpath = apppath;
   resourcespath = lookupResourcesPath();
   path_initialized = true;
 }
 
-std::string PlatformUtils::applicationPath()
-{
+std::string PlatformUtils::applicationPath() {
   if (!path_initialized) {
-    throw std::runtime_error("PlatformUtils::applicationPath(): application path not initialized!");
+    throw std::runtime_error(
+        "PlatformUtils::applicationPath(): application path not initialized!");
   }
   return applicationpath;
 }
 
-bool PlatformUtils::createUserLibraryPath()
-{
+bool PlatformUtils::createUserLibraryPath() {
   std::string path = PlatformUtils::userLibraryPath();
   bool OK = false;
   try {
@@ -113,68 +107,65 @@ bool PlatformUtils::createUserLibraryPath()
     if (!OK) {
       LOG(message_group::Error, "Cannot create %1$s", path);
     }
-  } catch (const fs::filesystem_error& ex) {
+  } catch (const fs::filesystem_error &ex) {
     LOG(message_group::Error, "%1$s", ex.what());
   }
   return OK;
 }
 
-std::string PlatformUtils::userPath(const std::string& name)
-{
+std::string PlatformUtils::userPath(const std::string &name) {
   fs::path path;
   try {
     std::string pathstr = PlatformUtils::documentsPath();
-    if (pathstr == "") return "";
+    if (pathstr == "")
+      return "";
     path = fs::path(pathstr);
-    if (!fs::exists(path)) return "";
+    if (!fs::exists(path))
+      return "";
 #ifndef __EMSCRIPTEN__
     path = fs::canonical(path);
 #endif
     // LOG(message_group::NONE,,"path size %1$i",fs::stringy(path).size());
     // LOG(message_group::NONE,,"lib path found: [%1$s]",path);
-    if (path.empty()) return "";
+    if (path.empty())
+      return "";
     path /= OPENSCAD_FOLDER_NAME;
     path /= name;
     // LOG(message_group::NONE,,"Appended path %1$s",path);
     // LOG(message_group::NONE,,"Exists: %1$i",fs::exists(path));
-  } catch (const fs::filesystem_error& ex) {
+  } catch (const fs::filesystem_error &ex) {
     LOG(message_group::Error, "%1$s", ex.what());
   }
   return path.generic_string();
 }
 
-std::string PlatformUtils::userLibraryPath()
-{
-  return userPath("libraries");
-}
+std::string PlatformUtils::userLibraryPath() { return userPath("libraries"); }
 
-std::string PlatformUtils::userExamplesPath()
-{
-  return userPath("examples");
-}
+std::string PlatformUtils::userExamplesPath() { return userPath("examples"); }
 
-std::string PlatformUtils::backupPath()
-{
+std::string PlatformUtils::backupPath() {
   fs::path path;
   try {
     std::string pathstr = PlatformUtils::documentsPath();
-    if (pathstr == "") return "";
+    if (pathstr == "")
+      return "";
     path = fs::path(pathstr);
-    if (!fs::exists(path)) return "";
+    if (!fs::exists(path))
+      return "";
 #ifndef __EMSCRIPTEN__
     path = fs::canonical(path);
 #endif
-    if (path.empty()) return "";
+    if (path.empty())
+      return "";
     path /= OPENSCAD_FOLDER_NAME;
     path /= "backups";
-  } catch (const fs::filesystem_error& ex) {
+  } catch (const fs::filesystem_error &ex) {
     LOG(message_group::Error, "%1$s", ex.what());
   }
   return path.generic_string();
 }
 
-bool PlatformUtils::createBackupPath()
-{
+bool PlatformUtils::createBackupPath() {
   std::string path = PlatformUtils::backupPath();
   bool OK = false;
   try {
@@ -184,23 +175,22 @@ bool PlatformUtils::createBackupPath()
     if (!OK) {
       LOG(message_group::Error, "Cannot create %1$s", path);
     }
-  } catch (const fs::filesystem_error& ex) {
+  } catch (const fs::filesystem_error &ex) {
     LOG(message_group::Error, "%1$s", ex.what());
   }
   return OK;
 }
 
 // This is the built-in read-only resources path
-std::string PlatformUtils::resourceBasePath()
-{
+std::string PlatformUtils::resourceBasePath() {
   if (!path_initialized) {
-    throw std::runtime_error("PlatformUtils::resourcesPath(): application path not initialized!");
+    throw std::runtime_error(
+        "PlatformUtils::resourcesPath(): application path not initialized!");
   }
   return resourcespath;
 }
 
-fs::path PlatformUtils::resourcePath(const std::string& resource)
-{
+fs::path PlatformUtils::resourcePath(const std::string &resource) {
   fs::path base(resourceBasePath());
   if (!fs::is_directory(base)) {
     return {};
@@ -214,8 +204,7 @@ fs::path PlatformUtils::resourcePath(const std::string& resource)
   return resource_dir;
 }
 
-int PlatformUtils::setenv(const char *name, const char *value, int overwrite)
-{
+int PlatformUtils::setenv(const char *name, const char *value, int overwrite) {
 #if defined(_WIN32)
   const char *ptr = getenv(name);
   if ((overwrite == 0) && (ptr != nullptr)) {
@@ -230,9 +219,8 @@ int PlatformUtils::setenv(const char *name, const char *value, int overwrite)
 #endif
 }
 
-std::string PlatformUtils::toMemorySizeString(uint64_t bytes, int digits)
-{
-  static const char *units[] = { "B", "kB", "MB", "GB", "TB", nullptr };
+std::string PlatformUtils::toMemorySizeString(uint64_t bytes, int digits) {
+  static const char *units[] = {"B", "kB", "MB", "GB", "TB", nullptr};
 
   int idx = 0;
   double val = bytes;
diff --git a/src/platform/PlatformUtils.h b/src/platform/PlatformUtils.h
index 266624f91..b97078593 100644
--- a/src/platform/PlatformUtils.h
+++ b/src/platform/PlatformUtils.h
@@ -1,19 +1,20 @@
 #pragma once
 
-#include <cstdint>
 #include <cstddef>
+#include <cstdint>
 #include <string>
 
 #include <filesystem>
 namespace fs = std::filesystem;
 
 static constexpr size_t STACK_BUFFER_SIZE = 128ul * 1024ul;
-static constexpr size_t STACK_LIMIT_DEFAULT = size_t{STACKSIZE} - STACK_BUFFER_SIZE;
+static constexpr size_t STACK_LIMIT_DEFAULT =
+    size_t{STACKSIZE} - STACK_BUFFER_SIZE;
 
 namespace PlatformUtils {
 extern const char *OPENSCAD_FOLDER_NAME;
 
-void registerApplicationPath(const std::string& applicationpath);
+void registerApplicationPath(const std::string &applicationpath);
 std::string applicationPath();
 
 /**
@@ -34,10 +35,10 @@ std::string documentsPath();
  *
  * @return the path for saving user documents
  */
-std::string userPath(const std::string& name);
+std::string userPath(const std::string &name);
 std::string userDocumentsPath();
 std::string resourceBasePath();
-fs::path resourcePath(const std::string& resource);
+fs::path resourcePath(const std::string &resource);
 std::string userLibraryPath();
 std::string userExamplesPath();
 
diff --git a/src/python/pyfunctions.cc b/src/python/pyfunctions.cc
index db2742011..d303c2db9 100644
--- a/src/python/pyfunctions.cc
+++ b/src/python/pyfunctions.cc
@@ -24,34 +24,32 @@
  *
  */
 
-#include <Python.h>
-#include "python/pyopenscad.h"
-#include "core/primitives.h"
-#include "core/CsgOpNode.h"
+#include "core/CgalAdvNode.h"
 #include "core/ColorNode.h"
 #include "core/ColorUtil.h"
-#include "core/TransformNode.h"
+#include "core/CsgOpNode.h"
+#include "core/ImportNode.h"
 #include "core/LinearExtrudeNode.h"
-#include "core/RotateExtrudeNode.h"
-#include "core/CgalAdvNode.h"
-#include "core/RoofNode.h"
+#include "core/OffsetNode.h"
+#include "core/ProjectionNode.h"
 #include "core/RenderNode.h"
+#include "core/RoofNode.h"
+#include "core/RotateExtrudeNode.h"
 #include "core/SurfaceNode.h"
 #include "core/TextNode.h"
-#include "core/OffsetNode.h"
-#include "core/ProjectionNode.h"
-#include "core/ImportNode.h"
+#include "core/TransformNode.h"
 #include "core/Tree.h"
+#include "core/primitives.h"
+#include "geometry/GeometryEvaluator.h"
 #include "geometry/PolySet.h"
 #include "geometry/PolySetUtils.h"
-#include "geometry/GeometryEvaluator.h"
-#include "utils/degree_trig.h"
-#include "io/fileutils.h"
 #include "handle_dep.h"
+#include "io/fileutils.h"
+#include "python/pyopenscad.h"
+#include "utils/degree_trig.h"
+#include <Python.h>
 
-
-PyObject *python_cube(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_cube(PyObject *self, PyObject *args, PyObject *kwargs) {
   DECLARE_INSTANCE
   auto node = std::make_shared<CubeNode>(instance);
 
@@ -60,10 +58,8 @@ PyObject *python_cube(PyObject *self, PyObject *args, PyObject *kwargs)
 
   PyObject *center = NULL;
 
-
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO", kwlist,
-                                   &size,
-                                   &center)){
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO", kwlist, &size,
+                                   &center)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing cube(size)");
     return NULL;
   }
@@ -79,9 +75,11 @@ PyObject *python_cube(PyObject *self, PyObject *args, PyObject *kwargs)
     return NULL;
   }
   node->center = false;
-  if (center == Py_False || center == NULL)  ;
-  else if (center == Py_True){
-    for (int i = 0; i < 3; i++)node->center = true;
+  if (center == Py_False || center == NULL)
+    ;
+  else if (center == Py_True) {
+    for (int i = 0; i < 3; i++)
+      node->center = true;
   } else {
     PyErr_SetString(PyExc_TypeError, "Unknown Value for center parameter");
     return NULL;
@@ -89,8 +87,7 @@ PyObject *python_cube(PyObject *self, PyObject *args, PyObject *kwargs)
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_sphere(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_sphere(PyObject *self, PyObject *args, PyObject *kwargs) {
   DECLARE_INSTANCE
   auto node = std::make_shared<SphereNode>(instance);
 
@@ -102,9 +99,8 @@ PyObject *python_sphere(PyObject *self, PyObject *args, PyObject *kwargs)
 
   double vr = 1;
 
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|Odddd", kwlist,
-                                   &rp, &d, &fn, &fa, &fs
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|Odddd", kwlist, &rp, &d, &fn,
+                                   &fa, &fs)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing sphere(r|d)");
     return NULL;
   }
@@ -118,7 +114,8 @@ PyObject *python_sphere(PyObject *self, PyObject *args, PyObject *kwargs)
     }
     vr = r;
     if (!isnan(d)) {
-      PyErr_SetString(PyExc_TypeError, "Cant specify r and d at the same time for sphere");
+      PyErr_SetString(PyExc_TypeError,
+                      "Cant specify r and d at the same time for sphere");
       return NULL;
     }
   }
@@ -131,21 +128,24 @@ PyObject *python_sphere(PyObject *self, PyObject *args, PyObject *kwargs)
   }
 
   get_fnas(node->fn, node->fa, node->fs);
-  if (!isnan(fn)) node->fn = fn;
-  if (!isnan(fa)) node->fa = fa;
-  if (!isnan(fs)) node->fs = fs;
+  if (!isnan(fn))
+    node->fn = fn;
+  if (!isnan(fa))
+    node->fa = fa;
+  if (!isnan(fs))
+    node->fs = fs;
 
   node->r = vr;
 
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_cylinder(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_cylinder(PyObject *self, PyObject *args, PyObject *kwargs) {
   DECLARE_INSTANCE
   auto node = std::make_shared<CylinderNode>(instance);
 
-  char *kwlist[] = {"h", "r1", "r2", "center",  "r", "d", "d1", "d2",  "fn", "fa", "fs", NULL};
+  char *kwlist[] = {"h",  "r1", "r2", "center", "r",  "d",
+                    "d1", "d2", "fn", "fa",     "fs", NULL};
   double h = NAN;
   double r = NAN;
   double r1 = NAN;
@@ -159,9 +159,11 @@ PyObject *python_cylinder(PyObject *self, PyObject *args, PyObject *kwargs)
   PyObject *center = NULL;
   double vr1 = 1, vr2 = 1, vh = 1;
 
-
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|dddOddddddd", kwlist, &h, &r1, &r2, &center, &r, &d, &d1, &d2, &fn, &fa, &fs)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing cylinder(h,r|r1+r2|d1+d2)");
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|dddOddddddd", kwlist, &h,
+                                   &r1, &r2, &center, &r, &d, &d1, &d2, &fn,
+                                   &fa, &fs)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing cylinder(h,r|r1+r2|d1+d2)");
     return NULL;
   }
 
@@ -193,28 +195,38 @@ PyObject *python_cylinder(PyObject *self, PyObject *args, PyObject *kwargs)
   }
 
   if (!isnan(r1) && !isnan(r2)) {
-    vr1 = r1; vr2 = r2;
+    vr1 = r1;
+    vr2 = r2;
   } else if (!isnan(r1) && isnan(r2)) {
-    vr1 = r1; vr2 = r1;
+    vr1 = r1;
+    vr2 = r1;
   } else if (!isnan(d1) && !isnan(d2)) {
-    vr1 = d1 / 2.0; vr2 = d2 / 2.0;
+    vr1 = d1 / 2.0;
+    vr2 = d2 / 2.0;
   } else if (!isnan(r)) {
-    vr1 = r; vr2 = r;
+    vr1 = r;
+    vr2 = r;
   } else if (!isnan(d)) {
-    vr1 = d / 2.0; vr2 = d / 2.0;
+    vr1 = d / 2.0;
+    vr2 = d / 2.0;
   }
 
   get_fnas(node->fn, node->fa, node->fs);
-  if (!isnan(fn)) node->fn = fn;
-  if (!isnan(fa)) node->fa = fa;
-  if (!isnan(fs)) node->fs = fs;
+  if (!isnan(fn))
+    node->fn = fn;
+  if (!isnan(fa))
+    node->fa = fa;
+  if (!isnan(fs))
+    node->fs = fs;
 
   node->r1 = vr1;
   node->r2 = vr2;
   node->h = vh;
 
-  if (center == Py_True) node->center = 1;
-  else if (center == Py_False || center == NULL)   node->center = 0;
+  if (center == Py_True)
+    node->center = 1;
+  else if (center == Py_False || center == NULL)
+    node->center = 0;
   else {
     PyErr_SetString(PyExc_TypeError, "Unknown Value for center parameter");
     return NULL;
@@ -223,8 +235,7 @@ PyObject *python_cylinder(PyObject *self, PyObject *args, PyObject *kwargs)
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_polyhedron(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_polyhedron(PyObject *self, PyObject *args, PyObject *kwargs) {
   DECLARE_INSTANCE
   unsigned int i, j, pointIndex;
   auto node = std::make_shared<PolyhedronNode>(instance);
@@ -239,18 +250,17 @@ PyObject *python_polyhedron(PyObject *self, PyObject *args, PyObject *kwargs)
   Vector3d point;
 
   if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!O!|iO!", kwlist,
-                                   &PyList_Type, &points,
-                                   &PyList_Type, &faces,
-                                   &convexity,
-                                   &PyList_Type, &triangles
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing polyhedron(points, faces)");
+                                   &PyList_Type, &points, &PyList_Type, &faces,
+                                   &convexity, &PyList_Type, &triangles)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing polyhedron(points, faces)");
     return NULL;
   }
 
   if (points != NULL && PyList_Check(points)) {
     if (PyList_Size(points) == 0) {
-      PyErr_SetString(PyExc_TypeError, "There must at least be one point in the polyhedron");
+      PyErr_SetString(PyExc_TypeError,
+                      "There must at least be one point in the polyhedron");
       return NULL;
     }
     for (i = 0; i < PyList_Size(points); i++) {
@@ -261,22 +271,25 @@ PyObject *python_polyhedron(PyObject *self, PyObject *args, PyObject *kwargs)
         point[2] = PyFloat_AsDouble(PyList_GetItem(element, 2));
         node->points.push_back(point);
       } else {
-        PyErr_SetString(PyExc_TypeError, "Coordinate must exactly contain 3 numbers");
+        PyErr_SetString(PyExc_TypeError,
+                        "Coordinate must exactly contain 3 numbers");
         return NULL;
       }
-
     }
   } else {
-    PyErr_SetString(PyExc_TypeError, "Polyhedron Points must be a list of coordinates");
+    PyErr_SetString(PyExc_TypeError,
+                    "Polyhedron Points must be a list of coordinates");
     return NULL;
   }
 
   if (triangles != NULL) {
     faces = triangles;
-//	LOG(message_group::Deprecated, inst->location(), parameters.documentRoot(), "polyhedron(triangles=[]) will be removed in future releases. Use polyhedron(faces=[]) instead.");
+    //	LOG(message_group::Deprecated, inst->location(),
+    //parameters.documentRoot(), "polyhedron(triangles=[]) will be removed in
+    //future releases. Use polyhedron(faces=[]) instead.");
   }
 
-  if (faces != NULL && PyList_Check(faces) ) {
+  if (faces != NULL && PyList_Check(faces)) {
     if (PyList_Size(faces) == 0) {
       PyErr_SetString(PyExc_TypeError, "must specify at least 1 face");
       return NULL;
@@ -288,7 +301,8 @@ PyObject *python_polyhedron(PyObject *self, PyObject *args, PyObject *kwargs)
         for (j = 0; j < PyList_Size(element); j++) {
           pointIndex = PyLong_AsLong(PyList_GetItem(element, j));
           if (pointIndex < 0 || pointIndex >= node->points.size()) {
-            PyErr_SetString(PyExc_TypeError, "Polyhedron Point Index out of range");
+            PyErr_SetString(PyExc_TypeError,
+                            "Polyhedron Point Index out of range");
             return NULL;
           }
           face.push_back(pointIndex);
@@ -296,29 +310,31 @@ PyObject *python_polyhedron(PyObject *self, PyObject *args, PyObject *kwargs)
         if (face.size() >= 3) {
           node->faces.push_back(std::move(face));
         } else {
-          PyErr_SetString(PyExc_TypeError, "Polyhedron Face must sepcify at least 3 indices");
+          PyErr_SetString(PyExc_TypeError,
+                          "Polyhedron Face must sepcify at least 3 indices");
           return NULL;
         }
 
       } else {
-        PyErr_SetString(PyExc_TypeError, "Polyhedron Face must be a list of indices");
+        PyErr_SetString(PyExc_TypeError,
+                        "Polyhedron Face must be a list of indices");
         return NULL;
       }
     }
   } else {
-    PyErr_SetString(PyExc_TypeError, "Polyhedron faces must be a list of indices");
+    PyErr_SetString(PyExc_TypeError,
+                    "Polyhedron faces must be a list of indices");
     return NULL;
   }
 
-
   node->convexity = convexity;
-  if (node->convexity < 1) node->convexity = 1;
+  if (node->convexity < 1)
+    node->convexity = 1;
 
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_square(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_square(PyObject *self, PyObject *args, PyObject *kwargs) {
   DECLARE_INSTANCE
   auto node = std::make_shared<SquareNode>(instance);
 
@@ -328,9 +344,7 @@ PyObject *python_square(PyObject *self, PyObject *args, PyObject *kwargs)
   PyObject *center = NULL;
   double z = NAN;
 
-
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO", kwlist,
-                                   &dim,
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OO", kwlist, &dim,
                                    &center)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing square(dim)");
     return NULL;
@@ -341,8 +355,10 @@ PyObject *python_square(PyObject *self, PyObject *args, PyObject *kwargs)
       return NULL;
     }
   }
-  if (center == Py_True) node->center = 1;
-  else if (center == Py_False || center == NULL)   node->center = 0;
+  if (center == Py_True)
+    node->center = 1;
+  else if (center == Py_False || center == NULL)
+    node->center = 0;
   else {
     PyErr_SetString(PyExc_TypeError, "Unknown Value for center parameter");
     return NULL;
@@ -350,8 +366,7 @@ PyObject *python_square(PyObject *self, PyObject *args, PyObject *kwargs)
 
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
-PyObject *python_circle(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_circle(PyObject *self, PyObject *args, PyObject *kwargs) {
   DECLARE_INSTANCE
   auto node = std::make_shared<CircleNode>(instance);
 
@@ -362,7 +377,8 @@ PyObject *python_circle(PyObject *self, PyObject *args, PyObject *kwargs)
 
   double vr = 1;
 
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|ddddd", kwlist, &r, &d, &fn, &fa, &fs)) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|ddddd", kwlist, &r, &d, &fn,
+                                   &fa, &fs)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing circle(r|d)");
     return NULL;
   }
@@ -374,7 +390,8 @@ PyObject *python_circle(PyObject *self, PyObject *args, PyObject *kwargs)
     }
     vr = r;
     if (!isnan(d)) {
-      PyErr_SetString(PyExc_TypeError, "Cant specify r and d at the same time for circle");
+      PyErr_SetString(PyExc_TypeError,
+                      "Cant specify r and d at the same time for circle");
       return NULL;
     }
   }
@@ -386,19 +403,19 @@ PyObject *python_circle(PyObject *self, PyObject *args, PyObject *kwargs)
     vr = d / 2.0;
   }
 
-
   get_fnas(node->fn, node->fa, node->fs);
-  if (!isnan(fn)) node->fn = fn;
-  if (!isnan(fa)) node->fa = fa;
-  if (!isnan(fs)) node->fs = fs;
+  if (!isnan(fn))
+    node->fn = fn;
+  if (!isnan(fa))
+    node->fa = fa;
+  if (!isnan(fs))
+    node->fs = fs;
 
   node->r = vr;
 
-
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
-PyObject *python_polygon(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_polygon(PyObject *self, PyObject *args, PyObject *kwargs) {
   DECLARE_INSTANCE
   unsigned int i, j, pointIndex;
   auto node = std::make_shared<PolygonNode>(instance);
@@ -411,18 +428,17 @@ PyObject *python_polygon(PyObject *self, PyObject *args, PyObject *kwargs)
   PyObject *element;
   Vector2d point;
 
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!|O!i", kwlist,
-                                   &PyList_Type, &points,
-                                   &PyList_Type, &paths,
-                                   &convexity
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing polygon(points,paths)");
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!|O!i", kwlist, &PyList_Type,
+                                   &points, &PyList_Type, &paths, &convexity)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing polygon(points,paths)");
     return NULL;
   }
 
-  if (points != NULL && PyList_Check(points) ) {
+  if (points != NULL && PyList_Check(points)) {
     if (PyList_Size(points) == 0) {
-      PyErr_SetString(PyExc_TypeError, "There must at least be one point in the polygon");
+      PyErr_SetString(PyExc_TypeError,
+                      "There must at least be one point in the polygon");
       return NULL;
     }
     for (i = 0; i < PyList_Size(points); i++) {
@@ -432,19 +448,21 @@ PyObject *python_polygon(PyObject *self, PyObject *args, PyObject *kwargs)
         point[1] = PyFloat_AsDouble(PyList_GetItem(element, 1));
         node->points.push_back(point);
       } else {
-        PyErr_SetString(PyExc_TypeError, "Coordinate must exactly contain 2 numbers");
+        PyErr_SetString(PyExc_TypeError,
+                        "Coordinate must exactly contain 2 numbers");
         return NULL;
       }
-
     }
   } else {
-    PyErr_SetString(PyExc_TypeError, "Polygon points must be a list of coordinates");
+    PyErr_SetString(PyExc_TypeError,
+                    "Polygon points must be a list of coordinates");
     return NULL;
   }
 
-  if (paths != NULL && PyList_Check(paths) ) {
+  if (paths != NULL && PyList_Check(paths)) {
     if (PyList_Size(paths) == 0) {
-      PyErr_SetString(PyExc_TypeError, "must specify at least 1 path when specified");
+      PyErr_SetString(PyExc_TypeError,
+                      "must specify at least 1 path when specified");
       return NULL;
     }
     for (i = 0; i < PyList_Size(paths); i++) {
@@ -454,45 +472,53 @@ PyObject *python_polygon(PyObject *self, PyObject *args, PyObject *kwargs)
         for (j = 0; j < PyList_Size(element); j++) {
           pointIndex = PyLong_AsLong(PyList_GetItem(element, j));
           if (pointIndex < 0 || pointIndex >= node->points.size()) {
-            PyErr_SetString(PyExc_TypeError, "Polyhedron Point Index out of range");
+            PyErr_SetString(PyExc_TypeError,
+                            "Polyhedron Point Index out of range");
             return NULL;
           }
           path.push_back(pointIndex);
         }
         node->paths.push_back(std::move(path));
       } else {
-        PyErr_SetString(PyExc_TypeError, "Polygon path must be a list of indices");
+        PyErr_SetString(PyExc_TypeError,
+                        "Polygon path must be a list of indices");
         return NULL;
       }
     }
   }
 
   node->convexity = convexity;
-  if (node->convexity < 1) node->convexity = 1;
+  if (node->convexity < 1)
+    node->convexity = 1;
 
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-int python_tomatrix(PyObject *pyt, Matrix4d& mat)
-{
-  if (pyt == nullptr)return 1;
+int python_tomatrix(PyObject *pyt, Matrix4d &mat) {
+  if (pyt == nullptr)
+    return 1;
   PyObject *row, *cell;
   double val;
-  if (!PyList_Check(pyt))return 1; // TODO crash wenn pyt eine funktion ist
-  if (PyList_Size(pyt) != 4)return 1;
+  if (!PyList_Check(pyt))
+    return 1; // TODO crash wenn pyt eine funktion ist
+  if (PyList_Size(pyt) != 4)
+    return 1;
   for (int i = 0; i < 4; i++) {
     row = PyList_GetItem(pyt, i);
-    if (!PyList_Check(row))return 1;
-    if (PyList_Size(row) != 4)return 1;
+    if (!PyList_Check(row))
+      return 1;
+    if (PyList_Size(row) != 4)
+      return 1;
     for (int j = 0; j < 4; j++) {
       cell = PyList_GetItem(row, j);
-      if (python_numberval(cell, &val))return 1;
+      if (python_numberval(cell, &val))
+        return 1;
       mat(i, j) = val;
     }
   }
   return 0;
 }
-PyObject *python_frommatrix(const Matrix4d& mat) {
+PyObject *python_frommatrix(const Matrix4d &mat) {
   PyObject *pyo = PyList_New(4);
   PyObject *row;
   for (int i = 0; i < 4; i++) {
@@ -504,27 +530,26 @@ PyObject *python_frommatrix(const Matrix4d& mat) {
   return pyo;
 }
 
-
-PyObject *python_matrix_scale(PyObject *mat, Vector3d scalevec)
-{
+PyObject *python_matrix_scale(PyObject *mat, Vector3d scalevec) {
   Transform3d matrix = Transform3d::Identity();
   matrix.scale(scalevec);
   Matrix4d raw;
-  if (python_tomatrix(mat, raw))return nullptr;
+  if (python_tomatrix(mat, raw))
+    return nullptr;
   Vector3d n;
   for (int i = 0; i < 3; i++) {
     n = Vector3d(raw(0, i), raw(1, i), raw(2, i)); // TODO fix
     n = matrix * n;
-    for (int j = 0; j < 3; j++)raw(j, i) = n[j];
+    for (int j = 0; j < 3; j++)
+      raw(j, i) = n[j];
   }
   return python_frommatrix(raw);
 }
 
-
-PyObject *python_scale_sub(PyObject *obj, Vector3d scalevec)
-{
+PyObject *python_scale_sub(PyObject *obj, Vector3d scalevec) {
   PyObject *mat = python_matrix_scale(obj, scalevec);
-  if (mat != nullptr)return mat;
+  if (mat != nullptr)
+    return mat;
 
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
@@ -543,78 +568,78 @@ PyObject *python_scale_sub(PyObject *obj, Vector3d scalevec)
     Py_ssize_t pos = 0;
     while (PyDict_Next(child_dict, &pos, &key, &value)) {
       PyObject *value1 = python_matrix_scale(value, scalevec);
-      if (value1 != nullptr) PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value1);
-      else PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value);
+      if (value1 != nullptr)
+        PyDict_SetItem(((PyOpenSCADObject *)pyresult)->dict, key, value1);
+      else
+        PyDict_SetItem(((PyOpenSCADObject *)pyresult)->dict, key, value);
     }
   }
   return pyresult;
-
 }
 
-PyObject *python_scale_core(PyObject *obj, PyObject *val_v)
-{
+PyObject *python_scale_core(PyObject *obj, PyObject *val_v) {
 
   double x = 1, y = 1, z = 1;
   if (python_vectorval(val_v, 2, 3, &x, &y, &z)) {
-    PyErr_SetString(PyExc_TypeError, "Invalid vector specifiaction in scale, use 1 to 3 ordinates.");
+    PyErr_SetString(
+        PyExc_TypeError,
+        "Invalid vector specifiaction in scale, use 1 to 3 ordinates.");
     return NULL;
   }
   Vector3d scalevec(x, y, z);
 
   if (OpenSCAD::rangeCheck) {
-    if (scalevec[0] == 0 || scalevec[1] == 0 || scalevec[2] == 0 || !std::isfinite(scalevec[0])|| !std::isfinite(scalevec[1])|| !std::isfinite(scalevec[2])) {
-//      LOG(message_group::Warning, instance->location(), parameters.documentRoot(), "scale(%1$s)", parameters["v"].toEchoStringNoThrow());
+    if (scalevec[0] == 0 || scalevec[1] == 0 || scalevec[2] == 0 ||
+        !std::isfinite(scalevec[0]) || !std::isfinite(scalevec[1]) ||
+        !std::isfinite(scalevec[2])) {
+      //      LOG(message_group::Warning, instance->location(),
+      //      parameters.documentRoot(), "scale(%1$s)",
+      //      parameters["v"].toEchoStringNoThrow());
     }
   }
 
   return python_scale_sub(obj, scalevec);
 }
 
-
-
-PyObject *python_scale(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_scale(PyObject *self, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"obj", "v", NULL};
   PyObject *obj = NULL;
   PyObject *val_v = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO", kwlist,
-                                   &obj,
-                                   &val_v)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing scale(object, scale)");
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO", kwlist, &obj, &val_v)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing scale(object, scale)");
     return NULL;
   }
   return python_scale_core(obj, val_v);
 }
 
-PyObject *python_oo_scale(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_scale(PyObject *obj, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"v", NULL};
   PyObject *val_v = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O", kwlist,
-                                   &val_v)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing scale(object, scale)");
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O", kwlist, &val_v)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing scale(object, scale)");
     return NULL;
   }
   return python_scale_core(obj, val_v);
 }
-PyObject *python_matrix_rot(PyObject *mat, Matrix3d rotvec)
-{
+PyObject *python_matrix_rot(PyObject *mat, Matrix3d rotvec) {
   Transform3d matrix = Transform3d::Identity();
   matrix.rotate(rotvec);
   Matrix4d raw;
-  if (python_tomatrix(mat, raw))return nullptr;
+  if (python_tomatrix(mat, raw))
+    return nullptr;
   Vector3d n;
   for (int i = 0; i < 4; i++) {
     n = Vector3d(raw(0, i), raw(1, i), raw(2, i));
     n = matrix * n;
-    for (int j = 0; j < 3; j++)raw(j, i) = n[j];
+    for (int j = 0; j < 3; j++)
+      raw(j, i) = n[j];
   }
   return python_frommatrix(raw);
 }
 
-
-PyObject *python_rotate_sub(PyObject *obj, Vector3d vec3, double angle)
-{
+PyObject *python_rotate_sub(PyObject *obj, Vector3d vec3, double angle) {
   Matrix3d M;
   if (isnan(angle)) {
     double sx = 0, sy = 0, sz = 0;
@@ -636,20 +661,21 @@ PyObject *python_rotate_sub(PyObject *obj, Vector3d vec3, double angle)
       cx = cos_degrees(a);
     }
 
-    M << cy * cz,  cz * sx * sy - cx * sz,   cx * cz * sy + sx * sz,
-      cy *sz,  cx *cz + sx * sy * sz,  -cz * sx + cx * sy * sz,
-      -sy,       cy *sx,                  cx *cy;
+    M << cy * cz, cz * sx * sy - cx * sz, cx * cz * sy + sx * sz, cy * sz,
+        cx * cz + sx * sy * sz, -cz * sx + cx * sy * sz, -sy, cy * sx, cx * cy;
   } else {
     M = angle_axis_degrees(angle, vec3);
   }
   PyObject *mat = python_matrix_rot(obj, M);
-  if (mat != nullptr)return mat;
+  if (mat != nullptr)
+    return mat;
 
   DECLARE_INSTANCE
   auto node = std::make_shared<TransformNode>(instance, "rotate");
 
   PyObject *child_dict;
-  std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNodeMulti(obj, &child_dict);
+  std::shared_ptr<AbstractNode> child =
+      PyOpenSCADObjectToNodeMulti(obj, &child_dict);
   if (child == NULL) {
     PyErr_SetString(PyExc_TypeError, "Invalid type for Object in rotate");
     return NULL;
@@ -663,23 +689,29 @@ PyObject *python_rotate_sub(PyObject *obj, Vector3d vec3, double angle)
     Py_ssize_t pos = 0;
     while (PyDict_Next(child_dict, &pos, &key, &value)) {
       PyObject *value1 = python_matrix_rot(value, M);
-      if (value1 != nullptr) PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value1);
-      else PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value);
+      if (value1 != nullptr)
+        PyDict_SetItem(((PyOpenSCADObject *)pyresult)->dict, key, value1);
+      else
+        PyDict_SetItem(((PyOpenSCADObject *)pyresult)->dict, key, value);
     }
   }
   return pyresult;
 }
 
-PyObject *python_rotate_core(PyObject *obj, PyObject *val_a, PyObject *val_v)
-{
+PyObject *python_rotate_core(PyObject *obj, PyObject *val_a, PyObject *val_v) {
   Vector3d vec3(0, 0, 0);
   double angle;
   if (val_a != nullptr && PyList_Check(val_a) && val_v == nullptr) {
-    if (PyList_Size(val_a) >= 1)vec3[0] = PyFloat_AsDouble(PyList_GetItem(val_a, 0));
-    if (PyList_Size(val_a) >= 2)vec3[1] = PyFloat_AsDouble(PyList_GetItem(val_a, 1));
-    if (PyList_Size(val_a) >= 3)vec3[2] = PyFloat_AsDouble(PyList_GetItem(val_a, 2));
+    if (PyList_Size(val_a) >= 1)
+      vec3[0] = PyFloat_AsDouble(PyList_GetItem(val_a, 0));
+    if (PyList_Size(val_a) >= 2)
+      vec3[1] = PyFloat_AsDouble(PyList_GetItem(val_a, 1));
+    if (PyList_Size(val_a) >= 3)
+      vec3[2] = PyFloat_AsDouble(PyList_GetItem(val_a, 2));
     return python_rotate_sub(obj, vec3, NAN);
-  } else if (val_a != nullptr && val_v != nullptr && !python_numberval(val_a, &angle) && PyList_Check(val_v) && PyList_Size(val_v) == 3) {
+  } else if (val_a != nullptr && val_v != nullptr &&
+             !python_numberval(val_a, &angle) && PyList_Check(val_v) &&
+             PyList_Size(val_v) == 3) {
     vec3[0] = PyFloat_AsDouble(PyList_GetItem(val_v, 0));
     vec3[1] = PyFloat_AsDouble(PyList_GetItem(val_v, 1));
     vec3[2] = PyFloat_AsDouble(PyList_GetItem(val_v, 2));
@@ -689,56 +721,58 @@ PyObject *python_rotate_core(PyObject *obj, PyObject *val_a, PyObject *val_v)
   return nullptr;
 }
 
-PyObject *python_rotate(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_rotate(PyObject *self, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"obj", "a", "v", nullptr};
   PyObject *val_a = nullptr;
   PyObject *val_v = nullptr;
   PyObject *obj = nullptr;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO|O", kwlist, &obj, &val_a, &val_v)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing rotate(object, vec3)");
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO|O", kwlist, &obj, &val_a,
+                                   &val_v)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing rotate(object, vec3)");
     return NULL;
   }
   return python_rotate_core(obj, val_a, val_v);
 }
 
-PyObject *python_oo_rotate(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_rotate(PyObject *obj, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"a", "v", nullptr};
   PyObject *val_a = nullptr;
   PyObject *val_v = nullptr;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O", kwlist, &val_a, &val_v)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing rotate(object, vec3)");
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O", kwlist, &val_a,
+                                   &val_v)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing rotate(object, vec3)");
     return NULL;
   }
   return python_rotate_core(obj, val_a, val_v);
 }
 
-
-PyObject *python_matrix_mirror(PyObject *mat, Matrix4d m)
-{
+PyObject *python_matrix_mirror(PyObject *mat, Matrix4d m) {
   Matrix4d raw;
-  if (python_tomatrix(mat, raw))return nullptr;
+  if (python_tomatrix(mat, raw))
+    return nullptr;
   Vector4d n;
   for (int i = 0; i < 3; i++) {
     n = Vector4d(raw(0, i), raw(1, i), raw(2, i), 0);
     n = m * n;
-    for (int j = 0; j < 3; j++)raw(j, i) = n[j];
+    for (int j = 0; j < 3; j++)
+      raw(j, i) = n[j];
   }
   return python_frommatrix(raw);
 }
 
-
-PyObject *python_mirror_sub(PyObject *obj, Matrix4d& m)
-{
+PyObject *python_mirror_sub(PyObject *obj, Matrix4d &m) {
   PyObject *mat = python_matrix_mirror(obj, m);
-  if (mat != nullptr)return mat;
+  if (mat != nullptr)
+    return mat;
 
   DECLARE_INSTANCE
   auto node = std::make_shared<TransformNode>(instance, "mirror");
   node->matrix = m;
   PyObject *child_dict;
-  std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNodeMulti(obj, &child_dict);
+  std::shared_ptr<AbstractNode> child =
+      PyOpenSCADObjectToNodeMulti(obj, &child_dict);
   if (child == NULL) {
     PyErr_SetString(PyExc_TypeError, "Invalid type for Object in mirror");
     return NULL;
@@ -750,15 +784,16 @@ PyObject *python_mirror_sub(PyObject *obj, Matrix4d& m)
     Py_ssize_t pos = 0;
     while (PyDict_Next(child_dict, &pos, &key, &value)) {
       PyObject *value1 = python_matrix_mirror(value, m);
-      if (value1 != nullptr) PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value1);
-      else PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value);
+      if (value1 != nullptr)
+        PyDict_SetItem(((PyOpenSCADObject *)pyresult)->dict, key, value1);
+      else
+        PyDict_SetItem(((PyOpenSCADObject *)pyresult)->dict, key, value);
     }
   }
   return pyresult;
 }
 
-PyObject *python_mirror_core(PyObject *obj, PyObject *val_v)
-{
+PyObject *python_mirror_core(PyObject *obj, PyObject *val_v) {
   Vector3d mirrorvec;
   double x = 1.0, y = 0.0, z = 0.0;
   if (python_vectorval(val_v, 2, 3, &x, &y, &z)) {
@@ -770,102 +805,100 @@ PyObject *python_mirror_core(PyObject *obj, PyObject *val_v)
   // z /= sqrt(x*x + y*y + z*z)
   Matrix4d m = Matrix4d::Identity();
   if (x != 0.0 || y != 0.0 || z != 0.0) {
-    // skip using sqrt to normalize the vector since each element of matrix contributes it with two multiplied terms
-    // instead just divide directly within each matrix element
-    // simplified calculation leads to less float errors
+    // skip using sqrt to normalize the vector since each element of matrix
+    // contributes it with two multiplied terms instead just divide directly
+    // within each matrix element simplified calculation leads to less float
+    // errors
     double a = x * x + y * y + z * z;
 
-    m << 1 - 2 * x * x / a, -2 * y * x / a, -2 * z * x / a, 0,
-      -2 * x * y / a, 1 - 2 * y * y / a, -2 * z * y / a, 0,
-      -2 * x * z / a, -2 * y * z / a, 1 - 2 * z * z / a, 0,
-      0, 0, 0, 1;
+    m << 1 - 2 * x * x / a, -2 * y * x / a, -2 * z * x / a, 0, -2 * x * y / a,
+        1 - 2 * y * y / a, -2 * z * y / a, 0, -2 * x * z / a, -2 * y * z / a,
+        1 - 2 * z * z / a, 0, 0, 0, 0, 1;
   }
   return python_mirror_sub(obj, m);
 }
 
-PyObject *python_mirror(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_mirror(PyObject *self, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"obj", "v", NULL};
 
   PyObject *obj = NULL;
   PyObject *val_v = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO", kwlist,
-                                   &obj,
-                                   &val_v)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing mirror(object, vec3)");
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO", kwlist, &obj, &val_v)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing mirror(object, vec3)");
     return NULL;
   }
   return python_mirror_core(obj, val_v);
 }
 
-PyObject *python_oo_mirror(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_mirror(PyObject *obj, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"v", NULL};
 
   PyObject *val_v = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O", kwlist,
-                                   &val_v)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing mirror(object, vec3)");
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O", kwlist, &val_v)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing mirror(object, vec3)");
     return NULL;
   }
   return python_mirror_core(obj, val_v);
 }
 
-PyObject *python_matrix_trans(PyObject *mat, Vector3d transvec)
-{
+PyObject *python_matrix_trans(PyObject *mat, Vector3d transvec) {
   Matrix4d raw;
-  if (python_tomatrix(mat, raw))return nullptr;
-  for (int i = 0; i < 3; i++)raw(i, 3) += transvec[i];
+  if (python_tomatrix(mat, raw))
+    return nullptr;
+  for (int i = 0; i < 3; i++)
+    raw(i, 3) += transvec[i];
   return python_frommatrix(raw);
 }
 
 PyObject *python_nb_sub_vec3(PyObject *arg1, PyObject *arg2, int mode);
-PyObject *python_translate_core(PyObject *obj, PyObject *v)
-{
-  if (v == nullptr)return obj;
+PyObject *python_translate_core(PyObject *obj, PyObject *v) {
+  if (v == nullptr)
+    return obj;
   return python_nb_sub_vec3(obj, v, 0);
 }
 
-PyObject *python_translate(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_translate(PyObject *self, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"obj", "v", NULL};
   PyObject *obj = NULL;
   PyObject *v = NULL;
   if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O", kwlist, &obj, &v)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing translate(object,vec3)");
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing translate(object,vec3)");
     return NULL;
   }
   return python_translate_core(obj, v);
 }
 
-PyObject *python_oo_translate(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_translate(PyObject *obj, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"v", NULL};
   PyObject *v = NULL;
   if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O", kwlist, &v)) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing translate(object,vec3)");
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing translate(object,vec3)");
     return NULL;
   }
   return python_translate_core(obj, v);
 }
 
-PyObject *python_multmatrix_sub(PyObject *pyobj, PyObject *pymat, int div)
-{
+PyObject *python_multmatrix_sub(PyObject *pyobj, PyObject *pymat, int div) {
   Matrix4d mat;
   if (!python_tomatrix(pymat, mat)) {
     double w = mat(3, 3);
-    if (w != 1.0) mat = mat / w;
+    if (w != 1.0)
+      mat = mat / w;
   } else {
     PyErr_SetString(PyExc_TypeError, "Matrix vector should be 4x4 array");
     return NULL;
   }
-  if (div){
+  if (div) {
     auto tmp = mat.inverse().eval();
     mat = tmp;
   }
 
   Matrix4d objmat;
-  if (!python_tomatrix(pyobj, objmat)){
+  if (!python_tomatrix(pyobj, objmat)) {
     objmat = mat * objmat;
     return python_frommatrix(objmat);
   }
@@ -880,7 +913,6 @@ PyObject *python_multmatrix_sub(PyObject *pyobj, PyObject *pymat, int div)
     return NULL;
   }
 
-
   node->matrix = mat;
   node->children.push_back(child);
   PyObject *pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
@@ -889,76 +921,73 @@ PyObject *python_multmatrix_sub(PyObject *pyobj, PyObject *pymat, int div)
     Py_ssize_t pos = 0;
     while (PyDict_Next(child_dict, &pos, &key, &value)) {
       Matrix4d raw;
-      if (python_tomatrix(value, raw))return nullptr;
+      if (python_tomatrix(value, raw))
+        return nullptr;
       PyObject *value1 = python_frommatrix(node->matrix * raw);
-      if (value1 != nullptr)PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value1);
-      else PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value);
+      if (value1 != nullptr)
+        PyDict_SetItem(((PyOpenSCADObject *)pyresult)->dict, key, value1);
+      else
+        PyDict_SetItem(((PyOpenSCADObject *)pyresult)->dict, key, value);
     }
   }
   return pyresult;
-
 }
 
-PyObject *python_multmatrix(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_multmatrix(PyObject *self, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"obj", "m", NULL};
   PyObject *obj = NULL;
   PyObject *mat = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO!", kwlist,
-                                   &obj,
-                                   &PyList_Type, &mat
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing multmatrix(object, vec16)");
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO!", kwlist, &obj,
+                                   &PyList_Type, &mat)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing multmatrix(object, vec16)");
     return NULL;
   }
   return python_multmatrix_sub(obj, mat, 0);
 }
 
-PyObject *python_oo_multmatrix(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_multmatrix(PyObject *obj, PyObject *args,
+                               PyObject *kwargs) {
   char *kwlist[] = {"m", NULL};
   PyObject *mat = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!", kwlist,
-                                   &PyList_Type, &mat
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing multmatrix(object, vec16)");
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!", kwlist, &PyList_Type,
+                                   &mat)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing multmatrix(object, vec16)");
     return NULL;
   }
   return python_multmatrix_sub(obj, mat, 0);
 }
 
-PyObject *python_divmatrix(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_divmatrix(PyObject *self, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"obj", "m", NULL};
   PyObject *obj = NULL;
   PyObject *mat = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO!", kwlist,
-                                   &obj,
-                                   &PyList_Type, &mat
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing divmatrix(object, vec16)");
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO!", kwlist, &obj,
+                                   &PyList_Type, &mat)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing divmatrix(object, vec16)");
     return NULL;
   }
   return python_multmatrix_sub(obj, mat, 1);
 }
 
-PyObject *python_oo_divmatrix(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_divmatrix(PyObject *obj, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"m", NULL};
   PyObject *mat = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!", kwlist,
-                                   &PyList_Type, &mat
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing divmatrix(object, vec16)");
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!", kwlist, &PyList_Type,
+                                   &mat)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing divmatrix(object, vec16)");
     return NULL;
   }
   return python_multmatrix_sub(obj, mat, 1);
 }
 
-PyObject *python_show_core(PyObject *obj)
-{
+PyObject *python_show_core(PyObject *obj) {
   PyObject *child_dict;
-  std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNodeMulti(obj, &child_dict);
+  std::shared_ptr<AbstractNode> child =
+      PyOpenSCADObjectToNodeMulti(obj, &child_dict);
   if (child == NULL) {
     PyErr_SetString(PyExc_TypeError, "Invalid type for Object in show");
     return NULL;
@@ -967,50 +996,45 @@ PyObject *python_show_core(PyObject *obj)
   return Py_None;
 }
 
-PyObject *python_show(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_show(PyObject *self, PyObject *args, PyObject *kwargs) {
   PyObject *obj = NULL;
   char *kwlist[] = {"obj", NULL};
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O", kwlist,
-                                   &obj
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O", kwlist, &obj)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing output(object)");
     return NULL;
   }
   return python_show_core(obj);
 }
 
-PyObject *python_oo_show(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_show(PyObject *obj, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {NULL};
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "", kwlist
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "", kwlist)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing output(object)");
     return NULL;
   }
   return python_show_core(obj);
 }
 
-PyObject *python__getitem__(PyObject *obj, PyObject *key)
-{
-  PyOpenSCADObject *self = (PyOpenSCADObject *) obj;
+PyObject *python__getitem__(PyObject *obj, PyObject *key) {
+  PyOpenSCADObject *self = (PyOpenSCADObject *)obj;
   if (self->dict == nullptr) {
     return nullptr;
   }
   PyObject *result = PyDict_GetItem(self->dict, key);
-  if (result == NULL){
+  if (result == NULL) {
     PyObject *dummy_dict;
-    std::shared_ptr<AbstractNode> node = PyOpenSCADObjectToNodeMulti(obj, &dummy_dict);
+    std::shared_ptr<AbstractNode> node =
+        PyOpenSCADObjectToNodeMulti(obj, &dummy_dict);
     PyObject *keyname = PyUnicode_AsEncodedString(key, "utf-8", "~");
     std::string keystr = PyBytes_AS_STRING(keyname);
     result = Py_None;
-  } else Py_INCREF(result);
+  } else
+    Py_INCREF(result);
   return result;
 }
 
-int python__setitem__(PyObject *dict, PyObject *key, PyObject *v)
-{
-  PyOpenSCADObject *self = (PyOpenSCADObject *) dict;
+int python__setitem__(PyObject *dict, PyObject *key, PyObject *v) {
+  PyOpenSCADObject *self = (PyOpenSCADObject *)dict;
   if (self->dict == NULL) {
     return 0;
   }
@@ -1019,9 +1043,7 @@ int python__setitem__(PyObject *dict, PyObject *key, PyObject *v)
   return 0;
 }
 
-
-PyObject *python_color_core(PyObject *obj, PyObject *color, double alpha)
-{
+PyObject *python_color_core(PyObject *obj, PyObject *color, double alpha) {
   PyObject *child_dict;
   std::shared_ptr<AbstractNode> child;
   child = PyOpenSCADObjectToNodeMulti(obj, &child_dict);
@@ -1034,7 +1056,8 @@ PyObject *python_color_core(PyObject *obj, PyObject *color, double alpha)
 
   Vector4d col(0, 0, 0, alpha);
   if (!python_vectorval(color, 3, 4, &col[0], &col[1], &col[2], &col[3])) {
-    node->color.setRgba(float(col[0]), float(col[1]), float(col[2]), float(col[3]));
+    node->color.setRgba(float(col[0]), float(col[1]), float(col[2]),
+                        float(col[3]));
   } else if (PyUnicode_Check(color)) {
     PyObject *value = PyUnicode_AsEncodedString(color, "utf-8", "~");
     char *colorname = PyBytes_AS_STRING(value);
@@ -1058,58 +1081,52 @@ PyObject *python_color_core(PyObject *obj, PyObject *color, double alpha)
     PyObject *key, *value;
     Py_ssize_t pos = 0;
     while (PyDict_Next(child_dict, &pos, &key, &value)) {
-      PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value);
+      PyDict_SetItem(((PyOpenSCADObject *)pyresult)->dict, key, value);
     }
   }
   return pyresult;
-
 }
 
-PyObject *python_color(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_color(PyObject *self, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"obj", "c", "alpha", NULL};
   PyObject *obj = NULL;
   PyObject *color = NULL;
   double alpha = 1.0;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|Od", kwlist,
-                                   &obj,
-                                   &color, &alpha
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|Od", kwlist, &obj, &color,
+                                   &alpha)) {
     PyErr_SetString(PyExc_TypeError, "error during parsing color");
     return NULL;
   }
   return python_color_core(obj, color, alpha);
 }
 
-PyObject *python_oo_color(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_color(PyObject *obj, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"c", "alpha", NULL};
   PyObject *color = NULL;
   double alpha = 1.0;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|Od", kwlist,
-                                   &color, &alpha
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|Od", kwlist, &color,
+                                   &alpha)) {
     PyErr_SetString(PyExc_TypeError, "error during parsing color");
     return NULL;
   }
   return python_color_core(obj, color, alpha);
 }
 
-PyObject *python_mesh_core(PyObject *obj, bool tessellate)
-{
+PyObject *python_mesh_core(PyObject *obj, bool tessellate) {
   PyObject *dummydict;
-  std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNodeMulti(obj, &dummydict);
+  std::shared_ptr<AbstractNode> child =
+      PyOpenSCADObjectToNodeMulti(obj, &dummydict);
   if (child == NULL) {
     PyErr_SetString(PyExc_TypeError, "Invalid type for  Object in mesh \n");
     return NULL;
   }
   Tree tree(child, "");
   GeometryEvaluator geomevaluator(tree);
-  std::shared_ptr<const Geometry> geom = geomevaluator.evaluateGeometry(*tree.root(), true);
+  std::shared_ptr<const Geometry> geom =
+      geomevaluator.evaluateGeometry(*tree.root(), true);
   std::shared_ptr<const PolySet> ps = PolySetUtils::getGeometryAsPolySet(geom);
 
-
-  if (ps != nullptr){
+  if (ps != nullptr) {
     if (tessellate == true) {
       ps = PolySetUtils::tessellate_faces(*ps);
     }
@@ -1144,7 +1161,7 @@ PyObject *python_mesh_core(PyObject *obj, bool tessellate)
     const std::vector<Outline2d> outlines = polygon2d->outlines();
     PyObject *pyth_outlines = PyList_New(outlines.size());
     for (unsigned int i = 0; i < outlines.size(); i++) {
-      const Outline2d& outline = outlines[i];
+      const Outline2d &outline = outlines[i];
       PyObject *pyth_outline = PyList_New(outline.vertices.size());
       for (unsigned int j = 0; j < outline.vertices.size(); j++) {
         Vector2d pt = outline.vertices[j];
@@ -1160,8 +1177,7 @@ PyObject *python_mesh_core(PyObject *obj, bool tessellate)
   return Py_None;
 }
 
-PyObject *python_mesh(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_mesh(PyObject *self, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"obj", "triangulate", NULL};
   PyObject *obj = NULL;
   PyObject *tess = NULL;
@@ -1172,9 +1188,8 @@ PyObject *python_mesh(PyObject *self, PyObject *args, PyObject *kwargs)
   return python_mesh_core(obj, tess == Py_True);
 }
 
-PyObject *python_oo_mesh(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = { "triangulate", NULL};
+PyObject *python_oo_mesh(PyObject *obj, PyObject *args, PyObject *kwargs) {
+  char *kwlist[] = {"triangulate", NULL};
   PyObject *tess = NULL;
   if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O", kwlist, &tess)) {
     PyErr_SetString(PyExc_TypeError, "error during parsing\n");
@@ -1183,41 +1198,50 @@ PyObject *python_oo_mesh(PyObject *obj, PyObject *args, PyObject *kwargs)
   return python_mesh_core(obj, tess == Py_True);
 }
 
-PyObject *rotate_extrude_core(PyObject *obj,  int convexity, double scale, double angle, PyObject *twist, PyObject *origin, PyObject *offset, PyObject *vp, char *method, double fn, double fa, double fs)
-{
+PyObject *rotate_extrude_core(PyObject *obj, int convexity, double scale,
+                              double angle, PyObject *twist, PyObject *origin,
+                              PyObject *offset, PyObject *vp, char *method,
+                              double fn, double fa, double fs) {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
   auto node = std::make_shared<RotateExtrudeNode>(instance);
-  if (1){
+  if (1) {
     PyObject *dummydict;
     child = PyOpenSCADObjectToNodeMulti(obj, &dummydict);
     if (child == NULL) {
-      PyErr_SetString(PyExc_TypeError, "Invalid type for  Object in rotate_extrude\n");
+      PyErr_SetString(PyExc_TypeError,
+                      "Invalid type for  Object in rotate_extrude\n");
       return NULL;
     }
     node->children.push_back(child);
   }
 
   get_fnas(node->fn, node->fa, node->fs);
-  if (!isnan(fn)) node->fn = fn;
-  if (!isnan(fa)) node->fa = fa;
-  if (!isnan(fs)) node->fs = fs;
+  if (!isnan(fn))
+    node->fn = fn;
+  if (!isnan(fa))
+    node->fa = fa;
+  if (!isnan(fs))
+    node->fs = fs;
 
   node->convexity = convexity;
 
   double dummy;
   Vector3d v(0, 0, 0);
-  if (vp != nullptr && !python_vectorval(vp, 3, 3, &v[0], &v[1], &v[2], &dummy)){
+  if (vp != nullptr &&
+      !python_vectorval(vp, 3, 3, &v[0], &v[1], &v[2], &dummy)) {
   }
 
-  if (node->convexity <= 0) node->convexity = 2;
-  if (node->angle <= -360)  node->angle = 360;
+  if (node->convexity <= 0)
+    node->convexity = 2;
+  if (node->angle <= -360)
+    node->angle = 360;
 
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_rotate_extrude(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_rotate_extrude(PyObject *self, PyObject *args,
+                                PyObject *kwargs) {
   PyObject *obj = NULL;
   int convexity = 1;
   double scale = 1.0;
@@ -1229,18 +1253,23 @@ PyObject *python_rotate_extrude(PyObject *self, PyObject *args, PyObject *kwargs
   PyObject *offset = NULL;
   double fn = NAN, fa = NAN, fs = NAN;
   get_fnas(fn, fa, fs);
-  char *kwlist[] = {"obj", "convexity", "scale", "angle", "twist", "origin", "offset", "v", "method", "fn", "fa", "fs", NULL};
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|iddOOOOsddd", kwlist,
-                                   &obj, &convexity, &scale, &angle, &twist, &origin, &offset, &v, &method, &fn, &fa, &fs)){
+  char *kwlist[] = {"obj",    "convexity", "scale", "angle",  "twist",
+                    "origin", "offset",    "v",     "method", "fn",
+                    "fa",     "fs",        NULL};
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|iddOOOOsddd", kwlist, &obj,
+                                   &convexity, &scale, &angle, &twist, &origin,
+                                   &offset, &v, &method, &fn, &fa, &fs)) {
 
-    PyErr_SetString(PyExc_TypeError, "Error during parsing rotate_extrude(object,...)");
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing rotate_extrude(object,...)");
     return NULL;
   }
-  return rotate_extrude_core(obj, convexity, scale, angle, twist, origin, offset, v, method, fn, fa, fs);
+  return rotate_extrude_core(obj, convexity, scale, angle, twist, origin,
+                             offset, v, method, fn, fa, fs);
 }
 
-PyObject *python_oo_rotate_extrude(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_rotate_extrude(PyObject *obj, PyObject *args,
+                                   PyObject *kwargs) {
   int convexity = 1;
   double scale = 1.0;
   double angle = 360.0;
@@ -1251,76 +1280,90 @@ PyObject *python_oo_rotate_extrude(PyObject *obj, PyObject *args, PyObject *kwar
   get_fnas(fn, fa, fs);
   PyObject *v = NULL;
   char *method = NULL;
-  char *kwlist[] = {"convexity", "scale", "angle", "twist", "origin", "offset", "v", "method", "fn", "fa", "fs", NULL};
+  char *kwlist[] = {"convexity", "scale",  "angle", "twist", "origin", "offset",
+                    "v",         "method", "fn",    "fa",    "fs",     NULL};
   if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|iddOOOOsddd", kwlist,
-                                   &convexity, &scale, &angle, &twist, &origin, &offset, &v, &method, &fn, &fa, &fs)){
+                                   &convexity, &scale, &angle, &twist, &origin,
+                                   &offset, &v, &method, &fn, &fa, &fs)) {
 
     PyErr_SetString(PyExc_TypeError, "error during parsing\n");
     return NULL;
   }
-  return rotate_extrude_core(obj, convexity, scale, angle, twist, origin, offset, v, method, fn, fa, fs);
+  return rotate_extrude_core(obj, convexity, scale, angle, twist, origin,
+                             offset, v, method, fn, fa, fs);
 }
 
-PyObject *linear_extrude_core(PyObject *obj, PyObject *height, int convexity, PyObject *origin, PyObject *scale, PyObject *center, int slices, int segments, PyObject *twist, double fn, double fa, double fs)
-{
+PyObject *linear_extrude_core(PyObject *obj, PyObject *height, int convexity,
+                              PyObject *origin, PyObject *scale,
+                              PyObject *center, int slices, int segments,
+                              PyObject *twist, double fn, double fa,
+                              double fs) {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
   auto node = std::make_shared<LinearExtrudeNode>(instance);
 
   get_fnas(node->fn, node->fa, node->fs);
-  if (1){
+  if (1) {
     PyObject *dummydict;
     child = PyOpenSCADObjectToNodeMulti(obj, &dummydict);
     if (child == NULL) {
-      PyErr_SetString(PyExc_TypeError, "Invalid type for  Object in linear_extrude\n");
+      PyErr_SetString(PyExc_TypeError,
+                      "Invalid type for  Object in linear_extrude\n");
       return NULL;
     }
     node->children.push_back(child);
   }
 
-
-  if (!isnan(fn)) node->fn = fn;
-  if (!isnan(fa)) node->fa = fa;
-  if (!isnan(fs)) node->fs = fs;
+  if (!isnan(fn))
+    node->fn = fn;
+  if (!isnan(fa))
+    node->fa = fa;
+  if (!isnan(fs))
+    node->fs = fs;
 
   Vector3d height_vec(0, 0, 0);
   double dummy;
   if (!python_numberval(height, &height_vec[2])) {
     node->height = height_vec;
-  } else if (!python_vectorval(height, 3, 3, &height_vec[0], &height_vec[1], &height_vec[2], &dummy)) {
+  } else if (!python_vectorval(height, 3, 3, &height_vec[0], &height_vec[1],
+                               &height_vec[2], &dummy)) {
     node->height = height_vec;
   }
 
   node->convexity = convexity;
 
-  node->scale_x = 1.0; node->scale_y = 1.0;
+  node->scale_x = 1.0;
+  node->scale_y = 1.0;
   if (scale != NULL && PyList_Check(scale) && PyList_Size(scale) == 2) {
     node->scale_x = PyFloat_AsDouble(PyList_GetItem(scale, 0));
     node->scale_y = PyFloat_AsDouble(PyList_GetItem(scale, 1));
   }
 
-  if (center == Py_True) node->center = 1;
-  else if (center == Py_False || center == NULL)   node->center = 0;
+  if (center == Py_True)
+    node->center = 1;
+  else if (center == Py_False || center == NULL)
+    node->center = 0;
   else {
     PyErr_SetString(PyExc_TypeError, "Unknown Value for center parameter");
     return NULL;
   }
 
   node->slices = slices;
-  node->has_slices = slices != 1?1:0;
+  node->has_slices = slices != 1 ? 1 : 0;
 
   node->segments = segments;
-  node->has_segments = segments != 1?1:0;
+  node->has_segments = segments != 1 ? 1 : 0;
 
   if (twist != NULL) {
     node->twist = PyFloat_AsDouble(twist);
     node->has_twist = 1;
-  } else node->has_twist = 0;
+  } else
+    node->has_twist = 0;
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_linear_extrude(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_linear_extrude(PyObject *self, PyObject *args,
+                                PyObject *kwargs) {
   PyObject *obj = NULL;
   PyObject *height = NULL;
   int convexity = 1;
@@ -1332,18 +1375,23 @@ PyObject *python_linear_extrude(PyObject *self, PyObject *args, PyObject *kwargs
   PyObject *twist = NULL;
   double fn = NAN, fa = NAN, fs = NAN;
 
-  char *kwlist[] = {"obj", "height", "convexity", "origin", "scale", "center", "slices", "segments", "twist", "fn", "fa", "fs", NULL};
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|OiOOOiiOddd", kwlist,
-                                   &obj, &height, &convexity, &origin, &scale, &center, &slices, &segments, &twist, &fn, &fs, &fs)){
+  char *kwlist[] = {"obj",    "height", "convexity", "origin", "scale",
+                    "center", "slices", "segments",  "twist",  "fn",
+                    "fa",     "fs",     NULL};
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|OiOOOiiOddd", kwlist, &obj,
+                                   &height, &convexity, &origin, &scale,
+                                   &center, &slices, &segments, &twist, &fn,
+                                   &fs, &fs)) {
     PyErr_SetString(PyExc_TypeError, "error during parsing\n");
     return NULL;
   }
 
-  return linear_extrude_core(obj, height, convexity, origin, scale, center, slices, segments, twist, fn, fa, fs);
+  return linear_extrude_core(obj, height, convexity, origin, scale, center,
+                             slices, segments, twist, fn, fa, fs);
 }
 
-PyObject *python_oo_linear_extrude(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_linear_extrude(PyObject *obj, PyObject *args,
+                                   PyObject *kwargs) {
   PyObject *height = NULL;
   int convexity = 1;
   PyObject *origin = NULL;
@@ -1354,17 +1402,21 @@ PyObject *python_oo_linear_extrude(PyObject *obj, PyObject *args, PyObject *kwar
   PyObject *twist = NULL;
   double fn = NAN, fa = NAN, fs = NAN;
 
-  char *kwlist[] = {"height", "convexity", "origin", "scale", "center", "slices", "segments", "twist", "fn", "fa", "fs", NULL};
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OiOOOiiOddd", kwlist,
-                                   &height, &convexity, &origin, &scale, &center, &slices, &segments, &twist, &fn, &fs, &fs)){
+  char *kwlist[] = {"height", "convexity", "origin",   "scale",
+                    "center", "slices",    "segments", "twist",
+                    "fn",     "fa",        "fs",       NULL};
+  if (!PyArg_ParseTupleAndKeywords(
+          args, kwargs, "|OiOOOiiOddd", kwlist, &height, &convexity, &origin,
+          &scale, &center, &slices, &segments, &twist, &fn, &fs, &fs)) {
     PyErr_SetString(PyExc_TypeError, "error during parsing\n");
     return NULL;
   }
 
-  return linear_extrude_core(obj, height, convexity, origin, scale, center, slices, segments, twist, fn, fa, fs);
+  return linear_extrude_core(obj, height, convexity, origin, scale, center,
+                             slices, segments, twist, fn, fa, fs);
 }
-PyObject *python_csg_sub(PyObject *self, PyObject *args, PyObject *kwargs, OpenSCADOperator mode)
-{
+PyObject *python_csg_sub(PyObject *self, PyObject *args, PyObject *kwargs,
+                         OpenSCADOperator mode) {
   DECLARE_INSTANCE
   int i;
 
@@ -1384,15 +1436,19 @@ PyObject *python_csg_sub(PyObject *self, PyObject *args, PyObject *kwargs, OpenS
     } else {
       switch (mode) {
       case OpenSCADOperator::UNION:
-        PyErr_SetString(PyExc_TypeError, "Error during parsing union. arguments must be solids or arrays.");
+        PyErr_SetString(
+            PyExc_TypeError,
+            "Error during parsing union. arguments must be solids or arrays.");
         return nullptr;
         break;
       case OpenSCADOperator::DIFFERENCE:
-        PyErr_SetString(PyExc_TypeError, "Error during parsing difference. arguments must be solids or arrays.");
+        PyErr_SetString(PyExc_TypeError, "Error during parsing difference. "
+                                         "arguments must be solids or arrays.");
         return nullptr;
         break;
       case OpenSCADOperator::INTERSECTION:
-        PyErr_SetString(PyExc_TypeError, "Error during parsing intersection. arguments must be solids or arrays.");
+        PyErr_SetString(PyExc_TypeError, "Error during parsing intersection. "
+                                         "arguments must be solids or arrays.");
         return nullptr;
         break;
       case OpenSCADOperator::MINKOWSKI:
@@ -1409,67 +1465,71 @@ PyObject *python_csg_sub(PyObject *self, PyObject *args, PyObject *kwargs, OpenS
   }
 
   PyObject *pyresult = PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
-  for (int i = child_dict.size() - 1; i >= 0; i--){ // merge from back  to give 1st child most priority
-    auto& dict = child_dict[i];
+  for (int i = child_dict.size() - 1; i >= 0;
+       i--) { // merge from back  to give 1st child most priority
+    auto &dict = child_dict[i];
     PyObject *key, *value;
     Py_ssize_t pos = 0;
     while (PyDict_Next(dict, &pos, &key, &value)) {
       PyObject *value1 = PyUnicode_AsEncodedString(key, "utf-8", "~");
       const char *value_str = PyBytes_AS_STRING(value1);
-      PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value);
+      PyDict_SetItem(((PyOpenSCADObject *)pyresult)->dict, key, value);
     }
   }
   return pyresult;
 }
 
-PyObject *python_union(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_union(PyObject *self, PyObject *args, PyObject *kwargs) {
   return python_csg_sub(self, args, kwargs, OpenSCADOperator::UNION);
 }
 
-PyObject *python_difference(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_difference(PyObject *self, PyObject *args, PyObject *kwargs) {
   return python_csg_sub(self, args, kwargs, OpenSCADOperator::DIFFERENCE);
 }
 
-PyObject *python_intersection(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_intersection(PyObject *self, PyObject *args,
+                              PyObject *kwargs) {
   return python_csg_sub(self, args, kwargs, OpenSCADOperator::INTERSECTION);
 }
 
-
-PyObject *python_oo_csg_sub(PyObject *self, PyObject *args, PyObject *kwargs, OpenSCADOperator mode)
-{
+PyObject *python_oo_csg_sub(PyObject *self, PyObject *args, PyObject *kwargs,
+                            OpenSCADOperator mode) {
   DECLARE_INSTANCE
   int i;
 
   auto node = std::make_shared<CsgOpNode>(instance, mode);
 
-
   PyObject *obj;
   PyObject *child_dict;
   PyObject *dummy_dict;
   std::shared_ptr<AbstractNode> child;
 
   child = PyOpenSCADObjectToNodeMulti(self, &child_dict);
-  if (child != NULL)node->children.push_back(child);
+  if (child != NULL)
+    node->children.push_back(child);
 
   for (i = 0; i < PyTuple_Size(args); i++) {
     obj = PyTuple_GetItem(args, i);
-    if (i == 0)child = PyOpenSCADObjectToNodeMulti(obj, &child_dict);
-    else child = PyOpenSCADObjectToNodeMulti(obj, &dummy_dict);
+    if (i == 0)
+      child = PyOpenSCADObjectToNodeMulti(obj, &child_dict);
+    else
+      child = PyOpenSCADObjectToNodeMulti(obj, &dummy_dict);
     if (child != NULL) {
       node->children.push_back(child);
     } else {
       switch (mode) {
       case OpenSCADOperator::UNION:
-        PyErr_SetString(PyExc_TypeError, "Error during parsing union. arguments must be solids or arrays.");
+        PyErr_SetString(
+            PyExc_TypeError,
+            "Error during parsing union. arguments must be solids or arrays.");
         break;
       case OpenSCADOperator::DIFFERENCE:
-        PyErr_SetString(PyExc_TypeError, "Error during parsing difference. arguments must be solids or arrays.");
+        PyErr_SetString(PyExc_TypeError, "Error during parsing difference. "
+                                         "arguments must be solids or arrays.");
         break;
       case OpenSCADOperator::INTERSECTION:
-        PyErr_SetString(PyExc_TypeError, "Error during parsing intersection. arguments must be solids or arrays.");
+        PyErr_SetString(PyExc_TypeError, "Error during parsing intersection. "
+                                         "arguments must be solids or arrays.");
         break;
       case OpenSCADOperator::MINKOWSKI:
         break;
@@ -1488,31 +1548,31 @@ PyObject *python_oo_csg_sub(PyObject *self, PyObject *args, PyObject *kwargs, Op
   return pyresult;
 }
 
-PyObject *python_oo_union(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_union(PyObject *self, PyObject *args, PyObject *kwargs) {
   return python_oo_csg_sub(self, args, kwargs, OpenSCADOperator::UNION);
 }
 
-PyObject *python_oo_difference(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_difference(PyObject *self, PyObject *args,
+                               PyObject *kwargs) {
   return python_oo_csg_sub(self, args, kwargs, OpenSCADOperator::DIFFERENCE);
 }
 
-PyObject *python_oo_intersection(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_intersection(PyObject *self, PyObject *args,
+                                 PyObject *kwargs) {
   return python_oo_csg_sub(self, args, kwargs, OpenSCADOperator::INTERSECTION);
 }
 
-PyObject *python_nb_sub(PyObject *arg1, PyObject *arg2, OpenSCADOperator mode)
-{
+PyObject *python_nb_sub(PyObject *arg1, PyObject *arg2, OpenSCADOperator mode) {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child[2];
   PyObject *child_dict[2];
 
-  if (arg1 == Py_None && mode == OpenSCADOperator::UNION)return arg2;
-  if (arg2 == Py_None && mode == OpenSCADOperator::UNION)return arg1;
-  if (arg2 == Py_None && mode == OpenSCADOperator::DIFFERENCE)return arg1;
-
+  if (arg1 == Py_None && mode == OpenSCADOperator::UNION)
+    return arg2;
+  if (arg2 == Py_None && mode == OpenSCADOperator::UNION)
+    return arg1;
+  if (arg2 == Py_None && mode == OpenSCADOperator::DIFFERENCE)
+    return arg1;
 
   child[0] = PyOpenSCADObjectToNodeMulti(arg1, &child_dict[0]);
   if (child[0] == NULL) {
@@ -1533,14 +1593,16 @@ PyObject *python_nb_sub(PyObject *arg1, PyObject *arg2, OpenSCADOperator mode)
       PyObject *key, *value;
       Py_ssize_t pos = 0;
       while (PyDict_Next(child_dict[i], &pos, &key, &value)) {
-        PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value);
+        PyDict_SetItem(((PyOpenSCADObject *)pyresult)->dict, key, value);
       }
     }
   }
   return pyresult;
 }
 
-PyObject *python_nb_sub_vec3(PyObject *arg1, PyObject *arg2, int mode) // 0: translate, 1: scale, 2: translateneg, 3=translate-exp
+PyObject *python_nb_sub_vec3(
+    PyObject *arg1, PyObject *arg2,
+    int mode) // 0: translate, 1: scale, 2: translateneg, 3=translate-exp
 {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
@@ -1553,7 +1615,8 @@ PyObject *python_nb_sub_vec3(PyObject *arg1, PyObject *arg2, int mode) // 0: tra
 
   if (mode == 0 && vecs.size() == 1) {
     PyObject *mat = python_matrix_trans(arg1, vecs[0]);
-    if (mat != nullptr)return mat;
+    if (mat != nullptr)
+      return mat;
   }
 
   if (vecs.size() > 0) {
@@ -1564,9 +1627,12 @@ PyObject *python_nb_sub_vec3(PyObject *arg1, PyObject *arg2, int mode) // 0: tra
     std::vector<std::shared_ptr<TransformNode>> nodes;
     for (size_t j = 0; j < vecs.size(); j++) {
       auto node = std::make_shared<TransformNode>(instance, "transform");
-      if (mode == 0 || mode == 3)node->matrix.translate(vecs[j]);
-      if (mode == 1)node->matrix.scale(vecs[j]);
-      if (mode == 2)node->matrix.translate(-vecs[j]);
+      if (mode == 0 || mode == 3)
+        node->matrix.translate(vecs[j]);
+      if (mode == 1)
+        node->matrix.scale(vecs[j]);
+      if (mode == 2)
+        node->matrix.translate(-vecs[j]);
       node->children.push_back(child);
       nodes.push_back(node);
     }
@@ -1577,8 +1643,10 @@ PyObject *python_nb_sub_vec3(PyObject *arg1, PyObject *arg2, int mode) // 0: tra
         Py_ssize_t pos = 0;
         while (PyDict_Next(child_dict, &pos, &key, &value)) {
           PyObject *value1 = python_matrix_trans(value, vecs[0]);
-          if (value1 != nullptr) PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value1);
-          else PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value);
+          if (value1 != nullptr)
+            PyDict_SetItem(((PyOpenSCADObject *)pyresult)->dict, key, value1);
+          else
+            PyDict_SetItem(((PyOpenSCADObject *)pyresult)->dict, key, value);
         }
       }
       return pyresult;
@@ -1588,24 +1656,32 @@ PyObject *python_nb_sub_vec3(PyObject *arg1, PyObject *arg2, int mode) // 0: tra
   return NULL;
 }
 
-PyObject *python_nb_add(PyObject *arg1, PyObject *arg2) { return python_nb_sub_vec3(arg1, arg2, 0); }  // translate
-PyObject *python_nb_mul(PyObject *arg1, PyObject *arg2) { return python_nb_sub_vec3(arg1, arg2, 1); } // scale
-PyObject *python_nb_or(PyObject *arg1, PyObject *arg2) { return python_nb_sub(arg1, arg2,  OpenSCADOperator::UNION); }
-PyObject *python_nb_subtract(PyObject *arg1, PyObject *arg2)
-{
+PyObject *python_nb_add(PyObject *arg1, PyObject *arg2) {
+  return python_nb_sub_vec3(arg1, arg2, 0);
+} // translate
+PyObject *python_nb_mul(PyObject *arg1, PyObject *arg2) {
+  return python_nb_sub_vec3(arg1, arg2, 1);
+} // scale
+PyObject *python_nb_or(PyObject *arg1, PyObject *arg2) {
+  return python_nb_sub(arg1, arg2, OpenSCADOperator::UNION);
+}
+PyObject *python_nb_subtract(PyObject *arg1, PyObject *arg2) {
   double dmy;
   if (PyList_Check(arg2) && PyList_Size(arg2) > 0) {
     PyObject *sub = PyList_GetItem(arg2, 0);
-    if (!python_numberval(sub, &dmy) || PyList_Check(sub)){
+    if (!python_numberval(sub, &dmy) || PyList_Check(sub)) {
       return python_nb_sub_vec3(arg1, arg2, 2);
     }
   }
-  return python_nb_sub(arg1, arg2,  OpenSCADOperator::DIFFERENCE); // if its solid
+  return python_nb_sub(arg1, arg2,
+                       OpenSCADOperator::DIFFERENCE); // if its solid
+}
+PyObject *python_nb_and(PyObject *arg1, PyObject *arg2) {
+  return python_nb_sub(arg1, arg2, OpenSCADOperator::INTERSECTION);
 }
-PyObject *python_nb_and(PyObject *arg1, PyObject *arg2) { return python_nb_sub(arg1, arg2,  OpenSCADOperator::INTERSECTION); }
 
-PyObject *python_csg_adv_sub(PyObject *self, PyObject *args, PyObject *kwargs, CgalAdvType mode)
-{
+PyObject *python_csg_adv_sub(PyObject *self, PyObject *args, PyObject *kwargs,
+                             CgalAdvType mode) {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
   int i;
@@ -1621,10 +1697,14 @@ PyObject *python_csg_adv_sub(PyObject *self, PyObject *args, PyObject *kwargs, C
     } else {
       switch (mode) {
       case CgalAdvType::HULL:
-        PyErr_SetString(PyExc_TypeError, "Error during parsing hull. arguments must be solids or arrays.");
+        PyErr_SetString(
+            PyExc_TypeError,
+            "Error during parsing hull. arguments must be solids or arrays.");
         break;
       case CgalAdvType::FILL:
-        PyErr_SetString(PyExc_TypeError, "Error during parsing fill. arguments must be solids or arrays.");
+        PyErr_SetString(
+            PyExc_TypeError,
+            "Error during parsing fill. arguments must be solids or arrays.");
         break;
       case CgalAdvType::RESIZE:
         break;
@@ -1638,8 +1718,7 @@ PyObject *python_csg_adv_sub(PyObject *self, PyObject *args, PyObject *kwargs, C
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_minkowski(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_minkowski(PyObject *self, PyObject *args, PyObject *kwargs) {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
   int i;
@@ -1647,15 +1726,13 @@ PyObject *python_minkowski(PyObject *self, PyObject *args, PyObject *kwargs)
   int convexity = 2;
 
   auto node = std::make_shared<CgalAdvNode>(instance, CgalAdvType::MINKOWSKI);
-  char *kwlist[] = { "obj", "convexity", NULL };
+  char *kwlist[] = {"obj", "convexity", NULL};
   PyObject *objs = NULL;
   PyObject *obj;
   PyObject *dummydict;
 
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!|i", kwlist,
-                                   &PyList_Type, &objs,
-                                   &convexity
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!|i", kwlist, &PyList_Type,
+                                   &objs, &convexity)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing minkowski(object)");
     return NULL;
   }
@@ -1675,20 +1752,16 @@ PyObject *python_minkowski(PyObject *self, PyObject *args, PyObject *kwargs)
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-
-
-PyObject *python_hull(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_hull(PyObject *self, PyObject *args, PyObject *kwargs) {
   return python_csg_adv_sub(self, args, kwargs, CgalAdvType::HULL);
 }
 
-PyObject *python_fill(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_fill(PyObject *self, PyObject *args, PyObject *kwargs) {
   return python_csg_adv_sub(self, args, kwargs, CgalAdvType::FILL);
 }
 
-PyObject *python_resize_core(PyObject *obj, PyObject *newsize, PyObject *autosize, int convexity)
-{
+PyObject *python_resize_core(PyObject *obj, PyObject *newsize,
+                             PyObject *autosize, int convexity) {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
 
@@ -1730,47 +1803,42 @@ PyObject *python_resize_core(PyObject *obj, PyObject *newsize, PyObject *autosiz
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_resize(PyObject *self, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = { "obj", "newsize", "auto", "convexity", NULL };
+PyObject *python_resize(PyObject *self, PyObject *args, PyObject *kwargs) {
+  char *kwlist[] = {"obj", "newsize", "auto", "convexity", NULL};
   PyObject *obj;
   PyObject *newsize = NULL;
   PyObject *autosize = NULL;
   int convexity = 2;
 
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O!O!i", kwlist,
-                                   &obj,
-                                   &PyList_Type, &newsize,
-                                   &PyList_Type, &autosize,
-                                   &convexity
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing resize(object,vec3)");
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O!O!i", kwlist, &obj,
+                                   &PyList_Type, &newsize, &PyList_Type,
+                                   &autosize, &convexity)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing resize(object,vec3)");
     return NULL;
   }
   return python_resize_core(obj, newsize, autosize, convexity);
 }
 
-PyObject *python_oo_resize(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
-  char *kwlist[] = {"newsize", "auto", "convexity", NULL };
+PyObject *python_oo_resize(PyObject *obj, PyObject *args, PyObject *kwargs) {
+  char *kwlist[] = {"newsize", "auto", "convexity", NULL};
   PyObject *newsize = NULL;
   PyObject *autosize = NULL;
   int convexity = 2;
 
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O!O!i", kwlist,
-                                   &PyList_Type, &newsize,
-                                   &PyList_Type, &autosize,
-                                   &convexity
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing resize(object,vec3)");
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O!O!i", kwlist, &PyList_Type,
+                                   &newsize, &PyList_Type, &autosize,
+                                   &convexity)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing resize(object,vec3)");
     return NULL;
   }
   return python_resize_core(obj, newsize, autosize, convexity);
 }
 
 #if defined(ENABLE_EXPERIMENTAL) && defined(ENABLE_CGAL)
-PyObject *python_roof_core(PyObject *obj, const char *method, int convexity, double fn, double fa, double fs)
-{
+PyObject *python_roof_core(PyObject *obj, const char *method, int convexity,
+                           double fn, double fa, double fs) {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
   auto node = std::make_shared<RoofNode>(instance);
@@ -1782,9 +1850,12 @@ PyObject *python_roof_core(PyObject *obj, const char *method, int convexity, dou
   }
 
   get_fnas(node->fn, node->fa, node->fs);
-  if (!isnan(fn)) node->fn = fn;
-  if (!isnan(fa)) node->fa = fa;
-  if (!isnan(fs)) node->fs = fs;
+  if (!isnan(fn))
+    node->fn = fn;
+  if (!isnan(fa))
+    node->fa = fa;
+  if (!isnan(fs))
+    node->fs = fs;
 
   node->fa = std::max(node->fa, 0.01);
   node->fs = std::max(node->fs, 0.01);
@@ -1799,48 +1870,44 @@ PyObject *python_roof_core(PyObject *obj, const char *method, int convexity, dou
     node->method = method;
     // method can only be one of...
     if (node->method != "voronoi" && node->method != "straight") {
-//      LOG(message_group::Warning, inst->location(), parameters.documentRoot(),
-//          "Unknown roof method '" + node->method + "'. Using 'voronoi'.");
+      //      LOG(message_group::Warning, inst->location(),
+      //      parameters.documentRoot(),
+      //          "Unknown roof method '" + node->method + "'. Using
+      //          'voronoi'.");
       node->method = "voronoi";
     }
   }
 
   double tmp_convexity = convexity;
   node->convexity = static_cast<int>(tmp_convexity);
-  if (node->convexity <= 0) node->convexity = 1;
+  if (node->convexity <= 0)
+    node->convexity = 1;
 
   node->children.push_back(child);
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_roof(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_roof(PyObject *self, PyObject *args, PyObject *kwargs) {
   double fn = NAN, fa = NAN, fs = NAN;
   char *kwlist[] = {"obj", "method", "convexity", "fn", "fa", "fs", NULL};
   PyObject *obj = NULL;
   const char *method = NULL;
   int convexity = 2;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|sdddd", kwlist,
-                                   &obj,
-                                   &method, convexity,
-                                   &fn, &fa, &fs
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|sdddd", kwlist, &obj,
+                                   &method, convexity, &fn, &fa, &fs)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing roof(object)");
     return NULL;
   }
   return python_roof_core(obj, method, convexity, fn, fa, fs);
 }
 
-PyObject *python_oo_roof(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_roof(PyObject *obj, PyObject *args, PyObject *kwargs) {
   double fn = NAN, fa = NAN, fs = NAN;
   char *kwlist[] = {"method", "convexity", "fn", "fa", "fs", NULL};
   const char *method = NULL;
   int convexity = 2;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|sdddd", kwlist,
-                                   &method, convexity,
-                                   &fn, &fa, &fs
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|sdddd", kwlist, &method,
+                                   convexity, &fn, &fa, &fs)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing roof(object)");
     return NULL;
   }
@@ -1848,8 +1915,7 @@ PyObject *python_oo_roof(PyObject *obj, PyObject *args, PyObject *kwargs)
 }
 #endif // if defined(ENABLE_EXPERIMENTAL) && defined(ENABLE_CGAL)
 
-PyObject *python_render_core(PyObject *obj, int convexity)
-{
+PyObject *python_render_core(PyObject *obj, int convexity) {
   DECLARE_INSTANCE
   auto node = std::make_shared<RenderNode>(instance);
 
@@ -1860,55 +1926,54 @@ PyObject *python_render_core(PyObject *obj, int convexity)
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_render(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_render(PyObject *self, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"obj", "convexity", NULL};
   PyObject *obj = NULL;
   long convexity = 2;
   if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!|i", kwlist,
-                                   &PyOpenSCADType, &obj,
-                                   &convexity
-                                   )) {
+                                   &PyOpenSCADType, &obj, &convexity)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing render(object)");
     return NULL;
   }
   return python_render_core(obj, convexity);
 }
 
-PyObject *python_oo_render(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_render(PyObject *obj, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"convexity", NULL};
   long convexity = 2;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i", kwlist,
-                                   &convexity
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|i", kwlist, &convexity)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing render(object)");
     return NULL;
   }
   return python_render_core(obj, convexity);
 }
 
-PyObject *python_surface_core(const char *file, PyObject *center, PyObject *invert, int convexity)
-{
+PyObject *python_surface_core(const char *file, PyObject *center,
+                              PyObject *invert, int convexity) {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
 
   auto node = std::make_shared<SurfaceNode>(instance);
 
   std::string fileval = file == NULL ? "" : file;
-  std::string filename = lookup_file(fileval, instance->location().filePath().parent_path().string(), "");
+  std::string filename = lookup_file(
+      fileval, instance->location().filePath().parent_path().string(), "");
   node->filename = filename;
   handle_dep(fs::path(filename).generic_string());
 
-  if (center == Py_True) node->center = 1;
-  else if (center == Py_False || center == NULL)   node->center = 0;
+  if (center == Py_True)
+    node->center = 1;
+  else if (center == Py_False || center == NULL)
+    node->center = 0;
   else {
     PyErr_SetString(PyExc_TypeError, "Unknown Value for center parameter");
     return NULL;
   }
   node->convexity = 2;
-  if (invert == Py_True)   node->invert = 1;
-  else if (center == Py_False || center == NULL)   node->center = 0;
+  if (invert == Py_True)
+    node->invert = 1;
+  else if (center == Py_False || center == NULL)
+    node->center = 0;
   else {
     PyErr_SetString(PyExc_TypeError, "Unknown Value for invert parameter");
     return NULL;
@@ -1917,16 +1982,14 @@ PyObject *python_surface_core(const char *file, PyObject *center, PyObject *inve
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_surface(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_surface(PyObject *self, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"file", "center", "convexity", "invert", NULL};
   const char *file = NULL;
   PyObject *center = NULL;
   PyObject *invert = NULL;
   long convexity = 2;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s|OlO", kwlist,
-                                   &file, &center, &convexity
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s|OlO", kwlist, &file,
+                                   &center, &convexity)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing surface(object)");
     return NULL;
   }
@@ -1934,26 +1997,25 @@ PyObject *python_surface(PyObject *self, PyObject *args, PyObject *kwargs)
   return python_surface_core(file, center, invert, convexity);
 }
 
-PyObject *python_text(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_text(PyObject *self, PyObject *args, PyObject *kwargs) {
   DECLARE_INSTANCE
   auto node = std::make_shared<TextNode>(instance);
 
-  char *kwlist[] = {"text", "size", "font", "spacing", "direction", "language", "script", "halign", "valign", "fn", "fa", "fs", NULL};
+  char *kwlist[] = {"text",     "size",   "font",   "spacing", "direction",
+                    "language", "script", "halign", "valign",  "fn",
+                    "fa",       "fs",     NULL};
 
   double size = 1.0, spacing = 1.0;
   double fn = NAN, fa = NAN, fs = NAN;
 
   get_fnas(fn, fa, fs);
 
-  const char *text = "", *font = NULL, *direction = "ltr", *language = "en", *script = "latin", *valign = "baseline", *halign = "left";
+  const char *text = "", *font = NULL, *direction = "ltr", *language = "en",
+             *script = "latin", *valign = "baseline", *halign = "left";
 
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s|dsdsssssddd", kwlist,
-                                   &text, &size, &font,
-                                   &spacing, &direction, &language,
-                                   &script, &halign, &valign,
-                                   &fn, &fa, &fs
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(
+          args, kwargs, "s|dsdsssssddd", kwlist, &text, &size, &font, &spacing,
+          &direction, &language, &script, &halign, &valign, &fn, &fa, &fs)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing text(string, ...))");
     return NULL;
   }
@@ -1962,41 +2024,47 @@ PyObject *python_text(PyObject *self, PyObject *args, PyObject *kwargs)
   node->params.set_fa(fa);
   node->params.set_fs(fs);
   node->params.set_size(size);
-  if (text != NULL) node->params.set_text(text);
+  if (text != NULL)
+    node->params.set_text(text);
   node->params.set_spacing(spacing);
-  if (font != NULL) node->params.set_font(font);
-  if (direction != NULL) node->params.set_direction(direction);
-  if (language != NULL) node->params.set_language(language);
-  if (script != NULL) node->params.set_script(script);
-  if (valign != NULL) node->params.set_halign(halign);
-  if (halign != NULL) node->params.set_valign(valign);
+  if (font != NULL)
+    node->params.set_font(font);
+  if (direction != NULL)
+    node->params.set_direction(direction);
+  if (language != NULL)
+    node->params.set_language(language);
+  if (script != NULL)
+    node->params.set_script(script);
+  if (valign != NULL)
+    node->params.set_halign(halign);
+  if (halign != NULL)
+    node->params.set_valign(valign);
   node->params.set_loc(instance->location());
 
-/*
-   node->params.set_documentPath(session->documentRoot());
-   }
- */
+  /*
+     node->params.set_documentPath(session->documentRoot());
+     }
+   */
   node->params.detect_properties();
 
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_textmetrics(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_textmetrics(PyObject *self, PyObject *args, PyObject *kwargs) {
   DECLARE_INSTANCE
   auto node = std::make_shared<TextNode>(instance);
 
-  char *kwlist[] = {"text", "size", "font", "spacing", "direction", "language", "script", "halign", "valign", NULL};
+  char *kwlist[] = {"text",     "size",   "font",   "spacing", "direction",
+                    "language", "script", "halign", "valign",  NULL};
 
   double size = 1.0, spacing = 1.0;
 
-  const char *text = "", *font = NULL, *direction = "ltr", *language = "en", *script = "latin", *valign = "baseline", *halign = "left";
+  const char *text = "", *font = NULL, *direction = "ltr", *language = "en",
+             *script = "latin", *valign = "baseline", *halign = "left";
 
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s|dsdsssss", kwlist,
-                                   &text, &size, &font,
-                                   &spacing, &direction, &language,
-                                   &script, &valign, &halign
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s|dsdsssss", kwlist, &text,
+                                   &size, &font, &spacing, &direction,
+                                   &language, &script, &valign, &halign)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing textmetrics");
     return NULL;
   }
@@ -2004,14 +2072,21 @@ PyObject *python_textmetrics(PyObject *self, PyObject *args, PyObject *kwargs)
   FreetypeRenderer::Params ftparams;
 
   ftparams.set_size(size);
-  if (text != NULL) ftparams.set_text(text);
+  if (text != NULL)
+    ftparams.set_text(text);
   ftparams.set_spacing(spacing);
-  if (font != NULL) ftparams.set_font(font);
-  if (direction != NULL) ftparams.set_direction(direction);
-  if (language != NULL) ftparams.set_language(language);
-  if (script != NULL) ftparams.set_script(script);
-  if (valign != NULL) ftparams.set_halign(halign);
-  if (halign != NULL) ftparams.set_valign(valign);
+  if (font != NULL)
+    ftparams.set_font(font);
+  if (direction != NULL)
+    ftparams.set_direction(direction);
+  if (language != NULL)
+    ftparams.set_language(language);
+  if (script != NULL)
+    ftparams.set_script(script);
+  if (valign != NULL)
+    ftparams.set_halign(halign);
+  if (halign != NULL)
+    ftparams.set_valign(valign);
   ftparams.set_loc(instance->location());
 
   FreetypeRenderer::TextMetrics metrics(ftparams);
@@ -2046,23 +2121,27 @@ PyObject *python_textmetrics(PyObject *self, PyObject *args, PyObject *kwargs)
   return (PyObject *)dict;
 }
 
-PyObject *python_offset_core(PyObject *obj, double r, double delta, PyObject *chamfer, double fn, double fa, double fs)
-{
+PyObject *python_offset_core(PyObject *obj, double r, double delta,
+                             PyObject *chamfer, double fn, double fa,
+                             double fs) {
   DECLARE_INSTANCE
   auto node = std::make_shared<OffsetNode>(instance);
 
   PyObject *dummydict;
-  std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNodeMulti(obj, &dummydict);
+  std::shared_ptr<AbstractNode> child =
+      PyOpenSCADObjectToNodeMulti(obj, &dummydict);
   if (child == NULL) {
     PyErr_SetString(PyExc_TypeError, "Invalid type for Object in offset");
     return NULL;
   }
 
   get_fnas(node->fn, node->fa, node->fs);
-  if (!isnan(fn)) node->fn = fn;
-  if (!isnan(fa)) node->fa = fa;
-  if (!isnan(fs)) node->fs = fs;
-
+  if (!isnan(fn))
+    node->fn = fn;
+  if (!isnan(fa))
+    node->fa = fa;
+  if (!isnan(fs))
+    node->fs = fs;
 
   node->delta = 1;
   node->chamfer = false;
@@ -2075,7 +2154,8 @@ PyObject *python_offset_core(PyObject *obj, double r, double delta, PyObject *ch
     if (chamfer == Py_True) {
       node->chamfer = true;
       node->join_type = Clipper2Lib::JoinType::Square;
-    } else if (chamfer == Py_False || chamfer == NULL) node->chamfer = 0;
+    } else if (chamfer == Py_False || chamfer == NULL)
+      node->chamfer = 0;
     else {
       PyErr_SetString(PyExc_TypeError, "Unknown Value for chamfer parameter");
       return NULL;
@@ -2085,46 +2165,42 @@ PyObject *python_offset_core(PyObject *obj, double r, double delta, PyObject *ch
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_offset(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_offset(PyObject *self, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"obj", "r", "delta", "chamfer", "fn", "fa", "fs", NULL};
   PyObject *obj = NULL;
   double r = NAN, delta = NAN;
   PyObject *chamfer = NULL;
   double fn = NAN, fa = NAN, fs = NAN;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|ddOddd", kwlist,
-                                   &obj,
-                                   &r, &delta, &chamfer,
-                                   &fn, &fa, &fs
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing offset(object,r,delta)");
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|ddOddd", kwlist, &obj, &r,
+                                   &delta, &chamfer, &fn, &fa, &fs)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing offset(object,r,delta)");
     return NULL;
   }
   return python_offset_core(obj, r, delta, chamfer, fn, fa, fs);
 }
 
-PyObject *python_oo_offset(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_offset(PyObject *obj, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"r", "delta", "chamfer", "fn", "fa", "fs", NULL};
   double r = NAN, delta = NAN;
   PyObject *chamfer = NULL;
   double fn = NAN, fa = NAN, fs = NAN;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|ddOddd", kwlist,
-                                   &r, &delta, &chamfer,
-                                   &fn, &fa, &fs
-                                   )) {
-    PyErr_SetString(PyExc_TypeError, "Error during parsing offset(object,r,delta)");
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|ddOddd", kwlist, &r, &delta,
+                                   &chamfer, &fn, &fa, &fs)) {
+    PyErr_SetString(PyExc_TypeError,
+                    "Error during parsing offset(object,r,delta)");
     return NULL;
   }
   return python_offset_core(obj, r, delta, chamfer, fn, fa, fs);
 }
 
-PyObject *python_projection_core(PyObject *obj, const char *cutmode, int convexity)
-{
+PyObject *python_projection_core(PyObject *obj, const char *cutmode,
+                                 int convexity) {
   DECLARE_INSTANCE
   auto node = std::make_shared<ProjectionNode>(instance);
   PyObject *dummydict;
-  std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNodeMulti(obj, &dummydict);
+  std::shared_ptr<AbstractNode> child =
+      PyOpenSCADObjectToNodeMulti(obj, &dummydict);
   if (child == NULL) {
     PyErr_SetString(PyExc_TypeError, "Invalid type for Object in projection");
     return NULL;
@@ -2132,44 +2208,40 @@ PyObject *python_projection_core(PyObject *obj, const char *cutmode, int convexi
 
   node->convexity = convexity;
   node->cut_mode = 0;
-  if (cutmode != NULL && !strcasecmp(cutmode, "cut")) node->cut_mode = 1;
+  if (cutmode != NULL && !strcasecmp(cutmode, "cut"))
+    node->cut_mode = 1;
 
   node->children.push_back(child);
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_projection(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_projection(PyObject *self, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"obj", "cut", "convexity", NULL};
   PyObject *obj = NULL;
   const char *cutmode = NULL;
   long convexity = 2;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|sl", kwlist,
-                                   &obj,
-                                   &cutmode, &convexity
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|sl", kwlist, &obj, &cutmode,
+                                   &convexity)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing projection(object)");
     return NULL;
   }
   return python_projection_core(obj, cutmode, convexity);
 }
 
-PyObject *python_oo_projection(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_projection(PyObject *obj, PyObject *args,
+                               PyObject *kwargs) {
   char *kwlist[] = {"cut", "convexity", NULL};
   const char *cutmode = NULL;
   long convexity = 2;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|sl", kwlist,
-                                   &cutmode, &convexity
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|sl", kwlist, &cutmode,
+                                   &convexity)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing projection(object)");
     return NULL;
   }
   return python_projection_core(obj, cutmode, convexity);
 }
 
-PyObject *python_group(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_group(PyObject *self, PyObject *args, PyObject *kwargs) {
   DECLARE_INSTANCE
   std::shared_ptr<AbstractNode> child;
 
@@ -2178,9 +2250,8 @@ PyObject *python_group(PyObject *self, PyObject *args, PyObject *kwargs)
   char *kwlist[] = {"obj", NULL};
   PyObject *obj = NULL;
   PyObject *dummydict;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!", kwlist,
-                                   &PyOpenSCADType, &obj
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!", kwlist, &PyOpenSCADType,
+                                   &obj)) {
     PyErr_SetString(PyExc_TypeError, "Error during parsing group(group)");
     return NULL;
   }
@@ -2190,14 +2261,15 @@ PyObject *python_group(PyObject *self, PyObject *args, PyObject *kwargs)
   return PyOpenSCADObjectFromNode(&PyOpenSCADType, node);
 }
 
-PyObject *python_align_core(PyObject *obj, PyObject *pyrefmat, PyObject *pydstmat)
-{
+PyObject *python_align_core(PyObject *obj, PyObject *pyrefmat,
+                            PyObject *pydstmat) {
   if (obj->ob_type != &PyOpenSCADType) {
     PyErr_SetString(PyExc_TypeError, "Must specify Object as 1st parameter");
     return nullptr;
   }
   PyObject *child_dict = nullptr;
-  std::shared_ptr<AbstractNode> dstnode = PyOpenSCADObjectToNode(obj, &child_dict);
+  std::shared_ptr<AbstractNode> dstnode =
+      PyOpenSCADObjectToNode(obj, &child_dict);
   if (dstnode == nullptr) {
     PyErr_SetString(PyExc_TypeError, "Invalid align object");
     return Py_None;
@@ -2208,8 +2280,10 @@ PyObject *python_align_core(PyObject *obj, PyObject *pyrefmat, PyObject *pydstma
   Matrix4d mat;
   Matrix4d MT = Matrix4d::Identity();
 
-  if (!python_tomatrix(pyrefmat, mat))MT = MT * mat;
-  if (!python_tomatrix(pydstmat, mat))MT = MT * mat.inverse();
+  if (!python_tomatrix(pyrefmat, mat))
+    MT = MT * mat;
+  if (!python_tomatrix(pydstmat, mat))
+    MT = MT * mat.inverse();
 
   multmatnode->matrix = MT;
 
@@ -2218,179 +2292,204 @@ PyObject *python_align_core(PyObject *obj, PyObject *pyrefmat, PyObject *pydstma
     PyObject *key, *value;
     Py_ssize_t pos = 0;
     while (PyDict_Next(child_dict, &pos, &key, &value)) {
-      if (!python_tomatrix(value, mat)){
+      if (!python_tomatrix(value, mat)) {
         mat = MT * mat;
-        PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, python_frommatrix(mat));
-      } else PyDict_SetItem(((PyOpenSCADObject *) pyresult)->dict, key, value);
+        PyDict_SetItem(((PyOpenSCADObject *)pyresult)->dict, key,
+                       python_frommatrix(mat));
+      } else
+        PyDict_SetItem(((PyOpenSCADObject *)pyresult)->dict, key, value);
     }
   }
   return pyresult;
 }
 
-PyObject *python_align(PyObject *self, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_align(PyObject *self, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"obj", "refmat", "objmat", NULL};
   PyObject *obj = NULL;
   PyObject *pyrefmat = NULL;
   PyObject *pyobjmat = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO|O", kwlist,
-                                   &obj,
-                                   &pyrefmat,
-                                   &pyobjmat
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO|O", kwlist, &obj,
+                                   &pyrefmat, &pyobjmat)) {
     PyErr_SetString(PyExc_TypeError, "Error during align");
     return NULL;
   }
   return python_align_core(obj, pyrefmat, pyobjmat);
 }
 
-PyObject *python_oo_align(PyObject *obj, PyObject *args, PyObject *kwargs)
-{
+PyObject *python_oo_align(PyObject *obj, PyObject *args, PyObject *kwargs) {
   char *kwlist[] = {"refmat", "objmat", NULL};
   PyObject *pyrefmat = NULL;
   PyObject *pyobjmat = NULL;
-  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O", kwlist,
-                                   &pyrefmat,
-                                   &pyobjmat
-                                   )) {
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O", kwlist, &pyrefmat,
+                                   &pyobjmat)) {
     PyErr_SetString(PyExc_TypeError, "Error during align");
     return NULL;
   }
   return python_align_core(obj, pyrefmat, pyobjmat);
 }
 
-
 PyObject *python_str(PyObject *self) {
   std::ostringstream stream;
   PyObject *dummydict;
   std::shared_ptr<AbstractNode> node = PyOpenSCADObjectToNode(self, &dummydict);
-  if (node != nullptr)stream << "OpenSCAD (" << (int) node->index() << ")";
-  else stream << "Invalid OpenSCAD Object";
+  if (node != nullptr)
+    stream << "OpenSCAD (" << (int)node->index() << ")";
+  else
+    stream << "Invalid OpenSCAD Object";
 
   return PyUnicode_FromStringAndSize(stream.str().c_str(), stream.str().size());
 }
 
 PyMethodDef PyOpenSCADFunctions[] = {
-  {"square", (PyCFunction) python_square, METH_VARARGS | METH_KEYWORDS, "Create Square."},
-  {"circle", (PyCFunction) python_circle, METH_VARARGS | METH_KEYWORDS, "Create Circle."},
-  {"polygon", (PyCFunction) python_polygon, METH_VARARGS | METH_KEYWORDS, "Create Polygon."},
-  {"text", (PyCFunction) python_text, METH_VARARGS | METH_KEYWORDS, "Create Text."},
-  {"textmetrics", (PyCFunction) python_textmetrics, METH_VARARGS | METH_KEYWORDS, "Get textmetrics."},
-  {"cube", (PyCFunction) python_cube, METH_VARARGS | METH_KEYWORDS, "Create Cube."},
-  {"cylinder", (PyCFunction) python_cylinder, METH_VARARGS | METH_KEYWORDS, "Create Cylinder."},
-  {"sphere", (PyCFunction) python_sphere, METH_VARARGS | METH_KEYWORDS, "Create Sphere."},
-  {"polyhedron", (PyCFunction) python_polyhedron, METH_VARARGS | METH_KEYWORDS, "Create Polyhedron."},
-  {"translate", (PyCFunction) python_translate, METH_VARARGS | METH_KEYWORDS, "Move  Object."},
-  {"rotate", (PyCFunction) python_rotate, METH_VARARGS | METH_KEYWORDS, "Rotate Object."},
-  {"scale", (PyCFunction) python_scale, METH_VARARGS | METH_KEYWORDS, "Scale Object."},
-  {"mirror", (PyCFunction) python_mirror, METH_VARARGS | METH_KEYWORDS, "Mirror Object."},
-  {"multmatrix", (PyCFunction) python_multmatrix, METH_VARARGS | METH_KEYWORDS, "Multmatrix Object."},
-  {"divmatrix", (PyCFunction) python_divmatrix, METH_VARARGS | METH_KEYWORDS, "Divmatrix Object."},
-  {"offset", (PyCFunction) python_offset, METH_VARARGS | METH_KEYWORDS, "Offset Object."},
+    {"square", (PyCFunction)python_square, METH_VARARGS | METH_KEYWORDS,
+     "Create Square."},
+    {"circle", (PyCFunction)python_circle, METH_VARARGS | METH_KEYWORDS,
+     "Create Circle."},
+    {"polygon", (PyCFunction)python_polygon, METH_VARARGS | METH_KEYWORDS,
+     "Create Polygon."},
+    {"text", (PyCFunction)python_text, METH_VARARGS | METH_KEYWORDS,
+     "Create Text."},
+    {"textmetrics", (PyCFunction)python_textmetrics,
+     METH_VARARGS | METH_KEYWORDS, "Get textmetrics."},
+    {"cube", (PyCFunction)python_cube, METH_VARARGS | METH_KEYWORDS,
+     "Create Cube."},
+    {"cylinder", (PyCFunction)python_cylinder, METH_VARARGS | METH_KEYWORDS,
+     "Create Cylinder."},
+    {"sphere", (PyCFunction)python_sphere, METH_VARARGS | METH_KEYWORDS,
+     "Create Sphere."},
+    {"polyhedron", (PyCFunction)python_polyhedron, METH_VARARGS | METH_KEYWORDS,
+     "Create Polyhedron."},
+    {"translate", (PyCFunction)python_translate, METH_VARARGS | METH_KEYWORDS,
+     "Move  Object."},
+    {"rotate", (PyCFunction)python_rotate, METH_VARARGS | METH_KEYWORDS,
+     "Rotate Object."},
+    {"scale", (PyCFunction)python_scale, METH_VARARGS | METH_KEYWORDS,
+     "Scale Object."},
+    {"mirror", (PyCFunction)python_mirror, METH_VARARGS | METH_KEYWORDS,
+     "Mirror Object."},
+    {"multmatrix", (PyCFunction)python_multmatrix, METH_VARARGS | METH_KEYWORDS,
+     "Multmatrix Object."},
+    {"divmatrix", (PyCFunction)python_divmatrix, METH_VARARGS | METH_KEYWORDS,
+     "Divmatrix Object."},
+    {"offset", (PyCFunction)python_offset, METH_VARARGS | METH_KEYWORDS,
+     "Offset Object."},
 #if defined(ENABLE_EXPERIMENTAL) && defined(ENABLE_CGAL)
-  {"roof", (PyCFunction) python_roof, METH_VARARGS | METH_KEYWORDS, "Roof Object."},
+    {"roof", (PyCFunction)python_roof, METH_VARARGS | METH_KEYWORDS,
+     "Roof Object."},
 #endif
-  {"color", (PyCFunction) python_color, METH_VARARGS | METH_KEYWORDS, "Color Object."},
-  {"show", (PyCFunction) python_show, METH_VARARGS | METH_KEYWORDS, "Show the result."},
-  {"linear_extrude", (PyCFunction) python_linear_extrude, METH_VARARGS | METH_KEYWORDS, "Linear_extrude Object."},
-  {"rotate_extrude", (PyCFunction) python_rotate_extrude, METH_VARARGS | METH_KEYWORDS, "Rotate_extrude Object."},
-  {"union", (PyCFunction) python_union, METH_VARARGS | METH_KEYWORDS, "Union Object."},
-  {"difference", (PyCFunction) python_difference, METH_VARARGS | METH_KEYWORDS, "Difference Object."},
-  {"intersection", (PyCFunction) python_intersection, METH_VARARGS | METH_KEYWORDS, "Intersection Object."},
-  {"hull", (PyCFunction) python_hull, METH_VARARGS | METH_KEYWORDS, "Hull Object."},
-  {"minkowski", (PyCFunction) python_minkowski, METH_VARARGS | METH_KEYWORDS, "Minkowski Object."},
-  {"fill", (PyCFunction) python_fill, METH_VARARGS | METH_KEYWORDS, "Fill Object."},
-  {"resize", (PyCFunction) python_resize, METH_VARARGS | METH_KEYWORDS, "Resize Object."},
-  {"projection", (PyCFunction) python_projection, METH_VARARGS | METH_KEYWORDS, "Projection Object."},
-  {"surface", (PyCFunction) python_surface, METH_VARARGS | METH_KEYWORDS, "Surface Object."},
-  {"mesh", (PyCFunction) python_mesh, METH_VARARGS | METH_KEYWORDS, "exports mesh."},
-  {"render", (PyCFunction) python_render, METH_VARARGS | METH_KEYWORDS, "Render Object."},
-  {"align", (PyCFunction) python_align, METH_VARARGS | METH_KEYWORDS, "Align Object to another."},
-  {NULL, NULL, 0, NULL}
-};
-
-#define OO_METHOD_ENTRY(name, desc) \
-        {#name, (PyCFunction) python_oo_ ## name, METH_VARARGS | METH_KEYWORDS, desc},
+    {"color", (PyCFunction)python_color, METH_VARARGS | METH_KEYWORDS,
+     "Color Object."},
+    {"show", (PyCFunction)python_show, METH_VARARGS | METH_KEYWORDS,
+     "Show the result."},
+    {"linear_extrude", (PyCFunction)python_linear_extrude,
+     METH_VARARGS | METH_KEYWORDS, "Linear_extrude Object."},
+    {"rotate_extrude", (PyCFunction)python_rotate_extrude,
+     METH_VARARGS | METH_KEYWORDS, "Rotate_extrude Object."},
+    {"union", (PyCFunction)python_union, METH_VARARGS | METH_KEYWORDS,
+     "Union Object."},
+    {"difference", (PyCFunction)python_difference, METH_VARARGS | METH_KEYWORDS,
+     "Difference Object."},
+    {"intersection", (PyCFunction)python_intersection,
+     METH_VARARGS | METH_KEYWORDS, "Intersection Object."},
+    {"hull", (PyCFunction)python_hull, METH_VARARGS | METH_KEYWORDS,
+     "Hull Object."},
+    {"minkowski", (PyCFunction)python_minkowski, METH_VARARGS | METH_KEYWORDS,
+     "Minkowski Object."},
+    {"fill", (PyCFunction)python_fill, METH_VARARGS | METH_KEYWORDS,
+     "Fill Object."},
+    {"resize", (PyCFunction)python_resize, METH_VARARGS | METH_KEYWORDS,
+     "Resize Object."},
+    {"projection", (PyCFunction)python_projection, METH_VARARGS | METH_KEYWORDS,
+     "Projection Object."},
+    {"surface", (PyCFunction)python_surface, METH_VARARGS | METH_KEYWORDS,
+     "Surface Object."},
+    {"mesh", (PyCFunction)python_mesh, METH_VARARGS | METH_KEYWORDS,
+     "exports mesh."},
+    {"render", (PyCFunction)python_render, METH_VARARGS | METH_KEYWORDS,
+     "Render Object."},
+    {"align", (PyCFunction)python_align, METH_VARARGS | METH_KEYWORDS,
+     "Align Object to another."},
+    {NULL, NULL, 0, NULL}};
+
+#define OO_METHOD_ENTRY(name, desc)                                            \
+  {#name, (PyCFunction)python_oo_##name, METH_VARARGS | METH_KEYWORDS, desc},
 
 PyMethodDef PyOpenSCADMethods[] = {
-  OO_METHOD_ENTRY(translate, "Move Object")
-  OO_METHOD_ENTRY(rotate, "Rotate Object")
-
-  OO_METHOD_ENTRY(union, "Union Object")
-  OO_METHOD_ENTRY(difference, "Difference Object")
-  OO_METHOD_ENTRY(intersection, "Intersection Object")
-  OO_METHOD_ENTRY(scale, "Scale Object")
-  OO_METHOD_ENTRY(mirror, "Mirror Object")
-  OO_METHOD_ENTRY(multmatrix, "Multmatrix Object")
-  OO_METHOD_ENTRY(divmatrix, "Divmatrix Object")
-  OO_METHOD_ENTRY(offset, "Offset Object")
+    OO_METHOD_ENTRY(translate, "Move Object") OO_METHOD_ENTRY(rotate,
+                                                              "Rotate Object")
+
+        OO_METHOD_ENTRY(union, "Union Object") OO_METHOD_ENTRY(
+            difference,
+            "Difference Object") OO_METHOD_ENTRY(intersection,
+                                                 "Intersection Object")
+            OO_METHOD_ENTRY(scale, "Scale Object") OO_METHOD_ENTRY(
+                mirror, "Mirror Object") OO_METHOD_ENTRY(multmatrix,
+                                                         "Multmatrix Object")
+                OO_METHOD_ENTRY(divmatrix, "Divmatrix Object") OO_METHOD_ENTRY(
+                    offset, "Offset Object")
 #if defined(ENABLE_EXPERIMENTAL) && defined(ENABLE_CGAL)
-  OO_METHOD_ENTRY(roof, "Roof Object")
+                    OO_METHOD_ENTRY(roof, "Roof Object")
 #endif
-  OO_METHOD_ENTRY(color, "Color Object")
-  OO_METHOD_ENTRY(linear_extrude, "Linear_extrude Object")
-  OO_METHOD_ENTRY(rotate_extrude, "Rotate_extrude Object")
-  OO_METHOD_ENTRY(resize, "Resize Object")
-
-  OO_METHOD_ENTRY(mesh, "Mesh Object")
-  OO_METHOD_ENTRY(align, "Align Object to another")
-
-  OO_METHOD_ENTRY(show, "Show Object")
-  OO_METHOD_ENTRY(projection, "Projection Object")
-  OO_METHOD_ENTRY(render, "Render Object")
-  {
-    NULL, NULL, 0, NULL
-  }
-};
-
-PyNumberMethods PyOpenSCADNumbers =
-{
-  python_nb_add,    //binaryfunc nb_add
-  python_nb_subtract,   //binaryfunc nb_subtract
-  python_nb_mul,    //binaryfunc nb_multiply
-  0,        //binaryfunc nb_remainder
-  0,        //binaryfunc nb_divmod
-  0,        //ternaryfunc nb_power
-  0,        //unaryfunc nb_negative
-  0,        //unaryfunc nb_positive
-  0,        //unaryfunc nb_absolute
-  0,        //inquiry nb_bool
-  0,          //unaryfunc nb_invert
-  0,        //binaryfunc nb_lshift
-  0,        //binaryfunc nb_rshift
-  python_nb_and,    //binaryfunc nb_and
-  0,        //binaryfunc nb_xor
-  python_nb_or,     //binaryfunc nb_or
-  0,        //unaryfunc nb_int
-  0,        //void *nb_reserved
-  0,        //unaryfunc nb_float
-
-  0,        //binaryfunc nb_inplace_add
-  0,        //binaryfunc nb_inplace_subtract
-  0,        //binaryfunc nb_inplace_multiply
-  0,        //binaryfunc nb_inplace_remainder
-  0,        //ternaryfunc nb_inplace_power
-  0,        //binaryfunc nb_inplace_lshift
-  0,        //binaryfunc nb_inplace_rshift
-  0,        //binaryfunc nb_inplace_and
-  0,        //binaryfunc nb_inplace_xor
-  0,        //binaryfunc nb_inplace_or
-
-  0,        //binaryfunc nb_floor_divide
-  0,        //binaryfunc nb_true_divide
-  0,        //binaryfunc nb_inplace_floor_divide
-  0,        //binaryfunc nb_inplace_true_divide
-
-  0,        //unaryfunc nb_index
-
-  0,        //binaryfunc nb_matrix_multiply
-  0         //binaryfunc nb_inplace_matrix_multiply
-};
-
-PyMappingMethods PyOpenSCADMapping =
-{
-  0,
-  python__getitem__,
-  python__setitem__
+                        OO_METHOD_ENTRY(color, "Color Object") OO_METHOD_ENTRY(
+                            linear_extrude, "Linear_extrude Object")
+                            OO_METHOD_ENTRY(rotate_extrude,
+                                            "Rotate_extrude Object")
+                                OO_METHOD_ENTRY(resize, "Resize Object")
+
+                                    OO_METHOD_ENTRY(mesh, "Mesh Object")
+                                        OO_METHOD_ENTRY(
+                                            align, "Align Object to another")
+
+                                            OO_METHOD_ENTRY(show, "Show Object")
+                                                OO_METHOD_ENTRY(
+                                                    projection,
+                                                    "Projection Object")
+                                                    OO_METHOD_ENTRY(
+                                                        render,
+                                                        "Render Object"){
+                                                        NULL, NULL, 0, NULL}};
+
+PyNumberMethods PyOpenSCADNumbers = {
+    python_nb_add,      // binaryfunc nb_add
+    python_nb_subtract, // binaryfunc nb_subtract
+    python_nb_mul,      // binaryfunc nb_multiply
+    0,                  // binaryfunc nb_remainder
+    0,                  // binaryfunc nb_divmod
+    0,                  // ternaryfunc nb_power
+    0,                  // unaryfunc nb_negative
+    0,                  // unaryfunc nb_positive
+    0,                  // unaryfunc nb_absolute
+    0,                  // inquiry nb_bool
+    0,                  // unaryfunc nb_invert
+    0,                  // binaryfunc nb_lshift
+    0,                  // binaryfunc nb_rshift
+    python_nb_and,      // binaryfunc nb_and
+    0,                  // binaryfunc nb_xor
+    python_nb_or,       // binaryfunc nb_or
+    0,                  // unaryfunc nb_int
+    0,                  // void *nb_reserved
+    0,                  // unaryfunc nb_float
+
+    0, // binaryfunc nb_inplace_add
+    0, // binaryfunc nb_inplace_subtract
+    0, // binaryfunc nb_inplace_multiply
+    0, // binaryfunc nb_inplace_remainder
+    0, // ternaryfunc nb_inplace_power
+    0, // binaryfunc nb_inplace_lshift
+    0, // binaryfunc nb_inplace_rshift
+    0, // binaryfunc nb_inplace_and
+    0, // binaryfunc nb_inplace_xor
+    0, // binaryfunc nb_inplace_or
+
+    0, // binaryfunc nb_floor_divide
+    0, // binaryfunc nb_true_divide
+    0, // binaryfunc nb_inplace_floor_divide
+    0, // binaryfunc nb_inplace_true_divide
+
+    0, // unaryfunc nb_index
+
+    0, // binaryfunc nb_matrix_multiply
+    0  // binaryfunc nb_inplace_matrix_multiply
 };
 
+PyMappingMethods PyOpenSCADMapping = {0, python__getitem__, python__setitem__};
diff --git a/src/python/pymod.cc b/src/python/pymod.cc
index 57fa81458..0f27b6e19 100644
--- a/src/python/pymod.cc
+++ b/src/python/pymod.cc
@@ -25,10 +25,10 @@
  */
 #include <Python.h>
 
-#include <string>
-#include <vector>
 #include <cstdlib>
 #include <filesystem>
+#include <string>
+#include <vector>
 
 #include "core/Settings.h"
 #include "platform/PlatformUtils.h"
@@ -39,17 +39,15 @@ namespace fs = std::filesystem;
 
 using SP = Settings::SettingsPython;
 
-std::string venvBinDirFromSettings()
-{
-  const auto& venv = fs::path(SP::pythonVirtualEnv.value()) / "bin";
+std::string venvBinDirFromSettings() {
+  const auto &venv = fs::path(SP::pythonVirtualEnv.value()) / "bin";
   if (fs::is_directory(venv)) {
     return venv.generic_string();
   }
   return "";
 }
 
-int pythonRunArgs(int argc, char **argv)
-{
+int pythonRunArgs(int argc, char **argv) {
   PyStatus status;
 
   PyConfig config;
@@ -76,9 +74,8 @@ fail:
   Py_ExitStatusException(status);
 }
 
-int pythonCreateVenv(const std::string& path)
-{
-  int result = pythonRunModule("", "venv", { path });
+int pythonCreateVenv(const std::string &path) {
+  int result = pythonRunModule("", "venv", {path});
   if (result != 0) {
     return result;
   }
@@ -112,9 +109,8 @@ int pythonCreateVenv(const std::string& path)
   return 0;
 }
 
-int pythonRunModule(const std::string& appPath, const std::string& module,
-                    const std::vector<std::string>& args)
-{
+int pythonRunModule(const std::string &appPath, const std::string &module,
+                    const std::vector<std::string> &args) {
   PyStatus status;
   const auto name = "openscad-python";
   const auto exe = PlatformUtils::applicationPath() + "/" + name;
@@ -151,7 +147,7 @@ int pythonRunModule(const std::string& appPath, const std::string& module,
     goto done;
   }
 
-  for (const auto& arg : args) {
+  for (const auto &arg : args) {
     std::wstring warg(arg.size(), L' ');
     warg.resize(std::mbstowcs(&warg[0], arg.c_str(), arg.size()));
     status = PyWideStringList_Append(&config.argv, warg.c_str());
diff --git a/src/python/pyopenscad.cc b/src/python/pyopenscad.cc
index 71f522efb..cea6cc545 100644
--- a/src/python/pyopenscad.cc
+++ b/src/python/pyopenscad.cc
@@ -26,9 +26,9 @@
 #include <Python.h>
 #include <filesystem>
 
-#include "pyopenscad.h"
 #include "core/CsgOpNode.h"
 #include "platform/PlatformUtils.h"
+#include "pyopenscad.h"
 
 namespace fs = std::filesystem;
 
@@ -43,25 +43,24 @@ PyObjectUniquePtr pythonInitDict(nullptr, PyObjectDeleter);
 PyObjectUniquePtr pythonMainModule(nullptr, PyObjectDeleter);
 std::list<std::string> pythonInventory;
 bool pythonDryRun = false;
-std::shared_ptr<AbstractNode> python_result_node = nullptr; /* global result veriable containing the python created result */
+std::shared_ptr<AbstractNode> python_result_node =
+    nullptr; /* global result veriable containing the python created result */
 PyObject *python_result_obj = nullptr;
 bool pythonMainModuleInitialized = false;
 
-void PyOpenSCADObject_dealloc(PyOpenSCADObject *self)
-{
+void PyOpenSCADObject_dealloc(PyOpenSCADObject *self) {
   Py_XDECREF(self->dict);
   Py_TYPE(self)->tp_free((PyObject *)self);
 }
 
-PyObject *PyOpenSCADObject_alloc(PyTypeObject *cls, Py_ssize_t nitems)
-{
+PyObject *PyOpenSCADObject_alloc(PyTypeObject *cls, Py_ssize_t nitems) {
   PyObject *self = PyType_GenericAlloc(cls, nitems);
   ((PyOpenSCADObject *)self)->dict = PyDict_New();
   PyObject *origin = PyList_New(4);
   for (int i = 0; i < 4; i++) {
     PyObject *row = PyList_New(4);
     for (int j = 0; j < 4; j++)
-      PyList_SetItem(row, j, PyFloat_FromDouble(i == j?1.0:0.0));
+      PyList_SetItem(row, j, PyFloat_FromDouble(i == j ? 1.0 : 0.0));
     PyList_SetItem(origin, i, row);
   }
   PyDict_SetItemString(((PyOpenSCADObject *)self)->dict, "origin", origin);
@@ -73,8 +72,8 @@ PyObject *PyOpenSCADObject_alloc(PyTypeObject *cls, Py_ssize_t nitems)
  *  allocates a new PyOpenSCAD Object including its internal dictionary
  */
 
-static PyObject *PyOpenSCADObject_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
-{
+static PyObject *PyOpenSCADObject_new(PyTypeObject *type, PyObject *args,
+                                      PyObject *kwds) {
   return PyOpenSCADObject_alloc(&PyOpenSCADType, 0);
 }
 
@@ -82,10 +81,10 @@ static PyObject *PyOpenSCADObject_new(PyTypeObject *type, PyObject *args, PyObje
  *  allocates a new PyOpenSCAD to store an existing OpenSCAD Abstract Node
  */
 
-PyObject *PyOpenSCADObjectFromNode(PyTypeObject *type, const std::shared_ptr<AbstractNode>& node)
-{
+PyObject *PyOpenSCADObjectFromNode(PyTypeObject *type,
+                                   const std::shared_ptr<AbstractNode> &node) {
   PyOpenSCADObject *self;
-  self = (PyOpenSCADObject *)  type->tp_alloc(type, 0);
+  self = (PyOpenSCADObject *)type->tp_alloc(type, 0);
   if (self != nullptr) {
     Py_XINCREF(self);
     self->node = node;
@@ -96,47 +95,50 @@ PyObject *PyOpenSCADObjectFromNode(PyTypeObject *type, const std::shared_ptr<Abs
 
 PyThreadState *tstate = nullptr;
 
-void python_lock(void){
-  if (tstate != nullptr && pythonInitDict != nullptr)PyEval_RestoreThread(tstate);
+void python_lock(void) {
+  if (tstate != nullptr && pythonInitDict != nullptr)
+    PyEval_RestoreThread(tstate);
 }
 
 void python_unlock(void) {
-  if (pythonInitDict != nullptr)tstate = PyEval_SaveThread();
+  if (pythonInitDict != nullptr)
+    tstate = PyEval_SaveThread();
 }
 /*
  *  extracts Absrtract Node from PyOpenSCAD Object
  */
 
-std::shared_ptr<AbstractNode> PyOpenSCADObjectToNode(PyObject *obj, PyObject **dict)
-{
-  std::shared_ptr<AbstractNode> result = ((PyOpenSCADObject *) obj)->node;
+std::shared_ptr<AbstractNode> PyOpenSCADObjectToNode(PyObject *obj,
+                                                     PyObject **dict) {
+  std::shared_ptr<AbstractNode> result = ((PyOpenSCADObject *)obj)->node;
   if (result.use_count() > 2) {
     result = result->clone();
   }
-  *dict = ((PyOpenSCADObject *) obj)->dict;
+  *dict = ((PyOpenSCADObject *)obj)->dict;
   return result;
 }
 
-std::string python_version(void)
-{
+std::string python_version(void) {
   std::ostringstream stream;
-  stream << "Python " << PY_MAJOR_VERSION << "." << PY_MINOR_VERSION << "." << PY_MICRO_VERSION;
+  stream << "Python " << PY_MAJOR_VERSION << "." << PY_MINOR_VERSION << "."
+         << PY_MICRO_VERSION;
   return stream.str();
 }
 
 /*
- * same as  python_more_obj but always returns only one AbstractNode by creating an UNION operation
+ * same as  python_more_obj but always returns only one AbstractNode by creating
+ * an UNION operation
  */
 
-std::shared_ptr<AbstractNode> PyOpenSCADObjectToNodeMulti(PyObject *objs, PyObject **dict)
-{
+std::shared_ptr<AbstractNode> PyOpenSCADObjectToNodeMulti(PyObject *objs,
+                                                          PyObject **dict) {
   std::shared_ptr<AbstractNode> result;
   if (Py_TYPE(objs) == &PyOpenSCADType) {
-    result = ((PyOpenSCADObject *) objs)->node;
+    result = ((PyOpenSCADObject *)objs)->node;
     if (result.use_count() > 2) {
       result = result->clone();
     }
-    *dict = ((PyOpenSCADObject *) objs)->dict;
+    *dict = ((PyOpenSCADObject *)objs)->dict;
   } else if (PyList_Check(objs)) {
     DECLARE_INSTANCE
     auto node = std::make_shared<CsgOpNode>(instance, OpenSCADOperator::UNION);
@@ -147,20 +149,24 @@ std::shared_ptr<AbstractNode> PyOpenSCADObjectToNodeMulti(PyObject *objs, PyObje
       if (Py_TYPE(obj) == &PyOpenSCADType) {
         std::shared_ptr<AbstractNode> child = PyOpenSCADObjectToNode(obj, dict);
         node->children.push_back(child);
-      } else return nullptr;
+      } else
+        return nullptr;
     }
     result = node;
-  } else result = nullptr;
+  } else
+    result = nullptr;
   return result;
 }
 
-
-int python_numberval(PyObject *number, double *result)
-{
-  if (number == nullptr)return 1;
-  if (number == Py_False)return 1;
-  if (number == Py_True)return 1;
-  if (number == Py_None)return 1;
+int python_numberval(PyObject *number, double *result) {
+  if (number == nullptr)
+    return 1;
+  if (number == Py_False)
+    return 1;
+  if (number == Py_True)
+    return 1;
+  if (number == Py_None)
+    return 1;
   if (PyFloat_Check(number)) {
     *result = PyFloat_AsDouble(number);
     return 0;
@@ -176,44 +182,51 @@ int python_numberval(PyObject *number, double *result)
  * Tries to extract an 3D vector out of a python list
  */
 
-int python_vectorval(PyObject *vec, int minval, int maxval, double *x, double *y, double *z, double *w)
-{
-  if (w != NULL) *w = 0;
+int python_vectorval(PyObject *vec, int minval, int maxval, double *x,
+                     double *y, double *z, double *w) {
+  if (w != NULL)
+    *w = 0;
   if (PyList_Check(vec)) {
-    if (PyList_Size(vec) < minval || PyList_Size(vec) > maxval)return 1;
+    if (PyList_Size(vec) < minval || PyList_Size(vec) > maxval)
+      return 1;
 
     if (PyList_Size(vec) >= 1) {
-      if (python_numberval(PyList_GetItem(vec, 0), x)) return 1;
+      if (python_numberval(PyList_GetItem(vec, 0), x))
+        return 1;
     }
     if (PyList_Size(vec) >= 2) {
-      if (python_numberval(PyList_GetItem(vec, 1), y)) return 1;
+      if (python_numberval(PyList_GetItem(vec, 1), y))
+        return 1;
     }
     if (PyList_Size(vec) >= 3) {
-      if (python_numberval(PyList_GetItem(vec, 2), z)) return 1;
+      if (python_numberval(PyList_GetItem(vec, 2), z))
+        return 1;
     }
     if (PyList_Size(vec) >= 4 && w != NULL) {
-      if (python_numberval(PyList_GetItem(vec, 3), w)) return 1;
+      if (python_numberval(PyList_GetItem(vec, 3), w))
+        return 1;
     }
     return 0;
   }
   if (!python_numberval(vec, x)) {
     *y = *x;
     *z = *x;
-    if (w != NULL)*w = *x;
+    if (w != NULL)
+      *w = *x;
     return 0;
   }
   return 1;
 }
 
-std::vector<Vector3d> python_vectors(PyObject *vec, int mindim, int maxdim)
-{
+std::vector<Vector3d> python_vectors(PyObject *vec, int mindim, int maxdim) {
   std::vector<Vector3d> results;
   if (PyList_Check(vec)) {
     // check if its a valid vec<Vector3d>
     int valid = 1;
     for (int i = 0; valid && i < PyList_Size(vec); i++) {
       PyObject *item = PyList_GetItem(vec, i);
-      if (!PyList_Check(item))valid = 0;
+      if (!PyList_Check(item))
+        valid = 0;
     }
     if (valid) {
       for (int j = 0; valid && j < PyList_Size(vec); j++) {
@@ -222,7 +235,8 @@ std::vector<Vector3d> python_vectors(PyObject *vec, int mindim, int maxdim)
         if (PyList_Size(item) >= mindim && PyList_Size(item) <= maxdim) {
           for (int i = 0; i < PyList_Size(item); i++) {
             if (PyList_Size(item) > i) {
-              if (python_numberval(PyList_GetItem(item, i), &result[i])) return results; // Error
+              if (python_numberval(PyList_GetItem(item, i), &result[i]))
+                return results; // Error
             }
           }
         }
@@ -234,7 +248,8 @@ std::vector<Vector3d> python_vectors(PyObject *vec, int mindim, int maxdim)
     if (PyList_Size(vec) >= mindim && PyList_Size(vec) <= maxdim) {
       for (int i = 0; i < PyList_Size(vec); i++) {
         if (PyList_Size(vec) > i) {
-          if (python_numberval(PyList_GetItem(vec, i), &result[i])) return results; // Error
+          if (python_numberval(PyList_GetItem(vec, i), &result[i]))
+            return results; // Error
         }
       }
     }
@@ -253,30 +268,34 @@ std::vector<Vector3d> python_vectors(PyObject *vec, int mindim, int maxdim)
  * Helper function to extract actual values for fn, fa and fs
  */
 
-void get_fnas(double& fn, double& fa, double& fs) {
+void get_fnas(double &fn, double &fa, double &fs) {
   PyObject *mainModule = PyImport_AddModule("__main__");
-  if (mainModule == nullptr) return;
+  if (mainModule == nullptr)
+    return;
   fn = 0;
   fa = 12;
   fs = 2;
 
   if (PyObject_HasAttrString(mainModule, "fn")) {
-    PyObjectUniquePtr varFn(PyObject_GetAttrString(mainModule, "fn"), PyObjectDeleter);
-    if (varFn.get() != nullptr){
+    PyObjectUniquePtr varFn(PyObject_GetAttrString(mainModule, "fn"),
+                            PyObjectDeleter);
+    if (varFn.get() != nullptr) {
       fn = PyFloat_AsDouble(varFn.get());
     }
   }
 
   if (PyObject_HasAttrString(mainModule, "fa")) {
-    PyObjectUniquePtr varFa(PyObject_GetAttrString(mainModule, "fa"), PyObjectDeleter);
-    if (varFa.get() != nullptr){
+    PyObjectUniquePtr varFa(PyObject_GetAttrString(mainModule, "fa"),
+                            PyObjectDeleter);
+    if (varFa.get() != nullptr) {
       fa = PyFloat_AsDouble(varFa.get());
     }
   }
 
-  PyObjectUniquePtr varFs(PyObject_GetAttrString(mainModule, "fs"), PyObjectDeleter);
+  PyObjectUniquePtr varFs(PyObject_GetAttrString(mainModule, "fs"),
+                          PyObjectDeleter);
   if (PyObject_HasAttrString(mainModule, "fs")) {
-    if (varFs.get() != nullptr){
+    if (varFs.get() != nullptr) {
       fs = PyFloat_AsDouble(varFs.get());
     }
   }
@@ -286,28 +305,31 @@ void get_fnas(double& fn, double& fa, double& fs) {
  * Type specific init function. nothing special here
  */
 
-static int PyOpenSCADInit(PyOpenSCADObject *self, PyObject *args, PyObject *kwds)
-{
+static int PyOpenSCADInit(PyOpenSCADObject *self, PyObject *args,
+                          PyObject *kwds) {
   (void)self;
   (void)args;
   (void)kwds;
   return 0;
 }
 
-void python_catch_error(std::string& errorstr)
-{
+void python_catch_error(std::string &errorstr) {
   PyObject *pyExcType;
   PyObject *pyExcValue;
   PyObject *pyExcTraceback;
   PyErr_Fetch(&pyExcType, &pyExcValue, &pyExcTraceback);
   PyErr_NormalizeException(&pyExcType, &pyExcValue, &pyExcTraceback);
-  if (pyExcType != nullptr) Py_XDECREF(pyExcType);
+  if (pyExcType != nullptr)
+    Py_XDECREF(pyExcType);
 
-  if (pyExcValue != nullptr){
+  if (pyExcValue != nullptr) {
     PyObjectUniquePtr str_exc_value(PyObject_Repr(pyExcValue), PyObjectDeleter);
-    PyObjectUniquePtr pyExcValueStr(PyUnicode_AsEncodedString(str_exc_value.get(), "utf-8", "~"), PyObjectDeleter);
+    PyObjectUniquePtr pyExcValueStr(
+        PyUnicode_AsEncodedString(str_exc_value.get(), "utf-8", "~"),
+        PyObjectDeleter);
     char *suberror = PyBytes_AS_STRING(pyExcValueStr.get());
-    if (suberror != nullptr) errorstr += suberror;
+    if (suberror != nullptr)
+      errorstr += suberror;
     Py_XDECREF(pyExcValue);
   }
   if (pyExcTraceback != nullptr) {
@@ -319,8 +341,7 @@ void python_catch_error(std::string& errorstr)
   }
 }
 
-void initPython(const std::string& binDir, double time)
-{
+void initPython(const std::string &binDir, double time) {
   const auto name = "openscad-python";
   const auto exe = binDir + "/" + name;
   if (pythonInitDict) { /* If already initialized, undo to reinitialize after */
@@ -328,49 +349,68 @@ void initPython(const std::string& binDir, double time)
     Py_ssize_t pos = 0;
     PyObject *maindict = PyModule_GetDict(pythonMainModule.get());
     while (PyDict_Next(maindict, &pos, &key, &value)) {
-      PyObjectUniquePtr key_(PyUnicode_AsEncodedString(key, "utf-8", "~"), PyObjectDeleter);
-      if (key_ == nullptr)continue;
+      PyObjectUniquePtr key_(PyUnicode_AsEncodedString(key, "utf-8", "~"),
+                             PyObjectDeleter);
+      if (key_ == nullptr)
+        continue;
       const char *key_str = PyBytes_AS_STRING(key_.get());
-      if (key_str == nullptr)continue;
-      if (std::find(std::begin(pythonInventory), std::end(pythonInventory), key_str) == std::end(pythonInventory)){
-        if (strlen(key_str) < 4 || strncmp(key_str, "stat", 4) != 0){
+      if (key_str == nullptr)
+        continue;
+      if (std::find(std::begin(pythonInventory), std::end(pythonInventory),
+                    key_str) == std::end(pythonInventory)) {
+        if (strlen(key_str) < 4 || strncmp(key_str, "stat", 4) != 0) {
           PyDict_DelItemString(maindict, key_str);
         }
       }
       // bug in  PyDict_GetItemString, thus iterating
       if (strcmp(key_str, "sys") == 0) {
         PyObject *sysdict = PyModule_GetDict(value);
-        if (sysdict == nullptr) continue;
+        if (sysdict == nullptr)
+          continue;
         // get builtin_module_names
         PyObject *key1, *value1;
         Py_ssize_t pos1 = 0;
         while (PyDict_Next(sysdict, &pos1, &key1, &value1)) {
-          PyObjectUniquePtr key1_(PyUnicode_AsEncodedString(key1, "utf-8", "~"), PyObjectDeleter);
-          if (key1_ == nullptr)continue;
+          PyObjectUniquePtr key1_(PyUnicode_AsEncodedString(key1, "utf-8", "~"),
+                                  PyObjectDeleter);
+          if (key1_ == nullptr)
+            continue;
           const char *key1_str = PyBytes_AS_STRING(key1_.get());
           if (strcmp(key1_str, "modules") == 0) {
             PyObject *key2, *value2;
             Py_ssize_t pos2 = 0;
             while (PyDict_Next(value1, &pos2, &key2, &value2)) {
-              PyObjectUniquePtr key2_(PyUnicode_AsEncodedString(key2, "utf-8", "~"), PyObjectDeleter);
-              if (key2_ == nullptr)continue;
+              PyObjectUniquePtr key2_(
+                  PyUnicode_AsEncodedString(key2, "utf-8", "~"),
+                  PyObjectDeleter);
+              if (key2_ == nullptr)
+                continue;
               const char *key2_str = PyBytes_AS_STRING(key2_.get());
-              if (key2_str == nullptr) continue;
-              if (!PyModule_Check(value2)) continue;
+              if (key2_str == nullptr)
+                continue;
+              if (!PyModule_Check(value2))
+                continue;
 
               PyObject *modrepr = PyObject_Repr(value2);
-              PyObject *modreprobj = PyUnicode_AsEncodedString(modrepr, "utf-8", "~");
+              PyObject *modreprobj =
+                  PyUnicode_AsEncodedString(modrepr, "utf-8", "~");
               const char *modreprstr = PyBytes_AS_STRING(modreprobj);
-              if (modreprstr == nullptr) continue;
-              if (strstr(modreprstr, "(frozen)") != nullptr) continue;
-              if (strstr(modreprstr, "(built-in)") != nullptr) continue;
-              if (strstr(modreprstr, "/encodings/") != nullptr) continue;
-              if (strstr(modreprstr, "_frozen_") != nullptr) continue;
-              if (strstr(modreprstr, "site-packages") != nullptr) continue;
-              if (strstr(modreprstr, "usr/lib") != nullptr) continue;
+              if (modreprstr == nullptr)
+                continue;
+              if (strstr(modreprstr, "(frozen)") != nullptr)
+                continue;
+              if (strstr(modreprstr, "(built-in)") != nullptr)
+                continue;
+              if (strstr(modreprstr, "/encodings/") != nullptr)
+                continue;
+              if (strstr(modreprstr, "_frozen_") != nullptr)
+                continue;
+              if (strstr(modreprstr, "site-packages") != nullptr)
+                continue;
+              if (strstr(modreprstr, "usr/lib") != nullptr)
+                continue;
 
               PyDict_DelItem(value1, key2);
-
             }
           }
         }
@@ -380,7 +420,8 @@ void initPython(const std::string& binDir, double time)
     PyPreConfig preconfig;
     PyPreConfig_InitPythonConfig(&preconfig);
     Py_PreInitialize(&preconfig);
-//    PyEval_InitThreads(); // https://stackoverflow.com/questions/47167251/pygilstate-ensure-causing-deadlock
+    //    PyEval_InitThreads(); //
+    //    https://stackoverflow.com/questions/47167251/pygilstate-ensure-causing-deadlock
 
     PyImport_AppendInittab("openscad", &PyInit_openscad);
     PyConfig config;
@@ -394,16 +435,18 @@ void initPython(const std::string& binDir, double time)
     stream << PlatformUtils::applicationPath() << "\\..\\libraries\\python";
 #else
     char sepchar = ':';
-    const auto pythonXY = "python" + std::to_string(PY_MAJOR_VERSION) + "." + std::to_string(PY_MINOR_VERSION);
+    const auto pythonXY = "python" + std::to_string(PY_MAJOR_VERSION) + "." +
+                          std::to_string(PY_MINOR_VERSION);
     const std::array<std::string, 5> paths = {
-      "../libraries/python",
-      "../lib/" + pythonXY,
-      "../python/lib/" + pythonXY,
-      "../Frameworks/" + pythonXY,
-      "../Frameworks/" + pythonXY + "/site-packages",
+        "../libraries/python",
+        "../lib/" + pythonXY,
+        "../python/lib/" + pythonXY,
+        "../Frameworks/" + pythonXY,
+        "../Frameworks/" + pythonXY + "/site-packages",
     };
-    for (const auto& path : paths) {
-      const auto p = fs::path(PlatformUtils::applicationPath() + fs::path::preferred_separator + path);
+    for (const auto &path : paths) {
+      const auto p = fs::path(PlatformUtils::applicationPath() +
+                              fs::path::preferred_separator + path);
       if (fs::is_directory(p)) {
         stream << sep << fs::absolute(p).generic_string();
         sep = sepchar;
@@ -427,35 +470,37 @@ void initPython(const std::string& binDir, double time)
     pythonMainModuleInitialized = pythonMainModule != nullptr;
     pythonInitDict.reset(PyModule_GetDict(pythonMainModule.get()));
     PyInit_PyOpenSCAD();
-    PyRun_String("from builtins import *\n", Py_file_input, pythonInitDict.get(), pythonInitDict.get());
+    PyRun_String("from builtins import *\n", Py_file_input,
+                 pythonInitDict.get(), pythonInitDict.get());
     PyObject *key, *value;
     Py_ssize_t pos = 0;
     PyObject *maindict = PyModule_GetDict(pythonMainModule.get());
     while (PyDict_Next(maindict, &pos, &key, &value)) {
-      PyObjectUniquePtr key1(PyUnicode_AsEncodedString(key, "utf-8", "~"), PyObjectDeleter);
+      PyObjectUniquePtr key1(PyUnicode_AsEncodedString(key, "utf-8", "~"),
+                             PyObjectDeleter);
       const char *key_str = PyBytes_AsString(key1.get());
-      if (key_str != NULL)pythonInventory.push_back(key_str);
+      if (key_str != NULL)
+        pythonInventory.push_back(key_str);
     }
-
   }
   std::ostringstream stream;
   stream << "t=" << time;
-  PyRun_String(stream.str().c_str(), Py_file_input, pythonInitDict.get(), pythonInitDict.get());
+  PyRun_String(stream.str().c_str(), Py_file_input, pythonInitDict.get(),
+               pythonInitDict.get());
 }
 
-void finishPython(void)
-{
-}
+void finishPython(void) {}
 
-std::string evaluatePython(const std::string& code, bool dry_run)
-{
+std::string evaluatePython(const std::string &code, bool dry_run) {
   std::string error;
   python_result_node = nullptr;
   PyObjectUniquePtr pyExcValue(nullptr, PyObjectDeleter);
   PyObjectUniquePtr pyExcTraceback(nullptr, PyObjectDeleter);
-  /* special python code to catch errors from stdout and stderr and make them available in OpenSCAD console */
+  /* special python code to catch errors from stdout and stderr and make them
+   * available in OpenSCAD console */
   pythonDryRun = dry_run;
-  if (!pythonMainModuleInitialized)return "Python not initialized";
+  if (!pythonMainModuleInitialized)
+    return "Python not initialized";
   const char *python_init_code = "\
 import sys\n\
 class InputCatcher:\n\
@@ -492,118 +537,121 @@ sys.stderr = stderr_bak\n\
 
   PyRun_SimpleString(python_init_code);
   PyObjectUniquePtr result(nullptr, PyObjectDeleter);
-  result.reset(PyRun_String(code.c_str(), Py_file_input, pythonInitDict.get(), pythonInitDict.get()));   /* actual code is run here */
-
+  result.reset(
+      PyRun_String(code.c_str(), Py_file_input, pythonInitDict.get(),
+                   pythonInitDict.get())); /* actual code is run here */
 
   if (result == nullptr) {
     PyErr_Print();
     error = "";
     python_catch_error(error);
   }
-  for (int i = 0; i < 2; i++){
+  for (int i = 0; i < 2; i++) {
     PyObjectUniquePtr catcher(nullptr, PyObjectDeleter);
-    catcher.reset(PyObject_GetAttrString(pythonMainModule.get(), i == 1?"catcher_err":"catcher_out"));
-    if (catcher == nullptr) continue;
+    catcher.reset(PyObject_GetAttrString(
+        pythonMainModule.get(), i == 1 ? "catcher_err" : "catcher_out"));
+    if (catcher == nullptr)
+      continue;
     PyObjectUniquePtr command_output(nullptr, PyObjectDeleter);
     command_output.reset(PyObject_GetAttrString(catcher.get(), "data"));
 
-    PyObjectUniquePtr command_output_value(nullptr,  PyObjectDeleter);
-    command_output_value.reset(PyUnicode_AsEncodedString(command_output.get(), "utf-8", "~"));
-    const char *command_output_bytes = PyBytes_AS_STRING(command_output_value.get());
-    if (command_output_bytes != nullptr && *command_output_bytes != '\0'){
-      if (i == 1) error += command_output_bytes; /* output to console */
-      else LOG(command_output_bytes);   /* error to LOG */
+    PyObjectUniquePtr command_output_value(nullptr, PyObjectDeleter);
+    command_output_value.reset(
+        PyUnicode_AsEncodedString(command_output.get(), "utf-8", "~"));
+    const char *command_output_bytes =
+        PyBytes_AS_STRING(command_output_value.get());
+    if (command_output_bytes != nullptr && *command_output_bytes != '\0') {
+      if (i == 1)
+        error += command_output_bytes; /* output to console */
+      else
+        LOG(command_output_bytes); /* error to LOG */
     }
   }
   PyRun_SimpleString(python_exit_code);
   return error;
 }
 /*
- * the magical Python Type descriptor for an OpenSCAD Object. Adding more fields makes the type more powerful
+ * the magical Python Type descriptor for an OpenSCAD Object. Adding more fields
+ * makes the type more powerful
  */
 
-
 int python__setitem__(PyObject *dict, PyObject *key, PyObject *v);
 PyObject *python__getitem__(PyObject *dict, PyObject *key);
 
-PyObject *python__getattro__(PyObject *dict, PyObject *key)
-{
+PyObject *python__getattro__(PyObject *dict, PyObject *key) {
   PyObject *result = python__getitem__(dict, key);
-  if (result == Py_None || result == nullptr) result = PyObject_GenericGetAttr(dict, key);
+  if (result == Py_None || result == nullptr)
+    result = PyObject_GenericGetAttr(dict, key);
   return result;
 }
 
-int python__setattro__(PyObject *dict, PyObject *key, PyObject *v)
-{
+int python__setattro__(PyObject *dict, PyObject *key, PyObject *v) {
   return python__setitem__(dict, key, v);
 }
 
-
 PyTypeObject PyOpenSCADType = {
-  PyVarObject_HEAD_INIT(nullptr, 0)
-  "PyOpenSCAD",                     /* tp_name */
-  sizeof(PyOpenSCADObject),         /* tp_basicsize */
-  0,                                /* tp_itemsize */
-  (destructor) PyOpenSCADObject_dealloc,    /* tp_dealloc */
-  0,                                /* vectorcall_offset */
-  0,                                /* tp_getattr */
-  0,                                /* tp_setattr */
-  0,                                /* tp_as_async */
-  python_str,                       /* tp_repr */
-  &PyOpenSCADNumbers,               /* tp_as_number */
-  0,                                /* tp_as_sequence */
-  &PyOpenSCADMapping,               /* tp_as_mapping */
-  0,                                /* tp_hash  */
-  0,                                /* tp_call */
-  python_str,                       /* tp_str */
-  python__getattro__,             /* tp_getattro */
-  python__setattro__,         /* tp_setattro */
-  0,                                /* tp_as_buffer */
-  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
-  "PyOpenSCAD Object",                /* tp_doc */
-  0,                                /* tp_traverse */
-  0,                                /* tp_clear */
-  0,                                /* tp_richcompare */
-  0,                                /* tp_weaklistoffset */
-  0,                                /* tp_iter */
-  0,                                /* tp_iternext */
-  PyOpenSCADMethods,                  /* tp_methods */
-  0,                      /* tp_members */
-  0,                                /* tp_getset */
-  0,                                /* tp_base */
-  0,                                /* tp_dict */
-  0,                                /* tp_descr_get */
-  0,                                /* tp_descr_set */
-  0,                                /* tp_dictoffset */
-  (initproc) PyOpenSCADInit,            /* tp_init */
-  PyOpenSCADObject_alloc,           /* tp_alloc */
-  PyOpenSCADObject_new,                   /* tp_new */
-};
-
-
-
-static PyModuleDef OpenSCADModule = {
-  PyModuleDef_HEAD_INIT,
-  "openscad",
-  "OpenSCAD Python Module",
-  -1,
-  PyOpenSCADFunctions,
-  NULL, NULL, NULL, NULL
+    PyVarObject_HEAD_INIT(nullptr, 0) "PyOpenSCAD", /* tp_name */
+    sizeof(PyOpenSCADObject),                       /* tp_basicsize */
+    0,                                              /* tp_itemsize */
+    (destructor)PyOpenSCADObject_dealloc,           /* tp_dealloc */
+    0,                                              /* vectorcall_offset */
+    0,                                              /* tp_getattr */
+    0,                                              /* tp_setattr */
+    0,                                              /* tp_as_async */
+    python_str,                                     /* tp_repr */
+    &PyOpenSCADNumbers,                             /* tp_as_number */
+    0,                                              /* tp_as_sequence */
+    &PyOpenSCADMapping,                             /* tp_as_mapping */
+    0,                                              /* tp_hash  */
+    0,                                              /* tp_call */
+    python_str,                                     /* tp_str */
+    python__getattro__,                             /* tp_getattro */
+    python__setattro__,                             /* tp_setattro */
+    0,                                              /* tp_as_buffer */
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,       /* tp_flags */
+    "PyOpenSCAD Object",                            /* tp_doc */
+    0,                                              /* tp_traverse */
+    0,                                              /* tp_clear */
+    0,                                              /* tp_richcompare */
+    0,                                              /* tp_weaklistoffset */
+    0,                                              /* tp_iter */
+    0,                                              /* tp_iternext */
+    PyOpenSCADMethods,                              /* tp_methods */
+    0,                                              /* tp_members */
+    0,                                              /* tp_getset */
+    0,                                              /* tp_base */
+    0,                                              /* tp_dict */
+    0,                                              /* tp_descr_get */
+    0,                                              /* tp_descr_set */
+    0,                                              /* tp_dictoffset */
+    (initproc)PyOpenSCADInit,                       /* tp_init */
+    PyOpenSCADObject_alloc,                         /* tp_alloc */
+    PyOpenSCADObject_new,                           /* tp_new */
 };
 
-extern "C" PyObject *PyInit_openscad(void)
-{
+static PyModuleDef OpenSCADModule = {PyModuleDef_HEAD_INIT,
+                                     "openscad",
+                                     "OpenSCAD Python Module",
+                                     -1,
+                                     PyOpenSCADFunctions,
+                                     NULL,
+                                     NULL,
+                                     NULL,
+                                     NULL};
+
+extern "C" PyObject *PyInit_openscad(void) {
   return PyModule_Create(&OpenSCADModule);
 }
 
-PyMODINIT_FUNC PyInit_PyOpenSCAD(void)
-{
+PyMODINIT_FUNC PyInit_PyOpenSCAD(void) {
   PyObject *m;
 
-  if (PyType_Ready(&PyOpenSCADType) < 0) return NULL;
+  if (PyType_Ready(&PyOpenSCADType) < 0)
+    return NULL;
 
   m = PyInit_openscad();
-  if (m == NULL) return NULL;
+  if (m == NULL)
+    return NULL;
 
   Py_INCREF(&PyOpenSCADType);
   PyModule_AddObject(m, "openscad", (PyObject *)&PyOpenSCADType);
diff --git a/src/python/pyopenscad.h b/src/python/pyopenscad.h
index 53e05507b..5c202934d 100644
--- a/src/python/pyopenscad.h
+++ b/src/python/pyopenscad.h
@@ -1,44 +1,48 @@
-#include <Python.h>
-#include <memory>
-#include "python_public.h"
-#include "geometry/Polygon2d.h"
-#include "core/node.h"
-#include "core/function.h"
 #include "core/ScopeContext.h"
 #include "core/UserModule.h"
+#include "core/function.h"
+#include "core/node.h"
+#include "geometry/Polygon2d.h"
+#include "python_public.h"
+#include <Python.h>
+#include <memory>
 
 #pragma GCC diagnostic ignored "-Wwrite-strings"
 
-#define DECLARE_INSTANCE  std::string instance_name; \
-        AssignmentList inst_asslist; \
-        ModuleInstantiation *instance = new ModuleInstantiation(instance_name, inst_asslist, Location::NONE);
-
+#define DECLARE_INSTANCE                                                       \
+  std::string instance_name;                                                   \
+  AssignmentList inst_asslist;                                                 \
+  ModuleInstantiation *instance =                                              \
+      new ModuleInstantiation(instance_name, inst_asslist, Location::NONE);
 
 typedef struct {
-  PyObject_HEAD
-  std::shared_ptr<AbstractNode> node;
+  PyObject_HEAD std::shared_ptr<AbstractNode> node;
   PyObject *dict;
   /* Type-specific fields go here. */
 } PyOpenSCADObject;
 
 void PyObjectDeleter(PyObject *pObject);
-using PyObjectUniquePtr = std::unique_ptr<PyObject, decltype(PyObjectDeleter )&>;
+using PyObjectUniquePtr =
+    std::unique_ptr<PyObject, decltype(PyObjectDeleter) &>;
 
 PyMODINIT_FUNC PyInit_PyOpenSCAD(void);
-int python_vectorval(PyObject *vec, int minarg, int maxarg, double *x, double *y, double *z, double *w = NULL);
-PyObject *PyOpenSCADObjectFromNode(PyTypeObject *type, const std::shared_ptr<AbstractNode>& node);
+int python_vectorval(PyObject *vec, int minarg, int maxarg, double *x,
+                     double *y, double *z, double *w = NULL);
+PyObject *PyOpenSCADObjectFromNode(PyTypeObject *type,
+                                   const std::shared_ptr<AbstractNode> &node);
 std::shared_ptr<AbstractNode> PyOpenSCADObjectToNode(PyObject *object);
 
-
 extern PyTypeObject PyOpenSCADType;
 extern std::shared_ptr<AbstractNode> python_result_node;
-std::shared_ptr<AbstractNode> PyOpenSCADObjectToNode(PyObject *object, PyObject **dict);
-std::shared_ptr<AbstractNode> PyOpenSCADObjectToNodeMulti(PyObject *object, PyObject **dict);
+std::shared_ptr<AbstractNode> PyOpenSCADObjectToNode(PyObject *object,
+                                                     PyObject **dict);
+std::shared_ptr<AbstractNode> PyOpenSCADObjectToNodeMulti(PyObject *object,
+                                                          PyObject **dict);
 extern std::string trusted_edit_document_name;
 extern std::string untrusted_edit_document_name;
 std::vector<Vector3d> python_vectors(PyObject *vec, int mindim, int maxdim);
 int python_numberval(PyObject *number, double *result);
-void get_fnas(double& fn, double& fa, double& fs);
+void get_fnas(double &fn, double &fa, double &fs);
 PyObject *python_str(PyObject *self);
 
 extern PyNumberMethods PyOpenSCADNumbers;
diff --git a/src/python/python_public.h b/src/python/python_public.h
index e7c8f8288..667ad1fa1 100644
--- a/src/python/python_public.h
+++ b/src/python/python_public.h
@@ -5,8 +5,8 @@ extern bool python_active;
 extern bool python_trusted;
 std::string python_version(void);
 
-void initPython(const std::string& binDir, double time);
-std::string evaluatePython(const std::string& code, bool dry_run = 0);
+void initPython(const std::string &binDir, double time);
+std::string evaluatePython(const std::string &code, bool dry_run = 0);
 void finishPython();
 void python_lock(void);
 void python_unlock(void);
@@ -14,6 +14,7 @@ void python_unlock(void);
 extern std::shared_ptr<AbstractNode> python_result_node;
 
 int pythonRunArgs(int argc, char **argv);
-int pythonCreateVenv(const std::string& path);
-int pythonRunModule(const std::string& appPath, const std::string& module, const std::vector<std::string>& args);
+int pythonCreateVenv(const std::string &path);
+int pythonRunModule(const std::string &appPath, const std::string &module,
+                    const std::vector<std::string> &args);
 std::string venvBinDirFromSettings();
diff --git a/src/utils/StackCheck.h b/src/utils/StackCheck.h
index 76be28b4f..b0ea2ac09 100644
--- a/src/utils/StackCheck.h
+++ b/src/utils/StackCheck.h
@@ -1,13 +1,11 @@
 #pragma once
 
-#include <cstdlib>
 #include "platform/PlatformUtils.h"
+#include <cstdlib>
 
-class StackCheck
-{
+class StackCheck {
 public:
-  static StackCheck& inst()
-  {
+  static StackCheck &inst() {
     static StackCheck instance;
     return instance;
   }
diff --git a/src/utils/boost-utils.h b/src/utils/boost-utils.h
index 04c24d50a..7a6ad94ff 100644
--- a/src/utils/boost-utils.h
+++ b/src/utils/boost-utils.h
@@ -17,29 +17,27 @@ BOOST_TRIBOOL_THIRD_STATE(unknown)
    For positive overflow, return max of Tout template type
    For negative overflow, return min of Tout template type
    On other conversion failures, return 0. */
-template <class Tout, class Tin> Tout boost_numeric_cast(Tin input)
-{
+template <class Tout, class Tin> Tout boost_numeric_cast(Tin input) {
   Tout result = 0;
   std::ostringstream status;
   status.str("ok");
   try {
     result = boost::numeric_cast<Tout>(input);
-  } catch (boost::numeric::negative_overflow& e) {
+  } catch (boost::numeric::negative_overflow &e) {
     status << e.what();
     result = std::numeric_limits<Tout>::min();
-  } catch (boost::numeric::positive_overflow& e) {
+  } catch (boost::numeric::positive_overflow &e) {
     status << e.what();
     result = std::numeric_limits<Tout>::max();
-  } catch (boost::numeric::bad_numeric_cast& e) {
+  } catch (boost::numeric::bad_numeric_cast &e) {
     status << e.what();
     result = 0;
   }
   if (status.str() != "ok") {
-    LOG(message_group::Warning, "Problem converting this number: %1$s", std::to_string(input));
+    LOG(message_group::Warning, "Problem converting this number: %1$s",
+        std::to_string(input));
     LOG(message_group::Warning, "%1$s", status.str());
     LOG(message_group::Warning, "setting result to %1$u", result);
   }
   return result;
 }
-
-
diff --git a/src/utils/calc.cc b/src/utils/calc.cc
index 3d4a50804..2a2a72109 100644
--- a/src/utils/calc.cc
+++ b/src/utils/calc.cc
@@ -25,39 +25,37 @@
  */
 #include "utils/calc.h"
 
-#include <cmath>
-#include <cassert>
 #include <algorithm>
+#include <cassert>
+#include <cmath>
 
 #include "geometry/Grid.h"
 #include "utils/degree_trig.h"
 
 // Linear interpolate.  Can replace with std::lerp in C++20
-double Calc::lerp(double a, double b, double t) {
-  return (1 - t) * a + t * b;
-}
+double Calc::lerp(double a, double b, double t) { return (1 - t) * a + t * b; }
 
 /*!
    Returns the number of subdivision of a whole circle, given radius and
    the three special variables $fn, $fs and $fa
  */
-int Calc::get_fragments_from_r(double r, double fn, double fs, double fa)
-{
-  // FIXME: It would be better to refuse to create an object. Let's do more strict error handling
-  // in future versions of OpenSCAD
-  if (r < GRID_FINE || std::isinf(fn) || std::isnan(fn)) return 3;
-  if (fn > 0.0) return static_cast<int>(fn >= 3 ? fn : 3);
+int Calc::get_fragments_from_r(double r, double fn, double fs, double fa) {
+  // FIXME: It would be better to refuse to create an object. Let's do more
+  // strict error handling in future versions of OpenSCAD
+  if (r < GRID_FINE || std::isinf(fn) || std::isnan(fn))
+    return 3;
+  if (fn > 0.0)
+    return static_cast<int>(fn >= 3 ? fn : 3);
   return static_cast<int>(ceil(fmax(fmin(360.0 / fa, r * 2 * M_PI / fs), 5)));
 }
 
 /*
    https://mathworld.wolfram.com/Helix.html
-   For a helix defined as:         F(t) = [r*cost(t), r*sin(t), c*t]  for t in [0,T)
-   The helical arc length is          L = T * sqrt(r^2 + c^2)
-   Where its pitch is             pitch = 2*PI*c
-   Pitch is also height per turn: pitch = height / (twist/360)
-   Solving for c gives                c = height / (twist*PI/180)
-   Where (twist*PI/180) is just twist in radians, aka "T"
+   For a helix defined as:         F(t) = [r*cost(t), r*sin(t), c*t]  for t in
+   [0,T) The helical arc length is          L = T * sqrt(r^2 + c^2) Where its
+   pitch is             pitch = 2*PI*c Pitch is also height per turn: pitch =
+   height / (twist/360) Solving for c gives                c = height /
+   (twist*PI/180) Where (twist*PI/180) is just twist in radians, aka "T"
  */
 static double helix_arc_length(double r_sqr, double height, double twist) {
   const double T = twist * M_DEG2RAD;
@@ -69,19 +67,21 @@ static double helix_arc_length(double r_sqr, double height, double twist) {
    Returns the number of slices for a linear_extrude with twist.
    Given height, twist, and the three special variables $fn, $fs and $fa
  */
-int Calc::get_helix_slices(double r_sqr, double height, double twist, double fn, double fs, double fa)
-{
+int Calc::get_helix_slices(double r_sqr, double height, double twist, double fn,
+                           double fs, double fa) {
   twist = fabs(twist);
   // 180 twist per slice is worst case, guaranteed non-manifold.
   // Make sure we have at least 3 slices per 360 twist
   const int min_slices = std::max(static_cast<int>(ceil(twist / 120.0)), 1);
-  if (sqrt(r_sqr) < GRID_FINE || std::isinf(fn) || std::isnan(fn)) return min_slices;
+  if (sqrt(r_sqr) < GRID_FINE || std::isinf(fn) || std::isnan(fn))
+    return min_slices;
   if (fn > 0.0) {
     const int fn_slices = static_cast<int>(ceil(twist / 360.0 * fn));
     return std::max(fn_slices, min_slices);
   }
   const int fa_slices = static_cast<int>(ceil(twist / fa));
-  const int fs_slices = static_cast<int>(ceil(helix_arc_length(r_sqr, height, twist) / fs));
+  const int fs_slices =
+      static_cast<int>(ceil(helix_arc_length(r_sqr, height, twist) / fs));
   return std::max(std::min(fa_slices, fs_slices), min_slices);
 }
 
@@ -98,11 +98,14 @@ static double archimedes_length(double a, double theta) {
   return 0.5 * a * (theta * sqrt(1 + theta * theta) + asinh(theta));
 }
 
-int Calc::get_conical_helix_slices(double r_sqr, double height, double twist, double scale, double fn, double fs, double fa) {
+int Calc::get_conical_helix_slices(double r_sqr, double height, double twist,
+                                   double scale, double fn, double fs,
+                                   double fa) {
   twist = fabs(twist);
   const double r = sqrt(r_sqr);
   const int min_slices = std::max(static_cast<int>(ceil(twist / 120.0)), 1);
-  if (r < GRID_FINE || std::isinf(fn) || std::isnan(fn)) return min_slices;
+  if (r < GRID_FINE || std::isinf(fn) || std::isnan(fn))
+    return min_slices;
   if (fn > 0.0) {
     const int fn_slices = static_cast<int>(ceil(twist * fn / 360));
     return std::max(fn_slices, min_slices);
@@ -120,8 +123,9 @@ int Calc::get_conical_helix_slices(double r_sqr, double height, double twist, do
    |\                  |____|/
    | \                 |    / 1x  (Z=0)
    |  \                |   /
-   |___\ 0.66x (Z=h)   |  /            t is angle of our arc section (twist, in rads)
-   |   |\              | /             E is angle_end (total triangle base length)
+   |___\ 0.66x (Z=h)   |  /            t is angle of our arc section (twist, in
+   rads) |   |\              | /             E is angle_end (total triangle base
+   length)
    |___|_\  1x (Z=0)   |/ 0x           S is angle_start
          t
 
@@ -139,9 +143,12 @@ int Calc::get_conical_helix_slices(double r_sqr, double height, double twist, do
   }
   const double angle_start = angle_end - rads;
   const double a = r / angle_end; // spiral scale coefficient
-  const double spiral_length = archimedes_length(a, angle_end) - archimedes_length(a, angle_start);
-  // Treat (flat spiral_length,extrusion height) as (base,height) of a right triangle to get diagonal length.
-  const double total_length = sqrt(spiral_length * spiral_length + height * height);
+  const double spiral_length =
+      archimedes_length(a, angle_end) - archimedes_length(a, angle_start);
+  // Treat (flat spiral_length,extrusion height) as (base,height) of a right
+  // triangle to get diagonal length.
+  const double total_length =
+      sqrt(spiral_length * spiral_length + height * height);
 
   const int fs_slices = static_cast<int>(ceil(total_length / fs));
   const int fa_slices = static_cast<int>(ceil(twist / fa));
@@ -153,17 +160,20 @@ int Calc::get_conical_helix_slices(double r_sqr, double height, double twist, do
     Either use $fn directly as slices,
     or divide the longest diagonal vertex extrude path by $fs
 
-    dr_sqr - the largest 2D delta (before/after scaling) for all vertices, squared.
-    note: $fa is not considered since no twist
-          scale is not passed in since it was already used to calculate the largest delta.
+    dr_sqr - the largest 2D delta (before/after scaling) for all vertices,
+   squared. note: $fa is not considered since no twist scale is not passed in
+   since it was already used to calculate the largest delta.
  */
-int Calc::get_diagonal_slices(double delta_sqr, double height, double fn, double fs) {
+int Calc::get_diagonal_slices(double delta_sqr, double height, double fn,
+                              double fs) {
   constexpr int min_slices = 1;
-  if (sqrt(delta_sqr) < GRID_FINE || std::isinf(fn) || std::isnan(fn)) return min_slices;
+  if (sqrt(delta_sqr) < GRID_FINE || std::isinf(fn) || std::isnan(fn))
+    return min_slices;
   if (fn > 0.0) {
     const int fn_slices = static_cast<int>(fn);
     return std::max(fn_slices, min_slices);
   }
-  const int fs_slices = static_cast<int>(ceil(sqrt(delta_sqr + height * height) / fs));
+  const int fs_slices =
+      static_cast<int>(ceil(sqrt(delta_sqr + height * height) / fs));
   return std::max(fs_slices, min_slices);
 }
diff --git a/src/utils/calc.h b/src/utils/calc.h
index 7ab8c48c1..944343064 100644
--- a/src/utils/calc.h
+++ b/src/utils/calc.h
@@ -3,7 +3,9 @@
 namespace Calc {
 double lerp(double a, double b, double t);
 int get_fragments_from_r(double r, double fn, double fs, double fa);
-int get_helix_slices(double r_sqr, double h, double twist, double fn, double fs, double fa);
-int get_conical_helix_slices(double r, double height, double twist, double scale, double fn, double fs, double fa);
+int get_helix_slices(double r_sqr, double h, double twist, double fn, double fs,
+                     double fa);
+int get_conical_helix_slices(double r, double height, double twist,
+                             double scale, double fn, double fs, double fa);
 int get_diagonal_slices(double delta_sqr, double height, double fn, double fs);
-}
+} // namespace Calc
diff --git a/src/utils/degree_trig.cc b/src/utils/degree_trig.cc
index ebee92b8b..9e8452540 100644
--- a/src/utils/degree_trig.cc
+++ b/src/utils/degree_trig.cc
@@ -36,28 +36,21 @@
 // Trigonometry function taking degrees, accurate for 30, 45, 60 and 90, etc.
 //
 
-static inline double rad2deg(double x)
-{
-  return x * M_RAD2DEG;
-}
+static inline double rad2deg(double x) { return x * M_RAD2DEG; }
 
-static inline double deg2rad(double x)
-{
-  return x * M_DEG2RAD;
-}
+static inline double deg2rad(double x) { return x * M_DEG2RAD; }
 
 // this limit assumes 26+26=52 bits mantissa
 // comment/undefine it to disable domain check
 #define TRIG_HUGE_VAL ((1L << 26) * 360.0 * (1L << 26))
 
-double sin_degrees(double x)
-{
+double sin_degrees(double x) {
   // use positive tests because of possible Inf/NaN
   if (x < 360.0 && x >= 0.0) {
     // Ok for now
   } else
 #ifdef TRIG_HUGE_VAL
-  if (x < TRIG_HUGE_VAL && x > -TRIG_HUGE_VAL)
+      if (x < TRIG_HUGE_VAL && x > -TRIG_HUGE_VAL)
 #endif
   {
     const double revolutions = floor(x / 360.0);
@@ -71,11 +64,15 @@ double sin_degrees(double x)
   }
 #endif
   const bool oppose = x >= 180.0;
-  if (oppose) x -= 180.0;
-  if (x > 90.0) x = 180.0 - x;
+  if (oppose)
+    x -= 180.0;
+  if (x > 90.0)
+    x = 180.0 - x;
   if (x < 45.0) {
-    if (x == 30.0) x = 0.5;
-    else x = sin(deg2rad(x));
+    if (x == 30.0)
+      x = 0.5;
+    else
+      x = sin(deg2rad(x));
   } else if (x == 45.0) {
     x = M_SQRT1_2;
   } else if (x == 60.0) {
@@ -86,14 +83,13 @@ double sin_degrees(double x)
   return oppose ? -x : x;
 }
 
-double cos_degrees(double x)
-{
+double cos_degrees(double x) {
   // use positive tests because of possible Inf/NaN
   if (x < 360.0 && x >= 0.0) {
     // Ok for now
   } else
 #ifdef TRIG_HUGE_VAL
-  if (x < TRIG_HUGE_VAL && x > -TRIG_HUGE_VAL)
+      if (x < TRIG_HUGE_VAL && x > -TRIG_HUGE_VAL)
 #endif
   {
     const double revolutions = floor(x / 360.0);
@@ -107,14 +103,17 @@ double cos_degrees(double x)
   }
 #endif
   bool oppose = x >= 180.0;
-  if (oppose) x -= 180.0;
+  if (oppose)
+    x -= 180.0;
   if (x > 90.0) {
     x = 180.0 - x;
     oppose = !oppose;
   }
   if (x > 45.0) {
-    if (x == 60.0) x = 0.5;
-    else x = sin(deg2rad(90.0 - x));
+    if (x == 60.0)
+      x = 0.5;
+    else
+      x = sin(deg2rad(90.0 - x));
   } else if (x == 45.0) {
     x = M_SQRT1_2;
   } else if (x == 30.0) {
@@ -125,15 +124,14 @@ double cos_degrees(double x)
   return oppose ? -x : x;
 }
 
-double tan_degrees(double x)
-{
+double tan_degrees(double x) {
   const int cycles = floor((x) / 180.0);
   // use positive tests because of possible Inf/NaN
   if (x < 180.0 && x >= 0.0) {
     // Ok for now
   } else
 #ifdef TRIG_HUGE_VAL
-  if (x < TRIG_HUGE_VAL && x > -TRIG_HUGE_VAL)
+      if (x < TRIG_HUGE_VAL && x > -TRIG_HUGE_VAL)
 #endif
   {
     x -= 180.0 * cycles;
@@ -146,7 +144,8 @@ double tan_degrees(double x)
   }
 #endif
   const bool oppose = x > 90.0;
-  if (oppose) x = 180.0 - x;
+  if (oppose)
+    x = 180.0 - x;
   if (x == 0.0) {
     x = (cycles % 2) == 0 ? 0.0 : -0.0;
   } else if (x == 30.0) {
@@ -156,9 +155,8 @@ double tan_degrees(double x)
   } else if (x == 60.0) {
     x = M_SQRT3;
   } else if (x == 90.0) {
-    x = (cycles % 2) == 0 ?
-      std::numeric_limits<double>::infinity() :
-      -std::numeric_limits<double>::infinity();
+    x = (cycles % 2) == 0 ? std::numeric_limits<double>::infinity()
+                          : -std::numeric_limits<double>::infinity();
   } else {
     x = tan(deg2rad(x));
   }
@@ -167,41 +165,41 @@ double tan_degrees(double x)
 //
 // Inverse trig
 //
-double asin_degrees(double x)
-{
+double asin_degrees(double x) {
   const auto degs = rad2deg(asin(x));
   const auto whole = round(degs);
-  if (sin_degrees(whole) == x) return whole;
+  if (sin_degrees(whole) == x)
+    return whole;
   return degs;
 }
-double acos_degrees(double x)
-{
+double acos_degrees(double x) {
   const auto degs = rad2deg(acos(x));
   const auto whole = round(degs);
-  if (cos_degrees(whole) == x) return whole;
+  if (cos_degrees(whole) == x)
+    return whole;
   return degs;
 }
-double atan_degrees(double x)
-{
+double atan_degrees(double x) {
   const auto degs = rad2deg(atan(x));
   const auto whole = round(degs);
-  if (tan_degrees(whole) == x) return whole;
+  if (tan_degrees(whole) == x)
+    return whole;
   return degs;
 }
-double atan2_degrees(double y, double x)
-{
+double atan2_degrees(double y, double x) {
   const auto degs = rad2deg(atan2(y, x));
   const auto whole = round(degs);
-  if (fabs(degs - whole) < 3.0E-14) return whole;
+  if (fabs(degs - whole) < 3.0E-14)
+    return whole;
   return degs;
 }
 //
 // Rotation_matrix_from_axis_and_angle
 //
-Matrix3d angle_axis_degrees(double a, Vector3d v)
-{
+Matrix3d angle_axis_degrees(double a, Vector3d v) {
   Matrix3d M{Matrix3d::Identity()};
-  // Formula from https://en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle
+  // Formula from
+  // https://en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle
   // We avoid dividing by the square root of the magnitude as much as possible
   // to minimise rounding errors.
   const auto s = sin_degrees(a);
@@ -210,23 +208,19 @@ Matrix3d angle_axis_degrees(double a, Vector3d v)
   if (m > 0) {
     const Vector3d Cv = v * ((1 - c) / m);
     const Vector3d us = v.normalized() * s;
-    M << Cv[0] * v[0] + c,     Cv[1] * v[0] - us[2], Cv[2] * v[0] + us[1],
-      Cv[0] * v[1] + us[2], Cv[1] * v[1] + c,     Cv[2] * v[1] - us[0],
-      Cv[0] * v[2] - us[1], Cv[1] * v[2] + us[0], Cv[2] * v[2] + c;
+    M << Cv[0] * v[0] + c, Cv[1] * v[0] - us[2], Cv[2] * v[0] + us[1],
+        Cv[0] * v[1] + us[2], Cv[1] * v[1] + c, Cv[2] * v[1] - us[0],
+        Cv[0] * v[2] - us[1], Cv[1] * v[2] + us[0], Cv[2] * v[2] + c;
   }
   return M;
 }
 //
 // 2D rotation matrix from angle in degrees
 //
-Matrix3d rotate_degrees(double angle)
-{
+Matrix3d rotate_degrees(double angle) {
   Eigen::Matrix3d m;
   const auto s = sin_degrees(angle);
   const auto c = cos_degrees(angle);
-  m <<
-    c, -s,  0,
-    s,  c,  0,
-    0,  0,  1;
+  m << c, -s, 0, s, c, 0, 0, 0, 1;
   return m;
 }
diff --git a/src/utils/degree_trig.h b/src/utils/degree_trig.h
index 35781b4df..d49a35bd8 100644
--- a/src/utils/degree_trig.h
+++ b/src/utils/degree_trig.h
@@ -29,9 +29,11 @@
 #pragma once
 #include "geometry/linalg.h"
 
-constexpr double M_SQRT3 = 1.73205080756887719318;    /* sqrt(3)   */
-constexpr double M_SQRT3_4 = 0.86602540378443859659;  /* sqrt(3/4) == sqrt(3)/2 */
-constexpr double M_SQRT1_3 = 0.57735026918962573106;  /* sqrt(1/3) == sqrt(3)/3 */
+constexpr double M_SQRT3 = 1.73205080756887719318; /* sqrt(3)   */
+constexpr double M_SQRT3_4 =
+    0.86602540378443859659; /* sqrt(3/4) == sqrt(3)/2 */
+constexpr double M_SQRT1_3 =
+    0.57735026918962573106; /* sqrt(1/3) == sqrt(3)/3 */
 constexpr double M_RAD2DEG = 57.2957795130823208767;  /* 180/PI */
 constexpr double M_DEG2RAD = 0.017453292519943295769; /* PI/180 */
 
diff --git a/src/utils/exceptions.h b/src/utils/exceptions.h
index 515d63c6e..6e0446d8f 100644
--- a/src/utils/exceptions.h
+++ b/src/utils/exceptions.h
@@ -1,48 +1,51 @@
 #pragma once
 
 #include <stdexcept>
-#include <utility>
 #include <string>
+#include <utility>
 
 #include "core/AST.h"
 #include "utils/printutils.h"
 
-class EvaluationException : public std::runtime_error
-{
+class EvaluationException : public std::runtime_error {
 public:
-  EvaluationException(const std::string& what_arg) : std::runtime_error(what_arg), traceDepth(OpenSCAD::traceDepth) {}
+  EvaluationException(const std::string &what_arg)
+      : std::runtime_error(what_arg), traceDepth(OpenSCAD::traceDepth) {}
 
 public:
   int traceDepth = 0;
 };
 
-class AssertionFailedException : public EvaluationException
-{
+class AssertionFailedException : public EvaluationException {
 public:
-  AssertionFailedException(const std::string& what_arg, Location loc) : EvaluationException(what_arg), loc(std::move(loc)) {}
+  AssertionFailedException(const std::string &what_arg, Location loc)
+      : EvaluationException(what_arg), loc(std::move(loc)) {}
 
 public:
   Location loc;
 };
 
-class RecursionException : public EvaluationException
-{
+class RecursionException : public EvaluationException {
 public:
-  static RecursionException create(const std::string& recursiontype, const std::string& name, const Location& loc) {
-    return RecursionException{STR("Recursion detected calling ", recursiontype, " '", name, "'"), loc};
+  static RecursionException create(const std::string &recursiontype,
+                                   const std::string &name,
+                                   const Location &loc) {
+    return RecursionException{
+        STR("Recursion detected calling ", recursiontype, " '", name, "'"),
+        loc};
   }
 
 public:
   Location loc;
 
 private:
-  RecursionException(const std::string& what_arg, Location loc) : EvaluationException(what_arg), loc(std::move(loc)) {}
+  RecursionException(const std::string &what_arg, Location loc)
+      : EvaluationException(what_arg), loc(std::move(loc)) {}
 };
 
-class LoopCntException : public EvaluationException
-{
+class LoopCntException : public EvaluationException {
 public:
-  static LoopCntException create(const std::string& type, const Location& loc) {
+  static LoopCntException create(const std::string &type, const Location &loc) {
     return LoopCntException{STR(type, " loop counter exceeded limit"), loc};
   }
 
@@ -50,22 +53,24 @@ public:
   Location loc;
 
 private:
-  LoopCntException(const std::string& what_arg, Location loc) : EvaluationException(what_arg), loc(std::move(loc)) {}
+  LoopCntException(const std::string &what_arg, Location loc)
+      : EvaluationException(what_arg), loc(std::move(loc)) {}
 };
 
-class VectorEchoStringException : public EvaluationException
-{
+class VectorEchoStringException : public EvaluationException {
 public:
   static VectorEchoStringException create() {
-    return VectorEchoStringException{"Stack exhausted while trying to convert a vector to EchoString"};
+    return VectorEchoStringException{
+        "Stack exhausted while trying to convert a vector to EchoString"};
   }
 
 private:
-  VectorEchoStringException(const std::string& what_arg) : EvaluationException(what_arg) {}
+  VectorEchoStringException(const std::string &what_arg)
+      : EvaluationException(what_arg) {}
 };
 
-class HardWarningException : public EvaluationException
-{
+class HardWarningException : public EvaluationException {
 public:
-  HardWarningException(const std::string& what_arg) : EvaluationException(what_arg) {}
+  HardWarningException(const std::string &what_arg)
+      : EvaluationException(what_arg) {}
 };
diff --git a/src/utils/hash.cc b/src/utils/hash.cc
index eb41124a2..d58a77f08 100644
--- a/src/utils/hash.cc
+++ b/src/utils/hash.cc
@@ -8,34 +8,37 @@
 #include "geometry/linalg.h"
 
 namespace std {
-std::size_t hash<Vector3f>::operator()(const Vector3f& s) const {
+std::size_t hash<Vector3f>::operator()(const Vector3f &s) const {
   return Eigen::hash_value(s);
 }
-std::size_t hash<Vector3d>::operator()(const Vector3d& s) const {
+std::size_t hash<Vector3d>::operator()(const Vector3d &s) const {
   return Eigen::hash_value(s);
 }
-std::size_t hash<Vector3l>::operator()(const Vector3l& s) const {
+std::size_t hash<Vector3l>::operator()(const Vector3l &s) const {
   return Eigen::hash_value(s);
 }
-}
+} // namespace std
 
 namespace Eigen {
 
-size_t hash_value(Vector3f const& v) {
+size_t hash_value(Vector3f const &v) {
   size_t seed = 0;
-  for (int i = 0; i < 3; ++i) boost::hash_combine(seed, v[i]);
+  for (int i = 0; i < 3; ++i)
+    boost::hash_combine(seed, v[i]);
   return seed;
 }
 
-size_t hash_value(Vector3d const& v) {
+size_t hash_value(Vector3d const &v) {
   size_t seed = 0;
-  for (int i = 0; i < 3; ++i) boost::hash_combine(seed, v[i]);
+  for (int i = 0; i < 3; ++i)
+    boost::hash_combine(seed, v[i]);
   return seed;
 }
 
-size_t hash_value(Eigen::Matrix<int64_t, 3, 1> const& v) {
+size_t hash_value(Eigen::Matrix<int64_t, 3, 1> const &v) {
   size_t seed = 0;
-  for (int i = 0; i < 3; ++i) boost::hash_combine(seed, v[i]);
+  for (int i = 0; i < 3; ++i)
+    boost::hash_combine(seed, v[i]);
   return seed;
 }
-}
+} // namespace Eigen
diff --git a/src/utils/hash.h b/src/utils/hash.h
index cfd03d8eb..66ba7e896 100644
--- a/src/utils/hash.h
+++ b/src/utils/hash.h
@@ -10,13 +10,19 @@
 using Vector3l = Eigen::Matrix<int64_t, 3, 1>;
 
 namespace std {
-template <> struct hash<Vector3f> { std::size_t operator()(const Vector3f& s) const; };
-template <> struct hash<Vector3d> { std::size_t operator()(const Vector3d& s) const; };
-template <> struct hash<Vector3l> { std::size_t operator()(const Vector3l& s) const; };
-}
+template <> struct hash<Vector3f> {
+  std::size_t operator()(const Vector3f &s) const;
+};
+template <> struct hash<Vector3d> {
+  std::size_t operator()(const Vector3d &s) const;
+};
+template <> struct hash<Vector3l> {
+  std::size_t operator()(const Vector3l &s) const;
+};
+} // namespace std
 
 namespace Eigen {
-size_t hash_value(Vector3f const& v);
-size_t hash_value(Vector3d const& v);
-size_t hash_value(Vector3l const& v);
-}
+size_t hash_value(Vector3f const &v);
+size_t hash_value(Vector3d const &v);
+size_t hash_value(Vector3l const &v);
+} // namespace Eigen
diff --git a/src/utils/parallel.h b/src/utils/parallel.h
index 0b4e0ebb4..b409b2de0 100644
--- a/src/utils/parallel.h
+++ b/src/utils/parallel.h
@@ -12,7 +12,7 @@
 template <class InputIterator, class OutputIterator, class Operation>
 void parallelizable_transform(const InputIterator begin1,
                               const InputIterator end1, OutputIterator out,
-                              const Operation& op) {
+                              const Operation &op) {
 #if ENABLE_TBB
   if (!getenv("OPENSCAD_NO_PARALLEL")) {
     tbb::parallel_for(tbb::blocked_range(begin1, end1), [&](auto range) {
@@ -28,10 +28,10 @@ void parallelizable_transform(const InputIterator begin1,
 
 template <class Container1, class Container2, class OutputIterator,
           class Operation>
-void parallelizable_cross_product_transform(const Container1& cont1,
-                                            const Container2& cont2,
+void parallelizable_cross_product_transform(const Container1 &cont1,
+                                            const Container2 &cont2,
                                             OutputIterator out,
-                                            const Operation& op) {
+                                            const Operation &op) {
 #if ENABLE_TBB
   if (!getenv("OPENSCAD_NO_PARALLEL")) {
     struct ReferencePair {
@@ -39,26 +39,23 @@ void parallelizable_cross_product_transform(const Container1& cont1,
       decltype(*cont2.begin()) second;
       ReferencePair(decltype(*cont1.begin()) first,
                     decltype(*cont2.begin()) second)
-        : first(first), second(second) {
-      }
+          : first(first), second(second) {}
     };
     std::vector<ReferencePair> pairs;
     pairs.reserve(cont1.size() * cont2.size());
-    for (const auto& v1 : cont1) {
-      for (const auto& v2 : cont2) {
+    for (const auto &v1 : cont1) {
+      for (const auto &v2 : cont2) {
         pairs.emplace_back(v1, v2);
       }
     }
     parallelizable_transform(
-      pairs.begin(), pairs.end(), out,
-      [&](const auto& pair) {
-      return op(pair.first, pair.second);
-    });
+        pairs.begin(), pairs.end(), out,
+        [&](const auto &pair) { return op(pair.first, pair.second); });
     return;
   }
 #endif // if ENABLE_TBB
-  for (const auto& v1 : cont1) {
-    for (const auto& v2 : cont2) {
+  for (const auto &v1 : cont1) {
+    for (const auto &v2 : cont2) {
       *(out++) = op(v1, v2);
     }
   }
diff --git a/src/utils/printutils.cc b/src/utils/printutils.cc
index 747cb906d..22bfa62a3 100644
--- a/src/utils/printutils.cc
+++ b/src/utils/printutils.cc
@@ -40,36 +40,30 @@ int count = 0;
 bool no_throw;
 bool deferred;
 
-}  // namespace
+} // namespace
 
-void set_output_handler(OutputHandlerFunc *newhandler, OutputHandlerFunc2 *newhandler2, void *userdata)
-{
+void set_output_handler(OutputHandlerFunc *newhandler,
+                        OutputHandlerFunc2 *newhandler2, void *userdata) {
   outputhandler = newhandler;
   outputhandler2 = newhandler2;
   outputhandler_data = userdata;
 }
 
-void no_exceptions_for_warnings()
-{
+void no_exceptions_for_warnings() {
   no_throw = true;
   deferred = false;
 }
 
-bool would_have_thrown()
-{
+bool would_have_thrown() {
   const auto would_throw = deferred;
   no_throw = false;
   deferred = false;
   return would_throw;
 }
 
-void print_messages_push()
-{
-  print_messages_stack.emplace_back();
-}
+void print_messages_push() { print_messages_stack.emplace_back(); }
 
-void print_messages_pop()
-{
+void print_messages_pop() {
   const std::string msg = print_messages_stack.back();
   print_messages_stack.pop_back();
   if (print_messages_stack.size() > 0 && !msg.empty()) {
@@ -80,9 +74,9 @@ void print_messages_pop()
   }
 }
 
-void PRINT(const Message& msgObj)
-{
-  if (msgObj.msg.empty() && msgObj.group != message_group::Echo) return;
+void PRINT(const Message &msgObj) {
+  if (msgObj.msg.empty() && msgObj.group != message_group::Echo)
+    return;
 
   if (print_messages_stack.size() > 0) {
     if (!print_messages_stack.back().empty()) {
@@ -93,26 +87,31 @@ void PRINT(const Message& msgObj)
 
   PRINT_NOCACHE(msgObj);
 
-  //to error log
-  if (outputhandler2 &&
-      !(msgObj.group == message_group::NONE || msgObj.group == message_group::Echo || msgObj.group == message_group::Trace)) {
+  // to error log
+  if (outputhandler2 && !(msgObj.group == message_group::NONE ||
+                          msgObj.group == message_group::Echo ||
+                          msgObj.group == message_group::Trace)) {
 
     outputhandler2(msgObj, outputhandler_data);
   }
 }
 
-void PRINT_NOCACHE(const Message& msgObj)
-{
-  if (msgObj.msg.empty() && msgObj.group != message_group::Echo) return;
+void PRINT_NOCACHE(const Message &msgObj) {
+  if (msgObj.msg.empty() && msgObj.group != message_group::Echo)
+    return;
 
   const auto msg = msgObj.str();
 
-  if (msgObj.group == message_group::Warning || msgObj.group == message_group::Error || msgObj.group == message_group::Trace) {
+  if (msgObj.group == message_group::Warning ||
+      msgObj.group == message_group::Error ||
+      msgObj.group == message_group::Trace) {
     size_t i;
     for (i = 0; i < lastmessages.size(); ++i) {
-      if (lastmessages[i] != msg) break;
+      if (lastmessages[i] != msg)
+        break;
     }
-    if (i == 5) return; // Suppress output after 5 equal ERROR or WARNING outputs.
+    if (i == 5)
+      return; // Suppress output after 5 equal ERROR or WARNING outputs.
     lastmessages.push_back(msg);
   }
   if (!deferred)
@@ -124,17 +123,20 @@ void PRINT_NOCACHE(const Message& msgObj)
       }
     }
   if (!std::current_exception()) {
-    if ((OpenSCAD::hardwarnings && msgObj.group == message_group::Warning) || (no_throw && msgObj.group == message_group::Error)) {
-      if (no_throw) deferred = true;
-      else throw HardWarningException(msgObj.msg);
+    if ((OpenSCAD::hardwarnings && msgObj.group == message_group::Warning) ||
+        (no_throw && msgObj.group == message_group::Error)) {
+      if (no_throw)
+        deferred = true;
+      else
+        throw HardWarningException(msgObj.msg);
     }
   }
 }
 
-void PRINTDEBUG(const std::string& filename, const std::string& msg)
-{
+void PRINTDEBUG(const std::string &filename, const std::string &msg) {
   // see printutils.h for usage instructions
-  if (OpenSCAD::debug == "") return;
+  if (OpenSCAD::debug == "")
+    return;
   const std::string shortfname = fs::path(filename).stem().generic_string();
   std::string lowshortfname(shortfname);
   boost::algorithm::to_lower(lowshortfname);
@@ -142,44 +144,41 @@ void PRINTDEBUG(const std::string& filename, const std::string& msg)
   boost::algorithm::to_lower(lowdebug);
   if (OpenSCAD::debug == "all" ||
       lowdebug.find(lowshortfname) != std::string::npos) {
-    const Message msgObj{shortfname + ": " + msg, message_group::NONE, Location::NONE, ""};
+    const Message msgObj{shortfname + ": " + msg, message_group::NONE,
+                         Location::NONE, ""};
     PRINT_NOCACHE(msgObj);
   }
 }
 
-const std::string& quoted_string(const std::string& str)
-{
+const std::string &quoted_string(const std::string &str) {
   static std::string buf;
   buf = str;
   boost::replace_all(buf, "\n", "\\n");
   return buf;
 }
 
-std::string two_digit_exp_format(std::string doublestr)
-{
+std::string two_digit_exp_format(std::string doublestr) {
 #ifdef _WIN32
   size_t exppos = doublestr.find('e');
   if (exppos != std::string::npos) {
     exppos += 2;
-    if (doublestr[exppos] == '0') doublestr.erase(exppos, 1);
+    if (doublestr[exppos] == '0')
+      doublestr.erase(exppos, 1);
   }
 #endif
   return doublestr;
 }
 
-std::string two_digit_exp_format(double x)
-{
+std::string two_digit_exp_format(double x) {
   return two_digit_exp_format(std::to_string(x));
 }
 
-void resetSuppressedMessages()
-{
+void resetSuppressedMessages() {
   printedDeprecations.clear();
   lastmessages.clear();
 }
 
-std::string getGroupName(const enum message_group& group)
-{
+std::string getGroupName(const enum message_group &group) {
   switch (group) {
   case message_group::NONE:
   case message_group::Warning:
@@ -208,8 +207,7 @@ std::string getGroupName(const enum message_group& group)
   }
 }
 
-std::string getGroupColor(const enum message_group& group)
-{
+std::string getGroupColor(const enum message_group &group) {
   switch (group) {
   case message_group::Warning:
   case message_group::Deprecated:
@@ -228,13 +226,8 @@ std::string getGroupColor(const enum message_group& group)
   }
 }
 
-bool getGroupTextPlain(const enum message_group& group)
-{
+bool getGroupTextPlain(const enum message_group &group) {
   return group == message_group::NONE || group == message_group::Echo;
 }
 
-std::string
-quoteVar(const std::string& varname)
-{
-  return '"' + varname + '"';
-}
+std::string quoteVar(const std::string &varname) { return '"' + varname + '"'; }
diff --git a/src/utils/printutils.h b/src/utils/printutils.h
index d46d9c113..5affb7d2c 100644
--- a/src/utils/printutils.h
+++ b/src/utils/printutils.h
@@ -1,7 +1,7 @@
 #pragma once
 
-#include <cstddef>
 #include <clocale>
+#include <cstddef>
 #include <initializer_list>
 #include <iostream>
 #include <list>
@@ -26,9 +26,9 @@
 
 #include "core/AST.h"
 
-// It seems standard practice to use underscore for gettext, even though it is reserved.
-// Not wanting to risk breaking translations by changing every usage of this,
-// I've opted to just disable the check in this case. - Hans L
+// It seems standard practice to use underscore for gettext, even though it is
+// reserved. Not wanting to risk breaking translations by changing every usage
+// of this, I've opted to just disable the check in this case. - Hans L
 // NOLINTBEGIN(bugprone-reserved-identifier)
 inline char *_(const char *msgid) { return gettext(msgid); }
 inline const char *_(const char *msgid, const char *msgctxt) {
@@ -47,16 +47,26 @@ inline const char *_(const char *msgid, const char *msgctxt) {
 }
 // NOLINTEND(bugprone-reserved-identifier)
 
-std::string quoteVar(const std::string& varname);
+std::string quoteVar(const std::string &varname);
 
 enum class message_group {
-  NONE, Error, Warning, UI_Warning, Font_Warning, Export_Warning, Export_Error, UI_Error, Parser_Error, Trace, Deprecated, Echo
+  NONE,
+  Error,
+  Warning,
+  UI_Warning,
+  Font_Warning,
+  Export_Warning,
+  Export_Error,
+  UI_Error,
+  Parser_Error,
+  Trace,
+  Deprecated,
+  Echo
 };
 
-
-std::string getGroupName(const enum message_group& group);
-std::string getGroupColor(const enum message_group& group);
-bool getGroupTextPlain(const enum message_group& group);
+std::string getGroupName(const enum message_group &group);
+std::string getGroupColor(const enum message_group &group);
+bool getGroupTextPlain(const enum message_group &group);
 
 struct Message {
   std::string msg;
@@ -65,24 +75,23 @@ struct Message {
   enum message_group group;
 
   Message()
-    : msg(""), loc(Location::NONE), docPath(""), group(message_group::NONE)
-  {
-  }
+      : msg(""), loc(Location::NONE), docPath(""), group(message_group::NONE) {}
 
-  Message(std::string msg, message_group group = message_group::NONE, Location loc = Location::NONE, std::string docPath = "")
-    : msg(std::move(msg)), loc(std::move(loc)), docPath(std::move(docPath)), group(group)
-  {
-  }
+  Message(std::string msg, message_group group = message_group::NONE,
+          Location loc = Location::NONE, std::string docPath = "")
+      : msg(std::move(msg)), loc(std::move(loc)), docPath(std::move(docPath)),
+        group(group) {}
 
   [[nodiscard]] std::string str() const {
-    const auto g = group == message_group::NONE ? "" : getGroupName(group) + ": ";
+    const auto g =
+        group == message_group::NONE ? "" : getGroupName(group) + ": ";
     const auto l = loc.isNone() ? "" : " " + loc.toRelativeString(docPath);
     return g + msg + l;
   }
 };
 
-using OutputHandlerFunc = void (const Message&, void *);
-using OutputHandlerFunc2 = void (const Message&, void *);
+using OutputHandlerFunc = void(const Message &, void *);
+using OutputHandlerFunc2 = void(const Message &, void *);
 
 extern OutputHandlerFunc *outputhandler;
 extern void *outputhandler_data;
@@ -95,9 +104,10 @@ extern int traceDepth;
 extern bool traceUsermoduleParameters;
 extern bool parameterCheck;
 extern bool rangeCheck;
-}
+} // namespace OpenSCAD
 
-void set_output_handler(OutputHandlerFunc *newhandler, OutputHandlerFunc2 *newhandler2, void *userdata);
+void set_output_handler(OutputHandlerFunc *newhandler,
+                        OutputHandlerFunc2 *newhandler2, void *userdata);
 void no_exceptions_for_warnings();
 bool would_have_thrown();
 
@@ -106,14 +116,16 @@ void print_messages_push();
 void print_messages_pop();
 void resetSuppressedMessages();
 
-
 /* PRINT statements come out in same window as ECHO.
    usage: PRINTB("Var1: %s Var2: %i", var1 % var2 ); */
-void PRINT(const Message& msgObj);
+void PRINT(const Message &msgObj);
 
-void PRINT_NOCACHE(const Message& msgObj);
-#define PRINTB_NOCACHE(_fmt, _arg) do { } while (0)
-// #define PRINTB_NOCACHE(_fmt, _arg) do { PRINT_NOCACHE(str(boost::format(_fmt) % _arg)); } while (0)
+void PRINT_NOCACHE(const Message &msgObj);
+#define PRINTB_NOCACHE(_fmt, _arg)                                             \
+  do {                                                                         \
+  } while (0)
+// #define PRINTB_NOCACHE(_fmt, _arg) do { PRINT_NOCACHE(str(boost::format(_fmt)
+// % _arg)); } while (0)
 
 /*PRINTD: debugging/verbose output. Usage in code:
    CGAL_Point_3 p0(0,0,0),p1(1,0,0),p2(0,1,0);
@@ -124,26 +136,35 @@ void PRINT_NOCACHE(const Message& msgObj);
    openscad x.scad --debug=<srcfile> # prints only debug msgs from srcfile.*.cc
    (example: openscad --debug=export # prints only debug msgs from export.cc )
 
-   For a debug with heavy computation cost, you can guard so that the computation
-   only occurs when debugging is turned on. For example:
-   if (OpenSCAD::debug!="") PRINTDB("PolySet dump: %s",ps->dump());
+   For a debug with heavy computation cost, you can guard so that the
+   computation only occurs when debugging is turned on. For example: if
+   (OpenSCAD::debug!="") PRINTDB("PolySet dump: %s",ps->dump());
  */
 
-void PRINTDEBUG(const std::string& filename, const std::string& msg);
+void PRINTDEBUG(const std::string &filename, const std::string &msg);
 // NOLINTBEGIN
-#define PRINTD(_arg) do { PRINTDEBUG(std::string(__FILE__), _arg); } while (0)
-#define PRINTDB(_fmt, _arg) do { try { PRINTDEBUG(std::string(__FILE__), str(boost::format(_fmt) % _arg)); } catch (const boost::io::format_error& e) { PRINTDEBUG(std::string(__FILE__), "bad PRINTDB usage"); } } while (0)
+#define PRINTD(_arg)                                                           \
+  do {                                                                         \
+    PRINTDEBUG(std::string(__FILE__), _arg);                                   \
+  } while (0)
+#define PRINTDB(_fmt, _arg)                                                    \
+  do {                                                                         \
+    try {                                                                      \
+      PRINTDEBUG(std::string(__FILE__), str(boost::format(_fmt) % _arg));      \
+    } catch (const boost::io::format_error &e) {                               \
+      PRINTDEBUG(std::string(__FILE__), "bad PRINTDB usage");                  \
+    }                                                                          \
+  } while (0)
 // NOLINTEND
 
 std::string two_digit_exp_format(std::string doublestr);
 std::string two_digit_exp_format(double x);
-const std::string& quoted_string(const std::string& str);
+const std::string &quoted_string(const std::string &str);
 
 // extremely simple logging, eventually replace with something like boost.log
 // usage: logstream out(5); openscad_loglevel=6; out << "hi";
 static int openscad_loglevel = 0;
-class logstream
-{
+class logstream {
 public:
   std::ostream *out;
   int loglevel;
@@ -151,7 +172,7 @@ public:
     loglevel = level;
     out = &(std::cout);
   }
-  template <typename T> logstream& operator<<(T const& t) {
+  template <typename T> logstream &operator<<(T const &t) {
     if (out && loglevel <= openscad_loglevel) {
       (*out) << t;
       out->flush();
@@ -160,36 +181,33 @@ public:
   }
 };
 
-inline std::string STR(std::ostringstream& oss) {
+inline std::string STR(std::ostringstream &oss) {
   auto s = oss.str();
-  oss.str("");  // clear the string buffer for next STR call
-  oss.clear();  // reset stream error state for next STR call
+  oss.str(""); // clear the string buffer for next STR call
+  oss.clear(); // reset stream error state for next STR call
   return s;
 }
 
-template <typename T, typename ... Args>
-std::string STR(std::ostringstream& oss, T&& t, Args&& ... args) {
+template <typename T, typename... Args>
+std::string STR(std::ostringstream &oss, T &&t, Args &&...args) {
   oss << t;
   return STR(oss, std::forward<Args>(args)...);
 }
 
-template <typename T, typename ... Args>
-std::string STR(T&& t, Args&& ... args) {
-  // using thread_local here so that recursive template does not instantiate excessive ostringstreams
+template <typename T, typename... Args> std::string STR(T &&t, Args &&...args) {
+  // using thread_local here so that recursive template does not instantiate
+  // excessive ostringstreams
   thread_local std::ostringstream oss;
   oss << t;
   return STR(oss, std::forward<Args>(args)...);
 }
 
-template <typename ... Ts>
-class MessageClass
-{
+template <typename... Ts> class MessageClass {
 private:
   std::string fmt;
   std::tuple<Ts...> args;
   template <std::size_t... Is>
-  [[nodiscard]] std::string format(const std::index_sequence<Is...>) const
-  {
+  [[nodiscard]] std::string format(const std::index_sequence<Is...>) const {
 
     std::string s;
     for (int i = 0; fmt[i] != '\0'; i++) {
@@ -202,46 +220,49 @@ private:
 
     boost::format f(s);
     f.exceptions(boost::io::bad_format_string_bit);
-    static_cast<void>(std::initializer_list<char> {(static_cast<void>(f % std::get<Is>(args)), char{}) ...});
+    static_cast<void>(std::initializer_list<char>{
+        (static_cast<void>(f % std::get<Is>(args)), char{})...});
     return boost::str(f);
   }
 
 public:
-  template <typename ... Args>
-  MessageClass(std::string&& fmt, Args&&... args) : fmt(fmt), args(std::forward<Args>(args)...)
-  {
-  }
+  template <typename... Args>
+  MessageClass(std::string &&fmt, Args &&...args)
+      : fmt(fmt), args(std::forward<Args>(args)...) {}
 
-  [[nodiscard]] std::string format() const
-  {
+  [[nodiscard]] std::string format() const {
     return format(std::index_sequence_for<Ts...>{});
   }
 };
 
 extern std::set<std::string> printedDeprecations;
 
-template <typename ... Args>
-void LOG(const message_group& msgGroup, Location loc, std::string docPath, std::string&& f, Args&&... args)
-{
-  auto formatted = MessageClass<Args...>{std::move(f), std::forward<Args>(args)...}.format();
+template <typename... Args>
+void LOG(const message_group &msgGroup, Location loc, std::string docPath,
+         std::string &&f, Args &&...args) {
+  auto formatted =
+      MessageClass<Args...>{std::move(f), std::forward<Args>(args)...}.format();
 
-  //check for deprecations
-  if (msgGroup == message_group::Deprecated && printedDeprecations.find(formatted + loc.toRelativeString(docPath)) != printedDeprecations.end()) return;
-  if (msgGroup == message_group::Deprecated) printedDeprecations.insert(formatted + loc.toRelativeString(docPath));
+  // check for deprecations
+  if (msgGroup == message_group::Deprecated &&
+      printedDeprecations.find(formatted + loc.toRelativeString(docPath)) !=
+          printedDeprecations.end())
+    return;
+  if (msgGroup == message_group::Deprecated)
+    printedDeprecations.insert(formatted + loc.toRelativeString(docPath));
 
-  Message msgObj{std::move(formatted), msgGroup, std::move(loc), std::move(docPath)};
+  Message msgObj{std::move(formatted), msgGroup, std::move(loc),
+                 std::move(docPath)};
 
   PRINT(msgObj);
 }
 
-template <typename ... Args>
-void LOG(const message_group& msgGroup, std::string&& f, Args&&... args)
-{
+template <typename... Args>
+void LOG(const message_group &msgGroup, std::string &&f, Args &&...args) {
   LOG(msgGroup, Location::NONE, "", std::move(f), std::forward<Args>(args)...);
 }
 
-template <typename ... Args>
-void LOG(std::string&& f, Args&&... args)
-{
-  LOG(message_group::NONE, Location::NONE, "", std::move(f), std::forward<Args>(args)...);
+template <typename... Args> void LOG(std::string &&f, Args &&...args) {
+  LOG(message_group::NONE, Location::NONE, "", std::move(f),
+      std::forward<Args>(args)...);
 }
diff --git a/src/utils/scope_guard.hpp b/src/utils/scope_guard.hpp
index a342287e5..20b6f6996 100644
--- a/src/utils/scope_guard.hpp
+++ b/src/utils/scope_guard.hpp
@@ -42,169 +42,163 @@
 #define SG_NODISCARD
 #endif
 
-namespace sg
-{
-namespace detail
-{
+namespace sg {
+namespace detail {
 /* --- Some custom type traits --- */
 
 // Type trait determining whether a type is callable with no arguments
 template <typename T, typename = void>
-struct is_noarg_callable_t
-  : public std::false_type
-{};     // in general, false
+struct is_noarg_callable_t : public std::false_type {}; // in general, false
 
 template <typename T>
-struct is_noarg_callable_t<T, decltype(std::declval<T&&>()())>
-  : public std::true_type
-{};     // only true when call expression valid
+struct is_noarg_callable_t<T, decltype(std::declval<T &&>()())>
+    : public std::true_type {}; // only true when call expression valid
 
 // Type trait determining whether a no-argument callable returns void
 template <typename T>
 struct returns_void_t
-  : public std::is_same<void, decltype(std::declval<T&&>()())>
-{};
+    : public std::is_same<void, decltype(std::declval<T &&>()())> {};
 
 /* Type trait determining whether a no-arg callable is nothrow invocable if
    required. This is where SG_REQUIRE_NOEXCEPT logic is encapsulated. */
 template <typename T>
 struct is_nothrow_invocable_if_required_t
-  : public
+    : public
 #ifdef SG_REQUIRE_NOEXCEPT
-  std::is_nothrow_invocable<T>         /* Note: _r variants not enough to
-                                          confirm void return: any return can be
-                                          discarded so all returns are
-                                          compatible with void */
+      std::is_nothrow_invocable<T> /* Note: _r variants not enough to
+                                      confirm void return: any return can be
+                                      discarded so all returns are
+                                      compatible with void */
 #else
-  std::true_type
+      std::true_type
 #endif
-{};
+{
+};
 
 // logic AND of two or more type traits
-template <typename A, typename B, typename ... C>
-struct and_t : public and_t<A, and_t<B, C...>>
-{};     // for more than two arguments
+template <typename A, typename B, typename... C>
+struct and_t : public and_t<A, and_t<B, C...>> {
+}; // for more than two arguments
 
 template <typename A, typename B>
-struct and_t<A, B> : public std::conditional<A::value, B, A>::type
-{};     // for two arguments
+struct and_t<A, B> : public std::conditional<A::value, B, A>::type {
+}; // for two arguments
 
 // Type trait determining whether a type is a proper scope_guard callback.
 template <typename T>
 struct is_proper_sg_callback_t
-  : public and_t<is_noarg_callable_t<T>,
-                 returns_void_t<T>,
-                 is_nothrow_invocable_if_required_t<T>,
-                 std::is_nothrow_destructible<T>>
-{};
-
+    : public and_t<is_noarg_callable_t<T>, returns_void_t<T>,
+                   is_nothrow_invocable_if_required_t<T>,
+                   std::is_nothrow_destructible<T>> {};
 
 /* --- The actual scope_guard template --- */
 
 template <typename Callback,
           typename = typename std::enable_if<
-            is_proper_sg_callback_t<Callback>::value>::type>
+              is_proper_sg_callback_t<Callback>::value>::type>
 class scope_guard;
 
-
 /* --- Now the friend maker --- */
 
 template <typename Callback>
-detail::scope_guard<Callback> make_scope_guard(Callback&& callback)
-noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value);     /*
-                                                                             we need this in the inner namespace due to MSVC bugs preventing
-                                                                             sg::detail::scope_guard from befriending a sg::make_scope_guard
-                                                                             template instance in the parent namespace (see https://is.gd/xFfFhE). */
-
+detail::scope_guard<Callback> make_scope_guard(Callback &&callback) noexcept(
+    std::is_nothrow_constructible<Callback, Callback &&>::
+        value); /*
+                   we need this in the inner namespace due to MSVC bugs
+                   preventing sg::detail::scope_guard from befriending a
+                   sg::make_scope_guard template instance in the parent
+                   namespace (see https://is.gd/xFfFhE). */
 
 /* --- The template specialization that actually defines the class --- */
 
-template <typename Callback>
-class SG_NODISCARD scope_guard<Callback> final
-{
+template <typename Callback> class SG_NODISCARD scope_guard<Callback> final {
 public:
   using callback_type = Callback;
 
-  scope_guard(scope_guard&& other)
-  noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value);
+  scope_guard(scope_guard &&other) noexcept(
+      std::is_nothrow_constructible<Callback, Callback &&>::value);
 
-  ~scope_guard() noexcept;     // highlight noexcept dtor
+  ~scope_guard() noexcept; // highlight noexcept dtor
 
   void dismiss() noexcept;
 
 public:
   scope_guard() = delete;
-  scope_guard(const scope_guard&) = delete;
-  scope_guard& operator=(const scope_guard&) = delete;
-  scope_guard& operator=(scope_guard&&) = delete;
+  scope_guard(const scope_guard &) = delete;
+  scope_guard &operator=(const scope_guard &) = delete;
+  scope_guard &operator=(scope_guard &&) = delete;
 
 private:
-  explicit scope_guard(Callback&& callback)
-  noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value);     /*
-                                                                               meant for friends only */
-
-  friend scope_guard<Callback> make_scope_guard<Callback>(Callback&&)
-  noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value);     /*
-                                                                               only make_scope_guard can create scope_guards from scratch (i.e. non-move)
-                                                                             */
+  explicit scope_guard(Callback &&callback) noexcept(
+      std::is_nothrow_constructible<
+          Callback, Callback &&>::value); /*
+                                             meant for friends only */
+
+  friend scope_guard<Callback> make_scope_guard<Callback>(Callback &&) noexcept(
+      std::is_nothrow_constructible<Callback, Callback &&>::
+          value); /*
+                     only make_scope_guard can create scope_guards from scratch
+                     (i.e. non-move)
+                   */
 
 private:
   Callback m_callback;
   bool m_active;
-
 };
 
-}   // namespace detail
-
+} // namespace detail
 
 /* --- Now the single public maker function --- */
 
-using detail::make_scope_guard;   // see comment on declaration above
+using detail::make_scope_guard; // see comment on declaration above
 
 } // namespace sg
 
 ////////////////////////////////////////////////////////////////////////////////
 template <typename Callback>
-sg::detail::scope_guard<Callback>::scope_guard(Callback&& callback)
-noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value)
-  : m_callback(std::forward<Callback>(callback)) /* use () instead of {} because
-                                                    of DR 1467 (https://is.gd/WHmWuo), which still impacts older compilers
-                                                    (e.g. GCC 4.x and clang <=3.6, see https://godbolt.org/g/TE9tPJ and
-                                                    https://is.gd/Tsmh8G) */
-  , m_active{true}
-{}
+sg::detail::scope_guard<Callback>::scope_guard(Callback &&callback) noexcept(
+    std::is_nothrow_constructible<Callback, Callback &&>::value)
+    : m_callback(std::forward<Callback>(
+          callback)) /* use () instead of {} because
+                        of DR 1467 (https://is.gd/WHmWuo), which still impacts
+                        older compilers (e.g. GCC 4.x and clang <=3.6, see
+                        https://godbolt.org/g/TE9tPJ and https://is.gd/Tsmh8G)
+                      */
+      ,
+      m_active{true} {}
 
 ////////////////////////////////////////////////////////////////////////////////
 template <typename Callback>
-sg::detail::scope_guard<Callback>::scope_guard::~scope_guard() noexcept  /*
-                                                                            need the extra injected-class-name here to make different compilers happy */
+sg::detail::scope_guard<Callback>::scope_guard::
+    ~scope_guard() noexcept /*
+                               need the extra injected-class-name here to make
+                               different compilers happy */
 {
-  if (m_active)m_callback();
+  if (m_active)
+    m_callback();
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 template <typename Callback>
-sg::detail::scope_guard<Callback>::scope_guard(scope_guard&& other)
-noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value)
-  : m_callback(std::forward<Callback>(other.m_callback)) // idem
-  , m_active{other.m_active}
-{
+sg::detail::scope_guard<Callback>::scope_guard(scope_guard &&other) noexcept(
+    std::is_nothrow_constructible<Callback, Callback &&>::value)
+    : m_callback(std::forward<Callback>(other.m_callback)) // idem
+      ,
+      m_active{other.m_active} {
   other.m_active = false;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 template <typename Callback>
-inline void sg::detail::scope_guard<Callback>::dismiss() noexcept
-{
+inline void sg::detail::scope_guard<Callback>::dismiss() noexcept {
   m_active = false;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 template <typename Callback>
-inline auto sg::detail::make_scope_guard(Callback&& callback)
-noexcept(std::is_nothrow_constructible<Callback, Callback&&>::value)
--> detail::scope_guard<Callback>
-{
+inline auto sg::detail::make_scope_guard(Callback &&callback) noexcept(
+    std::is_nothrow_constructible<Callback, Callback &&>::value)
+    -> detail::scope_guard<Callback> {
   return detail::scope_guard<Callback>{std::forward<Callback>(callback)};
 }
 
diff --git a/src/utils/svg.cc b/src/utils/svg.cc
index 2531ea2a3..4624220ed 100644
--- a/src/utils/svg.cc
+++ b/src/utils/svg.cc
@@ -18,8 +18,7 @@ namespace OpenSCAD {
 int svg_px_width = SVG_PXW;
 int svg_px_height = SVG_PXH;
 
-std::string svg_header(int widthpx, int heightpx)
-{
+std::string svg_header(int widthpx, int heightpx) {
   std::ostringstream out;
   out << "<svg width='" << widthpx << "px' height='" << heightpx << "px'"
       << " xmlns='http://www.w3.org/2000/svg' version='1.1'>\n";
@@ -28,15 +27,14 @@ std::string svg_header(int widthpx, int heightpx)
   return out.str();
 }
 
-std::string svg_label(const std::string& s)
-{
+std::string svg_label(const std::string &s) {
   std::ostringstream out;
-  out << "   <text fill='black' x='20' y='40' font-size='24'>" << s << "</text>";
+  out << "   <text fill='black' x='20' y='40' font-size='24'>" << s
+      << "</text>";
   return out.str();
 }
 
-std::string svg_styleblock(const std::string& strokewidth)
-{
+std::string svg_styleblock(const std::string &strokewidth) {
   std::ostringstream out;
   // halfedge: f1/f0 = face mark, b1/b0 = body or hole, m1/m0 = halfedge mark
   out << "\
@@ -55,38 +53,35 @@ std::string svg_styleblock(const std::string& strokewidth)
   return tmp;
 }
 
-std::string svg_border()
-{
+std::string svg_border() {
   std::ostringstream out;
   out << " <!-- border -->\n";
-  out << "  <polyline points='0,0 "
-      << svg_px_width << ",0 "
-      << svg_px_width << "," << svg_px_height
-      << " 0," << svg_px_height << "'"
+  out << "  <polyline points='0,0 " << svg_px_width << ",0 " << svg_px_width
+      << "," << svg_px_height << " 0," << svg_px_height << "'"
       << " style='fill:none;stroke:black' />\n";
   out << " <!-- /border -->";
   return out.str();
 }
 
-std::string svg_axes()
-{
+std::string svg_axes() {
   std::ostringstream out;
   out << " <!-- axes -->\n";
-  out << "  <polyline points='10,455 10,475 10,465 18,465 2,465 10,465 14,461 6,469 10,465'"
+  out << "  <polyline points='10,455 10,475 10,465 18,465 2,465 10,465 14,461 "
+         "6,469 10,465'"
       << " style='fill:none;stroke:black;' />\n";
   out << " <!-- /axes -->";
   return out.str();
 }
 
-CGAL_Nef_polyhedron2::Explorer::Point project_svg_3to2(const CGAL_Point_3& p, const CGAL_Iso_cuboid_3& bbox)
-{
+CGAL_Nef_polyhedron2::Explorer::Point
+project_svg_3to2(const CGAL_Point_3 &p, const CGAL_Iso_cuboid_3 &bbox) {
   CGAL_Kernel3::FT screenw(svg_px_width);
   CGAL_Kernel3::FT screenh(svg_px_height);
   CGAL_Kernel3::FT screenxc = screenw / 2;
   CGAL_Kernel3::FT screenyc = screenh / 2;
-  CGAL_Kernel3::FT bboxx = (bbox.xmax() - bbox.xmin() );
-  CGAL_Kernel3::FT bboxy = (bbox.ymax() - bbox.ymin() );
-  CGAL_Kernel3::FT bboxz = (bbox.zmax() - bbox.zmin() );
+  CGAL_Kernel3::FT bboxx = (bbox.xmax() - bbox.xmin());
+  CGAL_Kernel3::FT bboxy = (bbox.ymax() - bbox.ymin());
+  CGAL_Kernel3::FT bboxz = (bbox.zmax() - bbox.zmin());
   CGAL_Kernel3::FT largest_dim = CGAL::max(CGAL::max(bboxx, bboxy), bboxz);
   CGAL_Kernel3::FT bboxxc = bboxx / 2 + bbox.xmin();
   CGAL_Kernel3::FT bboxyc = bboxy / 2 + bbox.ymin();
@@ -95,34 +90,34 @@ CGAL_Nef_polyhedron2::Explorer::Point project_svg_3to2(const CGAL_Point_3& p, co
   CGAL_Kernel3::FT yinbox = (p.y() - bboxyc) / largest_dim;
   CGAL_Kernel3::FT zinbox = (p.z() - bboxzc) / largest_dim;
   // do simple fake parallel projection
-  CGAL_Kernel3::FT tx = screenxc + xinbox * screenw / 1.618 + yinbox * screenh / 3.2;
-  CGAL_Kernel3::FT ty = screenyc - zinbox * screenh / 1.618 - yinbox * screenh / 3.2;
+  CGAL_Kernel3::FT tx =
+      screenxc + xinbox * screenw / 1.618 + yinbox * screenh / 3.2;
+  CGAL_Kernel3::FT ty =
+      screenyc - zinbox * screenh / 1.618 - yinbox * screenh / 3.2;
   return {CGAL::to_double(tx), CGAL::to_double(ty)};
 }
 
-CGAL_Point_2e project_svg_2to2(const CGAL_Point_2e& p, const CGAL_Iso_rectangle_2e& bbox)
-{
+CGAL_Point_2e project_svg_2to2(const CGAL_Point_2e &p,
+                               const CGAL_Iso_rectangle_2e &bbox) {
   double screenw = svg_px_width;
   double screenh = svg_px_height;
   double borderw = screenw * 0.1618;
   double borderh = screenh * 0.1618;
   double vizw = screenw - borderw * 2;
   double vizh = screenh - borderh * 2;
-  double bboxw = CGAL::to_double(bbox.xmax() - bbox.xmin() );
-  double bboxh = CGAL::to_double(bbox.ymax() - bbox.ymin() );
-  double xinbox = CGAL::to_double(p.x() ) - CGAL::to_double(bbox.xmin() );
-  double yinbox = CGAL::to_double(p.y() ) - CGAL::to_double(bbox.ymin() );
-  double tx = borderw + (xinbox / (bboxw == 0?1:bboxw) ) * (vizw);
-  double ty = screenh - borderh - (yinbox / (bboxh == 0?1:bboxh) ) * (vizh);
+  double bboxw = CGAL::to_double(bbox.xmax() - bbox.xmin());
+  double bboxh = CGAL::to_double(bbox.ymax() - bbox.ymin());
+  double xinbox = CGAL::to_double(p.x()) - CGAL::to_double(bbox.xmin());
+  double yinbox = CGAL::to_double(p.y()) - CGAL::to_double(bbox.ymin());
+  double tx = borderw + (xinbox / (bboxw == 0 ? 1 : bboxw)) * (vizw);
+  double ty = screenh - borderh - (yinbox / (bboxh == 0 ? 1 : bboxh)) * (vizh);
   return {tx, ty};
 }
 
 std::string dump_cgal_nef_polyhedron2_face_svg(
-  CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator c1,
-  CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator c2,
-  const CGAL_Nef_polyhedron2::Explorer& explorer,
-  bool facemark, bool body)
-{
+    CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator c1,
+    CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator c2,
+    const CGAL_Nef_polyhedron2::Explorer &explorer, bool facemark, bool body) {
   std::ostringstream style;
   style << "halfedge_f" << facemark << "_b" << body << "_m";
   auto styleclass = style.str();
@@ -130,8 +125,8 @@ std::string dump_cgal_nef_polyhedron2_face_svg(
   std::ostringstream out;
   CGAL_For_all(c1, c2) {
     if (explorer.is_standard(explorer.target(c1))) {
-      auto source = explorer.point(explorer.source(c1) );
-      auto target = explorer.point(explorer.target(c1) );
+      auto source = explorer.point(explorer.source(c1));
+      auto target = explorer.point(explorer.target(c1));
       out << "    <!-- Halfedge. Mark: " << c1->mark() << " -->\n";
       auto he_mark = boost::lexical_cast<std::string>(c1->mark());
       out << "     <line"
@@ -147,20 +142,21 @@ std::string dump_cgal_nef_polyhedron2_face_svg(
   return out.str();
 }
 
-static CGAL_Iso_rectangle_2e bounding_box(const CGAL_Nef_polyhedron2& N)
-{
+static CGAL_Iso_rectangle_2e bounding_box(const CGAL_Nef_polyhedron2 &N) {
   auto explorer = N.explorer();
   std::vector<CGAL_Point_2e> points;
   // can be optimized by rewriting bounding_box to accept vertices
-  for (auto vi = explorer.vertices_begin(); vi != explorer.vertices_end(); ++vi) {
-    if (explorer.is_standard(vi)) points.push_back(explorer.point(vi));
+  for (auto vi = explorer.vertices_begin(); vi != explorer.vertices_end();
+       ++vi) {
+    if (explorer.is_standard(vi))
+      points.push_back(explorer.point(vi));
   }
-  if (points.size() > 0) return CGAL::bounding_box(points.begin(), points.end());
+  if (points.size() > 0)
+    return CGAL::bounding_box(points.begin(), points.end());
   return {0, 0, 0, 0};
 }
 
-std::string dump_svg(const CGAL_Nef_polyhedron2& N)
-{
+std::string dump_svg(const CGAL_Nef_polyhedron2 &N) {
   std::ostringstream out;
   auto explorer = N.explorer();
   auto bbox = bounding_box(N);
@@ -175,13 +171,17 @@ std::string dump_svg(const CGAL_Nef_polyhedron2& N)
     out << "   <!-- body begin -->\n";
     auto c1(explorer.face_cycle(i));
     auto c2(c1);
-    out << dump_cgal_nef_polyhedron2_face_svg(c1, c2, explorer, i->mark(), true);
+    out << dump_cgal_nef_polyhedron2_face_svg(c1, c2, explorer, i->mark(),
+                                              true);
     out << "   <!-- body end -->\n";
 
     for (auto j = explorer.holes_begin(i); j != explorer.holes_end(i); ++j) {
       out << "   <!-- hole begin. mark: " << j->mark() << " -->\n";
-      CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator c3(j), c4(c3);
-      out << dump_cgal_nef_polyhedron2_face_svg(c3, c4, explorer, j->mark(), false);
+      CGAL_Nef_polyhedron2::Explorer::Halfedge_around_face_const_circulator c3(
+          j),
+          c4(c3);
+      out << dump_cgal_nef_polyhedron2_face_svg(c3, c4, explorer, j->mark(),
+                                                false);
       out << "   <!-- hole end -->\n";
     }
     out << "  <!-- face end -->\n";
@@ -192,40 +192,34 @@ std::string dump_svg(const CGAL_Nef_polyhedron2& N)
   return tmp;
 }
 
-std::string point_dump(const CGAL_Point_3& p)
-{
+std::string point_dump(const CGAL_Point_3 &p) {
   std::ostringstream out;
-  out << CGAL::to_double(p.x()) << ","
-      << CGAL::to_double(p.y()) << ","
+  out << CGAL::to_double(p.x()) << "," << CGAL::to_double(p.y()) << ","
       << CGAL::to_double(p.z());
   return out.str();
 }
 
-std::string point_dump(const CGAL::Sphere_point<CGAL_Kernel3>& p)
-{
+std::string point_dump(const CGAL::Sphere_point<CGAL_Kernel3> &p) {
   std::ostringstream out;
-  out << CGAL::to_double(p.x()) << ","
-      << CGAL::to_double(p.y()) << ","
+  out << CGAL::to_double(p.x()) << "," << CGAL::to_double(p.y()) << ","
       << CGAL::to_double(p.z());
   return out.str();
 }
 
-std::string vert_dump(CGAL_Nef_polyhedron3::Vertex_const_handle vch)
-{
-  return point_dump(vch->point() );
+std::string vert_dump(CGAL_Nef_polyhedron3::Vertex_const_handle vch) {
+  return point_dump(vch->point());
 }
 
-std::string vert_dump(CGAL_Nef_polyhedron3::Nef_polyhedron_S2::SVertex_const_handle vch)
-{
-  return point_dump(vch->point() );
+std::string
+vert_dump(CGAL_Nef_polyhedron3::Nef_polyhedron_S2::SVertex_const_handle vch) {
+  return point_dump(vch->point());
 }
 
 /*
    Dump the 'sphere map' of every vertex in a CGAL Nef Polyhedron3
    see http://doc.cgal.org/latest/Nef_3/index.html
  */
-std::string sphere_map_dump(const CGAL_Nef_polyhedron3& N)
-{
+std::string sphere_map_dump(const CGAL_Nef_polyhedron3 &N) {
   std::ostringstream out;
   using Vertex_const_iterator = CGAL_Nef_polyhedron3::Vertex_const_iterator;
   using Nef_polyhedron_S2 = CGAL_Nef_polyhedron3::Nef_polyhedron_S2;
@@ -233,13 +227,15 @@ std::string sphere_map_dump(const CGAL_Nef_polyhedron3& N)
   using SHalfedge_const_handle = Nef_polyhedron_S2::SHalfedge_const_handle;
   using SHalfloop_const_handle = Nef_polyhedron_S2::SHalfloop_const_handle;
   using SFace_const_iterator = Nef_polyhedron_S2::SFace_const_iterator;
-  using SFace_cycle_const_iterator = Nef_polyhedron_S2::SFace_cycle_const_iterator;
+  using SFace_cycle_const_iterator =
+      Nef_polyhedron_S2::SFace_cycle_const_iterator;
   Vertex_const_iterator v;
   out << "<!-- sphere map begin -->\n";
   int counter = 0;
   for (v = N.vertices_begin(); v != N.vertices_end(); ++v) {
     counter++;
-    out << "<!-- vertex sphere map begin. vertex counter is " << counter << "\n";
+    out << "<!-- vertex sphere map begin. vertex counter is " << counter
+        << "\n";
     out << "     vertex coordinates: " << vert_dump(v) << "-->\n";
     Nef_polyhedron_S2 S(N.get_sphere_map(v));
 
@@ -248,26 +244,31 @@ std::string sphere_map_dump(const CGAL_Nef_polyhedron3& N)
     out << "  number of shalfedges: " << S.number_of_shalfedges() << std::endl;
     out << "  number of shalfloops: " << S.number_of_shalfloops() << std::endl;
     out << "  number of sfaces: " << S.number_of_sfaces() << std::endl;
-    out << "  number of sface cycles: " << S.number_of_sface_cycles() << std::endl;
-    out << "  connected_components: " << S.number_of_connected_components() << "\n";
+    out << "  number of sface cycles: " << S.number_of_sface_cycles()
+        << std::endl;
+    out << "  connected_components: " << S.number_of_connected_components()
+        << "\n";
     out << "  integrity check...(asserts if not OK)\n";
     S.check_integrity_and_topological_planarity();
-// S.print_statistics( out );
+    // S.print_statistics( out );
     int i = 0;
     SFace_const_iterator sf;
     for (sf = S.sfaces_begin(); sf != S.sfaces_end(); ++sf) {
       SFace_cycle_const_iterator it;
       out << " the sface cycles of sface " << i++ << " start with an\n";
       for (it = sf->sface_cycles_begin(); it != sf->sface_cycles_end(); ++it) {
-        if (it.is_svertex()) out << "  svertex at position "
-                                 << vert_dump(SVertex_const_handle(it) ) << "\n";
+        if (it.is_svertex())
+          out << "  svertex at position " << vert_dump(SVertex_const_handle(it))
+              << "\n";
         else if (it.is_shalfedge())
           out << "  shalfedge from "
-              << vert_dump(SHalfedge_const_handle(it)->source() ) << " to "
-              << vert_dump(SHalfedge_const_handle(it)->target() ) << std::endl;
-        else if (it.is_shalfloop()) out << "  shalfloop lying in the plane "
-                                        << SHalfloop_const_handle(it)->circle() << std::endl;
-        else out << "  unknown bug\n";
+              << vert_dump(SHalfedge_const_handle(it)->source()) << " to "
+              << vert_dump(SHalfedge_const_handle(it)->target()) << std::endl;
+        else if (it.is_shalfloop())
+          out << "  shalfloop lying in the plane "
+              << SHalfloop_const_handle(it)->circle() << std::endl;
+        else
+          out << "  unknown bug\n";
       }
     }
     out << "\n  vertex sphere map end -->\n";
@@ -276,44 +277,38 @@ std::string sphere_map_dump(const CGAL_Nef_polyhedron3& N)
   return out.str();
 }
 
-// This uses the Shell Explorer pattern from the CGAL Manual to dump the 3d Nef Polyhedron information
+// This uses the Shell Explorer pattern from the CGAL Manual to dump the 3d Nef
+// Polyhedron information
 // http://www.cgal.org/Manual/latest/doc_html/cgal_manual/Nef_3/Chapter_main.html#Subsection_29.7.2
-class NefPoly3_dumper_svg
-{
+class NefPoly3_dumper_svg {
 public:
   std::ostringstream out;
   CGAL_Iso_cuboid_3 bbox;
-  NefPoly3_dumper_svg(const CGAL_Nef_polyhedron3& N)
-  {
+  NefPoly3_dumper_svg(const CGAL_Nef_polyhedron3 &N) {
     bbox = CGALUtils::boundingBox(N);
   }
-  void visit(CGAL_Nef_polyhedron3::Vertex_const_handle vch)
-  {
+  void visit(CGAL_Nef_polyhedron3::Vertex_const_handle vch) {
     auto p = vch->point();
     out << "     <!-- vertex " << point_dump(p) << " -->\n";
   }
-  void visit(CGAL_Nef_polyhedron3::Halfedge_const_handle)
-  {
+  void visit(CGAL_Nef_polyhedron3::Halfedge_const_handle) {
     out << "  <!-- halfedge --> \n";
   }
-  void visit(CGAL_Nef_polyhedron3::SHalfedge_const_handle)
-  {
+  void visit(CGAL_Nef_polyhedron3::SHalfedge_const_handle) {
     out << "  <!-- shalfedge --> \n";
   }
-  void visit(CGAL_Nef_polyhedron3::SHalfloop_const_handle)
-  {
+  void visit(CGAL_Nef_polyhedron3::SHalfloop_const_handle) {
     out << "  <!-- shalfloop --> \n";
   }
-  void visit(CGAL_Nef_polyhedron3::SFace_const_handle)
-  {
+  void visit(CGAL_Nef_polyhedron3::SFace_const_handle) {
     out << "  <!-- sface --> \n";
   }
-  void visit(CGAL_Nef_polyhedron3::Halffacet_const_handle hfacet)
-  {
+  void visit(CGAL_Nef_polyhedron3::Halffacet_const_handle hfacet) {
     int contour_count = 0;
     out << "  <!-- Halffacet visit. Mark: " << (*hfacet).mark() << " -->\n";
     std::string color = "gold";
-    if (!(*hfacet).mark()) color = "green";
+    if (!(*hfacet).mark())
+      color = "green";
     CGAL_Nef_polyhedron3::Halffacet_cycle_const_iterator i;
     CGAL_forall_facet_cycles_of(i, hfacet) {
       CGAL_Nef_polyhedron3::SHalfloop_const_handle shl_handle;
@@ -323,24 +318,28 @@ public:
       } else {
         out << "    <!-- Hole contour:--> \n";
       }
-      CGAL_Nef_polyhedron3::SHalfedge_around_facet_const_circulator c1(i), c2(c1);
+      CGAL_Nef_polyhedron3::SHalfedge_around_facet_const_circulator c1(i),
+          c2(c1);
       CGAL_For_all(c1, c2) {
-        // don't know why we use source()->source(), except that's what CGAL does internally
+        // don't know why we use source()->source(), except that's what CGAL
+        // does internally
         auto source = c1->source()->source()->point();
         auto target = c1->source()->target()->point();
         auto tp1 = project_svg_3to2(source, bbox);
         auto tp2 = project_svg_3to2(target, bbox);
         out << "     <!-- " << CGAL::to_double(source.x()) << ","
-            << CGAL::to_double(source.y()) << ","
-            << CGAL::to_double(source.z()) << " -->\n";
+            << CGAL::to_double(source.y()) << "," << CGAL::to_double(source.z())
+            << " -->\n";
         out << "     <line "
             << "x1='" << CGAL::to_double(tp1.x()) << "' "
             << "y1='" << CGAL::to_double(tp1.y()) << "' "
             << "x2='" << CGAL::to_double(tp2.x()) << "' "
             << "y2='" << CGAL::to_double(tp2.y()) << "' "
             << " stroke='" << color << "'";
-        if (!(*hfacet).mark()) out << " stroke-dasharray='4 4' />\n";
-        else out << " />\n";
+        if (!(*hfacet).mark())
+          out << " stroke-dasharray='4 4' />\n";
+        else
+          out << " />\n";
       }
       contour_count++;
       out << "   <!-- Halffacet cycle end -->\n";
@@ -349,9 +348,7 @@ public:
   }
 };
 
-
-std::string dump_svg(const CGAL_Nef_polyhedron3& N)
-{
+std::string dump_svg(const CGAL_Nef_polyhedron3 &N) {
   std::ostringstream out;
   std::string linewidth = "0.05";
   out << "<!--CGAL_Nef_polyhedron3 dump begin-->\n";
@@ -362,10 +359,9 @@ std::string dump_svg(const CGAL_Nef_polyhedron3& N)
       << "\nnumber of halfedges " << N.number_of_halfedges()
       << "\nnumber of edges " << N.number_of_edges()
       << "\nnumber of halffacets " << N.number_of_halffacets()
-      << "\nnumber of facets " << N.number_of_facets()
-      << "\nnumber of volumes " << N.number_of_volumes()
-      << "\nis_simple()? " << N.is_simple()
-      << "\nis_valid()? " << (const_cast<CGAL_Nef_polyhedron3&>(N)).is_valid()
+      << "\nnumber of facets " << N.number_of_facets() << "\nnumber of volumes "
+      << N.number_of_volumes() << "\nis_simple()? " << N.is_simple()
+      << "\nis_valid()? " << (const_cast<CGAL_Nef_polyhedron3 &>(N)).is_valid()
       << "\n -->\n";
   out << "<!-- CGAL Nef Polyhedron sphere map: -->\n";
   out << sphere_map_dump(N);
@@ -378,7 +374,8 @@ std::string dump_svg(const CGAL_Nef_polyhedron3& N)
     CGAL_forall_shells_of(it, c) {
       out << "  <!--Shell begin-->\n";
       NefPoly3_dumper_svg dumper_svg(N);
-      N.visit_shell_objects(CGAL_Nef_polyhedron3::SFace_const_handle(it), dumper_svg);
+      N.visit_shell_objects(CGAL_Nef_polyhedron3::SFace_const_handle(it),
+                            dumper_svg);
       out << dumper_svg.out.str();
       out << "  <!--Shell end-->\n";
     }
@@ -391,6 +388,6 @@ std::string dump_svg(const CGAL_Nef_polyhedron3& N)
   return tmp;
 }
 
-} // namespace
+} // namespace OpenSCAD
 
 #endif // ENABLE_CGAL
diff --git a/src/utils/svg.h b/src/utils/svg.h
index 62ae893dd..2d572a5ed 100644
--- a/src/utils/svg.h
+++ b/src/utils/svg.h
@@ -17,10 +17,10 @@ extern int svg_px_width;
 extern int svg_px_height;
 
 std::string svg_header(int widthpx = SVG_PXW, int heightpx = SVG_PXH);
-std::string svg_label(const std::string& s);
+std::string svg_label(const std::string &s);
 std::string svg_border();
 std::string svg_axes();
-std::string dump_svg(const CGAL_Nef_polyhedron2& N);
-std::string dump_svg(const CGAL_Nef_polyhedron3& N);
+std::string dump_svg(const CGAL_Nef_polyhedron2 &N);
+std::string dump_svg(const CGAL_Nef_polyhedron3 &N);
 
-} // namespace
+} // namespace OpenSCAD
diff --git a/src/utils/version_check.h b/src/utils/version_check.h
index eff3cf315..f85ba0e38 100644
--- a/src/utils/version_check.h
+++ b/src/utils/version_check.h
@@ -24,40 +24,37 @@
 #define GMPMAJOR 5
 #define GMPMINOR 0
 #define GMPPATCH 0
-#define SYS_GMP_VER  (__GNU_MP_VERSION * 10000 + __GNU_MP_VERSION_MINOR * 100 + __GNU_MP_VERSION_PATCHLEVEL * 1)
+#define SYS_GMP_VER                                                            \
+  (__GNU_MP_VERSION * 10000 + __GNU_MP_VERSION_MINOR * 100 +                   \
+   __GNU_MP_VERSION_PATCHLEVEL * 1)
 #if SYS_GMP_VER < GMPMAJOR * 10000 + GMPMINOR * 100 + GMPPATCH * 1
 #error GNU GMP library missing or version too old. See README.md. To force compile, run qmake CONFIG+=skip-version-check
 #else
 
-
 #include <mpfr.h>
 #if MPFR_VERSION < MPFR_VERSION_NUM(3, 0, 0)
 #error GNU MPFR library missing or version too old. See README.md. To force compile, run qmake CONFIG+=skip-version-check
 #else
 
-
 #include <Eigen/Core>
 #if !EIGEN_VERSION_AT_LEAST(3, 0, 0)
 #error eigen library missing or version too old. See README.md. To force compile, run qmake CONFIG+=skip-version-check
 #else
 
-
 #include <boost/version.hpp>
 // boost 1.55 = 105500
 #if BOOST_VERSION < 105500
 #error boost library missing or version too old. See README.md. To force compile, run qmake CONFIG+=skip-version-check
 #else
 
-
 #ifdef ENABLE_CGAL
 #include <CGAL/version.h>
 
 #if CGAL_VERSION_NR < 1040900000
 #error CGAL library missing or version too old. See README.md. To force compile, run qmake CONFIG+=skip-version-check
-#endif //ENABLE_CGAL
+#endif // ENABLE_CGAL
 #else
 
-
 #if defined(ENABLE_OPENCSG) && defined(OPENCSG_GLEW)
 #include <GL/glew.h>
 // kludge - GLEW doesn't have compiler-accessible version numbering
@@ -65,7 +62,6 @@
 #error GLEW library missing or version too old. See README.md. To force compile, run qmake CONFIG+=skip-version-check
 #else
 
-
 #include <opencsg.h>
 // 1.4.2 -> 0x0142
 #if OPENCSG_VERSION < 0x0142
@@ -73,7 +69,6 @@
 #else
 #endif // ENABLE_OPENCSG
 
-
 #ifndef OPENSCAD_NOGUI
 #include <QtCore/qglobal.h>
 #if QT_VERSION < QT_VERSION_CHECK(5, 12, 0)
@@ -81,7 +76,6 @@
 #endif // QT
 #endif
 
-
 #ifdef ENABLE_OPENCSG
 #endif // OpenCSG
 #endif // GLEW
@@ -97,9 +91,8 @@
 #endif // GMP
 
 // see github issue #552
-#define GCC_VERSION (__GNUC__ * 10000 \
-                     + __GNUC_MINOR__ * 100 \
-                     + __GNUC_PATCHLEVEL__)
+#define GCC_VERSION                                                            \
+  (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)
 #if GCC_VERSION == 40802
 #warning "gcc 4.8.2 contains a bug causing a crash in CGAL."
 #endif
diff --git a/src/utils/version_helper.h b/src/utils/version_helper.h
index f578b4f6b..28ba09037 100644
--- a/src/utils/version_helper.h
+++ b/src/utils/version_helper.h
@@ -5,34 +5,39 @@
 
 namespace OpenSCAD {
 
-struct library_version_number
-{
+struct library_version_number {
   const unsigned int major;
   const unsigned int minor;
   const unsigned int micro;
 };
 
-const auto get_version_string = [](const library_version_number& header_version, const library_version_number& runtime_version)
-  {
-    std::ostringstream version_stream;
-
-    version_stream << header_version.major << '.' << header_version.minor << '.' << header_version.micro;
-    const bool match = (header_version.major == runtime_version.major && header_version.minor == runtime_version.minor && header_version.micro == runtime_version.micro);
-    if (!match) {
-      version_stream << " (runtime: " << runtime_version.major << '.' << runtime_version.minor << '.' << runtime_version.micro << ')';
-    }
-    return version_stream.str();
-  };
-
-const auto get_version = [](const std::string& header_version, const std::string& runtime_version)
-  {
-    std::ostringstream version_stream;
-
-    version_stream << header_version;
-    if (header_version != runtime_version) {
-      version_stream << " (runtime: " << runtime_version << ')';
-    }
-    return version_stream.str();
-  };
+const auto get_version_string =
+    [](const library_version_number &header_version,
+       const library_version_number &runtime_version) {
+      std::ostringstream version_stream;
+
+      version_stream << header_version.major << '.' << header_version.minor
+                     << '.' << header_version.micro;
+      const bool match = (header_version.major == runtime_version.major &&
+                          header_version.minor == runtime_version.minor &&
+                          header_version.micro == runtime_version.micro);
+      if (!match) {
+        version_stream << " (runtime: " << runtime_version.major << '.'
+                       << runtime_version.minor << '.' << runtime_version.micro
+                       << ')';
+      }
+      return version_stream.str();
+    };
+
+const auto get_version = [](const std::string &header_version,
+                            const std::string &runtime_version) {
+  std::ostringstream version_stream;
+
+  version_stream << header_version;
+  if (header_version != runtime_version) {
+    version_stream << " (runtime: " << runtime_version << ')';
+  }
+  return version_stream.str();
+};
 
 } // namespace OpenSCAD
diff --git a/src/version.cc b/src/version.cc
index cc27518a5..fb14974d1 100644
--- a/src/version.cc
+++ b/src/version.cc
@@ -28,7 +28,7 @@
 
 #include <string>
 
-#define QUOTE(x__) # x__
+#define QUOTE(x__) #x__
 #define QUOTED(x__) QUOTE(x__)
 
 std::string openscad_shortversionnumber = QUOTED(OPENSCAD_SHORTVERSION);
@@ -36,15 +36,14 @@ std::string openscad_versionnumber = QUOTED(OPENSCAD_VERSION);
 
 std::string openscad_displayversionnumber =
 #ifdef OPENSCAD_COMMIT
-  QUOTED(OPENSCAD_VERSION)
-  " (git " QUOTED(OPENSCAD_COMMIT) ")";
+    QUOTED(OPENSCAD_VERSION) " (git " QUOTED(OPENSCAD_COMMIT) ")";
 #else
-  QUOTED(OPENSCAD_SHORTVERSION);
+    QUOTED(OPENSCAD_SHORTVERSION);
 #endif
 
 std::string openscad_detailedversionnumber =
 #ifdef OPENSCAD_COMMIT
-  openscad_displayversionnumber;
+    openscad_displayversionnumber;
 #else
-  openscad_versionnumber;
+    openscad_versionnumber;
 #endif
